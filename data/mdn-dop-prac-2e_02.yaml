- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Source Code Management with Git and GitOps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 和 GitOps 进行源代码管理
- en: In the previous chapter, we looked at the core concepts of modern DevOps, had
    an introduction to the cloud, and got a fair understanding of containers. In this
    chapter, we will understand source code management and one of the modern ways
    of enabling DevOps with **GitOps**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了现代 DevOps 的核心概念，简要介绍了云计算，并对容器有了基本了解。在本章中，我们将了解源代码管理以及启用 DevOps 的现代方法之一——**GitOps**。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: What is source code management?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是源代码管理？
- en: A crash course on Git
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 快速入门
- en: What is GitOps?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 GitOps？
- en: The principles of GitOps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps 的原则
- en: Why GitOps?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 GitOps？
- en: Branching strategies and GitOps workflow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支策略和 GitOps 工作流
- en: Git versus GitOps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 与 GitOps
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow this chapter, you will need access to a Linux-based command line.
    If you are using macOS, you can use the inbuilt Terminal for all tasks. If you’re
    a Windows user, you must install **GitBash** from [https://git-scm.com/download/win](https://git-scm.com/download/win).
    We will cover the installation instructions for this in the following sections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，您需要访问基于 Linux 的命令行。如果您使用 macOS，可以使用内建的终端完成所有任务。如果您是 Windows 用户，则必须从[https://git-scm.com/download/win](https://git-scm.com/download/win)安装**GitBash**。我们将在接下来的章节中介绍安装说明。
- en: Now, let’s start by understanding source code management.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从了解源代码管理开始。
- en: What is source code management?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是源代码管理？
- en: Software development involves writing code. Code is the only tangible aspect
    of the software, allowing the software to function. Therefore, you need to store
    code somewhere to write and make changes to existing software. There are two kinds
    of code – **source code**, which is written in a high-level language, and **binaries**,
    which are compiled from the source code. Generally, binaries are nothing but functional
    applications that execute when we run the software, and source code is the human-readable
    code written to generate the binary, which is why source code is named as such.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发涉及编写代码。代码是软件的唯一有形部分，它使软件能够运行。因此，您需要将代码存储在某个地方，以便编写和修改现有软件。代码有两种类型——**源代码**，它是用高级语言编写的，以及**二进制文件**，它是从源代码编译而来的。通常，二进制文件只不过是执行软件时运行的功能性应用，而源代码是为了生成二进制文件而编写的人类可读的代码，这也是为什么源代码被称为源代码的原因。
- en: A software development team has multiple members writing software features,
    so they must collaborate on code. They cannot just write code on silos without
    understanding how the application works. Sometimes, more than one developer works
    on the same feature, so they need some place to share their code with their peers.
    Source code is an asset in itself; therefore, we want to store it securely in
    a central location while still readily providing access to developers without
    hampering their work. You will also want to track changes and version them as
    you might want to know what caused a problem and immediately roll them back. You
    will also need to persist the history of code to understand what changes were
    made by whom, and you will want to have a mechanism for source code peer reviews.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个软件开发团队有多个成员在编写软件功能，因此他们必须在代码上进行协作。他们不能单独编写代码而不理解应用程序如何工作。有时，多个开发人员会共同开发同一个功能，因此他们需要一个地方来与同伴共享代码。源代码本身是一种资产；因此，我们希望将其安全地存储在中央位置，同时仍然能够便捷地为开发人员提供访问权限，而不妨碍他们的工作。您还需要跟踪更改并对其进行版本控制，因为您可能想知道是什么导致了问题，并能够立即回滚。您还需要保存代码的历史记录，以便了解哪些更改是由谁进行的，并且您还希望有一个源代码同行评审的机制。
- en: As you can see, you would want to manage multiple aspects of source code, and
    therefore you would use a source code management tool to do so.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可能希望管理源代码的多个方面，因此您将使用源代码管理工具来实现这一目标。
- en: A source code management tool helps you manage all aspects of source code. It
    provides a central location to store your code, version changes and allows multiple
    developers to collaborate on the same source code. It also keeps a record of all
    changes through a version history and everything else that we’ve talked about
    before. Effective source code management practices improve collaboration; enable
    efficient development workflows; provide version control, repository management,
    branching and merging, change tracking, and auditing; and enhance the overall
    quality and maintainability of software projects. Some popular SCM tools are **Git**,
    **Subversion**, **Mercurial**, and **CVS**. However, the most popular and de facto
    standard for SCM is Git. So, let's go ahead and learn about it in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理工具帮助您管理源代码的各个方面。它提供一个集中位置来存储代码、版本更改，并允许多个开发者在相同的源代码上进行协作。它还通过版本历史记录保存所有的更改，以及我们之前提到的其他内容。有效的源代码管理实践能够提高协作效率；促进开发工作流的高效性；提供版本控制、仓库管理、分支和合并、变更跟踪、审计等功能；并提高软件项目的整体质量和可维护性。一些流行的
    SCM 工具有 **Git**、**Subversion**、**Mercurial** 和 **CVS**。然而，最流行且事实上的 SCM 标准是 Git。所以，接下来我们来学习它。
- en: A crash course on Git
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 快速入门
- en: Git is the most popular source code management system available these days,
    and it has now become mandatory for all developers to learn Git, at least the
    basic stuff. In this crash course, we will learn about all basic Git operations
    and build from them in the subsequent chapters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是目前最流行的源代码管理系统，现如今所有开发者都必须学习 Git，至少要掌握基础内容。在本次快速入门中，我们将学习所有基本的 Git 操作，并在后续章节中进行拓展。
- en: Git is a distributed version control system. This means that every Git repository
    is a copy of the original, and you can replicate that to a remote location if
    needed. In this chapter, we will create and initialize a local Git repository
    and then push the entire repository to a remote location.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一个分布式版本控制系统。这意味着每个 Git 仓库都是原始仓库的副本，您可以在需要时将其复制到远程位置。在本章中，我们将创建并初始化一个本地
    Git 仓库，然后将整个仓库推送到远程位置。
- en: 'A Git repository in a remote central location is also known as a **remote repository**.
    From this central repository, all developers sync changes in their local repository,
    similar to what’s shown in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在远程中央位置的 Git 仓库也被称为 **远程仓库**。在这个中央仓库中，所有开发者将本地仓库的更改同步到远程仓库，类似于下图所示：
- en: '![Figure 2.1 – Git distributed repository model](img/B19877_Figure_2.01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Git 分布式仓库模型](img/B19877_Figure_2.01.jpg)'
- en: Figure 2.1 – Git distributed repository model
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Git 分布式仓库模型
- en: First, let’s install Git locally and initialize a local repository. We will
    look at a remote repository later.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在本地安装 Git 并初始化一个本地仓库。稍后我们将查看远程仓库。
- en: Installing Git
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Git
- en: 'Depending on your platform and workstation, there are different ways to install
    Git. To install Git on **Ubuntu**, run the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的平台和工作站的不同，安装 Git 的方式也不同。在 **Ubuntu** 上安装 Git，请运行以下命令：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For other OSs and platforms, you can follow the steps at the following link:
    https://git-scm.com/book/en/v2/Getting-Started-Installing-Git.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他操作系统和平台，您可以按照以下链接中的步骤操作：https://git-scm.com/book/en/v2/Getting-Started-Installing-Git。
- en: 'To check if Git has been installed successfully, run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 Git 是否安装成功，请运行以下命令：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let’s initialize our first Git repository.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们初始化第一个 Git 仓库。
- en: Initializing your first Git repository
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化您的第一个 Git 仓库
- en: 'To create a Git repository, you need to create a directory and run the `git
    init` command, as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Git 仓库，您需要创建一个目录并运行 `git init` 命令，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You are now ready to use your Git repository. You can also see that when you
    initialized the Git repository, Git created a hidden directory, `.git`, which
    it uses to keep track of all changes and commits. Whatever changes you make in
    your repo, Git keeps them as a delta of changes, which it depicts using `+` and
    `-` signs. We will look at these in detail in the subsequent sections. For now,
    let’s create a new file within our Git repository and stage it for changes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用您的 Git 仓库了。您还可以看到，当您初始化 Git 仓库时，Git 创建了一个隐藏目录 `.git`，用于跟踪所有的更改和提交。您在仓库中所做的任何更改，Git
    都会将它们作为差异（delta）记录，使用 `+` 和 `-` 符号表示。我们将在后续部分详细探讨这些内容。现在，让我们在 Git 仓库中创建一个新文件并暂存更改。
- en: Staging code changes
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂存代码更改
- en: Git allows developers to stage their changes before they commit them. This helps
    you prepare what you want to commit to the repository. The staging area is a temporary
    holding area for your changes, and you can add and remove files from the staging
    area by using the `git add` and `git` `restore` commands.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Git允许开发者在提交之前暂存他们的更改。这有助于你准备好提交到仓库的内容。暂存区是你更改的临时存放区，你可以通过使用`git add`和`git restore`命令将文件添加或移除出暂存区。
- en: 'Let’s create our first file within the local Git repository and stage the changes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本地Git仓库中创建第一个文件并暂存更改：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, you can create a blank file in the `first-git-repo` directory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以在`first-git-repo`目录中创建一个空白文件。
- en: 'Now, we will check if Git can detect the new file that we’ve created. To do
    so, we need to run the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查Git是否能检测到我们创建的新增文件。为此，我们需要运行以下命令：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, as we can see, Git has detected `file1` and is telling us that it is not
    tracking the file currently. To allow Git to track the file, let’s run the following
    command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如我们所见，Git已经检测到`file1`并告诉我们它目前没有跟踪该文件。为了让Git跟踪该文件，让我们运行以下命令：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s run `git status` again to see what has changed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行`git status`来查看有哪些更改：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see, Git now shows `file1` as a new file in the staging area. You
    can continue making changes, and when you are done, you can commit the changes
    using the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Git现在显示`file1`作为暂存区中的新文件。你可以继续进行更改，当你完成后，可以使用以下命令提交这些更改：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Git has now recorded a commit with your changes. Now, let’s look at its status
    again using the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Git现在已记录了一个包含你更改的提交。现在，让我们再次使用以下命令查看它的状态：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Git is now reporting that the working tree is clean, and there is nothing to
    commit. It also shows that there are no untracked files. Now, let’s change `file1`
    and add some text to it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Git现在报告工作树是干净的，没有任何需要提交的内容。它还显示没有未跟踪的文件。现在，让我们修改`file1`并在其中添加一些文本：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`file1` now contains the first line. Let’s go ahead and commit this change:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`file1`现在包含了第一行。让我们继续提交这个更改：'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, Git is now reporting that one file has changed, and there is
    one insertion. Remember when we discussed that Git only tracks the delta changes
    between commits? That is what is happening here.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Git现在报告有一个文件已更改，并且有一处插入。记得我们讨论过Git只追踪提交之间的增量更改吗？这就是发生的情况。
- en: In the introduction, we mentioned that Git provides a history of all commits.
    Let’s look at how we can display this history.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍中，我们提到Git提供了所有提交的历史记录。让我们看看如何显示这个历史记录。
- en: Displaying commit history
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示提交历史
- en: 'Git keeps a history of all commits. To see a list of all commits that you’ve
    done, you can use the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Git保留了所有提交的历史记录。要查看你所做的所有提交列表，可以使用以下命令：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can see, Git has displayed the history of both our commits. Notice that
    Git marks every commit with a commit ID. We can also delve into what changes were
    made in the commit by using the `git diff <first_commit_id> <second_commit_id>`
    command, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Git已显示了我们两个提交的历史记录。注意，Git为每个提交标记了一个提交ID。我们还可以通过使用`git diff <first_commit_id>
    <second_commit_id>`命令来深入查看在提交中进行了哪些更改，具体如下：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output clearly shows that the second commit has added `This is first line`
    within `file1`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示，第二次提交已将`This is first line`添加到`file1`中。
- en: You’ve suddenly realized that you needed to add another line to `file1` and
    wanted to do so in the same commit. We can do this by amending the commit. We’ll
    look at this in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你突然意识到需要在`file1`中再添加一行，并希望将其与同一提交一起完成。我们可以通过修改提交来做到这一点。我们将在下一节中讨论这个问题。
- en: Amending the last commit
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改上一次提交
- en: It is a best practice to have a single commit for your changes to a particular
    feature. This helps you track the changes better and makes it easier for the reviewer
    to review them. In turn, it is cleaner to visualize and manage. However, committing
    frequently is also a best practice so that your changes are not lost. Fortunately,
    Git allows you to add changes to the last commit.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是为某个特定功能的更改创建单独的提交。这有助于你更好地追踪更改，并使审阅者更容易进行审查。反过来，这也使得可视化和管理更清晰。然而，频繁提交也是最佳实践，以确保你的更改不会丢失。幸运的是，Git允许你向上一次提交中添加更改。
- en: 'To demonstrate this, let’s change `file1` and add another line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们修改`file1`并添加另一行：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s add the changes to the previous commit using the following commands:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令将更改添加到之前的提交中：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you run this command, Git will show you a prompt, allowing you to amend
    the commit message if you like. It will look something like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行这个命令，Git 会显示一个提示，允许你修改提交信息（如果需要的话）。它将类似于以下内容：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save this file (use `ESC:wq` for Vim). This should amend the last commit with
    the changes. You should get the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件（使用 `ESC:wq` 保存退出 Vim）。这将修改最后一次提交并包含更改。你应该会看到以下输出：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When Git amends a commit, you can no longer refer to the previous commit with
    the same commit ID. Instead, Git generates a separate `SHA-1 id` for the amended
    commit. So, let’s look at the logs to see this for ourselves:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Git 修改提交时，你将无法再使用相同的提交 ID 引用之前的提交。相反，Git 会为修改后的提交生成一个单独的`SHA-1 id`。所以，让我们查看日志，亲自看看这个变化：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s run the `diff` command again and see what it is reporting:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行 `diff` 命令，看看它报告了什么：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output clearly shows that the second commit has added `This is first line`,
    as well as `This is second line`, within `file1`. With that, you’ve successfully
    amended a commit.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示，第二次提交在 `file1` 中添加了 `This is first line` 和 `This is second line`。这样，你就成功修改了提交。
- en: Local repositories are as good as keeping files on your system. However, since
    you need to share your code with others and keep it secure from laptop OS crashes,
    theft, physical damage, and more, you need to push your code into a remote repository.
    We’ll look at remote repositories in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本地仓库的作用就像是在系统上保存文件。然而，既然你需要与他人共享代码，并防止因笔记本操作系统崩溃、盗窃、物理损坏等原因造成的安全隐患，你需要将代码推送到远程仓库。我们将在下一节讨论远程仓库。
- en: Understanding remote repositories
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解远程仓库
- en: '**Remote repositories** are replicas of the Git repository at a central location
    for multiple people to access. This allows your developers to work on the same
    code base simultaneously and provides you with a backup of your code. There are
    various tools you can use to host your remote repositories. Notable ones include
    **GitHub**, **Bitbucket**, and **Gerrit**. You can install them on your on-premises
    or cloud servers or use a **Software-as-a-Service** (**SaaS**) platform to store
    them online. In this book, we are going to focus on GitHub.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程仓库**是 Git 仓库在中央位置的副本，供多人访问。这样，开发者可以同时在同一个代码库上工作，并且为你的代码提供了备份。你可以使用各种工具来托管远程仓库。著名的包括**GitHub**、**Bitbucket**
    和 **Gerrit**。你可以将它们安装在本地服务器或云服务器上，或者使用**软件即服务**（**SaaS**）平台在线存储它们。本书将重点讲解 GitHub。'
- en: GitHub is a web-based platform that helps developers collaborate on code. It
    is based on Git and allows you to host remote Git repositories. It was founded
    in 2008 and was acquired by Microsoft in 2018\. It is one of the most popular
    open-source SaaS-based Git repository services and contains almost all open-source
    code available worldwide.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 是一个基于 web 的平台，帮助开发者进行代码协作。它基于 Git，并允许你托管远程 Git 仓库。GitHub 成立于 2008 年，并在
    2018 年被微软收购。它是最受欢迎的开源 SaaS Git 仓库服务之一，包含了几乎所有全球可用的开源代码。
- en: Before we can create our first remote repo, we must go to [https://github.com/signup](https://github.com/signup)
    to create an account.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建第一个远程仓库之前，我们必须访问 [https://github.com/signup](https://github.com/signup) 创建一个账户。
- en: Once you’ve created an account, we can go ahead and create our first remote
    Git repository.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完账户后，我们可以继续创建第一个远程 Git 仓库。
- en: Creating a remote Git repository
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建远程 Git 仓库
- en: Creating a remote Git repository is simple on GitHub. Go to [https://github.com/new](https://github.com/new),
    set `first-git-repo`, keep the rest of the fields as-is, and click the **Create**
    **Repository** button.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 上创建远程 Git 仓库非常简单。访问 [https://github.com/new](https://github.com/new)，设置
    `first-git-repo`，其他字段保持默认，然后点击 **创建** **仓库** 按钮。
- en: Once you’ve done that, GitHub will provide you with some steps that you can
    follow to connect with your remote repository. Before we go into any of that,
    we want to configure some authentication for our local Git command line to interact
    with the remote repository. Let’s take a look.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，GitHub 会为你提供一些步骤，指导你如何连接到远程仓库。在我们深入这些步骤之前，我们需要为本地 Git 命令行配置一些身份验证，以便与远程仓库交互。让我们来看看。
- en: Setting up authentication with the remote Git repository
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置远程 Git 仓库的身份验证
- en: 'Some of the ways you can authenticate with your remote Git repository are as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下几种方式与远程 Git 仓库进行身份验证：
- en: '**HTTPS**: In this mode, Git uses HTTPS to connect with the remote Git repository.
    We need to create an HTTPS token within our GitHub account and use this token
    as a password to authenticate with the remote repository. This process requires
    you to key in your token every time you authenticate with Git; therefore, it is
    not a convenient option.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTPS**：在这种模式下，Git 使用 HTTPS 协议连接远程 Git 仓库。我们需要在 GitHub 账户中创建一个 HTTPS 令牌，并使用该令牌作为密码来进行身份验证。这个过程要求你每次进行
    Git 身份验证时都输入令牌，因此并不是一个方便的选项。'
- en: '**SSH**: In this mode, Git uses the SSH protocol to connect with the remote
    Git repository. While using SSH, we do not need to use a password to authenticate;
    instead, we must add the **public key** of an **SSH key pair** we can generate
    from the Linux (or Windows if you’re using Git Bash) command line to the GitHub
    account. This process is more secure as well as convenient.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSH**：在这种模式下，Git 使用 SSH 协议连接远程 Git 仓库。在使用 SSH 时，我们无需使用密码进行身份验证；相反，我们必须将从
    Linux（或如果你使用 Git Bash 的话，可以在 Windows 上）命令行生成的 **SSH 密钥对** 的 **公钥** 添加到 GitHub
    账户中。这个过程既更安全又更方便。'
- en: So, let’s set up SSH-based authentication with our remote Git repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们通过 SSH 认证设置与远程 Git 仓库的连接。
- en: 'First, we must generate the SSH key pair within our local system. Go to your
    Terminal and run the following command to generate an SSH key pair:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在本地系统中生成 SSH 密钥对。打开终端，运行以下命令生成 SSH 密钥对：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will be prompted for other details. Keep pressing *Enter* until you reach
    the prompt again.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会提示你输入其他详细信息。继续按 *Enter* 键，直到再次出现提示。
- en: Once the key pair has been generated, copy the public key present in the `~/.``ssh/id_rsa.pub`
    file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了密钥对，复制 `~/.ssh/id_rsa.pub` 文件中的公钥。
- en: Then, go to [https://github.com/settings/ssh/new](https://github.com/settings/ssh/new),
    paste the public key in the **Key** field, and click the **Add SSH Key** button.
    We are now ready to connect with the remote Git repository. Now, let’s look at
    the configurations we must do on our local repository to connect with the remote
    repository.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，访问 [https://github.com/settings/ssh/new](https://github.com/settings/ssh/new)，将公钥粘贴到
    **Key** 字段，并点击 **Add SSH Key** 按钮。现在，我们已经准备好连接远程 Git 仓库。接下来，让我们看看在本地仓库中需要做哪些配置才能连接到远程仓库。
- en: Connecting the local repository to the remote repository
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将本地仓库与远程仓库连接
- en: 'You will need to add a remote entry using the following command to connect
    with the remote repository from the local repository:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用以下命令添加远程条目，以便从本地仓库连接到远程仓库：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can also find these details on the **Quick Setup** page of your GitHub repository.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 GitHub 仓库的 **快速设置** 页面找到这些详细信息。
- en: Now that we’ve set up the connection, let’s look at how we can push our changes
    to the remote repository.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好连接，接下来让我们看看如何将更改推送到远程仓库。
- en: Pushing changes from the local repository to the remote repository
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将更改从本地仓库推送到远程仓库
- en: 'To push the changes from the local repository to the remote repository, use
    the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要将本地仓库的更改推送到远程仓库，使用以下命令：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, refresh the page on your remote repository. You should see that the code
    was synced, as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，刷新远程仓库页面。你应该能看到代码已经同步，如下图所示：
- en: '![Figure 2.2 – Code synced in the remote repository](img/B19877_Figure_2.02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 远程仓库中的代码同步](img/B19877_Figure_2.02.jpg)'
- en: Figure 2.2 – Code synced in the remote repository
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 远程仓库中的代码同步
- en: You can also use the inline editor to make further changes to the file using
    the GitHub web portal. While this is not recommended, we’ll do this to simulate
    a situation where another developer changed the same file you were working on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用内联编辑器通过 GitHub Web 门户进一步修改文件。虽然不推荐这么做，但我们会这样做来模拟另一位开发者更改了你正在工作的相同文件的情况。
- en: 'Click on **file1** and then click on the **pencil** icon to edit the file,
    as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **file1**，然后点击 **铅笔** 图标以编辑文件，如下图所示：
- en: '![Figure 2.3 – Editing the file in the remote repository](img/B19877_Figure_2.03.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 编辑远程仓库中的文件](img/B19877_Figure_2.03.jpg)'
- en: Figure 2.3 – Editing the file in the remote repository
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 编辑远程仓库中的文件
- en: 'Upon doing this, an editing window will open where you can make changes to
    the file. Let’s add `This is third line` within the file, as shown in the following
    screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，会打开一个编辑窗口，你可以在文件中进行更改。让我们在文件中添加 `This is third line`，如图所示：
- en: '![Figure 2.4 – Adding a new line](img/B19877_Figure_2.04.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 添加新行](img/B19877_Figure_2.04.jpg)'
- en: Figure 2.4 – Adding a new line
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 添加新行
- en: 'Scroll down – you should see a **Commit changes** section, where you can add
    a commit message field and click on the **Commit** button, as shown in the following
    screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 向下滚动–你应该能看到一个**提交更改**部分，在这里你可以添加提交信息字段并点击**提交**按钮，如下图所示：
- en: '![Figure 2.5 – The Commit changes section](img/B19877_Figure_2.05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 提交更改部分](img/B19877_Figure_2.05.jpg)'
- en: Figure 2.5 – The Commit changes section
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 提交更改部分
- en: 'Once you’ve clicked on that button, you should see the third line, as shown
    in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你点击了那个按钮，你应该能看到第三行，如下图所示：
- en: '![Figure 2.6 – Changes committed remotely](img/B19877_Figure_2.06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 远程提交的更改](img/B19877_Figure_2.06.jpg)'
- en: Figure 2.6 – Changes committed remotely
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 远程提交的更改
- en: 'At this point, changes have been made to the remote repository, but you have
    also been working on your changes. To simulate this, let’s make a change in the
    local repository as well using the following commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，远程仓库已经做出了更改，但你也在本地仓库上进行了一些更改。为了模拟这种情况，让我们也在本地仓库中做一个更改，使用以下命令：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we’ve committed the changes in our local repository, let’s try to
    push the code to the remote repository using the following commands:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在本地仓库提交了更改，让我们尝试使用以下命令将代码推送到远程仓库：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Wait, what happened? Well, the remote repository rejected the changes as we
    tried to push changes while someone else made some commits in the remote repository,
    and our changes are not current. We would need to pull the changes in our local
    repository first to apply our changes on top of the existing ones in the remote
    repository. We’ll look at this in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，发生了什么？我们尝试推送更改时，远程仓库拒绝了更改，因为在我们推送时，其他人已经在远程仓库做了提交，而我们的更改已经过时。我们需要先将远程仓库的更改拉取到本地仓库，然后再将我们的更改应用到这些现有的更改之上。我们将在下一节中讨论这个问题。
- en: Pulling and rebasing your code
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取和变基你的代码
- en: '**Pulling code** involves downloading up-to-date code from the remote to your
    local repository. **Rebasing** means applying your changes on top of the latest
    remote commit. It is a best practice to pull and rebase your changes on top of
    what already exists in the remote repository.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**拉取代码**是指将远程仓库的最新代码下载到本地仓库。**变基**意味着将你的更改应用到最新的远程提交之上。在远程仓库中，最好的实践是先拉取代码，再将你的更改变基到已经存在的代码上。'
- en: 'Let’s do so using the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令执行此操作：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we have another issue: we are unable to rebase our commit as we’ve tried
    to modify a file that has been modified by someone else. Git wants us to check
    the file and make appropriate changes so that the changes are applied correctly.
    This situation is known as a **merge conflict**. Git also provides us with the
    file that contains the conflict. Let’s open the file with a text editor and make
    the appropriate changes.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们遇到了另一个问题：我们无法变基我们的提交，因为我们试图修改一个已经被其他人修改过的文件。Git要求我们检查文件并做出适当的更改，以确保更改被正确应用。这种情况被称为**合并冲突**。Git还会提供包含冲突的文件。让我们用文本编辑器打开该文件并进行适当的更改。
- en: 'The current file looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当前文件看起来是这样的：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The portion depicted by `HEAD` is the line in the remote repository and shows
    the recent changes made remotely. The `e411e91` commit shows the changes that
    we made locally. Let’s change the file to the following and save it:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEAD`所示的部分是远程仓库中的一行，显示了最近在远程做的更改。`e411e91` 提交显示了我们在本地所做的更改。让我们将文件更改为以下内容并保存：'
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let’s add the file to the staging area and continue the rebase using the
    following commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将文件添加到暂存区，并使用以下命令继续执行变基：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we’ve rebased the changes, let’s look at the status of the Git repo
    by running the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经变基了更改，让我们通过运行以下命令查看Git仓库的状态：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we can see, we’ve added a single commit that we need to push to the remote
    repository. Let’s do that now using the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已经添加了一个需要推送到远程仓库的提交。现在让我们使用以下命令将其推送：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And this time, the push worked successfully.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，推送成功了。
- en: In most cases, you would normally need to take a copy of the main code and make
    changes to it to test new features. You might also want someone to review your
    changes before they are merged into the main code base. Git allows you to manage
    that by using Git branches. We’ll look at Git branches in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你通常需要复制主代码并进行更改，以测试新特性。你可能还希望在将更改合并到主代码库之前，先让别人审核这些更改。Git通过使用Git分支来管理这一过程。我们将在下一节讨论Git分支。
- en: Git branches
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git分支
- en: A **Git branch** is a copy of the code base (from where the branch is created)
    that you can independently modify and work on without affecting the main code
    base. You will want to create branches while working on new features to ensure
    that you are not affecting the main branch, which contains reviewed code. Most
    technology companies normally have several environments where you have code deployed
    in various stages. For example, you might have a **development environment** where
    you test your features, a **staging environment** where you integrate all features
    and test the complete application, and a **production environment** where the
    application that your end users access resides. So, there would be a possibility
    that you might have additional environment-specific branches where code deployed
    on those branches reside. In the following sections of this chapter, we will talk
    about GitOps, which works on this fundamental principle. For now, let’s look at
    how we can create and manage Git branches.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**Git分支**是代码库的一个副本（从中创建分支的位置），你可以独立修改和工作，而不会影响主代码库。你在处理新特性时希望创建分支，以确保不影响包含已审核代码的主分支。大多数科技公司通常会有多个环境，其中代码会在不同阶段部署。例如，你可能有一个**开发环境**来测试特性，一个**预生产环境**来集成所有特性并测试完整的应用程序，还有一个**生产环境**，是终端用户访问的应用程序所在的环境。所以，也有可能你会有额外的特定环境分支，用于存放在这些分支上部署的代码。在本章的接下来的章节中，我们将讨论GitOps，它基于这一基本原则。现在，让我们看看如何创建和管理Git分支。'
- en: Creating and managing Git branches
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和管理Git分支
- en: To create a Git branch, you must be on the branch from where you want to branch
    your code. As in our example repo, we were working on the master branch. Let’s
    stay there and create a feature branch out of that.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个Git分支，必须先切换到你希望从中分支的分支。例如，在我们的示例仓库中，我们是在master分支上工作的。让我们保持在该分支并从中创建一个特性分支。
- en: 'To create the branch, run the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建分支，运行以下命令：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As we can see, the feature branch has been created. To check what branch we
    are on now, we can use the `git branch` command. Let’s do that now:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，特性分支已经创建。要查看我们现在所在的分支，可以使用`git branch`命令。让我们现在就这样做：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And as we see by the `*` sign over the `master` branch, we are still on the
    `master` branch. The good thing is that it also shows the `feature/feature1` branch
    in the list. Let’s switch to the feature branch now by using the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通过`*`符号看到的，我们仍然在`master`分支上。好的一点是，它还在列表中显示了`feature/feature1`分支。现在让我们使用以下命令切换到特性分支：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we are on the `feature/feature1` branch. Let’s make some changes to the
    `feature/feature1` branch and commit it to the local repo:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在`feature/feature1`分支上。让我们对`feature/feature1`分支进行一些更改并提交到本地仓库：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we can see, the code is now committed to the `feature/feature1` branch.
    To check the version history, let’s run the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码现在已经提交到`feature/feature1`分支。要查看版本历史记录，让我们运行以下命令：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we can see, the `Feature 1` commit is shown in the Git logs. Now, let’s
    switch to the `master` branch and run the same command again:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Feature 1`的提交记录出现在Git日志中。现在，让我们切换到`master`分支并再次运行相同的命令：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we can see here, the `Feature 1` commit changes are absent. This shows that
    both branches are now isolated (and have now diverged). Now, the changes are locally
    present and are not in the remote repository yet. To push the changes to the remote
    repository, we will switch to the `feature/feature1` branch again. Let’s do that
    with the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`Feature 1`的提交更改缺失。这表明两个分支现在是隔离的（并且已经分叉）。现在，改变只存在于本地，还没有推送到远程仓库。为了将更改推送到远程仓库，我们将再次切换到`feature/feature1`分支。让我们通过以下命令来实现：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we’ve switched to the feature branch, let’s push the branch to the
    remote repository using the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经切换到特性分支，让我们使用以下命令将分支推送到远程仓库：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With that, we’ve successfully pushed the new branch to the remote repository.
    Assuming the feature is ready, we want the changes to go into the master branch.
    For that, we would have to raise a pull request. We’ll look at pull requests in
    the next section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就成功地将新分支推送到了远程仓库。假设功能已经准备好，我们希望将更改合并到master分支。为此，我们需要发起一个拉取请求。我们将在下一部分查看拉取请求。
- en: Working with pull requests
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用拉取请求
- en: 'A `master`. Pull requests are generally useful for developers to get their
    code peer reviewed before they merge it with the *fair* version of the code. The
    reviewer generally checks the quality of the code, whether best practices are
    being followed, and whether coding standards are appropriate. If the reviewer
    is unhappy, they might want to flag certain sections of the changes and request
    modifications. There are normally multiple cycles of reviews, changes, and re-reviews.
    Once the reviewer is happy with the changes, they can approve the pull request,
    and the requester can merge the code. Let’s take a look at this process:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`master`。拉取请求通常对开发者有用，帮助他们在将代码合并到*最终*版本之前进行同行评审。评审者通常会检查代码质量、是否遵循最佳实践、以及编码标准是否合适。如果评审者不满意，他们可能会标记出某些更改部分并要求修改。通常会有多轮评审、修改和重新评审。一旦评审者对更改满意，他们可以批准拉取请求，然后请求者就可以合并代码。让我们看一下这个过程：'
- en: 'Let’s try to raise a pull request for merging our code from the `feature/feature1`
    branch to the `master` branch. To do so, go to your GitHub repo, select **Pull
    requests**, and click on the **New pull request** button, as shown in the following
    screenshot:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试发起一个拉取请求，将我们的代码从`feature/feature1`分支合并到`master`分支。为此，进入你的GitHub仓库，选择**拉取请求**，然后点击**新建拉取请求**按钮，如下图所示：
- en: '![Figure 2.7 – New pull request](img/B19877_Figure_2.07.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 新拉取请求](img/B19877_Figure_2.07.jpg)'
- en: Figure 2.7 – New pull request
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 新拉取请求
- en: 'Keep `master` and, in the `feature/feature1`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持`master`，并在`feature/feature1`中：
- en: '![Figure 2.8 – Comparing changes](img/B19877_Figure_2.08.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 比较更改](img/B19877_Figure_2.08.jpg)'
- en: Figure 2.8 – Comparing changes
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 比较更改
- en: 'As you can see, it shows you all the changes we’ve made on the `feature/feature1`
    branch. Click on the **Create pull request** button to create the pull request.
    On the next page, stick to the defaults and click on the **Create pull** **request**
    button:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，它显示了我们在`feature/feature1`分支上所做的所有更改。点击**创建拉取请求**按钮来创建拉取请求。在下一页，保持默认设置并点击**创建拉取请求**按钮：
- en: '![Figure 2.9 – Pull request created](img/B19877_Figure_2.09.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 拉取请求已创建](img/B19877_Figure_2.09.jpg)'
- en: Figure 2.9 – Pull request created
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 拉取请求已创建
- en: As you can see, the pull request was created successfully. Here, you can assign
    a reviewer and get the code reviewed. Once the reviewer approves the code, you
    can merge the code to the master branch. For now, let’s click on the **Merge pull
    request** button, followed by the **Confirm merge** button, which should merge
    the pull request.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，拉取请求已成功创建。在这里，你可以分配评审者并进行代码评审。一旦评审者批准代码，你就可以将代码合并到master分支。现在，让我们点击**合并拉取请求**按钮，接着点击**确认合并**按钮，这样就可以合并拉取请求。
- en: Now, check if the `master` branch shows the changes within GitHub. If it does,
    switch to the `master` branch and pull the changes into your local repository.
    You should see the changes in your local repository as well.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查`master`分支是否在GitHub上显示了更改。如果显示了，切换到`master`分支，并将更改拉取到本地仓库。你应该也能在本地仓库中看到这些更改。
- en: I leave this to you as an exercise.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个留给你作为练习。
- en: This was a crash course on Git to help you get started. Now, let’s move on and
    understand GitOps, which uses Git as a single source of truth to spin up virtually
    anything within your application and infrastructure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于Git的速成课程，帮助你入门。现在，让我们继续了解GitOps，它使用Git作为单一的真理来源，来启动你应用程序和基础设施中的几乎任何内容。
- en: What is GitOps?
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是GitOps？
- en: GitOps is a method that involves implementing DevOps so that Git forms the single
    source of truth. Instead of maintaining a long list of scripts and tooling to
    support this, GitOps focuses on writing declarative code for everything, including
    the infrastructure, configuration, and application code. This means you can spin
    anything out of thin air by simply using the Git repository. The idea is that
    you declare what you need in your Git repository, and there is tooling behind
    the scenes that ensures the desired state is always maintained in the running
    application and infrastructure surrounding it. The code to spin up the tooling
    also resides in Git, and you don’t have anything outside of Git. This means everything,
    including the tooling, is automated in this process.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps是一种方法，旨在实现DevOps，使得Git成为唯一的真相来源。与其维护一长串脚本和工具来支持这一点，GitOps专注于为一切编写声明式代码，包括基础设施、配置和应用程序代码。这意味着你可以通过简单地使用Git仓库来轻松地创建任何东西。其理念是，你在Git仓库中声明所需的内容，背后有工具确保所需的状态始终保持在运行的应用程序和周围的基础设施中。用于启动这些工具的代码也存储在Git中，你不需要任何Git以外的东西。这意味着包括工具在内的一切都是自动化的。
- en: While GitOps also enables DevOps within the organization, it primarily focuses
    on using Git to manage infrastructure provisioning and application software deployments.
    DevOps is a broad term that contains a set of principles, processes, and tools
    to enable developers and operations teams to work seamlessly and shorten the development
    life cycle, with an end goal to deliver better software more quickly using a CI/CD
    cycle. While GitOps relies heavily on Git and its features and always looks to
    Git for versioning, finding configuration drift, and only applying deltas, DevOps
    is, as such, agnostic of any tool and focuses more on the concepts and processes.
    Therefore, you can implement DevOps without using Git, but you cannot implement
    GitOps without Git. Put simply, GitOps implements DevOps, but the reverse may
    not always be true.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然GitOps也使得组织内部的DevOps得以实现，但它主要侧重于使用Git来管理基础设施的配置和应用程序软件的部署。DevOps是一个广泛的术语，包含一组原则、过程和工具，旨在使开发人员和运维团队无缝协作，缩短开发生命周期，最终目标是通过CI/CD周期更快地交付更好的软件。尽管GitOps严重依赖Git及其特性，并始终依赖Git进行版本控制、查找配置漂移并仅应用增量，DevOps本身并不依赖任何工具，更加关注概念和过程。因此，你可以在不使用Git的情况下实现DevOps，但无法在没有Git的情况下实现GitOps。简单来说，GitOps实现了DevOps，但反过来并不总是成立。
- en: Why GitOps?
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择GitOps？
- en: 'GitOps provides us with the following benefits:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps为我们提供了以下好处：
- en: '**It deploys better software more quickly**: GitOps offers simplicity in delivering
    software. You don’t have to worry about what tool you need for the deployment
    type. Instead, you can commit your changes in Git, and the behind-the-scenes tooling
    automatically deploys it.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它更快地部署更好的软件**：GitOps简化了软件交付。你无需担心为部署类型需要什么工具。相反，你只需在Git中提交你的更改，背后的工具会自动进行部署。'
- en: '`git revert` and restore your environment. The idea is that you don’t need
    to learn anything else apart from Git to do a rollout or a rollback.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git revert`并恢复你的环境。其理念是，你不需要学习除Git之外的其他任何内容来执行发布或回滚。'
- en: '**It offers better credential management**: With GitOps, you don’t need to
    store your credentials in different places for your deployments to work. You simply
    need to provide the tooling access to your Git repository and the binary repository,
    and GitOps will take care of the rest. You can keep your environment completely
    secure by restricting your developers’ access to it and providing them access
    to Git instead.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它提供更好的凭证管理**：使用GitOps，你无需将凭证存储在不同的位置来使部署正常工作。你只需为工具提供对Git仓库和二进制仓库的访问权限，GitOps会处理其余的部分。你可以通过限制开发人员对环境的访问并为他们提供对Git的访问，来保持环境的安全。'
- en: '**Deployments are self-documenting**: Because everything is kept within Git,
    which records all commits, the deployments are automatically self-documenting.
    You can know exactly who deployed what at what time by simply looking at the commit
    history.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署是自我文档化的**：因为一切都保存在Git中，而Git记录了所有提交，所以部署是自动自我文档化的。你可以通过查看提交历史，准确知道是谁在什么时间部署了什么内容。'
- en: '**It promotes shared ownership and knowledge**: As Git forms the single source
    of truth for all code and configurations within the organization, teams have a
    single place to understand how things are implemented without ambiguity and dependency
    on other team members. This helps promote the shared ownership of the code and
    knowledge within the team.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它促进共享所有权和知识**：由于 Git 是组织内所有代码和配置的唯一真理来源，团队可以在一个地方理解事情是如何实现的，而不必依赖其他团队成员或存在歧义。这有助于推动团队内代码和知识的共享所有权。'
- en: Now that we know about the benefits of GitOps, let’s look at its key principles.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 GitOps 的好处，让我们来看看它的关键原则。
- en: The principles of GitOps
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitOps 的原则
- en: 'GitOps has the following key principles:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 有以下关键原则：
- en: '**It describes the entire system declaratively**: Having declarative code forms
    the first principle of GitOps. This means that instead of providing instructions
    on how to build your infrastructure, applying the relevant configuration, and
    deploying your application, you declare the end state of what you need. This means
    that your Git repository always maintains a single source of truth. As declarative
    changes are idempotent, you don’t need to worry about the state of your system
    as this will eventually become consistent with the code in Git.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它以声明性方式描述整个系统**：拥有声明性代码是 GitOps 的第一原则。这意味着，与其提供构建基础设施的指令，应用相关配置并部署应用程序，不如声明所需的最终状态。这意味着您的
    Git 仓库始终保持唯一的真理来源。由于声明性变更是幂等的，您不必担心系统的状态，因为它最终会与 Git 中的代码保持一致。'
- en: '**It versions desired system state using Git**: As Git forms an excellent version
    control system, you don’t need to worry too much about how to roll out and roll
    back your deployments. A simple Git commit means a new deployment, and a Git revert
    means a rollback. This means you do not need to worry about anything apart from
    ensuring that the Git repository reflects what you need.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它使用 Git 来版本化所需的系统状态**：由于 Git 是一个优秀的版本控制系统，您不必过于担心如何部署和回滚。一次简单的 Git 提交意味着一个新的部署，而
    Git 回滚意味着回滚。这意味着，除了确保 Git 仓库反映您需要的内容外，您不需要担心其他任何问题。'
- en: '**It uses tooling to automatically apply approved changes**: As you’ve stored
    everything within Git, you can then use tooling that looks for changes within
    the repository and automatically applies them to your environment. You can also
    have several branches that apply changes to different environments, along with
    a pull request-based approval and gating process so that only approved changes
    end up in your environment.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它使用工具自动应用已批准的更改**：由于您已经将一切存储在 Git 中，您可以使用工具来查找仓库中的更改，并自动将其应用到环境中。您还可以有多个分支将更改应用到不同的环境中，并使用基于拉取请求的审批和控制过程，确保只有已批准的更改最终进入您的环境。'
- en: '**It uses self-healing agents to alert and correct any divergence**: We have
    the tooling to automatically apply any changes in Git to the environment. However,
    we also require self-healing agents to alert us of any divergence from the repository.
    For example, suppose someone deletes a container manually from the environment
    but doesn’t remove it from the Git repository. In that scenario, the agent should
    alert the team and recreate the container to correct the divergence. This means
    there is no way to bypass GitOps, and Git remains the single source of truth.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它使用自愈代理来警报并纠正任何偏离**：我们有工具可以自动将 Git 中的任何更改应用到环境中。然而，我们还需要自愈代理来警报任何与仓库的偏离。例如，假设有人手动从环境中删除了一个容器，但没有从
    Git 仓库中删除它。在这种情况下，代理应该警报团队，并重新创建该容器以纠正偏离。这意味着没有办法绕过 GitOps，Git 始终是唯一的真理来源。'
- en: Implementing and living by these principles is simple with modern DevOps tools
    and techniques, and we will look at practically implementing them later in *Chapters
    11* and *12*. In this chapter, however, we’ll examine their design principles
    using a branching strategy and GitOps workflow.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现代 DevOps 工具和技术来实现并遵循这些原则非常简单，我们将在 *第 11 章* 和 *第 12 章* 中实际实施它们。然而，在本章中，我们将通过分支策略和
    GitOps 工作流来审视这些设计原则。
- en: Branching strategies and the GitOps workflow
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支策略和 GitOps 工作流
- en: 'GitOps requires at least two kinds of Git repositories to function: the **application
    repository**, which is from where your builds are triggered, and the **environment
    repository**, which contains all of the infrastructure and **configuration as
    code** (**CaC**). All deployments are driven from the environment repository,
    and the changes to the code repository drive the deployments. GitOps follows two
    primary kinds of deployment models: the **push model** and the **pull model**.
    Let’s discuss each of them.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 至少需要两种 Git 仓库才能正常工作：**应用仓库**，它是触发构建的来源，以及**环境仓库**，它包含所有基础设施和**配置即代码**（**CaC**）。所有的部署都来自环境仓库，而对代码仓库的变化驱动部署。GitOps
    有两种主要的部署模型：**推送模型**和**拉取模型**。我们来逐一讨论这两种模型。
- en: The push model
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推送模型
- en: 'The push model pushes any changes that occur within your Git repository to
    the environment. The following diagram explains this process in detail:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 推送模型将 Git 仓库中的任何变化推送到环境中。下图详细解释了这一过程：
- en: '![Figure 2.10 – The push model](img/B19877_Figure_2.010.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 推送模型](img/B19877_Figure_2.010.jpg)'
- en: Figure 2.10 – The push model
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 推送模型
- en: The push model is inherently unaware of the existing configuration and reacts
    only to changes made to your Git repositories. Therefore, you will need to set
    up some form of monitoring to understand whether there are any deviations. Additionally,
    the push model needs to store all environment credentials within the tools. This
    is because it interacts with the environment and has to manage the deployments.
    Typically, we use **Jenkins**, **CircleCI**, or **Travis CI** to implement the
    push model. While the push model is not recommended, it becomes inevitable in
    cloud provisioning with **Terraform**, or config management with **Ansible**,
    as they are both push-based models. Now, let’s take a closer look at the pull
    model.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 推送模型本身并不关注现有配置，只会对 Git 仓库中的变化作出反应。因此，你需要设置某种形式的监控，来了解是否存在任何偏差。此外，推送模型需要在工具中存储所有环境凭证，因为它与环境交互并且需要管理部署。通常，我们使用**Jenkins**、**CircleCI**
    或 **Travis CI** 来实现推送模型。虽然不推荐使用推送模型，但在使用**Terraform**进行云资源配置或使用**Ansible**进行配置管理时，它是不可避免的，因为它们本身就是基于推送的模型。现在，让我们更仔细地看看拉取模型。
- en: The pull model
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取模型
- en: 'The pull model is an *agent-based deployment model* (also known as an *operator-based
    deployment model*). An *agent* (or *operator*) within your environment monitors
    the Git repository for changes and applies them as and when needed. The operator
    constantly compares the existing configuration with the configuration in the environment
    repository and applies changes if required. The following diagram shows this process
    in detail:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取模型是一种*基于代理的部署模型*（也叫做*基于操作员的部署模型*）。在你的环境中，*代理*（或*操作员*）监控 Git 仓库的变化，并根据需要应用这些变化。操作员不断地将现有的配置与环境仓库中的配置进行比较，如果需要，则应用变化。下图详细展示了这一过程：
- en: '![Figure 2.11 – The pull model](img/B19877_Figure_2.011.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 拉取模型](img/B19877_Figure_2.011.jpg)'
- en: Figure 2.11 – The pull model
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 拉取模型
- en: The advantage of the pull model is that it monitors and reacts to environment
    changes alongside repository changes. This ensures that any changes that do not
    match the Git repository are reverted from the environment. It also alerts the
    operations team about anything it could not fix using mail notifications, ticketing
    tools, or Slack notifications. Because the operator lives within the same environment
    where the code is deployed, we do not need to store credentials within the tools.
    Instead, they live securely within the environment. You can also live without
    storing any credentials at all with tools such as Kubernetes, where you can employ
    **role-based access control** (**RBAC**) and service accounts for the operator
    managing the environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取模型的优点是，它在监控和响应环境变化的同时，也能响应仓库中的变化。这确保了任何与 Git 仓库不匹配的变化都会从环境中恢复。它还会通过邮件通知、工单工具或
    Slack 通知，提醒运维团队任何无法修复的问题。由于操作员与代码部署所在的环境处于同一环境中，因此我们不需要在工具中存储凭证。相反，这些凭证会安全地存储在环境中。你甚至可以完全不存储任何凭证，使用像
    Kubernetes 这样的工具时，你可以利用**基于角色的访问控制**（**RBAC**）和服务账户来管理操作员对环境的管理。
- en: Tip
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When choosing a GitOps model, the best practice is to check whether you can
    implement a pull-based model instead of a push-based model. Implement a push-based
    model only if a pull-based model is not possible. It is also a good idea to implement
    polling in the push-based model by scheduling something, such as a `cron` job,
    that will run the push periodically to ensure there is no configuration drift.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择 GitOps 模型时，最佳实践是检查是否可以实现基于拉取的模型，而不是基于推送的模型。仅当无法使用基于拉取的模型时，才实施基于推送的模型。在基于推送的模型中实施轮询是一个好主意，通过定期运行`cron`作业等调度，定期运行推送以确保没有配置漂移。
- en: We cannot solely live with one model or the other, so most organizations employ
    a **hybrid model** to run GitOps. This hybrid model combines push and pull models
    and focuses on using the pull model. It uses the push model when it cannot use
    the pull model. Now, let’s understand how to structure our Git repository so that
    it can implement GitOps.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能单靠其中一种模型生存，因此大多数组织采用**混合模型**来运行 GitOps。这种混合模型结合了推送和拉取模型，并侧重于使用拉取模型。当无法使用拉取模型时，它使用推送模型。现在，让我们了解如何构建我们的
    Git 仓库，以便它可以实施 GitOps。
- en: Structuring the Git repository
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git 仓库的结构化
- en: 'To implement GitOps, we require at least two repositories: the **application
    repository and the environment repository**. This does not mean that you cannot
    combine the two, but for the sake of simplicity, let’s take a look at each of
    them separately.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要实施 GitOps，我们至少需要两个仓库：**应用程序仓库和环境仓库**。这并不意味着您不能将两者合并，但是为了简单起见，让我们分别看看它们。
- en: The application repository
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序仓库
- en: The application repository stores the application code. It is a repository in
    which your developers can actively develop the product that you run for your business.
    Typically, your builds result from this application code, and they end up as containers
    (if we use a container-based approach). Your application repository may or may
    not have environment-specific branches. Most organizations keep the application
    repository independent of the environment and focus on building semantic code
    versions using a branching strategy. Now, there are multiple branching strategies
    available to manage your code, such as **Gitflow**, **GitHub flow**, and any other
    branching strategy that suits your needs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序仓库存储应用程序代码。这是一个您的开发人员可以积极开发您业务运行的产品的代码仓库。通常，您的构建源自这个应用程序代码，并且它们最终成为容器（如果我们使用基于容器的方法）。您的应用程序仓库可能有环境特定的分支，也可能没有。大多数组织将应用程序仓库独立于环境，并专注于使用分支策略构建语义化的代码版本。现在，有多种分支策略可用于管理您的代码，例如**Gitflow**、**GitHub
    flow**和任何适合您需求的其他分支策略。
- en: 'Gitflow is one of the most popular branching strategies that organizations
    use. That said, it is also one of the most complicated ones as it requires several
    kinds of branches (for instance, master, hotfixes, release branches, develop,
    and feature branches) and has a rigid structure. The structure of Gitflow is shown
    in the following diagram:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Gitflow 是组织中使用的最流行的分支策略之一。也可以说，它是最复杂的之一，因为它需要多种类型的分支（例如主分支、热修复分支、发布分支、开发分支和功能分支）并且有一个严格的结构。Gitflow
    的结构如下图所示：
- en: '![Figure 2.12 – Gitflow structure](img/B19877_Figure_2.012.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – Gitflow 结构](img/B19877_Figure_2.012.jpg)'
- en: Figure 2.12 – Gitflow structure
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – Gitflow 结构
- en: 'A simplified way of doing things is using GitHub flow. It employs fewer branches
    and is easier to maintain. Typically, it contains a single master branch and many
    feature branches that eventually merge with the master branch. The master branch
    always has software that is ready to be deployed to the environments. You tag
    and version the code in the master branch, pick and deploy it, test it, and then
    promote it to higher environments. The following diagram shows GitHub flow in
    detail:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GitHub flow 的简化方法是做事情更少的分支，并且更易于维护。通常，它包含一个单一的主分支和许多功能分支，这些分支最终与主分支合并。主分支始终具有准备部署到环境中的软件。您在主分支中标记和版本化代码，选择并部署它，测试它，然后将其推广到更高的环境中。以下图详细展示了
    GitHub flow：
- en: '![Figure 2.13 – GitHub flow](img/B19877_Figure_2.013.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – GitHub flow](img/B19877_Figure_2.013.jpg)'
- en: Figure 2.13 – GitHub flow
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – GitHub flow
- en: Note that you are free to create your branching strategy according to your needs
    and what works for you.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以根据自己的需求和适用情况自由创建自己的分支策略。
- en: Tip
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Choose Gitflow if you have a large team, a vast monolithic repository, and multiple
    releases running in parallel. Choose GitHub flow if you work for a fast-paced
    organization that releases updates several times a week and doesn’t use the concept
    of parallel releases. GitHub flow also typically works for microservices where
    changes are minor and quick.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个庞大的团队、大型单体仓库，并且有多个并行发布版本，可以选择Gitflow。如果你在一个快速发展的组织中工作，每周发布几次更新，并且没有并行发布的概念，可以选择GitHub
    flow。GitHub flow通常适用于微服务，在这种情况下，变更较小且快速。
- en: Typically, application repositories do not have to worry too much about environments;
    they can focus more on creating deployable software versions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应用程序仓库不需要过多担心环境问题；它们可以更多地专注于创建可部署的软件版本。
- en: The environment repository
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境仓库
- en: The environment repository stores the environment-specific configurations needed
    to run the application code. Therefore, they will typically have **Infrastructure
    as Code** (**IaC**) in the form of Terraform scripts, CaC in the form of Ansible
    playbooks, or Kubernetes manifests that typically help deploy the code we’ve built
    from the application repository.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 环境仓库存储运行应用程序代码所需的环境特定配置。因此，它们通常会包含**基础设施即代码**（**IaC**），如Terraform脚本、Ansible剧本形式的CaC，或Kubernetes清单，这些通常有助于部署我们从应用程序仓库构建的代码。
- en: 'The environment repository should follow an environment-specific branching
    strategy where a branch represents a particular environment. You can have pull
    request-based **gating** for these kinds of scenarios. Typically, you build your
    **development environments** from a development branch and then raise a pull request
    to merge the changes to a staging branch. From the staging branch to production,
    your code progresses with environments. If you have 10 environments, you might
    end up with 10 different branches in the environment repository. The following
    diagram showcases the branching strategy you might want to follow for your environment
    repository:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 环境仓库应遵循特定环境的分支策略，其中每个分支代表一个特定的环境。对于这些场景，您可以使用基于拉取请求的**门控**。通常，您会从开发分支构建**开发环境**，然后提出拉取请求将更改合并到暂存分支。从暂存分支到生产分支，您的代码随着环境的变化而推进。如果有10个环境，您可能会在环境仓库中有10个不同的分支。以下图示展示了您可能希望遵循的环境仓库分支策略：
- en: '![Figure 2.14 – The environment repository](img/B19877_Figure_2.014.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 环境仓库](img/B19877_Figure_2.014.jpg)'
- en: Figure 2.14 – The environment repository
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 环境仓库
- en: The environment repository aims to act as the single source of truth for your
    environments. The configuration you add to the repository is applied directly
    to your environments.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 环境仓库旨在作为您环境的唯一可信来源。您添加到仓库中的配置将直接应用于您的环境。
- en: Tip
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: While you can combine the environment and application repository into one, the
    best practice is to keep them separate. GitOps offers a clear separation between
    the CI and CD processes using the application and environment repositories, respectively.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以将环境和应用程序仓库合并为一个，但最佳实践是将它们分开。GitOps通过分别使用应用程序仓库和环境仓库，为CI和CD过程提供了明确的分离。
- en: Now that we’ve covered Git and GitOps in detail, let’s look at why Git and GitOps
    are related but different concepts.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细介绍了Git和GitOps，接下来我们来看看为什么Git和GitOps是相关但不同的概念。
- en: Git versus GitOps
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git与GitOps
- en: 'The following table summarizes the differences between Git and GitOps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了Git和GitOps之间的区别：
- en: '|  | **Git** | **GitOps** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|  | **Git** | **GitOps** |'
- en: '| Definition | Git is a distributed version control system that tracks changes
    to source code and other files. It allows multiple developers to collaborate and
    manage code revisions efficiently. | GitOps is a set of practices and principles
    that leverage Git as the single source of truth for managing and automating the
    deployment and operation of infrastructure and applications. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 定义 | Git是一种分布式版本控制系统，用于跟踪源代码和其他文件的更改。它允许多个开发者高效地协作和管理代码修订。 | GitOps是一组实践和原则，通过将Git作为管理和自动化基础设施和应用程序部署与操作的唯一可信来源。
    |'
- en: '| Focus | Primarily focused on version control and collaboration for source
    code. | Focused on automating and managing the deployment and operation of infrastructure
    and applications through Git-based DevOps workflows. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 重点 | 主要集中于源代码的版本控制和协作。 | 专注于通过基于Git的DevOps工作流自动化和管理基础设施和应用程序的部署与操作。 |'
- en: '| Usage | Widely used for version control and collaboration in software development
    projects. Developers use Git to track changes, manage branches, and merge code.
    | Used for declaratively defining and managing infrastructure and application
    configurations. Git repositories serve as a central hub for defining desired states
    and driving automation. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 用法 | 在软件开发项目中广泛用于版本控制和协作。开发者使用Git来跟踪变更、管理分支和合并代码。 | 用于声明性定义和管理基础设施和应用程序配置。Git存储库作为定义所需状态和驱动自动化的中心枢纽。
    |'
- en: '| Core Components | Repositories, branches, commits, and pull requests. | Git
    repositories, declarative configuration files (such as YAML), Kubernetes manifests,
    CI/CD pipelines, and deployment tools such as Argo CD or Flux. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 核心组件 | 存储库、分支、提交和拉取请求。 | Git存储库、声明性配置文件（如YAML）、Kubernetes清单、CI/CD流水线和部署工具如Argo
    CD或Flux。 |'
- en: '| Workflow | Developers clone, modify, commit, and push changes to a remote
    repository. They collaborate through pull requests and branch merges. | Infrastructure
    and application configurations are stored in Git repositories. Changes to these
    configurations trigger automated processes, such as CI/CD pipelines or reconciliation
    loops, to apply those changes to the target environment. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 工作流程 | 开发者克隆、修改、提交和推送更改到远程存储库。他们通过拉取请求和分支合并进行协作。 | 基础设施和应用配置存储在Git存储库中。对这些配置的更改会触发自动化流程，如CI/CD流水线或协调循环，以将这些更改应用到目标环境中。
    |'
- en: '| Benefits | Enables efficient version control, collaboration, and code management
    for software development teams. | Promotes infrastructure and application as code,
    versioning of configurations, and declarative management. It simplifies infrastructure
    deployment, provides consistency, and enables automated workflows. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 好处 | 为软件开发团队提供高效的版本控制、协作和代码管理。 | 促进基础设施和应用程序的代码、配置版本控制和声明式管理。简化基础设施部署，提供一致性，并启用自动化工作流程。
    |'
- en: '| Focus Area | Source code management. | Infrastructure and application deployment
    and management. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 关注领域 | 源代码管理。 | 基础设施和应用程序部署与管理。 |'
- en: '| Examples | GitHub, Bitbucket, GitLab. | Argo CD, Flux, Jenkins X, Weave Flux.
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 示例 | GitHub、Bitbucket、GitLab。 | Argo CD、Flux、Jenkins X、Weave Flux。 |'
- en: Remember that while Git is a version control system, GitOps extends this concept
    by utilizing Git as a central source of truth for infrastructure and application
    configurations, allowing for automated deployment and management of DevOps workflows.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然Git是一个版本控制系统，但GitOps通过利用Git作为基础设施和应用程序配置的中心真实来源，允许自动化部署和管理DevOps工作流程。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered Git, GitOps, why we need it, its principles, and various
    GitOps deployments. We also looked at different kinds of repositories that we
    can create to implement GitOps, along with the branching strategy choices for
    each of them.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Git、GitOps、我们为什么需要它、其原则以及各种GitOps部署。我们还研究了可以创建来实现GitOps的不同类型的存储库，以及每种存储库的分支策略选择。
- en: 'You should now be able to do the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该能够做到以下几点：
- en: Understand what source code management is and how it is necessary for many activities
    with modern DevOps
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解什么是源代码管理及其在现代DevOps中的必要性
- en: Create a Git repository and play around with the `clone`, `add`, `commit`, `push`,
    `pull`, `branch`, and `checkout` commands
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个Git存储库并尝试使用`clone`、`add`、`commit`、`push`、`pull`、`branch`和`checkout`命令进行操作
- en: Understand what GitOps is and how it fits the modern DevOps context
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解GitOps是什么以及它如何适应现代DevOps的背景
- en: Understand why we need GitOps and how it achieves modern DevOps
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么我们需要GitOps以及它如何实现现代DevOps
- en: Understand the salient principles of GitOps
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解GitOps的显著原则
- en: Understand how to use an effective branching strategy to implement GitOps based
    on the org structure and product type
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何使用有效的分支策略来实现基于组织结构和产品类型的GitOps
- en: In the next chapter, we will develop a core understanding of containers and
    look at Docker.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入理解容器并探讨Docker。
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章的理解：
- en: Which of the following is true about Git? (Choose three)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于Git的说法哪些是正确的？（选择三个）
- en: It is a distributed SCM platform
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个分布式SCM平台
- en: It is a centralized SCM platform
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个集中式SCM平台
- en: It allows multiple developers to collaborate
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它允许多个开发者协作
- en: It has commits and branches
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它具有提交和分支
- en: In Git terms, what does Git checkout mean?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Git术语中，Git checkout是什么意思？
- en: Sync code from remote to local
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从远程同步代码到本地
- en: Switch from one branch to another
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个分支切换到另一个分支
- en: Review and approve a pull request
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查并批准拉取请求
- en: In GitOps, what forms a single source of truth
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在GitOps中，什么构成了唯一的真理来源
- en: The Git repository
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Git 仓库
- en: The configuration stored in a datastore
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储在数据存储中的配置
- en: The secret management system
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 秘密管理系统
- en: The artifact repository
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 人工制品库
- en: Which of the following options are deployment models for GitOps? (Choose two)
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些选项是GitOps的部署模型？（选择两个）
- en: The push model
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送模型
- en: The pull model
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取模型
- en: The staggering model
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错开模型
- en: Should you use Gitflow for your environment repository?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否应该在环境仓库中使用Gitflow？
- en: For monolithic applications with multiple parallel developments in numerous
    releases, what is the most suitable Git branching strategy?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于具有多个并行开发和多个版本发布的单体应用，最适合的Git分支策略是什么？
- en: Gitflow
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gitflow
- en: GitHub flow
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitHub流
- en: Hybrid GitHub flow
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 混合GitHub流
- en: Which is the recommended deployment model for GitOps?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种是GitOps推荐的部署模型？
- en: The push model
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推送模型
- en: The pull model
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拉取模型
- en: The staggering model
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错开模型
- en: Answers
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A,C,D
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A,C,D
- en: B
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: A
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: A,B
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A,B
- en: 'No'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: A
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
