- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Relationships, Ordering, and Scope
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系、排序和范围
- en: In this chapter, we will be discussing relationships, ordering, and scope in
    Puppet. These topics are often considered complicated because Puppet’s approach
    differs greatly from traditional languages. However, we will show you how to manage
    these aspects effectively and avoid unnecessary complexities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 Puppet 中的关系、顺序和范围。这些话题常被认为很复杂，因为 Puppet 的处理方式与传统编程语言大不相同。不过，我们将向你展示如何有效地管理这些方面，避免不必要的复杂性。
- en: We will start by discussing Puppet’s approach to relationships and ordering.
    By default, Puppet treats resources as independent and can apply them in any order
    in the catalog. However, where ordering is necessary, we will show you how to
    use metaparameters such as `before`, `after`, `notify`, and `subscribe` to enforce
    ordering and create relationships between resources.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论 Puppet 对关系和排序的处理方式。默认情况下，Puppet 将资源视为独立的，可以按任意顺序在目录中应用。然而，当排序是必需时，我们将向你展示如何使用
    `before`、`after`、`notify` 和 `subscribe` 等元参数来强制执行排序并在资源之间创建关系。
- en: After that, we will cover the concept of containment. We will explain that including
    classes are not contained within their calling classes, so relationships/dependencies
    made between classes do not automatically create relationships and dependencies
    with the resources in those classes. To address this, we will introduce the `contain`
    function, which allows you to contain the resources within a class and create
    those relationships.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍封装的概念。我们将解释，包含类并不包含在其调用类内，因此，类之间建立的关系/依赖关系不会自动与这些类中的资源建立关系和依赖关系。为了解决这个问题，我们将介绍
    `contain` 函数，它允许你将资源包含在类内并创建这些关系。
- en: Finally, we will discuss scopes and how variables and resource defaults can
    have different visibility depending on where they are in the code and their relative
    scope. We will then provide best practices and pitfalls to ensure that you take
    the simplest path and avoid unnecessary complexity.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将讨论作用域，以及变量和资源默认值如何根据它们在代码中的位置及其相对作用域具有不同的可见性。然后，我们将提供最佳实践和常见陷阱，以确保你采取最简单的路径并避免不必要的复杂性。
- en: Overall, this chapter will equip you with the knowledge and skills to effectively
    manage relationships, ordering, and scope in Puppet.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，本章将帮助你掌握在 Puppet 中有效管理关系、排序和范围的知识与技能。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Relationships and ordering
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系和排序
- en: Containment
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Scope
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: Best practices and pitfalls
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践与常见陷阱
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All examples and labs in this chapter can be run within your own local dev environment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例和实验可以在你自己的本地开发环境中运行。
- en: Relationships and ordering
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系和排序
- en: By default, Puppet treats all resources as independent of each other, which
    means they can be applied in any order. This is different from traditional declarative
    code, which runs line by line and executes in the order it is written. One of
    the main advantages of Puppet’s approach is that if a single part of the code
    fails, Puppet will continue to apply all other resources. This eliminates the
    need to stop or have substantial failure handling in place to continue code. As
    a result, Puppet can bring a client server as close to the desired state as possible,
    even if some resources fail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Puppet 将所有资源视为相互独立的，这意味着它们可以按任意顺序应用。这与传统的声明式代码不同，传统代码按行执行并按照书写顺序执行。Puppet
    方法的主要优势之一是，如果代码的某个部分失败，Puppet 会继续应用所有其他资源。这消除了停止或需要大规模故障处理来继续执行代码的需求。因此，即使某些资源失败，Puppet
    也能将客户端服务器尽可能接近所需状态。
- en: 'It’s clear that some resources will be dependent on each other, such as a configuration
    file that can only exist after a package has been installed. Puppet provides metaparameters
    to create these dependencies:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，一些资源之间会相互依赖，例如一个配置文件只能在安装完某个包后才能存在。Puppet 提供了元参数来创建这些依赖关系：
- en: '`before`: The resource should be applied before the named resource(s).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before`: 该资源应在指定的资源之前应用。'
- en: '`require`: The resource should be applied after the named resource(s).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`require`: 该资源应在指定的资源之后应用。'
- en: '`notify`: The resource should be applied before the named resource(s). The
    named resource refreshes if the resource changes.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify`: 该资源应在指定的资源之前应用。如果该资源发生变化，指定的资源将被刷新。'
- en: '`subscribe`: The resource should be applied after the named resource(s). The
    resource refreshes if the named resource changes.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscribe`：资源应在指定的资源之后应用。如果指定的资源发生变化，资源将刷新。'
- en: The `before` and `require` metaparameters can be used to enforce a dependency
    relationship. However, it’s important to note that a relationship only needs to
    be applied in one direction. Therefore, there is no need to use both `before`
    and `require` on either side of a dependency.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`before`和`require`元参数可以用来强制执行依赖关系。然而，重要的是要注意，依赖关系只需在一个方向上应用。因此，不需要在依赖关系的两侧都使用`before`和`require`。'
- en: 'For example, to indicate that the `httpd` package should be installed before
    managing a file, either `before` or `require` can be used, as shown:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要表示在管理文件之前应安装`httpd`包，可以使用`before`或`require`，如下面所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A dependency chart, also known as a `--graph` option with the `puppet` command
    to produce a dot file that can be used to create a graphic in an appropriate program.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系图，也称为`puppet`命令中的`--graph`选项，用于生成一个dot文件，该文件可以用来在适当的程序中创建图形。
- en: 'In *Figure 6**.1*, the `require` on the file resource has been removed to produce
    a DAG for the example code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图6.1*中，文件资源上的`require`已经被移除，从而为示例代码生成了一个DAG：
- en: "![Figure 6.1 \uFEFF– A DAG of resource dependencies](img/B18492_06_01.jpg)"
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 资源依赖的DAG](img/B18492_06_01.jpg)'
- en: Figure 6.1 – A DAG of resource dependencies
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 资源依赖的DAG
- en: If both the `before` and `require` metaparameters were present, an extra arrow
    would be visible in the DAG, but it would have no effect on the compilation or
    resources applied. It’s worth noting that the starting and finishing classes,
    named `Main`, in the example code reflect that the code is not contained within
    a class and the code is at a global level. This will be discussed further in the
    *Scope* section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果同时存在`before`和`require`元参数，DAG中将会看到一个额外的箭头，但它不会影响编译或应用资源。值得注意的是，示例代码中的起始和结束类`Main`反映了代码不包含在类中，而是处于全局范围内。这将在*作用域*部分进一步讨论。
- en: 'In a DAG, loops are not expected, so the flow of dependencies should only go
    downward. If a third resource, such as a service, is added that should be enforced
    before the `httpd` package after the `/etc/httpd.conf` file, the DAG would look
    like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在DAG中，通常不期望出现循环，因此依赖关系的流动应该只向下进行。如果添加了第三个资源（例如服务），并且该资源应在`/etc/httpd.conf`文件之后强制执行`httpd`包，那么DAG应该是这样的：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would result in a dependency cycle, as illustrated in *Figure 6**.2*. When
    compiled, the code would produce an error, as there would be no way to determine
    the order in which to apply the resources.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致依赖循环，如*图6.2*所示。编译时，代码将产生错误，因为无法确定资源应用的顺序。
- en: "![Figure 6.2 \uFEFF– A DAG showing a dependency cycle](img/B18492_06_02.jpg)"
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 显示依赖循环的DAG](img/B18492_06_02.jpg)'
- en: Figure 6.2 – A DAG showing a dependency cycle
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 显示依赖循环的DAG
- en: 'It is also possible to represent multiple dependencies with an array, which
    can be an array of names either of the same type or of different types. For example,
    if a package were required by two files and two services for `exampleapp`, it
    could be represented like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用数组表示多个依赖关系，数组可以包含相同类型或不同类型的名称。例如，如果一个包被`exampleapp`的两个文件和两个服务所需要，可以这样表示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Sometimes, it can be easier to have all the resource dependencies on one side
    rather than on each individual resource.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，将所有资源依赖集中在一边比分别在每个资源上处理要更简单。
- en: As was mentioned in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), some Puppet
    types have automatic rules for creating dependencies, which can be found in the
    documentation for the Puppet type under `Autorequires` either online or using
    the Puppet `describe` command. For example, the user type autorequires any group
    under Puppet’s control, that a user resource has as its primary or secondary group.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[*第3章*](B18492_03.xhtml#_idTextAnchor048)中提到的，某些Puppet类型具有自动创建依赖关系的规则，这些规则可以在Puppet类型的文档中找到，位于`Autorequires`部分，可以在线查看或使用Puppet的`describe`命令。例如，用户类型会自动要求Puppet控制下的任何组，作为用户资源的主组或副组。
- en: As well as an ordering concept, Puppet has the `refresh` attribute, so if a
    resource has a dependency on another resource, it will refresh itself. This is
    useful in situations such as when a configuration file is updating and the service
    should restart to reread the configuration file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了排序概念，Puppet还有`refresh`属性，因此如果一个资源依赖于另一个资源，它将刷新自身。这在配置文件更新并且服务需要重启以重新读取配置文件的情况下非常有用。
- en: The `notify` and `subscribe` metaparameters create the same dependency as `before`
    and `require` but add the `refresh` attribute to the dependent resource. Of the
    built-in Puppet types, `service exec` and `package` can be refreshed. If a `notify`
    or `subscribe` metaparameter is used with a resource type incapable of refreshing,
    it will just enforce the dependency and do nothing on a refresh event.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify`和`subscribe`元参数创建与`before`和`require`相同的依赖关系，但将`refresh`属性添加到依赖资源。对于内置的Puppet类型，`service
    exec`和`package`可以被刷新。如果使用了`notify`或`subscribe`元参数与无法刷新资源类型，它只会强制执行依赖关系，并在刷新事件时不执行任何操作。'
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注解
- en: The `notify` metaparameter should not be confused with the `notify` resource
    type used to send messages to the agents log.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify`元参数不应与`notify`资源类型混淆，后者用于向代理日志发送消息。'
- en: 'For example, a `service` resource could use `subscribe` or `notify` from the
    `file` resource so that the service would be dependent on the file being created.
    It would also receive a refresh event if the file was updated and restart the
    service assuming the provider had the capability. As shown in the following code,
    again we show both sides of the dependency, although only one relationship attribute
    should be given:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个`service`资源可以使用`file`资源的`subscribe`或`notify`，使得该服务依赖于文件的创建。如果文件被更新，它也会接收到一个刷新事件，并重启服务，前提是提供者具有此能力。如以下代码所示，我们展示了依赖关系的双方，尽管只应提供一个关系属性：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In a DAG diagram, this would be identical to using `before` and `require`, and
    it can use the same resource reference or arrays of resource references.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在DAG图中，这与使用`before`和`require`是相同的，并且可以使用相同的资源引用或资源引用数组。
- en: The default behaviors and parameters of a refresh event for each type are shown
    in *Table 6.1*. Here, we see that by default, a service will use the provider’s
    `restart` variable if it is provided. Otherwise, `hasrestart` can define an `init`
    script or `restart` can define a custom restart script. If no `init` script is
    provided, the service name will be searched for in the process tree, but it is
    strongly advised to provide clear service management scripts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的刷新事件的默认行为和参数如*表6.1*所示。这里，我们看到默认情况下，服务将使用提供者的`restart`变量（如果提供）。否则，`hasrestart`可以定义一个`init`脚本，或`restart`可以定义一个自定义的重启脚本。如果没有提供`init`脚本，将在进程树中搜索服务名称，但强烈建议提供明确的服务管理脚本。
- en: For the package type, the default behavior is to ignore the `restart` event,
    but the parameter can be set to reinstall the package as the result of a `refresh`
    event.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包类型，默认行为是忽略`restart`事件，但可以将参数设置为在`refresh`事件后重新安装包。
- en: '`Exec` will rerun its command on a refresh but can be changed to run a different
    `refresh` command or to only run as a result of a `refresh` event.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exec`将在刷新时重新运行其命令，但可以更改为运行不同的`refresh`命令或仅在`refresh`事件后运行。'
- en: '| Type | Default Behavior | Parameter(s) |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 默认行为 | 参数 |'
- en: '| `Service` | Restart the service if the provider has a restart feature; otherwise,
    stop and start | hasrestartrestart |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `Service` | 如果提供者有重启功能，则重启服务；否则，停止并重新启动 | hasrestartrestart |'
- en: '| `Package` | Ignore refresh event | reinstall_on_refresh |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `Package` | 忽略刷新事件 | reinstall_on_refresh |'
- en: '| `Exec` | Rerun the command | refreshrefresh only |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `Exec` | 重新运行命令 | refreshrefresh only |'
- en: Table 6.1– Puppet native type refresh options
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 - Puppet本地类型刷新选项
- en: Metaparameter dependencies can produce three types of errors. The first is missing
    dependencies, where the resource is not found in the compiled catalog. This should
    normally be investigated for typos or logic, meaning the resource is not included.
    The second type of error is failed dependencies, where an issue with a resource
    means none of its dependencies can be applied. Troubleshooting this resource and
    rerunning Puppet should then allow all dependent resources to be applied. The
    third type of error is the dependency cycle, which we discussed and showed in
    *figure 6.2*, where producing a DAG can help identify where the loop is and fix
    the dependency logic.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 元参数依赖可能会产生三种类型的错误。第一种是缺少依赖，即在编译后的目录中找不到资源。这通常应该检查是否存在拼写错误或逻辑错误，意味着资源没有被包含。第二种错误是依赖失败，即资源存在问题，导致无法应用它的任何依赖。此时需要排查该资源并重新运行
    Puppet，这样所有依赖的资源就能被应用。第三种错误是依赖循环，我们在 *图 6.2* 中讨论过并展示过，通过生成有向无环图（DAG）可以帮助识别循环的位置并修复依赖逻辑。
- en: Despite having said so far that resources have no order beyond dependencies,
    this is not quite true since Puppet runs in what is known as **manifest order**.
    So, an individual manifest file will be applied in the order it is written unless
    dependencies change that. Although this could allow you not to use dependencies,
    the main purpose is to prevent random compilations causing code to behave differently
    on different servers as it could do if read in at random.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们之前说过资源除了依赖关系外没有顺序，但这并不完全准确，因为 Puppet 是按照所谓的 **清单顺序** 运行的。因此，单个清单文件将按其编写的顺序应用，除非依赖关系发生变化。尽管这允许你不使用依赖关系，但其主要目的是防止随机编译导致代码在不同的服务器上表现不同，这可能会发生在随机读取时。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Puppet went through a strange philosophical/purity argument around ordering
    in earlier versions. It was viewed as necessary to break the bad habits of developers
    assuming ordering would be like in other languages, line by line. So, Puppet initially
    chose a random order. This was chaotic and resulted in code that might work in
    your lab but ran in a different order in production and broke.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 在早期版本中经历了一个关于排序的奇怪哲学/纯粹性争论。开发人员习惯性地认为排序应像其他语言一样，按行逐行处理，因此 Puppet 最初选择了随机排序。这种做法混乱不堪，导致在实验室中运行的代码可能可以工作，但在生产环境中按不同的顺序运行并导致失败。
- en: 'A variation of the dependency metaparameters is chaining arrows, where `before`
    and `require` are represented by `->` and `<-` and `notify` and `subscribe` by
    `~>` and `<~`. They are generally used to show relationships between classes,
    such as to represent a module pattern, which will be seen in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
    For example, if we wanted an `install` class to apply before a `config` class
    and then for a `service` class to be applied and refreshed if the `config` class
    was updated, it could be represented as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖元参数的一种变体是链接箭头，其中 `before` 和 `require` 通过 `->` 和 `<-` 表示，而 `notify` 和 `subscribe`
    则通过 `~>` 和 `<~` 表示。它们通常用来表示类之间的关系，比如表示模块模式，详情见 [*第 8 章*](B18492_08.xhtml#_idTextAnchor212)。例如，如果我们希望
    `install` 类在 `config` 类之前应用，并且在 `config` 类更新时应用并刷新 `service` 类，可以表示为：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `include` function is necessary, as discussed in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048),
    to ensure the classes are added to a catalog.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 [*第 3 章*](B18492_03.xhtml#_idTextAnchor048) 中讨论的那样，`include` 函数是必要的，以确保类被添加到目录中。
- en: For style purposes, only the right-facing arrows are recommended to be used,
    to make it consistent while reading. While dependency parameters can be used in
    classes and resource declarations and chaining arrows on other resource types,
    it is not recommended to do so to make it clearer to read.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了风格上的一致性，建议仅使用右箭头，以确保阅读时的一致性。虽然依赖参数可以在类和资源声明中使用，并且可以在其他资源类型中链接箭头，但不推荐这样做，以保持阅读的清晰性。
- en: 'In simpler cases, the required function can also be used from within a class
    to create a dependency on other classes. However, no `refresh` or `before` equivalent
    exists, so for styling and consistency, it’s generally easier to use ordering
    arrows. A simple example, using the `require` function to represent that the `install`
    class should applied before the `config` class, would be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在简单的情况下，可以通过类内部使用所需的函数来创建对其他类的依赖。然而，没有类似 `refresh` 或 `before` 的功能，因此为了风格和一致性，通常使用排序箭头会更方便。一个简单的例子，使用
    `require` 函数表示 `install` 类应该在 `config` 类之前应用，示例如下：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we have just discussed in terms of the approach to class dependency is
    not quite as simple as it may seem because Puppet classes do not actually contain
    other classes. A class will include other classes by default, so the dependencies
    do not cover them. We will now look at what this containment problem means and
    how to handle it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讨论的类依赖方法并不像看起来那么简单，因为 Puppet 类实际上并不包含其他类。一个类默认会包含其他类，因此依赖关系不会覆盖它们。接下来我们将探讨这个包含问题的含义以及如何处理它。
- en: Containment
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含
- en: 'Containment in Puppet means that included classes are not contained in the
    same way as resources in a class; so, when setting up a dependency to a class
    that includes another class via the `include` function or a `class` resource,
    the dependency will only cover the resources. For example, say we created a requirement
    for `class1` to be applied before `class2` and `class2` contained a `package`
    resource and an `include` call to `class3`, as shown in the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 中的包含意味着包含的类不会像类中的资源那样被包含；因此，当设置对一个类的依赖关系，并通过 `include` 函数或 `class` 资源来包含另一个类时，依赖关系只会覆盖资源。例如，假设我们创建了一个要求
    `class1` 在 `class2` 之前应用，并且 `class2` 包含一个 `package` 资源和一个对 `class3` 的 `include`
    调用，如以下代码所示：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, while there might be an assumption that this would ensure `class1` was before
    `class3` but `class1` was before `class2`, it doesn’t, as can be seen in the DAG
    diagram in *Figure 6**.3*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然可能有一种假设认为这将确保 `class1` 在 `class3` 之前，但是 `class1` 确实在 `class2` 之前，这并不会发生，正如在
    *图 6.3* 的 DAG 图中所看到的那样。
- en: "![\uFEFFFigure 6.3 – DAG showing lack of containment](img/B18492_06_03.jpg)"
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – DAG 显示缺乏包含](img/B18492_06_03.jpg)'
- en: Figure 6.3 – DAG showing lack of containment
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – DAG 显示缺乏包含
- en: Remembering back to [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), where the
    `include` function was introduced, this containment is not automatic because we
    may want to include this class in different places for different situations and
    for it only to appear once in the catalog without dependency or containment issues.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下在 [*第 3 章*](B18492_03.xhtml#_idTextAnchor048) 中介绍的 `include` 函数，这种包含并非自动发生，因为我们可能希望将该类包含在不同的地方，以应对不同的情况，并且它在目录中只出现一次，没有依赖或包含问题。
- en: To contain a class, the `contain` function is used. Change the `include` line
    to `contain` `examplemodule::class3`, which will change the DAG diagram to contain
    `examplemodule::class3`, as We can see in *Figure 6**.4*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要包含一个类，可以使用 `contain` 函数。将 `include` 行改为 `contain` `examplemodule::class3`，这将使
    DAG 图包含 `examplemodule::class3`，正如我们在 *图 6.4* 中所看到的那样。
- en: "![\uFEFFFigure 6.4 – DAG showing the use of the contain function](img/B18492_06_04.jpg)"
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – DAG 显示使用 contain 函数](img/B18492_06_04.jpg)'
- en: Figure 6.4 – DAG showing the use of the contain function
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – DAG 显示使用 contain 函数
- en: 'If a `class` resource is used alongside a `contain` statement, it must appear
    in manifest order after the `class` resource. Failure to do so will cause the
    `class` resource to interpret the `contain` statement as an attempt to declare
    a duplicate resource, resulting in an error. For example, if the following code
    is used, the attribute can be passed successfully:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `class` 资源与 `contain` 语句一起使用，它必须在 `class` 资源之后按清单顺序出现。如果没有这样做，`class` 资源将把
    `contain` 语句解释为尝试声明一个重复的资源，从而导致错误。例如，如果使用以下代码，属性将被成功传递：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The immediate question to this containment problem might be why not just use
    `contain` for everything? That comes down to the needless and confusing dependencies
    it could create. If our original example were updated to use `contain` instead
    of `class` and we had another class, `anothermodule:class`, which required `examplemodule:class3`
    to be in the catalog, we could add the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个包含问题，直接的问题可能是为什么不使用 `contain` 来处理所有的内容呢？这归结于它可能产生的不必要且令人困惑的依赖关系。如果我们将原始示例更新为使用
    `contain` 替代 `class`，并且我们有另一个类 `anothermodule:class`，它要求 `examplemodule:class3`
    出现在目录中，那么我们可以添加如下代码：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, the DAG would look like *Figure 6**.5*. It can be immediately seen that
    we have created needless dependencies just with a small number of classes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，DAG 会像 *图 6.5* 所示。可以立刻看出，我们仅通过少数几个类就创建了不必要的依赖关系。
- en: "![Figure 6.5 \uFEFF– DAG showing cycle caused \uFEFFby the overuse \uFEFFof\
    \ contain](img/B18492_06_05.jpg)"
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – DAG 显示由于过度使用 contain 而导致的循环](img/B18492_06_05.jpg)'
- en: Figure 6.5 – DAG showing cycle caused by the overuse of contain
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – DAG 显示由于过度使用 contain 而导致的循环
- en: 'Worse, it can be easy to create a cyclical dependency. If, for example, the
    `security::default` class were to be included in all application classes, a cyclical
    dependency could be created by a `require` function being used between a class,
    `application2`, requiring the `application1` class, as shown in the following
    code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟的是，很容易创建一个循环依赖。例如，如果 `security::default` 类被包含在所有应用程序类中，`application2` 类通过
    `require` 函数引用 `application1` 类，就可能会创建一个循环依赖，代码如下所示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This would produce the DAG shown in *Figure 6**.6*. If only includes were used,
    we would have avoided the need for an unnecessary relationship from the application
    classes to `security::default`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成如 *图 6.6* 所示的 DAG。如果仅使用 include，就能避免应用程序类与 `security::default` 之间的不必要关系：
- en: "![\uFEFFFigure 6.6 – DAG showing how the over-use of contain causes cyclic\
    \ dependencies](img/B18492_06_06.jpg)"
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: "![\uFEFF图 6.6 – DAG 显示了过度使用 contain 导致循环依赖的情况](img/B18492_06_06.jpg)"
- en: Figure 6.6 – DAG showing how the over-use of contain causes cyclic dependencies
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – DAG 显示了过度使用 contain 导致循环依赖的情况
- en: In the *Best practices and pitfalls* section, we will further discuss how to
    avoid worrying about containment using consistent patterns.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *最佳实践与陷阱* 部分，我们将进一步讨论如何通过一致的模式避免担心包含问题。
- en: 'Before the `contain` function was introduced in Puppet 3.4, there was another
    approach, which you may see in heritage code: using `anchor` resources. This can
    either be done with a specific anchor resource provided by the `stdlib` module
    or any other pair or resources in the class. To ensure that the current class
    contains `examplemodule::class3`, the code using the `anchor` resource directly
    would look as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 3.4 版本引入 `contain` 函数之前，有另一种方法，您可能会在遗留代码中看到：使用 `anchor` 资源。这可以通过 `stdlib`
    模块提供的特定锚点资源或类中的其他资源对来完成。为了确保当前类包含 `examplemodule::class3`，使用 `anchor` 资源的代码如下所示：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, if the two package resources, `pdk` and `cowsay`, were in this
    class, they could be borrowed to create a relationship and contain the class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果这两个软件包资源，`pdk` 和 `cowsay`，在此类中，它们可以被借用来创建关系并包含该类：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The issue with this pattern is that it clutters up the DAG with extra anchor
    resources or unnecessary relationships, which can be confusing. Therefore, if
    you find that anchors are being used, it is recommended that you modernize your
    approach by using the `contain` keyword instead.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的问题是，它会用额外的锚点资源或不必要的关系使 DAG 变得杂乱，可能会引起混淆。因此，如果发现正在使用锚点，建议您通过使用 `contain`
    关键字来现代化您的方法。
- en: Having discussed dependencies and the containment of resources and classes,
    we will now see how variables and resource defaults are scoped across the Puppet
    language.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了依赖关系和资源及类的包含后，我们将看到变量和资源默认值在 Puppet 语言中的作用域。
- en: Scope
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: In Puppet terms, scope reflects the location in the code where variables can
    be directly accessed without the use of namespaces and where resource defaults
    can be affected.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 中，作用域反映了代码中可以直接访问变量的地方，而无需使用命名空间，并且可以影响资源默认值的地方。
- en: 'There are three levels of scope:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域有三个级别：
- en: '**Top scope**: Any code outside of a class, type, or node definition. Any variable
    or resource declaration in the top scope will be accessible to be read or used
    anywhere.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶层作用域**：类、类型或节点定义之外的任何代码。顶层作用域中的任何变量或资源声明将在任何地方都能读取或使用。'
- en: '**Node scope**: Any code defined in a node definition. Any variables and resource
    defaults in the node scope will be visible to nodes that match the node definition
    at the node and local scope levels.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点作用域**：在节点定义中定义的任何代码。节点作用域中的任何变量和资源默认值将对与该节点定义匹配的节点在节点和局部作用域级别可见。'
- en: '**Local scope**: Any code defined in a class, defined type, or lambda. So,
    any variables and resource defaults defined will only be visible within that specific
    resource.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部作用域**：在类、定义类型或 Lambda 中定义的任何代码。因此，在该特定资源内定义的任何变量和资源默认值将仅在该资源内可见。'
- en: Both **External Node Classifiers** (**ENCs**) and node definitions will be discussed
    in [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272). All we need to understand
    for this section is that an ENC is an executable script that returns variables
    and classes to be applied to a host. This script can inject custom logic and data
    by performing various actions, such as performing a database lookup or using AWS
    Lambda. It can also be used to access third-party sources, such as **Configuration
    Management Databases** (**CMDBs**). The variables returned are at the top-scope
    level, while the classes are at the node-scope level. This allows the provided
    variables to be visible anywhere, but only for the classes declared to have access
    to node-scope variables. In contrast, a node definition is a section of code that
    is applied to matching nodes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**外部节点分类器**（**ENCs**）和节点定义将在[*第11章*](B18492_11.xhtml#_idTextAnchor272)中讨论。我们在本节中需要理解的是，ENC是一个可执行脚本，它返回变量和类，这些变量和类将应用于主机。此脚本可以通过执行各种操作（例如，执行数据库查找或使用AWS
    Lambda）注入自定义逻辑和数据。它还可以用于访问第三方源，如**配置管理数据库**（**CMDBs**）。返回的变量位于顶级作用域，而类位于节点作用域级别。这使得提供的变量可以在任何地方可见，但只有声明了访问节点作用域变量的类才能访问这些变量。相比之下，节点定义是应用于匹配节点的代码段。'
- en: Classes have what is known as a named scope, where the name of the class is
    used in the namespace. For example, a variable created in `exampleclass` called
    `test` can be accessed from anywhere via `exampleclass::test`. Variables created
    in the global scope, such as `site.pp`, can be accessed from an empty namespace
    by calling `::variablename`. However, accessing data like this is generally not
    recommended. In [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233), we will show
    how to centrally manage data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类具有所谓的命名作用域，其中类的名称用于命名空间。例如，在`exampleclass`中创建的名为`test`的变量可以通过`exampleclass::test`从任何地方访问。在全局作用域中创建的变量（如`site.pp`）可以通过调用`::variablename`从空命名空间访问。然而，通常不推荐以这种方式访问数据。在[*第9章*](B18492_09.xhtml#_idTextAnchor233)中，我们将展示如何集中管理数据。
- en: Node-scope definitions and local-scope definitions on lambdas and defined types
    are anonymous and can only be accessed directly by name from where they are visible.
    It is also possible to override higher scope variables by declaring a variable
    in the current scope, such as a class overriding a global variable with its own.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda和已定义类型中的节点作用域定义和本地作用域定义是匿名的，只能通过其可见的名称直接访问。从当前作用域声明一个变量（例如，类覆盖全局变量）也可以覆盖更高作用域的变量。
- en: 'To show this, consider the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这一点，请考虑以下代码：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first `notify` would fail to find the local or node variable since it is
    in the global scope, and `testing` would be set to `testing123`. The second `notify`
    would directly access the local namespace, `example`, and print `localtest`. The
    third `notify` would be unable to access the local variable and would print `hello
    world`. The fourth `notify` would again access the local scope via the namespace.
    The final `notify` would be able to access all the variables, and `local` would
    be set to `localtest`. This example shows the flow of variables between scopes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`notify`无法找到本地或节点变量，因为它位于全局作用域，而`testing`将被设置为`testing123`。第二个`notify`将直接访问本地命名空间`example`，并打印`localtest`。第三个`notify`将无法访问本地变量，并打印`hello
    world`。第四个`notify`将再次通过命名空间访问本地作用域。最后一个`notify`将能够访问所有变量，并将`local`设置为`localtest`。此示例展示了变量在作用域之间的流动。
- en: Resource titles and resource references are unaffected by the scope and can
    be declared in any scope. For example, a resource can declare a dependency for
    any resource in the catalog. However, it is not good practice to rely on accessing
    external variables like this.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 资源标题和资源引用不受作用域的影响，可以在任何作用域中声明。例如，资源可以声明对目录中任何资源的依赖关系。然而，依赖于访问外部变量的做法并不推荐。
- en: Best practices and pitfalls
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践与陷阱
- en: In earlier versions of Puppet, scope, dependencies, and containment were some
    of the most challenging issues, which led to significant problems for newer developers.
    One major solution that largely addressed these issues was the widespread adoption
    of the roles and profiles method, which will be covered in full detail in [*Chapter
    8*](B18492_08.xhtml#_idTextAnchor212). Hiera data will be covered in [*Chapter
    9*](B18492_09.xhtml#_idTextAnchor233).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本的Puppet中，作用域、依赖关系和包含性是一些最具挑战性的问题，这导致了对新开发者的重大困扰。一项主要的解决方案是广泛采用角色和配置文件方法，这在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中将详细介绍。Hiera数据将在[*第9章*](B18492_09.xhtml#_idTextAnchor233)中进行详细讲解。
- en: The roles and profiles method involves grouping single-use component modules
    that perform one independent function well. For instance, a component module could
    install and configure Oracle. The module structure would contain a group of manifests
    with specific purposes, such as installing packages or managing services. This
    simplifies module organization and allows for the easier ordering of classes.
    For example, the `install` class can be applied before the `service` class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 角色和配置文件方法涉及将执行独立功能的单用途组件模块进行分组。例如，一个组件模块可以安装和配置Oracle。模块结构将包含一组具有特定目的的清单，如安装软件包或管理服务。这简化了模块的组织，并允许更容易地对类进行排序。例如，`install`类可以在`service`类之前应用。
- en: Component modules should function independently of one another and have no direct
    dependencies across modules. The profile layer groups modules together to create
    technology stacks and can put modules in order if necessary. Roles abstract another
    layer up to create business solutions using these technology stacks and can order
    the profiles. In this structure, any global or node data should come from Hiera
    instead of being set in node or global scopes, which reduces code complexity.
    It may feel counterintuitive to developers to avoid setting global variables in
    code, but following this practice is recommended.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 组件模块应该相互独立运行，并且模块之间没有直接的依赖关系。配置文件层将模块组合在一起以创建技术栈，并可以在必要时对模块进行排序。角色则抽象出另一层，利用这些技术栈创建业务解决方案，并可以对配置文件进行排序。在这种结构中，任何全局或节点数据应该来自Hiera，而不是在节点或全局作用域中设置，从而减少代码复杂性。对于开发者来说，避免在代码中设置全局变量可能会感觉不直观，但推荐遵循这一做法。
- en: As mentioned in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), it is advisable
    to avoid using resource collectors/exported resources. However, it is worth noting
    that they can be used as part of chaining arrows. Using them can be risky as it
    may result in unpredictable outcomes and create significant dependency cycles
    that are difficult to map until runtime. Dependencies should always be created
    as required, and you should not rely on manifest ordering for this purpose. Omitting
    these dependencies could significantly reduce code maintainability and create
    complications during future refactoring.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[*第3章*](B18492_03.xhtml#_idTextAnchor048)中提到的，建议避免使用资源收集器/导出的资源。然而，值得注意的是，它们可以作为链式箭头的一部分使用。使用它们可能具有风险，因为这可能导致不可预测的结果，并且可能产生难以在运行时映射的大量依赖循环。依赖关系应始终根据需要创建，不应依赖清单的顺序来实现这一点。省略这些依赖关系可能会显著降低代码的可维护性，并在未来重构时带来复杂性。
- en: Use chaining arrows for class dependencies and contain them only where necessary,
    as in the roles and profiles method. Avoid enforcing resource defaults globally,
    such as in `site.pp` or node definitions, as this approach makes the code unpredictable
    for everyone, especially when working with multiple application teams who may
    not be aware of these defaults in their own code. In summary, avoid attempting
    overly complex or familiar approaches from other languages and instead follow
    established roles/profiles and Hiera patterns. Review roles/profiles and Hiera
    patterns carefully and refactor any code that does not follow these guidelines.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链式箭头表示类依赖关系，并仅在必要时包含它们，如在角色和配置文件方法中所示。避免在全局范围内强制资源默认值，例如在`site.pp`或节点定义中，因为这种方法会使代码变得不可预测，特别是在与多个应用团队协作时，他们可能不了解自己代码中的这些默认值。总之，避免尝试过于复杂或从其他语言中借鉴的方式，应该遵循既定的角色/配置文件和Hiera模式。仔细审查角色/配置文件和Hiera模式，并重构任何不符合这些指导原则的代码。
- en: Lab – overview of relationships, ordering, and scope
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室 – 关系、顺序和范围概述
- en: In this lab, we will provide some code to review and run to ensure the concepts
    discussed are understood. All the code can be found at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch06](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch06).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，我们将提供一些代码进行回顾和运行，以确保理解所讨论的概念。所有代码都可以在 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch06](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch06)
    中找到。
- en: 'The code at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_1.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_1.pp)
    currently has no dependencies. To meet the following requirements, the code needs
    to be adjusted accordingly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_1.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_1.pp)
    中的代码目前没有依赖关系。为了满足以下要求，需要相应调整代码：'
- en: The `install` class and all its resources should run before `config` and `service`
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install` 类及其所有资源应在 `config` 和 `service` 之前运行'
- en: The `config` class and all its resources should run before `service`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config` 类及其所有资源应在 `service` 之前运行'
- en: The `service` class and all its resources should be refreshed if any resource
    in the `config` class is updated
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `config` 类中的任何资源被更新，则应刷新 `service` 类及其所有资源
- en: The `httpd` package should be installed before the `exampleapp` package
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpd` 包应在 `exampleapp` 包之前安装'
- en: The `exampleuser` user should be created after the `examplegroup` group
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exampleuser` 用户应在 `examplegroup` 组之后创建'
- en: The `/etc/exampleapp/` directory should be created after the `exampleuser` user
    and the `examplegroup` group
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应在创建 `exampleuser` 用户和 `examplegroup` 组之后创建 `/etc/exampleapp/` 目录
- en: The `/etc/exampleapp/exampleapp.conf` file should be created after the `exampleuser`
    user, the `examplegroup` group, and the `/``etc/exampleapp` directory
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应在创建 `exampleuser` 用户、`examplegroup` 组和 `/etc/exampleapp` 目录之后创建 `/etc/exampleapp/exampleapp.conf`
    文件
- en: The `httpd` service should start before the `exampleapp` service, and the `exampleapp`
    service should refresh if the `httpd` service restarts
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`httpd` 服务应在 `exampleapp` 服务之前启动，并且如果 `httpd` 服务重启，则应刷新 `exampleapp` 服务'
- en: It is recommended to use [https://validate.puppet.com/](https://validate.puppet.com/)
    to check your Puppet code, as you should not rely on manifest ordering alone.
    Additionally, it’s important to remember that some resources have auto-requirement
    behavior. A sample example is provided at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_2.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_2.pp).
    Examine the code and see what the `notify` function would print.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 建议使用 [https://validate.puppet.com/](https://validate.puppet.com/) 检查你的 Puppet
    代码，因为你不应仅仅依赖于清单顺序。此外，重要的是要记住某些资源具有自动依赖行为。一个示例可以在 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_2.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_2.pp)
    中找到。检查代码并查看 `notify` 函数将打印什么。
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: 'In this chapter, we discussed how resources are assumed to be applied in any
    order by default, and how metaparameters such as `before`, `require`, `notify`,
    and `subscribe` can be used to define any required order. We learned that DAGs
    can be used to visualize dependencies between resources, and that dependency cycles
    should be avoided to ensure the catalog can be applied successfully. We also discussed
    how certain resources automatically apply dependencies, such as a user requiring
    its primary group. The `notify` and `subscribe` metaparameters were explained,
    and their use of `refresh` was highlighted as particularly useful for resources
    such as `exec`, `package`, and `service`. This allows for these resources to be
    restarted, reinstalled, or rerun when necessary, such as when a configuration
    file changes. Additionally, we acknowledged that although resources should be
    assumed to have no order, they are in fact applied in the order they are written
    in a manifest to ensure consistency across environments. We also discussed the
    three types of errors that can occur: cyclic, missing dependencies, and dependent
    resource failures.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了资源默认按任何顺序应用的假设，以及如何使用元参数如`before`、`require`、`notify`和`subscribe`来定义所需的顺序。我们了解到，DAG（有向无环图）可以用来可视化资源之间的依赖关系，并且应该避免依赖关系的循环，以确保目录能够成功应用。我们还讨论了某些资源如何自动应用依赖关系，例如用户需要其主组。我们解释了`notify`和`subscribe`元参数，并特别强调它们在资源如`exec`、`package`和`service`中的`refresh`用法。这允许这些资源在必要时被重启、重新安装或重新运行，例如当配置文件发生变化时。此外，我们还承认，尽管资源应被假定没有特定顺序，但实际上它们会按清单中书写的顺序被应用，以确保在不同环境中的一致性。我们还讨论了三种可能发生的错误：循环依赖、缺失的依赖关系和依赖资源失败。
- en: After that, we discussed chaining arrows as a variation of metaparameters, allowing
    them to be used between classes. We emphasized that only right-facing arrows should
    be used to comply with the style guide. While metaparameters can be used on classes
    and chaining arrows on resources for consistency and styling, we recommend avoiding
    this practice. Instead, we showed that the `require` function can be used within
    a class that is dependent on another class for relatively simple class dependencies.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们讨论了作为元参数变体的链式箭头，允许它们在类之间使用。我们强调只有右向箭头应当被使用，以遵守样式指南。虽然元参数可以在类上使用，而链式箭头可以在资源上使用以保持一致性和样式，但我们建议避免这种做法。相反，我们展示了`require`函数如何在一个依赖于另一个类的类中使用，以处理相对简单的类依赖关系。
- en: We then discussed the issue of containment, which arises when including classes
    within other classes does not create resource dependencies. This was achieved
    using the `contain` function instead of an `include` function within a class causing
    this class to contain the other classes’ resources and creating the dependencies.
    We discussed how this may bring the temptation to contain all classes, but we
    demonstrated that this would create needless or cyclic dependencies. The older
    anchor pattern was shown since heritage code could still contain this. We highlighted
    that the `anchor` function is no longer a recommended approach and, where found,
    it should be modernized to use the `contain` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们讨论了封装问题，这个问题出现在将类包含在其他类中时，并未创建资源依赖关系。通过使用`contain`函数代替类中的`include`函数，达到了使该类包含其他类的资源并创建依赖关系的效果。我们讨论了这可能引发包含所有类的诱惑，但我们演示了这会创建不必要的或循环的依赖关系。我们展示了旧的锚点模式，因为遗留代码仍然可能包含这种模式。我们强调`anchor`函数不再是推荐的做法，且在发现时应当更新为使用`contain`函数。
- en: The scope was shown to affect variables and defaults for resources, where the
    global scope is anything set outside of the class, type, or node definition. The
    node scope is anything in a node definition and the local scope is anything in
    a class, type, or lambda.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域影响着变量和资源的默认值，其中全局作用域指的是类、类型或节点定义之外设置的任何内容。节点作用域是指节点定义中的任何内容，而局部作用域是指类、类型或lambda中的任何内容。
- en: Finally, for best practice, it is recommended to follow the roles and profiles
    method to ensure consistency in dependencies and ordering. It is also recommended
    to use Hiera instead of complex variable usage and to avoid setting resource defaults
    in the global scope, such as `site.pp` or node definitions. It is important to
    never rely on manifest ordering, use explicit dependencies to ensure consistency.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为最佳实践，建议遵循角色和配置文件方法，以确保依赖关系和顺序的一致性。还建议使用 Hiera 代替复杂的变量使用，并避免在全局范围内设置资源默认值，例如
    `site.pp` 或节点定义。重要的是，绝不要依赖清单的顺序，应该使用显式依赖关系来确保一致性。
- en: The next chapter will explore templates, iteration, and conditional statements
    in Puppet. It will demonstrate how Puppet can generate file content by leveraging
    variables, conditions, and text manipulation functions. Additionally, it will
    explain how iterative functions and lambda code sections enable Puppet to loop
    through and manipulate collections of data. Finally, the chapter will cover the
    usage of conditional statements in Puppet to create different configurations based
    on conditional logic.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将探讨 Puppet 中的模板、迭代和条件语句。它将展示如何通过利用变量、条件和文本处理函数，Puppet 能够生成文件内容。此外，还将解释如何通过迭代函数和
    Lambda 代码块，Puppet 能够循环处理并操作数据集合。最后，本章将介绍如何在 Puppet 中使用条件语句，根据条件逻辑创建不同的配置。
