- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Continuous Integration of Solution Development
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案开发的持续集成
- en: After PI planning, the teams on the ART are set to work. They’ll look at the
    outputs of Continuous Exploration and the features selected for the PI and carry
    them to the next stage of the Continuous Delivery Pipeline, **Continuous** **Integration**
    (**CI**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PI 规划后，ART 上的团队开始工作。他们将查看持续探索的产出以及为 PI 选择的功能，并将其带入持续交付管道的下一个阶段，即**持续** **集成**（**CI**）。
- en: 'In this chapter, we will discover the following activities in the CI stage
    of the Continuous Delivery Pipeline:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍在持续交付管道的 CI 阶段中进行的以下活动：
- en: Developing the solution
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发解决方案
- en: Building the solution package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建解决方案包
- en: Performing end-to-end testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行端到端测试
- en: Moving the packages to a staging environment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将包移到预发布环境
- en: We will also discover that the processes described in the Continuous Delivery
    Pipeline will meet up with automation in a **CI**/**Continuous Deployment** (**CD**)
    pipeline in the CI stage.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将发现，持续交付管道中描述的过程将在 CI 阶段与自动化相结合，形成**CI**/**持续部署**（**CD**）管道。
- en: Let’s join the ART now as they develop a solution as defined by the features
    created during Continuous Exploration.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们加入 ART，随着他们根据持续探索阶段创建的功能开发解决方案。
- en: Developing the solution
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发解决方案
- en: Teams on an ART work in markedly different ways than those that worked in product
    development using waterfall methodologies. An emphasis on Lean thinking and a
    focus on the system dictates newer ways of working.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ART 团队的工作方式与使用瀑布方法的产品开发团队有很大不同。强调精益思维并聚焦于系统决定了新的工作方式。
- en: 'We will examine the following aspects of engineering practices that are used
    by Agile teams today:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究今天敏捷团队使用的以下工程实践：
- en: Breaking down the work
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将工作分解
- en: Collaborative development
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协作开发
- en: Building in quality
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建质量
- en: Version control
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本控制
- en: Designing to the system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向系统的设计
- en: These practices strive to allow for a continuous flow of work, ready for the
    next state of building.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实践旨在实现工作流的持续流动，为下一个构建状态做好准备。
- en: Breaking down into stories
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将工作分解为故事
- en: An important part of the Lean flow we picked up on in [*Chapter 4*](B18756_04.xhtml#_idTextAnchor086),
    *Leveraging* *Lean Flow to Keep the Work Moving*, was to keep batch sizes small.
    A feature, as presented to us before PI planning, is a large batch of work, meant
    to be completed by the end of the PI. In order to ensure a smooth flow of work,
    the feature must be broken down into smaller batches of work.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B18756_04.xhtml#_idTextAnchor086)中学习到的精益流程的重要部分是保持批次规模小。一个功能，在 PI
    规划之前呈现给我们，是一个大批次的工作，计划在 PI 结束时完成。为了确保工作流的顺畅，功能必须分解成更小的工作批次。
- en: 'User stories often describe small pieces of desired user functionality meant
    to be delivered by the end of a sprint or iteration, which is commonly two weeks.
    They are commonly phrased in a user-voice form that briefly explains who the story
    is for and what the desired functionality and intended value are. An example follows
    of the user-voice form:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事通常描述了在冲刺或迭代结束时需要交付的小块用户功能，通常为两周。它们通常以用户语气的形式表达，简要说明该故事是为谁准备的，以及所需的功能和预期的价值。以下是用户语气形式的示例：
- en: '*As a* customer, *I want* an itemized receipt of services emailed monthly *so
    that* I can understand and organize my spending.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为*客户，*我想要*每月收到一份详细的服务收据，*以便*我可以了解并整理我的开支。'
- en: An essential part of the story is its acceptance criteria. The acceptance criteria
    outline the correct behavior of the story and are the way the team determines
    that the story is complete.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 故事的一个关键部分是其接受标准。接受标准概述了故事的正确行为，是团队判断故事是否完成的方式。
- en: Acceptance criteria can be written using the Gherkin format. This helps outline
    pre-conditions, inputs, and the desired behavior and outputs. These are described
    in clauses that begin with GIVEN-WHEN-THEN.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接受标准可以使用 Gherkin 格式编写。这有助于概述前置条件、输入、所需的行为和输出。这些在以 GIVEN-WHEN-THEN 开头的条款中进行描述。
- en: 'The following example of acceptance criteria for our story is written in the
    Gherkin format. Note how it describes the initial conditions, inputs, and outputs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们故事的接受标准示例，采用 Gherkin 格式编写。注意它是如何描述初始条件、输入和输出的：
- en: '| **Initial conditions** | **GIVEN I have configured the** **notification date…**
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| **初始条件** | **假设我已经配置了** **通知日期…** |'
- en: '| Input | …WHEN the notification date passes… |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | …当通知日期过去时… |'
- en: '| Output or desired behavior | …THEN I receive an email notification containing
    my itemized receipts. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 输出或期望的行为 | …然后我收到一封包含我项目清单的电子邮件通知。 |'
- en: 'Table 11.1: Acceptance criteria in the Gherkin format'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 11.1：Gherkin 格式的验收标准
- en: Enabler stories can also come from features. These stories do not provide direct
    user value but allow for easier development and architectural capability for future
    user stories, creating future business value. SAFe® outlines the following four
    types of enablers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使能故事也可以来自功能。这些故事不直接为用户提供价值，但为未来用户故事的开发和架构能力提供便利，从而创造未来的业务价值。SAFe®列出了以下四种类型的使能者。
- en: Infrastructure
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施
- en: Architectural
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构
- en: Exploration
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索
- en: Compliance
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合规性
- en: Splitting a feature into *user* and *enabler* stories can be done in a variety
    of ways. The following methods can be used to create stories that can be completed
    in a sprint.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个功能拆分成*用户*故事和*使能*故事可以通过多种方式完成。以下方法可以用来创建可以在短冲刺中完成的故事。
- en: '**Workflow steps**: Set up stories to perform the necessary steps of a workflow
    first. The other steps can be released in later sprints.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流步骤**：首先设置故事来执行工作流的必要步骤。其他步骤可以在后续冲刺中发布。'
- en: '**Variations of a business rule**: Divide up stories according to different
    rules for business, such as different classes of service, different product lines,
    and so on.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**业务规则的变异**：根据不同的业务规则划分故事，例如不同的服务等级、不同的产品线等。'
- en: '**Major effort**: Examine the possible stories that could be followed. Pick
    the story that appears to be most difficult to do first.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重大工作量**：检查可以遵循的可能故事。首先选择看起来最难完成的故事。'
- en: '**Simple vs. complex**: When evaluating the feature, is there a story that
    could be written that would provide the core functionality? That’s the first story
    to work. Subsequent stories would elaborate on the core functionality.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单与复杂**：在评估功能时，是否有一个可以编写的故事来提供核心功能？那就是要先做的第一个故事。后续的故事将进一步详细说明核心功能。'
- en: '**Variations present in data**: Start with a story that works with one data
    type and move to different stories to handle the other data types.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据中的变异**：从一个适用于某种数据类型的故事开始，然后转到处理其他数据类型的不同故事。'
- en: '**Different data entry methods**: Start by creating a story that enters the
    data manually, then progress with further stories with automated data entry.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的数据输入方法**：首先创建一个手动输入数据的故事，然后逐步推进自动化数据输入的后续故事。'
- en: '**Different system qualities**: One example of system qualities could be the
    different devices or interfaces our application would work with and establishing
    a story for each.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同的系统特性**：系统特性的一种示例可能是我们的应用程序将与不同的设备或接口配合使用，并为每个设备或接口建立一个故事。'
- en: '**By operation**: Divide into stories that handle different operations. A common
    breakdown is **Create, Read, Update, and** **Delete** (**CRUD**).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按操作**：将故事划分为处理不同操作的部分。常见的划分方法是**创建、读取、更新和删除**（**CRUD**）。'
- en: '**Use case scenarios**: Create a story for every use case.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用场景**：为每个使用场景创建一个故事。'
- en: '**Setting a spike and follow-up**: A spike is used to set aside development
    time to research a technical approach or an unknown. Once the research is complete,
    proceed with stories that implement the approach.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设置突发任务与后续工作**：突发任务是用来安排开发时间，研究一种技术方法或解决未知问题。一旦研究完成，就继续进行实现该方法的故事。'
- en: Note that splitting a large story further may be required so that the story
    can be completed and delivered by the end of the sprint. The preceding methods
    can be used to split larger stories into smaller stories.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可能需要进一步拆分大型故事，以便在短冲刺结束时完成并交付该故事。前述方法可以用来将较大的故事拆分成较小的故事。
- en: Collaborative development
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作开发
- en: Although teams can choose how they develop their stories, high-performing teams
    have found that team members working together instead of working solo produces
    higher quality products and enables effective knowledge sharing, and this creates
    stronger, more collaborative teams.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然团队可以选择如何开发他们的故事，但高效能团队发现，与其单独工作，不如团队成员一起合作，能够生产出更高质量的产品，并实现有效的知识共享，从而创造出更强大、更具协作性的团队。
- en: 'In this section, we’ll discuss two practices that allow teams to collaboratively
    develop products together, promoting better quality and stronger team cohesion:
    pair programming and mob programming or swarming.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论两种允许团队共同开发产品的实践，促进更好的质量和更强的团队凝聚力：配对编程和集体编程（或集群编程）。
- en: Pair programming
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配对编程
- en: Pair programming is a practice that originated with **Extreme Programming**
    (**XP**). Instead of two developers working separately in front of two computers,
    the developers are working in front of a shared computer, exchanging ideas back
    and forth, and simultaneously coding and reviewing their work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对偶编程是一种源自**极限编程**（**XP**）的实践。与其让两位开发者在两台电脑前分别工作，不如让他们在一台共享电脑前共同工作，相互交换想法，同时进行编码和审查工作。
- en: With two developers working together, the following patterns emerge for how
    they collaborate.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当两位开发者一起工作时，以下模式是他们协作的体现。
- en: '**Driver/navigator**: In this pattern, one developer takes control of the computer
    (driver) while the other developer reviews and guides by commenting on what is
    typed on the screen (navigator). At certain times during the session, the roles
    are switched. This is the most common pattern used in pair programming. This pattern
    is frequently used when one of the developers is an expert programmer paired with
    a novice.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**驾驶员/导航员**：在这种模式中，一位开发者掌控电脑（驾驶员），而另一位开发者通过评论屏幕上输入的内容来审查并提供指导（导航员）。在会议的某些时段，角色会进行交换。这是对偶编程中最常用的模式。通常，当一位开发者是专家级程序员，而另一位是新手时，这种模式尤其有效。'
- en: '**Unstructured**: In this ad hoc style of pair programming, there are no set
    roles for the developers. The collaboration tends to be unguided and loose. Typically,
    this pattern is adopted when neither developer knows what approach will work.
    This pattern works well with developers that are at similar levels of expertise,
    but two novice developers may have problems working with this approach.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无结构模式**：在这种临时的对偶编程风格中，开发者之间没有固定的角色。协作往往是没有明确指导和松散的。通常，在两位开发者都不确定哪种方法有效时会采用这种模式。这种模式适合技术水平相近的开发者，但对于两位初学者来说，可能会遇到一些问题。'
- en: '**Ping-pong**: This pattern is frequently used where one developer writes the
    test and the other developer works to pass the test. The developers switch roles
    frequently between writing the tests and writing code to pass the tests. This
    style works well with two developers at an advanced level.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**乒乓编程**：这种模式通常由一位开发者编写测试，另一位开发者则为通过测试而进行工作。两位开发者在编写测试和编写通过测试的代码之间频繁切换角色。这种风格适合两位经验丰富的开发者。'
- en: Pair programming has proven to be an effective way of working together. Code
    written during a pair programming session is frequently reviewed and debugged,
    resulting in higher-quality code. Knowledge is shared between developers, creating
    faster learning for novices or those new to the code base. If the code breaks,
    there is also more than a single developer with an understanding of the code that
    can help with repairs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对偶编程已被证明是一种有效的协作方式。在对偶编程过程中编写的代码通常会进行审查和调试，从而产生高质量的代码。知识在开发者之间共享，加速了初学者或不熟悉代码库的开发者的学习。如果代码出现问题，通常不仅仅有一个开发者了解代码，可以帮助修复问题。
- en: A common misconception is that pair programming requires twice the effort or
    resources. This belief is not supported by studies done on the effectiveness of
    pair programming, including one done by the University of Utah ([https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF](https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF))
    that found that while development costs increased by 15%, defects discovered at
    later stages decreased by 15% and code functionality was accomplished using fewer
    lines of code, which is a sign of better design quality.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是对偶编程需要双倍的努力或资源。然而，这一观点并没有得到对偶编程有效性研究的支持，包括犹他大学进行的一项研究（[https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF](https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF)），该研究发现，虽然开发成本增加了15%，但在后期阶段发现的缺陷减少了15%，且代码功能实现时所用的代码行数更少，这表明设计质量更高。
- en: Mob programming or swarming
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 团队编程或集体编程
- en: Mob programming can be considered to be pair programming taken to the highest
    level. Instead of a pair of developers, the entire team is seated in front of
    a single computer and controls. The team is working on the same thing, in the
    same time and space, and on the same computer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 集体编程可以看作是对偶编程的最高级形式。不同于只有一对开发者，整个团队都围坐在一台电脑前进行操作。团队成员们在相同的时间和空间里，在同一台电脑上共同工作。
- en: A typical pattern for this is a variation of the driver/navigator pattern. One
    person on the team has control of the computer, typing and creating the code or
    other pieces of work. The other members of the team review and guide the driver
    as navigators. After some time (usually 10 minutes), the controls are rotated
    to another member of the team. The rotation continues until all members of the
    team have had an opportunity to play the driver.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种典型的模式是一种驱动者/导航者模式的变体。团队中的一个人控制计算机，输入并创建代码或其他工作部分。团队的其他成员作为导航者审查并指导驱动者。经过一段时间（通常为10分钟），控制权会轮换到团队中的另一成员。轮换会持续进行，直到所有团队成员都有机会担任驱动者。
- en: Mob programming benefits the entire team. Knowledge sharing of the code is applied
    to the entire team, instead of a pair of developers. Communication is easier with
    the entire team present. Decisions are made with the most current and relevant
    information.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 集体编程有利于整个团队。代码的知识共享适用于整个团队，而不仅仅是一对开发人员。整个团队都在场时，沟通变得更容易。决策基于最当前和相关的信息。
- en: Building in quality by “shifting left”
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过“向左转移”来构建质量
- en: 'During this time, not only is the product being developed but the ways of ensuring
    that the product is high-quality are also being developed simultaneously. This
    is a change from traditional development where tests were created and run after
    the development of code. This change is often referred to as *shifting left* as
    illustrated in the following representation of the development process. This is
    one of the important practices in SAFe, which is described in more detail in the
    SAFe article on *Built-In* *Quality* ([https://www.scaledagileframework.com/built-in-quality/](https://www.scaledagileframework.com/built-in-quality/)):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '在此期间，不仅产品在开发中，同时确保产品质量的方法也在同时开发。这与传统开发方式有所不同，传统开发是在代码开发后才创建并运行测试。这一变化通常被称为*向左转移*，如下面的开发过程表示所示。这是SAFe中的一项重要实践，更多细节可参考SAFe文章《内建质量》([https://www.scaledagileframework.com/built-in-quality/](https://www.scaledagileframework.com/built-in-quality/)):'
- en: '![Figure 11.1 – Comparison of testing with “shift left” (© Scaled Agile, Inc.,
    All Rights Reserved)](img/B18756_11_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 与“向左转移”比较的测试（© Scaled Agile, Inc.，版权所有）](img/B18756_11_01.jpg)'
- en: Figure 11.1 – Comparison of testing with “shift left” (© Scaled Agile, Inc.,
    All Rights Reserved)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 与“向左转移”比较的测试（© Scaled Agile, Inc.，版权所有）
- en: In the preceding diagram, we see on the left that traditional testing may test
    stories and features long after the stories and features were originally conceived.
    This delayed feedback may take as long as 3 to 6 months, which may be too late
    to know whether we are moving in the right direction.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，我们可以看到，传统的测试可能在故事和功能最初构思后很长一段时间才进行测试。这个延迟的反馈可能需要长达3到6个月的时间，这可能太晚了，无法知道我们是否朝着正确的方向前进。
- en: With the diagram on the right, we see that we can accelerate the feedback using
    TDD and BDD tests to evaluate whether the behaviors of the feature and story are
    what is desired. Ideally, these tests should be automated so that they can be
    run repeatedly and quickly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从右侧的图示中，我们看到可以通过TDD和BDD测试加速反馈，以评估功能和故事的行为是否符合预期。理想情况下，这些测试应当自动化，以便能够反复快速运行。
- en: Another thing we can see from the preceding diagram is that there are many levels
    of tests, some of which should be run repeatedly with the help of automation,
    and others that may take some time or can only be run manually. How do we know
    which tests to automate and which tests should be run frequently?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从前面的图示中看到，测试有多个层级，其中一些应通过自动化反复运行，而另一些可能需要一些时间或只能手动运行。我们如何知道哪些测试应该自动化，哪些测试应该频繁运行呢？
- en: Mike Cohn described the levels of testing as a “testing pyramid” in his book
    *Succeeding with Agile*. He initially described the pyramid with the following
    three levels from bottom to top.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mike Cohn在他的书《成功的敏捷》中将测试层级描述为“测试金字塔”。他最初描述了以下三个从下到上的层级。
- en: Unit testing
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Service testing
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务测试
- en: UI testing
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI 测试
- en: 'Other types of testing can be added and applied to the testing pyramid. This
    allows us to view the testing pyramid as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型的测试可以添加到测试金字塔中并加以应用。这使得我们可以如下图所示查看测试金字塔：
- en: '![Figure 11.2 – Test pyramid](img/B18756_11_02.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2 – 测试金字塔](img/B18756_11_02.jpg)'
- en: Figure 11.2 – Test pyramid
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 测试金字塔
- en: Note that at the bottom of the pyramid, unit tests are both the quickest to
    execute and the cheapest to run. It makes sense to automate their execution in
    the pipeline and frequently run them at every commit into version control, ideally
    during the build phase.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在金字塔的底部，单元测试是执行速度最快且成本最低的。将它们的执行自动化并频繁运行是明智之举，理想情况下应该在每次提交版本控制时，尤其是在构建阶段执行。
- en: As you move further up the pyramid, the tests gradually take longer to execute
    and are more expensive. Those tests may not be run as frequently as unit tests.
    They may be executed through automation, but only upon entering the testing phase.
    Examples of these types of tests include story testing from BDD, integration testing,
    performance testing, and security testing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你向金字塔的上方移动，测试的执行时间逐渐增加，成本也变得更高。这些测试可能不会像单元测试那样频繁运行。它们可能通过自动化执行，但只会在进入测试阶段时运行。这些测试的例子包括来自
    BDD 的故事测试、集成测试、性能测试和安全测试。
- en: The tests at the top of the pyramid take the longest to execute and are also
    the most expensive to run. These are mostly manual tests. These tests may be run
    just before release. Examples of testing here include user acceptance testing
    and exploratory testing done by the customer.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 金字塔顶部的测试需要最久的执行时间，且也是最昂贵的。这些大多是手动测试。这些测试可能会在发布前运行。此处的测试示例包括用户验收测试和由客户进行的探索性测试。
- en: 'Most tests look to verify either proper code functionality and correctness
    as well as verification of the behaviors of the story and feature. The primary
    methods of creating tests to measure these criteria fall into the following methods:
    TDD and BDD. Let’s look at how these tests are developed.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数测试旨在验证代码的正确性和功能性，以及验证故事和特性的行为。创建测试以衡量这些标准的主要方法包括：TDD 和 BDD。让我们来看看这些测试是如何开发的。
- en: TDD
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD
- en: 'TDD is a practice derived from XP. With TDD, you practice the following flow:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 是源自 XP 的一种实践。在 TDD 中，你会遵循以下流程：
- en: Create the test. This is done to understand the behavior.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建测试。这是为了理解行为。
- en: Watch the test fail (even with no code written). This gives us confidence in
    the test execution environment and demonstrates system behavior when a test fails.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察测试失败（即使没有写任何代码）。这让我们对测试执行环境有信心，并展示了测试失败时系统的行为。
- en: Write the simplest code necessary to pass the test.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写通过测试所需的最简单代码。
- en: Ensure all tests pass. This may mean any new code created is revised until the
    tests pass.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有测试通过。这意味着任何新创建的代码都需要经过修订，直到测试通过为止。
- en: Refactor the tests and code as needed.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据需要重构测试和代码。
- en: 'This flow is repeated as new functionality is developed. A graphical representation
    of this flow is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新功能的开发，这个流程会重复进行。这个流程的图形表示如下：
- en: '![Figure 11.3 – TDD (https://en.wikipedia.org/wiki/Test-driven_development#/media/File:TDD_Global_Lifecycle.png
    licensed under CC BY-SA)](img/B18756_11_03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – TDD（[https://en.wikipedia.org/wiki/Test-driven_development#/media/File:TDD_Global_Lifecycle.png](https://en.wikipedia.org/wiki/Test-driven_development#/media/File:TDD_Global_Lifecycle.png)
    根据 CC BY-SA 许可证授权)](img/B18756_11_03.jpg)'
- en: Figure 11.3 – TDD (https://en.wikipedia.org/wiki/Test-driven_development#/media/File:TDD_Global_Lifecycle.png
    licensed under CC BY-SA)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – TDD（[https://en.wikipedia.org/wiki/Test-driven_development#/media/File:TDD_Global_Lifecycle.png](https://en.wikipedia.org/wiki/Test-driven_development#/media/File:TDD_Global_Lifecycle.png)
    根据 CC BY-SA 许可证授权）
- en: The tests usually written using TDD are unit tests; small, easily executed tests
    designed to verify the correct functionality of a code module. Broader tests use
    BDD to develop tests that verify the systemic behavior of features and stories.
    Let’s look at BDD now.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用 TDD 编写的测试是单元测试；小型、易于执行的测试，旨在验证代码模块的正确功能。更广泛的测试使用 BDD 来开发验证特性和故事的系统行为的测试。现在让我们来看看
    BDD。
- en: BDD
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BDD
- en: BDD is often seen as an extension of TDD, but while TDD looks to verify the
    correct behavior of individual code functions and components, BDD strives to verify
    the correct behavior of the system as an executable specification expressed in
    features and stories. One application of BDD was seen earlier in this chapter
    when we created the acceptance criteria for the story.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: BDD 通常被视为 TDD 的扩展，但与 TDD 侧重于验证单个代码功能和组件的正确行为不同，BDD 力求验证系统作为可执行规格的正确行为，这些规格通过特性和故事来表达。在本章的早些时候，我们创建了故事的接受标准，这是
    BDD 的一种应用。
- en: 'Looking at the correct systemic behavior involves three perspectives that work
    together to bring their point of view of what is eventually specified, what is
    developed, and what gets tested as correct. The following three perspectives include
    the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 查看正确的系统行为涉及三个互相协作的视角，这些视角帮助确定最终的规格、开发内容以及作为正确测试的内容。以下是这三种视角：
- en: Customers who understand the business needs and look for the desirability and
    viability of new features
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解业务需求并寻找新功能的可取性和可行性的客户
- en: Developers who understand the feasible technical approaches
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可行技术方法的开发人员
- en: Testers who view the edge cases and boundary conditions of the systemic behavior
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看系统行为的边界条件和边缘案例的测试人员
- en: 'BDD brings these three perspectives together using specifications. These specifications
    are written in a **Domain-Specific Language** (**DSL**) that employs natural language
    syntax so that technical and non-technical people can collaboratively develop
    the specification. One of these DSLs is Gherkin, which divides behavior into the
    following three clauses:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: BDD通过使用规范将这三种视角结合在一起。这些规范使用**领域特定语言**（**DSL**）编写，采用自然语言语法，使技术人员和非技术人员能够协同开发规范。这些DSL之一是Gherkin，它将行为划分为以下三个部分：
- en: '**GIVEN** outlines the initial conditions that must be present for the desired
    behavior in a scenario'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GIVEN** 概述了场景中期望行为所需的初始条件'
- en: '**WHEN** describes the input that triggers a scenario'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**WHEN** 描述了触发场景的输入'
- en: '**THEN** describes the desired behavior for the scenario'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**THEN** 描述了场景的期望行为'
- en: Multiple GIVEN, WHEN, and THEN clauses may be joined together using **AND**
    to indicate multiple conditions, inputs, and behaviors accordingly
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用**AND**将多个GIVEN、WHEN和THEN条款连接在一起，以表示多个条件、输入和行为。
- en: The specification, using the DSL, can become several artifacts. Product owners
    and product management create the acceptance criteria for features and stories
    with the other members of the development teams. The creation of acceptance criteria
    can be seen as the discovery of the desired systemic behavior.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DSL的规范可以变成多个工件。产品负责人和产品管理人员与开发团队的其他成员一起创建功能和故事的验收标准。验收标准的创建可以看作是对期望系统行为的发现。
- en: The next phase of creating the specification is formulation. In this phase,
    developers and testers work together to create acceptance tests. They can take
    the acceptance criteria as written and elaborate specific criteria in each clause,
    including allowable initial conditions and values to measure for inputs and outputs
    so that the specification for a specific scenario becomes a test. Ideally, acceptance
    tests are written in the same DSL as the acceptance criteria.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建规范的下一个阶段是制定。在此阶段，开发人员和测试人员共同合作，创建验收测试。他们可以根据写好的验收标准，详细阐述每个条款中的具体标准，包括允许的初始条件和测量输入与输出的值，从而使得某一特定场景的规范变成一项测试。理想情况下，验收测试应使用与验收标准相同的领域特定语言（DSL）编写。
- en: 'We can create an automated test by taking the acceptance criteria for our story
    and adding specific pre-conditions, input, and desired output or behavior. Let’s
    look at our previously seen acceptance criteria converted into a test in the following
    table:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过采用故事的验收标准，并添加特定的前置条件、输入和期望的输出或行为，来创建自动化测试。让我们看看之前看到的验收标准如何转化为测试，见下表：
- en: '| **Acceptance Criteria** | **Test** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **验收标准** | **测试** |'
- en: '| GIVEN I have configured the notification date… | Given the date state is
    not x… |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| GIVEN 我已配置通知日期… | 给定日期状态不是x… |'
- en: '| …WHEN the notification date passes… | …when it’s one business day after the
    date state has changed to x… |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| …WHEN 通知日期过去… | …当日期状态变为x之后一个工作日… |'
- en: '| …THEN I receive an email notification containing my itemized receipts. |
    …then send an email notification to all users with xxx content. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| …THEN 我收到一封包含明细收据的电子邮件通知。 | …然后向所有用户发送包含xxx内容的电子邮件通知。 |'
- en: Table 11.2 – Conversion of acceptance criteria into a test
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2 – 将验收标准转换为测试
- en: The last phase of the specification is automation. The acceptance test, written
    in the DSL, can be executed in a tool that allows for automated testing. Acceptance
    tests written in Gherkin can be executed by tools such as Cucumber, JBehave, Lettuce
    Behave, and Behat.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的最后一个阶段是自动化。用DSL编写的验收测试可以在支持自动化测试的工具中执行。用Gherkin编写的验收测试可以通过如Cucumber、JBehave、Lettuce
    Behave和Behat等工具执行。
- en: Version control
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制
- en: Version control software allows for multiple developers on a team to develop
    in parallel on the same code base, test scripts, or other bodies of text without
    interference from other developers’ changes. Each change in the version control
    system is recorded. Changes are consolidated using merge operations to bring together
    and resolve changes in the bodies of work.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制软件允许团队中的多个开发者在相同的代码库、测试脚本或其他文本上并行开发，而不受其他开发者更改的干扰。版本控制系统中的每个更改都会被记录。通过合并操作整合更改，解决工作内容中的变动。
- en: 'Important practices for the use of version control include the following ideas:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用版本控制的重要实践包括以下几个方面：
- en: '**Save EVERYTHING in version control**: A lot of design decisions are captured
    as artifacts in version control beyond source code. Code, test scripts, configuration
    files, and any other text-based artifacts can be tagged together to show they
    are part of the same release. Version control also allows for the retrieval of
    previous versions to roll back any changes or to view the evolution of design
    decisions.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将所有内容都保存在版本控制中**：许多设计决策作为工件被记录在版本控制中，超越了源代码的范畴。代码、测试脚本、配置文件以及任何其他基于文本的工件可以一起标记，表示它们是同一个发布版本的一部分。版本控制还允许检索先前的版本，回滚任何更改或查看设计决策的演变过程。'
- en: '**Everyone uses the same version control system**: As we saw in [*Chapter 1*](B18756_01.xhtml#_idTextAnchor014),
    *Introducing SAFe® and DevOps*, the photo-sharing website Flickr had a common
    version control system between its development and operations people. This allowed
    for the easy retrieval of artifacts by anyone when production failures occurred.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个人都使用相同的版本控制系统**：正如我们在[*第1章*](B18756_01.xhtml#_idTextAnchor014)《引入SAFe®与DevOps》中看到的，照片分享网站Flickr的开发和运维人员之间使用的是相同的版本控制系统。这使得当生产故障发生时，任何人都可以轻松检索工件。'
- en: Other best practices of version control that take place during the build process
    will be identified in our next section.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一部分中介绍构建过程中进行的其他版本控制最佳实践。
- en: Designing to the system
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向系统的设计
- en: The features and stories are not the only criteria teams have to consider when
    developing new capabilities for their product. **Non-Functional Requirements**
    (**NFRs**) are qualities that may impact every feature and story acting as a constraint
    or limitation. These NFRs may deal with security, compliance, performance, scalability,
    and reliability, among other things
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 特性和故事并不是团队在为其产品开发新能力时唯一需要考虑的标准。**非功能需求**（**NFRs**）是可能影响每个特性和故事的质量，它们作为一种约束或限制。这些NFRs可能涉及安全性、合规性、性能、可扩展性和可靠性等方面。
- en: 'Two practices are performed to ensure compliance with some NFRs: designing
    for operations and threat modeling. Let’s take a look at these practices.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种实践可确保符合某些NFRs：面向运维的设计和威胁建模。让我们来看看这些实践。
- en: Designing for operations
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向运维的设计
- en: The collaboration between development and operations is a hallmark of the DevOps
    movement. Ensuring that operations can easily examine system resources is something
    that is easily incorporated in the early stages of development rather than added
    as an afterthought.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 开发与运维之间的协作是DevOps运动的一个标志。确保运维可以轻松检查系统资源，是在开发初期容易纳入的内容，而不是事后才考虑的。
- en: A key part of ensuring capabilities are present for proper maintenance of the
    product is application telemetry. The product as a system must allow for the easy
    measurement of system resources, including how an application uses resources such
    as server memory and storage. In addition to system measurements, application
    telemetry should also allow for the measurement of business data, used as a leading
    indicator to validate the benefit hypothesis.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 确保产品维护所需能力的关键部分是应用遥测。作为一个系统，产品必须允许轻松衡量系统资源，包括应用程序如何使用服务器内存和存储等资源。除了系统度量，应用遥测还应允许衡量商业数据，用作验证收益假设的领先指标。
- en: Other considerations include ensuring that changes brought by new features can
    be easily rolled back or that fixes can be rolled forward through the Continuous
    Delivery Pipeline. When doing this, be aware of components that may represent
    the state of the system, such as a database. These may not be easily rolled back.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 其他考虑因素包括确保新特性带来的变化可以轻松回滚，或者修复可以通过持续交付管道向前推进。在进行这些操作时，需要注意可能代表系统状态的组件，例如数据库。这些组件可能无法轻松回滚。
- en: Threat modeling
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 威胁建模
- en: Moving toward a DevSecOps approach requires a *shift-left* mindset toward security.
    This mindset allows for including security concerns in the design and development
    stages of the Continuous Delivery Pipeline, which gives a more holistic view of
    the product.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 向DevSecOps方法迈进需要一种*向左转*的安全思维方式。这种思维方式可以在持续交付流水线的设计和开发阶段考虑安全问题，从而对产品有一个更全面的视角。
- en: 'We first saw that threat modeling was part of architecting the system in [*Chapter
    10*](B18756_10.xhtml#_idTextAnchor221), *Continuous Exploration and Finding New
    Features*. As part of threat modeling during CI, we may be asking the following
    questions:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在[*第10章*](B18756_10.xhtml#_idTextAnchor221)《持续探索与发现新特性》中看到，威胁建模是架构系统的一部分。作为持续集成过程中威胁建模的一部分，我们可能会问以下问题：
- en: What are we working on? This helps you get an idea of the scope.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在做什么？这有助于你了解工作的范围。
- en: What can go wrong with it? This allows you to start your assessment using brainstorming
    or a structured threat modeling process, such as the **Application Security Framework**
    (**ASF**) or **Spoofing, Tampering, Repudiation, Information Disclosure, Denial
    of Service, or Elevation of Privilege** (**STRIDE**), which identifies the types
    of possible information security threats.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能会出什么问题？这让你可以通过头脑风暴或结构化的威胁建模过程（例如**应用安全框架**（**ASF**）或**欺骗、篡改、拒绝、信息泄露、服务拒绝或特权提升**（**STRIDE**））开始你的评估，后者识别可能的网络安全威胁类型。
- en: What can we do about the things that go wrong? Based on the assessment, devise
    countermeasures or mitigation steps.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们能做些什么来解决出现的问题？根据评估，制定对策或缓解步骤。
- en: Are we doing a good enough job so far for the system as is? Continually evaluate
    the assessment, countermeasures, and mitigation steps.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止，我们为现有系统做得够好吗？持续评估评估、对策和缓解步骤。
- en: Developing toward DevSecOps is then based on the countermeasures and mitigation
    steps identified during the assessment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 向DevSecOps发展基于评估过程中识别的对策和缓解步骤。
- en: As development changes are completed, they must be integrated with the current
    product as it stands and be tested. This may start the incorporation of automation
    into a CI/CD pipeline. Next, let’s examine how entry into the CI/CD pipeline begins
    with a build process.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发更改的完成，它们必须与现有产品集成并进行测试。这可能会开始将自动化纳入CI/CD流水线。接下来，让我们看看如何通过构建过程开始进入CI/CD流水线。
- en: Building the solution package
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建解决方案包
- en: The CI/CD pipeline can be triggered by version control system actions such as
    saving a new change as a commit. Before the changes are accepted by the version
    control system, they should go through a testing process to ensure they will not
    adversely affect the current code base. This process of testing and version control
    integration is an important part of the CI process where practices are divided
    into a version control perspective and a testing perspective.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD流水线可以通过版本控制系统中的操作触发，例如将新更改保存为提交。在版本控制系统接受更改之前，它们应该经过测试过程，以确保不会对当前的代码库产生不良影响。这个测试和版本控制集成的过程是CI过程中的一个重要部分，其中实践分为版本控制视角和测试视角。
- en: Let’s look at each of these perspectives and the practices within.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些视角以及其中的实践。
- en: Version control practices
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制实践
- en: Good version control practices ensure that changes introduced into version control
    are evaluated through testing before they are saved and merged with the existing
    code base. This ensures that the code base is robust, without changes that may
    prevent the code base from being built or packaged correctly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的版本控制实践确保在将更改引入版本控制之前，通过测试对其进行评估，然后再将其保存并与现有代码库合并。这确保了代码库的健壮性，不会出现阻止代码库正确构建或打包的更改。
- en: Version control practices can further be divided into three types that help
    ensure a robust code base as changes come in. Let’s look at what these practices
    are in detail.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制实践可以进一步分为三种类型，帮助确保随着更改的引入，代码库保持健壮。让我们详细看看这些实践是什么。
- en: CI of code
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码的持续集成（CI）
- en: 'The practice of CI has its origins in optimizing the build process through
    automation by a build script or a CI tool. Saving a change to version control
    through a commit operation sets off a chain of the following steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: CI实践源于通过自动化构建脚本或CI工具优化构建过程。通过提交操作将更改保存到版本控制中，会触发以下一系列步骤：
- en: The application would be built, incorporating the saved changes. If building
    this code resulted in an error, notifications would be sent regarding the error.
    The changes would not be allowed to merge with the code base.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序将被构建，并整合保存的变更。如果构建过程中出现错误，将发送关于该错误的通知。变更将无法与代码库合并。
- en: If the build succeeded, tests would run against the build with the code changes.
    These tests are often small tests, measuring a small part of the functionality,
    that can be quickly executed and don’t take a lot of time. If a test failure was
    detected, a notification would be sent, and the changes would not be allowed to
    merge with the code base.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果构建成功，测试将会在包含代码变更的构建上运行。这些测试通常是小型测试，测量功能的一个小部分，可以快速执行且不占用太多时间。如果检测到测试失败，将会发送通知，并且变更将无法与代码库合并。
- en: Another type of test that could be executed would be a scan of the code base.
    Scanning could look for deviations from coding style standards and syntax errors
    to known security vulnerabilities. Depending on the severity of the findings,
    changes would not be allowed to merge with the code base. Notifications would
    be sent on all findings.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种可以执行的测试是对代码库的扫描。扫描可以查找代码风格标准的偏差、语法错误以及已知的安全漏洞。根据发现的严重性，变更将无法与代码库合并，并且会就所有发现的内容发送通知。
- en: Upon successful results from the building, testing, and scanning steps, the
    code change would be recorded into the version control system. Merging the change
    into the main trunk of the code base would proceed on the version control system,
    integrating the changes with the rest of the code.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建、测试和扫描步骤成功完成后，代码变更将被记录到版本控制系统中。代码变更将通过版本控制系统合并到主干，整合到代码库的其余部分。
- en: 'The preceding steps are outlined in the following diagram:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤在下图中进行了概述：
- en: '![Figure 11.4 – CI automation](img/B18756_11_04.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – CI 自动化](img/B18756_11_04.jpg)'
- en: Figure 11.4 – CI automation
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – CI 自动化
- en: 'When performing the preceding chain of steps, teams eventually figured out
    that successful code integration relied on the following factors:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行上述一系列步骤时，团队最终意识到，成功的代码集成依赖于以下因素：
- en: '**Performing the integration frequently**: Many teams started with performing
    the build and testing processes nightly, examining changes that had been saved
    over the previous day. With a lot of changes, the *nightly build* often grew until
    it couldn’t be finished until the next day or later. More frequent builds, often
    occurring several times a day, allowed people to see the build results and act
    on them swiftly.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频繁执行集成**：许多团队最初通过每晚执行构建和测试过程，检查前一天保存的变更。随着变更越来越多，*夜间构建*通常会增长，直到无法在第二天或更晚之前完成。更频繁的构建，通常是每天多次执行，允许团队成员看到构建结果并迅速采取行动。'
- en: '**Performing integration on fewer changes**: A *nightly build* that absorbs
    multiple changes from multiple developers produces problems when the build fails.
    It becomes more complex to troubleshoot to determine which developer’s change
    *broke the build*. Performing a build based on fewer changes, with the idea of
    building on each saved change, allows for quicker troubleshooting when errors
    occur.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在较少变更上执行集成**：一个包含多个开发者变更的*夜间构建*会在构建失败时产生问题。诊断哪个开发者的变更导致了构建失败变得更为复杂。基于较少变更执行构建，每次构建都基于保存的变更，可以在出现错误时更快速地进行故障排查。'
- en: 'CI results in the following outputs, regardless of success or failure:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无论成功与否，CI 都会产生以下输出：
- en: '**Fast feedback**: The results of CI should occur in minutes. Any errors that
    prevent the successful completion of CI will be given in a short amount of time,
    resulting in fewer delays.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速反馈**：CI 的结果应该在几分钟内产生。任何导致 CI 无法成功完成的错误都会在短时间内给出反馈，从而减少延迟。'
- en: '**Deployable artifacts upon success**: With a successful build, a build package
    able to be deployed into non-production environments will be produced.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功时可部署的工件**：通过成功构建，将生成一个可以部署到非生产环境中的构建包。'
- en: CI tools such as Jenkins, GitLab pipelines, and GitHub Actions form the basis
    of the automation that allows the CI of code to occur.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: CI 工具，如 Jenkins、GitLab 管道和 GitHub Actions，构成了实现代码持续集成（CI）的自动化基础。
- en: Trunk-based development
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主干开发
- en: Multiple developers in a single team or even multiple teams (such as the team
    of teams that is present in an ART) often must work on the same code base that
    is saved in version control. Version control systems allow for parallel development
    of the same code base by allowing changes to be branched out. A developer or team
    could work on a branch without their change affecting the rest of the team or
    ART until it was ready to merge and be shared with other developers or teams.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一个团队中的多个开发人员，甚至多个团队（如ART中的团队）通常必须在同一个代码库上工作，该代码库保存在版本控制中。版本控制系统通过允许更改分支出来，支持同一代码库的并行开发。开发人员或团队可以在分支上工作，直到准备好合并并与其他开发人员或团队共享之前，他们的更改不会影响其他团队或ART。
- en: '![Figure 11.5 – Branching structure example](img/B18756_11_05.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 分支结构示例](img/B18756_11_05.jpg)'
- en: Figure 11.5 – Branching structure example
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 分支结构示例
- en: In the preceding illustration, **Team 1** and **Team 2** have their own branches
    of the code base, based on different versions of the main branch (commonly referred
    to as the *trunk*). A developer on **Team 1** has created a change (**D1**) and
    merged it back into the **Team 1** branch as a change, **T1-2**. With separate
    team branches, how do we know that a necessary change from **Team 2** is visible
    and can be used by **Team 1**?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，**团队 1**和**团队 2**都有自己基于主分支不同版本的代码库分支（通常称为*主干*）。**团队 1**的开发人员创建了一个更改（**D1**）并将其作为更改**T1-2**合并回**团队
    1**的分支。在独立的团队分支下，我们如何知道**团队 2**的必要更改是否可见，并且能被**团队 1**使用呢？
- en: Another problem occurs as **Team 1** and **Team 2** develop on their branches
    without receiving updates from the trunk and wait to merge when they release or
    at the end of the sprint. Keeping track of the multiple changes from multiple
    teams and resolving a large number of merge conflicts results in an incredible
    challenge.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题出现在**团队 1**和**团队 2**在各自的分支上开发，但没有从主干接收更新，直到他们发布或冲刺结束时才合并。跟踪多个团队的多项更改，并解决大量合并冲突，带来了巨大的挑战。
- en: 'To keep things simple and ensure changes are visible to all teams, we want
    to avoid branches that are permanent or last a long time. Developers and teams
    may form branches to allow for parallel development, but when ready, they must
    merge back to the main branch, destroying the offshoot branch in the process.
    This process is known as trunk-based development. The following diagram highlights
    the process of trunk-based development:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单并确保所有团队都能看到变化，我们希望避免出现长期存在的或永久性的分支。开发人员和团队可以创建分支以支持并行开发，但当准备好后，必须将其合并回主分支，并在此过程中销毁分支。这一过程被称为基于主干的开发。下图展示了基于主干的开发流程：
- en: '![Figure 11.6 – Branching structure with trunk-based development](img/B18756_11_06.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 基于主干的开发分支结构](img/B18756_11_06.jpg)'
- en: Figure 11.6 – Branching structure with trunk-based development
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 基于主干的开发分支结构
- en: Trunk-based development allows for easier merge operations to occur since a
    merge to the main branch is happening on each validated change instead of a group
    of changes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的开发使得合并操作更容易进行，因为每个验证过的更改都会合并到主分支，而不是一组更改。
- en: Gated commits
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有门控的提交
- en: With trunk-based development, we are merging changes to the main branch of the
    code base as often as possible. This main branch is used by all the teams on the
    ART. Since the integrity of the main branch is vital for multiple teams, how do
    we ensure that any errant changes don’t break the current code base?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于主干的开发，我们尽可能频繁地将更改合并到代码库的主分支中。这个主分支是ART上所有团队使用的。由于主分支的完整性对多个团队至关重要，我们如何确保任何错误的更改不会破坏当前的代码库呢？
- en: To ensure a robust code base, we must follow a gated commit process where before
    a change is allowed to merge with the main branch, it must successfully pass the
    build and test process. Additional measures, such as a review of the change, may
    also be taken.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保代码库的健壮性，我们必须遵循一个有门控的提交过程，在允许更改合并到主分支之前，必须成功通过构建和测试过程。也可以采取额外的措施，比如对更改进行审查。
- en: In Git-based environments, Git servers from Bitbucket, GitLab, and GitHub define
    gated commits as pull requests or merge requests that allow for closer scrutiny
    when a merge operation is requested.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Git的环境中，Bitbucket、GitLab和GitHub等Git服务器将有门控的提交定义为拉取请求或合并请求，这些请求允许在请求合并操作时进行更严格的审查。
- en: Testing practices
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试实践
- en: We saw that build processes relied on testing to ensure that changes to a code
    base did not adversely affect the functionality or the security of the product.
    The tests that were run proved to be important since ideally, the build process
    would be performed on every saved change and if successful, the next step would
    be merging the change to the main branch, which is visible to the team or multiple
    teams in the case of the ART.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，构建过程依赖于测试来确保对代码库的更改不会对产品的功能或安全性产生不利影响。执行的测试证明是非常重要的，因为理想情况下，构建过程应该在每次保存的更改后执行，如果成功，下一步将是将更改合并到主分支，对于
    ART 来说，这个分支对团队或多个团队是可见的。
- en: 'The build process involves two types of tests that are run against a potential
    new version of the code base: automated unit testing and static analysis for application
    security.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 构建过程涉及两种类型的测试，这些测试会针对潜在的新版本代码库运行：自动化单元测试和静态应用安全分析。
- en: Let’s take a deeper look at each type of test run as part of the build process.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解作为构建过程一部分的每种测试类型。
- en: Automated unit testing
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化单元测试
- en: Unit tests are often written at the same time as code, if not beforehand. These
    unit tests may be run by an individual developer on their workstation while the
    code is being developed. If that’s the case, why run them again as part of the
    build process?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试通常与代码同时编写，如果不是提前编写。这些单元测试可能由个人开发者在其工作站上运行，在代码开发过程中进行。如果是这种情况，为什么还要在构建过程中再次运行它们呢？
- en: The main idea of CI is to ensure a standard, reliable process. Automation through
    a CI/CD pipeline ensures that this occurs for all developers. Adding unit testing
    during the build process on an automated CI/CD pipeline ensures that the unit
    tests are run on every developer’s code change every time.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: CI 的主要思想是确保一个标准、可靠的流程。通过 CI/CD 流水线实现自动化，确保所有开发者都遵循这一流程。在构建过程中增加单元测试，并在自动化的 CI/CD
    流水线上运行，确保每个开发者的代码变更都会每次执行单元测试。
- en: It’s also important to make sure that any unit tests that have been updated
    are simultaneously part of the potential change to the code base in version control.
    This ensures that code changes are validated against correct tests preventing
    a situation where the CI/CD pipeline stops because of incorrect tests. Collaborative
    development efforts between those creating the code and those creating the tests
    are required to ensure this situation doesn’t occur.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 同时确保任何已更新的单元测试也是潜在代码变更的一部分，并且被纳入版本控制中的代码库。这可以确保代码更改能够通过正确的测试进行验证，防止因为不正确的测试导致
    CI/CD 流水线停止。确保代码创建者和测试创建者之间的协作开发是必要的，以确保这种情况不发生。
- en: Static analysis for application security
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用安全的静态分析
- en: 'Static analysis is a process by which a tool scans the text of the code base,
    including the potential code change that is being checked in, to find specific
    text patterns. These text patterns can be used to identify the following issues:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析是一种通过工具扫描代码库文本（包括正在检查的潜在代码更改）来查找特定文本模式的过程。这些文本模式可以用于识别以下问题：
- en: Coding errors
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码错误
- en: Known security vulnerabilities
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知的安全漏洞
- en: Non-adherence to coding guidelines or coding standards
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不遵守编码指南或编码标准
- en: The analysis is performed without the need for executing the application. Because
    of this, static analysis is an efficient means of checking for problems in the
    build process.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分析是在无需执行应用程序的情况下进行的。因此，静态分析是一种高效的检查构建过程中问题的手段。
- en: 'As we saw in [*Chapter 3*](B18756_03.xhtml#_idTextAnchor066), *Automation for
    Efficiency and Quality*, static analysis can fall into the following two categories:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第3章*](B18756_03.xhtml#_idTextAnchor066)《*提高效率和质量的自动化*》中所看到的，静态分析可以分为以下两类：
- en: '**Static code analysis**: Look through the code for possible coding errors.
    Linting is an example of static code analysis.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态代码分析**：查看代码中可能存在的编码错误。Linting 就是静态代码分析的一种示例。'
- en: '**Static security analysis**: Look through the code for possible security vulnerabilities
    and attack vectors. Applications that perform static security analysis may perform
    the following scans:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态安全分析**：查看代码中可能存在的安全漏洞和攻击向量。执行静态安全分析的应用程序可能进行以下扫描：'
- en: '**Dependency scanning**: Scanning code dependencies and references to third-party
    libraries to find vulnerabilities'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖扫描**：扫描代码依赖和对第三方库的引用，以查找漏洞'
- en: '**Static Application Security Testing** (**SAST**): Scanning code to find attack
    vectors and vulnerabilities'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态应用安全测试**（**SAST**）：扫描代码以查找攻击向量和漏洞'
- en: '**License compliance**: Scanning libraries to determine their opensource licensing
    model'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**许可合规**：扫描库以确定其开源许可模型'
- en: '**Container scanning**: Scanning Docker containers to find embedded vulnerabilities'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器扫描**：扫描Docker容器以查找嵌入的漏洞'
- en: '**Secret detection**: Scanning code to find embedded credentials, keys, and
    tokens'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秘密检测**：扫描代码以查找嵌入的凭证、密钥和令牌'
- en: Our application has passed the first set of tests, but is it ready for the rigors
    of a production environment? To answer that question, we look to perform system-level
    testing. Our next section examines the practices that enable system-level testing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序已经通过了第一组测试，但它是否已经准备好应对生产环境中的严苛要求？为了回答这个问题，我们需要进行系统级测试。接下来的部分将探讨支持系统级测试的实践。
- en: Testing end to end
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端测试
- en: At this point, we have performed tests on individual pieces of code and ensured
    the correct functionality while maintaining security. Here, we start to integrate
    the new changes of code with the existing code base and evaluate the system as
    a whole by testing the system end to end.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经对单独的代码片段进行了测试，并确保了功能的正确性，同时保持了安全性。在此，我们开始将新的代码变更与现有代码库集成，并通过端到端测试来评估整个系统。
- en: The practices that allow for true end-to-end testing of the system will be examined
    in the upcoming sections. Let’s dive in.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 允许对系统进行真实端到端测试的实践将在接下来的部分中讨论。让我们深入了解。
- en: Equivalent test environments
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等效的测试环境
- en: System-level testing should be performed in an environment that resembles the
    production environment as closely as possible. Testing the solution in an environment
    with as many similarities to the production environment as possible enables higher
    confidence that the solution will work when actually released into the actual
    production environment. The more similarities a test environment has with the
    production environment, the fewer variables come into play when problems are found
    and troubleshooting for the root cause begins.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 系统级测试应在尽可能接近生产环境的环境中进行。尽量在与生产环境相似的环境中测试解决方案，可以更有信心地确保解决方案在实际投入生产环境时能够正常工作。测试环境与生产环境的相似性越高，发现问题并开始排查根本原因时，涉及的变量就越少。
- en: A key factor in ensuring the equivalence between test environments and the production
    environment is the use of configuration management. With configuration management,
    key resources such as the operating system version, versions of key drivers, and
    versions of applications are recorded in a text-based configuration file. Ideally,
    the configuration file is maintained in version control with labels that indicate
    the version of the solution and its application in the test environments and production
    environment.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 确保测试环境与生产环境等效的一个关键因素是使用配置管理。通过配置管理，操作系统版本、关键驱动程序版本和应用程序版本等关键资源会被记录在基于文本的配置文件中。理想情况下，配置文件会通过版本控制进行管理，并带有标签，标明解决方案的版本及其在测试环境和生产环境中的应用。
- en: Because the cost of allocating exact duplicates of the resources in production
    may be prohibitive, the important view is that exact versions of resources, rather
    than the exact number of resources, are key to maintaining equivalence.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 因为为生产环境分配完全相同的资源可能会非常昂贵，所以重要的视角是，资源的确切版本，而不是资源的确切数量，是保持等效性的关键。
- en: Test automation
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试自动化
- en: System-level testing can encompass a variety of levels, most of which can be
    automated. When looking at a variety of tests at various levels, which of these
    tests could be automated?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 系统级测试可以涵盖多个层次，其中大部分可以实现自动化。在不同层次的测试中，哪些测试可以被自动化？
- en: In addition to the testing pyramid mentioned earlier, we may need to consider
    the people who need to understand the test results. A second consideration is
    whether the test is to verify that the solution is meeting requirements or whether
    the test is to allow developers to see whether their design approach is correct.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面提到的测试金字塔，我们可能还需要考虑需要理解测试结果的人员。第二个考虑因素是，测试是验证解决方案是否符合要求，还是让开发人员看到他们的设计方法是否正确。
- en: 'The Agile testing matrix looks at the various kinds of tests and organizes
    them from these considerations. The following diagram depicts the Agile testing
    matrix as seen in the SAFe article on *Agile* *Testing* ([https://www.scaledagileframework.com/agile-testing/](https://www.scaledagileframework.com/agile-testing/)):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷测试矩阵查看各种类型的测试，并根据这些考虑因素对其进行组织。下图展示了在 SAFe 文章中看到的敏捷测试矩阵，关于*敏捷测试* ([https://www.scaledagileframework.com/agile-testing/](https://www.scaledagileframework.com/agile-testing/))：
- en: '![Figure 11.7 – Agile testing matrix (© Scaled Agile, Inc., All Rights Reserved)](img/B18756_11_07.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7 – 敏捷测试矩阵（© Scaled Agile, Inc.，保留所有权利）](img/B18756_11_07.jpg)'
- en: Figure 11.7 – Agile testing matrix (© Scaled Agile, Inc., All Rights Reserved)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 – 敏捷测试矩阵（© Scaled Agile, Inc.，保留所有权利）
- en: We can see from the preceding diagram that the first consideration looks at
    the perspective of either the business or the technology. Developers look at the
    technology tests to ensure the correct functionality and proper operation of the
    solution. End users look at the business-facing tests to ensure an understanding
    of the solution and the validation of the benefit hypothesis.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图示可以看出，第一个考虑因素是从业务或技术的角度来看待的。开发人员从技术测试的角度，确保解决方案的正确功能和正常操作。最终用户从面向业务的测试角度，确保对解决方案的理解并验证其效益假设。
- en: 'We can also see the second consideration: whether the test informs the complete
    solution or the implementation. Tests that guide development assist in TDD and
    BDD approaches where the test is written first. Tests that critique the product
    look to see whether the solution complies with user requirements.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到第二个考虑因素：测试是否涉及完整的解决方案或实现。指导开发的测试有助于 TDD 和 BDD 方法，其中测试先于代码编写。批判产品的测试则关注解决方案是否符合用户需求。
- en: 'With two areas of concern within each of the two considerations, we can divide
    tests into the following four quadrants:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个考虑因素的两个领域中，我们可以将测试分为以下四个象限：
- en: '**Q1**: These contain unit and component tests. These tests may be created
    as part of a TDD approach.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Q1**：这些包含单元测试和组件测试。这些测试可能作为 TDD 方法的一部分创建。'
- en: '**Q2**: These contain functional tests and tests for stories and features.
    These may be created using a BDD approach to allow for automated testing. Otherwise,
    some of this validation may be manual.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Q2**：这些包含功能性测试以及故事和特性的测试。这些测试可以使用 BDD 方法创建，以实现自动化测试。否则，其中一些验证可能需要手动进行。'
- en: '**Q3**: These are acceptance tests of the entire solution. These may be the
    final validation before release. These are often manually run with alpha and beta
    users.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Q3**：这些是整个解决方案的验收测试。这些可能是发布前的最终验证。这些测试通常由 alpha 和 beta 用户手动执行。'
- en: '**Q4**: These test overall system qualities, including NFRs. These verify the
    system in the production environment.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Q4**：这些测试整体系统的质量，包括非功能性需求（NFRs）。这些测试验证生产环境中的系统。'
- en: We will see that tests in Q3 are done during CD in [*Chapter 12*](B18756_12.xhtml#_idTextAnchor268),
    *Continuous Deployment to Production*. Tests in Q4 are done during Release on
    Demand as mentioned in [*Chapter 13*](B18756_13.xhtml#_idTextAnchor292), *Releasing
    on Demand to* *Realize Value*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，第3象限的测试是在[*第12章*](B18756_12.xhtml#_idTextAnchor268) *持续部署到生产环境* 中的 CD
    阶段进行的。第4象限的测试是在[*第13章*](B18756_13.xhtml#_idTextAnchor292) *按需发布以实现价值* 中提到的按需发布阶段进行的。
- en: Management of test data
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试数据的管理
- en: A key part of ensuring the similarities between a testing environment and the
    production environment is the data used to test the solution. Using data that
    could be found in production environments allows for more realistic test outcomes,
    leading to higher confidence in the solution.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 确保测试环境与生产环境之间相似的一个关键部分是用于测试解决方案的数据。使用在生产环境中可能找到的数据，可以提供更现实的测试结果，从而增加对解决方案的信心。
- en: Realistic test data can come from either synthetic test data or real production
    data. Test data may come from a backup of production data restored into the test
    environment. The test data should have any information that is considered private
    removed.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现实的测试数据可以来自合成测试数据或真实的生产数据。测试数据可能来自生产数据的备份，这些数据被恢复到测试环境中。测试数据应该删除任何被视为私密的信息。
- en: Synthetic test data is *fake data* created by a data generation tool such as
    DATPROF Privacy and Gretel. It offers the advantage of not requiring an anonymization
    step to redact private information.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 合成测试数据是由数据生成工具（如 DATPROF Privacy 和 Gretel）创建的*虚假数据*。它的优点是无需进行匿名化步骤来删除私人信息。
- en: Regardless of whether the data is anonymized production data or synthetic data,
    the test data should be maintained in version control, using artifact repository
    software for large binary-based data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '无论数据是匿名化的生产数据还是合成数据，测试数据应该使用版本控制来维护，使用工件库软件来存储大规模的基于二进制的数据。  '
- en: Service virtualization
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '服务虚拟化  '
- en: 'Service virtualization allows for test environments to behave like production
    environments even when the test environment is missing resources available in
    production. The production environment may have crucial dependencies on key components
    that are impossible to copy because of the following factors:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '服务虚拟化使得即使测试环境缺少生产环境中可用的资源，测试环境也能像生产环境一样工作。生产环境可能依赖于一些关键组件，这些组件由于以下因素而无法复制：  '
- en: The component is not complete yet
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '该组件尚未完成  '
- en: The component is being developed by a third-party vendor or partner
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '该组件由第三方供应商或合作伙伴开发  '
- en: There is limited access to the component in a test environment
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在测试环境中对组件的访问有限  '
- en: The component is difficult to configure in a test environment
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '该组件在测试环境中配置困难  '
- en: Multiple teams with differing setups require access to the component
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '需要访问该组件的多个团队具有不同的设置  '
- en: The component is too costly to use for performance or load testing
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '该组件太昂贵，无法用于性能或负载测试  '
- en: Systems made up of components that communicate together using well-known interfaces
    can take advantage of service virtualization to simulate the behavior of one or
    more components. If the virtualized service is a database, it can return synthetic
    test data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '由组件组成的系统，如果它们通过公认的接口进行通信，可以利用服务虚拟化来模拟一个或多个组件的行为。如果虚拟化服务是一个数据库，它可以返回合成的测试数据。  '
- en: 'Components that are simulated in test environments are called virtual assets.
    Virtual assets are created by tools that measure the true component’s behavior
    by the following methods:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试环境中模拟的组件称为虚拟资产。虚拟资产是通过以下方法由工具创建的，这些方法可以测量真实组件的行为：
- en: Recording the messages, responses, and response times of a component as it communicates
    on a common channel or bus
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '记录一个组件在共享通道或总线上通信时的消息、响应和响应时间  '
- en: Examination of the component’s logs
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '检查组件的日志  '
- en: Viewing the service interface specifications
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '查看服务接口规范  '
- en: Manually applying inputs and measuring behavior
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '手动输入数据并测量行为  '
- en: 'Once the virtual asset is created, it takes its place in the test environment.
    An illustration of the difference between the production environment and the test
    environment with virtual assets is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '一旦虚拟资产创建完成，它就会在测试环境中占据一席之地。生产环境与测试环境之间使用虚拟资产的区别示例如下：  '
- en: '![Figure 11.8 – Production vs. test environment](img/B18756_11_08.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 生产环境与测试环境](img/B18756_11_08.jpg)  '
- en: Figure 11.8 – Production vs. test environment
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '图 11.8 – 生产环境与测试环境  '
- en: Popular tools for creating virtual assets include SoapUI and ReadyAPI from Smartbear,
    MockLab, Parasoft Virtualize, and WireMock.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '用于创建虚拟资产的流行工具包括Smartbear的SoapUI和ReadyAPI、MockLab、Parasoft Virtualize和WireMock。  '
- en: An important difference to consider is that while service virtualization may
    seem similar to *mocking* or stubbing a component, the two concepts are not similar.
    Adding a mock component or a stub may be done during development when the component
    is not ready for release. The behavior of a mock object only returns one type
    of output – a success message – so the development of other components is not
    impeded. Service virtualization allows for the proper behavior for a wide variety
    of scenarios.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '一个重要的区别需要考虑的是，尽管服务虚拟化看起来类似于*模拟*或桩化组件，但这两个概念并不相同。添加模拟组件或桩通常是在开发过程中进行的，当组件尚未准备好发布时。模拟对象的行为只返回一种类型的输出——成功信息——因此其他组件的开发不会受到阻碍。服务虚拟化允许在各种场景下提供正确的行为。  '
- en: Environments with virtual assets should be maintained in configuration management
    tools. The configuration files and interface definition files for virtual assets
    should be kept in version control, in close proximity, and with labels identifying
    their role as test assets for versions of an application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '使用虚拟资产的环境应在配置管理工具中进行维护。虚拟资产的配置文件和接口定义文件应保存在版本控制中，紧密存放，并贴有标签以标识它们作为应用程序版本的测试资产。  '
- en: Testing nonfunctional requirements
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '测试非功能性需求  '
- en: As we perform end-to-end system testing, we need to remember the constraints
    our system has, which we have previously identified as NFRs. NFRs affect every
    story and feature, acting as a constraint that must be heeded. Qualities such
    as security, performance, reliability, and scalability, among other things, should
    be examined through testing to verify that these constraints aren’t broken.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行端到端系统测试时，我们需要记住系统的约束条件，这些条件我们之前已经确定为非功能性需求（NFRs）。非功能性需求影响每个用户故事和功能，作为必须遵守的约束。诸如安全性、性能、可靠性和可扩展性等质量属性，应该通过测试进行检查，以验证这些约束没有被破坏。
- en: The testing of NFRs is often automated, involving specialized testing tools.
    Agile teams on the ART often work with the system team to ensure that the tooling
    is established to perform testing for NFRs as part of the end-to-end testing.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 非功能性需求的测试通常是自动化的，涉及专门的测试工具。ART上的敏捷团队通常与系统团队合作，确保建立工具链，以便作为端到端测试的一部分执行非功能性需求的测试。
- en: After the portfolio of tests is performed on our change, we may want one more
    opportunity to see whether our change is ready to be deployed to production. We
    place our changes into a staging environment, a stand-in for the production environment
    for a final examination before deploying changes to production. Let’s look at
    the activities involved in deploying changes to staging.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在对变更执行完所有测试组合后，我们可能还希望有一个机会来查看我们的变更是否准备好部署到生产环境。我们将变更放入阶段环境，这是生产环境的替代品，用于在将变更部署到生产之前进行最终检查。让我们来看看将变更部署到阶段环境的活动。
- en: Moving to staging
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移动到阶段环境
- en: We may want verification that we can deploy the change to a production-like
    environment and verify that our solution still works. To enable this last look,
    we employ certain practices.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望验证能否将变更部署到类似生产的环境中，并验证我们的解决方案是否仍然有效。为了进行这最后的检查，我们采用了一些实践。
- en: Let’s look at these practices in depth.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解这些实践。
- en: Staging environments
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阶段环境
- en: A staging environment is a facsimile of the production environment, which has
    several uses throughout the PI. It is the place where demonstrations of the system
    as it currently stands are performed in the system demo. User acceptance testing
    can be performed in this environment, which is as close to production as possible.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段环境是生产环境的复制品，在PI过程中有多种用途。它是系统演示的地方，展示当前系统的状态。用户验收测试可以在这个环境中进行，它尽可能接近生产环境。
- en: As the changes to the product are being developed, the staging environment shows
    the state of change before deployment to production. At the very least, changes
    to the staging environment happen every sprint or iteration for the ART. More
    frequent changes are allowed as long as the build process and end-to-end testing
    are completed successfully.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 随着产品的变更开发，阶段环境展示了在部署到生产之前的变更状态。至少，每个迭代或冲刺期间，阶段环境都会进行变更。只要构建过程和端到端测试成功完成，更频繁的变更也是允许的。
- en: A staging environment may also act as an alternative environment for production
    in a configuration known as blue/green deployment, which may allow for easy rollback
    in the event of production failures. Let’s take a look at this configuration now.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 阶段环境也可以作为生产环境的替代环境，采用蓝绿部署配置，这种配置可以在生产故障时轻松回滚。现在，让我们来看一下这种配置。
- en: Blue/green deployments
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: In a blue/green deployment, you have two identical environments. Of the two
    environments, one is the production environment and facing traffic, while the
    other is idle and on standby.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在蓝绿部署中，你有两个相同的环境。两个环境中，一个是生产环境并面对流量，另一个是空闲的，处于待命状态。
- en: 'The idle environment receives the latest change where thorough testing occurs.
    At the appropriate time, the change is released by making the idle environment
    live and the other environment idle. This transition is illustrated by the following
    graphic:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 空闲环境接收最新的变更，并进行彻底的测试。适当时，变更将通过将空闲环境切换为上线状态，并使另一个环境处于空闲状态来发布。以下图示说明了这一过渡：
- en: '![](img/B18756_11_09.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18756_11_09.jpg)'
- en: Figure 11.9 – Blue/green deployment release of a new version
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 蓝绿部署发布新版本
- en: If problems are discovered, a switchback can be made to roll back changes. This
    transition back and forth is easy for systems that do not track states. Otherwise,
    blue/green deployments must be carefully architected so that components that are
    capable of storing states, such as databases, do not get corrupted upon transition.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现问题，可以切换回滚变更。对于不追踪状态的系统来说，这种来回切换很容易。否则，蓝/绿部署必须精心设计，以确保能够存储状态的组件，如数据库，在过渡时不会被损坏。
- en: System demo
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统演示
- en: At the end of every sprint or iteration in the PI, after each team’s iteration
    review, the teams get together to integrate their efforts. Working with the system
    team, they demonstrate the current state of the product as it stands so far in
    the PI in the staging environment. Business owners, customers, and other key stakeholders
    of the ART are present at this demonstration to view progress and supply feedback.
    This event provides fast feedback on the efforts of the ART so far.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个PI（程序增量）的每个冲刺或迭代结束时，在每个团队的迭代评审后，团队会聚集在一起整合他们的工作成果。与系统团队合作，他们展示目前在暂存环境中该PI中产品的当前状态。商业负责人、客户和ART的其他关键利益相关者会出席此演示活动，以查看进展并提供反馈。这个活动为ART目前的努力提供了快速反馈。
- en: Note that the system demo does not prevent the deployment of changes into production.
    That may continue to happen automatically as part of CD (which we will visit in
    the next chapter), but feedback may prevent the release of the change to customers
    until changes resulting from the feedback make their way into production and are
    released on demand.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，系统演示并不妨碍将变更部署到生产环境中。这可以继续作为CD（我们将在下一章讨论）的一部分自动发生，但反馈可能会阻止变更发布给客户，直到基于反馈的变更进入生产并按需发布。
- en: Successful testing in a staging environment gives us confidence that our change
    has the correct functionality and is robust enough in a production environment,
    but the only true way to prove that is to deploy our change into the actual production
    environment.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂存环境中的成功测试让我们有信心，变更具有正确的功能，并且在生产环境中足够稳定，但唯一真正证明这一点的方式是将我们的变更部署到实际的生产环境中。
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we continued our discovery of the Continuous Delivery Pipeline
    by looking at CI, the part that implements the features created in Continuous
    Exploration. Features are divided into more digestible stories. Development of
    not only the product but also the tests to verify the product begins. Security
    and designing for operation concerns are included in the development.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续探索持续交付管道，关注CI（持续集成），它实现了在持续探索中创建的功能。功能被拆分成更易消化的故事。产品的开发不仅包括产品本身，还包括验证产品的测试。安全性和面向运维的设计也纳入了开发中。
- en: The build phase introduces automation into the pipeline. When a commit to version
    control occurs, unit tests are run to ensure continued, correct functionality.
    The build is also scanned for coding errors and to find security vulnerabilities.
    If everything is correct, the commit will be allowed to merge with the main branch,
    or trunk, of the version control repository.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 构建阶段将自动化引入管道中。当版本控制发生提交时，单元测试会运行以确保功能的持续正确性。构建还会扫描代码错误并查找安全漏洞。如果一切正常，提交将被允许与版本控制仓库的主分支或干线合并。
- en: A successful build can trigger further testing in a testing environment that
    may be similar to the production environment. Here, system-level, end-to-end testing
    happens to guard against any production failures. The testing here is as automated
    as it can be. Accurate test data and service virtualization may offer a reasonable
    facsimile to a production environment for testing.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的构建可以触发在类似生产环境的测试环境中进行进一步测试。在这里，会进行系统级的端到端测试，以防止任何生产故障。这里的测试尽可能自动化。准确的测试数据和服务虚拟化可能为生产环境提供合理的仿真进行测试。
- en: When building and testing are complete, the change may find itself in a staging
    environment, a copy of the production environment, or one-half of a blue/green
    deployment. A staging environment is also a place where changes are shown during
    a system demo, an event where the ART receives feedback on the development of
    the system at the end of each sprint or iteration.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建和测试完成后，变更可能会出现在一个暂存环境中，它是生产环境的副本，或者是蓝/绿部署的一部分。暂存环境也是在系统演示期间展示变更的地方，这是一个在每次冲刺或迭代结束时，ART（敏捷释放训练）团队获得系统开发反馈的活动。
- en: After making its way to the staging environment, we must move our changes into
    production. That happens in CD, which we will explore in our next chapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入暂存环境后，我们必须将更改移入生产环境。这是在 CD 中发生的，我们将在下一章中探讨它。
- en: Questions
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are two examples of collaborative development?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协同开发的两个例子是什么？
- en: Solo programming
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 独立编程
- en: Pair programming
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配对编程
- en: Gauntlet programming
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挑战编程
- en: Mob programming
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mob 编程
- en: Cross-team programming
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跨团队编程
- en: What is the first step in TDD?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TDD 的第一步是什么？
- en: Write the test
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写测试
- en: Write the code
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码
- en: Refactor the test
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构测试
- en: Refactor the code
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构代码
- en: When performing trunk-based development, a successful build and test will allow
    the committed change to merge with which branch?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行基于主干的开发时，成功的构建和测试将使提交的更改与哪个分支合并？
- en: Release branch
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布分支
- en: Fix branch
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复分支
- en: Main branch
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主分支
- en: Test-complete branch
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整测试分支
- en: According to the testing pyramid, what types of tests are the quickest to execute?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据测试金字塔，哪种类型的测试执行速度最快？
- en: Unit tests
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Security tests
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全测试
- en: Story tests
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 故事测试
- en: User acceptance tests
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户验收测试
- en: What text-based artifacts should be stored in version control?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该存储在版本控制中的基于文本的文档是什么？
- en: Code
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码
- en: Tests
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试
- en: Configuration files
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置文件
- en: A and C
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: A 和 C
- en: All of the above
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有
- en: What can be used to allow test environments to be similar to production environments?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以用什么方法让测试环境与生产环境相似？
- en: Using old production servers
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用旧的生产服务器
- en: Sanitized backups of production data
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理后的生产数据备份
- en: Service virtualization
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务虚拟化
- en: B and C
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: B 和 C
- en: All of the above
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有
- en: What can a staging environment, identical to the production environment, be
    used for?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与生产环境完全相同的暂存环境可以用来做什么？
- en: User acceptance tests
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户验收测试
- en: An idle environment for blue/green deployment
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于蓝绿部署的空闲环境
- en: System demos
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统演示
- en: All of the above
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以上所有
- en: Further reading
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Guidance from Scaled Agile on how to decompose f[eatures into stories and what
    good stories](https://www.scaledagileframework.com/story/) contain: [https://www.scaledagileframework.com/story/](https://www.scaledagileframework.com/story/)'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scaled Agile 指南，说明如何将功能分解为故事及良好故事的内容：[https://www.scaledagileframework.com/story/](https://www.scaledagileframework.com/story/)
- en: 'A guide to common patterns used to decompose features into stories or to split
    big stories into smaller stories: [http://www.humanizingwork.com/wp-content/uploads/2020/10/HW-Story-Splitting-Flowchart.pdf](http://www.humanizingwork.com/wp-content/uploads/2020/10/HW-Story-Splitting-Flowchart.pdf)'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一份常用模式的指南，说明如何将功能分解为故事或将大故事拆分成小故事：[http://www.humanizingwork.com/wp-content/uploads/2020/10/HW-Story-Splitting-Flowchart.pdf](http://www.humanizingwork.com/wp-content/uploads/2020/10/HW-Story-Splitting-Flowchart.pdf)
- en: 'A good article detailing the practice of pair programming: [https://www.techtarget.com/searchsoftwarequality/definition/Pair-programming](https://www.techtarget.com/searchsoftwarequality/definition/Pair-programming)'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇好文章，详细介绍了配对编程的实践：[https://www.techtarget.com/searchsoftwarequality/definition/Pair-programming](https://www.techtarget.com/searchsoftwarequality/definition/Pair-programming)
- en: 'The study done by the University of Utah detailing the benefits of pair programming:
    [https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF](https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 犹他大学进行的研究，详细描述了配对编程的好处：[https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF](https://collaboration.csc.ncsu.edu/laurie/Papers/XPSardinia.PDF)
- en: 'The original article from Woody Zuill, detailing how mob programming works
    and its benefits: [https://www.agilealliance.org/resources/experience-reports/mob-programming-agile2014/](https://www.agilealliance.org/resources/experience-reports/mob-programming-agile2014/)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Woody Zuill 的原文，详细描述了 mob 编程的工作原理及其好处：[https://www.agilealliance.org/resources/experience-reports/mob-programming-agile2014/](https://www.agilealliance.org/resources/experience-reports/mob-programming-agile2014/)
- en: 'An article from Scaled Agile on “shifting testing left” and adopting TDD and
    BDD: [https://www.scaledagileframework.com/built-in-quality/](https://www.scaledagileframework.com/built-in-quality/)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scaled Agile 的一篇文章，关于“将测试向左移”和采用 TDD 和 BDD：[https://www.scaledagileframework.com/built-in-quality/](https://www.scaledagileframework.com/built-in-quality/)
- en: 'Article from the **Open Web Application Security Project** (**OWASP**) detailing
    threat modeling: [https://owasp.org/www-community/Threat_Modeling](https://owasp.org/www-community/Threat_Modeling)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 **开放 Web 应用程序安全项目** (**OWASP**) 的文章，详细描述了威胁建模：[https://owasp.org/www-community/Threat_Modeling](https://owasp.org/www-community/Threat_Modeling)
- en: 'Article from the OWASP detailing processes used for threat modeling, including
    ASP and STRIDE: [https://owasp.org/www-community/Threat_Modeling_Process](https://owasp.org/www-community/Threat_Modeling_Process
    )'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这篇来自OWASP的文章详细介绍了用于威胁建模的流程，包括ASP和STRIDE：[https://owasp.org/www-community/Threat_Modeling_Process](https://owasp.org/www-community/Threat_Modeling_Process)
- en: 'An article expanding on Mike Cohn’s testing pyramid: [https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html)'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一篇扩展了Mike Cohn测试金字塔的文章：[https://martinfowler.com/articles/practical-test-pyramid.html](https://martinfowler.com/articles/practical-test-pyramid.html)
- en: 'Scaled Agile article on Agile testing and the Agile Testing Matrix: [https://www.scaledagileframework.com/agile-testing/](https://www.scaledagileframework.com/agile-testing/)'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scaled Agile关于敏捷测试和敏捷测试矩阵的文章：[https://www.scaledagileframework.com/agile-testing/](https://www.scaledagileframework.com/agile-testing/)
- en: 'An article by Smartbear, vendor of two leading service virtualization tools,
    on what service virtualization is, its benefits, and how it compares to stubs:
    [https://smartbear.com/learn/software-testing/what-is-service-virtualization/](https://smartbear.com/learn/software-testing/what-is-service-virtualization/)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Smartbear公司（两款领先服务虚拟化工具的供应商）撰写的关于服务虚拟化的文章，内容包括什么是服务虚拟化，它的好处，以及它与存根的比较：[https://smartbear.com/learn/software-testing/what-is-service-virtualization/](https://smartbear.com/learn/software-testing/what-is-service-virtualization/)
- en: 'Guidance from Scaled Agile on what a system demo is: [https://www.scaledagileframework.com/system-demo/](https://www.scaledagileframework.com/system-demo/)'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scaled Agile关于系统演示的指导：[https://www.scaledagileframework.com/system-demo/](https://www.scaledagileframework.com/system-demo/)
