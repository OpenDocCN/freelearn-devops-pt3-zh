- en: 'Chapter 13: Infrastructure as Code with Terraform'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章：使用 Terraform 实现基础设施即代码
- en: '**Infrastructure as Code** (**IaC**) is the practice of provisioning computing
    infrastructure using machine-readable, declarative specifications or imperative
    code, rather than using an interactive configuration tool. IaC became increasingly
    popular with the rise of cloud computing. Infrastructure administrators who were
    previously maintaining long-lived infrastructure found themselves needing to scale
    in both agility and capacity as companies adopted cloud infrastructure.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础设施即代码**（**IaC**）是使用机器可读的声明性规范或命令式代码来配置计算基础设施的实践，而不是使用交互式配置工具。随着云计算的兴起，IaC
    越来越流行。以前负责维护长期存在的基础设施的基础设施管理员，发现自己在公司采用云基础设施后，既需要在敏捷性上提高，又需要在容量上扩展。'
- en: Remember that at this time, software teams and infrastructure teams were unlikely
    to work closely together until a software project needed to be deployed. IaC created
    a bridge between infrastructure administrators and software developers by establishing
    a shared set of documents that described the desired infrastructure for the software
    project. The IaC specifications or code often live within or alongside the project.
    By establishing this shared context between software developers and infrastructure
    administrators, these two teams were able to work together earlier in the software
    development life cycle and establish a shared vision for infrastructure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在这时，软件团队和基础设施团队通常不会紧密合作，直到需要部署软件项目时。IaC 通过建立一套共享的文档，描述了软件项目所需的基础设施，从而为基础设施管理员和软件开发人员架起了桥梁。IaC
    规范或代码通常存在于项目内部或与项目并行存放。通过在软件开发人员和基础设施管理员之间建立这种共享上下文，这两个团队能够在软件开发生命周期的早期就开始合作，并为基础设施建立共同的愿景。
- en: In this chapter, we'll start off by learning about how Terraform approaches
    IaC and the basics of its usage. After we have a handle on how Terraform works,
    we'll discuss Terraform providers and see how the vast ecosystem of providers
    can empower us to describe and provision a wide variety of resources, not just
    compute infrastructure such as virtual machines. Finally, we'll learn how to extend
    Terraform by building our own pet store Terraform provider.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先学习 Terraform 如何处理 IaC 及其基本用法。在我们掌握 Terraform 的工作原理之后，我们将讨论 Terraform
    提供者，并看看如何通过丰富的提供者生态系统来描述和配置各种资源，而不仅仅是计算基础设施，如虚拟机。最后，我们将学习如何通过构建我们自己的宠物商店 Terraform
    提供者来扩展 Terraform。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to IaC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IaC 简介
- en: Understanding the basics of Terraform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Terraform 的基础知识
- en: Understanding the basics of Terraform providers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Terraform 提供者的基础知识
- en: Building a pet store Terraform provider
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建宠物商店 Terraform 提供者
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you will need to have the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你需要具备以下内容：
- en: Docker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Git
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Go
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: 'The Terraform CLI: [https://learn.hashicorp.com/tutorials/terraform/install-cli](https://learn.hashicorp.com/tutorials/terraform/install-cli)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform CLI：[https://learn.hashicorp.com/tutorials/terraform/install-cli](https://learn.hashicorp.com/tutorials/terraform/install-cli)
- en: 'The Azure CLI: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure CLI：[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)
- en: 'The code for this chapter: [https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider](https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码：[https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider](https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider)
- en: Let's get started by learning some Terraform basics.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习一些 Terraform 基础知识开始。
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/13/petstore-provider](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/13/petstore-provider)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以从 [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/13/petstore-provider](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/13/petstore-provider)
    下载
- en: An introduction to IaC
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IaC 简介
- en: IaC had a significant impact beyond bringing infrastructure and software development
    teams together; the practice also made it much easier and safer to deploy infrastructure
    for projects. By defining the infrastructure and storing the specifications in
    a software project, the infrastructure code could be tested in the same way that
    the software project was tested. As with testing code, consistently testing infrastructure
    code reduces bugs, surfaces inefficiencies, and increases confidence in the infrastructure
    deployment process.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: IaC 不仅促进了基础设施与软件开发团队的合作，还使得项目基础设施的部署变得更加简便和安全。通过定义基础设施并将规范存储在软件项目中，基础设施代码可以像测试软件项目一样进行测试。与测试代码一样，持续测试基础设施代码能够减少缺陷、发现低效之处，并提高对基础设施部署过程的信心。
- en: We take it for granted today, but in many organizations, working with infrastructure
    administrators to build a cluster for a non-trivial application could take weeks.
    Taking that same experience, condensing it into a handful of files, and then being
    able to deploy a cluster in minutes was a game changer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 今天我们已经习惯了这一点，但在许多组织中，与基础设施管理员合作为一个复杂的应用程序构建集群可能需要几周时间。将这一经验压缩成少数几个文件，然后能够在几分钟内部署集群，这一变化具有革命性意义。
- en: There are many IaC tools available. Each has its own flavor for how the tool
    approaches the problem of describing and provisioning infrastructure. Though they
    are all a bit different, each tool can be categorized using a couple of facets,
    by how the code is specified by the author, and by how it deals with changes to
    code. The foremost category is how the infrastructure code is specified. Specifically,
    the code is a declarative specification describing the desired state (what to
    provision), or the code is a set of imperative steps described in a programming
    language (how to provision). The second category is how the tool applies the infrastructure,
    push or pull. Pull IaC tools watch for changes to code in a centralized repository.
    Push IaC tools apply their changes to the destination system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有许多 IaC 工具，每个工具在描述和配置基础设施时都有自己独特的方式。虽然它们各有不同，但每个工具都可以通过两个方面来分类：一是作者如何指定代码，二是工具如何处理代码的变更。最重要的分类是基础设施代码如何被指定。具体而言，代码是一种声明式的规范，描述所需的状态（要配置什么），或者代码是用编程语言描述的一系列命令性步骤（如何配置）。第二个分类是工具如何应用基础设施，推送（Push）或拉取（Pull）。拉取式
    IaC 工具会监视中央仓库中代码的变化，推送式 IaC 工具则将其更改应用到目标系统中。
- en: IaC is a critical practice in bridging the gap between writing, delivering,
    and operating software. It is one of the key areas where development overlaps
    with operations. Mastering the practice will better enable your team to deliver
    software faster with greater agility and reliability.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: IaC 是在编写、交付和运维软件之间架起桥梁的关键实践之一。它是开发与运维交集的关键领域之一。掌握这一实践将使您的团队能够更快、更灵活、更可靠地交付软件。
- en: Understanding the basics of Terraform
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Terraform 的基础知识
- en: '**Terraform** ([https://www.terraform.io/](https://www.terraform.io/)) is an
    open source IaC tool written in Go and created by HashiCorp that provides a consistent
    command-line experience for managing a wide variety of resources. With Terraform,
    infrastructure engineers define the desired state of a set of hierarchical resources
    using declarative Terraform configuration files or with imperative code ([https://www.terraform.io/cdktf](https://www.terraform.io/cdktf)),
    which results in Terraform configurations files. These configuration files are
    the code in IaC. They can be used to manage the full life cycle of creating, mutating,
    and destroying resources, plan and predict changes to resources, provide a graph
    of dependencies in complex resource topologies, and store the last observed state
    of a system.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Terraform** ([https://www.terraform.io/](https://www.terraform.io/)) 是一个由
    HashiCorp 创建、用 Go 编写的开源 IaC 工具，提供一致的命令行体验来管理各种资源。通过 Terraform，基础设施工程师可以使用声明式的
    Terraform 配置文件或命令式代码（[https://www.terraform.io/cdktf](https://www.terraform.io/cdktf)）定义一组层次化资源的期望状态，从而生成
    Terraform 配置文件。这些配置文件就是 IaC 中的代码。它们可以用于管理资源的整个生命周期，包括创建、修改和销毁资源，计划并预测资源变更，提供复杂资源拓扑中的依赖关系图，并存储系统的最后观察状态。'
- en: Terraform is simple to get started and has a fairly linear learning curve. There
    are many features of Terraform we will not cover in this chapter that will be
    useful as you deepen your adoption of the tool. The goal of this chapter is not
    to become an expert with Terraform but rather to show you how to get started and
    be effective quickly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 非常容易上手，并且有一个相对平缓的学习曲线。在本章中，我们不会涵盖 Terraform 的许多功能，但这些功能在你深入使用工具时会非常有用。本章的目标不是让你成为
    Terraform 的专家，而是帮助你快速上手并高效使用。
- en: In this section, you will learn the basics of how Terraform operates, and how
    to use the Terraform CLI. We'll start off with a simple example and discuss what
    happens at execution time. By the end of the section, you should feel comfortable
    defining resources, initializing, and applying using the Terraform CLI.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将学习 Terraform 如何运作的基础知识，以及如何使用 Terraform CLI。我们将从一个简单的示例开始，并讨论执行时发生的事情。到本节结束时，你应该能够熟练地使用
    Terraform CLI 定义资源、初始化并应用。
- en: Initializing and applying infrastructure specs using Terraform
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Terraform 初始化和应用基础设施规范
- en: In the first part of this section, we will discuss resources rather than infrastructure
    components. Discussing resources and components is rather abstract. Let's use
    a concrete example to explain the normal flow of actions with Terraform.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一部分，我们将讨论资源而不是基础设施组件。讨论资源和组件较为抽象。让我们用一个具体的例子来解释使用 Terraform 的正常操作流程。
- en: 'For our first example, we will use a directory structured like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个示例，我们将使用如下所示的目录结构：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding block, we have a directory with a single `main.tf` file. In
    that file, we will add the following content:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码块中，我们有一个目录，里面有一个名为 `main.tf` 的文件。在该文件中，我们将添加以下内容：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding Terraform `main.tf` configuration file, we define a `local_file`
    resource named `foo` with the `foo!` content located at `${path.module}/foo.txt.
    ${path.module}` is the filesystem path of the module, in this case, `./foo.txt`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述 Terraform `main.tf` 配置文件中，我们定义了一个名为 `foo` 的 `local_file` 资源，并将其内容设置为 `foo!`，该文件位于
    `${path.module}/foo.txt`。`${path.module}` 是模块的文件系统路径，在此例中为 `./foo.txt`。
- en: 'We can simply run the following to initialize Terraform in the directory and
    apply the desired state:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地运行以下命令来初始化 Terraform 并应用所需的状态：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding `terraform init` command will check the validity of `main.tf`,
    pull down the providers needed, and initialize the local state of the project.
    After the `init` command is executed, the `apply` command will be executed. We''ll
    break these down into two parts, `init` and then `apply`. The `init` command should
    output the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`terraform init`命令将检查`main.tf`的有效性，拉取所需的提供程序，并初始化项目的本地状态。在执行`init`命令后，将执行`apply`命令。我们将这两个命令分为两部分来讨论，首先是`init`，然后是`apply`。`init`命令应输出以下内容：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see from the preceding output, Terraform installed the `hashicorp/local`
    provider at a specific version. Terraform then saved the version to a local lock
    file, `.terraform.lock.hcl`, to ensure that the same version is used in the future,
    establishing the information needed to have a reproducible build. Finally, Terraform
    provides instructions for using `terraform plan` to see what Terraform will do
    to reach the desired state described in `main.tf`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如上面的输出所示，Terraform 安装了特定版本的`hashicorp/local`提供程序。然后，Terraform 将该版本保存到本地锁定文件`.terraform.lock.hcl`中，以确保未来使用相同的版本，从而确保可重现的构建。最后，Terraform
    提供了使用`terraform plan`查看 Terraform 将如何执行以达到`main.tf`中描述的所需状态的指令。
- en: 'After initialization, running `terraform apply` will trigger Terraform to determine
    the current desired state and compare it to the known state of the resources in
    `main.tf`. `terraform apply` presents the operator with a plan of the operations
    that will be executed. Upon operator approval of the plan, Terraform executes
    the plan and stores the updated state of the resources. Let''s see the output
    from `terraform apply`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，运行`terraform apply`将触发 Terraform 确定当前所需的状态，并与`main.tf`中资源的已知状态进行比较。`terraform
    apply`会向操作员呈现即将执行的操作计划。经操作员批准计划后，Terraform 执行该计划并保存资源的更新状态。我们来看一下`terraform apply`的输出：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After confirming the plan by entering `yes`, Terraform has applied the desired
    state and created the resource, a local file. The directory should look like the
    following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认计划并输入`yes`后，Terraform 已应用所需的状态并创建了一个本地文件资源。目录应如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding directory structure, we can see the local provider that Terraform
    used to provision the file, the Terraform lock file, the `foo.txt` file, and a
    `terraform.tfstate` file. Let''s explore `foo.txt` and the `terraform.tfstate`
    files:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的目录结构中，我们可以看到Terraform用于配置文件的本地提供程序、Terraform锁文件、`foo.txt`文件和`terraform.tfstate`文件。让我们探索一下`foo.txt`和`terraform.tfstate`文件：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we described in `main.tf`, Terraform has created `foo.txt` with the `foo!`
    content. Next, let''s look at `terraform.tfstate`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`main.tf`中描述的那样，Terraform已经创建了包含`foo!`内容的`foo.txt`。接下来，让我们看看`terraform.tfstate`：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `terraform.tfstate` file is a bit more interesting than `foo.txt`. The `tfstate`
    file is where Terraform stores its last known state for the resources applied
    in the plan. This enables Terraform to inspect the differences with the last known
    state and build a plan for updating the resource if the desired state changes
    in the future.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform.tfstate`文件比`foo.txt`更为有趣。`tfstate`文件是Terraform存储计划中已应用资源的最后已知状态的地方。这使得Terraform能够检查与最后已知状态的差异，并在未来所需状态发生变化时，生成更新资源的计划。'
- en: 'Next, let''s change the desired state in `main.tf` and see what happens when
    we apply the configuration again. Let''s update `main.tf` to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`main.tf`中更改所需的状态，并查看再次应用配置时会发生什么。我们将`main.tf`更新为如下：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that we''ve changed the content of `foo.txt` and added file permissions
    to the resource. Now, let''s apply the desired state and see what happens:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已更改了`foo.txt`的内容，并为该资源添加了文件权限。现在，让我们应用所需状态，看看会发生什么：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Terraform was able to determine the attributes of the resource that have changed
    and create a plan for reaching the desired state. As the plan output states with
    `1` to add, `0` to change, `1` to destroy, the local `foo.txt` file will be deleted
    and then recreated, since a change to the file permissions forces the replacement
    of the file. This example illustrates that a single attribute change can, but
    does not always, cause the deletion and recreation of a resource. Note that we
    added the `-auto-approve` flag to the `apply` command. As the name implies, this
    will not prompt approval of the plan before it is applied. You may want to use
    caution when using that flag, as it's good practice to check the plan to ensure
    that the actions you expect are the actions described in the plan.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform能够确定资源已更改的属性，并为达到所需状态创建计划。正如计划输出中所示，`1`个添加，`0`个更改，`1`个销毁，表示本地的`foo.txt`文件将被删除并重新创建，因为文件权限的更改迫使该文件被替换。这个例子说明了，单一属性的更改可能会（但不总是）导致资源的删除和重建。请注意，我们为`apply`命令添加了`-auto-approve`标志。顾名思义，这将不会在应用计划之前提示审批。在使用该标志时，你可能需要小心，因为检查计划确保你期望的操作与计划中描述的操作一致是一个好习惯。
- en: 'Let''s see the new contents of `foo.txt`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`foo.txt`的新内容：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the content of `foo.txt` has been updated to reflect the desired
    state. Now, let''s examine the directory:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`foo.txt`的内容已经更新，以反映所需的状态。现在，让我们检查一下目录：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that a new file was created, `terraform.tfstate.backup`. This is a copy
    of the previous `tfstate` file in case the new `tfstate` file is corrupted or
    lost.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，创建了一个新文件，`terraform.tfstate.backup`。这是之前`tfstate`文件的副本，以防新的`tfstate`文件损坏或丢失。
- en: By default, the `tfstate` files are stored locally. When working individually,
    this is perfectly fine; however, when working with a team, it would become difficult
    to share the most recent state with others. This is where remote state ([https://www.terraform.io/language/state/remote](https://www.terraform.io/language/state/remote))
    becomes extremely useful. We will not cover this feature here, but you should
    be aware of it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`tfstate`文件是存储在本地的。在个人工作时，这完全没问题；然而，在团队合作时，就会变得难以与其他人共享最新的状态。此时，远程状态（[https://www.terraform.io/language/state/remote](https://www.terraform.io/language/state/remote)）变得非常有用。我们在这里不讨论这一功能，但你应该了解它。
- en: 'Finally, we will destroy the resource we have created:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将销毁我们已创建的资源：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running `terraform destroy` will clean up all of the resources described in
    the desired state. If you examine your directory, you will see that the `foo.txt`
    file has been deleted.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`terraform destroy`将清理所有在所需状态中描述的资源。如果你检查你的目录，你会发现`foo.txt`文件已被删除。
- en: Congratulations! You have covered the absolute basics of Terraform. We have
    learned at a high level how Terraform operates and how to use the Terraform CLI.
    We created a simple local file resource, mutated it, and destroyed it. In the
    next section, we'll discuss Terraform providers and explore the world that opens
    up when we take advantage of the vast ecosystem of them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经掌握了 Terraform 的基础知识。我们从高层次了解了 Terraform 是如何操作的以及如何使用 Terraform CLI。我们创建了一个简单的本地文件资源，修改了它，并销毁了它。在下一节中，我们将讨论
    Terraform 提供商，并探索利用这些提供商所打开的广阔世界。
- en: Understanding the basics of Terraform providers
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Terraform 提供商的基础知识
- en: At its heart, Terraform is a platform for reconciling an expressed desired state
    with an external system. The way Terraform interacts with external APIs is through
    plugins called **providers**. A provider is responsible for describing the schema
    for its exposed resources, and implementing **Create, Read, Update, and Delete**
    (**CRUD**) interactions with external APIs. Providers enable Terraform to express
    nearly any external API's resources as Terraform resources.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Terraform 是一个平台，用于将表达的期望状态与外部系统进行对比。Terraform 与外部 API 交互的方式是通过名为 **提供商**
    的插件。提供商负责描述其公开资源的架构，并实现与外部 API 的 **创建、读取、更新和删除**（**CRUD**）交互。提供商使 Terraform 能够将几乎所有外部
    API 的资源表示为 Terraform 资源。
- en: Through its thousands of community and verified providers, Terraform is able
    to manage resources including databases such as Redis, Cassandra, and MongoDB,
    cloud infrastructure for all major cloud service providers, communication and
    messaging services such as Discord and SendGrid, and a vast number of other providers.
    If you are interested, you can explore a listing of them in the Terraform Registry
    ([https://registry.terraform.io/](https://registry.terraform.io/)). You can simply
    write, plan, and apply your way to your desired infrastructure.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过其成千上万的社区和验证过的提供商，Terraform 能够管理包括 Redis、Cassandra 和 MongoDB 等数据库，所有主要云服务提供商的云基础设施，Discord
    和 SendGrid 等通信和消息服务，以及大量其他提供商。如果你有兴趣，可以在 Terraform 注册表中查看它们的列表 ([https://registry.terraform.io/](https://registry.terraform.io/))。你只需编写、规划并应用，即可实现你所期望的基础设施。
- en: In this section, we will build on our experience of using a local provider and
    extend what we learned to use a provider that interacts with an external API.
    We will define the desired state for a set of cloud resources and provision them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将基于使用本地提供商的经验，并将我们学到的知识扩展到使用与外部 API 交互的提供商。我们将为一组云资源定义期望的状态并进行配置。
- en: Defining and provisioning cloud resources
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和配置云资源
- en: 'Imagine that we want to deploy infrastructure to our cloud service provider.
    In this case, we''re going to use Microsoft Azure via the `hashicorp/azurerm`
    provider. In an empty directory, let''s start by authoring a simple `main.tf`
    file like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要将基础设施部署到我们的云服务提供商。此时，我们将通过 `hashicorp/azurerm` 提供商使用 Microsoft Azure。在一个空目录中，让我们从编写一个简单的
    `main.tf` 文件开始，如下所示：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding Terraform configuration file requires the `hashicorp/azurerm`
    provider and defines a resource group named `mygroup` in the `southcentralus`
    region (a resource group is an Azure concept that groups infrastructure resources
    together).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 Terraform 配置文件需要 `hashicorp/azurerm` 提供商，并在 `southcentralus` 区域定义了一个名为 `mygroup`
    的资源组（资源组是 Azure 的一个概念，用于将基础设施资源组合在一起）。
- en: 'To run the rest of the examples in this section, you will need an Azure account.
    If you do not have an Azure account, you can sign up for a free account with $200
    of Azure credits: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本节中的其他示例，你需要一个 Azure 账户。如果你没有 Azure 账户，可以注册一个免费账户，获得 $200 的 Azure 信用： [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: 'Once you have an account, log in with the Azure CLI:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你拥有账户，请使用 Azure CLI 登录：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding command will log you into your Azure account and set the default
    context to your primary Azure subscription. To see what subscription is active,
    run the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将使你登录到 Azure 账户，并将默认上下文设置为你的主 Azure 订阅。要查看当前活跃的订阅，可以运行以下命令：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding command output shows the name of the subscription and other details
    about the current context of the Azure CLI. The `azurerm` provider will use the
    authentication context of the Azure CLI to interact with the Azure APIs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出显示了订阅名称和 Azure CLI 当前上下文的其他详细信息。`azurerm` 提供商将使用 Azure CLI 的认证上下文与 Azure
    API 进行交互。
- en: 'Now that we have an authenticated Azure session on the Azure CLI, let''s use
    `init` and `apply` to create our desired state. Within the directory containing
    the `main.tf` file, run the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在 Azure CLI 上完成了身份验证的 Azure 会话，接下来让我们使用`init`和`apply`来创建我们期望的状态。在包含`main.tf`文件的目录下，运行以下命令：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`terraform init` will initialize the directory, pulling down the latest `azurerm`
    provider. By specifying the `~> 3.0` version constraint, Terraform is directed
    to install the latest version of the provider in the `3.0.x` series. You should
    see something like the following output from `init`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform init`将初始化目录，并下载最新的`azurerm`提供程序。通过指定`~> 3.0`版本约束，Terraform会安装`3.0.x`系列中的最新版本。您应该会看到类似于以下的`init`输出：'
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This output should look familiar from the *Initializing and applying infrastructure
    specs using Terraform* section. After initialization, you will again be greeted
    with the plan for creating the desired resources. Once the plan is approved, the
    desired resources are created. The output should look like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这段输出应该在*使用 Terraform 初始化和应用基础设施规范*部分中看过。初始化完成后，您将再次看到创建所需资源的计划。计划获得批准后，所需资源会被创建。输出应该像下面这样：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see from the preceding output, the resource group is created.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出中可以看到，资源组已经创建。
- en: Note
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are using a free Azure account, you may not have regional capacity in
    the `southcentralus` location. You may need to use a different region such as
    `centralus` or `northeurope`. To find out more information on what region would
    be best for you, view the Azure geography guidance here: [https://azure.microsoft.com/en-us/global-infrastructure/geographies/#geographies](https://azure.microsoft.com/en-us/global-infrastructure/geographies/#geographies).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是免费的 Azure 账户，可能在` southcentralus`区域没有配额。您可能需要使用其他区域，如`centralus`或`northeurope`。要了解更多关于适合您的区域的信息，可以查看
    Azure 地理位置指南：[https://azure.microsoft.com/en-us/global-infrastructure/geographies/#geographies](https://azure.microsoft.com/en-us/global-infrastructure/geographies/#geographies)。
- en: 'Opening the Azure portal and navigating to the **Resource groups** view, you
    should see the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Azure 门户并导航到**资源组**视图，您应该能看到以下内容：
- en: '![Figure 13.1 – The created resource group in Azure'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.1 – 在 Azure 中创建的资源组'
- en: '](img/B17626_13_001.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_13_001.jpg)'
- en: Figure 13.1 – The created resource group in Azure
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 在 Azure 中创建的资源组
- en: In the preceding screenshot, we can see our newly created Azure resource group,
    `mygroup`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到我们新创建的 Azure 资源组，`mygroup`。
- en: 'Let''s see what new files have been added to our local directory after running
    `init` and `apply`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在运行`init`和`apply`后，哪些新文件被添加到了本地目录中：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Similar to the previous section, we can see the Terraform lock and state files.
    However, in the `providers` directory, we now see that the `azurerm` provider
    was installed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的部分类似，我们可以看到 Terraform 的锁定文件和状态文件。然而，在`providers`目录中，我们现在可以看到安装了`azurerm`提供程序。
- en: 'Let''s add some more resources and apply them. You can find a listing of all
    of the supported resources in the Azure provider documentation ([https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs](https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs)).
    We''ll update the `main.tf` file to contain the following resources:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些资源并应用它们。您可以在 Azure 提供程序文档中找到所有受支持资源的列表（[https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs](https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs)）。我们将更新`main.tf`文件，包含以下资源：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The resources added to the preceding `main.tf` file include two Azure resources,
    an App Service plan, a Linux web app, and one `random_integer` resource. The Azure
    App Service plan defines a regional deployment of compute infrastructure for running
    a Linux-based web application. The Azure Linux web app is associated with the
    Azure App Service plan and is configured to run a hello world NGINX demo container
    image. The `random_integer` resource is needed to provide some random input for
    the **Fully Qualified Domain Name** (**FQDN**) for the Linux web app.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到前面的`main.tf`文件中的资源包括两个 Azure 资源，一个应用服务计划，一个 Linux Web 应用，以及一个`random_integer`资源。Azure
    应用服务计划定义了一个区域性的计算基础设施部署，用于运行基于 Linux 的 Web 应用。Azure Linux Web 应用与 Azure 应用服务计划相关联，并配置为运行一个
    hello world NGINX 演示容器镜像。`random_integer`资源需要提供一些随机输入，用于**完全限定域名**（**FQDN**）的配置，供
    Linux Web 应用使用。
- en: Note the use of variables. For example, we use `azurerm_resource_group.mygroup.name`
    to provide the value for `resource_group_name` in the `azure_service_plan` resource.
    Variable usage helps to minimize the number of string literals in the configuration
    files. This is helpful when making a change because you can make it in one place,
    rather than each occurrence of the string.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意变量的使用。例如，我们使用`azurerm_resource_group.mygroup.name`为`azure_service_plan`资源中的`resource_group_name`提供值。使用变量有助于最小化配置文件中的字符串字面值数量。这在进行修改时很有帮助，因为你可以在一个地方进行修改，而不是在每个字符串出现的地方修改。
- en: Also, note the use of an output variable, `host_name`. This instructs Terraform
    to output the `host_name` key with the value of `azurerm_linux_web_app.myapp.default_hostname`
    after the completion of `terraform apply`. We'll use this output to make it easier
    to open the website after it is provisioned.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意使用输出变量`host_name`。这指示 Terraform 在`terraform apply`完成后输出`host_name`键，值为`azurerm_linux_web_app.myapp.default_hostname`。我们将使用此输出，以便在网站部署后更方便地打开它。
- en: 'Let''s run `terraform apply` again and see what happens:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行`terraform apply`，看看会发生什么：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Oh no! `terraform apply` responds with an error, informing us that we have
    a new provider added to the configuration that we didn''t have last time. Run
    `terraform init -upgrade`, and the `random` module will be added:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！`terraform apply`返回了一个错误，提示我们在配置中添加了一个新提供者，而上次没有这个。运行`terraform init -upgrade`，`random`模块将被添加：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should see some output like the preceding that shows Terraform installing
    the latest version of the `hashicorp/random` provider. Let''s see what our directory
    looks like now that we''ve added the provider:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似上面的输出，显示 Terraform 正在安装最新版本的`hashicorp/random`提供者。让我们看看在添加了提供者后，我们的目录现在是什么样子的：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, the `random` provider is now installed. We should be ready
    to use `apply` again:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`random`提供者现在已安装。我们应该可以再次使用`apply`了：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We've omitted some of the output of `terraform apply`. The things to note here
    are that we are creating each of the resources we described in `main.tf`, they
    have provisioned successfully, and `host_name` contains a **Universal Resource
    Identifier** (**URI**) for accessing the newly deployed web application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了`terraform apply`的部分输出。需要注意的是，我们正在创建`main.tf`中描述的每个资源，它们已经成功配置，并且`host_name`包含了一个**通用资源标识符**（**URI**），用于访问新部署的
    Web 应用。
- en: 'Take the `host_name` URI and open it in a browser. You should see the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`host_name`的URI并在浏览器中打开。你应该会看到如下内容：
- en: '![Figure 13.2 – NGINX running in Azure App Service'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 13.2 – NGINX 运行在 Azure 应用服务中'
- en: '](img/B17626_13_002.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_13_002.jpg)'
- en: Figure 13.2 – NGINX running in Azure App Service
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – NGINX 运行在 Azure 应用服务中
- en: If you go back to the Azure portal, you will also see the resources created
    within your resource group.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你返回到 Azure 门户，你也会看到在你的资源组内创建的资源。
- en: I hope you will take some time to experiment by defining and applying other
    resources. Once you get the hang of using providers and some basic syntax, Terraform
    is a joy to work with. When you are done with your resources, just run `terraform
    destroy`, and they will be deleted.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能花点时间通过定义和应用其他资源进行实验。一旦你掌握了使用提供者和一些基本语法，Terraform将变得非常愉快。当你完成资源配置后，只需运行`terraform
    destroy`，它们将被删除。
- en: In this section, we learned some basics about using providers to manipulate
    cloud resources. We only need to use a couple of providers, but as discussed in
    the opening of the section, there are thousands of providers out there. It's very
    likely that you will be able to find a provider to solve your problem. However,
    there may be APIs and resources you would like to manage with Terraform without
    an existing provider. In the next section, we will build a Terraform provider
    for a fictional pet store.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了使用提供者来操作云资源的一些基础知识。我们只需要使用几个提供者，但正如本节开头所讨论的那样，世上有成千上万的提供者。你很可能能够找到一个提供者来解决你的问题。然而，也可能有一些你希望用
    Terraform 管理的 API 和资源，而没有现成的提供者。在下一节中，我们将为一个虚构的宠物商店构建一个 Terraform 提供者。
- en: Building a pet store Terraform provider
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建宠物商店 Terraform 提供者
- en: Even though the Terraform provider registry ([https://registry.terraform.io/](https://registry.terraform.io/))
    has almost every provider you can think of, there is a chance that a provider
    you need does not yet exist. Perhaps you want to use Terraform to interact with
    resources of a proprietary API internal to your company. If you want to manage
    resources that don't yet exist in the Terraform provider ecosystem, you will need
    to write a provider for that API. The good news is that writing a Terraform provider
    is relatively simple. The thoughtful folks at HashiCorp provide great documentation,
    SDKs, and tools to make building a provider a breeze.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Terraform 提供商注册表 ([https://registry.terraform.io/](https://registry.terraform.io/))
    几乎涵盖了您能想到的每个提供商，但您可能需要的提供商尚未存在。也许您希望使用 Terraform 与公司内部的专有 API 资源进行交互。如果您想管理尚不存在于
    Terraform 提供商生态系统中的资源，您将需要为该 API 编写一个提供商。好消息是，编写 Terraform 提供商相对简单。HashiCorp 的负责人提供了出色的文档、SDK
    和工具，使构建提供商变得轻而易举。
- en: In the previous sections, we learned the basics of Terraform and how to use
    providers to interact with resources in both local and external systems. We were
    able to build cloud resources to deploy a Linux web application running in a container.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了 Terraform 的基础知识以及如何使用提供商与本地和外部系统中的资源进行交互。我们能够构建云资源以部署运行在容器中的 Linux
    Web 应用程序。
- en: In this section, we will build upon the previous sections and learn how to build
    our own provider. The Terraform provider we are building in this section will
    expose pet resources and will interact with a local `docker-compose-h`osted pet
    store service to simulate an external API.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在前几节的基础上构建，并学习如何构建我们自己的提供商。我们在本节中构建的 Terraform 提供商将暴露宠物资源，并与本地 `docker-compose-h`osted
    宠物店服务交互，以模拟外部 API。
- en: You will learn how to define custom resources with a strong schema and validations,
    create data sources, and implement CRUD interactions for our pet resources. Finally,
    we'll discuss publishing a module for the world to use via the Terraform provider
    registry.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何定义具有强大模式和验证的自定义资源，创建数据源，并为我们的宠物资源实施 CRUD 交互。最后，我们将讨论通过 Terraform 提供商注册表发布供全球使用的模块。
- en: Resources for building custom providers
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建自定义提供商的资源
- en: HashiCorp provides an extensive set of tutorials for building custom providers
    ([https://learn.hashicorp.com/collections/terraform/providers](https://learn.hashicorp.com/collections/terraform/providers)).
    I highly recommend reviewing the content if you intend on building your own custom
    provider.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp 提供了一套广泛的教程，用于构建自定义提供商 ([https://learn.hashicorp.com/collections/terraform/providers](https://learn.hashicorp.com/collections/terraform/providers))。如果您打算构建自己的自定义提供商，我强烈推荐查阅这些内容。
- en: The code for this section is located in [https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider](https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider).
    We will not cover all of the code, but we will dive into the most interesting
    parts. I've done my best to keep to only the most simple implementation; however,
    simple is not always elegant.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码位于 [https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider](https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider)。我们不会覆盖所有代码，但我们将深入探讨最有趣的部分。我尽力保持只保留最简单的实现；然而，简单并不总是优雅。
- en: Additionally, our pet store custom provider uses the Terraform plugin SDK v2
    ([https://www.terraform.io/plugin/sdkv2/sdkv2-intro](https://www.terraform.io/plugin/sdkv2/sdkv2-intro))
    rather than the new (at the time of writing) Terraform plugin framework. I chose
    this path as the majority of existing providers use the SDK v2, and *the Terraform
    plugin framework* ([https://www.terraform.io/plugin/framework](https://www.terraform.io/plugin/framework))
    has not reached stability yet. If you are interested in weighing the benefits,
    read the *Which SDK Should I Use?* article from HashiCorp ([https://www.terraform.io/plugin/which-sdk](https://www.terraform.io/plugin/which-sdk)).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的宠物店自定义提供商使用的是 Terraform 插件 SDK v2 ([https://www.terraform.io/plugin/sdkv2/sdkv2-intro](https://www.terraform.io/plugin/sdkv2/sdkv2-intro))，而不是新的（在撰写本文时）Terraform
    插件框架。我选择这条路线是因为大多数现有的提供商都使用 SDK v2，而 *Terraform 插件框架* ([https://www.terraform.io/plugin/framework](https://www.terraform.io/plugin/framework))
    尚未达到稳定性。如果您对权衡利弊感兴趣，请阅读 HashiCorp 的 *Which SDK Should I Use?* 文章 ([https://www.terraform.io/plugin/which-sdk](https://www.terraform.io/plugin/which-sdk))。
- en: Now that we have established a foundation of content and learning, let's proceed
    to the code.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了内容和学习的基础，让我们继续进行代码编写。
- en: The pet store provider
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宠物店提供商
- en: 'Our pet store Terraform provider is just another Go application. Most of the
    interactions between Terraform and the provider are handled at the Terraform SDK
    level, and very little gets in the way of the provider developer. Let''s start
    off by taking a look at the directory structure of the provider:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的宠物商店Terraform提供者只是另一个Go应用程序。Terraform和提供者之间的大部分交互都是在Terraform SDK层面处理的，很少有东西会干扰到提供者开发者。让我们首先来看一下提供者的目录结构：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As I said, it''s a standard Go application with an entry point in `main.go`.
    Let''s start at the top and work our way down the files. The first on the list
    is the Makefile:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我之前说的，这是一个标准的Go应用程序，入口点在`main.go`中。让我们从顶部开始，逐步查看文件。列表中的第一个是Makefile：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding Makefile offers some helpful build tasks and environmental configuration.
    For example, `make` or `make install` will build the provider for the current
    architecture and place it in the `~/.terraform.d/plugins` directory tree, which
    will enable us to use the provider locally without publishing it to the registry.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的Makefile提供了一些有用的构建任务和环境配置。例如，`make`或`make install`会根据当前架构构建提供者，并将其放置在`~/.terraform.d/plugins`目录树中，这样我们就可以在本地使用该提供者，而无需将其发布到注册表中。
- en: 'Next, we have the `docker-compose.yml` file. Let''s take a look:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`docker-compose.yml`文件。让我们看一下：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `docker-compose.yml` file runs the pet store service from [*Chapter 10*](B17626_10.xhtml#_idTextAnchor496),
    *Automating Workflows with GitHub Actions*, and exposes the gRPC service on port
    `6742`. The pet store service stores pets in an in-memory store, so to wipe out
    the pets currently stored, just restart the service. We'll talk more about starting
    and stopping the service later in the section.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yml`文件运行来自[*第10章*](B17626_10.xhtml#_idTextAnchor496)的宠物商店服务，*使用GitHub
    Actions自动化工作流*，并在端口`6742`上暴露gRPC服务。宠物商店服务将宠物存储在内存中，因此要清除当前存储的宠物，只需重新启动该服务即可。稍后我们将在本节中讨论如何启动和停止服务。'
- en: 'Next up, we have `examples/main.tf`. Let''s see what an example of defining
    our pet resources will look like:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看`examples/main.tf`。让我们看看定义我们宠物资源的示例：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding `main.tf` file, we can see the provider registered and configured
    to use the local pet store service. We can also see the definition for two `petstore_pet`
    resources, `Thor` and `Tron`. After the resources, we define a `petstore_pet`
    data source. We will walk through bits of this file in more detail later in the
    section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`main.tf`文件中，我们可以看到提供者已注册并配置为使用本地宠物商店服务。我们还可以看到定义了两个`petstore_pet`资源，分别是`Thor`和`Tron`。在这些资源之后，我们定义了一个`petstore_pet`数据源。稍后我们将更详细地介绍文件的各个部分。
- en: The main reason I'd like you to see `main.tf` before we get into the code is
    that it will give you an idea of the interface we want to achieve in the provider
    implementation. I believe seeing the usage of the provider will help you to better
    understand the provider implementation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你在进入代码之前先看到`main.tf`，因为它会给你一个关于我们希望在提供者实现中实现的接口的概念。我相信看到提供者的使用将帮助你更好地理解提供者的实现。
- en: 'The rest of the source code is all in Go, so rather than going from top to
    bottom, I''m going to move to the entry point in `main.go` and dive into the actual
    implementation:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的源代码全部是Go语言编写的，所以与其从上到下查看，我打算跳到`main.go`中的入口点，深入了解实际的实现：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Well, `main.go` is simple enough. All we are doing in `main` is starting a
    plugin server via the Terraform plugin SDK v2 and providing it with an implementation
    of our pet store provider. Let''s next look at the `petstore.Provider` implementation
    in `internal/provider.go`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，`main.go`是足够简单的。在`main`中，我们所做的就是通过Terraform插件SDK v2启动一个插件服务器，并为其提供我们的宠物商店提供者的实现。接下来，让我们看看`internal/provider.go`中的`petstore.Provider`实现：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There are only two funcs in `provider.go`. The `Provider` func creates an `*schema.Provider`
    that describes the schema for configuring the provider, the resources of the provider,
    the data sources of the provider, and the configure func for initializing the
    provider. The resource map for the provider contains resources by a string name
    and their schemas. The schemas for each of the structures describe the domain-specific
    language to Terraform for interacting with their fields and resource hierarchies.
    We will examine the schemas for these structures in more detail soon.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`provider.go` 中只有两个函数。`Provider` 函数创建一个 `*schema.Provider`，该提供者描述了配置提供者的架构、提供者的资源、提供者的数据源以及用于初始化提供者的配置函数。提供者的资源映射通过字符串名称包含资源及其架构。每个结构的架构描述了与
    Terraform 交互的领域特定语言，以操作其字段和资源层次结构。我们将在稍后详细查看这些结构的架构。'
- en: 'Next, let''s look at the `configure` func in `provider.go`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看 `provider.go` 中的 `configure` 函数：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `configure` func is responsible for handling provider configuration. Note
    how the `host` data described in the preceding `Provider` schema is available
    via the `data` argument. This is a common pattern you will see throughout the
    provider. We use the `host` configuration data to construct the client for the
    pet store service. If we are unable to construct a pet store client, we append
    a `diag.Diagnostic` structure to the slice of `diag.Diagnostics`. These diagnostic
    structures inform Terraform of an event of varying severity occurring in the provider.
    In this case, it is an error if we are unable to build the client, which should
    be communicated back to the user. If all goes well, we return the `client` instance
    and an empty slice of `diag.Diagnostics`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`configure` 函数负责处理提供者配置。请注意，前面 `Provider` 架构中描述的 `host` 数据通过 `data` 参数提供。这是你将在整个提供者中看到的常见模式。我们使用
    `host` 配置数据来构建宠物店服务的客户端。如果无法构建宠物店客户端，我们会将一个 `diag.Diagnostic` 结构附加到 `diag.Diagnostics`
    切片中。这些诊断结构会通知 Terraform 提供者中发生的不同严重性的事件。在这种情况下，如果我们无法构建客户端，则会发生错误，并应将此信息反馈给用户。如果一切顺利，我们将返回
    `client` 实例和一个空的 `diag.Diagnostics` 切片。'
- en: Next, let's examine the pet store data source.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来查看宠物店数据源。
- en: Implementing the pet store data source
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现宠物店数据源
- en: The pet store data source is a bit simpler than the resource implementation,
    given that a data source is intended as a way for Terraform to pull in data from
    an external API and is read-only in this case. The pet store data source is defined
    in `internal/data_source_pet.go`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物店数据源比资源实现简单一些，因为数据源是 Terraform 用来从外部 API 拉取数据的方式，并且在这种情况下是只读的。宠物店数据源定义在 `internal/data_source_pet.go`
    中。
- en: 'There are three functions of primary interest in the pet store data source.
    We will approach them one at a time. Let''s start with the `dataSourcePet` func:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物店数据源有三个主要函数。我们将逐个查看它们。首先从 `dataSourcePet` 函数开始：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding function creates the `*schema.Resource` data source by providing
    a schema for the data being provided via `getPetDataSchema`. `ReadContext` expects
    a function that is responsible for translating the input schema, querying the
    external API, and returning data to Terraform that matches the structure defined
    in the schema.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数通过提供一个 `getPetDataSchema` 的数据架构来创建 `*schema.Resource` 数据源。`ReadContext`
    期望一个函数，该函数负责翻译输入架构，查询外部 API，并返回与架构中定义的结构匹配的数据给 Terraform。
- en: 'The definition of `getPetDataSchema` is located in `internal/schema.go`, and
    it is helpful to review it prior to examining the code in `dataSourcePetRead`.
    We will break down the function into two parts, the input and the computed output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`getPetDataSchema` 的定义位于 `internal/schema.go` 中，查看它会对理解 `dataSourcePetRead`
    中的代码有帮助。我们将把该函数分为两部分，输入部分和计算出的输出部分：'
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding schema describes the data structure for the pet store pet data
    source. Each of the top-level keys is marked as optional and will be used to filter
    the data source. For example, the `name` key specifies that it is optional, is
    of type `string`, and should be validated with the `validateName` func. We will
    examine validations in more detail later in the section.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述架构描述了宠物店宠物数据源的数据结构。每个顶级键都标记为可选，并将用于过滤数据源。例如，`name` 键指定它是可选的，类型为 `string`，并且应通过
    `validateName` 函数进行验证。我们将在后续部分详细讨论验证。
- en: 'The following is the schema for the output of the data source:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是数据源输出的架构：
- en: '[PRE34]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `pets` key contains all the `Computed` values, which means each of the values
    is read-only. These represent the list result of the query.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`pets` 键包含所有 `Computed` 值，这意味着每个值都是只读的。它们表示查询的列表结果。'
- en: 'Now that we have a better understanding of the data schema we are working with,
    let''s continue with the implementation of `dataSourcePetRead`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对使用的数据模式有了更好的理解，让我们继续实现 `dataSourcePetRead`：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In `dataSourcePetRead`, we instantiate a client for the pet store service, populate
    the filter criteria from the data schema supplied, and then set the `pets` key
    in the `data` argument with the pets returned from the pet store service in the
    key value format specified by the schema. The `flattenPets` function is responsible
    for transforming the protobuf structures we receive from the pet store service
    into the format expected by the schema. If you are interested in the implementation,
    it is not terribly elegant, but it is simple.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `dataSourcePetRead` 中，我们为宠物店服务实例化了一个客户端，从提供的数据模式中填充过滤条件，然后将 `pets` 键在 `data`
    参数中设置为从宠物店服务返回的宠物数据，格式为模式中指定的键值格式。`flattenPets` 函数负责将我们从宠物店服务接收到的 protobuf 结构转换为模式所期望的格式。如果你对实现感兴趣，它并不是特别优雅，但很简单。
- en: I purposely didn't mention the `data.SetId` function. We are setting the value
    of that to a value that will cause the data to be fetched from the pet store service
    each time. Terraform identifies that data has changed if the ID for that data
    has changed. This ensures that the ID changes each time the function is executed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我故意没有提到 `data.SetId` 函数。我们将它的值设置为一个每次都会从宠物店服务中获取数据的值。当该数据的 ID 改变时，Terraform
    会识别数据发生了变化。这确保了每次执行该函数时，ID 都会发生变化。
- en: 'In the `configure` func, we created the pet store client, so how did we gain
    access to that client in the data source? We can find the answer to that in the
    `clientFromMeta` func:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `configure` 函数中，我们创建了宠物店客户端，那么我们是如何在数据源中访问该客户端的呢？我们可以在 `clientFromMeta` 函数中找到答案：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `clientFromMeta` func takes the `meta interface{}` argument passed into
    the `ReadContext` func and casts it as the pet store client. The `meta` variable
    contains the variable returned in the `configure` func. This is not as intuitive
    as we would like, but it is effective.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`clientFromMeta` 函数接收传入 `ReadContext` 函数的 `meta interface{}` 参数，并将其转换为宠物店客户端。`meta`
    变量包含在 `configure` 函数中返回的变量。这一点可能不像我们希望的那样直观，但它是有效的。'
- en: With the code described previously and some helpers from `internal/data_source_pet.go`,
    we have implemented a filtered data source to the pet store API that we can use
    in Terraform configuration files.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前描述的代码和来自 `internal/data_source_pet.go` 的一些帮助函数，我们实现了一个过滤的数据源，连接到宠物店 API，可以在
    Terraform 配置文件中使用。
- en: Next, let's take a look at how we handle CRUD interactions for pet resources.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看一下我们是如何处理宠物资源的 CRUD 操作的。
- en: Implementing the Pet resource
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现宠物资源
- en: The implementation for the Pet resource follows many of the same patterns as
    the pet store data source, but with the pet resources, we also need to implement
    create, update, and delete interactions in addition to read. Unless otherwise
    stated, the code we cover for the pet resource implementation is in `internal/resource_pet.go`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物资源的实现遵循了与宠物店数据源类似的许多模式，但对于宠物资源，我们还需要实现创建、更新和删除操作，而不仅仅是读取操作。除非另有说明，我们在讲解宠物资源实现时，代码都位于
    `internal/resource_pet.go` 中。
- en: 'Let''s start by examining the `resourcePet` func, which is the func called
    when we created the provider schema:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从检查 `resourcePet` 函数开始，该函数是在创建提供程序模式时被调用的：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Just like the pet store data source, the pet resource defines handlers for
    each CRUD operation as well as a schema. Before we get into the CRUD operations,
    let''s first look at the schema, which is in `internal/schema.go`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 和宠物店数据源一样，宠物资源也定义了每个 CRUD 操作的处理程序以及一个模式。在讨论 CRUD 操作之前，我们先来看一下模式，它位于 `internal/schema.go`
    中：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The schema defined here is simpler than the data source schema, since we are
    not defining query filters. Note that the `id` key is computed, but all the others
    are not. The `id` value is generated by the pet store service and is not to be
    specified by the user.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里定义的模式比数据源模式更简单，因为我们没有定义查询过滤条件。请注意，`id` 键是计算得出的，但其他键都不是。`id` 值由宠物店服务生成，不需要由用户指定。
- en: 'Since these values are specified by the user as a string, validation becomes
    more significant. For a better user experience, we want to provide feedback to
    a user when a value is invalid. Let''s take a look at how we validate the `type`
    field with the `validateType` func:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些值是由用户以字符串形式指定的，因此验证变得更加重要。为了提供更好的用户体验，我们希望在值无效时向用户提供反馈。让我们来看一下如何通过`validateType`函数验证`type`字段：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `validateType` func returns a validation constructed with each valid value
    of the enumeration. This prevents a user from entering a string value for a pet
    type that is not supported in the pet store. The rest of the validations take
    a similar approach to validating the range of input values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`validateType`函数返回一个通过每个有效的枚举值构造的验证。这防止用户输入宠物类型的字符串值，而该类型在宠物商店中不受支持。其余的验证采取了类似的方法来验证输入值的范围。'
- en: 'Now that we have explored the schema, we are prepared to explore the CRUD operations.
    Let''s start with the `read` operation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了模式，准备开始探索CRUD操作。让我们从`read`操作开始：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `resourcePetRead` func fetches the pet store client from the `meta` argument
    and then finds the pet by ID in the store. If the pet is found, the `data` argument
    is updated with data from the pet.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`resourcePetRead`函数从`meta`参数获取宠物商店客户端，然后通过ID在商店中查找宠物。如果找到宠物，`data`参数将使用来自宠物的数据进行更新。'
- en: 'That''s simple enough. Next, let''s look at create:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这足够简单。接下来，让我们看一下创建操作：
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `resourcePetCreate` func follows a similar pattern. The difference is that
    the pet is constructed from fields in the `data` argument, and then the pet store
    API is called to add the pet to the store. In the end, the ID for the new pet
    is set.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`resourcePetCreate`函数遵循类似的模式。不同之处在于宠物是从`data`参数中的字段构造的，然后调用宠物商店API将宠物添加到商店。最后，设置新宠物的ID。'
- en: 'Next, let''s look at update:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下更新操作：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `resourcePetUpdate` func combines parts of read and create. Initially, we
    need to check to see whether the pet is in the store and fetch the pet data. If
    we don't find the pet, we return an error. If we do find the pet, we update the
    fields of the pet and call `UpdatePets` on the pet store client.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`resourcePetUpdate`函数结合了读取和创建的部分。首先，我们需要检查宠物是否在商店中，并获取宠物数据。如果没有找到宠物，则返回错误。如果找到宠物，则更新宠物的字段，并调用宠物商店客户端上的`UpdatePets`。'
- en: The delete operation is relatively trivial, so I will not dive into it here.
    If you want, you can take a look at `resourcePetDelete` to see for yourself.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作相对简单，因此我在这里不再深入讨论。如果你愿意，你可以查看`resourcePetDelete`自己了解。
- en: At this point, we have now implemented the pet resource and are ready to see
    our Terraform provider in action.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了宠物资源，并准备好查看我们的Terraform提供者如何运作。
- en: Running the pet store provider
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行宠物商店提供者
- en: 'Now that we have a fully implemented pet store provider, the fun part is running
    it. From the root of the pet store provider, run the following commands. Be sure
    to have Docker running:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个完整实现的宠物商店提供者，接下来有趣的部分就是运行它。从宠物商店提供者的根目录，运行以下命令。请确保Docker已经在运行：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding commands will start the pet store service using `docker-compose`,
    build and install the provider, move it into the example directory, and finally,
    use `init` and `apply` to create our desired state containing our pets.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将使用`docker-compose`启动宠物商店服务，构建并安装提供者，将其移动到示例目录，最后使用`init`和`apply`来创建包含宠物的期望状态。
- en: 'When `init` executes, you should see something like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当`init`执行时，你应该看到如下内容：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Yay! The provider is installed and Terraform is ready to apply our resources.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 耶！提供者已安装，Terraform已准备好应用我们的资源。
- en: 'After Terraform has applied the resources, you should see the following output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在Terraform应用了资源后，你应该看到如下输出：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can see from the preceding output that both of our resources, `Tron` and
    `Thor`, have been added, and our data source when queried with no filters returned
    each of the pets. Lastly, we can see the `thor` output was returned, containing
    the data for `Thor`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的输出中，我们可以看到我们的两个资源，`Tron`和`Thor`，都已添加，并且在没有过滤器的情况下查询的数据源返回了每只宠物。最后，我们可以看到返回了`thor`输出，包含了`Thor`的数据。
- en: 'Let''s review `examples/main.tf` again and see where the `thor` output came
    from:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再看看`examples/main.tf`，看看`thor`输出来自哪里：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding `main.tf` file, we defined a `pet_name` variable with the value
    of `Thor`. We then queried the pet store data source, providing no filters but
    depending on the completion of both of the resources in the file. Lastly, we output
    a key of `thor`, with the value being a query that matches only when `pet.name`
    equals `var.pet_name`. This filtered the data source for only pets named `Thor`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 `main.tf` 文件中，我们定义了一个值为 `Thor` 的 `pet_name` 变量。然后，我们查询了宠物商店数据源，没有提供过滤器，而是依赖文件中两个资源的完成。最后，我们输出了一个键为
    `thor` 的值，这个查询仅在 `pet.name` 等于 `var.pet_name` 时才会匹配。这样，我们就过滤出了名为 `Thor` 的宠物数据。
- en: You can now use any of the Terraform skills you've learned thus far to manipulate
    pet store resources. There really wasn't all that much code to implement.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用到目前为止学到的任何 Terraform 技能来操作宠物商店资源。实际上，实现这一切的代码并不多。
- en: Publishing custom providers
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布自定义提供者
- en: Anyone can publish a provider to the Terraform Registry by logging into it using
    a GitHub account. Again, HashiCorp has excellent documentation on how to publish
    a provider. We will not walk through the process in this book, as the documentation
    for *Release and Publish a Provider to the Terraform Registry* ([https://learn.hashicorp.com/tutorials/terraform/provider-release-publish](https://learn.hashicorp.com/tutorials/terraform/provider-release-publish))
    is likely sufficient if you have reached this far in your journey building your
    own Terraform provider.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以通过使用 GitHub 账户登录来将提供者发布到 Terraform 注册表。HashiCorp 提供了出色的文档，指导如何发布提供者。我们在本书中不会逐步讲解这个过程，因为《发布并将提供者发布到
    Terraform 注册表》([https://learn.hashicorp.com/tutorials/terraform/provider-release-publish](https://learn.hashicorp.com/tutorials/terraform/provider-release-publish))
    的文档如果你已经走到这一步，应该足够帮助你构建自己的 Terraform 提供者。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the history of IaC and the advantages of leveraging
    the practice to bring software development and operations together by setting
    a shared context for expressing and continuously testing infrastructure. We learned
    where Terraform lies in the ecosystem of IaC tooling and how to use it to describe
    desired infrastructure states, mutate existing infrastructure, deploy a cloud
    infrastructure, and finally, create our own resources for automating external
    APIs. You should now be prepared with the tools needed to improve your own software
    projects.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了基础设施即代码（IaC）的历史以及利用这一实践将软件开发与运维结合的优势，通过设置共享的上下文来表达并持续测试基础设施。我们了解了
    Terraform 在 IaC 工具生态系统中的位置，以及如何使用它来描述期望的基础设施状态、修改现有基础设施、部署云基础设施，最后，创建我们自己的资源以自动化外部
    API。你现在应该准备好了所需的工具，以改进自己的软件项目。
- en: In the next chapter, we will learn how to use Go to deploy applications to Kubernetes
    and build upon that knowledge to understand how to extend it with Go. We'll enable
    our Kubernetes users to reconcile pets as custom Kubernetes resources.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何使用 Go 将应用部署到 Kubernetes，并基于此知识了解如何通过 Go 扩展它。我们将使 Kubernetes 用户能够将宠物作为自定义
    Kubernetes 资源进行协调。
