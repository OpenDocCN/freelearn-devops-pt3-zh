- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: A Deep Dive into Docker
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解Docker
- en: The advent of Docker has revolutionized the way we run, deploy, and maintain
    our applications. With the rise of containerization, we’ve been able to abstract
    away much of the underlying infrastructure and dependencies that applications
    rely on, making it easier than ever to deploy and manage them across different
    environments. However, with great power comes great responsibility, and we must
    understand the internals of Docker and establish good practices to ensure that
    our applications are secure, reliable, and performant.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的出现彻底改变了我们运行、部署和维护应用程序的方式。随着容器化的兴起，我们能够抽象出应用程序所依赖的许多底层基础设施和依赖项，使得跨不同环境部署和管理应用程序变得比以往更容易。然而，强大的能力也伴随着巨大的责任，我们必须理解Docker的内部机制，并建立良好的实践，以确保我们的应用程序是安全、可靠和高效的。
- en: In this chapter, we’ll delve into the nitty-gritty of Docker, exploring its
    architecture, components, and key features. We’ll also examine some of the helper
    projects that have emerged on top of Docker, such as Docker Compose and Kubernetes,
    and learn how to use them to build more complex and scalable applications. Throughout,
    we’ll emphasize best practices for working with Docker, such as creating efficient
    Docker images, managing containers, and optimizing performance. By the end of
    this chapter, you’ll be well-equipped to confidently run your applications inside
    Docker and leverage its full power to build robust and scalable systems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨Docker的细节，探索它的架构、组件和关键特性。我们还将研究一些在Docker之上出现的辅助项目，如Docker Compose和Kubernetes，并学习如何使用它们来构建更复杂和可扩展的应用程序。在整个过程中，我们将强调与Docker一起工作的最佳实践，如创建高效的Docker镜像、管理容器和优化性能。到本章结束时，你将能够自信地在Docker中运行应用程序，并利用其全部功能构建强大和可扩展的系统。
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下主题：
- en: Docker advanced use cases
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker的高级用例
- en: Docker Compose
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose
- en: Advanced Dockerfile techniques
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级Dockerfile技术
- en: Docker orchestration
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker编排
- en: Docker advanced use cases
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的高级用例
- en: While using Docker and its CLI, there are a lot of things we will need to take
    care of in terms of the life cycle of the container, build process, volumes, and
    networking. Some of those things you can automate by using other tools, but it’s
    still useful to know what’s going on underneath.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Docker及其CLI时，我们需要处理许多关于容器生命周期、构建过程、数据卷和网络的事项。你可以通过使用其他工具来自动化其中的一些任务，但了解底层的工作原理仍然是很有用的。
- en: Running public images
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行公共镜像
- en: A lot of public images you can find on Docker Hub ([https://hub.docker.com](https://hub.docker.com))
    have initialization scripts available that take configuration from environment
    variables or the mounted files to a predefined directory.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Docker Hub上找到的许多公共镜像（[https://hub.docker.com](https://hub.docker.com)）都提供了初始化脚本，这些脚本从环境变量或挂载的文件中获取配置，写入到预定义的目录中。
- en: 'The most commonly used image that uses both techniques is images with databases.
    Let’s look for an official **Docker PostgreSQL** image. You can find the one we’ll
    be using here: [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的镜像是使用了两种技术的数据库镜像。让我们来看看官方的**Docker PostgreSQL**镜像。我们将使用的镜像可以在这里找到：[https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)。
- en: 'To run the official PostgreSQL Docker image, you can use the following command:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行官方的PostgreSQL Docker镜像，你可以使用以下命令：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this command, we have the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们有以下内容：
- en: '`--name some-postgres` gives the container a name of *some-postgres*'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name some-postgres`给容器指定了一个名称*some-postgres*'
- en: '`-e POSTGRES_PASSWORD=mysecretpassword` sets the password for the default PostgreSQL
    user (*postgres*)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e POSTGRES_PASSWORD=mysecretpassword`为默认的PostgreSQL用户(*postgres*)设置密码'
- en: '`-d` runs the container in the background; `postgres` specifies the image to
    use'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`在后台运行容器；`postgres`指定使用的镜像'
- en: It’s also possible to override the default user (*postgres*) by adding a `POSTGRES_USER`
    environment variable. Other configuration environment variables are listed in
    the documentation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过添加`POSTGRES_USER`环境变量来覆盖默认用户(*postgres*)。其他配置环境变量可以在文档中找到。
- en: 'A very useful feature you can use when working with the official PostgreSQL
    image is database pre-population using SQL scripts. To achieve this, you will
    need to bind mount a local directory with scripts to `/docker-entrypoint-initdb.d`
    inside the container. There are two things you will need to take care of: empty
    data directory and making sure all scripts are finished with success. An empty
    data directory is necessary as this will act as the entry point where you can
    load your SQL or shell scripts; it also prevents data loss. If any of the scripts
    finish with an error, the database won’t be started.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用官方 PostgreSQL 镜像时，一个非常有用的功能是通过 SQL 脚本进行数据库预填充。为此，你需要将一个本地目录与脚本绑定挂载到容器内的
    `/docker-entrypoint-initdb.d`。有两件事需要注意：空数据目录和确保所有脚本成功完成。空数据目录是必要的，因为它将充当你可以加载
    SQL 或 shell 脚本的入口点；它还可以防止数据丢失。如果任何脚本出现错误，数据库将无法启动。
- en: Similar features are provided for other Docker images running any other database
    available in Docker Hub.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 Docker Hub 中运行的其他数据库，类似的功能也可以使用。
- en: 'Another useful official image you could use is **nginx**: it’s probably much
    simpler to use as you already have a configured web server inside and you will
    need to provide either content for it to serve (HTML files, JavaScript, or CSS)
    or override the default configuration.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的另一个有用的官方镜像是**nginx**：它可能更简单，因为你已经有一个配置好的 web 服务器，并且你需要提供内容（HTML 文件、JavaScript
    或 CSS）供其提供，或者覆盖默认配置。
- en: 'Here is an example of mounting a static HTML website to a container:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是将一个静态 HTML 网站挂载到容器的示例：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this command, we have the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们有以下内容：
- en: '`-p 8080:80`: This option maps port `8080` on the host machine to port `80`
    inside the container. This means that when someone accesses port `8080` on the
    host machine, it will be redirected to port `80` in the container.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p 8080:80`：这个选项将主机上的 `8080` 端口映射到容器内的 `80` 端口。这意味着当有人访问主机上的 `8080` 端口时，它将被重定向到容器内的
    `80` 端口。'
- en: '`-v /your/webpage:/usr/share/nginx/html:ro`: This option mounts the `/your/webpage`
    directory on the host machine to the `/usr/share/nginx/html` directory inside
    the container. The `ro` option means that the mount is read-only, which means
    that the container cannot modify the files in the `/``your/webpage` directory.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v /your/webpage:/usr/share/nginx/html:ro`：这个选项将主机上的 `/your/webpage` 目录挂载到容器内的
    `/usr/share/nginx/html` 目录。`ro` 选项意味着挂载是只读的，这意味着容器不能修改 `/your/webpage` 目录中的文件。'
- en: '`-d`: This option tells Docker to run the container in detached mode, which
    means that it will run in the background.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：这个选项告诉 Docker 以分离模式运行容器，这意味着它将在后台运行。'
- en: '`nginx`: This is the name of the Docker image that will be used to run the
    container. In this case, it’s the official nginx image from Docker Hub.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nginx`：这是将用于运行容器的 Docker 镜像的名称。在本例中，它是来自 Docker Hub 的官方 nginx 镜像。'
- en: 'We can override the default nginx configuration like so:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样覆盖默认的 nginx 配置：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this command, most of the previous options repeat themselves except one:
    `-v ./config/nginx.conf:/etc/nginx/nginx.conf:ro`. This option mounts the `./config/nginx.conf`
    file on the host machine to the `/etc/nginx/nginx.conf` file inside the container.
    The `ro` option means that the mount is read-only, which means that the container
    cannot modify the `nginx.conf` file.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，大部分之前的选项重复出现，只有一个例外：`-v ./config/nginx.conf:/etc/nginx/nginx.conf:ro`。这个选项将主机上的
    `./config/nginx.conf` 文件挂载到容器内的 `/etc/nginx/nginx.conf` 文件。`ro` 选项表示挂载是只读的，意味着容器不能修改
    `nginx.conf` 文件。
- en: Running a debugging container
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行调试容器
- en: Containers running in production usually have very few tools that are useful
    for troubleshooting installed. On top of that, those containers aren’t running
    as root users and have multiple security mechanisms to prevent tampering. With
    that in mind, how do we get into the Docker network to debug if something is not
    working?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行的容器通常只有很少的工具对故障排除有帮助。更重要的是，这些容器不是以 root 用户身份运行，并且有多个安全机制来防止篡改。考虑到这一点，如果出现问题，我们该如何进入
    Docker 网络进行调试呢？
- en: The answer to that question is just running another container we could get into.
    It would have some tools pre-installed or would allow us to install whatever we
    need while running. There are multiple techniques we can use to achieve this.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案就是运行另一个我们可以进入的容器。这个容器会预安装一些工具，或者允许我们在运行时安装所需的工具。我们可以使用多种技术来实现这一点。
- en: First, we will need a process that will run indefinitely until we stop it manually.
    While this process is running, we could step in and use the `docker exec` command
    to get *inside* the running Docker.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个会无限运行的进程，直到我们手动停止它。这个进程运行时，我们可以进入并使用 `docker exec` 命令进入正在运行的 Docker
    容器中。
- en: 'Knowing Bash scripting, the easiest way to run this process is to create a
    `while` loop:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Bash 脚本后，执行这个过程最简单的方式是创建一个 `while` 循环：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Another method is to use the `sleep` program:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 `sleep` 程序：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, you could just try to *read* a special device, `/dev/null`,
    that is outputting nothing and the `tail` command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以尝试*读取*一个特殊设备，`/dev/null`，它什么都不输出，以及使用`tail`命令：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, when one of these commands is running inside the network you’re trying
    to troubleshoot, you can run a command inside it, and effectively be able to run
    commands from within the environment you need to investigate:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当这些命令之一在你正在尝试排查故障的网络中运行时，你可以在其中运行一个命令，并有效地能够从你需要调查的环境中运行命令：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let us now look at cleaning up unused containers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看如何清理未使用的容器。
- en: Cleaning up unused containers
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理未使用的容器
- en: Docker images can accumulate over time, especially when you frequently build
    and experiment with containers. Some of these images may no longer be needed,
    and they can take up valuable disk space. To clean up these unused images, you
    can use the `docker image prune` command. This command removes all images that
    are not associated with a container, also known as **dangling images**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，Docker 镜像可能会积累，尤其是当你频繁构建和实验容器时。这些镜像中的一些可能不再需要，并且它们可能占用宝贵的磁盘空间。要清理这些未使用的镜像，你可以使用
    `docker image prune` 命令。该命令会删除所有未与容器关联的镜像，也就是所谓的**悬挂镜像**。
- en: In addition to unused images, there may also be leftover containers that were
    not removed properly. These containers can be identified using the `docker ps
    -a` command. To remove a specific container, you can use the `docker rm <container_id>`
    command, where `<container_id>` is the identifier of the container you want to
    remove. If you want to remove all stopped containers, you can use the `docker
    container` `prune` command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了未使用的镜像外，可能还有一些未正确移除的容器。这些容器可以通过 `docker ps -a` 命令来识别。要删除特定的容器，你可以使用 `docker
    rm <container_id>` 命令，其中 `<container_id>` 是你想要删除的容器的标识符。如果你想删除所有已停止的容器，你可以使用 `docker
    container prune` 命令。
- en: It’s good practice to regularly perform image and container cleanup to maintain
    a healthy Docker environment. This not only saves disk space but also helps prevent
    potential security vulnerabilities associated with unused resources. It is also
    best practice to remove all sensitive information, such as passwords and keys,
    from the containers and images.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 定期执行镜像和容器清理是一个良好的实践，有助于保持健康的 Docker 环境。这不仅可以节省磁盘空间，还可以防止与未使用资源相关的潜在安全漏洞。最好还要从容器和镜像中移除所有敏感信息，如密码和密钥。
- en: 'Here’s an example of using the `docker image prune` command to remove dangling
    images:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 `docker image prune` 命令来删除悬挂镜像的示例：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s an example of using the `docker container prune` command to remove all
    stopped containers:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用 `docker container prune` 命令删除所有已停止容器的示例：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To automate these tasks, you can use `crontab` to schedule regular cleanups.
    To edit your `crontab` file, you can use the `crontab -e` command. Here’s an example
    of scheduling a daily cleanup of dangling images at 3 A.M.:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化这些任务，你可以使用 `crontab` 来安排定期清理。要编辑你的 `crontab` 文件，你可以使用 `crontab -e` 命令。以下是一个例子，展示如何在每天凌晨3点安排定期清理悬挂镜像：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This line is made up of five fields separated by spaces. These fields represent
    the minutes, hours, days of the month, months, and days of the week when the command
    will be executed. In this example, the command will be executed at 3 A.M. every
    day. Let’s look at each element in detail:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行由五个字段组成，字段之间由空格分隔。这些字段表示命令执行时的分钟、小时、月日、月份和星期几。在这个例子中，命令将在每天的凌晨3点执行。让我们详细看看每个元素：
- en: The first field, `0`, represents the minutes. In this case, we want the command
    to be executed at exactly 0 minutes past the hour.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个字段，`0`，表示分钟。在这种情况下，我们希望命令在整点的0分钟执行。
- en: The second field, `3`, represents the hours. In this case, we want the command
    to be executed at 3 A.M.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个字段，`3`，表示小时。在这个例子中，我们希望命令在凌晨3点执行。
- en: The third field, `*`, represents the days of the month. The asterisk means “any”
    day of the month.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个字段，`*`，表示每月的天数。星号表示“任何”一天。
- en: The fourth field, `*`, represents the months. The asterisk means “any” month
    of the year.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个字段，`*`，表示月份。星号意味着“任何”一个月份。
- en: The fifth field, `*`, represents the days of the week. The asterisk means “any”
    day of the week. `1` represents Monday, `2` represents Tuesday, and so on until
    `7`, which represents Sunday.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第五个字段，`*`，表示星期几。星号意味着“任何”一天。`1`表示星期一，`2`表示星期二，以此类推，直到`7`表示星期天。
- en: 'Here’s an example of scheduling a weekly cleanup of stopped containers at 4
    A.M. on Sundays:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，演示如何安排在每周日凌晨 4 点清理停止的容器：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `-f` flag is used to force the removal of the images or containers without
    confirming this with the user.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`标志用于强制删除镜像或容器，而不需要用户确认。'
- en: 'To list all existing cron jobs for your user, you can use the `crontab -l`
    command. More about `crontab` can be found online or by using the `man crontab`
    command. A great how-to article about using it can be found in the Ubuntu Linux
    knowledge base: [https://help.ubuntu.com/community/CronHowto](https://help.ubuntu.com/community/CronHowto).'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出当前用户的所有 cron 作业，你可以使用`crontab -l`命令。关于`crontab`的更多信息可以在线查找或使用`man crontab`命令。关于如何使用它的一篇优秀教程文章可以在
    Ubuntu Linux 知识库中找到：[https://help.ubuntu.com/community/CronHowto](https://help.ubuntu.com/community/CronHowto)。
- en: Docker volumes and bind mounts
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 卷和绑定挂载
- en: As mentioned in the previous chapter, Docker volumes and bind mounts are two
    different ways to persist data generated by a Docker container. Volumes are managed
    by Docker and exist outside the container’s filesystem. They can be shared and
    reused between containers, and they persist even if the original container is
    deleted. On the other hand, bind mounts link a file or directory on the host system
    to a file or directory in the container. The data in bind mounts is directly accessible
    from the host and the container and persists for as long as the host file or directory
    remains.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，Docker 卷和绑定挂载是两种不同的持久化 Docker 容器生成的数据的方法。卷由 Docker 管理，并存在于容器的文件系统之外。它们可以在容器之间共享和重用，即使原始容器被删除，它们也会持久存在。而绑定挂载则将主机系统上的文件或目录链接到容器中的文件或目录。绑定挂载中的数据可以从主机和容器直接访问，并且只要主机文件或目录存在，它就会持续存在。
- en: 'To use a Docker volume, you can use the `-v` or `--mount` flag when you run
    the `docker run` command and specify the host source and container destination.
    For example, to create a volume and mount it to the container at `/app/data`,
    you can run the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Docker 卷，你可以在运行`docker run`命令时使用`-v`或`--mount`标志，并指定主机源和容器目标。例如，要创建一个卷并将其挂载到容器的`/app/data`，你可以运行以下命令：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To use a bind mount, you can use the same flags and specify the host source
    and container destination, just like with a volume. However, instead of using
    a volume name, you need to use the host file or directory path. For example, to
    bind mount the `/host/data` host directory to the container at `/app/data`, you
    can run the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用绑定挂载，你可以使用相同的标志并指定主机源和容器目标，就像使用卷一样。然而，与你使用卷名称不同的是，你需要使用主机文件或目录的路径。例如，要将主机目录`/host/data`绑定挂载到容器的`/app/data`，你可以运行以下命令：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When using bind mounts in Docker, you may encounter permission problems with
    the files and directories within the bind mount. This is because the **user IDs**
    (**UIDs**) and **group IDs** (**GIDs**) of the host and container may not match,
    leading to issues with accessing or modifying the data in the bind mount.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Docker 的绑定挂载时，你可能会遇到与挂载中文件和目录的权限问题。这是因为主机和容器的**用户 ID**（**UIDs**）和**组 ID**（**GIDs**）可能不匹配，从而导致无法访问或修改绑定挂载中的数据。
- en: For example, if the host file or directory is owned by a user with UID 1000,
    and the corresponding UID in the container is different, the container may not
    be able to access or modify the data in the bind mount. Similarly, if the group
    IDs do not match, the container may not be able to access or modify the data due
    to group permissions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果主机文件或目录的所有者是 UID 为 1000 的用户，而容器中的 UID 不同，那么容器可能无法访问或修改绑定挂载中的数据。同样，如果组 ID
    不匹配，由于组权限，容器也可能无法访问或修改数据。
- en: 'To prevent these permission problems, you can specify the UID and GID of the
    host file or directory when you run the `docker run` command. For example, to
    run a container with a bind mount as the UID and GID 1000, you can run the following
    command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些权限问题，你可以在运行`docker run`命令时指定主机文件或目录的 UID 和 GID。例如，要使用 UID 和 GID 为 1000
    的绑定挂载运行容器，你可以运行以下命令：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the `:ro` flag specifies that the bind mount should be read-only,
    and the `,Z` flag tells Docker to label the bind mount with a private label so
    that it cannot interact with other containers. The `--user` flag sets the UID
    and GID of the process running inside the container to `1000`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`:ro` 标志指定绑定挂载应为只读，`,Z` 标志告诉Docker使用私有标签标记绑定挂载，以防它与其他容器交互。`--user` 标志将容器内运行的进程的UID和GID设置为
    `1000`。
- en: By specifying the UID and GID of the host file or directory in the container,
    you can prevent permission problems with bind mounts in Docker and ensure that
    the container can access and modify the data as expected.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在容器中指定主机文件或目录的UID和GID，可以避免Docker中绑定挂载的权限问题，并确保容器可以按预期访问和修改数据。
- en: Docker networking advanced use cases
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker网络高级用法
- en: Docker provides a convenient way to manage the networking of containers in a
    user-defined network. By using Docker networks, you can easily control the communication
    between containers and isolate them from the host network.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Docker提供了一种便捷的方式来管理用户定义网络中容器的网络。通过使用Docker网络，您可以轻松控制容器之间的通信，并将它们与主机网络隔离开来。
- en: Docker bridge networking is a default network configuration that enables communication
    between containers running on the same host. It works by creating a virtual network
    interface on the host system that acts as a bridge between the containers and
    the host network. Each container on the bridge network is assigned a unique IP
    address that allows it to communicate with other containers and the host.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Docker桥接网络是一种默认的网络配置，可以使运行在同一主机上的容器之间进行通信。它通过在主机系统上创建一个虚拟网络接口来实现容器与主机网络之间的桥接。桥接网络上的每个容器都被分配一个唯一的IP地址，允许它与其他容器和主机进行通信。
- en: Bridge networks are isolated from each other, meaning that containers connected
    to different bridge networks cannot communicate with each other directly. To achieve
    communication between containers on different networks, you can use the Docker
    service discovery mechanism, such as connecting to a specific container IP address
    or using a load balancer.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 桥接网络彼此隔离，这意味着连接到不同桥接网络的容器无法直接通信。要在不同网络的容器之间实现通信，可以使用Docker服务发现机制，例如连接到特定容器IP地址或使用负载均衡器。
- en: To use bridge networking in practice, you can create a new bridge network using
    the Docker CLI. For example, you can use the `docker network create --driver bridge
    production-network` command to create a new bridge network named *production-network*.
    After the network is created, you can then connect your containers to the network
    by using the `--network` option in the `docker run` command. You can use the `docker
    run --network production-network my-image` command to run a container from the
    *my-image* image on the *production-network* network.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际中使用桥接网络，您可以使用Docker CLI创建一个新的桥接网络。例如，您可以使用命令 `docker network create --driver
    bridge production-network` 来创建一个名为 *production-network* 的新桥接网络。网络创建后，您可以使用 `docker
    run` 命令中的 `--network` 选项将容器连接到网络。您可以使用命令 `docker run --network production-network
    my-image` 在 *production-network* 网络上运行来自 *my-image* 镜像的容器。
- en: In addition to creating a new bridge network, you can connect containers to
    the default *bridge* network that is automatically created when you install Docker.
    To connect a container to the default network, you do not need to specify the
    `--network` option in the `docker run` command. The container will automatically
    be connected to the default *bridge* network and assigned an IP address from the
    bridge network subnet.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建新的桥接网络外，还可以将容器连接到安装Docker时自动创建的默认 *bridge* 网络。要将容器连接到默认网络，您无需在 `docker run`
    命令中指定 `--network` 选项。容器将自动连接到默认 *bridge* 网络，并从桥接网络子网中分配IP地址。
- en: Now, if you create multiple networks, by default, they will be separated and
    no communication will be allowed between them. To allow communication between
    two bridge networks, such as *production-network* and *shared-network*, you will
    need to create a network connection between the two networks by connecting a container
    of your choosing to those two networks or allowing all communication between the
    two networks. The latter option, if possible, is not supported.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果创建多个网络，默认情况下它们将被隔离，不允许它们之间进行通信。要允许两个桥接网络之间的通信，例如 *production-network* 和
    *shared-network*，您需要通过连接您选择的容器到这两个网络或允许这两个网络之间的所有通信来创建网络连接。如果可能的话，后者选项不受支持。
- en: The final option is to use **Docker Swarm** mode and overlay network mode, which
    we will get into a bit later in this chapter in the *Docker* *orchestration* section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项是使用**Docker Swarm**模式和覆盖网络模式，我们将在本章的*Docker* *编排*部分稍后讨论。
- en: 'The following is an example of how to connect a container to two networks at
    the same time. First, let’s create a production and shared network:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将容器同时连接到两个网络的示例。首先，让我们创建一个生产网络和一个共享网络：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we can start a container connected to `production-network`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动一个连接到`production-network`的容器：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s do the same for `shared-network`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也对`shared-network`做同样的操作：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s investigate if both containers are running:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下两个容器是否都在运行：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, let’s also connect `prod-container` to a shared network:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要将`prod-container`连接到共享网络：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After that, we can get a shell inside `prod-container` and ping `shared-container`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以进入`prod-container`并ping `shared-container`：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can learn more about networking in Docker on the official website: [https://docs.docker.com/network/](https://docs.docker.com/network/).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Docker官方网页上了解更多关于网络的内容：[https://docs.docker.com/network/](https://docs.docker.com/network/)。
- en: Security features of Docker
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker的安全特性
- en: Docker, at its core, wasn’t meant to be a security tool. This was built in at
    a later stage with the support of the Linux Kernel features that are still being
    developed, and more security features are being added.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的核心并非旨在作为安全工具。这是在后期通过Linux内核特性的支持逐步构建的，且仍在开发中，更多的安全特性也在不断加入。
- en: 'There’s a lot to cover regarding this topic, but we’re going to focus on the
    four most frequently used security features:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题涉及很多内容，但我们将重点介绍四个最常用的安全特性：
- en: Namespaces
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: '**Security computing** **mode** (**seccomp**)'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全计算** **模式**（**seccomp**）'
- en: Rootless mode
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无根模式
- en: Docker signed images
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker签名镜像
- en: Linux kernel namespaces
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux内核命名空间
- en: '**Kernel namespaces** are an important component of Docker security as they
    provide isolation between containers and the host system. They allow each container
    to have a view of the system resources, such as the filesystem, network, and process
    table, without affecting the host or other containers. This means that a process
    running inside a container cannot access or modify the host filesystem, network
    configuration, or processes, which helps secure the host system from malicious
    or rogue containers.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**内核命名空间**是Docker安全的重要组成部分，因为它们为容器和主机系统之间提供隔离。它们允许每个容器查看系统资源，如文件系统、网络和进程表，而不会影响主机或其他容器。这意味着运行在容器内的进程不能访问或修改主机文件系统、网络配置或进程，从而帮助保护主机系统免受恶意或不受控制的容器的威胁。'
- en: Docker uses several Linux kernel namespaces to provide isolated environments
    for containers. These namespaces are used to create isolated environments for
    processes, networks, mount points, and more.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用多个Linux内核命名空间为容器提供隔离环境。这些命名空间用于为进程、网络、挂载点等创建隔离的环境。
- en: The `USER` namespace for the Docker daemon will ensure that the root inside
    the Docker container is running in a separate context from the host context. It’s
    needed to ensure that the root user inside the container is not equal to the root
    on the host.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Docker守护进程的`USER`命名空间将确保容器内的root用户与主机环境中的root用户处于不同的上下文。这是为了确保容器内的root用户与主机上的root用户不相同。
- en: The `PID` namespace isolates the process IDs between containers. Each container
    sees its own set of processes, isolated from other containers and the host.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`PID`命名空间隔离容器之间的进程ID。每个容器只能看到自己的进程集，且与其他容器和主机隔离。'
- en: The `NET` namespace’s function is to isolate the network stack of each container
    so that each container has a virtual network stack, with its own network devices,
    IP addresses, and routes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`NET`命名空间的功能是隔离每个容器的网络堆栈，使得每个容器都有自己的虚拟网络堆栈，包括网络设备、IP地址和路由。'
- en: The `IPC` namespace deals with the **inter-process communication** (**IPC**)
    resources between containers. Each container has its own private IPC resources,
    such as System V IPC objects, semaphores, and message queues.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`IPC`命名空间处理容器之间的**进程间通信**（**IPC**）资源。每个容器都有自己独立的IPC资源，如System V IPC对象、信号量和消息队列。'
- en: The `UTS` namespace is about hostname and domain name isolation for each container.
    Here, each container has its own hostname and domain name that does not affect
    other containers or the host.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`UTS`命名空间用于容器的主机名和域名隔离。在这里，每个容器都有自己的主机名和域名，这些不会影响其他容器或主机。'
- en: Finally, the `MNT` namespace isolates the mount points of each container. This
    means that each container has a private filesystem hierarchy, with its own root
    filesystem, mounted filesystems, and bind mounts.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`MNT`命名空间隔离了每个容器的挂载点。这意味着每个容器都有一个私有的文件系统层级，拥有自己的根文件系统、挂载的文件系统和绑定挂载。
- en: By using these namespaces, Docker containers are isolated from each other and
    from the host, which helps ensure the security of containers and the host system.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些命名空间，Docker容器彼此之间以及与主机之间都被隔离，这有助于确保容器和主机系统的安全性。
- en: The most confusing to use is the `USER` namespace as it requires a special UID
    and GID mapping configuration. It’s not enabled by default as sharing `PID` or
    `NET` namespaces with the host (`–pid=host` or `–network=host`) isn’t possible.
    Also, using the `–privileged mode` flag on `docker run` will not be possible without
    specifying `–userns=host` (thus disabling the `USER` namespace separation). Other
    namespaces listed previously are in effect mostly without any other special configuration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER`命名空间是最难使用的，因为它需要特别的UID和GID映射配置。默认情况下并未启用它，因为与主机共享`PID`或`NET`命名空间（`–pid=host`或`–network=host`）是不可能的。此外，使用`docker
    run`时如果没有指定`–userns=host`（从而禁用`USER`命名空间的隔离），将无法使用`–privileged mode`标志。之前列出的其他命名空间大多无需任何特别配置即可生效。'
- en: Seccomp
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Seccomp
- en: '**Seccomp**, short for **secure computing mode**, is a Linux kernel feature
    that allows a process to specify the system calls it is allowed to make. This
    makes it possible to restrict the types of system calls that can be made by a
    container, which can help improve the security of the host system by reducing
    the risk of container escape or privilege escalation.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**Seccomp**，即**安全计算模式**，是一个Linux内核功能，允许进程指定其允许进行的系统调用。这使得可以限制容器能够执行的系统调用类型，从而通过减少容器逃逸或特权提升的风险来提高主机系统的安全性。'
- en: When a process specifies its seccomp profile, the Linux kernel filters incoming
    system calls and only allows those that are specified in the profile. This means
    that even if an attacker were to gain access to a container, they would be limited
    in the types of actions they could perform, reducing the impact of the attack.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程指定其seccomp配置文件时，Linux内核会过滤传入的系统调用，并仅允许在配置文件中指定的那些调用。这意味着，即使攻击者获得了容器的访问权限，他们也会受到能执行的操作类型的限制，从而减少攻击的影响。
- en: To create a seccomp profile for a container, you can use the `seccomp configuration`
    option in the `docker run` command. This allows you to specify the seccomp profile
    to use when starting the container.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要为容器创建seccomp配置文件，可以在`docker run`命令中使用`seccomp配置`选项。这允许你在启动容器时指定要使用的seccomp配置文件。
- en: 'There are two main ways to create a seccomp profile: using a predefined profile
    or creating a custom profile. Predefined profiles are available for common use
    cases and can be easily specified in the `docker run` command. For example, the
    default profile allows all system calls, while the restricted profile only allows
    a limited set of system calls that are considered safe for most use cases.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建seccomp配置文件有两种主要方式：使用预定义的配置文件或创建自定义配置文件。预定义配置文件适用于常见的使用场景，可以在`docker run`命令中轻松指定。例如，默认配置文件允许所有系统调用，而限制配置文件仅允许一组被认为对大多数使用场景安全的系统调用。
- en: To create a custom seccomp profile, you can use the **Podman** ([https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.xhtml](https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.xhtml))
    or **seccomp-gen** ([https://github.com/blacktop/seccomp-gen](https://github.com/blacktop/seccomp-gen))
    tools. Both tools automate figuring out which calls are being made by the container
    you intend to use in production and generate a JSON file that can be used as the
    seccomp profile.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自定义的seccomp配置文件，可以使用**Podman**（[https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.xhtml](https://podman.io/blogs/2019/10/15/generate-seccomp-profiles.xhtml)）或**seccomp-gen**（[https://github.com/blacktop/seccomp-gen](https://github.com/blacktop/seccomp-gen)）工具。这两个工具自动识别容器在生产环境中使用时会进行的系统调用，并生成一个JSON文件，可用作seccomp配置文件。
- en: Seccomp does not guarantee security. It is important to understand the system
    calls that are required for your application and ensure that they are allowed
    in the seccomp profile.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Seccomp并不能保证安全。了解你的应用所需的系统调用并确保它们在seccomp配置文件中被允许，是非常重要的。
- en: 'The following is an example of a seccomp profile that allows a limited set
    of system calls for a container running a web server application:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个seccomp配置文件示例，它允许运行Web服务器应用的容器使用有限的系统调用：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, `defaultAction` is set to `SCMP_ACT_ALLOW`, which means that
    all system calls not specifically listed in the `syscalls` array will be allowed.
    To block all not-defined calls, you can use `SCMP_ACT_ERRNO` as a default action.
    All available actions are described in the online manual for the `seccomp_rule_add`
    filter specification: [https://man7.org/linux/man-pages/man3/seccomp_rule_add.3.xhtml](https://man7.org/linux/man-pages/man3/seccomp_rule_add.3.xhtml).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`defaultAction`被设置为`SCMP_ACT_ALLOW`，意味着所有未在`syscalls`数组中特别列出的系统调用都会被允许。为了阻止所有未定义的调用，你可以将默认操作设置为`SCMP_ACT_ERRNO`。所有可用的操作都在`seccomp_rule_add`过滤器规格的在线手册中有所描述：[https://man7.org/linux/man-pages/man3/seccomp_rule_add.3.xhtml](https://man7.org/linux/man-pages/man3/seccomp_rule_add.3.xhtml)。
- en: The `syscalls` array lists the system calls that should be allowed for the container
    and specifies the action to take for each call (in this case, all calls are allowed).
    This profile only allows the system calls necessary for a web server to function
    and blocks all other system calls, improving the security of the container.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`syscalls`数组列出了应该允许容器使用的系统调用，并为每个调用指定了要采取的行动（在这种情况下，所有调用都被允许）。该配置文件仅允许Web服务器运行所需的系统调用，阻止所有其他系统调用，从而提高容器的安全性。'
- en: 'More information about system calls is available here: [https://docs.docker.com/engine/security/seccomp/](https://docs.docker.com/engine/security/seccomp/).'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有关系统调用的更多信息，请参阅：[https://docs.docker.com/engine/security/seccomp/](https://docs.docker.com/engine/security/seccomp/)。
- en: Rootless mode
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无根模式
- en: '**Docker Rootless** mode is a feature that allows users to run Docker containers
    without having to run the Docker daemon as the root user. This mode provides an
    additional layer of security by reducing the attack surface of the host system
    and minimizing the risk of privilege escalation.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 无根**模式是一个功能，允许用户在不以root用户身份运行Docker守护进程的情况下运行Docker容器。该模式通过减少主机系统的攻击面并最小化特权升级的风险，提供了额外的安全层。'
- en: 'Let’s set up a rootless Docker daemon on Ubuntu Linux or Debian Linux. First,
    make sure you’ve installed Docker from the official Docker package repository
    instead of the Ubuntu/Debian package:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Ubuntu Linux或Debian Linux上设置一个无根Docker守护进程。首先，确保你已从官方Docker软件包仓库安装了Docker，而不是从Ubuntu/Debian软件包中安装：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`docker-ce-rootless-extras` will install a shell script in your `/usr/bin`
    directory named `dockerd-rootless-setuptool.sh`, which will automate the whole
    process:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-ce-rootless-extras`将在你的`/usr/bin`目录中安装一个名为`dockerd-rootless-setuptool.sh`的脚本，它将自动化整个过程：'
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To run this script, we will need a non-root user with a configured environment
    to be able to run the Docker daemon. Let’s create a `dockeruser` user first:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，我们需要一个具有配置环境的非root用户，以便能够运行Docker守护进程。让我们首先创建一个`dockeruser`用户：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s also create a UID map configuration before we proceed. To do that, we
    will need to install the `uidmap` package and create the `/etc/subuid` and `/etc/subgid`
    configuration files:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们还需要创建一个UID映射配置。为此，我们需要安装`uidmap`软件包，并创建`/etc/subuid`和`/etc/subgid`配置文件：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Log in as `dockeruser` and run the `dockerd-rootless-setuptool.sh` script:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以`dockeruser`身份登录并运行`dockerd-rootless-setuptool.sh`脚本：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Make sure `environment XDG_RUNTIME_DIR` is set and systemd can read environment
    variables from `dockeruser`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 确保设置了`environment XDG_RUNTIME_DIR`，并且systemd可以从`dockeruser`读取环境变量：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, you can install rootless Docker using the `dockerd-rootless-setuptool.sh`
    script (some output has been truncated for readability):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用`dockerd-rootless-setuptool.sh`脚本安装无根（rootless）Docker（部分输出已被截断以提高可读性）：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let’s verify if we can use the Docker rootless daemon:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们验证一下能否使用Docker无根守护进程：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: At this point, we have a Docker daemon running as a *dockeruser* system user
    instead of root. We will be able to run all services we need the same way we would
    in a standard configuration. There are some exceptions, such as a Docker in Docker
    setup, which require further configuration.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经有一个以*dockeruser*系统用户身份运行的Docker守护进程，而不是root用户。我们将能够像在标准配置中一样运行所有需要的服务。某些情况，如Docker中的Docker配置，需要进一步的配置。
- en: More detailed information about rootless mode can be found at [https://docs.docker.com/engine/security/rootless/](https://docs.docker.com/engine/security/rootless/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有关无根模式的更多详细信息，请访问[https://docs.docker.com/engine/security/rootless/](https://docs.docker.com/engine/security/rootless/)。
- en: Docker signed images
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker签名镜像
- en: Docker signed images are a security measure that assures users that a Docker
    image has come from a trusted source and has not been tampered with. Docker uses
    a digital signature to sign images, which can be verified by Docker Engine to
    ensure that the image is exactly as it was when it was signed by the publisher.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 签名镜像是一种安全措施，它确保用户知道 Docker 镜像来自受信任的源，并且没有被篡改。Docker 使用数字签名对镜像进行签名，Docker
    引擎可以验证签名，以确保镜像与发布者签名时完全一致。
- en: Docker signed images can be verified by checking the public key of the signer
    from a trusted registry (such as Docker Hub). If the image is valid, Docker will
    allow you to pull and run the image locally.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 签名镜像可以通过检查签名者的公钥来验证，公钥可以从受信任的注册中心（如 Docker Hub）获取。如果镜像有效，Docker 会允许你在本地拉取并运行该镜像。
- en: 'The first step in signing a Docker image is to generate a signing key. A `docker
    trust key` `generate` command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 签名 Docker 镜像的第一步是生成一个签名密钥。可以使用 `docker trust key` `generate` 命令：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Remember to use a strong password to secure the key from access. The private
    key will be saved in your home directory – for example, `~/.docker/trust/private`.
    The name of the file will be hashed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 记得使用强密码来保护密钥免受访问。私钥将保存在你的主目录中——例如，`~/.docker/trust/private`。文件的名称会被哈希化。
- en: 'Once you have generated the signing key, the next step is to initialize the
    trust metadata for the image. The trust metadata contains information about the
    image, including the list of keys that are authorized to sign the image. To initialize
    the trust metadata, you can use the `docker trust signer add` command. Note that
    you need to be logged into the Docker registry you’re using (via the `docker`
    `login` command):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你生成了签名密钥，下一步就是初始化镜像的信任元数据。信任元数据包含关于镜像的信息，包括授权签名镜像的密钥列表。要初始化信任元数据，可以使用 `docker
    trust signer add` 命令。请注意，你需要登录到所使用的 Docker 注册中心（通过 `docker` `login` 命令）：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can sign the image by using the `docker trust sign` command after a successful
    Docker image build and tagging it with your registry name. This command signs
    the image using the authorized keys in the trust metadata and pushes this information,
    along with your Docker image, to the registry:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在成功构建 Docker 镜像并用注册中心名称进行标签标记后，使用 `docker trust sign` 命令对镜像进行签名。此命令会使用信任元数据中的授权密钥对镜像进行签名，并将该信息连同你的
    Docker 镜像一起推送到注册中心：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To verify that your Docker image has been signed and with which key, you can
    use the `docker trust` `inspect` command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证你的 Docker 镜像是否已经签名，并且使用了哪个密钥，你可以使用 `docker trust` `inspect` 命令：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`DOCKER_CONTENT_TRUST` environment variable to `1`. This will prevent Docker
    from downloading non-signed and verified images to local storage.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `DOCKER_CONTENT_TRUST` 环境变量设置为 `1`。这样将防止 Docker 下载未签名和未验证的镜像到本地存储。
- en: 'More detailed information about DCT can be found on an official website: [https://docs.docker.com/engine/security/trust/](https://docs.docker.com/engine/security/trust/).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 DCT 的更详细信息可以在官方站点找到：[https://docs.docker.com/engine/security/trust/](https://docs.docker.com/engine/security/trust/)。
- en: Docker for CI/CD pipeline integration
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 用于 CI/CD 管道集成
- en: '**Continuous integration** (**CI**) and **continuous deployment** (**CD**)
    are popular software development practices that aim to ensure that the software
    development process is streamlined and the quality of code is maintained.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）和 **持续部署**（**CD**）是流行的软件开发实践，旨在确保软件开发过程高效流畅，并保持代码质量。'
- en: CI refers to the practice of automatically building and testing code changes
    in a shared repository. CD is the next step after CI, where the code changes are
    automatically deployed to production or a staging environment.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: CI 指的是在共享代码库中自动构建和测试代码更改的实践。CD 是 CI 之后的下一步，其中代码更改会自动部署到生产或暂存环境中。
- en: Docker is a popular tool that’s used in CI/CD pipelines as it provides an efficient
    way to package and distribute applications. In this subsection, we will show you
    how to build and push a Docker image to AWS **Elastic Container Registry** (**ECR**)
    using GitHub Actions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是在 CI/CD 管道中广泛使用的工具，它提供了一种高效的方式来打包和分发应用程序。在这一小节中，我们将展示如何使用 GitHub Actions
    构建并将 Docker 镜像推送到 AWS **Elastic Container Registry**（**ECR**）。
- en: Let’s look at an example of how to set up a GitHub Action to build and push
    a Docker image to AWS ECR.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例，展示如何设置 GitHub Action 来构建并将 Docker 镜像推送到 AWS ECR。
- en: Create a new GitHub Actions workflow by creating a new file named `main.yml`
    in the `.github/workflows` directory of your repository. After adding and pushing
    it to the main branch, it’ll be available and triggered after any new push to
    this branch.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在你的仓库的 `.github/workflows` 目录中创建一个名为 `main.yml` 的新文件来创建一个新的 GitHub Actions
    工作流。添加并推送到主分支后，它将在每次该分支有新的推送时可用并被触发。
- en: 'In the `main.yml` file, define the steps for the workflow, like so:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.yml`文件中，定义工作流的步骤，如下所示：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Replace the `AWS_REGION` and `AWS_REGISTRY_URL` environment variables with your
    specific values. You should also replace `my-image` with the name of your Docker
    image.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 用你的特定值替换 `AWS_REGION` 和 `AWS_REGISTRY_URL` 环境变量。你还应该将 `my-image` 替换为你 Docker
    镜像的名称。
- en: 'In your GitHub repository settings, create two secrets named `AWS_ACCESS_KEY_ID`
    and `AWS_SECRET_ACCESS_KEY` with the AWS credentials that have the necessary permissions
    to push to AWS ECR. Alternatively, you could use your own runner and AWS IAM role
    attached to the runner or GitHub OIDC, which will authenticate itself with the
    AWS account. You can find the relevant documentation here: [https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 GitHub 仓库设置中，创建两个密钥，命名为 `AWS_ACCESS_KEY_ID` 和 `AWS_SECRET_ACCESS_KEY`，并使用具有推送权限的
    AWS 凭证。或者，你可以使用你自己的运行器和附加到运行器的 AWS IAM 角色，或 GitHub OIDC，这将通过 AWS 账户进行身份验证。你可以在这里找到相关文档：[https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services)。
- en: With these steps in place, your GitHub Action will now automatically build and
    push your Docker image to AWS ECR every time you push code changes to the main
    branch. After the push, you could trigger another process on the server side to
    evaluate and deploy a new Docker image to one of your environments without further
    manual interaction. This helps streamline your CI/CD pipeline and ensures that
    your code changes are deployed to production with confidence.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，每当你将代码更改推送到主分支时，你的 GitHub Action 将自动构建并推送 Docker 镜像到 AWS ECR。推送之后，你可以触发服务器端的另一个过程，评估并将新
    Docker 镜像部署到你的某个环境中，而无需进一步的手动操作。这有助于简化你的 CI/CD 管道，并确保你的代码更改可以放心地部署到生产环境。
- en: It’s also possible to integrate the same pipeline with GitLab or other CI/CD
    tools in a similar manner.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以以类似的方式将相同的管道集成到 GitLab 或其他 CI/CD 工具中。
- en: In this section, we’ve learned about some not-so-common use cases for containers,
    such as rootless mode, secure computing mode, networking advanced use cases, and
    how to start a debugging container. In the next section, we will focus on automating
    the process of setting up Docker containers even further and how to orchestrate
    it a bit better than manually starting containers one by one.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了一些容器的非常见使用场景，如无根模式、受保护计算模式、网络高级用例以及如何启动调试容器。在下一节中，我们将进一步集中讨论如何自动化设置
    Docker 容器的过程，并探讨如何比手动逐个启动容器更好地进行编排。
- en: Docker Compose
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: '**Docker Compose** is a console tool for running multiple containers using
    one command. It provides an easy way to manage and coordinate multiple containers,
    making it easier to build, test, and deploy complex applications. With Docker
    Compose, you can define your application’s services, networks, and volumes in
    a single YAML file, and then start and stop all services from the command line.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker Compose** 是一个控制台工具，用于通过一个命令运行多个容器。它提供了一种简便的方式来管理和协调多个容器，使构建、测试和部署复杂应用变得更加容易。使用
    Docker Compose，你可以在一个 YAML 文件中定义应用程序的服务、网络和卷，然后通过命令行启动和停止所有服务。'
- en: To use Docker Compose, you first need to define your application’s services
    in a `docker-compose.yml` file. This file should include information about the
    services you want to run, their configuration, and how they are connected. The
    file should also specify which Docker images to use for each service.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Docker Compose，首先需要在 `docker-compose.yml` 文件中定义应用程序的服务。该文件应包括有关你希望运行的服务、它们的配置以及它们如何连接的信息。文件还应指定每个服务使用的
    Docker 镜像。
- en: The `docker-compose.yaml` file is a central configuration file that’s used by
    Docker Compose to manage the deployment and running of applications. It is written
    in YAML syntax.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yaml` 文件是一个核心配置文件，用于 Docker Compose 管理应用程序的部署和运行。它采用 YAML 语法编写。'
- en: The structure of the `docker-compose.yaml` file is divided into several sections,
    each of which defines a different aspect of the deployment. The first section,
    `version`, specifies the version of the Docker Compose file format being used.
    The second section, `services`, defines the services that make up the application,
    including their image names, environment variables, ports, and other configuration
    options.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yaml` 文件的结构分为几个部分，每个部分定义部署的不同方面。第一部分 `version` 指定了使用的 Docker
    Compose 文件格式的版本。第二部分 `services` 定义了组成应用程序的服务，包括它们的镜像名称、环境变量、端口和其他配置选项。'
- en: The `services` section is the most important part of the `docker-compose.yaml`
    file as it defines how the application is built, run, and connected. Each service
    is defined by its own set of key-value pairs, which specify its configuration
    options. For example, the `image` key is used to specify the name of the Docker
    image to be used for the service, while the `ports` key is used to specify the
    port mappings for the service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`services` 部分是 `docker-compose.yaml` 文件中最重要的部分，因为它定义了应用程序的构建、运行和连接方式。每个服务通过其自己的键值对集合来定义其配置选项。例如，`image`
    键用于指定要用于服务的 Docker 镜像的名称，而 `ports` 键用于指定服务的端口映射。'
- en: The `docker-compose.yaml` file can also include other sections, such as `volumes`
    and `networks`, which allow you to define shared data storage and network configurations
    for your application. Overall, the `docker-compose.yaml` file provides a centralized,
    declarative way to define, configure, and run multi-container applications with
    Docker Compose. With its simple syntax and powerful features, it is a key tool
    for streamlining the development and deployment of complex applications.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose.yaml` 文件还可以包含其他部分，比如 `volumes` 和 `networks`，这些部分允许您为应用程序定义共享数据存储和网络配置。总体来说，`docker-compose.yaml`
    文件提供了一种集中式、声明式的方式来定义、配置和运行使用 Docker Compose 的多容器应用程序。借助其简单的语法和强大的功能，它是简化复杂应用程序开发和部署的关键工具。'
- en: Environment variables are key-value pairs that allow you to pass configuration
    information to your services when they are run. In the `docker-compose.yaml` file,
    environment variables can be specified using the environment key within the service
    definition.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量是键值对，允许您在运行服务时传递配置信息。在 `docker-compose.yaml` 文件中，可以使用服务定义中的环境键来指定环境变量。
- en: 'One way to specify environment variables in the `docker-compose.yaml` file
    is to simply list them as key-value pairs within the environment section. Here’s
    an example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `docker-compose.yaml` 文件中指定环境变量的一种方法是在环境部分中简单地列出它们作为键值对。以下是一个例子：
- en: '[PRE34]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In addition to specifying environment variables directly in the `docker-compose.yaml`
    file, you can store them in an external file and reference that file within the
    `docker-compose.yaml` file using the `env_file` key. Here’s an example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接在 `docker-compose.yaml` 文件中指定环境变量之外，还可以将它们存储在外部文件中，并在 `docker-compose.yaml`
    文件中使用 `env_file` 键引用该文件。以下是一个例子：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The contents of the `db.env` file might look like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.env` 文件的内容可能如下所示：'
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By using an external `env_file` key, you can keep sensitive information separate
    from your `docker-compose.yaml` file and easily manage environment variables across
    different environments.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用外部的 `env_file` 键，您可以将敏感信息与 `docker-compose.yaml` 文件分开，并在不同的环境中轻松管理环境变量。
- en: As an example, consider a MariaDB Docker image. The MariaDB image requires several
    environment variables to be set to configure the database, such as `MYSQL_ROOT_PASSWORD`
    for the root password, `MYSQL_DATABASE` for the name of the default database,
    and others. These environment variables can be defined in the `docker-compose.yaml`
    file to configure the MariaDB service.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，考虑一个 MariaDB Docker 镜像。MariaDB 镜像需要设置几个环境变量来配置数据库，例如 `MYSQL_ROOT_PASSWORD`
    用于 root 密码，`MYSQL_DATABASE` 用于默认数据库的名称，以及其他变量。这些环境变量可以在 `docker-compose.yaml`
    文件中定义以配置 MariaDB 服务。
- en: 'Let’s look at an example of using Docker Compose to set up a nginx container,
    a PHP-FPM container, a WordPress container, and a MySQL container. We’ll start
    by defining our services in the `docker-compose.yml` file and break it down into
    smaller blocks with comments:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用 Docker Compose 设置 nginx 容器、PHP-FPM 容器、WordPress 容器和 MySQL 容器的例子。我们将在
    `docker-compose.yml` 文件中定义我们的服务，并通过注释将其分解成较小的块：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding line defines the version of the Docker Compose file syntax. Next,
    we will define all Docker images to be run and interact with each other:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行定义了Docker Compose文件语法的版本。接下来，我们将定义所有要运行并与彼此交互的Docker镜像：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This defines a component of our application stack named `web`. It will use
    a Docker image from Docker Hub named `nginx` with the `latest` tag. Here are some
    other important settings:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了我们应用程序栈中名为`web`的组件。它将使用来自Docker Hub的`nginx`镜像，标签为`latest`。以下是一些其他重要设置：
- en: '`depends_on`: This tells Docker Compose to start this component after the `wordpress`
    service.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on`: 这告诉Docker Compose在`wordpress`服务之后启动此组件。'
- en: '`ports`: This forwards your host port to a Docker port; in this case, it’ll
    open port `80` on your computer and forward all incoming traffic to the same port
    inside the Docker image, the same way the `–p` setting does when starting a single
    Docker container using the command line.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`: 这将您的主机端口转发到Docker端口；在这种情况下，它将在计算机上打开端口`80`并将所有传入流量转发到Docker镜像中的相同端口，就像在命令行中启动单个Docker容器时所做的`-p`设置一样。'
- en: '`volumes`: This setting is equivalent to the `-v` option in the Docker command-line
    tool, so it’ll mount a `nginx.conf` file from the local directory to the `/etc/nginx/conf.d/default.conf`
    file inside a Docker image.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes`: 这个设置等同于Docker命令行工具中的`-v`选项，因此它将从本地目录将一个`nginx.conf`文件挂载到Docker镜像内的`/etc/nginx/conf.d/default.conf`文件。'
- en: '`wordpress:/var/www/html`: This line will mount a Docker volume named `wordpress`
    to the directory inside the Docker image. The volume will be defined ahead.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wordpress:/var/www/html`: 这一行将一个名为`wordpress`的Docker卷挂载到Docker镜像内部的目录。卷将在前面定义。'
- en: '`networks`: Here, we’re connecting this service to a Docker network named `wordpress`,
    which is defined as follows:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`networks`: 在这里，我们将此服务连接到名为`wordpress`的Docker网络，其定义如下：'
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding service is very similar to a *web* service, with the following
    additions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的服务与*web*服务非常相似，具有以下附加项：
- en: '`environment`: This defines environment variables present inside the Docker
    image.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`: 这定义了Docker镜像内部存在的环境变量。'
- en: '`restart`: This configures the service so that it’s automatically restarted
    if the process stops working for some reason. Docker Compose will not attempt
    to restart this service if we’ve manually stopped it.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`: 这配置了服务，使其在某些原因导致进程停止工作时自动重启。如果我们手动停止了该服务，Docker Compose将不会尝试重新启动它。'
- en: '`depends_on`: This server will only be started after the `db` service is up.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on`: 该服务器只会在`db`服务启动后才会启动。'
- en: 'Let’s look at the `db` service:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`db`服务：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This service is setting up the MariaDB database so that it can store WordPress
    data. Note that all environment variables we can use for MariaDB or WordPress
    images are documented on their respective Docker Hub pages:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务正在设置MariaDB数据库，以便存储WordPress数据。请注意，我们可以为MariaDB或WordPress镜像使用的所有环境变量都记录在它们各自的Docker
    Hub页面上：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, we’re defining the Docker volumes we are using for WordPress and MariaDB.
    These are regular Docker volumes that are stored locally, but by installing Docker
    Engine plugins, those could be distributed filesystems, such as GlusterFS or MooseFS:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在定义用于WordPress和MariaDB的Docker卷。这些是存储在本地的常规Docker卷，但通过安装Docker引擎插件，可以将它们作为分布式文件系统（如GlusterFS或MooseFS）分发：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Finally, we’re defining a `wordpress` network with a `bridge` driver that allows
    communication between all preceding services with isolation from the Docker images
    running on a machine you will run it on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个`wordpress`网络，使用`bridge`驱动程序，允许所有前述服务之间的通信，并与在其上运行的Docker镜像隔离开来。
- en: In the preceding example, in addition to the options already covered in this
    section, we have a services dependency (`depends_on`), which will allow us to
    force the order in which containers will be started.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，除了本节已经涵盖的选项之外，还有一个服务依赖项（`depends_on`），这将允许我们强制容器启动的顺序。
- en: The two volumes we’re defining (`wordpress` and `dbdata`) are used for data
    persistence. The `wordpress` volume is being used to host all WordPress files
    and it’s also mounted to the web container that is running the nginx web server.
    That way, the web server will be able to serve static files such as CSS, images,
    and JavaScript, as well as forward requests to the PHP-FPM server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的两个卷（`wordpress`和`dbdata`）用于数据持久化。`wordpress`卷用于托管所有WordPress文件，并且它也被挂载到运行nginx
    Web服务器的web容器上。这样，Web服务器将能够提供静态文件，如CSS、图像和JavaScript，同时将请求转发到PHP-FPM服务器。
- en: 'Here’s the nginx configuration, which uses `fastcgi` to connect to the WordPress
    container running the PHP-FPM daemon:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 nginx 配置，它使用 `fastcgi` 连接到运行 PHP-FPM 守护进程的 WordPress 容器：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With this `docker-compose.yml` file, you can start and stop all the services
    defined in the file by using the `docker-compose up` and `docker-compose down`
    commands, respectively. When you run `docker-compose up`, Docker will download
    the necessary images and start the containers, and you’ll be able to access your
    WordPress website at [http://localhost](http://localhost).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个 `docker-compose.yml` 文件，你可以通过 `docker-compose up` 和 `docker-compose down`
    命令分别启动和停止文件中定义的所有服务。当你运行 `docker-compose up` 时，Docker 将下载必要的镜像并启动容器，你就可以在 [http://localhost](http://localhost)
    访问你的 WordPress 网站。
- en: '`docker-compose` is a very useful tool for running applications that require
    multiple services in an easy and repeatable way. It’s most commonly used when
    running applications locally for development, but some organizations decide to
    use `docker-compose` in production systems where it serves its purpose.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 是一个非常有用的工具，用于以简单且可重复的方式运行需要多个服务的应用程序。它通常在本地开发时运行应用程序时使用，但一些组织决定在生产系统中使用
    `docker-compose`，在这种情况下它也能发挥作用。'
- en: It’s extremely rare if you can use a ready-made Docker image for local development
    or production. Using public images as a base for your customization is a practice
    applied in, dare we claim it, all organizations using Docker. With that in mind,
    in the next section, we will learn how to build Docker images using multi-stage
    builds and how to use each Dockerfile command properly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能使用现成的 Docker 镜像进行本地开发或生产环境，实际上是极为罕见的。使用公共镜像作为自定义的基础是所有使用 Docker 的组织普遍采用的做法。考虑到这一点，在接下来的章节中，我们将学习如何使用多阶段构建构建
    Docker 镜像，以及如何正确使用每个 Dockerfile 命令。
- en: Advanced Dockerfile techniques
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Dockerfile 技巧
- en: Dockerfiles are used to define how an application should be built inside a Docker
    container. We covered most of the available commands in [*Chapter 8*](B18197_08.xhtml#_idTextAnchor166).
    Here, we will introduce more advanced techniques, such as multi-stage builds or
    not-so-common `ADD` command uses.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 用于定义应用程序在 Docker 容器内应如何构建。我们在 [*第 8 章*](B18197_08.xhtml#_idTextAnchor166)
    中介绍了大部分可用命令。在这里，我们将介绍一些更高级的技术，例如多阶段构建或不太常见的 `ADD` 命令用法。
- en: Multi-stage build
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多阶段构建
- en: Multi-stage builds are a feature of Docker that allows you to use multiple Docker
    images to create a single final image. By creating multiple stages, you can separate
    the build process into distinct steps and reduce the size of the final image.
    Multi-stage builds are particularly useful when building complex applications
    that require multiple dependencies as they allow developers to keep the necessary
    dependencies in one stage and the application in another.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建是 Docker 的一个功能，允许你使用多个 Docker 镜像创建一个最终的单一镜像。通过创建多个阶段，你可以将构建过程分为不同的步骤，从而减少最终镜像的大小。多阶段构建在构建需要多个依赖的复杂应用程序时特别有用，因为它允许开发人员将必要的依赖项放在一个阶段，而将应用程序本身放在另一个阶段。
- en: 'One example of using multi-stage builds with a Golang application involves
    creating two stages: one for building the application and one for running it.
    In the first stage, the Dockerfile pulls in the necessary dependencies and compiles
    the application code. In the second stage, only the compiled binary is copied
    over from the first stage, reducing the size of the final image. Here’s an example
    Dockerfile for a Golang application:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多阶段构建来构建 Golang 应用程序的一个例子涉及创建两个阶段：一个用于构建应用程序，另一个用于运行它。在第一个阶段，Dockerfile 拉取必要的依赖项并编译应用程序代码。在第二个阶段，仅从第一个阶段复制已编译的二进制文件，从而减少最终镜像的大小。以下是一个
    Golang 应用程序的 Dockerfile 示例：
- en: '[PRE44]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding example, the Dockerfile creates two stages. The first stage
    uses the `golang:alpine` image and installs the necessary dependencies. Then,
    it compiles the application and places the binary in the `/go/bin/app` directory.
    The second stage uses the smaller Alpine image and copies the binary from the
    first stage into the `/go/bin/app` directory. Finally, it sets the entry point
    to `/go/bin/app`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，Dockerfile 创建了两个阶段。第一个阶段使用 `golang:alpine` 镜像并安装必要的依赖项。然后，它编译应用程序并将二进制文件放置在
    `/go/bin/app` 目录下。第二个阶段使用更小的 Alpine 镜像，并将第一个阶段中的二进制文件复制到 `/go/bin/app` 目录下。最后，它将入口点设置为
    `/go/bin/app`。
- en: ADD command use cases
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ADD` 命令的用法示例'
- en: The `ADD` command in a Docker file is used to add files or directories to the
    Docker image. It works in the same way as `COPY` but with some additional features.
    We’ve talked about basic uses before, but there are other use cases too.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 中的 `ADD` 命令用于将文件或目录添加到 Docker 镜像中。它的工作方式与 `COPY` 相同，但具有一些额外的功能。我们之前已经讨论过基本的用法，但还有其他用例。
- en: 'The second use case allows you to unpack files compressed with ZIP or TAR and
    gzip tools on the fly. While adding a compressed file to the image, the file will
    be uncompressed and all the files inside it will be extracted to the destination
    folder. Here’s an example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种用法允许你即时解压 ZIP 或 TAR 和 gzip 工具压缩的文件。在将压缩文件添加到镜像时，文件将被解压，所有文件将被提取到目标文件夹中。以下是一个示例：
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The third way of using the `ADD` command is to copy a remote file from a URL
    to the Docker image. For example, to download a file named `file.txt` from a URL,
    [https://yourdomain.tld/configurations/nginx.conf](https://yourdomain.tld/configurations/nginx.conf),
    and copy it to the nginx configuration directory, `/etc/nginx`, inside the Docker
    image, you can use the following `ADD` command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ADD` 命令的第三种方式是从 URL 将远程文件复制到 Docker 镜像中。例如，要从 URL [https://yourdomain.tld/configurations/nginx.conf](https://yourdomain.tld/configurations/nginx.conf)
    下载名为 `file.txt` 的文件并将其复制到 Docker 镜像中的 nginx 配置目录 `/etc/nginx`，可以使用以下 `ADD` 命令：
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can also use a Git repository to add your code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 Git 仓库来添加代码：
- en: '[PRE47]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: To clone a Git repository over SSH, you will need to allow the `ssh` command
    inside Docker to access a private key with access to the repository you’re trying
    to access. You can achieve this by adding a private key in a multi-stage build
    and removing it at the end of the stage where you’re cloning a repository. This
    is generally not recommended if you have a choice. You can do this more securely
    by using Docker secrets and mounting the secret while running the build.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 SSH 克隆 Git 仓库，你需要允许 Docker 内的 `ssh` 命令访问拥有访问你要克隆仓库的私钥。你可以通过在多阶段构建中添加私钥，并在克隆仓库的阶段结束时将其移除来实现这一点。如果可能的话，一般不推荐这样做。你可以通过使用
    Docker secrets 并在构建时挂载该 secret 来更安全地实现。
- en: 'Here’s an example of using `ARG` with a private key:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 `ARG` 配合私钥的示例：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here’s an example of using a Docker secret and a mount:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Docker secret 和挂载的示例：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding example, we’re assuming your private key isn’t protected by
    the password and your key is being saved in the `ssh_id_rsa` file.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们假设你的私钥没有密码保护，并且你的密钥保存在 `ssh_id_rsa` 文件中。
- en: 'The final way of using the `ADD` command is to extract a TAR archive from the
    host machine and copy its contents to the Docker image. For example, to extract
    a TAR archive named `data.tar.gz` from the host machine and copy its contents
    to the `/data` directory inside the Docker image, you can use the following `ADD`
    command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ADD` 命令的最后一种方式是从主机机器中提取 TAR 压缩包并将其内容复制到 Docker 镜像中。例如，要从主机机器中提取一个名为 `data.tar.gz`
    的 TAR 压缩包并将其内容复制到 Docker 镜像中的 `/data` 目录，可以使用以下 `ADD` 命令：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Secrets management
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Secrets 管理
- en: Docker secrets management is an important aspect of building secure and reliable
    containerized applications.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Docker secrets 管理是构建安全可靠的容器化应用程序的一个重要方面。
- en: Secrets are sensitive pieces of information that an application needs to function,
    but they should not be exposed to unauthorized users or processes. Examples of
    secrets include passwords, API keys, SSL certificates, and other authentication
    or authorization tokens. These secrets are often required by applications at runtime,
    but storing them in plaintext in code or configuration files can be a security
    risk.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Secrets 是应用程序需要运行的敏感信息，但不应暴露给未授权的用户或进程。Secrets 的例子包括密码、API 密钥、SSL 证书以及其他身份验证或授权令牌。这些
    secrets 通常在应用程序运行时需要，但如果将其以明文形式存储在代码或配置文件中，则存在安全风险。
- en: Securing secrets is crucial to ensuring the security and reliability of applications.
    Leaking secrets can lead to data breaches, service disruptions, and other security
    incidents.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 保护 secrets 对于确保应用程序的安全性和可靠性至关重要。泄露 secrets 可能导致数据泄露、服务中断和其他安全事件。
- en: In the basic Docker setup, it’s only possible to provide secrets to a Docker
    image using environment variables, as we covered in [*Chapter 8*](B18197_08.xhtml#_idTextAnchor166).
    Docker also provides a built-in secrets management mechanism that allows you to
    securely store and manage secrets. However, it’s only available when Swarm mode
    needs to be enabled (we will get back to Swarm later in this chapter in the *Docker*
    *orchestration* section).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本的Docker设置中，您只能通过环境变量将密钥提供给Docker镜像，正如我们在[*第8章*](B18197_08.xhtml#_idTextAnchor166)中介绍的那样。Docker还提供了一个内置的密钥管理机制，可以安全地存储和管理密钥。但是，它仅在启用Swarm模式时可用（我们将在本章的*Docker*
    *编排*部分进一步探讨Swarm）。
- en: 'To make secrets available to applications running inside Docker, you can use
    the `docker secret create` command. For example, to create a secret for a MySQL
    database password, you can use the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要使密钥可用于运行在Docker中的应用程序，您可以使用`docker secret create`命令。例如，要为MySQL数据库密码创建一个密钥，您可以使用以下命令：
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This command creates a secret named `mysql_password` with a value of `mysecretpassword`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建了一个名为`mysql_password`的密钥，值为`mysecretpassword`。
- en: 'To use a secret in a service, you need to define the secret in the service
    configuration file. For example, to use the `mysql_password` secret in a service,
    you can define it in the `docker-compose.yml` file, as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要在服务中使用密钥，您需要在服务配置文件中定义该密钥。例如，要在服务中使用`mysql_password`密钥，您可以在`docker-compose.yml`文件中定义它，如下所示：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this configuration file, the `mysql_password` secret is defined in the `secrets`
    section, and the `MYSQL_ROOT_PASSWORD_FILE` environment variable is set to the
    path of the secret file, which is `/run/secrets/mysql_password`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置文件中，`mysql_password`密钥定义在`secrets`部分，且`MYSQL_ROOT_PASSWORD_FILE`环境变量设置为密钥文件的路径，即`/run/secrets/mysql_password`。
- en: 'To deploy the service, you can use the `docker stack deploy` command. For example,
    to deploy the service defined in the `docker-compose.yml` file, you can use the
    following command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署服务，您可以使用`docker stack deploy`命令。例如，要部署在`docker-compose.yml`文件中定义的服务，您可以使用以下命令：
- en: '[PRE53]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Handling secrets with care is extremely important from a security perspective.
    The most common mistake is putting a secret directly inside a Docker image, environment
    file, or application configuration file that is committed into the Git repository.
    There are existing contingencies that prevent users from doing that (such as Dependabot
    in GitHub), but if they should fail, it’s extremely hard to remove them from the
    Git history afterward.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，小心处理密钥至关重要。最常见的错误是将密钥直接放入Docker镜像、环境文件或提交到Git仓库的应用程序配置文件中。虽然已有现成的应急措施防止用户这么做（如GitHub中的Dependabot），但如果它们失败，之后从Git历史中删除这些密钥将非常困难。
- en: In this section, we covered how to handle different aspects of building a container
    and advanced build techniques. With this knowledge and with the use of Docker
    Compose, you will be able to build and run your application with a decent dose
    of automation. What if you have 10 of those applications? 100? Or even more?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们介绍了如何处理构建容器的不同方面以及高级构建技巧。掌握这些知识并使用Docker Compose，您将能够以相当程度的自动化构建和运行您的应用程序。如果您有10个这样的应用程序呢？100个？甚至更多呢？
- en: In the next section, we will dig into clusters, which will automate things further
    and deploy your applications to multiple hosts simultaneously.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将深入探讨集群，它将进一步自动化操作，并将您的应用程序同时部署到多个主机。
- en: Docker orchestration
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker编排
- en: In the world of containerization, **orchestration** is the process of automating
    deployment and managing and scaling your applications across multiple hosts. Orchestration
    solutions help simplify the management of containerized applications, increase
    availability, and improve scalability by providing a layer of abstraction that
    allows you to manage containers at a higher level, instead of manually managing
    individual containers.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器化的世界中，**编排**是自动化部署、管理和扩展应用程序到多个主机的过程。编排解决方案通过提供一个抽象层，帮助简化容器化应用程序的管理，提升可用性，并改善可扩展性，使您可以在更高层次上管理容器，而不是手动管理每个容器。
- en: '**Docker Swarm** is a Docker-native clustering and orchestration tool that
    allows you to create and manage a cluster of Docker nodes, allowing users to deploy
    and manage Docker containers across a large number of hosts. Docker Swarm is an
    easy-to-use solution that comes built-in with Docker, making it a popular choice
    for those who are already familiar with Docker.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker Swarm** 是一个原生的 Docker 集群和编排工具，允许你创建并管理 Docker 节点的集群，使用户能够在多个主机上部署和管理
    Docker 容器。Docker Swarm 是一个易于使用的解决方案，并且与 Docker 一起内置，成为了那些已经熟悉 Docker 的用户的热门选择。'
- en: '**Kubernetes** is an open source container orchestration platform that was
    originally developed by Google. Kubernetes allows you to deploy, scale, and manage
    containerized applications across multiple hosts, while also providing advanced
    features such as self-healing, automated rollouts, and rollbacks. Kubernetes is
    one of the most popular orchestration solutions in use today and is widely used
    in production environments.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kubernetes** 是一个开源容器编排平台，最初由 Google 开发。Kubernetes 允许你在多个主机上部署、扩展和管理容器化应用，同时提供了自愈、自动发布和回滚等高级功能。Kubernetes
    是目前最流行的编排解决方案之一，并广泛应用于生产环境。'
- en: '**OpenShift** is a container application platform that is built on top of Kubernetes
    and it’s developed by Red Hat. This platform provides a complete solution for
    deploying, managing, and scaling containerized applications, with additional features
    such as built-in CI/CD pipelines, integrated monitoring, and automatic scaling.
    OpenShift is designed to be enterprise-grade, with features such as multi-tenancy
    and **role-based access control** (**RBAC**), making it a popular choice for large
    organizations that need to manage complex containerized environments.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenShift** 是一个建立在 Kubernetes 基础上的容器应用平台，由 Red Hat 开发。这个平台提供了一个完整的解决方案，用于部署、管理和扩展容器化应用，附加功能包括内建的
    CI/CD 流水线、集成监控和自动扩展。OpenShift 设计为企业级平台，具备多租户支持和**基于角色的访问控制**（**RBAC**）等功能，是需要管理复杂容器化环境的大型组织的热门选择。'
- en: There is a wide variety of orchestration solutions available, each with its
    strengths and weaknesses. The choice of which solution to use ultimately depends
    on your specific needs, but Docker Swarm, Kubernetes, and OpenShift are all popular
    choices that provide robust and reliable orchestration capabilities for containerized
    applications.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有各种各样的编排解决方案，每种方案都有其优缺点。选择使用哪种方案最终取决于你的具体需求，但 Docker Swarm、Kubernetes 和 OpenShift
    都是提供强大且可靠的容器化应用编排功能的热门选择。
- en: Docker Swarm
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Docker Swarm is a native clustering and orchestration solution for Docker containers.
    It provides a simple yet powerful way to manage and scale Dockerized applications
    across a cluster of hosts. With Docker Swarm, users can create and manage a swarm
    of Docker nodes that act as a single virtual system.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 是一个为 Docker 容器提供的原生集群和编排解决方案。它提供了一种简单而强大的方式来管理和扩展跨主机的 Docker 化应用。通过
    Docker Swarm，用户可以创建并管理一个由 Docker 节点组成的集群，这些节点作为一个虚拟系统共同工作。
- en: 'The base components of Docker Swarm are as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 的基本组件如下：
- en: '**Nodes**: These are the Docker hosts that form the Swarm. Nodes can be physical
    or virtual machines running the Docker daemon, and they can join or leave the
    Swarm as needed.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：这些是构成 Swarm 的 Docker 主机。节点可以是运行 Docker 守护进程的物理或虚拟机，并可以根据需要加入或退出 Swarm。'
- en: '**Services**: These are the applications that run on the Swarm. A service is
    a scalable unit of work that defines how many replicas of the application should
    run, and how to deploy and manage them across the Swarm.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：这些是在 Swarm 上运行的应用程序。服务是一个可扩展的工作单元，定义了应用程序应该运行多少个副本，以及如何在 Swarm 上部署和管理它们。'
- en: '**Managers**: These are the nodes responsible for managing the Swarm state
    and orchestrating the deployment of services. Managers are in charge of maintaining
    the desired state of the services and ensuring they are running as intended.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理节点**：这些节点负责管理 Swarm 状态并协调服务的部署。管理节点负责维持服务的期望状态，确保它们按预期运行。'
- en: '**Workers**: These are the nodes that run the actual containers. Workers receive
    instructions from the managers and run the desired replicas of the service.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作节点**：这些节点运行实际的容器。工作节点从管理节点接收指令，并运行所需的服务副本。'
- en: '**Overlay networks**: These are the networks that allow the services to communicate
    with each other, regardless of the node they are running on. Overlay networks
    provide a transparent network that spans the entire Swarm.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**覆盖网络**：这些是允许服务相互通信的网络，无论它们运行在哪个节点上。覆盖网络提供了一个跨越整个 Swarm 的透明网络。'
- en: Docker Swarm provides a simple and easy-to-use way to manage containerized applications.
    It is tightly integrated with the Docker ecosystem and provides a familiar interface
    for Docker users. With its built-in features for service discovery, load balancing,
    rolling updates, and scaling, Docker Swarm is a popular choice for organizations
    that are just starting with container orchestration.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 提供了一种简单且易于使用的方式来管理容器化应用程序。它与 Docker 生态系统紧密集成，为 Docker 用户提供了熟悉的界面。借助其内置的服务发现、负载均衡、滚动更新和扩展功能，Docker
    Swarm 是刚开始使用容器编排的组织的热门选择。
- en: 'To initialize Docker Swarm mode and add two workers to the cluster, you will
    need to initialize Swarm mode:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化 Docker Swarm 模式并将两个工作节点添加到集群中，你需要初始化 Swarm 模式：
- en: '[PRE54]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This will create a new Swarm and make the current node the Swarm manager.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的 Swarm，并将当前节点设置为 Swarm 管理器。
- en: 'Once the Swarm has been initialized, you can add worker nodes to the cluster.
    To do this, you need to run the following command on each worker node:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Swarm 初始化完成，你可以将工作节点添加到集群中。为此，你需要在每个工作节点上运行以下命令：
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, `<token>` is the token generated by the `docker swarm init` command output,
    which you can find in the preceding code block, and `<manager-ip>` is the IP address
    of the Swarm manager.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<token>` 是 `docker swarm init` 命令输出中生成的令牌，你可以在前面的代码块中找到它，而 `<manager-ip>`
    是 Swarm 管理器的 IP 地址。
- en: 'For example, if the token is `SWMTKN-1-0hu2dmht259tb4skyetrpzl2qhxgeddij3bc1wof3jxh7febmd-6pzkhrh4ak345m8022hauviil`
    and the manager IP is `10.0.2.15`, the command would be as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果令牌是 `SWMTKN-1-0hu2dmht259tb4skyetrpzl2qhxgeddij3bc1wof3jxh7febmd-6pzkhrh4ak345m8022hauviil`，而管理节点
    IP 地址是 `10.0.2.15`，命令将如下所示：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After running the `docker swarm join` command on each worker node, you can
    verify that they have joined the Swarm by running the following command on the
    Swarm manager node:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个工作节点上运行 `docker swarm join` 命令后，你可以通过在 Swarm 管理节点上运行以下命令来验证它们是否已加入 Swarm：
- en: '[PRE57]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This will show a list of all the nodes in the Swarm, including the manager and
    any workers you have added.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示 Swarm 中所有节点的列表，包括管理节点和你已添加的任何工作节点。
- en: After that, you can add more nodes and start deploying applications to Docker
    Swarm. It’s possible to reuse any Docker Compose you’re using or Kubernetes manifests.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后，你可以添加更多节点并开始将应用程序部署到 Docker Swarm。你可以重用任何正在使用的 Docker Compose 文件或 Kubernetes
    清单。
- en: 'To deploy a sample application, we can reuse a Docker Compose template by deploying
    a `wordpress` service, but we will need to update it slightly by using MySQL user
    and password files in the environment variables:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署一个示例应用程序，我们可以通过部署 `wordpress` 服务来重用 Docker Compose 模板，但我们需要稍微更新它，通过在环境变量中使用
    MySQL 用户和密码文件：
- en: '[PRE58]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here’s an example of adding secrets to both the `wordpress` and `db` services:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是向 `wordpress` 和 `db` 服务添加机密的示例：
- en: '[PRE59]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Here’s an example of adding a secrets definition at the bottom of `docker-compose.yml:secrets`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个在 `docker-compose.yml:secrets` 文件底部添加机密定义的示例：
- en: '[PRE60]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `external: true` setting is telling `docker-compose` that secrets are already
    present and that it should not try to update or recreate them on its own.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`external: true` 设置告诉 `docker-compose` 机密已经存在，它不应该尝试更新或重新创建这些机密。'
- en: In this version of the Compose file, we use secrets to store the MySQL user
    and password for both the `wordpress` and `db` services.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本的 Compose 文件中，我们使用机密来存储 `wordpress` 和 `db` 服务的 MySQL 用户和密码。
- en: 'To deploy this file to Docker Swarm, we can use the following commands:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此文件部署到 Docker Swarm，我们可以使用以下命令：
- en: '[PRE61]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we can deploy the stack:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以部署堆栈：
- en: '[PRE62]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here, `docker-compose.yaml` is the name of the Compose file and `my-stack-name`
    is the name of the Docker stack.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`docker-compose.yaml` 是 Compose 文件的名称，`my-stack-name` 是 Docker 堆栈的名称。
- en: 'Once the stack has been deployed, the `wordpress`, `web`, and `db` services
    will be running with the MySQL user and password specified in the secrets. You
    can verify this by listing stacks and checking if containers are running:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦堆栈部署完成，`wordpress`、`web` 和 `db` 服务将使用在机密中指定的 MySQL 用户和密码运行。你可以通过列出堆栈并检查容器是否正在运行来验证这一点：
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Docker Swarm is a great project to start your adventure with Docker orchestration
    methods. It’s possible to use it with a production-grade system by using various
    plugins that will extend its default functionality.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 是一个很好的项目，可以让你开始学习 Docker 编排方法。通过使用各种插件扩展其默认功能，它也可以用于生产级系统。
- en: Kubernetes and OpenShift
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 和 OpenShift
- en: 'Two of the most popular tools for orchestrating Docker containers are Kubernetes
    and OpenShift. Although they share some similarities, they also have some significant
    differences. Here are the main differences between Kubernetes and OpenShift:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 两个最受欢迎的 Docker 容器编排工具是 Kubernetes 和 OpenShift。尽管它们有一些相似之处，但也存在一些显著的区别。以下是 Kubernetes
    和 OpenShift 之间的主要区别：
- en: '**Architecture**: Kubernetes is a standalone orchestration platform that is
    designed to work with multiple container runtimes, including Docker. OpenShift,
    on the other hand, is a platform that is built on top of Kubernetes. It provides
    additional features and tools, such as source code management, continuous integration,
    and deployment. These additional features make OpenShift a more comprehensive
    solution for enterprises that require end-to-end DevOps capabilities.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构**：Kubernetes 是一个独立的编排平台，旨在与多个容器运行时（包括 Docker）一起工作。而 OpenShift 是建立在 Kubernetes
    之上的平台。它提供了额外的功能和工具，如源代码管理、持续集成和部署。这些附加功能使 OpenShift 成为一个更全面的解决方案，适合需要端到端 DevOps
    功能的企业。'
- en: '**Ease of use**: Kubernetes is a powerful orchestration tool that requires
    a high level of technical expertise to set up and operate. OpenShift, on the other
    hand, is designed to be more user-friendly and accessible to developers with varying
    levels of technical knowledge. OpenShift provides a web-based interface for managing
    applications and can be integrated with various development tools, making it easier
    for developers to work with.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：Kubernetes 是一个强大的编排工具，需要较高的技术水平才能设置和操作。而 OpenShift 则旨在更加用户友好，适合具有不同技术背景的开发人员。OpenShift
    提供了一个基于 Web 的界面来管理应用，并且可以与各种开发工具集成，方便开发人员使用。'
- en: '**Cost**: Kubernetes is an open source project that is free to use, but enterprises
    may need to invest in additional tools and resources to set it up and operate
    it. OpenShift is an enterprise platform that requires a subscription for full
    access to its features and support. The cost of OpenShift may be higher than Kubernetes,
    but it provides additional features and support that may be worth the investment
    for enterprises that require advanced DevOps capabilities.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：Kubernetes 是一个开源项目，可以免费使用，但企业可能需要投入额外的工具和资源来搭建和操作它。OpenShift 是一个企业级平台，完全访问其功能和支持需要订阅。OpenShift
    的成本可能高于 Kubernetes，但它提供了额外的功能和支持，对于需要高级 DevOps 功能的企业来说，可能值得投资。'
- en: Both solutions are powerful Docker orchestration tools that offer different
    benefits and trade-offs. Kubernetes is highly customizable and suitable for more
    technical users. OpenShift, on the other hand, provides a more comprehensive solution
    with additional features and a user-friendly interface but comes at a higher cost.
    You should consider specific needs in your organization when choosing between
    these two tools, keeping in mind that Docker Swarm is also an option. Cloud providers
    also developed their own solutions, with Elastic Container Service being one of
    them.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种解决方案都是强大的 Docker 编排工具，提供不同的优势和权衡。Kubernetes 高度可定制，适合更具技术背景的用户。另一方面，OpenShift
    提供了更全面的解决方案，具有额外的功能和更易于使用的界面，但成本较高。在选择这两种工具时，你应该考虑你组织的具体需求，同时记住 Docker Swarm 也是一个可选项。云服务提供商也开发了自己的解决方案，其中
    Elastic Container Service 就是其中之一。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered more advanced topics around Docker, only touching
    topics around orchestration. Kubernetes, OpenShift, and SaaS solutions provided
    by cloud operators are driving the creation of new tools that will further ease
    Docker’s use in modern applications.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们讨论了关于 Docker 的更高级话题，仅涉及了容器编排相关的内容。Kubernetes、OpenShift 和云服务提供商提供的 SaaS
    解决方案正在推动新工具的创造，这些工具将进一步简化 Docker 在现代应用中的使用。
- en: Docker has had a profound impact on the world of software development and deployment,
    enabling us to build, ship, and run applications more efficiently and reliably
    than ever before. By understanding the internals of Docker and following best
    practices for working with it, we can ensure that our applications are secure,
    performant, and scalable across a wide range of environments.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Docker对软件开发和部署的世界产生了深远影响，使我们能够比以往更加高效和可靠地构建、发布和运行应用程序。通过了解Docker的内部机制并遵循最佳实践，我们可以确保我们的应用程序在各种环境中都是安全、高效和可扩展的。
- en: In the next chapter, we will look into challenges on how to monitor and gather
    logs in a distributed environment built on top of Docker containers.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨在基于Docker容器的分布式环境中，如何监控和收集日志的挑战。
- en: 'Part 3: DevOps Cloud Toolkit'
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：DevOps 云工具包
- en: This last part of the book will focus more on automation using **Configuration
    as Code** (**CaC**) and **Infrastructure as Code** (**IaC**). We will also talk
    about monitoring and tracing as a crucial part of modern application development
    and maintenance. In the last chapter, we will talk about DevOps pitfalls we’ve
    experienced in many projects we’ve been involved with.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的最后部分将更多地关注通过**配置即代码**（**CaC**）和**基础设施即代码**（**IaC**）实现自动化。我们还将讨论监控和追踪作为现代应用程序开发和维护的关键部分。在最后一章，我们将讨论我们在许多项目中经历过的DevOps陷阱。
- en: 'This part has the following chapters:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B18197_10.xhtml#_idTextAnchor282), *Monitoring, Tracing, and
    Distributed Logging*'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18197_10.xhtml#_idTextAnchor282)，*监控、追踪与分布式日志记录*'
- en: '[*Chapter 11*](B18197_11.xhtml#_idTextAnchor325), *Using Ansible for Configuration
    as Code*'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18197_11.xhtml#_idTextAnchor325)，*使用Ansible进行配置即代码*'
- en: '[*Chapter 12*](B18197_12.xhtml#_idTextAnchor365), *Leveraging Infrastructure
    as Code*'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18197_12.xhtml#_idTextAnchor365)，*利用基础设施即代码*'
- en: '[*Chapter 13*](B18197_13.xhtml#_idTextAnchor412), *CI/CD with Terraform, GitHub,
    and Atlantis*'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18197_13.xhtml#_idTextAnchor412)，*使用Terraform、GitHub和Atlantis进行CI/CD*'
- en: '[*Chapter 14*](B18197_14.xhtml#_idTextAnchor443), *Avoiding Pitfalls in DevOps*'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B18197_14.xhtml#_idTextAnchor443)，*避免DevOps中的陷阱*'
