- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Command-Line Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令行基础知识
- en: In this chapter, we’re going to dive right into the Linux command line. We will
    explain what makes it so powerful and, by extension, important to every system
    administrator and DevOps person. But more importantly, we will start teaching
    you the most useful commands and a way to use them efficiently. Along the way,
    we will be adding other core Linux concepts, as they will be required to understand
    the chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将直接深入学习 Linux 命令行。我们将解释它的强大之处，以及如何对每个系统管理员和 DevOps 人员都至关重要。更重要的是，我们将开始教授你最有用的命令及其有效使用方式。在此过程中，我们还将添加其他核心
    Linux 概念，因为这些概念对理解本章是必需的。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: What a command line is and how it works
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是命令行及其工作原理
- en: Why it is so important to feel comfortable working with the command line
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么熟练掌握命令行如此重要
- en: Basic commands for Linux system administration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux 系统管理的基本命令
- en: It is not possible to introduce all the commands and tools in a single chapter.
    What follows is our choice of the most basic tools you will need to know. Managing
    the Linux system is a separate book topic on its own. It so happens that Packt
    does have several publications on that.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能在单一章节中介绍所有命令和工具。接下来我们选择了您需要了解的最基本工具。管理 Linux 系统是一个独立的书籍主题。恰好 Packt 出版社确实有几本相关出版物。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It is highly recommended to have a Linux system installed and ready for use.
    We recommend it to be a virtual machine or a laptop that you can safely reinstall
    from scratch in case something goes horribly wrong. It will let you follow the
    examples in the book and perform any kind of exercise that we give you.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议准备好并安装 Linux 系统以供使用。我们建议使用虚拟机或可以安全地从头开始重新安装的笔记本电脑。这将使您能够按照书中的示例并执行我们给出的任何练习。
- en: We are not going to cover an installation. Every distribution may use its own
    installer, either graphical or text (depending on the distribution and which variant
    you’ve picked). You’ll need to note down or remember the name of your user (conveniently
    called username or login) and password. There are ways to get into the system
    if you have physical access and you don’t know either the login or password, or
    both, but they are way outside of the scope of this book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会涵盖安装过程。每个发行版可能都有自己的安装程序，可以是图形化的或文本的（取决于发行版及其选择的变体）。您需要记下或记住您的用户名（方便地称为用户名或登录名）和密码。如果您有物理访问权限但不知道登录名或密码，或两者都不知道，有方法可以进入系统，但这些超出了本书的范围。
- en: Our main distribution in the book is Debian. However, you should be alright
    with any of the major ones we covered in the previous chapter, *Choosing the Right
    Linux Distribution*, as long as it isn’t Alpine.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们书中的主要发行版是 Debian。然而，只要不是 Alpine，你在上一章中涵盖的任何主要发行版都应该可以使用。
- en: The Linux command line – shell
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux 命令行 - shell
- en: The natural environment for a Linux system administrator is the command line.
    You’ll never hear anyone call it that, however. The correct name is the **shell**,
    and from now on, that’s how we’re going to address it in the book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 系统管理员的自然环境是命令行。但是，你永远不会听到有人这样称呼它。正确的名称是**shell**，从现在开始我们在书中就这样称呼它。
- en: The **shell** is a program that accepts input from a user (mostly keyboard strokes,
    but there are other ways, and you can even use a mouse pointer), interprets it,
    and, if it’s a valid command, executes it, providing the user with the result
    or with error information if they’ve made a mistake or if the commands couldn’t
    complete their execution properly.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell** 是一个接受用户输入（主要是键盘输入，但也有其他方式，甚至可以使用鼠标指针）的程序，解释这些输入，如果是有效的命令则执行它，并向用户提供结果或错误信息，如果命令不能正确执行。'
- en: 'There are a few ways to access the shell:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种访问 shell 的方法：
- en: Log in to the Terminal (screenshot in *Figure 2**.1*)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录到终端（*图2.1** 中的截图）
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You’ll also see the term **console**. There is a difference between the Terminal
    and a console. A **console** is a physical device that lets users interact with
    the computer. It is the physical input (nowadays, mostly keyboard) and output
    (nowadays, a monitor, but in the beginning, the output was printed out). **Terminal**
    is a console emulator, a program that lets users perform the same tasks.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到术语 **console**。终端和控制台是有区别的。**控制台** 是一个物理设备，让用户与计算机交互。它是物理输入（现在通常是键盘）和输出（现在通常是显示器，但最初输出是打印出来的）。**终端**
    是一个控制台模拟器，一个程序，让用户执行相同的任务。
- en: Open a Terminal window in a graphical interface, if you have one
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在图形界面中打开一个终端窗口（如果你有的话）
- en: Log in remotely over a secure connection from another device (phone, tablet,
    or your computer)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过安全连接远程登录到另一台设备（手机、平板或你的电脑）
- en: The shell is a very powerful environment. It may seem cumbersome at first to
    do everything by typing commands, but soon you’ll learn that the more complex
    the task, the more you can do with the shell, more easily than with graphical
    interfaces. Every Linux system administrator worth their salt will know how to
    do tasks in the shell and how to manage the system through it, and I wouldn’t
    risk much by betting that they will prefer the shell to any GUI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 是一个非常强大的环境。一开始通过输入命令做所有事情可能看起来有些繁琐，但很快你会发现，任务越复杂，通过 shell 完成起来比图形界面更容易。每个有经验的
    Linux 系统管理员都知道如何在 shell 中完成任务，以及如何通过它来管理系统，我敢打赌他们更倾向于使用 shell 而非任何 GUI。
- en: Getting to know your shell
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解你的 shell
- en: The shell is a program, and as such, there is not a single shell. Instead, there
    are a number of more or less popular shells that bring forth their own view on
    how things should be done.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 是一个程序，因此并不是只有一个 shell。相反，有许多流行程度不同的 shell，它们各自呈现出不同的处理方式。
- en: 'By far the most popular and default in most Linux distributions is **Bash**
    (**Bourne again shell**). There are other shells you may want to be aware of:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大多数 Linux 发行版中最流行且默认的 shell 是 **Bash**（**Bourne Again Shell**）。还有其他一些你可能需要了解的
    shell：
- en: '**sh**: The original Steve Bourne shell. It is *the* shell, the very first
    one ever written that we know of. While it lacks many interactive features that
    users came to appreciate from other, more modern shells, *sh* is known for its
    speed of script execution and small size.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sh**：原始的 Steve Bourne shell。它是*最初的* shell，也是我们所知道的第一个编写出来的 shell。虽然它缺少许多用户从其他更现代的
    shell 中获得的交互功能，*sh* 以其快速的脚本执行速度和小巧的体积而闻名。'
- en: '**ksh**: Developed as an evolution of the Bourne shell, it is a superset of
    its predecessor. Thus, all scripts written for *sh* will run in *ksh*.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ksh**：作为 Bourne shell 的演变版本开发而来，它是其前身的超集。因此，所有为 *sh* 编写的脚本都能在 *ksh* 中运行。'
- en: '**csh**: The C shell. The name comes from its syntax, which closely follows
    the C programming language.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**csh**：C shell。这个名字来自于它的语法，它与 C 编程语言的语法非常相似。'
- en: '**zsh**: The Z shell. It should be well known to macOS users, as it is a default
    on this operating system. It is a completely modern shell, providing a lot of
    features that you’d expect from it: command history, arithmetic operations, command
    completion, and so on.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**zsh**：Z shell。对于 macOS 用户来说，它应该非常熟悉，因为它是该操作系统的默认 shell。它是一个完全现代化的 shell，提供了许多你所期待的功能：命令历史、算术运算、命令补全等。'
- en: 'We won’t trouble you much with shell variants and history. If you are interested
    in how Bash came to be, refer to this Wikipedia article: [https://en.wikipedia.org/wiki/Bash_(Unix_shell)](https://en.wikipedia.org/wiki/Bash_(Unix_shell)).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会用太多的 shell 变种和历史来困扰你。如果你对 Bash 的起源感兴趣，可以参考这篇维基百科文章：[https://en.wikipedia.org/wiki/Bash_(Unix_shell)](https://en.wikipedia.org/wiki/Bash_(Unix_shell))。
- en: In our book, we are working with Bash. As mentioned earlier, it is the default
    shell for most Linux distributions, it offers *sh* compatibility mode, it has
    all the features you’d expect from a modern shell, and the amount of books, articles,
    how-tos, and other material for extending your knowledge about it is staggering.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用的是 Bash。如前所述，它是大多数 Linux 发行版的默认 shell，提供 *sh* 兼容模式，拥有现代 shell 所有的特性，而且关于它的书籍、文章、教程等资料极其丰富。
- en: 'The first task that we will be performing is logging in to your shell. Depending
    on your chosen installation method, you may need to power up the local virtual
    machine, your physical machine, or a cloud-based **Virtual Private Server** (**VPS**).
    If you have picked a server installation without a graphical user interface, you
    should see something similar to the following screenshot:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要执行的第一个任务是登录到Shell中。根据你选择的安装方式，你可能需要启动本地虚拟机、物理机器或基于云的**虚拟专用服务器**（**VPS**）。如果你选择了没有图形界面的服务器安装，你应该看到类似以下的屏幕截图：
- en: '![Figure 2.1 – Login screen](img/B18197_02_1.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 登录界面](img/B18197_02_1.jpg)'
- en: Figure 2.1 – Login screen
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 登录界面
- en: You are presented with a login screen, where you can provide your username and
    password. Once successfully logged in, you are presented with a command prompt,
    which confirms that you’ve just successfully started your shell.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个登录界面，你可以在此输入用户名和密码。成功登录后，你会看到一个命令提示符，表示你已经成功启动了Shell。
- en: 'The way the prompt looks is configurable and may be different depending on
    your chosen distribution. There is, however, one thing that will stay the same,
    and we advise you to never change it. In the world of Linux, there are two types
    of users: *normal users* and the *superuser*. While the login for normal users
    can be anything as long as it adheres to the Linux user naming conventions, the
    superuser is called `root` as the username/login and its password next.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提示符的外观是可配置的，并且可能根据你选择的发行版而有所不同。不过，有一件事会保持不变，我们建议你不要更改它。在Linux世界中，有两种类型的用户：*普通用户*和*超级用户*。普通用户的登录名可以是任何符合Linux用户命名规范的名称，而超级用户的登录名是`root`，下面是其密码。
- en: The superuser account is named that way for a reason. In most Linux distributions,
    it’s the omnipotent user. Once logged in as `root`, you can do anything you wish,
    even deleting all files, including the operating system itself.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 超级用户账户之所以这么命名，是有原因的。在大多数Linux发行版中，它是无所不能的用户。登录为`root`后，你可以做任何事情，甚至删除所有文件，包括操作系统本身。
- en: To help you distinguish between being a normal user and the `root` one, the
    prompt will present you with a clue. While logged in as `root`, your prompt will
    end with the `#` sign. When logged in as a normal user, it will present you with
    `$`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你区分普通用户和`root`用户，提示符会给你提供一个线索。当以`root`用户登录时，提示符会以`#`符号结尾。当以普通用户登录时，提示符则会以`$`符号结尾。
- en: While we’re at it, the `#` (hash) sign is also a so-called comment sign. If
    you happen to paste a command or type it from the internet, if it starts with
    `#` or `$`, it is your clue as to which type of user should run this command.
    You should omit this sign, especially as `#` in front will prevent the command
    from running.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`#`（井号）符号也是所谓的注释符号。如果你从互联网复制命令或输入命令时，若它以`#`或`$`开头，这就是提示你该命令应该由哪种类型的用户来执行。你应该省略这个符号，尤其是`#`符号会阻止命令的执行。
- en: 'In addition to the sign that ends the prompt, many distributions will prepend
    the username to it, making sure you know which user you are. Given a user admin
    on a Linux system called `myhome`, the default prompt for Debian 11 will look
    like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了结束提示符的符号，许多发行版会在其前面加上用户名，确保你知道自己是哪位用户。如果在一个名为`myhome`的Linux系统上有一个管理员用户，Debian
    11的默认提示符看起来像这样：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For the `root` user, it would look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`root`用户，它看起来像这样：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For the record, there are more ways to check your identity, but we will leave
    that for [*Chapter 4*](B18197_04.xhtml#_idTextAnchor063).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 需要说明的是，检查身份的方式有很多种，但我们将留待在[*第4章*](B18197_04.xhtml#_idTextAnchor063)中讨论。
- en: I call to thee
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我呼唤你
- en: So far, so good. You have logged in, you know who you are, you can type, and
    you can read. But how do you actually run programs?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很好。你已经登录，知道自己是谁，可以输入命令并进行阅读。但实际操作程序是如何进行的呢？
- en: In the Linux lingo, running a program is executing it or calling it. Actually,
    **calling** is mostly used when referring to system commands or shell built-in
    commands, and **executing** is used when talking about something that is not a
    part of the distribution—so-called third-party programs or binary.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux术语中，运行一个程序就是执行它或调用它。实际上，**调用**这个词通常用于指代系统命令或Shell内建命令，而**执行**则用于谈论那些不属于发行版的一部分的程序——即所谓的第三方程序或二进制文件。
- en: Before I can tell you how to execute a program or call a command, I’ll have
    to explain a little bit about filesystem structure and a very important system
    variable called `PATH`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我告诉你如何执行程序或调用命令之前，我得先解释一下文件系统结构和一个非常重要的系统变量，叫做 `PATH`。
- en: The filesystem structure
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统结构
- en: Since it may be your first time, we are going to step back a little bit and
    explain how the filesystem is structured (in other words, how directories are
    organized in typical Linux).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这可能是你第一次接触，我们将稍微退后一步，解释一下文件系统的结构（换句话说，就是典型 Linux 系统中文件夹是如何组织的）。
- en: Linux follows the Unix philosophy that states that everything is a file. (There
    are exceptions, but not many.) The consequence is that almost every aspect of
    the operating system is reflected either as a file or a directory. Memory states,
    processes' (running programs) states, logs, binaries, and device drivers all live
    within this structure. This also means that almost every aspect of your Linux
    system can be edited or inspected using just normal text editing tools.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 遵循 Unix 的哲学思想，即一切皆文件。（虽然有例外，但不多。）其结果是操作系统几乎每个方面都以文件或目录的形式体现。内存状态、进程（正在运行的程序）的状态、日志、二进制文件和设备驱动程序都在这个结构中。也就是说，几乎你
    Linux 系统的每个方面都可以通过普通的文本编辑工具进行编辑或检查。
- en: In the directory tree, its structure always starts with a `/` folder, called
    the **root directory**. Every drive, network share, and system directory lives
    in a hierarchy that starts from the root.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录树中，它的结构总是从一个 `/` 文件夹开始，这个文件夹被称为 **根目录**。每个驱动器、网络共享和系统目录都在一个从根目录开始的层次结构中。
- en: 'The process of making a network share or local drive available to the system
    or user is called `/home/` directory. You would never be able to tell it when
    browsing the filesystem structure. The only way to tell would be to inspect mounted
    drives and partitions using the following commands:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将网络共享或本地驱动器提供给系统或用户的过程被称为 `/home/` 目录。你在浏览文件系统结构时是无法看出它的。唯一能看出来的方法是通过以下命令检查已挂载的驱动器和分区：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: or
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are going to elaborate on them in [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050),
    so for now, just know they exist.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第 3 章*](B18197_03.xhtml#_idTextAnchor050)中详细讲解它们，所以现在你只需要知道它们的存在即可。
- en: The name of the uppermost directory is `/`. We already covered that. The separator
    between folders nested in another folder is also `/`. So `/usr/bin` means a `bin`
    directory that exists in the `usr` directory, and the `usr` directory exists in
    the `/` directory. Simple.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最上层目录的名称是 `/`。我们已经讲过了。嵌套在另一个文件夹中的文件夹之间的分隔符也是 `/`。所以 `/usr/bin` 表示在 `usr` 目录中存在一个
    `bin` 目录，而 `usr` 目录位于 `/` 目录中。很简单。
- en: 'There is a very nice command that lets us inspect the directory structure,
    conveniently called `tree`. It may not be present in your system. If so, don’t
    be worried; it’s not so important that you run it rather than go through our explanation.
    In [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050), when we introduce the installation
    of packages, you can revisit and play around. By default, the `tree` command will
    flood your screen with the full hierarchy, making it difficult to read and follow.
    There is an option, however, that lets us limit the depth we will be inspecting:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常方便的命令，可以让我们查看目录结构，叫做 `tree`。这个命令可能在你的系统中没有安装。如果没有，别担心；它并不是那么重要，你可以通过我们的讲解来了解。在[*第
    3 章*](B18197_03.xhtml#_idTextAnchor050)中，当我们介绍如何安装软件包时，你可以回过头来再试试这个命令。默认情况下，`tree`
    命令会把整个目录结构显示出来，可能会让屏幕信息满得让人难以阅读和跟随。不过，有一个选项可以让我们限制查看的深度：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There are several important concepts to cover here; we won’t be explaining all
    the directories at this time, however. The first time a given folder becomes important,
    in [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050) onward, we will briefly touch
    upon it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个重要的概念需要讲解；不过我们暂时不会讲解所有目录。每当某个文件夹变得重要时，从[*第 3 章*](B18197_03.xhtml#_idTextAnchor050)开始，我们会简要地提及它。
- en: 'First, the calling of `tree`. You saw my prompt, which tells me I am running
    as user admin, on a system named `myhome` and that I am not a `root` user (*the
    dollar sign at the end*). If you want to run the `tree` command, you will skip
    the prompt. Next is the actual call: `tree` with the `-L` option and number `1`;
    this instructs the program to only print one level of depth. In other words, it
    will not go any deeper into the directories. Finally, the `/` symbol tells the
    program to start printing at the very beginning of the filesystem—the `root` folder.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，调用 `tree` 命令。你看到了我的提示符，它告诉我当前以 admin 用户身份在名为 `myhome` 的系统上运行，并且我不是 `root`
    用户（*提示符末尾的美元符号*）。如果你想运行 `tree` 命令，你可以跳过提示符。接下来是实际的命令调用：`tree` 加上 `-L` 选项和数字 `1`；这会指示程序只打印一个深度级别。换句话说，它不会进一步进入目录。最后，`/`
    符号告诉程序从文件系统的最开始——`root` 文件夹开始打印。
- en: Next, you’ll notice that some rows have this mysterious arrow pointing from
    one name to another. This denotes a shortcut. There are two types of shortcuts,
    hard and symbolic. Directories can only have a symbolic link. In the preceding
    output, the `/bin` directory is a link to a `/usr/bin` directory. For all intents
    and purposes, they can be treated as one. There are technical and historical reasons
    for the existence of this link. In days past, tools living in `/bin` and `/sbin`
    were used to mount a `/usr` partition and then allow access to `/usr/bin` and
    `/usr/sbin`. Nowadays, this task is handled earlier in the boot process by other
    tools and the requirement is no longer necessary. The structure is kept for backward
    compatibility with tools that may require the existence of both `/bin` and `/sbin`
    directories. More details can be found at [https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.xhtml](https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.xhtml)
    or [https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained](https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你会注意到某些行中有一个神秘的箭头，指向一个名字。这个箭头表示一个快捷方式。有两种类型的快捷方式，硬链接和符号链接。目录只能拥有符号链接。在前面的输出中，`/bin`
    目录是指向 `/usr/bin` 目录的链接。从实际使用的角度来看，它们可以当作一个目录来对待。存在这个链接有技术上的原因和历史背景。过去，位于 `/bin`
    和 `/sbin` 目录中的工具用于挂载 `/usr` 分区，然后允许访问 `/usr/bin` 和 `/usr/sbin`。如今，这一任务由启动过程中的其他工具更早处理，因此不再需要此链接。该结构的保留是为了与可能需要同时存在
    `/bin` 和 `/sbin` 目录的工具的向后兼容性。更多详情请参考 [https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.xhtml](https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.xhtml)
    或 [https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained](https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained)。
- en: Since we already touched on the `/bin` and `/sbin` directory, let’s explain
    the difference. The `/usr/bin` directory contains `/usr/sbin` directory contains
    so-called `root` user. It will also contain binaries for system processes (called
    **daemons**)—programs that run in the background and do important work for the
    running system.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经提到了 `/bin` 和 `/sbin` 目录，那么我们来解释一下它们之间的区别。`/usr/bin` 目录包含 `/usr/sbin` 目录，后者包含所谓的
    `root` 用户。它还包含系统进程的二进制文件（称为 **守护进程**）——这些程序在后台运行并为正在运行的系统执行重要工作。
- en: The `/root` directory is the home of the superuser. This is where all its configuration
    files lay.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`/root` 目录是超级用户的主目录。所有与超级用户相关的配置文件都存放在这里。'
- en: The interesting one is the `/home` directory. This is where all the user home
    directories exist. When I created my admin user for my home machine, it was placed
    in the `/``home/admin` folder.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是 `/home` 目录。这里存放着所有用户的主目录。当我为我的家用机器创建 admin 用户时，它被放置在 `/home/admin` 文件夹中。
- en: 'Of importance to us at this moment will also be the `/etc/` directory. It contains
    all the configuration files for the whole system: the source for online package
    repositories, default shell configuration, system name, processes that start at
    the boot, system users and their passwords, and time-based commands. On a freshly
    installed Debian 11 system, the `/etc/` directory contains about 150 subdirectories
    and files, and each subdirectory may contain more folders inside.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，目前重要的是 `/etc/` 目录。它包含整个系统的所有配置文件：在线软件包仓库的源，默认的 shell 配置，系统名称，启动时会启动的进程，系统用户及其密码，以及基于时间的命令。在一个全新安装的
    Debian 11 系统中，`/etc/` 目录包含大约 150 个子目录和文件，每个子目录可能还包含更多的文件夹。
- en: The `/tmp` folder contains temporary files. They only live when the system is
    booted and will be deleted the moment it is shut down or restarted. The nature
    of those files is often very volatile; they can hop into existence and disappear
    very fast or can be modified very often. It is not uncommon for this directory
    to only exist in the computer’s RAM. It’s the fastest storage device your system
    has and will automatically purge on restart or power off.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`/tmp`文件夹包含临时文件。它们只在系统启动时存在，一旦关闭或重启系统，它们会被删除。这些文件的性质通常非常不稳定；它们可能会迅速生成并消失，或者频繁被修改。这个目录有时仅存在于计算机的内存中。它是你系统中最快的存储设备，并且在重启或关闭电源时会自动清除。'
- en: As mentioned earlier, additional drives are mounted under this structure. We
    could have a separate hard drive for home directories. The whole `/home` folder
    may live on it or even on a networked hard disk array. As mentioned, the `/tmp`
    directory is often mounted in the RAM. Sometimes, the `/var` directory (which
    contains things that can change often in the system but are not supposed to be
    purged, such as logs) is mounted on a separate drive. One of the reasons is that
    the contents of `/var`, and especially of `/var/log` (where the system logs live),
    can grow very fast and take all the available space, making accessing the system
    impossible or very tricky.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，附加驱动器会在该结构下挂载。我们可能会为主目录分配一个单独的硬盘。整个`/home`文件夹可能会存放在该硬盘上，甚至存放在一个网络硬盘阵列中。如前所述，`/tmp`目录通常挂载在内存中。有时，`/var`目录（包含系统中经常变化的内容但不应被清除的文件，如日志）会挂载在单独的硬盘上。这样做的原因之一是，`/var`的内容，尤其是`/var/log`（系统日志所在的目录），可能会增长得非常快，占用所有可用空间，导致无法访问系统，或者变得非常困难。
- en: 'Finally, there are two important and special directories that exist everywhere
    you go:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有两个重要且特殊的目录，遍布你访问的每个地方：
- en: '`.`: A single dot means the `.` folder, you’ll end up where you are. It’s useful,
    however, as you’ll see in [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050).'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`：一个点表示`．`文件夹，你将停留在当前位置。不过，它很有用，正如你将在[*第3章*](B18197_03.xhtml#_idTextAnchor050)中看到的那样。'
- en: '`..`: Two dots mean the directory above us—the `..` folder, you’ll end up one
    level above where you started. Note that for the `/` directory, both `.` and `..`
    mean the same: `/`. You can’t go any higher than the root.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`..`：两个点表示上级目录——`..`文件夹，你将进入比起始位置高一级的目录。请注意，对于`/`目录来说，`.`和`..`表示相同的目录：`/`。你无法再向上移动超出根目录。'
- en: Running a program
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行程序。
- en: Now that we know some things about the folder hierarchy, let’s briefly touch
    on executing programs.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对文件夹层次结构有了一些了解，接下来简要讲一下执行程序的过程。
- en: 'There are three basic ways to execute a program in a shell:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Shell中执行程序有三种基本方法：
- en: '`PATH` variable (explained in [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050)).'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATH`变量（在[*第3章*](B18197_03.xhtml#_idTextAnchor050)中解释）。'
- en: '`/`. When using the absolute path, you have to list all the directories that
    lead to the program, including the leading `/`. An example execution may look
    like this:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`。当使用绝对路径时，必须列出所有指向程序的目录，包括前导的`/`。执行示例可能如下所示：'
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`./`. This shortcut means the `./myprogram` or `./bin/myprogram`. The latter
    would mean: let’s start a program called `myprogram` that is in a `bin` directory
    that is in the current directory.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`./`。这个快捷方式表示`./myprogram`或`./bin/myprogram`。后者意味着：在当前目录中的`bin`目录里启动一个名为`myprogram`的程序。'
- en: To call a program in a directory somewhere else in the system using a relative
    path, we will have to use the two dots, meaning the parent folder. Let’s say you
    are logged in to your home directory, `/home/admin`, and want to execute a program
    in `/opt/some/program/bin`; you’d call `../../opt/some/program/bin/myprogram`.
    The two dots and slash mean moving up.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在系统中的其他目录调用程序时，我们需要使用两个点，表示父文件夹。假设你已经登录到你的主目录`/home/admin`，并想执行位于`/opt/some/program/bin`中的程序；你需要输入`../../opt/some/program/bin/myprogram`。这两个点和斜杠表示向上移动。
- en: If this looks arcane, it is because it is a little bit. Fortunately, everything
    will start coming together as the book progresses.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这看起来很神秘，那是因为它确实有点复杂。幸运的是，随着本书的推进，一切都会逐渐变得清晰。
- en: The command to teach you all commands
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用来教你所有命令的命令。
- en: 'You should get into the habit of searching the internet whenever you have a
    question or problem. Most of the issues you are going to run into are already
    fixed or explained out there. However, there’s one command that can save your
    life—or at least lots of time. You should make another habit of using it often
    – even if you are sure you know the correct syntax, you might just discover a
    better way of completing your task. This command is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该养成遇到问题或有疑问时上网查找的习惯。大多数问题已经在网上得到了解决或解释。然而，有一个命令能拯救你的生命——或者至少能节省很多时间。你应该养成经常使用它的习惯——即使你确信自己知道正确的语法，你可能还是会发现一种更好的完成任务的方法。这个命令如下：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `man` command is a shorthand for *manual* and it is exactly what it says:
    it is a manual for whatever command you want to learn about. To learn more about
    the `man` command, simply call the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`man` 命令是 *manual*（手册）的简写，它正是它所说的：它是你想了解的任何命令的手册。要了解更多关于 `man` 命令的内容，只需调用以下命令：'
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output you’ll see should be similar to the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的输出应该类似如下：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'I have cut it for brevity. A well-written `man` page will have several sections:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我已简化内容以便简洁。编写良好的 `man` 页面将包含多个部分：
- en: '`name`: This is where the name of the command is stated. If the command exists
    under various names, they will all be listed here.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这里列出了命令的名称。如果命令有多个名称，它们都会列出。'
- en: '`synopsis`: This will list possible ways of calling the command.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synopsis`：这将列出调用命令的可能方式。'
- en: '`description`: This is the purpose of the command.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`description`：这是命令的目的。'
- en: '`examples`: This will show several examples of the command call, to make the
    syntax clearer and give some ideas.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`examples`：这将展示几个命令调用的示例，以使语法更加清晰并提供一些思路。'
- en: '`options`: This will show all the available options and their meaning.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`options`：这将显示所有可用选项及其含义。'
- en: '`getting help`: This is how to get a shortened version of the command synopsis.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getting help`：这是获取简化版命令摘要的方式。'
- en: '`files`: If the command has configuration files or consumes files known to
    exist in the filesystem, they will be listed here (for `man`, I have listed `/etc/manpath.config`
    and `/usr/share/man`).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`：如果命令有配置文件或使用文件，并且这些文件在文件系统中已知存在，它们将被列在此处（对于 `man`，我列出了 `/etc/manpath.config`
    和 `/usr/share/man`）。'
- en: '`bugs`: This is where to look for bugs and report new ones.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bugs`：这是查找 bug 和报告新 bug 的地方。'
- en: '`history`: This will show all the current and previous authors of the program.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`history`：这将显示程序的当前及所有历史作者。'
- en: '`see also`: These are programs that are in some way tied to the command (for
    `man`: `apropos(1)`, `groff(1)`, `less(1)`, `manpath(1)`, `nroff(1)`, `troff(1)`,
    `whatis(1)`, `zsoelim(1)`, `manpath(5)`, `man(7)`, `catman(8)`, and `mandb(8)`).'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`see also`：这些是与命令有某种关联的程序（对于 `man`：`apropos(1)`，`groff(1)`，`less(1)`，`manpath(1)`，`nroff(1)`，`troff(1)`，`whatis(1)`，`zsoelim(1)`，`manpath(5)`，`man(7)`，`catman(8)`
    和 `mandb(8)`）。'
- en: Many commands will contain a lot of additional sections, specific to this program.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 许多命令会包含大量额外的部分，这些部分是特定于该程序的。
- en: 'The `man` pages will contain a lot of knowledge, and sometimes the names will
    duplicate. This is where the mysterious numbers in brackets come into play. The
    `man` pages are broken down into sections. To quote the `man` page about `man`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`man` 页面包含大量知识，有时名称可能会重复。这时，括号中的神秘数字就派上用场了。`man` 页面分为多个部分。引用 `man` 页面中的 `man`：'
- en: Executable programs or shell commands
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可执行程序或 shell 命令
- en: System calls (functions provided by the kernel)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统调用（内核提供的函数）
- en: Library calls (functions within program libraries)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 库调用（程序库中的函数）
- en: Special files (usually found in `/dev`)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊文件（通常位于 `/dev`）
- en: File formats and conventions, for example, `/etc/passwd`
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件格式和约定，例如，`/etc/passwd`
- en: Games
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 游戏
- en: Miscellaneous (including macro packages and conventions), for example, `man(7)`,
    `groff(7)`
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他（包括宏包和约定），例如，`man(7)`，`groff(7)`
- en: System administration commands (usually only for `root`)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统管理命令（通常仅限`root`使用）
- en: Kernel routines [non-standard]
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核例程 [非标准]
- en: Let’s take, for example, `printf`. There are several things that are called
    `printf`. One of them is a library function of the C programming language. Its
    `man` page will live in section `3`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，`printf`。有几种东西被称为 `printf`，其中之一是 C 语言的库函数。它的 `man` 页面位于第 `3` 节。
- en: 'To read about that library function, you have to tell `man` to look into section
    `3`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要阅读这个库函数，你必须告诉 `man` 去查找第 `3` 节：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Most commands and shell programs have a shorter synopsis called `help`. Usually,
    it can be invoked by running binary with the `-h` or --`help` option:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数命令和shell程序都有一个简短的概要，叫做`help`。通常，可以通过运行带有`-h`或--`help`选项的二进制文件来调用它：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I have cut the output for brevity, but you get the drift.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经简化了输出，但你应该明白我的意思。
- en: Note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The short options are preceded with one dash while longer ones are preceded
    with two. --`help` is not one long dash but two standard ones.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 短选项前面加一个短横线，而长选项前面加两个。--`help`不是一个长横线，而是两个标准的短横线。
- en: 'The `man` and `–help` commands should become your friends even before searching
    online. A lot of questions can be quickly answered just by looking at the `help`
    output. Even if you are a seasoned administrator, you are allowed to forget command
    syntax. There is an online source of endless Linux guides called *The Linux Documentation
    Project*: [https://tldp.org](https://tldp.org). Make it your bookmark.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`man`和`–help`命令应该成为你的朋友，即使在你搜索在线资料之前。很多问题可以通过查看`help`输出快速得到答案。即使你是一个经验丰富的管理员，也可以忘记命令语法。网络上有一个无尽的Linux指南来源，叫做*The
    Linux Documentation Project*：[https://tldp.org](https://tldp.org)。将它加入书签吧。'
- en: Know your environment
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解你的环境
- en: The way your system behaves is controlled by several factors. One of them is
    a set of variables called **environment**. They set things such as what language
    your system is going to use when talking to you, how entries during listing will
    be sorted, where the shell is going to look for executables, and many more. The
    exact set of variables depends on the distribution.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的行为由几个因素控制。其中之一就是一组被称为**环境变量**的变量。它们设置了系统与用户交互时使用的语言，列出文件时的排序方式，shell寻找可执行文件的路径等许多其他内容。具体的环境变量集取决于所使用的发行版。
- en: 'The full set of all the environment variables that your shell has set can be
    printed using the `env` command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`env`命令打印出shell设置的所有环境变量的完整列表：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you know the variable you want to inspect, you can use the `echo` command:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道要检查的变量，可以使用`echo`命令：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that when you are using a variable, you have to precede its name with
    a dollar sign, hence `$PATH`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当你使用一个变量时，你必须在变量名前加上美元符号，因此是`$PATH`。
- en: Where in the PATH am I?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我当前在PATH中的哪个位置？
- en: 'Since we mentioned `PATH`, let’s talk briefly about it. **Path** can mean two
    things:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们提到过`PATH`，那么我们简要地谈一下它。**Path**可以有两种含义：
- en: 'A place in the system that leads to something: a binary, a file, or a device'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统中的一个指向某个对象的地方：一个二进制文件，一个文件，或者一个设备
- en: An environment variable that lists places where the shell is going to look when
    trying to execute a program
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个列出shell在执行程序时会查找的地方的环境变量
- en: 'You already know a little bit about the first kind of path. We explained the
    absolute path and relative path. There is a command that lets you move around,
    and it’s called `cd` (shortcut for `cd` without an argument, it will take you
    to your home directory. If you call it with an argument, it will move you to the
    specified folder, given that it exists, you specified the path properly, and you
    have the right to access it. Let’s see a few examples:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经对第一种路径有了些了解。我们解释了绝对路径和相对路径。有一个命令可以让你在目录间移动，它叫做`cd`（如果不带参数，`cd`会将你带到家目录。如果你带上参数，它会将你移动到指定的文件夹，前提是文件夹存在，你指定的路径正确，并且你有权限访问该文件夹。我们来看看几个例子：
- en: 'Checking which directory we’re currently in:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查当前所在的目录：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Changing directory to `/home/admin/documents/current`:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换目录到`/home/admin/documents/current`：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Changing one directory up from a current level:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从当前目录上级跳转：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Changing the directory to the user home directory:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换到用户的家目录：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Know your rights
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解你的权限
- en: 'The most basic security mechanism in Linux is based on defining a combination
    of rights for a set of entities. The rights are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中最基本的安全机制是基于为一组实体定义权限组合。权限如下：
- en: '`read`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`'
- en: '`write`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write`'
- en: '`execute` (read contents when talking about a directory)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute`（在谈到目录时，表示读取内容）'
- en: 'And the entities are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实体如下：
- en: The owner of the file or directory
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件或目录的拥有者
- en: The group that owns the file or directory
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有文件或目录的组
- en: All the other users and groups
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他用户和组
- en: This is a crude security system. It’s sufficient for small servers and desktop
    uses but, for more complex setups, it is sometimes too restraining. There are
    other additional systems, such as **Access Control Lists** (**ACLs**), AppArmor,
    SELinux, and more. We are not going to cover them in this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个粗略的安全系统。它足以用于小型服务器和桌面使用，但对于更复杂的设置，有时它的限制太大。还有其他附加的系统，例如**访问控制列表**（**ACLs**）、AppArmor、SELinux等。本书不打算涵盖这些内容。
- en: With the use of the previous systems, we can still achieve quite a lot regarding
    our system security.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前提到的系统，我们仍然可以在系统安全性方面取得相当大的进展。
- en: 'How do those rights and ownership work? We use the `ls` command (list files
    and directories):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些权限和所有权是如何工作的？我们使用`ls`命令（列出文件和目录）：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The output is presented in nine columns.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出呈现为九列。
- en: The first column presents the type of the entry and the rights in a concise
    manner, but let’s jump to the third and fourth. Those columns inform us about
    who is the owner of the file and what user group the file belongs to. All files
    and directories must belong to a user and to a group. In the preceding output,
    most of the files belong to the user admin and to the group admin. The exception
    is the `..` directory, which belongs to the `root` user and `root` group. It is
    common to denote this pair in the form `user:group`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列简洁地呈现条目的类型和权限，但让我们跳到第三列和第四列。这些列告诉我们谁是文件的所有者，以及该文件属于哪个用户组。所有文件和目录必须属于一个用户和一个组。在前面的输出中，大多数文件属于用户admin和组admin。例外是`..`目录，它属于`root`用户和`root`组。通常用`user:group`的形式表示这对。
- en: The next columns describe the size (with a directory, it describes the size
    of the entry, not how much space the directory contents take), the date of the
    last change, the time of the last change, and the name of the entry.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的列描述了文件的大小（对于目录，它描述的是条目的大小，而不是目录内容占用的空间），最后修改的日期、最后修改的时间以及条目的名称。
- en: 'Now, let us go back to the first column. It informs us what an owner, a group,
    and all other users in the system are allowed to do with the given file or directory:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到第一列。它告诉我们，文件或目录的所有者、组和系统中所有其他用户被允许对该条目执行什么操作：
- en: The letter `d` means that we are dealing with a directory. A dash (`–`) means
    it’s a file.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字母`d`表示我们正在处理的是一个目录。一个破折号（`–`）表示它是一个文件。
- en: 'Next is a group of nine one-letter symbols that denote who can do what with
    the given entry:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一组九个单字符符号，表示谁可以对给定的条目执行什么操作：
- en: The first three letters denote what the file or directory owner can do with
    it. `r` means that they can read it, `w` means they can write to it, and `x` means
    they can execute it as a program. In the case of a text file with `x` set, the
    shell will try to run it as a script. The caveat is when we are dealing with a
    directory. `x` means that we can change a current working directory to it. It
    is possible to be able to go into a directory (`x` set) and not be able to see
    what is in it (`r` not set).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个字母表示文件或目录的所有者可以对其执行的操作。`r`表示他们可以读取，`w`表示他们可以写入，`x`表示他们可以将其作为程序执行。如果一个文本文件设置了`x`，shell将尝试将其作为脚本运行。需要注意的是，当我们处理目录时，`x`表示我们可以将当前工作目录切换到该目录。有可能进入一个目录（`x`设置）但无法查看其中的内容（`r`未设置）。
- en: The same three letters explain the group rights in the second grouping.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的三个字母在第二组中解释了组的权限。
- en: The same set explains all other users’ rights in the third grouping.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的一组符号在第三组中解释了所有其他用户的权限。
- en: In the preceding output, `.Bash_history` is a file (it has a dash in the first
    field); the owner of the file (user admin) can read from it and write to it. It
    is possible to be able to write to a file (for example, a log file) but not be
    able to read from it. The file cannot be executed as a script (a dash). The next
    six dashes inform us that neither users assigned to the group admin nor any other
    user or group in the system can do anything with this file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，`.Bash_history`是一个文件（它在第一列有一个破折号）；文件的所有者（用户admin）可以读取并写入该文件。可能会有这样的情况：可以写入一个文件（例如日志文件），但无法读取它。该文件不能作为脚本执行（破折号）。接下来的六个破折号告诉我们，分配给admin组的用户以及系统中任何其他用户或组都不能对该文件执行任何操作。
- en: There is one exception, and it is the `root` user. Without stepping up with
    ACLs and tools such as SELinux, you cannot limit root’s omnipotence in the system.
    Even for a file or directory that has no rights assigned (all dashes), `root`
    has full access to it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个例外，就是`root`用户。除非通过ACL和诸如SELinux等工具提升权限，否则无法限制`root`在系统中的全能性。即使是没有权限分配的文件或目录（全是破折号），`root`也能完全访问。
- en: 'The administration of the ownership and the rights is done by means of two
    commands:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有权和权限的管理是通过两条命令来完成的：
- en: '`chown`: This command allows you to change the ownership of a file or directory.
    The name is a shortcut for *changing owners*. The syntax is quite simple. Let’s
    take this opportunity to exercise a bit with the notation in Linux help:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chown`：此命令允许你更改文件或目录的所有权。该命令的名称是*更改所有者*的缩写。语法非常简单。让我们借此机会练习一下Linux帮助文档中的表示法：'
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is an unwritten convention that most, if not all, commands’ help adhere
    to:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个不成文的约定，几乎所有命令的帮助文档都会遵循：
- en: Text without any brackets must be typed as shown.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有括号的文本必须按显示方式输入。
- en: Anything inside `[ ]` brackets is optional. In the `chown` command, the user
    and group are optional, but you must supply at least one.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何位于`[ ]`括号中的内容是可选的。在`chown`命令中，用户和组是可选的，但你必须至少提供一个。
- en: Text in `< >` brackets is mandatory but is a placeholder for whatever you will
    have to supply.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尖括号`< >`中的文本是强制性的，但它是一个占位符，代表你需要提供的内容。
- en: Brackets `{ }` denote a set of options and you’re supposed to choose one. They
    can be separated by a vertical line, `|`.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号`{ }`表示一组选项，你需要选择其中一个。它们可以通过竖线`|`分隔。
- en: Three dots after an element means this element can be supplied multiple times.
    In the `chown` case, it’s the name of the file or directory.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素后面跟三个点表示该元素可以多次提供。在`chown`的例子中，它是文件或目录的名称。
- en: 'The following is a set of ownership changes that I apply to a file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我对文件应用的一组所有权变更：
- en: I change the ownership from `admin` to `testuser`, but I leave the group unchanged.
    Please note that changing actually requires the use of the `root` account (via
    the `sudo` command, explained in [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050)).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将所有权从`admin`更改为`testuser`，但不改变组。请注意，进行更改实际上需要使用`root`账户（通过`sudo`命令，详见[*第3章*](B18197_03.xhtml#_idTextAnchor050)）。
- en: 'I change the ownership back to `admin`, but change the group to `testuser`:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我将所有权更改回`admin`，但将组更改为`testuser`：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding output, we can see that a successful call to a command produces
    no output (`chown`) unless the output is the purpose of the command (`ls`). This
    is one of the basic rules that Linux follows. In the following output, we can
    see what happens when the command terminates with an error—insufficient rights
    to change the group:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们可以看到，成功调用一个命令时不会产生任何输出（`chown`），除非输出本身就是命令的目的（如`ls`）。这是Linux遵循的基本规则之一。在接下来的输出中，我们可以看到当命令因错误而终止时的情况——没有足够的权限来更改组：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'One other way to run the `chown` command is to point to a reference file, as
    in the following example:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`chown`命令的另一种方式是指定一个参考文件，如下面的示例所示：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the `–reference` option, we point to a file that will be a matrix for
    our changes. This will become more interesting once we move on to the next chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`–reference`选项，我们可以指定一个文件作为我们更改的基准。这在我们进入下一章节时会变得更加有趣。
- en: '`chmod`: Similar to the `chown` command, `chmod` (short for *change mode*)
    is the one you’ll be looking for to change the rights of the assigned user and
    group:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod`：与`chown`命令类似，`chmod`（*更改模式*的缩写）是你用来更改分配给用户和组的权限的命令：'
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `chmod` command will accept options, mandatory mode, optionally more modes,
    and a list of files that the change is supposed to be applied to. As with the
    `chown` command, we can specify a reference file that will have its mode copied
    over.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`chmod`命令将接受选项、强制模式、可选的更多模式以及需要应用更改的文件列表。与`chown`命令一样，我们可以指定一个参考文件，其模式将被复制过来。'
- en: 'In the first form, you will specify the mode for either a user, a group, others,
    or all of them using the following syntax:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种形式中，你将指定一个用户、一个组、其他人或所有这些的权限模式，语法如下：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here, the following meanings apply:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这里适用以下含义：
- en: '`u`: User, in other words, the owner of the file'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`：用户，也就是文件的拥有者'
- en: '`g`: Group that owns the file'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`：拥有文件的组'
- en: '`o`: Others—all others'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o`：其他人——所有其他人'
- en: '`a`: All, meaning everyone'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：所有，意味着每个人'
- en: '`-`: Remove the specified right'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`：移除指定的权限'
- en: '`+`: Add the specified right'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：添加指定的权限'
- en: '`=`: Make the rights exactly as specified'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`：将权限设置为完全符合指定的内容'
- en: Let’s see some examples.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些例子。
- en: 'This adds read and write permissions to the `testfile` file for the file owner:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这为文件所有者添加了`testfile`文件的读写权限：
- en: '[PRE24]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This removes the execute right to the `testfile` file for everyone who is not
    the file owner and is not in the group that owns the file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这会移除对`testfile`文件的执行权限，适用于所有不是文件所有者且不在文件所有组中的用户：
- en: '[PRE25]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This gives the user and the group read and execute rights to the `testfile`
    file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这为用户和组授予了`testfile`文件的读取和执行权限：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the syntax summary we have pasted, the middle row is interesting. The octal
    mode means that we can specify the mode by means of numbers. This is especially
    useful in scripts, as dealing with numbers is easier. Once you memorize the mode
    numbers, you may find it easier to use the octal `chmod`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们粘贴的语法总结中，中间一行很有趣。八进制模式意味着我们可以通过数字指定模式。这在脚本中尤其有用，因为处理数字更简单。一旦你记住了模式数字，你可能会发现使用八进制`chmod`更加方便。
- en: 'The formula for the numeric setting of file mode is simple:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 设置文件模式的数字公式很简单：
- en: '`0`: no rights (`---`)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`：无权限 (`---`)'
- en: '`1`: execute mode (`--x`)'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1`：执行模式 (`--x`)'
- en: '`2`: write mode (`-w-`)'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`：写入模式 (`-w-`)'
- en: '`4`: read mode (`r–`)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`4`：读取模式 (`r–`)'
- en: 'To set the mode on a file or directory, you will use a sum of the rights you
    want to apply, starting with a leading `0`, which will inform `chmod` that you
    are setting octal mode. The syntax is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置文件或目录的模式，你将使用你想要应用的权限的总和，前面加上一个`0`，这将告诉`chmod`你正在设置八进制模式。语法如下：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There is a very important difference between this form and the letter one—you
    must specify the mode for all three types of entities: user, group, and others.
    You cannot omit any of them. This means that you also won’t be using the `-`,
    `+`, or `=` signs. With the octal syntax, the rights will always be exactly as
    specified.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这种形式和字母形式之间有一个非常重要的区别——你必须为所有三种实体（用户、组和其他）指定模式。你不能省略其中任何一个。这意味着你也不会使用`-`、`+`或`=`符号。使用八进制语法时，权限将始终严格按指定方式设置。
- en: 'To combine the modes, you will add their numbers and use the sum as the final
    specifier. You will find that this is a very elegant solution. There are no two
    identical sums of those numbers (combination of rights). Try it:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要组合多个模式，你需要将它们的数字相加，并使用这个总和作为最终的指定。你会发现这是一个非常优雅的解决方案。没有两个相同的数字组合（权限组合）。试试吧：
- en: Execute and read is 1 and 2 = 3\. There is no other combination of the modes
    that can result in 3.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行和读取是1和2，合起来是3。没有其他组合可以得到3。
- en: Read and write is 2 and 4 = 6\. Again, no other combination can result in 6.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读和写是2和4，合起来是6。再次强调，没有其他组合能得到6。
- en: Now, let’s try some examples.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试一些例子。
- en: 'The owner of the file will have read and write access to the file, while the
    group and others will have read access:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的所有者将拥有文件的读写权限，而组用户和其他用户将只有读取权限：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The owner of the file has all the rights (read, write, and execute), while
    the group and others can read and execute only:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的所有者拥有所有权限（读、写和执行），而组用户和其他用户只能读取和执行：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The leading `0` in the mode is not obligatory.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 模式前面的`0`并非必需。
- en: We have covered the filesystem, directory structure, and basic file permissions
    related to users and groups. In the next section, we will introduce basic Linux
    commands.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讲解了文件系统、目录结构以及与用户和组相关的基本文件权限。在下一部分，我们将介绍基本的Linux命令。
- en: Interacting with the system
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与系统交互
- en: Programs and scripts lying on a hard drive are just files. The moment they get
    mapped to the memory and start performing their function, they become **processes**.
    At this stage, you can safely assume that anything running in the system is some
    kind of a process.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在硬盘上的程序和脚本只是文件。当它们被映射到内存并开始执行时，它们就变成了**进程**。在这一阶段，你可以安全地假设系统中运行的任何东西都是某种进程。
- en: Process this
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理这个
- en: 'Processes in Linux have several characteristics that you need to be aware of:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的进程有几个特性是你需要了解的：
- en: '**Process ID** (**PID**): A system-wide unique numerical identifier.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程 ID** (**PID**)：一个系统范围内唯一的数字标识符。'
- en: '**Parent process ID** (**PPID**): Every single process in the Linux system,
    except process number 1, has a parent. Process number 1 is an *init* process.
    It is the program responsible for starting all the system services. A program
    that starts another program is known as a **parent**. A program started by another
    program is known as a **child**. When you log in to the system, your shell is
    a process too, and it has its PID. When you start a program in that shell, your
    command-line PID will become the parent ID of that program. If a process loses
    its parent (i.e., the parent process terminates without terminating its child),
    then the child process is assigned a new parent: process number 1.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父进程 ID**（**PPID**）：Linux 系统中的每个进程（除进程号为 1 的进程外）都有一个父进程。进程号为 1 的进程是 *init*
    进程。它是负责启动所有系统服务的程序。启动另一个程序的程序被称为 **父进程**。由另一个程序启动的程序被称为 **子进程**。当你登录到系统时，你的 shell
    也是一个进程，并且它有自己的 PID。当你在该 shell 中启动一个程序时，你的命令行 PID 将成为该程序的父进程 ID。如果一个进程失去了它的父进程（即父进程在未终止其子进程的情况下终止），那么该子进程将被分配一个新的父进程：进程号
    1。'
- en: '`S` state, the process went to sleep. It will not, however, accept any interrupts
    and signals. It will only awake when a requested resource becomes available.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`S` 状态，进程进入休眠状态。然而，它不会接受任何中断和信号。只有当请求的资源可用时，它才会醒来。'
- en: '**T**: We can instruct a program to stop its execution and wait. This is called
    a **stopped state**. Such a process can be brought back to execution with the
    use of a special signal.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**T**：我们可以指示程序停止执行并等待。这被称为 **停止状态**。这样的进程可以通过使用特殊信号重新启动执行。'
- en: '**Z**: Zombie. When a process ends its execution, it informs its parent process
    about that. The same happens when the process is terminated. The parent is responsible
    for removing it from the process table. Until it happens, the process remains
    in a zombie state, also called **defunc**.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Z**：僵尸进程。当一个进程结束其执行时，它会通知其父进程。进程终止时也会发生同样的事情。父进程负责将其从进程表中移除。在此之前，进程会保持在僵尸状态，也叫做
    **defunc**。'
- en: '**User**: The owner of the process, or rather, a user with whose system rights
    the process is being executed. If that user cannot do something, the process cannot
    do it either.*   **CPU**: Percentage of the CPU time the process is using, presented
    as a floating-point number between 0.0 and 1.0.*   **MEM**: The memory usage,
    again between 0.0 and 1.0, where 1.0 is 100% of system memory.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：进程的所有者，或者更准确地说，是使用该用户权限执行进程的用户。如果该用户无法做某事，进程也无法做到。**CPU**：进程所使用的 CPU
    时间的百分比，以 0.0 到 1.0 之间的浮动数字表示。**MEM**：内存使用量，同样在 0.0 到 1.0 之间，其中 1.0 表示系统内存的 100%。'
- en: Each process has more characteristics than the ones we’ve just covered, but
    those are absolutely essential. Managing processes is a subject for a separate
    chapter, if not an entire book.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有比我们刚才提到的更多特征，但这些是绝对必要的。管理进程是一个独立章节的主题，如果不是整本书的内容。
- en: The tool to inspect the processes is called `ps`. It seems like a pretty simple
    command at first sight, but in reality, the `man` page shows an incredible amount
    of options. It is important to note that `ps` itself will only print a snapshot
    of the system. It won’t be monitoring and updating its output. You can combine
    `ps` with `watch` or `run top` or `htop` commands to have continuous information
    about the processes and system load.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 检查进程的工具叫做 `ps`。乍一看，它似乎是一个非常简单的命令，但实际上，`man` 页面展示了大量的选项。需要注意的是，`ps` 本身只会打印出系统的快照。它不会监控并更新其输出。你可以将
    `ps` 与 `watch` 或 `run top` 或 `htop` 命令结合使用，以持续获取关于进程和系统负载的信息。
- en: 'In its simplest form, `ps` will print all processes running with the same user
    ID as the user that calls it:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式下，`ps` 将打印出与调用它的用户 ID 相同的所有进程：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'On my Linux machine, there are only two processes running for my user: the
    Bash shell and the `ps` program itself.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 Linux 机器上，只有两个进程在为我的用户运行：Bash shell 和 `ps` 程序本身。
- en: 'The `ps` command has several interesting options that help interrogate the
    system about the running processes. Now, specifying options to `ps` is tricky,
    because it accepts two syntaxes, one with a dash and one without, and some options
    have different meanings depending on the dash. Let me quote the `man` page:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps` 命令有几个有趣的选项，可以帮助查询系统中的运行进程。现在，为 `ps` 指定选项是有点棘手的，因为它接受两种语法，一种带有连字符，另一种不带，有些选项根据连字符的不同有不同的含义。让我引用一下
    `man` 页面：'
- en: '[PRE31]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'I have cut some output for brevity. This distinction may become important once
    you start working with shell scripts, as they may adopt any of the three syntaxes.
    Whenever in doubt, use the dash notation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我已经省略了一些输出内容。一旦你开始使用 shell 脚本，这个区别可能变得很重要，因为它们可能会采用三种语法中的任何一种。每当你有疑问时，请使用破折号表示法：
- en: '`-f`: So-called `PID`, `PPID`, `C`), `STIME`), `TTY`) to which it is attached,
    `TIME`), and the command that started the process:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：所谓的 `PID`、`PPID`、`C`、`STIME`、`TTY`、`TIME` 以及启动进程的命令：'
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`-e`: All processes of all users:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`：所有用户的所有进程：'
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`-ef`: To see all processes in the long output format:'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ef`：以长格式查看所有进程：'
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`-ejH`: A nice process tree. The more indented CMDs (the last column of the
    output) are children of the less indented ones:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ejH`：一个漂亮的进程树。输出中缩进更多的 CMD（最后一列）是较少缩进的 CMD 的子进程：'
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are many more options available, especially to control which fields are
    of interest. We will come back to them in later chapters.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 还有很多其他选项可用，特别是用于控制哪些字段是感兴趣的。我们将在后续章节中继续讨论这些。
- en: There is a command that has a name that can be very misleading, the `kill` command.
    It is used to send so-called signals to the running processes. Signals are a way
    of telling processes to perform a kind of action. One of them actually kills the
    program, terminating it at once, but that’s just one of many.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名字可能会让人误解的命令，叫做 `kill` 命令。它用于向正在运行的进程发送所谓的信号。信号是一种通知进程执行某种操作的方式。其中一个信号确实会终止程序，立即将其结束，但这只是其中的一种。
- en: 'To list existing signals, use the `kill -``l` command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出现有信号，请使用 `kill -l` 命令：
- en: '[PRE36]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Okay, this list is cute, but it tells us nothing. How can we tell what each
    of those signals does? Here’s a bit of detective work. First, since we see those
    in the `kill -l` output, let’s invoke the `man kill` command and see whether there’s
    anything that can explain them to us:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这个列表很可爱，但它什么都没告诉我们。我们怎么知道这些信号分别有什么作用呢？下面来做点侦探工作。首先，由于我们在 `kill -l` 的输出中看到了这些内容，我们可以运行
    `man kill` 命令，看看是否有什么能解释这些信号：
- en: '[PRE37]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'There is an examples section that shows and describes one signal, but in the
    `SEE ALSO` section, we can see a reference to a `man` page signal in section `7`.
    Let us check it out:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 例子部分显示并描述了一个信号，但在 `SEE ALSO` 部分，我们看到有一个指向 `man` 页面中第 7 节的信号的引用。我们来检查一下：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, there’s a nice page with a table listing all signals available to you in
    Linux.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个漂亮的页面，其中有一个表格列出了你在 Linux 中可以使用的所有信号。
- en: 'So, how do you use this `kill` command? Do you have to learn about all these
    signals? The answer is no. There are a handful of signals that you’ll be using.
    And if you forget any, don’t hesitate to `man` them or search the web:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何使用这个 `kill` 命令呢？你需要学习所有这些信号吗？答案是否定的。你会使用一些常见的信号。如果你忘记了某个信号，别犹豫，直接查阅 `man`
    或在网上搜索：
- en: '`kill -9 PID`: The infamous `SIGKILL`. This terminates the process whose PID
    we have specified abruptly, forcing it to omit any cleanup it may do normally.
    If it has opened file handles, it won’t free them; if it has to write any information
    to a file or synchronize with another program, it won’t do it. This should be
    used sparingly, only when we are sure that we really have to stop a program from
    running.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill -9 PID`：臭名昭著的 `SIGKILL`。这会强制终止我们指定 PID 的进程，且会突然中断，忽略任何它可能进行的清理工作。如果该进程已打开文件句柄，它不会释放；如果需要写入文件或与其他程序同步，它也不会执行。这个命令应该谨慎使用，仅在我们确定必须停止程序时才使用。'
- en: '`kill PID`: If no signal is specified, then by default, `SIGTERM` is sent.
    This tells the program to stop running but gracefully—perform all the exit routines
    and cleanup it needs. If you have to use the `kill` command, this is the preferred
    use.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill PID`：如果没有指定信号，默认会发送 `SIGTERM`。这会告诉程序停止运行，但要优雅地停止——执行所有必要的退出例程并清理资源。如果你不得不使用
    `kill` 命令，这是首选的使用方式。'
- en: '`kill -1`: The so-called `SIGHUP` signal. It was originally used for detecting
    loss of user connection—hangup of the phone line. Currently, it is often used
    to tell the process to reread its configuration.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill -1`：所谓的 `SIGHUP` 信号。它最初用于检测用户连接丢失——电话线路挂断。现在，它常常用于通知进程重新读取其配置。'
- en: 'Here is an example of calling `kill` to terminate a process. I have started
    a shell script that does nothing except wait for a keyboard input. I called it
    `sleep.sh`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个调用 `kill` 来终止进程的例子。我启动了一个 shell 脚本，做的事情只是等待键盘输入。我将它命名为 `sleep.sh`：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'First, I used `ps aux` and searched in the output for the `sleep.sh` process,
    just to show you that it’s there. Next, I used `pgrep` to find the PID of my running
    script quickly. I have supplied this PID to the `kill -9` command. In effect,
    `sleep.sh` has been killed. This can be confirmed on another Terminal, where I
    was running `sleep.sh`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我使用`ps aux`命令并在输出中查找`sleep.sh`进程，目的是向你展示它确实存在。接着，我使用`pgrep`命令快速找到正在运行的脚本的PID，并将该PID传递给`kill
    -9`命令。实际上，`sleep.sh`进程已经被终止。你可以在另一个终端中确认这一点，那时我正运行着`sleep.sh`：
- en: '[PRE40]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Had I simply used `kill`, the output would be different:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我只是简单地使用`kill`命令，输出会有所不同：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There is another way of delivering two of all signals to running programs,
    but only if currently executing in the shell we’re logged into in the foreground;
    this means it has the control of the screen and keyboard:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方式可以将所有信号传递给正在运行的程序，但前提是当前程序正在我们登录的shell中运行，并且处于前台状态；这意味着它控制了屏幕和键盘：
- en: Pressing the *Ctrl* + *C* keys will send `SIGINT` to the program. `SIGINT` tells
    the program that the user has pressed the key combination and it should stop.
    It’s still up to the program how the termination should occur.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *C*键会向程序发送`SIGINT`信号。`SIGINT`告诉程序用户已经按下了该组合键，程序应该停止。程序如何终止还取决于它自身的实现。
- en: Pressing the *Ctrl* + *D* keys will send `SIGQUIT`—it is like `SIGINT` but also
    produces a so-called core dump, or a file that can be used in a debugging process.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *D*键会发送`SIGQUIT`信号——它类似于`SIGINT`，但还会生成所谓的核心转储（core dump），也就是一个可以在调试过程中使用的文件。
- en: The common way of denoting those combinations in text is `^c` and `^d` (`^`
    for the *Ctrl* key), `ctrl+c` and `ctrl+d` (`ctrl` being a shortcut for the *Ctrl*
    key), and `C-c` and `C-d` (`C` denoting the *Ctrl* key, again).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本中表示这些组合键的常见方式是`^c`和`^d`（`^`代表*Ctrl*键），`ctrl+c`和`ctrl+d`（`ctrl`是*Ctrl*键的快捷方式），以及`C-c`和`C-d`（`C`代表*Ctrl*键）。
- en: Looking for something?
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在找东西吗？
- en: There are times when you need to look for a directory or a file on the filesystem.
    Linux has a set of commands that let you perform this operation. Of them all,
    `find` is the most powerful. To cover all of its abilities would take a lot more
    space than we have. You can look for a file or directory `of both` that have exactly
    the name you specified, that have part of the name that you specified, that have
    been modified at a defined point in time, that are owned by a user or a group,
    and many more scenarios. Additionally, on each file that has been found, an action
    can be performed, such as rename, compress, or search for a word.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要在文件系统中查找一个目录或文件。Linux提供了一些命令，可以让你执行这一操作。在这些命令中，`find`是最强大的。要详细介绍它的所有功能需要更多的篇幅，而我们目前没有足够的空间。你可以查找与指定名称完全匹配的文件或目录，查找名称中包含你指定的部分字符的文件或目录，查找在特定时间修改过的文件，查找属于某个用户或组的文件，以及更多其他情况。此外，对于每一个找到的文件，还可以执行一些操作，比如重命名、压缩或搜索某个单词。
- en: 'In the following example, we’re looking for a file, `signals.h`, in the `/``usr`
    directory:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们正在查找一个文件`signals.h`，它位于`/``usr`目录下：
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we call `find` itself, then we tell it to start looking at the beginning
    of the filesystem (`/`), and then we tell it to look for a file named `os-release`
    (`-``name os-release`).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`find`命令，然后告诉它从文件系统的根目录(`/`)开始查找，接着告诉它查找一个名为`os-release`的文件（`-``name
    os-release`）。
- en: You will notice that in the output, which I have cut for brevity, there are
    errors about files to which `find` had no proper rights.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，在输出中（为了简洁起见我省略了一部分），有一些错误信息，表示`find`没有权限访问某些文件。
- en: If you are unsure about the case of the name, that is, whether it contains lowercase
    or uppercase letters (remember that Linux is case -sensitive and *OS-Release*
    is not the same file as *os-release*), you can use the `-iname` option instead.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定名称的大小写，即它是否包含小写字母或大写字母（记住，Linux是区分大小写的，*OS-Release*和*os-release*不是同一个文件），你可以使用`-iname`选项。
- en: 'If you are sure that what you are looking for is a file, then you can use the
    `-type` `f` option:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定你要找的是一个文件，那么可以使用`-type` `f`选项：
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: For a directory option, use `-``type d`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于目录选项，使用`-``type d`。
- en: 'To look for files that match a pattern, say filenames that end with `.sh`,
    you’d use a pattern:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要查找与某个模式匹配的文件，比如以`.sh`结尾的文件，可以使用以下模式：
- en: '[PRE44]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The asterisk means any number of any characters. We enclosed it in the quotes
    to avoid problems with the shell interpreting the asterisk before `find` got a
    chance. We will explain all the special signs (called **globs**) and regular expressions
    in the next chapter, *Intermediate Linux*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 星号表示任意数量的任意字符。我们将它放在引号中，以避免在 `find` 有机会执行之前，shell 先解释星号。我们将在下一章 *中级Linux* 中解释所有特殊符号（称为
    **globs**）和正则表达式。
- en: 'To delete all found files, you can use the `-``delete` option:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除所有找到的文件，你可以使用 `-delete` 选项：
- en: '[PRE45]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To perform an action on the found file, you can use the `-``exec` option:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要对找到的文件执行操作，你可以使用 `-exec` 选项：
- en: '[PRE46]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the preceding example, we have used the command called `grep` to look for
    any line that contains the word `debian`, no matter whether uppercase or lowercase.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了名为 `grep` 的命令来查找包含 `debian` 这个单词的所有行，无论是大写还是小写。
- en: This leads us to the `grep` command.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了 `grep` 命令。
- en: The `grep` command is used to look for an occurrence of a pattern inside a file.
    Upon finding this pattern-matching line, it prints it. The `grep` command is similar
    to the `find` command, except its purpose is to search inside the files, while
    `find` only cares for the characteristics of files and directories themselves.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep` 命令用于在文件中查找某个模式的出现。找到匹配的行后，它会打印该行。`grep` 命令与 `find` 命令类似，不同之处在于它的目的是在文件内部进行搜索，而
    `find` 只关心文件和目录本身的特性。'
- en: 'Assume a text file called `red_fox.txt` with the following content:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个名为 `red_fox.txt` 的文本文件，内容如下：
- en: '[PRE47]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As a side note, `cat` is a command that prints the contents of a specified file
    to the Terminal.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，`cat` 是一个将指定文件内容打印到终端的命令。
- en: 'Let’s say we want to find all lines that contain the word `the`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想查找所有包含单词 `the` 的行：
- en: '[PRE48]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You have probably guessed that the `-i` option means that we don’t care about
    the case.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，`-i` 选项表示我们不在乎大小写。
- en: 'But wait. We can search for alternatives. Let’s say we care for lines that
    contain either `fox` or `dog`. You would use the `-e` option for each word you
    search for or the `-E` option with all the words in single quotes and separated
    by the `|` character:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，我们可以搜索替代项。假设我们关心的行包含 `fox` 或 `dog`。你可以使用 `-e` 选项为每个要搜索的单词添加一次，或者使用 `-E` 选项将所有单词放在单引号内，并用
    `|` 字符分隔：
- en: '[PRE49]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'By adding the `-n` option, you’ll get information on which line the match was
    found in:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `-n` 选项，你将获得匹配项所在行的行号：
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can look for lines that start with a given word or have the specified pattern
    at the end of the line.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查找以指定单词开头的行或在行尾具有特定模式的行。
- en: 'You can even `grep` all files in a directory hierarchy. The syntax is a bit
    different then: the pattern comes first, and the directory comes at the end. Also,
    you get the name of the file where the match was found:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在一个目录层次结构中的所有文件中执行 `grep` 搜索。语法稍有不同：模式放在前面，目录放在后面。同时，你还会得到匹配所在的文件名：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The most power for both `find` and `grep` comes from a concept called **regular
    expressions** (**regex** or **regexp** for short), which have a book of their
    own and can be confusing for new users. We are going to explain them in *Chapters
    3* and *4*. We will, however, be only introducing the most everyday uses of them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`find` 和 `grep` 的最大威力来自于一个叫做 **正则表达式**（**regex** 或 **regexp** 的简称）的概念，它们有一本专门的书，且对于新用户可能会感到困惑。我们将在
    *第3章* 和 *第4章* 中详细解释它们。不过，我们会仅介绍最常用的用法。'
- en: 'If you are looking for a program and want to know its full path, there is a
    command for that, and it is called `whereis`. Here is an example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一个程序并且想知道它的完整路径，有一个命令可以做到，那就是 `whereis`。这里有一个示例：
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `whereis` command will not only print the whole path to the binary but also
    a corresponding `man` page, if it has one installed.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`whereis` 命令不仅会打印二进制文件的完整路径，如果安装了相应的 `man` 手册页，它还会打印该手册页。'
- en: Let’s be manipulative
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们进行一些操作
- en: 'There are four basic operations that can be performed on files and directories:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 对文件和目录可以执行四种基本操作：
- en: Create
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建
- en: Rename or move
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名或移动
- en: Remove
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除
- en: Copy
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制
- en: 'Each of these operations has a special tool:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个操作都有一个特殊的工具：
- en: '`mkdir`: This command has very simple and limited syntax. Basically, you are
    telling it to create a directory with a given name. If you are creating nested
    directories, that is, one folder contains another, all the directories in the
    path must exist. If they don’t, you can create them using the special `-``p` option:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkdir`：这个命令的语法非常简单且有限。基本上，你只是告诉它创建一个指定名称的目录。如果你要创建嵌套目录，也就是一个文件夹包含另一个文件夹，路径中的所有目录必须存在。如果它们不存在，你可以使用特殊的`-p`选项来创建它们：'
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding example, you can see that I create a directory test directly
    in my home folder. Next, I try to create a folder, `new`, inside the `something`
    folder. However, the latter doesn’t exist and `mkdir` tells me so and refuses
    to create the new directory. I use the special `-p` option to create a whole path
    to the new directory.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你可以看到我直接在我的主文件夹中创建了一个名为test的目录。接下来，我尝试在`something`文件夹中创建一个`new`文件夹。然而，后者并不存在，`mkdir`告诉我这一点并拒绝创建新的目录。我使用了特殊的`-p`选项来创建一个完整的路径以便创建新的目录。
- en: '`mv`: This is a command that is used to move and rename files and directories.
    Again, the syntax is pretty simple, although this command offers a little more
    functionality, such as creating a backup of moved files.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mv`：这是一个用于移动和重命名文件及目录的命令。同样，语法相当简单，尽管这个命令提供了一些额外的功能，比如创建移动文件的备份。'
- en: 'To rename a file or directory, we move it from the current name to the new
    one:'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要重命名一个文件或目录，我们将其从当前名称移动到新名称：
- en: '[PRE54]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Check out its `man` page or `help` message to find out more.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 查看其`man`页面或`help`信息以了解更多。
- en: '`rm`: This command is more interesting, mainly because it offers safety features.
    With the special `-i` option, you can tell it to always ask you before removing
    the file or directory. Normally, `rm` bails at directories, as in the following
    example:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`：这个命令比较有趣，主要因为它提供了安全功能。通过特殊的`-i`选项，你可以指示它在删除文件或目录之前始终询问你。通常，`rm`会对目录进行退出，如下例所示：'
- en: '[PRE55]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: I created a file test inside the `no-test` directory. `rm` refuses to remove
    the folder. I used the `-d` option, which instructs the command to remove empty
    directories. However, it still contains a file. Next, I removed the file and then
    `rm -d` cleanly deleted the `no-test` folder. I could have used the `-r` option,
    which makes the command remove all directories, even if they are not empty.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`no-test`目录中创建了一个名为test的文件。`rm`拒绝删除该文件夹。我使用了`-d`选项，指示命令删除空目录。然而，该目录仍然包含一个文件。接着，我删除了文件，然后使用`rm
    -d`成功删除了`no-test`文件夹。我本可以使用`-r`选项，这将使命令删除所有目录，即使它们不是空的。
- en: '`cp`: This command is used for copying files and directories. Note that, as
    with `rm`, `cp` will refuse to copy directories unless instructed with the `-r`
    option. `cp` arguably is the most complex and feature-rich command of all, including
    the ability to back up files, create links (shortcuts) instead of real copies,
    and more. Check out its `man` page. In the following example, I copy a `something`
    directory to a `new` directory. Obviously, I have to use the `-r` option. Next,
    I create an empty file called `file` and copy it to `newfile`. For those, I don’t
    require any options:'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp`：这个命令用于复制文件和目录。请注意，与`rm`类似，`cp`会拒绝复制目录，除非使用`-r`选项。`cp`可以说是所有命令中最复杂且功能最丰富的命令之一，包括备份文件、创建链接（快捷方式）代替真正的复制等功能。查看它的`man`页面。在以下示例中，我将`something`目录复制到`new`目录。显然，我必须使用`-r`选项。接着，我创建了一个名为`file`的空文件并将其复制到`newfile`。对于这些，我不需要任何选项：'
- en: '[PRE56]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You should now understand and be able to use basic command-line commands in
    Linux or a similar system, such as create, copy, and delete files; you can also
    find content inside text files or find files or directories by name. You also
    have an understanding of processes in the system you work on. In the next chapter,
    we will deepen this knowledge.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该理解并能够使用Linux或类似系统中的基本命令行命令，比如创建、复制和删除文件；你还可以查找文本文件中的内容，或者按名称查找文件或目录。你对你工作系统中的进程也有所了解。在下一章中，我们将深化这些知识。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have presented but a fraction of the hundreds of commands that Linux admins
    may use in their work. As mentioned at the beginning of this chapter, the complete
    reference is beyond the scope of this book. What we have learned, however, is
    enough to do basic system use and it builds the base for our next chapter: the
    more advanced Linux administration topics.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示的只是Linux管理员在工作中可能使用的几百个命令中的一小部分。正如本章开头所提到的，完整的参考超出了本书的范围。然而，我们学到的内容足以进行基本的系统操作，并为下一章的内容打下基础：更高级的Linux管理话题。
- en: Exercises
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Find out how to apply `chown` recursively—it means that our `chown` call should
    step inside a directory and apply the change to all the items within.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何递归地应用`chown`——这意味着我们的`chown`调用应该进入目录并将更改应用于其中的所有项目。
- en: Find out what the `watch` command does. Use it with a `ps` command.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解`watch`命令的功能。将其与`ps`命令一起使用。
- en: Find out how to remove a directory.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何删除一个目录。
- en: For all the commands you have learned here, read their `–help` output. Open
    a `man` page and look through it, especially the examples section.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于你在这里学到的所有命令，阅读它们的`–help`输出。打开`man`页面并浏览其中的内容，特别是示例部分。
- en: Resources
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: 'You can read more about SELinux here: [https://www.packtpub.com/product/selinux-system-administration-second-edition/9781787126954](https://www.packtpub.com/product/selinux-system-administration-second-edition/9781787126954)'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在这里阅读更多关于SELinux的内容：[https://www.packtpub.com/product/selinux-system-administration-second-edition/9781787126954](https://www.packtpub.com/product/selinux-system-administration-second-edition/9781787126954)
- en: 'This is a very good publication on Linux systems administration: [https://www.packtpub.com/product/mastering-linux-administration/9781789954272](https://www.packtpub.com/product/mastering-linux-administration/9781789954272)'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一本关于Linux系统管理的非常好的出版物：[https://www.packtpub.com/product/mastering-linux-administration/9781789954272](https://www.packtpub.com/product/mastering-linux-administration/9781789954272)
