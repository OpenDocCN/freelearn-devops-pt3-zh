- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: The Modern Way of DevOps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代DevOps方式
- en: This first chapter will provide some background knowledge of DevOps practices,
    processes, and tools. We will understand modern DevOps and how it differs from
    traditional DevOps. We will also introduce containers and understand in detail
    how containers within the cloud change the entire IT landscape so that we can
    build on this book’s base. While this book does not entirely focus on containers
    and their orchestration, modern DevOps practices heavily emphasize it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将提供一些DevOps实践、流程和工具的背景知识。我们将了解现代DevOps以及它与传统DevOps的区别。我们还将介绍容器，并详细理解容器如何在云环境中改变整个IT格局，以便在本书的基础上继续深入学习。尽管本书并不完全聚焦于容器及其编排，但现代DevOps实践强调这一点。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: What is DevOps?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是DevOps？
- en: Introduction to cloud computing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云计算简介
- en: Understanding modern cloud-native applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解现代云原生应用
- en: Modern DevOps versus traditional DevOps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代DevOps与传统DevOps
- en: The need for containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的需求
- en: Container architecture
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器架构
- en: Containers and modern DevOps practices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器与现代DevOps实践
- en: Migrating to containers from virtual machines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从虚拟机迁移到容器
- en: 'By the end of this chapter, you should understand the following key aspects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该理解以下几个关键方面：
- en: What DevOps is and what role it plays in the modern IT landscape
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是DevOps，它在现代IT环境中扮演的角色
- en: What cloud computing is and how it has changed IT services
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是云计算，它如何改变IT服务
- en: What a modern cloud-native application looks like and how it has changed DevOps
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代云原生应用的样貌以及它如何改变DevOps
- en: Why we need containers and what problems they solve
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要容器，以及容器解决了什么问题
- en: The container architecture and how it works
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器架构及其工作原理
- en: How containers contribute to modern DevOps practices
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器如何促成现代DevOps实践
- en: The high-level steps of moving from a virtual machine-based architecture to
    containers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从基于虚拟机的架构迁移到容器的高级步骤
- en: What is DevOps?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是DevOps？
- en: As you know, software development and operations were traditionally handled
    by separate teams with distinct roles and responsibilities. Developers focused
    on writing code and creating new features, while operations teams focused on deploying
    and managing the software in production environments. This separation often led
    to communication gaps, slow release cycles, and inefficient processes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，软件开发和运维传统上由不同的团队承担，各自有不同的角色和责任。开发者专注于编写代码和创建新功能，而运维团队则专注于在生产环境中部署和管理软件。这种分离常常导致沟通鸿沟、发布周期缓慢以及低效的工作流程。
- en: '**DevOps** bridges the gap between development and operations by promoting
    a culture of collaboration, shared responsibilities, and continuous feedback using
    automation throughout the software development life cycle.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps**通过推动协作文化、共享责任以及在整个软件开发生命周期中使用自动化来弥合开发和运维之间的差距，确保持续反馈。'
- en: It is a set of principles and practices, as well as a philosophy, that encourage
    the participation of the development and operations teams in the entire software
    development life cycle, including software maintenance and operations. To implement
    this, organizations manage several processes and tools that help automate the
    software delivery process to improve speed and agility, reduce the cycle time
    of code release through **continuous integration and continuous delivery** (**CI/CD**)
    pipelines, and monitor the applications running in production.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一套原则和实践，也是一种哲学，鼓励开发和运维团队参与整个软件开发生命周期，包括软件维护和运维。为了实现这一点，组织管理多个流程和工具，帮助自动化软件交付过程，从而提高速度和灵活性，通过**持续集成和持续交付**（**CI/CD**）管道减少代码发布的周期时间，并监控运行在生产环境中的应用程序。
- en: A DevOps team should ensure that instead of having a clear set of siloed groups
    that do development, operations, and QA, they have a single team that takes care
    of the entire SDLC life cycle – that is, the team will build, deploy, and monitor
    the software. The combined team owns the whole application instead of certain
    functions. That does not mean that people don’t have specialties, but the idea
    is to ensure that developers know something about operations and that operations
    engineers know something about development. The QA team works hand in hand with
    developers and operations engineers to understand the business requirements and
    various issues faced in the field. Based on these learnings, they need to ensure
    that the product they are developing meets business requirements and addresses
    problems encountered in the field.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 团队应该确保，不是将开发、运维和质量保证分成不同的职能小组，而是组建一个能够涵盖整个软件开发生命周期（SDLC）的单一团队——即，该团队负责构建、部署和监控软件。合并后的团队拥有整个应用程序的所有权，而不是某些职能的所有权。这并不意味着团队成员没有专业技能，而是要确保开发人员了解运维工作，运维工程师也要了解开发工作。QA
    团队与开发人员和运维工程师密切合作，了解业务需求以及在实际操作中遇到的各种问题。基于这些经验，他们需要确保自己开发的产品能够满足业务需求，并解决实际操作中遇到的问题。
- en: 'In a traditional development team, the source of the backlog is the business
    and its architects. However, for a DevOps team, there are two sources of their
    daily backlog – the business and its architects and the customers and issues that
    they face while they’re operating their application in production. Therefore,
    instead of following a linear path of software delivery, DevOps practices generally
    follow an infinity loop, as shown in the following figure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的开发团队中，积压工作的来源是业务及其架构师。然而，对于 DevOps 团队来说，他们的日常积压工作有两个来源——业务及其架构师，以及客户和他们在生产环境中运行应用时遇到的问题。因此，DevOps
    实践通常遵循一个无限循环，而不是线性的交付路径，如下图所示：
- en: '![Figure 1.1 – DevOps infinity loop](img/B19877_Figure_1.01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – DevOps 无限循环](img/B19877_Figure_1.01.jpg)'
- en: Figure 1.1 – DevOps infinity loop
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – DevOps 无限循环
- en: To ensure smooth interoperability between people of different skill sets, DevOps
    focuses heavily on automation and tools. DevOps aims to ensure that we try to
    automate repeatable tasks as much as possible and focus on more important things.
    This ensures product quality and speedy delivery. DevOps focuses on *people*,
    *processes*, and *tools*, giving the most importance to people and the least to
    tools. We generally use tools to automate processes that help people achieve the
    right goals.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保具有不同技能的人员之间能够顺利协作，DevOps 强调自动化和工具的使用。DevOps 的目标是尽可能地自动化重复性的任务，集中精力处理更重要的事务。这确保了产品的质量和快速交付。DevOps
    注重 *人员*、*流程* 和 *工具*，其中最重要的是人员，最不重要的是工具。我们通常使用工具来自动化流程，帮助人员实现正确的目标。
- en: 'Some of the fundamental ideas and jargon that a DevOps engineer generally encounters
    are as follows. We are going to focus heavily on each throughout this book:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 工程师通常会遇到一些基本的概念和术语，下面列出了一些。我们将在本书中重点讨论这些内容：
- en: '**Continuous** **integration** (**CI**)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续** **集成**（**CI**）'
- en: CI is a software development practice that involves frequently merging code
    changes from multiple developers into a shared repository, typically several times
    a day. This ensures that your developers regularly merge code into a central repository
    where automated builds and tests run to provide real-time feedback to the team.
    This reduces cycle time significantly and improves the quality of code. This process
    aims to minimize bugs within the code early within the cycle rather than later
    during the test phases. It detects integration issues early and ensures that the
    software always remains in a releasable state.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: CI 是一种软件开发实践，涉及频繁地将多个开发人员的代码更改合并到共享的代码库中，通常是每天几次。这确保开发人员定期将代码合并到一个中央代码库中，并在此库中运行自动化构建和测试，实时向团队反馈。这大大减少了周期时间，并提高了代码质量。该过程旨在尽早发现代码中的错误，而不是等到测试阶段。它能尽早发现集成问题，并确保软件始终保持可发布状态。
- en: '**Continuous** **delivery** (**CD**)'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续** **交付**（**CD**）'
- en: CD is all about shipping your tested software into your production environment
    whenever it is ready. So, a CD pipeline will build your changes into packages
    and run integration and system tests on them. Once you have thoroughly tested
    your code, you can automatically (or on approval) deploy changes to your test
    and production environments. So, CD aims to have the latest set of tested artifacts
    ready to deploy.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CD 主要是将您经过测试的软件在准备好时部署到生产环境中。因此，CD 管道将把您的更改打包并进行集成和系统测试。一旦您彻底测试了代码，就可以自动（或经批准后）将更改部署到测试和生产环境中。所以，CD
    的目标是准备好最新的经过测试的工件，以便进行部署。
- en: '**Infrastructure as** **Code** (**IaC**)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施即** **代码** (**IaC**)'
- en: IaC is a practice in software development that involves managing and provisioning
    infrastructure resources, such as servers, networks, and storage, using code and
    configuration files rather than manual processes. IaC treats infrastructure as
    software, enabling teams to define and manage infrastructure resources in a programmable
    and version-controlled manner. With the advent of virtual machines, containers,
    and the cloud, technology infrastructure has become virtual to a large extent.
    This means we can build infrastructure through API calls and templates. With modern
    tools, we can also build infrastructure in the cloud declaratively. This means
    that you can now build IaC, store the code needed to build the infrastructure
    within a source code repository such as Git, and use a CI/CD pipeline to spin
    and manage the infrastructure.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: IaC 是软件开发中的一种实践，涉及使用代码和配置文件而非手动过程来管理和配置基础设施资源，如服务器、网络和存储。IaC 将基础设施视为软件，使团队能够以可编程和版本控制的方式定义和管理基础设施资源。随着虚拟机、容器和云技术的出现，技术基础设施在很大程度上已变得虚拟化。这意味着我们可以通过
    API 调用和模板来构建基础设施。借助现代工具，我们还可以以声明式方式在云中构建基础设施。这意味着您现在可以构建 IaC，将构建基础设施所需的代码存储在源代码库中，如
    Git，并使用 CI/CD 管道来创建和管理基础设施。
- en: '**Configuration as** **code** (**CaC**)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置即** **代码** (**CaC**)'
- en: CaC is a practice in software development and system administration that involves
    managing and provisioning configuration settings using code and version control
    systems. It treats configuration settings as code artifacts, enabling teams to
    define, store, and manage configuration in a programmatic and reproducible manner.
    Historically, servers used to be built manually from scratch and seldom changed.
    However, with elastic infrastructure in place and an emphasis on automation, the
    configuration can also be managed using code. CaC goes hand in hand with IaC for
    building scalable, fault-tolerant infrastructure so that your application can
    run seamlessly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: CaC 是软件开发和系统管理中的一种实践，涉及使用代码和版本控制系统管理和配置设置。它将配置设置视为代码制品，使团队能够以程序化和可重现的方式定义、存储和管理配置。历史上，服务器通常是从头开始手动构建的，并且很少发生变化。然而，随着弹性基础设施的出现和对自动化的重视，配置也可以通过代码进行管理。CaC
    与 IaC 密切配合，共同构建可扩展的、容错的基础设施，从而使您的应用程序能够无缝运行。
- en: '**Monitoring** **and logging**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控** **和日志记录**'
- en: Monitoring and logging are essential practices in software development and operations
    that involve capturing and analyzing data about the behavior and performance of
    software applications and systems. They provide insights into the software’s health,
    availability, and performance, enabling teams to identify issues, troubleshoot
    problems, and make informed decisions for improvement. Monitoring and logging
    come under observability, which is a crucial area for any DevOps team – that is,
    knowing when your application has issues and exceptions using monitoring and triaging
    them using logging. These practices and tools form your eye, and it is a critical
    area in the DevOps stack. In addition, they contribute a lot to building the backlog
    of a DevOps team.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 监控和日志记录是软件开发和运维中的基本实践，涉及捕获和分析关于软件应用和系统行为及性能的数据。它们为软件的健康、可用性和性能提供洞察，使团队能够识别问题、排查故障并做出有依据的改进决策。监控和日志记录属于可观察性范畴，这是任何
    DevOps 团队都必须关注的领域——即通过监控知道您的应用程序出现问题和异常，并通过日志记录进行问题追踪。这些实践和工具就像您的眼睛，是 DevOps 堆栈中的关键领域。此外，它们对构建
    DevOps 团队的待办事项列表也有重要贡献。
- en: '**Communication** **and collaboration**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沟通** **与协作**'
- en: Communication and collaboration are crucial aspects of DevOps practices. They
    promote effective teamwork, knowledge sharing, and streamlined workflows across
    development, operations, and other stakeholders involved in the software delivery
    life cycle. Communication and collaboration make a DevOps team function well.
    Gone are the days when communication used to be through emails. Instead, modern
    DevOps teams manage their backlog using ticketing and Agile tools, keep track
    of their knowledge articles and other documents using a wiki, and communicate
    instantly using chat and **instant messaging** (**IM**) tools.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 沟通与协作是 DevOps 实践中的关键要素。它们促进了开发、运营和其他参与软件交付生命周期的利益相关者之间的高效团队合作、知识共享和简化的工作流程。沟通与协作使得
    DevOps 团队能够高效运作。过去，通过电子邮件的沟通方式已经不再适用。现代 DevOps 团队使用票务和敏捷工具来管理待办事项，利用 Wiki 跟踪知识文章和其他文档，并通过聊天和**即时消息**（**IM**）工具进行即时沟通。
- en: While these are just a few core aspects of DevOps practices and tools, there
    have been recent changes with the advent of containers and the cloud – that is,
    the modern cloud-native application stack. Now that we’ve covered a few buzzwords
    in this section, let’s understand what we mean by the cloud and cloud computing.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些只是 DevOps 实践和工具的一些核心方面，但随着容器和云的出现，已经发生了一些变化——即现代云原生应用栈。现在我们已经介绍了几个流行词汇，接下来让我们理解什么是云计算和云计算服务。
- en: Introduction to cloud computing
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云计算简介
- en: Traditionally, software applications used to run on servers that ran on in-house
    computers (servers), known as **data centers**. This meant that an organization
    would have to buy and manage physical computer and networking infrastructure,
    which used to be a considerable capital expenditure, plus they had to spend quite
    a lot on operating expenses. In addition, servers used to fail and required maintenance.
    This meant smaller companies who wanted to try things would generally not start
    because of the huge **capital expenditure** (**CapEx**) involved. This suggested
    that projects had to be well planned, budgeted, and architected well, and then
    infrastructure was ordered and provisioned accordingly. This also meant that quickly
    scaling infrastructure with time would not be possible. For example, suppose you
    started small and did not anticipate much traffic on the site you were building.
    Therefore, you ordered and provisioned fewer resources, and the site suddenly
    became popular. In that case, your servers won’t be able to handle that amount
    of traffic and will probably crash. Scaling that quickly would involve buying
    new hardware and then adding it to the data center, which would take time, and
    your business may lose that window of opportunity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，软件应用程序通常运行在内部计算机（服务器）上，这些服务器被称为**数据中心**。这意味着组织必须购买和管理物理计算机和网络基础设施，这通常需要大量的资本支出，同时还需要支付相当高的运营费用。此外，服务器会出现故障并需要维护。这意味着那些希望尝试新事物的小型公司通常不会开始，因为所需的**资本支出**（**CapEx**）非常庞大。这表明，项目必须经过良好的规划、预算和架构设计，然后再根据需求购买和配置基础设施。这也意味着，随着时间推移，快速扩展基础设施变得不可行。例如，假设你开始时规模较小，并未预料到网站的流量很大，因此你订购和配置了较少的资源，但网站突然变得很受欢迎。在这种情况下，你的服务器将无法处理如此大量的流量，可能会崩溃。快速扩展将涉及购买新的硬件并将其添加到数据中心，这需要时间，而你的业务可能会失去这一机会。
- en: To solve this problem, internet giants such as Amazon, Microsoft, and Google
    started building public infrastructure to run their internet systems, eventually
    leading them to launch it for public use. This led to a new phenomenon known as
    **cloud computing**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，像亚马逊、微软和谷歌等互联网巨头开始建设公共基础设施来运行他们的互联网系统，最终将其推出供公众使用。这促成了一个新的现象，即**云计算**。
- en: Cloud computing refers to delivering on-demand computing resources, such as
    servers, storage, databases, networking, software, and analytics, over the internet.
    Rather than hosting these resources locally on physical infrastructure, cloud
    computing allows organizations to access and utilize computing services provided
    by **cloud service providers** (**CSPs**). Some of the leading public CSPs are
    **Amazon Web Services** (**AWS**), **Microsoft Azure**, and **Google** **Cloud
    Platform**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算是指通过互联网按需提供计算资源，如服务器、存储、数据库、网络、软件和分析服务。与将这些资源托管在本地物理基础设施上不同，云计算使组织能够访问和利用**云服务提供商**（**CSPs**）提供的计算服务。一些领先的公共
    CSPs 包括**亚马逊云服务**（**AWS**）、**微软 Azure**和**谷歌云平台**。
- en: In cloud computing, the CSP owns, maintains, and manages the underlying infrastructure
    and resources, while the users or organizations leverage these resources for their
    applications and services.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算中，云服务提供商（CSP）拥有、维护并管理底层的基础设施和资源，而用户或组织则利用这些资源来支持他们的应用程序和服务。
- en: Simply put, cloud computing is nothing but using someone else’s data center
    to run your application, which should be on demand. It should have a control panel
    through a web portal, APIs, and so on over the internet to allow you to do so.
    In exchange for these services, you need to pay rent for the resources you provision
    (or use) on a pay-as-you-go basis.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，云计算不过是使用他人的数据中心来运行您的应用程序，且应按需提供。它应该通过网络门户、API等方式提供控制面板，以便让您进行操作。作为交换，您需要按**按需付费**的方式支付租赁费用，来使用您所配置（或使用）的资源。
- en: 'Therefore, cloud computing offers several benefits and opens new doors for
    businesses like never before. Some of these benefits are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，云计算提供了多种好处，并为企业打开了前所未有的新机遇。以下是其中的一些好处：
- en: '**Scalability**: Resources on the cloud are scalable. This means you can add
    new servers or resources to existing servers when needed. You can also automate
    scaling with traffic for your application. This means that if you need one server
    to run your application, and suddenly because of popularity or peak hours, you
    need five, your application can automatically scale to five servers using cloud
    computing APIs and inbuilt management resources. This gives businesses a lot of
    power as they can now start small, and they do not need to bother much about future
    popularity and scale.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：云上的资源是可扩展的。这意味着您可以根据需要向现有服务器添加新的服务器或资源。您还可以通过流量自动扩展应用程序。这意味着，如果您需要一台服务器来运行应用程序，而由于受欢迎程度或高峰时段的原因，您突然需要五台服务器，您的应用程序可以通过云计算API和内置的管理资源自动扩展到五台服务器。这为企业提供了强大的能力，因为他们可以从小规模开始，而不必过多担心未来的流量和扩展问题。'
- en: '**Cost savings**: Cloud computing follows a **pay-as-you-go** model, where
    users only pay for the resources and services they consume. This eliminates the
    need for upfront CapEx on hardware and infrastructure. It is always cheaper to
    rent for businesses rather than invest in computing hardware. Therefore, as you
    pay only for the resources you need at a certain period, there is no need to overprovision
    resources to cater to the future load. This results in substantial cost savings
    for most small and medium organizations.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本节省**：云计算遵循**按需付费**模式，用户只需为他们实际使用的资源和服务付费。这消除了对硬件和基础设施的前期资本支出（CapEx）的需求。对于企业来说，租用资源通常比投资计算硬件要便宜。因此，您只需为特定时间段内所需的资源付费，无需预先配置资源来应对未来的负载，这为大多数中小型组织节省了大量成本。'
- en: '**Flexibility**: Cloud resources are no longer only servers. You can get many
    other things, such as simple object storage solutions, network and block storage,
    managed databases, container services, and more. These provide you with a lot
    of flexibility regarding what you do with your application.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：云资源不再仅仅是服务器。您还可以获取许多其他服务，如简单的对象存储解决方案、网络和块存储、托管数据库、容器服务等。这些为您在应用程序的使用上提供了极大的灵活性。'
- en: '**Reliability**: Cloud computing resources are bound by **service-level agreements**
    (**SLAs**), sometimes in the order of 99.999% availability. This means that most
    of your cloud resources will never go down; if they do, you will not notice this
    because of built-in redundancy.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：云计算资源受**服务水平协议**（**SLA**）的约束，有时可达到99.999%的可用性。这意味着大多数云资源永远不会停机；如果停机，您也不会注意到，因为云平台有内置的冗余机制。'
- en: '**Security**: Since cloud computing companies run applications for various
    clients, they often have a stricter security net than you can build on-premises.
    They have a team of security experts manning the estate 24/7, and they have services
    that offer encryption, access control, and threat detection by default. As a result,
    when architected correctly, an application running on the cloud is much more secure.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：由于云计算公司为多个客户运行应用程序，它们通常拥有比您在本地构建的更严格的安全防护网。它们拥有一支安全专家团队，全天候监控云平台，并且默认提供加密、访问控制和威胁检测等服务。因此，在正确架构的情况下，运行在云上的应用程序更加安全。'
- en: 'There are a variety of cloud computing services on offer, including the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算提供了多种服务，包含以下几种：
- en: '**Infrastructure-as-a-Service** (**IaaS**) is similar to running your application
    on servers. It is a cloud computing service model that provides virtualized computing
    resources over the internet. With IaaS, organizations can access and manage fundamental
    IT infrastructure components, such as virtual machines, storage, and networking,
    without investing in and maintaining physical hardware. In the IaaS model, the
    CSP owns and manages the underlying physical infrastructure, including servers,
    storage devices, networking equipment, and data centers. Users or organizations,
    on the other hand, have control over the **operating systems** (**OSs**), applications,
    and configurations running on the virtualized infrastructure.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施即服务**（**IaaS**）类似于在服务器上运行应用程序。它是一种云计算服务模型，通过互联网提供虚拟化的计算资源。使用IaaS，组织可以访问和管理基本的IT基础设施组件，如虚拟机、存储和网络，而无需投资和维护物理硬件。在IaaS模式中，CSP拥有并管理底层的物理基础设施，包括服务器、存储设备、网络设备和数据中心。而用户或组织则可以控制虚拟化基础设施上运行的**操作系统**（**OSs**）、应用程序和配置。'
- en: '**Platform-as-a-Service** (**PaaS**) gives you an abstraction where you can
    focus on your code and leave your application management to the cloud service.
    It is a cloud computing service model that provides a platform and environment
    for developers to build, deploy, and manage applications without worrying about
    underlying infrastructure components. PaaS abstracts the complexities of infrastructure
    management, allowing developers to focus on application development and deployment.
    In the PaaS model, the CSP offers a platform that includes OSs, development frameworks,
    runtime environments, and various tools and services needed to support the application
    development life cycle. Users or organizations can leverage these platform resources
    to develop, test, deploy, and scale their applications.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台即服务**（**PaaS**）为你提供了一个抽象层，在这个层级上，你可以专注于代码编写，将应用程序管理交给云服务。PaaS是一种云计算服务模型，为开发人员提供一个平台和环境，以便构建、部署和管理应用程序，而无需担心底层的基础设施组件。PaaS抽象化了基础设施管理的复杂性，使开发人员可以专注于应用程序开发和部署。在PaaS模式中，CSP提供的平台包括操作系统（OS）、开发框架、运行时环境，以及支持应用程序开发生命周期所需的各种工具和服务。用户或组织可以利用这些平台资源来开发、测试、部署和扩展应用程序。'
- en: '**Software-as-a-Service** (**SaaS**) provides a pre-built application for your
    consumption, such as a monitoring service that’s readily available for you to
    use that you can easily plug and play with your application. In the SaaS model,
    the CSP hosts and manages the software application, including infrastructure,
    servers, databases, and maintenance. Users or organizations can access the application
    through a web browser or a thin client application. They typically pay a subscription
    fee based on usage, and the software is delivered as a service on demand.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件即服务**（**SaaS**）为你提供了一个预构建的应用程序，例如一个可以轻松与应用程序集成的现成监控服务。在SaaS模式中，云服务提供商（CSP）托管和管理软件应用程序，包括基础设施、服务器、数据库和维护。用户或组织可以通过网页浏览器或瘦客户端应用程序访问该应用。通常他们根据使用量支付订阅费用，软件作为按需服务提供。'
- en: The advent of the cloud has led to a new buzzword in the industry called cloud-native
    applications. We’ll look at them in the next section.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 云的出现带来了一个新的行业流行词——云原生应用。我们将在下一节中讨论它们。
- en: Understanding modern cloud-native applications
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解现代云原生应用
- en: When we say cloud-native, we talk about applications built to run natively on
    the cloud. A cloud-native application is designed to run in the cloud taking full
    advantage of the capabilities and benefits of the cloud using cloud services as
    much as possible.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说云原生时，指的是那些为在云中原生运行而构建的应用程序。云原生应用旨在充分利用云的能力和优势，尽可能多地使用云服务在云中运行。
- en: These applications are inherently **scalable**, **flexible**, and **resilient**
    (fault-tolerant). They rely on cloud services and automation to a large extent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些应用程序天生具有**可扩展性**、**灵活性**和**弹性**（容错能力）。它们在很大程度上依赖于云服务和自动化。
- en: 'Some of the characteristics of a modern cloud-native application are as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现代云原生应用的一些特征如下：
- en: '**Microservices architecture**: Modern cloud-native applications typically
    follow the microservices architecture. Microservices are applications that are
    broken down into multiple smaller, loosely coupled parts with independent business
    functions. Independent microservices can be written in different programming languages
    based on the need or specific functionality. These smaller parts can then independently
    scale, are flexible to run, and are resilient by design.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**：现代云原生应用通常遵循微服务架构。微服务是将应用程序拆分为多个较小，松散耦合的部分，具有独立的业务功能。独立的微服务可以根据需要或特定功能使用不同的编程语言编写。这些较小的部分可以独立扩展，灵活运行，并且从设计上具有弹性。'
- en: '**Containerization**: Microservices applications typically use containers to
    run. Containers provide a **consistent**, **portable**, and **lightweight** environment
    for applications to run, ensuring that they have all the necessary dependencies
    and configurations bundled together. Containers can run the same on all environments
    and cloud platforms.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器化**：微服务应用通常使用容器来运行。容器为应用程序提供了一种**一致**，**便携**和**轻量级**的环境，确保它们捆绑了所有必要的依赖关系和配置。容器可以在所有环境和云平台上运行相同的内容。'
- en: '**DevOps and automation**: Cloud-native applications heavily use modern DevOps
    practices and tools and therefore rely on automation to a considerable extent.
    This streamlines development, testing, and operations for your application. Automation
    also brings about **scalability**, **resilience,** and **consistency**.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps和自动化**：云原生应用程序大量使用现代DevOps的实践和工具，因此在很大程度上依赖自动化。这简化了应用程序的开发，测试和运营。自动化还带来了**可扩展性**，**韧性**和**一致性**。'
- en: '**Dynamic orchestration**: Cloud-native applications are built to scale and
    are inherently meant to be fault tolerant. These applications are typically **ephemeral**
    (**transient**); therefore, replicas of services can come and go as needed. Dynamic
    orchestration platforms such as **Kubernetes** and **Docker Swarm** are used to
    manage these services. These tools help run your application under changing demands
    and traffic patterns.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态编排**：云原生应用程序构建为可扩展且本质上是容错的。这些应用程序通常是**短暂的**（**临时的**）；因此，服务的副本可以根据需要随时出现和消失。诸如**Kubernetes**和**Docker
    Swarm**之类的动态编排平台用于管理这些服务。这些工具帮助在变化的需求和流量模式下运行您的应用程序。'
- en: '**Use of cloud-native data services**: Cloud-native applications typically
    use managed cloud data services such as **storage**, **databases**, **caching**,
    and **messaging** systems to allow for communication between multiple services.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**云原生数据服务的使用**：云原生应用通常使用托管的云数据服务，如**存储**，**数据库**，**缓存**和**消息**系统，以便多个服务之间进行通信。'
- en: Cloud-native systems emphasize DevOps, and modern DevOps has emerged to manage
    them. So, now, let’s look at the difference between traditional and modern DevOps.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生系统强调DevOps，并且现代DevOps已经出现来管理它们。因此，现在让我们来看看传统DevOps和现代DevOps之间的区别。
- en: Modern DevOps versus traditional DevOps
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代DevOps与传统DevOps的对比
- en: DevOps’ traditional approach involved establishing a DevOps team consisting
    of **Dev**, **QA**, and **Ops** members and working toward creating better software
    faster. However, while there would be a focus on automating software delivery,
    automation tools such as **Jenkins**, **Git**, and others were installed and maintained
    manually. This led to another problem as we now had to manage another set of IT
    infrastructure. It finally boiled down to infrastructure and configuration, and
    the focus was to automate the automation process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps的传统方法涉及建立一个包含**开发**，**质量保证**和**运维**成员的DevOps团队，并努力创建更快，更好的软件。然而，虽然会专注于自动化软件交付，但自动化工具如**Jenkins**，**Git**等仍需手动安装和维护。这导致了另一个问题，因为现在我们不得不管理另一套IT基础设施。最终问题归结为基础设施和配置，而焦点是自动化自动化过程。
- en: With the advent of containers and the recent boom in the public cloud landscape,
    DevOps’ modern approach came into the picture, which involved automating everything.
    From provisioning infrastructure to configuring tools and processes, there is
    code for everything. So, now, we have **IaC**, **CaC**, **immutable infrastructure**,
    and **containers**. I call this approach to DevOps modern DevOps, and it will
    be the focus of this book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 随着容器的出现和公共云景观的近期繁荣，DevOps的现代方法进入了视野，其中涉及到一切的自动化。从基础设施的供应到工具和流程的配置，一切都有相应的代码。因此，现在我们有**IaC**，**CaC**，**不可变基础设施**和**容器**。我称这种方法为现代DevOps，并且这将是本书的重点。
- en: 'The following table describes some of the key similarities and differences
    between modern DevOps and traditional DevOps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了现代 DevOps 和传统 DevOps 之间的一些关键相似性和差异：
- en: '| **Aspect** | **Modern DevOps** | **Traditional DevOps** |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **方面** | **现代 DevOps** | **传统 DevOps** |'
- en: '| Software Delivery | Emphasis on CI/CD pipelines, automated testing, and deployment
    automation. | Emphasis on CI/CD pipelines, automated testing, and deployment automation.
    |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 软件交付 | 重视 CI/CD 流水线、自动化测试和部署自动化。 | 重视 CI/CD 流水线、自动化测试和部署自动化。 |'
- en: '| Infrastructure management | IaC is commonly used to provision and manage
    infrastructure resources. Cloud platforms and containerization technologies are
    often utilized. | Manual provisioning and configuration of infrastructure is done,
    often relying on traditional data centers and limited automation. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 基础设施管理 | 常用 IaC 来进行基础设施资源的规划和管理。经常使用云平台和容器化技术。 | 手动进行基础设施的规划和配置，通常依赖传统数据中心和有限的自动化。
    |'
- en: '| Application deployment | Containerization and container orchestration technologies,
    such as Docker and Kubernetes, are widely adopted to ensure application portability
    and scalability. | Traditional deployment methods are used, such as deploying
    applications directly on virtual machines or physical servers without containerization.
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序部署 | 广泛采用容器化和容器编排技术，如 Docker 和 Kubernetes，以确保应用程序的可移植性和可扩展性。 | 使用传统的部署方法，如直接在虚拟机或物理服务器上部署应用程序，没有采用容器化。
    |'
- en: '| Scalability and resilience | Utilizes the auto-scaling capabilities of cloud
    platforms and container orchestration to handle varying workloads. Focuses on
    high availability and fault tolerance. | Scalability is achieved through vertical
    scaling (adding resources to existing servers) or manual capacity planning. High
    availability is achieved by adding redundant servers manually. Elasticity is non-existent,
    and fault tolerance is not a focus. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 可扩展性和弹性 | 利用云平台和容器编排的自动扩展能力来处理不同的工作负载。专注于高可用性和容错性。 | 通过纵向扩展（向现有服务器添加资源）或手动容量规划来实现可扩展性。通过手动添加冗余服务器来实现高可用性。弹性不存在，容错性不是重点。
    |'
- en: '| Monitoring and logging | Extensive use of monitoring tools, log aggregation,
    and real-time analytics to gain insights into application and infrastructure performance.
    | Limited monitoring and logging practices, with fewer tools and analytics available.
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 监控与日志记录 | 广泛使用监控工具、日志聚合和实时分析来获取应用程序和基础设施性能的洞察。 | 监控和日志记录做法有限，可用工具和分析较少。 |'
- en: '| Collaboration and culture | Emphasizes collaboration, communication, and
    shared ownership between development and operations teams (DevOps culture). |
    Emphasizes collaboration, communication, and shared ownership between development
    and operations teams (DevOps culture). |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 协作与文化 | 强调开发和运维团队之间的协作、沟通和共享责任（DevOps 文化）。 | 强调开发和运维团队之间的协作、沟通和共享责任（DevOps
    文化）。 |'
- en: '| Security | Security is integrated into the development process with the use
    of **DevSecOps** practices. Security testing and vulnerability scanning are automated.
    | Security measures are often applied manually and managed by a separate security
    team. There is limited automated security testing in the SDLC. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 安全性 | 安全性通过使用**DevSecOps**实践集成到开发过程中。安全测试和漏洞扫描是自动化的。 | 安全措施通常是手动应用并由独立的安全团队管理。在软件开发生命周期中自动化安全测试有限。
    |'
- en: '| Speed of deployment | Rapid and frequent deployment of software updates through
    automated pipelines, enabling faster time-to-market. | Rapid application deployments,
    but automated infrastructure deployments are often lacking. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 部署速度 | 通过自动化流水线快速频繁地部署软件更新，从而缩短上市时间。 | 快速部署应用程序，但缺乏自动化的基础设施部署。 |'
- en: Table 1.1 – Key similarities and differences between modern DevOps and traditional
    DevOps
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – 现代 DevOps 和传统 DevOps 之间的主要相似性和差异
- en: It’s important to note that the distinction between modern DevOps and traditional
    DevOps is not strictly binary as organizations can adopt various practices and
    technologies along a spectrum. The modern DevOps approach generally focuses on
    leveraging cloud technologies, automation, containerization, and DevSecOps principles
    to enhance collaboration, agility, and software development and deployment efficiency.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，现代DevOps与传统DevOps之间的区别并不是严格的二元对立，因为组织可以在一个范围内采用各种实践和技术。现代DevOps方法通常专注于利用云技术、自动化、容器化和DevSecOps原则，以提高协作性、敏捷性以及软件开发和部署的效率。
- en: As we discussed previously, containers help implement modern DevOps and form
    the core of the practice. We’ll have a look at containers in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，容器有助于实现现代DevOps，并构成了这一实践的核心。我们将在下一节中深入了解容器。
- en: The need for containers
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的需求
- en: Containers are in vogue lately and for excellent reason. They solve the computer
    architecture’s most critical problem – *running reliable, distributed software
    with near-infinite scalability in any* *computing environment*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，容器非常流行，原因也很充分。它们解决了计算机架构中最关键的问题——*在任何计算环境中运行可靠的、分布式的软件，并具备接近无限的可扩展性*。
- en: They have enabled an entirely new discipline in software engineering – *microservices*.
    They have also introduced the *package once deploy anywhere* concept in technology.
    Combined with the cloud and distributed applications, containers with container
    orchestration technology have led to a new buzzword in the industry – *cloud-native*
    – changing the IT ecosystem like never before.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它们促成了软件工程领域的一门全新学科——*微服务*。它们还在技术中引入了*一次打包，随时部署*的概念。结合云计算和分布式应用程序，容器与容器编排技术共同促成了业界的一个新热词——*云原生*——彻底改变了IT生态系统。
- en: Before we delve into more technical details, let’s understand containers in
    plain and simple words.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨更多技术细节之前，让我们用简单明了的方式来理解容器。
- en: Containers derive their name from shipping containers. I will explain containers
    using a shipping container analogy for better understanding. Historically, because
    of transportation improvements, a lot of stuff moved across multiple geographies.
    With various goods being transported in different modes, loading and unloading
    goods was a massive issue at every transportation point. In addition, with rising
    labor costs, it was impractical for shipping companies to operate at scale while
    keeping prices low.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 容器得名于集装箱。我将通过集装箱类比来解释容器，以便更好地理解。历史上，由于交通运输的改善，大量物品跨越多个地理区域进行运输。由于各种货物通过不同方式运输，货物在每个运输点的装卸问题巨大。而且，随着劳动力成本的上升，航运公司要在规模化运营的同时保持低价格变得不切实际。
- en: Also, it resulted in frequent damage to items, and goods used to get misplaced
    or mixed up with other consignments because there was no isolation. There was
    a need for a standard way of transporting goods that provided the necessary isolation
    between consignments and allowed for easy loading and unloading of goods. The
    shipping industry came up with shipping containers as an elegant solution to this
    problem.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这也导致了物品经常遭受损坏，货物容易被错放或与其他货物混淆，因为没有隔离措施。运输货物需要一种标准的方式，以提供必要的货物隔离，并便于装卸。航运业提出了集装箱这一优雅的解决方案来解决这个问题。
- en: 'Now, shipping containers have simplified a lot of things in the shipping industry.
    With a standard container, we can ship goods from one place to another by only
    moving the container. The same container can be used on roads, loaded on trains,
    and transported via ships. The operators of these vehicles don’t need to worry
    about what is inside the container most of the time. The following figure depicts
    the entire workflow graphically for ease of understanding:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，集装箱简化了航运业中的许多事情。通过标准化集装箱，我们可以只移动集装箱就将货物从一个地方运输到另一个地方。相同的集装箱可以用于公路、装载到火车上并通过船只运输。这些运输工具的操作员大多数时候不需要担心集装箱内的货物。下图以图形方式描绘了整个工作流程，便于理解：
- en: '![Figure 1.2 – Shipping container workflow](img/B19877_Figure_1.02.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 集装箱工作流程](img/B19877_Figure_1.02.jpg)'
- en: Figure 1.2 – Shipping container workflow
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 – 集装箱工作流程
- en: Similarly, there have been issues with software portability and compute resource
    management in the software industry. In a standard software development life cycle,
    a piece of software moves through multiple environments, and sometimes, numerous
    applications share the same OS. There may be differences in the configuration
    between environments, so software that may have worked in a development environment
    may not work in a test environment. Something that worked in test may also not
    work in production.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，软件行业在软件可移植性和计算资源管理方面也存在问题。在标准软件开发生命周期中，软件会在多个环境中移动，有时候，多个应用程序共享同一个操作系统。环境之间的配置可能存在差异，因此在开发环境中可以正常工作的软件在测试环境中可能无法正常工作。测试环境中正常工作的东西在生产环境中也可能不正常。
- en: Also, when you have multiple applications running within a single machine, there
    is no isolation between them. One application can drain compute resources from
    another application, and that may lead to runtime issues.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当您在单台计算机内运行多个应用程序时，它们之间没有隔离。一个应用程序可能会耗尽另一个应用程序的计算资源，这可能导致运行时问题。
- en: Repackaging and reconfiguring applications is required in every step of deployment,
    so it takes a lot of time and effort and is sometimes error-prone.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署的每个步骤中都需要重新打包和重新配置应用程序，因此需要大量的时间和精力，有时会出错。
- en: In the software industry, containers solve these problems by providing isolation
    between application and compute resource management, which provides an optimal
    solution to these issues.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件行业，容器通过提供应用程序之间的隔离和计算资源管理来解决这些问题，为这些问题提供了最佳解决方案。
- en: The software industry’s biggest challenge is to provide application isolation
    and manage external dependencies elegantly so that they can run on any platform,
    irrespective of the OS or the infrastructure. Software is written in numerous
    programming languages and uses various dependencies and frameworks. This leads
    to a scenario called the **matrix** **of hell**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 软件行业面临的最大挑战是提供应用程序隔离和优雅地管理外部依赖项，以便它们可以在任何平台上运行，无论操作系统或基础设施如何。软件用多种编程语言编写，并使用各种依赖项和框架。这导致了一个称为**地狱矩阵**的场景。
- en: The matrix of hell
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 地狱矩阵
- en: 'Let’s say you’re preparing a server that will run multiple applications for
    multiple teams. Now, assume that you don’t have a virtualized infrastructure and
    that you need to run everything on one physical machine, as shown in the following
    diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在准备一台服务器，该服务器将为多个团队的多个应用程序运行。现在，假设您没有虚拟化基础设施，并且需要在一个物理机器上运行所有内容，如下图所示：
- en: '![Figure 1.3 – Applications on a physical server](img/B19877_Figure_1.03.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 物理服务器上的应用程序](img/B19877_Figure_1.03.jpg)'
- en: Figure 1.3 – Applications on a physical server
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 物理服务器上的应用程序
- en: One application uses one particular version of a dependency, while another application
    uses a different one, and you end up managing two versions of the same software
    in one system. When you scale your system to fit multiple applications, you will
    be managing hundreds of dependencies and various versions that cater to different
    applications. It will slowly turn out to be unmanageable within one physical system.
    This scenario is known as the **matrix of hell** in popular computing nomenclature.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个应用程序使用某个依赖项的特定版本，而另一个应用程序使用不同版本，您最终在一个系统中管理两个版本的同一软件。当您扩展系统以适应多个应用程序时，您将管理数百个依赖项和不同应用程序版本，这会逐渐变得在一个物理系统内难以管理。这种情况在流行的计算术语中被称为**地狱矩阵**。
- en: Multiple solutions come out of the matrix of hell, but there are two notable
    technological contributions – *virtual machines* and *containers*.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 地狱矩阵产生了多种解决方案，但有两种显著的技术贡献 – *虚拟机* 和 *容器*。
- en: Virtual machines
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟机
- en: A **virtual machine** emulates an OS using a technology called a **hypervisor**.
    A hypervisor can run as software on a physical host OS or run as firmware on a
    bare-metal machine. Virtual machines run as a virtual guest OS on the hypervisor.
    With this technology, you can subdivide a sizeable physical machine into multiple
    smaller virtual machines, each catering to a particular application. This has
    revolutionized computing infrastructure for almost two decades and is still in
    use today. Some of the most popular hypervisors on the market are **VMware** and
    **Oracle VirtualBox**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟机**通过一种叫做**虚拟机管理程序**（hypervisor）的技术来模拟操作系统。虚拟机管理程序可以作为软件运行在物理主机操作系统上，或者作为固件运行在裸机上。虚拟机作为虚拟的客操作系统在虚拟机管理程序上运行。借助这项技术，您可以将一台庞大的物理机器划分为多个较小的虚拟机，每个虚拟机都服务于特定的应用程序。这项技术已经彻底改变了计算基础设施，近二十年来一直在使用，至今仍然活跃在市场上。市场上一些最流行的虚拟机管理程序包括**VMware**和**Oracle
    VirtualBox**。'
- en: 'The following diagram shows the same stack on virtual machines. You can see
    that each application now contains a dedicated guest OS, each of which has its
    own libraries and dependencies:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了虚拟机上的同一堆栈。您可以看到，每个应用程序现在都包含一个专用的客操作系统，每个操作系统都有自己的库和依赖关系：
- en: '![Figure 1.4 – Applications on virtual machines](img/B19877_Figure_1.04.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 虚拟机上的应用程序](img/B19877_Figure_1.04.jpg)'
- en: Figure 1.4 – Applications on virtual machines
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 虚拟机上的应用程序
- en: Though the approach is acceptable, it is like using an entire ship for your
    goods rather than a simple container from the shipping container analogy. Virtual
    machines are heavy on resources as you need a heavy guest OS layer to isolate
    applications rather than something more lightweight. We need to allocate dedicated
    CPU and memory to a virtual machine; resource sharing is suboptimal since people
    tend to overprovision virtual machines to cater to peak load. They are also slower
    to start, and virtual machine scaling is traditionally more cumbersome as multiple
    moving parts and technologies are involved. Therefore, automating horizontal scaling
    (handling more traffic from users by adding more machines to the resource pool)
    using virtual machines is not very straightforward. Also, sysadmins now have to
    deal with multiple servers rather than numerous libraries and dependencies in
    one. It is better than before, but it is not optimal from a compute resource point
    of view.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法是可接受的，但它就像使用一整艘船来运输货物，而不是使用简单的货运集装箱来做类比。虚拟机资源消耗较大，因为它需要一个较重的客操作系统层来隔离应用程序，而不是更轻量的解决方案。我们需要为虚拟机分配专用的CPU和内存；资源共享不够理想，因为人们往往为了应对高峰负载而过度配置虚拟机。虚拟机的启动速度也较慢，虚拟机的扩展传统上较为繁琐，因为涉及到多个活动组件和技术。因此，使用虚拟机自动化水平扩展（通过向资源池中添加更多机器来处理更多来自用户的流量）并不是特别直接。此外，系统管理员现在不得不处理多个服务器，而不是一个服务器中的大量库和依赖关系。虽然比以前有所改善，但从计算资源的角度来看，它仍然不是最优解。
- en: Containers
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: This is where containers come into the picture. Containers solve the matrix
    of hell without involving a heavy guest OS layer between them. Instead, they isolate
    the application runtime and dependencies by encapsulating them to create an abstraction
    called containers. Now, you have multiple containers that run on a single OS.
    Numerous applications running on containers can share the same infrastructure.
    As a result, they do not waste your computing resources. You also do not have
    to worry about application libraries and dependencies as they are isolated from
    other applications – a win-win situation for everyone!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是容器技术的引入背景。容器技术解决了地狱矩阵的问题，并且没有涉及重型的客操作系统层。相反，容器通过封装应用程序运行时和依赖关系，将它们隔离开来，创建了一种叫做容器的抽象。现在，您可以在单一操作系统上运行多个容器。运行在容器中的众多应用程序可以共享相同的基础设施。因此，它们不会浪费您的计算资源。您也无需担心应用程序的库和依赖关系，因为它们被隔离在其他应用程序之外——对每个人来说，都是一种双赢的局面！
- en: Containers run on container runtimes. While **Docker** is the most popular and
    more or less the de facto container runtime, other options are available on the
    market, such as **Rkt** and **Containerd**. They all use the same Linux kernel
    **cgroups** feature, whose basis comes from the combined efforts of Google, IBM,
    OpenVZ, and SGI to embed **OpenVZ** into the main Linux kernel. OpenVZ was an
    early attempt at implementing features to provide virtual environments within
    a Linux kernel without using a guest OS layer, which we now call containers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行在容器运行时环境上。虽然**Docker**是最流行且几乎是事实上的容器运行时，但市场上还有其他选择，比如**Rkt**和**Containerd**。它们都使用相同的Linux内核**cgroups**特性，这一特性的基础来源于谷歌、IBM、OpenVZ和SGI的共同努力，将**OpenVZ**嵌入到Linux主内核中。OpenVZ是最早尝试在不使用客操作系统层的情况下，在Linux内核中实现虚拟环境特性的项目，我们现在称之为容器。
- en: It works on my machine
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它在我的机器上能运行
- en: You might have heard this phrase many times in your career. It is a typical
    situation where you have erratic developers worrying your test team with “*But,
    it works on my machine*” answers and your testing team responding with “*We are
    not going to deliver your machine to the client.*” Containers use the *Build once,
    run anywhere* and the *Package once, deploy anywhere* concepts and solve the *It
    works on my machine* syndrome. As containers need a container runtime, they can
    run on any machine in the same way. A standardized setup for applications also
    means that the sysadmin’s job is reduced to just taking care of the container
    runtime and servers and delegating the application’s responsibilities to the development
    team. This reduces the admin overhead from software delivery, and software development
    teams can now spearhead development without many external dependencies – a great
    power indeed! Now, let’s look at how containers are designed to do that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在职业生涯中听过这句话很多次。这是一个典型的情形：开发人员给测试团队带来困扰，他们会说“*但在我的机器上能运行*”，而测试团队则回应道“*我们不会把你的机器交给客户*。”容器使用*一次构建，到处运行*和*一次打包，随处部署*的理念，解决了*它在我的机器上能运行*的问题。由于容器需要容器运行时，它们可以在任何机器上以相同的方式运行。应用程序的标准化设置也意味着系统管理员的工作仅限于照顾容器运行时和服务器，并将应用程序的责任委托给开发团队。这减少了软件交付的管理负担，软件开发团队现在可以在没有太多外部依赖的情况下引领开发——这确实是强大的能力！现在，让我们看看容器是如何设计来实现这一点的。
- en: Container architecture
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器架构
- en: 'In most cases, you can visualize containers as mini virtual machines – at least,
    they seem like they are. But, in reality, they are just computer programs running
    within an OS. So, let’s look at a high-level diagram of what an application stack
    within containers looks like:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你可以将容器视为迷你虚拟机——至少，它们看起来像虚拟机。但实际上，它们只是运行在操作系统中的计算机程序。那么，让我们来看看容器中应用堆栈的高层次示意图：
- en: '![Figure 1.5 – Applications on containers](img/B19877_Figure_1.05.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 容器中的应用程序](img/B19877_Figure_1.05.jpg)'
- en: Figure 1.5 – Applications on containers
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 容器中的应用程序
- en: As we can see, we have the compute infrastructure right at the bottom, forming
    the base, followed by the host OS and a container runtime (in this case, Docker)
    running on top of it. We then have multiple containerized applications using the
    container runtime, running as separate processes over the host operating system
    using *namespaces* and *cgroups*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，计算基础设施位于最底部，形成了基础层，其上是主机操作系统和运行其上的容器运行时（在本例中为Docker）。接着，我们有多个使用容器运行时的容器化应用程序，它们作为独立进程在主操作系统上运行，利用*命名空间*和*cgroups*。
- en: As you may have noticed, we do not have a guest OS layer within it, which is
    something we have with virtual machines. Each container is a *software program*
    that runs on the Kernel userspace and shares the same OS and associated runtime
    and other dependencies, with only the required libraries and dependencies within
    the container. Containers do not inherit the OS environment variables. You have
    to set them separately for each container.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们在其中没有像虚拟机那样的客操作系统层。每个容器都是在内核用户空间上运行的*软件程序*，它与主机操作系统共享相同的操作系统及相关的运行时和其他依赖项，容器中仅包含所需的库和依赖项。容器不会继承操作系统的环境变量。你必须为每个容器单独设置这些变量。
- en: Containers replicate the filesystem, and though they are present on disk, they
    are isolated from other containers. This makes containers run applications in
    a secure environment. A separate container filesystem means that containers don’t
    have to communicate to and fro with the OS filesystem, which results in faster
    execution than virtual machines.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 容器复制了文件系统，尽管它们存在于磁盘上，但彼此隔离。这使得容器能够在安全的环境中运行应用程序。单独的容器文件系统意味着容器不需要与操作系统文件系统进行频繁的交互，从而比虚拟机更快地执行。
- en: Containers were designed to use Linux *namespaces* to provide isolation and
    *cgroups* to offer restrictions on CPU, memory, and disk I/O consumption.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 容器设计使用 Linux *命名空间* 来提供隔离，并使用 *cgroups* 对 CPU、内存和磁盘 I/O 消耗进行限制。
- en: 'This means that if you list the OS processes, you will see the container process
    running alongside other processes, as shown in the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你列出操作系统进程，你将看到容器进程与其他进程一起运行，如下所示：
- en: '![Figure 1.6 – OS processes](img/B19877_Figure_1.06.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 操作系统进程](img/B19877_Figure_1.06.jpg)'
- en: Figure 1.6 – OS processes
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 操作系统进程
- en: 'However, when you list the container’s processes, you will only see the container
    process, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你列出容器的进程时，你只会看到容器进程，如下所示：
- en: '[PRE0]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is how namespaces provide a degree of isolation between containers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是命名空间如何在容器之间提供一定程度的隔离。
- en: Cgroups play a role in limiting the amount of computing resources a group of
    processes can use. For example, if you add processes to a cgroup, you can limit
    the CPU, memory, and disk I/O the processes can use. In addition, you can measure
    and monitor resource usage and stop a group of processes when an application goes
    astray. All these features form the core of containerization technology, which
    we will see later in this book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Cgroups 在限制一组进程可以使用的计算资源方面起着重要作用。例如，如果你将进程添加到一个 cgroup，你可以限制这些进程使用的 CPU、内存和磁盘
    I/O。此外，你还可以衡量和监控资源使用情况，当应用程序出现问题时，可以停止一组进程。所有这些特性构成了容器化技术的核心，我们将在本书后面看到这些内容。
- en: Once we have independently running containers, we also need to understand how
    they interact. Therefore, we’ll have a look at container networking in the next
    section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了独立运行的容器，我们还需要了解它们如何交互。因此，我们将在下一节探讨容器网络。
- en: Container networking
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器网络
- en: Containers are separate network entities within the OS. Docker runtimes use
    network drivers to define networking between containers, and they are software-defined
    networks. **Container networking** works by using software to manipulate the *host
    iptables*, connect with external network interfaces, create tunnel networks, and
    perform other activities to allow connections to and from containers.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是操作系统中的独立网络实体。Docker 运行时使用网络驱动程序来定义容器之间的网络连接，它们是软件定义的网络。**容器网络**通过使用软件来操作
    *主机 iptables*、连接外部网络接口、创建隧道网络以及执行其他活动，以便容器之间可以进行连接。
- en: 'While there are various types of network configurations you can implement with
    containers, it is good to know about some widely used ones. Don’t worry too much
    if the details are overwhelming – you will understand them while completing the
    hands-on exercises later in this book, and it is not a hard requirement to know
    all of this to follow the text. For now, let’s look at various types of container
    networks that you can define:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在容器中实现多种网络配置，但了解一些常用的配置还是很有帮助的。如果细节看起来有些复杂，不要太担心——你将在本书后续的实操练习中理解它们，跟随文本并不需要完全掌握这些内容。现在，让我们来看一下你可以定义的几种容器网络类型：
- en: '**None**: This is a fully isolated network, and your containers cannot communicate
    with the external world. They are assigned a loopback interface and cannot connect
    with an external network interface. You can use this network to test your containers,
    stage your container for future use, or run a container that does not require
    any external connection, such as batch processing.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：这是一个完全隔离的网络，您的容器无法与外界通信。它们被分配了一个回环接口，并且无法连接到外部网络接口。您可以使用此网络来测试容器、为未来使用准备容器，或者运行不需要任何外部连接的容器，比如批处理任务。'
- en: '`docker0` interface for default containers. The bridge network manipulates
    IP tables to provide **Network Address Translation** (**NAT**) between the container
    and host network, allowing external network connectivity. It also does not result
    in port conflicts, enabling network isolation between containers running on a
    host. Therefore, you can run multiple applications that use the same container
    port within a single host. A bridge network allows containers within a single
    host to communicate using the container IP addresses. However, they don’t permit
    communication with containers running on a different host. Therefore, you should
    not use the bridge network for clustered configuration (using multiple servers
    in tandem to run your containers).'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker0` 接口用于默认容器。桥接网络通过操作 IP 表来提供 **网络地址转换**（**NAT**），实现容器与主机网络之间的外部网络连接。它还可以避免端口冲突，使得运行在同一主机上的容器之间能够进行网络隔离。因此，你可以在单个主机内运行多个使用相同容器端口的应用程序。桥接网络允许同一主机内的容器通过容器
    IP 地址进行通信。然而，它不允许与运行在不同主机上的容器通信。因此，你不应该在集群配置中使用桥接网络（即使用多台服务器联合运行容器）。'
- en: '**Host**: Host networking uses the network namespace of the host machine for
    all the containers. It is similar to running multiple applications within your
    host. While a host network is simple to implement, visualize, and troubleshoot,
    it is prone to port-conflict issues. While containers use the host network for
    all communications, it does not have the power to manipulate the host network
    interfaces unless it is running in privileged mode. Host networking does not use
    NAT, so it is fast and communicates at bare-metal speeds. Therefore, you can use
    host networking to optimize performance. However, since it has no network isolation
    between containers, from a security and management point of view, in most cases,
    you should avoid using the host network.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机网络**：主机网络使用主机机器的网络命名空间来处理所有容器的网络。这类似于在主机上运行多个应用程序。虽然主机网络实现简单，易于可视化和故障排除，但它容易出现端口冲突问题。尽管容器使用主机网络进行所有通信，但除非在特权模式下运行，否则它无法操作主机网络接口。主机网络不使用NAT，因此速度较快，并且以裸机速度进行通信。因此，你可以使用主机网络来优化性能。然而，由于容器之间没有网络隔离，从安全和管理的角度来看，在大多数情况下，你应该避免使用主机网络。'
- en: '**Underlay**: Underlay exposes the host network interfaces directly to containers.
    This means you can run your containers directly on the network interfaces instead
    of using a bridge network. There are several underlay networks, the most notable
    being MACvlan and IPvlan. MACvlan allows you to assign a MAC address to every
    container so that your container looks like a physical device. This is beneficial
    for migrating your existing stack to containers, especially when your application
    needs to run on a physical machine. MACvlan also provides complete isolation to
    your host networking, so you can use this mode if you have a strict security requirement.
    MACvlan has limitations as it cannot work with network switches with a security
    policy to disallow MAC spoofing. It is also constrained to the MAC address ceiling
    of some network interface cards, such as Broadcom, which only allows 512 MAC addresses
    per interface.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底层网络**：底层网络直接将主机网络接口暴露给容器。这意味着你可以直接在网络接口上运行容器，而无需使用桥接网络。有几种底层网络，最著名的有 MACvlan
    和 IPvlan。MACvlan 允许你为每个容器分配一个 MAC 地址，使得容器看起来像是一个物理设备。这对于将现有堆栈迁移到容器特别有用，尤其是当你的应用程序需要在物理机器上运行时。MACvlan
    还提供了对主机网络的完全隔离，因此，如果你有严格的安全要求，可以使用这种模式。MACvlan 有一定的限制，因为它不能与设置了安全策略禁止 MAC 欺骗的网络交换机一起使用。它还受到某些网络接口卡的
    MAC 地址数量限制，例如 Broadcom，只允许每个接口最多 512 个 MAC 地址。'
- en: '**Overlay**: Don’t confuse overlay with underlay – even though they seem like
    antonyms, they are not. Overlay networks allow communication between containers
    on different host machines via a networking tunnel. Therefore, from a container’s
    perspective, they seem to interact with containers on a single host, even when
    they are located elsewhere. It overcomes the bridge network’s limitations and
    is especially useful for cluster configuration, especially when using a container
    orchestrator such as Kubernetes or Docker Swarm. Some popular overlay technologies
    container runtimes and orchestrators use are **flannel**, **calico**, and **VXLAN**.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Overlay**：不要将 Overlay 与 Underlay 混淆 - 尽管它们看起来像是反义词，但实际上并非如此。Overlay 网络通过网络隧道允许不同主机上的容器进行通信。因此，从容器的角度来看，它们似乎在单个主机上与容器进行交互，即使它们位于其他位置。它克服了桥接网络的限制，特别适用于集群配置，尤其是在使用容器编排器如
    Kubernetes 或 Docker Swarm 时。一些流行的 Overlay 技术包括 **flannel**、**calico** 和 **VXLAN**。'
- en: Before we delve into the technicalities of different kinds of networks, let’s
    understand the nuances of container networking. For this discussion, we’ll talk
    about Docker in particular.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论不同类型网络技术之前，让我们了解容器网络的微妙之处。在这次讨论中，我们将特别谈谈 Docker。
- en: 'Every Docker container running on a host is assigned a unique IP address. If
    you `exec` (open a shell session) into the container and run `hostname -I`, you
    should see something like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在主机上运行的 Docker 容器都分配了一个唯一的 IP 地址。如果你 `exec`（打开一个 shell 会话）进入容器并运行 `hostname
    -I`，你应该看到类似以下的内容：
- en: '[PRE1]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This allows different containers to communicate with each other through a simple
    TCP/IP link. The Docker daemon acts as the DHCP server for every container. Here,
    you can define virtual networks for a group of containers and club them together
    to provide network isolation if you desire. You can also connect a container to
    multiple networks to share it for two different roles.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许不同的容器通过简单的 TCP/IP 链路进行通信。Docker 守护进程充当每个容器的 DHCP 服务器。在这里，你可以为一组容器定义虚拟网络，并将它们结合在一起以提供网络隔离（如果需要）。你还可以将容器连接到多个网络，以便为它们提供两种不同的角色共享。
- en: 'Docker assigns every container a unique hostname that defaults to the container
    ID. However, this can be overridden easily, provided you use unique hostnames
    in a particular network. So, if you `exec` into a container and run `hostname`,
    you should see the container ID as the hostname, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 为每个容器分配一个唯一的主机名，默认为容器 ID。然而，这可以很容易地被覆盖，只要在特定网络中使用唯一的主机名即可。因此，如果你 `exec`
    进入一个容器并运行 `hostname`，你应该看到容器 ID 作为主机名，如下所示：
- en: '[PRE2]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This allows containers to act as separate network entities rather than simple
    software programs, and you can easily visualize containers as mini virtual machines.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得容器能够作为独立的网络实体而不仅仅是简单的软件程序，你可以轻松地将容器视为小型虚拟机。
- en: Containers also inherit the host OS’s DNS settings, so you don’t have to worry
    too much if you want all the containers to share the same DNS settings. If you’re
    going to define a separate DNS configuration for your containers, you can easily
    do so by passing a few flags. Docker containers do not inherit entries in the
    `/etc/hosts` file, so you must define them by declaring them while creating the
    container using the `docker` `run` command.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还继承了主机操作系统的 DNS 设置，因此如果你希望所有容器共享相同的 DNS 设置，你不必太担心。如果你想为你的容器定义单独的 DNS 配置，你可以通过传递一些标志来轻松实现。Docker
    容器不继承 `/etc/hosts` 文件中的条目，因此你必须在使用 `docker run` 命令创建容器时声明它们。
- en: If your containers need a proxy server, you must set that either in the Docker
    container’s environment variables or by adding the default proxy to the `~/.``docker/config.json`
    file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的容器需要代理服务器，你必须在 Docker 容器的环境变量中设置或者通过向 `~/.docker/config.json` 文件添加默认代理来设置。
- en: So far, we’ve discussed containers and what they are. Now, let’s discuss how
    containers are revolutionizing the world of DevOps and how it was necessary to
    spell this outright at the beginning.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了容器及其定义。现在，让我们讨论容器如何正在改变 DevOps 的世界，以及在一开始就明确拼写这一点是必要的。
- en: Containers and modern DevOps practices
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和现代 DevOps 实践
- en: Containers and modern DevOps practices are highly complementary and have transformed
    how we approach software development and deployment.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和现代 DevOps 实践高度互补，并且已经改变了我们对软件开发和部署的方式。
- en: Containers have a great synergy with modern DevOps practices as they provide
    the necessary infrastructure encapsulation, portability, scalability, and agility
    to enable rapid and efficient software delivery. With modern DevOps practices
    such as CI/CD, IaC, and microservices, containers form a powerful foundation for
    organizations to achieve faster time-to-market, improved software quality, and
    enhanced operational efficiency.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 容器与现代DevOps实践具有很好的协同作用，因为它们提供了必要的基础设施封装、可移植性、可扩展性和灵活性，从而实现快速高效的软件交付。通过现代DevOps实践，如CI/CD、IaC和微服务，容器为组织提供了一个强大的基础，使它们能够实现更快的市场响应时间、提升的软件质量和增强的操作效率。
- en: 'Containers follow DevOps practices right from the start. If you look at a typical
    container build and deployment workflow, this is what you’ll get:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 容器从一开始就遵循DevOps实践。如果你查看典型的容器构建和部署工作流，你将会看到以下内容：
- en: First, code your app in whatever language you wish.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，用你想要的任何语言编写应用程序。
- en: Then, create a **Dockerfile** that contains a series of steps to install the
    application dependencies and environment configuration to run your app.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个**Dockerfile**，其中包含一系列步骤来安装应用程序的依赖项和运行应用所需的环境配置。
- en: 'Next, use the Dockerfile to create container images by doing the following:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过以下操作，使用Dockerfile创建容器镜像：
- en: a) Build the container image.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: a) 构建容器镜像。
- en: b) Run the container image.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: b) 运行容器镜像。
- en: c) Unit test the app running on the container.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: c) 对运行在容器上的应用程序进行单元测试。
- en: Then, push the image to a container registry such as **DockerHub**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将镜像推送到像**DockerHub**这样的容器注册中心。
- en: Finally, create containers from container images and run them in a cluster.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从容器镜像创建容器，并在集群中运行它们。
- en: 'You can embed these steps beautifully in the CI/CD pipeline example shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些步骤优雅地嵌入到下面显示的CI/CD管道示例中：
- en: '![Figure 1.7 – Container CI/CD pipeline example](img/B19877_Figure_1.07.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 容器CI/CD管道示例](img/B19877_Figure_1.07.jpg)'
- en: Figure 1.7 – Container CI/CD pipeline example
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 容器CI/CD管道示例
- en: This means your application and its runtime dependencies are all defined in
    the code. You follow configuration management from the very beginning, allowing
    developers to treat containers like ephemeral workloads (ephemeral workloads are
    temporary workloads that are dispensable, and if one disappears, you can spin
    up another one without it having any functional impact). You can replace them
    if they misbehave – something that was not very elegant with virtual machines.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你的应用程序及其运行时依赖项都在代码中定义。你从一开始就遵循配置管理，允许开发人员像处理短期工作负载一样处理容器（短期工作负载是可以临时替换的工作负载，如果某个工作负载消失了，可以随时启动另一个，而不会对功能产生影响）。如果它们表现不佳，你可以替换它们——这在虚拟机中是不太优雅的做法。
- en: Containers fit very well within modern CI/CD practices as you now have a standard
    way of building and deploying applications, irrespective of the language you code
    in. You don’t have to manage expensive build and deployment software as you get
    everything out of the box with containers.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 容器非常适合现代的CI/CD实践，因为现在你有了一种标准的方式来构建和部署应用程序，无论你使用何种编程语言。你不必管理昂贵的构建和部署软件，因为容器提供了一切。
- en: Containers rarely run on their own, and it is a standard practice in the industry
    to plug them into a container orchestrator such as **Kubernetes** or use a **Container-as-a-Service**
    (**CaaS**) platform such as **AWS ECS** and **EKS**, **Google Cloud Run** and
    **Kubernetes Engine**, **Azure ACS** and **AKS**, **Oracle OCI** and **OKE**,
    and others. Popular **Function-as-a-Service** (**FaaS**) platforms such as **AWS
    Lambda**, **Google Functions**, **Azure Functions**, and **Oracle Functions**
    also run containers in the background. So, though they may have abstracted the
    underlying mechanism from you, you may already be using containers unknowingly.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 容器很少独立运行，在业界，将它们插入到容器编排器中，如**Kubernetes**，或者使用**容器即服务**（**CaaS**）平台，如**AWS ECS**和**EKS**，**Google
    Cloud Run**和**Kubernetes Engine**，**Azure ACS**和**AKS**，**Oracle OCI**和**OKE**等，已经成为行业的标准做法。流行的**功能即服务**（**FaaS**）平台，如**AWS
    Lambda**、**Google Functions**、**Azure Functions**和**Oracle Functions**，也会在后台运行容器。因此，尽管它们可能已经将底层机制抽象化，但你可能已经在不知不觉中使用了容器。
- en: As containers are lightweight, you can build smaller parts of applications into
    containers to manage them independently. Combine that with a container orchestrator
    such as Kubernetes, and you get a distributed microservices architecture running
    with ease. These smaller parts can then scale, auto-heal, and get released independently
    of others, which means you can release them into production quicker than before
    and much more reliably.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器轻量化，你可以将应用程序的更小部分构建成容器，以便独立管理它们。结合像Kubernetes这样的容器编排工具，你就可以轻松运行一个分布式微服务架构。这些小部分可以独立扩展、自我修复，并独立于其他部分发布，这意味着你可以比以前更快、更可靠地将它们发布到生产环境中。
- en: You can also plug in a **service mesh** (infrastructure components that allow
    you to discover, list, manage, and allow communication between multiple components
    (services) of your microservices application) such as **Istio** on top, and you
    will get advanced Ops features such as traffic management, security, and observability
    with ease. You can then do cool stuff such as **blue/green deployments** and **A/B
    testing**, operational tests in production with **traffic mirroring**, **geolocation-based
    routing**, and much more.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在上面接入**服务网格**（允许你发现、列出、管理并使你的微服务应用程序中多个组件（服务）之间进行通信的基础设施组件），比如**Istio**，并轻松获得流量管理、安全性和可观察性等高级运维功能。然后，你可以做一些很酷的事情，如**蓝绿部署**和**A/B测试**，在生产环境中进行操作测试，使用**流量镜像**、**基于地理位置的路由**等，功能丰富。
- en: As a result, large and small enterprises are embracing containers quicker than
    ever, and the field is growing exponentially. According to [businesswire.com](http://businesswire.com),
    the application container market shows a compounded growth of 31% per annum and
    will reach $6.9 billion by 2025\. The exponential growth of 30.3% per annum in
    the cloud, expected to reach over $2.4 billion by 2025, has also contributed to
    this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大型和小型企业比以往任何时候都更快地拥抱容器化，且这一领域正在呈指数级增长。根据[businesswire.com](http://businesswire.com)的数据，应用容器市场年均复合增长率为31%，预计到2025年将达到69亿美元。云计算领域每年增长30.3%，预计到2025年将超过24亿美元，这也促进了容器化的快速发展。
- en: Therefore, modern DevOps engineers must understand containers and the relevant
    technologies to ship and deliver containerized applications effectively. This
    does not mean that virtual machines are unnecessary, and we cannot completely
    ignore the role of IaaS-based solutions in the market, so we will also cover some
    config management with **Ansible** in further chapters. Due to the advent of the
    cloud, IaC has been gaining much momentum recently, so we will also cover **Terraform**
    as an IaC tool.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现代DevOps工程师必须理解容器及相关技术，以有效地交付容器化应用程序。这并不意味着虚拟机变得不再必要，我们不能完全忽视基于IaaS的解决方案在市场中的作用，因此在后续章节中我们还会涉及一些**Ansible**配置管理内容。由于云计算的到来，基础设施即代码（IaC）最近获得了很大的发展势头，因此我们还将介绍作为IaC工具的**Terraform**。
- en: Migrating from virtual machines to containers
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从虚拟机迁移到容器
- en: As we see the technology market moving toward containers, DevOps engineers have
    a crucial task – *migrating applications running on virtual machines so that they
    can run on containers*. Well, this is in most DevOps engineers’ job descriptions
    and is one of the most critical things we do.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 随着技术市场朝着容器化发展，DevOps工程师面临着一个重要任务——*将运行在虚拟机上的应用程序迁移到容器中，以便它们能够在容器上运行*。嗯，这是大多数DevOps工程师职位描述中的一项任务，也是我们做的最重要的事情之一。
- en: While, in theory, containerizing an application is as simple as writing a few
    steps, practically speaking, it can be a complicated beast, especially if you
    are not using config management to set up your virtual machines. Virtual machines
    that run on current enterprises these days were created from a lot of manual labor
    by toiling sysadmins, improving the servers piece by piece, and making it hard
    to reach out to the paper trail of hotfixes they might have made until now.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，容器化一个应用程序就像写几个简单的步骤，但从实际操作来说，它可能是一个复杂的难题，尤其是在没有使用配置管理来设置虚拟机的情况下。当前企业中运行的虚拟机大多是由系统管理员通过大量手动劳动创建的，他们一块一块地改进服务器，并使得很难追溯他们可能做过的热修复记录。
- en: Since containers follow config management principles from the very beginning,
    it is not as simple as picking up the virtual machine image and using a converter
    to convert it into a Docker container.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器从一开始就遵循配置管理原则，因此它不像直接获取虚拟机镜像并使用转换工具将其转换为Docker容器那样简单。
- en: Migrating a legacy application running on virtual machines requires numerous
    steps. Let’s take a look at them in more detail.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将运行在虚拟机上的遗留应用程序迁移需要多个步骤。让我们更详细地了解这些步骤。
- en: Discovery
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现
- en: 'First, we start with the discovery phase:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从发现阶段开始：
- en: Understand the different parts of your applications
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解应用程序的不同部分
- en: Assess what parts of the legacy applications you can containerize and whether
    it is technically possible to do so
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估可以容器化的遗留应用程序部分，并判断是否技术上可行
- en: Define a migration scope and agree on the clear goals and benefits of the migration
    with timelines
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义迁移范围，并与相关方就迁移的明确目标、收益以及时间表达成一致
- en: Application requirement assessment
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序需求评估
- en: 'Once the discovery phase is complete, we need to do the application requirement
    assessment:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发现阶段完成，我们需要进行应用程序需求评估：
- en: Assess if it is a better idea to break the application into smaller parts. If
    so, then what would the application parts be, and how will they interact with
    each other?
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估是否更好地将应用程序拆分为更小的部分。如果是，那么这些应用程序部分是什么，它们如何相互作用？
- en: Assess what aspects of the architecture, its performance, and its security you
    need to cater to regarding your application, and think about the container world’s
    equivalent.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估与应用程序相关的架构、性能和安全性方面，思考在容器化环境中的对应内容。
- en: Understand the relevant risks and decide on mitigation approaches.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解相关风险并决定减轻风险的应对措施。
- en: Understand the migration principle and decide on a migration approach, such
    as what part of the application you should containerize first. Always start with
    the application with the least amount of external dependencies first.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解迁移原则，并决定迁移策略，例如应该首先容器化应用程序的哪一部分。总是从外部依赖最少的应用程序开始。
- en: Container infrastructure design
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器基础设施设计
- en: Container infrastructure design involves creating a robust and scalable environment
    to support the deployment and management of containerized applications.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 容器基础设施设计涉及创建一个稳健且可扩展的环境，以支持容器化应用程序的部署和管理。
- en: Designing a container infrastructure involves considering factors such as scalability,
    networking, storage, security, automation, and monitoring. It’s crucial to align
    the infrastructure design with the specific requirements and goals of the containerized
    applications and to follow best practices for efficient and reliable container
    deployment and management.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 设计容器基础设施涉及考虑可扩展性、网络、安全、自动化和监控等因素。关键是将基础设施设计与容器化应用程序的特定需求和目标对齐，并遵循高效、可靠的容器部署和管理的最佳实践。
- en: 'Once we’ve assessed all our requirements, architecture, and other aspects,
    we can move on to container infrastructure design:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们评估了所有需求、架构及其他方面，我们就可以进入容器基础设施设计阶段：
- en: Understand the current and future scale of operations when you make this decision.
    You can choose from many options based on your application’s complexity. The right
    questions include; how many containers do we need to run on the platform? What
    kind of dependencies do these containers have on each other? How frequently are
    we going to deploy changes to the components? What is the potential traffic the
    application can receive? What is the traffic pattern on the application?
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在做出决策时，了解当前和未来的运营规模。根据应用程序的复杂性，你可以从多种选项中进行选择。关键问题包括：我们需要在平台上运行多少个容器？这些容器之间有哪些依赖关系？我们将多频繁地部署组件更改？应用程序可能会接收到的潜在流量是多少？应用程序的流量模式是什么？
- en: Based on the answers you get to the preceding questions, you need to understand
    what sort of infrastructure you will run your application on. Will it be on-premises
    or the cloud, and will you use a managed Kubernetes cluster or self-host and manage
    one? You can also look at options such as CaaS for lightweight applications.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据前面问题的答案，你需要了解将应用程序运行在哪种基础设施上。是本地部署还是云端，使用托管的Kubernetes集群，还是自行托管并管理？你还可以考虑轻量级应用程序的CaaS选项。
- en: How will you monitor and operate your containers? Will it require installing
    specialist tools? Will it require integrating with the existing monitoring tool
    stack? Understand the feasibility and make an appropriate design decision.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将如何监控和操作容器？是否需要安装专业工具？是否需要与现有监控工具堆栈进行集成？了解可行性并做出适当的设计决策。
- en: How will you secure your containers? Are there any regulatory and compliance
    requirements regarding security? Does the chosen solution cater to them?
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将如何保护你的容器？是否有任何关于安全性的法规和合规要求？所选择的解决方案是否满足这些要求？
- en: Containerizing the application
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化应用程序
- en: Containerizing an application involves packaging the application and its dependencies
    into a container image, which can be deployed and run consistently across different
    environments.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化应用程序包括将应用程序及其依赖项打包成容器镜像，这样可以在不同的环境中一致地部署和运行。
- en: Containerizing an application offers benefits such as improved portability,
    scalability, and reproducibility. It simplifies the deployment process and allows
    for consistent application behavior across different environments.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化应用程序带来了更好的可移植性、可扩展性和可重现性等好处。它简化了部署过程，并确保在不同环境中应用程序行为的一致性。
- en: 'Once we’ve considered all aspects of the design, we can now start containerizing
    the application:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们考虑了设计的所有方面，就可以开始容器化应用程序：
- en: This is where we look into the application and create a Dockerfile containing
    the steps to create the container just as it is currently. This requires a lot
    of brainstorming and assessment, mostly if config management tools don’t build
    your application by running on a virtual machine such as Ansible. It can take
    a long time to figure out how the application was installed, and you need to write
    the exact steps for this.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这时，我们需要查看应用程序并创建一个Dockerfile，包含创建容器的步骤，就像当前一样。这需要大量的头脑风暴和评估，特别是当配置管理工具没有通过在虚拟机上运行来构建你的应用程序时，比如Ansible。如果应用程序是如何安装的需要花费很多时间去弄清楚，那么你就需要编写准确的步骤来实现这一过程。
- en: If you plan to break your application into smaller parts, you may need to build
    your application from scratch.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你计划将应用程序拆分为更小的部分，可能需要从头开始构建应用程序。
- en: You must decide on a test suite that works on your parallel virtual machine-based
    application and improve it over time.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须决定一个适用于基于虚拟机并行应用程序的测试套件，并随着时间推移不断改进。
- en: Testing
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: Testing containerized applications is an important step to ensure their functionality,
    performance, and compatibility.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 测试容器化应用程序是确保其功能、性能和兼容性的重要步骤。
- en: By implementing a comprehensive testing strategy, you can ensure the reliability,
    performance, and security of your containerized application. Testing at various
    levels, integrating automation, and closely monitoring the application’s behavior
    will help you identify and resolve issues early in the development life cycle,
    leading to a more robust and reliable containerized application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施全面的测试策略，你可以确保容器化应用程序的可靠性、性能和安全性。在不同层次进行测试，集成自动化，并密切监控应用程序的行为，将帮助你在开发生命周期的早期识别和解决问题，从而使容器化应用程序更加稳健和可靠。
- en: 'Once we’ve containerized the application, the next step in the process is testing:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们容器化了应用程序，接下来的步骤是进行测试：
- en: To prove whether your containerized application works exactly like the one in
    the virtual machine, you need to do extensive testing to prove that you haven’t
    missed any details or parts you should have considered previously. Run an existing
    test suite or the one you created for the container.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了证明你的容器化应用程序是否与虚拟机中的应用程序完全一样，你需要进行广泛的测试，证明你没有遗漏任何细节或之前应该考虑的部分。运行现有的测试套件或你为容器创建的测试套件。
- en: Running an existing test suite can be the right approach, but you also need
    to consider the software’s non-functional aspects. Benchmarking the original application
    is a good start, and you need to understand the overhead the container solution
    is putting in. You also need to fine-tune your application so that it fits the
    performance metrics.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行现有的测试套件可能是正确的方法，但你也需要考虑软件的非功能性方面。对原始应用程序进行基准测试是一个好的开始，你需要理解容器化解决方案所带来的开销。你还需要对应用程序进行微调，以使其符合性能指标。
- en: You also need to consider the importance of security and how you can bring it
    into the container world. Penetration testing will reveal a lot of security loopholes
    that you might not be aware of.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还需要考虑安全性的重要性以及如何将其引入容器化世界。渗透测试将揭示许多你可能没有意识到的安全漏洞。
- en: Deployment and rollout
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署和发布
- en: Deploying and rolling out a containerized application involves deploying the
    container images to the target environment and making the application available
    for use.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 部署和发布容器化应用程序涉及将容器镜像部署到目标环境，并使应用程序可供使用。
- en: 'Once we’ve tested our containers and are confident enough, we can roll out
    our application to production:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们测试了容器并且足够有信心，我们就可以将我们的应用部署到生产环境中：
- en: Finally, we roll out our application to production and learn from there if further
    changes are needed. We then return to the discovery process until we have perfected
    our application.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将应用部署到生产环境，并从中学习是否需要进一步的修改。然后，我们返回到发现过程，直到我们完善了应用。
- en: You must define and develop an automated runbook and a CI/CD pipeline to reduce
    cycle time and troubleshoot issues quickly.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须定义并开发一个自动化的运行手册和 CI/CD 管道，以减少周期时间并快速排查问题。
- en: Doing A/B testing with the container applications running in parallel can help
    you realize any potential issues before you switch all the traffic to the new
    solution.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行 A/B 测试，容器化应用并行运行，可以帮助你在将所有流量切换到新方案之前发现潜在问题。
- en: 'The following diagram summarizes these steps, and as you can see, this process
    is cyclic. This means that you may have to revisit these steps from time to time
    based on what you learned from the operating containers in production:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表总结了这些步骤，如你所见，这一过程是循环的。这意味着你可能需要根据在生产中运行容器时学到的经验，时不时地重新审视这些步骤：
- en: '![Figure 1.8 – Migrating from virtual machines to containers](img/B19877_Figure_1.08.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 从虚拟机迁移到容器](img/B19877_Figure_1.08.jpg)'
- en: Figure 1.8 – Migrating from virtual machines to containers
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 从虚拟机迁移到容器
- en: Now, let’s understand what we need to do to ensure that we migrate from virtual
    machines to containers with the least friction and also attain the best possible
    outcome.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下为了确保从虚拟机迁移到容器时尽量减少摩擦并获得最佳效果，我们需要做些什么。
- en: What applications should go in containers?
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪些应用应该容器化？
- en: In your journey of moving from virtual machines to containers, you first need
    to assess what can and can’t go in containers. Broadly speaking, there are two
    kinds of application workloads you can have – **stateless** and **stateful**.
    While stateless workloads do not store state and are computing powerhouses, such
    as APIs and functions, stateful applications, such as databases, require persistent
    storage to function.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在从虚拟机迁移到容器的过程中，首先需要评估哪些应用可以容器化，哪些不能。广义上讲，你的应用工作负载可以分为两种类型——**无状态**和**有状态**。无状态工作负载不存储状态，是计算能力强大的应用，如
    API 和函数；而有状态应用，如数据库，则需要持久化存储才能正常工作。
- en: Though it is possible to containerize any application that can run on a Linux
    virtual machine, stateless applications become the first low-hanging fruits you
    may want to look at. It is relatively easy to containerize these workloads because
    they don’t have storage dependencies. The more storage dependencies you have,
    the more complex your application becomes in containers.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何可以在 Linux 虚拟机上运行的应用都可以容器化，但无状态应用通常是你首先要考虑的低悬果。容器化这些工作负载相对容易，因为它们没有存储依赖。你拥有的存储依赖越多，应用在容器中的复杂性就越高。
- en: Secondly, you also need to assess the form of infrastructure you want to host
    your applications on. For example, if you plan to run your entire tech stack on
    Kubernetes, you would like to avoid a heterogeneous environment wherever possible.
    In that scenario, you may also wish to containerize stateful applications. With
    web services and the middleware layer, most applications rely on some form of
    state to function correctly. So, in any case, you would end up managing storage.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你还需要评估你想要托管应用的基础设施形式。例如，如果你打算在 Kubernetes 上运行整个技术栈，尽量避免异构环境。在这种情况下，你可能也希望容器化有状态应用。对于
    Web 服务和中间件层，大多数应用依赖某种形式的状态才能正确运行。所以，无论如何，你都会管理存储。
- en: Though this might open up Pandora’s box, there is no standard agreement within
    the industry regarding containerizing databases. While some experts are naysayers
    for its use in production, a sizeable population sees no issues. The primary reason
    is insufficient data to support or disprove using a containerized database in
    production.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能会打开潘多拉的盒子，但业内并没有达成共识关于是否将数据库容器化。虽然一些专家反对在生产环境中使用容器化数据库，但也有相当一部分人认为没有问题。主要原因是缺乏足够的数据来支持或反驳在生产环境中使用容器化数据库。
- en: I suggest that you proceed with caution regarding databases. While I am not
    opposed to containerizing databases, you must consider various factors, such as
    allocating proper memory, CPU, disk, and every dependency you have on virtual
    machines. Also, it would help if you looked into the behavioral aspects of the
    team. If you have a team of DBAs managing the database within production, they
    might not be very comfortable dealing with another layer of complexity – containers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在处理数据库时要小心。虽然我并不反对将数据库容器化，但你必须考虑各种因素，如分配适当的内存、CPU、磁盘，以及你在虚拟机上的每个依赖关系。此外，你还需要关注团队的行为方面。如果你有一支管理生产环境中数据库的
    DBAs 团队，他们可能不太愿意处理额外的复杂性——即容器。
- en: 'We can summarize these high-level assessment steps using the following flowchart:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下流程图总结这些高层次的评估步骤：
- en: '![Figure 1.9 – Virtual machine to container migration assessment](img/B19877_Figure_1.09.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.9 – 虚拟机到容器迁移评估](img/B19877_Figure_1.09.jpg)'
- en: Figure 1.9 – Virtual machine to container migration assessment
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 虚拟机到容器迁移评估
- en: This flowchart accounts for the most common factors that are considered during
    the assessment. You also need to factor in situations that are unique to your
    organization. So, it is a good idea to take those into account as well before
    making any decisions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程图考虑了评估过程中最常见的因素。你还需要考虑到属于你组织的独特情况。因此，在做出任何决定之前，最好也考虑这些因素。
- en: 'Let’s look at some use cases that are suitable for containerization to get
    a fair understanding. The following types of applications are commonly deployed
    using containers:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些适合容器化的用例，以便更好地理解。以下类型的应用程序通常使用容器进行部署：
- en: '**Microservices architecture**: Applications that follow a microservices architecture,
    where the functionality is divided into small, independent services, are well-suited
    for containerization. Each microservice can be packaged as a separate container,
    enabling easier development, deployment, scaling, and management of the individual
    services.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**微服务架构**：采用微服务架构的应用程序，其中功能被分割成小的、独立的服务，非常适合容器化。每个微服务可以作为一个独立的容器进行打包，从而简化了个别服务的开发、部署、扩展和管理。'
- en: '**Web applications**: Web applications, including frontend applications, backend
    APIs, and web services, can be containerized. Containers provide a consistent
    runtime environment, making it easier to package and deploy web applications across
    different environments, such as development, testing, and production.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Web 应用**：Web 应用程序，包括前端应用、后端 API 和 Web 服务，可以容器化。容器提供了一致的运行环境，使得在不同环境（如开发、测试和生产）中打包和部署
    Web 应用变得更加容易。'
- en: '**Stateful applications**: Containers can also be used to run stateful applications
    that require persistent data storage. By leveraging container orchestration platforms’
    features, such as persistent volumes or stateful sets, stateful applications such
    as databases, content management systems, or file servers can be containerized
    and managed effectively.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有状态应用**：容器也可以用于运行需要持久数据存储的有状态应用。通过利用容器编排平台的功能，如持久卷或有状态集，有状态应用程序（如数据库、内容管理系统或文件服务器）可以被容器化并有效管理。'
- en: '**Batch processing or scheduled jobs**: Applications that perform batch processing
    tasks or scheduled jobs, such as data processing, periodic backups, or report
    generation, can benefit from containerization. Containers provide a controlled
    and isolated environment for running these jobs, ensuring consistent execution
    and reproducibility.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理或定时任务**：执行批处理任务或定时任务的应用程序，如数据处理、定期备份或报告生成，可以从容器化中受益。容器为这些任务提供了一个受控和隔离的环境，确保一致的执行和可重现性。'
- en: '**CI/CD tools**: Containerizing CI/CD tools such as Jenkins, GitLab CI/CD,
    or CircleCI allows for consistent and reproducible build, test, and deployment
    pipelines. Containers make it easier to manage dependencies, isolate build environments,
    and enable rapid deployment of CI/CD infrastructure.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI/CD 工具**：将 Jenkins、GitLab CI/CD 或 CircleCI 等 CI/CD 工具容器化，可以实现一致和可重现的构建、测试和部署流水线。容器简化了依赖关系的管理、构建环境的隔离，并能够快速部署
    CI/CD 基础设施。'
- en: '**Development and testing environments**: Containers are valuable for creating
    isolated and reproducible development and testing environments. Developers can
    use containers to package their applications along with the required dependencies,
    libraries, and development tools. This enables consistent development and testing
    experiences across different machines and team members.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发和测试环境**：容器对于创建隔离的、可重复的开发和测试环境非常有价值。开发人员可以使用容器将他们的应用及所需的依赖、库和开发工具一起打包，这样可以确保在不同机器和团队成员之间拥有一致的开发和测试体验。'
- en: '**Internet of Things** (**IoT**) **applications**: Containers can be used to
    deploy and manage applications in IoT scenarios. They provide lightweight and
    portable runtime environments for IoT applications, enabling easy deployment across
    edge devices, gateways, or cloud infrastructures.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物联网**（**IoT**）**应用**：容器可以用于在物联网场景中部署和管理应用程序。它们为物联网应用提供轻量级、便捷的运行环境，使得应用可以在边缘设备、网关或云基础设施上轻松部署。'
- en: '**Machine learning and data analytics applications**: Containerization is increasingly
    used to deploy machine learning models and data science applications. Containers
    encapsulate the necessary dependencies, libraries, and runtime environments, allowing
    for seamless deployment and scaling of data-intensive applications.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机器学习和数据分析应用**：容器化在部署机器学习模型和数据科学应用方面的应用日益增多。容器封装了所需的依赖、库和运行时环境，从而实现数据密集型应用的无缝部署和扩展。'
- en: It’s important to note that not all applications are ideal candidates for containerization.
    Applications with heavy graphical interfaces, legacy monolithic architectures
    tightly coupled to the underlying infrastructure, or applications that require
    direct hardware access may not be suitable for containerization. Virtual machines
    or other deployment approaches may be more appropriate in such cases.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意，并非所有应用都适合容器化。具有复杂图形界面的应用、与底层基础设施紧密耦合的遗留单体架构，或者需要直接访问硬件的应用可能不适合容器化。在这种情况下，虚拟机或其他部署方法可能更为合适。
- en: Breaking the applications into smaller pieces
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将应用拆分成更小的部分
- en: You get the most out of containers if you run parts of your application independently
    of others.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将应用的各个部分独立运行，你将最大限度地发挥容器的优势。
- en: 'This approach has numerous benefits, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法具有许多好处，具体如下：
- en: You can release your application more often as you can now change a part of
    your application without this impacting something else; your deployments will
    also take less time to run.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于你现在可以在不影响其他部分的情况下更改应用的某一部分，你可以更频繁地发布应用；你的部署也将花费更少的时间来运行。
- en: Your application parts can scale independently of each other. For example, if
    you have a shopping app and your *orders* module is jam-packed, it can scale more
    than the *reviews* module, which may be far less busy. With a monolith, your entire
    application would scale with traffic, and this would not be the most optimized
    approach from a resource consumption point of view.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的应用部分可以独立扩展。例如，如果你有一个购物应用，而你的*订单*模块非常繁忙，它可以比*评论*模块扩展得更多，因为后者的繁忙程度可能远低于前者。如果是单体应用，整个应用会随着流量一起扩展，这从资源消耗的角度来看并不是最优方案。
- en: Something that impacts one part of the application does not compromise your
    entire system. For example, customers can still add items to their cart and check
    out orders if the *reviews* module is down.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 影响应用某一部分的变化不会破坏整个系统。例如，如果*评论*模块出现故障，顾客仍然可以将商品添加到购物车并结算订单。
- en: However, you should also not break your application into tiny components. This
    will result in considerable management overhead as you will not be able to distinguish
    between what is what. In terms of the shopping website example, it is OK to have
    an *order* container, a *reviews* container, a *shopping cart* container, and
    a *catalog* container. However, it is not OK to have *create order*, *delete order*,
    and *update order* containers. That would be overkill. Breaking your application
    into logical components that fit your business is the right way.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你也不应将你的应用拆分成过小的组件。这将导致相当大的管理开销，因为你将无法区分各个组件的作用。以购物网站为例，拥有一个*订单*容器，一个*评论*容器，一个*购物车*容器和一个*目录*容器是可以的。然而，拥有*创建订单*、*删除订单*和*更新订单*容器则不合适，这会显得过于繁琐。将应用拆分成符合你业务逻辑的组件才是正确的方法。
- en: But should you break your application into smaller parts as the very first step?
    Well, it depends. Most people will want to get a **return on investment** (**ROI**)
    out of their containerization work. Suppose you do a lift and shift from virtual
    machines to containers, even though you are dealing with very few variables, and
    you can go into containers quickly. In that case, you don’t get any benefits out
    of it – especially if your application is a massive monolith. Instead, you would
    add some application overhead because of the container layer. So, rearchitecting
    your application to fit in the container landscape is the key to going ahead.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 但你应该在第一步就将应用程序拆分成更小的部分吗？嗯，这取决于情况。大多数人都希望从容器化工作中获得**投资回报**（**ROI**）。假设你从虚拟机迁移到容器，尽管你面临的变量很少，而且可以快速进入容器。那样的话，你不会从中获得任何好处——尤其是当你的应用程序是一个庞大的单体时。相反，由于容器层的存在，你会增加一些应用程序的开销。所以，将应用程序重新架构以适应容器化环境是继续前进的关键。
- en: Are we there yet?
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们到了吗？
- en: So, you might be wondering, are we there yet? Not really! Virtual machines are
    to stay for a very long time. They have a good reason to exist, and while containers
    solve most problems, not everything can be containerized. Many legacy systems
    are running on virtual machines that cannot be migrated to containers.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可能会想，我们到了吗？其实还没有！虚拟机将长期存在。它们有存在的充分理由，虽然容器解决了大部分问题，但并不是所有事情都能容器化。许多遗留系统运行在无法迁移到容器上的虚拟机中。
- en: With the advent of the cloud, *virtualized infrastructure* forms its base, and
    virtual machines are at its core. Most containers run on virtual machines within
    the cloud, and though you might be running containers in a cluster of nodes, these
    nodes would still be virtual machines.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 随着云计算的到来，*虚拟化基础设施*成为其基础，虚拟机处于核心地位。大多数容器在云中的虚拟机上运行，尽管你可能在一组节点中运行容器，但这些节点仍然是虚拟机。
- en: However, the best thing about the container era is that it sees virtual machines
    as part of a standard setup. You install a container runtime on your virtual machines
    and do not need to distinguish between them. You can run your applications within
    containers on any virtual machine you wish. With a container orchestrator such
    as *Kubernetes*, you also benefit from the orchestrator deciding where to run
    the containers while considering various factors – resource availability is among
    the most critical.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，容器时代最棒的一点是，它将虚拟机视为标准设置的一部分。你只需在虚拟机上安装容器运行时，便无需区分它们。你可以在任何你希望的虚拟机上运行容器内的应用程序。使用像*Kubernetes*这样的容器编排工具，你还可以受益于编排工具在考虑各种因素的情况下决定容器的运行位置——资源可用性是其中最关键的因素之一。
- en: This book will look at various aspects of modern DevOps practices, including
    managing cloud-based infrastructure, virtual machines, and containers. While we
    will mainly cover containers, we will also look at config management with equal
    importance using Ansible and learn how to spin up infrastructure with Terraform.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将探讨现代DevOps实践的各个方面，包括管理基于云的基础设施、虚拟机和容器。虽然我们主要讨论容器，但我们也会同样重视使用Ansible进行配置管理，并学习如何使用Terraform快速部署基础设施。
- en: We will also look into modern CI/CD practices and learn how to deliver an application
    into production efficiently and error-free. For this, we will cover tools such
    as **Jenkins** and **Argo CD**. This book will give you everything you need to
    undertake a modern DevOps engineer role in the cloud and container era.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨现代CI/CD实践，并学习如何高效、无误地将应用程序交付到生产环境中。为此，我们将介绍**Jenkins**和**Argo CD**等工具。本书将为你提供在云和容器时代担任现代DevOps工程师角色所需的一切知识。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we understood modern DevOps, the cloud, and modern cloud-native
    applications. We then looked at how the software industry is quickly moving toward
    containers and how, with the cloud, it is becoming more critical for a modern
    DevOps engineer to have the required skills to deal with both. Then, we took a
    peek at the container architecture and discussed some high-level steps in moving
    from a virtual machine-based architecture to a containerized one.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了现代DevOps、云计算和现代云原生应用程序。接着，我们探讨了软件行业如何迅速转向容器，并讨论了随着云计算的发展，现代DevOps工程师必须掌握的技能，以应对容器和云的挑战。然后，我们简要了解了容器架构，并讨论了从基于虚拟机的架构迁移到容器化架构的一些高层步骤。
- en: In the next chapter, we will look at source code management with **Git**, which
    will form the base of everything we will do in the rest of this book.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用**Git**进行源代码管理，这将构成本书其余部分的基础。
- en: Questions
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章的知识：
- en: Cloud computing is more expensive than on-premises. (True/False)
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云计算比本地部署更贵。 (正确/错误)
- en: Cloud computing requires more **Capital** **Expenditure** (**CapEx**) than **Operating
    Expenditure** (**OpEx**). (True/False)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云计算比**资本支出**（**CapEx**）需要更多的**运营支出**（**OpEx**）。 (正确/错误)
- en: Which of the following is true about cloud-native applications? (Choose three)
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项关于云原生应用程序的说法是正确的？（选择三项）
- en: A. They typically follow the microservices architecture
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: A. 它们通常遵循微服务架构
- en: B. They are typically monoliths
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: B. 它们通常是单体的
- en: C. They use containers
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: C. 它们使用容器
- en: D. They use dynamic orchestration
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: D. 它们使用动态编排
- en: E. They use on-premises databases
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: E. 它们使用本地数据库
- en: Containers need a hypervisor to run. (True/False)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器需要虚拟机管理程序才能运行。 (正确/错误)
- en: Which of the following statements regarding containers is *not* correct? (Choose
    one)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项关于容器的说法是*不*正确的？（选择一项）
- en: A. Containers are virtual machines within virtual machines
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: A. 容器是虚拟机中的虚拟机
- en: B. Containers are simple OS processes
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: B. 容器是简单的操作系统进程
- en: C. Containers use cgroups to provide isolation
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: C. 容器使用cgroups提供隔离
- en: D. Containers use a container runtime
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: D. 容器使用容器运行时
- en: E. A container is an ephemeral workload
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: E. 容器是短暂的工作负载
- en: All applications can be containerized. (True/False)
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有应用程序都可以容器化。 (正确/错误)
- en: Which of the following is a container runtime? (Choose two)
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是容器运行时？（选择两项）
- en: A. Docker
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: A. Docker
- en: B. Kubernetes
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: B. Kubernetes
- en: C. Containerd
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: C. Containerd
- en: D. Docker Swarm
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: D. Docker Swarm
- en: What kind of applications should you choose to containerize first?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该选择容器化哪种类型的应用程序？
- en: A. APIs
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: A. APIs
- en: B. Databases
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: B. 数据库
- en: C. Mainframes
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: C. 大型机
- en: Containers follow CI/CD principles out of the box. (True/False)
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器原生支持CI/CD原则。 (正确/错误)
- en: Which of the following is an advantage of breaking your applications into multiple
    parts? (Choose four)
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是将应用程序拆分成多个部分的优点？（选择四项）
- en: A. Fault isolation
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: A. 故障隔离
- en: B. Shorter release cycle time
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: B. 更短的发布周期
- en: C. Independent, fine-grained scaling
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: C. 独立的、细粒度的扩展
- en: D. Application architecture simplicity
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: D. 应用架构简单性
- en: E. Simpler infrastructure
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: E. 更简单的基础设施
- en: While breaking an application into microservices, which aspect should you consider?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将应用程序拆分为微服务时，应该考虑哪个方面？
- en: A. Breaking applications into as many tiny components as possible
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: A. 将应用程序拆分成尽可能多的小组件
- en: B. Breaking applications into logical components
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: B. 将应用程序拆分成逻辑组件
- en: What kind of application should you containerize first?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该首先容器化哪种类型的应用程序？
- en: A. Stateless
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: A. 无状态
- en: B. Stateful
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: B. 有状态
- en: Which of the following are examples of CaaS? (Choose three)
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是CaaS的示例？（选择三项）
- en: A. Azure Functions
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: A. Azure Functions
- en: B. Google Cloud Run
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: B. Google Cloud Run
- en: C. Amazon ECS
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: C. Amazon ECS
- en: D. Azure ACS
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: D. Azure ACS
- en: E. Oracle Functions
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: E. Oracle Functions
- en: Answers
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'False'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 'False'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: A, C, D
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, C, D
- en: 'False'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: A
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: 'False'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: A, C
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, C
- en: A
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: 'True'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: A, B, C, E
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B, C, E
- en: B
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: A
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B, C, D
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B, C, D
