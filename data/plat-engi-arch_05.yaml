- en: <st c="0">5</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">5</st>
- en: <st c="2">Integration, Delivery, and Deployment – Automation is Ubiquitous</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">集成、交付和部署 — 自动化无处不在</st>
- en: '[*<st c="66">Chapter 2</st>*](B31164_02.xhtml#_idTextAnchor055) <st c="76">included
    a reference architecture of a platform highlighting layers such as</st> *<st c="153">Developer
    Experience</st>*<st c="173">,</st> *<st c="175">Automation and Orchestration</st>*<st
    c="203">, and</st> *<st c="209">Observability Plane</st>*<st c="228">.</st> [*<st
    c="230">Chapter 3</st>*](B31164_03.xhtml#_idTextAnchor133) <st c="239">ended with
    a different perspective on this reference architecture using a top-down approach
    from</st> *<st c="337">Purpose</st>*<st c="344">,</st> *<st c="346">User Interface</st>*<st
    c="360">,</st> *<st c="362">Core Platform Components</st>*<st c="386">,</st> *<st
    c="388">Platform as a Product</st>*<st c="409">, and</st> *<st c="415">Success
    KPIs</st>*<st c="427">.</st>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[*<st c="66">第 2 章</st>*](B31164_02.xhtml#_idTextAnchor055) <st c="76">包括了一个平台的参考架构，突出了诸如</st>
    *<st c="153">开发者体验</st>*<st c="173">、</st> *<st c="175">自动化与编排</st>*<st c="203">和</st>
    *<st c="209">可观察性平面</st>*<st c="228">等层次。</st> [*<st c="230">第 3 章</st>*](B31164_03.xhtml#_idTextAnchor133)
    <st c="239">从一个不同的角度结束了该参考架构，采用自上而下的方法，从</st> *<st c="337">目的</st>*<st c="344">、</st>
    *<st c="346">用户界面</st>*<st c="360">、</st> *<st c="362">核心平台组件</st>*<st c="386">、</st>
    *<st c="388">平台作为产品</st>*<st c="409">以及</st> *<st c="415">成功的 KPI</st>*<st c="427">等方面进行了阐述。</st>'
- en: <st c="428">Most platforms are built with the purpose of making it easier for
    development teams to ship software without having to deal with all the complexity
    around building, deploying, testing, validating, securing, operating, releasing,
    or scaling software.</st> <st c="679">In this chapter, we will dive into those
    layers and components of our platform so we understand how we can centralize and
    automate the expertise it takes to ship software and provide it as</st> <st c="868">a
    self-service.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="428">大多数平台的构建目的是为了使开发团队能够更容易地发布软件，而无需处理构建、部署、测试、验证、安全、操作、发布或扩展软件的复杂性。</st>
    <st c="679">在本章中，我们将深入探讨平台的各个层次和组件，以便理解如何集中化并自动化发布软件所需的专业知识，并将其提供为</st> <st c="868">自助服务。</st>
- en: <st c="883">By the end of this chapter, we will have learned how to define an
    end-to-end release process for software artifacts, align the</st> **<st c="1011">continuous
    integration / continuous deployment</st>** <st c="1057">(</st>**<st c="1059">CI/CD</st>**<st
    c="1064">) process with the artifact life cycle phases, automate the phases using
    tools for CI, CD, and continuous release, integrate those tools into your existing
    process, observe the automation, and scale through</st> <st c="1272">an IDP.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="883">在本章结束时，我们将学习如何为软件制品定义端到端的发布过程，将</st> **<st c="1011">持续集成/持续部署</st>**
    <st c="1057">(</st>**<st c="1059">CI/CD</st>**<st c="1064">)过程与制品生命周期阶段对齐，使用 CI、CD
    和持续发布工具自动化这些阶段，将这些工具集成到现有流程中，观察自动化效果，并通过</st> <st c="1272">IDP 实现扩展。</st>
- en: <st c="1279">As such, we will cover the following main topics in</st> <st c="1332">the
    chapter:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1279">因此，我们将在本章中覆盖以下主要内容：</st>
- en: <st c="1344">An introduction to</st> <st c="1364">Continuous X</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1344">介绍</st> <st c="1364">持续 X</st>
- en: '<st c="1376">GitOps: Moving from pushing to pulling the</st> <st c="1420">desired
    state</st>'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1376">GitOps：从推动到拉取期望状态</st>
- en: <st c="1433">Understanding the importance of container and artifact registries
    as</st> <st c="1503">entry points</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1433">理解容器和制品注册表的重要性，作为</st> <st c="1503">入口点</st>
- en: <st c="1515">Defining the release process</st> <st c="1545">and management</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1515">定义发布过程</st> <st c="1545">和管理</st>
- en: <st c="1559">Achieving sustainable CI/CD for DevOps – application life</st>
    <st c="1618">cycle orchestration</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1559">实现可持续的 CI/CD 流程用于 DevOps — 应用生命周期编排</st>
- en: '**<st c="1637">Internal Developer Platforms</st>** <st c="1666">(</st>**<st
    c="1668">IDPs</st>**<st c="1672">) – the automation Kraken in</st> <st c="1702">the
    platform</st>'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="1637">内部开发者平台</st>** <st c="1666">(</st>**<st c="1668">IDP</st>**<st
    c="1672">) — 平台中的自动化巨兽</st>'
- en: <st c="1714">An introduction to Continuous X</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1714">持续 X 介绍</st>
- en: <st c="1746">If this is the first time you are hearing</st> <st c="1789">about</st>
    **<st c="1795">Continuous Integration</st>** <st c="1817">(</st>**<st c="1819">CI</st>**<st
    c="1821">) or</st> **<st c="1827">Continuous Delivery</st>** <st c="1846">(</st>**<st
    c="1848">CD</st>**<st c="1850">), then we suggest checking out some of the great
    literature that</st> <st c="1916">exists on these basic concepts.</st> *<st c="1949">Jez
    Humble</st>* <st c="1959">is the maintainer of</st> [<st c="1981">https://continuousdelivery.com/</st>](https://continuousdelivery.com/)
    <st c="2012">and has co-authored the original</st> *<st c="2046">Continuous Delivery</st>*
    <st c="2065">book with</st> *<st c="2076">Dave Farley</st>*<st c="2087">. If you
    need a crash course on this topic, then please have a look at their material.</st>
    <st c="2174">There are also several recorded talks that give a great overview,
    such as the one titled</st> *<st c="2263">Continuous Delivery Sounds Great But
    It Won’t Work</st>* *<st c="2314">Here</st>*<st c="2318">:</st> [<st c="2321">https://vimeo.com/193849732</st>](https://vimeo.com/193849732)<st
    c="2348">.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1746">如果这是你第一次听说</st> <st c="1789">关于</st> **<st c="1795">持续集成</st>**
    <st c="1817">(</st>**<st c="1819">CI</st>**<st c="1821">) 或</st> **<st c="1827">持续交付</st>**
    <st c="1846">(</st>**<st c="1848">CD</st>**<st c="1850">)，那么我们建议你查看一些关于这些基本概念的优秀文献。</st>
    *<st c="1949">Jez Humble</st>* <st c="1959">是</st> [<st c="1981">https://continuousdelivery.com/</st>](https://continuousdelivery.com/)
    <st c="2012">的维护者，并且是</st> *<st c="2046">《持续交付》</st>* <st c="2065">一书的共同作者，</st>
    *<st c="2076">Dave Farley</st>*<st c="2087">。如果你需要这个主题的速成课程，请查看他们的资料。</st> <st
    c="2174">也有一些录制的讲座，提供了很好的概述，比如题为</st> *<st c="2263">持续交付听起来很棒，但它行不通</st>* *<st
    c="2314">这里</st>*<st c="2318">：</st> [<st c="2321">https://vimeo.com/193849732</st>](https://vimeo.com/193849732)<st
    c="2348">。</st>
- en: <st c="2349">So that we all have the same common understanding, let us quickly
    recap what the building blocks are and why this is important in</st> <st c="2480">software
    delivery</st><st c="2497">.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2349">为了确保我们有相同的理解，让我们快速回顾一下构建模块是什么以及为什么它在</st> <st c="2480">软件交付</st><st
    c="2497">中很重要。</st>
- en: <st c="2498">High-level definition of Continuous X</st>
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="2498">持续 X 的高层次定义</st>
- en: '<st c="2536">The</st> <st c="2540">basic foundation of automating software
    delivery is to have proper</st> *<st c="2608">configuration management</st>* <st
    c="2632">of all assets required to build, deploy, validate, operate, and scale
    our systems: code, tests, deployment and infrastructure definitions, dependencies,
    observability, ownership, and more.</st> <st c="2822">Putting all those assets
    into version control allows us to generate repeatable and reliable output, gives
    us auditability, allows us to revert breaking changes, and gives us disaster</st>
    <st c="3005">recovery capabilities.</st>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2536">自动化软件交付的</st> <st c="2540">基本基础是正确的</st> *<st c="2608">配置管理</st>*
    <st c="2632">，包括构建、部署、验证、操作和扩展我们系统所需的所有资产：代码、测试、部署和基础设施定义、依赖关系、可观测性、所有权等。</st>
    <st c="2822">将所有这些资产放入版本控制中，可以生成可重复且可靠的输出，提供审计能力，允许我们回滚破坏性更改，并提供灾难</st> <st c="3005">恢复能力。</st>
- en: <st c="3027">Git, or any</st> <st c="3039">type of Git flavor, is most likely
    what can be found today in software organizations for version control.</st> <st
    c="3146">Depending on the Git solution you use, you will see additional built-in
    capabilities such as cross-team collaboration (issue tracking, resolving merge
    conflicts, etc.), automation (commit checks, delivery pipelines, etc.), or reporting
    (efficiency or</st> <st c="3397">DORA metrics).</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3027">Git，或任何</st> <st c="3039">类型的 Git 版本，今天最有可能在软件组织中用于版本控制。</st> <st
    c="3146">根据你使用的 Git 解决方案，你将看到额外的内建功能，如跨团队协作（问题跟踪、解决合并冲突等）、自动化（提交检查、交付流水线等）或报告（效率或</st>
    <st c="3397">DORA 指标）。</st>
- en: <st c="3411">Now that we have established the foundation, let’s dive into</st>
    <st c="3473">Continuous</st> <st c="3483">X.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3411">现在我们已经建立了基础，让我们深入探讨</st> <st c="3473">持续</st> <st c="3483">X。</st>
- en: <st c="3486">CI</st>
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="3486">CI</st>
- en: '**<st c="3489">CI</st>** <st c="3492">is the</st> <st c="3499">practice that
    emphasizes frequent and automated integration of code changes into a shared repository.</st>
    <st c="3602">When multiple developers work on the same code base, it’s important
    to bring those changes together frequently to validate that the code integrates
    well and produces an artifact (a container image, a binary) that can be deployed
    into an environment.</st> <st c="3852">Key aspects of CI include</st> <st c="3878">the
    following:</st>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="3489">持续集成</st>** <st c="3492">是</st> <st c="3499">一种强调频繁和自动化地将代码变更集成到共享代码库中的实践。</st>
    <st c="3602">当多个开发人员在同一个代码库上工作时，定期将这些变更合并非常重要，以验证代码是否能良好集成，并生成可以部署到环境中的工件（如容器镜像或二进制文件）。</st>
    <st c="3852">持续集成的关键方面包括</st> <st c="3878">以下内容：</st>'
- en: '**<st c="3892">Automated builds</st>**<st c="3909">: Code</st> <st c="3916">commits
    in version</st> <st c="3935">control trigger an automated build process that compiles,
    runs tests, and</st> <st c="4010">generates artifacts</st>'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3892">自动化构建</st>**<st c="3909">：代码</st> <st c="3916">提交到版本控制系统时，会触发一个自动化构建过程，该过程会编译代码、运行测试，并且</st>
    <st c="4010">生成工件</st>'
- en: '**<st c="4029">Test automation</st>**<st c="4045">: Unit tests, integration
    tests, and other checks are executed during the build</st> <st c="4126">process</st>
    <st c="4134">marking the build broken if any tests</st> <st c="4172">should fail</st>'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4029">测试自动化</st>**<st c="4045">：单元测试、集成测试以及其他检查会在构建</st> <st c="4126">过程中执行</st>
    <st c="4134">如果有任何测试失败，构建会被标记为失败</st> <st c="4172">。</st>'
- en: '**<st c="4183">Feedback loop</st>**<st c="4197">: This provides</st> <st c="4214">rapid
    feedback to</st> <st c="4232">developers to quickly fix issues, leading to overall
    higher code quality</st> <st c="4305">and</st> <st c="4308">stability</st>'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4183">反馈回路</st>**<st c="4197">：这为</st> <st c="4214">开发人员提供了快速反馈，以便快速修复问题，从而提高整体代码质量</st>
    <st c="4232">和</st> <st c="4305">稳定性</st>'
- en: <st c="4318">Continuous testing and validation of observability</st>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="4318">持续测试和可观察性的验证</st>
- en: <st c="4369">While CI already highlights the</st> <st c="4401">importance of
    automated unit and integration tests, we want to stress the fact that more automated
    testing and validation early in the life cycle will result in better quality and
    stability.</st> <st c="4593">Assuming the built software provides REST APIs or
    a UI, basic validation against those interfaces should be done to validate the
    accurate functionality (e.g, do APIs return proper responses, are the correct
    HTTP status codes used when testing with invalidated parameters, are there any
    timeouts in API calls, or are any HTTP</st> <st c="4918">errors returned?).</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4369">尽管持续集成已经强调了</st> <st c="4401">自动化单元测试和集成测试的重要性，但我们要强调的是，在生命周期早期进行更多自动化测试和验证，将带来更好的质量和稳定性。</st>
    <st c="4593">假设构建的软件提供了REST API或UI接口，应该针对这些接口进行基本验证，以确保功能的准确性（例如，API是否返回正确的响应，使用无效参数时是否返回正确的HTTP状态码，API调用是否有超时，或是否返回任何HTTP</st>
    <st c="4918">错误？）</st>
- en: '**<st c="4936">Observability</st>** <st c="4950">is essential</st> <st c="4964">to
    validate if systems are healthy and provides the data to troubleshoot problems
    faster.</st> <st c="5054">As part of the continuous validation</st> <st c="5090">process,
    we must validate that the tested build is producing valid and expected observability
    data.</st> <st c="5191">We should validate that all expected metrics, logs, or
    traces are produced and that there is no obvious anomaly or outlier present after
    running those basic unit, integration, or</st> <st c="5370">API tests.</st>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="4936">可观察性</st>** <st c="4950">对验证系统健康至关重要</st> <st c="4964">，并提供了更快排查问题所需的数据。</st>
    <st c="5054">作为持续验证</st> <st c="5090">过程的一部分，我们必须验证已测试的构建是否生成有效且预期的可观察性数据。</st>
    <st c="5191">我们应该验证是否生成了所有预期的指标、日志或跟踪数据，并且在运行这些基本的单元测试、集成测试或</st> <st c="5370">API测试后，是否没有明显的异常或离群值。</st>'
- en: <st c="5380">We have been stressing that</st> <st c="5409">observability has
    to be a non-functional requirement of modern software.</st> <st c="5482">This
    is why the CI should already validate if the expected data is produced.</st> <st
    c="5559">If not, then this is just like a failing unit or integration test and
    you should mark the build</st> <st c="5655">as broken!</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5380">我们一直在强调，</st> <st c="5409">可观察性必须是现代软件的非功能性要求。</st> <st c="5482">这就是为什么持续集成应该验证是否生成了预期的数据。</st>
    <st c="5559">如果没有，那么这就像是一个失败的单元或集成测试，你应该将构建</st> <st c="5655">标记为失败！</st>
- en: <st c="5665">For Financial One ACME and its critical financial services, we
    should validate</st> <st c="5745">the following:</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5665">对于 Financial One ACME 及其关键财务服务，我们应验证</st> <st c="5745">以下内容：</st>
- en: <st c="5759">Will the API properly validate the access control of the caller
    (e.g., not be able to query financial data from</st> <st c="5872">other users)?</st>
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="5759">API 是否能正确验证调用者的访问控制（例如，不能查询</st> <st c="5872">其他用户的财务数据）？</st>
- en: <st c="5885">Will the API not log any confidential data, such as credit card
    numbers, usernames,</st> <st c="5970">or tokens?</st>
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="5885">API 是否不会记录任何机密数据，如信用卡号、用户名</st> <st c="5970">或令牌？</st>
- en: <st c="5980">Will the API properly generate metrics for failed attempts so this
    can be used in production to alert on potential</st> <st c="6095">hack attacks?</st>
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="5980">API 是否能正确生成失败尝试的指标，以便在生产中用于警报潜在的</st> <st c="6095">黑客攻击？</st>
- en: <st c="6109">Continuous delivery</st>
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="6109">持续交付</st>
- en: <st c="6129">As defined on the continuous delivery site (</st>[<st c="6174">https://continuousdelivery.com/</st>](https://continuousdelivery.com/)<st
    c="6206">), “</st>*<st c="6211">Continuous Delivery is the ability to get changes
    of all types—including new features, configuration changes, bug fixes and experiments—into
    production, or into the hands of users, safely and quickly in a sustainable way</st>*<st
    c="6432">.” The goal is to take the fear of failure out of</st> <st c="6482">deployments.</st>
    <st c="6495">Instead of infrequent big bang releases, deployments should become
    routine as they continuously happen.</st> <st c="6599">Additionally, applying
    new deployment patterns such as blue/green, canary, or feature flagging allows
    us to reduce the risk even further.</st> <st c="6737">These will be discussed
    further in the section about deployments</st> <st c="6802">versus releases!</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6129">在持续交付网站上定义（</st>[<st c="6174">https://continuousdelivery.com/</st>](https://continuousdelivery.com/)<st
    c="6206">），“</st>*<st c="6211">持续交付是将所有类型的变更——包括新特性、配置更改、错误修复和实验——以安全、快速且可持续的方式投入生产，或交到用户手中的能力。</st>*<st
    c="6432">”目标是消除</st> <st c="6482">部署中的失败恐惧。</st> <st c="6495">与其进行不频繁的大规模发布，部署应该成为常规操作，持续发生。</st>
    <st c="6599">此外，采用新的部署模式，如蓝绿部署、金丝雀部署或特性标记，可以进一步降低风险。</st> <st c="6737">这些将在关于部署</st>
    <st c="6802">与发布的章节中进一步讨论！</st>
- en: <st c="6818">Some aspects of continuous delivery are</st> <st c="6859">as follows:</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6818">持续交付的一些方面如下：</st>
- en: '**<st c="6870">Automated deployments</st>**<st c="6892">: New</st> <st c="6899">artifacts
    that come</st> <st c="6918">out of CI are bundled with other changes and get automatically
    deployed.</st> <st c="6992">Deployment definitions are declarative and version-controlled
    and therefore allow a more predictable, repeatable, and low-risk way of updating
    in</st> <st c="7138">any environment.</st>'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6870">自动化部署</st>**<st c="6892">：来自 CI 的新</st> <st c="6899">工件与其他更改捆绑，并自动部署。</st>
    <st c="6918">部署定义是声明式的并且受版本控制，因此允许在任何环境中以更可预测、可重复和低风险的方式进行更新。</st> <st c="7138">环境。</st>'
- en: '**<st c="7154">Deployment pipelines</st>**<st c="7175">: Pipelines</st> <st
    c="7188">allow higher-level testing and deployment validation as compared to CI.</st>
    <st c="7260">Here</st> <st c="7264">is where performance, security, scalability,
    resiliency, and user experience tests get executed.</st> <st c="7362">This validates
    not just a single artifact but the full deployment</st> <st c="7428">change set!</st>'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7154">部署流水线</st>**<st c="7175">：与 CI 相比，流水线允许更高级别的测试和部署验证。</st> <st
    c="7260">在此，执行性能、安全性、可扩展性、韧性和用户体验等测试。</st> <st c="7362">这不仅验证单一工件，而是整个部署</st>
    <st c="7428">变更集！</st>'
- en: '**<st c="7439">Quality gates and promotion</st>**<st c="7467">: At the end
    of a deployment pipeline, all test results act as a quality gate</st> <st c="7545">before
    promoting</st> <st c="7562">that change into the next environment: from development</st>
    <st c="7618">to</st> **<st c="7622">Quality Assurance</st>** <st c="7639">(</st>**<st
    c="7641">QA</st>**<st c="7643">,) from QA to staging, from staging</st> <st c="7679">to
    production.</st>'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7439">质量门控与晋升</st>**<st c="7467">：在部署流水线的末尾，所有测试结果充当质量门控</st> <st
    c="7545">，然后将变更晋升到下一个环境：从开发</st> <st c="7618">到</st> **<st c="7622">质量保证</st>**
    <st c="7639">（</st>**<st c="7641">QA</st>**<st c="7643">），从 QA 到暂存，从暂存</st> <st
    c="7679">到生产。</st>'
- en: '**<st c="7693">Rolling back versus rolling forward</st>**<st c="7729">: If
    the quality gate fails in production, a rollback</st> <st c="7783">can be triggered
    by reverting back to the previous version-controlled deployment</st> <st c="7864">configuration.</st>
    <st c="7880">Another strategy is rolling forward, which means that problems</st>
    <st c="7942">are fixed, and thanks to automated deployments, the fix can be deployed
    quickly to avoid</st> <st c="8031">the need for</st> <st c="8045">a rollback.</st>'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7693">回滚与向前滚动</st>**<st c="7729">：如果生产环境中的质量门槛未通过，可以通过回滚至先前版本控制的部署配置来触发回滚。</st>
    <st c="7783">另一种策略是向前滚动，意味着问题被修复，</st> <st c="7864">并且由于自动化部署，修复可以迅速部署，以避免</st>
    <st c="8031">需要回滚。</st>'
- en: <st c="8056">Continuous deployments – decoupling deployments from releases</st>
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="8056">持续部署 – 将部署与发布解耦</st>
- en: <st c="8118">CD deploys changes in an automated and fast way.</st> <st c="8168">However,
    there is still a risk that a change results in a failure, requiring either rolling
    backward or rolling forward, as</st> <st c="8292">explained earlier.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8118">CD 以自动化和快速的方式部署更改。</st> <st c="8168">然而，仍然存在更改导致失败的风险，需要回滚或向前滚动，正如</st>
    <st c="8292">前面所解释的那样。</st>
- en: <st c="8310">Continuous deployments</st> <st c="8334">go a step further and
    embrace new deployment patterns that favor the separation of the deployment of
    a change and releasing the new feature set to the end users.</st> <st c="8496">The
    current well-established patterns are</st> <st c="8538">as follows:</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="8310">持续部署</st> <st c="8334">更进一步，采用了新的部署模式，倾向于将更改的部署与向最终用户发布新功能集分离。</st>
    <st c="8496">目前已经成熟的模式如下：</st> '
- en: '**<st c="8549">Blue/green deployments</st>**<st c="8572">: The new</st> <st
    c="8583">deployment (commonly labeled</st> *<st c="8612">blue</st>*<st c="8616">)
    will be done</st> <st c="8632">in parallel to the existing deployment (commonly
    labeled</st> *<st c="8689">green</st>*<st c="8694">).</st> <st c="8698">Through
    a load balancer, traffic can be switched to blue.</st> <st c="8756">If there is
    a problem with blue, traffic can be switched back to the still-running instance,
    therefore eliminating the need for a rollback while minimizing the impact on the</st>
    <st c="8929">end user.</st> <st c="8940">If all goes well, green becomes blue
    until the next deployment</st> <st c="9003">comes along.</st>'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8549">蓝绿部署</st>**<st c="8572">：新的</st> <st c="8583">部署（通常标记为</st>
    *<st c="8612">蓝色</st>*<st c="8616">）将与现有部署（通常标记为</st> *<st c="8689">绿色</st>*<st
    c="8694">）并行进行。</st> <st c="8698">通过负载均衡器，可以将流量切换到蓝色。</st> <st c="8756">如果蓝色出现问题，流量可以切换回仍在运行的实例，从而避免了回滚，并最小化了对</st>
    <st c="8929">最终用户的影响。</st> <st c="8940">如果一切顺利，绿色将变为蓝色，直到下次部署</st> <st c="9003">来临。</st>'
- en: '**<st c="9015">Canary deployments</st>**<st c="9034">: Similar to blue/green
    deployments but on a more granular level.</st> <st c="9101">It’s the practice</st>
    <st c="9119">of a staged deployment of the new version besides the old version.</st>
    <st c="9186">First, it is deployed to a small subset of users or a</st> <st c="9240">percentage
    of the traffic.</st> <st c="9267">If everything is good, the staged rollout continues
    until all user traffic has the new version.</st> <st c="9363">If a problem occurs
    during the stages, the old version will receive</st> <st c="9431">the traffic.</st>'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9015">金丝雀部署</st>**<st c="9034">：类似于蓝绿部署，但在更精细的层次上。</st> <st c="9101">这是新版本与旧版本并行部署的做法。</st>
    <st c="9119">首先，它会部署到一小部分用户或一部分流量。</st> <st c="9186">如果一切正常，分阶段的推出将继续，直到所有用户流量都使用新版本。</st>
    <st c="9267">如果在阶段过程中出现问题，流量将切换回旧版本。</st>'
- en: '**<st c="9443">Feature flagging</st>**<st c="9460">: Instead of load-balanced
    side-by-side deployments of the old and new versions, feature flagging</st> <st
    c="9558">allows developers to “hide” new code</st> <st c="9595">behind a switch/toggle.</st>
    <st c="9620">During a deployment, the new version gets deployed over the old one
    without executing the new hidden code.</st> <st c="9727">Through fine-grained
    configuration, features can be turned on for individual users, user types, geographical
    regions, or any other attribute of a consumer of a service.</st> <st c="9896">If
    a feature has a problem, it only takes a runtime configuration change and that
    code becomes</st> <st c="9991">inactive again.</st>'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9443">特性标志</st>**<st c="9460">：与旧版本和新版本的负载均衡并排部署不同，特性标志</st> <st c="9558">允许开发者“隐藏”新代码</st>
    <st c="9595">在开关/切换后面。</st> <st c="9620">在部署期间，新版本会覆盖旧版本，但不会执行隐藏的新代码。</st> <st
    c="9727">通过细粒度的配置，可以为单个用户、用户类型、地理区域或任何其他服务消费者属性启用特性。</st> <st c="9896">如果某个特性有问题，只需进行一次运行时配置更改，代码就会</st>
    <st c="9991">重新变为非活动状态。</st>'
- en: <st c="10006">Decoupling deployments from releases allows teams to better control
    the rollout of new features of their software and with that, minimize risk.</st>
    <st c="10151">There is more to explain about implementation details as well as
    challenges but that’s beyond the scope of this book.</st> <st c="10269">If you
    are interested in learning more, look into</st> *<st c="10319">OpenFeature</st>*
    *<st c="10330">[1]</st>*<st c="10334">, a</st> **<st c="10338">Cloud Native Computing
    Foundation</st>** <st c="10371">(</st>**<st c="10373">CNCF</st>**<st c="10377">)
    incubating project.</st> <st c="10400">OpenFeature provides a standard, feature-flag</st>
    <st c="10446">management, vendor-agnostic way for developers to implement feature
    flags.</st> <st c="10521">The community around it also has a lot of best practices
    around progressive delivery, which includes all</st> <st c="10625">the patterns</st>
    <st c="10639">discussed previously.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10006">将部署与发布解耦，使团队能够更好地控制新功能的推出，从而最小化风险。</st> <st c="10151">还有更多关于实现细节以及挑战的内容，但超出了本书的范围。</st>
    <st c="10269">如果你有兴趣了解更多，可以查看</st> *<st c="10319">OpenFeature</st>* *<st c="10330">[1]</st>*<st
    c="10334">，一个</st> **<st c="10338">云原生计算基金会</st>** <st c="10371">（</st>**<st c="10373">CNCF</st>**<st
    c="10377">）孵化的项目。</st> <st c="10400">OpenFeature 提供了一种标准的、特性标志管理、供应商无关的方式供开发者实现特性标志。</st>
    <st c="10446">围绕它的社区也有很多关于渐进式交付的最佳实践，其中包括前面讨论的所有</st> <st c="10625">模式</st> <st
    c="10639">。</st>
- en: <st c="10660">Continuous X for infrastructure</st>
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10660">基础设施的持续X</st>
- en: <st c="10692">Continuous X</st> <st c="10705">is not only relevant for application
    code or configuration.</st> <st c="10766">The same concepts should be applied
    to any infrastructure definition.</st> <st c="10836">As a platform, we will need
    certain infrastructure components.</st> <st c="10899">Whether that’s virtual machines,
    Kubernetes nodes, load</st> <st c="10955">balancers,</st> **<st c="10966">Domain
    Name System</st>** <st c="10984">(</st>**<st c="10986">DNS</st>**<st c="10989">),
    file storage, databases, virtual networks, serverless, or any other component
    that allows us to run our core platform as well as the applications that will
    be deployed, operated, and managed through our</st> <st c="11196">platform self-services.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10692">持续X</st> <st c="10705">不仅仅与应用程序代码或配置相关。</st> <st c="10766">相同的概念应适用于任何基础设施定义。</st>
    <st c="10836">作为平台，我们将需要某些基础设施组件。</st> <st c="10899">无论是虚拟机、Kubernetes节点、负载均衡器、**<st
    c="10966">域名系统</st>** <st c="10984">（</st>**<st c="10986">DNS</st>**<st c="10989">）、文件存储、数据库、虚拟网络、无服务器计算，还是其他任何允许我们运行核心平台以及将通过我们的</st>
    <st c="11196">平台自服务部署、操作和管理的应用程序的组件。</st>
- en: <st c="11219">Just like with application code, we want to configure our infrastructure
    requirements as code, version control them, and apply the same CI and continuous
    testing, validation,</st> <st c="11395">and delivery.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11219">就像应用程序代码一样，我们希望将基础设施需求配置为代码，进行版本控制，并应用相同的 CI 和持续测试、验证、</st> <st
    c="11395">和交付。</st>
- en: '**<st c="11408">GitOps</st>** <st c="11415">is also</st> <st c="11423">a term
    that emerged over the past years and it focuses on automating the process of provisioning
    infrastructure from a desired state defined declaratively and version-controlled
    in Git.</st> <st c="11610">We will cover GitOps in more detail in a later section
    of this chapter.</st> <st c="11682">First, let’s</st> <st c="11695">discuss the
    basics by star</st><st c="11721">ting with</st> **<st c="11732">infrastructure
    as</st>** **<st c="11750">code</st>** <st c="11754">(</st>**<st c="11756">IaC</st>**<st
    c="11759">).</st>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="11408">GitOps</st>** <st c="11415">也是近几年出现的一个术语，它专注于自动化根据声明性定义的期望状态，通过Git进行版本控制来配置基础设施的过程。</st>
    <st c="11610">我们将在本章的后续部分更详细地介绍GitOps。</st> <st c="11682">首先，</st> <st c="11695">让我们从</st>
    **<st c="11732">基础设施即代码</st>** **<st c="11750">（IaC）</st>**<st c="11754">开始，讨论一些基础知识。</st>'
- en: <st c="11762">IaC</st>
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="11762">IaC</st>
- en: '<st c="11766">There are</st> <st c="11777">many different tools that enable</st>
    **<st c="11810">IaC</st>** <st c="11813">and most likely, you already have one
    or several</st> <st c="11863">in your organization: Terraform, Ansible, Puppet,
    Chef, CloudFormation, and</st> **<st c="11939">AWS</st>** **<st c="11942">Cloud
    Development Kit</st>** <st c="11964">(</st>**<st c="11966">CDK</st>**<st c="11969">)
    just to name</st> <st c="11985">a few.</st>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11766">有许多不同的工具可以实现</st> **<st c="11810">IaC</st>** <st c="11813">，而且你很可能已经在你的组织中使用了一个或多个工具：Terraform、Ansible、Puppet、Chef、CloudFormation以及</st>
    **<st c="11939">AWS</st>** **<st c="11942">云开发工具包</st>** <st c="11964">(</st>**<st
    c="11966">CDK</st>**<st c="11969">)仅举几个例子。</st>
- en: <st c="11991">Here is a very simple Terraform snippet that would create an EC2
    instance of</st> <st c="12069">type</st> `<st c="12074">c5.large</st>`<st c="12082">:</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11991">这是一个非常简单的Terraform代码片段，用于创建一个类型为</st> <st c="12069">c5.large</st>`<st
    c="12074">的EC2实例</st>`<st c="12082">：</st>
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="12226">Here is one more example of creating an AWS S3 bucket</st> <st
    c="12281">using Ansible:</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12226">这里有一个使用Ansible创建AWS S3存储桶的例子：</st>
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="12560">IaC</st> <st c="12565">enables us to define the desired state
    of our IaC.</st> <st c="12616">This is code that can be version-controlled, such
    as application code, and once deployed, it results in the desired infrastructure
    being provisioned.</st> <st c="12766">Like with application code, we can use</st>
    <st c="12805">the following:</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12560">IaC</st> <st c="12565">使我们能够定义我们期望的IaC状态。</st> <st c="12616">这段代码可以进行版本控制，类似于应用程序代码，一旦部署，就会实现期望的基础设施配置。</st>
    <st c="12766">与应用程序代码类似，我们可以使用</st> <st c="12805">以下内容：</st>
- en: '**<st c="12819">CI</st>**<st c="12822">: Use this to validate that all our
    IaC is valid.</st> <st c="12873">IaC tools typically have features to “dry run”
    and validate that there is no mistake and that all config files have no conflict
    or</st> <st c="13004">dependency issues.</st>'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12819">CI</st>**<st c="12822">：用来验证我们所有的IaC是否有效。</st> <st c="12873">IaC工具通常具有“干运行”功能，可以验证是否没有错误，所有配置文件是否没有冲突或</st>
    <st c="13004">依赖问题。</st>'
- en: '**<st c="13022">Testing and deployment validation</st>**<st c="13056">: After
    IaC is deployed, we can validate that we really got our desired state (e.g., ensuring
    that the EC2 instance is really up and running, that the S3 buckets are</st> <st
    c="13223">accessible, etc.).</st>'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="13022">测试和部署验证</st>**<st c="13056">：在IaC部署后，我们可以验证我们是否真正达到了期望的状态（例如，确保EC2实例已启动并运行，S3存储桶可以</st>
    <st c="13223">访问，等等）。</st>'
- en: '**<st c="13241">Rollback or revert</st>**<st c="13260">: IaC gives us the option
    to roll back changes or revert to a previous version because everything</st> <st
    c="13359">is version-controlled!</st>'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="13241">回滚或恢复</st>**<st c="13260">：IaC让我们可以回滚更改或恢复到先前的版本，因为一切</st>
    <st c="13359">都被版本控制！</st>'
- en: <st c="13381">For more details on</st> <st c="13401">IaC, including version
    control strategies (where IaC lives), the authors recommend looking i</st><st
    c="13494">nto existing books and blogs on</st> <st c="13527">that topic.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13381">关于</st> <st c="13401">IaC的更多细节，包括版本控制策略（IaC的存储位置），作者建议参考现有的书籍和博客，了解</st>
    <st c="13494">该主题。</st>
- en: <st c="13538">Crossplane – IaC for platform and applications</st>
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="13538">Crossplane – 平台和应用的IaC</st>
- en: <st c="13585">IaC is not limited to the</st> <st c="13612">core platform services
    but is also relevant for the applications that we allow our development teams
    to deploy through our platform self-services.</st> <st c="13759">A new application
    may need file storage, a database, and a public DNS, or need to deploy a third-party
    solution; it depends on its own virtual machine, which is accessible from the
    deployed app that may reside</st> <st c="13969">on K8s.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13585">基础设施即代码（IaC）不仅仅局限于核心平台服务，它还适用于我们允许开发团队通过平台自服务部署的应用程序。</st> <st
    c="13612">一个新的应用程序可能需要文件存储、数据库和公共DNS，或需要部署第三方解决方案；这取决于其虚拟机，而该虚拟机可以从部署的应用程序访问，这些应用程序可能会驻留在</st>
    <st c="13969">K8s上。</st>
- en: <st c="13976">You can provide templates for Terraform, Ansible, and CDK, which
    your developers can add to their own code repositories, and which are then applied
    as part of the Continuous X of</st> <st c="14156">their application.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13976">你可以为Terraform、Ansible和CDK提供模板，开发人员可以将其添加到自己的代码库中，然后作为其应用程序持续X的一部分进行应用。</st>
- en: <st c="14174">One tool that has emerged in the cloud native space to cover both
    application and infrastructure orchestration is the</st> **<st c="14293">CNCF
    project Crossplane</st>** *<st c="14316">[2]</st>*<st c="14320">. Besides coming
    with a lot of different</st> <st c="14361">providers for all major cloud vendors
    or even Terraform, it comes with Compositions.</st> **<st c="14446">Compositions</st>**
    <st c="14458">are a template for creating multiple managed resources as a single
    object.</st> <st c="14534">This allows the platform team to define such templates
    for common application architectures and then have the application team simply
    use that template to instantiate the correct infrastructure and deploy</st> <st
    c="14739">the application.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14174">在云原生领域中，出现了一种工具来覆盖应用程序和基础设施编排，它就是</st> **<st c="14293">CNCF项目Crossplane</st>**
    *<st c="14316">[2]</st>*<st c="14320">。除了提供许多不同的云供应商或甚至Terraform的提供程序外，它还提供了Compositions。</st>
    **<st c="14446">Compositions</st>** <st c="14458">是一个用于创建多个托管资源作为单一对象的模板。</st>
    <st c="14534">这使得平台团队能够为常见的应用程序架构定义这样的模板，然后让应用程序团队仅使用该模板来实例化正确的基础设施并部署</st> <st
    c="14739">应用程序。</st>
- en: <st c="14755">One of our self-service use cases discussed in</st> [*<st c="14803">Chapter
    2</st>*](B31164_02.xhtml#_idTextAnchor055) <st c="14812">was the automated provisioning
    of a performance test environment.</st> <st c="14879">We could define a composition
    that would be as easy to use by the development teams as the one shown in</st>
    <st c="14983">this example:</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14755">我们在</st> [*<st c="14803">第2章</st>*](B31164_02.xhtml#_idTextAnchor055)
    <st c="14812">中讨论了一个自服务使用案例——自动化性能测试环境的配置。</st> <st c="14879">我们可以定义一个组成模板，使开发团队能够像使用下面示例中的模板一样轻松使用它：</st>
    <st c="14983">这个例子：</st>
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="15330">The Composition</st> <st c="15347">definition of</st> `<st c="15361">PerformanceTestCluster</st>`
    <st c="15383">would have been created by the platform engineering team in combination
    with those experts who know how to install the load testing and observability
    tools.</st> <st c="15541">In the preceding example, a new medium-sized K8s cluster
    would be provisioned, the requested app would be installed using the referenced
    Helm chart, observability data would be captured (e.g., Prometheus and log scraping
    configured) and the load testing tool would be deployed to be able to run spike
    load scenarios.</st> <st c="15858">Once everything is ready, a Slack notification
    with the environment details will be sent to the team.</st> <st c="15960">Last
    but not least, the environment would also be shut down after 12 hours as specified
    in the mandatory</st> `<st c="16065">leaseTime</st>` <st c="16074">field.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15330">这个Composition</st> <st c="15347">的定义是</st> `<st c="15361">PerformanceTestCluster</st>`
    <st c="15383">由平台工程团队与那些知道如何安装负载测试和可观察性工具的专家共同创建。</st> <st c="15541">在前面的例子中，一个新的中型K8s集群将被配置，所请求的应用程序将使用引用的Helm
    chart进行安装，捕获可观察性数据（例如，配置Prometheus和日志抓取），并且将部署负载测试工具，以便能够运行尖峰负载场景。</st> <st c="15858">一旦一切准备就绪，带有环境详情的Slack通知将发送给团队。</st>
    <st c="15960">最后但同样重要的是，该环境将在12小时后根据强制性</st> `<st c="16065">leaseTime</st>` <st
    c="16074">字段的规定自动关闭。</st>
- en: <st c="16081">The preceding example already shows the power of IaC when i</st><st
    c="16141">ntegrating this into our Continuous</st> <st c="16178">X efforts!</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16081">前面的例子已经展示了将IaC集成到我们的持续</st> <st c="16141">X工作中时的强大功能！</st>
- en: <st c="16188">Continuous X as a system-critical component in our platform</st>
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="16188">Continuous X 作为我们平台中的系统关键组件</st>
- en: '<st c="16248">There are many different tools we can</st> <st c="16287">choose
    from to implement Continuous X: Jenkins, GitLab, Tekton, Argo CD, Flux, Keptn,
    Crossplane, Selenium, and</st> `<st c="16399">k6</st>`<st c="16401">, to just
    name a few.</st> <st c="16423">Whatever tools we choose, those tools need to be
    available, resilient, and secure all of the time, as they are the backbone of
    our platform.</st> <st c="16564">Those tools are as business-critical as any software
    that powers the business we are in.</st> <st c="16653">Think about Financial One
    ACME.</st> <st c="16685">If the developers need to push out a fix to a critical
    production issue on their financial software, they need Continuous X to</st> <st
    c="16812">work perfectly.</st>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16248">我们可以从许多不同的工具中选择来实施 Continuous X：Jenkins、GitLab、Tekton、Argo CD、Flux、Keptn、Crossplane、Selenium
    和</st> `<st c="16399">k6</st>`<st c="16401">，仅举几例。</st> <st c="16423">无论我们选择哪种工具，这些工具需要始终可用、具备弹性并且安全，因为它们是我们平台的支柱。</st>
    <st c="16564">这些工具与任何支撑我们业务的软件同样重要。</st> <st c="16653">想想 Financial One ACME。</st>
    <st c="16685">如果开发人员需要发布一个修复，解决其金融软件中的关键生产问题，他们需要 Continuous X</st> <st c="16812">能够完美运行。</st>
- en: <st c="16827">To ensure that those components are available when they are needed,
    we need to apply the same best practices as we put on our</st> <st c="16954">business-critical
    apps:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16827">为了确保在需要时这些组件能够可用，我们需要应用与我们业务关键应用相同的最佳实践：</st>
- en: '**<st c="16977">Secure by default</st>**<st c="16995">: If attackers find their
    way into our Continuous X toolkit, they have open doors to enter any system that
    is managed by our platform.</st> <st c="17131">Because of this criticality,</st>
    [*<st c="17160">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381) <st c="17169">is
    fully dedicated to building secure and</st> <st c="17212">compliant products.</st>'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16977">默认安全</st>**<st c="16995">：如果攻击者能够进入我们的 Continuous X 工具包，他们将打开进入我们平台管理的任何系统的大门。</st>
    <st c="17131">由于这一关键性，</st> [*<st c="17160">第7章</st>*](B31164_07.xhtml#_idTextAnchor381)
    <st c="17169">完全致力于构建安全和</st> <st c="17212">合规的产品。</st>'
- en: '**<st c="17231">Test every change we make</st>**<st c="17257">: Let’s assume
    we use GitLab as one of our tools for Git and CI.</st> <st c="17323">We must version
    control the deployment configuration of GitLab and run it through the same Continuous
    X process to validate every new version or configuration change.</st> <st c="17490">If
    necessary, we will roll back or roll forward in case an update is</st> <st c="17559">causing
    issues!</st>'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17231">测试我们所做的每一个更改</st>**<st c="17257">：假设我们使用 GitLab 作为我们的 Git 和
    CI 工具之一。</st> <st c="17323">我们必须对 GitLab 的部署配置进行版本控制，并通过相同的 Continuous X 流程运行，以验证每个新版本或配置更改。</st>
    <st c="17490">如果必要，我们将回滚或前进，以防更新</st> <st c="17559">引发问题！</st>'
- en: '**<st c="17574">Deploy highly available</st>**<st c="17598">: Follow the deployment
    guidelines for those tools for high availability.</st> <st c="17673">If we have
    globally distributed teams, we want to make sure to deploy certain components
    as close as possible to our end users.</st> <st c="17801">Also, look into zero-downtime
    upgrade options and</st> <st c="17851">follow them.</st>'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17574">部署高可用性</st>**<st c="17598">：遵循这些工具的部署指南，以确保高可用性。</st> <st c="17673">如果我们有全球分布的团队，我们需要确保将某些组件尽可能部署到离终端用户最近的地方。</st>
    <st c="17801">另外，考虑零停机时间的升级选项并</st> <st c="17851">遵循这些选项。</st>'
- en: '**<st c="17863">Observe each component</st>**<st c="17886">: Every tool provides
    some type of telemetry data that indicates health.</st> <st c="17960">Argo CD,
    for instance, exposes Prometheus metrics for work queue length, Git requests,
    and sync activity.</st> <st c="18066">Those give an indication of whether Argo
    CD is still able to do its job.</st> <st c="18139">A constantly increasing work
    queue depth is a sign that Argo CD can’t keep up with all requests, which needs
    to be</st> <st c="18254">looked into.</st>'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17863">观察每个组件</st>**<st c="17886">：每个工具都提供某种类型的遥测数据，用以指示健康状态。</st>
    <st c="17960">例如，Argo CD 会暴露 Prometheus 指标，用于工作队列长度、Git 请求和同步活动。</st> <st c="18066">这些数据能指示
    Argo CD 是否仍然能够正常工作。</st> <st c="18139">持续增加的工作队列深度表明 Argo CD 无法跟上所有请求，需要</st>
    <st c="18254">进行排查。</st>'
- en: '**<st c="18266">Service-level agreements (SLAs) and alerting on problems</st>**<st
    c="18323">: We – the platform team – must know that something is wrong before
    our end users report it to us.</st> <st c="18423">That’s why we need to set up</st>
    <st c="18451">SLAs for each component and configure proper alerting in case systems
    are not working as expected.</st> <st c="18551">The simplest way to do this is
    to set up synthetic checks against the key API endpoints of each tool (e.g., validate
    that Jenkins UI is responsive</st> <st c="18697">with a synthetic check that runs
    every five minutes; this gives us an early warning signal in case Jenkins starts
    having problems before anyone else</st> <st c="18847">notices it).</st>'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="18266">服务级协议（SLAs）和故障警报</st>**<st c="18323">：我们——平台团队——必须在最终用户报告问题之前就知道存在问题。</st>
    <st c="18423">这就是为什么我们需要为每个组件设置SLAs，并在系统未按预期工作时配置适当的警报。</st> <st c="18451">实现这一点的最简单方法是设置针对每个工具的关键API端点的合成检查（例如，通过每五分钟运行一次的合成检查来验证
    Jenkins UI 是否响应，这为我们提供了一个提前警告信号，以防 Jenkins 在其他人注意到之前就开始出现问题）。</st>'
- en: <st c="18859">The following is an example dashboard highlighting key health
    indicators of tools, such as Argo CD.</st> <st c="18960">The</st> <st c="18963">same
    must be applied to all other tools that make up our core</st> <st c="19026">platform
    capabilities!</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18859">以下是一个示例仪表板，突出显示了工具的关键健康指标，例如 Argo CD。</st> <st c="18960">同样的原则必须应用于构成我们核心平台能力的所有其他工具！</st>
- en: '![Figure 5.1: Monitor and observe every tool part of the platform](img/B31164_05_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：监控并观察平台中每个工具的情况](img/B31164_05_01.jpg)'
- en: '<st c="19787">Figure 5.1: Monitor and observe every tool part of the platform</st>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19787">图 5.1：监控并观察平台中每个工具的情况</st>
- en: <st c="19850">Platform Components are as business-critical as your critical
    apps</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19850">平台组件与您的关键应用程序同样至关重要</st>
- en: <st c="19917">The core of the platform will revolve around deploying changes
    into various environments.</st> <st c="20008">All tools that support those use
    cases – especially those for Continuous X – need to be highly available, resilient,
    and secure.</st> <st c="20137">Make sure to apply the same engineering best practices
    to all components of</st> <st c="20213">the platform!</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19917">平台的核心将围绕将更改部署到各种环境展开。</st> <st c="20008">所有支持这些用例的工具——尤其是那些用于连续X的工具——需要具有高度可用性、弹性和安全性。</st>
    <st c="20137">确保将相同的工程最佳实践应用于平台的所有组件！</st>
- en: <st c="20226">Now that we have recapped the core concepts of Continuous X (integration,
    testing, validation, delivery, deployment, and release) and discussed that all
    configurations (code, deployment config, infrastructure, observability, etc.)
    must follow the same principles, it’s time to have a look into how these concepts
    can be used to provide self-service autonom</st><st c="20583">y to teams that
    leverage this through</st> <st c="20622">a platform.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20226">现在我们已经回顾了连续X（集成、测试、验证、交付、部署和发布）的核心概念，并讨论了所有配置（代码、部署配置、基础设施、可观测性等）必须遵循相同的原则，接下来是时候探讨如何利用这些概念为通过平台实现自主服务的团队提供支持。</st>
- en: <st c="20633">GitOps – Moving from pushing to pulling the desired state</st>
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="20633">GitOps – 从推送到拉取期望状态的转变</st>
- en: '**<st c="20691">CI/CD</st>** <st c="20697">has</st> <st c="20701">been around
    for many years.</st> <st c="20730">The</st> *<st c="20734">Continuous Delivery</st>*
    <st c="20753">book was initially released back in 2010 – years before the emergence
    of containers (made popular through Docker, starting in 2013) and container orchestration
    platforms (such as Kubernetes, starting</st> <st c="20954">in 2014).</st>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="20691">CI/CD</st>** <st c="20697">已经存在多年。</st> <st c="20701">《持续交付》一书最初发布于2010年——容器（通过Docker推广，从2013年开始）和容器编排平台（如Kubernetes，从2014年开始）出现之前的几年。</st>'
- en: <st c="20963">Fast forward to 2024 when this book was initially published; we
    live in a world where the following is</st> <st c="21067">the case:</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20963">快速推进到2024年，当本书首次发布时；我们生活在一个以下情况的世界：</st> <st c="21067">现状是：</st>
- en: '**<st c="21076">Git</st>** <st c="21080">is the source</st> <st c="21095">of
    truth.</st> <st c="21105">It contains everything as code: source code, tests,
    infrastructure and deployment definitions, observability, ownership, and</st>
    <st c="21230">so on.</st>'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21076">Git</st>** <st c="21080">是事实的源头</st> <st c="21095">。</st> <st
    c="21105">它包含了所有的内容作为代码：源代码、测试、基础设施和部署定义、可观测性、所有权等。</st>'
- en: '**<st c="21236">CI/CD</st>** <st c="21242">is building, testing, and</st> <st
    c="21268">packaging container /</st> **<st c="21291">Open Container Initiative</st>**
    <st c="21316">(</st>**<st c="21318">OCI</st>**<st c="21321">) images</st> <st
    c="21331">from a source code Git repository and publishing them to an artifact
    registry (</st><st c="21410">e.g., Harbor).</st>'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21236">CI/CD</st>** <st c="21242">是构建、测试并</st> <st c="21268">打包容器
    /</st> **<st c="21291">开放容器倡议</st>** <st c="21316">(</st>**<st c="21318">OCI</st>**<st
    c="21321">) 镜像</st> <st c="21331">来自源代码 Git 仓库，并将它们发布到工件注册中心（</st><st c="21410">例如，Harbor）</st>。'
- en: '**<st c="21425">GitOps</st>** <st c="21432">continuously attempts to apply
    the latest desired state as declared in a deployment</st> <st c="21517">Git repository
    (e.g., Helm Charts) on the target Kubernetes environment and pushes any additional
    configuration (e.g., observability to the</st> <st c="21657">respective tools).</st>'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21425">GitOps</st>** <st c="21432">持续尝试应用部署 Git 仓库（例如 Helm 图表）中声明的最新期望状态，并将任何额外的配置（例如，观测性）推送到</st>
    <st c="21657">相应的工具中。</st>'
- en: <st c="21675">The preceding description is not a one-size-fits-all model.</st>
    <st c="21736">GitOps will be implemented slightly differently in every organization.</st>
    <st c="21807">If you search for</st> `<st c="21825">What is GitOps?</st>`<st c="21840">,
    you will find many different variations, such as</st> <st c="21891">the following:</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21675">上述描述并不是适用于所有情况的统一模型。</st> <st c="21736">GitOps 在每个组织中的实施方式都会有所不同。</st>
    <st c="21807">如果你搜索</st> `<st c="21825">什么是 GitOps？</st>`<st c="21840">，你会找到许多不同的变体，如</st>
    <st c="21891">以下内容：</st>
- en: '**<st c="21905">Separate CI and CD</st>**<st c="21924">: CI publishing containers
    and CD publishing packaged artifacts, such as</st> <st c="21998">Helm charts</st>'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21905">分离 CI 和 CD</st>**<st c="21924">：CI 负责发布容器，CD 负责发布打包后的工件，如</st>
    <st c="21998">Helm 图表</st>'
- en: '**<st c="22009">Single Git</st>**<st c="22020">: Everything as code (source,
    test, deployment, observability, etc.) in a single</st> <st c="22102">Git repository</st>'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22009">单一 Git</st>**<st c="22020">：将一切作为代码（源代码、测试、部署、观测性等）存储在单一的</st>
    <st c="22102">Git 仓库中</st>'
- en: '**<st c="22116">Push GitOps</st>**<st c="22128">: Pushing</st> <st c="22138">the
    desired state through pipelines or workflows versus pulling changes into the target
    environment through</st> <st c="22247">GitOps operators</st>'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22116">推送 GitOps</st>**<st c="22128">：通过流水线或工作流推送期望的状态，而不是通过</st>
    <st c="22247">GitOps 操作员</st> <st c="22138">将更改拉入目标环境</st>'
- en: <st c="22263">In the following section, we will shine the light on one flavor
    of GitOps that favors the</st> **<st c="22354">pull</st>** <st c="22358">(</st>*<st
    c="22360">pulling</st>* <st c="22367">a configuration into the target environment)
    model over the</st> **<st c="22428">push</st>** <st c="22432">(</st>*<st c="22434">pushing</st>*
    <st c="22441">a configuration from an external tool into the target environment)
    model, which can be implemented with CNCF tools, such as Flux or Argo CD, as shown
    in the following illustration taken from Codefresh’s Learning Center on</st> <st
    c="22664">GitOps:</st> [<st c="22672">https://codefresh.io/learn/gitops/</st>](https://codefresh.io/learn/gitops/)<st
    c="22706">.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22263">在接下来的章节中，我们将重点介绍一种偏向于</st> **<st c="22354">拉取</st>** <st c="22358">(</st>*<st
    c="22360">将配置拉入目标环境</st>* <st c="22367">) 模型，而不是</st> **<st c="22428">推送</st>**
    <st c="22432">(</st>*<st c="22434">从外部工具推送配置到目标环境</st>* <st c="22441">) 模型，该模型可以使用
    CNCF 工具（如 Flux 或 Argo CD）实现，如下图所示，该图取自 Codefresh 学习中心的</st> <st c="22664">GitOps</st>：[<st
    c="22672">https://codefresh.io/learn/gitops/</st>](https://codefresh.io/learn/gitops/)<st
    c="22706">。</st>
- en: '![Figure 5.2: Basic GitOps flow as promoted by GitOps tools such as Argo CD
    or Flux](img/B31164_05_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：GitOps 流程基础，如 Argo CD 或 Flux 等 GitOps 工具所推广的那样](img/B31164_05_02.jpg)'
- en: '<st c="22940">Figure 5.2: Basic GitOps flow as promoted by GitOps tools such
    as Argo CD or Flux</st>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22940">图 5.2：GitOps 流程基础，如 Argo CD 或 Flux 等 GitOps 工具所推广的那样</st>
- en: <st c="23021">It’s your choice as to whether you favor the Push model using
    automated pipelines or workflows to push changes into your target Kubernetes environments!</st>
    <st c="23175">To make the decision easier, let’s dig into more detail on the individual
    phases and learn about</st> <st c="23272">some best practices that should happen
    in</st> <st c="23314">every phase!</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23021">是否选择使用自动化流水线或工作流推送更改到目标 Kubernetes 环境是由你决定的！</st> <st c="23175">为了让决策更容易，我们将深入探讨每个阶段的更多细节，并了解</st>
    <st c="23272">在每个阶段中应该遵循的一些最佳实践！</st>
- en: <st c="23326">Phase 1 – from source code to container image</st>
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23326">阶段 1 – 从源代码到容器镜像</st>
- en: <st c="23372">Moving to GitOps doesn’t</st> <st c="23398">change anything about
    how we are building our applications from source code that is version-controlled
    in Git.</st> <st c="23509">Before building new artifacts, a good practice is to
    automate dependency checks and updates.</st> <st c="23602">Tools, such as</st>
    **<st c="23617">Renovate Bot</st>** *<st c="23629">[3]</st>*<st c="23633">, integrate
    with</st> <st c="23650">Git and create Pull Requests in case outdated dependencies,
    third-party libraries, or other dependencies</st> <st c="23755">are found.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23372">迁移到GitOps并不</st> <st c="23398">改变我们如何从Git中版本控制的源代码构建应用程序。</st>
    <st c="23509">在构建新工件之前，一个好的做法是自动化依赖检查和更新。</st> <st c="23602">例如，</st> **<st c="23617">Renovate
    Bot</st>** *<st c="23629">[3]</st>*<st c="23633">工具可以与Git集成，并在发现过时的依赖、第三方库或其他依赖项时创建Pull
    Requests。</st> <st c="23755">这些工具非常有用。</st>
- en: '<st c="23765">Once we have our up-to-date code in Git,</st> **<st c="23807">CI</st>**
    <st c="23809">has the</st> <st c="23817">same job as it always had: it creates
    an artifact, most likely a container image, that gets pushed to a container registry!</st>
    <st c="23942">That CI can be triggered on demand, on commits to certain branches,
    on Pull Requests, or on any other trigger that makes sense for</st> <st c="24073">the
    organization!</st>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23765">一旦我们在Git中更新了代码，</st> **<st c="23807">CI</st>** <st c="23809">就有了和以前一样的任务：它创建一个工件，最有可能是一个容器镜像，并将其推送到容器注册表！</st>
    <st c="23942">这个CI可以根据需要触发，或者在某些分支的提交、Pull Requests，或者任何其他合理的触发条件下触发。</st> <st
    c="24073">这是对组织来说非常重要的！</st>
- en: '<st c="24090">There are many different tools available that can do the job:
    Jenkins, GitLab, Azure DevOps, GitHub Actions, Bitbucket Pipelines, and many more.</st>
    <st c="24236">There are also various container registry options.</st> <st c="24287">We
    will talk about container registries and the importance of them a bit later in
    this book as they are – like all the components of our platform – critical to
    the success of our</st> <st c="24466">future platform!</st>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24090">有很多不同的工具可以完成这项工作：Jenkins、GitLab、Azure DevOps、GitHub Actions、Bitbucket
    Pipelines等等。</st> <st c="24236">也有各种容器注册表选项。</st> <st c="24287">稍后我们将在本书中讨论容器注册表及其重要性，它们和我们平台的所有组件一样，都是我们</st>
    <st c="24466">未来平台成功的关键！</st>
- en: <st c="24482">Once the CI</st> <st c="24495">has successfully compiled the source
    code, executed unit tests, and run any additional quality checks on the code,
    it’s time to package the binary into a container image.</st> <st c="24666">There
    are many best practices out there for building container images; from just packaging
    a single service into a container, being careful to use public base images, to
    building the smallest image possible.</st> <st c="24874">Following all those rules
    will lead to a higher rate of success as the container image moves from CI all
    the way into production.</st> <st c="25004">Here are two obvious but very important
    practices that we want to mention in this chapter (for more information, please
    refer to the books</st> <st c="25143">previously mentioned):</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24482">一旦CI</st> <st c="24495">成功编译源代码、执行单元测试，并对代码进行任何额外的质量检查后，便可以将二进制文件打包成容器镜像。</st>
    <st c="24666">构建容器镜像有很多最佳实践；从只将单个服务打包到容器中、谨慎使用公共基础镜像，到构建尽可能小的镜像。</st> <st c="24874">遵循所有这些规则将提高容器镜像从CI到生产环境的成功率。</st>
    <st c="25004">这里有两个显而易见但非常重要的实践，我们希望在本章提到（更多信息，请参阅之前提到的书籍）：</st>
- en: '`<st c="25293">finoneacme/fund-transfer:2.34.3</st>`<st c="25324">, where</st>
    `<st c="25332">finoneacme/fund-transfer</st>` <st c="25356">is the name and</st>
    `<st c="25373">2.34.3</st>` <st c="25379">is the tag).</st> <st c="25393">When
    you build an image, it’s up to you to tag it properly but you should follow a
    consistent policy.</st> <st c="25495">There are two common ways to do this that
    are used in</st> <st c="25549">the industry:</st>'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="25293">finoneacme/fund-transfer:2.34.3</st>`<st c="25324">，其中</st>
    `<st c="25332">finoneacme/fund-transfer</st>` <st c="25356">是名称，</st> `<st c="25373">2.34.3</st>`
    <st c="25379">是标签。</st> <st c="25393">在你构建镜像时，标签由你决定，但你应该遵循一致的命名规则。</st> <st c="25495">行业中有两种常见的做法：</st> '
- en: '`<st c="25738">MAJOR.MINOR.PATCH</st>`<st c="25755">. Every minor or patch
    version number must be for a backward-compatible change.</st> <st c="25835">In
    combination with the version name</st> `<st c="25872">latest</st>`<st c="25878">,
    which is the default to point to the latest available version, you can provide
    easy access to a specific image (e.g.,</st> `<st c="25998">X.Y.Z</st>`<st c="26003">).</st>
    <st c="26007">It also allows for the selection of the latest patch release for
    a specific minor release (e.g.,</st> `<st c="26104">X.Y</st>`<st c="26107">) or
    the latest minor and patch version for a major release (</st><st c="26169">e.g.,</st>
    `<st c="26176">X</st>`<st c="26177">).</st>'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="25738">MAJOR.MINOR.PATCH</st>`<st c="25755">。每个次要或修补版本号必须是向后兼容的更改。</st>
    <st c="25835">结合版本名称</st> `<st c="25872">latest</st>`<st c="25878">，这是指向最新可用版本的默认值，你可以方便地访问特定的镜像（例如，</st>
    `<st c="25998">X.Y.Z</st>`<st c="26003">）。</st> <st c="26007">它还允许选择特定次版本的最新修补版本（例如，</st>
    `<st c="26104">X.Y</st>`<st c="26107">）或某个主版本的最新次版本和修补版本（</st><st c="26169">例如，</st>
    `<st c="26176">X</st>`<st c="26177">）。</st>'
- en: '`<st c="26287">git commit</st>` <st c="26297">hash as version instead of keeping
    track of semantic versioning.</st> <st c="26363">The commit hash</st> <st c="26378">on
    the image also immediately tells us which source code commit was responsible for
    producing this container image.</st> <st c="26495">For our image, this could mean
    it’s tagged like</st> <st c="26543">this:</st> `<st c="26549">financeoneacme/fund-transfer:d85aaef</st>`<st
    c="26585">.</st>'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="26287">git commit</st>` <st c="26297">哈希作为版本，而不是跟踪语义版本。</st> <st c="26363">提交哈希</st>
    <st c="26378">在镜像上也立即告诉我们是哪个源代码提交负责生成了这个容器镜像。</st> <st c="26495">对于我们的镜像，这可能意味着它被标记为</st>
    <st c="26543">这样：</st> `<st c="26549">financeoneacme/fund-transfer:d85aaef</st>`<st
    c="26585">。</st>'
- en: '`<st c="27201">log4j</st>` <st c="27206">vulnerability.</st> <st c="27222">This
    is why security must go beyond the static checks in the CI process and continue
    throughout the life cycle of an artifact.</st> <st c="27349">This will be</st>
    <st c="27361">explored more in</st> [*<st c="27379">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="27388">, which dives deeper into building and operating</st> <st c="27437">secure
    products.</st>'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27201">log4j</st>` <st c="27206">漏洞。</st> <st c="27222">这就是为什么安全性必须超越
    CI 流程中的静态检查，并贯穿整个工件的生命周期。</st> <st c="27349">这一点将在</st> <st c="27361">[*第7章*](B31164_07.xhtml#_idTextAnchor381)中进一步探讨</st>
    <st c="27388">，该章节深入探讨了构建和运营</st> <st c="27437">安全产品。</st>'
- en: <st c="27453">Now that we have a container image uploaded to our</st> <st c="27505">container
    registry, we can use it in a</st> <st c="27544">deployment definition.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27453">现在我们已经将容器镜像上传到我们的</st> <st c="27505">容器注册表中，我们可以在</st> <st c="27544">部署定义中使用它。</st>
- en: <st c="27566">Phase 2 – from container image to metadata-enriched deployment
    artifact</st>
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="27566">第2阶段 – 从容器镜像到富含元数据的部署工件</st>
- en: <st c="27638">The container image now needs to find its way into a deployment
    definition.</st> <st c="27715">Looking at Kubernetes, we would need a manifest
    file that defines our deployment definition, which we can later apply to our</st>
    <st c="27840">K8s cluster.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27638">容器镜像现在需要找到进入部署定义的路径。</st> <st c="27715">看 Kubernetes，我们需要一个清单文件来定义我们的部署定义，之后可以将其应用到我们的</st>
    <st c="27840">K8s 集群。</st>
- en: <st c="27852">In</st> [*<st c="27856">Chapter 3</st>*](B31164_03.xhtml#_idTextAnchor133)<st
    c="27865">, we highlighted that adding</st> <st c="27894">metadata (ownership,
    observability level, notifications) to our deployment file will benefit lots of
    the self-service use cases, such as the</st> *<st c="28035">Requesting Logs as
    Self-Service</st>* <st c="28066">use case.</st> <st c="28077">Besides our source
    code, we therefore also need to version control our deployment definition and
    should enforce a minimum set of metadata.</st> <st c="28216">This enables our
    platform self-service use cases (e.g., who has deployed which services belong
    to which application) as well as following general infrastructure best</st> <st
    c="28382">practices (e.g., defining request and resource limits), as you can see
    in the</st> <st c="28460">following manifest:</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27852">在</st> [*<st c="27856">第3章</st>*](B31164_03.xhtml#_idTextAnchor133)<st
    c="27865">中，我们强调了将</st> <st c="27894">元数据（所有权、可观察性级别、通知）添加到我们的部署文件中，将有利于许多自助服务用例，例如</st>
    *<st c="28035">作为自助服务请求日志</st>* <st c="28066">的用例。</st> <st c="28077">因此，除了我们的源代码，我们还需要对我们的部署定义进行版本控制，并且应强制执行最小元数据集。</st>
    <st c="28216">这使我们的平台自助服务用例（例如，谁部署了哪些服务，属于哪个应用程序）以及遵循一般基础设施最佳</st> <st c="28382">实践（例如，定义请求和资源限制）成为可能，正如你在以下清单中看到的：</st>
- en: <st c="28479">mainfest.yaml (Kubernetes Deployment)</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28479">mainfest.yaml（Kubernetes 部署文件）</st>
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="29126">The deployment definition can be a manifest or a set of manifest
    files, as we likely also need additional K8s resources, such as a service or Ingress
    definition.</st> <st c="29289">Instead of plain manifest files that we organize
    in a subfolder next to the source code of our service, there are options to leverage
    templating or</st> <st c="29436">packaging frameworks and tools, such</st> <st
    c="29473">as</st> **<st c="29477">Kustomize</st>** *<st c="29486">[5]</st>* <st
    c="29490">or</st> **<st c="29494">Helm</st>** *<st c="29498">[6]</st>*<st c="29502">.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29126">部署定义可以是一个清单文件或一组清单文件，因为我们可能还需要额外的 K8s 资源，例如服务或 Ingress 定义。</st>
    <st c="29289">与我们将清单文件组织在与服务源代码相邻的子文件夹中的做法不同，我们可以选择使用模板化或</st> <st c="29436">打包框架和工具，如</st>
    **<st c="29477">Kustomize</st>** *<st c="29486">[5]</st>* <st c="29490">或</st>
    **<st c="29494">Helm</st>** *<st c="29498">[6]</st>*<st c="29502">。</st>
- en: <st c="29503">It is important to consider how to organize and version control
    all of our everything as code files.</st> <st c="29605">There are several strategies
    with pros and cons that are well documented.</st> <st c="29679">To learn more,
    the authors suggest reading up on the different patterns for repositories and
    directory structures.</st> <st c="29794">The following section is just a quick
    overview of wha</st><st c="29847">t you must know to continue your in-depth research
    on</st> <st c="29902">this topic!</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29503">考虑如何组织和版本控制所有“作为代码”的文件是非常重要的。</st> <st c="29605">有几种策略，每种策略都有优缺点，并且都有很好的文档支持。</st>
    <st c="29679">如果想深入了解，作者建议阅读关于仓库和目录结构的不同模式。</st> <st c="29794">以下部分只是对你在深入研究这一主题时必须知道的内容的简要概述！</st>
- en: <st c="29913">Monorepo versus polyrepo</st>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="29913">单一仓库与多仓库</st>
- en: <st c="29938">When designing your git repository structure, you have two general
    options which the industry refers to as monorepo</st> <st c="30054">or polyrepo;
    a single Git repository or multiple repositories split by teams</st> <st c="30131">or
    functions:</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29938">在设计 Git 仓库结构时，你有两个常见的选择，业界称之为单一仓库（monorepo）</st> <st c="30054">或多仓库（polyrepo）；一个
    Git 仓库或多个由团队</st> <st c="30131">或职能划分的仓库：</st>
- en: '![Figure 5.3: Mono versus polyrepo – pros and cons for both patterns](img/B31164_05_03.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：单一仓库与多仓库——两种模式的优缺点](img/B31164_05_03.jpg)'
- en: '<st c="30266">Figure 5.3: Mono versus polyrepo – pros and cons for both patterns</st>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30266">图 5.3：单一仓库与多仓库——两种模式的优缺点</st>
- en: '**<st c="30332">Monorepo</st>**<st c="30341">: In the</st> <st c="30350">monorepo
    pattern, all configuration files (code, infrastructure, observability, etc.) are
    stored in a single Git repository.</st> <st c="30476">This pattern applies to
    every potential environment (dev, testing, staging, production)—meaning every
    configuration is in a single Git repo, separated</st> <st c="30627">by folders.</st>'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="30332">单一仓库</st>**<st c="30341">：在单一仓库模式中，所有配置文件（代码、基础设施、可观察性等）都存储在一个
    Git 仓库中。</st> <st c="30476">这种模式适用于每一个潜在的环境（开发、测试、预发布、生产），也就是说，所有配置都在同一个 Git 仓库中，通过文件夹来区分。</st>'
- en: <st c="30638">The benefit of a</st> <st c="30655">monorepo is that everything
    is in one place.</st> <st c="30701">The downside is that this repo will eventually
    become very large, resulting in potential performance issues when tools like ArgoCD
    or Flux need to constantly scan the entire repo for changes.</st> <st c="30893">It
    also makes it harder to separate the concerns between application and</st> <st
    c="30966">infrastructure owners.</st>
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30638">单一仓库的好处是所有内容都集中在一个地方。</st> <st c="30655">缺点是，这个仓库最终会变得非常庞大，当像
    ArgoCD 或 Flux 这样的工具需要不断扫描整个仓库以检查变化时，可能会引发性能问题。</st> <st c="30701">它还使得应用程序和基础设施拥有者之间的关注点分离变得更加困难。</st>
- en: '**<st c="30988">Polyrepo</st>**<st c="30997">: In the</st> <st c="31007">polyrepo
    pattern, we have multiple repositories, which makes it easier to separate concerns.</st>
    <st c="31100">These can be repositories per team (app team A, B, C), per environment
    (dev, staging, prod, etc.), per tenant (in multi-tenancy systems), or per organizational
    boundary (app teams, platform</st> <st c="31290">teams, etc.).</st>'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="30988">多仓库</st>**<st c="30997">：在多仓库模式中，我们有多个仓库，这使得分离关注点变得更加容易。</st>
    <st c="31100">这些可以是按团队划分的仓库（例如，应用团队 A、B、C），按环境划分的仓库（开发、测试、生产等），按租户划分的仓库（在多租户系统中），或者按组织边界划分的仓库（如应用团队、平台团队等）。</st>'
- en: <st c="31303">The</st> <st c="31308">benefit is a better separation of concerns.</st>
    <st c="31352">The downside is that we eventually end up managing a large number
    of Git repositories, which makes it harder to ensure consistency and overall validity
    across all configuratio</st><st c="31527">ns spread across multiple repos that
    make up the</st> <st c="31577">entire configuration.</st>
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="31303">好处在于更好的关注点分离。</st> <st c="31352">缺点是，最终我们会管理大量的 Git 仓库，这使得在所有配置文件中确保一致性和整体有效性变得更加困难。</st><st
    c="31527">这些配置文件分布在多个仓库中，组成了整个配置。</st>
- en: <st c="31598">Directory structure – follow the DRY principle</st>
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="31598">目录结构 – 遵循 DRY 原则</st>
- en: <st c="31645">Whether mono or polyrepo, the individual</st> <st c="31686">Git
    repository will need to have a good directory structure.</st> <st c="31748">Typically,
    we see it reflecting the organizational structure separating the development teams
    from the teams that manage the underlying infrastructure or platform.</st> <st
    c="31912">A good practice is to follow</st> <st c="31941">the</st> **<st c="31945">don’t
    repeat yourself</st>** <st c="31966">(</st>**<st c="31968">DRY</st>**<st c="31971">)</st>
    *<st c="31974">[7]</st>* <st c="31977">principle.</st> <st c="31989">The idea
    is to find the best structure to avoid copying/pasting common YAML settings in
    different places.</st> <st c="32095">This is where tools such as Helm and</st>
    <st c="32132">Kustomize help.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31645">无论是单一仓库还是多仓库，每个</st> <st c="31686">Git 仓库都需要有良好的目录结构。</st> <st
    c="31748">通常，我们会看到它反映了组织结构，将开发团队与管理基础设施或平台的团队分开。</st> <st c="31912">一个好的实践是遵循</st>
    <st c="31941">不重复自己（</st>**<st c="31945">DRY</st>**<st c="31966">）</st> *<st c="31974">[7]</st>*
    <st c="31977">原则。</st> <st c="31989">这个理念的核心是找到最佳结构，以避免在不同位置复制/粘贴常见的 YAML 设置。</st>
    <st c="32095">这就是像 Helm 和</st> <st c="32132">Kustomize 这样的工具提供帮助的地方。</st>
- en: <st c="32147">The following structure example was inspired by a GitOps blog</st>
    <st c="32209">from</st> **<st c="32215">Red Hat</st>** *<st c="32222">[8]</st>*
    <st c="32226">and shows the configuration for the platform administrator and the
    configuration for an application team using a templating tool such</st> <st c="32361">as
    Kustomize.</st> <st c="32375">This structure could either be used in a single
    monorepo separated by a folder, or it could be put into individual repos following
    the</st> <st c="32510">polyrepo pattern.</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32147">以下结构示例灵感来源于一篇来自</st> **<st c="32215">Red Hat</st>** *<st c="32222">[8]</st>*
    <st c="32226">的 GitOps 博客，展示了平台管理员的配置和应用团队使用像 Kustomize 这样的模板工具的配置。</st> <st c="32361">该结构可以用于一个单一的
    monorepo，通过文件夹进行分离，或者按照</st> <st c="32510">polyrepo 模式</st> 进行配置。</st>
- en: '| **<st c="32527">Platform Team</st>** | **<st c="32541">Development Team</st>**
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="32527">平台团队</st>** | **<st c="32541">开发团队</st>** |'
- en: '| --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `<st c="32558">├──</st>` `<st c="32563">bootstrap</st>``<st c="32572">│ ├──</st>`
    `<st c="32579">base</st>``<st c="32583">│ └──</st>` `<st c="32590">overlays</st>``<st
    c="32598">│ └──</st>` `<st c="32605">default</st>``<st c="32612">├──</st>` `<st
    c="32617">cluster-config</st>``<st c="32631">│</st>``**<st c="32633">├──</st>**`
    **`<st c="32637">gitops-controller</st>`** **`<st c="32654">│ ├──</st>` `<st c="32661">identity-provider</st>`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '| `<st c="32558">├──</st>` `<st c="32563">bootstrap</st>``<st c="32572">│ ├──</st>`
    `<st c="32579">base</st>``<st c="32583">│ └──</st>` `<st c="32590">overlays</st>``<st
    c="32598">│ └──</st>` `<st c="32605">default</st>``<st c="32612">├──</st>` `<st
    c="32617">cluster-config</st>``<st c="32631">│</st>``**<st c="32633">├──</st>**`
    **`<st c="32637">gitops-controller</st>`** **`<st c="32654">│ ├──</st>` `<st c="32661">identity-provider</st>`'
- en: '`<st c="32678">│ └──</st>` `<st c="32685">image-scanner</st>`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="32678">│ └──</st>` `<st c="32685">image-scanner</st>`'
- en: '`<st c="32698">└──</st>` `<st c="32703">components</st>`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="32698">└──</st>` `<st c="32703">components</st>`'
- en: '`**<st c="32713">├──</st>**` **`<st c="32718">applicationsets</st>`**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`**<st c="32713">├──</st>**` **`<st c="32718">applicationsets</st>`**'
- en: '**`<st c="32733">├──</st>` `<st c="32738">applications</st>`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**`<st c="32733">├──</st>` `<st c="32738">applications</st>`'
- en: '`**<st c="32750">└──</st>**` **`<st c="32755">argocdproj</st>`******  | `<st
    c="32765">└──</st>` `<st c="32770">deploy</st>``<st c="32776">├──</st>` `<st c="32781">base</st>``<st
    c="32785">└──</st>` `<st c="32790">overlays</st>``<st c="32798">├──</st>` `<st
    c="32803">dev</st>``<st c="32806">├──</st>` `<st c="32811">prod</st>``<st c="32815">└──</st>`
    `<st c="32820">stage</st>` |'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`**<st c="32750">└──</st>**` **`<st c="32755">argocdproj</st>`******  | `<st
    c="32765">└──</st>` `<st c="32770">deploy</st>``<st c="32776">├──</st>` `<st c="32781">base</st>``<st
    c="32785">└──</st>` `<st c="32790">overlays</st>``<st c="32798">├──</st>` `<st
    c="32803">dev</st>``<st c="32806">├──</st>` `<st c="32811">prod</st>``<st c="32815">└──</st>`
    `<st c="32820">stage</st>` |'
- en: '<st c="32825">Table 5.1: One possible directory structure used by tools such
    as Kustomize</st>'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32825">表5.1：Kustomize等工具可能使用的目录结构</st>
- en: <st c="32901">Now that we have learned about the different ways to organize
    our repositories and directory structures, we need to learn how the new container
    image in</st> *<st c="33055">Phase 1</st>* <st c="33062">makes it to our deployment
    definition in</st> <st c="33104">our repositories!</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32901">现在我们已经了解了组织仓库和目录结构的不同方式，接下来需要学习新容器镜像如何从</st> *<st c="33055">第一阶段</st>*
    <st c="33062">进入我们仓库中的部署定义！</st>
- en: <st c="33121">Updating manifest with new container image version</st>
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="33121">用新容器镜像版本更新清单</st>
- en: <st c="33172">The last piece to</st> *<st c="33191">Phase 2</st>* <st c="33198">is
    to promote a</st> <st c="33214">new image version that came out of CI into our
    deployment files.</st> <st c="33280">This could be updating the deployment manifest,
    as shown in the preceding example, or updating a</st> `<st c="33377">values.yaml</st>`
    <st c="33388">file when using</st> <st c="33405">Helm charts.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33172">最后一步是</st> *<st c="33191">第二阶段</st>* <st c="33198">将CI构建出的新镜像版本推广到我们的部署文件中。</st>
    <st c="33280">这可能是更新部署清单，如前面的示例所示，或者在使用</st> `<st c="33377">values.yaml</st>`
    <st c="33388">文件时更新</st> <st c="33405">Helm图表。</st>
- en: <st c="33417">As those configuration files are version-controlled in a Git repository
    (mono or poly, it doesn’t matter), we should follow the regular Git workflow and
    create a Pull Request to promote the update of that image.</st> <st c="33630">We
    can automate the creation of that Pull Request in</st> <st c="33683">two ways:</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33417">由于这些配置文件是版本控制的，存储在Git仓库中（无论是单一仓库还是多个仓库，都没有关系），我们应该遵循常规的Git工作流，创建一个Pull
    Request来推广镜像的更新。</st> <st c="33630">我们可以通过以下两种方式自动创建该Pull Request：</st>
- en: '**<st c="33692">Step in CI pipeline</st>**<st c="33712">: As the last step
    in CI, a Pull Request</st> <st c="33753">can be opened, promoting the new image
    tag to the respective deployment definition repo and the right directory structure
    (for example, updating the values in the development overlay directory if this
    is a newly</st> <st c="33966">built image)</st>'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33692">CI流水线中的步骤</st>**<st c="33712">：作为CI的最后一步，可以打开一个Pull Request，将新镜像标签推广到相应的部署定义仓库和正确的目录结构（例如，如果这是一个新构建的镜像，则更新开发覆盖目录中的值）</st>'
- en: '**<st c="33978">Webhook in a container registry</st>**<st c="34010">: When
    the registry receives a new image from CI, it can trigger a webhook, which allows</st>
    <st c="34100">us to create that same Pull Request in our deployment</st> <st c="34154">Git
    repository</st>'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="33978">容器注册表中的Webhook</st>**<st c="34010">：当注册表接收到CI的新镜像时，它可以触发一个Webhook，允许</st>
    <st c="34100">我们在部署</st> <st c="34154">Git仓库中创建相同的Pull Request</st>'
- en: <st c="34168">The following shows the updated version information of the</st>
    *<st c="34228">Kubernetes Deployment</st>* <st c="34249">that we have seen in
    the earlier example.</st> <st c="34292">You can compare this with the values of
    the</st> <st c="34336">previous example:</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34168">以下是我们在前面示例中看到的</st> *<st c="34228">Kubernetes部署</st>* <st c="34249">的更新版本信息。</st>
    <st c="34292">你可以将其与之前示例中的值进行对比：</st>
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="34780">Now, we know how a new image that is built by CI makes it into
    the deployment definition in our respective repositories.</st> <st c="34902">We
    already saw the GitOps operator in an image earlier in this chapter.</st> <st
    c="34974">Now, it’s time to dive into what the GitOps operator really does to
    apply our desired state from Git to our</st> <st c="35082">target cluster</st><st
    c="35096">s!</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34780">现在，我们知道了由CI构建的新镜像是如何进入我们各自仓库中的部署定义的。</st> <st c="34902">我们之前已经看到过GitOps操作符在本章中的图像。</st>
    <st c="34974">现在，是时候深入了解GitOps操作符如何将我们在Git中的目标状态应用到我们的</st> <st c="35082">目标集群</st><st
    c="35096">了！</st>
- en: <st c="35099">Phase 3 – GitOps – keeping your desired deployment state</st>
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="35099">第三阶段 – GitOps – 保持你期望的部署状态</st>
- en: <st c="35156">Now that we have everything as code in Git, it’s time to talk
    about how to apply that configuration to our target environments.</st> <st c="35285">One
    way is to use the same push model as we use for CI.</st> <st c="35341">We could
    have delivery pipelines get triggered on changes in our Git repository and then
    have the latest version of the manifests or helm charts applied to the target
    environment.</st> <st c="35521">In this chapter, we, however, focus on and favor
    the Pull model, which is implemented by GitOps operators or GitOps agents, such
    as Argo CD, Flux, and some</st> <st c="35677">commercial offering</st><st c="35696">s.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35156">现在我们已经将所有内容作为代码存储在 Git 中，是时候讨论如何将这些配置应用到目标环境了。</st> <st c="35285">一种方法是使用与
    CI 相同的推送模型。</st> <st c="35341">我们可以在 Git 仓库发生更改时触发交付管道，然后将最新版本的清单或 Helm 图表应用到目标环境。</st>
    <st c="35521">然而，在本章中，我们专注并倾向于使用拉取模型，这由 GitOps 操作员或 GitOps 代理实现，例如 Argo CD、Flux
    以及一些</st> <st c="35677">商业产品</st><st c="35696">。</st>
- en: <st c="35699">GitOps operators in a nutshell – sync Git to K8s</st>
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="35699">GitOps 操作员简介 – 将 Git 同步到 K8s</st>
- en: <st c="35748">GitOps operators</st> <st c="35765">continuously reconcile and
    ensure that the desired state declared in our repositories matches the actual
    state running in our target environments.</st> <st c="35913">The operator detects
    an</st> *<st c="35937">out-of-sync</st>* <st c="35948">if the state in Git does
    not match the one on the target environment.</st> <st c="36019">This could happen
    if the Git configuration was changed (e.g., a new image is available and causes
    a manifest update).</st> <st c="36137">It can also happen if somebody changes
    the configuration in K8s (e.g., through a manual update or a different automation
    tooling).</st> <st c="36268">The following is a high-level overview showing the
    role of the</st> <st c="36331">GitOps operator:</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35748">GitOps 操作员</st> <st c="35765">持续调和并确保我们在仓库中声明的期望状态与目标环境中实际运行的状态匹配。</st>
    <st c="35913">如果 Git 中的状态与目标环境中的状态不匹配，操作员会检测到一个</st> *<st c="35937">不同步</st>*
    <st c="35948">的情况。</st> <st c="36019">这种情况可能发生在 Git 配置更改时（例如，新的镜像可用并导致清单更新）。</st>
    <st c="36137">也可能发生在有人修改了 K8s 中的配置时（例如，通过手动更新或使用不同的自动化工具）。</st> <st c="36268">以下是一个高层次的概述，展示了
    GitOps 操作员的角色：</st> <st c="36331">GitOps 操作员：</st>
- en: '![Figure 5.4: GitOps operator synchronizes the desired state in Git with the
    actual state in K8s](img/B31164_05_04.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4：GitOps 操作员将 Git 中的期望状态与 K8s 中的实际状态同步](img/B31164_05_04.jpg)'
- en: '<st c="36448">Figure 5.4: GitOps operator synchronizes the desired state in
    Git with the actual state in K8s</st>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36448">图 5.4：GitOps 操作员将 Git 中的期望状态与 K8s 中的实际状态同步</st>
- en: <st c="36542">Depending on the GitOps operator tool, there will be different
    configuration options in the reconciliation process.</st> <st c="36659">It’s worth
    checking out the documentation of the two prominent tools in the cloud native</st>
    <st c="36748">ecosystem:</st> **<st c="36759">Argo CD</st>** *<st c="36766">[9]</st>*
    <st c="36770">and</st> **<st c="36775">Flux</st>** *<st c="36779">[10]</st>*<st
    c="36784">. Also, make</st> <st c="36797">yourself familiar with the configuration
    elements, as some tools have a concept of projects and applications, whereas others
    just have a concept of</st> <st c="36945">a sou</st><st c="36950">rce.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36542">根据 GitOps 操作员工具的不同，调和过程中的配置选项也会有所不同。</st> <st c="36659">值得查看云原生生态系统中两个重要工具的文档：</st>
    **<st c="36759">Argo CD</st>** *<st c="36766">[9]</st>* <st c="36770">和</st> **<st
    c="36775">Flux</st>** *<st c="36779">[10]</st>*<st c="36784">。另外，请熟悉配置元素，因为一些工具有项目和应用程序的概念，而其他工具则只有</st>
    <st c="36945">源</st><st c="36950">的概念。</st>
- en: <st c="36955">Understanding reconciliation – keeping K8s in sync with Git</st>
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="36955">理解调和 – 保持 K8s 与 Git 的同步</st>
- en: '<st c="37015">Essentially, the GitOps operator will fetch the desired state
    for a project or application from a source (Git repository, a folder in the Git
    repository, the OCI repository, S3 buckets, etc.) and compare it with the current
    state running on the target K8s cluster.</st> <st c="37281">The two states can
    either be</st> *<st c="37310">synced</st>* <st c="37316">or</st> *<st c="37320">out-of-sync</st>*<st
    c="37331">. When the state is</st> *<st c="37351">out-of-sync</st>*<st c="37362">,
    there are different options for the GitOps operator to synchronize the states
    – meaning: bring the current state to match the</st> <st c="37490">desired state:</st>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37015">从本质上来说，GitOps 操作会从源头（如 Git 仓库、Git 仓库中的文件夹、OCI 仓库、S3 存储桶等）获取项目或应用的期望状态，并与目标
    K8s 集群上当前运行的状态进行比较。</st> <st c="37281">这两个状态可能是</st> *<st c="37310">同步的</st>*
    <st c="37316">或</st> *<st c="37320">不同步的</st>*<st c="37331">。当状态是</st> *<st c="37351">不同步</st>*<st
    c="37362">时，GitOps 操作有不同的选项来同步这些状态——即：将当前状态调整为匹配</st> <st c="37490">期望状态：</st>
- en: '**<st c="37504">Manual sync</st>**<st c="37516">: Either via</st> <st c="37529">a</st>
    **<st c="37532">command-line interface</st>** <st c="37554">(</st>**<st c="37556">CLI</st>**<st
    c="37559">) or a</st> <st c="37566">UI, one can trigger the GitOps operator to
    synchronize the</st> <st c="37626">two states.</st>'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="37504">手动同步</st>**<st c="37516">：通过</st> <st c="37529">命令行接口</st>
    **<st c="37532">CLI</st>** <st c="37554">(</st>**<st c="37556">CLI</st>**<st c="37559">)
    或者</st> <st c="37566">用户界面(UI)，可以触发 GitOps 操作来同步这</st> <st c="37626">两个状态。</st>'
- en: '**<st c="37637">Auto sync</st>**<st c="37647">: Once a</st> <st c="37657">system
    is out-of-sync, the GitOps operator tries to</st> <st c="37709">automatically
    synchronize.</st>'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="37637">自动同步</st>**<st c="37647">：一旦</st> <st c="37657">系统出现不同步，GitOps
    操作会尝试</st> <st c="37709">自动同步。</st>'
- en: '**<st c="37735">Sync schedules/windows</st>**<st c="37758">: There might</st>
    <st c="37772">be times when you want or don’t want syncs to happen.</st> <st c="37827">This
    is where sync schedules or sync windows come in, which either block or allow syncs</st>
    <st c="37915">to happen.</st>'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="37735">同步计划/窗口</st>**<st c="37758">：可能会有一些时候你希望或者不希望同步发生。</st> <st
    c="37772">这时，同步计划或同步窗口就发挥作用了，它们可以阻止或允许同步</st> <st c="37915">发生。</st>'
- en: '**<st c="37925">Sync failed</st>**<st c="37937">: It can happen</st> <st c="37954">that
    the GitOps operator can’t apply the desired state.</st> <st c="38010">This could
    be because of configuration file mistakes (e.g., referencing an invalid image).</st>
    <st c="38101">It could be because of an infrastructure issue (e.g., K8s doesn’t
    have enough resources).</st> <st c="38191">It could also be because of competing
    tools (e.g., auto-scaling tools, such as HPA/KEDA, changing replicas or resource
    limits).</st> <st c="38319">It’s important to be aware of this state and handle
    it correctly.</st> <st c="38385">See the section on best practices for some</st>
    <st c="38428">additional input!</st>'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="37925">同步失败</st>**<st c="37937">：有时</st> <st c="37954">GitOps 操作可能无法应用期望的状态。</st>
    <st c="38010">这可能是由于配置文件错误（例如，引用了无效的镜像）。</st> <st c="38101">也可能是因为基础设施问题（例如，K8s
    的资源不足）。</st> <st c="38191">还可能是由于工具之间的冲突（例如，自动扩展工具，如 HPA/KEDA，正在更改副本或资源限制）。</st>
    <st c="38319">重要的是要意识到这种状态并正确处理。</st> <st c="38385">请参阅最佳实践部分以获取一些</st> <st c="38428">额外的建议！</st>'
- en: <st c="38445">Now that we are aware of the synchronization basics, let’s have
    a look at different GitOps operator</st> <st c="38546">deployment</st> <st c="38557">patterns!</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38445">现在我们了解了同步的基本知识，接下来让我们看看不同的 GitOps 操作</st> <st c="38546">部署</st>
    <st c="38557">模式吧！</st>
- en: <st c="38566">GitOps operator patterns – single, hub and spoke, and many-to-many</st>
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="38566">GitOps 操作模式 – 单一模式、中心辐射模式和多对多模式</st>
- en: <st c="38633">The simplest version – and</st> <st c="38660">probably the model
    that many start with – is the monorepo approach with GitOps operators pulling
    into a single target environment, as we have seen in</st> *<st c="38811">Figure
    5</st>**<st c="38819">.3</st>* <st c="38821">for both patterns.</st> <st c="38841">While
    the single target is a common pattern, especially as you are getting started with
    GitOps, we have other patterns that we want to</st> <st c="38976">quickly highlight.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38633">最简单的版本 – 也是许多人开始时可能会使用的模型 – 是 monorepo 方法，GitOps 操作从单一目标环境中拉取，如我们在</st>
    *<st c="38811">图 5</st>**<st c="38819">.3</st>* <st c="38821">中看到的两种模式。</st> <st
    c="38841">虽然单一目标是一个常见模式，特别是当你刚开始使用 GitOps 时，我们还有其他模式需要</st> <st c="38976">快速介绍一下。</st>
- en: <st c="38994">GitOps can also be set up where we have a central GitOps operator
    that keeps the desired state as declared in Git and synchronizes with several
    target environments by pushing out those changes.</st> <st c="39189">This is called</st>
    <st c="39203">the</st> **<st c="39208">hub-and-spoke model</st>**<st c="39227">.
    Another option is the</st> **<st c="39251">many-to-many model</st>**<st c="39269">,
    where each target environment has its own GitOps</st> <st c="39320">operator that
    continuously synchronizes the desired state with the state on its own cluster,
    as shown in the</st> <st c="39429">following figure:</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38994">GitOps 也可以设置为一个中心 GitOps 操作员，它将 Git 中声明的期望状态保持一致，并通过推送这些更改与多个目标环境进行同步。</st>
    <st c="39189">这被称为</st> <st c="39203">集线器-辐射模型</st> **<st c="39208">hub-and-spoke
    model</st>**<st c="39227">。另一种选择是</st> **<st c="39251">多对多模型</st>**<st c="39269">，其中每个目标环境都有自己的
    GitOps 操作员，它会不断地将期望状态与其自身集群中的状态进行同步，如下图所示：</st>
- en: '![Figure 5.5: Hub-and-spoke and many-to-many GitOps operator pattern](img/B31164_05_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5：集线器-辐射模式和多对多 GitOps 操作模式](img/B31164_05_05.jpg)'
- en: '<st c="39503">Figure 5.5: Hub-and-spoke and many-to-many GitOps operator pattern</st>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39503">图 5.5：集线器-辐射模式和多对多 GitOps 操作模式</st>
- en: <st c="39569">Now that we have discussed the major phases in GitOps, let’s recap
    and have a quick look into some</st> <st c="39669">best</st> <st c="39673">practices.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39569">现在我们已经讨论了 GitOps 中的主要阶段，让我们总结一下，并快速看一下几个</st> <st c="39669">最佳</st>
    <st c="39673">实践。</st>
- en: <st c="39684">GitOps best practices</st>
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="39684">GitOps 最佳实践</st>
- en: <st c="39706">This list is not complete but should</st> <st c="39744">give you
    a good starting point when defining your</st> <st c="39793">GitOps process:</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39706">这个列表并不完整，但应该能为你在定义 GitOps 过程时提供一个良好的起点：</st>
- en: '**<st c="39809">Separate config from source code repositories/folders</st>**<st
    c="39863">: It’s recommended to separate the actual source code from the deployment
    definitions.</st> <st c="39951">Either in separate repositories or, within the
    repo, in separate folders.</st> <st c="40025">Why is that?</st> <st c="40038">It’s
    a clean separation of concerns and access.</st> <st c="40086">It makes Git-triggered
    actions easier as a change in a deployment config file should trigger different
    actions than in the source code files.</st> <st c="40228">It avoids a potentially
    infinite loop of change if CI changes the same repository!</st> <st c="40311">The
    smaller the repository, the less work for GitOps tools to scan all files to determine
    the</st> <st c="40405">desired state.</st>'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="39809">将配置与源代码库/文件夹分离</st>**<st c="39863">：建议将实际的源代码与部署定义分开。</st>
    <st c="39951">可以放在不同的仓库中，或者在同一仓库中放在不同的文件夹里。</st> <st c="40025">为什么要这么做？</st> <st
    c="40038">这是为了清晰地分离关注点和访问权限。</st> <st c="40086">这使得 Git 触发的操作变得更加简便，因为在部署配置文件中的更改应该触发与源代码文件中不同的操作。</st>
    <st c="40228">如果 CI 修改相同的仓库，它避免了可能的无限循环变化！</st> <st c="40311">仓库越小，GitOps 工具扫描所有文件以确定期望状态所需的工作就越少。</st>'
- en: '**<st c="40419">Proper sync settings – poll versus webhook</st>**<st c="40462">:
    GitOps tools provide different sync settings for both scanning the source systems
    (e.g., Git) and scheduling the triggering of synchronizations.</st> <st c="40610">For
    scanning, make yourself familiar with the default poll frequency (e.g., Argo CD,
    by default, pulls all Git repos every three minutes).</st> <st c="40749">Both
    Argo CD and Flux can also be changed to receive webhooks from the Git system,
    which replaces the pull into a push mechanism!</st> <st c="40879">This is very
    important to understand, as with an increase in the number of source systems (Git,
    artifact repositories, S3 buckets, etc.), the number of API calls from your GitOps
    tool to those systems increases.</st> <st c="41091">It’s a good practice to monitor
    the number of calls made from the GitOps tool to those external systems to get
    alerted in case the behavior drastically changes.</st> <st c="41252">A change
    in behavior could be caused by an accidental configuration change of default settings.</st>
    <st c="41348">Most tools provide Prometheus or OpenTelemetry metrics that can
    be observed by your</st> <st c="41432">observability tool!</st>'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="40419">正确的同步设置 – 拉取与 Webhook</st>**<st c="40462">：GitOps 工具提供不同的同步设置，用于扫描源系统（如
    Git）和调度触发同步。</st> <st c="40610">对于扫描，了解默认的拉取频率非常重要（例如，默认情况下，Argo CD 每三分钟拉取一次所有
    Git 仓库）。</st> <st c="40749">Argo CD 和 Flux 还可以配置为接收来自 Git 系统的 Webhook，这样就将拉取机制替换为推送机制！</st>
    <st c="40879">这非常重要，因为随着源系统（Git、工件仓库、S3 存储桶等）数量的增加，从 GitOps 工具到这些系统的 API 调用次数也会增加。</st>
    <st c="41091">因此，最好监控 GitOps 工具到外部系统的调用次数，以便在行为发生剧烈变化时及时收到警报。</st> <st c="41252">行为的变化可能是由于不小心更改了默认设置的配置。</st>
    <st c="41348">大多数工具提供 Prometheus 或 OpenTelemetry 指标，可以通过你的</st> <st c="41432">可观测性工具进行观察！</st>'
- en: <st c="41451">The authors have seen configurations that ended in API rate limits
    and even crashing Git systems due to too much load produced by the GitOps tools
    during</st> <st c="41606">a sync!</st>
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="41451">作者见过由于 GitOps 工具在同步过程中产生过多负载，导致 API 限制甚至使 Git 系统崩溃的配置！</st> <st
    c="41606">同步！</st>
- en: '**<st c="41613">Not every config must be in a manifest</st>**<st c="41652">:
    As GitOps keeps track of desired versus actual state, it’s important to leave
    some configuration out of your manifest that might be managed by different tools.</st>
    <st c="41815">Take replicas as an example.</st> <st c="41844">If you are using
    tools such as HPA or KEDA to auto-scale your pods, you do not want a static replicas
    count in your manifest.</st> <st c="41970">This would lead the GitOps tool to
    detect out-of-syncs for any change that HPA/KEDA does.</st> <st c="42060">This,
    therefore, results in two automation tools competing with</st> <st c="42124">each
    other.</st>'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="41613">并非每个配置都必须在清单中</st>**<st c="41652">：由于 GitOps 跟踪期望状态与实际状态，因此重要的是将一些可能由不同工具管理的配置排除在清单之外。</st>
    <st c="41815">以副本为例。</st> <st c="41844">如果你使用 HPA 或 KEDA 等工具来自动扩展 Pod，则不希望在清单中设置静态的副本数。</st>
    <st c="41970">这会导致 GitOps 工具在 HPA/KEDA 进行任何更改时检测到不同步状态。</st> <st c="42060">因此，导致两个自动化工具彼此竞争。</st>
    <st c="42124">彼此竞争。</st>'
- en: '**<st c="42135">GitOps notifications to handle sync states</st>**<st c="42178">:
    GitOps tools provide notifications when sync status changes.</st> <st c="42242">This
    would be when GitOps detects an out-of-sync, when it finishes a sync, or when
    there is an issue and a sync fails.</st> <st c="42361">In all those cases, it’s
    important to get notified as you want to make sure that you handle sync failures
    or send information back to the development</st> <st c="42511">team when the latest
    update has successfully</st> <st c="42556">been</st> <st c="42560">synced.</st>'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42135">GitOps 通知以处理同步状态</st>**<st c="42178">：GitOps 工具在同步状态变化时提供通知。</st>
    <st c="42242">这通常发生在 GitOps 检测到不同步状态时，完成同步时，或当同步失败时出现问题。</st> <st c="42361">在这些情况下，收到通知非常重要，因为你需要确保能够处理同步失败或在最新更新成功同步时将信息反馈给开发团队。</st>
    <st c="42511">团队。</st> <st c="42556">已</st> <st c="42560">同步。</st>'
- en: <st c="42568">To get notified, GitOps tools will create Kubernetes events that
    you can ingest into your observability solution and then react/alert on them.</st>
    <st c="42712">GitOps tools also typically provide some type of native notification
    feature where an external tool can be triggered in the case of a special event.</st>
    <st c="42861">Flux, for instance, provides Alerts, whereas Argo CD provides a
    concept of notifications.</st> <st c="42951">Both allow you to, for example, send
    Slack messages or trigger other external tools in the case of certain events that</st>
    <st c="43070">need attention!</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42568">为了接收通知，GitOps 工具会创建 Kubernetes 事件，你可以将这些事件导入到你的可观测性解决方案中，并对其进行反应/警报。</st>
    <st c="42712">GitOps 工具通常还提供某种类型的本地通知功能，当发生特定事件时，可以触发外部工具。</st> <st c="42861">例如，Flux
    提供了警报功能，而 Argo CD 提供了通知的概念。</st> <st c="42951">这两者都允许你在某些需要关注的事件发生时，发送 Slack 消息或触发其他外部工具！</st>
- en: <st c="43085">GitOps – changing from push to pull</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43085">GitOps——从推送到拉取的转变</st>
- en: <st c="43121">GitOps expands the power of Git from application code to everything
    as code.</st> <st c="43199">While CI/CD still focuses on building artifacts, GitOps
    provides an elegant way to pull the desired deployment state into any target environment
    along the software development life cycle.</st> <st c="43387">Changes to a system
    can only be done through Git with the benefit of traceability of changes, revertability
    to a previous version, and enforcing review processes through</st> <st c="43557">Pull
    Requests.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43121">GitOps 将 Git 的力量从应用代码扩展到一切皆代码。</st> <st c="43199">虽然 CI/CD 仍然侧重于构建工件，但
    GitOps 提供了一种优雅的方式，将所需的部署状态拉取到软件开发生命周期中的任何目标环境。</st> <st c="43387">系统的变更只能通过 Git
    完成，借助变更可追溯性、回滚到先前版本的功能，并通过 Pull Requests 强制执行审查流程。</st>
- en: <st c="43571">Now that we have covered the basics of GitOps, we should see how
    this can benefit us in building modern platforms.</st> <st c="43687">As platform
    teams, we can centrally enforce best practices (version control, policies, etc.)
    by using automation in CI/CD and the container registry to reduce the chance of
    a bad change request.</st> <st c="43882">With Git, every change and deployment
    is traceable back to a Git commit, making troubleshooting much easier, and it
    also provides an additional level of self-service (e.g., notify development teams
    when their change has been synchronized to the target environment or notify them
    when their latest version (via the</st> `<st c="44196">git commit</st>` <st c="44206">hash)
    has</st> <st c="44217">any issues).</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43571">现在我们已经覆盖了 GitOps 的基础内容，我们应该看看它如何在构建现代平台中对我们有所帮助。</st> <st c="43687">作为平台团队，我们可以通过在
    CI/CD 中使用自动化以及容器注册表来集中执行最佳实践（版本控制、策略等），从而减少错误变更请求的可能性。</st> <st c="43882">通过 Git，每个变更和部署都可以追溯到
    Git 提交，这使得故障排除变得更加容易，同时它还提供了额外的自服务功能（例如，当你的变更已经同步到目标环境时，通知开发团队，或通过</st> `<st c="44196">git
    commit</st>` <st c="44206">哈希值</st> <st c="44217">通知他们最新版本存在问题）。</st>
- en: <st c="44229">Now, let’s go on and spend some time on container registries as,
    without them, we wouldn’t be able to publish or distribute any of the images that
    are being produced by the development teams that leverage the platform as</st>
    <st c="44451">a self-service.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44229">现在，让我们花些时间讲解容器注册表，因为没有它们，我们将无法发布或分发开发团队利用平台作为自服务所生成的任何镜像。</st>
    <st c="44451">一个自服务平台。</st>
- en: <st c="44466">Understanding the importance of container and artifact registries
    as entry points</st>
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="44466">理解容器和工件注册表作为入口点的重要性</st>
- en: <st c="44548">Container and artifact registries deserve their own chapter as
    they are one of the core building blocks of modern cloud-native platforms.</st>
    <st c="44687">However, we will try to provide the relevant knowledge that should
    help you follow along with what’s to come in the later chapters of</st> <st c="44821">this
    book.</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44548">容器和工件注册表值得单独成章，因为它们是现代云原生平台的核心构建块之一。</st> <st c="44687">然而，我们将尽量提供相关知识，以帮助你跟随本书后续章节的内容。</st>
- en: <st c="44831">We differentiate between public and</st> <st c="44868">private
    registries:</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44831">我们区分公有注册表和</st> <st c="44868">私有注册表：</st>
- en: '**<st c="44887">Public registries</st>** <st c="44905">are commonly</st> <st
    c="44919">used by individuals or small teams that want to get up and running with
    their registries as quickly as possible.</st> <st c="45032">However, at some point,
    it’s worth looking at</st> <st c="45078">private registries.</st>'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="44887">公共注册中心</st>** <st c="44905">通常由个人或小团队使用，这些用户希望尽可能快速地启动并运行他们的注册中心。</st>
    <st c="45032">然而，某些时候，值得考虑</st> <st c="45078">私有注册中心。</st>'
- en: '**<st c="45097">Private registries</st>** <st c="45116">provide</st> <st c="45124">several
    critical capabilities, such as efficient storage of images, scanning for vulnerabilities,
    replicating images to other registries, enforcing access control when images get
    pulled, and notifying other tools about updates, with the ultimate goal of making
    images fast and easily accessible to those environments that need to</st> <st
    c="45455">deploy them.</st>'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="45097">私有注册中心</st>** <st c="45116">提供</st> <st c="45124">几个关键功能，如高效的镜像存储、漏洞扫描、将镜像复制到其他注册中心、在拉取镜像时强制执行访问控制以及通知其他工具有关更新的内容，最终目标是使镜像能够快速、轻松地被需要它们的环境部署。</st>'
- en: <st c="45467">While private container registries are typically only accessed
    internally to push new builds and have them pulled by our GitOps tools, we can
    also open the registry to the</st> *<st c="45639">public</st>*<st c="45646">.
    With the</st> *<st c="45657">public</st>*<st c="45663">, we mean</st> <st c="45672">allowing
    third-party vendors the option to push their latest images or deployment artifacts.</st>
    <st c="45766">As organizations rely on third-party software – think about any
    off-the-shelf software product you deploy yourself – we can leverage the same
    process of vulnerability scanning, replication, and access control before that
    software gets deployed on the internal systems.</st> <st c="46035">Financial One
    ACME, for instance, could allow their third-party vendors for a Development Ticketing
    System to push new versions to that public endpoint.</st> <st c="46188">Once scanned
    and validated, it can be deployed to the internal K8s clusters that run all the</st>
    <st c="46281">development tooling.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45467">虽然私有容器注册中心通常仅在内部访问，用于推送新的构建并由我们的GitOps工具拉取，但我们也可以将注册中心开放给</st>
    *<st c="45639">公众</st>*<st c="45646">。这里的</st> *<st c="45657">公众</st>*<st c="45663">指的是</st>
    <st c="45672">允许第三方供应商将他们最新的镜像或部署构件推送到此公共端点。</st> <st c="45766">随着组织依赖于第三方软件——想想你自己部署的任何现成软件产品——我们可以在这些软件部署到内部系统之前，利用相同的漏洞扫描、复制和访问控制过程。</st>
    <st c="46035">例如，金融公司ACME可能允许他们的第三方供应商为开发票务系统推送新版本到该公共端点。</st> <st c="46188">一旦扫描并验证完毕，这些版本就可以部署到运行所有开发工具的内部K8s集群中。</st>
- en: <st c="46301">The following illustration is a very high-level overview of how
    container registries integrate into the end-to-end delivery process that starts
    with pushing a new artifact (third-party or CI/CD) until that new artifact gets
    deployed to the</st> <st c="46542">target environments:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了容器注册中心如何集成到端到端交付过程中，该过程从推送一个新的构件（第三方或CI/CD）开始，直到该新构件被部署到目标环境：
- en: '![Figure 5.6: Container registries – the heartbeat of our platform](img/B31164_05_06.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6: 容器注册中心 – 我们平台的心跳](img/B31164_05_06.jpg)'
- en: '<st c="46750">Figure 5.6: Container registries – the heartbeat of our platform</st>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="46750">图 5.6: 容器注册中心 – 我们平台的心跳</st>'
- en: <st c="46814">While there is a lot of in-depth information available from the
    different open source and commercial registry vendors, we want to give a quick
    overview of how registries fit into our platform engineering architecture, why
    certain concepts are important, and how we can best make container registries
    available to our end users as an easy to</st> <st c="47156">use self-service!</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46814">虽然从不同的开源和商业注册中心供应商那里可以获得大量深入的信息，但我们想简要概述一下注册中心如何融入我们的平台工程架构、为什么某些概念很重要，以及我们如何最好地将容器注册中心作为易于使用的自助服务提供给终端用户！</st>
- en: <st c="47173">From container to artifact registry</st>
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="47173">从容器到构件注册中心</st>
- en: <st c="47209">Before diving into the</st> <st c="47233">process, we need to
    quickly highlight that container registries – while the name implies it – are
    not limited to container images.</st> <st c="47364">Most container registries
    typically support the OCI</st> *<st c="47416">[11]</st>* <st c="47420">image standard.</st>
    <st c="47437">Over the past years, container registries expanded to support non-container
    artifacts such as Helm Charts, zipped versions of Manifests, or Kustomize-based
    templates.</st> <st c="47604">That expansion also came with a name change for
    artifact registries as those tools manage artifacts in general and not just</st>
    <st c="47728">container images.</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47209">在深入探讨</st> <st c="47233">过程之前，我们需要快速指出，容器注册表——尽管名字有这种暗示——并不局限于容器镜像。</st>
    <st c="47364">大多数容器注册表通常支持 OCI</st> *<st c="47416">[11]</st>* <st c="47420">镜像标准。</st>
    <st c="47437">在过去的几年中，容器注册表扩展了对非容器工件的支持，如 Helm Charts、压缩版的 Manifests 或基于 Kustomize
    的模板。</st> <st c="47604">这种扩展还带来了工件注册表名称的变化，因为这些工具管理的是一般的工件，而不仅仅是</st> <st c="47728">容器镜像。</st>
- en: <st c="47745">But that is not all.</st> <st c="47767">Artifact registries, open
    source, or</st> **<st c="47804">SaaS</st>** <st c="47808">(short for</st> **<st
    c="47820">Software as a Service</st>**<st c="47841">) services, often come</st>
    <st c="47865">with additional features, such as access control, regional replication,
    audit logging, policy enforcement, security scanning, notificatio</st><st c="48002">ns,
    and</st> <st c="48011">even more.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47745">但这还不是全部。</st> <st c="47767">工件注册表、开源软件或</st> **<st c="47804">SaaS</st>**
    <st c="47808">(即</st> **<st c="47820">软件即服务</st>**<st c="47841">) 服务，通常还具备其他功能，如访问控制、区域复制、审计日志、策略执行、安全扫描、通知</st><st
    c="48002">等</st> <st c="48011">更多功能。</st>
- en: <st c="48021">Building and pushing artifacts to the registry</st>
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="48021">构建和推送工件到注册表</st>
- en: '*<st c="48068">Uploading</st>* <st c="48078">(</st>*<st c="48080">pushing</st>*<st
    c="48087">) and</st> *<st c="48094">downloading</st>* <st c="48105">(</st>*<st
    c="48107">pulling</st>*<st c="48114">) images can be done</st> <st c="48136">using
    Docker (or other tools, such as Podman) commands.</st> <st c="48192">Before doing
    so, you need to authenticate against the registry (your private or public registry,
    such as Docker Hub).</st> <st c="48310">Once authenticated, it’s easy to push
    and pull, as shown in the</st> <st c="48374">following code:</st>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="48068">上传</st>* <st c="48078">(</st>*<st c="48080">推送</st>*<st c="48087">)
    和</st> *<st c="48094">下载</st>* <st c="48105">(</st>*<st c="48107">拉取</st>*<st
    c="48114">) 镜像可以使用 Docker（或其他工具，如 Podman）命令来完成。</st> <st c="48136">在此之前，你需要先对注册表进行身份验证（无论是私有还是公共注册表，例如
    Docker Hub）。</st> <st c="48192">一旦认证通过，推送和拉取就非常简单，如以下代码所示：</st>'
- en: <st c="48389">Interacting with the container registry via docker commands</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48389">通过 docker 命令与容器注册表交互</st>
- en: '[PRE5]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="48778">When building new images as part of the CI process, it’s important
    to follow best practices around image labels and metadata.</st> <st c="48905">The
    OCI therefore also has a list of suggested annotations</st> *<st c="48964">[12]</st>*
    <st c="48968">as part of their image spec that should be used, such as</st> `<st
    c="49026">created</st>`<st c="49033">,</st> `<st c="49035">authors</st>`<st c="49042">,</st>
    `<st c="49044">url</st>`<st c="49047">, and</st> `<st c="49053">documentation</st>`
    <st c="49066">(all prefixed</st> <st c="49081">with</st> `<st c="49086">org.opencontainers.image.</st>`<st
    c="49111">).</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48778">在 CI 过程中构建新镜像时，遵循最佳实践来处理镜像标签和元数据非常重要。</st> <st c="48905">因此，OCI
    也在其镜像规范中列出了建议的注释</st> *<st c="48964">[12]</st>* <st c="48968">，如</st> `<st c="49026">created</st>`<st
    c="49033">，</st> `<st c="49035">authors</st>`<st c="49042">，</st> `<st c="49044">url</st>`<st
    c="49047">，以及</st> `<st c="49053">documentation</st>` <st c="49066">(所有前缀为</st>
    <st c="49081">`org.opencontainers.image.`</st><st c="49111">)</st>。
- en: <st c="49114">Next to an API interface, registries typically also provide</st>
    <st c="49174">a</st> **<st c="49177">user interface</st>** <st c="49191">(</st>**<st
    c="49193">UI</st>**<st c="49195">) that makes it easier to see what images are
    uploaded, how much space they consume, and – depending on the management features
    of the registry – also provides the configurational aspects of all those capabilities
    (e.g., creating projects, managing users, specifying policies, configu</st><st
    c="49480">ring</st> <st c="49486">webhooks, etc.).</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49114">除了API接口外，注册表通常还提供</st> <st c="49174">一个</st> **<st c="49177">用户界面</st>**
    <st c="49191">(</st>**<st c="49193">UI</st>**<st c="49195">)，使得查看已上传的镜像、它们占用的空间以及根据注册表的管理功能提供所有这些功能的配置方面（例如，创建项目、管理用户、指定策略、配置</st><st
    c="49480">webhooks</st> <st c="49486">等）变得更加容易。</st>
- en: <st c="49502">Managing uploaded artifacts</st>
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="49502">管理已上传的工件</st>
- en: <st c="49530">Registries typically</st> <st c="49551">manage artifacts in projects.</st>
    <st c="49582">Projects can be private or public within the registry, meaning that
    artifacts in a public project can be accessed by anyone who can reach the registry,
    while private projects can only be reached by authorized users.</st> <st c="49798">That
    brings us to user management and access controls, which can be defined on a project
    level, and can also feed into access logs.</st> <st c="49930">Registries will
    create logs for every push and pull to have a good audit trail.</st> <st c="50010">The
    CNCF Harbor</st> <st c="50025">is a very popular container registry that also
    provides good documentation about all those features.</st> <st c="50127">Instead
    of going into detail here, we suggest you read up on the publicly available documentation</st>
    *<st c="50225">[13]</st>* <st c="50229">for all those features.</st> <st c="50254">What
    is important to remember is how to organize your images into projects and who
    you give access to.</st> <st c="50357">If we also want to allow external third
    parties to push their images to our registries, you can create specific users
    for them that allow them to upload to the respect</st><st c="50524">ive</st> <st
    c="50529">container projects!</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49530">注册表通常</st> <st c="49551">管理项目中的工件。</st> <st c="49582">项目可以是注册表中的私有或公共，意味着公共项目中的工件可以被任何能够访问注册表的人访问，而私有项目只能由授权用户访问。</st>
    <st c="49798">这引出了用户管理和访问控制，可以在项目级别定义，也可以输入访问日志。</st> <st c="49930">注册表会为每次推送和拉取创建日志，以便有良好的审计追踪。</st>
    <st c="50010">CNCF Harbor</st> <st c="50025">是一个非常流行的容器注册表，它还提供了关于所有这些功能的良好文档。</st>
    <st c="50127">我们建议你阅读公开的文档</st> *<st c="50225">[13]</st>* <st c="50229">以了解所有这些功能。</st>
    <st c="50254">需要记住的关键是如何将你的镜像组织到项目中，以及你将谁授予访问权限。</st> <st c="50357">如果我们还希望允许外部第三方将他们的镜像推送到我们的注册表中，可以为他们创建特定的用户，允许他们上传到相应的</st><st
    c="50524">容器项目</st> <st c="50529">！</st>
- en: <st c="50548">Vulnerability scanning</st>
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="50548">漏洞扫描</st>
- en: '[*<st c="50571">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381) <st c="50581">focuses
    on security in more detail but it’s important to mention here that a central component,
    such as an artifact registry where every artifact has to pass through, is a perfect
    place for static vulnerability checking.</st> <st c="50803">Registries often provide
    out-of-the-box</st> <st c="50842">scanning capabilities or allow the integration
    of additional tools depending on the artifact type.</st> <st c="50942">Those tools
    would then be called either during the upload of a new image to get scanned as
    images arrive or on a schedule to make sure that images get scanned and rescanne</st><st
    c="51113">d on a</st> <st c="51121">continuous basis.</st>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[*<st c="50571">第七章</st>*](B31164_07.xhtml#_idTextAnchor381) <st c="50581">更详细地讨论了安全性，但在这里需要提到的是，像工件注册表这样的中央组件，每个工件都必须通过它，是进行静态漏洞检查的完美场所。</st>
    <st c="50803">注册表通常提供开箱即用的</st> <st c="50842">扫描功能，或者允许根据工件类型集成额外的工具。</st> <st
    c="50942">这些工具将在上传新镜像时调用，以扫描镜像的到达，或者按计划进行扫描，以确保镜像被扫描并在持续的基础上重新扫描。</st>'
- en: <st c="51138">Subscribing to the life cycle events of an artifact in the registry</st>
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="51138">订阅注册表中工件生命周期事件</st>
- en: <st c="51206">An artifact typically runs</st> <st c="51233">through different
    life cycle stages from the initial upload (push), security scan, replication to
    other repositories, and downloads (pull) until an artifact is deleted as it is
    no longer needed.</st> <st c="51429">Looking at Harbor as an example registry,
    we can also subscribe to all of those life cycle stages using webhooks.</st> <st
    c="51543">This enables a lot of interesting use cases, such as</st> <st c="51596">the
    following:</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51206">一个 artifact 通常会经历</st> <st c="51233">从初始上传（推送）、安全扫描、复制到其他仓库、下载（拉取）到最后被删除的不同生命周期阶段，直到它不再需要为止。</st>
    <st c="51429">以 Harbor 为例，我们也可以使用 Webhook 订阅这些生命周期阶段。</st> <st c="51543">这为许多有趣的使用案例提供了可能，例如</st>
    <st c="51596">以下几点：</st>
- en: '**<st c="51610">Security</st>**<st c="51619">: Notify security team on</st>
    <st c="51646">new vulnerabilities</st>'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="51610">安全</st>**<st c="51619">：通知安全团队关于</st> <st c="51646">新的漏洞</st>'
- en: '**<st c="51665">Storage</st>**<st c="51673">: Clean up old images in case storage
    quotas</st> <st c="51719">are reached</st>'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="51665">存储</st>**<st c="51673">：清理旧镜像以防存储配额</st> <st c="51719">达到限制</st>'
- en: '**<st c="51730">Deploy</st>**<st c="51737">: New images uploaded from CI/CD
    or</st> <st c="51774">third-party vendors</st>'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="51730">部署</st>**<st c="51737">：从 CI/CD 或</st> <st c="51774">第三方供应商上传的新镜像</st>'
- en: '**<st c="51793">Audit</st>**<st c="51799">: Keep track of who is pulling</st>
    <st c="51831">which artifacts</st>'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="51793">审计</st>**<st c="51799">：跟踪谁在拉取</st> <st c="51831">哪些 artifact</st>'
- en: <st c="51846">For reference, here is the full list of available life cycle events
    that can be used with webhooks:</st> `<st c="51947">artifact deleted</st>`<st
    c="51963">,</st> `<st c="51965">artifact pulled</st>`<st c="51980">,</st> `<st
    c="51982">artifact pushed</st>`<st c="51997">,</st> `<st c="51999">chart deleted</st>`<st
    c="52012">,</st> `<st c="52014">chart downloaded</st>`<st c="52030">,</st> `<st
    c="52032">chart uploaded</st>`<st c="52046">,</st> `<st c="52048">quota exceeded</st>`<st
    c="52062">,</st> `<st c="52064">quote near threshold</st>`<st c="52084">,</st>
    `<st c="52086">replication finished</st>`<st c="52106">,</st> `<st c="52108">scanning
    faile</st><st c="52122">d</st>`<st c="52124">, and</st> `<st c="52130">scanning
    finished</st>`<st c="52147">.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51846">作为参考，以下是可以与 Webhook 一起使用的完整生命周期事件列表：</st> `<st c="51947">artifact
    deleted</st>`<st c="51963">,</st> `<st c="51965">artifact pulled</st>`<st c="51980">,</st>
    `<st c="51982">artifact pushed</st>`<st c="51997">,</st> `<st c="51999">chart
    deleted</st>`<st c="52012">,</st> `<st c="52014">chart downloaded</st>`<st c="52030">,</st>
    `<st c="52032">chart uploaded</st>`<st c="52046">,</st> `<st c="52048">quota exceeded</st>`<st
    c="52062">,</st> `<st c="52064">quote near threshold</st>`<st c="52084">,</st>
    `<st c="52086">replication finished</st>`<st c="52106">,</st> `<st c="52108">scanning
    faile</st><st c="52122">d</st>`<st c="52124">, 和</st> `<st c="52130">scanning
    finished</st>`<st c="52147">。</st>
- en: <st c="52148">Retention and immutability</st>
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="52148">保持性和不可变性</st>
- en: <st c="52175">Repositories can grow really</st> <st c="52205">quickly – potentially</st>
    <st c="52226">leading to high storage costs if you don’t have a good cleanup strategy.</st>
    <st c="52300">This is why it is advisable to clean old images that are no longer
    needed.</st> <st c="52375">Some registries, therefore, provide out-of-the-box
    retention policies where you can define the images that match certain rules that
    will be retained and for how long.</st> <st c="52542">Once images fall out of
    the retention period, they will</st> <st c="52598">be deleted.</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52175">仓库可能会迅速</st> <st c="52205">膨胀—如果没有良好的清理策略，</st> <st c="52226">可能会导致存储成本高昂。</st>
    <st c="52300">因此，建议清理不再需要的旧镜像。</st> <st c="52375">因此，一些仓库提供开箱即用的保留策略，您可以定义匹配特定规则的镜像以及它们将保留多长时间。</st>
    <st c="52542">一旦镜像超过保留期，它们将</st> <st c="52598">被删除。</st>
- en: <st c="52609">Another use case is that, by</st> <st c="52638">default, everyone
    can upload a new image with the same</st> <st c="52693">image tag, leaving the
    previous image version tagless.</st> <st c="52749">To prevent this, some registries
    provide immutability rules, which prevent tags from being</st> <st c="52840">removed
    from</st> <st c="52853">existing images!</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52609">另一个使用案例是，</st> <st c="52638">默认情况下，每个人都可以上传一个新镜像，且具有相同的</st> <st
    c="52693">镜像标签，导致之前的镜像版本没有标签。</st> <st c="52749">为了防止这种情况，某些仓库提供不可变性规则，禁止标签</st>
    <st c="52840">从</st> <st c="52853">现有镜像中移除！</st>
- en: <st c="52869">Monitoring our registries</st>
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="52869">监控我们的仓库</st>
- en: <st c="52895">As registries are the heartbeat</st> <st c="52927">of our platform,
    we need to make sure they stay healthy.</st> <st c="52985">If registries stop
    processing push or pull requests, can’t execute vulnerability checks, and can’t
    replicate to other registries or send out notifications, then we have a problem!</st>
    <st c="53165">It means that critical updates won’t make it into the target environments
    fast enough.</st> <st c="53252">This could mean that a security vulnerability
    – while fixed through a new image – can’t be remediated as the new image can’t
    be delivered to the infected environment.</st> <st c="53419">It can also mean
    that we can’t ship new features in the time</st> <st c="53480">we promised.</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52895">由于注册表是我们平台的核心</st> <st c="52927">，我们需要确保它们保持健康。</st> <st c="52985">如果注册表停止处理推送或拉取请求，无法执行漏洞检查，无法复制到其他注册表或发送通知，那么我们就会遇到问题！</st>
    <st c="53165">这意味着关键更新无法及时进入目标环境。</st> <st c="53252">这可能意味着一个安全漏洞——尽管通过新镜像修复——无法得到修复，因为新镜像无法传送到受感染的环境。</st>
    <st c="53419">这也可能意味着我们无法在承诺的时间内</st> <st c="53480">发布新特性。</st>
- en: <st c="53492">To observe the health of our registries, we can monitor their
    various health metrics.</st> <st c="53579">In self-hosted registries, those metrics
    are often exposed via Prometheus or a custom REST API.</st> <st c="53675">In SaaS-hosted
    registries, those metrics are typically exposed via the vendor’s monitoring service
    API, such as</st> <st c="53787">AWS CloudWatch.</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53492">为了观察我们的注册表健康状况，我们可以监控它们的各种健康指标。</st> <st c="53579">在自托管的注册表中，这些指标通常通过
    Prometheus 或自定义的 REST API 暴露。</st> <st c="53675">在 SaaS 托管的注册表中，这些指标通常通过供应商的监控服务
    API 暴露，例如</st> <st c="53787">AWS CloudWatch。</st>
- en: <st c="53802">A good reference is Harbor, the CNCF project we mentioned earlier.</st>
    <st c="53870">It exposes lots of important metrics</st> <st c="53907">via</st>
    **<st c="53911">Prometheus</st>** *<st c="53921">[14]</st>*<st c="53926">, including
    the number of projects and repositories within a project, storage used, number
    of tasks executed and queued as well as performance metrics on the Harbor APIs
    (e.g., how long it takes to push or</st> <st c="54132">pull artifacts).</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53802">一个好的参考是 Harbor，这是我们之前提到的 CNCF 项目。</st> <st c="53870">它通过 **<st
    c="53911">Prometheus</st>** *<st c="53921">[14]</st>*<st c="53926">，暴露了许多重要的指标，包括项目和项目内仓库的数量、使用的存储、执行和排队的任务数量，以及
    Harbor API 的性能指标（例如，推送或拉取工件需要多长时间）。</st>
- en: '![Figure 5.7: Monitoring our registry to identify potential problems early](img/B31164_05_07.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7：监控我们的注册表，及早识别潜在问题](img/B31164_05_07.jpg)'
- en: '<st c="54225">Figure 5.7: Monitoring our registry to identify potential problems
    early</st>'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54225">图 5.7：监控我们的注册表，及早识别潜在问题</st>
- en: <st c="54297">Harbor</st> <st c="54304">is also an early adopter of OpenTelemetry,
    the CNCF project that initially introduced a standard for distributed tracing
    to the cloud-native community.</st> <st c="54457">Harbor provides</st> <st c="54473">an</st>
    **<st c="54476">OpenTelemetry exporter</st>** *<st c="54498">[15]</st>*<st c="54503">,
    generating traces with even more detailed information that can be used for both
    health monitoring as well</st> <st c="54611">as troubleshooting!</st>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54297">Harbor</st> <st c="54304">也是 OpenTelemetry 的早期采纳者，这是一个 CNCF 项目，最初为云原生社区引入了分布式追踪的标准。</st>
    <st c="54457">Harbor 提供了</st> <st c="54473">一个</st> **<st c="54476">OpenTelemetry
    导出器</st>** *<st c="54498">[15]</st>*<st c="54503">，生成带有更详细信息的追踪数据，既可用于健康监测，也可用于故障排除！</st>
- en: <st c="54630">Registries – the central hub for all our artifacts</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54630">注册表——我们所有工件的核心中心</st>
- en: '**<st c="54681">Container or artifact registries</st>** <st c="54714">are the
    central</st> <st c="54731">hub of all software that gets built and deployed.</st>
    <st c="54781">It</st> <st c="54783">provides a central way to manage, scan, distribute,
    and enforce access to all software before it gets deployed.</st> <st c="54896">It
    must, therefore, be treated as a highly critical component that must be observed
    to ensure availability and resiliency, and must be secure</st> <st c="55038">in
    itself!</st>'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="54681">容器或工件注册表</st>** <st c="54714">是所有构建和部署的软件的核心</st> <st c="54731">中心。</st>
    <st c="54781">它</st> <st c="54783">提供了一种集中管理、扫描、分发和执行访问控制的方式，确保所有软件在部署前进行管理。</st>
    <st c="54896">因此，它必须被视为一个高度关键的组件，必须进行监控以确保可用性和弹性，同时本身必须是安全的！</st>'
- en: <st c="55048">Now that we have talked about the importance of our artifact registry,
    let’s continue to see how all of those components integrate</st> <st c="55179">with
    our</st> <st c="55189">end-to-release process.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55048">现在我们已经讨论了我们的工件注册表的重要性，让我们继续看看所有这些组件是如何与我们的</st> <st c="55179">发布流程</st>
    <st c="55189">集成的。</st>
- en: <st c="55212">Defining the release process and management</st>
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="55212">定义发布流程和管理</st>
- en: <st c="55256">We have covered all of the building blocks it takes to build and
    deploy software.</st> <st c="55339">CI builds new container images or artifacts
    and pushes them to a registry.</st> <st c="55414">We know that registries have
    the power to scan for vulnerabilities, replicate to other registries, notify other
    tools about any activity, and enforce</st> <st c="55564">access control.</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55256">我们已经涵盖了构建和部署软件所需的所有基本模块。</st> <st c="55339">CI 构建新的容器镜像或工件，并将其推送到注册表。</st>
    <st c="55414">我们知道注册表具有扫描漏洞、复制到其他注册表、通知其他工具的能力，以及强制</st> <st c="55564">访问控制。</st>
- en: <st c="55579">We also learned about GitOps and its pull approach of ensuring
    the desired deployment state (manifest files, Helm charts, Kustomize, etc.), as
    defined in a Git repository on the</st> <st c="55758">target environment.</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55579">我们还了解了 GitOps 及其通过拉取方法确保目标环境中定义的期望部署状态（清单文件、Helm 图表、Kustomize
    等）。</st>
- en: <st c="55777">What we are discussing now is how to define and enforce a full
    end-to-end release process and how to manage the life cycle of artifacts from
    the initial creation, initial deployment, promotion into other stages, and updates
    to new versions until a potential retirement when the software is no</st> <st
    c="56071">longer required!</st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55777">我们现在讨论的是如何定义和执行完整的端到端发布流程，以及如何管理从初始创建、初始部署、推广到其他阶段，以及更新到新版本，直到软件不再</st>
    <st c="56071">需要为止！</st>
- en: <st c="56087">The following illustration highlights that pushing a new image
    and replicating it to other registries is just one piece of the puzzle.</st> <st
    c="56223">The new version of the image also needs to be referenced in the deployment
    definition that is managed in mono or poly Git repositories.</st> <st c="56359">When
    having multiple stages (development, QA, production) and having multiple regions
    or clusters in a stage, we also need to promote that new version between each
    stage and</st> <st c="56533">each region/cluster!</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56087">下图突显了将新镜像推送并复制到其他注册表只是问题的一部分。</st> <st c="56223">镜像的新版本还需要在管理单一或多个
    Git 仓库中的部署定义中进行引用。</st> <st c="56359">在拥有多个阶段（开发、QA、生产）和在每个阶段拥有多个区域或集群时，我们还需要在每个阶段和</st>
    <st c="56533">每个区域/集群之间推广该新版本！</st>
- en: '![Figure 5.8: Release process – from initial push to deploy and promote, from
    stage to stage](img/B31164_05_08.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8：发布流程 – 从初始推送到部署和推广，从阶段到阶段](img/B31164_05_08.jpg)'
- en: '<st c="56764">Figure 5.8: Release process – from initial push to deploy and
    promote, from stage to stage</st>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56764">图 5.8：发布流程 – 从初始推送到部署和推广，从阶段到阶段</st>
- en: <st c="56854">In the preceding figure,</st> `<st c="56880">values.yaml</st>`
    <st c="56891">represents the values for a Helm chart.</st> <st c="56932">It is,
    of course, simplified as there would be many more of the values that we discussed
    earlier (e.g., ownership, application context, log level,</st> `<st c="57079">git
    commit</st>` <st c="57089">hash, container</st> <st c="57106">registry, etc.).</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56854">在上图中，</st> `<st c="56880">values.yaml</st>` <st c="56891">代表 Helm
    图表的值。</st> <st c="56932">当然，这只是简化版，因为我们之前讨论过的值会有更多（例如所有权、应用上下文、日志级别、</st> `<st
    c="57079">git commit</st>` <st c="57089">哈希、容器</st> <st c="57106">注册表等）。</st>
- en: <st c="57122">Now, let’s have a look into how those deployment updates can be
    done, what should happen between the stages, what rollout options we have, and
    how to best keep track of a live inventory to know what is d</st><st c="57326">eployed
    where, when, and</st> <st c="57352">by whom!</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57122">现在，让我们看看如何完成这些部署更新，各个阶段之间应该发生什么，我们有哪些推出选项，以及如何最好地跟踪实时库存，了解是谁在何时</st><st
    c="57326">部署了哪些内容！</st>
- en: <st c="57360">Updating deployment to a new version</st>
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="57360">将部署更新到新版本</st>
- en: <st c="57397">There are</st> <st c="57408">different ways that</st> `<st c="57428">values.yaml</st>`
    <st c="57439">can be updated for the initial development stage and how it then
    gets promoted to the next stages.</st> <st c="57539">Depending on the tooling
    and the level of maturity or processes that organizations have in place, this
    can be implemented in various ways.</st> <st c="57678">The options would be</st>
    <st c="57699">as follows:</st>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57397">有</st> <st c="57408">多种方法可以更新</st> `<st c="57428">values.yaml</st>`
    <st c="57439">文件，用于初始开发阶段，并且它如何被推广到下一个阶段。</st> <st c="57539">根据组织使用的工具和成熟度或流程，这可以通过不同的方式实现。</st>
    <st c="57678">选项如下：</st> <st c="57699">如下：</st>
- en: '**<st c="57710">Updated as part of the CI</st>**<st c="57736">: Once the CI
    publishes a new image to the registry, it could open a Pull Request to update
    the version in the repository for the</st> <st c="57867">first stage.</st>'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="57710">作为 CI 一部分更新</st>**<st c="57736">：一旦 CI 将新镜像发布到注册表，它可以打开一个 Pull
    Request，更新第一个阶段仓库中的版本。</st>'
- en: '**<st c="57879">Updated through a registry webhook</st>**<st c="57914">: When
    a new image is uploaded to the registry, a webhook can be used to open a Pull
    Request.</st> <st c="58009">This approach is similar to having the CI do it.</st>
    <st c="58058">However, it decouples the process.</st> <st c="58093">This also
    works independently of which tool (e.g., CI) or creator (e.g., third-party vendor)
    pushes a new</st> <st c="58199">image version.</st>'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="57879">通过注册表 Webhook 更新</st>**<st c="57914">：当一个新镜像上传到注册表时，可以使用 Webhook
    打开一个 Pull Request。</st> <st c="58009">这种方法类似于让 CI 来完成。</st> <st c="58058">然而，它解耦了这个过程。</st>
    <st c="58093">这也能够独立于使用哪个工具（例如，CI）或哪个创建者（例如，第三方供应商）推送新</st> <st c="58199">镜像版本。</st>'
- en: '**<st c="58213">Scheduled updates</st>**<st c="58231">: Every hour, every day
    at 8 a.m., or any other schedule can be used to create a Pull Request with the
    latest version information from the registry.</st> <st c="58381">This provides
    continuous updates as well as batch changes on</st> <st c="58442">a schedule.</st>'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="58213">计划更新</st>**<st c="58231">：每小时、每天早上 8 点，或者任何其他时间表都可以用来创建一个 Pull
    Request，拉取注册表中的最新版本信息。</st> <st c="58381">这提供了持续更新和按计划批量更改的功能。</st> <st c="58442">按计划进行。</st>'
- en: '**<st c="58453">Manual Pull Requests</st>**<st c="58474">: As a precursor to
    automating the Pull Requests, or to enforce</st> <st c="58538">mandatory manual
    approval, the versio</st><st c="58576">n update can also be</st> <st c="58598">done
    manually.</st>'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="58453">手动 Pull Requests</st>**<st c="58474">：作为自动化 Pull Requests 的前奏，或强制</st>
    <st c="58538">强制手动批准，版本更新也可以</st> <st c="58576">通过手动完成。</st>'
- en: <st c="58612">Batching changes to combat dependencies</st>
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="58612">批量变更以应对依赖关系</st>
- en: <st c="58652">When dealing with simple applications or microservices that can
    be deployed independently, a single file update might be enough.</st> <st c="58782">Often,
    we have to combine multiple changes into a single change request.</st> <st c="58855">This
    is when changes have dependencies on changes in other components.</st> <st c="58926">An
    example for our Finance One ACME could be that the new version of the</st> `<st
    c="58999">fund-transfer</st>` <st c="59012">service also requires a new version
    of the</st> `<st c="59056">account-info</st>` <st c="59068">service, which requires
    an infrastructure change.</st> <st c="59119">You can see that it can easily become
    complex and it becomes harder to</st> <st c="59190">fully automate.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58652">当处理可以独立部署的简单应用程序或微服务时，更新单个文件可能已经足够。</st> <st c="58782">通常，我们必须将多个变更合并为一个变更请求。</st>
    <st c="58855">这通常发生在变更依赖于其他组件的变更时。</st> <st c="58926">例如，我们的 Finance One ACME
    可能会出现新版本的</st> `<st c="58999">fund-transfer</st>` <st c="59012">服务也需要新版本的</st>
    `<st c="59056">account-info</st>` <st c="59068">服务，而这个服务又需要基础设施更改。</st> <st c="59119">你可以看到，它很容易变得复杂，而且完全自动化变得更加困难。</st>
    <st c="59190">自动化变得更加困难。</st>
- en: <st c="59205">Those changes are hard to automate and often fall back to some
    release management team that resolves those</st> <st c="59313">dependencies manually.</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59205">这些变更很难自动化，通常会回退到某个发布管理团队，由他们手动解决这些</st> <st c="59313">依赖关系。</st>
- en: <st c="59335">There are other ways of solving this.</st> <st c="59374">One approach
    is using package managers, such as Helm, where a Helm chart can</st> <st c="59451">contain
    all configurations needed to deploy a full app.</st> <st c="59507">Helm charts</st>
    <st c="59518">can then also become artifacts uploaded to</st> <st c="59562">a
    registry.</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59335">还有其他解决方法。</st> <st c="59374">一种方法是使用包管理器，例如 Helm，其中 Helm 图表可以</st>
    <st c="59451">包含部署整个应用所需的所有配置。</st> <st c="59507">Helm 图表</st> <st c="59518">还可以成为上传到</st>
    <st c="59562">注册表的工件。</st>
- en: <st c="59573">Another approach that we have seen in an earlier section is using
    tools such as Crossplane, which</st> <st c="59672">provides IaC and application
    as code.</st> <st c="59710">The following is an example of using a composition
    for an application that contains several components, such as the business logic,
    a cache, an ingress, and</st> <st c="59867">a database:</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59573">我们在前面的章节中看到的另一种方法是使用像 Crossplane 这样的工具，它</st> <st c="59672">提供了基础设施即代码（IaC）和应用程序即代码。</st>
    <st c="59710">以下是使用组合来部署一个包含多个组件的应用程序的示例，组件包括业务逻辑、缓存、入口和</st> <st c="59867">数据库：</st>
- en: '[PRE6]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="60232">As we can see, there are different ways to solve this application</st>
    <st c="60299">dependency problem.</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60232">正如我们所看到的，有多种方法可以解决这个应用程序</st> <st c="60299">依赖性问题。</st>
- en: <st c="60318">Where this becomes trickier is when we have cross-application
    dependencies or dependencies to shared services that are independently deployed
    and updated.</st> <st c="60474">Following best practices to define good and clear
    APIs between those services and ensuring backward compatibility between major
    versions will make this easier.</st> <st c="60634">To learn more, have a look
    at existing literature or the work the CNCF</st> **<st c="60705">TAG App Delivery</st>**
    *<st c="60721">[16]</st>* <st c="60726">does on</st> <st c="60735">managing a</st><st
    c="60745">pplication and</st> <st c="60761">deployment dependencies.</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60318">当我们面临跨应用程序依赖或依赖于独立部署和更新的共享服务时，这将变得更加棘手。</st> <st c="60474">遵循最佳实践来定义这些服务之间良好而清晰的
    API，并确保主要版本之间的向后兼容性，将使这变得更加容易。</st> <st c="60634">要了解更多信息，可以查看现有的文献或CNCF</st>
    **<st c="60705">TAG 应用交付</st>** *<st c="60721">[16]</st>* <st c="60726">在管理</st>
    <st c="60735">应用程序和</st><st c="60745">部署依赖方面所做的工作。</st>
- en: <st c="60785">Pre- and post-deployment checks</st>
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="60785">部署前和部署后的检查</st>
- en: <st c="60817">Once we have all our deployment configuration changes ready and
    committed to Git, we will be ready to deploy into the target cluster.</st> <st
    c="60952">As explained earlier in this chapter, we can either use a Push model
    (e.g., a delivery pipeline deploys our changes) or a Pull model (e.g., a GitOps
    operator synchronizes the latest version in Git to the</st> <st c="61156">target
    cluster).</st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60817">一旦我们准备好并提交了所有的部署配置更改到 Git，我们就可以准备将其部署到目标集群。</st> <st c="60952">如本章前面所解释的，我们可以选择使用推送模型（例如，交付管道部署我们的更改）或拉取模型（例如，GitOps
    操作员将 Git 中的最新版本同步到</st> <st c="61156">目标集群）</st>。
- en: <st c="61172">With both approaches, we want to do some pre- and post-deployment
    checks to answer questions, such as</st> <st c="61275">the following:</st>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61172">无论是哪种方法，我们都希望进行一些部署前和部署后的检查，以回答如下问题：</st>
- en: '**<st c="61289">Pre-deployment: Are we ready to deploy</st>** **<st c="61329">that
    change?</st>**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="61289">部署前：我们准备好部署</st>** **<st c="61329">该更改了吗？</st>**'
- en: <st c="61341">Are all</st> <st c="61350">external</st> <st c="61358">dependencies
    ready?</st>
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61341">所有的</st> <st c="61350">外部</st> <st c="61358">依赖是否已准备好？</st>
- en: <st c="61378">Have all new images been successfully scanned and have</st> <st
    c="61434">no vulnerabilities?</st>
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61378">所有新的镜像是否已成功扫描并且没有</st> <st c="61434">漏洞？</st>
- en: <st c="61453">Is there no ongoing maintenance or deployment quarantine in the</st>
    <st c="61518">target environment?</st>
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61453">目标环境中是否没有正在进行的维护或部署隔离？</st>
- en: <st c="61537">Has everyone that needs to approve a deployment</st> <st c="61586">approved
    it?</st>
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61537">所有需要批准部署的人</st> <st c="61586">都批准了吗？</st>
- en: '**<st c="61598">Post-deployment: Was the</st>** **<st c="61624">deployment
    successful?</st>**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="61598">部署后：部署</st>** **<st c="61624">是否成功？</st>**'
- en: <st c="61646">Are</st> <st c="61650">updated services available and successfully</st>
    <st c="61695">handling requests?</st>
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61646">更新的服务是否可用并成功</st> <st c="61650">处理请求？</st>
- en: <st c="61713">Does the system meet all functional and</st> <st c="61754">non-functional
    requirements?</st>
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61713">系统是否满足所有功能性和</st> <st c="61754">非功能性要求？</st>
- en: <st c="61782">Do all services meet their SLAs</st> <st c="61815">and</st> **<st
    c="61819">service-level</st>** **<st c="61833">objectives</st>** <st c="61843">(</st>**<st
    c="61845">SLOs</st>**<st c="61849">)?</st>
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61782">所有服务是否符合它们的 SLA</st> <st c="61815">并且</st> **<st c="61819">服务级别</st>**
    **<st c="61833">目标</st>** <st c="61843">(</st>**<st c="61845">SLOs</st>**<st c="61849">)？</st>
- en: <st c="61852">Was everyone notified about</st> <st c="61881">the deployment?</st>
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61852">是否每个人都已被通知</st> <st c="61881">关于部署的情况？</st>
- en: <st c="61896">Can the deployment be promoted to the</st> <st c="61935">next
    stage?</st>
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="61896">该部署是否可以升级到</st> <st c="61935">下一阶段？</st>
- en: <st c="61946">The pre-deployment checks can be implemented in various ways.</st>
    <st c="62009">Some can be implemented as part of the Pull Request flow (e.g.,
    Pull Requests cannot be merged when not all pre-deployment checks are fulfilled).</st>
    <st c="62155">They can also be validated within a deployment pipeline or implemented
    as a pre-sync hook in</st> <st c="62248">GitOps tools.</st>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61946">预部署检查可以通过多种方式实现。</st> <st c="62009">其中一些可以作为 Pull Request 流程的一部分来实现（例如，当所有预部署检查未完成时，Pull
    Request 不能合并）。</st> <st c="62155">它们也可以在部署管道中进行验证，或者作为 GitOps 工具中的预同步钩子来实现。</st>
- en: <st c="62261">The post-deployment checks can be implemented after the deployment
    is done from the deployment pipeline as well as through post-sync hooks in</st>
    <st c="62404">GitOps tools.</st>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62261">后部署检查可以在部署完成后通过部署管道或 GitOps 工具中的后同步钩子来实现。</st>
- en: <st c="62417">One tool that enables pre- and post-deployment checks on Kubernetes
    independent of how the deployment is done is the CNCF project, Keptn.</st> **<st
    c="62556">Keptn</st>** <st c="62561">can stop Kubernetes deployments if the pre-deployment</st>
    <st c="62616">checks are not successful.</st> <st c="62643">Keptn can also execute
    post-deployment checks, such as executing tests, evaluating SLOs, or</st> <st
    c="62735">notifying teams.</st>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62417">一个能够在 Kubernetes 上独立于部署方式实现预部署和后部署检查的工具是 CNCF 项目 Keptn。</st> **<st
    c="62556">Keptn</st>** <st c="62561">可以在预部署检查未成功时停止 Kubernetes 部署。</st> <st c="62616">Keptn
    还可以执行后部署检查，例如执行测试、评估 SLOs，或</st> <st c="62735">通知团队。</st>
- en: <st c="62751">To learn mo</st><st c="62763">re about Keptn, check the</st> <st
    c="62790">documentation</st> *<st c="62804">[17]</st>*<st c="62808">.</st>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62751">要了解更多关于 Keptn 的信息，请查看</st> <st c="62763">文档</st> *<st c="62804">[17]</st>*<st
    c="62808">。</st>
- en: <st c="62809">Deployment notifications</st>
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="62809">部署通知</st>
- en: <st c="62834">Once we are aware of a new</st> <st c="62861">deployment that
    has either succeeded or failed the post-deployment check, we can use this information
    and notify those people or tools that can benefit from this information.</st>
    <st c="63037">Whether using tools such as Keptn, the notifications of the GitOps
    tools, or doing this from the pipeline, here are some examples of where to send</st>
    <st c="63184">this information:</st>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62834">一旦我们得知新的</st> <st c="62861">部署是否成功或失败，并完成了部署后的检查，我们可以利用这些信息，通知那些能够从中受益的人或工具。</st>
    <st c="63037">无论是使用像 Keptn 这样的工具、GitOps 工具的通知，还是通过管道来实现，以下是一些发送</st> <st c="63184">此类信息的示例：</st>
- en: '**<st c="63201">A chat</st>**<st c="63208">: Notify development teams in their
    Slack channel that their latest deployment is either ready or has failed</st>
    <st c="63318">the checks</st>'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="63201">一个聊天</st>**<st c="63208">：在他们的 Slack 渠道中通知开发团队，他们的最新部署要么已准备好，要么已经未通过</st>
    <st c="63318">检查</st>'
- en: '**<st c="63328">A ticket</st>**<st c="63337">: Update the Pull Request or a
    Jira ticket with the information about the</st> <st c="63412">deployment status</st>'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="63328">一个票证</st>**<st c="63337">：通过更新 Pull Request 或 Jira 票证，告知关于</st>
    <st c="63412">部署状态</st>'
- en: '**<st c="63429">A status page</st>**<st c="63443">: Keep a deployment status
    page with version, environment, and health information up</st> <st c="63529">to
    date</st>'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="63429">一个状态页面</st>**<st c="63443">：保持部署状态页面的更新，显示版本、环境和健康信息</st> <st
    c="63529">直到最新</st>'
- en: '**<st c="63536">An observability backend</st>**<st c="63561">: Send a deployment
    event to your</st> <st c="63596">observability backend</st>'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="63536">一个可观察性后端</st>**<st c="63561">：将部署事件发送到你的</st> <st c="63596">可观察性后端</st>'
- en: <st c="63617">Deployment events to observability backend</st>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63617">部署事件到可观察性后端</st>
- en: <st c="63660">Observability tools not only track metrics, logs, and traces,
    but they can also track events such as</st> <st c="63761">deployment or</st> <st
    c="63775">configuration change events.</st> <st c="63805">Many observability tools
    (</st>**<st c="63831">Dynatrace</st>**<st c="63841">,</st> **<st c="63843">Datadog</st>**<st
    c="63850">,</st> **<st c="63852">New Relic</st>**<st c="63861">, etc.) can use
    those events and correlate them</st> <st c="63908">with a change in the app’s
    behavior.</st> <st c="63946">This can significantly improve incident response
    as it can</st> <st c="64004">be correlated with a specific</st> <st c="64035">deployment
    change.</st>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63660">可观察性工具不仅跟踪度量、日志和追踪信息，还可以跟踪诸如</st> <st c="63761">部署或</st> <st c="63775">配置变更事件等。</st>
    <st c="63805">许多可观察性工具（如</st>**<st c="63831">Dynatrace</st>**<st c="63841">，</st>
    **<st c="63843">Datadog</st>**<st c="63850">，</st> **<st c="63852">New Relic</st>**<st
    c="63861">等）可以利用这些事件并将它们与</st> <st c="63908">应用行为的变化进行关联。</st> <st c="63946">这可以显著提高事件响应，因为它可以</st>
    <st c="64004">与特定的</st> <st c="64035">部署变更相关联。</st>
- en: <st c="64053">Promotions between stages</st>
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="64053">阶段之间的晋升</st>
- en: <st c="64079">Assuming we have a new</st> <st c="64102">release in development
    that successfully passed all post-deployment checks, how do those changes get
    promoted from development to QA and then into production?</st> <st c="64262">Does
    every change have to get promoted all the way into production or not?</st> <st
    c="64337">Do new releases get rolled out to all production environments at once
    or are there better strategies</st> <st c="64438">for it?</st>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64079">假设我们在开发中有一个新的</st> <st c="64102">版本成功通过了所有后部署检查，那么这些更改是如何从开发环境推广到QA，然后再进入生产环境的呢？</st>
    <st c="64262">每个更改是否都必须推广到生产环境，还是有其他更好的策略？</st> <st c="64337">新的发布是否会一次性推出到所有生产环境，还是有更好的策略</st>
    <st c="64438">呢？</st>
- en: <st c="64445">Here are some strategies that we have seen in organizations we
    have worked with in the past.</st> <st c="64539">For all those strategies, it
    means that a Pull Request is created to promote the new deployment definition
    from the Git location of the lower stage to the Git location of the</st> <st c="64714">higher
    stage:</st>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64445">以下是我们在过去与之合作的组织中看到的一些策略。</st> <st c="64539">对于所有这些策略，意味着创建一个Pull
    Request，将新的部署定义从较低阶段的Git位置推送到较高阶段的Git位置：</st>
- en: '**<st c="64727">Automated</st>**<st c="64737">: Often seen between development
    and QA environments.</st> <st c="64792">Every time the post-deployment checks
    are successful, it can trigger an automated Pull Request.</st> <st c="64888">This
    ensures that all development changes that have made it through the basic checks
    are quickly promoted to an environment used for more</st> <st c="65026">thorough
    testing.</st>'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="64727">自动化</st>**<st c="64737">：通常出现在开发环境和QA环境之间。</st> <st c="64792">每当后部署检查成功时，它可以触发一个自动化的Pull
    Request。</st> <st c="64888">这确保了所有通过基本检查的开发更改能够迅速推送到一个用于更</st> <st c="65026">全面测试的环境中。</st>'
- en: '**<st c="65043">Scheduled</st>**<st c="65053">: For instance, once a day, promote
    the latest version from development or QA into a special test environment (e.g.,
    a performance testing environment).</st> <st c="65207">This ensures that the team
    gets daily feedback on performance behavior changes of their updates from the
    previous</st> <st c="65321">24 hours.</st>'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="65043">计划性</st>**<st c="65053">：例如，每天一次，将开发或QA中的最新版本推广到一个特殊的测试环境（例如，性能测试环境）。</st>
    <st c="65207">这确保团队每天都能获得他们更新在过去</st> <st c="65321">24小时内的性能行为变化反馈。</st>'
- en: '**<st c="65330">Controlled/manual</st>**<st c="65348">: This typically happens
    the closer you get into production.</st> <st c="65410">Changes that made it successfully
    through QA and performance testing are marked to be safe to promote into higher-level
    environments.</st> <st c="65544">The actual promotion typically happens manually
    while the Pull Request itself might already be automatically created (but not
    auto-approved) from those versions that successfully made it through, for example,
    the performance</st> <st c="65769">testing phase!</st>'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="65330">受控/手动</st>**<st c="65348">：通常越接近生产环境，这种情况越常见。</st> <st c="65410">那些成功通过QA和性能测试的更改将被标记为可以安全推送到更高级别的环境中。</st>
    <st c="65544">实际的晋升通常是手动进行的，而Pull Request本身可能已经自动创建（但不会自动批准），例如，从那些成功通过性能</st>
    <st c="65769">测试阶段的版本中创建！</st>'
- en: '**<st c="65783">Multi-stage in production</st>**<st c="65809">: When having
    multiple production clusters, it is common practice to roll out the changes into
    one cluster first.</st> <st c="65924">Then, validate if everything works and keep
    rolling out the rest.</st> <st c="65990">This first cluster could be for internal
    usage only or for users who know that they receive updates first (e.g., friends
    and family or members of an early access group).</st> <st c="66160">When deploying
    into multiple regions or multiple SaaS vendors, it is also advisable to define
    a</st> <st c="66255">clear sequence (e.g., start in Europe first and then roll
    out to</st> <st c="66321">the US).</st>'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="65783">生产环境中的多阶段部署</st>**<st c="65809">：当有多个生产集群时，通常的做法是先将更改部署到一个集群。</st>
    <st c="65924">然后，验证一切正常后，再继续发布到其他集群。</st> <st c="65990">第一个集群可能仅供内部使用，或者仅供那些知道他们会首先接收到更新的用户（例如，亲朋好友或早期访问小组成员）。</st>
    <st c="66160">当在多个区域或多个 SaaS 服务商中部署时，建议定义清晰的</st> <st c="66255">顺序（例如，先在欧洲部署，再在</st>
    <st c="66321">美国发布）。</st>'
- en: '<st c="66329">Using multiple quality gated stages and a staged rollout strategy
    in our various production environments has</st> <st c="66438">one goal: reducing
    the risk of</st> <st c="66470">failed deployments!</st>'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66329">在我们不同的生产环境中使用多个质量门控阶段和分阶段发布策略的</st> <st c="66438">目标是：减少</st>
    <st c="66470">部署失败的风险！</st>
- en: <st c="66489">Blue/green, canary, and feature flagging</st>
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="66489">蓝绿部署、金丝雀发布和功能标志</st>
- en: <st c="66530">While using multiple</st> <st c="66552">stages with pre- and</st>
    <st c="66572">post-deployment checks already</st> <st c="66604">reduces risk,
    there is more we can do for each individual deployment:</st> **<st c="66674">progressive
    delivery</st>** <st c="66694">strategies, such as</st> <st c="66715">blue/green,
    canary, or feature flags.</st> <st c="66753">We have already discussed what those
    things are in more detail in the</st> *<st c="66823">Continuous deployment – decoupling
    deployments from</st>* *<st c="66875">releases</st>* <st c="66883">section.</st>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66530">虽然使用多个</st> <st c="66552">阶段进行发布前和发布后检查已经</st> <st c="66572">降低了风险，但我们还可以为每个单独的部署做更多的工作：</st>
    **<st c="66674">渐进式交付</st>** <st c="66694">策略，如</st> <st c="66715">蓝绿部署、金丝雀发布或功能标志。</st>
    <st c="66753">我们已经在</st> *<st c="66823">持续部署—将部署与</st>* *<st c="66875">发布解耦</st>*
    <st c="66883">章节中详细讨论了这些内容。</st>
- en: <st c="66892">In the context of the release process, this is an important topic,
    as there are several</st> <st c="66981">open questions:</st>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66892">在发布过程中，这是一个重要话题，因为存在几个</st> <st c="66981">悬而未决的问题：</st>
- en: <st c="66996">Who is receiving the new version?</st> <st c="67031">Is it a certain
    percentage of users or a</st> <st c="67072">specific group?</st>
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="66996">谁将接收到新版本？</st> <st c="67031">是某个特定百分比的用户，还是</st> <st c="67072">某个特定群体？</st>
- en: <st c="67087">How do you measure and validate whether the rollout</st> <st c="67140">was
    successful?</st>
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="67087">如何衡量和验证发布</st> <st c="67140">是否成功？</st>
- en: <st c="67155">Who is responsible for making the roll-forward or</st> <st c="67206">rollback
    decision?</st>
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="67155">谁负责做出前进或</st> <st c="67206">回滚决策？</st>
- en: <st c="67224">Just like validating a deployment through post-deployment checks,
    we can do the same with progressive delivery.</st> <st c="67337">Open</st> <st
    c="67342">source tools, such</st> <st c="67361">as</st> **<st c="67364">Argo Rollouts</st>**
    *<st c="67377">[18]</st>* <st c="67382">and</st> **<st c="67387">Flagger</st>**
    *<st c="67394">[19]</st>*<st c="67399">, or commercial tools provide automated
    analysis between the progressive rollout phases.</st> <st c="67488">This usually
    works by querying data from the observability platform; for example, Prometheus,
    to validate if the new version doesn’t differ from the existing version for key
    service-level indicators, such as request failure rate, response time, memory,
    and CPU consumption.</st> <st c="67762">For more details, it’s recommended to
    check the documentation of the</st> <st c="67831">respective tooling that is used
    for</st> <st c="67867">progressive rollouts.</st>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67224">就像通过发布后检查验证部署一样，我们也可以通过渐进式交付进行相同的操作。</st> <st c="67337">开源</st>
    <st c="67342">工具，如</st> **<st c="67364">Argo Rollouts</st>** *<st c="67377">[18]</st>*
    <st c="67382">和</st> **<st c="67387">Flagger</st>** *<st c="67394">[19]</st>*<st
    c="67399">，或商业工具提供自动化分析，比较渐进式发布各阶段之间的差异。</st> <st c="67488">通常通过查询可观察性平台的数据来实现；例如，使用
    Prometheus，验证新版本是否在关键服务级别指标（如请求失败率、响应时间、内存和 CPU 消耗）上与现有版本没有差异。</st> <st c="67762">有关更多详情，建议查看相应工具的文档，这些工具用于</st>
    <st c="67831">渐进式发布。</st>
- en: <st c="67888">Release inventory</st>
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="67888">发布清单</st>
- en: <st c="67906">The value proposition of automating the deployment and release
    process is that engineering teams can release updates more frequently into the
    various target environments.</st> <st c="68078">The easier we make this automation
    available through our platform, the more teams will end up deploying</st> <st
    c="68182">more releases.</st>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67906">自动化部署和发布过程的价值主张在于，工程团队可以更频繁地将更新发布到各个目标环境中。</st> <st c="68078">我们越是通过平台简化这种自动化的可用性，团队就会更频繁地发布</st>
    <st c="68182">更多版本。</st>
- en: '<st c="68196">Release inventories allow</st> <st c="68223">us to keep track
    of which versions are currently released in which environments by which teams.</st>
    <st c="68319">From a platform engineering perspective, we can enforce a consistent
    definition of exactly that information: version, environment, and ownership.</st>
    <st c="68465">If everything is configured as code, it means that this information
    is available in Git.</st> <st c="68554">When using Kubernetes as the target platform,
    we can also add this information as annotations on our Kubernetes objects (Deployments,</st>
    <st c="68688">Pods, Ingress).</st>'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68196">发布清单可以帮助</st> <st c="68223">我们跟踪当前在哪些环境中、由哪些团队发布了哪些版本。</st> <st
    c="68319">从平台工程的角度来看，我们可以强制执行对这些信息的一致定义：版本、环境和所有权。</st> <st c="68465">如果一切都以代码配置，这意味着这些信息可以在
    Git 中获取。</st> <st c="68554">当使用 Kubernetes 作为目标平台时，我们还可以将这些信息作为注释添加到我们的 Kubernetes
    对象（部署、</st> <st c="68688">Pod、Ingress）上。</st>
- en: <st c="68703">In previous examples, we already highlighted some of the standard
    K8s annotations.</st> <st c="68787">Here is a snippet of a</st> <st c="68810">deployment
    definition:</st>
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68703">在之前的示例中，我们已经强调了一些标准的 K8s 注释。</st> <st c="68787">这里是一个</st> <st
    c="68810">部署定义的片段：</st>
- en: '[PRE7]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="69083">With this information in K8s, we</st> <st c="69117">can simply
    query the K8s API of each K8s cluster to get an overview of all deployments by
    those labels.</st> <st c="69221">We could then get an overview</st> <st c="69251">like
    this:</st>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="69083">在 K8s 中，我们</st> <st c="69117">可以简单地查询每个 K8s 集群的 K8s API，以获取这些标签下所有部署的概览。</st>
    <st c="69221">然后我们可以获得如下概览</st> <st c="69251">：</st>
- en: '| **<st c="69261">Cluster</st>** | **<st c="69269">Release</st>** | **<st c="69277">Part-Of</st>**
    | **<st c="69285">Owner</st>** |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="69261">集群</st>** | **<st c="69269">发布</st>** | **<st c="69277">部分</st>**
    | **<st c="69285">所有者</st>** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `<st c="69291">dev</st>` | `<st c="69295">fund-transfer:1.5.1</st>` | `<st
    c="69315">backend</st>` | `<st c="69323">team-at</st>` |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `<st c="69291">dev</st>` | `<st c="69295">fund-transfer:1.5.1</st>` | `<st
    c="69315">backend</st>` | `<st c="69323">team-at</st>` |'
- en: '| `<st c="69331">dev</st>` | `<st c="69335">account-info:1.17.2</st>` | `<st
    c="69355">backend</st>` | `<st c="69363">team-ae</st>` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `<st c="69331">dev</st>` | `<st c="69335">account-info:1.17.2</st>` | `<st
    c="69355">backend</st>` | `<st c="69363">team-ae</st>` |'
- en: '| `<st c="69371">qa</st>` | `<st c="69374">fund-transfer:1.4.9</st>` | `<st
    c="69394">backend</st>` | `<st c="69402">team-at</st>` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `<st c="69371">qa</st>` | `<st c="69374">fund-transfer:1.4.9</st>` | `<st
    c="69394">backend</st>` | `<st c="69402">team-at</st>` |'
- en: '| `<st c="69410">qa</st>` | `<st c="69413">account-info:1.17.1</st>` | `<st
    c="69433">backend</st>` | `<st c="69441">team-ae</st>` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `<st c="69410">qa</st>` | `<st c="69413">account-info:1.17.1</st>` | `<st
    c="69433">backend</st>` | `<st c="69441">team-ae</st>` |'
- en: '| `<st c="69449">prod-eu</st>` | `<st c="69457">fund-transfer:1.4.7</st>` |
    `<st c="69477">backend-tenant-1</st>` | `<st c="69494">team-de</st>` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| `<st c="69449">prod-eu</st>` | `<st c="69457">fund-transfer:1.4.7</st>` |
    `<st c="69477">backend-tenant-1</st>` | `<st c="69494">team-de</st>` |'
- en: '| `<st c="69502">prod-eu</st>` | `<st c="69510">account-info:1.17.1</st>` |
    `<st c="69530">backend-tenant-1</st>` | `<st c="69547">team-de</st>` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| `<st c="69502">prod-eu</st>` | `<st c="69510">account-info:1.17.1</st>` |
    `<st c="69530">backend-tenant-1</st>` | `<st c="69547">team-de</st>` |'
- en: '| `<st c="69555">prod-us</st>` | `<st c="69563">fund-transfer:1.4.6</st>` |
    `<st c="69583">backend-tenant-2</st>` | `<st c="69600">team-us</st>` |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| `<st c="69555">prod-us</st>` | `<st c="69563">fund-transfer:1.4.6</st>` |
    `<st c="69583">backend-tenant-2</st>` | `<st c="69600">team-us</st>` |'
- en: '| `<st c="69608">prod-us</st>` | `<st c="69616">account-info:1.17.0</st>` |
    `<st c="69636">backend-tenant-2</st>` | `<st c="69653">team-us</st>` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| `<st c="69608">prod-us</st>` | `<st c="69616">account-info:1.17.0</st>` |
    `<st c="69636">backend-tenant-2</st>` | `<st c="69653">team-us</st>` |'
- en: '<st c="69661">Table 5.2: Release inventory based on metadata on deployed artifacts</st>'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="69661">表 5.2：基于部署工件元数据的发布清单</st>
- en: <st c="69730">Observability tools often provide this feature as they already
    pull the K8s APIs to observe cluster health, events, and objects including</st>
    <st c="69869">this metadata.</st>
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性工具通常提供此功能，因为它们已经拉取K8s的API来观察集群的健康状况、事件和对象，包括这些元数据。
- en: <st c="69883">Another approach is to parse this information directly from Git.</st>
    <st c="69949">Tools such as Backstage do exactly this and with that information,
    provide an easy-to-search</st> <st c="70042">software catalog.</st>
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是直接从Git解析这些信息。像Backstage这样的工具正是做的这个，它们通过这些信息提供一个易于搜索的**软件目录**。
- en: <st c="70059">Release management – from launch to mission control</st>
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布管理——从启动到任务控制
- en: <st c="70111">For many organizations, the release</st> <st c="70148">process
    ends with the actual deployment of a new release into production when operations
    teams take over all aspects of keeping the software running.</st> <st c="70298">These
    two phases are also often called</st> **<st c="70337">launch</st>** <st c="70343">and</st>
    **<st c="70348">mission control</st>**<st c="70363">, borrowed from how NASA manages
    their</st> <st c="70402">space missions.</st>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多组织来说，发布过程的结束标志是将新版本部署到生产环境中，随后运维团队接管所有保持软件运行的工作。这两个阶段通常也被称为**启动**和**任务控制**，这两个术语来源于NASA如何管理其**太空任务**。
- en: <st c="70417">Many years ago, the DevOps movement was fueled by prominent examples,
    such as the AWS platform, which promoted the</st> *<st c="70533">you built it,
    you run it!</st>* <st c="70558">approach.</st> <st c="70569">This meant that the
    responsibility of developers didn’t end with building an artifact and then throwing
    it over the so-called “Ops Wall.” Developers had to take full responsibility and
    ownership of their code from development all the way into production.</st> <st
    c="70824">They had to handle incidents and updates until their code eventually</st>
    <st c="70893">got retired.</st>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 多年前，DevOps运动受到了许多著名例子的推动，例如AWS平台，它推广了*你构建它，你运行它！*的方法。这意味着开发者的责任不仅仅是构建一个工件，然后将其扔到所谓的“运维墙”那边。开发者必须对他们的代码从开发到生产的全过程负全责并拥有所有权。他们需要处理事件和更新，直到他们的代码最终被**淘汰**。
- en: <st c="70905">When looking at today’s complex environments, it is very hard
    to own every aspect (code and infrastructure).</st> <st c="71015">With platform
    engineering, we try to bring the promise of DevOps back by providing self-services
    to reduce the complexity and giving teams the chance to own more of the end-to-end
    life cycle of</st> <st c="71209">their software.</st>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看今天复杂的环境时，拥有每一个方面（代码和基础设施）是非常困难的。通过平台工程，我们尝试通过提供自服务来减少复杂性，并给团队提供更多控制权，使他们能够拥有自己软件的端到端生命周期。
- en: <st c="71224">When building future platforms, our focus must be to provide self-services
    to orchestrate the whole life cycle of an artifact.</st> <st c="71352">In fact,
    orchestrating the whole life cycle of an application as a single artifact is typically
    just a fraction of an application.</st> **<st c="71483">Life cycle orchestration</st>**
    <st c="71507">includes</st> <st c="71516">building, deploying, and releasing,
    but also all use cases needed for production support.</st> <st c="71607">This
    includes resiliency through scaling, incident management, access to the right
    observability data for troubleshooting, and automated delivery to push fixes</st>
    <st c="71767">and updates.</st>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建未来平台时，我们的重点必须是提供自服务功能来编排整个工件的生命周期。实际上，将整个应用程序的生命周期编排成一个单一的工件，通常只是应用程序的一部分。**生命周期编排**包括构建、部署和发布，但也包括生产支持所需的所有用例。这包括通过扩展性实现的弹性、事件管理、获取正确的可观察数据以进行故障排除，以及自动化交付以推动修复和更新。
- en: <st c="71779">In the next section, we dive into life cycle orchestration, how
    to increase transparency by making our life cycles observable, and how an event-driven
    model can help reduce the complexity of pipeline and</st> <st c="71984">orchestration
    code</st><st c="72002">.</st>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将深入探讨生命周期编排，如何通过使我们的生命周期可观察来提高透明度，以及事件驱动模型如何帮助减少管道和**编排代码**的复杂性。
- en: <st c="72003">Achieving sustainable CI/CD for DevOps – application life cycle
    orchestration</st>
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="72003">实现可持续的CI/CD for DevOps – 应用生命周期编排</st>
- en: <st c="72081">From building, to publishing, to promoting, to deploying, to releasing,
    to fixing.</st> <st c="72165">That’s a lot of tasks that have to be automated
    to orchestrate the whole life cycle of our artifacts and applications.</st> <st
    c="72284">The challenge that we have seen with teams that take end-to-end responsibility
    is that the majority of those scripts deal with</st> <st c="72411">the following:</st>
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="72081">从构建，到发布，再到推广、部署、发布、修复。</st> <st c="72165">这是需要自动化的很多任务，用来协调我们工件和应用程序的整个生命周期。</st>
    <st c="72284">我们在那些负责端到端的团队中看到的挑战是，大多数这些脚本处理的是</st> <st c="72411">以下内容：</st>
- en: <st c="72425">Triggering a certain (</st><st c="72448">hardcoded) tool</st>
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="72425">触发某个（</st><st c="72448">硬编码）工具</st>
- en: <st c="72464">Doing so in a certain (</st><st c="72488">hardcoded) environment</st>
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="72464">在某个（</st><st c="72488">硬编码）环境中执行</st>
- en: <st c="72511">Then, waiting for the tool to complete</st> <st c="72551">its
    job</st>
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="72511">然后，等待工具完成</st> <st c="72551">它的工作</st>
- en: <st c="72558">Parsing the specific</st> <st c="72580">result format</st>
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="72558">解析特定的</st> <st c="72580">结果格式</st>
- en: <st c="72593">Based on the parsing result, deciding what to do</st> <st c="72643">next
    (hardcoded)</st>
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="72593">根据解析结果，决定接下来做什么</st> <st c="72643">（硬编码）</st>
- en: <st c="72659">That script code then often gets copied and pasted between different
    projects, slightly modified, and adapted.</st> <st c="72771">Fixes or adaptations
    to a single script are hard to promote to all the other variations as there is
    no easy tracking of all those scripts.</st> <st c="72910">This leads to high effort
    in maintenance, makes it inflexible to change the process or tools used in those
    scripts, and takes away time from engineers doing their</st> <st c="73073">regular
    jobs.</st>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="72659">这些脚本代码往往会被复制粘贴到不同的项目中，稍作修改并适配。</st> <st c="72771">对单个脚本进行修复或调整很难推广到所有其他变种，因为没有简单的跟踪这些脚本的方法。</st>
    <st c="72910">这导致了高昂的维护成本，使得改变这些脚本中使用的过程或工具变得不灵活，并且浪费了工程师用于做自己</st> <st c="73073">常规工作的时间。</st>
- en: <st c="73086">There is nothing wrong with using the power of pipeline scripting.</st>
    <st c="73154">Many of the pipeline automation tools also provide abstractions,
    code reuse through libraries, and other features to reduce code duplication and
    increase reusability.</st> <st c="73321">So, depending on the tools you use, make
    sure to follow those</st> <st c="73383">best practices!</st>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73086">使用管道脚本的强大功能没有问题。</st> <st c="73154">许多管道自动化工具还提供了抽象、通过库实现的代码复用以及其他特性，以减少代码重复并增加可重用性。</st>
    <st c="73321">因此，根据您使用的工具，确保遵循这些</st> <st c="73383">最佳实践！</st>
- en: <st c="73398">There exists a different approach that fits in the event-driven
    nature of modern cloud-native applications and</st> <st c="73509">cloud-native
    environments:</st> **<st c="73537">life cycle</st>** **<st c="73548">event-driven
    orchestration</st>**<st c="73574">!</st>
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73398">存在一种适合现代云原生应用及</st> <st c="73509">云原生环境的不同方法：</st> **<st c="73537">生命周期</st>**
    **<st c="73548">事件驱动编排</st>**<st c="73574">！</st>
- en: <st c="73575">In the next section, we will dive into this approach as it provides
    a lot of flexibility and centralized observability and will lead to a more sustainable
    way to automate CI/CD</st> <st c="73752">and operation</st><st c="73765">s!</st>
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73575">在接下来的部分，我们将深入探讨这一方法，因为它提供了大量的灵活性和集中式可观察性，并将导致更可持续的CI/CD自动化</st>
    <st c="73752">以及运维</st><st c="73765">！</st>
- en: <st c="73768">Artifact life cycle event observability</st>
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="73768">工件生命周期事件可观察性</st>
- en: '<st c="73808">The basics for event-driven</st> <st c="73837">orchestration
    are life cycle events, such as those discussed in</st> [*<st c="73901">Chapter
    3</st>*](B31164_03.xhtml#_idTextAnchor133)<st c="73910">. It’s about observing
    the full life cycle of an artifact: from the initial Git commit of code, the building
    and pushing of container images to a registry, to the releasing into every stage
    until the artifact gets updated or retired, including all the steps</st> <st c="74168">in
    between.</st>'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73808">事件驱动编排的基础是生命周期事件，如在</st> [*<st c="73901">第3章</st>*](B31164_03.xhtml#_idTextAnchor133)<st
    c="73910">中讨论的那些。它涉及观察工件的完整生命周期：从代码的初始Git提交、容器镜像构建并推送到注册表，再到每个阶段的发布，直到工件更新或退休，包含所有的中间步骤。</st>
- en: <st c="74179">So far in this chapter, we discussed many of those life cycle
    steps and also highlighted how to extract some of those life</st> <st c="74303">cycle
    events:</st>
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="74179">到目前为止，在本章中，我们讨论了许多生命周期步骤，并且强调了如何提取其中一些生命周期</st> <st c="74303">事件：</st>
- en: '**<st c="74316">CI/CD pipelines</st>** <st c="74332">can emit events when they</st>
    *<st c="74359">build</st>* <st c="74364">or</st> *<st c="74368">deploy</st>*'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="74316">CI/CD 流水线</st>** <st c="74332">可以在它们</st> *<st c="74359">构建</st>*
    <st c="74364">或</st> *<st c="74368">部署</st>*'
- en: '**<st c="74374">Artifact registries</st>** <st c="74394">provide webhooks when
    containers get</st> *<st c="74432">pushed</st>*<st c="74438">,</st> *<st c="74440">pulled</st>*<st
    c="74446">,</st> <st c="74448">or</st> *<st c="74451">scanned</st>*'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="74374">工件注册表</st>** <st c="74394">在容器被</st> *<st c="74432">推送</st>*<st
    c="74438">，</st> *<st c="74440">拉取</st>*<st c="74446">，</st> <st c="74448">或</st>
    *<st c="74451">扫描</st>*'
- en: '`<st c="74499">PreSync</st>`<st c="74506">,</st> `<st c="74508">Sync</st>`<st
    c="74512">,</st> `<st c="74514">PostSync</st>`<st c="74522">,</st> <st c="74524">and</st>
    `<st c="74528">SyncFailed</st>`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="74499">PreSync</st>`<st c="74506">，</st> `<st c="74508">Sync</st>`<st
    c="74512">，</st> `<st c="74514">PostSync</st>`<st c="74522">，</st> <st c="74524">和</st>
    `<st c="74528">SyncFailed</st>`'
- en: '**<st c="74538">Git</st>** <st c="74542">workflows can be used to send events
    when code</st> *<st c="74590">changes</st>* <st c="74597">or</st> <st c="74601">gets</st>
    *<st c="74606">promoted</st>*'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="74538">Git</st>** <st c="74542">工作流可以用于在代码</st> *<st c="74590">更改</st>*
    <st c="74597">或</st> <st c="74601">被</st> *<st c="74606">提升</st>*'
- en: <st c="74614">Tools such as</st> **<st c="74629">Keptn</st>** <st c="74634">provide</st>
    <st c="74642">pre- and post-deployment events for individual deployments as well
    as</st> <st c="74713">complex applications</st>
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="74614">像</st> **<st c="74629">Keptn</st>** <st c="74634">这样的工具提供了每个部署的前后事件，以及</st>
    <st c="74713">复杂应用程序的事件</st>
- en: '**<st c="74733">Container</st>** <st c="74743">platforms, such as Kubernetes,
    expose events about</st> *<st c="74795">deployment health</st>*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="74733">容器</st>** <st c="74743">平台，如 Kubernetes，暴露了有关</st> *<st c="74795">部署健康</st>*'
- en: '**<st c="74812">CDEvents</st>** *<st c="74821">[20]</st>*<st c="74826">, a
    project</st> <st c="74837">from the Continuous Delivery Foundation, extends the
    CloudEvents specification, which is already a graduated CNCF project with wide
    ecosystem adoption.</st> <st c="74990">CDEvents was initially started to standardize
    events for all life cycle phases for building, testing, and deploying.</st> <st
    c="75107">It has recently expanded to also cover the life cycle phases of deployments
    in operations such as</st> <st c="75205">production incidents.</st>'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="74812">CDEvents</st>** *<st c="74821">[20]</st>*<st c="74826">，一个来自连续交付基金会的项目，扩展了
    CloudEvents 规范，后者已经是一个成熟的 CNCF 项目，并且在生态系统中得到了广泛的应用。</st> <st c="74990">CDEvents
    最初的目标是为构建、测试和部署的所有生命周期阶段标准化事件。</st> <st c="75107">最近，它已扩展到覆盖运营中的部署生命周期阶段，如</st>
    <st c="75205">生产事故。</st>'
- en: <st c="75226">The idea is that tools that adhere to those event standards are
    easier to integrate with all other tools in the ecosystem.</st> <st c="75350">Instead
    of having to manage and maintain hard code integrations between tools, those tools
    communicate via open standard APIs and Events.</st> <st c="75488">Tools can emit
    those events; for example, Jenkins has created a new artifact and other tools
    can subscribe to them (e.g., GitLab can subscribe and trigger a workflow to scan
    and publish the container).</st> <st c="75690">That life cycle phase would also
    generate a</st> <st c="75734">standardized event.</st>
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="75226">这个想法是，遵循这些事件标准的工具更容易与生态系统中的所有其他工具集成。</st> <st c="75350">不需要管理和维护工具之间的硬编码集成，这些工具通过开放标准的API和事件进行通信。</st>
    <st c="75488">工具可以触发这些事件；例如，Jenkins 创建了一个新工件，其他工具可以订阅这些事件（例如，GitLab 可以订阅并触发一个工作流来扫描并发布容器）。</st>
    <st c="75690">这个生命周期阶段也会生成一个</st> <st c="75734">标准化事件。</st>
- en: <st c="75753">All events have a minimum set of properties to identify the phase,
    the artifact, and the tool that was involved, as well as the additional properties
    that are mandatory (e.g., initial</st> `<st c="75938">git commit</st>`<st c="75948">,
    version, environment, and</st> <st c="75976">responsible team).</st>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="75753">所有事件都有最基本的属性集，用于识别阶段、工件以及涉及的工具，此外，还有必填的附加属性（例如，初始</st> `<st c="75938">git
    提交</st>`<st c="75948">，版本，环境，和</st> <st c="75976">责任团队）</st>
- en: <st c="75994">When all those events are sent to a central event hub, it enables
    a fully event-driven orchestration of the life cycle</st> <st c="76114">of artifacts.</st>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="75994">当所有这些事件被发送到一个中央事件中心时，它就能实现对工件生命周期的完全事件驱动编排。</st> <st c="76114">工件的生命周期。</st>
- en: <st c="76127">For example, if you decide to notify development teams about new
    deployments in their Slack, you can easily subscribe to the deployment events
    and forward that event to Slack.</st> <st c="76304">If you change the chat tool
    to something else, simply change that event subscription.</st> <st c="76390">No
    need to find all code in all pipelines that currently send notifications as this
    happens through a simple event</st> <st c="76505">subscription change.</st>
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="76127">例如，如果你决定通知开发团队有关其Slack中的新部署，你可以轻松地订阅部署事件，并将该事件转发到Slack。</st> <st
    c="76304">如果你更改聊天工具为其他工具，只需更改该事件订阅。</st> <st c="76390">无需查找所有管道中当前发送通知的代码，因为这通过简单的事件</st>
    <st c="76505">订阅变更完成。</st>
- en: <st c="76525">To sum it up, using a well-defined set of life cycle events across
    all tools and phases enables many capabilities in our platform</st> <st c="76656">engineering
    approach:</st>
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="76525">总的来说，在所有工具和阶段中使用一组定义良好的生命周期事件，使我们的平台</st> <st c="76656">工程方法具备了许多能力：</st>
- en: '**<st c="76677">Traceability</st>**<st c="76690">: We can trace every artifact
    from its initial creation until its end of the life cycle.</st> <st c="76780">This
    allows us to see where artifacts are (release inventory), where they are stuck,
    and who is responsible for letting an artifact into a</st> <st c="76919">certain
    environment.</st>'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="76677">可追溯性</st>**<st c="76690">：我们可以追踪每个工件从初始创建到生命周期结束的全过程。</st>
    <st c="76780">这让我们能够看到工件的位置（发布库存）、它们卡住的位置，以及谁负责将工件放入</st> <st c="76919">某个环境。</st>'
- en: '**<st c="76939">Measurement</st>**<st c="76951">: We can measure how many artifacts
    flow through the life cycle and how long it takes.</st> <st c="77039">This is
    the basis for reporting the DORA</st> <st c="77080">Efficiency metrics!</st>'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="76939">度量</st>**<st c="76951">：我们可以衡量多少工件在生命周期中流动以及花费了多长时间。</st> <st
    c="77039">这是报告DORA</st> <st c="77080">效率指标的基础！</st>'
- en: '**<st c="77099">Interoperability</st>**<st c="77116">: We can easily integrate
    new tools or replace them if they all adhere to the same standards (e.g., switching
    from one notification tool to another is just a matter of changing an</st> <st
    c="77297">event subscription).</st>'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="77099">互操作性</st>**<st c="77116">：我们可以轻松地集成新工具或替换它们，只要它们都遵循相同的标准（例如，切换通知工具只是更改一个</st>
    <st c="77297">事件订阅</st>）的问题。</st>'
- en: '**<st c="77317">Flexibility</st>**<st c="77329">: Like</st> <st c="77336">replacing
    tools, we can easily adapt our delivery processes by having additional tools add
    work on certain events (e.g., adding an additional mandatory security scan for
    deployments in certain environments can be done by an event subscription of a
    security</st> <st c="77594">scan tool).</st>'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="77317">灵活性</st>**<st c="77329">：像替换工具一样，我们可以通过让额外的工具在特定事件上添加工作，轻松地调整我们的交付流程（例如，在某些环境中为部署添加强制性的安全扫描，可以通过安全</st>
    <st c="77594">扫描工具的事件订阅实现）。</st>'
- en: <st c="77605">Let’s have a quick overview of the building blocks of such an
    event-driven system as compared to having to create and maintain lengthy complex
    automation scripts to include a lot of</st> <st c="77788">process</st> <st c="77796">logic.</st>
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="77605">让我们快速回顾一下与创建和维护冗长复杂的自动化脚本相比，这种事件驱动系统的构建块。</st> <st c="77788">过程</st>
    <st c="77796">逻辑。</st>
- en: <st c="77802">Working with events</st>
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="77802">与事件一起工作</st>
- en: <st c="77822">The first step is that the tools we</st> <st c="77859">use along
    the artifact life cycle emit those events.</st> <st c="77912">Looking at</st>
    <st c="77923">CDEvents (which extends CloudEvents), there are several tools in
    the ecosystem that already provide out-of-the-box support for them, such as Jenkins,
    Tekton, Keptn, Tracetest, Spinnaker,</st> <st c="78110">and others.</st>
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="77822">第一步是我们使用的工具必须在工件生命周期中发出这些事件。</st> <st c="77859">观察</st> <st c="77912">CDEvents（它扩展了CloudEvents），在生态系统中已经有一些工具提供了开箱即用的支持，例如Jenkins、Tekton、Keptn、Tracetest、Spinnaker</st>
    <st c="78110">等。</st>
- en: <st c="78121">Those tools that are not integrated yet can easily emit those
    events using the available SDKs.</st> <st c="78217">The following is a code example
    using Python, which creates a Pipeline Run Finished Event (</st>`<st c="78308">cdevents.new_pipelinerun_finished</st>`<st
    c="78342">_event) with metadata, identifying the pipeline, artifact,</st> <st
    c="78402">or owner:</st>
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="78121">那些尚未集成的工具，可以使用现有的SDK轻松发布这些事件。</st> <st c="78217">以下是一个使用Python的代码示例，它创建了一个带有元数据的管道运行完成事件（</st>`<st
    c="78308">cdevents.new_pipelinerun_finished</st>`<st c="78342">_event），标识管道、制品或所有者：</st>
- en: '[PRE8]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="79161">The preceding Python code example creates a new</st> `<st c="79210">pipelinerun_finished_event</st>`<st
    c="79236">, which indicates the finished execution of a pipeline.</st> <st c="79292">The
    additional context data indicates which pipeline and when it was built, and it
    allows us to provide additional metadata, such as ownership, artifact, or which
    application this pipeline</st> <st c="79481">belongs to.</st>
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="79161">前面的Python代码示例创建了一个新的</st> `<st c="79210">pipelinerun_finished_event</st>`<st
    c="79236">，表示管道执行完成。</st> <st c="79292">附加的上下文数据指示了哪个管道以及它何时构建，它允许我们提供附加的元数据，例如所有权、制品或该管道属于哪个应用程序。</st>
- en: <st c="79492">Whether you use the</st> <st c="79513">CDEvents standard proposal
    or send your own life cycle events, it is a</st> <st c="79584">good idea to base
    it on CloudEvents as that project already has a lot of industry integrations that
    can either emit or consume CloudEvents, with Knative as</st> <st c="79740">on</st><st
    c="79742">e example!</st>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="79492">无论你是使用</st> <st c="79513">CDEvents标准提案，还是发送你自己的生命周期事件，</st> <st
    c="79584">基于CloudEvents是个不错的主意，因为该项目已经有许多行业集成，可以发布或消费CloudEvents，Knative就是</st>
    <st c="79740">其中一个例子！</st>
- en: <st c="79753">Subscribing to events to orchestrate</st>
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="79753">通过订阅事件来进行协调</st>
- en: <st c="79790">Once all our tools are</st> <st c="79814">emitting standardized
    events, we can more easily orchestrate our artifact life cycle process by having
    tools we want to participate in the process subscribe to those events they want
    to</st> <st c="80000">act upon.</st>
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="79790">一旦我们的所有工具都</st> <st c="79814">发布标准化事件，我们就可以通过让我们希望参与该过程的工具订阅它们想要</st>
    <st c="80000">执行的事件，从而更容易地协调我们的制品生命周期过程。</st>
- en: <st c="80009">We discussed the same concept earlier in this chapter when we
    talked about using the webhook capabilities of tools such as Argo CD or Harbor
    to act upon when a new artifact is available or when a new deployment was</st>
    <st c="80225">successfully synced.</st>
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="80009">我们在本章之前讨论过相同的概念，当时我们谈到使用工具（如Argo CD或Harbor）的webhook功能来在新制品可用时或新部署成功同步时执行操作。</st>
- en: <st c="80245">The benefit of a standard event model is that tools no longer
    need to subscribe to a specific webhook of a specific tool (e.g., Argo CD webhooks).</st>
    <st c="80393">Instead, we can subscribe to a central event hub that receives all
    standardized life cycle events from all involved tools, as</st> <st c="80519">visualized
    here:</st>
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="80245">标准事件模型的好处是，工具不再需要订阅特定工具的特定webhook（例如，Argo CD的webhook）。</st> <st
    c="80393">相反，我们可以订阅一个接收所有涉及工具的标准化生命周期事件的中央事件中心，如下图所示：</st>
- en: '![Figure 5.9: All tools emit and subscribe to standardized life cycle events](img/B31164_05_09.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9：所有工具都发布并订阅标准化的生命周期事件](img/B31164_05_09.jpg)'
- en: '<st c="80607">Figure 5.9: All tools emit and subscribe to standardized life
    cycle events</st>'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="80607">图 5.9：所有工具都发布并订阅标准化的生命周期事件</st>
- en: <st c="80681">Having everything</st> <st c="80700">based on an event standard
    eliminates the need for point-to-point tool integrations or hardcoded tool integrations
    in pipeline scripts.</st> <st c="80836">As an example, instead of sending a notification
    to Slack or Mattermost from every pipeline that deploys a new build, we can simply
    subscribe to the</st> `<st c="80985">dev.cdevents.service.published</st>` <st
    c="81015">event and have the details about that service forwarded to our</st>
    <st c="81079">chat tool.</st>
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="80681">将一切</st> <st c="80700">基于事件标准，消除了点对点工具集成或管道脚本中硬编码的工具集成需求。</st>
    <st c="80836">举个例子，我们可以简单地订阅</st> `<st c="80985">dev.cdevents.service.published</st>`
    <st c="81015">事件，获取关于该服务的详细信息并将其转发到我们的</st> <st c="81079">聊天工具。</st>
- en: <st c="81089">If that tool is Slack today, and at a later time, we decide to
    move to another tool, we simply change</st> <st c="81192">that subscription.</st>
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="81089">如果今天该工具是Slack，将来我们决定切换到另一个工具时，我们只需更改</st> <st c="81192">该订阅。</st>
- en: <st c="81210">Another use case is to have different tools as part of the process
    active in different environments.</st> <st c="81312">As those standardized events
    contain a lot of metadata (e.g., which environment a service gets deployed into),
    we can subscribe to events for a certain environment.</st> <st c="81477">The following
    is a table that shows</st> <st c="81513">some examples:</st>
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="81210">另一个用例是将不同的工具作为流程的一部分，在不同的环境中处于活动状态。</st> <st c="81312">由于这些标准化的事件包含大量的元数据（例如，某个服务被部署到哪个环境），我们可以订阅某个特定环境的事件。</st>
    <st c="81477">以下是展示</st> <st c="81513">一些示例的表格：</st>
- en: '| **<st c="81527">Source Tool</st>** | **<st c="81539">Event Properties</st>**
    | **<st c="81556">Subscribed By</st>** | **<st c="81570">Action</st>** |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="81527">源工具</st>** | **<st c="81539">事件属性</st>** | **<st c="81556">被订阅者</st>**
    | **<st c="81570">操作</st>** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| <st c="81577">Argo</st> | `<st c="81590">service.deployed</st>``<st c="81621">staging</st>``<st
    c="81640">fund-transfer:2.3</st>``<st c="81666">team-backend</st>` | <st c="81678">K6
    when</st> `<st c="81687">environment == "</st>``<st c="81703">staging"</st>` |
    <st c="81712">Execute</st> <st c="81721">simple load</st> |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| <st c="81577">Argo</st> | `<st c="81590">service.deployed</st>``<st c="81621">staging</st>``<st
    c="81640">fund-transfer:2.3</st>``<st c="81666">team-backend</st>` | <st c="81678">K6
    当</st> `<st c="81687">environment == "</st>``<st c="81703">staging"</st>` | <st
    c="81712">执行</st> <st c="81721">简单负载</st> |'
- en: '| <st c="81732">.</st> |  | <st c="81733">Slack when</st> `<st c="81744">Owner
    ==</st>` `<st c="81754">team-backend</st>` | <st c="81766">Send a notification
    to the team’s backend</st> <st c="81809">Slack channel</st> |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| <st c="81732">.</st> |  | <st c="81733">Slack 当</st> `<st c="81744">所有者 ==</st>`
    `<st c="81754">team-backend</st>` | <st c="81766">向团队的后端</st> <st c="81809">Slack
    频道发送通知</st> |'
- en: '|  |  | <st c="81822">OTel Collector</st> | <st c="81837">Collecting all events
    to forward to the</st> <st c="81878">observability backend</st> |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '|  |  | <st c="81822">OTel Collector</st> | <st c="81837">收集所有事件并转发到</st> <st
    c="81878">可观测性后端</st> |'
- en: '<st c="81899">Table 5.3: The same event from Argo can be subscribed by various
    tools for various actions</st>'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="81899">表 5.3：来自 Argo 的相同事件可以被不同的工具订阅，以执行不同的操作</st>
- en: <st c="81990">Some tools already provide</st> <st c="82018">out-of-the-box support
    for CloudEvents where they can either subscribe to a CloudEvent source or provide
    an API endpoint that can consume CloudEvents.</st> <st c="82169">For others, it
    will be necessary to build a slim integration layer where one subscribes to those
    events and then forwards them to the target tool.</st> <st c="82316">It’s also
    possible to implement this using event bus systems that</st> <st c="82382">support
    CloudEvents.</st>
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="81990">一些工具已经提供了</st> <st c="82018">开箱即用的支持，能够订阅 CloudEvent 源或提供一个可以消费
    CloudEvent 的 API 端点。</st> <st c="82169">对于其他工具，则需要构建一个轻量级的集成层，该层订阅这些事件并将其转发给目标工具。</st>
    <st c="82316">也可以通过支持 CloudEvents 的事件总线系统来实现。</st>
- en: <st c="82402">Analyzing events</st>
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="82402">分析事件</st>
- en: <st c="82419">Now that we know how events are</st> <st c="82452">sent and how
    they can be subscribed by other tools, we can discuss how we can leverage them
    to analyze how well our life cycle processes</st> <st c="82589">actually work.</st>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="82419">现在我们知道了事件是如何</st> <st c="82452">发送的，以及其他工具如何订阅这些事件，我们可以讨论如何利用它们来分析我们的生命周期过程</st>
    <st c="82589">实际上是如何运作的。</st>
- en: <st c="82603">Well-defined</st> <st c="82617">events that have a timestamp,
    a life cycle phase definition (</st>`<st c="82678">=event type</st>`<st c="82690">),
    and some context (artifact, environment, owner) can be analyzed to answer questions,
    such as</st> <st c="82787">the following:</st>
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="82603">定义良好的</st> <st c="82617">事件拥有时间戳、生命周期阶段定义（</st>`<st c="82678">=事件类型</st>`<st
    c="82690">）以及一些上下文信息（工件、环境、所有者），可以用于分析以下问题：</st> <st c="82787">例如：</st>
- en: <st c="82801">How many deployments happen in a</st> <st c="82835">given environment?</st>
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="82801">在某个</st> <st c="82835">特定环境中发生了多少次部署？</st>
- en: <st c="82853">How many deployments are done for a particular application</st>
    <st c="82913">or tenant?</st>
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="82853">一个特定应用程序或租户的部署次数是多少？</st> <st c="82913">或者租户的部署情况如何？</st>
- en: <st c="82923">How active is a team based on the</st> <st c="82958">ownership
    information?</st>
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="82923">一个团队的活跃程度如何，基于</st> <st c="82958">所有权信息？</st>
- en: <st c="82980">How many artifacts make it from development</st> <st c="83025">to
    production?</st>
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="82980">有多少工件从开发环境</st> <st c="83025">到达生产环境？</st>
- en: <st c="83039">Which artifacts take a long time and where are they blocked on
    the way</st> <st c="83111">to production?</st>
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="83039">哪些工件需要很长时间，并且在到达生产环境的过程中被阻塞了？</st> <st c="83111">到生产环境的路径上在哪里出现了阻塞？</st>
- en: <st c="83125">Are there certain artifacts that cause more security vulnerabilities
    or production problems</st> <st c="83218">than others?</st>
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="83125">是否有某些制品比其他制品更容易引发安全漏洞或生产问题？</st> <st c="83218"></st>
- en: <st c="83230">Which tools involved in the process are consuming most of</st>
    <st c="83289">the time?</st>
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="83230">在流程中，哪些工具消耗了大部分</st> <st c="83289">时间？</st>
- en: <st c="83298">Are there tools that are most often the reason for a slow</st>
    <st c="83357">end-to-end process?</st>
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="83298">有哪些工具通常是导致端到端流程缓慢的原因？</st>
- en: <st c="83376">There are probably many more questions that we can all answer
    by analyzing</st> <st c="83452">those events.</st>
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="83376">我们可能还有更多的问题，可以通过分析</st> <st c="83452">这些事件来解答。</st>
- en: <st c="83465">How can we analyze them?</st> <st c="83491">You can stream all
    those events to a database or your observability platform.</st> <st c="83569">In</st>
    *<st c="83572">Figure 5</st>**<st c="83580">.9</st>*<st c="83582">, we included
    OpenTelemetry, as events can just be ingested and forwarded to your observability
    backend and</st> <st c="83690">analyzed there.</st>
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="83465">我们如何分析这些事件？</st> <st c="83491">你可以将所有这些事件流式传输到数据库或你的可观察性平台。</st>
    <st c="83569">在</st> *<st c="83572">图5</st>**<st c="83580">.9</st>*<st c="83582">中，我们包含了OpenTelemetry，因为事件可以直接被摄取并转发到你的可观察性后台，并</st>
    <st c="83690">在那里进行分析。</st>
- en: <st c="83705">Bringing transparency into CI/CD through event observability</st>
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="83705">通过事件可观察性为CI/CD带来透明性</st>
- en: <st c="83766">Having all events in a single spot with all that metadata and
    clearly defined types that represent the life cycle stages allows us to get a
    lot of transparency into the integration, delivery, and operations processes.</st>
    <st c="83985">This data allows us to optimize our processes, which will result
    in</st> <st c="84053">more sustainability.</st>
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="83766">将所有事件与所有元数据以及明确定义的表示生命周期阶段的类型放在一个地方，使我们能够获得关于集成、交付和运维过程的很多透明性。</st>
    <st c="83985">这些数据使我们能够优化流程，从而实现</st> <st c="84053">更高的可持续性。</st>
- en: <st c="84073">Building automation for CI/CD and operations typically results
    in a lot of customized code that needs to be maintained across all projects it
    was copied to.</st> <st c="84231">What we learned in this section is that moving
    to an event-driven approach for artifact life cycle management can address a lot
    of the complexity problems that are otherwise hidden in custom scripts or hardcoded</st>
    <st c="84443">tool-to-tool integrations.</st>
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="84073">为CI/CD和运维构建自动化通常会导致大量自定义代码，需要在所有被复制的项目中进行维护。</st> <st c="84231">我们在这一节中学到的是，转向事件驱动的方法来管理制品生命周期，可以解决很多复杂性问题，这些问题通常隐藏在自定义脚本或硬编码的</st>
    <st c="84443">工具对工具集成中。</st>
- en: <st c="84469">In</st> [*<st c="84473">Chapter 9</st>*](B31164_09.xhtml#_idTextAnchor479)<st
    c="84482">, we will cover additional aspects of how to reduce technical debt in
    all our platform components by making the right</st> <st c="84600">architectural
    decision</st><st c="84622">s.</st>
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="84469">在</st> [*<st c="84473">第9章</st>*](B31164_09.xhtml#_idTextAnchor479)<st
    c="84482">中，我们将讨论如何通过做出正确的</st> <st c="84600">架构决策</st><st c="84622">来减少我们平台组件中的技术债务。</st>
- en: <st c="84625">IDPs – the automation Kraken in the platform</st>
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="84625">IDP – 平台中的自动化克拉肯</st>
- en: <st c="84670">In this chapter so</st> <st c="84689">far, we have learned a lot
    about the basic building blocks to automate the end-to-end build, delivery, deployment,
    and release process.</st> <st c="84826">We have talked about new approaches to
    deploying the desired state with GitOps where the desired state is pulled from
    within the target environment versus pushed from an external tool, such as</st>
    <st c="85019">a pipeline.</st>
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="84670">到目前为止，在这一章中</st> <st c="84689">我们已经学到了许多关于自动化端到端构建、交付、部署和发布过程的基本构建模块。</st>
    <st c="84826">我们讨论了通过GitOps部署期望状态的新方法，其中期望状态是从目标环境中拉取的，而不是从外部工具（如</st> <st c="85019">管道</st>）推送过来。</st>
- en: <st c="85030">We discussed the end-to-end release processes on what happens
    from the first commit until releasing software to the end users.</st> <st c="85158">Finally,
    we talked about applying an event-driven approach to orchestrating our artifact
    life cycle, which provides a centralized event hub to make everything that happens
    more transparent and observable.</st> <st c="85363">It also gives us more flexibility
    as we can remove the complexity of tool integrations and process definitions from
    pipeline or bash scripts into event subscriptions and</st> <st c="85533">event-driven
    workflows.</st>
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="85030">我们讨论了从第一次提交到将软件发布给最终用户的端到端发布流程。</st> <st c="85158">最后，我们讨论了将事件驱动方法应用于编排我们的工件生命周期，这提供了一个集中的事件中心，使所有发生的事情更加透明和可观察。</st>
    <st c="85363">这还使我们更灵活，因为我们可以将工具集成和流程定义从流水线或bash脚本转移到事件订阅和</st> <st c="85533">事件驱动工作流中，从而消除复杂性。</st>
- en: <st c="85556">In this last section, we want to have a brief look into which
    of those concepts can be implemented with existing tools that you may already
    have, which new approaches exist to solve some of the challenges we discussed,
    and where you may want to look as some new tools have emerged over the last years
    – both open source and commercial – that take some of that work off</st> <st c="85926">our
    shoulders.</st>
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="85556">在这最后一部分，我们想简要了解哪些概念可以通过您可能已经拥有的现有工具实施，哪些新方法存在以解决我们讨论的一些挑战，以及您可能希望查看的一些新工具，这些工具在过去几年中已经出现
    - 无论是开源还是商业 - 都可以减轻一些工作</st> <st c="85926">的负担。</st>
- en: <st c="85940">We will do so by putting ourselves into the shoes of our users,
    our developers, or our development teams, as they are the ones who will need to
    apply to a new way</st> <st c="86104">of worki</st><st c="86112">ng.</st>
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="85940">我们将通过将自己置于我们的用户、开发人员或开发团队的鞋子中来实现这一目标，因为他们将需要适应新的工作方式。</st>
- en: <st c="86116">Providing templates as Golden Paths for easier starts!</st>
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="86116">为更轻松的启动提供黄金路径模板！</st>
- en: <st c="86171">We try to enforce a lot of new practices, such as ensuring the
    right metadata on the deployments (version, application context, ownership, etc.)
    or having security vulnerability checks as part of every build pipeline.</st>
    <st c="86390">In the platform engineering community, those are also referred to</st>
    <st c="86456">as</st> *<st c="86459">Golden Paths</st>*<st c="86471">. To ensure
    that those practices can easily be followed by teams that start new projects,
    we need to make them easily accessible</st> <st c="86600">and adoptable!</st>
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="86171">我们尝试推行许多新实践，例如确保部署的正确元数据（版本、应用上下文、所有权等），或者在每个构建流水线中包含安全漏洞检查。</st>
    <st c="86390">在平台工程社区中，这些也被称为</st> <st c="86456">*黄金路径*。</st> <st c="86471">为了确保新项目团队能够轻松遵循这些实践，我们需要使它们易于获取</st>
    <st c="86600">和采纳！</st>
- en: <st c="86614">The easiest and most impactful approach is to provide software
    or repository templates.</st> <st c="86703">These are templates in the forms of
    manifest files, pipelines, automation scripts, and so on that developers can find
    in a template repository, which they can then take and apply to</st> <st c="86885">their
    projects.</st>
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="86614">最简单且最有影响力的方法是提供软件或存储库模板。</st> <st c="86703">这些是形式为清单文件、流水线、自动化脚本等的模板，开发人员可以在模板存储库中找到，然后应用到</st>
    <st c="86885">他们的项目中。</st>
- en: <st c="86900">While this approach works, it doesn’t force engineers to really
    use those templates; plus, it’s an additional manual step that can also lead</st>
    <st c="87042">to mistakes.</st>
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="86900">虽然这种方法有效，但并不强迫工程师真正使用这些模板；此外，这是一个额外的手动步骤，也可能导致错误。</st>
- en: <st c="87054">One way to make this easier and automated is to either provide
    a CLI or a UI to initialize new or update existing git repositories with best-practice
    templates.</st> <st c="87216">This can either be custom-built or we can look into
    existing solutions, such as</st> **<st c="87296">Backstage</st>**<st c="87305">,
    a CNCF</st> <st c="87313">project that was donated</st> <st c="87339">by Spotify.</st>
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="87054">使这变得更加简单和自动化的一种方法是提供一个CLI或UI来初始化新的或更新现有的git存储库，使用最佳实践模板。</st>
    **<st c="87296">Backstage</st>**<st c="87305">，这是一个由Spotify捐赠给CNCF的</st> <st c="87313">项目。</st>
- en: <st c="87350">Backstage’s</st> **<st c="87363">Software Templates</st>** <st
    c="87381">feature</st> <st c="87390">was built to make Golden Path templates the
    entry point for every developer’s journey as they are building new software components.</st>
    <st c="87522">Templates can be defined by subject matter experts who know how
    to properly configure pipelines, enable automated testing and deployment, and
    enforce</st> <st c="87672">security checks.</st>
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="87350">Backstage</st> **<st c="87363">软件模板</st>** <st c="87381">功能</st>
    <st c="87390">旨在将 Golden Path 模板作为每个开发人员构建新软件组件时的入口点。</st> <st c="87522">模板可以由了解如何正确配置流水线、启用自动化测试和部署以及强制</st>
    <st c="87672">安全检查的专家定义。</st>
- en: <st c="87688">Once templates are defined, they are available through an easy-to-use
    wizard that prompts the developer for some critical input data, such as what type
    of service they implement, ownership information, the requirements on observability
    or security, and so on – all of that input will then impact the creation of a
    new repository or the update of an existing one with the files and configurations
    from</st> <st c="88090">the template.</st>
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="87688">一旦定义了模板，它们就可以通过易于使用的向导进行访问，提示开发人员提供一些关键输入数据，例如他们实现的服务类型、所有权信息、可观察性或安全性的要求等
    - 所有这些输入都将影响使用来自</st> <st c="88090">模板的文件和配置创建新存储库或更新现有存储库。</st>
- en: <st c="88103">To learn more about templating, check out the detailed documentation
    and examples on the</st> **<st c="88193">Backstage</st>** **<st c="88203">website</st>**
    *<st c="88210">[21]</st>*<st c="88215">.</st>
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="88103">要了解更多关于模板的信息，请查看 Backstage 网站上的详细文档和示例。</st> **<st c="88193">Backstage</st>**
    **<st c="88203">网站</st>** *<st c="88210">[21]</st>*<st c="88215">。</st>
- en: <st c="88216">Abstractions through Crossplane</st>
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="88216">通过 Crossplane 的抽象</st>
- en: <st c="88248">Another simplification and way to enforce best practices is to
    provide an additional layer of abstraction when defining your</st> <st c="88374">application
    or services.</st> <st c="88399">In K8s, we have to define our deployments, services,
    Ingress,</st> **<st c="88461">Persistent Volume Claims</st>** <st c="88485">(</st>**<st
    c="88487">PVCs</st>**<st c="88491">), and even more when we need to deploy dependent
    services, such as a database, a cache, or any other required</st> <st c="88603">software
    components.</st>
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="88248">另一种简化和强制最佳实践的方法是在定义您的</st> <st c="88374">应用程序或服务时提供额外的抽象层。</st>
    <st c="88399">在 K8s 中，我们必须定义我们的部署、服务、Ingress，</st> **<st c="88461">持久卷索赔</st>**
    <st c="88485">(</st>**<st c="88487">PVCs</st>**<st c="88491">)，以及在需要部署依赖服务时更多的软件组件，如数据库、缓存或其他所需的</st>
    <st c="88603">软件组件。</st>
- en: <st c="88623">In the earlier section on IaC, we introduced the CNCF project,
    Crossplane.</st> **<st c="88699">Crossplane</st>** <st c="88709">orchestrates</st>
    <st c="88723">both infrastructure and application deployment through code and
    provides a concept of</st> <st c="88809">so-called</st> **<st c="88819">composites</st>**<st
    c="88829">. We will not spend more time here on this as we already provided several
    examples earlier on how to use composites to provision a performance test environment
    as well as one to define a financial backend type of application where the developer
    only needs to specify the versions of services that will then be deployed together.</st>
    <st c="89158">The following are just the first two lines of that composite definition.</st>
    <st c="89231">See the rest in the</st> *<st c="89251">Crossplane – IaC for platform
    and</st>* *<st c="89285">applications</st>* <st c="89297">section:</st>
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="88623">在 IaC 的早期部分，我们介绍了 CNCF 项目 Crossplane。</st> **<st c="88699">Crossplane</st>**
    <st c="88709">通过代码编排</st> <st c="88723">同时管理基础设施和应用程序部署，并提供了所谓的</st> **<st c="88819">复合体</st>**<st
    c="88829">的概念。在这里，我们不会花更多时间，因为我们之前已经提供了几个示例，展示了如何使用复合体来提供性能测试环境以及定义金融后端应用程序类型，开发人员只需指定要部署的服务版本即可。</st>
    <st c="89158">以下是复合体定义的前两行。</st> <st c="89231">在</st> *<st c="89251">Crossplane
    – 用于平台和</st>* *<st c="89285">应用程序的 IaC</st>* <st c="89297">部分中查看其余内容：</st>
- en: '[PRE9]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="89379">When providing abstractions, it is important to make them known
    to developers.</st> <st c="89459">This can be done by providing educational material
    or simply providing them through the same templating approach, as discussed earlier,
    using a tool such</st> <st c="89613">as B</st><st c="89617">ackstage.</st>
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="89379">在提供抽象时，使开发人员了解这些抽象的重要性至关重要。</st> <st c="89459">这可以通过提供教育材料或简单地通过与前面讨论的相同模板方法（如使用</st>
    <st c="89613">Backstage 等工具）来实现。</st>
- en: <st c="89627">Everything Git-flow-driven</st>
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="89627">一切Git-flow驱动</st>
- en: <st c="89654">Well, it should be no surprise that Git</st> <st c="89694">is
    our source of truth – we have established this early in the chapter.</st> <st
    c="89767">However, most Git solutions provide additional capabilities that we
    can use to also enforce standards and processes (e.g., GitHub workflows).</st>
    <st c="89909">Workflows can be triggered on a schedule or as part of many different
    events that can happen in the end to end flow of a Git driven process (e.g.,</st>
    *<st c="90056">push</st>*<st c="90060">,</st> *<st c="90062">pull</st>* *<st c="90067">requests</st>*<st
    c="90075">,</st> *<st c="90077">release</st>*<st c="90084">).</st>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="89654">嗯，Git作为我们的事实来源应该不是什么惊讶的事情——我们在本章早期就已经确立了这一点。</st> <st c="89694">然而，大多数Git解决方案提供了额外的功能，我们可以利用这些功能来加强标准和流程（例如，GitHub工作流）。</st>
    <st c="89767">工作流可以根据计划触发，也可以作为Git驱动过程中的许多不同事件的一部分（例如，</st> *<st c="90056">推送</st>*<st
    c="90060">，</st> *<st c="90062">拉取</st>* *<st c="90067">请求</st>*<st c="90075">，</st>
    *<st c="90077">发布</st>*<st c="90084">）。</st>
- en: <st c="90087">This allows us to enforce our standards as well before artifacts
    get built and pushed; for instance, validating mandatory metadata files we expect
    for every deployment (e.g., ownership information).</st> <st c="90287">We can
    also use this to automatically do code scans and generate scorecards or we can
    use it to validate that all dependencies are safe and don’t have any known</st>
    <st c="90448">security vulnerabilities.</st>
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="90087">这使我们能够在构建和推送工件之前也强制执行我们的标准；例如，验证我们期望每次部署时必需的元数据文件（例如，所有者信息）。</st>
    <st c="90287">我们还可以使用它自动进行代码扫描并生成得分卡，或者我们可以用它来验证所有依赖项是否安全且没有已知的</st> <st c="90448">安全漏洞。</st>
- en: <st c="90473">Depending on the Git tool that is chosen, you will typically find
    a marketplace or best practice catalog of workflows and actions that can and should
    be executed for certain types of projects.</st> <st c="90667">Make sure you make
    yourself familiar with all that is possible based on your</st> <st c="90744">to</st><st
    c="90746">ol choice.</st>
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="90473">根据选择的Git工具，你通常会找到一个市场或最佳实践目录，列出可以为特定类型的项目执行的工作流和操作。</st> <st c="90667">确保你熟悉所有基于你的</st>
    <st c="90744">工具选择</st><st c="90746">可能实现的功能。</st>
- en: <st c="90757">Software catalog</st>
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="90757">软件目录</st>
- en: <st c="90774">Once we enable developers to build more software that follows
    all our processes, we will hopefully see the result in a lot of new services being
    developed.</st> <st c="90931">Those are services that other developers also need
    to know about so that we avoid the problem of development teams building duplicated
    services and encouraging developers to build more capabilities on top of existing
    services</st> <st c="91157">and APIs.</st>
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="90774">一旦我们使开发人员能够构建更多遵循所有流程的软件，我们希望会看到大量新服务的开发。</st> <st c="90931">这些是其他开发人员也需要了解的服务，以避免开发团队构建重复的服务，并鼓励开发人员在现有服务</st>
    <st c="91157">和API的基础上构建更多功能。</st>
- en: <st c="91166">A</st> **<st c="91169">software catalog</st>** <st c="91185">that</st>
    <st c="91190">gives an overview of all available services and APIs and ideally
    also provides some documentation is what we are</st> <st c="91304">aiming for.</st>
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="91166">一个</st> **<st c="91169">软件目录</st>** <st c="91185">提供所有可用服务和API的概述，并理想情况下还提供一些文档，这是我们</st>
    <st c="91304">追求的目标。</st>
- en: <st c="91315">As</st> <st c="91319">Git is the source of truth, we can extract
    most of this information straight from Git.</st> <st c="91406">Depending on which
    Git solution we choose, a software catalog might already be part of the offering.</st>
    <st c="91507">However, there are more services and APIs that are part of the software
    catalog that an organization owns and can develop against (e.g., external APIs
    or third-party software</st> <st c="91682">deployed on-premises).</st>
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="91315">由于Git是事实来源，我们可以直接从Git中提取大部分信息。</st> <st c="91406">根据我们选择的Git解决方案，软件目录可能已经是提供的一部分。</st>
    <st c="91507">然而，软件目录中还有更多服务和API，组织可以拥有并基于它们进行开发（例如，部署在本地的外部API或第三方软件）。</st>
- en: <st c="91704">Backstage, the tool that</st> <st c="91729">also provides the
    templating feature discussed earlier, also comes with a software catalog.</st>
    <st c="91822">It gets its data from parsing specific metadata files in Git repositories
    but also allows external data sources to provide entity information.</st> <st
    c="91965">The following illustration is taken from the Backstage blog and shows
    what Spotify’s software catalog in Backstage</st> <st c="92080">looks like:</st>
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="91704">Backstage，这个</st> <st c="91729">也提供了前面讨论过的模板功能的工具，还附带一个软件目录。</st>
    <st c="91822">它通过解析 Git 仓库中的特定元数据文件获取数据，但也允许外部数据源提供实体信息。</st> <st c="91965">以下插图来自
    Backstage 博客，展示了 Spotify 在 Backstage 中的软件目录的样子：</st> <st c="92080">样子：</st>
- en: '![Figure 5.10: Software catalog extracted from entity metadata in Git](img/B31164_05_10.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10：从 Git 中提取的实体元数据的软件目录](img/B31164_05_10.jpg)'
- en: '<st c="93405">Figure 5.10: Software catalog extracted from entity metadata
    in Git</st>'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="93405">图 5.10：从 Git 中提取的实体元数据的软件目录</st>
- en: <st c="93472">As we can see from the preceding screenshot, software catalogs
    are a powerful way to understand what software components are available within
    an organization, what type of software it is, who owns it, where to find the source
    code, and</st> <st c="93709">additional information.</st>
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="93472">从前面的截图中我们可以看到，软件目录是了解一个组织内有哪些软件组件、它们是什么类型、谁拥有它们、在哪里可以找到源代码以及</st>
    <st c="93709">其他信息的强大工具。</st>
- en: <st c="93732">Tools such as Backstage</st> <st c="93756">are not the full IDP;
    however, they represent a portal – a graphical UI – into all the data relevant
    for the majority of the users of</st> <st c="93891">an IDP.</st>
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="93732">像 Backstage 这样的工具</st> <st c="93756">并不是完整的 IDP；然而，它们代表了一个门户——一个图形化界面——可以访问大多数
    IDP 用户相关的数据。</st> <st c="93891">IDP。</st>
- en: <st c="93898">While Backstage is one option, there are many other options out
    there.</st> <st c="93970">Everything from homegrown to other open source or commercial
    tools, such as Cortex, Humanitec, Por</st><st c="94068">t,</st> <st c="94072">or
    Kratix.</st>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="93898">虽然 Backstage 是一个选项，但市场上还有许多其他选择。</st> <st c="93970">从自家开发到其他开源或商业工具，如
    Cortex、Humanitec、Port</st><st c="94068">，</st> <st c="94072">或 Kratix。</st>
- en: <st c="94082">Summary</st>
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="94082">总结</st>
- en: <st c="94090">In this chapter, we learned a lot about the underlying automation
    and processes to get an artifact from the initial creation all the way into production.</st>
    <st c="94245">For modern platforms, a GitOps approach where we pull versus push
    changes should be a key consideration.</st> <st c="94350">We learned about Git
    as the source of truth and artifacts (container or OCI-compliant images) as of
    our business logic into our</st> <st c="94478">target environments.</st>
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="94090">在这一章中，我们了解了从最初创建到投入生产的整个过程中的底层自动化和流程。</st> <st c="94245">对于现代平台，采用
    GitOps 方法，尤其是通过拉取而非推送的方式，应当是一个重要的考虑因素。</st> <st c="94350">我们学习了 Git 作为真实来源，以及将业务逻辑作为容器或
    OCI 合规的镜像放入我们的</st> <st c="94478">目标环境中的方式。</st>
- en: <st c="94498">As an organization grows, it’s important to enforce good processes
    and best practices.</st> <st c="94586">For enforcement to work, it needs to be
    easily accessible and should be available end-to-end as a self-service to not
    impact the flow of creativity</st> <st c="94734">of engineers.</st>
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="94498">随着组织的成长，推行良好的流程和最佳实践变得尤为重要。</st> <st c="94586">为了确保执行效果，它需要易于访问，并且应当作为自助服务提供端到端的支持，以免影响工程师们的创造力流动。</st>
    <st c="94734">工程师的创造力。</st>
- en: '<st c="94747">This also brings us to the topic of the next chapter.</st> <st
    c="94802">In</st> [*<st c="94805">Chapter 6</st>*](B31164_06.xhtml#_idTextAnchor341)<st
    c="94814">, we dive into the importance of focusing on self-service capabilities
    that really address the needs of our target users: our developers.</st> <st c="94952">We
    will discuss how to bring those Golden Paths’ best practices into our platform
    to significantly improve the way developers can get their</st> <st c="95092">work
    done.</st>'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="94747">这也引出了下一章的主题。</st> <st c="94802">在</st> [*<st c="94805">第6章</st>*](B31164_06.xhtml#_idTextAnchor341)<st
    c="94814">中，我们深入探讨了专注于自助服务功能的重要性，这些功能真正解决了目标用户——我们的开发人员——的需求。</st> <st c="94952">我们将讨论如何将这些黄金路径的最佳实践引入我们的平台，从而显著改善开发人员完成工作的方式。</st>
- en: <st c="95102">Further reading</st>
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="95102">进一步阅读</st>
- en: <st c="95118">[1] OpenFeature –</st> [<st c="95137">https://openfeature.dev/</st>](https://openfeature.dev/)
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="95118">[1] OpenFeature –</st> [<st c="95137">https://openfeature.dev/</st>](https://openfeature.dev/)
- en: <st c="95161">[2] Crossplane –</st> [<st c="95179">https://www.crossplane.io/</st>](https://www.crossplane.io/)
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[2] Crossplane – [https://www.crossplane.io/](https://www.crossplane.io/)'
- en: <st c="95205">[3] Renovate Bot –</st> [<st c="95225">https://github.com/renovatebot/renovate</st>](https://github.com/renovatebot/renovate)
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[3] Renovate Bot – [https://github.com/renovatebot/renovate](https://github.com/renovatebot/renovate)'
- en: <st c="95264">[4] Semantic Versioning –</st> [<st c="95291">https://semver.org/</st>](https://semver.org/)
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[4] 语义化版本控制 – [https://semver.org/](https://semver.org/)'
- en: <st c="95310">[5] Kustomize –</st> [<st c="95327">https://kustomize.io/</st>](https://kustomize.io/)
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[5] Kustomize – [https://kustomize.io/](https://kustomize.io/)'
- en: <st c="95348">[6] Helm –</st> [<st c="95360">https://helm.sh/</st>](https://helm.sh/)
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[6] Helm – [https://helm.sh/](https://helm.sh/)'
- en: <st c="95376">[7]</st> *<st c="95381">The Pragmatic Programmer</st>* <st c="95405">–
    the DRY principle –</st> [<st c="95428">https://media.pragprog.com/titles/tpp20/dry.pdf</st>](https://media.pragprog.com/titles/tpp20/dry.pdf)
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[7] *务实程序员* – DRY 原则 – [https://media.pragprog.com/titles/tpp20/dry.pdf](https://media.pragprog.com/titles/tpp20/dry.pdf)'
- en: <st c="95475">[8]</st> *<st c="95480">How to set up GitOps directory structure</st>*
    <st c="95520">–</st> [<st c="95523">https://developers.redhat.com/articles/2022/09/07/how-set-your-gitops-directory-structure#directory_structures</st>](https://developers.redhat.com/articles/2022/09/07/how-set-your-gitops-directory-structure#directory_structures)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[8] *如何设置 GitOps 目录结构* – [https://developers.redhat.com/articles/2022/09/07/how-set-your-gitops-directory-structure#directory_structures](https://developers.redhat.com/articles/2022/09/07/how-set-your-gitops-directory-structure#directory_structures)'
- en: <st c="95633">[9] Argo CD –</st> [<st c="95648">https://argo-cd.readthedocs.io/en/stable/</st>](https://argo-cd.readthedocs.io/en/stable/)
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[9] Argo CD – [https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)'
- en: <st c="95689">[10] Flux –</st> [<st c="95702">https://fluxcd.io/flux/</st>](https://fluxcd.io/flux/)
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[10] Flux – [https://fluxcd.io/flux/](https://fluxcd.io/flux/)'
- en: <st c="95725">[11] Open Container Initiative –</st> [<st c="95759">https://opencontainers.org/</st>](https://opencontainers.org/)
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[11] 开放容器倡议 – [https://opencontainers.org/](https://opencontainers.org/)'
- en: <st c="95786">[12] Suggested container annotations –</st> [<st c="95826">https://github.com/opencontainers/image-spec/blob/main/annotations.md</st>](https://github.com/opencontainers/image-spec/blob/main/annotations.md)
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[12] 建议的容器注解 – [https://github.com/opencontainers/image-spec/blob/main/annotations.md](https://github.com/opencontainers/image-spec/blob/main/annotations.md)'
- en: <st c="95895">[13] Harbor –</st> [<st c="95910">https://goharbor.io/</st>](https://goharbor.io/)
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[13] Harbor – [https://goharbor.io/](https://goharbor.io/)'
- en: <st c="95930">[14] Harbor Prometheus metrics –</st> [<st c="95964">https://goharbor.io/docs/2.10.0/administration/metrics/</st>](https://goharbor.io/docs/2.10.0/administration/metrics/)
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[14] Harbor Prometheus 指标 – [https://goharbor.io/docs/2.10.0/administration/metrics/](https://goharbor.io/docs/2.10.0/administration/metrics/)'
- en: <st c="96019">[15] Harbor distributed tracing –</st> [<st c="96054">https://goharbor.io/docs/2.10.0/administration/distributed-tracing/</st>](https://goharbor.io/docs/2.10.0/administration/distributed-tracing/)
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[15] Harbor 分布式追踪 – [https://goharbor.io/docs/2.10.0/administration/distributed-tracing/](https://goharbor.io/docs/2.10.0/administration/distributed-tracing/)'
- en: <st c="96121">[16]</st> *<st c="96127">CNCF TAG App Delivery</st>* <st c="96148">–</st>
    [<st c="96151">https://tag-app-delivery.cncf.io/</st>](https://tag-app-delivery.cncf.io/)
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[16] *CNCF TAG 应用交付* – [https://tag-app-delivery.cncf.io/](https://tag-app-delivery.cncf.io/)'
- en: <st c="96184">[17] Keptn –</st> [<st c="96198">https://keptn.sh/</st>](https://keptn.sh/)
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[17] Keptn – [https://keptn.sh/](https://keptn.sh/)'
- en: <st c="96215">[18]</st> *<st c="96221">Argo Rollouts</st>* <st c="96234">–</st>
    [<st c="96237">https://argoproj.github.io/rollouts/</st>](https://argoproj.github.io/rollouts/)
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[18] *Argo Rollouts* – [https://argoproj.github.io/rollouts/](https://argoproj.github.io/rollouts/)'
- en: <st c="96273">[19] Flagger –</st> [<st c="96289">https://flagger.app/</st>](https://flagger.app/)
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[19] Flagger – [https://flagger.app/](https://flagger.app/)'
- en: <st c="96309">[20] CDEvents –</st> [<st c="96326">https://github.com/cdevents</st>](https://github.com/cdevents)
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[20] CDEvents – [https://github.com/cdevents](https://github.com/cdevents)'
- en: <st c="96353">[21] Backstage –</st> [<st c="96371">https://backstage.io/</st>](https://backstage.io/)
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[21] Backstage – [https://backstage.io/](https://backstage.io/)'
