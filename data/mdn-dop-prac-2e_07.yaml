- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Containers as a Service (CaaS) and Serverless Computing for Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器即服务（CaaS）和容器的无服务器计算
- en: In the last two chapters, we covered Kubernetes and how it helps manage your
    containers seamlessly. Now, let’s look at other ways of automating and managing
    container deployments—**Containers as a Service** (**CaaS**) and **serverless
    computing for containers**. CaaS provides container-based virtualization that
    abstracts away all management behind the scenes and helps you manage your containers
    without worrying about the underlying infrastructure and orchestration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们介绍了Kubernetes及其如何帮助无缝管理容器。现在，让我们看看自动化和管理容器部署的其他方式——**容器即服务**（**CaaS**）和**容器的无服务器计算**。CaaS提供基于容器的虚拟化，抽象了所有管理工作，帮助你管理容器而无需担心底层的基础设施和编排。
- en: For simple deployments and less complex applications, CaaS can be a savior.
    Serverless computing is a broad term that encompasses applications that can be
    run without us having to worry about the infrastructure behind the scenes. It
    has an additional benefit that you can focus purely on the application. We will
    discuss CaaS technologies such as **Amazon Elastic Container Service** (**Amazon
    ECS**) with **Amazon Web Services Fargate** (**AWS Fargate**) in detail and briefly
    discuss other cloud-based CaaS offerings such as **Azure Kubernetes Services**
    (**AKS**), **Google Kubernetes Engine** (**GKE**), and **Google Cloud Run**. We
    will then delve into the popular open source serverless CaaS solution known as
    **Knative**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的部署和较少复杂的应用，CaaS可以成为救世主。无服务器计算是一个广泛的术语，涵盖了无需我们担心背后基础设施的应用。它的一个额外好处是你可以完全专注于应用本身。我们将详细讨论CaaS技术，如**Amazon
    Elastic Container Service**（**Amazon ECS**）与**Amazon Web Services Fargate**（**AWS
    Fargate**），并简要讨论其他基于云的CaaS服务，如**Azure Kubernetes Services**（**AKS**）、**Google
    Kubernetes Engine**（**GKE**）和**Google Cloud Run**。然后，我们将深入探讨流行的开源无服务器CaaS解决方案——**Knative**。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: The need for serverless offerings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器服务的需求
- en: Amazon ECS with **Elastic Compute Cloud** (**EC2**) and Fargate
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon ECS与**弹性计算云**（**EC2**）和Fargate
- en: Other CaaS services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他CaaS服务
- en: Open source CaaS with Knative
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Knative的开源CaaS
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need an active AWS subscription for this chapter’s exercises. AWS is
    the market’s most popular, feature-rich cloud platform. Currently, AWS is offering
    a free tier for some products. You can sign up for this at [https://aws.amazon.com/free](https://aws.amazon.com/free).
    This chapter uses some paid services, but we will try to minimize how many we
    use as much as possible during the exercises.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习需要一个有效的AWS订阅。AWS是市场上最受欢迎、功能最丰富的云平台。目前，AWS为一些产品提供免费套餐。你可以在[https://aws.amazon.com/free](https://aws.amazon.com/free)注册。尽管本章使用了一些付费服务，但我们会尽量减少在练习中使用的付费服务。
- en: 'You will also need to clone the following GitHub repository for some of the
    exercises:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要克隆以下GitHub仓库进行一些练习：
- en: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e%0D)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e%0D)'
- en: 'Run the following command to clone the repository into your home directory.
    Then, `cd` into the `ch7` directory to access the required resources:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将仓库克隆到你的主目录。然后，`cd`到`ch7`目录以访问所需的资源：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As the repository contains files with placeholder strings, you must replace
    the `<your_dockerhub_user>` string with your actual Docker Hub user. Use the following
    commands to substitute the placeholders:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仓库中包含带有占位符字符串的文件，你必须将`<your_dockerhub_user>`字符串替换为实际的Docker Hub用户。使用以下命令替换占位符：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: So, let’s get started!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: The need for serverless offerings
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器服务的需求
- en: Numerous organizations, so far, have been focusing a lot on infrastructure provisioning
    and management. They optimize the number of resources, machines, and infrastructure
    surrounding the applications they build. However, they should focus on what they
    do best—software development. Unless your organization wants to invest heavily
    in an expensive infrastructure team to do a lot of heavy lifting behind the scenes,
    you’d be better off concentrating on writing and building quality applications
    rather than focusing on where and how to run and optimize them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，许多组织一直在集中精力进行基础设施的提供和管理。他们优化围绕他们构建的应用程序的资源、机器和基础设施的数量。然而，他们应该集中精力做他们最擅长的事情——软件开发。除非你的组织打算投入大量资金组建一个昂贵的基础设施团队来做大量繁重的后台工作，否则你最好将精力集中在编写和构建高质量的应用程序上，而不是关注如何以及在哪里运行和优化它们。
- en: Serverless offerings come as a reprieve for this problem. Instead of concentrating
    on how to host your infrastructure to run your applications, you can declare what
    you want to run, and the serverless offering manages it for you. This has become
    a boon for small enterprises that do not have the budget to invest heavily in
    infrastructure and want to get started quickly without wasting too much time standing
    up and maintaining infrastructure to run applications.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器服务为这个问题提供了缓解。你不再需要集中精力关注如何托管基础设施来运行应用程序，而是可以声明你想要运行的内容，无服务器服务会为你管理它。这对于那些没有预算投入大量资金进行基础设施建设的小型企业来说，已经成为一项福音，他们可以快速启动，而无需浪费太多时间搭建和维护基础设施来运行应用程序。
- en: Serverless offerings also offer automatic placement and scaling for container
    and application workloads. You can spin from 0 to 100 instances in minutes, if
    not seconds. The best part is that you pay for what you use in some services rather
    than what you allocate.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器服务还提供容器和应用程序工作负载的自动部署和扩展。你可以在几分钟甚至几秒钟内从0扩展到100个实例。最棒的是，在某些服务中，你只需为实际使用的部分付费，而不是为分配的部分付费。
- en: This chapter will concentrate on a very popular AWS container management offering
    called **ECS** and AWS’s container serverless offering, **AWS Fargate**. We will
    then briefly examine offerings from other cloud platforms and, finally, the open
    source container-based serverless solution known as **Knative**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍一个非常受欢迎的AWS容器管理服务——**ECS**以及AWS的容器无服务器服务——**AWS Fargate**。然后，我们将简要地考察其他云平台的相关服务，最后介绍一种开源的基于容器的无服务器解决方案——**Knative**。
- en: Now, let’s go ahead and look at Amazon ECS.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续了解Amazon ECS。
- en: Amazon ECS with EC2 and Fargate
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Amazon ECS与EC2和Fargate
- en: Amazon ECS is a container orchestration platform that AWS offers. It is simple
    to use and manage, uses Docker behind the scenes, and can deploy your workloads
    to **Amazon EC2**, a **virtual machine** (**VM**)-based solution, or **AWS Fargate**,
    a serverless offering.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon ECS是AWS提供的一个容器编排平台。它易于使用和管理，在后台使用Docker，并且可以将工作负载部署到**Amazon EC2**，这是基于**虚拟机**（**VM**）的解决方案，或者**AWS
    Fargate**，一种无服务器服务。
- en: It is a highly scalable solution that deploys containers in seconds. It makes
    hosting, running, stopping, and starting your containers easy. Just as Kubernetes
    offers **pods**, ECS offers **tasks** that help you run your container workloads.
    A task can contain one or more containers grouped according to a logical relationship.
    You can also group one or more tasks into **services**. Services are similar to
    Kubernetes controllers, which manage tasks and can ensure that the required number
    of replicas of your tasks are running in the right place at the right time. ECS
    uses simple API calls to provide many functionalities, such as creating, updating,
    reading, and deleting tasks and services.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高度可扩展的解决方案，可以在几秒钟内部署容器。它使得托管、运行、停止和启动容器变得非常容易。正如Kubernetes提供**pods**一样，ECS提供**任务**，帮助你运行容器工作负载。一个任务可以包含一个或多个根据逻辑关系分组的容器。你还可以将一个或多个任务分组为**服务**。服务类似于Kubernetes控制器，管理任务并确保所需数量的任务副本在正确的时间、正确的地方运行。ECS使用简单的API调用提供许多功能，例如创建、更新、读取和删除任务和服务。
- en: ECS also allows you to place your containers according to multiple placement
    strategies while keeping **high availability** (**HA**) and resource optimization
    in mind. You can tweak the placement algorithm according to your priority—cost,
    availability, or a mix of both. So, you can use ECS to run one-time batch workloads
    or long-running microservices, all using a simple-to-use API interface.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ECS还允许你根据多个放置策略来放置容器，同时考虑**高可用性**（**HA**）和资源优化。你可以根据优先级（成本、可用性或两者的结合）调整放置算法。因此，你可以使用ECS运行一次性的批处理工作负载或长期运行的微服务，所有操作都可以通过简单易用的API接口完成。
- en: ECS architecture
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ECS架构
- en: 'Before we explore the ECS architecture, it is important to understand some
    common AWS terminologies to follow it. Let’s look at some AWS resources:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解ECS架构之前，了解一些常见的AWS术语是很重要的。我们先来看看一些AWS资源：
- en: '`us-east-1`, `us-west-1`, `ap-southeast-1`, `eu-central-1`, and so on.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us-east-1`、`us-west-1`、`ap-southeast-1`、`eu-central-1`等。'
- en: '`us-east-1a`, `us-east-1b`, and so on.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`us-east-1a`、`us-east-1b`等。'
- en: '**AWS virtual private cloud (VPC)**: An AWS VPC is an isolated network resource
    you create within AWS. You associate a dedicated private IP address range to it
    from which the rest of your resources, such as EC2 instances, can derive their
    IP addresses. An AWS VPC spans an AWS Region.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS虚拟私有云（VPC）**：AWS VPC是你在AWS内创建的一个隔离的网络资源。你将一个专用的私有IP地址范围关联到它，从中你的其他资源（如EC2实例）可以获取其IP地址。AWS
    VPC跨越一个AWS区域。'
- en: '**Subnet**: A subnet, as the name suggests, is a subnetwork within the VPC.
    You must subdivide the IP address ranges you provided to the VPC and associate
    them with subnets. Resources normally reside within subnets, and each subnet spans
    an AZ.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子网**：子网顾名思义是在VPC内的一个子网络。你必须将提供给VPC的IP地址范围细分并与子网关联。资源通常位于子网内，每个子网跨越一个可用区（AZ）。'
- en: '**Route table**: An AWS route table routes traffic within the VPC subnets and
    to the internet. Every AWS subnet is associated with a route table through **subnet
    route** **table associations**.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由表**：AWS路由表在VPC子网内以及与互联网之间路由流量。每个AWS子网通过**子网路由表关联**与路由表相关联。'
- en: '**Internet gateways**: An internet gateway allows connection to and from the
    internet to your AWS subnets.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**互联网网关**：互联网网关允许AWS子网与互联网之间的连接。'
- en: '**Identity Access Management (IAM)**: AWS IAM helps you control access to resources
    by users and other AWS resources. They help you implement **role-based access
    control** (**RBAC**) and the **principle of least** **privilege** (**PoLP**).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份与访问管理（IAM）**：AWS IAM帮助你控制用户和其他AWS资源对资源的访问。它们帮助你实现**基于角色的访问控制**（**RBAC**）以及**最小权限原则**（**PoLP**）。'
- en: '**Amazon EC2**: EC2 allows you to spin up VMs within subnets, also known as
    instances.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon EC2**：EC2允许你在子网内启动虚拟机，也称为实例。'
- en: '**AWS Auto Scaling groups (ASGs)**: An AWS ASG works with Amazon EC2 to provide
    HA and scalability to your instances. It monitors your EC2 instances and ensures
    that a defined number of healthy instances are always running. It also takes care
    of autoscaling your instances with increasing load in your machines to allow for
    handling more traffic. It uses the **instance profile** and **launch configuration**
    to decide on the properties of new EC2 instances it spins up.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS自动扩展组（ASGs）**：AWS ASG与Amazon EC2一起工作，为你的实例提供高可用性（HA）和可扩展性。它监控你的EC2实例，并确保始终有一定数量的健康实例在运行。它还会根据机器负载的增加自动扩展实例，以应对更多的流量。它使用**实例配置文件**和**启动配置**来决定新EC2实例的属性。'
- en: '**Amazon CloudWatch**: Amazon CloudWatch is a monitoring and observability
    service. It allows you to collect, track, and monitor metrics, log files, and
    set alarms to take automated actions on specific conditions. CloudWatch helps
    understand application performance, health, and resource utilization.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon CloudWatch**：Amazon CloudWatch是一项监控和可观察性服务。它允许你收集、跟踪和监控指标、日志文件，并设置警报以在特定条件下采取自动化操作。CloudWatch有助于理解应用程序的性能、健康状况和资源利用情况。'
- en: ECS is a cloud-based regional service. When you spin up an ECS cluster, the
    instances span multiple AZs, where you can schedule your tasks and services using
    simple manifests. ECS manifests are very similar to `docker-compose` YAML manifests,
    where we specify which tasks to run and which tasks comprise a service.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ECS是一个基于云的区域服务。当你启动一个ECS集群时，实例会跨越多个可用区（AZ），在这些可用区中，你可以使用简单的清单调度任务和服务。ECS清单非常类似于`docker-compose`
    YAML清单，我们可以在其中指定要运行的任务以及构成服务的任务。
- en: You can run ECS within an existing VPC. We can schedule tasks in either Amazon
    EC2 or AWS Fargate.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在现有的VPC中运行ECS。我们可以在Amazon EC2或AWS Fargate中调度任务。
- en: Your ECS cluster can have one or more EC2 instances attached to it. You also
    have the option to attach an existing EC2 instance to a cluster by installing
    the ECS node agent within your EC2 instance. The agent sends information about
    your containers’ state and tasks to the ECS scheduler. It then interacts with
    the container runtime to schedule containers within the node. They are similar
    to `kubelet` in the Kubernetes ecosystem. If you run your containers within EC2
    instances, you pay for the number of EC2 instances you allocate to the cluster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您的ECS集群可以附加一个或多个EC2实例。您还可以选择通过在EC2实例中安装ECS节点代理将现有EC2实例附加到集群。该代理会将容器的状态和任务信息发送到ECS调度器。然后，它与容器运行时交互，以便在节点内调度容器。它们类似于Kubernetes生态系统中的`kubelet`。如果您在EC2实例中运行容器，您需要为分配给集群的EC2实例数量付费。
- en: If you plan to use Fargate, the infrastructure is wholly abstracted from you,
    and you must specify the amount of CPU and memory your container is set to consume.
    You pay for the CPU and memory your container consumes rather than the resources
    you allocate to the machines.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算使用Fargate，基础设施将完全抽象化，您必须指定容器将消耗的CPU和内存数量。您支付的是容器实际消耗的CPU和内存，而不是您分配给机器的资源。
- en: Tip
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Although you only pay for the resources you consume in Fargate, it is more expensive
    than running your tasks on EC2, especially when running long-running services
    such as a web server. A rule of thumb is to run long-running online tasks within
    EC2 and batch tasks with Fargate. That will give you the best cost optimization.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在Fargate中您只为实际消耗的资源付费，但它比在EC2上运行任务更昂贵，尤其是对于长时间运行的服务，如Web服务器。一个经验法则是将长时间运行的在线任务放在EC2中运行，而将批处理任务放在Fargate中运行。这样可以实现最佳的成本优化。
- en: When we schedule a task, AWS spins up the container on a managed EC2 or Fargate
    server by pulling the required container image from a **container registry**.
    Every **task** has an **elastic network interface** (**ENI**) attached to it.
    Multiple tasks are grouped as a **service**, and the service ensures that all
    the required tasks run at once.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调度一个任务时，AWS会通过从**容器注册表**拉取所需的容器镜像，在托管的EC2或Fargate服务器上启动容器。每个**任务**都有一个附加的**弹性网络接口**（**ENI**）。多个任务会被组合成一个**服务**，该服务确保所有必需的任务同时运行。
- en: Amazon ECS uses a **task scheduler** to schedule containers on your cluster.
    It places your containers in an appropriate node of your cluster based on placement
    logic, availability, and cost requirements. The scheduler also ensures that the
    desired number of tasks run on the node at a given time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon ECS使用**任务调度器**来调度集群上的容器。根据放置逻辑、可用性和成本要求，它会将容器放置在集群的适当节点上。调度器还确保在给定时间节点上运行所需数量的任务。
- en: 'The following diagram explains the ECS cluster architecture beautifully:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 下图清晰地解释了ECS集群架构：
- en: '![Figure 7.1 – ECS architecture](img/B19877_07_1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – ECS架构](img/B19877_07_1.jpg)'
- en: Figure 7.1 – ECS architecture
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – ECS架构
- en: Amazon provides the ECS **command-line interface** (**CLI**) for interacting
    with the ECS cluster. It is a simple command-line tool that you can use to administer
    an ECS cluster and create and manage tasks and services on the ECS cluster.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon提供了ECS的**命令行界面**（**CLI**）用于与ECS集群交互。它是一个简单的命令行工具，您可以用来管理ECS集群、创建和管理集群上的任务和服务。
- en: Now, let’s go ahead and install the ECS CLI.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续安装ECS CLI。
- en: Installing the AWS and ECS CLIs
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装AWS和ECS CLI
- en: 'The AWS CLI is available as a `deb` package within the public `apt` repositories.
    To install it, run the following commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI作为`deb`包提供，包含在公共的`apt`仓库中。要安装它，请运行以下命令：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Installing the ECS CLI in the Linux ecosystem is simple. We need to download
    the binary and move to the system path using the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux环境中安装ECS CLI非常简单。我们只需下载二进制文件并使用以下命令将其移至系统路径：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the following command to check whether `ecs-cli` has been installed correctly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来检查`ecs-cli`是否已正确安装：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we can see, `ecs-cli` has been successfully installed on our system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`ecs-cli`已成功安装在我们的系统上。
- en: 'The next step is to allow `ecs-cli` to connect with your AWS API. You need
    to export your AWS CLI environment variables for this. Run the following commands
    to do so:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是允许`ecs-cli`与您的AWS API连接。为此，您需要导出AWS CLI环境变量。运行以下命令进行操作：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Once we’ve set the environment variables, `ecs-cli` will use them to authenticate
    with the AWS API. In the next section, we’ll spin up an ECS cluster using the
    ECS CLI.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了环境变量，`ecs-cli` 将使用它们来进行 AWS API 的身份验证。在下一部分中，我们将使用 ECS CLI 启动一个 ECS 集群。
- en: Spinning up an ECS cluster
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 ECS 集群
- en: We can use the ECS CLI commands to spin up an ECS cluster. You can run your
    containers in EC2 and Fargate, so first, we will create a cluster that runs EC2
    instances. Then, we will add Fargate tasks within the cluster.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 ECS CLI 命令来启动 ECS 集群。你可以在 EC2 和 Fargate 上运行你的容器，因此首先我们将创建一个运行 EC2 实例的集群。然后，我们将在集群中添加
    Fargate 任务。
- en: 'To connect with your EC2 instances, you need to generate a key pair within
    AWS. To do so, run the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到你的 EC2 实例，你需要在 AWS 中生成一个密钥对。为此，请运行以下命令：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output of this command will provide the key pair in a JSON file. Extract
    the JSON file’s key material and save that in a separate file called `ecs-keypair.pem`.
    Remember to replace the `\n` characters with a new line when you save the file.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出将提供密钥对的 JSON 文件。提取 JSON 文件的密钥材料，并将其保存在一个名为 `ecs-keypair.pem` 的单独文件中。记得在保存文件时将
    `\n` 字符替换为换行符。
- en: 'Once we’ve generated the key pair, we can use the following command to create
    an ECS cluster using the ECS CLI:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们生成了密钥对，我们可以使用以下命令通过 ECS CLI 创建一个 ECS 集群：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we issue this command, in the background, AWS spins up a stack of resources
    using CloudFormation. CloudFormation is AWS’s **Infrastructure-as-Code** (**IaC**)
    solution that helps you deploy infrastructure on AWS through reusable templates.
    The CloudFormation template consists of several resources such as a VPC, a security
    group, a subnet within the VPC, a route table, a route, a subnet route table association,
    an internet gateway, an IAM role, an instance profile, a launch configuration,
    an ASG, a VPC gateway attachment, and the cluster itself. The ASG contains two
    EC2 instances running and serving the cluster. Keep a copy of the output; we will
    need the details later during the exercises.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此命令时，AWS 会在后台使用 CloudFormation 启动一堆资源。CloudFormation 是 AWS 的**基础设施即代码**（**IaC**）解决方案，它通过可重用的模板帮助你在
    AWS 上部署基础设施。CloudFormation 模板包含多个资源，例如 VPC、安全组、VPC 内的子网、路由表、路由、子网路由表关联、互联网网关、IAM
    角色、实例配置文件、启动配置、ASG、VPC 网关附件以及集群本身。ASG 包含两个正在运行并为集群提供服务的 EC2 实例。请保留输出的副本；稍后的练习中我们需要使用这些细节。
- en: Now that our cluster is up, we will spin up our first task.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的集群已经启动，我们将启动我们的第一个任务。
- en: Creating task definitions
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建任务定义
- en: ECS tasks are similar to Kubernetes pods. They are the basic building blocks
    of ECS and comprise one or more related containers. Task definitions are the blueprints
    for ECS tasks and define what the ECS task should look like. They are very similar
    to `docker-compose` files and are written in YAML format. ECS also uses all versions
    of `docker-compose` to allow us to define tasks. They help you define containers
    and their images, resource requirements, where they should run (EC2 or Fargate),
    volume and port mappings, and other networking requirements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ECS 任务类似于 Kubernetes pod。它们是 ECS 的基本构建块，由一个或多个相关的容器组成。任务定义是 ECS 任务的蓝图，定义了 ECS
    任务的外观。它们与 `docker-compose` 文件非常相似，且采用 YAML 格式编写。ECS 还使用所有版本的 `docker-compose`
    允许我们定义任务。它们帮助你定义容器及其镜像、资源需求、运行位置（EC2 或 Fargate）、卷和端口映射以及其他网络需求。
- en: Tip
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Using the `docker-compose` manifest to spin up tasks and services is a great
    idea, as it will help you align your configuration with an open standard.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker-compose` 清单来启动任务和服务是一个好主意，因为它将帮助你将配置与开放标准对齐。
- en: A task is a finite process and only runs once. Even if it’s a long-running process,
    such as a web server, the task still runs once as it waits for the long-running
    process to end (which runs indefinitely in theory). The task’s life cycle follows
    the **Pending** -> **Running** -> **Stopped** states. So, when you schedule your
    task, the task enters the **Pending** state, attempting to pull the image from
    the container registry. Then, it tries to start the container. Once the container
    has started, it enters the **Running** state. When the container has completed
    executing or errored out, it ends up in the **Stopped** state. A container with
    startup errors directly transitions from the **Pending** state to the **Stopped**
    state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是一个有限的过程，仅运行一次。即使它是一个长时间运行的过程，例如Web服务器，任务仍然只运行一次，等待长时间运行的进程结束（理论上会一直运行）。任务的生命周期遵循**Pending**（待处理）
    -> **Running**（运行中） -> **Stopped**（已停止）状态。因此，当你调度任务时，任务进入**Pending**状态，尝试从容器注册表中拉取镜像。然后，它尝试启动容器。一旦容器启动，它就进入**Running**状态。当容器执行完成或出错时，它将进入**Stopped**状态。一个启动错误的容器会直接从**Pending**状态转到**Stopped**状态。
- en: Now, let’s go ahead and deploy an `nginx` web server task within the ECS cluster
    we just created.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续在刚刚创建的ECS集群中部署一个`nginx` Web服务器任务。
- en: 'To access the resources for this section, `cd` into the following directory:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，`cd`到以下目录：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We’ll use `docker-compose` task definitions here. So, let’s start by defining
    the following `docker-compose.yml` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里使用`docker-compose`任务定义。所以，让我们从定义以下`docker-compose.yml`文件开始：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The YAML file defines a `web` container with an `nginx` image with host port
    `80` mapped to container port `80`. It uses the `awslogs` logging driver, which
    streams logs into Amazon CloudWatch. It will stream the logs to the `/aws/webserver`
    log group in the `us-east-1` region with the `ecs` stream prefix.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件定义了一个`web`容器，使用`nginx`镜像，主机端口`80`映射到容器端口`80`。它使用`awslogs`日志驱动程序，将日志流式传输到Amazon
    CloudWatch。它会将日志流传输到`us-east-1`区域中的`/aws/webserver`日志组，并使用`ecs`流前缀。
- en: 'The task definition also includes the resource definition—that is, the amount
    of resources we want to reserve for our task. Therefore, we will have to define
    the following `ecs-params.yaml` file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 任务定义还包括资源定义——也就是说，我们希望为任务保留的资源量。因此，我们将需要定义以下的`ecs-params.yaml`文件：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This YAML file defines `cpu_shares` in millicores and `mem_limit` in bytes for
    the container we plan to fire. Now, let’s look at scheduling this task as an EC2
    task.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YAML文件定义了容器的`cpu_shares`（以毫核为单位）和`mem_limit`（以字节为单位）。现在，我们来看看如何将此任务调度为EC2任务。
- en: Scheduling EC2 tasks on ECS
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ECS上调度EC2任务
- en: 'Let’s use `ecs-cli` to apply the configuration and schedule our task using
    the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`ecs-cli`应用配置并使用以下命令调度任务：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that the task has been scheduled and the container is running, let’s list
    all the tasks to get the container’s details and find out where it is running.
    To do so, run the following command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在任务已经调度并且容器正在运行，让我们列出所有任务以获取容器的详细信息，并查找它运行的位置。为此，运行以下命令：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see, the web container is running on `cluster-1` on `34.237.218.7:80`.
    Now, use the following command to curl this endpoint to see what we get:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Web容器正在`34.237.218.7:80`的`cluster-1`上运行。现在，使用以下命令来curl此端点，看看我们能得到什么：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we get the default `nginx` home page! We’ve successfully scheduled a container
    on ECS using the EC2 launch type. You might want to duplicate this task to handle
    more traffic. This is known as horizontal scaling. We’ll see how in the next section.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到了默认的`nginx`首页！我们已经成功地在ECS上使用EC2启动类型调度了一个容器。你可能想要复制这个任务来处理更多的流量。这被称为水平扩展。我们将在下一部分看到如何实现。
- en: Scaling tasks
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展任务
- en: 'We can easily scale tasks using `ecs-cli`. Use the following command to scale
    the tasks to `2`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ecs-cli`轻松地扩展任务。使用以下命令将任务扩展到`2`：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, use the following command to check whether two containers are running
    on the cluster:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令检查集群中是否有两个容器在运行：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As we can see, two containers are running on the cluster. Now, let’s query CloudWatch
    to get the logs of the containers.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，集群上正在运行两个容器。现在，让我们查询CloudWatch以获取容器的日志。
- en: Querying container logs from CloudWatch
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从CloudWatch查询容器日志
- en: 'To query logs from CloudWatch, we must list the log streams using the following
    command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要从CloudWatch查询日志，我们必须使用以下命令列出日志流：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see, there are two log streams for this—one for each task. `logStreamName`
    follows the convention `<log_stream_prefix>/<task_name>/<task_id>`. So, to get
    the logs for `ecs/b43bdec7/web`, run the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这里有两个日志流——每个任务一个。`logStreamName` 遵循 `<log_stream_prefix>/<task_name>/<task_id>`
    的约定。因此，要获取 `ecs/b43bdec7/web` 的日志，请运行以下命令：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you will see a stream of logs in JSON format in the response. Now, let’s
    look at how we can stop running tasks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，您将在响应中看到以JSON格式显示的日志流。现在，让我们来看一下如何停止正在运行的任务。
- en: Stopping tasks
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止任务
- en: '`ecs-cli` uses the friendly `docker-compose` syntax for everything. Use the
    following command to stop the tasks in the cluster:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ecs-cli` 使用友好的 `docker-compose` 语法进行所有操作。使用以下命令停止集群中的任务：'
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s list the containers to see whether the tasks have stopped by using the
    following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出容器，查看任务是否已停止，使用以下命令：
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As we can see, both containers have stopped.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，两个容器都已停止。
- en: Running tasks on EC2 is not a serverless way of doing things. You still have
    to provision and manage the EC2 instances, and although ECS manages workloads
    on the cluster, you still have to pay for the amount of resources you’ve provisioned
    in the form of EC2 instances. AWS offers Fargate as a serverless solution where
    you pay per resource consumption. Let’s look at how we can create the same task
    as a Fargate task.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在EC2上运行任务并不是一种无服务器的方式。您仍然需要配置和管理EC2实例，尽管ECS管理集群上的工作负载，但您仍然需要为已配置的EC2实例的资源支付费用。AWS提供了Fargate作为一种无服务器解决方案，按资源消耗付费。让我们看看如何将相同的任务创建为Fargate任务。
- en: Scheduling Fargate tasks on ECS
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ECS上调度Fargate任务
- en: Scheduling tasks on Fargate is very similar to EC2\. Here, we need to specify
    the `launch-type` value as `FARGATE`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fargate上调度任务与EC2非常相似。在这里，我们需要将`launch-type`值指定为`FARGATE`。
- en: 'To schedule the same task on Fargate, run the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Fargate上调度相同的任务，请运行以下命令：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Oops! We have a problem! Well, it’s complaining about the network type. For
    a Fargate task, we must supply the network type as `awsvpc` instead of the default
    bridge network. The `awsvpc` network is an overlay network that implements the
    `awsvpc` network type. But before that, the Fargate task requires a few configurations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！我们遇到问题了！它抱怨网络类型。对于Fargate任务，我们必须提供网络类型`awsvpc`，而不是默认的桥接网络。`awsvpc`网络是一种覆盖网络，实施了`awsvpc`网络类型。但在此之前，Fargate任务需要一些配置。
- en: 'To access the resources for this section, `cd` into the following directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，请`cd`进入以下目录：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: First, we’ll have to assume a task execution role for the ECS agent to authenticate
    with the AWS API and interact with Fargate.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须假设一个任务执行角色，以便ECS代理能够进行AWS API认证并与Fargate交互。
- en: 'To do so, create the following `task-execution-assume-role.json` file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请创建以下`task-execution-assume-role.json`文件：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, use the following command to assume the task execution role:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令来假设任务执行角色：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'ECS provides a default role policy called `AmazonECSTaskExecutionRolePolicy`,
    which contains various permissions that help you interact with CloudWatch and
    **Elastic Container Registry** (**ECR**). The following JSON code outlines the
    permission that the policy has:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ECS提供了一个默认的角色策略，名为`AmazonECSTaskExecutionRolePolicy`，其中包含多种权限，帮助您与CloudWatch和**Elastic
    Container Registry**（**ECR**）进行交互。以下JSON代码概述了该策略的权限：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We have to assign this role policy to the `ecsTaskExecution` role we assumed
    previously by using the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过以下命令将该角色策略分配给我们之前假设的`ecsTaskExecution`角色：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Once we’ve assigned the policy to the `ecsTaskExecution` role, we need to source
    the ID of both subnets and the security group of the ECS cluster when we created
    it. You can find those details in the command-line output from when we created
    the cluster. We will use these details in the following `ecs-params.yml` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将策略分配给`ecsTaskExecution`角色，我们需要在创建ECS集群时获取两个子网和安全组的ID。您可以在创建集群时的命令行输出中找到这些详细信息。我们将在以下的`ecs-params.yml`文件中使用这些详细信息：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `ecs-params.yml` file consists of `task_execution_role`, which we created,
    and `ecs_network_mode` set to `awsvpc`, as Fargate requires. We’ve defined `task_size`
    to have `0.5GB` of memory and `256` millicores of CPU. So, since Fargate is a
    serverless solution, we only pay for the CPU cores and memory we consume. The
    `run_params` section consists of `network_configuration`, which contains `awsvpc_configuration`.
    Here, we specify both subnets created when we created the ECS cluster. We must
    also specify `security_groups`, which we created with the ECS cluster.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ecs-params.yml` 文件包括我们创建的 `task_execution_role` 和设置为 `awsvpc` 的 `ecs_network_mode`，因为
    Fargate 要求如此。我们已将 `task_size` 定义为拥有 `0.5GB` 的内存和 `256` 毫核 CPU。由于 Fargate 是一种无服务器解决方案，我们只需为所消耗的
    CPU 核心和内存付费。`run_params` 部分包括 `network_configuration`，其中包含 `awsvpc_configuration`。在这里，我们指定了在创建
    ECS 集群时创建的两个子网。我们还必须指定与 ECS 集群一起创建的 `security_groups`。'
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Use the subnets and security groups of your ECS cluster instead of copying the
    ones in this example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你 ECS 集群的子网和安全组，而不是复制本示例中的内容。
- en: 'Now that we’re ready to fire the task on Fargate, let’s run the following command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在 Fargate 上启动任务，让我们运行以下命令：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let’s check whether the task is running successfully by using the following
    command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下命令检查任务是否成功运行：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we can see, the task is running on `3.80.173.230:80` as a Fargate task.
    Let’s `curl` this URL to see whether we get a response by using the following
    command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，任务正在 `3.80.173.230:80` 上运行，作为 Fargate 任务。让我们使用以下命令 `curl` 这个 URL，看看是否能收到响应：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see, we get the default `nginx` home page.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们得到了默认的 `nginx` 首页。
- en: 'Now, let’s go ahead and delete the task we created by using the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续使用以下命令删除我们创建的任务：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we already know, tasks have a set life cycle, and once they stop, they stop.
    You cannot start the same task again. Therefore, we must create a **service**
    to ensure that a certain number of tasks are always running. We’ll create a service
    in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，任务有一个固定的生命周期，一旦停止，它就会停止。你无法再次启动相同的任务。因此，我们必须创建一个**服务**来确保始终有一定数量的任务在运行。我们将在下一节中创建一个服务。
- en: Scheduling services on ECS
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 ECS 上调度服务
- en: '`ecs-cli` command line.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`ecs-cli` 命令行。'
- en: Tip
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always use services for applications that are long-running, such as web servers.
    For batch jobs, always use tasks, as we don’t want to recreate the job after it
    ends.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长期运行的应用程序（如 Web 服务器），始终使用服务。对于批处理任务，始终使用任务，因为我们不希望在任务结束后重新创建任务。
- en: 'To run the `nginx` web server as a service, we can use the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `nginx` Web 服务器作为服务运行，我们可以使用以下命令：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Looking at the logs, we can see that the service is trying to ensure that the
    task’s desired count matches the task’s running count. If your task is deleted,
    ECS will replace it with a new one.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志中我们可以看到，服务正在尝试确保任务的期望数量与任务的运行数量相匹配。如果你的任务被删除，ECS 会用一个新的任务替换它。
- en: 'Let’s list the tasks and see what we get by using the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列出任务，看看通过以下命令能得到什么：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As we can see, the service has created a new task that is running on `18.234.123.71:80`.
    Let’s try to access this URL using the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，服务已创建一个新任务，并在 `18.234.123.71:80` 上运行。让我们尝试通过以下命令访问该 URL：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We get the default `nginx` home page in the response. Now, let’s try to browse
    the logs of the task.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在响应中得到默认的 `nginx` 首页。现在，让我们尝试浏览任务的日志。
- en: Browsing container logs using the ECS CLI
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ECS CLI 浏览容器日志
- en: Apart from using Amazon CloudWatch, you can also use the friendly ECS CLI to
    do this, irrespective of where your logs are stored. This helps us see everything
    from a single pane of glass.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 Amazon CloudWatch 外，你还可以使用便捷的 ECS CLI 来做到这一点，无论你的日志存储在哪里。这帮助我们从单一视图看到所有内容。
- en: 'Run the following command to do so:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来执行此操作：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, we can browse the logs for the particular task this service is
    running. Now, let’s go ahead and delete the service.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以浏览该服务正在运行的特定任务的日志。现在，让我们继续删除该服务。
- en: Deleting an ECS service
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除 ECS 服务
- en: 'To delete the service, run the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除服务，运行以下命令：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As we can see, the service has been deleted.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，服务已被删除。
- en: Note that even if we create multiple instances of tasks, they run on different
    IP addresses and can be accessed separately. However, tasks need to be load-balanced,
    and we need to provide a single endpoint. Let’s look at a solution we can use
    to manage this.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使我们创建了多个任务实例，它们会运行在不同的 IP 地址上并且可以单独访问。然而，任务需要负载均衡，我们需要提供一个单一的端点。让我们来看一个可以用来管理这个问题的解决方案。
- en: Load balancing containers running on ECS
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ECS上运行负载均衡容器
- en: '**Load balancing** is an essential functionality of multi-instance applications.
    They help us serve the application on a single endpoint. Therefore, you can have
    multiple instances of your applications running simultaneously, and the end user
    doesn’t need to worry about which instance they’re calling. AWS provides two main
    load-balancing solutions—**Layer 4** with the **Network Load Balancer** (**NLB**)
    and **Layer 7** with the **Application Load** **Balancer** (**ALB**).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**负载均衡**是多实例应用程序的重要功能。它们帮助我们在单一端点上提供应用服务。因此，你可以同时运行多个实例，而最终用户不需要关心他们访问的是哪个实例。AWS提供了两种主要的负载均衡解决方案——**第四层**的**网络负载均衡器**（**NLB**）和**第七层**的**应用负载均衡器**（**ALB**）。'
- en: Tip
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: While both load balancers have their use cases, a Layer 7 load balancer provides
    a significant advantage for HTTP-based applications. It offers advanced traffic
    management, such as path-based and host-based routing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两种负载均衡器各有其使用场景，但第七层负载均衡器对于基于HTTP的应用程序具有显著优势。它提供了先进的流量管理功能，例如基于路径和主机的路由。
- en: 'So, let’s go ahead and create an ALB to frontend our tasks using the following
    command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令创建一个ALB，将其用作我们任务的前端：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The output of the preceding command contains values for `LoadBalancerARN` and
    `DNSName`. We will need to use them in the subsequent steps, so keep a copy of
    the output safe.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出包含了`LoadBalancerARN`和`DNSName`的值。我们将在后续步骤中使用它们，所以请保存输出的副本。
- en: 'The next step will be to create a **target group**. The target group defines
    the group of tasks and the port they will be listening to, and the load balancer
    will forward traffic to it. Use the following command to define a target group:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个**目标组**。目标组定义了任务的组和它们将监听的端口，负载均衡器将把流量转发到该组。使用以下命令定义目标组：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You will get the `targetGroupARN` value in the response. Keep it safe, as we
    will need it in the next step.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在响应中获得`targetGroupARN`值。请妥善保管，因为我们将在下一步中需要它。
- en: 'Next, we will need a **listener** running on the load balancer. This should
    forward traffic from the load balancer to the target group. Use the following
    command to do so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在负载均衡器上运行一个**监听器**。它应该将流量从负载均衡器转发到目标组。使用以下命令来实现：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You will get the `listenerARN` value in response to this command. Please keep
    that handy; we will need it in the next step.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在响应中获得`listenerARN`值。请妥善保管，因为我们将在下一步中需要它。
- en: Now that we’ve defined the load balancer, we need to run `ecs-cli compose service
    up` to deploy our service. We will also provide the target group as a parameter
    to associate our service with the load balancer.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了负载均衡器，我们需要运行`ecs-cli compose service up`来部署我们的服务。我们还将提供目标组作为参数，以将我们的服务与负载均衡器关联。
- en: 'To access the resources for this section, `cd` into the following directory:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，请`cd`到以下目录：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run the following command to do so:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that the service and our task are running on Fargate, we can scale our
    service to three desired tasks. To do so, run the following command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 既然服务和任务已经在Fargate上运行，我们可以将服务扩展到三个所需任务。为此，请运行以下命令：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since our service has scaled to three tasks, let’s go ahead and hit the load
    balancer DNS endpoint we captured in the first step. This should provide us with
    the default `nginx` response. Run the following command to do so:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的服务已经扩展到三个任务，现在让我们访问在第一步中获取的负载均衡器DNS端点。这应该会为我们提供默认的`nginx`响应。运行以下命令：
- en: '[PRE42]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As we can see, we get a default `nginx` response from the load balancer. This
    shows that load balancing is working well!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们从负载均衡器获得了默认的`nginx`响应。这表明负载均衡工作正常！
- en: ECS provides a host of other features, such as horizontal autoscaling, customizable
    task placement algorithms, and others, but they are beyond the scope of this book.
    Please read the ECS documentation to learn more about other aspects of the tool.
    Now, let’s look at other popular CaaS products available on the market.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ECS提供了许多其他功能，如水平自动扩展、可自定义的任务调度算法等，但这些超出了本书的范围。请阅读ECS文档，了解该工具的其他方面。现在，让我们看看市场上其他流行的CaaS产品。
- en: Other CaaS services
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他CaaS服务
- en: Amazon ECS provides a versatile way of managing your container workloads. It
    works great when you have a smaller, simpler architecture and don’t want to add
    the additional overhead of using a complex container orchestration engine such
    as Kubernetes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon ECS 提供了一种灵活的方式来管理你的容器工作负载。当你拥有一个较小、较简单的架构时，它非常适用，并且你不想增加使用像 Kubernetes
    这样复杂的容器编排引擎的额外开销。
- en: Tip
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: ECS is an excellent tool choice if you run exclusively on AWS and don’t have
    a future multi-cloud or hybrid-cloud strategy. Fargate makes deploying and running
    your containers easier without worrying about the infrastructure behind the scenes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全依赖于 AWS 并且没有未来的多云或混合云战略，ECS 是一个优秀的工具选择。Fargate 使得部署和运行容器变得更容易，无需担心背后的基础设施。
- en: ECS is tightly coupled with AWS and its architecture. To solve this problem,
    we can use managed services within AWS, such as **Elastic Kubernetes Service**
    (**EKS**). It offers the Kubernetes API to schedule your workloads. This makes
    managing containers even more versatile as you can easily spin up a Kubernetes
    cluster and use a standard, open source solution that you can install and run
    anywhere you like. This does not tie you to a particular vendor. However, EKS
    is slightly more expensive than ECS and adds a *$0.10* per hour cluster management
    charge. That is nothing in comparison to the benefits you get out of it.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ECS 与 AWS 及其架构紧密耦合。为了解决这个问题，我们可以使用 AWS 内的托管服务，如**弹性 Kubernetes 服务**（**EKS**）。它提供了
    Kubernetes API 来调度工作负载。这使得管理容器更加灵活，因为你可以轻松地启动 Kubernetes 集群，并使用一个标准的开源解决方案，在任何地方安装和运行。这不会将你绑定到特定的供应商。然而，EKS
    比 ECS 略贵，并且增加了每小时*0.10 美元*的集群管理费用。但与它带来的好处相比，这点费用算不了什么。
- en: If you aren’t running on AWS, there are options from other providers too. The
    next of the big three cloud providers is Azure, which offers **Azure Kubernetes
    Service (AKS)**, a managed Kubernetes solution that can help you get started in
    minutes. AKS provides a fully managed solution with event-driven elastic provisioning
    for worker nodes as and when required. It also integrates nicely with **Azure
    DevOps**, giving you a faster **end-to-end** (**E2E**) development experience.
    As with AWS, Azure also charges *$0.10* per hour for cluster management.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在 AWS 上运行，也有其他提供商的选择。下一个大三云服务提供商是 Azure，它提供了**Azure Kubernetes 服务（AKS）**，这是一种托管的
    Kubernetes 解决方案，可以帮助你在几分钟内开始使用。AKS 提供了一种完全托管的解决方案，支持按需事件驱动的弹性工作节点供应。它还与**Azure
    DevOps**良好集成，为你提供更快的**端到端**（**E2E**）开发体验。与 AWS 一样，Azure 也收取每小时*0.10 美元*的集群管理费用。
- en: '**Google Kubernetes Engine (GKE)** is one of the most robust Kubernetes platforms.
    Since the Kubernetes project came from Google and is the largest contributor to
    this project in the open source community, GKE is generally quicker to roll out
    newer versions and is the first to release security patches into the solution.
    Also, it is one of the most feature-rich with customizable solutions and offers
    several plugins as a cluster configuration. Therefore, you can choose what to
    install on Bootstrap and further harden your cluster. However, all these come
    at a cost, as GKE charges a *$0.10* cluster management charge per hour, just like
    AWS and Azure.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Kubernetes Engine（GKE）**是最强大的 Kubernetes 平台之一。由于 Kubernetes 项目来自 Google，并且它是该项目在开源社区中的最大贡献者，GKE
    通常会更快推出新版本，并且是第一个发布安全补丁的解决方案。此外，它是最具功能性的 Kubernetes 平台之一，提供了可自定义的解决方案，并提供了多个插件作为集群配置。因此，你可以选择在启动时安装哪些内容，并进一步加固集群。然而，所有这些都需要付出代价，因为
    GKE 与 AWS 和 Azure 一样，收取每小时*0.10 美元*的集群管理费用。'
- en: You can use **Google Cloud Run** if you don’t want to use Kubernetes if your
    architecture is not complicated, and there are only a few containers to manage.
    Google Cloud Run is a serverless CaaS solution built on the open source **Knative**
    project. It helps you run your containers without any vendor lock-in. Since it
    is serverless, you only pay for the number of containers you use and their resource
    utilization. It is a fully scalable and well-integrated solution with Google Cloud’s
    DevOps and monitoring solutions such as **Cloud Code**, **Cloud Build**, **Cloud
    Monitoring**, and **Cloud Logging**. The best part is that it is comparable to
    AWS Fargate and abstracts all infrastructure behind the scenes. So, it’s a minimal
    Ops or NoOps solution.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的架构不复杂，并且只需要管理少量容器，你可以使用 **Google Cloud Run**，而不必使用 Kubernetes。Google Cloud
    Run 是基于开源 **Knative** 项目构建的无服务器 CaaS 解决方案，帮助你运行容器而不受供应商锁定的限制。由于它是无服务器的，你只需为使用的容器数量及其资源利用付费。它是一个完全可扩展、与
    Google Cloud 的 DevOps 和监控解决方案（如 **Cloud Code**、**Cloud Build**、**Cloud Monitoring**
    和 **Cloud Logging**）良好集成的解决方案。最棒的是，它可以与 AWS Fargate 相媲美，并将所有基础设施工作抽象化。因此，它是一个最小运维或无运维的解决方案。
- en: Now that we’ve mentioned Knative as an open source CaaS solution, let’s discuss
    it in more detail.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们提到了 Knative 作为开源 CaaS 解决方案，接下来我们将更详细地讨论它。
- en: Open source CaaS with Knative
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于 Knative 的开源 CaaS
- en: As we’ve seen, several vendor-specific CaaS services are available on the market.
    Still, the problem with most of them is that they are tied up to a single cloud
    provider. Our container deployment specification then becomes vendor-specific
    and results in vendor lock-in. As modern DevOps engineers, we must ensure that
    the proposed solution best fits the architecture’s needs, and avoiding vendor
    lock-in is one of the most important requirements.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，市场上已有多种供应商特定的 CaaS 服务。然而，大多数服务的问题在于它们绑定于单一的云服务提供商。我们的容器部署规范因此会变得供应商特定，最终导致供应商锁定。作为现代的
    DevOps 工程师，我们必须确保所提议的解决方案最适合架构需求，而避免供应商锁定是最重要的要求之一。
- en: However, Kubernetes in itself is not serverless. You must have infrastructure
    defined, and long-running services should have at least a single instance running
    at a particular time. This makes managing microservices applications a pain and
    resource-intensive.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kubernetes 本身并不是无服务器的。你必须定义基础设施，并且长期运行的服务在特定时间应该至少有一个实例运行。这使得管理微服务应用变得繁琐且资源密集。
- en: But wait! We said that microservices help optimize infrastructure consumption.
    Yes—that’s correct, but they do so within the container space. Imagine that you
    have a shared cluster of VMs where parts of the application scale with traffic,
    and each part of the application has its peaks and troughs. Doing this will save
    a lot of infrastructure by performing this simple multi-tenancy.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 等等！我们说过微服务有助于优化基础设施的使用。没错——这是正确的，但它们是在容器空间内实现这一点的。试想一下，你有一个共享的虚拟机集群，应用的不同部分会随流量进行扩展，而每个部分的应用会有不同的高峰和低谷。通过这种简单的多租户方式，可以节省大量基础设施资源。
- en: However, it also means that you must have at least one instance of each microservice
    running every time—even if there is zero traffic! Well, that’s not the best utilization
    we have. How about creating instances when you get the first hit and not having
    any when you don’t have traffic? This would save a lot of resources, especially
    when things are silent. You can have hundreds of microservices making up the application
    that would not have any instances during an idle period. If you combine it with
    a managed service that runs Kubernetes and then autoscale your VM instances with
    traffic, you can have minimal instances during the silent period.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也意味着每次都必须运行每个微服务的至少一个实例——即使没有任何流量！嗯，这并不是我们所期望的最佳利用方式。那怎样做才更好呢？如何在第一次请求时创建实例，而在没有流量时不创建实例呢？这样可以节省大量资源，特别是在空闲时。你可以拥有成百上千个微服务组成应用，而在空闲期间，这些微服务是没有实例的。如果将其与管理的
    Kubernetes 服务结合，并通过流量自动扩展虚拟机实例，你就可以在空闲期间保持最少的实例。
- en: There have been attempts within the open source and cloud-native space to develop
    an open source, vendor-agnostic, serverless framework for containers. We have
    Knative for this, which the **Cloud Native Computing Foundation** (**CNCF**) has
    adopted.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在开源和云原生领域，曾有人尝试开发一种开源、供应商无关、无服务器框架用于容器。我们有 Knative，它是 **云原生计算基金会** (**CNCF**)
    采用的解决方案。
- en: Tip
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The Cloud Run service uses Knative behind the scenes. So, if you use Google
    Cloud, you can use Cloud Run to use a fully managed serverless offering.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Run 服务在后台使用 Knative。所以，如果你使用 Google Cloud，你可以使用 Cloud Run 来使用完全托管的无服务器服务。
- en: To understand how Knative works, let’s look at the Knative architecture.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Knative 是如何工作的，我们先来看看 Knative 的架构。
- en: Knative architecture
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Knative 架构
- en: 'The Knative project combines elements of existing CNCF projects such as Kubernetes,
    `kubectl` command line. Knative provides its API for developers, which the `kn`
    command-line utility can use. The users are provided access through Istio, which,
    with its traffic management features, is a crucial component of Knative. The following
    diagram describes this graphically:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 项目结合了现有 CNCF 项目的元素，如 Kubernetes 和 `kubectl` 命令行。Knative 为开发者提供了其 API，开发者可以通过
    `kn` 命令行工具使用它。用户通过 Istio 访问这些 API，而 Istio 的流量管理功能是 Knative 的一个关键组件。以下图表描述了这一过程：
- en: '![Figure 7.2 – Knative architecture](img/B19877_07_2.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – Knative 架构](img/B19877_07_2.jpg)'
- en: Figure 7.2 – Knative architecture
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – Knative 架构
- en: Knative consists of two main modules—`serving` and `eventing`. While the `serving`
    module helps us maintain stateless applications using HTTP/S endpoints, the `eventing`
    module integrates with eventing engines such as Kafka and Google Pub/Sub. As we’ve
    discussed mostly HTTP/S traffic, we will scope our discussion to Knative serving
    for this book.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 由两个主要模块组成——`serving` 和 `eventing`。`serving` 模块帮助我们使用 HTTP/S 端点维护无状态应用程序，而
    `eventing` 模块与事件引擎（如 Kafka 和 Google Pub/Sub）集成。由于我们主要讨论的是 HTTP/S 流量，本书将重点讨论 Knative
    的 serving 模块。
- en: 'Knative maintains serving pods, which help route traffic within workload pods
    and act as proxies using the **Istio Ingress Gateway** component. It provides
    a virtual endpoint for your service and listens to it. When it discovers a hit
    on the endpoint, it creates the required Kubernetes components to serve that traffic.
    Therefore, Knative has the functionality to scale from zero workload pods as it
    will spin up a pod when it receives traffic for it. The following diagram shows
    how:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 维护服务 Pod，这些 Pod 帮助在工作负载 Pod 内路由流量，并使用 **Istio Ingress Gateway** 组件作为代理。它为你的服务提供一个虚拟端点并监听该端点。当它发现该端点有请求时，它会创建所需的
    Kubernetes 组件来处理该流量。因此，Knative 具备从零工作负载 Pod 扩展的功能，因为当接收到流量时，它会启动一个 Pod。以下图示说明了这一过程：
- en: '![Figure 7.3 – Knative serving architecture](img/B19877_07_3.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – Knative 服务架构](img/B19877_07_3.jpg)'
- en: Figure 7.3 – Knative serving architecture
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – Knative 服务架构
- en: Knative endpoints are made up of three basic parts—`<app-name>`, `<namespace>`,
    and `<custom-domain>`. While `name` and `namespace` are similar to Kubernetes
    Services, `custom-domain` is defined by us. It can be a legitimate domain for
    your organization or a **MagicDNS** solution, such as **sslip.io,** which we will
    use in our hands-on exercises. If you are using your organization domain, you
    must create your DNS configuration to resolve the domain to the Istio Ingress
    Gateway IP addresses.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 端点由三部分组成——`<app-name>`、`<namespace>` 和 `<custom-domain>`。其中 `name` 和
    `namespace` 类似于 Kubernetes 服务，而 `custom-domain` 是我们定义的。它可以是你所在组织的合法域名，也可以是 **MagicDNS**
    解决方案，如 **sslip.io**，我们将在实践中使用。如果你使用的是自己组织的域名，你必须创建 DNS 配置，将该域名解析到 Istio Ingress
    Gateway 的 IP 地址。
- en: Now, let’s go ahead and install Knative.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续安装 Knative。
- en: For the exercises, we will use GKE. Since GKE is a highly robust Kubernetes
    cluster, it is a great choice for integrating with Knative. As mentioned previously,
    Google Cloud provides a free trial of $300 for 90 days. You can sign up at [https://cloud.google.com/free](https://cloud.google.com/free)
    if you’ve not done so already.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于练习，我们将使用 GKE。由于 GKE 是一个高度可靠的 Kubernetes 集群，因此它非常适合与 Knative 集成。如前所述，Google
    Cloud 提供 90 天 $300 的免费试用。如果你还没有注册，可以在 [https://cloud.google.com/free](https://cloud.google.com/free)
    上注册。
- en: Spinning up GKE
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 GKE
- en: Once you’ve signed up and are on your console, you can open the Google Cloud
    Shell CLI to run the following commands.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你注册并进入控制台，你可以打开 Google Cloud Shell CLI 来运行以下命令。
- en: 'You need to enable the GKE API first using the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要先使用以下命令启用 GKE API：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To create a two-node autoscaling GKE cluster that scales from `1` node to `5`
    nodes, run the following command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个从 `1` 个节点扩展到 `5` 个节点的自动扩展 GKE 集群，请运行以下命令：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: And that’s it! The cluster is up and running.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！集群已启动并运行。
- en: 'You will also need to clone the following GitHub repository for some of the
    exercises:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要克隆以下 GitHub 仓库以进行一些练习：
- en: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)'
- en: 'Run the following command to clone the repository into your home directory.
    Then, `cd` into the `ch7` directory to access the required resources:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将仓库克隆到你的主目录中。然后，`cd` 到 `ch7` 目录以访问所需资源：
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now that the cluster is up and running, let’s go ahead and install Knative.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 既然集群已经启动并运行，让我们继续安装 Knative。
- en: Installing Knative
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Knative
- en: We will install the CRDs that define Knative resources as Kubernetes API resources.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装定义 Knative 资源作为 Kubernetes API 资源的 CRD。
- en: 'To access the resources for this section, `cd` into the following directory:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，`cd` 到以下目录：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Run the following command to install the CRDs:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令安装 CRD：
- en: '[PRE47]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we can see, Kubernetes has installed some CRDs. Next, we must install the
    core components of the Knative `serving` module. Use the following command to
    do so:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Kubernetes 已安装了一些 CRD。接下来，我们必须安装 Knative `serving` 模块的核心组件。使用以下命令来执行此操作：
- en: '[PRE48]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now that the core serving components have been installed, the next step is
    installing Istio within the Kubernetes cluster. To do so, run the following commands:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 既然核心服务组件已经安装，下一步是在 Kubernetes 集群中安装 Istio。为此，请运行以下命令：
- en: '[PRE49]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now that Istio has been installed, we will wait for the Istio Ingress Gateway
    component to be assigned an external IP address. Run the following command to
    check this until you get an external IP in the response:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 Istio 已经安装，我们将等待 Istio Ingress Gateway 组件分配外部 IP 地址。运行以下命令检查，直到响应中返回外部 IP：
- en: '[PRE50]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As we can see, we’ve been assigned an external IP—`35.226.198.46`. We will use
    this IP for the rest of this exercise.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，已分配给我们一个外部 IP——`35.226.198.46`。我们将在接下来的操作中使用此 IP。
- en: 'Now, we will install the Knative Istio controller by using the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下命令安装 Knative Istio 控制器：
- en: '[PRE51]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now that the controller has been installed, we must configure the DNS so that
    Knative can provide custom endpoints. To do so, we can use the MagicDNS solution
    known as `sslip.io`, which you can use for experimentation. The MagicDNS solution
    resolves any endpoint to the IP address present in the subdomain. For example,
    `35.226.198.46.sslip.io` resolves to `35.226.198.46`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 既然控制器已经安装，我们必须配置 DNS，以便 Knative 可以提供自定义端点。为此，我们可以使用 MagicDNS 解决方案，称为 `sslip.io`，你可以在实验中使用它。MagicDNS
    解决方案将任何端点解析到子域中存在的 IP 地址。例如，`35.226.198.46.sslip.io` 会解析到 `35.226.198.46`。
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use MagicDNS in production. It is an experimental DNS service and should
    only be used for evaluating Knative.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中不要使用 MagicDNS。它是一个实验性的 DNS 服务，应该仅用于评估 Knative。
- en: 'Run the following command to configure the DNS:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令配置 DNS：
- en: '[PRE52]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: As you can see, it provides a batch job that gets fired whenever there is a
    DNS request.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它提供了一个批处理作业，当 DNS 请求发生时会触发。
- en: 'Now, let’s install the **HorizontalPodAutoscaler** (**HPA**) add-on to automatically
    help us autoscale pods on the cluster with traffic. To do so, run the following
    command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装 **HorizontalPodAutoscaler** (**HPA**) 插件，以便在集群上随着流量自动扩展 pod。为此，请运行以下命令：
- en: '[PRE53]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That completes our Knative installation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 Knative 的安装。
- en: 'Now, we need to install and configure the `kn` command-line utility. Use the
    following commands to do so:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要安装并配置 `kn` 命令行工具。使用以下命令来执行此操作：
- en: '[PRE54]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the next section, we’ll deploy our first application on Knative.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将部署第一个 Knative 应用程序。
- en: Deploying a Python Flask application on Knative
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Knative 上部署 Python Flask 应用程序
- en: To understand Knative, let’s try to build and deploy a Flask application that
    outputs the current timestamp in the response. Let’s start by building the app.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Knative，让我们尝试构建并部署一个 Flask 应用程序，该应用程序在响应中输出当前的时间戳。让我们从构建应用开始。
- en: Building the Python Flask app
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 Python Flask 应用程序
- en: We will have to create a few files to build such an app.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建几个文件来构建这样的应用。
- en: 'The `app.py` file looks like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 文件如下所示：'
- en: '[PRE55]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We will need the following Dockerfile to build this application:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要以下 Dockerfile 来构建这个应用：
- en: '[PRE56]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let’s go ahead and build the Docker container using the following command:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令来构建 Docker 容器：
- en: '[PRE57]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now that the image is ready, let’s push it to Docker Hub by using the following
    command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 既然镜像已经准备好，我们让我们使用以下命令将其推送到 Docker Hub：
- en: '[PRE58]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we’ve successfully pushed the image, we can run this on Knative.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经成功推送了镜像，就可以在 Knative 上运行它了。
- en: Deploying the Python Flask app on Knative
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Knative 上部署 Python Flask 应用
- en: 'We can use the `kn` command line or create a manifest file to deploy the app.
    Use the following command to deploy the application:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `kn` 命令行或创建一个清单文件来部署应用。使用以下命令来部署应用：
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'As we can see, Knative has deployed the app and provided a custom endpoint.
    Let’s `curl` the endpoint to see what we get:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Knative 已经部署了应用并提供了一个自定义端点。让我们使用 `curl` 访问该端点看看返回的结果：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We get the current time in the response. As we already know, Knative should
    detect whether there is no traffic coming into the pod and delete it. Let’s watch
    the pods for some time and see what happens:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在响应中获得了当前时间。正如我们所知道的，Knative 应该会检测到 pod 没有流量并将其删除。让我们观察 pod 一段时间，看看会发生什么：
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As we can see, just after 1 minute of inactivity, Knative starts terminating
    the pod. Now, that’s what we mean by scaling from zero.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在 1 分钟的不活动后，Knative 开始终止 pod。现在，这就是我们所说的从零扩展。
- en: 'To delete the service permanently, we can use the following command:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要永久删除服务，我们可以使用以下命令：
- en: '[PRE62]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We’ve just looked at the imperative way of deploying and managing the application.
    But what if we want to declare the configuration as we did previously? We can
    create a CRD manifest with the `Service` resource provided by `apiVersion`—`serving.knative.dev/v1`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才查看了以命令式的方式部署和管理应用程序。那么，如果我们想像之前那样声明配置该怎么办？我们可以创建一个 CRD 清单，使用由 `apiVersion`
    提供的 `Service` 资源——`serving.knative.dev/v1`。
- en: 'We will create the following manifest file, called `py-time-deploy.yaml`, for
    this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建以下名为 `py-time-deploy.yaml` 的清单文件：
- en: '[PRE63]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As we’ve created this file, we will use the `kubectl` CLI to apply it. It makes
    deployment consistent with Kubernetes.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了这个文件，我们将使用 `kubectl` CLI 来应用它。这使得部署与 Kubernetes 保持一致。
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Though it is a `service` resource, don’t confuse this with the typical Kubernetes
    `Service` resource. It is a custom resource provided by `apiVersion` `serving.knative.dev/v1`.
    That is why `apiVersion` is very important.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个 `service` 资源，但不要将其与典型的 Kubernetes `Service` 资源混淆。它是由 `apiVersion` `serving.knative.dev/v1`
    提供的自定义资源。这就是为什么 `apiVersion` 非常重要。
- en: 'Let’s go ahead and run the following command to do so:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续运行以下命令来实现：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'With that, the service has been created. To get the service’s endpoint, we
    will have to query the `ksvc` resource using `kubectl`. Run the following command
    to do so:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 到此，服务已经创建完成。要获取服务的端点，我们需要通过 `kubectl` 查询 `ksvc` 资源。运行以下命令来实现：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The URL is the custom endpoint we have to target. Let’s `curl` the custom endpoint
    using the following command:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: URL 是我们必须访问的自定义端点。让我们使用以下命令 `curl` 自定义端点：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We get the same response this time as well! So, if you want to keep using `kubectl`
    for managing Knative, you can easily do so.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们也得到了相同的响应！所以，如果你想继续使用 `kubectl` 来管理 Knative，你完全可以这么做。
- en: Knative helps scale applications based on the load it receives—automatic horizontal
    scaling. Let’s run load testing on our application to see that in action.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Knative 根据接收到的负载帮助扩展应用——自动水平扩展。让我们对应用进行负载测试，以观察它的实际应用。
- en: Load testing your app on Knative
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Knative 上进行应用负载测试
- en: 'We will use the `hey` utility to perform load testing. Since your application
    has already been deployed, run the following command to do the load test:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `hey` 工具进行负载测试。由于您的应用程序已经部署好，运行以下命令来进行负载测试：
- en: '[PRE67]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Once the command has executed, run the following command to get the currently
    running instances of the `py-time` pods:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完命令后，运行以下命令来查看当前运行的 `py-time` pod 实例：
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As we can see, Knative has created seven instances of the `py-time` pod. This
    is horizontal autoscaling in action.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Knative 已经创建了七个 `py-time` pod 实例。这就是水平自动扩展的实际应用。
- en: 'Now, let’s look at the cluster nodes by running the following command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行以下命令来查看集群节点：
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As we can see, GKE has created another node in the node pool because of the
    extra burst of traffic it received. This is phenomenal, as we have the Kubernetes
    API to do what we want. We have automatically horizontally autoscaled our pods.
    We have also automatically horizontally autoscaled our cluster worker nodes. This
    means we have a fully automated solution for running containers without worrying
    about the management nuances! That is open source serverless in action for you!
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，GKE 已经在节点池中创建了另一个节点，因为它接收到了额外的流量激增。这非常了不起，因为我们拥有 Kubernetes API 可以实现我们想要的功能。我们已经自动水平扩展了我们的
    pod。我们还自动水平扩展了集群的工作节点。这意味着我们有了一个完全自动化的解决方案，可以运行容器，而不必担心管理的细节！这就是开源无服务器架构的实际应用！
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered CaaS and serverless CaaS services. These help us manage
    container applications with ease without worrying about the underlying infrastructure
    and managing them. We used Amazon’s ECS as an example and deep-dived into it.
    Then, we briefly discussed other solutions that are available on the market.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节介绍了 CaaS 和无服务器 CaaS 服务。这些服务帮助我们轻松管理容器应用，无需担心底层基础设施和它们的管理。我们以亚马逊的 ECS 为例，进行了深入讲解。接着，我们简要讨论了市场上其他可用的解决方案。
- en: Finally, we looked at Knative, an open source serverless solution for containers
    that run on top of Kubernetes and use many other open source CNCF projects.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了 Knative，这是一个开源无服务器解决方案，适用于运行在 Kubernetes 之上的容器，并使用了许多其他开源 CNCF 项目。
- en: In the next chapter, we will delve into IaC with Terraform.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章节中，我们将深入探讨使用 Terraform 的基础设施即代码（IaC）。
- en: Questions
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: ECS allows us to deploy to which of the following? (Choose two)
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ECS 允许我们部署到以下哪些环境？（选择两个）
- en: A. EC2
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. EC2
- en: B. AWS Lambda
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. AWS Lambda
- en: C. Fargate
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Fargate
- en: D. Amazon Lightsail
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 亚马逊 Lightsail
- en: ECS uses Kubernetes in the background. (True/False)
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ECS 背后使用了 Kubernetes。（对/错）
- en: We should always use services in ECS instead of tasks for batch jobs. (True/False)
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该始终使用 ECS 中的服务而不是任务来处理批处理作业。（对/错）
- en: We should always use Fargate for batch jobs as it runs for a short period, and
    we only pay for the resources that are consumed during that time. (True/False)
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该始终使用 Fargate 来处理批处理作业，因为它运行时间短，而且我们只需为在此期间消耗的资源付费。（对/错）
- en: Which of the following are CaaS services that implement the Kubernetes API?
    (Choose three)
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是实现 Kubernetes API 的 CaaS 服务？（选择三个）
- en: A. GKE
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. GKE
- en: B. AKS
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. AKS
- en: C. EKS
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. EKS
- en: D. ECS
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. ECS
- en: Google Cloud Run is a serverless offering that uses Knative behind the scenes.
    (True/False)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Google Cloud Run 是一项无服务器服务，背后使用了 Knative。（对/错）
- en: Which one of the following is offered as a Knative module? (Choose two)
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一项是作为 Knative 模块提供的？（选择两个）
- en: A. Serving
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 服务管理
- en: B. Eventing
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 事件管理
- en: C. Computing
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 计算
- en: D. Containers
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 容器
- en: Answers
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A, C
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, C
- en: 'False'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错
- en: 'False'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错
- en: 'True'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对
- en: A, B, C
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B, C
- en: 'True'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对
- en: A, B
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B
- en: Part 3:Managing Config and Infrastructure
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：管理配置与基础设施
- en: This part takes a deep dive into infrastructure and configuration management
    in the public cloud, exploring various tools that enable infrastructure automation,
    configuration management, and immutable infrastructure.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分深入探讨了公共云中的基础设施与配置管理，探索了各种能够实现基础设施自动化、配置管理和不可变基础设施的工具。
- en: 'This part has the following chapters:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 8*](B19877_08.xhtml#_idTextAnchor1010), *Infrastructure as Code (IaC)
    with Terraform*'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B19877_08.xhtml#_idTextAnchor1010)，*使用 Terraform 实现基础设施即代码（IaC）*'
- en: '[*Chapter 9*](B19877_09.xhtml#_idTextAnchor1198), *Configuration Management
    with Ansible*'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19877_09.xhtml#_idTextAnchor1198)，*使用 Ansible 实现配置管理*'
- en: '[*Chapter 10*](B19877_10.xhtml#_idTextAnchor1330), *Immutable Infrastructure
    with Packer*'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19877_10.xhtml#_idTextAnchor1330)，*使用 Packer 实现不可变基础设施*'
