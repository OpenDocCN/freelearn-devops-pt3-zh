- en: <st c="0">7</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">7</st>
- en: <st c="2">An Overview of DevSecOps in Power Platform</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">Power Platform中的DevSecOps概述</st>
- en: <st c="44">DevSecOps is a software development methodology that integrates security
    practices into the</st> <st c="137">whole</st> **<st c="143">software development
    life cycle</st>** <st c="174">(</st>**<st c="176">SDLC</st>**<st c="180">) from</st>
    <st c="187">requirement analysis, planning and design, development, and testing
    and quality assurance through deployment and maintenance.</st> <st c="314">The
    Power Platform is a modern application runtime platform that enables developers
    to build custom applications, automate workflows, create chatbots, design and
    publish websites, and more.</st> <st c="504">The platform has a robust security
    model that ensures data protection and compliance with industry standards (</st>*<st
    c="614">more than 90+ compliance certificates</st>*<st c="652">); application
    life cycle management and the DevOps processes established by Azure DevOps or
    GitHub partially consider by default this security infusion when they deal with
    any kind of</st> <st c="838">development projects.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44">DevSecOps是一种将安全实践融入整个</st> <st c="137">**软件开发生命周期**</st> <st c="174">(</st>**<st
    c="176">SDLC</st>**<st c="180">)的软件开发方法论，包括需求分析、规划与设计、开发、测试和质量保证，直到部署和维护。</st>
    <st c="314">Power Platform是一个现代化的应用程序运行平台，使开发者能够构建自定义应用程序、自动化工作流、创建聊天机器人、设计和发布网站等。</st>
    <st c="504">该平台拥有强大的安全模型，确保数据保护并遵守行业标准（</st>*<st c="614">超过90个合规证书</st>*<st c="652">）；由Azure
    DevOps或GitHub建立的应用程序生命周期管理和DevOps流程，在处理任何类型的</st> <st c="838">开发项目时，默认部分考虑到这种安全整合。</st>
- en: <st c="859">This chapter will cover the steps and actions that are essential
    for us to set up a secure DevOps development project with multiple environments
    and</st> **<st c="1009">Microsoft Entra ID</st>**<st c="1027">-backed identity
    and access management.</st> <st c="1068">We will also learn how we can use DevOps
    tools to spin up Power Platform-based development projects at scale, allowing
    developers and contributors to quickly build and deploy applications while maintaining
    security and compliance standards.</st> <st c="1309">The platform also provides
    static analysis tools and reports to monitor certain types of security threats.</st>
    <st c="1416">This helps us enable frictionless productivity while minimizing cyber
    risk.</st> <st c="1492">We will also cover the security implications regarding
    custom code with open source libraries and we will investigate our DevOps tools
    from a</st> <st c="1634">security perspective.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="859">本章将介绍设置安全的DevOps开发项目所需的步骤和行动，涵盖多个环境以及</st> **<st c="1009">Microsoft
    Entra ID</st>**<st c="1027">支持的身份和访问管理。</st> <st c="1068">我们还将学习如何使用DevOps工具大规模启动基于Power
    Platform的开发项目，使开发人员和贡献者能够快速构建和部署应用程序，同时保持安全性和合规性标准。</st> <st c="1309">该平台还提供静态分析工具和报告，用于监控某些类型的安全威胁。</st>
    <st c="1416">这有助于我们在减少网络风险的同时实现高效的生产力。</st> <st c="1492">我们还将讨论使用开源库的自定义代码的安全影响，并将从</st>
    <st c="1634">安全的角度检查我们的DevOps工具。</st>
- en: <st c="1655">In this chapter, we are going to cover the following</st> <st c="1709">main
    topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1655">本章我们将涵盖以下</st> <st c="1709">主要主题：</st>
- en: <st c="1721">What</st> <st c="1727">is DevSecOps?</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1721">什么是DevSecOps？</st>
- en: <st c="1740">Security model of</st> <st c="1759">Power Platform</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1740">Power Platform的</st> <st c="1759">安全模型</st>
- en: <st c="1773">Secret scanning and static code</st> <st c="1806">analysis tools</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1773">机密扫描和静态代码</st> <st c="1806">分析工具</st>
- en: <st c="1820">Solution checker</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1820">解决方案检查器</st>
- en: <st c="1837">Spinning up DevSecOps projects</st> <st c="1869">at scale</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1837">大规模启动DevSecOps项目</st> <st c="1869">的实施</st>
- en: <st c="1877">Security of</st> <st c="1890">DevOps processes</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1877">DevOps流程的</st> <st c="1890">安全性</st>
- en: <st c="1906">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1906">技术要求</st>
- en: <st c="1929">To delve into the details of DevSecOps approaches and tools, we
    need to have</st> <st c="2007">the following:</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1929">要深入了解DevSecOps方法和工具，我们需要具备</st> <st c="2007">以下内容：</st>
- en: '**<st c="2021">A Power Platform subscription</st>**<st c="2051">: We can sign
    up for a Power Apps Developer Plan (</st>[<st c="2102">https://www.microsoft.com/en-us/power-platform/products/power-apps/free</st>](https://www.microsoft.com/en-us/power-platform/products/power-apps/free)<st
    c="2174">), if we already have a Microsoft Entra ID work account, or we can join
    the Microsoft 365 Developer</st> <st c="2275">Program (</st>[<st c="2284">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2348">)</st>'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2021">Power Platform 订阅</st>**<st c="2051">：我们可以注册 Power Apps 开发者计划（</st>
    [<st c="2102">https://www.microsoft.com/en-us/power-platform/products/power-apps/free</st>](https://www.microsoft.com/en-us/power-platform/products/power-apps/free)<st
    c="2174">），如果我们已经有 Microsoft Entra ID 工作帐户，或者我们可以加入 Microsoft 365 开发者</st> <st
    c="2275">计划（</st> [<st c="2284">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2348">）</st>'
- en: '**<st c="2350">An Azure DevOps services organization</st>**<st c="2387">: We
    can create a DevOps organization any time for</st> <st c="2439">free (</st>[<st
    c="2445">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st>](https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates)<st
    c="2528">).</st>'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2350">Azure DevOps 服务组织</st>**<st c="2387">：我们可以随时创建一个免费的 DevOps 组织（</st>
    [<st c="2445">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st>](https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates)<st
    c="2528">）。</st>'
- en: '**<st c="2531">A GitHub handle and a public</st>** **<st c="2561">repository</st>**<st
    c="2571">:</st> [<st c="2574">https://github.com/signup</st>](https://github.com/signup)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2531">GitHub 账户和公共</st>** **<st c="2561">仓库</st>**<st c="2571">：</st>
    [<st c="2574">https://github.com/signup</st>](https://github.com/signup)'
- en: '**<st c="2599">GitHub Advanced Security</st>**<st c="2624">: This is available
    free for public repositories;</st> <st c="2675">see</st> [<st c="2679">https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security#about-advanced-security-features</st>](https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security#about-advanced-security-features)<st
    c="2803">.</st>'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2599">GitHub 高级安全</st>**<st c="2624">：此功能对公共仓库免费开放；</st> 参见 [<st c="2679">https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security#about-advanced-security-features</st>](https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security#about-advanced-security-features)<st
    c="2803">。</st>'
- en: '**<st c="2804">Samples and walk-throughs</st>** <st c="2830">discussed in this
    chapter are located</st> <st c="2869">under</st> [<st c="2875">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter07</st>](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter07)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2804">示例和演练</st>** <st c="2830">本章讨论的内容可以在以下位置找到</st> <st c="2869">：
    </st> [<st c="2875">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter07</st>](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter07)'
- en: <st c="2974">What is DevSecOps?</st>
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2974">什么是 DevSecOps？</st>
- en: '**<st c="2993">DevSecOps</st>** <st c="3003">stands</st> <st c="3010">for</st>
    **<st c="3015">development, security, and operations</st>** <st c="3052">and the
    collaboration of these areas to deliver secure applications.</st> <st c="3122">Its
    principles were established shortly after defining the DevOps process and methodology.</st>
    <st c="3213">The idea is the same, applying the</st> **<st c="3248">shift-left</st>**
    <st c="3258">mindset in</st> <st c="3270">security in an analogous way to how
    we have applied the shift-left mindset in quality assurance and later in operations.</st>
    <st c="3391">It is a framework that integrates security into all phases of the
    SDLC and, in that sense, it is an evolution in the way software development organizations
    approach security by introducing a security-first mindset culture and automating
    security into every phase of the software development life cycle from design to
    delivery.</st> <st c="3718">Organizations</st> <st c="3732">widely adopt this
    approach to reduce the risk of releasing code with security vulnerabilities to
    avoid not just reputation loss but also the high financial impacts of</st> <st
    c="3899">such failures.</st>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="2993">DevSecOps</st>** <st c="3003">代表</st> <st c="3010">的是</st> **<st
    c="3015">开发、安全和运维</st>** <st c="3052">以及这些领域的协作，以交付安全的应用程序。</st> <st c="3122">它的原则是在定义
    DevOps 过程和方法论后不久建立的。</st> <st c="3213">这个理念相同，就是将</st> **<st c="3248">左移</st>**
    <st c="3258">的思维方式应用于安全领域，这与我们在质量保证和后来的运维中应用左移思维方式类似。</st> <st c="3270">它是一个框架，将安全性整合到
    SDLC 的所有阶段，从这个角度看，它是软件开发组织在处理安全问题时的一次演进，旨在通过引入“安全第一”的思维文化，并在软件开发生命周期的每个阶段（从设计到交付）自动化安全。</st>
    <st c="3391">组织广泛采用这种方法，减少发布含有安全漏洞的代码的风险，不仅避免了声誉损失，还避免了因</st> <st c="3899">此类失败而造成的高额财务损失。</st>'
- en: <st c="3913">If we look back at the main phases of the SDLC that we learned
    about in</st> [*<st c="3986">Chapter 1</st>*](B22208_01.xhtml#_idTextAnchor014)
    <st c="3995">(requirement analysis, planning and design, development, testing
    and quality assurance, deployment, and maintenance), then we can map the security
    activities and automations to those phases, as the following</st> <st c="4204">figure
    shows:</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3913">如果我们回顾在</st> [*<st c="3986">第一章</st>*](B22208_01.xhtml#_idTextAnchor014)
    <st c="3995">中学习到的 SDLC 的主要阶段（需求分析、规划与设计、开发、测试与质量保证、部署和维护），那么我们可以将安全活动和自动化映射到这些阶段，如下图所示：</st>
- en: '![Figure 7.1 – Security in SDLC](img/B22208_07_1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – SDLC 中的安全性](img/B22208_07_1.jpg)'
- en: <st c="4873">Figure 7.1 – Security in SDLC</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4873">图 7.1 – SDLC 中的安全性</st>
- en: <st c="4902">These steps and activities</st> <st c="4930">and their continuous
    improvements build up the</st> **<st c="4977">security development life cycle</st>**
    <st c="5008">(</st>**<st c="5010">SDL</st>**<st c="5013">).</st> <st c="5017">The
    SDL is a</st> <st c="5030">software development process that helps developers
    build and design more secure software that addresses security compliance requirements
    while reducing development costs.</st> <st c="5201">It standardizes security best
    practices across services and results in delivering more</st> <st c="5288">secure
    products.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4902">这些步骤和活动</st> <st c="4930">以及它们的持续改进构成了</st> **<st c="4977">安全开发生命周期</st>**
    <st c="5008">(</st>**<st c="5010">SDL</st>**<st c="5013">)。</st> <st c="5017">SDL
    是一种</st> <st c="5030">软件开发过程，帮助开发人员构建和设计更安全的软件，满足安全合规要求，同时降低开发成本。</st> <st c="5201">它在各项服务中标准化了安全最佳实践，并最终交付更</st>
    <st c="5288">安全的产品。</st>
- en: <st c="5304">Let us have a look at these activities in detail going through
    the SDLC and, respectively, the</st> <st c="5400">security scopes.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5304">让我们详细查看这些活动，并通过 SDLC 分析相应的</st> <st c="5400">安全范围。</st>
- en: <st c="5416">Setup</st>
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5416">设置</st>
- en: <st c="5422">During the</st> <st c="5433">initial phase of the project, we focus
    on two major</st> <st c="5486">security topics:</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5422">在项目的</st> <st c="5433">初始阶段，我们重点关注两个主要的</st> <st c="5486">安全话题：</st>
- en: '**<st c="5502">Inventory Management</st>** <st c="5523">is one</st> <st c="5531">of
    the key elements of security because this catalogizes the applications and services
    we provide for our customers.</st> <st c="5648">It is our</st> **<st c="5658">app
    catalog</st>** <st c="5669">that</st> <st c="5674">contains</st> <st c="5684">our
    applications (</st>**<st c="5702">products</st>**<st c="5711">) and</st> <st c="5718">services
    (</st>**<st c="5728">service trees</st>**<st c="5742">) in production and their
    assets (source code location, released binaries, version numbers, Azure DevOps
    projects, Azure pipelines, GitHub projects, GitHub workflows, etc.) within our
    organization.</st> <st c="5941">With the help of Inventory Management, we can
    easily find the application owners of the impacted components in the case of security
    breaches.</st> <st c="6083">Inventory Management is fully automated in organizations
    with mature DevSecOps processes, which means every time a new project is kicked
    off, a new catalog item is created that triggers workflows to spin up Azure DevOps
    or GitHub projects, Git repositories, Microsoft Entra ID groups, service principals,
    self-hosted agents, pipelines, and</st> <st c="6423">so on.</st>'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5502">库存管理</st>** <st c="5523">是</st> <st c="5531">安全性的重要元素之一，因为它
    catalogizes 我们为客户提供的应用程序和服务。</st> <st c="5648">这是我们的</st> **<st c="5658">应用目录</st>**
    <st c="5669">，其中包含</st> <st c="5674">我们的应用程序（</st>**<st c="5702">产品</st>**<st
    c="5711">）和</st> <st c="5718">服务（</st>**<st c="5728">服务树</st>**<st c="5742">）在生产中的资产（源代码位置、发布的二进制文件、版本号、Azure
    DevOps 项目、Azure 管道、GitHub 项目、GitHub 工作流等）在我们组织内部。</st> <st c="5941">借助库存管理，我们可以轻松找到受安全漏洞影响的组件的应用程序所有者。</st>
    <st c="6083">在具有成熟 DevSecOps 流程的组织中，库存管理是完全自动化的，这意味着每当启动一个新项目时，就会创建一个新的目录项，并触发工作流来启动
    Azure DevOps 或 GitHub 项目、Git 仓库、Microsoft Entra ID 组、服务主体、自托管代理、管道等。</st>'
- en: '**<st c="6429">Access control management</st>** <st c="6455">refers</st> <st
    c="6462">to the access to the application artifacts and, respectively, the underlying
    DevOps tools from an engineering perspective.</st> <st c="6586">We need to define
    the framework</st> <st c="6617">and the</st> **<st c="6626">identity and access
    management</st>** <st c="6656">(</st>**<st c="6658">IAM</st>**<st c="6661">) solution
    that we will use to give access to product owners, engineers, testers, architects,
    release managers, and ops teams while they interact with development projects.</st>
    <st c="6835">We also need to define how we are going to deal with conditional
    access policies, such as</st> <st c="6924">enforcing</st> **<st c="6935">multi-factor
    authentication</st>** <st c="6962">(</st>**<st c="6964">MFA</st>**<st c="6967">)
    when accessing production environments, and to which extent we are going to work
    with privileged identities</st> <st c="7077">in</st> **<st c="7081">privileged
    identity management</st>** <st c="7111">(</st>**<st c="7113">PIM</st>**<st c="7116">),
    for instance, to provide just-in-time privileged access to Microsoft Entra ID
    and Azure resources for high privileged users or global administrators.</st> <st
    c="7270">When PIM is enabled, these highly privileged activities are monitored
    and</st> <st c="7344">audited, too.</st> <st c="7358">It is worth noting that
    this access control is not the one that our application or service to be developed
    will use for authentication</st> <st c="7493">and authorization.</st>'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6429">访问控制管理</st>** <st c="6455">指的是</st> <st c="6462">从工程角度访问应用程序工件，以及相应的底层
    DevOps 工具。</st> <st c="6586">我们需要定义框架</st> <st c="6617">和</st> **<st c="6626">身份与访问管理</st>**
    <st c="6656">(</st>**<st c="6658">IAM</st>**<st c="6661">) 解决方案，用于授予产品所有者、工程师、测试人员、架构师、发布经理和运营团队在与开发项目交互时的访问权限。</st>
    <st c="6835">我们还需要定义如何处理条件访问策略，例如</st> <st c="6924">强制</st> **<st c="6935">多因素认证</st>**
    <st c="6962">(</st>**<st c="6964">MFA</st>**<st c="6967">) 以访问生产环境，以及我们在与特权身份管理</st>
    <st c="7077">（</st>**<st c="7081">PIM</st>**<st c="7111">）合作时的程度， 例如，向高特权用户或全局管理员提供“即时”特权访问
    Microsoft Entra ID 和 Azure 资源。</st> <st c="7270">启用 PIM 后，这些高度特权的活动会被监控并</st>
    <st c="7344">审计。</st> <st c="7358">值得注意的是，这种访问控制并非我们要开发的应用程序或服务用于身份验证和授权的控制方式。</st>'
- en: <st c="7511">Plan and Design</st>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="7511">计划和设计</st>
- en: <st c="7527">After</st> <st c="7533">setting up the project with the appropriate
    access rights and Inventory Management in place, we delve into the</st> *<st c="7645">Plan
    and Design</st>* <st c="7660">phase from a</st> <st c="7674">security perspective:</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好项目的适当访问权限和库存管理后，我们从安全角度深入探讨*计划与设计*阶段：
- en: '**<st c="7695">Threat modeling</st>** <st c="7711">is</st> <st c="7715">used
    to identify threats to our systems through the view of potential attackers and
    their probabilities and impacts on our applications before implementing any mitigation.</st>
    <st c="7887">It is a typical risk management process focusing on security.</st>
    <st c="7949">There are several tools available on the market to model threats,
    such as</st> <st c="8022">the</st> **<st c="8027">Microsoft Threat Modeling Tool</st>**
    <st c="8057">(see the</st> *<st c="8067">Further reading</st>* <st c="8082">section).</st>
    <st c="8093">As part of the sprint planning process, we can conduct threat modeling
    exercises, and, based on the risk analysis, we can decide whether we should mitigate
    certain threats and introduce those activities as product backlog items marked
    with the</st> <st c="8337">security category.</st>'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7695">威胁建模</st>** 被用来识别我们系统的潜在威胁，通过潜在攻击者的视角，以及他们对我们的应用程序的可能性和影响，在实施任何缓解措施之前进行评估。<st
    c="7887">它是一个典型的风险管理过程，专注于安全。</st> <st c="7949">市场上有多种工具可用于建模威胁，例如</st> <st c="8022">微软威胁建模工具</st>（请参见*进一步阅读*部分）。<st
    c="8093">作为冲刺计划过程的一部分，我们可以进行威胁建模演练，并根据风险分析来决定是否应缓解某些威胁，并将这些活动作为产品待办事项，标记为安全类别。</st>'
- en: '`<st c="8730">SecureString</st>` <st c="8742">type to handle credentials in</st>
    <st c="8773">our code.</st>'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="8730">SecureString</st>` 类型用于处理我们代码中的凭证。'
- en: '**<st c="8782">The peer review guide</st>** <st c="8804">is</st> <st c="8808">used
    to lay down the peer review process: when and how often they will be executed
    and whether we will involve security experts in the process or not.</st> <st c="8959">Nowadays,
    DevOps processes already prescribe code reviews in case of any pull requests,
    and DevOps tools support and document the findings</st> <st c="9098">in detail.</st>'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8782">同行评审指南</st>** 用于制定同行评审过程：评审将何时执行，执行的频率以及是否会涉及安全专家。</st> <st
    c="8959">如今，DevOps流程已经规定了在有拉取请求时必须进行代码审查，DevOps工具也会详细记录和支持这些发现。</st>'
- en: '**<st c="9108">Pre-commit hooks</st>** <st c="9125">define</st> <st c="9132">what
    kind of security checks we perform before committing code changes to repositories,
    for instance, checking commits for secrets before they reach our repositories.</st>
    <st c="9300">Pre-commit hooks can execute only a small subset of static code analysis
    rulesets because of time constraints, but they are</st> <st c="9424">essential
    parts to immediately block commits to prevent security breaches.</st> <st c="9499">We
    can</st> <st c="9505">use</st> **<st c="9510">IDE security plugins</st>** <st
    c="9530">to execute lightweight security</st> <st c="9563">analysis locally.</st>'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9108">预提交钩子</st>** 定义了在提交代码更改到代码库之前，我们执行哪些安全检查，例如，在提交之前检查提交内容是否包含敏感信息。</st>
    <st c="9300">由于时间限制，预提交钩子只能执行静态代码分析规则集的一小部分，但它们是</st> <st c="9424">防止安全漏洞的必要部分，能立即阻止不安全的提交。</st>
    <st c="9499">我们可以</st> <st c="9505">使用</st> **<st c="9510">IDE安全插件</st>** 来执行本地的轻量级安全分析。</st>'
- en: <st c="9580">Commit (CI)</st>
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交（CI）
- en: <st c="9592">After passing the</st> <st c="9610">pre-commit hooks and code review
    results, the next phase is to execute the CI build and the related security activities
    as part of the pull request</st> <st c="9759">validation process:</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过了<st c="9610">预提交钩子和代码审查结果后，下一阶段是执行CI构建和相关的安全活动，作为拉取请求验证过程的一部分：</st>
- en: '**<st c="9778">Dependency management</st>**<st c="9800">: Nowadays, custom-developed
    applications heavily rely on</st> <st c="9859">open source packages.</st> <st
    c="9881">On average, 90% of the code in current applications contains components
    based on external packages or</st> <st c="9982">libraries.</st> <st c="9994">The
    term</st> **<st c="10003">software supply chain management</st>** <st c="10035">is
    very often used, since those packages that we use in our applications also use
    other third-party components that also use other packages, and the chain goes
    on in that way.</st> <st c="10212">Identifying and exposing vulnerabilities in
    those third-party packages makes our applications vulnerable unless we refresh
    our supply chain.</st> <st c="10353">Tools such as</st> **<st c="10367">GitHub
    Dependabot</st>** <st c="10384">can</st> <st c="10388">identify the vulnerabilities
    in our supply chain (</st>*<st c="10439">inherited vulnerabilities</st>*<st c="10465">)
    and automatically create Dependabot alerts with pull requests to submit the changes
    back to our main branches.</st> <st c="10579">Dependabot checks can be executed
    during</st> <st c="10620">CI builds.</st>'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9778">依赖管理</st>**<st c="9800">：如今，定制开发的应用程序在很大程度上依赖于</st> <st c="9859">开源软件包。</st>
    <st c="9881">目前应用程序中，平均90%的代码包含基于外部软件包或</st> <st c="9982">库的组件。</st> <st c="9994">术语</st>
    **<st c="10003">软件供应链管理</st>** <st c="10035">非常常见，因为我们在应用中使用的这些软件包也使用其他第三方组件，而这些组件又使用其他包，依此类推，形成了一个链条。</st>
    <st c="10212">如果不刷新我们的供应链，识别和暴露这些第三方包中的漏洞将使我们的应用变得脆弱。</st> <st c="10353">像</st>
    **<st c="10367">GitHub Dependabot</st>** <st c="10384">这样的工具可以</st> <st c="10388">识别我们供应链中的漏洞（</st>*<st
    c="10439">继承的漏洞</st>*<st c="10465">），并自动创建Dependabot警报，发起拉取请求，将更改提交回我们的主分支。</st>
    <st c="10579">Dependabot检查可以在</st> <st c="10620">CI构建过程中执行。</st>'
- en: '**<st c="10630">Static application security testing</st>** <st c="10666">(</st>**<st
    c="10668">SAST</st>**<st c="10672">): This is static code analysis and code scanning</st>
    <st c="10723">for security.</st> <st c="10737">There are several tools available
    on the market that we can use to perform such analyses on our code base, such
    as SonarCloud, Fortify, or GitHub Advanced Security with CodeQL.</st> <st c="10914">These
    tools can be integrated into our CI pipelines for further customization.</st>
    <st c="10993">The output of static code analysis results are</st> **<st c="11040">Static
    Analysis Results Interchange Format</st>** <st c="11082">(</st>**<st c="11084">SARIF</st>**<st
    c="11089">) open standard data.</st> <st c="11112">Code scanning alerts</st> <st
    c="11132">are automatically created based on SARIF results and they can be tracked
    as backlog items.</st> <st c="11224">In the case of the GitHub Enterprise version
    with Advanced Security, we have also the possibility to use GitHub Copilot to
    fix our security issues</st> <st c="11371">fully automated.</st>'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10630">静态应用安全测试</st>** <st c="10666">(</st>**<st c="10668">SAST</st>**<st
    c="10672">)：这是对代码进行静态分析和安全扫描</st> <st c="10723">以确保安全性。</st> <st c="10737">市场上有几种工具可以用来对我们的代码库进行这种分析，例如SonarCloud、Fortify或带有CodeQL的GitHub高级安全。</st>
    <st c="10914">这些工具可以集成到我们的CI管道中，以便进一步自定义。</st> <st c="10993">静态代码分析结果的输出为</st>
    **<st c="11040">静态分析结果交换格式</st>** <st c="11082">(</st>**<st c="11084">SARIF</st>**<st
    c="11089">)开放标准数据。</st> <st c="11112">基于SARIF结果，系统会自动创建代码扫描警报，</st> <st c="11132">并且它们可以作为待办事项进行跟踪。</st>
    <st c="11224">在使用GitHub企业版高级安全功能的情况下，我们还可以使用GitHub Copilot来自动修复我们的安全问题，</st> <st
    c="11371">实现完全自动化。</st>'
- en: '**<st c="11387">Security unit and functional testing</st>**<st c="11424">:
    These are other ways to maintain the high quality of our code base and to avoid
    implementing</st> <st c="11520">security vulnerabilities.</st>'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11387">安全单元和功能测试</st>**<st c="11424">：这些是维护我们代码库高质量的其他方式，旨在避免实现</st>
    <st c="11520">安全漏洞。</st>'
- en: '**<st c="11545">Secure pipelines</st>**<st c="11562">: We need to cautiously
    care about our automated pipelines from a security point of view: who can access
    which pipeline, where the pipeline secrets are stored (Azure Key Vault), and whether
    we can use managed identities to execute workflows because insecure CI/CD pipelines
    can lead to credential leakage or even to execute malicious code in production
    environments.</st> <st c="11930">During</st> <st c="11936">CI builds, so-called</st>
    **<st c="11958">software bills of materials</st>** <st c="11985">(</st>**<st c="11987">SBOMs</st>**<st
    c="11992">) are created to track the components used in the build pipeline.</st>
    <st c="12059">An SBOM is a list of software components with their hierarchical
    relationships, version numbers, dependencies, and license requirements, usually
    in JSON format, that</st> <st c="12225">build up the application.</st> <st c="12251">SBOMs
    help with the transparency and provenance claims for our supply chain and help
    with conformance enablement.</st> <st c="12365">Hosted pools can be used to build
    and sign the code, ensuring build integrity and component governance.</st> <st
    c="12469">After a successful build, the code is stored in a secure</st> <st c="12526">artifact
    storage.</st>'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="11545">安全管道</st>**<st c="11562">：我们需要谨慎关注自动化管道的安全性：谁可以访问哪些管道，管道机密信息存储在哪里（Azure
    Key Vault），以及我们是否可以使用托管标识来执行工作流程。</st> <st c="11930">在CI构建期间，所谓的</st> **<st c="11958">软件材料清单</st>**
    <st c="11985">(</st>**<st c="11987">SBOMs</st>**<st c="11992">)会被创建，以跟踪构建管道中使用的组件。</st>
    <st c="12059">SBOM是软件组件的列表，包括它们的层次关系、版本号、依赖关系和许可要求，通常以JSON格式呈现。</st> <st c="12225">SBOM有助于透明度和供应链的可追溯性声明，并帮助符合要求的启用。</st>
    <st c="12251">托管池可以用于构建和签署代码，确保构建的完整性和组件治理。</st> <st c="12365">构建成功后，代码会存储在安全的</st>
    <st c="12469">构件存储中。</st>'
- en: '**<st c="12543">Credential scanning</st>**<st c="12563">: We</st> <st c="12568">can
    use tools to scan our code base for plain text credentials to lower the risk of</st>
    <st c="12653">credential stealing.</st>'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12543">凭证扫描</st>**<st c="12563">：我们</st> <st c="12568">可以使用工具扫描我们的代码库，以减少凭证泄露的风险。</st>'
- en: <st c="12673">Deploy (CD)</st>
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="12673">部署（CD）</st>
- en: <st c="12685">In this stage, we</st> <st c="12703">look at the overall health
    of the code base, in addition to the items checked in the Commit stage (which
    can be repeated in the deploy stage as well).</st> <st c="12855">We introduce
    additional security checks during the</st> <st c="12906">release process:</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12685">在这个阶段，我们</st> <st c="12703">查看代码库的整体健康状况，除了在提交阶段检查的内容（这些内容也可以在部署阶段重复检查）。</st>
    <st c="12855">我们在发布过程中引入了额外的安全检查：</st>
- en: '**<st c="12922">Dynamic application security testing</st>** <st c="12959">(</st>**<st
    c="12961">DAST</st>**<st c="12965">) is a technique used to evaluate</st> <st
    c="12999">the security of a software application in its running state.</st> <st
    c="13061">It involves the use of DAST tools to conduct simulated cyber-attacks
    on web applications while they are operational, identifying vulnerabilities such
    as SQL injection, cross-site scripting, and insecure configurations.</st> <st
    c="13280">This form of security testing emulates the actions of a malicious attacker
    to uncover security weaknesses within the live application, enabling developers
    to address these issues prior to the application’s release to</st> <st c="13497">the
    public.</st>'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12922">动态应用安全测试</st>** <st c="12959">(</st>**<st c="12961">DAST</st>**<st
    c="12965">)是一种评估软件应用安全性的技术，它在应用程序运行时进行。</st> <st c="12999">它涉及使用DAST工具对Web应用程序进行模拟的网络攻击，以识别SQL注入、跨站脚本攻击和不安全配置等漏洞。</st>
    <st c="13061">这种安全测试模拟恶意攻击者的行为，以发现实时应用程序中的安全弱点，使开发人员能够在应用发布之前解决这些问题。</st> <st
    c="13280">安全管道</st> <st c="13497">是为了避免凭证泄露或在生产环境中执行恶意代码。</st>'
- en: '**<st c="13508">Cloud configuration validation</st>** <st c="13539">is the
    process of verifying that the configuration</st> <st c="13590">of cloud resources
    is correct, secure, and compliant with best practices and policies.</st> <st c="13678">This
    can be done through automated tools that scan the configuration files and settings
    of cloud resources and report any issues or violations (such as configuration
    changes in production, and discrepancies between</st> <st c="13893">the IaC scripts
    and the running configuration).</st> <st c="13941">Validation can help prevent
    misconfigurations, security vulnerabilities, and compliance issues, and ensure
    that cloud resources are set up and</st> <st c="14084">managed correctly.</st>'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="13508">云配置验证</st>** <st c="13539">是验证云资源配置是否正确、安全，并符合最佳实践和政策的过程。</st>
    <st c="13590">这可以通过自动化工具完成，这些工具扫描云资源的配置文件和设置，并报告任何问题或违规行为（例如生产环境中的配置更改，或</st>
    <st c="13893">IaC 脚本与实际运行配置之间的不一致）。</st> <st c="13941">验证有助于防止配置错误、安全漏洞和合规问题，确保云资源的正确设置和</st>
    <st c="14084">管理。</st>'
- en: '**<st c="14102">Infrastructure-as-code</st>** <st c="14125">(</st>**<st c="14127">IaC</st>**<st
    c="14130">)</st> **<st c="14133">scanning</st>** <st c="14141">is the process
    of analyzing IaC files for</st> <st c="14183">security vulnerabilities, misconfigurations,
    and compliance with best practices and policies.</st> <st c="14278">IaC scanning
    tools can detect policy violations and suggest fixes for any violations detected.</st>
    <st c="14373">Even LLM-based tools can be used to prompt a GPT-4 model to detect
    policy violations in IaC files and suggest fixes for any violation detections.</st>
    <st c="14519">The violations and fixes are reported in a</st> <st c="14562">SARIF
    file.</st>'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="14102">基础设施即代码</st>** <st c="14125">(</st>**<st c="14127">IaC</st>**<st
    c="14130">)</st> **<st c="14133">扫描</st>** <st c="14141">是分析 IaC 文件以查找</st> <st
    c="14183">安全漏洞、配置错误以及是否符合最佳实践和政策的过程。</st> <st c="14278">IaC 扫描工具可以检测政策违规并提出修复建议。</st>
    <st c="14373">甚至可以使用基于 LLM 的工具提示 GPT-4 模型，检测 IaC 文件中的政策违规，并为任何违规行为提供修复建议。</st>
    <st c="14519">违规和修复会以</st> <st c="14562">SARIF 文件形式报告。</st>'
- en: '**<st c="14573">Security acceptance testing</st>** <st c="14601">is the process
    of verifying that a system meets the defined</st> <st c="14661">security requirements
    and standards before it is released or deployed.</st> <st c="14733">This type
    of testing is typically performed on new systems, upgrades, or deployments and
    includes the testing of information security requirements and adherence to secure
    system development practices.</st> <st c="14934">Acceptance testing activities
    may be performed on individual components or integrated systems, and validation
    activities may be performed using test environments to ensure that the system
    will not introduce vulnerabilities.</st> <st c="15158">Care must be taken when
    selecting test data or data from information systems that are operational to ensure
    that no personally identifiable information, secret data such as passwords, or
    hashes are captured in</st> <st c="15368">that dataset.</st>'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="14573">安全验收测试</st>** <st c="14601">是验证系统在发布或部署前是否满足已定义的</st> <st c="14661">安全要求和标准的过程。</st>
    <st c="14733">这种测试通常在新系统、升级或部署时进行，包括对信息安全要求的测试以及遵循安全系统开发实践的测试。</st> <st c="14934">验收测试活动可以在单个组件或集成系统上进行，验证活动可以在测试环境中进行，以确保系统不会引入漏洞。</st>
    <st c="15158">在选择测试数据或来自运营中信息系统的数据时，必须小心，确保没有捕获任何个人身份信息、密码等机密数据或哈希值。</st> <st
    c="15368">该数据集。</st>'
- en: <st c="15381">After successful deployments to test and later to production environments,
    the SBOM and evidence storage are used to track</st> <st c="15505">the releases.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15381">在成功部署到测试环境并随后部署到生产环境后，SBOM 和证据存储用于跟踪</st> <st c="15505">版本发布。</st>
- en: <st c="15518">Operate and Monitor</st>
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="15518">操作与监控</st>
- en: <st c="15538">In this stage, after</st> <st c="15560">successfully releasing
    our application to production, we need to focus on the following</st> <st c="15648">security-infused
    activities:</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15538">在这个阶段，成功将我们的应用程序发布到生产环境后，我们需要关注以下</st> <st c="15648">安全相关的活动：</st>
- en: '**<st c="15676">Continuous monitoring</st>** <st c="15698">is</st> <st c="15702">the
    process of continuously tracking, assessing, and reviewing the security controls
    and risks of an information system.</st> <st c="15823">This process helps to ensure
    that the security controls remain effective over time and that any changes to
    the system or its environment do not introduce new vulnerabilities.</st> <st c="15998">Continuous
    monitoring can be achieved by automated tools and processes that collect and analyze
    data from various sources, such as logs, network traffic, and system configurations.</st>
    <st c="16179">This data is then used to identify potential security issues and
    to generate alerts or reports that can be used to improve the security of</st>
    <st c="16318">the system.</st>'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="15676">持续监控</st>** <st c="15698">是</st> <st c="15702">持续跟踪、评估和审查信息系统的安全控制和风险的过程。</st>
    <st c="15823">这一过程有助于确保安全控制随时间保持有效，并确保系统或其环境的任何变化不会引入新的漏洞。</st> <st c="15998">持续监控可以通过自动化工具和过程来实现，这些工具和过程收集并分析来自各种来源的数据，如日志、网络流量和系统配置。</st>
    <st c="16179">然后，这些数据被用来识别潜在的安全问题，并生成可以用来提高系统安全性的警报或报告。</st> <st c="16318">该系统的安全性。</st>'
- en: '**<st c="16329">Audit logs</st>** <st c="16340">are</st> <st c="16345">monitored
    for security detections.</st> <st c="16380">Admin monitoring and scanning are
    performed to ensure the security of the system.</st> <st c="16462">We can consider
    the audit logs of our solutions, as our DevOps tools as well.</st> <st c="16540">Audit
    logs are essential to understand and detect changes that might come from</st>
    <st c="16619">suspicious sources.</st>'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16329">审计日志</st>** <st c="16340">是</st> <st c="16345">用于安全检测的监控对象。</st>
    <st c="16380">进行管理员监控和扫描，以确保系统的安全性。</st> <st c="16462">我们可以考虑我们解决方案的审计日志，就像我们的DevOps工具一样。</st>
    <st c="16540">审计日志对于理解和检测可能来自可疑来源的变化至关重要。</st> <st c="16619">可疑来源。</st>'
- en: '**<st c="16638">Threat intelligence</st>** <st c="16658">is the</st> <st c="16665">practice
    of collecting, analyzing, and disseminating information about current and potential
    cybersecurity threats.</st> <st c="16782">It assists organizations in proactively
    detecting and addressing security threats.</st> <st c="16865">Microsoft Threat
    Intelligence is a cloud service that uses machine learning algorithms on the collected
    signals globally to detect and mitigate security risks.</st> <st c="17025">This
    infrastructure is used to support Azure services, traditional products, endpoints
    (devices), and other corporate assets.</st> <st c="17151">It is designed to protect
    the global infrastructure that powers services such as Microsoft Azure and Power
    Platform.</st> **<st c="17268">Security incident and event management</st>** <st
    c="17306">(</st>**<st c="17308">SIEM</st>**<st c="17312">) tools, such</st> <st
    c="17327">as Microsoft Sentinel or Microsoft Defender for Cloud, use audit logs
    to detect anomalies and unusual patterns by leveraging different machine</st>
    <st c="17470">learning algorithms.</st>'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16638">威胁情报</st>** <st c="16658">是</st> <st c="16665">收集、分析和传播当前及潜在网络安全威胁信息的实践。</st>
    <st c="16782">它帮助组织主动检测和应对安全威胁。</st> <st c="16865">Microsoft 威胁情报是一个云服务，利用全球收集的信号上的机器学习算法来检测和缓解安全风险。</st>
    <st c="17025">该基础设施用于支持Azure服务、传统产品、端点（设备）以及其他企业资产。</st> <st c="17151">其目的是保护全球基础设施，支持如Microsoft
    Azure和Power Platform等服务。</st> **<st c="17268">安全事件和事件管理</st>** <st c="17306">(</st>**<st
    c="17308">SIEM</st>**<st c="17312">)工具，如Microsoft Sentinel或Microsoft Defender
    for Cloud，利用审计日志通过不同的机器学习算法来检测异常和不寻常的模式。</st> <st c="17470">学习算法。</st>'
- en: '**<st c="17490">Blameless post-mortems</st>** <st c="17513">are the process
    of analyzing incidents or failures in a non-punitive</st> <st c="17582">manner,
    with the goal of identifying the root causes and improving systems and processes
    to prevent similar incidents from happening again.</st> <st c="17723">The focus
    is on learning and improving, rather than assigning blame or punishment.</st>
    <st c="17806">Blameless post-mortems encourage open and honest communication,
    allowing team members to share their mistakes and learn from them</st> <st c="17935">without
    fear of retribution.</st> <st c="17965">This approach fosters a culture of continuous
    improvement and helps teams to build more</st> <st c="18053">resilient systems.</st>'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无责事后分析** 是一种以非惩罚性的方式分析事件或故障的过程，目的是识别根本原因并改进系统和流程，以防止类似事件再次发生。重点在于学习和改进，而不是指责或惩罚。无责事后分析鼓励开放和诚实的沟通，允许团队成员分享他们的错误并从中学习，而不必担心遭受报复。这种方法培养了持续改进的文化，帮助团队构建更具弹性的系统。'
- en: <st c="18071">We will see in the upcoming sections which of these activities
    we can apply for Power Platform solutions and which of these tasks are provided
    by the ops teams of the Power Platform</st> <st c="18254">SaaS offering.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将看到我们可以为 Power Platform 解决方案应用哪些活动，以及哪些任务由 Power Platform 的运维团队提供。
- en: <st c="18268">Let’s now move on to the security model of Power Platform and
    learn about its security design</st> <st c="18363">and principles.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续了解 Power Platform 的安全模型，学习其安全设计和原则。
- en: <st c="18378">Security model of Power Platform</st>
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Power Platform 的安全模型
- en: <st c="18411">Microsoft Power Platform runs on</st> <st c="18445">Microsoft
    Azure, and it benefits from all the security PaaS services available in the hyperscaler,
    such as Microsoft Sentinel, Microsoft Defender for Cloud, the comprehensive audit
    logs of Microsoft Entra, and</st> <st c="18655">much more.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Power Platform 运行在微软 Azure 上，受益于在该超大规模平台上可用的所有 PaaS 安全服务，如 Microsoft Sentinel、Microsoft
    Defender for Cloud、Microsoft Entra 的全面审计日志等。
- en: <st c="18665">The</st> <st c="18670">security model of Microsoft Power Platform
    is built on the principle of</st> **<st c="18742">least privileged access</st>**
    <st c="18765">(</st>**<st c="18767">LPA</st>**<st c="18770">), which</st> <st
    c="18779">facilitates the creation of applications with finer access control levels.</st>
    <st c="18855">Power Platform leverages the Microsoft Identity Platform for the
    authorization of all API requests, utilizing the widely recognized OAuth 2.0 protocol.</st>
    <st c="19007">Additionally, Dataverse, which serves as the foundational data layer
    for Power Platform, boasts a comprehensive security model that encompasses security
    at the environmental level, role-based, and record- and field-level security,
    security roles, and business units and teams through security groups and application
    users, as we learned about in</st> [*<st c="19353">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="19362">.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Power Platform 的安全模型建立在**最小权限访问**（**LPA**）的原则之上，这有助于创建具有更精细访问控制级别的应用程序。Power
    Platform 利用微软身份平台来授权所有 API 请求，采用广泛认可的 OAuth 2.0 协议。此外，作为 Power Platform 基础数据层的
    Dataverse 拥有一个全面的安全模型，涵盖了环境级安全、基于角色的安全以及记录和字段级安全、安全角色、通过安全组和应用用户的业务单元和团队，正如我们在[*第4章*](B22208_04.xhtml#_idTextAnchor074)中所了解的。
- en: <st c="19363">Additionally, Power Platform is built in distinct environments,
    which are containers of our apps, flows, connections, and other components along
    with security and data access management capabilities in geographic locations
    defined at the creation of</st> <st c="19614">those environments.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Power Platform 构建在不同的环境中，这些环境是我们应用程序、流程、连接和其他组件的容器，并具有在创建这些环境时定义的地理位置的安全性和数据访问管理能力。
- en: <st c="19633">The architecture of Power Platform is based on the zero-trust
    security principle, the</st> *<st c="19720">never trust, always verify</st>* <st
    c="19746">philosophy.</st> <st c="19759">A</st> **<st c="19761">zero-trust strategy</st>**
    <st c="19780">prescribes strict identity verification for every user and</st>
    <st c="19840">device regardless of their location (corporate or external perimeter),
    and this check happens every time corporate resources are to be accessed.</st>
    <st c="19985">This approach is realized with the help of Microsoft Identity Platform
    and the capabilities of Microsoft Entra ID.</st> <st c="20100">Every call going
    to Power Platform service endpoints requires a valid access token (bearer token)
    to get that endpoint executed.</st> <st c="20229">On the server side, the access
    token is sent to the identity provider (to Microsoft Entra ID to check its validity)
    every time a request hits the endpoints.</st> <st c="20386">These digitally signed
    access tokens contain claims about the caller that are used for authentication
    and authorization purposes.</st> <st c="20516">After identifying our caller, Power
    Platform will determine its authorization level in conjunction with that endpoint.</st>
    <st c="20635">Here, custom and built-in security roles, the business unit hierarchy,
    and team assignments are considered</st> <st c="20742">application-level authorizations.</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19633">Power Platform 的架构基于零信任安全原则，</st> *<st c="19720">永不信任，总是验证</st>*
    <st c="19746">的哲学。</st> <st c="19759">零信任策略</st> **<st c="19761">要求对每个用户和</st>
    <st c="19780">设备进行严格的身份验证，无论其位置如何（公司内网或外部边界），并且每次访问公司资源时都会进行此检查。</st> <st c="19985">这种方法通过微软身份平台和
    Microsoft Entra ID 的能力得以实现。</st> <st c="20100">每次访问 Power Platform 服务端点时，都需要有效的访问令牌（承载令牌）才能执行该端点。</st>
    <st c="20229">在服务器端，每次请求到达端点时，都会将访问令牌发送到身份提供者（即 Microsoft Entra ID）以验证其有效性。</st>
    <st c="20386">这些经过数字签名的访问令牌包含关于调用者的声明，用于身份验证和授权目的。</st> <st c="20516">在识别出调用者后，Power
    Platform 会结合该端点确定其授权级别。</st> <st c="20635">在此，考虑到自定义和内置安全角色、业务单元层级以及团队分配，这些都是</st>
    <st c="20742">应用级授权。</st>
- en: <st c="20775">The following figure</st> <st c="20797">shows the architecture
    of Power Platform within one Microsoft</st> <st c="20859">Azure region:</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20775">下图</st> <st c="20797">展示了 Power Platform 在一个 Microsoft</st> <st
    c="20859">Azure 区域中的架构：</st>
- en: '![Figure 7.2 – Power Platform architecture](img/B22208_07_2.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – Power Platform 架构](img/B22208_07_2.jpg)'
- en: <st c="21283">Figure 7.2 – Power Platform architecture</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21283">图 7.2 – Power Platform 架构</st>
- en: <st c="21323">A cluster of web</st> <st c="21341">frontend servers contains
    ASP.NET sites hosted within the Azure App Service Environment.</st> <st c="21430">An
    App Service Environment</st> <st c="21456">provides the underlying, dedicated
    compute units on which App Service Plans are deployed.</st> <st c="21547">App
    Service Plans can host one or more applications (websites).</st> <st c="21611">These
    are part of Azure App Service.</st> <st c="21648">When accessing a Power Platform
    service or app, the client’s DNS is used to direct the request to the closest
    data center, as determined by Azure Traffic Manager.</st> <st c="21811">Azure
    Traffic Manager provides several options for routing and load-balancing at layer
    4 in the OSI model, such as performance routing (closest endpoint by latency),
    weighted round-robin, and geography-based routing (closest endpoint by</st> <st
    c="22048">geographical location).</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21323">一组网页</st> <st c="21341">前端服务器包含托管在 Azure 应用服务环境中的 ASP.NET 网站。</st>
    <st c="21430">应用服务环境</st> <st c="21456">提供了底层的专用计算单元，应用服务计划在其上部署。</st> <st c="21547">应用服务计划可以托管一个或多个应用程序（网站）。</st>
    <st c="21611">这些都是 Azure 应用服务的一部分。</st> <st c="21648">当访问 Power Platform 服务或应用时，客户端的
    DNS 会将请求定向到最近的数据中心，具体由 Azure Traffic Manager 确定。</st> <st c="21811">Azure Traffic
    Manager 提供了几种路由和负载均衡选项，在 OSI 模型的第 4 层进行，例如性能路由（按延迟选择最接近的端点）、加权轮询和基于地理位置的路由（按</st>
    <st c="22048">地理位置选择最接近的端点）。</st>
- en: <st c="22071">The frontend cluster is responsible for handling the sign-in and
    authentication process.</st> <st c="22161">Once a user is verified, they receive
    a Microsoft Entra ID access token (OAuth2 token).</st> <st c="22249">The ASP.NET
    system examines the token to identify the user’s organization (Azure App Registrations
    are used internally with the account type</st> *<st c="22390">Multitenant</st>*
    <st c="22401">behind the scene).</st> <st c="22421">It then communicates with
    the Power Platform global backend service to inform the browser of the specific
    backend cluster where the organization’s tenant resides.</st> <st c="22584">All
    further interactions between the client and the backend cluster happen directly,
    bypassing the</st> <st c="22683">web frontend.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22071">前端集群负责处理登录和身份验证过程。</st> <st c="22161">一旦用户通过验证，他们会收到一个 Microsoft
    Entra ID 访问令牌（OAuth2 令牌）。</st> <st c="22249">ASP.NET 系统会检查令牌，以识别用户的组织（后台使用的是</st>
    *<st c="22390">多租户</st>* <st c="22401">帐户类型的 Azure 应用注册）。</st> <st c="22421">然后，它与
    Power Platform 全球后端服务进行通信，通知浏览器该组织租户所在的具体后端集群。</st> <st c="22584">之后，客户端与后端集群之间的所有进一步交互都会直接发生，绕过</st>
    <st c="22683">网页前端。</st>
- en: <st c="22696">For static resources such as JavaScript, CSS, and image files,
    the browser typically retrieves them</st> <st c="22797">from</st> **<st c="22802">Azure
    Content Delivery</st>** **<st c="22825">Network</st>** <st c="22832">(</st>**<st
    c="22834">CDN</st>**<st c="22837">).</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22696">对于静态资源，如 JavaScript、CSS 和图像文件，浏览器通常会从</st> <st c="22797">**Azure
    内容分发**</st> **<st c="22802">网络</st>** <st c="22832">(</st>**<st c="22834">CDN</st>**<st
    c="22837">) 获取它们。</st>
- en: <st c="22840">The backbone of</st> <st c="22857">Power Platform services is
    running</st> <st c="22891">in the</st> **<st c="22899">backend clusters</st>**<st
    c="22915">, which provide service endpoints, background services, databases, caches,
    and various other elements.</st> <st c="23018">The backend clusters span numerous
    Azure regions.</st> <st c="23068">A single region may accommodate multiple clusters
    (represented as</st> **<st c="23134">Scale Group</st>** <st c="23145">in the previous
    figure), enabling the Power Platform services to scale horizontally beyond the
    vertical and horizontal scaling capacities of an</st> <st c="23290">individual
    cluster.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22840">Power Platform 服务的核心</st> <st c="22857">运行在</st> <st c="22891">**后端集群**</st>
    <st c="22915">中，提供服务端点、后台服务、数据库、缓存和其他各种元素。</st> <st c="23018">后端集群遍布多个 Azure 区域。</st>
    <st c="23068">单个区域可能容纳多个集群（在前面的图中表示为</st> **<st c="23134">规模组</st>** <st c="23145">），使
    Power Platform 服务能够超越单个集群的垂直和水平扩展能力，进行水平扩展。</st>
- en: <st c="23309">These backend clusters are designed to be</st> *<st c="23352">stateful</st>*<st
    c="23360">, hosting the complete dataset for all the tenants they serve.</st>
    <st c="23423">The specific cluster storing a tenant’s data is known as that tenant’s
    primary cluster.</st> <st c="23511">The Power Platform global backend service
    provides details about a user’s primary cluster to the web frontend cluster, which
    then directs requests to the appropriate home backend cluster.</st> *<st c="23699">Every
    environment resides within a scale group</st>*<st c="23745">, which is a collective
    infrastructure designed to offer a scalable and maintainable set of resources.</st>
    <st c="23848">A scale group accommodates numerous customer organizations, each
    possessing its own database while sharing the service infrastructure.</st> <st
    c="23983">This setup leverages a variety of Azure services, such as Azure SQL,
    Azure Virtual Machines, and Azure Cache for Redis.</st> <st c="24103">These scale
    groups are established in pairs corresponding to the region chosen by the customer.</st>
    <st c="24199">For instance, opting for the United States as the region results
    in the formation of scale groups in both the West US and East US regions.</st>
    <st c="24338">While tenant metadata and data typically reside within the cluster,
    there is an exception for data replication to a secondary backend cluster located
    in a paired region within the same Azure geography.</st> <st c="24540">This secondary
    cluster acts as a contingency during regional disruptions, remaining inactive
    otherwise.</st> <st c="24644">Additionally, microservices dispersed across various
    machines within the cluster’s virtual network contribute to the</st> <st c="24761">backend’s
    functionality.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23309">这些后端集群旨在</st> *<st c="23352">保持状态</st>*<st c="23360">，承载它们所服务的所有租户的完整数据集。</st>
    <st c="23423">存储某个租户数据的特定集群被称为该租户的主集群。</st> <st c="23511">Power Platform全球后端服务将有关用户主集群的详细信息提供给Web前端集群，后者会将请求定向到适当的主后端集群。</st>
    *<st c="23699">每个环境都驻留在一个规模组内</st>*<st c="23745">，这是一个集体基础设施，旨在提供可扩展且可维护的资源集合。</st>
    <st c="23848">一个规模组容纳多个客户组织，每个组织拥有自己的数据库，同时共享服务基础设施。</st> <st c="23983">此设置利用了多种Azure服务，例如Azure
    SQL、Azure虚拟机和Azure Cache for Redis。</st> <st c="24103">这些规模组成对建立，分别对应客户选择的区域。</st>
    <st c="24199">例如，选择美国作为区域时，会在西部美国和东部美国区域形成规模组。</st> <st c="24338">虽然租户元数据和数据通常驻留在集群内，但数据也可以复制到位于同一Azure地理区域中配对区域的次要后端集群。</st>
    <st c="24540">该次要集群在区域性中断期间作为应急备用，否则保持不活动状态。</st> <st c="24644">此外，分散在集群虚拟网络内各种机器上的微服务也有助于</st>
    <st c="24761">后端的功能。</st>
- en: <st c="24785">DevSecOps processes and activities are realized and operated by
    the Power Platform product teams, and we embrace those as part</st> <st c="24913">of
    this</st> **<st c="24921">Software-as-a-Service</st>** <st c="24942">(</st>**<st
    c="24944">SaaS</st>**<st c="24948">) offering.</st> <st c="24961">This means that
    the product engineering teams have established controls and guardrails starting
    with Inventory Management, access control, pre-commit hooks, peer review, SAST
    and DAST analysis, secure pipelines, IaC scanning, and dependency analysis through
    threat intelligence on their development processes.</st> <st c="25271">This approach
    is audited and certified by third-party independent auditors on a regular basis.</st>
    <st c="25366">During the development process, these teams use Microsoft SDL for
    coding best practices and threat modeling, too.</st> <st c="25480">This leads
    to the conclusion that we need to focus on only the customization and extensibility
    points of the platform since these are the</st> <st c="25617">places where we
    can introduce</st> <st c="25648">vulnerabilities in our solutions.</st> <st c="25682">These
    include but not limited to</st> <st c="25715">the following:</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24785">DevSecOps流程和活动由Power Platform产品团队实现并运营，我们将其视为</st> <st c="24913">这部分</st>
    **<st c="24921">软件即服务</st>** <st c="24942">(</st>**<st c="24944">SaaS</st>**<st
    c="24948">)提供的一部分。</st> <st c="24961">这意味着产品工程团队已经建立了从库存管理、访问控制、提交前钩子、同行评审、SAST和DAST分析、安全管道、IaC扫描到通过威胁情报进行的依赖性分析等一系列控制和防护措施，涵盖了他们的开发流程。</st>
    <st c="25271">这一方法经过第三方独立审计员的定期审计和认证。</st> <st c="25366">在开发过程中，这些团队还使用Microsoft
    SDL来确保编码最佳实践和威胁建模。</st> <st c="25480">由此得出的结论是，我们需要专注于平台的定制化和可扩展性点，因为这些是</st>
    <st c="25617">我们可能引入</st> <st c="25648">漏洞的地方。</st> <st c="25682">这些包括但不限于</st>
    <st c="25715">以下内容：</st>
- en: <st c="25729">Environment</st> <st c="25742">access management</st>
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25729">环境</st> <st c="25742">访问管理</st>
- en: <st c="25759">Custom-developed</st> **<st c="25777">Power Apps Component Framework</st>**
    <st c="25807">(</st>**<st c="25809">PCF</st>**<st c="25812">) components</st>
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25759">自定义开发的</st> **<st c="25777">Power Apps组件框架</st>** <st c="25807">（</st>**<st
    c="25809">PCF</st>**<st c="25812">）组件</st>
- en: <st c="25825">Dataverse custom workflow activities and Dataverse web resources
    (HTML</st> <st c="25897">and JavaScript)</st>
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25825">Dataverse自定义工作流活动和Dataverse Web资源（HTML</st> <st c="25897">和JavaScript）</st>
- en: <st c="25912">Dataverse configurations and Dataverse</st> <st c="25952">custom-developed
    plugins</st>
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25912">Dataverse配置和Dataverse</st> <st c="25952">自定义开发的插件</st>
- en: <st c="25976">Power</st> <st c="25983">Fx expressions</st>
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25976">Power</st> <st c="25983">Fx表达式</st>
- en: <st c="25997">Power Pages custom code (HTML, JavaScript,</st> <st c="26041">and
    Liquid)</st>
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="25997">Power Pages自定义代码（HTML、JavaScript、</st> <st c="26041">和Liquid）</st>
- en: <st c="26052">Our own DevOps processes with automation scripts</st> <st c="26102">for
    CI/CD</st>
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="26052">我们自己的DevOps流程与CI/CD自动化脚本</st>
- en: <st c="26111">Solution and</st> <st c="26125">Inventory Management</st>
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="26111">解决方案和</st> <st c="26125">库存管理</st>
- en: <st c="26145">Fusion architecture components in</st> <st c="26180">Microsoft
    Azure</st>
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="26145">Fusion架构组件</st> <st c="26180">在Microsoft Azure中</st>
- en: <st c="26195">After understanding the security model of Power Platform and the
    benefits of this SaaS product from a security perspective, let us learn more about
    the tools we can use for static code analysis, dependency checks, and</st> <st
    c="26414">secret scanning.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26195">在了解Power Platform的安全模型及从安全角度看该SaaS产品的优势后，让我们进一步了解可以用于静态代码分析、依赖性检查和</st>
    <st c="26414">密钥扫描的工具。</st>
- en: <st c="26430">Secret scanning and static code analysis tools</st>
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="26430">密钥扫描和静态代码分析工具</st>
- en: <st c="26477">Although there are many other SAST tools on the market,</st> **<st
    c="26534">GitHub Advanced Security</st>** <st c="26558">(</st>**<st c="26560">GHAS</st>**<st
    c="26564">) provides</st> <st c="26576">the most comprehensive feature set for
    static security code analysis together with Copilot security support.</st> <st
    c="26685">GHAS features</st> <st c="26699">are the following for private</st>
    <st c="26729">GitHub repositories:</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26477">尽管市场上有许多其他SAST工具，</st> **<st c="26534">GitHub高级安全性</st>** <st
    c="26558">（</st>**<st c="26560">GHAS</st>**<st c="26564">）提供了</st> <st c="26576">最全面的静态安全代码分析功能，同时支持Copilot安全功能。</st>
    <st c="26685">GHAS功能</st> <st c="26699">对于私有</st> <st c="26729">GitHub代码库如下：</st>
- en: '**<st c="26749">Code scanning</st>** <st c="26763">uses</st> **<st c="26769">CodeQL</st>**
    <st c="26775">or other</st> <st c="26785">tools of your flavor to find vulnerabilities</st>
    <st c="26830">and coding errors.</st> <st c="26849">Results are stored in SARIF
    format, and they are managed at a repository level</st> <st c="26928">in GitHub.</st>'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="26749">代码扫描</st>** <st c="26763">使用</st> **<st c="26769">CodeQL</st>**
    <st c="26775">或其他</st> <st c="26785">您喜欢的工具来查找漏洞</st> <st c="26830">和编码错误。</st>
    <st c="26849">结果以SARIF格式存储，并在GitHub的代码库级别进行管理。</st>'
- en: '**<st c="26938">CodeQL CLI</st>** <st c="26949">is a standalone</st> <st c="26965">tool
    that we can use to scan our code base for vulnerabilities and coding errors.</st>
    <st c="27048">The</st> **<st c="27052">CodeQL CLI</st>** <st c="27062">is used
    in conjunction with the previous point (code scanning), or we can use it in other
    DevOps tools, such as GitLab</st> <st c="27182">or Jenkins.</st>'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="26938">CodeQL CLI</st>** <st c="26949">是一个独立的</st> <st c="26965">工具，我们可以用它扫描代码库中的漏洞和编码错误。</st>
    <st c="27048">该</st> **<st c="27052">CodeQL CLI</st>** <st c="27062">与前述的（代码扫描）一起使用，或者可以在其他DevOps工具中使用，例如GitLab</st>
    <st c="27182">或Jenkins。</st>'
- en: '**<st c="27193">Secret scanning</st>** <st c="27209">looks</st> <st c="27216">for
    secrets, keys, and sensitive tokens in your code base.</st> **<st c="27275">Pre-commit
    hooks</st>** <st c="27291">are also available to block local commits</st> <st
    c="27334">before reaching the repository and creating a new</st> <st c="27384">history
    record.</st>'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="27193">密钥扫描</st>** <st c="27209">查找</st> <st c="27216">代码库中的秘密、密钥和敏感令牌。</st>
    **<st c="27275">预提交钩子</st>** <st c="27291">也可用来阻止本地提交</st> <st c="27334">在到达代码库并创建新</st>
    <st c="27384">历史记录之前。</st>'
- en: '**<st c="27399">Custom auto-triage rules</st>** <st c="27424">assist</st> <st
    c="27431">in orchestrating</st> <st c="27448">your</st> **<st c="27454">Dependabot
    alerts</st>** <st c="27471">on a large scale.</st> <st c="27490">With custom auto-triage
    rules, you can determine which alerts to disregard, postpone, or initiate a Dependabot
    security</st> <st c="27610">update for.</st>'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="27399">自定义自动分类规则</st>** <st c="27424">有助于</st> <st c="27431">大规模协调</st>
    <st c="27448">你的</st> **<st c="27454">Dependabot 提示</st>** <st c="27471">。使用自定义自动分类规则，你可以决定忽略、推迟或触发
    Dependabot 安全</st> <st c="27610">更新。</st>'
- en: '**<st c="27621">Dependency review</st>** <st c="27639">helps us</st> <st c="27649">to
    catch insecure dependencies before we introduce them</st> <st c="27704">in our
    repositories, and provides information on licenses, dependents, and age</st> <st
    c="27784">of dependencies.</st>'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="27621">依赖性审查</st>** <st c="27639">帮助我们</st> <st c="27649">在将不安全的依赖引入我们的代码库之前进行识别</st>
    <st c="27704">并提供有关许可证、依赖项和依赖项年龄的信息。</st>'
- en: <st c="27800">These advanced security features are available in every public
    GitHub repository without any</st> <st c="27894">additional fee.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27800">这些高级安全功能在每个公共的 GitHub 仓库中都可以使用，无需额外的</st> <st c="27894">费用。</st>
- en: <st c="27909">GHAS for Azure DevOps became generally available in September
    2023\.</st> <st c="27978">The same code scanning, secret scanning, and dependency
    scanning features are available in this product as in GitHub Enterprise.</st>
    <st c="28107">The GitHub engineering team has shared this feature set with Azure
    DevOps teams in the same way as, a few years ago, the Azure DevOps team provided
    the build agent (hosted runners) functionality to the GitHub</st> <st c="28316">product
    group.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27909">GHAS for Azure DevOps 于 2023 年 9 月正式发布。</st> <st c="27978">此产品提供的代码扫描、密钥扫描和依赖扫描功能与
    GitHub 企业版中的功能相同。</st> <st c="28107">GitHub 工程团队已与 Azure DevOps 团队分享这一功能集，就像几年前
    Azure DevOps 团队将构建代理（托管运行器）功能提供给 GitHub</st> <st c="28316">产品组一样。</st>
- en: <st c="28330">Which tool, when?</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28330">哪种工具，何时使用？</st>
- en: <st c="28348">We can use GHAS for Azure DevOps only for Azure Git repositories.</st>
    <st c="28415">If we have a GitHub repository attached to Azure DevOps pipelines,
    we need to use GHAS on the GitHub side.</st> <st c="28522">Build tasks for GHAS
    for Azure DevOps will</st> <st c="28565">not work.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28348">我们只能在 Azure DevOps 中使用 GHAS 来处理 Azure Git 仓库。</st> <st c="28415">如果我们有一个附加到
    Azure DevOps 流水线的 GitHub 仓库，我们需要在 GitHub 端使用 GHAS。</st> <st c="28522">Azure DevOps
    中的 GHAS 构建任务将</st> <st c="28565">无法工作。</st>
- en: <st c="28574">GHAS is based on</st> <st c="28592">the</st> **<st c="28596">Code
    Query Language</st>** <st c="28615">(</st>**<st c="28617">CodeQL</st>**<st c="28623">),
    which can be used to build up code analysis databases on different programming
    languages.</st> <st c="28717">CodeQL supports C, C++, C#, Java, Go, Kotlin, JavaScript,
    Python, Ruby, Swift and TypeScript.</st> <st c="28811">CodeQL approaches code
    as data, enabling the discovery of potential security flaws with more assurance
    than conventional static analysis tools.</st> <st c="28955">By creating a CodeQL
    database that mirrors your code base, you can execute CodeQL queries against this
    database to pinpoint issues within your code.</st> <st c="29104">The query results
    are shown as</st> *<st c="29135">code scanning alerts</st>* <st c="29155">in GitHub
    and Azure DevOps when you use CodeQL with</st> <st c="29208">code scanning.</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28574">GHAS 基于</st> <st c="28592">的</st> **<st c="28596">代码查询语言</st>**
    <st c="28615">(</st>**<st c="28617">CodeQL</st>**<st c="28623">)，可以用于构建不同编程语言的代码分析数据库。</st>
    <st c="28717">CodeQL 支持 C、C++、C#、Java、Go、Kotlin、JavaScript、Python、Ruby、Swift 和
    TypeScript。</st> <st c="28811">CodeQL 将代码视为数据，比传统的静态分析工具更有保障地发现潜在的安全漏洞。</st> <st
    c="28955">通过创建一个与代码库相匹配的 CodeQL 数据库，你可以对这个数据库执行 CodeQL 查询，以查明代码中的问题。</st> <st
    c="29104">查询结果将显示为</st> *<st c="29135">代码扫描警报</st>* <st c="29155">，当你在 GitHub
    和 Azure DevOps 中使用 CodeQL 进行</st> <st c="29208">代码扫描时。</st>
- en: <st c="29222">CodeQL creates a relational database under the hood.</st> <st
    c="29276">Every language has its own schema and CodeQL</st> <st c="29321">uses</st>
    **<st c="29326">extractors</st>** <st c="29336">(unique for every language) to
    read the code files and compiled binaries (except for script languages) and builds
    up a hierarchical representation of code expressions, abstract syntax tree, data
    flow graph, and control flow graph.</st> <st c="29568">These building blocks are
    stored in the database and security queries are executed against these tables
    to find language-specific vulnerabilities and coding errors.</st> <st c="29733">CodeQL’s
    databases are snapshots taken from the time when we executed the analysis.</st>
    <st c="29817">GitHub provides query packs for any supported languages.</st> **<st
    c="29874">Query packs</st>** <st c="29885">consist</st> <st c="29893">of</st>
    **<st c="29897">CodeQL suites</st>** <st c="29910">(</st>**<st c="29912">qls</st>**<st
    c="29915">) that</st> <st c="29922">are sets of query language files (</st>**<st
    c="29957">ql files</st>**<st c="29966">).</st> <st c="29970">These query suites
    help us to immediately benefit from the security knowledge and expertise of GitHub
    and to get these code scanning rules executed on our code base.</st> <st c="30136">We
    can also write our own queries using Visual Studio Code and the CodeQL extension
    and we can derive from existing query suites to introduce our additional checks
    (the Windows Driver Validation Team did this to introduce their own custom</st>
    <st c="30375">rules:</st> [<st c="30381">https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql</st>](https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql)<st
    c="30471">).</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29222">CodeQL 在底层创建了一个关系数据库。</st> <st c="29276">每种语言都有自己的架构，CodeQL</st>
    <st c="29321">使用</st> **<st c="29326">提取器</st>** <st c="29336">(每种语言都有独特的提取器)来读取代码文件和编译后的二进制文件（脚本语言除外），并建立代码表达式、抽象语法树、数据流图和控制流图的层次表示。</st>
    <st c="29568">这些构建块存储在数据库中，安全查询会针对这些表执行，以发现特定语言的漏洞和编码错误。</st> <st c="29733">CodeQL
    的数据库是我们执行分析时的快照。</st> <st c="29817">GitHub 提供了适用于任何支持语言的查询包。</st> **<st c="29874">查询包</st>**
    <st c="29885">由</st> <st c="29893">组成</st> **<st c="29897">CodeQL 套件</st>** <st
    c="29910">(</st>**<st c="29912">qls</st>**<st c="29915">) 是查询语言文件集（</st>**<st
    c="29957">ql 文件</st>**<st c="29966">）。</st> <st c="29970">这些查询套件帮助我们立即受益于 GitHub
    的安全知识和专业技术，并在我们的代码库上执行这些代码扫描规则。</st> <st c="30136">我们还可以使用 Visual Studio Code
    和 CodeQL 扩展编写自己的查询，并可以从现有查询套件中派生，增加我们自己的检查（Windows 驱动验证团队就是这样做的，引入了他们自己的自定义</st>
    <st c="30375">规则：</st> [<st c="30381">https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql</st>](https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql)<st
    c="30471">）。</st>
- en: <st c="30474">The CodeQL CLI is part of the GHAS offering, and it is free of
    charge for students and academics.</st> <st c="30573">CodeQL CLI as a standalone
    tool supports macOS, Linux, and Windows operating systems and we can download
    it as binaries (see the link in</st> *<st c="30710">Further reading</st>*<st c="30725">).</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30474">CodeQL CLI 是 GHAS 服务的一部分，对学生和学术人员免费。</st> <st c="30573">作为独立工具的
    CodeQL CLI 支持 macOS、Linux 和 Windows 操作系统，我们可以将其作为二进制文件下载（请参见</st> *<st c="30710">进一步阅读</st>*<st
    c="30725">）。</st>
- en: <st c="30728">We can use the CodeQL CLI to execute code analysis even locally,
    on our Azure DevOps build agents, or on our</st> <st c="30838">GitHub runners.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30728">我们可以使用 CodeQL CLI 在本地、Azure DevOps 构建代理，或我们的</st> <st c="30838">GitHub
    执行器上执行代码分析。</st>
- en: <st c="30853">Both Azure DevOps and GitHub offer build tasks and actions around
    the CodeQL CLI to easily integrate code scanning capabilities in our existing
    pipelines</st> <st c="31008">and workflows:</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30853">Azure DevOps 和 GitHub 都提供围绕 CodeQL CLI 的构建任务和操作，便于将代码扫描功能轻松集成到现有的流水线</st>
    <st c="31008">和工作流中：</st>
- en: '![Figure 7.3 – CodeQL CLI wrappers in DevOps tools](img/B22208_07_3.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – DevOps 工具中的 CodeQL CLI 包装器](img/B22208_07_3.jpg)'
- en: <st c="31065">Figure 7.3 – CodeQL CLI wrappers in DevOps tools</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31065">图 7.3 – DevOps 工具中的 CodeQL CLI 包装器</st>
- en: <st c="31113">Since</st> <st c="31120">there are numerous places in Power Platform
    where we can introduce custom code, it is recommended to have firsthand knowledge
    of how to use the CodeQL CLI and how to set up pipelines and workflows to execute
    the different query packs.</st> <st c="31355">The best place to</st> [<st c="31373">fin</st><st
    c="31376">d custom code for Power Platform is the</st> `<st c="31417">Pow</st>`](https://github.com/microsoft/PowerApps-Samples)`<st
    c="31420">erApps-Samples</st>` <st c="31435">repository at</st> [<st c="31450">https://github.com/microsoft/PowerApps-Samples</st>](https://github.com/microsoft/PowerApps-Samples)<st
    c="31496">. Let us check the custom</st> `<st c="31629">runcodeql_javascript.ps1</st>`
    <st c="31654">in the GitHub repo of</st> <st c="31677">this chapter):</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31113">由于</st> <st c="31120">在 Power Platform 中有许多地方可以引入自定义代码，建议首先了解如何使用
    CodeQL CLI 以及如何设置管道和工作流来执行不同的查询包。</st> <st c="31355">最好的地方是</st> [<st c="31373">找到</st><st
    c="31376">Power Platform 的自定义代码在</st> `<st c="31417">Pow</st>`](https://github.com/microsoft/PowerApps-Samples)`<st
    c="31420">erApps-Samples</st>` <st c="31435">仓库，地址是</st> [<st c="31450">https://github.com/microsoft/PowerApps-Samples</st>](https://github.com/microsoft/PowerApps-Samples)<st
    c="31496">。让我们检查一下本章中的 GitHub 仓库中的自定义</st> `<st c="31629">runcodeql_javascript.ps1</st>`
    <st c="31654">文件：</st>
- en: <st c="31691">We can download the CodeQL CLI binaries (see</st> *<st c="31737">Further
    reading</st>* <st c="31752">|</st> *<st c="31755">CodeQL CLI Binaries</st>*<st
    c="31774">) and add the unpacked folder location to our</st> <st c="31821">environment
    path.</st>
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31691">我们可以下载 CodeQL CLI 二进制文件（见</st> *<st c="31737">深入阅读</st>* <st c="31752">|</st>
    *<st c="31755">CodeQL CLI 二进制文件</st>*<st c="31774">），并将解压后的文件夹位置添加到我们的</st> <st
    c="31821">环境路径中。</st>
- en: <st c="31838">We then clone the repo and navigate to the</st> <st c="31882">target
    folder:</st>
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31838">然后我们克隆该仓库并导航到</st> <st c="31882">目标文件夹：</st>
- en: '[PRE0]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="31953">Let us download the query pack for JavaScript</st> <st c="32000">and
    TypeScript:</st>
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31953">让我们下载 JavaScript</st> <st c="32000">和 TypeScript 的查询包：</st>
- en: '[PRE1]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="32097">Let us create our CodeQL database for JavaScript/TypeScript (there
    is only one extractor for JS/TS</st> <st c="32197">in place):</st>
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="32097">让我们为 JavaScript/TypeScript 创建 CodeQL 数据库（目前只有一个 JS/TS 提取器）：</st>
- en: '[PRE2]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: codeql.exe database analyze .\codeql-database-js .\codeql-pack\javascript\codeql\javascript-queries\0.8.12\codeql-suites\<st
    c="32527">javascript-code-scanning.qls</st> --format=csv --output=results.csv
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: codeql.exe database analyze .\codeql-database-js .\codeql-pack\javascript\codeql\javascript-queries\0.8.12\codeql-suites\<st
    c="32527">javascript-code-scanning.qls</st> --format=csv --output=results.csv
- en: '[PRE3]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="32590">Of course, we can analyze the code and get the results in</st>
    <st c="32649">SARIF format:</st>
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="32590">当然，我们可以分析代码并以</st> <st c="32649">SARIF 格式获取结果：</st>
- en: '[PRE4]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '# Upload results to GitHub repository'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# 上传结果到 GitHub 仓库'
- en: $env:GH_PAT = "ghp_PAT TOKEN"
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $env:GH_PAT = "ghp_PAT TOKEN"
- en: $env:GH_PAT | & codeql.exe github upload-results `
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $env:GH_PAT | & codeql.exe github upload-results `
- en: --repository=ourrepo/test `
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: --repository=ourrepo/test `
- en: --ref=refs/heads/main `
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: --ref=refs/heads/main `
- en: --commit 18cd21585b94dd16c48dc13bc1365269696a75a4 `
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: --commit 18cd21585b94dd16c48dc13bc1365269696a75a4 `
- en: --sarif=javascript.sarif --github-auth-stdin
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: --sarif=javascript.sarif --github-auth-stdin
- en: '[PRE5]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="33504">In the case of C# projects and solutions, the CodeQL commands
    are a little bit different.</st> <st c="33595">For instance, when</st> <st c="33614">we
    need to implement Dataverse plugins, we can use the C# query pack but, in this
    case, we need also to build our Visual Studio projects during the analysis (see</st>
    `<st c="33776">runcodeql_dotnet.ps1</st>` <st c="33796">in the</st> `<st c="33804">Chapter07</st>`
    <st c="33813">folder of the</st> <st c="33828">GitHub repo):</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33504">对于 C# 项目和解决方案，CodeQL 命令略有不同。</st> <st c="33595">例如，当</st> <st
    c="33614">我们需要实现 Dataverse 插件时，可以使用 C# 查询包，但在这种情况下，我们还需要在分析过程中构建 Visual Studio
    项目（见</st> `<st c="33776">runcodeql_dotnet.ps1</st>` <st c="33796">文件，位于</st> `<st
    c="33804">Chapter07</st>` <st c="33813">文件夹下，在</st> <st c="33828">GitHub 仓库中）：</st>
- en: '[PRE6]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="34255">We use the</st> `<st c="34267">--command</st>` <st c="34276">argument
    to create a database for one or more compiled languages.</st> <st c="34343">It
    expects the</st> `<st c="34358">build</st>` <st c="34363">command that builds
    our solution, such as</st> `<st c="34406">dotnet build <<path to the sln file>></st>`<st
    c="34443">. We do not need this option if we are working with Python</st> <st
    c="34502">or TS/JS.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34255">我们使用</st> `<st c="34267">--command</st>` <st c="34276">参数来为一种或多种编译语言创建数据库。</st>
    <st c="34343">它需要我们用来构建解决方案的</st> `<st c="34358">build</st>` <st c="34363">命令，例如</st>
    `<st c="34406">dotnet build <<sln 文件路径>></st>`<st c="34443">。如果我们使用的是 Python</st>
    <st c="34502">或 TS/JS，则不需要此选项。</st>
- en: <st c="34511">In the case of</st> <st c="34527">large code bases, we can use
    the following tricks to optimize CodeQL</st> <st c="34596">run durations:</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34511">在大规模代码库的情况下，我们可以使用以下技巧来优化 CodeQL</st> <st c="34596">的运行时：</st>
- en: '**<st c="34610">Query packs</st>**<st c="34622">: We</st> <st c="34627">can
    create our own query packs derived from the publicly available ones and we can
    create our own query suites to focus on different code scanning and security scanning
    analyses depending on the time we have in our pipelines.</st> <st c="34854">For
    example, during the pull request validation build, we would like to minimize the
    execution time of the analysis by focusing on the most critical security vulnerabilities,
    whereas building the main branch would execute every available</st> <st c="35092">query
    suite.</st>'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="34610">查询包</st>**<st c="34622">：我们</st> <st c="34627">可以创建自己的查询包，基于公开可用的查询包，也可以创建自己的查询套件，专注于不同的代码扫描和安全扫描分析，这取决于我们在流水线中的时间。</st>
    <st c="34854">例如，在拉取请求验证构建期间，我们希望通过专注于最关键的安全漏洞来最小化分析的执行时间，而构建主分支时则会执行所有可用的</st>
    <st c="35092">查询套件。</st>'
- en: '`<st c="35135">codeql database analyze</st>`<st c="35158">: We can use the</st>
    `<st c="35176">--thread</st>` <st c="35184">parameter</st> <st c="35195">if we
    want to use more than one thread to run queries.</st> <st c="35250">The default
    value is</st> `<st c="35271">1</st>`<st c="35272">, which means the analysis runs
    only in one thread.</st> <st c="35324">We can specify more threads to speed up
    query execution.</st> <st c="35381">To set the number of threads to the number
    of logical processors, we specify</st> `<st c="35458">0</st>` <st c="35459">to</st>
    <st c="35463">this argument.</st>'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="35135">codeql database analyze</st>`<st c="35158">：如果我们希望使用多个线程运行查询，可以使用</st>
    `<st c="35176">--thread</st>` <st c="35184">参数</st> <st c="35195">。默认值为</st> `<st
    c="35271">1</st>`<st c="35272">，这意味着分析仅在一个线程中运行。</st> <st c="35324">我们可以指定更多的线程来加速查询执行。</st>
    <st c="35381">要将线程数设置为逻辑处理器的数量，我们可以将此参数设置为</st> `<st c="35458">0</st>` <st c="35459">。</st>'
- en: '**<st c="35477">CodeQL execution targeting only part of our code base</st>**<st
    c="35531">: Ideally, we can have pull request pipelines/workflows that contain
    not just the trigger condition of whether the pull request happens but</st> <st
    c="35672">also</st> **<st c="35677">path filters</st>** <st c="35689">for the
    changes in the source</st> <st c="35719">code.</st> <st c="35726">With that, CodeQL
    can be executed for only the portion of the code, namely, the area in the source
    hierarchy that has</st> <st c="35844">been changed.</st>'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="35477">仅针对部分代码库执行 CodeQL</st>**<st c="35531">：理想情况下，我们可以拥有拉取请求流水线/工作流，这些工作流不仅包含拉取请求发生的触发条件，还可以</st>
    <st c="35672">包含</st> **<st c="35677">路径过滤器</st>** <st c="35689">来过滤源代码中的变更。</st>
    <st c="35719">这样，CodeQL 只会针对源代码层次结构中已变更的部分执行。</st> <st c="35726">通过这种方式，CodeQL
    仅在源代码中已更改的区域运行。</st>'
- en: <st c="35857">Finally, we delve into the Azure pipeline build tasks available</st>
    <st c="35921">in</st> `<st c="35952">.pipelines/codeql.yml</st>` <st c="35973">in
    the</st> `<st c="35981">Chapter07</st>` <st c="35990">folder of the</st> <st c="36005">GitHub
    repo):</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35857">最后，我们深入了解可用的 Azure 流水线构建任务</st> <st c="35921">在</st> `<st c="35952">.pipelines/codeql.yml</st>`
    <st c="35973">文件中，该文件位于</st> `<st c="35981">Chapter07</st>` <st c="35990">文件夹下的</st>
    <st c="36005">GitHub 仓库中：</st>
- en: <st c="36018">Let us</st> <st c="36025">import</st> [<st c="36033">https://github.com/microsoft/PowerApps-Samples</st>](https://github.com/microsoft/PowerApps-Samples)
    <st c="36079">into one of our Azure DevOps projects.</st> <st c="36119">We need
    to go to</st> **<st c="36136">Repos</st>** <st c="36141">and click the drop-down
    list containing all repositories in the project where we will find the</st> **<st
    c="36237">Import repository</st>** <st c="36254">action item:</st>
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36018">让我们</st> <st c="36025">导入</st> [<st c="36033">https://github.com/microsoft/PowerApps-Samples</st>](https://github.com/microsoft/PowerApps-Samples)
    <st c="36079">到我们的 Azure DevOps 项目中。</st> <st c="36119">我们需要进入</st> **<st c="36136">代码库</st>**
    <st c="36141">并点击包含所有仓库的下拉列表，在该列表中我们可以找到</st> **<st c="36237">导入仓库</st>** <st
    c="36254">操作项：</st>
- en: '![Figure 7.4 – Import a Git repository](img/B22208_07_4.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 导入 Git 仓库](img/B22208_07_4.jpg)'
- en: <st c="36429">Figure 7.4 – Import a Git repository</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36429">图 7.4 – 导入 Git 仓库</st>
- en: <st c="36465">Here, we can add the URL to the GitHub public repo and</st> <st
    c="36521">import</st> `<st c="36528">PowerApps-Samples</st>`<st c="36545">.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36465">在这里，我们可以添加 GitHub 公共仓库的 URL 并</st> <st c="36521">导入</st> `<st
    c="36528">PowerApps-Samples</st>`<st c="36545">。</st>
- en: <st c="36546">Enable the</st> **<st c="36558">Advanced Security</st>** <st c="36575">feature
    by opening the project settings (project administrator rights are required) and
    then selecting the recently imported repository.</st> <st c="36713">We</st> <st
    c="36716">need to enable</st> **<st c="36731">Advanced Security</st>** <st c="36748">by
    toggling</st> <st c="36761">the button:</st>
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="36546">通过打开项目设置启用</st> **<st c="36558">Advanced Security</st>** <st c="36575">功能（需要项目管理员权限），然后选择最近导入的仓库。</st>
    <st c="36713">我们</st> <st c="36716">需要启用</st> **<st c="36731">Advanced Security</st>**
    <st c="36748">，方法是切换</st> <st c="36761">按钮：</st>
- en: '![Figure 7.5 – Turning on the Advanced Security feature in Azure DevOps](img/B22208_07_5.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 在 Azure DevOps 中启用高级安全功能](img/B22208_07_5.jpg)'
- en: <st c="37430">Figure 7.5 – Turning on the Advanced Security feature in Azure
    DevOps</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37430">图 7.5 – 在 Azure DevOps 中启用高级安全功能</st>
- en: <st c="37499">After enabling this security feature, we can navigate to</st>
    **<st c="37557">Pipelines</st>**<st c="37566">, and we can create a new pipeline
    YAML file that will be stored in the new</st> <st c="37642">Git repository.</st>
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37499">启用此安全功能后，我们可以导航到</st> **<st c="37557">Pipelines</st>**<st c="37566">，然后我们可以创建一个新的管道
    YAML 文件，该文件将存储在新的</st> <st c="37642">Git 仓库中。</st>
- en: <st c="37657">The YAML file should look</st> <st c="37684">as follows:</st>
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="37657">YAML 文件应如下所示：</st>
- en: '[PRE7]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="37986">This</st> <st c="37991">YAML file will execute the same CodeQL
    analysis that we have seen previously with PowerShell for JavaScript via the</st>
    <st c="38108">CodeQL CLI.</st>
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37986">此</st> <st c="37991">YAML 文件将执行与之前使用 PowerShell 对 JavaScript 进行的相同的
    CodeQL 分析，通过</st> <st c="38108">CodeQL CLI。</st>
- en: <st c="38119">The code scanning and secret scanning alerts are listed under</st>
    **<st c="38182">Repos</st>** <st c="38187">in the</st> **<st c="38195">Advanced
    Security</st>** <st c="38212">tab of</st> <st c="38220">Azure DevOps:</st>
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="38119">代码扫描和密钥扫描警报列在</st> **<st c="38182">Repos</st>** <st c="38187">下的</st>
    **<st c="38195">Advanced Security</st>** <st c="38212">选项卡中，位于</st> <st c="38220">Azure
    DevOps 中：</st>
- en: '![Figure 7.6 – Code and secret scanning results in Azure DevOps](img/B22208_07_6.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 在 Azure DevOps 中的代码和密钥扫描结果](img/B22208_07_6.jpg)'
- en: <st c="39290">Figure 7.6 – Code and secret scanning results in Azure DevOps</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39290">图 7.6 – 在 Azure DevOps 中的代码和密钥扫描结果</st>
- en: <st c="39351">In the case of GitHub, we can apply the same steps by forking</st>
    `<st c="39414">PowerApps-Samples</st>` <st c="39431">and creating</st> <st c="39445">the
    code analysis-related actions (see</st> `<st c="39484">.github/workflows/codeql.yml</st>`
    <st c="39512">in the</st> `<st c="39520">Chapter07</st>` <st c="39529">folder
    of the</st> <st c="39544">GitHub repo):</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39351">在 GitHub 的情况下，我们可以通过分叉</st> `<st c="39414">PowerApps-Samples</st>`
    <st c="39431">并创建</st> <st c="39445">与代码分析相关的操作（请参阅</st> `<st c="39484">.github/workflows/codeql.yml</st>`
    <st c="39512">文件，位于</st> `<st c="39520">Chapter07</st>` <st c="39529">文件夹中的</st>
    <st c="39544">GitHub 仓库中）：</st>
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="40125">Using the</st> <st c="40135">Azure DevOps pipeline templates and
    the reusable GitHub workflows, we can easily introduce these additional code scanning
    and security analysis steps in every project of ours.</st> <st c="40312">Fortunately,
    there is another way to infuse security validation and code scanning checks in
    Power Platform solutions, which is the</st> **<st c="40443">solution checker</st>**<st
    c="40459">.</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40125">使用</st> <st c="40135">Azure DevOps 管道模板和可重用的 GitHub 工作流，我们可以轻松地在每个项目中引入这些额外的代码扫描和安全分析步骤。</st>
    <st c="40312">幸运的是，还有另一种方法可以在 Power Platform 解决方案中注入安全验证和代码扫描检查，那就是</st> **<st
    c="40443">解决方案检查器</st>**<st c="40459">。</st>
- en: <st c="40460">Solution checker</st>
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="40460">解决方案检查器</st>
- en: <st c="40477">The solution checker</st> <st c="40498">embraces the Power Apps
    checker service to execute code analysis in solutions by submitting jobs for the
    Power Platform backend.</st> <st c="40628">There are</st> <st c="40638">predefined</st>
    **<st c="40649">rulesets</st>** <st c="40657">with</st> **<st c="40663">rules</st>**
    <st c="40668">to cover certain security recommendations and coding best practices
    of our solutions.</st> <st c="40755">The solution checker can report the found
    issues in SARIF format, which we can easily upload to our DevOps tools, such as
    GitHub with GHAS or GHAS for Azure DevOps.</st> <st c="40920">The solution checker
    reviews the following Power Platform assets in</st> <st c="40988">unmanaged solutions:</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40477">解决方案检查器</st> <st c="40498">利用 Power Apps 检查服务，通过提交任务到 Power Platform
    后端执行代码分析。</st> <st c="40628">有</st> <st c="40638">预定义的</st> **<st c="40649">规则集</st>**
    <st c="40657">和</st> **<st c="40663">规则</st>** <st c="40668">用于覆盖我们解决方案的某些安全建议和编码最佳实践。</st>
    <st c="40755">解决方案检查器可以以 SARIF 格式报告找到的问题，我们可以轻松将其上传到我们的 DevOps 工具中，例如使用 GitHub
    的 GHAS 或 Azure DevOps 的 GHAS。</st> <st c="40920">解决方案检查器检查以下 Power Platform 资产</st>
    <st c="40988">中的非托管解决方案：</st>
- en: <st c="41008">Dataverse custom</st> <st c="41026">workflow activities</st>
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41008">Dataverse 自定义</st> <st c="41026">工作流活动</st>
- en: <st c="41045">Dataverse web resources (HTML</st> <st c="41076">and JavaScript)</st>
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41045">Dataverse Web 资源（HTML</st> <st c="41076">和 JavaScript）</st>
- en: <st c="41091">Dataverse configurations, such as SDK</st> <st c="41130">message
    steps</st>
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41091">Dataverse 配置，例如 SDK</st> <st c="41130">消息步骤</st>
- en: <st c="41143">Power Automate flows (via Power Automate</st> <st c="41185">Flow
    Checker)</st>
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41143">Power Automate 流程（通过 Power Automate</st> <st c="41185">Flow Checker）</st>
- en: <st c="41198">Power Fx expressions (via App Checker – part of the Power Apps</st>
    <st c="41262">checker service)</st>
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41198">Power Fx 表达式（通过应用检查器 – Power Apps</st> <st c="41262">检查服务的一部分）</st>
- en: '<st c="41278">The rulesets and their rules are predefined and categorized to
    cover the previously listed components: plug-in or workflow activity, web resources,
    and canvas app.</st> <st c="41443">We can execute the</st> <st c="41461">solution
    checker in multiple ways for</st> <st c="41500">unmanaged solutions:</st>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41278">规则集及其规则是预定义并分类的，涵盖了之前列出的组件：插件或工作流活动、Web 资源以及画布应用。</st> <st c="41443">我们可以通过多种方式执行</st>
    <st c="41461">解决方案检查器，以检查</st> <st c="41500">非托管解决方案：</st>
- en: <st c="41520">In the Power Apps maker portal under the</st> **<st c="41562">Solutions</st>**
    <st c="41571">blade.</st>
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41520">在 Power Apps 创建者门户的</st> **<st c="41562">解决方案</st>** <st c="41571">面板中。</st>
- en: <st c="41578">Using the</st> `<st c="41589">pac solution check</st>` <st c="41607">command
    with the proper parameters, such as</st> <st c="41652">the following:</st>
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41578">使用</st> `<st c="41589">pac solution check</st>` <st c="41607">命令，带上正确的参数，例如</st>
    <st c="41652">如下：</st>
- en: '[PRE9]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<st c="42256">Using</st> <st c="42263">the</st> **<st c="42267">Power Apps
    checker web API</st>**<st c="42293">: The Power App maker portal, the PAC CLI,
    and the PowerShell module rely on these REST API endpoints under the hood.</st>
    <st c="42412">We can directly call these endpoints having the appropr</st>[<st
    c="42467">iate access token in place; for instance, the</st>](https://unitedstates.api.advisor.powerapps.com)
    <st c="42514">US endpoint is reachable under the following</st> <st c="42559">URL:</st>
    [<st c="42564">https://unitedstates.api.advisor.powerapps.com</st>](https://unitedstates.api.advisor.powerapps.com)<st
    c="42610">.</st>'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="42256">使用</st> <st c="42263">以下</st> **<st c="42267">Power Apps 检查器 Web
    API</st>**<st c="42293">：Power Apps 创建者门户、PAC CLI 和 PowerShell 模块都依赖于这些 REST API
    端点。</st> <st c="42412">我们可以直接调用这些端点，前提是有适当的访问令牌；例如，</st> [<st c="42467">美国端点可通过以下</st>](https://unitedstates.api.advisor.powerapps.com)
    <st c="42514">URL 访问：</st> <st c="42559">以下是</st> [<st c="42564">https://unitedstates.api.advisor.powerapps.com</st>](https://unitedstates.api.advisor.powerapps.com)<st
    c="42610">。</st>
- en: <st c="42611">Using</st> **<st c="42618">managed environments</st>** <st c="42638">to
    enforce solution checker runs before importing solutions to target environments.</st>
    <st c="42723">Here, we can block the import of solutions if violations against
    these rules</st> <st c="42800">are encountered.</st>
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="42611">使用</st> **<st c="42618">托管环境</st>** <st c="42638">在导入解决方案到目标环境之前强制执行解决方案检查器运行。</st>
    <st c="42723">在此，我们可以阻止导入解决方案，如果遇到违反这些规则的情况</st> <st c="42800">。</st>
- en: <st c="42816">Leveraging the</st> `<st c="43186">PowerPlatformChecker@2</st>`<st
    c="43209">) during the import process of solutions from Git repositories.</st>
    <st c="43274">This task uses the PAC CLI behind</st> <st c="43308">the scenes.</st>
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="42816">利用</st> `<st c="43186">PowerPlatformChecker@2</st>`<st c="43209">)
    在从 Git 仓库导入解决方案的过程中。</st> <st c="43274">此任务在后台使用 PAC CLI。</st>
- en: <st c="43319">Let us have a look at the build task in Azure pipelines that executes
    such a static code analysis on our</st> <st c="43425">solution (see</st> `<st
    c="43439">.pipelines/solution-checker.yml</st>` <st c="43470">in the</st> `<st
    c="43478">Chapter07</st>` <st c="43487">folder of the</st> <st c="43502">GitHub
    repo):</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43319">让我们来看一下在 Azure 管道中执行静态代码分析的构建任务，该任务分析我们的</st> <st c="43425">解决方案（见</st>
    `<st c="43439">.pipelines/solution-checker.yml</st>` <st c="43470">在</st> `<st
    c="43478">第七章</st>` <st c="43487">文件夹中的</st> <st c="43502">GitHub 仓库）：</st>
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'name: Solution-Checker'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：解决方案检查器
- en: 'on:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 触发：
- en: 'workflow_dispatch:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'workflow_dispatch:'
- en: 'jobs:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 作业：
- en: 'solutioncheck:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 'solutioncheck:'
- en: 'runs-on: ubuntu-latest'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在：ubuntu-latest
- en: 'env:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 环境：
- en: 'Solution: mpa_ITBase'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解决方案：mpa_ITBase
- en: 'steps:'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 步骤：
- en: '- uses: actions/checkout@v3'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 使用：actions/checkout@v3'
- en: '- name: Install Power Platform Tools'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 名称：安装 Power Platform 工具'
- en: 'uses: microsoft/powerplatform-actions/actions-install@v1 <st c="45422">- name:
    Pack unmanaged solution</st>'
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '使用: microsoft/powerplatform-actions/actions-install@v1 <st c="45422">- 名称:
    打包未管理的解决方案</st>'
- en: '<st c="45453">uses: microsoft/powerplatform-actions/pack-solution@v1</st>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="45453">使用: microsoft/powerplatform-actions/pack-solution@v1</st>'
- en: <st c="45508">with:</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45508">使用：</st>
- en: '<st c="45514">solution-folder: ${{ env.Solution }}</st>'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="45514">解决方案文件夹: ${{ env.Solution }}</st>'
- en: '<st c="45551">solution-file: ${{ env.Solution }}_unmanaged.zip</st>'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="45551">解决方案文件: ${{ env.Solution }}_unmanaged.zip</st>'
- en: '<st c="45600">solution-type: Unmanaged</st>'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45600">解决方案类型：未管理</st>
- en: '<st c="45625">- name: Check-solution</st>'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45625">- 名称：检查解决方案</st>
- en: '<st c="45648">uses: microsoft/powerplatform-actions/check-solution@v1</st>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="45648">使用: microsoft/powerplatform-actions/check-solution@v1</st>'
- en: <st c="45704">with:</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45704">使用：</st>
- en: '<st c="45710">environment-url: https://yourorg.crm.dynamics.com</st>'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="45710">环境网址: https://yourorg.crm.dynamics.com</st>'
- en: '<st c="45760">app-id: 862e5a17-d38b-BBBB-FFFF-88a77f59623f</st>'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="45760">应用程序 ID: 862e5a17-d38b-BBBB-FFFF-88a77f59623f</st>'
- en: '<st c="45805">client-secret: "${{ secrets.CLIENTSECRET_DEV }}"</st>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45805">客户端密钥：“${{ secrets.CLIENTSECRET_DEV }}”</st>
- en: '<st c="45854">tenant-id: 4ae51f31-033a-XXXX-YYYY-5ece14d2c081</st>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45854">租户 ID：4ae51f31-033a-XXXX-YYYY-5ece14d2c081</st>
- en: <st c="45962">microsoft/powerplatform-actions/pack-solution@v1</st>, also uploads
    the SARIF result to the artifacts of the GitHub workflow run.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45962">microsoft/powerplatform-actions/pack-solution@v1</st>，还将 SARIF
    结果上传到 GitHub 工作流运行的工件中。
- en: <st c="46086">Managing the findings</st>
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46086">管理发现</st>
- en: <st c="46108">Whether the solution checker with SARIF results, GHAS, or other
    code and dependency scanning tools are used to execute SAST, after gathering the
    results, we also need to manage those findings.</st> <st c="46302">We can mitigate
    these risks by accepting them, such as a security alert in the test code will
    not be corrected, or we can introduce new issues or work items to update the code
    according to the finding and respectively the vulnerability described</st> <st
    c="46547">in the</st> **<st c="46555">Common Weakness Enumeration</st>** <st c="46582">(</st>**<st
    c="46584">CWE</st>**<st c="46587">) database.</st> <st c="46600">Modern DevOps
    tools support linking the code scanning, dependency scanning, and secret scanning
    alerts to work items or issues and introduce the demand for fixes in the development</st>
    <st c="46781">life cycle.</st>
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46108">无论是使用带有 SARIF 结果的解决方案检查器、GHAS，还是其他代码和依赖扫描工具执行 SAST，在收集结果后，我们还需要管理这些发现。</st>
    <st c="46302">我们可以通过接受这些风险来减轻风险，例如在测试代码中的安全警报不被修正，或者我们可以引入新的问题或工作项，根据发现和相应描述的漏洞</st>
    <st c="46547">在</st> **<st c="46555">常见弱点枚举</st>** <st c="46582">(</st>**<st c="46584">CWE</st>**<st
    c="46587">) 数据库中。</st> <st c="46600">现代 DevOps 工具支持将代码扫描、依赖扫描和密钥扫描警报链接到工作项或问题，并在开发</st>
    <st c="46781">生命周期中引入修复需求。</st>
- en: <st c="46792">Now we are familiar with the solution checker, the GHAS features,
    and the tasks in the DevSecOps process related to the SDLC methodology, we now
    combine this knowledge with the automated DevOps processes from</st> [*<st c="47002">Chapter
    6</st>*](B22208_06.xhtml#_idTextAnchor103)<st c="47011">.</st>
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46792">现在我们已经熟悉了解决方案检查器、GHAS 功能以及与 SDLC 方法论相关的 DevSecOps 流程中的任务，我们将这些知识与来自</st>
    [*<st c="47002">第六章</st>*](B22208_06.xhtml#_idTextAnchor103)<st c="47011">的自动化
    DevOps 流程结合起来。</st>
- en: <st c="47012">Spinning up DevSecOps projects at scale</st>
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47012">大规模启动 DevSecOps 项目</st>
- en: <st c="47052">In</st> [*<st c="47056">Chapter 6</st>*](B22208_06.xhtml#_idTextAnchor103)<st
    c="47065">, we</st> <st c="47070">learned how to spin up Power Platform environments
    with solutions assigned to our Git repositories and, respectively, the underlying
    branches.</st> <st c="47213">We created pipeline templates and reusable workflows
    in GitHub to provide automations for</st> <st c="47303">the following:</st>
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47052">在</st> [*<st c="47056">第 6 章</st>*](B22208_06.xhtml#_idTextAnchor103)<st
    c="47065">中，我们学习了如何为我们的 Git 仓库分配解决方案并相应地设置底层分支来启动 Power Platform 环境。</st> <st
    c="47213">我们在 GitHub 中创建了管道模板和可重用的工作流，以提供以下自动化功能：</st>
- en: <st c="47317">Spinning up new Power Platform</st> <st c="47349">developer environments</st>
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="47317">启动新的 Power Platform</st> <st c="47349">开发者环境</st>
- en: <st c="47371">Creating service connections to those Power</st> <st c="47416">Platform
    environments</st>
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="47371">为这些 Power</st> <st c="47416">Platform 环境创建服务连接</st>
- en: <st c="47437">Exporting solutions from developer environments to</st> <st c="47489">Git
    branches</st>
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="47437">从开发者环境导出解决方案到</st> <st c="47489">Git 分支</st>
- en: <st c="47501">Importing solutions from Git repositories and branches to target
    environments via pull requests or directly to our</st> <st c="47617">developer
    branch</st>
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="47501">通过拉取请求或直接将解决方案从 Git 仓库和分支导入目标环境，或导入到我们的</st> <st c="47617">开发分支</st>
- en: '<st c="47633">We can take one step forward in this journey and automate the
    entire development process of Power Platform solutions.</st> <st c="47752">First,
    let us introduce a new term: workload.</st> **<st c="47798">Workloads</st>** <st
    c="47807">consist</st> <st c="47816">of one or more solutions that contribute
    to each other to implement complex business requirements.</st> <st c="47915">We
    can consider them as the input solutions for package deployer packages, such as
    the</st> **<st c="48002">Enterprise templates</st>** <st c="48022">we learned
    about in</st> [*<st c="48043">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="48052">. To set up an enterprise-grade DevSecOps project for workloads or for
    separate solutions, we need to accomplish the following additional</st> <st c="48190">automation
    tasks:</st>'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47633">我们可以在这段旅程中迈出一步，自动化整个 Power Platform 解决方案的开发过程。</st> <st c="47752">首先，让我们引入一个新术语：工作负载。</st>
    **<st c="47798">工作负载</st>** <st c="47807">由一个或多个相互配合的解决方案组成，旨在实现复杂的业务需求。</st>
    <st c="47915">我们可以将它们视为包部署器包的输入解决方案，例如我们在</st> **<st c="48002">企业模板</st>** <st
    c="48022">中学到的内容，在</st> [*<st c="48043">第 4 章</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="48052">中学到的内容。要为工作负载或独立解决方案设置一个企业级的 DevSecOps 项目，我们需要完成以下额外的自动化任务：</st>
- en: <st c="48207">Create AAD groups (Microsoft Entra ID groups) for owners and contributors.</st>
    <st c="48283">There must be at least two owners in the</st> `<st c="48324">Owners</st>`
    <st c="48330">group.</st> <st c="48338">In most cases, we recommend having a budget
    owner and a technical owner assigned to</st> <st c="48422">a project</st><st c="48431">.</st>
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48207">为所有者和贡献者创建 AAD 组（Microsoft Entra ID 组）。</st> <st c="48283">必须至少有两个所有者在</st>
    `<st c="48324">所有者</st>` <st c="48330">组中。</st> <st c="48338">在大多数情况下，我们建议指定一个预算所有者和一个技术所有者来负责</st>
    <st c="48422">项目</st><st c="48431">。</st>
- en: <st c="48432">Create environments for testing and production per each workload
    or use existing shared environments hosting more solutions for the</st> <st c="48565">new
    one.</st>
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48432">为每个工作负载创建测试和生产环境，或者使用现有的共享环境来托管更多的解决方案</st> <st c="48565">。</st>
- en: <st c="48573">Create</st> <st c="48581">service principals for these environments
    using</st> `<st c="48629">pac admin create-service-principal</st>` <st c="48663">and
    the</st> `<st c="48938">Owners</st>` <st c="48944">AAD group</st> <st c="48955">created
    earlier.</st>
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48573">为这些环境创建</st> <st c="48581">服务主体，使用</st> `<st c="48629">pac admin
    create-service-principal</st>` <st c="48663">和之前创建的</st> `<st c="48938">所有者</st>`
    <st c="48944">AAD 组</st> <st c="48955">。</st>
- en: <st c="48971">Create an Azure DevOps project and assign the</st> `<st c="49018">Owners</st>`
    <st c="49024">AAD group to</st> `<st c="49081">Contributors</st>` <st c="49093">group
    to the</st> **<st c="49107">Contributors</st>** <st c="49119">group of</st> <st
    c="49129">Azure DevOps.</st>
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="48971">创建一个 Azure DevOps 项目，并将</st> `<st c="49018">所有者</st>` <st c="49024">AAD
    组分配给</st> `<st c="49081">贡献者</st>` <st c="49093">组，</st> **<st c="49107">贡献者</st>**
    <st c="49119">组分配给</st> <st c="49129">Azure DevOps。</st>
- en: <st c="49142">Create a Git repository for the workload or solution in the Azure
    DevOps project with branch policies</st> <st c="49245">in place.</st>
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="49142">为工作负载或解决方案在 Azure DevOps 项目中创建一个 Git 仓库，并设置分支策略</st> <st c="49245">。</st>
- en: <st c="49254">Create service connections for these environments using the service
    principals that we have created.</st> <st c="49356">This is what we did in</st>
    [*<st c="49379">Chapter 6</st>*](B22208_06.xhtml#_idTextAnchor103)<st c="49388">.</st>
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="49254">为这些环境创建服务连接，使用我们创建的服务主体。</st> <st c="49356">这正是我们在</st> [*<st
    c="49379">第 6 章</st>*](B22208_06.xhtml#_idTextAnchor103)<st c="49388">中所做的。</st>
- en: <st c="49389">Create CI/CD pipelines that use pipeline templates available in
    a separate, dedicated repository and configure them to use those new service connections</st>
    <st c="49543">as parameters.</st>
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="49389">创建使用位于单独专用库中的管道模板的 CI/CD 管道，并配置它们以使用这些新的服务连接</st> <st c="49543">作为参数。</st>
- en: <st c="49557">In the end, we can achieve the following</st> <st c="49599">project
    setup:</st>
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49557">最终，我们可以实现以下的</st> <st c="49599">项目设置：</st>
- en: '![Figure 7.7 – DevSecOps Power Platform project](img/B22208_07_7.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.7 – DevSecOps Power Platform 项目](img/B22208_07_7.jpg)'
- en: <st c="49942">Figure 7.7 – DevSecOps Power Platform project</st>
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49942">图 7.7 – DevSecOps Power Platform 项目</st>
- en: <st c="49987">We can see</st> <st c="49998">here the</st> `<st c="50320">Owners</st>`
    <st c="50327">and</st> `<st c="50332">Contributors</st>`<st c="50344">) can work
    on the project.</st> <st c="50372">Membership changes are logged into</st> **<st
    c="50407">Azure Log Analytics workspaces</st>** <st c="50437">and</st> <st c="50442">monitored
    by SIEM solutions, such as Microsoft Sentinel (</st><st c="50499">Threat Intelligence).</st>
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49987">我们可以在此看到</st> <st c="49998">这里的</st> `<st c="50320">所有者</st>`
    <st c="50327">和</st> `<st c="50332">贡献者</st>`<st c="50344">) 可以在项目中工作。</st> <st
    c="50372">成员变更被记录到</st> **<st c="50407">Azure Log Analytics 工作区</st>** <st c="50437">并</st>
    <st c="50442">由 SIEM 解决方案监控，如 Microsoft Sentinel（</st><st c="50499">威胁情报</st>）。</st>
- en: <st c="50521">We can automate all the previous steps with the help</st> <st
    c="50574">of</st> **<st c="50578">Azure pipelines</st>** <st c="50593">located
    in a separate Azure DevOps project.</st> <st c="50638">Let us see those steps</st>
    <st c="50661">in detail:</st>
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="50521">我们可以借助</st> <st c="50574">的帮助</st> **<st c="50578">Azure 管道</st>**
    <st c="50593">位于一个单独的 Azure DevOps 项目中。</st> <st c="50638">让我们详细查看这些步骤</st> <st
    c="50661">：</st>
- en: <st c="50671">Create</st> <st c="50679">AAD groups:</st>
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="50671">创建</st> <st c="50679">AAD 组：</st>
- en: <st c="50690">To create an AAD group, we can use the following script (see</st>
    `<st c="50752">create-aad-group.sh</st>` <st c="50771">in the</st> `<st c="50779">Chapter07</st>`
    <st c="50788">folder of the</st> <st c="50803">GitHub repo):</st>
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="50690">要创建 AAD 组，我们可以使用以下脚本（参见</st> `<st c="50752">create-aad-group.sh</st>`
    <st c="50771">在</st> `<st c="50779">第 7 章</st>` <st c="50788">文件夹中的</st> <st c="50803">GitHub
    仓库）：</st>
- en: '[PRE11]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '#!/bin/bash'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '#!/bin/bash'
- en: set -e
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: set -e
- en: Define environment variables
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义环境变量
- en: SERVICE_PRINCIPAL_APP_ID="<your-service-principal-app-id>"
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SERVICE_PRINCIPAL_APP_ID="<your-service-principal-app-id>"
- en: SERVICE_PRINCIPAL_SECRET="<your-service-principal-password>"
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SERVICE_PRINCIPAL_SECRET="<your-service-principal-password>"
- en: TENANT_ID="<your-tenant-id>"
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TENANT_ID="<your-tenant-id>"
- en: ENV_NAME="YOUR_ENV_NAME"
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ENV_NAME="YOUR_ENV_NAME"
- en: REGION="YOUR_REGION"
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: REGION="YOUR_REGION"
- en: CURRENCY="YOUR_CURRENCY"
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CURRENCY="YOUR_CURRENCY"
- en: LANGUAGE="YOUR_LANGUAGE"
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LANGUAGE="YOUR_LANGUAGE"
- en: Login to Power Apps using service principal <st c="52302">pac auth create --applicationId
    $SERVICE_PRINCIPAL_APP_ID --clientSecret $SERVICE_PRINCIPAL_SECRET \</st>
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务主体登录到 Power Apps <st c="52302">pac auth create --applicationId $SERVICE_PRINCIPAL_APP_ID
    --clientSecret $SERVICE_PRINCIPAL_SECRET \</st>
- en: '<st c="52402">--tenant $TENANT_ID</st> # Create a new environment <st c="52450">pac
    admin create --name $ENV_NAME --region $REGION \</st>'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '<st c="52402">--tenant $TENANT_ID</st> # 创建一个新环境 <st c="52450">pac admin create
    --name $ENV_NAME --region $REGION \</st>'
- en: <st c="52502">--currency $CURRENCY --language $LANGUAGE \</st>
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52502">--currency $CURRENCY --language $LANGUAGE \</st>
- en: <st c="52546">--type Production</st>
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52546">--type 生产环境</st>
- en: <st c="52564">rawOutput=$(pac admin list --name $ENV_NAME | tail -n 2)</st>
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52564">rawOutput=$(pac admin list --name $ENV_NAME | tail -n 2)</st>
- en: '<st c="52621">environmentId=$(echo $rawOutput | cut -d '' '' -f 2)</st> #Enable
    Managed Environment <st c="52701">pac admin set-governance-config \</st>'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '<st c="52621">environmentId=$(echo $rawOutput | cut -d '' '' -f 2)</st> #启用托管环境
    <st c="52701">pac admin set-governance-config \</st>'
- en: <st c="52734">--environment $environmentId \</st>
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52734">--environment $environmentId \</st>
- en: <st c="52848">pac admin set-governance-config</st> command to enable managed
    environment features.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52848">pac admin set-governance-config</st> 命令以启用托管环境功能。
- en: '[PRE12]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="52927">Create</st> <st c="52934">service principals</st> <st c="52954">for
    environments:</st>
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="52927">创建</st> <st c="52934">服务主体</st> <st c="52954">用于环境：</st>
- en: <st c="52971">As we did in</st> [*<st c="52985">Chapter 5</st>*](B22208_05.xhtml#_idTextAnchor089)<st
    c="52994">, we can use the following PAC CLI command to create a service principal
    assigned to the newly</st> <st c="53089">created environments:</st>
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="52971">正如我们在</st> [*<st c="52985">第5章</st>*](B22208_05.xhtml#_idTextAnchor089)<st
    c="52994">中所做的，我们可以使用以下PAC CLI命令来创建一个分配给新创建环境的服务主体：</st>
- en: '[PRE13]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="53451">Create an Azure</st> <st c="53468">DevOps project:</st>
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="53451">创建一个Azure</st> <st c="53468">DevOps项目：</st>
- en: <st c="53483">Here, we need to use</st> <st c="53504">a</st> `<st c="54040">System.AccessToken</st>`
    <st c="54058">and we can refer to this token to perform administrative or organization-wide
    actions.</st> <st c="54146">With this approach, we can eliminate the</st> <st
    c="54187">use of personal access tokens and we can grant access rights and privileges
    for the build service account at the collection level.</st> <st c="54318">For
    this, we need to disable the</st> **<st c="54351">Limit job authorization scope
    to current project for non-release pipelines</st>** <st c="54425">and</st> **<st
    c="54430">Limit job authorization scope to current project for release pipelines</st>**
    <st c="54500">options under</st> **<st c="54515">Project Settings</st>** <st c="54531">in
    the pipeline’s</st> **<st c="54550">Settings</st>** <st c="54558">blade in the
    project that will host our management pipelines, as the following</st> <st c="54638">figure
    shows:</st>
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="53483">在这里，我们需要使用</st> <st c="53504">一个</st> `<st c="54040">System.AccessToken</st>`
    <st c="54058">，并且我们可以引用这个令牌来执行管理或全组织范围的操作。</st> <st c="54146">通过这种方式，我们可以消除</st>
    <st c="54187">个人访问令牌的使用，并且我们可以在集合级别为构建服务帐户授予访问权限和特权。</st> <st c="54318">为此，我们需要禁用</st>
    **<st c="54351">将作业授权范围限制为当前项目（针对非发布管道）</st>** <st c="54425">和</st> **<st c="54430">将作业授权范围限制为当前项目（针对发布管道）</st>**
    <st c="54500">选项，位于</st> **<st c="54515">项目设置</st>** <st c="54531">中的</st> **<st
    c="54550">设置</st>** <st c="54558">面板，在将托管我们管理管道的项目中，如下图所示：</st>
- en: '![Figure 7.8 – System.AccessToken: project versus organization scope](img/B22208_07_8.jpg)'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图7.8 – System.AccessToken：项目与组织范围](img/B22208_07_8.jpg)'
- en: '<st c="55598">Figure 7.8 – System.AccessToken: project versus organization
    scope</st>'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="55598">图7.8 – System.AccessToken：项目与组织范围</st>
- en: <st c="55664">If these toggle buttons are disabled, then we need to turn them
    off at the organization level.</st> <st c="55760">Finally, we need to grant permission
    to the</st> `<st c="55966">$(System.AccessToken)</st>` <st c="55987">system variable
    in our pipelines to execute the following script (see</st> `<st c="56058">.pipelines/setup-azure-devops-project.yml</st>`
    <st c="56099">in the</st> `<st c="56107">Chapter07</st>` <st c="56116">folder
    of the</st> <st c="56131">GitHub repo):</st>
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="55664">如果这些切换按钮被禁用，我们需要在组织级别关闭它们。</st> <st c="55760">最后，我们需要在我们的管道中授予权限，使用</st>
    `<st c="55966">$(System.AccessToken)</st>` <st c="55987">系统变量来执行以下脚本（请参见</st>
    `<st c="56058">.pipelines/setup-azure-devops-project.yml</st>` <st c="56099">，位于</st>
    `<st c="56107">Chapter07</st>` <st c="56116">文件夹中的</st> <st c="56131">GitHub仓库）：</st>
- en: '[PRE14]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '# Variables'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '# 变量'
- en: organizationURL="<Your-Azure-DevOps-Organization-URL>"
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: organizationURL="<Your-Azure-DevOps-Organization-URL>"
- en: project="<Your-Azure-DevOps-Project>"
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: project="<Your-Azure-DevOps-Project>"
- en: repository="<Your-New-Repository-Name>"
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: repository="<Your-New-Repository-Name>"
- en: pat="<Your-Personal-Access-Token>"
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: pat="<Your-Personal-Access-Token>"
- en: '<st c="58230">main</st> branch:'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="58230">main</st> 分支：
- en: '[PRE15]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: organizationName=$(basename $organizationURL) <st c="58289">git clone https://$organizationName@dev.azure.com/$organizationName/$project/_git/$repository</st>
    cd $repository <st c="58398">git checkout -b main</st> echo "# $repository" >>
    README.md <st c="58453">git add .</st>
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: organizationName=$(basename $organizationURL) <st c="58289">git clone https://$organizationName@dev.azure.com/$organizationName/$project/_git/$repository</st>
    cd $repository <st c="58398">git checkout -b main</st> echo "# $repository" >>
    README.md <st c="58453">git add .</st>
- en: <st c="58462">git commit -m "Initial commit"</st>
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="58462">git commit -m "初始提交"</st>
- en: '<st c="58573">main</st> branch from direct commits by introducing the check
    for linked work items on pull requests (see <st c="58674">create-gitrepo-and-branch-policy.sh</st>
    in the <st c="58717">Chapter07</st> folder of the GitHub repo):'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="58573">main</st> 分支通过引入对拉取请求中关联工作项的检查，防止直接提交（请参见GitHub仓库中<st c="58674">create-gitrepo-and-branch-policy.sh</st>，位于<st
    c="58717">Chapter07</st>文件夹）：
- en: '[PRE16]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="59553">resources:</st>
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="59553">资源：</st>
- en: <st c="59564">repositories:</st>
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="59564">仓库：</st>
- en: '<st c="59578">- repository: templates</st>'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="59578">- 仓库：templates</st>
- en: '<st c="59602">type: git</st>'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="59602">类型：git</st>
- en: '<st c="59612">name: OtherProject/TemplateRepo</st>'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="59612">名称：OtherProject/TemplateRepo</st>
- en: '<st c="59644">ref: refs/heads/main</st>'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="59644">引用：refs/heads/main</st>
- en: '<st c="59665">endpoint: MyServiceConnection</st> steps: #or stages:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '<st c="59665">端点：MyServiceConnection</st> 步骤： #或阶段：'
- en: '- template: .pipelines\ include-paccli-steps.yml@templates'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 模板：.pipelines\ include-paccli-steps.yml@templates'
- en: <st c="61119">--yml-path</st> option. To create these YAML files, we can use
    the previously discussed Git commands to commit the baseline pipelines that already
    refer to the pipeline templates that are enriched with secret scanning and static
    code analysis.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="61119">--yml-path</st> 选项。要创建这些YAML文件，我们可以使用先前讨论过的Git命令提交基线流水线，这些流水线已经引用了丰富了秘密扫描和静态代码分析的流水线模板。
- en: '[PRE18]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
