- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: Over the last couple of years, containers have become a hot topic. They allow
    you to package any application or any tool, written in any language, and deploy
    it on a basic host or cluster. When implementing DevOps, containers can be of
    tremendous value. That is why DevOps and containers are often mentioned in the
    same breath. However, they are not the same thing. While DevOps is a cultural
    thing, containers are a type of technology, an alternative way of hosting your
    applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，容器已成为热门话题。它们允许您打包任何应用程序或工具，使用任何语言编写，并在基本主机或集群上部署。在实施 DevOps 时，容器可以提供巨大的价值。这就是为什么
    DevOps 和容器经常被同时提及的原因。然而，它们并不是同一回事。虽然 DevOps 是一种文化，但容器是一种技术，是一种托管应用程序的替代方式。
- en: In this chapter, you will learn more about containers and how they work. This
    is achieved by exercises wherein custom container images are created and run on
    different hosting platforms, such as Azure Container Instances and Kubernetes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习有关容器及其工作原理的更多信息。通过练习，可以创建自定义容器镜像，并在不同的托管平台上运行，例如 Azure 容器实例和 Kubernetes。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器简介
- en: Building a container image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: Building images in Azure DevOps and running them in Azure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中构建镜像并在 Azure 中运行
- en: An introduction to Kubernetes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 简介
- en: Kubernetes in action
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 实践
- en: Upgrading containers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级容器
- en: Scaling containers and Kubernetes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展容器和 Kubernetes
- en: Deploying to Kubernetes with Azure DevOps
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure DevOps 部署到 Kubernetes
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To experiment with the techniques described in this chapter, you need one or
    more of the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试本章描述的技术，您需要以下一项或多项：
- en: Docker Desktop
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: Visual Studio 2019/Visual Studio Code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019/Visual Studio Code
- en: An Azure subscription
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 订阅
- en: The Azure CLI
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 命令行界面（CLI）
- en: All these are available for free or can be obtained for a limited period for
    free for evaluation purposes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以免费获取，或者可以免费获取一段时间用于评估。
- en: An introduction to containers
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器简介
- en: Containers are the evolution of virtualization. With virtualization, the resources
    of physical machines are shared among several virtual machines. Sharing those
    resources also means that all virtual machines have their own operating system.
    This is different when using containers. With containers, not only are the resources
    shared but also the operating system kernel, making it very small in comparison
    with a virtual machine image.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是虚拟化的进化。通过虚拟化，物理机的资源被多个虚拟机共享。共享这些资源意味着所有虚拟机都有自己的操作系统。但是使用容器时情况有所不同。容器不仅共享资源，还共享操作系统内核，因此与虚拟机镜像相比，它非常小。
- en: Since the operating system kernel is shared, containers are also very portable.
    Images can be deployed on any type of host environment that supports running containers.
    This works because all the application’s binaries and configurations are stored
    inside the container. As a result, environment variables outside the container
    do not impact the application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于共享操作系统内核，容器也非常易于移植。镜像可以部署在支持运行容器的任何类型的主机环境上。这是因为所有应用程序的二进制文件和配置都存储在容器内部。因此，容器外部的环境变量不会影响应用程序。
- en: Naturally, there are a number of caveats, however – a container shares the operating
    system kernel.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有一些注意事项，例如容器共享操作系统内核。
- en: 'Containers provide the ability to virtualize an operating system in order to
    run multiple workloads on a single operating system. This is visualized in the
    following diagram, where you can see the difference between regular hosting, virtual
    machine hosting, and containers:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 容器提供了在单个操作系统上运行多个工作负载的能力。下图展示了常规托管、虚拟机托管和容器之间的区别：
- en: '![Figure 16.1 – Virtualization to containers ](img/B18655_16_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.1 – 从虚拟化到容器](img/B18655_16_01.jpg)'
- en: Figure 16.1 – Virtualization to containers
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.1 – 从虚拟化到容器
- en: If you have ever heard of containers, you almost certainly have also heard of
    Docker. This is because Docker is one of the most well-known container engines
    that can be used for running containers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您听说过容器，几乎肯定也听说过 Docker。这是因为 Docker 是最知名的容器引擎之一，可用于运行容器。
- en: The next section will delve into DevOps and containers, while the remainder
    of the chapter will go into more technical detail regarding containers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将深入探讨 DevOps 和容器，而本章的其余部分将更详细地介绍容器的技术细节。
- en: DevOps and containers
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DevOps 和容器
- en: 'As mentioned in the introduction, DevOps and containers are not the same thing.
    Containers are the technology that makes DevOps easier. This is because containers
    have benefits that make them *the* perfect tool for DevOps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如在介绍中所提到的，DevOps 和容器并不是同一回事。容器是让 DevOps 变得更容易的技术。这是因为容器具有使其成为 DevOps 完美工具的优势：
- en: '**Consistent**: Because you build the container images, the hurdle of “*it
    works on my machine”* is eliminated.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：因为您构建了容器镜像，"*它在我的机器上可以工作*"这一障碍被消除了。'
- en: '**Separation of concerns**: When using containers, your application will be
    distributed between separate containers, which makes it easier to maintain and
    separate the processes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：使用容器时，您的应用程序将被分布在多个独立的容器中，这使得维护和分离进程变得更加容易。'
- en: '**Platform**: The solution can be run on different platforms. It does not matter
    whether this is in Microsoft Azure, on Amazon Web Services, on Google Cloud, or
    in an on-premises environment, including even on your development machine.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台**：该解决方案可以在不同的平台上运行。无论是在 Microsoft Azure、Amazon Web Services、Google Cloud，还是本地环境中，包括甚至是您的开发机器上，都不重要。'
- en: That aside, DevOps is more cultural than technical and, as mentioned in [*Chapter
    1*](B18655_01.xhtml#_idTextAnchor014), *Introduction to DevOps*, technical components
    are used to support DevOps. In the remainder of this chapter, we will focus on
    the technical side of things.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，DevOps 更偏向文化而非技术，正如在[*第1章*](B18655_01.xhtml#_idTextAnchor014)《DevOps 简介》中提到的那样，技术组件用于支持
    DevOps。在本章的其余部分，我们将关注技术层面的内容。
- en: Hosting options
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托管选项
- en: As mentioned previously, one of the benefits of containers is that they are
    extremely portable. This also means that containers can be hosted on numerous
    platforms and technologies.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，容器的一个好处是它们具有极强的可移植性。这也意味着容器可以托管在多种平台和技术上。
- en: 'To run the containers, there are a lot of options that will vary according
    to your use case. Some of these options are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行容器，您有许多选项，这些选项将根据您的使用场景有所不同。以下是其中一些选项：
- en: Azure App Service
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 应用服务
- en: Azure Service Fabric
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 服务网格
- en: Docker Swarm
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Docker Desktop
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: Kubernetes
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Depending on the demands of the application/container, it could run on all the
    options mentioned in the preceding list.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据应用程序/容器的需求，它可以在前面提到的所有选项中运行。
- en: The images used to run containers (container images) also need to be hosted.
    These images are hosted in a so-called container registry. In a container registry,
    they are published privately or publicly. The two most well-known registries are
    Docker Registry and Azure Container Registry within the Azure platform.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 用于运行容器的镜像（容器镜像）也需要托管。这些镜像托管在所谓的容器注册表中。在容器注册表中，它们可以是私有发布或公开发布的。最著名的两个注册表是 Docker
    Registry 和 Azure 平台中的 Azure Container Registry。
- en: Now that we have gone through some of the background information regarding containers,
    we are ready to go more deeply into the techniques behind containers and find
    out what is needed to create a custom container image.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了一些有关容器的背景信息，接下来我们将深入探讨容器背后的技术，了解创建自定义容器镜像所需的内容。
- en: Building a container image
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: This section will take you through the process of building a container image
    and executing it on your local system. To do this, we will first have to create
    an application and then add Docker support to it before we create an image and
    finally test it. So, let’s begin!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将带您了解构建容器镜像并在本地系统上执行它的过程。为此，我们将首先创建一个应用程序，然后为其添加 Docker 支持，接着创建镜像并最终进行测试。那么，开始吧！
- en: Creating an application
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序
- en: To be able to test and check what is running on the container, an application
    is required. For this, a new application can be created, or you can use an existing
    application.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试和检查容器中正在运行的内容，需要一个应用程序。为此，可以创建一个新的应用程序，也可以使用现有的应用程序。
- en: 'When creating a new application, the easiest option is to use the default ASP.NET
    Core website template within Visual Studio 2019\. Container support can be added
    in a few clicks. This is simply done by checking the **Enable Docker** box when
    creating the project:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建一个新的应用程序时，最简单的选择是在 Visual Studio 2019 中使用默认的 ASP.NET Core 网站模板。容器支持可以通过几个点击轻松添加。只需在创建项目时勾选**启用
    Docker**框即可：
- en: '![Figure 16.2 – An ASP.Net Core new application with Docker support ](img/B18655_16_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.2 – 带有 Docker 支持的 ASP.Net Core 新应用程序](img/B18655_16_02.jpg)'
- en: Figure 16.2 – An ASP.Net Core new application with Docker support
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.2 – 带有 Docker 支持的 ASP.Net Core 新应用程序
- en: Keep the new application open or open your existing application. In the next
    section, we will investigate how Docker support can be added to an existing application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 保持新应用程序打开，或者打开现有的应用程序。在下一部分，我们将探讨如何向现有应用程序添加 Docker 支持。
- en: Adding Docker support to an existing application
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向现有应用程序添加 Docker 支持
- en: 'Adding Docker support to an existing application requires a couple of simple
    steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 向现有应用程序添加 Docker 支持只需要几个简单步骤：
- en: Open the project/solution in Visual Studio 2019 and right-click on the project.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2019 中打开项目/解决方案，并右键单击项目。
- en: 'Choose **Add** and select **Docker Support**:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**添加**并选择**Docker 支持**：
- en: '![Figure 16.3 – An ASP.Net Core existing application with Docker support ](img/B18655_16_03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.3 – 带有 Docker 支持的 ASP.Net Core 现有应用程序](img/B18655_16_03.jpg)'
- en: Figure 16.3 – An ASP.Net Core existing application with Docker support
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.3 – 带有 Docker 支持的 ASP.Net Core 现有应用程序
- en: 'Depending on your client tools and Visual Studio configuration, there may also
    be a **Container Orchestrator Support** option. With this option, the cloud orchestrator
    of your choice can be chosen. In this sample, we used Docker Compose because this
    format is supported by the major container orchestrators. Other cloud orchestrator
    options do exist, however:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据客户端工具和 Visual Studio 配置，也可能会有一个**容器编排器支持**选项。通过此选项，可以选择您选择的云编排器。在此示例中，我们使用了
    Docker Compose，因为这种格式得到了主要容器编排器的支持。然而，确实存在其他云编排器选项：
- en: Docker Swarm
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Kubernetes
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Mesos Marathon
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos Marathon
- en: Depending on the cloud orchestrator used, a file is added to the project in
    the specific format for that orchestrator.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据使用的云编排器，项目中会添加一个特定格式的文件，适用于该编排器。
- en: 'By adding Docker support, a new file is added to the project named `Dockerfile`.
    The Dockerfile is the specification of a container image. This file can be read
    by Docker, which sees it as instructions. The file is a text document that contains
    separate commands that can also be called within a command-line tool to assemble
    an image:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 Docker 支持，项目中会添加一个名为 `Dockerfile` 的新文件。Dockerfile 是容器镜像的规范。Docker 可以读取该文件，将其视为指令。该文件是一个文本文件，包含单独的命令，这些命令也可以在命令行工具中调用以组装镜像：
- en: '[PRE0]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The example uses a technique called a multi-stage build file. This is because
    the file uses multiple `FROM` statements where there is a reference to a specific
    image.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了一种称为多阶段构建文件的技术。这是因为该文件使用了多个`FROM`语句，其中有对特定镜像的引用。
- en: Prior to the multi-stage build, it wasn’t possible to use multiple `FROM` statements.
    During this time, it was hard to build efficient container images. Each statement
    in the file represented an additional layer on the image that resulted in it becoming
    larger and larger.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在多阶段构建之前，无法使用多个 `FROM` 语句。在那时，构建高效的容器镜像是非常困难的。文件中的每个语句代表镜像上的一个附加层，导致镜像变得越来越大。
- en: During this build process, it was also necessary to remove any components that
    were required during this process. For this reason, it was very common to have
    separate Dockerfiles for development and production.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在此构建过程中，还需要移除一些在该过程中需要的组件。因此，在开发和生产环境中使用单独的 Dockerfile 文件是非常常见的做法。
- en: 'As mentioned, the Dockerfile comprises instructions and the most commonly used
    instructions are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Dockerfile 包含了一些指令，最常用的指令如下：
- en: '`FROM` command is used to specify on which operating system or base image the
    image will be based. In the preceding example, the `mcr.microsoft.com/dotnet/aspnet:3.1
    AS` base image is used to build the production version of the application.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM` 命令用于指定镜像将基于哪个操作系统或基础镜像。在前面的示例中，使用 `mcr.microsoft.com/dotnet/aspnet:3.1
    AS` 基础镜像来构建应用程序的生产版本。'
- en: '`RUN` command is used to install components or perform operations during the
    build process of the container image.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN` 命令用于在容器镜像的构建过程中安装组件或执行操作。'
- en: '`ENTRYPOINT` command specifies what the entry point for a container image needs
    to be. In the preceding example, the entry point is specified as a .NET application
    that references the library that was built during the compilation process.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 命令指定容器镜像的入口点。在前面的示例中，入口点指定为一个 .NET 应用程序，该应用程序引用了在编译过程中构建的库。'
- en: So far, we’ve created our application and added Docker support. Next, we’ll
    see how to create an image with the application.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了应用程序并添加了 Docker 支持。接下来，我们将学习如何使用该应用程序创建镜像。
- en: Creating an image with the application
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用应用程序创建镜像
- en: 'To be able to create a Docker image, Docker Desktop needs to be installed,
    as Visual Studio uses this to construct the image. With a complete Dockerfile,
    the image can be built using the following steps:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够创建 Docker 镜像，必须安装 Docker Desktop，因为 Visual Studio 使用它来构建镜像。完成 Dockerfile
    后，可以使用以下步骤构建镜像：
- en: 'Right-click the Dockerfile in Visual Studio and select **Build Docker Image**:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中右击 Dockerfile 并选择**构建 Docker 镜像**：
- en: '![Figure 16.4 – An Asp.Net Core application build Docker Image ](img/B18655_16_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.4 – 一个 Asp.Net Core 应用程序构建的 Docker 镜像](img/B18655_16_04.jpg)'
- en: Figure 16.4 – An Asp.Net Core application build Docker Image
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.4 – 一个 Asp.Net Core 应用程序构建的 Docker 镜像
- en: During the compilation and building of the image, take a look at the output
    window. Looking at it will provide more insights into the layered approach of
    container images.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译和构建镜像时，查看输出窗口。查看它将为你提供有关容器镜像分层方法的更多见解。
- en: 'Docker Desktop also makes it possible to run and store images locally. After
    building the image, open a terminal and run the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop 还可以让你在本地运行和存储镜像。构建镜像后，打开终端并运行以下命令：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The command displays all images currently on the machine. In this list, the
    base images that are downloaded during the creation of images are also listed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令显示机器上当前所有的镜像。在此列表中，也列出了在创建镜像时下载的基础镜像：
- en: '![Figure 16.5 – A Docker image list ](img/B18655_16_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.5 – Docker 镜像列表](img/B18655_16_05.jpg)'
- en: Figure 16.5 – A Docker image list
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.5 – Docker 镜像列表
- en: We looked at how to add Docker support and make Docker images for current and
    new ASP.NET Core apps. The next part will explore how to run container images.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过如何添加 Docker 支持并为现有和新的 ASP.NET Core 应用程序制作 Docker 镜像。接下来的部分将探讨如何运行容器镜像。
- en: Running the container image
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行容器镜像
- en: 'The container image can be started locally by running it within Docker. As
    we now have a container image, a container can be created:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像可以通过在 Docker 中运行来本地启动。现在我们有了容器镜像，可以创建一个容器：
- en: 'Run the following `docker container run` command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下 `docker container run` 命令：
- en: '[PRE2]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding command will start the container image specified at the end of
    the command. In addition, different arguments are specified:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令将在命令末尾指定的容器镜像启动。此外，还指定了不同的参数：
- en: '`publish` argument opens a port from the host to the container. As mentioned
    in the example in the preceding section, this will open port `8123` and route
    traffic to port `80` within the container.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publish` 参数从主机打开一个端口到容器。如前一部分中的示例所述，这将打开端口 `8123` 并将流量路由到容器内的端口 `80`。'
- en: '`detach` argument will run the container in the background and print out its
    specific ID.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detach` 参数将使容器在后台运行，并打印出其特定的 ID。'
- en: '**Name**: The name for the container within Docker.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Name**: 容器在 Docker 中的名称。'
- en: To list all running containers, use the **docker ps** command within the terminal.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出所有正在运行的容器，请在终端中使用**docker ps**命令。
- en: 'With the container running, open a browser and navigate to `http://localhost:8123`.
    If everything works fine, this should show a default ASP.NET Core web page:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器运行后，打开浏览器并访问 `http://localhost:8123`。如果一切正常，应该会显示一个默认的 ASP.NET Core 网页：
- en: '![Figure 16.6 – The ASP.Net Core default welcome page ](img/B18655_16_06.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.6 – ASP.Net Core 默认欢迎页面](img/B18655_16_06.jpg)'
- en: Figure 16.6 – The ASP.Net Core default welcome page
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.6 – ASP.Net Core 默认欢迎页面
- en: Since building stuff locally and running it on your machine is not really the
    DevOps way of doing things, we will move to a different hosting platform in the
    upcoming sections.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在本地构建东西并在你的机器上运行并不是 DevOps 的做法，接下来的章节中我们将转向不同的托管平台。
- en: "Building images in Azure DevOps and running them \Lin Azure"
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中构建镜像并在 Azure 中运行
- en: 'To support continuous integration and continuous delivery, the source files
    need to be shared in a repository. So, let’s share the resources in Azure Repos
    and try to build our container by using Azure Pipelines. After building the container
    image, a place to store the images and run the container is also required. Within
    the Azure platform, there are two perfect services for this scenario:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持持续集成和持续交付，源文件需要在一个仓库中共享。因此，让我们在 Azure Repos 中共享资源，并尝试通过 Azure Pipelines
    构建我们的容器。在构建容器镜像之后，还需要一个存储镜像和运行容器的位置。在 Azure 平台上，有两个非常适合这种场景的服务：
- en: '**Azure Container Registry** (**ACR**): This service is a managed private Docker
    registry based on the open source Docker Registry. Here, you can maintain and
    register container images.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 容器注册表** (**ACR**)：该服务是基于开源 Docker 注册表的托管私有 Docker 注册表。在这里，您可以维护和注册容器镜像。'
- en: '**Azure Container Instance**: **Azure Container Instances**, also referred
    to as **ACI**, is a solution for running isolated containers without a lot of
    management.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 容器实例**：**Azure 容器实例**，也称为 **ACI**，是一种运行隔离容器的解决方案，无需大量管理。'
- en: Important Note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For the simplicity of this guide, the files are already added to the repository
    and the Azure resource is already created.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化本指南，文件已被添加到仓库中，Azure 资源也已创建。
- en: In the next section, we will explore how to create images in ACR and run them
    in ACI through Azure DevOps.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分中，我们将探索如何在 ACR 中创建镜像并通过 Azure DevOps 在 ACI 中运行它们。
- en: Creating a service endpoint
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建服务端点
- en: As already discussed within the book, connections within Azure DevOps with external
    services such as Azure and container registries are configured within a service
    endpoint. Because an image needs to be available in order for ACI to retrieve
    it, it needs to be published to a container registry. The connection from Azure
    DevOps to the registry is configured within a service connection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书中已讨论的，Azure DevOps 与外部服务（如 Azure 和容器注册表）的连接是通过服务端点配置的。由于 ACI 需要访问镜像，因此必须将镜像发布到容器注册表。Azure
    DevOps 到注册表的连接是通过服务连接进行配置的。
- en: 'Perform the following steps to configure the service connection:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来配置服务连接：
- en: In the Azure DevOps project, open the project settings.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 项目中，打开项目设置。
- en: Within the project settings, click on **Service connections**.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目设置中，点击 **服务连接**。
- en: In the service connection overview, click on **Create service connection** and
    choose **Docker Registry**.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务连接概述中，点击 **创建服务连接** 并选择 **Docker 注册表**。
- en: 'In the fly-out that appears, fill in the correct information and save the connection:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的菜单中，填写正确的信息并保存连接：
- en: '![Figure 16.7 – A new Azure Container Registry service connection ](img/B18655_16_07.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.7 – 新的 Azure 容器注册表服务连接](img/B18655_16_07.jpg)'
- en: Figure 16.7 – A new Azure Container Registry service connection
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.7 – 新的 Azure 容器注册表服务连接
- en: Saving the connection will add a service connection to the project that can
    be used by the pipelines we will create, or that you will create in the future.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 保存连接将为项目添加一个服务连接，管道可以使用该连接，或者您将来创建的管道也可以使用它。
- en: Creating a new pipeline
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新管道
- en: To be able to start building the container image and publish it to the registry,
    we will create a new pipeline. For this example, we will make use of the YAML
    pipeline experience.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始构建容器镜像并将其发布到注册表，我们将创建一个新的管道。在这个例子中，我们将使用 YAML 管道体验。
- en: 'Perform the following steps to get started with the pipeline:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以开始使用管道：
- en: Open your Azure DevOps project and click on **Pipelines**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您的 Azure DevOps 项目并点击 **Pipelines**。
- en: In the pipelines overview, click on **New Pipeline**.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在管道概述中，点击 **新建管道**。
- en: 'Select **Azure Repos Git**, choose the correct repository, and then choose
    **Starter pipeline**:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **Azure Repos Git**，选择正确的仓库，然后选择 **Starter pipeline**：
- en: '![Figure 16.8 – Azure DevOps – configuring a new pipeline ](img/B18655_16_08.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.8 – Azure DevOps – 配置新管道](img/B18655_16_08.jpg)'
- en: Figure 16.8 – Azure DevOps – configuring a new pipeline
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.8 – Azure DevOps – 配置新管道
- en: From the starter pipeline, remove the two dummy script tasks and open the assistant.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从启动管道中，删除两个虚拟脚本任务并打开助手。
- en: In the assistant, search for the Docker tasks and add the tasks to the pipeline.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在助手中，搜索 Docker 任务并将任务添加到管道中。
- en: Choose the service connection created for the container registry and keep the
    other information as the default.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择为容器注册表创建的服务连接，并保持其他信息为默认值。
- en: Important Note
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Make sure to change the `buildContext` property of the tasks to point to the
    correct directory. This is required for Docker to be able to reference the correct
    paths when building your image.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保将任务的`buildContext`属性更改为指向正确的目录。这是Docker能够引用正确路径构建镜像所必需的。
- en: 'When added, the YAML should look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 添加后，YAML应如下所示：
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save and run the pipeline. After the first run, the container image is created
    and published to the container registry.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行管道。在第一次运行后，容器镜像被创建并发布到容器注册表。
- en: 'The images in the container registry can be retrieved by using a predefined
    URL. This URL comprises a few specific components:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 容器注册表中的镜像可以通过使用预定义的URL进行检索。该URL由几个特定的组件组成：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Container registry**: The base URL of the container registry.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器注册表**：容器注册表的基础URL。'
- en: '**Repository**: The repository as specified during the process of publishing
    the image.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**：在发布镜像过程中指定的仓库。'
- en: '`BuildId`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BuildId`。'
- en: 'Now that we have a reference to the container image, ACI should be able to
    retrieve the container and run it. The only thing needed for this is an Azure
    CLI command:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经获得了容器镜像的引用，ACI应该能够检索容器并运行它。所需的唯一操作是一个Azure CLI命令：
- en: '[PRE5]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since the reference to the image is different for each build (`BuildId` for
    the tag value), `BuildId` is retrieved in the Azure CLI command via the `$(Build.BuildId)`
    variable:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个构建的图像引用不同（对于标签值是`BuildId`），因此通过Azure CLI命令中的`$(Build.BuildId)`变量获取`BuildId`：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To execute the preceding script, the Azure CLI task is added to the pipeline.
    In this task, we configure the correct subscription via the service endpoint and
    set the inline script.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行上述脚本，需要将Azure CLI任务添加到管道中。在此任务中，我们通过服务端点配置正确的订阅，并设置内联脚本。
- en: The script will create a container instance in the `aci-rg-devops` resource
    group with the name `aci-demo-app` and retrieve the `azuredevops` container image
    from the `msftazuredevops.azurecr.io` repository.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将在`aci-rg-devops`资源组中创建一个名为`aci-demo-app`的容器实例，并从`msftazuredevops.azurecr.io`仓库中检索`azuredevops`容器镜像。
- en: 'The complete YAML for this task looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该任务的完整YAML配置如下：
- en: '[PRE7]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running this pipeline will result in an Azure container instance in Azure.
    That container will be running the exact same application that was running locally:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此管道将在Azure中生成一个Azure容器实例。该容器将运行与本地运行的完全相同的应用程序：
- en: '![Figure 16.9 – An aci-demo-app instance running in ACI ](img/B18655_16_09.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图16.9 – 一个运行在ACI中的aci-demo-app实例](img/B18655_16_09.jpg)'
- en: Figure 16.9 – An aci-demo-app instance running in ACI
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9 – 一个运行在ACI中的aci-demo-app实例
- en: 'When opening the Azure container instance in the Azure portal, you will see
    that it is a running instance and that there is a `dns-name-label`, within the
    Azure CLI command, `aci-msft- demo.westeurope.azurecontainer.io`. Open the URL
    in your browser and see the application we have pushed to the container:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure门户中打开Azure容器实例时，您会看到它是一个正在运行的实例，并且在Azure CLI命令中会看到`dns-name-label`，例如`aci-msft-demo.westeurope.azurecontainer.io`。在浏览器中打开该URL，查看我们已经推送到容器中的应用程序：
- en: '![Figure 16.10 – The aci-demo-app welcome page ](img/B18655_16_10.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图16.10 – aci-demo-app欢迎页面](img/B18655_16_10.jpg)'
- en: Figure 16.10 – The aci-demo-app welcome page
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10 – aci-demo-app欢迎页面
- en: It shows the same content as the container that was started locally. This is
    because, in both places, the same container image was started.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示的内容与本地启动的容器相同。这是因为，在两个地方都启动了相同的容器镜像。
- en: In this section, we started the container on ACI, but how will we manage running
    containers and restart them when there are problems? This is where Kubernetes
    comes in.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们启动了ACI上的容器，但当容器出现问题时，我们如何管理正在运行的容器并重新启动它们呢？这就是Kubernetes的作用。
- en: An introduction to Kubernetes
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes简介
- en: Kubernetes is another service for running your containers. Kubernetes is a cluster
    orchestration technology first developed by Google. It is now an open source platform
    for automating deployment, scaling, and operations of application containers across
    clusters of hosts, thereby providing a container-centric infrastructure. The term
    Kubernetes is often abbreviated as *K8s*. This is generated by substituting the
    eight letters of *ubernete* in the word with the numeral 8.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes是另一个用于运行容器的服务。Kubernetes是由Google最早开发的集群编排技术。它现在是一个开源平台，用于自动化部署、扩展和操作跨主机集群的应用程序容器，从而提供面向容器的基础设施。术语Kubernetes通常缩写为*K8s*。这是通过将单词*ubernete*中的八个字母替换为数字8生成的。
- en: The functionalities of Kubernetes
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes的功能
- en: 'As mentioned earlier, containers offer you a great way to package your applications.
    When running the applications, you need to make sure that applications keep running
    and this is where Kubernetes comes in, as it has the following core functionalities:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，容器为你提供了一个打包应用程序的好方法。在运行这些应用程序时，你需要确保应用程序保持运行，这就是 Kubernetes 发挥作用的地方，因为它具有以下核心功能：
- en: '**Service discovery and load balancing**: How a container is exposed is controlled
    within Kubernetes and, in addition, it is also capable of balancing the traffic
    within the orchestration.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现和负载均衡**：容器的暴露方式由 Kubernetes 内部控制，此外，它还能够在调度中平衡流量。'
- en: '**Storage orchestration**: The ability to mount different kinds of storage
    providers to the platform.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储编排**：将不同种类的存储提供商挂载到平台的能力。'
- en: '**Rollouts and rollbacks**: Kubernetes can automatically create and restart
    containers for the specified deployment.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布和回滚**：Kubernetes 可以自动为指定的部署创建并重启容器。'
- en: '**Self-healing**: Kubernetes can heal containers when they are failing.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我修复**：当容器发生故障时，Kubernetes 可以修复容器。'
- en: '**Secret and configuration management**: Kubernetes has a built-in functionality
    to manage secrets such as tokens, passwords, and keys.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秘密和配置管理**：Kubernetes 内置了管理秘密（如令牌、密码和密钥）的功能。'
- en: In order to provide these functionalities, Kubernetes consists of a number of
    components.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这些功能，Kubernetes 由多个组件组成。
- en: Kubernetes core components and services
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 核心组件和服务
- en: Kubernetes consists of a few core components that make it run. These components
    together make a great and stable product for running and managing containers.
    The next few subsections will go over each of these components individually.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 由几个核心组件组成，这些组件共同构成一个出色且稳定的容器运行与管理产品。接下来的几个子部分将逐一介绍这些组件。
- en: Master node
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主节点
- en: 'One of the important components within Kubernetes is the master node. The node
    manages the cluster. It contains all the Kubernetes core components in order to
    manage the cluster:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的一个重要组件是主节点。该节点管理集群。它包含所有的 Kubernetes 核心组件，以便管理集群：
- en: '`kubectl`, and the Kubernetes dashboard.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl` 和 Kubernetes 仪表盘。'
- en: '**etcd**: Used to maintain the state of the Kubernetes cluster.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd**：用于维护 Kubernetes 集群的状态。'
- en: '**kube-scheduler**: A component that selects nodes for the Pods to run on.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-scheduler**：一个选择节点以便 Pods 运行的组件。'
- en: '**kube-controller-manager**: The controller manager oversees a number of smaller
    controllers that perform actions such as replicating Pods and managing node operations.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-controller-manager**：控制器管理器负责监督多个小型控制器，执行如复制 Pods 和管理节点操作等任务。'
- en: By using these components, the master node can maintain the desired state for
    the cluster. It is good to know that when you are interacting with Kubernetes,
    you are communicating with the master node. The master node will then communicate
    with the other components within the cluster.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些组件，主节点可以保持集群所需的状态。需要知道的是，当你与 Kubernetes 交互时，实际上是在与主节点进行通信。然后，主节点会与集群内的其他组件进行通信。
- en: Regular nodes
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 普通节点
- en: These are the nodes that will run the containers. Sometimes, they are referred
    to as worker nodes. They can be virtual machines or even physical machines. On
    these machines, the so-called `kubelet` is installed. `kubelet` is the agent that’s
    used to run Pods/containers within the nodes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是将运行容器的节点。有时它们被称为工作节点。它们可以是虚拟机，甚至是物理机器。在这些机器上，安装了所谓的 `kubelet`。`kubelet` 是用于在节点内运行
    Pods/容器的代理。
- en: As you may have noticed in the preceding sections, there are also other core
    services within Kubernetes, and we will discuss them next.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的章节中所注意到的，Kubernetes 中还有其他核心服务，我们接下来将讨论它们。
- en: Pod
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod
- en: Within Kubernetes, Pods are used to run the applications. Within the Pods, it
    is specified which resources are required to run the application. The scheduler
    (`kube-schedular`) within Kubernetes checks where to run the application, depending
    on the demands and the nodes coupled to the cluster.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，Pods 用于运行应用程序。在 Pods 内部，指定了运行应用程序所需的资源。Kubernetes 中的调度器（`kube-scheduler`）会根据需求和与集群连接的节点来决定应用程序的运行位置。
- en: Pods have a limited lifespan and are removed when new versions are deployed.
    Also, when a node fails, Pods can be replaced by other Pods on the same or another
    node.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Pods 有有限的生命周期，在新版本部署时会被移除。此外，当节点发生故障时，Pods 可以由同一节点或另一节点上的 Pods 替代。
- en: Service
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: The service is sometimes referred to as the load balancer and is used to provide
    a logical grouping of Pods and furnish them with connectivity (a way to connect).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务有时也被称为负载均衡器，用于提供 Pods 的逻辑分组，并为它们提供连接性（连接的方式）。
- en: 'The three major services are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 三个主要服务如下：
- en: '![Figure 16.11 – The K8s services relationship ](img/B18655_16_11.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.11 – K8s 服务关系图](img/B18655_16_11.jpg)'
- en: Figure 16.11 – The K8s services relationship
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.11 – K8s 服务关系图
- en: 'The three major services are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 三个主要服务如下：
- en: '**Cluster IP**: Adding an internal IP to a service. By selecting this option,
    the service is only accessible from within the cluster. This is the standard service
    type.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集群 IP**：为服务添加一个内部 IP。选择此选项时，服务只能从集群内部访问。这是标准的服务类型。'
- en: '**Node port**: The node port service establishes a port on each cluster node,
    hence the name, and routes traffic arriving on that port to the underlying service.
    It exposes services to external clients.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点端口**：节点端口服务在每个集群节点上建立一个端口，因此得名，并将到达该端口的流量路由到底层服务。它将服务暴露给外部客户端。'
- en: '**Load balancer**: This service adds a load balancer resource and configures
    an external IP address on the load balancer. On the external side, the load balancer
    will route traffic to the specific nodes based on the rules configured in the
    load balancer and internally to the correct Pod.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载均衡器**：此服务添加一个负载均衡资源，并在负载均衡器上配置一个外部 IP 地址。在外部，负载均衡器将根据负载均衡器中配置的规则将流量路由到特定节点，并在内部路由到正确的
    Pod。'
- en: With these services, the internal and external connections for Pods are arranged.
    The services and Pods are all specified within a deployment.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些服务，Pods 的内部和外部连接得以安排。服务和 Pods 都在一个部署中被指定。
- en: Deployment
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署
- en: A Kubernetes deployment is a resource object that outlines an application’s
    expected state. It specifies the number of replicas as well as the update strategy
    for that application. Kubernetes will monitor the health of the Pods and will
    remove or add Pods as needed to reach the desired state specified in the deployment.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 部署是一个资源对象，概述了应用程序的预期状态。它指定副本数量以及应用程序的更新策略。Kubernetes 会监控 Pods 的健康状况，并根据需要删除或添加
    Pods，以达到部署中指定的期望状态。
- en: These deployments are specified in a YAML file. For example, when running a
    container in Kubernetes, you must specify a replica set. A replica set ensures
    that a specified number of Pod replicas are running at any given time.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部署在 YAML 文件中被指定。例如，在 Kubernetes 中运行容器时，必须指定副本集。副本集确保在任何给定时刻运行指定数量的 Pod 副本。
- en: Operation of Kubernetes
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 操作
- en: 'When you are new to containers, and especially to Kubernetes, it is hard to
    figure things out immediately. However, to aid your understanding of the concept,
    take a look at the following diagram:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚接触容器，尤其是 Kubernetes 时，很难立即弄清楚。为了帮助你理解这个概念，看看下面的图示：
- en: '![Figure 16.12 – An overview of Kubernetes operations ](img/B18655_16_12.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.12 – Kubernetes 操作概览](img/B18655_16_12.jpg)'
- en: Figure 16.12 – An overview of Kubernetes operations
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.12 – Kubernetes 操作概览
- en: Deployments of containers to a Kubernetes cluster are defined in the so-called
    deployment file (**1**). In these deployment files, the desired state of the application
    is described. This desired state is described as a YAML file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将容器部署到 Kubernetes 集群中是通过所谓的部署文件 (**1**) 来定义的。在这些部署文件中，应用程序的期望状态被描述。这个期望状态被描述为一个
    YAML 文件。
- en: In this example, the desired state is a load balancer service and three Pods
    (**2**). These Pods are divided by the Kubernetes API on the nodes that run the
    containers (**3**). The service defined in the deployment file ensures that the
    traffic is routed to the specific Pods. The deployment can be changed by updating
    it.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，期望的状态是一个负载均衡服务和三个 Pods (**2**)。这些 Pods 由 Kubernetes API 在运行容器的节点上划分 (**3**)。部署文件中定义的服务确保流量被路由到特定的
    Pods。通过更新部署，可以更改部署。
- en: The scheduler can also change deployments when, for example, automatic scaling
    is configured for the application. In that kind of scenario, a fourth Pod could
    be added to the cluster. In the service, there can also be an external load balancer
    to route traffic to the internal load balancer of Kubernetes (**4**).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器也可以在配置了应用程序的自动扩展时更改部署。在这种情况下，可以向集群中添加第四个 Pod。在服务中，也可以有一个外部负载均衡器，将流量路由到 Kubernetes
    的内部负载均衡器 (**4**)。
- en: Azure Kubernetes Service
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Kubernetes 服务
- en: '**Azure Kubernetes Service**, or **AKS**, is the Microsoft implementation of
    Kubernetes. Setting up a regular Kubernetes cluster is a lot of work, but with
    AKS, it has been made easier. This is because AKS is a managed platform and the
    reason why almost all operational tasks are handled by the platform itself.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Kubernetes 服务**（**AKS**）是微软实现的 Kubernetes。设置常规 Kubernetes 集群需要很多工作，但使用
    AKS 后，操作变得更加简便。这是因为 AKS 是一个托管平台，几乎所有操作任务都由平台本身处理。'
- en: 'Some key functionalities of AKS are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: AKS 的一些关键功能如下：
- en: Azure manages critical tasks, such as health monitoring, scaling, and maintenance,
    including Kubernetes version upgrades and patching according to configuration
    and management requirements.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 管理关键任务，如健康监控、扩展和维护，包括根据配置和管理需求进行的 Kubernetes 版本升级和修补。
- en: The master node of Kubernetes is fully managed.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 的主节点完全由 Azure 管理。
- en: Master nodes are free, and you only pay for running agent nodes. You only have
    to pay for the worker nodes; the master node is free because the Kubernetes cluster
    master is managed by Azure. You administer the cluster’s agent nodes and only
    pay for the **virtual machines** (**VM s**) on which your nodes run.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点是免费的，您只需为运行代理节点付费。您只需为工作节点付费；主节点是免费的，因为 Kubernetes 集群的主节点由 Azure 管理。您管理集群的代理节点，并仅为运行节点的**虚拟机**（**VMs**）付费。
- en: By using AKS, a Kubernetes cluster can be operational within minutes and the
    master node is managed by Azure, so the focus will be on application development
    and deployment. Now, let’s try to run a Kubernetes cluster with custom images.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AKS 后，Kubernetes 集群可以在几分钟内投入使用，主节点由 Azure 管理，因此重点将放在应用程序开发和部署上。现在，让我们尝试运行一个带有自定义镜像的
    Kubernetes 集群。
- en: Kubernetes in action
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 实践
- en: In the first few sections of this chapter, we created a container and deployed
    it to an Azure container instance. Let’s now deploy this container to a Kubernetes
    cluster.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几个部分中，我们创建了一个容器并将其部署到 Azure 容器实例。现在，让我们将这个容器部署到 Kubernetes 集群中。
- en: Creating a cluster can be done via the Azure CLI or an **Azure Resource Manager**
    (**ARM**) template. For ease of demonstration, the Azure CLI will be used.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集群可以通过 Azure CLI 或 **Azure 资源管理器**（**ARM**）模板进行。为了便于演示，将使用 Azure CLI。
- en: 'First, a new resource group needs to be created to host the Azure Kubernetes
    cluster:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要创建一个新的资源组来托管 Azure Kubernetes 集群：
- en: '[PRE8]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we can create our Kubernetes cluster.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建我们的 Kubernetes 集群。
- en: Creating a Kubernetes cluster
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Kubernetes 集群
- en: 'When the resource group is created, a new Kubernetes cluster can be added to
    the group:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当资源组创建后，可以将新的 Kubernetes 集群添加到该组中：
- en: '[PRE9]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command creates a new Kubernetes cluster with the name `mykubernetescluster`
    and with a single node. This means that there will be one VM created in the Azure
    portal that is configured as a node for the Kubernetes cluster. In addition, the
    monitoring add-ons will be enabled on the cluster.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建了一个名为 `mykubernetescluster` 的新 Kubernetes 集群，并且只包含一个节点。这意味着将在 Azure 门户中创建一个
    VM，并将其配置为 Kubernetes 集群的节点。此外，将启用集群上的监控插件。
- en: The creation of this cluster will take a couple of minutes. In Azure, the `mykubernetescluster`
    service will be created in the specified resource group. Alongside this resource
    group, another group will be created by the Azure platform itself.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 创建该集群将需要几分钟时间。在 Azure 中，将在指定的资源组中创建 `mykubernetescluster` 服务。除了该资源组，Azure 平台本身还将创建另一个资源组。
- en: Kubernetes infrastructure
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 基础设施
- en: 'In this resource group, all virtualized infrastructure that is needed to run
    the cluster is created. This also means that in the future, new components can
    be added to this resource group depending on the demands of the application:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在该资源组中，创建了运行集群所需的所有虚拟化基础设施。这也意味着将来可以根据应用程序的需求将新组件添加到此资源组中：
- en: '![Figure 16.13 – The mpn-rg-kubernetes resource group ](img/B18655_16_13.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.13 – mpn-rg-kubernetes 资源组](img/B18655_16_13.jpg)'
- en: Figure 16.13 – The mpn-rg-kubernetes resource group
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.13 – mpn-rg-kubernetes 资源组
- en: 'In the resource group created, you will find all the aforementioned resources
    to run the cluster:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建的资源组中，您将找到所有运行集群所需的上述资源：
- en: '![Figure 16.14 – A list of a few resources required to run a cluster ](img/B18655_16_14.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.14 – 运行集群所需的一些资源列表](img/B18655_16_14.jpg)'
- en: Figure 16.14 – A list of a few resources required to run a cluster
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.14 – 运行集群所需的一些资源列表
- en: With the Kubernetes infrastructure now up and running, the management and deployment
    of resources can begin.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Kubernetes 基础设施已启动并运行，可以开始管理和部署资源。
- en: Managing Kubernetes
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理 Kubernetes
- en: 'To manage Kubernetes, the `kubectl` command line is used and installed locally
    (or used in Azure Cloud Shell). This is command-line interface tooling that will
    communicate with the Kubernetes API. Let’s see how to work with Kubernetes with
    this command line:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要管理 Kubernetes，使用 `kubectl` 命令行工具，并且在本地安装（或者在 Azure Cloud Shell 中使用）。这是一个与 Kubernetes
    API 通信的命令行界面工具。让我们看看如何使用这个命令行与 Kubernetes 一起工作：
- en: 'First, download and install `kubectl`, and if you do not already have the Azure
    CLI installed, run the following command to install the Azure CLI on your machine:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，下载并安装 `kubectl`，如果您尚未安装 Azure CLI，请运行以下命令以在您的计算机上安装 Azure CLI：
- en: '[PRE10]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To connect to the cluster, the credentials need to be retrieved and saved to
    the local system. This can be done by using the `az aks get-credentials` command
    and specifying the resource group and cluster name:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要连接到集群，需要检索凭据并将其保存到本地系统。可以使用 `az aks get-credentials` 命令并指定资源组和集群名称来完成此操作：
- en: '[PRE11]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With all the prerequisites configured, a lot of the base functionality can
    be run against the Kubernetes cluster. Take a look at these two commands for example:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置好所有前提条件后，可以对 Kubernetes 集群执行大部分基本功能。举个例子，看看这两个命令：
- en: 'Retrieve the nodes of the cluster:'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索集群的节点：
- en: '[PRE12]'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Get the Pods in the cluster:'
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取集群中的 Pods：
- en: '[PRE13]'
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As well as to the preceding commands, you can also try the following Azure
    CLI command to open up the Kubernetes dashboard. This dashboard is a management
    interface built on top of the Kubernetes API that can be used next to the `kubectl`
    command line:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了前面的命令外，您还可以尝试以下 Azure CLI 命令来打开 Kubernetes 仪表盘。该仪表盘是构建在 Kubernetes API 之上的管理界面，可以与
    `kubectl` 命令行一起使用：
- en: '[PRE14]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The dashboard is shown in the following screenshot:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘如下所示：
- en: '![Figure 16.15 – Viewing the Kubernetes dashboard ](img/B18655_16_15.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.15 – 查看 Kubernetes 仪表盘 ](img/B18655_16_15.jpg)'
- en: Figure 16.15 – Viewing the Kubernetes dashboard
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.15 – 查看 Kubernetes 仪表盘
- en: A deployment file needs to be created to be able to run containers within the
    cluster. So, let’s see how to do this.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 需要创建一个部署文件，以便在集群内运行容器。那么，让我们看看如何做到这一点。
- en: Deploying a container image
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署容器镜像
- en: 'We will create a deployment file and deploy it to Kubernetes. To do this, perform
    the following steps:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个部署文件并将其部署到 Kubernetes。为此，请执行以下步骤：
- en: 'Make a new file in your favorite text editor and call it `deploy.yaml`. Add
    the following information to the `deploy.yaml` file:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您喜欢的文本编辑器中创建一个新文件，命名为 `deploy.yaml`。将以下信息添加到 `deploy.yaml` 文件中：
- en: '[PRE15]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this example, the following is specified:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，以下内容已被指定：
- en: A deployment is created with the name `kubernetes-deployment` (`metadata.name`).
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署使用名称 `kubernetes-deployment` 创建（`metadata.name`）。
- en: The deployment will create three replicas of the specified container (`spec.replicas`).
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署将创建指定容器的三个副本（`spec.replicas`）。
- en: The selector, in combination with the `labels` tag, is used to specify which
    components this deployment file will manage within Kubernetes.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器与 `labels` 标签结合使用，用于指定该部署文件将在 Kubernetes 中管理哪些组件。
- en: The deployment file will create a container for the `msftazuredevops.azurecr.io/azuredevops:586`
    image file.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署文件将为 `msftazuredevops.azurecr.io/azuredevops:586` 镜像文件创建一个容器。
- en: 'To deploy this file to Kubernetes, we will again use the `kubectl` command
    line and make use of the `apply` command:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将此文件部署到 Kubernetes，我们将再次使用 `kubectl` 命令行，并利用 `apply` 命令：
- en: '[PRE16]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `-f` argument is used to specify that a local path is used as a reference
    to a deployment file. After executing the command, you can open the Kubernetes
    dashboard to see the status and maybe even observe errors.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f` 参数用于指定使用本地路径作为部署文件的引用。执行命令后，您可以打开 Kubernetes 仪表盘查看状态，甚至可能观察到错误。'
- en: Important Note
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is possible that you encounter an error stating that pulling the image from
    your location failed. This could be a security issue. Under the hood, AKS is using
    a service principal. You should also see this when creating a new Kubernetes cluster.
    Make sure to give this service principal access rights on the Azure Container
    Registry.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会遇到一个错误，提示从您的位置拉取镜像失败。这可能是一个安全问题。在底层，AKS 使用的是服务主体。在创建新的 Kubernetes 集群时，您应该也会看到这个问题。确保为该服务主体授予
    Azure 容器注册表的访问权限。
- en: Following a successful execution, try the `get Pods` command to see whether
    there are three Pods within the system. If everything proceeded correctly, there
    should be three Pods running within Kubernetes, but the application is still not
    available to the outside world.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行成功后，尝试执行 `get Pods` 命令，查看系统中是否有三个 Pod。如果一切顺利，Kubernetes 中应该运行着三个 Pod，但应用程序仍然无法对外界可用。
- en: To make it available, we need to add a service to the deployment file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让它可用，我们需要在部署文件中添加一个服务。
- en: Important Note
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you want to add a service to the same file, add a line with the `---` characters
    between the deployments. This is not required when you also define separate files
    for deployment.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在同一个文件中添加服务，可以在部署之间添加一行包含 `---` 字符的分隔符。如果你定义了单独的部署文件，则不需要这么做。
- en: 'In the `deploy.yaml` file, add the following section:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `deploy.yaml` 文件中，添加以下部分：
- en: '[PRE17]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This YAML section creates a load balancer and attaches it to the specified selector
    (`spec.selector.app`), meaning it will be used for the Pods, as we previously
    specified.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 YAML 部分会创建一个负载均衡器，并将其附加到指定的选择器（`spec.selector.app`），这意味着它将用于之前指定的 Pods。
- en: In the background, Kubernetes will create an Azure load balancer and a public
    IP address for connection to the Pods.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，Kubernetes 会创建一个 Azure 负载均衡器，并为与 Pods 连接分配一个公共 IP 地址。
- en: 'To retrieve the external IP address of the service, use the following command
    until it displays the external IP address:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 若要检索服务的外部 IP 地址，请使用以下命令，直到它显示出外部 IP 地址为止：
- en: '[PRE18]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will return all services and their external IP addresses if they are present.
    Also, take a quick look at the additional resource group of Kubernetes to see
    which Azure resources are created.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有服务及其外部 IP 地址（如果存在）。同时，快速查看 Kubernetes 的附加资源组，看看哪些 Azure 资源已被创建。
- en: Well done! In this section, you learned how to create a Kubernetes cluster and
    deploy a container image on it via `kubectl` and deployment files. In the next
    section, we will take this forward and learn how to upgrade these containers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 做得好！在本节中，你学习了如何创建 Kubernetes 集群，并通过 `kubectl` 和部署文件将容器镜像部署到其中。在下一节中，我们将继续学习如何升级这些容器。
- en: Upgrading containers
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级容器
- en: In Kubernetes, applications are very easily updated. For this, Kubernetes uses
    rolling updates, which means that traffic to a container is first drained before
    the container is replaced. During an upgrade of the application, Kubernetes will
    deploy an additional Pod and run it through some specified probes.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，应用程序非常容易更新。为此，Kubernetes 使用滚动更新，意味着在替换容器之前，容器的流量会先被清空。在应用程序升级过程中，Kubernetes
    会部署一个额外的 Pod，并通过一些指定的探针来运行它。
- en: A probe is a diagnostic that is periodically performed on a Pod to check its
    status. During the upgrading or creation of a Pod, Kubernetes brings up the additional
    Pod and makes sure that it passes the liveness and readiness probes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 探针是对 Pod 进行定期检查状态的诊断工具。在升级或创建 Pod 期间，Kubernetes 会启动额外的 Pod，并确保它通过存活探针和就绪探针。
- en: If the newly created Pod succeeds with both probes, the traffic to a single,
    old Pod is terminated and traffic to the new Pod is opened. For this termination,
    Kubernetes uses a termination grace period. During this period, the connection
    to the load balancer is stopped and active connections are processed successfully,
    and new traffic is routed to a running Pod. During the 30-second default grace
    period, the Pod is in a termination state and all previous traffic to it is diverted
    to the other Pods.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新创建的 Pod 成功通过了两个探针，流量将从一个旧 Pod 中断开，转而指向新 Pod。对于这种终止，Kubernetes 使用终止宽限期。在此期间，与负载均衡器的连接被停止，活跃连接会被成功处理，新的流量会被路由到正在运行的
    Pod。在默认的 30 秒宽限期内，Pod 处于终止状态，所有到该 Pod 的流量将被转发到其他 Pods。
- en: 'This process continues until all Pods are replaced with the new version. All
    of this is default behavior within Azure Kubernetes. Deployment is simply triggered
    by adjusting the deployment file and applying it with the same command as used
    previously:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程会持续进行，直到所有 Pod 被新版本替换。这些都是 Azure Kubernetes 中的默认行为。只需调整部署文件并使用与之前相同的命令应用它，就可以触发部署：
- en: '[PRE19]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'By default, `httpGet` probes are added to Pods that are being exposed, but
    they can also be customized by adding the readiness probe or liveness probe to
    the deployment:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`httpGet` 探针会被添加到正在暴露的 Pods 中，但也可以通过在部署文件中添加就绪探针或存活探针来自定义它们：
- en: '[PRE20]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This readiness probe performs an `httpGet` request on the Pod and has the following
    options:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此就绪探测在Pod上执行`httpGet`请求，并具有以下选项：
- en: '`path`: The path it should call for the `httpGet` request.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`: 执行`httpGet`请求时应调用的路径。'
- en: '`port`: The port number it should use for the call. This is also configured
    in our deployment file.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`: 用于调用的端口号。这也在我们的部署文件中配置。'
- en: '`initialDelaySeconds`: The seconds it waits before running the probe once the
    container is started.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialDelaySeconds`: 容器启动后运行探测前等待的秒数。'
- en: '`periodSeconds`: The number of seconds the probe waits before it times out.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`periodSeconds`: 探测在超时之前等待的秒数。'
- en: '`successThreshold`: The minimum amount of success necessary for the probe is
    `1`.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`successThreshold`: 探测所需的最小成功次数为`1`。'
- en: 'As mentioned, a deployment has a default rolling upgrade scenario configured.
    The configuration of the rolling deployment can be retrieved by using the following
    command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，部署配置了默认的滚动升级场景。可以使用以下命令检索滚动部署的配置：
- en: '[PRE21]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Important Note
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are interested in doing so, build a new version of your container and
    upgrade it within Kubernetes. Before running the upgrade, make sure you have the
    dashboard open, refresh the page during the update, and you will see extra Pods
    coming up and old Pods being terminated.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有兴趣这样做，请在Kubernetes内构建并升级容器的新版本。在运行升级之前，请确保打开了仪表板，在更新过程中刷新页面，您将看到额外的Pod出现并且旧的Pod被终止。
- en: In this section, we learned how to upgrade containers, which will help you stay
    up to date with the latest version. Moving forward, in the next section, we will
    look further into the scaling of containers and Kubernetes.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何升级容器，这将帮助您保持最新版本。接下来，在下一节中，我们将进一步探讨容器和Kubernetes的扩展。
- en: Scaling containers and Kubernetes
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展容器和Kubernetes
- en: 'As the demand for your application grows, you will need to scale the application.
    Scaling the application can be done in multiple ways and different components
    can be scaled:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序需求的增长，您需要扩展应用程序。可以通过多种方式进行应用程序的扩展，可以扩展不同的组件：
- en: '![Figure 16.16 – The autoscaler in AKS ](img/B18655_16_16.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图16.16 – AKS中的自动缩放器](img/B18655_16_16.jpg)'
- en: Figure 16.16 – The autoscaler in AKS
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16 – AKS中的自动缩放器
- en: The preceding diagram shows you the different ways to scale your application
    or cluster, which we will discuss over the upcoming subsections.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 上图显示了应用程序或集群扩展的不同方式，我们将在接下来的小节中讨论。
- en: Scaling Pods manually
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动扩展Pod
- en: 'Pods can easily be scaled by updating the number of replicas. Try getting your
    Pods by using the `kubectl get Pods` command, and increase the number of replicas
    by using the following command:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过更新副本数量轻松扩展Pod。尝试使用`kubectl get Pods`命令获取您的Pod，并使用以下命令增加副本数量：
- en: '[PRE22]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command scales the Pods up or down, based on the number of replicas. The
    scale is adjusted, as shown in the deployment configuration.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令根据副本数量调整Pod的规模。规模按照部署配置进行调整。
- en: Autoscaling Pods
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod自动缩放
- en: AKS also supports autoscaling. The scheduler will then update the number of
    Pods, depending on CPU utilization or other metrics that are available.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: AKS也支持自动缩放。调度程序将根据CPU利用率或其他可用的指标更新Pod的数量。
- en: Kubernetes uses the metrics server for this. The metrics server collects metrics
    from the summary API of the kubelet agents that run on the nodes within the cluster.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使用度量服务器进行此操作。度量服务器从集群中的节点上运行的kubelet代理的摘要API中收集度量。
- en: The autoscale functionality also requires some configuration on the deployment
    side of Kubernetes. For deployment, you need to specify the requests and limits
    for the running container. These values are specified for a specific metric –
    for example, the CPU.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 自动缩放功能还需要在Kubernetes部署端进行一些配置。对于部署，您需要指定运行容器的请求和限制。这些值针对特定的度量标准进行指定，例如CPU。
- en: 'In the following example, there are requests and limits specified for the CPU
    metric. The CPU metric is measured in CPU units. In Azure, one unit stands for
    one core. On different platforms, a unit can have a different meanings:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，为CPU度量标准指定了请求和限制。CPU度量标准以CPU单位进行测量。在Azure中，一个单位代表一个核心。在不同的平台上，一个单位可能有不同的含义：
- en: '[PRE23]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This part can be added to the container in the deployment file, and this will
    make sure that the Pods can be autoscaled when large numbers of requests need
    to be served.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将此部分添加到部署文件的容器中，这将确保在需要大量请求时可以自动扩展Pod。
- en: 'With the updated deployment file, deploy it and make an autoscale rule within
    the Kubernetes cluster:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新后的部署文件，部署它并在 Kubernetes 集群中设置自动扩展规则：
- en: '[PRE24]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This rule will update the deployment with autoscale functionality. If average
    CPU utilization across all Pods exceeds 60% of their requested usage, the autoscaler
    increases the Pods up to a maximum of 10 instances. A minimum of one instance
    is then defined for the deployment:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则将更新部署并添加自动扩展功能。如果所有 Pods 的平均 CPU 利用率超过它们请求的使用量的 60%，则自动扩展器将增加 Pods 数量，最多可增加至
    10 个实例。然后，为该部署定义了最小实例数为 1：
- en: 'After creating the autoscaler, you can check it by running the following command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自动扩展器后，您可以通过运行以下命令来检查它：
- en: '[PRE25]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Tip
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '**HPA** stands for **Horizontal Pod Autoscaler**.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**HPA** 代表 **Horizontal Pod Autoscaler**（水平 Pod 自动扩展器）。'
- en: Try creating a CPU-intensive operation within an application and checking automatic
    Pod creation during execution. The Kubernetes cluster will notice the significant
    amount of CPU usage and will scale out the cluster automatically by creating multiple
    Pods.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在应用程序中创建一个 CPU 密集型操作，并在执行期间检查自动创建的 Pod。Kubernetes 集群会注意到 CPU 使用量的显著增加，并会通过创建多个
    Pod 自动扩展集群。
- en: Once the intensive operation is finished, Kubernetes will scale the number of
    Pods down to the minimum.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦密集型操作完成，Kubernetes 会将 Pods 数量缩减至最小值。
- en: Scaling nodes
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放节点
- en: 'Alongside scaling Pods, Kubernetes can also scale the number of nodes that
    run within the Kubernetes cluster. The number of nodes can be scaled using the
    following commands:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缩放 Pods 外，Kubernetes 还可以缩放 Kubernetes 集群中运行的节点数量。可以使用以下命令缩放节点数量：
- en: 'First, get the information pertaining to the current environment by requesting
    the number of nodes:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过请求节点的数量，获取与当前环境相关的信息：
- en: '[PRE26]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, use this command to update `nodepool`. Extract the name of `nodepool`
    from the result of the last command:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用此命令更新`nodepool`。从上一个命令的结果中提取`nodepool`的名称：
- en: '[PRE27]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Scaling the number of nodes up can increase the performance drastically. This
    will also make the cluster more expensive. By scaling the number of cluster nodes
    down, costs can decrease, and you are only using the resources that are actually
    required by your application. To keep track of this, the nodes can also be autoscaled.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 增加节点数量可以大幅提升性能，但这也会使集群变得更加昂贵。通过缩减集群节点数量，可以降低成本，同时只使用应用程序实际需要的资源。为了跟踪这一点，节点也可以进行自动缩放。
- en: Autoscaling nodes
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动缩放节点
- en: 'Alongside the manual scaling of nodes, nodes can also scale automatically by
    updating the Kubernetes cluster. This can be done by using the `az aks update`
    command. With this command, you can set the minimum and maximum node counts. The
    autoscaler will then make sure that nodes are created when needed:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动缩放节点外，还可以通过更新 Kubernetes 集群来实现节点的自动缩放。这可以通过使用`az aks update`命令来完成。通过此命令，您可以设置节点的最小和最大数量。然后，自动扩展器将确保在需要时创建节点：
- en: '[PRE28]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: AKS also has the option to scale out with ACI. To use this option, a specific
    configuration needs to be applied when creating the AKS cluster. This is mainly
    required because ACI needs a specific subnet within the virtual network.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: AKS 还提供了使用 ACI 扩展的选项。要使用此选项，在创建 AKS 集群时需要应用特定的配置。这是因为 ACI 需要虚拟网络中的特定子网。
- en: In this section, we learned to scale containers and the cluster to drastically
    increase performance. Next up is deployment from Azure DevOps to facilitate continuous
    deployment.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了如何缩放容器和集群，从而大幅提升性能。接下来是通过 Azure DevOps 进行部署，以实现持续部署。
- en: Deploying to Kubernetes with Azure DevOps
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure DevOps 部署到 Kubernetes
- en: We have seen a lot of options for deploying and configuring the Kubernetes cluster
    via the command line. When working with DevOps, however, changes need to be applied
    in a continuous way.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多通过命令行部署和配置 Kubernetes 集群的选项。然而，在与 DevOps 一起工作时，变更需要以持续的方式进行应用。
- en: 'For this, there is the Kubernetes manifest task within Azure DevOps, which
    contains a lot of functionalities to manage a Kubernetes cluster:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，Azure DevOps 中有 Kubernetes 清单任务，包含许多功能来管理 Kubernetes 集群：
- en: '[PRE29]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding example, the following is configured:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，配置了以下内容：
- en: '`action`: The kind of action we want to perform. In this example, the `deploy`
    action is used because we want to deploy/apply a deployment file.'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action`：我们希望执行的操作类型。在这个示例中，使用`deploy`操作，因为我们要部署/应用部署文件。'
- en: '`kubernetesServiceConnection`: The service connection to the Kubernetes cluster.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubernetesServiceConnection`：与 Kubernetes 集群的服务连接。'
- en: '`manifests`: The path to the manifest file. As we are using the deploy action,
    this should be a reference to the deployment file.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manifests`：清单文件的路径。由于我们使用的是部署操作，因此这应该是对部署文件的引用。'
- en: '`containers`: A special field where you can override the version of the container
    being deployed. By specifying the preceding, every image is specified in the deployment
    manifest with the `msftazuredevops.azurecr.io` reference, and the `azuredevops`
    repository is replaced by the new value as configured in this field.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers`：一个特殊字段，可以覆盖正在部署的容器的版本。通过指定前述内容，部署清单中的每个镜像都会使用`msftazuredevops.azurecr.io`引用，并且`azuredevops`存储库将被替换为此字段中配置的新值。'
- en: Using a Kubernetes destination environment within Azure DevOps pipelines also
    has the advantage of seeing the environment running within Azure DevOps. This
    will show the number of running Pods within the cluster.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 管道中使用 Kubernetes 目标环境的另一个优点是可以看到 Azure DevOps 中运行的环境。这将显示集群中正在运行的
    Pods 数量。
- en: 'Try it out with the following stage configuration for a build that will publish
    the deployment files to the artifact location of Azure DevOps:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用以下阶段配置进行构建，该构建将发布部署文件到 Azure DevOps 的工件位置：
- en: '[PRE30]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next to the build stage, add the following release stage. Following the initial
    execution of the pipeline, a new environment will be available within Azure DevOps.
    In the environment created by the release, attach the Kubernetes cluster to see
    information on the running Pods:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建阶段旁边，添加以下发布阶段。在管道首次执行后，Azure DevOps 中将会有一个新的环境。在发布创建的环境中，连接 Kubernetes 集群以查看运行中的
    Pods 信息：
- en: '[PRE31]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the example, two stages are specified for a multi-stage pipeline. The first
    stage will build the container image via the Docker task and publish it to a container
    registry. After publishing the image, it also publishes a number of build artifacts
    – in this case, the Kubernetes manifests.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，为多阶段管道指定了两个阶段。第一个阶段将通过 Docker 任务构建容器镜像，并将其发布到容器注册表。在发布镜像后，它还会发布多个构建工件——在此例中为
    Kubernetes 清单。
- en: The second stage deploys to a specific environment called Kubernetes. This environment
    will also be created in Azure DevOps if it has not already been added. During
    the remainder of the process, it retrieves the published artifacts of the build
    stage and uses the Kubernetes manifest task to deploy the Kubernetes resources.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个阶段将部署到名为 Kubernetes 的特定环境。如果该环境尚未添加，它也会在 Azure DevOps 中创建。在过程的其余部分，它会检索构建阶段发布的工件，并使用
    Kubernetes 清单任务部署 Kubernetes 资源。
- en: Summary
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned what containers are and how they relate to
    DevOps. Where DevOps is more of a cultural thing, containers are a way to support
    it technically. You have also learned how to create container images via a Dockerfile,
    specifically by using a multi-stage build file. Finally, we dived into Kubernetes,
    where we learned a way to host containers and also manage the running containers
    by using the `kubectl` command.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了容器是什么以及它们如何与 DevOps 相关。DevOps 更多的是一种文化，而容器则是支持它的技术方式。你还学习了如何通过 Dockerfile
    创建容器镜像，特别是通过使用多阶段构建文件。最后，我们深入探讨了 Kubernetes，学习了如何使用`kubectl`命令托管容器并管理正在运行的容器。
- en: Using the knowledge acquired in this chapter, you are now able to deploy applications
    to Kubernetes and make sure that it scales with the number of requests it receives.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章中获得的知识，你现在可以将应用程序部署到 Kubernetes，并确保其能够根据收到的请求数量进行扩展。
- en: In the next chapter, you will learn more about facilitating the DevOps process
    by using Azure DevOps. You will learn what works for your organization and team
    and what doesn’t, and how to implement that structure and your approach using
    Azure DevOps.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何通过使用 Azure DevOps 来促进 DevOps 流程。你将了解哪些方法适合你的组织和团队，哪些方法不适合，并学习如何使用
    Azure DevOps 实现这些结构和方法。
- en: Questions
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding the material covered in this chapter. You will find the answers in the
    *Assessments* section of the *Appendix* chapter:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结部分，这里列出了几个问题，帮助你测试自己对本章内容的掌握情况。你可以在*附录*章节的*评估*部分找到答案：
- en: What are the benefits of containers for DevOps?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器对 DevOps 有哪些好处？
- en: A specific container can be hosted on different platforms (Azure/**Amazon web
    Services** (**AWS**)/**Google Cloud platform** (**GCP**)) – true or false?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个特定的容器可以托管在不同的平台上（Azure/**Amazon Web Services**（**AWS**）/**Google Cloud Platform**（**GCP**））——对还是错？
- en: Is it possible to add container support to an existing application?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以为现有应用程序添加容器支持？
- en: What is the RUN command used for within a Dockerfile?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Dockerfile 中的 RUN 命令是用来做什么的？
- en: Kubernetes can be scaled on different components. What are they?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 可以在不同组件上进行扩展。它们是什么？
- en: Exercises
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Let’s create and publish an image of our application into Azure Container Registry
    and deploy it on an Azure Kubernetes cluster.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们创建并将我们的应用程序镜像发布到 Azure 容器注册表，并在 Azure Kubernetes 集群上进行部署。
- en: 'The following Azure resources need to be configured for this lab:'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本实验需要配置以下 Azure 资源：
- en: ACR
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACR
- en: AKS
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: AKS
- en: 'Set up the environment – create AKS and ACR:'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境 – 创建 AKS 和 ACR：
- en: '[PRE32]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Configure ACR integration with an existing AKS cluster:'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 ACR 与现有 AKS 集群的集成：
- en: '[PRE33]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Refer to `azurecontainercluster-pipelines.yml` in the repository or create
    a new YAML file with the following contents:'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考仓库中的 `azurecontainercluster-pipelines.yml` 文件，或者创建一个包含以下内容的新 YAML 文件：
- en: '[PRE34]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the containerRegistry name is `packtbookacr`, which is the same as
    when you created AKS and ACR. The containerRegistry name `packtbookacr` must be
    globally unique, so you won’t be able to use the same name.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请注意，containerRegistry 名称是 `packtbookacr`，与创建 AKS 和 ACR 时使用的名称相同。containerRegistry
    名称 `packtbookacr` 必须是全球唯一的，因此你不能使用相同的名称。
- en: 'Update `dockerfile` with the following contents:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下内容更新 `dockerfile`：
- en: Important Note
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The endpoint is masked with `***` in the following example. Please use an appropriate
    and valid endpoint for your NuGet feed.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，端点被 `***` 遮蔽。请使用适当且有效的端点来处理你的 NuGet feed。
- en: '[PRE35]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We use **Azure Artifact Credential Provider** here to automate the acquisition
    of the credentials required to restore NuGet packages.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这里使用 **Azure Artifact Credential Provider** 来自动获取还原 NuGet 包所需的凭据。
- en: 'After successfully executing the `azurecontainercluster-pipelines.yml` file
    through the Azure DevOps build pipeline, you will notice that an image with tags
    is created in ACR:'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在通过 Azure DevOps 构建管道成功执行 `azurecontainercluster-pipelines.yml` 文件后，你会注意到 ACR
    中创建了带有标签的镜像：
- en: '![Figure 16.17 – An ACR list ](img/B18655_16_17.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.17 – 一个 ACR 列表](img/B18655_16_17.jpg)'
- en: Figure 16.17 – An ACR list
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.17 – 一个 ACR 列表
- en: 'You may need to establish and authorize an Azure DevOps Service connection
    with ACR, as created in the preceding paragraph, to successfully execute a build
    pipeline:'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能需要建立并授权一个 Azure DevOps 服务连接与 ACR，如前面段落所创建的，以成功执行构建管道：
- en: '![Figure 16.18 – Establishing an ACR service connection ](img/B18655_16_18.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![图 16.18 – 建立 ACR 服务连接](img/B18655_16_18.jpg)'
- en: Figure 16.18 – Establishing an ACR service connection
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16.18 – 建立 ACR 服务连接
- en: Further reading
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Information on installing the Azure CLI: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli).'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Azure CLI 的信息：[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)。
- en: 'Information on installing Docker Desktop: [https://docs.docker.com/desktop/windows/install/](https://docs.docker.com/desktop/windows/install/).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker Desktop 的信息：[https://docs.docker.com/desktop/windows/install/](https://docs.docker.com/desktop/windows/install/)。
- en: 'More information on Kubernetes: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Kubernetes 的更多信息：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)
- en: 'You can find more information regarding Azure Kubernetes at the following link:
    [https://azure.microsoft.com/en-us/topic/what-is-kubernetes/](https://azure.microsoft.com/en-us/topic/what-is-kubernetes/).'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在以下链接找到关于 Azure Kubernetes 的更多信息：[https://azure.microsoft.com/en-us/topic/what-is-kubernetes/](https://azure.microsoft.com/en-us/topic/what-is-kubernetes/)。
- en: 'Information on ACR: [https://docs.microsoft.com/en-in/azure/container-registry/container-registry-get-started-portal](https://docs.microsoft.com/en-in/azure/container-registry/container-registry-get-started-portal).'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ACR 信息：[https://docs.microsoft.com/en-in/azure/container-registry/container-registry-get-started-portal](https://docs.microsoft.com/en-in/azure/container-registry/container-registry-get-started-portal)。
- en: 'More information regarding multi-stage builds: [https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/).'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于多阶段构建的更多信息：[https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)。
