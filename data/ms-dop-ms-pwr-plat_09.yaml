- en: <st c="0">9</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">9</st>
- en: <st c="2">Implementing the Fusion Development Approach</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">实现融合开发方法</st>
- en: <st c="46">Power Platform, with its low-code/no-code approach, allows citizen
    developers who are close to business processes to use their knowledge of the business
    problem to design and bring new applications to usage faster.</st> <st c="262">It
    often can happen, that the challenges they are facing scale to be more complex
    or the feature demand surpasses their capabilities, thus pro-developers are required
    to support the development process and help citizen developers avoid</st> <st
    c="498">repetitive tasks.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46">Power Platform 采用低代码/零代码方法，允许接近业务流程的公民开发人员利用他们对业务问题的了解来设计并更快地将新应用投入使用。</st>
    <st c="262">然而，他们所面临的挑战可能会变得更加复杂，或是功能需求超出了他们的能力，因此需要专业开发人员支持开发过程，帮助公民开发人员避免</st>
    <st c="498">重复性的任务。</st>
- en: <st c="515">In this chapter, we will look at how organizations can connect different
    personas to build effective teams that will work together to solve challenges
    and enable organizations with digitized business solutions.</st> <st c="727">We
    will start by focusing on the general understanding of the fusion development
    approach and how teams are represented by different personas.</st> <st c="870">We
    will continue with some good open source development practices that can be applied
    also in low-code/no-code and drill into a tool in Power Platform that</st> <st
    c="1026">supports them.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="515">在本章中，我们将探讨组织如何将不同的角色联系在一起，构建有效的团队，合作解决挑战，并为组织提供数字化的业务解决方案。</st>
    <st c="727">我们将从聚焦融合开发方法的基本理解及团队如何通过不同角色进行表现开始。</st> <st c="870">接着，我们将介绍一些好的开源开发实践，这些实践同样适用于低代码/零代码，并深入了解
    Power Platform 中一个支持这些实践的工具。</st>
- en: <st c="1040">The final part will focus on the integration between the Azure
    cloud and Power Platform.</st> <st c="1130">The emphasis here will be on specific
    Azure services, such as the Azure API Management service, which serves as the
    integration service between Azure and Power Platform.</st> <st c="1300">Some other
    common Azure services that are often used in the integration scenarios with Power
    Platform will be covered as well.</st> <st c="1427">We will finish off by looking
    into an example of building an integration between a low-code application and
    a</st> <st c="1537">code-first solution.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1040">最后一部分将集中讨论 Azure 云与 Power Platform 之间的集成。</st> <st c="1130">这里将重点介绍特定的
    Azure 服务，如 Azure API 管理服务，它作为 Azure 与 Power Platform 之间的集成服务。</st> <st c="1300">此外，还将涵盖一些在与
    Power Platform 集成场景中经常使用的其他常见 Azure 服务。</st> <st c="1427">最后，我们将通过构建低代码应用与</st>
    <st c="1537">代码优先解决方案的集成示例来结束。</st>
- en: <st c="1557">We will cover the following main topics in</st> <st c="1601">this
    chapter:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1557">本章将涵盖以下主要内容：</st> <st c="1601">：</st>
- en: <st c="1614">What is the fusion</st> <st c="1634">development approach?</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1614">什么是融合</st> <st c="1634">开发方法？</st>
- en: <st c="1655">Microsoft Azure and Power</st> <st c="1682">Platform together</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1655">Microsoft Azure 和 Power</st> <st c="1682">平台的结合</st>
- en: <st c="1699">Example of an Azure and Power Platform</st> <st c="1739">integration
    scenario</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1699">Azure 和 Power Platform 的集成示例</st> <st c="1739">场景</st>
- en: <st c="1759">Technical requirements</st>
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1759">技术要求</st>
- en: <st c="1782">This chapter connects Power Platform solutions together with Azure
    services.</st> <st c="1860">To follow along, we recommend having these requirements</st>
    <st c="1916">in place:</st>
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1782">本章将连接 Power Platform 解决方案与 Azure 服务。</st> <st c="1860">为了跟上进度，我们建议提前准备好以下要求：</st>
    <st c="1916">：</st>
- en: '**<st c="1925">Power Platform subscription</st>**<st c="1953">: You can sign
    up for a Power Platform Developer Plan (</st>[<st c="2009">https://powerapps.microsoft.com/en-us/developerplan/</st>](https://powerapps.microsoft.com/en-us/developerplan/)<st
    c="2062">) if you already have a Microsoft Entra ID work account, or you can join
    the Microsoft 365 Developer</st> <st c="2164">Program (</st>[<st c="2173">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2237">).</st>'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="1925">Power Platform 订阅</st>**<st c="1953">：如果你已经拥有 Microsoft Entra
    ID 工作账户，可以注册 Power Platform 开发者计划（</st>[<st c="2009">https://powerapps.microsoft.com/en-us/developerplan/</st>](https://powerapps.microsoft.com/en-us/developerplan/)<st
    c="2062">）；或者，你也可以加入 Microsoft 365 开发者计划（</st>[<st c="2173">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2237">）。</st>'
- en: '**<st c="2240">Azure subscription</st>**<st c="2259">: You can provision a
    free Azure account following the guidance on this website:</st> [<st c="2341">https://azure.microsoft.com/en-us/free</st>](https://azure.microsoft.com/en-us/free)<st
    c="2379">. Once provisioned, the Microsoft Azure portal can be accessed via the
    following</st> <st c="2460">URL:</st> [<st c="2465">https://portal.azure.com/</st>](https://portal.azure.com/)<st
    c="2490">.</st>'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2240">Azure 订阅</st>**<st c="2259">：你可以按照此网站上的指导，注册一个免费的 Azure 账户：</st>
    [<st c="2341">https://azure.microsoft.com/en-us/free</st>](https://azure.microsoft.com/en-us/free)<st
    c="2379">。注册完成后，可以通过以下</st> <st c="2460">网址</st> [<st c="2465">https://portal.azure.com/</st>](https://portal.azure.com/)<st
    c="2490">访问 Microsoft Azure 门户。</st>'
- en: '**<st c="2491">Visual Studio</st>**<st c="2505">: If you do not have access
    to any other version of Visual Studio, you can use the free Community Edition
    (</st>[<st c="2613">https://visualstudio.microsoft.com/vs/community/</st>](https://visualstudio.microsoft.com/vs/community/)<st
    c="2662">).</st> <st c="2666">Some examples demonstrate the capabilities of Power
    Platform tools for Visual Studio that are not available in Visual Studio Code.</st>
    <st c="2797">For other cases, you can also use</st> **<st c="2831">Visual Studio
    Code</st>** <st c="2849">(</st>**<st c="2851">VS Code</st>**<st c="2858">) with
    the</st> **<st c="2870">Power Platform Tools</st>** <st c="2890">extension.</st>
    <st c="2902">VS Code can be found</st> <st c="2923">here:</st> [<st c="2929">https://code.visualstudio.com/</st>](https://code.visualstudio.com/)<st
    c="2959">.</st>'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2491">Visual Studio</st>**<st c="2505">：如果你无法访问其他版本的 Visual Studio，可以使用免费的
    Community Edition（</st>[<st c="2613">https://visualstudio.microsoft.com/vs/community/</st>](https://visualstudio.microsoft.com/vs/community/)<st
    c="2662">）。</st> <st c="2666">一些示例展示了 Power Platform 工具在 Visual Studio 中的功能，这些功能在
    Visual Studio Code 中不可用。</st> <st c="2797">在其他情况下，你也可以使用</st> **<st c="2831">Visual
    Studio Code</st>** <st c="2849">(</st>**<st c="2851">VS Code</st>**<st c="2858">)
    和</st> **<st c="2870">Power Platform Tools</st>** <st c="2890">扩展。</st> <st c="2902">VS
    Code 可以在以下网址找到：</st> [<st c="2929">https://code.visualstudio.com/</st>](https://code.visualstudio.com/)<st
    c="2959">。</st>'
- en: '**<st c="2960">Samples</st>** <st c="2968">discussed in this chapter are located
    in the following</st> <st c="3024">repository:</st> [<st c="3036">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09</st>](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09)<st
    c="3135">.</st>'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2960">示例</st>** <st c="2968">本章讨论的示例位于以下</st> <st c="3024">代码库：</st>
    [<st c="3036">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09</st>](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09)<st
    c="3135">。</st>'
- en: <st c="3136">What is the fusion development approach?</st>
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3136">什么是融合开发方法？</st>
- en: <st c="3177">This section covers how individuals</st> <st c="3213">from different
    teams collaborate to realize projects through a concept known as the</st> **<st
    c="3298">fusion development approach</st>**<st c="3325">. We will explain what
    this is and how it bridges the gap between citizen developers and pro-developers.</st>
    <st c="3430">We will explain how Power Platform can also benefit from the practices
    coming from the open source development world, and finish off by preparing our
    development environment to be connected with</st> <st c="3625">Power Platform.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3177">本节介绍不同团队成员如何通过一个名为</st> **<st c="3298">融合开发方法</st>**<st c="3325">的概念进行协作，以实现项目目标。</st>
    <st c="3430">我们将解释这是什么，以及它如何弥合公民开发者与专业开发者之间的差距。</st> <st c="3625">我们还将解释 Power
    Platform 如何受益于来自开源开发世界的实践，最后将我们的开发环境配置为连接 Power Platform。</st>
- en: <st c="3640">Fusion development involves merging diverse teams and their skillset,
    to facilitate the digitization of business capabilities and deliver value.</st>
    <st c="3786">It is a term that was first defined by Gartner as a multidisciplinary
    digital business team that blends technology and business domain expertise and
    is responsible for delivering digital products.</st> <st c="3983">Gartner’s research
    showed that implementing distributed fusion teams can help speed up the progress
    of realizing the organization’s digital transformation agenda much faster compared
    to the traditional centralized teams.</st> <st c="4204">You can read more about
    Gartner’s research in the article published on this</st> <st c="4280">page:</st>
    [<st c="4286">https://www.gartner.com/en/articles/why-fusion-teams-matter</st>](https://www.gartner.com/en/articles/why-fusion-teams-matter)<st
    c="4345">.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3640">融合开发涉及整合不同的团队及其技能，以促进业务能力的数字化，并提供价值。</st> <st c="3786">这一术语首次由
    Gartner 定义，指的是一个跨学科的数字商业团队，结合了技术和业务领域的专业知识，负责交付数字产品。</st> <st c="3983">Gartner
    的研究表明，与传统的集中式团队相比，实施分布式融合团队可以更快地加速实现组织数字化转型的进程。</st> <st c="4204">你可以在这篇文章中阅读更多关于
    Gartner 研究的内容：</st> <st c="4280">页面：</st> [<st c="4286">https://www.gartner.com/en/articles/why-fusion-teams-matter</st>](https://www.gartner.com/en/articles/why-fusion-teams-matter)<st
    c="4345">。</st>
- en: <st c="4346">In the world of Power Platform, the fusion development approach</st>
    <st c="4410">blends together a low-code/no-code development approach with a traditional
    software development approach and IT operations for managing resources and platforms.</st>
    <st c="4572">The purpose of these multidisciplinary teams working together is
    to take advantage of the knowledge that teams have and use that to scale the application
    modernization or the digitization of the business processes with the use of low-code/no-code
    tools.</st> <st c="4826">It helps organizations succeed with business transformation
    in a fast-changing business environment, where it is imperative to have business
    solutions available in the market soon enough to gain a</st> <st c="5023">competitive
    advantage.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4346">在 Power Platform 的世界里，融合开发方法</st> <st c="4410">将低代码/无代码开发方法与传统软件开发方法以及
    IT 运营相结合，用于管理资源和平台。</st> <st c="4572">这些多学科团队合作的目的是利用团队所掌握的知识，并通过使用低代码/无代码工具来扩展应用程序现代化或业务流程的数字化。</st>
    <st c="4826">它帮助组织在快速变化的商业环境中实现业务转型的成功，在这个环境中，必须尽早提供市场上可用的商业解决方案，以获得</st> <st
    c="5023">竞争优势。</st>
- en: <st c="5045">We can group team members of fusion teams into three different</st>
    <st c="5109">persona groups:</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5045">我们可以将融合团队的成员分为三种不同的</st> <st c="5109">角色组：</st>
- en: '**<st c="5124">Citizen developers</st>**<st c="5143">: This group consists
    of people who have business knowledge, understand</st> <st c="5215">the business</st>
    <st c="5228">processes and the business challenges, and are determined to digitize
    existing business processes.</st> <st c="5328">Here, we can find business users,
    business analysts, and business engineers.</st> <st c="5405">They will be using
    tools that support low-code/no-code development approaches, such as Microsoft
    Power Platform, to visually design and build certain parts of the project.</st>
    <st c="5577">This could be building a frontend prototype of the application in
    Power Apps or workflows that support business processes in</st> <st c="5702">Power
    Automate.</st>'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5124">公民开发者</st>**<st c="5143">：这一群体由具备商业知识、理解</st> <st c="5215">商业</st>
    <st c="5228">流程和商业挑战的人组成，他们决心将现有的业务流程数字化。</st> <st c="5328">在这里，我们可以找到商业用户、业务分析师和业务工程师。</st>
    <st c="5405">他们将使用支持低代码/无代码开发方法的工具，如 Microsoft Power Platform，以可视化的方式设计和构建项目的某些部分。</st>
    <st c="5577">这可能包括在 Power Apps 中构建应用程序的前端原型，或在 Power Automate 中支持业务流程的工作流。</st>'
- en: '**<st c="5717">Professional developers</st>**<st c="5741">: This is a group</st>
    <st c="5760">of skilled professional developers</st> <st c="5794">who are experienced
    in various programming languages that will be used to solve complex application
    development challenges.</st> <st c="5919">Using traditional software development
    tools, such as Visual Studio, they will primarily be building extensions for low-code
    solutions.</st> <st c="6055">Their work will focus on developing backend APIs,
    integration scenarios, or custom code components that will be used by citizen
    developers in their low-code/no-code projects.</st> <st c="6230">Where possible,
    it is recommended that professional developers also use the same low-code development
    tool as citizen developers, to support the development of simpler tasks</st> <st
    c="6403">and to integrate custom solutions into the newly</st> <st c="6453">developed
    solution.</st>'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5717">专业开发人员</st>**<st c="5741">：这是一个由经验丰富的专业开发人员组成的团队</st> <st c="5760">他们精通多种编程语言，能够解决复杂的应用程序开发挑战。</st>
    <st c="5794">通过使用传统的软件开发工具，如 Visual Studio，他们将主要为低代码解决方案构建扩展。</st> <st c="5919">他们的工作将侧重于开发后端
    API、集成场景或由公民开发人员在其低代码/无代码项目中使用的自定义代码组件。</st> <st c="6055">如果可能，建议专业开发人员也使用与公民开发人员相同的低代码开发工具，以支持开发更简单的任务</st>
    <st c="6230">并将自定义解决方案集成到新开发的解决方案中。</st>'
- en: '**<st c="6472">IT professionals/DevOps engineers</st>**<st c="6506">: The last
    group is where we will find IT professionals, who will look after the resources</st>
    <st c="6597">that will be</st> <st c="6610">running newly built business applications
    in order to be used in a managed and governed way, aligned with organizational
    IT policies.</st> <st c="6745">In this group, we will find DevOps engineers, who
    will be responsible for managing the DevOps processes of the business solution.</st>
    <st c="6875">They will make sure the project is aligned with DevOps practices,
    such as having CI/CD pipelines up and running and ensuring that all components
    of the business solution are</st> <st c="7049">properly version-controlled.</st>'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6472">IT 专业人士/DevOps 工程师</st>**<st c="6506">：最后一组是 IT 专业人士，他们将负责管理资源</st>
    <st c="6597">这些资源将会</st> <st c="6610">运行新建的业务应用程序，以便以受管理和受管控的方式使用，并与组织的 IT 政策对齐。</st>
    <st c="6745">在这一组中，我们会找到 DevOps 工程师，他们将负责管理业务解决方案的 DevOps 流程。</st> <st c="6875">他们将确保项目与
    DevOps 实践对齐，例如确保 CI/CD 管道正常运行，并确保业务解决方案的所有组件都</st> <st c="7049">得到正确的版本控制。</st>'
- en: <st c="7077">The following figure shows how the personas are all connected and
    work together to achieve the goal of building a</st> <st c="7192">business solution:</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7077">下图展示了各个角色如何相互连接并协作以实现构建</st> <st c="7192">业务解决方案的目标：</st>
- en: '![Figure 9.1 – The fusion development approach](img/B22208_09_1.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 融合开发方法](img/B22208_09_1.jpg)'
- en: <st c="7577">Figure 9.1 – The fusion development approach</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7577">图 9.1 – 融合开发方法</st>
- en: <st c="7621">Additionally, we should</st> <st c="7645">introduce two more personas
    in the fusion development approach that will bring benefit to the</st> <st c="7740">fusion
    team.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7621">此外，我们应该</st> <st c="7645">在融合开发方法中引入另外两个人物角色，这将为</st> <st c="7740">融合团队带来好处。</st>
- en: <st c="7752">The first one is the</st> **<st c="7774">fusion team leader</st>**<st
    c="7792">. Their role is to oversee</st> <st c="7818">the entire project development
    and coordinate team members, taking care of the communication and the</st> <st
    c="7920">project delivery.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7752">第一个角色是</st> **<st c="7774">融合团队领导</st>**<st c="7792">。他们的职责是监督</st>
    <st c="7818">整个项目的开发并协调团队成员，负责沟通和</st> <st c="7920">项目交付。</st>
- en: <st c="7937">The second one is the</st> **<st c="7960">solution architect</st>**
    <st c="7978">role.</st> <st c="7985">It is recommended to include</st> <st c="8013">a
    solution architect in the planning and designing phase of the project, as they
    will dive into the technical details and help with creating a high-level architectural
    design of the solution, take care of the design patterns, share recommendations
    on the tools and technology selection,</st> <st c="8301">and more.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7937">第二个角色是</st> **<st c="7960">解决方案架构师</st>** <st c="7978">角色。</st>
    <st c="7985">建议在项目的规划和设计阶段引入解决方案架构师，因为他们将深入研究技术细节并帮助创建解决方案的高级架构设计，关注设计模式，分享关于工具和技术选择的建议，</st>
    <st c="8301">等等。</st>
- en: <st c="8310">The recommendation for the fusion team size is very similar to
    the general recommendation for the agile team size.</st> <st c="8426">There is
    no one-size-fits-all; it will all depend on the project’s complexity and organizational
    maturity.</st> <st c="8533">However, we should keep the fusion teams</st> *<st
    c="8574">small</st>* <st c="8579">in size in order to maintain the autonomy and
    agility of</st> <st c="8637">the team.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8310">融合团队的规模建议与敏捷团队规模的普遍建议非常相似。</st> <st c="8426">没有一种适合所有的标准；这将取决于项目的复杂性和组织的成熟度。</st>
    <st c="8533">然而，我们应该保持融合团队的</st> *<st c="8574">小型</st>* <st c="8579">规模，以保持团队的自主性和敏捷性。</st>
    <st c="8637">团队。</st>
- en: <st c="8646">Somewhere between 5 and 7 people in a team is considered the appropriate
    agile team size.</st> <st c="8737">This is many times linked to Amazon’s</st>
    *<st c="8775">two-pizza rule</st>* <st c="8789">which states that the teams should
    be small enough to be fed by two pizzas.</st> <st c="8866">Smaller teams allow
    communication and collaboration to be efficient while maintaining agility.</st>
    <st c="8961">This includes the ability to rapidly adapt to the challenges the
    team is facing, without introducing</st> <st c="9062">necessary bottlenecks.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8646">团队规模在5到7人之间被认为是合适的敏捷团队规模。</st> <st c="8737">这通常与亚马逊的</st> *<st
    c="8775">“两块披萨规则”</st>* <st c="8789">有关，该规则表示团队应该足够小，能够被两块披萨喂饱。</st> <st c="8866">小型团队有助于提高沟通和协作效率，同时保持敏捷性。</st>
    <st c="8961">这包括迅速适应团队面临的挑战的能力，而不会引入</st> <st c="9062">必要的瓶颈。</st>
- en: <st c="9084">The fusion team</st> <st c="9100">itself may be a temporary,</st>
    **<st c="9128">short-lived team</st>**<st c="9144">. Its purpose could be to solve
    a particular business problem and once this is done, the team disperses and team
    members continue their normal work routine – for example, citizen developers,
    who could be business users and business analysts, will continue their work, while
    software developers might go back to another traditional software</st> <st c="9484">development
    project.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9084">融合团队</st> <st c="9100">本身可能是一个临时的，</st> **<st c="9128">短期团队</st>**<st
    c="9144">。它的目的是解决一个特定的业务问题，一旦完成，团队解散，团队成员继续他们的正常工作例程——例如，公民开发者，可能是业务用户和业务分析师，将继续他们的工作，而软件开发人员可能会回到另一个传统的软件</st>
    <st c="9484">开发项目。</st>
- en: <st c="9504">As mentioned, in some ways, fusion development</st> <st c="9551">overlaps
    with an agile culture.</st> <st c="9584">The fusion development approach follows
    the lean methodology, which we described in</st> [*<st c="9668">Chapter 1</st>*](B22208_01.xhtml#_idTextAnchor014)<st
    c="9677">. The idea of the lean methodology is to focus on delivering value in
    a fast iterative development.</st> <st c="9777">Fusion teams can work in sprints
    to track and deliver work, using DevOps tools and project planning tools, such
    as</st> <st c="9892">Azure Boards.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9504">如前所述，在某些方面，融合开发</st> <st c="9551">与敏捷文化有所重叠。</st> <st c="9584">融合开发方法遵循精益方法论，我们在</st>
    [*<st c="9668">第1章</st>*](B22208_01.xhtml#_idTextAnchor014)<st c="9677">中进行了描述。精益方法论的理念是专注于在快速迭代的开发中交付价值。</st>
    <st c="9777">融合团队可以在冲刺中工作，以跟踪和交付工作，使用 DevOps 工具和项目规划工具，例如</st> <st c="9892">Azure
    Boards。</st>
- en: <st c="9905">Common examples of the fusion development approach in Power Platform</st>
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="9905">Power Platform 中融合开发方法的常见示例</st>
- en: <st c="9974">Fusion teams come together to solve business problems.</st> <st
    c="10030">During the planning and design phase, these challenges are thought through
    and tasks are divided between the stakeholders.</st> <st c="10153">Next, we will
    provide a couple of examples of how, with a fusion approach, pro-developers and
    citizen developers can tackle these problems with</st> <st c="10297">technological
    solutions.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9974">融合团队汇聚在一起解决业务问题。</st> <st c="10030">在规划和设计阶段，这些挑战被深思熟虑，任务在利益相关者之间分配。</st>
    <st c="10153">接下来，我们将提供几个例子，展示通过融合方法，专业开发人员和公民开发人员如何通过</st> <st c="10297">技术解决方案来解决这些问题。</st>
- en: <st c="10321">Custom connector to backend API</st>
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="10321">自定义连接器到后端 API</st>
- en: <st c="10353">We often</st> <st c="10363">see in organizations that there are
    already a set of systems and services that are being utilized in legacy applications
    and business processes.</st> <st c="10508">If we wish to modernize only our frontend
    application or build an entirely new application from scratch, but utilize some
    of the backend services, we can use custom connectors in Power Platform to connect
    backend services with the Power Platform applications.</st> <st c="10768">Building
    custom connectors in Power Platform helps organizations unlock access to those
    APIs from different Power Platform services and allows makers to reuse them for
    any potential</st> <st c="10950">new scenario.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10353">我们经常</st> <st c="10363">在组织中看到，已经有一套系统和服务正在被旧有应用程序和业务流程所使用。</st>
    <st c="10508">如果我们只希望现代化前端应用程序或从头开始构建一个全新的应用程序，但利用一些后端服务，我们可以在 Power Platform
    中使用自定义连接器，将后端服务与 Power Platform 应用程序连接起来。</st> <st c="10768">在 Power Platform
    中构建自定义连接器可以帮助组织解锁对这些 API 的访问，并允许开发者在任何潜在的</st> <st c="10950">新场景中重用它们。</st>
- en: <st c="10963">If we are building new APIs, we can keep in mind that they might
    be used in Power Platform.</st> <st c="11056">Therefore, building and using custom
    connectors is a common practice when building applications, flows, and copilots
    with Power Platform services.</st> <st c="11203">From the roles perspective, as
    an example, we might see professional developers building new Web APIs, citizen
    developers utilizing them in Power Apps applications, and IT operations taking
    control of managing Power Platform environments, building data loss prevention
    policies, and describing</st> <st c="11496">required infrastructure, using an</st>
    **<st c="11531">infrastructure as code</st>** <st c="11553">(</st>**<st c="11555">IaC</st>**<st
    c="11558">) approach, which will be used to provision the required infrastructure,
    including Azure API Management, to run supporting services.</st> <st c="11692">DevOps
    engineers would, together with pro-developers, make sure that the CI/CD pipelines
    are configured to build and deploy applications and APIs in an</st> <st c="11844">automated
    way.</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10963">如果我们正在构建新的 API，我们可以记住它们可能会在 Power Platform 中使用。</st> <st c="11056">因此，在构建应用程序、流程和助手时，构建和使用自定义连接器是一种常见做法，尤其是在使用
    Power Platform 服务时。</st> <st c="11203">从角色的角度来看，举个例子，我们可能会看到专业开发人员构建新的 Web API，公民开发者在
    Power Apps 应用程序中使用它们，IT 运维人员则负责管理 Power Platform 环境，构建数据丢失防护策略，并描述</st> <st c="11496">所需的基础设施，使用</st>
    **<st c="11531">基础设施即代码</st>** <st c="11553">(</st>**<st c="11555">IaC</st>**<st
    c="11558">) 方法，这将用于配置所需的基础设施，包括 Azure API 管理，以运行支持服务。</st> <st c="11692">DevOps
    工程师将与专业开发人员一起，确保 CI/CD 管道已配置好，以自动化的方式构建和部署应用程序和 API。</st>
- en: <st c="11858">Once a custom connector is built and deployed to Power Platform,
    we can reuse it in Power Automate to bring the capabilities of our legacy systems
    and services into the business logic that the</st> <st c="12052">Power Automate
    flow</st> <st c="12072">is implementing.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11858">一旦自定义连接器构建并部署到 Power Platform，我们可以在 Power Automate 中重用它，将我们旧有系统和服务的能力引入到</st>
    <st c="12052">Power Automate 流程</st> <st c="12072">所实现的业务逻辑中。</st>
- en: <st c="12088">Copilot Studio</st> <st c="12103">now also offers the ability
    to use connectors, including custom connectors directly within the</st> <st c="12199">custom
    copilot.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12088">Copilot Studio</st> <st c="12103">现在还提供了在自定义助手中直接使用连接器，包括自定义连接器的能力。</st>
- en: <st c="12214">Extending with PCF control</st>
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="12214">通过 PCF 控件扩展</st>
- en: <st c="12241">Sometimes, controls that are available out of the box in Power
    Pages or Power Apps, canvas, and</st> <st c="12338">model-driven apps might not
    be enough.</st> <st c="12377">Maybe we are looking for a graphically richer component
    or just a custom component that does a very specific job.</st> <st c="12491">In
    this case, we can reach out to pro-developers</st> <st c="12539">to support us
    by building custom code components with</st> **<st c="12594">Power Apps Component
    Framework</st>** <st c="12624">(</st>**<st c="12626">PCF</st>**<st c="12629">).</st>
    <st c="12633">PCF components are reusable and enrich the</st> <st c="12676">user
    experience.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12241">有时，Power Pages 或 Power Apps 画布和</st> <st c="12338">模型驱动应用中提供的控件可能不足以满足需求。</st>
    <st c="12377">也许我们正在寻找一个图形上更丰富的组件，或者只是一个执行特定任务的自定义组件。</st> <st c="12491">在这种情况下，我们可以联系专业开发人员</st>
    <st c="12539">支持我们通过使用</st> **<st c="12594">Power Apps 组件框架</st>** <st c="12624">(</st>**<st
    c="12626">PCF</st>**<st c="12629">) 构建自定义代码组件。</st> <st c="12633">PCF 组件是可重用的，并能增强</st>
    <st c="12676">用户体验。</st>
- en: <st c="12692">This is another good example of where pro-developers utilize their
    skills in software development.</st> <st c="12792">By using the TypeScript</st>
    <st c="12815">programming language, they develop a component that citizen developers
    can add to their applications built in Power Apps or websites built with Power
    Pages, to improve the user experience or enable certain additional</st> <st c="13033">business
    scenarios.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12692">这是另一个很好的例子，展示了专业开发人员如何运用他们的软件开发技能。</st> <st c="12792">通过使用 TypeScript</st>
    <st c="12815">编程语言，他们开发了一个组件，市民开发人员可以将其添加到他们在 Power Apps 中构建的应用程序或在 Power Pages
    中构建的网站中，以改善用户体验或实现某些额外的</st> <st c="13033">业务场景。</st>
- en: <st c="13052">While the previous example with custom connectors allowed pro-developers
    to be almost separated from Power Platform as they were focusing only on Web APIs,
    with code</st> <st c="13218">components, pro-developers should know about Power
    Platform since each application type (canvas, model-driven, or website/portal)
    has its own set of development best practices</st> <st c="13395">and limitations.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13052">虽然之前使用自定义连接器的示例让专业开发人员几乎可以与 Power Platform 分离，因为他们只关注 Web API
    和代码组件，但专业开发人员应该了解 Power Platform，因为每种应用类型（画布应用、模型驱动应用或网站/门户）都有其独特的开发最佳实践</st>
    <st c="13218">和限制。</st>
- en: <st c="13411">Enabling complex skills in custom copilots</st>
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="13411">在自定义助理中启用复杂技能</st>
- en: <st c="13454">Another</st> <st c="13463">example of the fusion approach is related
    to building custom copilots or bots in</st> <st c="13544">Copilot Studio.</st>
    <st c="13560">Copilot Studio allows extending capabilities of custom copilots
    with Power Automate flows, connectors, plugins, and Copilot framework skills.</st>
    <st c="13702">If using existing connectors and building flows that integrate with
    Copilot Studio is something that can be done by a citizen developer, building
    skill actions requires the involvement</st> <st c="13887">of pro-developers.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13454">另一个</st> <st c="13463">融合方法的例子与在</st> <st c="13544">Copilot Studio
    中构建自定义助理或机器人有关。</st> <st c="13560">Copilot Studio 允许通过 Power Automate 流程、连接器、插件和
    Copilot 框架技能扩展自定义助理的功能。</st> <st c="13702">如果使用现有连接器并构建与 Copilot Studio 集成的流程是市民开发人员可以完成的事情，那么构建技能操作则需要专业开发人员的参与。</st>
    <st c="13887">。</st>
- en: <st c="13905">A skill</st> <st c="13913">is a bot that can perform a set of
    actions for another bot/skill consumer, which is often a user-facing bot.</st>
    <st c="14023">It supports multi-turn operations, such as making a product order,
    as opposed to integrations with Power Automate flows, which allow single-turn
    operations, such as getting the status of</st> <st c="14210">a parcel.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13905">技能</st> <st c="13913">是一个可以为另一个机器人/技能消费者执行一系列操作的机器人，通常是面向用户的机器人。</st>
    <st c="14023">它支持多轮操作，例如进行产品订单，而与 Power Automate 流程集成的则仅支持单轮操作，例如获取</st> <st c="14210">包裹的状态。</st>
- en: <st c="14219">In this case, pro-developers will be using the Copilot framework
    SDK to build a skill that will be then used by citizen developers in a user-facing
    custom copilot bot that will be built in</st> <st c="14409">Copilot Studio.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14219">在这种情况下，专业开发人员将使用 Copilot 框架 SDK 构建一个技能，然后该技能将在自定义助理机器人中由市民开发人员使用，该机器人将在</st>
    <st c="14409">Copilot Studio 中构建。</st>
- en: <st c="14424">All these examples have one thing in common – reusability.</st>
    <st c="14484">Let’s take a look at how building a catalog in Power Platform can
    help with the discoverability and reusability of the</st> <st c="14603">built
    components.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14424">所有这些示例有一个共同点——可重用性。</st> <st c="14484">让我们看看在 Power Platform 中构建目录如何帮助组件的可发现性和可重用性。</st>
- en: <st c="14620">Empowering collaboration with open source development practices</st>
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="14620">通过开源开发实践增强协作</st>
- en: <st c="14684">Organizations will move at a rapid</st> <st c="14719">pace to
    implement</st> <st c="14737">new applications, flows, or chatbots.</st> <st c="14776">Fusion
    teams will develop many components in Power Platform that can be reusable in other
    projects instead of wasting time on reinventing the wheel.</st> <st c="14925">How
    can we remove silos in the organizations and empower any developer, no matter
    whether they are pro-developers or citizen developers, to understand what has
    already been done and allow them to reuse that in their own projects?</st> <st
    c="15155">Before answering this question, let us step back a bit and see how this
    has been solved in the traditional software</st> <st c="15271">development world.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14684">组织将以快速的</st> <st c="14719">速度实施</st> <st c="14737">新应用、流程或聊天机器人。</st>
    <st c="14776">Fusion 团队将在 Power Platform 中开发许多可以在其他项目中重用的组件，而不是浪费时间重新发明轮子。</st>
    <st c="14925">我们如何消除组织中的信息孤岛，赋能任何开发者，无论是专业开发者还是公民开发者，让他们了解已经完成的工作，并允许他们在自己的项目中重用这些成果呢？</st>
    <st c="15155">在回答这个问题之前，让我们稍微退一步，看看传统软件</st> <st c="15271">开发世界是如何解决这个问题的。</st>
- en: <st c="15289">Not too long ago, many organizations</st> <st c="15326">were very
    closed, independently</st> <st c="15358">working on projects without collaboration.</st>
    <st c="15402">This led to duplicated efforts and inefficiencies in the development
    processes.</st> <st c="15482">Teams were isolated and collaboration and communication
    were very poor or non-existent.</st> <st c="15570">We also sometimes experienced
    resistance to new ideas or practices that could lead to changing the way</st>
    <st c="15673">teams operated.</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15289">不久前，许多组织</st> <st c="15326">都非常封闭，独立</st> <st c="15358">进行项目工作，缺乏合作。</st>
    <st c="15402">这导致了重复的工作和开发过程中的低效率。</st> <st c="15482">团队之间相互隔离，合作和沟通非常差，甚至根本不存在。</st>
    <st c="15570">我们有时也会遇到对新想法或做法的抵触，这些新方法可能会改变团队的运作方式。</st>
- en: <st c="15688">However, if we look at the software development practices in the
    open source world, we can see how open source software is potentially shared with
    anyone, open for use and modifications.</st> <st c="15876">Practically anyone
    can review the project, and modify and reuse the open source software.</st> <st
    c="15966">The goal of such an approach is to build code that is more reliable</st>
    <st c="16034">and better.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15688">然而，如果我们看看开源世界中的软件开发实践，我们可以看到开源软件如何可能与任何人共享，开放供使用和修改。</st> <st
    c="15876">几乎任何人都可以审查项目，修改和重用开源软件。</st> <st c="15966">这种方法的目标是构建更可靠</st> <st c="16034">和更优质的代码。</st>
- en: <st c="16045">This is where we need to introduce</st> **<st c="16081">InnerSource</st>**<st
    c="16092">. InnerSource is a development</st> <st c="16122">methodology that takes
    the good practices of open source software development and applies them to a closed
    group – employees of an organization.</st> <st c="16268">This would mean that
    software development projects become private open-sourced projects of</st> <st
    c="16359">an organization.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16045">这时我们需要引入</st> **<st c="16081">InnerSource</st>**<st c="16092">。InnerSource
    是一种开发</st> <st c="16122">方法论，它将开源软件开发的优秀实践应用到一个封闭的群体——组织的员工中。</st> <st c="16268">这意味着软件开发项目将成为组织的私有开源项目。</st>
    <st c="16359">一个组织的项目。</st>
- en: <st c="16375">The interesting thing is that this kind of development approach,
    which uses DevOps tools such as Azure DevOps and GitHub, can be used for any kind
    of project, even outside of</st> <st c="16551">software development.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16375">有趣的是，这种使用 DevOps 工具（如 Azure DevOps 和 GitHub）的开发方式，可以用于任何类型的项目，甚至是软件开发之外的项目。</st>
- en: <st c="16572">InnerSource brings a modern approach to software development and
    helps us to remove challenges that older and more rigid ways of building proprietary
    software have on an organization.</st> <st c="16757">Collaborating openly in the
    organization will help improve innovation since more people can collaborate and
    contribute to the project.</st> <st c="16892">Developers don’t always have to
    build projects from</st> <st c="16943">the beginning, as InnerSource helps with</st>
    **<st c="16985">discoverability</st>**<st c="17000">. It may be that something
    already exists within our organization that can be reused.</st> <st c="17086">This
    will drive rapid development, decrease development costs, and improve time to
    market.</st> <st c="17177">It will improve collaboration and, most importantly,
    foster a culture</st> <st c="17247">of openness.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16572">InnerSource为软件开发带来了现代化的方法，帮助我们消除传统专有软件在组织中带来的挑战。</st> <st c="16757">在组织中开放地合作将有助于改进创新，因为更多人可以参与项目并做出贡献。</st>
    <st c="16892">开发人员不必总是从头开始构建项目，因为InnerSource有助于</st> **<st c="16985">发现性</st>**<st
    c="17000">。也许我们的组织内已经存在可以重复使用的东西。</st> <st c="17086">这将推动快速开发，降低开发成本，提高上市时间。</st>
    <st c="17177">它将改善协作，并且最重要的是，培养开放的文化。</st>
- en: <st c="17259">The annual research that is done by the</st> <st c="17299">InnerSource
    Commons Foundation, called the</st> *<st c="17343">State of InnerSource Report</st>*
    <st c="17370">(available at</st> [<st c="17385">https://innersourcecommons.org/</st>](https://innersourcecommons.org/)<st
    c="17416">), identifies the benefits and blockers of InnerSource.</st> <st c="17473">Common
    blockers for not applying InnerSource practices are due to the organizational
    culture, siloed thinking, and lack of awareness and familiarity with Innersource
    principles.</st> <st c="17651">This is why it is important to make sure developers
    get familiar with these practices and there is a buy-in for this strategy in the
    organization, which will help us allocate resources and time for implementing
    and unlocking the benefits of InnerSource within</st> <st c="17911">the organization.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17259">InnerSource Commons Foundation每年进行的研究称为</st> *<st c="17343">InnerSource
    状态报告</st>* <st c="17370">(可在</st> [<st c="17385">https://innersourcecommons.org/</st>](https://innersourcecommons.org/)<st
    c="17416">找到)，它识别了InnerSource的好处和阻碍。</st> <st c="17473">未应用InnerSource实践的常见阻碍包括组织文化、独立思维以及对InnerSource原则的认知和熟悉度不足。</st>
    <st c="17651">因此，确保开发人员熟悉这些实践，并在组织中推广这一策略至关重要，这将有助于我们分配资源和时间来实施和释放InnerSource的好处。</st>
    <st c="17911">该组织内。</st>
- en: <st c="17928">These good practices can also be applied to the low-code/no-code</st>
    <st c="17994">development approach.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17928">这些良好的实践也可以应用于低代码/无代码</st> <st c="17994">开发方法。</st>
- en: <st c="18015">Fusion development teams – more specifically, pro-developers and
    DevOps engineers – perform many tasks with DevOps tools, such as Azure DevOps
    and GitHub, where the InnerSource approach is at the heart of the product.</st>
    <st c="18234">Tools such as Azure Boards or GitHub Issues enable developers to
    bring up ideas for new features, report bugs in the product, comment on tasks,
    and more.</st> <st c="18388">Pull request mechanisms enable better results, as
    build validations and peer reviews make sure the final artifact meets all requirements.</st>
    <st c="18526">To further support good DevOps practices, companies can expand their
    set of tools with products such as Microsoft Teams to improve communication and
    collaboration of fusion teams and</st> <st c="18709">implement ChatOps.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18015">融合开发团队，尤其是专业开发人员和DevOps工程师，使用诸如Azure DevOps和GitHub等DevOps工具执行许多任务，其中InnerSource方法是产品的核心。</st>
    <st c="18234">Azure Boards或GitHub Issues等工具使开发人员能够提出新功能的想法，报告产品中的错误，评论任务等。</st>
    <st c="18388">拉取请求机制通过构建验证和同行审查确保最终生成物符合所有要求，从而实现更好的结果。</st> <st c="18526">为了进一步支持良好的DevOps实践，公司可以通过产品如Microsoft
    Teams扩展其工具集，以改进融合团队的沟通和协作，并</st> <st c="18709">实现ChatOps。</st>
- en: <st c="18727">Services and features of DevOps tools</st> <st c="18765">are built
    in a way that helps</st> <st c="18795">organizations enable and foster InnerSource
    more easily.</st> <st c="18853">For an organization to understand whether they
    are moving toward the desired goal, they should implement periodic reviews to
    understand how InnerSource is</st> <st c="19008">being adopted.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18727">DevOps 工具的服务和功能</st> <st c="18765">是以帮助</st> <st c="18795">组织更轻松地实现和促进
    InnerSource 的方式构建的。</st> <st c="18853">为了让组织了解是否朝着目标前进，他们应该实施定期评审，以了解 InnerSource
    的</st> <st c="19008">采用情况。</st>
- en: <st c="19022">Building a catalog process</st>
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="19022">构建目录流程</st>
- en: <st c="19049">When working on a business solution for Power Platform, we should
    also consider how to follow InnerSource best practices, allow fusion teams to
    share their work, and allow other teams to reuse components and built templates.</st>
    <st c="19275">While opening projects in Azure DevOps and GitHub would allow pro-developers
    to understand which projects are available in the organizations, we cannot expect
    our business users to follow the same steps as pro-developers.</st> <st c="19497">There
    is another way to share our work with anyone in</st> <st c="19551">the organization.</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19049">在为 Power Platform 开发业务解决方案时，我们还应该考虑如何遵循 InnerSource 最佳实践，允许融合团队共享他们的工作，并允许其他团队重用组件和构建的模板。</st>
    <st c="19275">虽然在 Azure DevOps 和 GitHub 中打开项目可以让专业开发人员了解组织中有哪些项目，但我们不能指望业务用户按照与专业开发人员相同的步骤进行操作。</st>
    <st c="19497">还有一种方法可以将我们的工作分享给组织中的任何人。</st> <st c="19551"> </st>
- en: <st c="19568">The</st> **<st c="19573">catalog</st>** <st c="19580">in Power
    Platform is the single source</st> <st c="19619">of truth of all components and
    templates that were deployed to the catalog to be cataloged and reused.</st> <st
    c="19723">It is presented as a model-driven app within Power Apps and it helps
    us understand what is already available in the organization.</st> <st c="19853">The
    Power Platform catalog is not a version control system and does not replace DevOps
    tools for version control and CI/CD pipelines.</st> <st c="19987">However, it
    does enhance the ALM/DevOps processes as it supports the automation scenarios
    through the PAC CLI commands, as we have seen in an example in</st> [*<st c="20140">Chapter
    6</st>*](B22208_06.xhtml#_idTextAnchor103)<st c="20149">.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19568">Power Platform 中的</st> **<st c="19573">目录</st>** <st c="19580">是所有已部署到目录并需要进行目录化和重用的组件和模板的唯一真实来源。</st>
    <st c="19619">它以模型驱动应用的形式出现在 Power Apps 中，帮助我们了解组织中已经有哪些资源可用。</st> <st c="19853">Power
    Platform 目录不是一个版本控制系统，不能替代用于版本控制和 CI/CD 流水线的 DevOps 工具。</st> <st c="19987">然而，它确实增强了
    ALM/DevOps 流程，因为它支持通过 PAC CLI 命令进行自动化场景，就像我们在</st> [*<st c="20140">第六章</st>*](B22208_06.xhtml#_idTextAnchor103)
    中的示例所看到的那样。</st>
- en: <st c="20150">Components and templates are represented in the catalog as items.</st>
    <st c="20217">Pro-developers and citizen developers will use the catalog to understand
    which existing items are available in the organization and who has published them.</st>
    <st c="20373">It will serve also to find and reuse components in new projects
    or start by using the built templates.</st> <st c="20476">On the other hand, the
    IT operations team will use the management capabilities of the catalog to control
    the usage of code components</st> <st c="20610">and templates.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20150">组件和模板在目录中作为项目呈现。</st> <st c="20217">专业开发人员和公民开发人员将使用目录了解组织中现有的项目，以及谁发布了这些项目。</st>
    <st c="20373">它还将用于在新项目中查找和重用组件，或从现有模板开始。</st> <st c="20476">另一方面，IT 运维团队将使用目录的管理功能来控制代码组件</st>
    <st c="20610">和模板的使用。</st>
- en: <st c="20624">We recommend starting by installing one catalog in the organization.</st>
    <st c="20694">However, there are cases when an organization needs to install more
    than one catalog in the Power Platform tenant – for example, if an organization
    has very sensitive projects that have to be isolated from others.</st> <st c="20908">In
    this case, another catalog should be installed to provide the level of</st> <st
    c="20982">isolation needed.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20624">我们建议首先在组织中安装一个目录。</st> <st c="20694">然而，在某些情况下，组织需要在 Power Platform
    租户中安装多个目录——例如，如果一个组织有非常敏感的项目，必须与其他项目隔离。</st> <st c="20908">在这种情况下，应该安装另一个目录，以提供所需的</st>
    <st c="20982">隔离级别。</st>
- en: <st c="20999">Preview functionality</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20999">预览功能</st>
- en: <st c="21021">Note that as</st> <st c="21034">of the time of writing,</st> **<st
    c="21059">Catalog in Power Platform</st>** <st c="21084">is a preview feature
    and so has some limitations in functionalities, such as, for example, that it
    cannot be utilized in an environment that uses a customer-managed key.</st> <st
    c="21255">During preview, the catalog can be used in all types of environments,
    but when released to general</st> <st c="21353">availability, this will only be
    available in the</st> **<st c="21403">managed</st>** <st c="21410">environments.</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21021">请注意，</st> <st c="21034">截至撰写本文时，</st> **<st c="21059">Power Platform中的目录</st>**
    <st c="21084">是一个预览功能，因此在功能上有一些限制，例如它不能在使用客户管理密钥的环境中使用。</st> <st c="21255">在预览阶段，目录可以在所有类型的环境中使用，但发布到正式版后，这将仅在</st>
    **<st c="21403">受管</st>** <st c="21410">环境中可用。</st>
- en: <st c="21424">Catalog process</st>
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="21424">目录过程</st>
- en: <st c="21440">Catalog in Power Platform</st> <st c="21466">follows a process
    life cycle from the creation of catalog items to the acquisition phase when a
    new team reuses the previously developed</st> <st c="21604">catalog item.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21440">Power Platform中的目录</st> <st c="21466">遵循从目录项创建到获取阶段的生命周期，新的团队将在此阶段重复使用之前开发的</st>
    <st c="21604">目录项。</st>
- en: <st c="21617">It starts with the fusion team of pro-developers and citizen developers
    creating components and building catalog items with all the components that solved
    their initial business challenges.</st> <st c="21808">These catalog items also
    include configuration parameters that would be required for the catalog item to
    be</st> <st c="21916">properly configured.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21617">这一过程始于由专业开发人员和公民开发者组成的融合团队，创建组件并构建包含解决初始业务挑战的所有组件的目录项。</st> <st
    c="21808">这些目录项还包括在正确配置目录项时所需的配置参数。</st> <st c="21916">以确保目录项能被正确配置。</st>
- en: <st c="21936">These catalog items are then submitted to the catalog for reuse
    purposes.</st> <st c="22011">Once submitted, IT administrators and line-of-business
    approvers will review these new catalog items and approve</st> <st c="22124">them
    accordingly.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21936">这些目录项随后将提交到目录中，以供重新使用。</st> <st c="22011">一旦提交，IT管理员和业务线审批人员将审核这些新的目录项并相应地批准它们。</st>
    <st c="22124">并据此进行批准。</st>
- en: <st c="22141">Other pro-developers and app makers</st> <st c="22177">will use
    the catalog to find existing solutions and templates.</st> <st c="22241">Those
    catalog items that seem fit for their business problem will be reused.</st> <st
    c="22318">In order to finish the configuration, makers have to provide all necessary
    configuration parameters and establish required connections.</st> <st c="22454">After
    that, this catalog item is successfully provisioned in their environment.</st>
    <st c="22534">Now, they can reuse the components in their own solutions that they</st>
    <st c="22602">are building.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22141">其他专业开发人员和应用程序开发者</st> <st c="22177">将使用该目录查找现有的解决方案和模板。</st> <st
    c="22241">那些看似适合他们业务问题的目录项将被重新使用。</st> <st c="22318">为了完成配置，开发者必须提供所有必要的配置参数并建立所需的连接。</st>
    <st c="22454">之后，该目录项将在他们的环境中成功配置。</st> <st c="22534">现在，他们可以在自己构建的解决方案中重复使用这些组件。</st>
    <st c="22602">他们正在构建自己的解决方案。</st>
- en: <st c="22615">Starting with the Catalog Manager</st>
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="22615">从目录管理员开始</st>
- en: <st c="22649">Before we can start using Catalog</st> <st c="22683">in Power
    Platform, we must first install it from Microsoft AppSource.</st> <st c="22754">We
    should have a</st> *<st c="22771">system administrator</st>* <st c="22791">security
    role assigned in the environment to be able to install the Catalog Manager.</st>
    <st c="22877">The Catalog Manager will be installed in a Dataverse environment,
    which should have a minimum database version of</st> `<st c="22991">9.2.22122.00148</st>`<st
    c="23006">. We can check the Dataverse version in the</st> **<st c="23050">Version</st>**
    <st c="23057">card inside the environment settings.</st> <st c="23096">We need
    to first open</st> **<st c="23118">Power Platform admin center</st>** <st c="23145">|</st>
    **<st c="23148">Environments</st>** <st c="23160">and then select the environment
    and the</st> **<st c="23201">Version</st>** <st c="23208">card.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22649">在我们开始在 Power Platform 中使用目录之前</st> <st c="22683">，我们必须首先从 Microsoft
    AppSource 安装它。</st> <st c="22754">我们应该在环境中分配一个</st> *<st c="22771">系统管理员</st>*
    <st c="22791">安全角色，以便能够安装目录管理器。</st> <st c="22877">目录管理器将安装在一个 Dataverse 环境中，该环境的数据库版本应至少为</st>
    `<st c="22991">9.2.22122.00148</st>`<st c="23006">。我们可以在环境设置中的</st> **<st c="23050">版本</st>**
    <st c="23057">卡片上查看 Dataverse 版本。</st> <st c="23096">我们首先需要打开</st> **<st c="23118">Power
    Platform 管理中心</st>** <st c="23145">|</st> **<st c="23148">环境</st>** <st c="23160">，然后选择该环境，并选择</st>
    **<st c="23201">版本</st>** <st c="23208">卡片。</st>
- en: <st c="23214">We recommend having a separate Power Platform environment that
    will be used for the catalog.</st> <st c="23308">This allows anyone to access
    the environment and review the catalog items as well as install catalog items
    from this catalog to</st> <st c="23436">their environments.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23214">我们建议为目录创建一个单独的 Power Platform 环境。</st> <st c="23308">这样，任何人都可以访问该环境并查看目录项，也可以将目录中的项安装到他们的环境中。</st>
- en: <st c="23455">Once we have cleared all the prerequisites, we can proceed to</st>
    <st c="23518">the installation.</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23455">一旦我们完成所有前提条件的检查，就可以继续进行</st> <st c="23518">安装。</st>
- en: <st c="23535">We have the option to install the Catalog Manager via the PAC
    CLI.</st> <st c="23603">In order to do this, we first connect to the Power Platform
    environment where we would like to install it.</st> <st c="23710">There, we use</st>
    `<st c="23724">pac application list</st>` <st c="23744">to find all applications
    that are available in our tenant.</st> <st c="23804">One of these will be</st>
    `<st c="23881">mspcat_CatalogManager</st>` <st c="23902">or a GUID of</st> `<st
    c="23916">83a35943-cb41-4266-b7d2-81d60f383695</st>`<st c="23952">. This unique
    name or GUID can be used to install the application in the current environment
    by using</st> `<st c="24054">pac application install --application-name mspcat_CatalogManager</st>`<st
    c="24118">. To install the application to a different environment, switch</st>
    `<st c="24182">--environment <ENV_ID></st>` <st c="24204">with the appropriate
    environment ID or URL.</st> <st c="24249">To verify that we have installed the
    catalog in our tenant, we can use</st> `<st c="24320">pac admin list --application
    83a35943-cb41-4266-b7d2-81d60f383695</st>`<st c="24385">, which will return information
    on the environments where Catalog Manager</st> <st c="24459">is installed.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23535">我们可以选择通过 PAC CLI 安装目录管理器。</st> <st c="23603">为了做到这一点，我们首先连接到我们希望安装目录管理器的
    Power Platform 环境。</st> <st c="23710">在该环境中，我们使用</st> `<st c="23724">pac application
    list</st>` <st c="23744">查找我们租户中所有可用的应用。</st> <st c="23804">其中之一将是</st> `<st c="23881">mspcat_CatalogManager</st>`
    <st c="23902">或 GUID 为</st> `<st c="23916">83a35943-cb41-4266-b7d2-81d60f383695</st>`<st
    c="23952">。这个唯一名称或 GUID 可以用来通过</st> `<st c="24054">pac application install --application-name
    mspcat_CatalogManager</st>`<st c="24118">安装应用到当前环境。</st> <st c="24182">要将应用安装到不同的环境中，使用</st>
    `<st c="24182">--environment <ENV_ID></st>` <st c="24204">并替换为适当的环境 ID 或 URL。</st>
    <st c="24249">为了验证我们是否已在租户中安装了目录，我们可以使用</st> `<st c="24320">pac admin list --application
    83a35943-cb41-4266-b7d2-81d60f383695</st>`<st c="24385">，它将返回安装了目录管理器的环境信息。</st>
- en: <st c="24472">If we would like to install this application using the UI, we
    will need to use this link directly to install it:</st> [<st c="24586">https://appsource.microsoft.com/product/dynamics-365/powerappssvc.catalogmanager-preview?flightCodes=dde212e5c66047c59bf2b346c419cef6</st>](https://appsource.microsoft.com/product/dynamics-365/powerappssvc.catalogmanager-preview?flightCodes=dde212e5c66047c59bf2b346c419cef6)<st
    c="24719">. When prompted to sign in to Microsoft AppSource, we need to do so
    with our system administrator and confirm the installation by clicking</st> **<st
    c="24858">Get it now</st>**<st c="24868">. This takes us to</st> **<st c="24887">Dynamics
    365 apps</st>** <st c="24904">inside</st> **<st c="24912">Power Platform admin
    center</st>** <st c="24939">to complete the installation process.</st> <st c="24978">As
    a final step, we need to select an environment in which this application will
    be installed.</st> <st c="25073">We need to agree with the terms and privacy statements
    and then we can click</st> **<st c="25150">Install</st>** <st c="25157">to install
    the app.</st> <st c="25178">The process</st> <st c="25189">of installation takes
    a couple</st> <st c="25221">of minutes.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24472">如果我们想通过 UI 安装此应用程序，我们需要直接使用此链接进行安装：</st> [<st c="24586">https://appsource.microsoft.com/product/dynamics-365/powerappssvc.catalogmanager-preview?flightCodes=dde212e5c66047c59bf2b346c419cef6</st>](https://appsource.microsoft.com/product/dynamics-365/powerappssvc.catalogmanager-preview?flightCodes=dde212e5c66047c59bf2b346c419cef6)<st
    c="24719">。当提示我们登录 Microsoft AppSource 时，我们需要使用系统管理员帐户登录并点击</st> **<st c="24858">立即获取</st>**<st
    c="24868">进行确认。这会将我们带到</st> **<st c="24887">Dynamics 365 应用</st>** <st c="24904">内的</st>
    **<st c="24912">Power Platform 管理中心</st>** <st c="24939">以完成安装过程。</st> <st c="24978">最后一步，我们需要选择一个环境来安装此应用程序。</st>
    <st c="25073">我们需要同意条款和隐私声明，然后可以点击</st> **<st c="25150">安装</st>** <st c="25157">来安装应用程序。</st>
    <st c="25178">安装过程</st> <st c="25189">大约需要几分钟时间。</st> <st c="25221">。</st>
- en: '![Figure 9.2 – Installing the Catalog Manager app](img/B22208_09_2.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 安装目录管理器应用](img/B22208_09_2.jpg)'
- en: <st c="25728">Figure 9.2 – Installing the Catalog Manager app</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25728">图 9.2 – 安装目录管理器应用</st>
- en: <st c="25775">The installation process installs a new Power Apps application.</st>
    <st c="25840">After installation is done, we will need to configure the catalog
    metadata.</st> <st c="25916">First, we need to run the Catalog Manager.</st> <st
    c="25959">Accessing the Catalog Manager is done through Power Apps.</st> <st c="26017">We
    can find the application in the list of apps in the corresponding environment.</st>
    <st c="26099">Simply go to</st> **<st c="26112">Power Apps</st>** <st c="26122">|</st>
    **<st c="26125">Apps</st>**<st c="26129">, hover over the</st> **<st c="26146">Power
    Platform Catalog Manager</st>** <st c="26176">app name, and click on the</st>
    *<st c="26204">play</st>* <st c="26208">icon to run the application, or click
    on the three dots next to the name and then click</st> **<st c="26297">Play</st>**
    <st c="26301">to run</st> <st c="26309">the application.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25775">安装过程会安装一个新的 Power Apps 应用程序。</st> <st c="25840">安装完成后，我们需要配置目录元数据。</st>
    <st c="25916">首先，我们需要运行目录管理器。</st> <st c="25959">访问目录管理器是通过 Power Apps 完成的。</st>
    <st c="26017">我们可以在相应环境的应用程序列表中找到此应用。</st> <st c="26099">只需进入</st> **<st c="26112">Power
    Apps</st>** <st c="26122">|</st> **<st c="26125">应用</st>**<st c="26129">，将鼠标悬停在</st>
    **<st c="26146">Power Platform 目录管理器</st>** <st c="26176">应用名称上，点击</st> *<st c="26204">播放</st>*
    <st c="26208">图标运行应用程序，或者点击名称旁边的三个点，再点击</st> **<st c="26297">播放</st>** <st c="26301">以运行</st>
    <st c="26309">应用程序。</st>
- en: <st c="26325">Now that we have the application running, we can configure metadata
    by opening the configuration group.</st> <st c="26430">In the left navigation
    bar, at the very bottom, click</st> **<st c="26484">Catalog</st>**<st c="26491">,
    which opens an option to select an area; from there, click</st> **<st c="26552">Settings</st>**<st
    c="26560">. This will open the configuration group, where we have options to configure</st>
    **<st c="26637">Catalog</st>**<st c="26644">,</st> **<st c="26646">Rule sets for
    PowerApps checker</st>**<st c="26677">,</st> **<st c="26679">Static Analysis Policies</st>**<st
    c="26703">, and</st> **<st c="26709">Configurations for PowerApps checker</st>**<st
    c="26745">. Clicking</st> **<st c="26756">Catalog</st>** <st c="26763">will open</st>
    **<st c="26774">Catalog Configuration</st>**<st c="26795">, as can be seen in</st>
    *<st c="26815">Figure 9</st>**<st c="26823">.3</st>*<st c="26825">. Here, we can
    change the catalog name, description, help link, and image to help us identify
    the catalog.</st> <st c="26932">On the right, in</st> **<st c="26949">Catalog
    Configuration</st>**<st c="26970">, we have the option to enable the catalog,
    allow unmanaged solutions (future feature plans) to be deployed to the catalog,
    and enable global auto-approval for the published catalog items on the catalog
    level.</st> <st c="27180">This final setting of auto-approval, if configured on
    a global level, will override</st> <st c="27263">the setting</st> <st c="27275">on
    the</st> <st c="27283">publisher level.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26325">现在我们已经启动了应用程序，可以通过打开配置组来配置元数据。</st> <st c="26430">在左侧导航栏的最底部，点击</st>
    **<st c="26484">目录</st>**<st c="26491">，这将打开一个选择区域的选项；从那里，点击</st> **<st c="26552">设置</st>**<st
    c="26560">。这将打开配置组，我们可以在这里配置</st> **<st c="26637">目录</st>**<st c="26644">，</st>
    **<st c="26646">PowerApps 检查器的规则集</st>**<st c="26677">，</st> **<st c="26679">静态分析策略</st>**<st
    c="26703">，和</st> **<st c="26709">PowerApps 检查器的配置</st>**<st c="26745">。点击</st>
    **<st c="26756">目录</st>** <st c="26763">将打开</st> **<st c="26774">目录配置</st>**<st
    c="26795">，如</st> *<st c="26815">图 9.3</st>*<st c="26823">所示。</st> <st c="26825">在这里，我们可以更改目录名称、描述、帮助链接和图像，以帮助我们识别该目录。</st>
    <st c="26932">在右侧的</st> **<st c="26949">目录配置</st>**<st c="26970">中，我们可以启用目录、允许未管理的解决方案（未来功能计划）部署到目录，并启用在目录级别发布的目录项目的全局自动审批。</st>
    <st c="27180">此最终设置的自动审批，如果在全局级别配置，将覆盖</st> <st c="27263">发布者级别</st> <st c="27275">的设置。</st>
- en: '![Figure 9.3 – Catalog metadata and configuration](img/B22208_09_3.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 目录元数据和配置](img/B22208_09_3.jpg)'
- en: <st c="27945">Figure 9.3 – Catalog metadata and configuration</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27945">图 9.3 – 目录元数据和配置</st>
- en: <st c="27992">To return to the main</st> **<st c="28015">Catalog</st>** <st
    c="28022">area, we can click on the</st> **<st c="28049">Home</st>** <st c="28053">navigation
    in the left navigation bar.</st> <st c="28093">Among other things, here we will
    find individual dashboards with action items, an</st> **<st c="28175">Approvals</st>**
    <st c="28184">section with all the approval requests,</st> **<st c="28225">Catalog</st>**
    <st c="28232">section with published catalog items, and the deployment history.</st>
    <st c="28299">Details of each section and explanation can be found</st> <st c="28352">here:</st>
    [<st c="28358">https://learn.microsoft.com/en-us/power-platform/developer/administer-catalog</st>](https://learn.microsoft.com/en-us/power-platform/developer/administer-catalog)<st
    c="28435">.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27992">要返回到主要的</st> **<st c="28015">目录</st>** <st c="28022">区域，我们可以点击左侧导航栏中的</st>
    **<st c="28049">主页</st>** <st c="28053">导航。</st> <st c="28093">在这里，我们将看到带有操作项的单独仪表板，包含所有审批请求的</st>
    **<st c="28175">审批</st>** <st c="28184">部分，包含已发布目录项的</st> **<st c="28225">目录</st>**
    <st c="28232">部分，以及部署历史记录。</st> <st c="28299">每个部分的详细信息和说明可以在</st> <st c="28352">这里找到：</st>
    [<st c="28358">https://learn.microsoft.com/en-us/power-platform/developer/administer-catalog</st>](https://learn.microsoft.com/en-us/power-platform/developer/administer-catalog)<st
    c="28435">。</st>
- en: <st c="28436">Publishing a new catalog item</st>
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="28436">发布新的目录项目</st>
- en: <st c="28466">Let’s say we have successfully</st> <st c="28497">built a solution
    that we would like to publish to a catalog and allow its reuse.</st> <st c="28579">To
    publish an item to the catalog, we need a solution or package deployer package
    with items that we wish to publish as well as a submission metadata</st> <st c="28729">JSON
    file.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28466">假设我们已经成功</st> <st c="28497">构建了一个我们希望发布到目录并允许其重用的解决方案。</st> <st
    c="28579">要将项目发布到目录，我们需要一个包含我们希望发布的项目的解决方案或包部署器包，并且还需要一个提交元数据</st> <st c="28729">JSON
    文件。</st>
- en: <st c="28739">We will be using the PAC CLI to perform operations with the catalog
    item.</st> <st c="28814">As we are already used to doing, we will start our terminal
    and run the</st> `<st c="28886">pac auth create</st>` <st c="28901">command to
    create an authentication profile (if we do not have one yet) or reuse an existing
    authentication profile.</st> <st c="29019">We can check the existing authentication
    profiles by using the</st> `<st c="29082">pac auth list</st>` <st c="29095">command.</st>
    <st c="29105">Keep in mind that when we need to connect to an environment with
    the catalog in which we would like to publish items, we use the</st> `<st c="29234">pac
    auth create –-environment</st>` <st c="29263">or</st> `<st c="29267">-env</st>`
    <st c="29271">switch with the name or ID of the environment in which the catalog</st>
    <st c="29339">is installed.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28739">我们将使用 PAC CLI 来操作目录项目。</st> <st c="28814">正如我们已经习惯的那样，我们将启动终端并运行</st>
    `<st c="28886">pac auth create</st>` <st c="28901">命令来创建一个认证配置文件（如果我们还没有的话）或重用现有的认证配置文件。</st>
    <st c="29019">我们可以使用</st> `<st c="29082">pac auth list</st>` <st c="29095">命令检查现有的认证配置文件。</st>
    <st c="29105">请记住，当我们需要连接到一个环境，以便在其中发布项目时，我们使用</st> `<st c="29234">pac auth create
    –-environment</st>` <st c="29263">或</st> `<st c="29267">-env</st>` <st c="29271">开关，并提供目录所在环境的名称或
    ID。</st>
- en: <st c="29352">Using</st> `<st c="29359">pac catalog list</st>` <st c="29375">will
    show us all published</st> <st c="29403">catalog items.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29352">使用</st> `<st c="29359">pac catalog list</st>` <st c="29375">将显示我们所有已发布的</st>
    <st c="29403">目录项目。</st>
- en: <st c="29417">Now, we are ready to publish new items to the catalog.</st> <st
    c="29473">We will use the</st> `<st c="29489">pac catalog create-submission</st>`
    <st c="29518">command to generate a default submission metadata JSON document
    called</st> `<st c="29590">submission.json</st>` <st c="29605">in the current
    operating folder of your terminal (to change the path, we can use the</st> `<st
    c="29691">--path</st>` <st c="29697">switch).</st> <st c="29707">We need to edit
    this file to prepare it for the catalog item that we plan</st> <st c="29781">to
    submit.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29417">现在，我们已经准备好将新的项目发布到目录中。</st> <st c="29473">我们将使用</st> `<st c="29489">pac
    catalog create-submission</st>` <st c="29518">命令生成一个默认的提交元数据 JSON 文件，名为</st> `<st
    c="29590">submission.json</st>` <st c="29605">，该文件位于终端当前操作目录中（要更改路径，我们可以使用</st>
    `<st c="29691">--path</st>` <st c="29697">开关）。</st> <st c="29707">我们需要编辑这个文件，为计划提交的目录项目做准备。</st>
- en: <st c="29791">Note</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29791">注意</st>
- en: <st c="29796">This command is also subject to change when this preview feature
    comes closer to general availability.</st> <st c="29900">Use</st> `<st c="29904">pac
    catalog --help</st>` <st c="29922">to find a list of all</st> <st c="29945">possible
    commands.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29796">当该预览功能接近正式发布时，这个命令也可能会发生变化。</st> <st c="29900">使用</st> `<st c="29904">pac
    catalog --help</st>` <st c="29922">可以查看所有</st> <st c="29945">可能的命令列表。</st>
- en: <st c="29963">The submission</st> <st c="29978">metadata JSON file contains
    submission attributes that we need to update to match our catalog item.</st> <st
    c="30079">An example file, created using the previous command, looks similar</st>
    <st c="30146">to this:</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29963">提交</st> <st c="29978">元数据 JSON 文件包含我们需要更新的提交属性，以使其与我们的目录项目匹配。</st>
    <st c="30079">使用之前的命令创建的示例文件类似于以下内容：</st>
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<st c="30728">From the submission metadata</st> <st c="30757">file, four attributes
    are required for submission: publisher, catalog item, engineering contact, and</st>
    <st c="30859">support contact.</st>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30728">从提交元数据</st> <st c="30757">文件中，提交时需要的四个属性为：发布者、目录项目、工程联系人和</st>
    <st c="30859">支持联系人。</st>
- en: <st c="30875">The publisher attributes are in the section in JSON described
    as</st> `<st c="30941">publisherDetails</st>`<st c="30957">. They are one or more
    Microsoft Entra ID groups, which will allow users who are part of that group to
    update catalog items in the future.</st> <st c="31096">When we think of</st> `<st
    c="31113">publisher</st>`<st c="31122">, this can be a fusion development team
    that is working on a specific project or a group of developers who are part of
    a specific department in the organization.</st> <st c="31284">We recommend providing</st>
    `<st c="31307">publisherID</st>` <st c="31318">and</st> `<st c="31323">publisherDisplayName</st>`<st
    c="31343">, as these are used to verify whether the publisher</st> <st c="31395">already
    exists.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30875">发布者属性位于 JSON 部分中，描述为</st> `<st c="30941">publisherDetails</st>`<st
    c="30957">。它们是一个或多个 Microsoft Entra ID 组，这将允许属于该组的用户在未来更新目录项。</st> <st c="31096">当我们提到</st>
    `<st c="31113">publisher</st>`<st c="31122">时，这可以是一个专注于特定项目的融合开发团队，或者是组织中某个特定部门的开发人员组。</st>
    <st c="31284">我们建议提供</st> `<st c="31307">publisherID</st>` <st c="31318">和</st>
    `<st c="31323">publisherDisplayName</st>`<st c="31343">，因为这些用于验证发布者</st> <st c="31395">是否已存在。</st>
- en: <st c="31410">The catalog item is the solution that we plan to publish.</st>
    <st c="31469">We need to provide</st> `<st c="31488">id</st>` <st c="31490">and</st>
    `<st c="31495">displayName</st>` <st c="31506">as well as</st> `<st c="31518">engineeringName</st>`
    <st c="31533">and</st> `<st c="31538">supportName</st>`<st c="31549">, as these
    are required attributes.</st> <st c="31585">The engineering contact helps those
    who would like to reuse the catalog item to understand who to contact in case
    of any additional questions about the item.</st> <st c="31743">The support name</st>
    <st c="31759">helps identify who can offer support if there are any technical
    issues with the</st> <st c="31840">catalog item.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31410">目录项是我们计划发布的解决方案。</st> <st c="31469">我们需要提供</st> `<st c="31488">id</st>`
    <st c="31490">和</st> `<st c="31495">displayName</st>` <st c="31506">以及</st> `<st
    c="31518">engineeringName</st>` <st c="31533">和</st> `<st c="31538">supportName</st>`<st
    c="31549">，因为这些是必需的属性。</st> <st c="31585">工程联系信息帮助那些希望重用该目录项的人了解如果有任何关于该项的问题，应该联系谁。</st>
    <st c="31743">支持名称</st> <st c="31759">有助于识别谁可以提供支持，如果目录项有任何技术问题。</st> <st c="31840">目录项。</st>
- en: <st c="31853">A full description of attributes</st> <st c="31886">can be found
    on this documentation</st> <st c="31922">page:</st> [<st c="31928">https://learn.microsoft.com/en-us/power-platform/developer/submit-catalog-items</st>](https://learn.microsoft.com/en-us/power-platform/developer/submit-catalog-items)<st
    c="32007">.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31853">属性的完整描述</st> <st c="31886">可以在此文档</st> <st c="31922">页面中找到：</st>
    [<st c="31928">https://learn.microsoft.com/en-us/power-platform/developer/submit-catalog-items</st>](https://learn.microsoft.com/en-us/power-platform/developer/submit-catalog-items)<st
    c="32007">。</st>
- en: <st c="32008">Example – submitting items to the catalog</st>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="32008">示例 - 提交项到目录</st>
- en: <st c="32050">Imagine we have a template</st> <st c="32077">app, built as a
    canvas app in Power Apps.</st> <st c="32120">This will represent our templatized
    canvas app.</st> <st c="32168">Along with the app, we could also have additional
    components as part of the solution, such as flows, Dataverse tables, and more.</st>
    <st c="32297">All of that is packaged in</st> <st c="32324">a solution.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32050">假设我们有一个模板</st> <st c="32077">应用程序，作为 Power Apps 中的画布应用程序构建。</st>
    <st c="32120">这将代表我们模板化的画布应用程序。</st> <st c="32168">除了应用程序，我们还可以将其他组件作为解决方案的一部分，例如流程、Dataverse
    表格等。</st> <st c="32297">所有这些内容都被打包在</st> <st c="32324">一个解决方案中。</st>
- en: <st c="32335">From the catalog process perspective, in the creation stage, we
    are working on our solution.</st> <st c="32429">In the previous chapters, we have
    already seen how we can create packages as part of the ALM process.</st> <st c="32531">Now,
    once we have the exported solution ready, we can create a submission JSON file
    by running a</st> `<st c="32628">pac catalog create-submission</st>` <st c="32657">command.</st>
    <st c="32667">We will need to update the submission attributes to correctly reflect
    our catalog item.</st> <st c="32755">We will update the business category, provide
    publisher details, and modify the catalog item definition, by providing the ID,
    display name, description, contacts, and other required attributes.</st> <st c="32949">An
    example of a submission JSON file for an example solution is uploaded in a chapter
    folder in the book’s GitHub</st> <st c="33063">repository (</st>[<st c="33075">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09</st>](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09)<st
    c="33175">).</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从目录过程的角度来看，在创建阶段，我们正在处理我们的解决方案。在前面的章节中，我们已经看到如何将包创建作为 ALM 过程的一部分。现在，一旦我们准备好导出的解决方案，我们可以通过运行`pac
    catalog create-submission`命令来创建提交 JSON 文件。我们需要更新提交属性，以正确反映我们的目录项目。我们将更新业务类别，提供发布者详情，并通过提供
    ID、显示名称、描述、联系人以及其他必需的属性来修改目录项定义。一个示例解决方案的提交 JSON 文件示例已上传到本书 GitHub 仓库的章节文件夹中（[https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09)）。
- en: <st c="33178">When we are ready with the JSON file and would like to start the</st>
    `<st c="33244">submit</st>` <st c="33250">process, we use</st> `<st c="33267">pac
    catalog submit --path <submission JSON file location> –-solution-zip <solution</st>`
    `<st c="33350">file location></st>`<st c="33364">.</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们准备好 JSON 文件并希望开始`提交`过程时，我们使用`pac catalog submit --path <提交 JSON 文件位置> --solution-zip
    <解决方案文件位置>`。
- en: <st c="33365">If we would like to submit to a catalog in a different environment,
    we can add the</st> `<st c="33449">–environment</st>` <st c="33461">switch to
    the command and specify the environment.</st> <st c="33513">This will produce
    an output similar to the</st> <st c="33556">following one:</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望提交到不同环境中的目录，可以将`--environment`开关添加到命令中并指定环境。这将产生类似于以下内容的输出：
- en: '[PRE1]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="33850">We can check the status of the submission using the</st> `<st
    c="33903">pac catalog status --tracking-id <submission tracking id> --type submit</st>`
    <st c="33974">command.</st> <st c="33984">If we are submitting to a different
    environment, we need to also provide the environment name to the command.</st>
    <st c="34094">The</st> `<st c="34098">type</st>` <st c="34102">parameter allows
    us to check the status of</st> `<st c="34146">install</st>` <st c="34153">and</st>
    `<st c="34158">submit</st>` <st c="34164">operations.</st> <st c="34177">The preceding
    command would generate a similar output to the following, which also demonstrates
    the use of short aliases for tracking ID</st> <st c="34314">and type:</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`pac catalog status --tracking-id <提交跟踪 ID> --type submit`命令检查提交状态。如果我们是提交到不同的环境，则需要向命令中提供环境名称。`type`参数允许我们检查`install`和`submit`操作的状态。前面的命令将生成类似以下内容的输出，也展示了跟踪
    ID和类型的短别名使用：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="34522">If the status is</st> `<st c="34540">Failed Prevalidation</st>`<st
    c="34560">, we can check the details of the error in the Catalog Manager, under</st>
    **<st c="34630">Failed Pre-Validation</st>**<st c="34651">.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果状态是`Failed Prevalidation`，我们可以在 Catalog Manager 中查看错误的详细信息，在**Failed Pre-Validation**下。
- en: <st c="34652">Now that we see our status</st> <st c="34679">as</st> `<st c="34683">Submitted</st>`<st
    c="34692">, the second stage of the catalog process (submit) is complete and we
    are moving to the next stage (approve and store).</st> <st c="34812">Our catalog
    items are submitted for approval.</st> <st c="34858">The approval can be seen
    in the Catalog Manager application either in the dashboard section of</st> **<st
    c="34953">Approval Request Status</st>** <st c="34976">or in</st> **<st c="34983">Approvals</st>**
    <st c="34992">|</st> **<st c="34995">Request</st>**<st c="35002">.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34652">现在我们看到我们的状态为</st> `<st c="34683">已提交</st>`<st c="34692">，目录过程的第二阶段（提交）已完成，我们正进入下一个阶段（批准和存储）。</st>
    <st c="34812">我们的目录项已提交等待批准。</st> <st c="34858">批准状态可以在目录管理器应用程序的仪表盘部分查看，位于</st>
    **<st c="34953">批准请求状态</st>** <st c="34976">或</st> **<st c="34983">批准</st>** <st
    c="34992">|</st> **<st c="34995">请求</st>**<st c="35002">。</st>
- en: '![Figure 9.4 – Approval request for submitted catalog items](img/B22208_09_4.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 提交的目录项的批准请求](img/B22208_09_4.jpg)'
- en: <st c="35604">Figure 9.4 – Approval request for submitted catalog items</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35604">图 9.4 – 提交的目录项的批准请求</st>
- en: <st c="35661">Once the catalog item gets approved, it gets stored in the catalog
    and can be found by going to the Catalog Manager and navigating to</st> **<st
    c="35796">Catalog Items</st>**<st c="35809">. Publishers will also be visible
    in</st> **<st c="35846">Catalog Publishers</st>** <st c="35864">and engineering
    and support contacts are added to the</st> **<st c="35919">Contact</st>** **<st
    c="35927">Info</st>** <st c="35931">list.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35661">一旦目录项获得批准，它将被存储在目录中，可以通过访问目录管理器并导航到</st> **<st c="35796">目录项</st>**<st
    c="35809">找到它。</st> 出版商也将显示在</st> **<st c="35846">目录出版商</st>** <st c="35864">中，工程和支持联系人将被添加到</st>
    **<st c="35919">联系人</st>** **<st c="35927">信息</st>** <st c="35931">列表中。</st>
- en: <st c="35937">Pro-developers will find a convenient attribute</st> <st c="35985">in
    the catalog item details that can provide a</st> **<st c="36033">Code Repository</st>**
    <st c="36048">link, which can be found in the</st> **<st c="36081">Links and Legal</st>**
    <st c="36096">section of the catalog item.</st> <st c="36126">This allows us to
    inform pro-developers where the source code is located, which only improves the
    InnerSource methodology described earlier, as now pro-developers can also review
    the code and contribute to the</st> <st c="36336">development process.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35937">专业开发人员将在目录项详情中找到一个便捷的属性</st> <st c="35985">，该属性提供一个</st> **<st
    c="36033">代码库</st>** <st c="36048">链接，您可以在目录项的</st> **<st c="36081">链接和法律</st>**
    <st c="36096">部分找到它。</st> <st c="36126">这使我们能够告知专业开发人员源代码的位置，这仅仅是之前提到的InnerSource方法论的进一步完善，因为现在专业开发人员也可以审查代码并参与到</st>
    <st c="36336">开发过程中。</st>
- en: <st c="36356">Example – installing a catalog item from the catalog</st>
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="36356">示例 – 从目录安装目录项</st>
- en: <st c="36409">We are moving now to the discovery phase</st> <st c="36450">of
    the catalog process.</st> <st c="36475">Here, app makers or pro-developers review
    the catalog or use the PAC CLI to list any catalog item from a given catalog by
    using the</st> `<st c="36607">pac catalog list</st>` <st c="36623">command.</st>
    <st c="36633">This returns all catalog items inside an environment.</st> <st c="36687">We
    can also use</st> `<st c="36703">--catalog-item-name</st>` <st c="36722">or</st>
    `<st c="36726">--catalog-item-id</st>` <st c="36743">as an additional search mechanism,
    to find only specific catalog items by name</st> <st c="36823">or ID.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36409">现在我们进入目录过程的发现阶段</st> <st c="36450">。</st> <st c="36475">在此阶段，应用开发者或专业开发人员会审查目录，或使用PAC
    CLI通过</st> `<st c="36607">pac catalog list</st>` <st c="36623">命令列出给定目录中的任何目录项。</st>
    <st c="36633">这将返回环境中的所有目录项。</st> <st c="36687">我们还可以使用</st> `<st c="36703">--catalog-item-name</st>`
    <st c="36722">或</st> `<st c="36726">--catalog-item-id</st>` <st c="36743">作为附加的搜索机制，通过名称</st>
    <st c="36823">或ID仅查找特定的目录项。</st>
- en: <st c="36829">Once we have reviewed the catalog items and are determined to
    test them out in our development environment, we can install an item by using</st>
    `<st c="36970">pac catalog install --catalog-item-id <catalog-item-id> --environment
    <your environment guid or absolute https URL></st>`<st c="37085">. This moves
    us to the final stage of the catalog process,</st> <st c="37144">called acquisition.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36829">一旦我们审查了目录项并决定在开发环境中测试它们，我们可以使用</st> `<st c="36970">pac catalog
    install --catalog-item-id <catalog-item-id> --environment <your environment guid
    or absolute https URL></st>`<st c="37085">进行安装。这将把我们带入目录过程的最后阶段，</st> <st c="37144">称为获取阶段。</st>
- en: <st c="37163">Keep in mind that if we plan to install the catalog item in another
    environment, we need to have the Catalog Manager installed in that environment</st>
    <st c="37311">as well.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37163">请记住，如果我们计划在另一个环境中安装目录项，我们需要在该环境中安装目录管理器</st> <st c="37311">。</st>
- en: <st c="37319">Once we run the command, we will get output similar</st> <st c="37372">to
    this:</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37319">一旦我们运行该命令，我们将获得类似</st> <st c="37372">这样的输出：</st>
- en: '[PRE3]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="37639">To discover, review, and install available catalog items using
    the UI, app makers can also go to Power Apps or Power Automate and click</st>
    **<st c="37776">More</st>** <st c="37780">|</st> **<st c="37783">Catalog</st>**
    <st c="37790">in the left navigation bar (be informed that this functionality
    is currently in public preview).</st> <st c="37888">This will open the</st> **<st
    c="37907">Catalog</st>** <st c="37914">area where we can search across all available
    catalog items within one or more catalogs in our tenant.</st> <st c="38018">Here,
    we will find all reusable published catalog items and information about personal
    activity in either acquiring catalog items or submitting new</st> <st c="38166">catalog
    items.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37639">要使用 UI 发现、查看和安装可用的目录项，应用程序开发者还可以前往 Power Apps 或 Power Automate
    并点击</st> **<st c="37776">更多</st>** <st c="37780">|</st> **<st c="37783">目录</st>**
    <st c="37790">在左侧导航栏中（请注意，这项功能当前处于公开预览阶段）。</st> <st c="37888">这将打开</st> **<st
    c="37907">目录</st>** <st c="37914">区域，在此我们可以在租户的一个或多个目录中搜索所有可用的目录项。</st> <st c="38018">在这里，我们将找到所有可重复使用的已发布目录项以及关于个人活动的信息，包括获取目录项或提交新</st>
    <st c="38166">目录项。</st>
- en: '![Figure 9.5 – Catalog area in Power Apps](img/B22208_09_5.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – Power Apps 中的目录区域](img/B22208_09_5.jpg)'
- en: <st c="38757">Figure 9.5 – Catalog area in Power Apps</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38757">图 9.5 – Power Apps 中的目录区域</st>
- en: <st c="38796">We can proceed by using the</st> **<st c="38825">Get</st>** <st
    c="38828">button for each catalog item that we would like to install in a current
    environment, following the installation wizard, and completing the</st> <st c="38968">installation
    process.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38796">我们可以继续使用</st> **<st c="38825">获取</st>** <st c="38828">按钮，为我们希望在当前环境中安装的每个目录项，按照安装向导进行操作，并完成</st>
    <st c="38968">安装过程。</st>
- en: <st c="38989">Now that the item has been installed either using the UI or PAC
    CLI, we can use this new component.</st> <st c="39090">If the solution is deployed
    as unmanaged to a development environment with the intention of further developing
    it, we can proceed with developing it to our needs and then follow the ALM process
    to get it deployed to the production environment with the</st> <st c="39342">created
    changes.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38989">现在，无论是通过 UI 还是 PAC CLI 安装的该项，我们都可以使用这个新组件。</st> <st c="39090">如果该解决方案作为未管理的形式部署到开发环境，并计划进一步开发它，我们可以继续按照我们的需求进行开发，然后遵循
    ALM 流程将其部署到生产环境中，带着</st> <st c="39342">创建的更改。</st>
- en: <st c="39358">Let’s not forget that the catalog</st> <st c="39392">process is
    continuous and involves development and deployment to the catalog for further
    reuse.</st> <st c="39489">As developers, we will spend more time in the development
    phase, so let’s explore some of the additional tools that developers, using Visual
    Studio, can use in</st> <st c="39649">Power Platform.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39358">别忘了，目录</st> <st c="39392">过程是持续的，涉及到将开发和部署到目录中以便进一步重用。</st> <st
    c="39489">作为开发人员，我们将在开发阶段花费更多时间，所以让我们来探索一些开发人员在使用 Visual Studio 时可以在</st> <st
    c="39649">Power Platform 中使用的附加工具。</st>
- en: <st c="39664">Additional tools for developers using Visual Studio</st>
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="39664">开发人员使用 Visual Studio 的附加工具</st>
- en: <st c="39716">From the tooling perspective, citizen developers</st> <st c="39765">focus
    on using low-code/no-code</st> <st c="39797">development tools, such as Microsoft
    Power Platform.</st> <st c="39851">Although pro-developers should also use the
    same low-code/no-code tool as citizen developers where possible, integrations
    and custom components would require custom coding, for which an IDE such as Visual
    Studio or VS Code will be used.</st> <st c="40088">Some of the developer’s tools
    have already been mentioned and used in previous chapters, such as Power Platform
    CLI and Power Platform Build Tools, together with Azure DevOps and GitHub.</st>
    <st c="40275">Similar to the Power Platform Tools extension for VS Code, developers
    who write code in Visual Studio can install the Power Platform Tools for Visual</st>
    <st c="40425">Studio extension.</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39716">从工具的角度来看，公民开发者</st> <st c="39765">专注于使用低代码/零代码</st> <st c="39797">开发工具，如
    Microsoft Power Platform。</st> <st c="39851">尽管专业开发者在可能的情况下也应该使用与公民开发者相同的低代码/零代码工具，但集成和自定义组件则需要自定义编码，针对这些需求，IDE
    如 Visual Studio 或 VS Code 将被使用。</st> <st c="40088">一些开发者工具已经在前面的章节中提到并使用过，例如 Power
    Platform CLI 和 Power Platform Build Tools，结合 Azure DevOps 和 GitHub。</st> <st c="40275">与
    VS Code 的 Power Platform Tools 扩展类似，编写代码的 Visual Studio 开发者可以安装 Visual Studio
    的 Power Platform Tools 扩展。</st>
- en: <st c="40442">The Power Platform Tools extension for Visual Studio can be found
    in Visual Studio Marketplace, similar to what we described in</st> [*<st c="40571">Chapter
    2</st>*](B22208_02.xhtml#_idTextAnchor030) <st c="40580">for VS Code.</st> <st
    c="40594">As a prerequisite for the installation, we will need to have at least
    Visual Studio 2019 or higher and .NET Framework 4.6.2, if we want to build plug-ins
    or</st> <st c="40751">workflow activities.</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40442">Visual Studio 的 Power Platform Tools 扩展可以在 Visual Studio Marketplace
    中找到，类似于我们在</st> [*<st c="40571">第 2 章</st>*](B22208_02.xhtml#_idTextAnchor030)
    <st c="40580">中描述的 VS Code。</st> <st c="40594">作为安装的前提条件，我们需要至少拥有 Visual Studio
    2019 或更高版本，并且需要 .NET Framework 4.6.2，如果我们希望构建插件或</st> <st c="40751">工作流活动。</st>
- en: '<st c="40771">We can install the extension</st> <st c="40800">from Visual Studio
    Marketplace (</st>[<st c="40833">https://marketplace.visualstudio.com</st>](https://marketplace.visualstudio.com)<st
    c="40870">) or in Visual Studio: on the top menu bar, click</st> `<st c="41124">Power
    Platform</st>` <st c="41138">in the search bar and click</st> **<st c="41167">Download</st>**<st
    c="41175">. When the download completes, we must restart Visual Studio for the
    scheduled extension installation</st> <st c="41277">to complete.</st>'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40771">我们可以从 Visual Studio Marketplace 安装扩展（</st>[<st c="40833">https://marketplace.visualstudio.com</st>](https://marketplace.visualstudio.com)<st
    c="40870">）或在 Visual Studio 中安装：在顶部菜单栏中，点击</st> `<st c="41124">Power Platform</st>`
    <st c="41138">在搜索栏中，点击</st> **<st c="41167">下载</st>**<st c="41175">。当下载完成后，我们必须重启
    Visual Studio，以完成计划中的扩展安装</st> <st c="41277">。</st>
- en: '![Figure 9.6 – Installing the extension for Visual Studio](img/B22208_09_6.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 为 Visual Studio 安装扩展](img/B22208_09_6.jpg)'
- en: <st c="42312">Figure 9.6 – Installing the extension for Visual Studio</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42312">图 9.6 – 为 Visual Studio 安装扩展</st>
- en: <st c="42367">Uninstallation can be done</st> <st c="42394">in a similar way
    as installation.</st> <st c="42429">Go to</st> **<st c="42435">Extensions</st>**
    <st c="42445">|</st> **<st c="42448">Manage Extensions</st>**<st c="42465">. This
    time, select</st> **<st c="42485">Installed</st>** <st c="42494">in the left navigation
    bar, find the Power Platform Tools extension, and</st> <st c="42568">click</st>
    **<st c="42574">Uninstall</st>**<st c="42583">.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42367">卸载可以像安装一样</st> <st c="42394">以类似的方式进行。</st> <st c="42429">进入</st>
    **<st c="42435">扩展</st>** <st c="42445">|</st> **<st c="42448">管理扩展</st>**<st
    c="42465">。这时，选择</st> **<st c="42485">已安装</st>** <st c="42494">在左侧导航栏中，找到 Power
    Platform Tools 扩展，然后</st> <st c="42568">点击</st> **<st c="42574">卸载</st>**<st c="42583">。</st>
- en: <st c="42584">The extension will only be visible</st> <st c="42619">when we
    either create a new project using Power Platform project templates or open an
    existing project that already contains at least one project created with the Power
    Platform</st> <st c="42798">Tools template.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42584">扩展只有在我们使用 Power Platform 项目模板创建新项目或打开一个已经包含至少一个使用 Power Platform</st>
    <st c="42798">Tools 模板创建的项目时才会可见。</st>
- en: <st c="42813">We can also show</st> **<st c="42831">Power Platform Explorer</st>**
    <st c="42854">after we first connect to the Dataverse environment.</st> <st c="42908">We
    can do that by selecting</st> **<st c="42936">Tools</st>** <st c="42941">in the
    top menu bar and then clicking</st> **<st c="42980">Connect</st>** **<st c="42988">to
    Dataverse…</st>**<st c="43001">.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42813">我们还可以在首次连接到 Dataverse 环境后显示</st> **<st c="42831">Power Platform
    Explorer</st>** <st c="42854">。</st> <st c="42908">我们可以通过在顶部菜单栏中选择</st> **<st
    c="42936">工具</st>** <st c="42941">，然后点击</st> **<st c="42980">连接到 Dataverse…</st>**<st
    c="42988">。</st>
- en: '![Figure 9.7 – Connecting to Dataverse from Visual Studio](img/B22208_09_7.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 从 Visual Studio 连接到 Dataverse](img/B22208_09_7.jpg)'
- en: <st c="43404">Figure 9.7 – Connecting to Dataverse from Visual Studio</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43404">图 9.7 – 从 Visual Studio 连接到 Dataverse</st>
- en: <st c="43459">This will open a new wizard</st> <st c="43487">window, where we
    will authenticate with our user to our Dataverse environment.</st> <st c="43567">For
    the login deployment type, we select</st> **<st c="43608">Office 365</st>** <st
    c="43618">since this will allow us to use Microsoft Entra ID as the authentication
    provider.</st> <st c="43702">Once we authenticate with our user, we will be prompted
    to select the solution in which we will</st> <st c="43798">be operating.</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43459">这将打开一个新的向导</st> <st c="43487">窗口，我们将在其中使用我们的用户身份验证连接到 Dataverse
    环境。</st> <st c="43567">对于登录部署类型，我们选择</st> **<st c="43608">Office 365</st>** <st
    c="43618">，因为这将允许我们使用 Microsoft Entra ID 作为身份验证提供者。</st> <st c="43702">一旦我们通过用户身份验证，我们将被提示选择将要操作的解决方案。</st>
- en: <st c="43811">If all steps complete successfully, then Power Platform Explorer</st>
    <st c="43876">should appear in front of us, connected to the environment in which
    the selected solution resides.</st> <st c="43976">We have a chance now to explore
    our environment and add plug-ins to the selected tables, register webhooks, add
    workflow activities, and more.</st> <st c="44119">Note that for the developing
    custom workflow activity, we need to have installed</st> **<st c="44200">Windows
    Workflow Foundation</st>**<st c="44227">. This can be installed through Visual
    Studio Installer by selecting</st> **<st c="44296">Modify</st>** <st c="44302">on
    the version of Visual Studio that we use for the development.</st> <st c="44368">Once
    in Installer, a window for modifying installation will open.</st> <st c="44434">Here,
    we select</st> **<st c="44450">Individual components</st>** <st c="44471">and
    search for the Windows Workflow Foundation.</st> <st c="44520">We select it and
    click</st> **<st c="44543">Modify</st>**<st c="44549">, which will download and
    install</st> <st c="44583">the functionality.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43811">如果所有步骤都成功完成，Power Platform Explorer</st> <st c="43876">应出现在我们面前，并连接到所选解决方案所在的环境。</st>
    <st c="43976">现在我们有机会探索我们的环境，并将插件添加到选定的表格中，注册 Webhooks，添加工作流活动等等。</st> <st c="44119">请注意，对于开发自定义工作流活动，我们需要安装</st>
    **<st c="44200">Windows Workflow Foundation</st>**<st c="44227">。可以通过 Visual Studio
    安装程序安装，方法是选择</st> **<st c="44296">修改</st>** <st c="44302">我们用于开发的 Visual Studio
    版本。</st> <st c="44368">在安装程序中，打开修改安装的窗口。</st> <st c="44434">在这里，我们选择</st> **<st
    c="44450">单个组件</st>** <st c="44471">并搜索 Windows Workflow Foundation。</st> <st
    c="44520">我们选择它并点击</st> **<st c="44543">修改</st>**<st c="44549">，这将下载并安装该功能。</st>
- en: '![Figure 9.8 – Power Platform Explorer](img/B22208_09_8.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – Power Platform Explorer](img/B22208_09_8.jpg)'
- en: <st c="44863">Figure 9.8 – Power Platform Explorer</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44863">图 9.8 – Power Platform Explorer</st>
- en: <st c="44899">Power Platform Tools for Visual Studio offers a set of project
    templates that allow us to use the C# programming language to develop the aforementioned
    Power Platform plug-ins, custom workflow activity, solution templates, and packages
    that are used to deploy solution and custom code libraries to our</st> <st c="45202">Dataverse
    environment.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44899">Power Platform Tools for Visual Studio 提供了一套项目模板，使我们能够使用 C# 编程语言开发前述的
    Power Platform 插件、定制工作流活动、解决方案模板和用于将解决方案和自定义代码库部署到我们的</st> <st c="45202">Dataverse
    环境的包。</st>
- en: <st c="45224">Developers who are using Visual Studio to develop</st> <st c="45274">backend
    APIs can also extend</st> <st c="45303">the capabilities of Visual Studio with</st>
    **<st c="45343">Connected Services</st>** <st c="45361">in order to create customer
    connectors in Power Platform.</st> <st c="45420">In order to leverage this capability,
    we should be using at least Visual Studio 2022, version 17.7, with ASP.NET and
    the web development workload installed.</st> <st c="45577">This is a capability
    that, at this moment, is not enabled in Visual Studio for Mac.</st> <st c="45661">Our
    API should be developed as an ASP.NET Core Web</st> <st c="45712">API project.</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45224">使用 Visual Studio 开发后端 API 的开发者，还可以通过</st> <st c="45274">“连接服务”</st>
    <st c="45303">扩展 Visual Studio 的功能，以便在 Power Platform 中创建自定义连接器。</st> <st c="45420">为了利用此功能，我们需要至少使用
    Visual Studio 2022，版本 17.7，并安装 ASP.NET 和 Web 开发工作负载。</st> <st c="45577">目前，这项功能在
    Visual Studio for Mac 中尚未启用。</st> <st c="45661">我们的 API 应该作为 ASP.NET Core Web</st>
    <st c="45712">API 项目进行开发。</st>
- en: <st c="45724">We will be talking more about custom</st> <st c="45761">connectors,
    code components, and pro-developer</st> <st c="45808">extensibilities in</st>
    [*<st c="45828">Chapter 10</st>*](B22208_10.xhtml#_idTextAnchor172)<st c="45838">.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45724">我们将在</st> [*<st c="45828">第 10 章</st>*](B22208_10.xhtml#_idTextAnchor172)<st
    c="45838">中进一步讨论自定义连接器、代码组件以及专业开发人员的扩展性。</st>
- en: <st c="45839">Now that we have all the tools ready, we can look at how Power
    Platform can be integrated with</st> <st c="45935">Azure services.</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45839">现在我们已经准备好了所有工具，接下来可以看看 Power Platform 如何与</st> <st c="45935">Azure
    服务集成。</st>
- en: <st c="45950">Microsoft Azure and Power Platform together</st>
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="45950">微软 Azure 和 Power Platform 携手合作</st>
- en: <st c="45994">This section focuses on explaining the most commonly used Azure
    services in the integration scenarios with Power Platform.</st> <st c="46118">We
    have grouped these services into workloads specific to the capabilities they provide
    and briefly described them.</st> <st c="46234">For each workload, we provide an
    example of how the Azure service could be used with</st> <st c="46319">Power Platform.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45994">本节将重点介绍与 Power Platform 集成场景中最常用的 Azure 服务。</st> <st c="46118">我们将这些服务分为按其提供的功能进行分组，并简要描述了它们。</st>
    <st c="46234">对于每个工作负载，我们提供了如何将 Azure 服务与</st> <st c="46319">Power Platform 配合使用的示例。</st>
- en: <st c="46334">Microsoft Azure, as a cloud platform, allows</st> <st c="46379">us
    to run different workloads in the cloud, such as hosting our applications entirely
    in Azure or extending and connecting our on-premise applications with Azure services.</st>
    <st c="46552">As we have seen in previous chapters, when organizations are modernizing
    their applications or building new applications, they always have a chance to
    select the path of using a low-code/no-code development approach to modernize
    existing apps or build new ones.</st> <st c="46814">However, many times, scenarios
    are too complex and require teams to work as a fusion team, where pro-developers
    focus on developing complex scenarios with the services that</st> <st c="46987">Azure
    provides.</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46334">作为云平台，微软 Azure 使我们能够在云中运行不同的工作负载，例如将我们的应用完全托管在 Azure 中，或者将本地应用与
    Azure 服务进行扩展和连接。</st> <st c="46379">正如我们在前面的章节中看到的，当组织在现代化他们的应用或构建新应用时，他们总是有机会选择使用低代码/无代码开发方法来现代化现有应用或构建新应用。</st>
    <st c="46552">然而，很多时候，场景过于复杂，需要团队作为融合团队来合作，在这个团队中，专业开发人员专注于使用 Azure 提供的服务来开发复杂的场景。</st>
    <st c="46987">Azure 提供的服务。</st>
- en: <st c="47002">Microsoft Azure, with its vast array of cloud computing services,
    can cover complex scenarios that span compute services, networking, storage, web
    services, and more.</st> <st c="47170">Let’s take a look at some Azure services
    that are widely used with Power Platform.</st> <st c="47253">We will not be able
    to cover all of them, as there are too many options, so we encourage you to navigate</st>
    <st c="47357">to the Azure</st> **<st c="47371">Products</st>** <st c="47379">web
    page to read more about</st> <st c="47408">them:</st> [<st c="47414">https://azure.microsoft.com/en-us/products</st>](https://azure.microsoft.com/en-us/products)<st
    c="47456">.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47002">微软 Azure 提供了丰富的云计算服务，可以覆盖从计算服务、网络、存储、Web 服务等多个复杂场景。</st> <st c="47170">让我们来看看一些与
    Power Platform 广泛集成的 Azure 服务。</st> <st c="47253">我们无法涵盖所有服务，因为选择太多，因此我们建议你访问</st>
    <st c="47357">Azure</st> **<st c="47371">产品</st>** <st c="47379">网页，进一步了解这些服务：</st>
    [<st c="47414">https://azure.microsoft.com/en-us/products</st>](https://azure.microsoft.com/en-us/products)<st
    c="47456">。</st>
- en: <st c="47457">Application hosting services</st>
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="47457">应用程序托管服务</st>
- en: <st c="47486">Azure provides a wide range</st> <st c="47514">of services that
    are able to host applications.</st> <st c="47563">They have different purposes,
    from services that can run Spring Boot applications to container hosting services
    to multi-purpose web hosting services, such as Azure</st> <st c="47728">App Service:</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47486">Azure提供了广泛的服务，可以托管应用程序。</st> <st c="47514">这些服务有不同的用途，从可以运行Spring
    Boot应用程序的服务到容器托管服务，再到多用途Web托管服务，如Azure</st> <st c="47728">App Service：</st>
- en: '**<st c="47740">Azure App Service</st>** <st c="47758">is a managed service
    that allows</st> <st c="47791">us to host web applications, Web APIs, and mobile
    backends.</st> <st c="47852">Since it is a managed PaaS service, it is up to the
    cloud provider to maintain the operating system and underlying infrastructure,
    while we focus on building the application.</st> <st c="48027">It is a scalable,
    enterprise-grade service that allows applications to be scaled automatically depending
    on the load while keeping a high degree</st> <st c="48172">of security.</st>'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="47740">Azure App Service</st>** <st c="47758">是一项托管服务，允许</st> <st
    c="47791">我们托管Web应用程序，Web API和移动后端。</st> <st c="47852">由于它是托管的PaaS服务，云提供商负责维护操作系统和基础设施，而我们专注于构建应用程序。</st>
    <st c="48027">它是一个可扩展的企业级服务，允许根据负载自动缩放应用程序，同时保持高度</st> <st c="48172">的安全性。</st>'
- en: '**<st c="48184">Azure Container Apps</st>** <st c="48205">is a serverless platform
    designed to run</st> <st c="48246">containerized applications.</st> <st c="48275">Compared
    to</st> **<st c="48287">Azure Kubernetes Service</st>** <st c="48311">(</st>**<st
    c="48313">AKS</st>**<st c="48316">), a managed Kubernetes cluster</st> <st c="48348">in
    which we need to manage nodes attached to the AKS cluster, with Azure Container
    Apps, we get a fully managed Kubernetes service that provides automatic scaling
    of our application workloads without the need to manage</st> <st c="48568">the
    infrastructure.</st>'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="48184">Azure Container Apps</st>** <st c="48205">是一个无服务器平台，专为运行</st>
    <st c="48246">容器化应用程序而设计。</st> <st c="48275">与</st> **<st c="48287">Azure Kubernetes
    Service</st>** <st c="48311">(</st>**<st c="48313">AKS</st>**<st c="48316">)相比，后者是一个托管的Kubernetes集群，需要我们管理连接到AKS集群的节点。而Azure
    Container Apps则提供了一个完全托管的Kubernetes服务，可以自动扩展我们的应用工作负载，而无需管理</st> <st c="48568">基础设施。</st>'
- en: <st c="48587">Let’s look at a Power Platform</st> <st c="48618">integration
    example.</st> <st c="48640">Both of the preceding services are used for running
    either frontend applications or backend API endpoints.</st> <st c="48747">We can
    use them to run background processing jobs or to build and run our Web APIs.</st>
    <st c="48831">When we choose containers as the packaging and deployment option,
    we can also deploy our microservices to Azure Container Apps or similar container-running
    services on Azure.</st> <st c="49006">These APIs will be exposed securely through
    Azure API Management and will serve as a backend for our</st> <st c="49107">custom
    connectors.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48587">让我们来看一个Power Platform</st> <st c="48618">集成示例。</st> <st c="48640">前面提到的两种服务用于运行前端应用程序或后端API端点。</st>
    <st c="48747">我们可以使用它们来运行后台处理作业或构建并运行我们的Web API。</st> <st c="48831">当我们选择容器作为打包和部署选项时，还可以将我们的微服务部署到Azure
    Container Apps或类似的Azure容器运行服务上。</st> <st c="49006">这些API将通过Azure API Management安全地公开，并作为我们</st>
    <st c="49107">自定义连接器的后端。</st>
- en: <st c="49125">Integration Services</st>
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="49125">集成服务</st>
- en: <st c="49146">Azure Integration Services is a set of Azure</st> <st c="49191">services
    that allow organizations to build solutions that connect different systems and
    applications together.</st> <st c="49303">They can be used to provide a highly
    secure messaging platform, build ETL processes, and perform data transformation,
    or to securely expose backend systems through APIs for internal and</st> <st c="49489">external
    use:</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49146">Azure集成服务是一组Azure</st> <st c="49191">服务，允许组织构建连接不同系统和应用程序的解决方案。</st>
    <st c="49303">它们可以用于提供高度安全的消息平台，构建ETL流程和执行数据转换，或通过API安全地公开后端系统供内部和</st> <st c="49489">外部使用：</st>
- en: '**<st c="49502">Azure API Management</st>** <st c="49523">(</st>**<st c="49525">Azure
    APIM</st>**<st c="49535">) enables organizations to manage APIs and expose</st>
    <st c="49585">them to other applications easily and securely.</st> <st c="49634">It
    is built from three components: the gateway, developer portal, and admin management
    plane.</st> <st c="49728">Backend applications and data can reside in Azure or
    in other environments (including on-premises) while providing the clients with
    this front door, which allows routing requests to the backend while keeping control
    of the request and</st> <st c="49963">response flow.</st>'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="49502">Azure API 管理</st>** <st c="49523">(</st>**<st c="49525">Azure
    APIM</st>**<st c="49535">) 使组织能够管理 API 并将它们暴露给其他应用程序，</st> <st c="49585">使得这一过程既快捷又安全。</st>
    <st c="49634">它由三个组件构成：网关、开发者门户和管理员管理面板。</st> <st c="49728">后台应用程序和数据可以驻留在 Azure
    或其他环境中（包括本地环境），同时为客户端提供一个前门，</st> <st c="49963">该前门可以将请求路由到后台，同时保持对请求和响应流的控制。</st>'
- en: '**<st c="49977">Power Platform integration example</st>**<st c="50012">: Once
    we have APIs ready, exposing them through Azure APIM</st> <st c="50072">enables
    us to quickly create custom connectors in Power Platform.</st> <st c="50139">Custom
    connectors will be used in our applications</st> <st c="50190">or flows.</st>'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**<st c="49977">Power Platform 集成示例</st>**<st c="50012">：一旦我们准备好了 API，通过 Azure
    APIM 将它们暴露出来</st> <st c="50072">使我们能够快速在 Power Platform 中创建自定义连接器。</st> <st c="50139">自定义连接器将用于我们的应用程序</st>
    <st c="50190">或流程。</st>'
- en: '**<st c="50199">Azure Functions</st>** <st c="50215">is an event-driven, serverless
    compute platform that allows developers to use</st> <st c="50294">event-driven
    triggers and bindings to connect functions to other services and execute the application
    logic.</st> <st c="50403">Since it is a serverless platform, the overhead of managing
    the cloud infrastructure is managed by the cloud provider and the platform.</st>
    <st c="50539">Azure Functions are commonly used in scenarios where processing
    data needs to be done (such as responding to an event, database changes, or reading
    requests that are stored in Azure Service Bus) or where data is captured from
    different IoT streams and needs to be processed in</st> <st c="50816">real time.</st>'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="50199">Azure Functions</st>** <st c="50215">是一个事件驱动的无服务器计算平台，允许开发人员使用</st>
    <st c="50294">事件驱动的触发器和绑定将函数连接到其他服务并执行应用程序逻辑。</st> <st c="50403">由于它是一个无服务器平台，云基础设施的管理由云提供商和平台承担，</st>
    <st c="50539">因此无需担心管理开销。</st> <st c="50816">Azure Functions 通常用于需要处理数据的场景（例如响应事件、数据库更改或读取存储在
    Azure Service Bus 中的请求），</st> <st c="50539">或者当从不同的 IoT 流中捕获数据并需要实时处理时。</st>'
- en: '**<st c="50826">Power Platform integration example</st>**<st c="50861">: Azure
    Functions is used for processing data</st> <st c="50907">that is stored in a data
    store, including Dataverse.</st> <st c="50961">It allows implementing Web APIs
    through REST endpoints to perform specific complex logic.</st> <st c="51051">Such
    APIs can be connected through custom connectors with our Power Platform solution
    to perform an</st> <st c="51151">API operation.</st>'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**<st c="50826">Power Platform 集成示例</st>**<st c="50861">：Azure Functions 用于处理存储在数据存储中的数据，包括
    Dataverse。</st> <st c="50907">它允许通过 REST 端点实现 Web API，执行特定的复杂逻辑。</st> <st c="50961">这些
    API 可以通过自定义连接器与我们的 Power Platform 解决方案连接，执行 API 操作。</st>'
- en: '**<st c="51165">Azure Service Bus</st>** <st c="51183">is an asynchronous messaging
    cloud</st> <st c="51219">platform that allows us to create reliable messaging
    solutions.</st> <st c="51283">It is designed to enable application decoupling
    and building</st> <st c="51344">scalable systems.</st>'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="51165">Azure Service Bus</st>** <st c="51183">是一个异步消息传递云平台，</st> <st
    c="51219">它允许我们创建可靠的消息传递解决方案。</st> <st c="51283">它的设计目标是实现应用程序解耦并构建</st> <st c="51344">可扩展的系统。</st>'
- en: '**<st c="51361">Power Platform integration example</st>**<st c="51396">: It
    allows us to enable asynchronous communication between</st> <st c="51456">applications
    and backend services in order to decouple applications and services from each
    other.</st> <st c="51555">Using the Service Bus connector in Power Platform, we
    can perform operations such as sending or receiving messages</st> <st c="51670">to/from
    queues.</st>'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**<st c="51361">Power Platform 集成示例</st>**<st c="51396">：它使我们能够在应用程序和后台服务之间启用异步通信，从而将应用程序和服务彼此解耦。</st>
    <st c="51456">通过在 Power Platform 中使用 Service Bus 连接器，我们可以执行诸如发送或接收消息</st> <st
    c="51670">到/从队列的操作。</st>'
- en: '**<st c="51685">Azure Logic Apps</st>** <st c="51702">is a cloud platform to
    create</st> <st c="51732">and run automated workflows, similar to Power Automate,
    with more emphasis on pro-developers and IT professionals.</st> <st c="51848">It
    has some unique capabilities that Power Automate does not have, such as utilizing
    Visual Studio and VS Code with extensions in order to develop and review workflows</st>
    <st c="52016">through code.</st>'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="51685">Azure Logic Apps</st>** <st c="51702">是一个云平台，用于创建</st> <st
    c="51732">和运行自动化工作流，类似于 Power Automate，但更侧重于专业开发人员和 IT 专业人士。</st> <st c="51848">它具有
    Power Automate 没有的一些独特功能，比如利用 Visual Studio 和 VS Code 通过扩展来开发和审查工作流</st> <st c="52016">代码。</st>'
- en: '**<st c="52029">Power Platform integration example</st>**<st c="52064">: It
    can be used to automate Azure-related tasks or more</st> <st c="52121">complex
    processes that are not Power Platform solution-related.</st> <st c="52186">We
    can build custom connectors that are connected to Logic Apps workflows and run
    the workflow through custom connectors in Power Automate or</st> <st c="52328">Power
    Apps.</st>'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**<st c="52029">Power Platform 集成示例</st>**<st c="52064">：它可以用于自动化与 Azure 相关的任务或更</st>
    <st c="52121">复杂的流程，这些流程不一定与 Power Platform 解决方案相关。</st> <st c="52186">我们可以构建自定义连接器，连接到
    Logic Apps 工作流，并通过 Power Automate 或</st> <st c="52328">Power Apps 中的自定义连接器运行该工作流。</st>'
- en: <st c="52339">Data analytics</st>
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="52339">数据分析</st>
- en: <st c="52354">Azure offers a set of data analytics</st> <st c="52391">services
    that help us gain insights into the data stored anywhere, enable real-time data
    streaming from IoT devices, take care of the telemetry ingestion,</st> <st c="52547">and
    more:</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52354">Azure 提供了一套数据分析</st> <st c="52391">服务，帮助我们获取存储在任何地方的数据洞察，支持来自
    IoT 设备的实时数据流，处理遥测数据的摄取，</st> <st c="52547">等等：</st>
- en: '**<st c="52556">Azure Event Hubs</st>** <st c="52573">brings a common point
    to integration</st> <st c="52610">scenarios where applications need to respond
    to events that are happening in real time.</st> <st c="52699">It allows the ingestion
    of real-time event data from different sources.</st> <st c="52771">It is very
    common to use it when working with IoT scenarios or application monitoring.</st>
    <st c="52858">Since Power Platform includes a connector for Azure Event Hubs,
    we can build integrations</st> <st c="52948">more easily.</st>'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="52556">Azure Event Hubs</st>** <st c="52573">为集成提供了一个共同的点</st> <st
    c="52610">，适用于应用程序需要响应实时事件的场景。</st> <st c="52699">它允许从不同来源摄取实时事件数据。</st> <st c="52771">在处理
    IoT 场景或应用程序监控时，使用它非常常见。</st> <st c="52858">由于 Power Platform 包含了 Azure Event Hubs
    的连接器，我们可以更容易地构建集成。</st>'
- en: '**<st c="52960">Power Platform integration example</st>**<st c="52995">: When
    an IoT device sends data to IoT Hub, that data gets</st> <st c="53054">processed
    by Azure Functions and sent to Azure Event Hubs.</st> <st c="53114">When events
    are available in Event Hubs, a Power Automate flow gets triggered and performs</st>
    <st c="53205">the logic.</st>'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**<st c="52960">Power Platform 集成示例</st>**<st c="52995">：当 IoT 设备将数据发送到 IoT
    Hub 时，数据会被</st> <st c="53054">Azure Functions 处理并发送到 Azure Event Hubs。</st> <st
    c="53114">当事件在 Event Hubs 中可用时，Power Automate 流程会被触发并执行</st> <st c="53205">相应的逻辑。</st>'
- en: '**<st c="53215">Microsoft Fabric</st>** <st c="53232">is a single unified analytics
    platform</st> <st c="53271">that connects tools such as Azure Data Factory, Azure
    Synapse Analytics, and Power BI together.</st> <st c="53368">Fabric includes</st>
    <st c="53383">a multi-cloud data lake, called OneLake, which sits underneath the
    mentioned Fabric tools and helps eliminate data silos.</st> <st c="53506">OneLake
    works as a single storage system allowing organizations to combine data from different
    data sources, including Dynamics 365 data.</st> <st c="53644">Once data is represented
    in OneLake, organizations can perform different types of analytics in</st> <st
    c="53739">Microsoft Fabric.</st>'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="53215">Microsoft Fabric</st>** <st c="53232">是一个统一的分析平台</st> <st c="53271">，连接了如
    Azure Data Factory、Azure Synapse Analytics 和 Power BI 等工具。</st> <st c="53368">Fabric
    包括</st> <st c="53383">一个多云数据湖，称为 OneLake，它位于上述 Fabric 工具下方，帮助消除数据孤岛。</st> <st
    c="53506">OneLake 作为一个单一的存储系统，允许组织将来自不同数据源的数据结合起来，包括 Dynamics 365 数据。</st> <st
    c="53644">一旦数据被表示在 OneLake 中，组织就可以在</st> <st c="53739">Microsoft Fabric 中执行不同类型的分析。</st>'
- en: '**<st c="53756">Power Platform integration example</st>**<st c="53791">: Recently,
    Power Platform introduced a Dataverse</st> <st c="53842">integration with Microsoft
    Fabric.</st> <st c="53877">It opens possibilities to connect Dataverse to Fabric,
    using</st> **<st c="53938">Link to Fabric</st>**<st c="53952">, and a scenario
    where Fabric</st> <st c="53981">is connected to Dataverse, using virtual tables.</st>
    <st c="54031">Link to Fabric allows organizations to keep the data in Dataverse
    while enabling analytical capabilities in Fabric to find insights into the data.</st>
    <st c="54178">These insights can be sent back to Dataverse in the format of virtual
    tables, which allows developers to utilize these findings in a business process.</st>
    <st c="54329">Similar to before where data stayed in Dataverse, here, data resides</st>
    <st c="54398">in OneLake.</st>'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**<st c="53756">Power Platform 集成示例</st>**<st c="53791">：最近，Power Platform
    引入了与 Microsoft Fabric 的 Dataverse</st> <st c="53842">集成。</st> <st c="53877">它开启了将
    Dataverse 连接到 Fabric 的可能性，使用</st> **<st c="53938">Link to Fabric</st>**<st c="53952">，以及一个将
    Fabric</st> <st c="53981">连接到 Dataverse 的场景，利用虚拟表。</st> <st c="54031">Link to
    Fabric 允许组织将数据保留在 Dataverse 中，同时启用 Fabric 中的分析功能，以发现数据中的洞察。</st> <st c="54178">这些洞察可以以虚拟表的格式返回到
    Dataverse，这使得开发人员能够在业务流程中利用这些发现。</st> <st c="54329">与之前数据停留在 Dataverse 中类似，在这里，数据驻留在</st>
    <st c="54398">OneLake 中。</st>'
- en: <st c="54409">AI services</st>
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="54409">AI 服务</st>
- en: '**<st c="54421">Azure AI services</st>** <st c="54439">are a set of REST APIs
    and client library SDKs</st> <st c="54486">that enable pro-developers to create
    intelligent applications with pre-built and customizable AI models that have cognitive
    capabilities such as natural language understanding through conversation, speech
    capabilities, vision, and more.</st> <st c="54724">Azure AI services are an umbrella
    for services such as Azure OpenAI, Azure AI Search, Vision, Speech,</st> <st c="54826">and
    more.</st>'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="54421">Azure AI 服务</st>** <st c="54439">是一组 REST API 和客户端库 SDK</st>
    <st c="54486">，使专业开发人员能够使用预构建和可定制的 AI 模型创建智能应用，这些模型具有自然语言理解、语音能力、视觉能力等认知功能。</st>
    <st c="54724">Azure AI 服务是如 Azure OpenAI、Azure AI 搜索、视觉、语音等服务的总称。</st> <st c="54826">以及更多服务。</st>'
- en: <st c="54835">Let’s look at a Power Platform integration example.</st> <st c="54888">Although
    Power Platform includes AI Builder, which utilizes some of these pre-built models,
    Azure AI services allow additional capabilities, such as integrating speech-to-text
    and text-to-speech capabilities or utilizing other AI models</st> <st c="55124">in
    our</st> <st c="55132">business applications.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54835">让我们来看一个 Power Platform 集成的示例。</st> <st c="54888">尽管 Power Platform
    包括 AI Builder，利用了一些预构建的模型，Azure AI 服务提供了额外的功能，例如集成语音转文本和文本转语音功能，或者利用其他 AI 模型</st>
    <st c="55124">在我们的</st> <st c="55132">业务应用中。</st>
- en: <st c="55154">Data storage</st>
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="55154">数据存储</st>
- en: '**<st c="55167">Azure SQL Database</st>** <st c="55186">is a fully managed
    relational database.</st> <st c="55227">It is a PaaS deployment of Azure SQL that
    enables</st> <st c="55276">hyperscale (unlimited database storage) and autoscaling.</st>
    <st c="55334">As many organizations are already utilizing SQL Server for their
    database systems, such an option enables them to modernize their database and
    eliminate the need to manage</st> <st c="55506">the infrastructure.</st>'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="55167">Azure SQL 数据库</st>** <st c="55186">是一个完全托管的关系型数据库。</st> <st
    c="55227">它是 Azure SQL 的 PaaS 部署，支持</st> <st c="55276">超大规模（无限的数据库存储）和自动扩展。</st>
    <st c="55334">由于许多组织已经在使用 SQL Server 作为他们的数据库系统，这样的选项使他们能够现代化其数据库，并消除管理</st> <st
    c="55506">基础设施的需求。</st>'
- en: <st c="55525">Let’s look at a Power Platform integration example.</st> <st c="55578">Power
    Platform meets customers where they are with their data.</st> <st c="55641">This
    is why there are more than 1,000 connectors available in Power Platform, and one
    of them is also for connecting to SQL Servers.</st> <st c="55774">This allows
    us to build applications and flows that connect to the existing</st> <st c="55850">data
    sources.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55525">让我们来看一个 Power Platform 集成的示例。</st> <st c="55578">Power Platform
    根据客户的数据需求提供支持。</st> <st c="55641">这就是为什么 Power Platform 中有超过 1,000 个连接器，其中之一也是用于连接
    SQL 服务器。</st> <st c="55774">这使我们能够构建连接到现有</st> <st c="55850">数据源的应用和流程。</st>
- en: <st c="55863">Azure provides additional database services.</st> <st c="55909">Depending
    on the need of the project, we could utilize other relational databases, such
    as PostgreSQL, MySQL, or MariaDB, or non-relational database services such as
    Cosmos DB.</st> <st c="56086">For each of these data services, there is a connector
    that we can use to build our automation flows or business applications using the</st>
    <st c="56221">existing databases.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 提供了额外的数据库服务。根据项目的需求，我们可以使用其他关系型数据库，如 PostgreSQL、MySQL 或 MariaDB，或者非关系型数据库服务，如
    Cosmos DB。对于这些数据服务中的每一项，都有一个连接器，我们可以使用它来构建我们的自动化流程或业务应用程序，利用现有的数据库。
- en: <st c="56240">The aforementioned services are just a handful of services in
    the pool of all the available options on Azure.</st> <st c="56351">When planning
    a project, consult with a solution architect or enterprise architect in the organization
    who has a knowledge of cloud computing to determine which services are best suited
    for the</st> <st c="56545">planned project.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述服务只是 Azure 所提供的众多选项中的一小部分。在规划项目时，请咨询具有云计算知识的解决方案架构师或企业架构师，以确定哪些服务最适合计划中的项目。
- en: <st c="56561">Example of an Azure and Power Platform integration scenario</st>
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure 和 Power Platform 集成场景示例
- en: <st c="56621">This section focuses on a practical example</st> <st c="56665">that
    demonstrates how fusion teams could work together.</st> <st c="56722">This case
    shows a connection between Power Platform and Azure through the use of custom
    connectors and Azure services, such as Azure</st> <st c="56855">API Management.</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 本节聚焦于一个实践案例，展示了融合团队如何协同工作。该案例展示了通过使用自定义连接器和 Azure 服务（如 Azure API 管理）将 Power
    Platform 与 Azure 连接起来。
- en: <st c="56870">For the example in this chapter, we focus on integrating Web API
    templates written in the C# programming language in Visual Studio 2022, with Power
    Platform as a custom connector.</st> <st c="57051">We have already installed Power
    Platform Tools in Visual Studio 2022 in the previous chapter.</st> <st c="57145">This
    will demonstrate how pro-developers can use modern tools to build and test Web
    APIs that support business applications in Power Apps.</st> <st c="57284">The
    Web API will be deployed to the Azure service and exposed over Azure</st> <st
    c="57357">API Management.</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例聚焦于将用 C# 编程语言编写的 Web API 模板与 Power Platform 作为自定义连接器集成，使用 Visual Studio
    2022。我们在上一章中已经安装了 Power Platform 工具在 Visual Studio 2022 中。本示例将展示如何通过现代工具，帮助专业开发者构建和测试支持
    Power Apps 业务应用程序的 Web API。Web API 将部署到 Azure 服务并通过 Azure API 管理进行暴露。
- en: '<st c="57372">Here, we will introduce two ways of creating a custom connector:
    one with the support of Visual Studio 2022 and the other with the support of Azure</st>
    <st c="57521">API Management.</st>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍两种创建自定义连接器的方法：一种是借助 Visual Studio 2022，另一种是借助 Azure API 管理。
- en: <st c="57536">Once a custom connector is created, our citizen developers can
    use operations in Power Platform in their</st> <st c="57642">business solution.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了自定义连接器，我们的公民开发者就可以在 Power Platform 中使用这些操作来开发他们的业务解决方案。
- en: <st c="57660">The next chapter will focus on the ALM process for many different
    Power Platform components, so here we will be showing</st> <st c="57780">the concept
    of the fusion</st> <st c="57807">development approach.</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍 Power Platform 各个组件的 ALM 流程，因此在这里我们将展示融合开发方法的概念。
- en: <st c="57828">Let’s jump into creating a Web</st> <st c="57860">API first.</st>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从创建 Web API 开始。
- en: <st c="57870">Creating a Web API and a Power Platform custom connector with
    Visual Studio 2022</st>
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Visual Studio 2022 创建 Web API 和 Power Platform 自定义连接器
- en: <st c="57951">We will put on our pro-developer</st> <st c="57984">hats and create
    our sample API using</st> <st c="58021">the ASP.NET Core Web API template in Visual
    Studio 2022\.</st> <st c="58079">We will do this to demonstrate the capabilities
    that pro-developers gain using Visual Studio while working in the fusion development
    team on a project that will mainly reside on Power</st> <st c="58263">Platform
    services.</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57951">我们将戴上专业开发者的</st> <st c="57984">帽子，并使用</st> <st c="58021">Visual
    Studio 2022 中的 ASP.NET Core Web API 模板创建我们的示例 API。</st> <st c="58079">我们这样做是为了展示专业开发者在融合开发团队中使用
    Visual Studio 开发项目时所获得的能力，该项目主要部署在 Power</st> <st c="58263">Platform 服务上。</st>
- en: <st c="58281">When Visual Studio starts, it welcomes us with a window in which
    we can create a new project by clicking on the</st> `<st c="58529">web api</st>`<st
    c="58536">, select the</st> **<st c="58549">ASP.NET Core Web API</st>** <st c="58569">template
    in the C# language, and click</st> **<st c="58609">Next</st>**<st c="58613">,
    as shown in the</st> <st c="58631">following figure:</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58281">当 Visual Studio 启动时，它会欢迎我们进入一个窗口，在这个窗口中，我们可以通过点击</st> `<st c="58529">web
    api</st>`<st c="58536">来创建一个新项目，选择 C# 语言中的</st> **<st c="58549">ASP.NET Core Web
    API</st>** <st c="58569">模板，然后点击</st> **<st c="58609">Next</st>**<st c="58613">，如以下图所示：</st>
- en: '![Figure 9.9 – Creating a new Web API project](img/B22208_09_9.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 创建一个新的 Web API 项目](img/B22208_09_9.jpg)'
- en: <st c="59634">Figure 9.9 – Creating a new Web API project</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59634">图 9.9 – 创建一个新的 Web API 项目</st>
- en: <st c="59677">On the next</st> <st c="59689">screen, we will</st> <st c="59705">provide
    our</st> `<st c="60167">GET</st>` <st c="60170">operation, called</st> `<st c="60189">WeatherForecast</st>`<st
    c="60204">, which is already part of</st> <st c="60231">the template.</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59677">在接下来的</st> <st c="59689">界面中，我们将</st> <st c="59705">提供我们的</st>
    `<st c="60167">GET</st>` <st c="60170">操作，名为</st> `<st c="60189">WeatherForecast</st>`<st
    c="60204">，它已经是</st> <st c="60231">模板的一部分。</st>
- en: <st c="60244">As part of the DevOps experience, our task would be to version
    control our code, which would mean that we either create a new project in Azure
    DevOps or GitHub or use an existing project for this part of the project, and
    then commit our code to the repository with the initial commit.</st> <st c="60530">We
    enable branch protection on the</st> `<st c="60565">main</st>` <st c="60569">branch
    and configure other policies, as we have learned in previous chapters.</st> <st
    c="60648">At this point, our pro-developers who are working on the API can continue
    their work following the DevOps</st> <st c="60754">best practices.</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60244">作为 DevOps 经验的一部分，我们的任务是对代码进行版本控制，这意味着我们要么在 Azure DevOps 或 GitHub
    上创建一个新项目，要么使用现有项目来进行这一部分工作，然后将我们的代码提交到代码库，并进行首次提交。</st> <st c="60530">我们在</st>
    `<st c="60565">main</st>` <st c="60569">分支上启用分支保护，并配置其他策略，正如我们在前面的章节中学到的那样。</st>
    <st c="60648">此时，我们的 API 开发者可以按照 DevOps</st> <st c="60754">最佳实践继续他们的工作。</st>
- en: <st c="60769">Coming back to our example, we can test the newly created project
    or continue with development and remove the existing</st> `<st c="60889">WeatherForecast</st>`
    <st c="60904">operation and go ahead and develop the API operations that the business
    project that we are working on is requesting</st> <st c="61022">from us.</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60769">回到我们的示例，我们可以测试新创建的项目，或者继续开发并删除现有的</st> `<st c="60889">WeatherForecast</st>`
    <st c="60904">操作，继续开发业务项目要求的 API 操作。</st>
- en: <st c="61030">When we want to test</st> <st c="61052">our developed API, we
    can simply hit</st> *<st c="61089">F5</st>* <st c="61091">on our keyboard to launch</st>
    <st c="61117">a debugging process or head over to the top navigation bar, expand</st>
    **<st c="61185">Debug</st>**<st c="61190">, and select</st> **<st c="61203">Start
    Debugging</st>** <st c="61218">to launch our API in a browser.</st> <st c="61251">This
    will open the Swagger UI, which shows our Swagger file with all the operations
    that exist in our Web API.</st> <st c="61362">Swagger provides a convenient way
    to design, document, and consume our API.</st> <st c="61438">It uses</st> **<st
    c="61446">OpenAPI</st>** <st c="61453">specification and provides a set of open
    source</st> <st c="61501">and commercial tools to work with the Swagger file,
    which is in a JSON format describing our API operations.</st> <st c="61611">An
    OpenAPI definition is also consumed by Power Platform when creating a custom connector</st>
    <st c="61700">and it needs to be in OpenAPI 2.0 (previously known as</st> <st
    c="61756">Swagger) format.</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61030">当我们想测试</st> <st c="61052">已开发的 API 时，我们可以简单地按下</st> *<st c="61089">F5</st>*
    <st c="61091">键启动调试过程，或者前往顶部导航栏，展开</st> **<st c="61185">调试</st>**<st c="61190">，并选择</st>
    **<st c="61203">开始调试</st>** <st c="61218">以在浏览器中启动我们的 API。</st> <st c="61251">这将打开
    Swagger UI，显示我们的 Swagger 文件，其中包含 Web API 中所有存在的操作。</st> <st c="61362">Swagger
    提供了一种方便的方式来设计、文档化并使用我们的 API。</st> <st c="61438">它使用</st> **<st c="61446">OpenAPI</st>**
    <st c="61453">规范，并提供了一组开源和商业工具来处理 Swagger 文件，该文件采用 JSON 格式描述我们的 API 操作。</st> <st
    c="61501">OpenAPI 定义在创建自定义连接器时也被 Power Platform 使用</st> <st c="61611">，并且它必须采用
    OpenAPI 2.0（之前称为</st> <st c="61756">Swagger）格式。</st>
- en: <st c="61772">When we are ready with our API and would like to test it in the
    Power Apps application or Power Automate flow, we can add Power Platform as a
    connected service.</st> <st c="61934">This way, Visual Studio will automatically
    create a custom connector for us in Power Platform.</st> <st c="62029">To do this,
    we head to our Web API project in Visual Studio.</st> <st c="62090">Inside</st>
    **<st c="62097">Solution Explorer</st>**<st c="62114">, we expand our project
    so that we are able to see</st> **<st c="62165">Connected Services</st>** <st
    c="62183">|</st> **<st c="62186">Add</st>** <st c="62189">|</st> **<st c="62192">Microsoft
    Power Platform</st>**<st c="62216">. This will open a new tab, opened in the</st>
    **<st c="62258">Connected Services</st>** <st c="62276">part, and a</st> **<st
    c="62289">Connect to Microsoft Power</st>** **<st c="62316">Platform</st>** <st
    c="62324">window:</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61772">当我们准备好 API，并希望在 Power Apps 应用程序或 Power Automate 流程中测试它时，我们可以将
    Power Platform 添加为连接的服务。</st> <st c="61934">这样，Visual Studio 将自动为我们在 Power Platform
    中创建一个自定义连接器。</st> <st c="62029">为此，我们前往 Visual Studio 中的 Web API 项目。</st> <st
    c="62090">在</st> **<st c="62097">解决方案资源管理器</st>**<st c="62114">中，我们展开项目，以便看到</st>
    **<st c="62165">连接的服务</st>** <st c="62183">|</st> **<st c="62186">添加</st>** <st
    c="62189">|</st> **<st c="62192">Microsoft Power Platform</st>**<st c="62216">。这将打开一个新标签页，并显示在</st>
    **<st c="62258">连接的服务</st>** <st c="62276">部分，出现一个</st> **<st c="62289">连接到 Microsoft
    Power</st>** **<st c="62316">平台</st>** <st c="62324">的窗口：</st>
- en: '![Figure 9.10 – Adding Power Platform as a connected service](img/B22208_09_10.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 将 Power Platform 添加为连接的服务](img/B22208_09_10.jpg)'
- en: <st c="62796">Figure 9.10 – Adding Power Platform as a connected service</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62796">图 9.10 – 将 Power Platform 添加为连接的服务</st>
- en: <st c="62854">This new window holds all parameters for a new custom connector.</st>
    <st c="62920">Before creating it, we need to make sure that we are signed in.</st>
    <st c="62984">If not, in the top-right corner, we can sign in and provide the
    right credentials of the user.</st> <st c="63079">Once authenticated, we select
    a Power Platform environment into which we would like to deploy our custom connector.</st>
    <st c="63195">In the</st> **<st c="63202">Power Platform Solutions</st>** <st
    c="63226">dropdown, we select the solution in which the connector will</st> <st
    c="63288">be deployed.</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62854">这个新窗口包含所有用于创建新自定义连接器的参数。</st> <st c="62920">在创建之前，我们需要确保已经登录。</st>
    <st c="62984">如果没有，在右上角，我们可以登录并提供正确的用户凭据。</st> <st c="63079">身份验证通过后，我们选择一个 Power
    Platform 环境，将自定义连接器部署到其中。</st> <st c="63195">在</st> **<st c="63202">Power Platform
    解决方案</st>** <st c="63226">下拉菜单中，我们选择要部署连接器的解决方案。</st>
- en: <st c="63300">Next, we connect</st> <st c="63317">to the custom</st> <st c="63331">connector.</st>
    <st c="63343">In our case, we are creating it for the first time, so we will click</st>
    **<st c="63412">+</st>** <st c="63413">(the plus icon) to create a new custom
    connector.</st> <st c="63464">We will check</st> **<st c="63478">Auto-generate
    the OpenAPI V2 specification</st>** <st c="63520">so that Visual Studio generates
    the OpenAPI definition for us.</st> <st c="63584">Lastly, we will create a</st>
    **<st c="63609">public dev tunnel</st>** <st c="63626">by clicking</st> **<st
    c="63639">+</st>** <st c="63640">(the plus icon) next</st> <st c="63661">to</st>
    **<st c="63665">Select a public dev tunnel</st>**<st c="63691">, which will be
    used for debugging purposes between the custom connector and our instance of</st>
    <st c="63784">Visual Studio.</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63300">接下来，我们连接</st> <st c="63317">到自定义</st> <st c="63331">连接器。</st>
    <st c="63343">在我们的案例中，由于我们第一次创建它，因此我们将点击</st> **<st c="63412">+</st>** <st c="63413">(加号图标)来创建一个新的自定义连接器。</st>
    <st c="63464">我们将勾选</st> **<st c="63478">自动生成 OpenAPI V2 规范</st>** <st c="63520">，以便
    Visual Studio 为我们生成 OpenAPI 定义。</st> <st c="63584">最后，我们将通过点击</st> **<st c="63609">+</st>**
    <st c="63626">（加号图标）创建一个</st> **<st c="63639">公共开发隧道</st>** <st c="63640">，点击</st>
    **<st c="63661">选择公共开发隧道</st>**<st c="63691">，该隧道将用于在自定义连接器与我们实例中的</st> <st c="63784">Visual
    Studio 之间进行调试。</st>
- en: <st c="63798">Dev tunnel</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63798">开发隧道</st>
- en: <st c="63809">Dev tunnels in Visual Studio provide a quick and secure way to
    test Web APIs across the internet.</st> <st c="63908">In our case within Power
    Platform services, it will create a connection between our local machine, which
    is running Visual Studio, and a Power Platform service that is utilizing the custom
    connector (i.e., the Power Apps application using a custom connector).</st> <st
    c="64168">This approach is intended to create ad hoc connections for development
    and testing purposes only, not for</st> <st c="64274">production workloads.</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63809">Visual Studio 中的开发隧道提供了一种快速、安全的方式来测试互联网中的 Web API。</st> <st c="63908">在我们的案例中，Power
    Platform 服务将创建一个连接，连接我们本地运行 Visual Studio 的机器和一个使用自定义连接器的 Power Platform 服务（即使用自定义连接器的
    Power Apps 应用程序）。</st> <st c="64168">这种方法旨在为开发和测试目的创建临时连接，不适用于</st> <st c="64274">生产工作负载。</st>
- en: <st c="64295">The following screenshot shows</st> <st c="64326">us how a public
    dev tunnel</st> <st c="64353">can be created after connecting to Microsoft Power
    Platform.</st> <st c="64415">When we click on</st> **<st c="64432">Next</st>**<st
    c="64436">, we can see the</st> **<st c="64453">Summary of changes</st>** <st
    c="64471">screen, which informs us that a custom connector will be created in
    Microsoft Power Platform.</st> <st c="64566">We confirm this by clicking</st>
    **<st c="64594">Finish</st>**<st c="64600">. The process will build our project,
    configure a dev tunnel, generate a Swagger JSON file (OpenAPI specification file),
    and create a custom connector in our selected Power</st> <st c="64773">Platform
    environment:</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64295">以下截图展示了</st> <st c="64326">我们如何在连接到 Microsoft Power Platform 后创建一个公共开发隧道。</st>
    <st c="64353">当我们点击</st> **<st c="64432">下一步</st>**<st c="64436">时，我们会看到</st>
    **<st c="64453">更改摘要</st>** <st c="64471">页面，通知我们将在 Microsoft Power Platform 中创建一个自定义连接器。</st>
    <st c="64566">我们通过点击</st> **<st c="64594">完成</st>**<st c="64600">来确认这一操作。该过程将构建我们的项目，配置开发隧道，生成
    Swagger JSON 文件（OpenAPI 规范文件），并在我们选择的 Power</st> <st c="64773">Platform 环境中创建一个自定义连接器：</st>
- en: '![Figure 9.11 – Creating a custom connector](img/B22208_09_11.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 创建自定义连接器](img/B22208_09_11.jpg)'
- en: <st c="65285">Figure 9.11 – Creating a custom connector</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65285">图 9.11 – 创建自定义连接器</st>
- en: <st c="65326">Now that the dev tunnel and custom connector are created, if we
    run our API now (by pressing</st> *<st c="65420">F5</st>* <st c="65422">or clicking
    on</st> **<st c="65438">Debug</st>** <st c="65443">|</st> **<st c="65446">Start
    Debugging</st>**<st c="65461">), we will see that Visual Studio will use the</st>
    *<st c="65509">dev tunnels</st>* <st c="65520">feature and will expose our web
    API to the public endpoint, which we are also informed about in the notification
    that has opened in the web browser.</st> <st c="65670">Once we confirm it, the
    dev tunnel is established and we can use a custom connector in Power Platform,
    which is now connected to our Visual Studio dev environment.</st> <st c="65834">This
    is a very convenient way for debugging our Web API and custom connector.</st>
    <st c="65912">We can now use this custom connector in any Power Apps application
    or other Power Platform services and set breakpoints in the source code of our
    Web API in Visual Studio for the debugging purposes.</st> <st c="66111">We will
    be able to see in Visual Studio that our breakpoint was hit by debug engine once
    the API operation is executed .</st> <st c="66232">This will allow us to continue
    with the</st> <st c="66272">debugging/testing process.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65326">现在开发隧道和自定义连接器已创建，如果我们现在运行我们的 API（通过按下</st> *<st c="65420">F5</st>*
    <st c="65422">或点击</st> **<st c="65438">调试</st>** <st c="65443">|</st> **<st c="65446">开始调试</st>**<st
    c="65461">），我们将看到 Visual Studio 使用</st> *<st c="65509">开发隧道</st>* <st c="65520">功能，并将我们的
    Web API 暴露到公共端点，通知也会在 Web 浏览器中弹出，告知我们这一点。</st> <st c="65670">确认后，开发隧道建立成功，我们可以在
    Power Platform 中使用这个自定义连接器，它现在已连接到我们的 Visual Studio 开发环境。</st> <st c="65834">这是调试我们的
    Web API 和自定义连接器的非常便捷的方法。</st> <st c="65912">我们现在可以在任何 Power Apps 应用程序或其他 Power
    Platform 服务中使用这个自定义连接器，并在 Visual Studio 中的 Web API 源代码中设置断点进行调试。</st> <st c="66111">一旦
    API 操作被执行，我们就能在 Visual Studio 中看到调试引擎已触发我们设置的断点。</st> <st c="66232">这将帮助我们继续进行</st>
    <st c="66272">调试/测试过程。</st>
- en: <st c="66298">As a citizen developer</st> <st c="66321">or an app maker, we
    can now</st> <st c="66349">see the newly created custom connector in Power Apps.</st>
    <st c="66404">Navigate to</st> **<st c="66416">Power Automate</st>** <st c="66430">or</st>
    **<st c="66434">Power Apps</st>**<st c="66444">. Either click on</st> **<st c="66462">Solutions</st>**
    <st c="66471">in the left navigation bar and open the solution that was used to
    deploy the custom connector from Visual Studio, or go to</st> **<st c="66595">Custom
    connectors</st>** <st c="66612">and find our custom connector and click</st> **<st
    c="66653">Edit</st>** <st c="66657">(the</st> <st c="66663">pencil icon):</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66298">作为一名公民开发者</st> <st c="66321">或应用程序开发者，我们现在可以</st> <st c="66349">在
    Power Apps 中看到新创建的自定义连接器。</st> <st c="66404">导航到</st> **<st c="66416">Power Automate</st>**
    <st c="66430">或</st> **<st c="66434">Power Apps</st>**<st c="66444">。可以点击左侧导航栏中的**<st
    c="66462">解决方案</st>** <st c="66471">，并打开用于从 Visual Studio 部署自定义连接器的解决方案，或者进入</st>
    **<st c="66595">自定义连接器</st>** <st c="66612">并找到我们的自定义连接器，然后点击</st> **<st c="66653">编辑</st>**
    <st c="66657">(铅笔图标)：</st>
- en: '![Figure 9.12 – Opening the custom connector definition](img/B22208_09_12.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 打开自定义连接器定义](img/B22208_09_12.jpg)'
- en: <st c="67132">Figure 9.12 – Opening the custom connector definition</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67132">图 9.12 – 打开自定义连接器定义</st>
- en: <st c="67185">We can see that the host and the URL in the definition of the
    API operations are pointing to the</st> <st c="67283">dev tunnel.</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67185">我们可以看到 API 操作定义中的主机和 URL 正指向</st> <st c="67283">开发隧道（dev tunnel）。</st>
- en: <st c="67294">We can create a Power Apps application, a flow, or anything else
    in Power Platform and utilize the custom connector.</st> <st c="67412">As long
    as the connection via the dev tunnel is active in Visual Studio, our custom connector
    will be able to get the results of an API operation that we will be calling.</st>
    <st c="67583">Using the</st> `<st c="67593">pac connector list</st>` <st c="67611">command,
    we will be able to see all custom connectors registered in Dataverse and their
    display names and IDs.</st> <st c="67723">As an example, we can use this information
    about connectors to create a sample canvas app from the PAC CLI.</st> <st c="67831">The
    app</st> <st c="67838">is generated based</st> <st c="67857">on the OpenAI definition
    from a</st> <st c="67890">custom connector:</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67294">我们可以在 Power Platform 中创建 Power Apps 应用程序、流或其他任何内容，并利用自定义连接器。</st>
    <st c="67412">只要 Visual Studio 中的开发隧道连接处于活动状态，我们的自定义连接器就能够获取我们将要调用的 API 操作的结果。</st>
    <st c="67583">使用</st> `<st c="67593">pac connector list</st>` <st c="67611">命令，我们将能够看到所有在
    Dataverse 中注册的自定义连接器及其显示名称和 ID。</st> <st c="67723">例如，我们可以使用关于连接器的信息，从 PAC CLI
    创建一个示例画布应用。</st> <st c="67831">该应用</st> <st c="67838">是基于</st> <st c="67857">来自自定义连接器的
    OpenAI 定义生成的：</st> <st c="67890">自定义连接器示例：</st>
- en: '[PRE4]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="67980">Creating a Power Platform custom connector with Azure APIM</st>
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="67980">使用 Azure APIM 创建 Power Platform 自定义连接器</st>
- en: <st c="68039">Let us continue with the example.</st> <st c="68074">Let’s say</st>
    <st c="68083">that our pro-developers</st> <st c="68108">are progressing with
    their new Web API.</st> <st c="68148">They are using DevOps principles to build,
    test, and deploy the Web API to a test environment.</st> <st c="68243">The test
    environment differs from the local development machine, as this environment is
    now provisioned in Azure.</st> <st c="68357">For our Web API to be hosted, we
    can choose from the plethora of application hosting services available in Azure.</st>
    <st c="68471">We will be using Azure App Services, a PaaS service that is capable
    of hosting</st> <st c="68550">Web APIs.</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68039">让我们继续举例。</st> <st c="68074">假设</st> <st c="68083">我们的专业开发人员</st>
    <st c="68108">正在推进他们的新 Web API。</st> <st c="68148">他们正在使用 DevOps 原则来构建、测试并将 Web
    API 部署到测试环境中。</st> <st c="68243">测试环境不同于本地开发机器，因为此环境现在已在 Azure 中进行配置。</st> <st
    c="68357">为了托管我们的 Web API，我们可以选择 Azure 中提供的众多应用托管服务。</st> <st c="68471">我们将使用
    Azure 应用服务，这是一个能够托管</st> <st c="68550">Web API 的 PaaS 服务。</st>
- en: <st c="68559">As with DevOps best practices, we are following an IaC approach
    and describing the environment in a Bicep or ARM template file.</st> <st c="68688">This
    IaC definition file is also version-controlled in our Azure DevOps/GitHub repository,
    so we can keep track of changes and run validation checks over the</st> <st c="68846">template
    file.</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68559">与 DevOps 最佳实践一样，我们遵循 IaC 方法，并在 Bicep 或 ARM 模板文件中描述环境。</st> <st
    c="68688">此 IaC 定义文件也在我们的 Azure DevOps/GitHub 仓库中进行版本控制，因此我们可以跟踪更改并对模板文件执行验证检查。</st>
    <st c="68846">模板文件。</st>
- en: <st c="68860">The CI/CD pipelines make sure that our Web API, as an artifact,
    is deployable and we deploy it automatically to the newly provisioned test environment.</st>
    <st c="69013">Once our API is deployed to a hosting platform, we are ready to
    connect our Web API to Azure</st> <st c="69106">API Management.</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68860">CI/CD 流水线确保我们的 Web API 作为构件是可部署的，并且我们将其自动部署到新配置的测试环境中。</st> <st
    c="69013">一旦我们的 API 部署到托管平台，我们就准备好将 Web API 连接到 Azure</st> <st c="69106">API 管理。</st>
- en: <st c="69121">Azure services such as Logic Apps, App Service, Functions, and
    Container Apps provide a seamless integration between the Web API and the Azure
    APIM to register the API in APIM.</st> <st c="69299">However, Azure APIM also
    provides options to add APIs by providing definition files, such as OpenAPI, WSDL,
    OData, and WADL.</st> <st c="69424">Of course, we can also start completely from
    scratch and manually add all properties and operations of</st> <st c="69527">the
    API.</st>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="69121">Azure 服务，如 Logic Apps、App Service、Functions 和 Container Apps，提供了
    Web API 与 Azure APIM 之间的无缝集成，用于在 APIM 中注册 API。</st> <st c="69299">然而，Azure APIM
    也提供了通过提供定义文件（如 OpenAPI、WSDL、OData 和 WADL）来添加 API 的选项。</st> <st c="69424">当然，我们也可以完全从头开始，手动添加
    API 的所有属性和操作。</st> <st c="69527">API。</st>
- en: '![Figure 9.13 – Creating new APIs in APIM](img/B22208_09_13.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 在 APIM 中创建新 API](img/B22208_09_13.jpg)'
- en: <st c="70529">Figure 9.13 – Creating new APIs in APIM</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="70529">图 9.13 – 在 APIM 中创建新 API</st>
- en: <st c="70568">APIM provides a convenient</st> <st c="70595">way to configure</st>
    *<st c="70613">mock responses</st>*<st c="70627">. This allows to speed up development
    time, as pro-developers</st> <st c="70688">can add all operations to Azure APIM
    with mocked responses, while app makers in Power Platform utilize such an API
    and build the rest of the service in Power Platform.</st> <st c="70857">For example,
    citizen developers use the custom connector that has all the operations available,
    but the responses are mocked by APIM.</st> <st c="70991">Once the backend Web
    API is developed and ready to be used, pro-developers disable mock responses on
    the operation and leave it to the Web API to perform the logic and return correct
    responses.</st> <st c="71185">On the other hand, the frontend that has been developed
    by citizen developers does not see any differences – only the returned data from
    the API</st> <st c="71330">is different.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="70568">APIM 提供了一种便捷的</st> <st c="70595">配置</st> *<st c="70613">模拟响应</st>*<st
    c="70627">的方式。这有助于加快开发进度，因为专业开发人员</st> <st c="70688">可以将所有操作添加到 Azure APIM 中并模拟响应，而
    Power Platform 中的应用开发人员则使用这样的 API 并在 Power Platform 中构建其余服务。</st> <st c="70857">例如，公民开发人员使用已包含所有操作的自定义连接器，但响应是由
    APIM 模拟的。</st> <st c="70991">一旦后端 Web API 开发完成并准备好使用，专业开发人员会禁用操作上的模拟响应，将逻辑交由 Web
    API 执行并返回正确的响应。</st> <st c="71185">另一方面，由公民开发人员开发的前端并不会看到任何差异——只有从 API 返回的数据</st>
    <st c="71330">有所不同。</st>
- en: <st c="71343">Once our API is ready to be consumed, we can create a connector
    in Power Platform directly from</st> <st c="71440">Azure APIM:</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="71343">一旦我们的 API 准备好被使用，我们可以直接在 Power Platform 中从</st> <st c="71440">Azure
    APIM 创建一个连接器：</st>
- en: '![Figure 9.14 – Creating a custom connector from Azure APIM](img/B22208_09_14.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 从 Azure APIM 创建自定义连接器](img/B22208_09_14.jpg)'
- en: <st c="72427">Figure 9.14 – Creating a custom connector from Azure APIM</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="72427">图 9.14 – 从 Azure APIM 创建自定义连接器</st>
- en: <st c="72484">After we click on the</st> **<st c="72507">Create a connector</st>**
    <st c="72525">button, the next step asks us to provide the</st> **<st c="72571">API</st>**
    <st c="72574">name, which will be used</st> <st c="72599">for the custom</st>
    <st c="72614">connector.</st> <st c="72626">We need to select the one that we
    were working on.</st> <st c="72677">Following that, we need to provide the Power
    Platform environment and API display name, as this will represent the custom connector
    that will be deployed to the selected environment.</st> <st c="72860">Once we
    have provided this information, we can proceed by clicking on the</st> **<st c="72934">Create</st>**
    <st c="72940">button.</st> <st c="72949">After that, a new custom connector will
    appear in the selected Power Platform environment and will be ready to be used
    by any app maker in</st> <st c="73088">Power Platform.</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="72484">当我们点击</st> **<st c="72507">创建连接器</st>** <st c="72525">按钮时，接下来的步骤要求我们提供</st>
    **<st c="72571">API</st>** <st c="72574">名称，该名称将用于</st> <st c="72599">自定义</st>
    <st c="72614">连接器。</st> <st c="72626">我们需要选择我们正在使用的那个。</st> <st c="72677">接下来，我们需要提供
    Power Platform 环境和 API 显示名称，因为这将代表将部署到所选环境的自定义连接器。</st> <st c="72860">一旦我们提供了这些信息，就可以通过点击</st>
    **<st c="72934">创建</st>** <st c="72940">按钮继续。</st> <st c="72949">之后，一个新的自定义连接器将在选定的
    Power Platform 环境中出现，并将准备好供任何 Power Platform 中的应用开发人员使用。</st>
- en: <st c="73103">Applying ALM to custom connectors</st>
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="73103">将 ALM 应用于自定义连接器</st>
- en: <st c="73137">The preceding examples</st> <st c="73160">demonstrated how to
    create a custom connector</st> <st c="73206">through either Visual Studio or Azure
    APIM.</st> <st c="73251">However, if we would like to use CI/CD pipelines to deploy
    our custom connectors to different environments, it is good to know how to follow
    a code-first approach to operate with custom connectors in order to deploy them
    to different target environments.</st> <st c="73506">We will be using Power Platform
    CLI commands for</st> <st c="73555">these purposes.</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73137">前面的示例</st> <st c="73160">展示了如何通过 Visual Studio 或 Azure APIM 创建自定义连接器。</st>
    <st c="73206">然而，如果我们希望使用 CI/CD 流水线将我们的自定义连接器部署到不同的环境，了解如何采用代码优先的方法来操作自定义连接器，并将其部署到不同的目标环境是很有帮助的。</st>
    <st c="73251">我们将使用 Power Platform CLI 命令来实现</st> <st c="73506">这些目的。</st>
- en: <st c="73570">In order to create a custom connector using the PAC CLI, we need
    to obtain the API definition file and generate supporting properties files.</st>
    <st c="73712">An API definition file is an OpenAPI 2.0 (Swagger) definition file
    that describes the API and its operations.</st> <st c="73822">We can either create
    a Swagger definition file from scratch or obtain it from the existing custom connector
    that we created in the</st> <st c="73953">previous exercise.</st>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73570">为了使用 PAC CLI 创建自定义连接器，我们需要获取 API 定义文件并生成支持的属性文件。</st> <st c="73712">API
    定义文件是一个 OpenAPI 2.0（Swagger）定义文件，描述了 API 及其操作。</st> <st c="73822">我们可以从头开始创建 Swagger
    定义文件，或者从我们在</st> <st c="73953">前一个练习中创建的自定义连接器中获取它。</st>
- en: <st c="73971">Along with the API definition file, we will require the API properties
    file.</st> <st c="74049">An API properties file is a JSON file that holds supporting
    information for our connector, such as authentication information, brand color,
    publisher information, and</st> <st c="74216">so on.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73971">与 API 定义文件一起，我们还需要 API 属性文件。</st> <st c="74049">API 属性文件是一个 JSON
    文件，包含我们连接器的支持信息，如认证信息、品牌颜色、发布者信息等。</st> <st c="74216">等等。</st>
- en: <st c="74222">Optionally, we can use additional files such as icons files, script
    files (CSX files), and</st> <st c="74314">settings files.</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="74222">可选地，我们可以使用附加文件，如图标文件、脚本文件（CSX 文件）和</st> <st c="74314">设置文件。</st>
- en: <st c="74329">We can start creating a custom connector from scratch using the</st>
    `<st c="74394">pac connector init</st>` <st c="74412">command with additional
    parameters that will generate the additional files needed for the custom connector.</st>
    <st c="74521">Next, we can see an example that generates an API properties file
    with an API key that will be used to authenticate requests against the custom
    connector.</st> <st c="74676">It also generates settings files, a properties file,
    and a script file in a separate</st> `<st c="74761">DemoBankAPI</st>` <st c="74772">folder:</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="74329">我们可以使用</st> `<st c="74394">pac connector init</st>` <st c="74412">命令从头开始创建一个自定义连接器，并附加其他参数来生成自定义连接器所需的附加文件。</st>
    <st c="74521">接下来，我们可以看到一个示例，生成一个带有 API 密钥的 API 属性文件，用于验证针对自定义连接器的请求。</st> <st
    c="74676">它还会生成设置文件、属性文件和脚本文件，所有这些都位于一个单独的</st> `<st c="74761">DemoBankAPI</st>`
    <st c="74772">文件夹中：</st>
- en: '[PRE5]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="74910">If we want to generate an API definition file from an existing
    custom connector that we have created in the previous examples, we can use the</st>
    `<st c="75053">pac connector list</st>` <st c="75071">command to get a list of
    all the connectors in the current environment with the connector IDs of</st> <st
    c="75169">each connector.</st>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="74910">如果我们想从之前创建的自定义连接器生成 API 定义文件，可以使用</st> `<st c="75053">pac connector
    list</st>` <st c="75071">命令获取当前环境中所有连接器的列表及其连接器 ID。</st>
- en: <st c="75184">Once we have found the connector ID information for a custom connector,
    we can use</st> `<st c="75268">pac connector download --connector-id <CONNECTOR-ID></st>`
    <st c="75320">to download</st> `<st c="75333">apiDefinition.json</st>` <st c="75351">and</st>
    `<st c="75356">apiProperties.json</st>` <st c="75374">for the selected</st> <st
    c="75392">custom connector.</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="75184">找到自定义连接器的连接器 ID 信息后，我们可以使用</st> `<st c="75268">pac connector download
    --connector-id <CONNECTOR-ID></st>` <st c="75320">下载</st> `<st c="75333">apiDefinition.json</st>`
    <st c="75351">和</st> `<st c="75356">apiProperties.json</st>` <st c="75374">以供所选</st>
    <st c="75392">自定义连接器使用。</st>
- en: <st c="75409">At this point, we should already commit our files to the repository
    so that any modification is version-controlled.</st> <st c="75526">We will perform
    changes to the files so that they reflect the right values for the target environment.</st>
    <st c="75629">This means changing the</st> *<st c="75653">host</st>* <st c="75657">value,
    which is an endpoint to which our custom connector is pointing, as well as any
    additional</st> <st c="75755">property values.</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="75409">此时，我们应该已经将文件提交到仓库，以便任何修改都能进行版本控制。</st> <st c="75526">我们将对文件进行更改，以使其反映目标环境的正确值。</st>
    <st c="75629">这意味着更改</st> *<st c="75653">host</st>* <st c="75657">值，该值是我们自定义连接器指向的端点，以及任何其他</st>
    <st c="75755">属性值。</st>
- en: <st c="75771">When we want to create</st> <st c="75794">a custom connector in
    a target</st> <st c="75826">environment, we can use a simple</st> `<st c="75859">pac
    connector create --settings-file .\settings.json</st>` <st c="75911">command,
    since the settings file already includes information about all supporting files
    as well as the environment value for deploying to the target environment.</st>
    <st c="76075">Next, we can see a sample</st> `<st c="76101">settings.json</st>`
    <st c="76114">file:</st>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="75771">当我们想要在目标</st> <st c="75794">环境中创建自定义连接器时，可以使用简单的</st> `<st c="75859">pac
    connector create --settings-file .\settings.json</st>` <st c="75911">命令，因为设置文件中已包含有关所有支持文件的信息，以及部署到目标环境的环境值。</st>
    <st c="76075">接下来，我们可以看到一个示例</st> `<st c="76101">settings.json</st>` <st c="76114">文件：</st>
- en: '[PRE6]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="76315">Values in</st> `<st c="76326">settings.json</st>` <st c="76339">and
    any supporting file, such as an API properties file, which holds information for
    authentication, should be changed and parameterized so that we will not have values
    hardcoded in the file, but rather, only variable names, which get changed with
    actual values during the</st> <st c="76613">CI/CD pipelines.</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="76315">在</st> `<st c="76326">settings.json</st>` <st c="76339">以及任何支持文件（如用于身份验证的
    API 属性文件）中的值，应该进行更改和参数化，以确保文件中不会硬编码值，而是只使用变量名，这些变量在</st> <st c="76613">CI/CD 流水线</st>
    <st c="76613">中根据实际值进行更改。</st>
- en: <st c="76629">Another variation of the</st> `<st c="76655">create</st>` <st
    c="76661">command, using manually defined values, is</st> <st c="76705">as follows:</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="76629">另一种使用手动定义值的</st> `<st c="76655">create</st>` <st c="76661">命令变体如下：</st>
- en: '[PRE7]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="76874">When we need to update the custom connector in the target environments,
    we should use</st> `<st c="76961">pac connector update --</st>``<st c="76984">settings-file
    .\settings.json</st>`<st c="77014">.</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="76874">当我们需要更新目标环境中的自定义连接器时，我们应该使用</st> `<st c="76961">pac connector
    update --</st>``<st c="76984">settings-file .\settings.json</st>`<st c="77014">。</st>
- en: <st c="77015">Once we have a custom connector created in the target environment,
    we can use it to test the operations in our existing application or create a new
    dummy application using</st> `<st c="77188">pac canvas create --msapp <new-msapp-file>
    --connector-id <connector-id></st>`<st c="77260">. We are now ready</st> <st c="77278">to
    test our newly</st> <st c="77297">deployed</st> <st c="77305">connector.</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="77015">一旦我们在目标环境中创建了自定义连接器，就可以使用它来测试现有应用程序中的操作，或者使用</st> `<st c="77188">pac
    canvas create --msapp <new-msapp-file> --connector-id <connector-id></st>`<st
    c="77260">创建一个新的虚拟应用程序。</st>我们现在准备好</st> <st c="77278">测试我们新部署的</st> <st c="77297">连接器。</st>
- en: <st c="77316">Summary</st>
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="77316">总结</st>
- en: <st c="77324">This chapter covered the important aspect of the methodology that
    embraces collaboration, agility, and innovation.</st> <st c="77440">Organizations
    should recognize that fusion teams can lead to reduced time to solve business
    challenges since these teams break down the traditional barriers between business
    users, pro-developers, and IT professionals with their agile approach</st> <st
    c="77684">and synergy.</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="77324">本章介绍了采用协作、敏捷和创新方法的重要方面。</st> <st c="77440">组织应该认识到，融合团队可以缩短解决业务挑战的时间，因为这些团队打破了商业用户、专业开发人员和
    IT 专业人员之间的传统障碍，通过敏捷的方法</st> <st c="77684">和协同效应。</st>
- en: <st c="77696">Organizations should also adopt best practices that are coming
    from open source development, which enhance the possibilities of app makers within
    the organization, as we are empowering makers to be able to discover and reuse
    what has already been done internally.</st> <st c="77961">Similar to the traditional
    software development tools, Power Platform provides all the tools to support this
    experience, such as Catalog Manager and integrations</st> <st c="78123">with Azure.</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="77696">组织还应该采纳来自开源开发的最佳实践，这些实践增强了组织内部应用开发者的可能性，因为我们赋予开发者发现和重用已有成果的能力。</st>
    <st c="77961">与传统软件开发工具类似，Power Platform 提供了支持这一体验的所有工具，如目录管理器和与</st> <st c="78123">Azure
    的集成。</st>
- en: <st c="78134">Integrations with Azure are even more important for organizations
    that are already onboarded on Azure and running business workloads on this public
    cloud.</st> <st c="78290">With integration in mind, we investigated some common
    cases of how Power Platform can be connected with</st> <st c="78394">Azure services.</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="78134">对于已经在 Azure 上注册并在该公共云上运行业务工作负载的组织来说，Azure 集成更加重要。</st> <st c="78290">考虑到集成，我们调查了
    Power Platform 如何与</st> <st c="78394">Azure 服务进行连接的一些常见案例。</st>
- en: <st c="78409">We finished the chapter with an example of a pro-developer experience
    when building a Web API that will be used as a backend for the Power Platform
    services and how Visual Studio enables quicker development and efficient testing
    experience.</st> <st c="78651">When the Web API was ready, we showed how fast
    and smooth the integration between Azure APIM and Power Platform services</st>
    <st c="78772">can be.</st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="78409">我们通过一个专业开发人员在构建Web API的示例结束了本章，Web API将作为Power Platform服务的后端使用，并且展示了Visual
    Studio如何促进更快的开发和高效的测试体验。</st> <st c="78651">当Web API准备就绪时，我们展示了Azure APIM与Power
    Platform服务之间的集成是多么快速和顺畅</st> <st c="78772">。</st>
- en: <st c="78779">The next chapter will focus on pro-developer extensibility in
    Power Platform.</st> <st c="78858">We will continue exploring the possibilities
    for pro-developers when it comes to connectors, code components, and more, with
    examples that can be reused in the</st> <st c="79018">DevOps process.</st>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="78779">下一章将聚焦于Power Platform中的专业开发人员扩展性。</st> <st c="78858">我们将继续探索专业开发人员在连接器、代码组件等方面的可能性，并通过可在</st>
    <st c="79018">DevOps流程中重用的示例。</st>
- en: <st c="79033">Further reading</st>
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="79033">进一步阅读</st>
- en: <st c="79049">InnerSource</st> <st c="79062">fundamentals:</st> [<st c="79076">https://resources.github.com/innersource/fundamentals/</st>](https://resources.github.com/innersource/fundamentals/)
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="79049">InnerSource</st> <st c="79062">基础知识：</st> [<st c="79076">https://resources.github.com/innersource/fundamentals/</st>](https://resources.github.com/innersource/fundamentals/)
- en: <st c="79130">View Dataverse data in Microsoft</st> <st c="79164">Fabric:</st>
    [<st c="79172">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/azure-synapse-link-view-in-fabric</st>](https://learn.microsoft.com/en-us/power-apps/maker/data-platform/azure-synapse-link-view-in-fabric)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="79130">在Microsoft</st> <st c="79164">Fabric中查看Dataverse数据：</st> [<st
    c="79172">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/azure-synapse-link-view-in-fabric</st>](https://learn.microsoft.com/en-us/power-apps/maker/data-platform/azure-synapse-link-view-in-fabric)
- en: <st c="79270">Azure and Power Platform architecture</st> <st c="79309">examples:</st>
    [<st c="79319">https://learn.microsoft.com/en-us/azure/architecture/browse/?products=power-platform</st>](https://learn.microsoft.com/en-us/azure/architecture/browse/?products=power-platform)
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="79270">Azure和Power Platform架构</st> <st c="79309">示例：</st> [<st c="79319">https://learn.microsoft.com/en-us/azure/architecture/browse/?products=power-platform</st>](https://learn.microsoft.com/en-us/azure/architecture/browse/?products=power-platform)
- en: <st c="79403">Dev tunnels in Visual</st> <st c="79426">Studio:</st> [<st c="79434">https://learn.microsoft.com/en-us/connectors/custom-connectors/port-tunneling</st>](https://learn.microsoft.com/en-us/connectors/custom-connectors/port-tunneling)
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="79403">Visual Studio中的开发隧道：</st> [<st c="79434">https://learn.microsoft.com/en-us/connectors/custom-connectors/port-tunneling</st>](https://learn.microsoft.com/en-us/connectors/custom-connectors/port-tunneling)
- en: <st c="79511">Exporting APIs from Azure APIM to Power</st> <st c="79552">Platform:</st>
    [<st c="79562">https://learn.microsoft.com/en-us/azure/api-management/export-api-power-platform</st>](https://learn.microsoft.com/en-us/azure/api-management/export-api-power-platform)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="79511">从Azure APIM导出API到Power</st> <st c="79552">Platform：</st> [<st
    c="79562">https://learn.microsoft.com/en-us/azure/api-management/export-api-power-platform</st>](https://learn.microsoft.com/en-us/azure/api-management/export-api-power-platform)
- en: <st c="79642">Custom connectors with PAC</st> <st c="79670">CLI:</st> [<st c="79675">https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/connector</st>](https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/connector)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="79642">与PAC的自定义连接器</st> <st c="79670">CLI:</st> [<st c="79675">https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/connector</st>](https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/connector)
