- en: <st c="0">10</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">10</st>
- en: <st c="3">Enabling Pro-Dev Extensibility in Power Platform</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3">在 Power Platform 中启用专业开发人员扩展性</st>
- en: <st c="52">This chapter focuses on the capabilities provided by Power Platform
    to professional developers to extend the experience of business solutions built
    on top of Power Platform.</st> <st c="227">We will take a look at how Power Platform
    ensures the smooth integration of these extensibility options with ALM/DevOps
    processes in order to support the software development life cycle of</st> <st
    c="416">these components.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52">本章重点介绍了 Power Platform 为专业开发人员提供的能力，以扩展在 Power Platform 上构建的业务解决方案的体验。</st>
    <st c="227">我们将探讨 Power Platform 如何确保这些扩展选项与 ALM/DevOps 流程的顺利集成，以支持这些组件的软件开发生命周期。</st>
    <st c="416">这些组件。</st>
- en: <st c="433">We will start the chapter by looking into connectors and continue
    our work on custom connectors.</st> <st c="531">In the previous chapter, we showed
    how pro developers can build web APIs and deploy them to Power Platform directly
    from Visual Studio; here, we will explore the concept of using the PAC CLI to
    ensure we enable ALM for custom connectors.</st> <st c="769">We will also look
    into the other aspects of the custom connectors, such as environmental variables
    and connection references, and explain their role when moving solutions across
    different</st> <st c="957">target environments.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="433">我们将通过了解连接器开始本章内容，并继续研究自定义连接器。</st> <st c="531">在上一章中，我们展示了专业开发人员如何从
    Visual Studio 构建 Web API 并直接部署到 Power Platform；在本章中，我们将探讨使用 PAC CLI 的概念，以确保我们为自定义连接器启用
    ALM。</st> <st c="769">我们还将探讨自定义连接器的其他方面，如环境变量和连接引用，并解释它们在跨不同目标环境移动解决方案时的作用。</st>
    <st c="957">目标环境。</st>
- en: <st c="977">After that, we will discuss canvas components in Power Apps and
    the key benefits of using them.</st> <st c="1074">From there, we will delve into
    the Power Platform code components, more specifically the Power Apps component
    framework.</st> <st c="1195">For both canvas components and code components, we
    will explain the process of including them in the</st> <st c="1296">ALM process.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="977">之后，我们将讨论 Power Apps 中的 Canvas 组件以及使用它们的主要优势。</st> <st c="1074">接下来，我们将深入研究
    Power Platform 的代码组件，特别是 Power Apps 组件框架。</st> <st c="1195">对于 Canvas 组件和代码组件，我们将解释如何将它们包含在
    ALM 流程中。</st>
- en: <st c="1308">We will close this chapter with coverage of Power Pages, how pro
    developers can extend Power Pages with custom code, and how the ALM process can</st>
    <st c="1454">be implemented.</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1308">我们将在本章结束时介绍 Power Pages，专业开发人员如何通过自定义代码扩展 Power Pages，以及如何实现 ALM
    流程。</st> <st c="1454">实现。</st>
- en: <st c="1469">We will cover the following</st> <st c="1498">main topics:</st>
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1469">我们将涵盖以下</st> <st c="1498">主要主题：</st>
- en: <st c="1510">Enabling the power of integration –</st> <st c="1547">connectors</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1510">启用集成的力量 –</st> <st c="1547">连接器</st>
- en: <st c="1557">Overview of canvas components and the</st> <st c="1596">component
    library</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1557">Canvas 组件概览及</st> <st c="1596">组件库</st>
- en: <st c="1613">Getting to know the</st> <st c="1634">code components</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1613">了解</st> <st c="1634">代码组件</st>
- en: <st c="1649">ALM for</st> <st c="1658">Power Pages</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1649">Power Pages 的 ALM</st>
- en: <st c="1669">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1669">技术要求</st>
- en: <st c="1692">To follow this chapter, you need</st> <st c="1726">the following:</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1692">要跟随本章内容，您需要</st> <st c="1726">以下内容：</st>
- en: '**<st c="1740">Power Platform subscription</st>**<st c="1768">: You can sign
    up for a Power Platform development plan (</st>[<st c="1826">https://powerapps.microsoft.com/en-us/developerplan/</st>](https://powerapps.microsoft.com/en-us/developerplan/)<st
    c="1879">) if you already have a Microsoft Entra ID work account, or you can join
    the Microsoft 365 developer</st> <st c="1981">program (</st>[<st c="1990">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2054">).</st>'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="1740">Power Platform 订阅</st>**<st c="1768">：如果您已经拥有 Microsoft Entra
    ID 工作帐户，您可以注册 Power Platform 开发计划（</st>[<st c="1826">https://powerapps.microsoft.com/en-us/developerplan/</st>](https://powerapps.microsoft.com/en-us/developerplan/)<st
    c="1879">），或者您可以加入 Microsoft 365 开发者</st> <st c="1981">计划（</st>[<st c="1990">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2054">）。</st>'
- en: '**<st c="2057">Visual Studio Code</st>**<st c="2076">: We recommend using Visual
    Studio Code or Visual Studio with the Power Platform Tools extension, or the IDE
    of your choice.</st> <st c="2202">Visual Studio Code can be found here:</st> [<st
    c="2240">https://code.visualstudio.com/</st>](https://code.visualstudio.com/)<st
    c="2270">. Visual Studio is also available as a free Community</st> <st c="2324">edition:</st>
    [<st c="2333">https://visualstudio.microsoft.com/vs/community/</st>](https://visualstudio.microsoft.com/vs/community/)<st
    c="2381">.</st>'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2057">Visual Studio Code</st>**<st c="2076">：我们建议使用Visual Studio Code或带有Power
    Platform Tools扩展的Visual Studio，或者你选择的IDE。</st> <st c="2202">可以在此找到Visual Studio
    Code：</st> [<st c="2240">https://code.visualstudio.com/</st>](https://code.visualstudio.com/)<st
    c="2270">。Visual Studio也可以作为免费的Community版获取：</st> [<st c="2333">https://visualstudio.microsoft.com/vs/community/</st>](https://visualstudio.microsoft.com/vs/community/)<st
    c="2381">。</st>'
- en: '**<st c="2382">Power Platform CLI</st>**<st c="2401">: We will be using the
    PAC CLI inside the command line or terminal.</st> <st c="2470">Installation guidance
    can be found</st> <st c="2505">here:</st> [<st c="2511">https://learn.microsoft.com/en-us/power-platform/developer/cli/introduction?tabs=windows</st>](https://learn.microsoft.com/en-us/power-platform/developer/cli/introduction?tabs=windows)<st
    c="2599">.</st>'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2382">Power Platform CLI</st>**<st c="2401">：我们将在命令行或终端中使用PAC CLI。</st>
    <st c="2470">安装指南可以在此找到</st> <st c="2505">：</st> [<st c="2511">https://learn.microsoft.com/en-us/power-platform/developer/cli/introduction?tabs=windows</st>](https://learn.microsoft.com/en-us/power-platform/developer/cli/introduction?tabs=windows)<st
    c="2599">。</st>'
- en: '**<st c="2600">Azure DevOps or GitHub</st>**<st c="2623">: We can create an
    Azure DevOps service organization any time</st> *<st c="2686">for free</st>* <st
    c="2694">(</st>[<st c="2696">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st>](https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates)<st
    c="2778">).</st> <st c="2782">We can also create a GitHub handle and public repository
    (</st>[<st c="2840">https://github.com/signup</st>](https://github.com/signup)<st
    c="2866">), which is also</st> *<st c="2884">free</st>* <st c="2888">for</st>
    <st c="2893">public repositories.</st>'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2600">Azure DevOps或GitHub</st>**<st c="2623">：我们可以随时创建一个Azure DevOps服务组织</st>
    *<st c="2686">免费</st>* <st c="2694">（</st>[<st c="2696">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st>](https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates)<st
    c="2778">）。</st> <st c="2782">我们还可以创建GitHub账号和公共仓库（</st>[<st c="2840">https://github.com/signup</st>](https://github.com/signup)<st
    c="2866">），这对于</st> *<st c="2884">公共仓库</st>* <st c="2888">也是免费的。</st>'
- en: '**<st c="2913">Node.js</st>**<st c="2921">: To build PCF code components, you
    require Node.js.</st> <st c="2975">The LTS version is</st> <st c="2994">recommended
    (</st>[<st c="3007">https://nodejs.org/en</st>](https://nodejs.org/en)<st c="3029">).</st>'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2913">Node.js</st>**<st c="2921">：要构建PCF代码组件，你需要Node.js。</st> <st
    c="2975">推荐使用LTS版本</st> <st c="2994">（</st>[<st c="3007">https://nodejs.org/en</st>](https://nodejs.org/en)<st
    c="3029">）。</st>'
- en: '`<st c="3072">msbuild</st>` <st c="3079">(part of Visual Studio) or</st> `<st
    c="3107">dotnet build</st>` <st c="3119">tools (part of the .NET</st> <st c="3144">SDK:</st>
    [<st c="3149">https://learn.microsoft.com/en-us/dotnet/core/sdk</st>](https://learn.microsoft.com/en-us/dotnet/core/sdk)<st
    c="3198">).</st>'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="3072">msbuild</st>` <st c="3079">（Visual Studio的一部分）或</st> `<st c="3107">dotnet
    build</st>` <st c="3119">工具（.NET SDK的一部分：</st> [<st c="3149">https://learn.microsoft.com/en-us/dotnet/core/sdk</st>](https://learn.microsoft.com/en-us/dotnet/core/sdk)<st
    c="3198">）。</st>'
- en: <st c="3201">Enabling the power of the integration – connectors</st>
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3201">启用集成功能——连接器</st>
- en: <st c="3252">This section provides a deeper look into how connectors and custom
    connectors can be reused across environments with the help of ALM.</st> <st c="3387">We
    will take a look at the concepts of environmental variables and connection references,
    which are two important concepts for when we plan to scale.</st> <st c="3537">We
    will learn how solutions can be used to wrap connectors for potential reuse across</st>
    <st c="3623">different environments.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3252">本节将深入探讨如何借助ALM在不同环境中复用连接器和自定义连接器。</st> <st c="3387">我们将了解环境变量和连接引用的概念，这两个概念对于我们计划进行扩展时至关重要。</st>
    <st c="3537">我们将学习如何通过解决方案将连接器封装，以便在</st> <st c="3623">不同环境中进行潜在复用。</st>
- en: <st c="3646">Connectors</st>
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3646">连接器</st>
- en: <st c="3657">We were introduced to</st> <st c="3680">connectors in</st> [*<st
    c="3694">Chapter 2</st>*](B22208_02.xhtml#_idTextAnchor030)<st c="3703">. Our
    discussion on connectors so far has covered that connectors enable us to connect
    to different services and data sources from within our applications, flows, and
    chatbots.</st> <st c="3880">Connectors can be either certified ones, which connect
    to first- or third-party services, or they can be custom ones.</st> <st c="3998">Certified
    connectors are prebuilt and cannot be changed, whereas custom connectors give
    us the freedom to create our own connectors to connect to either our own custom
    services/APIs or other services for which a prebuilt connector does not</st> <st
    c="4238">yet exist.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3657">我们在</st> <st c="3680">第2章</st><st c="3694">中介绍了</st><st c="3703">连接器。</st>
    <st c="3880">到目前为止，我们讨论的连接器使我们能够从我们的应用程序、流程和聊天机器人中连接到不同的服务和数据源。</st> <st c="3998">连接器可以是认证的，连接到第一方或第三方服务，也可以是自定义的。</st>
    <st c="4238">认证的连接器是预构建的，不能更改，而自定义连接器则使我们可以自由创建连接到我们自己的自定义服务/API或其他服务的连接器，即使预构建的连接器尚未</st><st
    c="4359">存在。</st>
- en: <st c="4248">Connectors act as wrappers around sets of API operations, which
    are categorized as either triggers</st> <st c="4348">or actions.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4248">连接器作为API操作集的包装，按触发器</st> <st c="4348">或操作分类。</st>
- en: '**<st c="4359">Triggers</st>** <st c="4368">are</st> <st c="4373">operations
    in a connector that respond to a certain event, for example, a SharePoint list
    item being created.</st> <st c="4483">Two types of triggers exist: polling triggers</st>
    <st c="4528">and pushing triggers.</st> **<st c="4551">Polling</st>** <st c="4558">triggers</st>
    <st c="4568">proactively check for changes.</st> <st c="4599">They repeatedly,
    at regular intervals, perform calls of the specified service endpoint to look
    for new data.</st> **<st c="4708">Pushing</st>** <st c="4715">triggers, or webhook
    triggers, are able to react to external events.</st> <st c="4785">When a certain
    event occurs, the service endpoint notifies the trigger via the</st> <st c="4864">callback
    URL.</st>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="4359">触发器</st>** <st c="4368">是</st> <st c="4373">连接器中响应某个事件的操作，例如创建SharePoint列表项。</st>
    <st c="4483">存在两种类型的触发器：轮询触发器</st> <st c="4528">和推送触发器。</st> **<st c="4551">轮询</st>**
    <st c="4558">触发器</st> <st c="4568">主动检查更改。</st> <st c="4599">它们定期执行指定服务端点的调用，以查找新数据。</st>
    **<st c="4708">推送</st>** <st c="4715">触发器或Webhook触发器能够对外部事件做出反应。</st> <st c="4785">当发生某个特定事件时，服务端点通过</st>
    <st c="4864">回调URL通知触发器。</st>'
- en: '**<st c="4877">Actions</st>** <st c="4885">are</st> <st c="4889">operations
    that help us perform methods (retrieve, create, update, and delete) specified
    in an API definition file.</st> <st c="5006">Operations are performed over the
    data in a service that a connector is connected to, for example, getting all SharePoint
    lists from</st> <st c="5139">a site.</st>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="4877">操作</st>** <st c="4885">是</st> <st c="4889">帮助我们执行在API定义文件中指定的方法（检索、创建、更新和删除）的操作。</st>
    <st c="5006">操作是在连接器连接的服务中的数据上执行的，例如从</st> <st c="5139">站点获取所有SharePoint列表。</st>'
- en: <st c="5146">We worked with custom connectors in</st> [*<st c="5183">Chapter
    9</st>*](B22208_09.xhtml#_idTextAnchor149)<st c="5192">. They give us the ability
    to define our own triggers and actions based on the API operations of</st> <st
    c="5289">our service.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5146">我们在</st> [*<st c="5183">第9章</st>*](B22208_09.xhtml#_idTextAnchor149)<st
    c="5192">中使用了自定义连接器。</st> <st c="5289">它们使我们能够根据我们服务的API操作定义自己的触发器和操作。</st>
- en: <st c="5301">Microsoft Power Platform’s open source repository</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5301">Microsoft Power Platform的开源存储库</st>
- en: <st c="5351">Microsoft published an open source repository that allows anyone
    to review existing certified and custom connectors as well as collaborate by submitting
    new connectors to the repository.</st> <st c="5539">The list of predefined connectors
    and custom connectors with the corresponding definition files is published in
    Microsoft’s GitHub repository, which is open to anyone for</st> <st c="5710">contributions:</st>
    [<st c="5725">https://github.com/microsoft/PowerPlatformConnectors/</st>](https://github.com/microsoft/PowerPlatformConnectors/)<st
    c="5778">.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5351">Microsoft发布了一个开源存储库，允许任何人查看现有的认证和自定义连接器，并通过向存储库提交新连接器来进行协作。</st>
    <st c="5539">预定义连接器和带有相应定义文件的自定义连接器的列表已发布在Microsoft的GitHub存储库中，任何人都可以参与</st> <st
    c="5710">贡献：</st> [<st c="5725">https://github.com/microsoft/PowerPlatformConnectors/</st>](https://github.com/microsoft/PowerPlatformConnectors/)<st
    c="5778">。</st>
- en: <st c="5779">Anyone who wants to certify a connector can follow the step-by-step
    approach, described</st> <st c="5868">here:</st> [<st c="5874">https://learn.microsoft.com/en-us/connectors/custom-connectors/submit-certification</st>](https://learn.microsoft.com/en-us/connectors/custom-connectors/submit-certification)<st
    c="5957">.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5779">任何想要认证连接器的人都可以按照这里描述的逐步方法进行：</st> <st c="5868">[<st c="5874">https://learn.microsoft.com/en-us/connectors/custom-connectors/submit-certification</st>](https://learn.microsoft.com/en-us/connectors/custom-connectors/submit-certification)<st
    c="5957">。</st>
- en: <st c="5958">When planning to deploy applications to different target environments,
    we must ensure that our connectors utilize connections that exist in the target
    environments.</st> <st c="6124">To be able to switch to the right connection in
    a target environment in an automated way using pipelines, we recommend using connection
    references.</st> <st c="6272">Let us now take a look at what connection references
    are and how they can</st> <st c="6346">be used.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5958">在计划将应用程序部署到不同目标环境时，我们必须确保我们的连接器使用存在于目标环境中的连接。</st> <st c="6124">为了能够通过管道自动切换到目标环境中的正确连接，我们建议使用连接引用。</st>
    <st c="6272">现在，让我们来看看什么是连接引用以及它们如何</st> <st c="6346">使用。</st>
- en: <st c="6354">Connection references</st>
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6354">连接引用</st>
- en: <st c="6376">When a connector is used in an application or flow to run a certain
    connector operation, a</st> **<st c="6468">connection</st>** <st c="6478">for
    the connector is created in the specific environment.</st> <st c="6537">Connections
    are bound to an environment and store authentication credentials to perform</st>
    <st c="6625">the operation.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6376">当连接器在应用程序或流程中用于执行某个连接器操作时，</st> **<st c="6468">连接</st>** <st c="6478">将在特定环境中为连接器创建。</st>
    <st c="6537">连接绑定到环境，并存储用于执行</st> <st c="6625">操作的身份验证凭据。</st>
- en: <st c="6639">Since connections are not solution-aware and do not provide an
    option of decoupling our business solution from the connection, connection references</st>
    <st c="6789">were introduced.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6639">由于连接不是解决方案感知的，并且不提供将我们的业务解决方案与连接解耦的选项，</st> <st c="6789">因此引入了连接引用。</st>
- en: '**<st c="6805">Connection references</st>** <st c="6827">are</st> <st c="6832">solution
    components that point to a connection for a specific connector.</st> <st c="6905">Using
    connection references allows us to build flexible solutions that enable us to
    programmatically change the connection information in applications and flows.</st>
    <st c="7067">This simplifies the deployment of our solution to different target
    environments when using the DevOps approach, as it allows us to connect to resources
    that are relevant to the</st> <st c="7244">target environment.</st>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="6805">连接引用</st>** <st c="6827">是</st> <st c="6832">指向特定连接器连接的解决方案组件。</st>
    <st c="6905">使用连接引用使我们能够构建灵活的解决方案，允许我们在应用程序和流程中通过编程方式更改连接信息。</st> <st c="7067">这简化了使用
    DevOps 方法将解决方案部署到不同目标环境时的工作，因为它允许我们连接到与</st> <st c="7244">目标环境相关的资源。</st>'
- en: <st c="7263">Let’s explore another method for parameterizing solution configuration:</st>
    <st c="7336">environment variables.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7263">让我们探索另一种参数化解决方案配置的方法：</st> <st c="7336">环境变量。</st>
- en: <st c="7358">Environment variables</st>
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="7358">环境变量</st>
- en: <st c="7380">Environment variables act as</st> <st c="7410">configuration parameters
    for solution components, allowing us to dynamically change configuration values
    specific to the target environment.</st> <st c="7551">Environment variables are
    well known in traditional application development, where developers use them to
    decouple the configuration from the application.</st> <st c="7706">This allows
    developers to adapt the application to the target environment without changing
    the application code.</st> <st c="7819">In Power Platform, we follow the same
    concept to use the application components across different target environments
    by only changing the environmental variables.</st> <st c="7982">This way, we can
    connect to a data source or set of APIs that is specific to the</st> <st c="8063">target
    environment.</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7380">环境变量充当</st> <st c="7410">解决方案组件的配置参数，允许我们动态更改特定于目标环境的配置值。</st>
    <st c="7551">环境变量在传统应用程序开发中非常常见，开发人员使用它们将配置与应用程序解耦。</st> <st c="7706">这使开发人员可以在不更改应用程序代码的情况下，使应用程序适应目标环境。</st>
    <st c="7819">在 Power Platform 中，我们遵循相同的概念，通过仅更改环境变量来在不同目标环境中使用应用程序组件。</st> <st
    c="7982">这样，我们可以连接到特定于</st> <st c="8063">目标环境的数据源或一组 API。</st>
- en: <st c="8082">Environmental variables are usually stored in the format of key-value
    pairs, with values stored outside of the</st> <st c="8193">application source
    code in a secure location, such as</st> **<st c="8248">Azure App Configuration</st>**
    <st c="8271">or</st> **<st c="8275">Azure Key Vault</st>**<st c="8290">, so that
    the values are not easily accessible.</st> <st c="8338">During application</st>
    <st c="8357">runtime or CI/CD pipeline execution, the values are retrieved from
    these services and</st> <st c="8443">used accordingly.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8082">环境变量通常以键值对的格式存储，值存储在应用程序源代码之外的安全位置，如</st> **<st c="8248">Azure
    应用配置</st>** <st c="8271">或</st> **<st c="8275">Azure 密钥保管库</st>**<st c="8290">，以防止值被轻易访问。</st>
    <st c="8338">在应用程序</st> <st c="8357">运行时或 CI/CD 流水线执行过程中，这些值会从这些服务中检索并</st> <st
    c="8443">按需使用。</st>
- en: '<st c="8460">Utilizing such an approach allows us to enable one of the DevOps
    best practices: parameterizing as much as possible to enable the flexibility of
    our applications.</st> <st c="8624">Hardcoding values in the application source
    code could lead not only to maintenance issues but also to potential</st> <st
    c="8737">security vulnerabilities.</st>'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8460">使用这种方法使我们能够实现 DevOps 最佳实践之一：尽可能参数化，以增强应用程序的灵活性。</st> <st c="8624">在应用程序源代码中硬编码值不仅可能导致维护问题，还可能带来潜在的</st>
    <st c="8737">安全漏洞。</st>
- en: <st c="8762">In summary, here are some of the</st> <st c="8796">benefits of
    using</st> <st c="8814">environment variables:</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8762">总之，使用环境变量的一些</st> <st c="8796">好处包括</st> <st c="8814">以下几点：</st>
- en: <st c="8836">We can decouple the application from the configuration, allowing
    us to easily change the configuration values for data sources and other secrets.</st>
    <st c="8983">For example, we can change the connection to the data sources, such
    as API keys and server URLs, as we deploy our application to different</st> <st
    c="9122">target environments.</st>
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="8836">我们可以将应用程序与配置解耦，从而轻松更改数据源和其他机密的配置值。</st> <st c="8983">例如，我们可以在将应用程序部署到不同的</st>
    <st c="9122">目标环境时，改变与数据源的连接，例如 API 密钥和服务器 URL。</st>
- en: <st c="9142">We can reuse environment variables across other solution components.</st>
    <st c="9212">For example, we can create an environment variable that will be used
    in both Power Automate and Power Apps, which</st> <st c="9326">simplifies configuration.</st>
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="9142">我们可以在其他解决方案组件之间复用环境变量。</st> <st c="9212">例如，我们可以创建一个环境变量，在 Power
    Automate 和 Power Apps 中都使用，从而</st> <st c="9326">简化配置。</st>
- en: <st c="9351">We can improve security by separating the secrets from the solution
    components and</st> <st c="9435">storing them in a key vault to reduce the risk</st>
    <st c="9482">of misuse.</st>
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="9351">通过将机密与解决方案组件分离并</st> <st c="9435">将其存储在密钥保管库中，我们可以提高安全性，减少</st>
    <st c="9482">滥用的风险。</st>
- en: <st c="9492">When we add environment variables to our solution, Power Platform
    automatically creates entries in two Dataverse tables:</st> **<st c="9614">Environment
    Variable Value</st>** <st c="9640">and</st> **<st c="9645">Environment Variable
    Definition</st>**<st c="9676">. To use environment variables in Power Apps applications,
    we should use a lookup function on these two tables and obtain the values based
    on the names of the environment variables that we create, as seen in the</st>
    *<st c="9888">Introducing feature flags</st>* <st c="9913">exercise in</st> [*<st
    c="9926">Chapter 8</st>*](B22208_08.xhtml#_idTextAnchor134)<st c="9935">. In Power
    Automate, we are able to access environment variables by using the dynamic</st>
    <st c="10021">content selector.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9492">当我们将环境变量添加到解决方案时，Power Platform 会自动在两个 Dataverse 表中创建条目：</st> **<st
    c="9614">环境变量值</st>** <st c="9640">和</st> **<st c="9645">环境变量定义</st>**<st c="9676">。要在
    Power Apps 应用程序中使用环境变量，我们应该使用查找函数来查询这两个表，并根据我们创建的环境变量名称获取值，如在</st> *<st c="9888">引入功能标志</st>*
    <st c="9913">练习中所示</st> [*<st c="9926">第 8 章</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="9935">。在 Power Automate 中，我们可以通过使用动态</st> <st c="10021">内容选择器来访问环境变量。</st>
- en: <st c="10038">To better understand how we can streamline this operation and
    follow DevOps best practices, we will take a closer look at this approach through</st>
    <st c="10183">an example.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10038">为了更好地理解如何简化此操作并遵循 DevOps 最佳实践，我们将通过</st> <st c="10183">一个示例来进一步了解这种方法。</st>
- en: <st c="10194">Example – Decoupling configuration from the application</st>
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10194">示例 - 将配置与应用程序解耦</st>
- en: <st c="10250">In this example, we will be</st> <st c="10278">utilizing connection
    references and environment variables to decouple a configuration from our</st>
    <st c="10374">business solution.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10250">在这个例子中，我们将</st> <st c="10278">利用连接引用和环境变量来将配置从我们的</st> <st c="10374">业务解决方案中解耦。</st>
- en: <st c="10392">First, we need to create a solution and add all components that
    are part of our business solution, including new environment variables and connection
    references.</st> <st c="10555">Then, we will create a deployment settings file,
    which will decouple the configuration settings from our actual application.</st>
    <st c="10680">This will allow us to configure the values specific to the target
    environment.</st> <st c="10759">We will use the deployment settings file to import
    the solution to a target environment with the relevant</st> <st c="10865">configuration
    values.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10392">首先，我们需要创建一个解决方案并添加所有属于我们业务解决方案的组件，包括新的环境变量和连接引用。</st> <st c="10555">然后，我们将创建一个部署设置文件，该文件将把配置设置与实际应用程序解耦。</st>
    <st c="10680">这将使我们能够配置特定于目标环境的值。</st> <st c="10759">我们将使用部署设置文件将解决方案导入到目标环境中，并带有相关的</st>
    <st c="10865">配置值。</st>
- en: <st c="10886">Preparing a solution</st>
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="10886">准备解决方案</st>
- en: <st c="10907">Let us explore the first step of</st> <st c="10940">preparing
    the solution with</st> <st c="10969">configuration settings:</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10907">让我们来探索准备解决方案与</st> <st c="10940">配置设置的第一步：</st>
- en: <st c="10992">On the Power Apps (</st>[<st c="11012">https://make.powerapps.com</st>](https://make.powerapps.com)<st
    c="11039">) or Power Automate (</st>[<st c="11061">https://make.powerautomate.com</st>](https://make.powerautomate.com)<st
    c="11092">) home page, we can find a</st> **<st c="11120">Solutions</st>** <st
    c="11129">option in the left navigation bar.</st> <st c="11165">Selecting it will
    open a screen with a list of all solutions in the</st> <st c="11233">current environment.</st>
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10992">在 Power Apps（</st>[<st c="11012">https://make.powerapps.com</st>](https://make.powerapps.com)<st
    c="11039">）或 Power Automate（</st>[<st c="11061">https://make.powerautomate.com</st>](https://make.powerautomate.com)<st
    c="11092">）主页上，我们可以在左侧导航栏中找到</st> **<st c="11120">解决方案</st>** <st c="11129">选项。</st>
    <st c="11165">选择该选项将打开一个屏幕，显示当前环境中所有解决方案的列表。</st>
- en: <st c="11253">We either click</st> `<st c="11541">pac solution init</st>` <st
    c="11558">and</st> `<st c="11563">pac solution</st>` `<st c="11576">import</st>`
    <st c="11582">commands.</st>
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11253">我们可以点击</st> `<st c="11541">pac solution init</st>` <st c="11558">和</st>
    `<st c="11563">pac solution</st>` `<st c="11576">import</st>` <st c="11582">命令。</st>
- en: <st c="11592">Once we are in the solution object explorer, we can add a new
    connection reference by clicking</st> **<st c="11688">New</st>** <st c="11691">|</st>
    **<st c="11694">More</st>** <st c="11698">|</st> **<st c="11701">Connection Reference</st>**<st
    c="11721">.</st>
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11592">当我们进入解决方案对象资源管理器时，我们可以通过点击</st> **<st c="11688">新建</st>** <st
    c="11691">|</st> **<st c="11694">更多</st>** <st c="11698">|</st> **<st c="11701">连接引用</st>**<st
    c="11721">来添加新的连接引用。</st>
- en: <st c="11722">To add an</st> <st c="11732">existing connection reference, we
    click on</st> **<st c="11776">Add existing</st>** <st c="11788">|</st> **<st c="11791">More</st>**
    <st c="11795">|</st> **<st c="11798">Connection Reference</st>**<st c="11818">,
    select the existing connection reference, and click</st> **<st c="11872">Next</st>**<st
    c="11876">, as we can see in</st> *<st c="11895">Figure 10</st>**<st c="11904">.1\.</st>*
    <st c="11908">This will add any existing components to</st> <st c="11949">the</st>
    <st c="11953">solution:</st>
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="11722">要添加一个</st> <st c="11732">现有的连接引用，我们点击</st> **<st c="11776">添加现有</st>**
    <st c="11788">|</st> **<st c="11791">更多</st>** <st c="11795">|</st> **<st c="11798">连接引用</st>**<st
    c="11818">，选择现有的连接引用，然后点击</st> **<st c="11872">下一步</st>**<st c="11876">，正如我们在</st>
    *<st c="11895">图 10</st>**<st c="11904">.1\.</st>* <st c="11908">中看到的。</st> <st
    c="11949">这将把任何现有的组件添加到</st> <st c="11953">解决方案中：</st>
- en: '![Figure 10.1 – Adding components in the solution object explorer](img/B22208_10_1.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 在解决方案对象资源管理器中添加组件](img/B22208_10_1.jpg)'
- en: <st c="12421">Figure 10.1 – Adding components in the solution object explorer</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12421">图 10.1 – 在解决方案对象资源管理器中添加组件</st>
- en: <st c="12484">Whenever we are creating new connection references, the</st> **<st
    c="12541">New Connection Reference</st>** <st c="12565">screen will open, as can
    be seen in</st> *<st c="12602">Figure 10</st>**<st c="12611">.2</st>*<st c="12613">.</st>
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12484">每当我们创建新的连接引用时，</st> **<st c="12541">新建连接引用</st>** <st c="12565">屏幕将会打开，正如在</st>
    *<st c="12602">图 10</st>**<st c="12611">.2</st>*<st c="12613">中所见。</st>
- en: <st c="12614">Here we must provide the</st> **<st c="12640">Display name</st>**<st
    c="12652">,</st> **<st c="12654">Name</st>**<st c="12658">,</st> **<st c="12660">Connector</st>**
    <st c="12669">values, as well as a</st> **<st c="12691">Connection</st>** <st
    c="12701">value for the selected connector.</st> <st c="12736">Providing a description
    is optional but is recommended to have a better understanding of the use of</st>
    <st c="12836">connection references:</st>
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="12614">在这里，我们必须提供</st> **<st c="12640">显示名称</st>**<st c="12652">，</st>
    **<st c="12654">名称</st>**<st c="12658">，</st> **<st c="12660">连接器</st>** <st c="12669">的值，以及</st>
    **<st c="12691">连接</st>** <st c="12701">值用于所选连接器。</st> <st c="12736">提供描述是可选的，但建议提供，以便更好地理解</st>
    <st c="12836">连接引用的用途：</st>
- en: <st c="12858">If there are no connections for a selected connector in the environment,
    we need to create a new one by selecting</st> **<st c="12973">+ New connection</st>**<st
    c="12989">, which opens a new connections screen with a pop-up box for our selected
    connector.</st> <st c="13074">We need to provide all required parameters for the
    connection and click</st> **<st c="13146">Create</st>** <st c="13152">to create</st>
    <st c="13163">a connection.</st>
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="12858">如果在环境中没有所选连接器的连接，我们需要通过选择</st> **<st c="12973">+ 新建连接</st>**<st
    c="12989">来创建一个新连接，这将打开一个新连接屏幕，弹出框中显示我们所选的连接器。</st> <st c="13074">我们需要提供所有必需的连接参数，并点击</st>
    **<st c="13146">创建</st>** <st c="13152">来创建</st> <st c="13163">一个连接。</st>
- en: <st c="13176">Going back</st> <st c="13187">to the previous</st> **<st c="13204">New
    Connection Reference</st>** <st c="13228">screen, we can now click the</st> **<st
    c="13258">Refresh</st>** <st c="13265">button next to the drop-down list of connections,
    as can be seen in</st> *<st c="13334">Figure 10</st>**<st c="13343">.2</st>*<st
    c="13345">, which will update the list of connections and show the newly created
    connection.</st> <st c="13428">We can select it and proceed by clicking</st> **<st
    c="13469">Create</st>**<st c="13475">, which creates a new component in</st> <st
    c="13510">our</st> <st c="13513">solution.</st>
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13176">返回</st> <st c="13187">到之前的</st> **<st c="13204">新建连接引用</st>**
    <st c="13228">屏幕，我们现在可以点击</st> **<st c="13258">刷新</st>** <st c="13265">按钮，位于连接下拉列表旁边，如</st>
    *<st c="13334">图 10</st>**<st c="13343">.2</st>*<st c="13345">所示，这将更新连接列表并显示新创建的连接。</st>
    <st c="13428">我们可以选择它并点击</st> **<st c="13469">创建</st>**<st c="13475">，这将在</st>
    <st c="13510">我们的</st> <st c="13513">解决方案中创建一个新组件。</st>
- en: '![Figure 10.2 – Creating a new connection reference](img/B22208_10_2.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 创建新的连接引用](img/B22208_10_2.jpg)'
- en: <st c="13745">Figure 10.2 – Creating a new connection reference</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13745">图 10.2 – 创建新的连接引用</st>
- en: <st c="13794">To add an</st> <st c="13805">environment variable, we follow similar
    steps to those mentioned in</st> *<st c="13873">step 3</st>*<st c="13879">. This
    time, we select</st> **<st c="13902">New</st>** <st c="13905">|</st> **<st c="13908">More</st>**
    <st c="13912">|</st> **<st c="13915">Environment variable</st>**<st c="13935">.</st>
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13794">要添加一个</st> <st c="13805">环境变量，我们遵循类似于</st> *<st c="13873">步骤 3</st>*<st
    c="13879">中提到的步骤。这次，我们选择</st> **<st c="13902">新建</st>** <st c="13905">|</st> **<st
    c="13908">更多</st>** <st c="13912">|</st> **<st c="13915">环境变量</st>**<st c="13935">。</st>
- en: <st c="13936">A new screen will appear, which will require us to provide more
    information about the environment variable, such as</st> **<st c="14053">Display
    name</st>**<st c="14065">,</st> **<st c="14067">Name</st>**<st c="14071">,</st>
    **<st c="14073">Description</st>**<st c="14084">, and</st> **<st c="14090">Data
    Type</st>**<st c="14099">:</st>
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="13936">将出现一个新屏幕，我们需要提供更多关于环境变量的信息，例如</st> **<st c="14053">显示名称</st>**<st
    c="14065">，</st> **<st c="14067">名称</st>**<st c="14071">，</st> **<st c="14073">描述</st>**<st
    c="14084">，以及</st> **<st c="14090">数据类型</st>**<st c="14099">：</st>
- en: '**<st c="14101">Data Type</st>** <st c="14110">specifies the type of our environment
    variable.</st> <st c="14159">This could be</st> **<st c="14173">Decimal number</st>**<st
    c="14187">,</st> **<st c="14189">Yes/No</st>**<st c="14195">,</st> **<st c="14197">Text</st>**<st
    c="14201">,</st> **<st c="14203">Data source</st>**<st c="14214">,</st> **<st
    c="14216">Secret</st>**<st c="14222">, and so on.</st> <st c="14235">After selecting
    a data type, we can configure the default and current value, as can be seen in</st>
    *<st c="14330">Figure 10.3</st>*<st c="14341">. If we are creating an environment
    variable of type</st> **<st c="14394">Data source</st>**<st c="14405">, we get
    the possibility of</st> <st c="14433">selecting</st> **<st c="14443">Connector</st>**<st
    c="14452">.</st>'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="14101">数据类型</st>** <st c="14110">指定了我们环境变量的类型。</st> <st c="14159">这可以是</st>
    **<st c="14173">十进制数</st>**<st c="14187">，</st> **<st c="14189">是/否</st>**<st
    c="14195">，</st> **<st c="14197">文本</st>**<st c="14201">，</st> **<st c="14203">数据源</st>**<st
    c="14214">，</st> **<st c="14216">机密</st>**<st c="14222">，等等。</st> <st c="14235">选择数据类型后，我们可以配置默认值和当前值，如在</st>
    *<st c="14330">图 10.3</st>*<st c="14341">中所示。如果我们正在创建一个类型为</st> **<st c="14394">数据源</st>**<st
    c="14405">的环境变量，我们可以选择</st> <st c="14433">连接器</st>**<st c="14443">。</st>'
- en: '![Figure 10.3 – Adding a new environment variable](img/B22208_10_3.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 添加新环境变量](img/B22208_10_3.jpg)'
- en: <st c="14836">Figure 10.3 – Adding a new environment variable</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14836">图 10.3 – 添加新环境变量</st>
- en: '**<st c="14883">Default Value</st>** <st c="14897">is not a</st> <st c="14906">required
    field; however, it is something that is used when no</st> **<st c="14969">Current
    Value</st>** <st c="14982">setting is configured.</st> **<st c="15006">Current
    Value</st>** <st c="15019">overrides</st> **<st c="15030">Default Value</st>**
    <st c="15043">and is something that is very useful when deploying to different</st>
    <st c="15109">target environments.</st>'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="14883">默认值</st>** <st c="14897">不是必填项；然而，当没有</st> **<st c="14969">当前值</st>**
    <st c="14982">设置时，它是会被使用的。</st> **<st c="15006">当前值</st>** <st c="15019">会覆盖</st>
    **<st c="15030">默认值</st>** <st c="15043">，并且在部署到不同的</st> <st c="15109">目标环境时非常有用。</st>'
- en: <st c="15129">Once we have configured the environment variable as needed, we
    can click</st> **<st c="15203">Save</st>** <st c="15207">to store the configuration,
    which adds a new component to</st> <st c="15266">our solution.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15129">一旦我们按需要配置好环境变量后，可以点击</st> **<st c="15203">保存</st>** <st c="15207">来存储配置，这将会将一个新组件添加到</st>
    <st c="15266">我们的解决方案中。</st>
- en: <st c="15279">If we need to add existing environment variables to our solution,
    we can do so by clicking</st> **<st c="15371">Add existing</st>**<st c="15383">|</st>
    **<st c="15386">More</st>** <st c="15390">|</st> **<st c="15393">Environment variable</st>**
    <st c="15413">in the solution object explorer, selecting the existing variables
    from the list, and clicking</st> **<st c="15508">Next</st>**<st c="15512">. The
    next screen shows us the selected environment variables, and for each, we have
    options to select</st> **<st c="15615">Include definition</st>** <st c="15633">and</st>
    **<st c="15638">Include current value</st>** <st c="15659">checkboxes.</st> <st
    c="15672">We can review the existing selected</st> <st c="15708">environment variable
    and click</st> **<st c="15739">Add</st>** <st c="15742">to have it added to</st>
    <st c="15763">our solution.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15279">如果我们需要将现有的环境变量添加到我们的解决方案中，可以通过点击</st> **<st c="15371">添加现有</st>**<st
    c="15383">|</st> **<st c="15386">更多</st>** <st c="15390">|</st> **<st c="15393">环境变量</st>**
    <st c="15413">在解决方案对象资源管理器中，选择列表中的现有变量，然后点击</st> **<st c="15508">下一步</st>**<st
    c="15512">。接下来的页面会显示我们选择的环境变量，对于每个变量，我们可以选择</st> **<st c="15615">包含定义</st>** <st
    c="15633">和</st> **<st c="15638">包含当前值</st>** <st c="15659">复选框。</st> <st c="15672">我们可以审查已选择的现有</st>
    <st c="15708">环境变量，并点击</st> **<st c="15739">添加</st>** <st c="15742">将其添加到</st>
    <st c="15763">我们的解决方案中。</st>
- en: <st c="15776">Current limitations of environment variables</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15776">环境变量的当前限制</st>
- en: <st c="15821">There are still some limitations when using environment variables;
    for example, data source environment variables cannot currently be managed using
    Microsoft Power Platform Build Tools.</st> <st c="16008">Please make sure to review
    limitations and use environment variables accordingly.</st> <st c="16090">Refer
    to the updated information about the limitations</st> <st c="16145">here:</st>
    [<st c="16151">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables</st>](https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables)<st
    c="16236">.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15821">在使用环境变量时仍然存在一些限制；例如，目前无法使用 Microsoft Power Platform Build Tools
    管理数据源环境变量。</st> <st c="16008">请确保查看限制并相应地使用环境变量。</st> <st c="16090">有关限制的更新信息，请参考</st>
    <st c="16145">这里：</st> [<st c="16151">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables</st>](https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables)<st
    c="16236">。</st>
- en: <st c="16237">Now that we have prepared our solution, we can deploy it to different
    environments.</st> <st c="16322">When importing a solution manually, the import
    process will check whether any connection already exists in the environment for
    the defined connection reference.</st> <st c="16483">If so, import process will
    link it to that connection; if not, it will offer us the chance to automatically
    create and link the connection .</st> <st c="16624">Once the connections are configured,
    the next step allows us to update environment variables with the actual values
    for the</st> <st c="16748">target environment.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16237">现在我们已经准备好了解决方案，可以将其部署到不同的环境中。</st> <st c="16322">手动导入解决方案时，导入过程会检查环境中是否已经存在定义的连接引用。</st>
    <st c="16483">如果存在，导入过程将其与该连接关联；如果不存在，它将提供自动创建并关联连接的机会。</st> <st c="16624">一旦连接配置完成，下一步将允许我们使用目标环境的实际值更新环境变量。</st>
- en: <st c="16767">To decouple the settings and allow our solution to be imported
    in a more programmatic way, we will take a look at how a deployment settings file
    can be generated</st> <st c="16930">and used.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16767">为了将设置解耦并允许我们的解决方案以更具程序化的方式导入，我们将查看如何生成并使用部署设置文件。</st> <st c="16930">和使用。</st>
- en: <st c="16939">Building a deployment settings file</st>
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="16939">构建部署设置文件</st>
- en: <st c="16975">A</st> **<st c="16977">deployment settings file</st>** <st c="17002">is
    a</st> <st c="17008">JSON-format file that stores the information about the connection
    references and environment variables that are being used in our solution.</st>
    <st c="17148">This same file will be used during the solution import process with
    Power Platform Build Tools or the PAC CLI.</st> <st c="17259">We touched on it
    briefly in</st> [*<st c="17287">Chapter 8</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="17296">:</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16975">一个</st> **<st c="16977">部署设置文件</st>** <st c="17002">是一个</st> <st
    c="17008">存储关于连接引用和我们解决方案中使用的环境变量信息的 JSON 格式文件。</st> <st c="17148">同一个文件将在使用 Power
    Platform Build Tools 或 PAC CLI 进行解决方案导入时使用。</st> <st c="17259">我们在</st> [*<st
    c="17287">第 8 章</st>*](B22208_08.xhtml#_idTextAnchor134)<st c="17296">中简要提到过它：</st>
- en: <st c="17298">We should</st> <st c="17307">export our solution or clone it.</st>
    <st c="17341">We need to</st> <st c="17351">have either a solution ZIP file or
    an unpacked solution folder to which we can point to generate a settings file.</st>
    <st c="17466">We can do this in</st> <st c="17484">two ways:</st>
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该<st c="17298">导出我们的解决方案或克隆它。</st> <st c="17307">我们需要</st> <st c="17341">拥有一个解决方案
    ZIP 文件或一个未打包的解决方案文件夹，我们可以通过它来生成设置文件。</st> <st c="17466">我们可以通过</st> <st c="17484">两种方式来实现：</st>
- en: <st c="17493">By selecting the solution, clicking</st> `<st c="17615">pac solution
    clone --name <solution-name></st>` <st c="17656">or</st> `<st c="17660">pac solution
    export --name <name></st>`<st c="17693">, which means the solution folder will
    be cloned locally or the solution ZIP file will be</st> <st c="17783">downloaded
    locally</st>
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="17493">选择解决方案，点击</st> `<st c="17615">pac solution clone --name <solution-name></st>`
    <st c="17656">或</st> `<st c="17660">pac solution export --name <name></st>`<st
    c="17693">，这意味着解决方案文件夹将被本地克隆，或解决方案 ZIP 文件将被</st> <st c="17783">本地下载</st>
- en: <st c="17801">Now that we</st> <st c="17813">have exported the solution package</st>
    <st c="17849">file, we are ready to create the deployment settings file, using
    the</st> <st c="17918">following approach.</st>
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="17801">现在我们</st> <st c="17813">已经导出了解决方案包</st> <st c="17849">文件，我们准备好按照以下方法创建部署设置文件。</st>
- en: <st c="17937">Generating a deployment setting file can be done by using the
    following PAC</st> <st c="18014">CLI command:</st>
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="17937">生成部署设置文件可以使用以下 PAC</st> <st c="18014">CLI 命令：</st>
- en: '[PRE0]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="18496">An example of the structure of the</st> `<st c="18532">deploymentSettings.json</st>`
    <st c="18555">file is present in the</st> [*<st c="18579">Chapter 10</st>*](B22208_10.xhtml#_idTextAnchor172)
    <st c="18589">folder of this book’s GitHub repository.</st> <st c="18631">In the
    file, we can see the structure of the environment variables and connection references
    with the</st> <st c="18733">respective values.</st>
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18496">下面是</st> `<st c="18532">deploymentSettings.json</st>` <st c="18555">文件结构的示例，位于本书
    GitHub 仓库的</st> [*<st c="18579">第 10 章</st>*](B22208_10.xhtml#_idTextAnchor172)
    <st c="18589">文件夹中。</st> <st c="18631">在该文件中，我们可以看到环境变量和连接引用的结构，并包含相应的值。</st>
- en: <st c="18751">For each environment variable in the file, there is a</st> `<st
    c="18806">Value</st>` <st c="18811">property.</st> <st c="18822">Initially, it
    is an empty string that we update with the value for the target environment.</st>
    <st c="18913">The same should be done for the connection references, where the</st>
    `<st c="18978">ConnectionId</st>` <st c="18990">property is initially empty and
    needs to</st> <st c="19032">be provided.</st>
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="18751">文件中的每个环境变量都有一个</st> `<st c="18806">Value</st>` <st c="18811">属性。</st>
    <st c="18822">初始时，它是一个空字符串，我们将其更新为目标环境的值。</st> <st c="18913">对连接引用也应进行相同的操作，其中</st>
    `<st c="18978">ConnectionId</st>` <st c="18990">属性最初为空，需要</st> <st c="19032">提供。</st>
- en: <st c="19044">To update the connection reference values, we can use the PAC
    CLI to connect to the target environment and list all connections.</st> <st c="19174">This
    will allow us to see whether any of the connections for the given connector already
    exist there.</st> <st c="19276">Once we are pointing the PAC CLI at the target
    environment, we can use the</st> `<st c="19351">pac connection list</st>` <st
    c="19370">command to list all connections established in the selected environment.</st>
    <st c="19444">If a connection exists, copy the</st> `<st c="19477">Id</st>` <st
    c="19479">value of the connection into the deployment settings file under the
    right connection reference</st> `<st c="19575">ConnectionId</st>` <st c="19587">value,
    as shown in</st> [*<st c="19607">Chapter 8</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="19616">; otherwise, a create</st> <st c="19639">new connection.</st>
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="19044">要更新连接引用值，我们可以使用 PAC CLI 连接到目标环境并列出所有连接。</st> <st c="19174">这将使我们看到给定连接器的连接是否已存在于目标环境中。</st>
    <st c="19276">当我们将 PAC CLI 指向目标环境时，可以使用</st> `<st c="19351">pac connection list</st>`
    <st c="19370">命令列出在选定环境中建立的所有连接。</st> <st c="19444">如果连接已存在，请将该连接的</st> `<st c="19477">Id</st>`
    <st c="19479">值复制到部署设置文件中的正确连接引用</st> `<st c="19575">ConnectionId</st>` <st c="19587">值下，如</st>
    [*<st c="19607">第 8 章</st>*](B22208_08.xhtml#_idTextAnchor134) <st c="19616">所示；否则，创建一个新的连接。</st>
- en: <st c="19654">Now that we have prepared the deployment settings file for the
    solution, we can proceed with the solution import process, including the specified
    deployment settings file.</st> <st c="19827">If no environment value or path is
    provided with the command, the current environment and the current folder structure
    will be used for the</st> <st c="19966">solution</st> <st c="19976">import:</st>
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="19654">现在我们已经为解决方案准备了部署设置文件，可以继续进行解决方案导入过程，包括指定的部署设置文件。</st> <st c="19827">如果命令中未提供环境值或路径，将使用当前环境和当前文件夹结构进行</st>
    <st c="19966">解决方案</st> <st c="19976">导入：</st>
- en: '[PRE1]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="20071">The preceding approach presents a programmatic approach for generating
    a deployment settings file, editing it, and importing the solution to the target
    environment.</st> <st c="20237">To follow the DevOps approach, we can use extra
    tasks in the pipelines to manage the deployment settings file and deploy to the</st>
    <st c="20365">target environment.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20071">上述方法提供了一种编程方式来生成部署设置文件、编辑它并将解决方案导入目标环境。</st> <st c="20237">为了遵循
    DevOps 方法，我们可以在流水线中使用额外任务来管理部署设置文件并部署到</st> <st c="20365">目标环境。</st>
- en: <st c="20384">The deployment settings file and the DevOps approach</st>
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="20384">部署设置文件和 DevOps 方法</st>
- en: <st c="20437">In</st> [*<st c="20441">Chapter 8</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="20450">, we saw how</st> <st c="20462">the deployment settings</st> <st c="20486">file
    can be used within DevOps.</st> <st c="20519">In order to keep things automated,
    we can add an extra task in the pipeline, which will create a deployment settings
    file and store it in the repository, next to our exported solution.</st> <st c="20704">We
    can do that using the PAC CLI.</st> <st c="20738">We have to make sure that when
    we use the Power Platform Tool Installer task in our export pipeline, we add the
    PAC CLI to the</st> `<st c="20865">PATH</st>` <st c="20869">environment variable.</st>
    <st c="20892">The following example shows how it can be done in</st> <st c="20942">Azure
    DevOps:</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20437">在</st> [*<st c="20441">第8章</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="20450">中，我们看到如何在 DevOps 中使用部署设置</st><st c="20462">文件。</st> <st c="20486">为了保持自动化，我们可以在管道中添加一个额外的任务，</st><st
    c="20519">该任务将创建一个部署设置文件并将其存储在与我们导出解决方案相同的仓库中。</st> <st c="20704">我们可以使用 PAC CLI
    来实现。</st> <st c="20738">我们必须确保在导出管道中使用 Power Platform Tool Installer 任务时，将 PAC
    CLI 添加到</st> `<st c="20865">PATH</st>` <st c="20869">环境变量中。</st> <st c="20892">以下示例演示了如何在</st>
    <st c="20942">Azure DevOps 中完成这项操作：</st>
- en: '[PRE2]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="21042">To generate a deployment settings file, we will use a</st> **<st
    c="21097">Command line</st>** <st c="21109">task, with a command that we are now</st>
    <st c="21147">familiar with:</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21042">为了生成部署设置文件，我们将使用一个</st> **<st c="21097">命令行</st>** <st c="21109">任务，使用我们现在</st>
    <st c="21147">已经熟悉的命令：</st>
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="21375">The</st> `<st c="21380">git commit</st>` <st c="21390">command</st>
    <st c="21399">that we have as part of our export pipeline will now make sure that
    this new deployment settings file will be added to our repository.</st> <st c="21534">If
    we are creating an artifact within the export pipeline, we should make sure that
    we add the deployment settings file to the artifact using a</st> **<st c="21678">Copy
    files</st>** <st c="21688">task in</st> <st c="21697">the pipeline.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21375">我们在导出管道中使用的</st> `<st c="21380">git commit</st>` <st c="21390">命令</st>
    <st c="21399">将确保这个新的部署设置文件会被添加到我们的仓库中。</st> <st c="21534">如果我们在导出管道中创建一个制品，我们应该确保使用管道中的</st>
    **<st c="21678">复制文件</st>** <st c="21688">任务将部署设置文件添加到制品中。</st>
- en: '<st c="21710">Now that we have</st> <st c="21727">the deployment settings file
    in our repository, it is time to update the values in the files.</st> <st c="21822">As
    we do not want to keep any sensitive information in our source code, and these
    values can be readable, we recommend parameterizing the values for environmental
    variables and connection IDs for connection references.</st> <st c="22041">As
    an example, in the deployment settings file, we could have values of environment
    variables written like this:</st> `<st c="22154">„Value": „#{ENV_NAME}#"</st>`<st
    c="22177">, and values of connection IDs for connection references written like
    this:</st> `<st c="22253">„ConnectionId": „#{CONN_O365OUTLOOK}#</st>`<st c="22290">.
    A similar approach was shown in</st> [*<st c="22324">Chapter 8</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="22333">.</st>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="21710">现在我们已经在仓库中有了部署设置文件，接下来就是更新文件中的值。</st> <st c="21822">由于我们不希望在源代码中保留任何敏感信息，而这些值可能是可读的，我们建议将环境变量和连接参考的连接
    ID 的值参数化。</st> <st c="22041">例如，在部署设置文件中，我们可以将环境变量的值写成如下形式：</st> `<st c="22154">„Value":
    „#{ENV_NAME}#"</st>`<st c="22177">，连接参考的连接 ID 值则可以写成如下形式：</st> `<st c="22253">„ConnectionId":
    „#{CONN_O365OUTLOOK}#</st>`<st c="22290">。类似的方法在</st> [*<st c="22324">第8章</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="22333">中有展示。</st>'
- en: <st c="22334">As part of our</st> <st c="22349">deployment pipeline, where we
    import the solution to the environment, we can update the values to be correct.</st>
    <st c="22460">We can do that using a task/action in our DevOps pipeline that searches
    for the tokens with the right prefix and suffix, in our case</st> `<st c="22593">#{
    … }#</st>`<st c="22600">, and replaces those tokens with the actual value stored
    in the variables within the DevOps tool or a secure key vault.</st> <st c="22720">As
    an example, in Azure DevOps and GitHub, we can achieve this with a</st> **<st
    c="22790">Replace</st>** **<st c="22798">tokens</st>** <st c="22804">task/action.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22334">作为我们</st> <st c="22349">部署管道的一部分，在将解决方案导入到环境中的过程中，我们可以更新这些值以确保其正确。</st>
    <st c="22460">我们可以使用 DevOps 管道中的一个任务/操作，搜索具有正确前缀和后缀的令牌，在我们的案例中是</st> `<st c="22593">#{
    … }#</st>`<st c="22600">，并用存储在 DevOps 工具或安全密钥库中的实际值替换这些令牌。</st> <st c="22720">例如，在
    Azure DevOps 和 GitHub 中，我们可以通过一个</st> **<st c="22790">替换</st>** **<st c="22798">令牌</st>**
    <st c="22804">任务/操作来实现这一点。</st>
- en: <st c="22817">Once the tokens have been replaced with the actual values during
    the deployment pipeline, the next step is to import the solution using the</st>
    **<st c="22958">Power Platform Import Solution</st>** <st c="22988">task, which
    is</st> <st c="23004">part of Power Platform Build Tools.</st> <st c="23040">This</st>
    <st c="23045">allows us to reference the deployment settings file when importing
    the solution.</st> <st c="23126">Here, we can see an example of such a task in
    an Azure</st> <st c="23181">DevOps pipeline:</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22817">一旦在部署管道中将令牌替换为实际值，下一步是使用</st> **<st c="22958">Power Platform 导入解决方案</st>**
    <st c="22988">任务导入解决方案，该任务是</st> <st c="23004">Power Platform 构建工具的一部分。</st> <st
    c="23040">这</st> <st c="23045">使我们能够在导入解决方案时引用部署设置文件。</st> <st c="23126">在这里，我们可以看到一个这样的任务在
    Azure</st> <st c="23181">DevOps 管道中的示例：</st>
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="23509">Now that we have a better understanding of how our solutions can
    have configuration settings files that make them reusable across environments,
    this will also help us with building other components, such as canvas components
    and code components.</st> <st c="23756">We will start with canvas components and</st>
    <st c="23797">component libraries.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23509">现在，我们更清楚地了解了我们的解决方案如何拥有配置设置文件，使其能够在不同的环境中重用，这也将帮助我们构建其他组件，如画布组件和代码组件。</st>
    <st c="23756">我们将从画布组件和</st> <st c="23797">组件库开始。</st>
- en: <st c="23817">Overview of canvas components and component libraries</st>
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="23817">画布组件和组件库概述</st>
- en: <st c="23871">When developing applications in Power Apps, app makers use various
    controls for application building blocks.</st> <st c="23981">In order to avoid
    repetition and to build reusable parts of the application that can be used across
    the same application or across multiple apps, app makers should look to canvas
    components.</st> <st c="24172">This section introduces a canvas component together
    with a component library and will help you understand their differences and how
    they fit into the</st> <st c="24322">ALM process.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23871">在 Power Apps 中开发应用时，应用开发者使用各种控件来构建应用的基础模块。</st> <st c="23981">为了避免重复，并构建可重用的应用部件，这些部件可以在同一个应用或多个应用中使用，开发者应考虑使用画布组件。</st>
    <st c="24172">本节介绍了画布组件以及组件库，并帮助你理解它们之间的区别以及它们如何融入</st> <st c="24322">ALM 过程。</st>
- en: <st c="24334">Canvas components</st>
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="24334">画布组件</st>
- en: '**<st c="24352">Canvas components</st>** <st c="24370">serve as</st> <st c="24379">individual
    modular building blocks that encapsulate specific functionality or elements of
    the user interface.</st> <st c="24490">Canvas components are reusable across Power
    Apps canvas apps and model-driven apps.</st> <st c="24574">Not only do these components
    play a crucial role in creating larger and more complex enterprise-grade applications,
    but they are also significant when it comes to working in a larger team in a co-development
    environment, as developers can divide tasks and focus each individual component
    when building a business solution.</st> <st c="24897">An additional benefit of
    creating canvas components is that they can be updated centrally in one place,
    with all updates being reflected in all instances within</st> <st c="25058">the
    application.</st>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="24352">画布组件</st>** <st c="24370">作为</st> <st c="24379">独立的模块化构建块，封装了特定的功能或用户界面元素。</st>
    <st c="24490">画布组件可以在 Power Apps 画布应用和基于模型的应用中重用。</st> <st c="24574">这些组件不仅在创建更大、更复杂的企业级应用时起着至关重要的作用，而且在多人协作开发环境中也非常重要，因为开发人员可以分配任务，并在构建业务解决方案时专注于每个单独的组件。</st>
    <st c="24897">创建画布组件的另一个好处是，它们可以在一个地方集中更新，所有更新都会在应用中的所有实例中反映出来。</st> <st c="25058">该应用。</st>'
- en: <st c="25074">Creating canvas</st> <st c="25090">components is done inside Power
    Apps Studio while building a canvas application.</st> <st c="25172">In the left
    navigation bar, under</st> **<st c="25206">Tree view</st>**<st c="25215">, we
    can see all the screens and components that are part of our application.</st>
    <st c="25293">Clicking</st> **<st c="25302">Components</st>** <st c="25312">allows
    us to see all existing components as well as create new ones, by clicking</st>
    **<st c="25394">New component</st>**<st c="25407">. This creates a blank canvas
    component to which we can</st> <st c="25463">add controls:</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25074">创建画布</st> <st c="25090">组件是在 Power Apps Studio 中构建画布应用程序时完成的。</st>
    <st c="25172">在左侧导航栏中，点击</st> **<st c="25206">树视图</st>**<st c="25215">，我们可以看到应用程序中所有的屏幕和组件。</st>
    <st c="25293">点击</st> **<st c="25302">组件</st>** <st c="25312">可以查看所有现有的组件，并通过点击</st>
    **<st c="25394">新建组件</st>**<st c="25407">来创建新的组件。这会创建一个空白的画布组件，我们可以</st> <st c="25463">添加控件：</st>
- en: '![Figure 10.4 – Creating a canvas component in Power Apps](img/B22208_10_4.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – 在 Power Apps 中创建画布组件](img/B22208_10_4.jpg)'
- en: <st c="25536">Figure 10.4 – Creating a canvas component in Power Apps</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25536">图 10.4 – 在 Power Apps 中创建画布组件</st>
- en: <st c="25591">Each component can hold custom properties.</st> <st c="25635">Custom
    properties allow components to either receive values from the application, known
    as input properties, or send data or state from the component to the app, known
    as output properties.</st> <st c="25825">No matter the property type (input/output),
    a custom property can hold data of any data type, spanning from traditional data
    types, such as text and number, to more Power Apps-specific types, such as screen,
    color, and table.</st> <st c="26051">Using custom properties allows the sharing
    of information between the component and the app host.</st> <st c="26149">There
    is one more setting on the canvas component level,</st> **<st c="26206">Access
    app scope</st>**<st c="26222">, and it can be found in the properties of the component
    itself.</st> <st c="26287">It can be turned on or off to allow access to a greater
    set of information</st> <st c="26362">available within the application, such as
    global variables, collections, and controls within the application.</st> <st c="26472">This
    is only applicable to the canvas components within the application and not to
    the components within the component library.</st> <st c="26600">We can turn off
    this setting and feed the information to the component through the</st> <st c="26683">custom
    properties.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25591">每个组件都可以拥有自定义属性。</st> <st c="25635">自定义属性允许组件接收应用程序传递的值（称为输入属性），或者将数据或状态从组件发送到应用程序（称为输出属性）。</st>
    <st c="25825">无论属性类型是输入还是输出，自定义属性都可以保存任何数据类型的数据，涵盖从传统的数据类型，如文本和数字，到更符合 Power Apps
    特性的类型，如屏幕、颜色和表格。</st> <st c="26051">使用自定义属性可以在组件与应用程序主机之间共享信息。</st> <st c="26149">在画布组件层级还有一个设置，</st>
    **<st c="26206">访问应用程序范围</st>**<st c="26222">，可以在组件的属性中找到。</st> <st c="26287">它可以打开或关闭，以允许访问应用程序内更广泛的信息</st>
    <st c="26362">，例如全局变量、集合和应用程序中的控件。</st> <st c="26472">这仅适用于应用程序内的画布组件，而不适用于组件库中的组件。</st>
    <st c="26600">我们可以关闭此设置，并通过</st> <st c="26683">自定义属性</st> <st c="26683">将信息传递给组件。</st>
- en: <st c="26701">Component libraries</st>
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="26701">组件库</st>
- en: <st c="26721">Since canvas components can only be used within one application,
    in order to reuse the components across applications in the environment, we can
    create a component library.</st> <st c="26895">A</st> **<st c="26897">component
    library</st>** <st c="26914">serves</st> <st c="26921">as a repository for component
    definitions.</st> <st c="26965">This allows an application to manage dependencies
    on the components that it utilizes, which means that whenever a component update
    is available, the app maker will be informed about it.</st> <st c="27151">The
    information about the available update will appear when editing the application
    in Power Apps Studio or by manually clicking a refresh button to check for the
    component</st> <st c="27324">library updates.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26721">由于画布组件只能在一个应用程序内使用，为了在环境中跨应用程序重用组件，我们可以创建组件库。</st> <st c="26895">一个</st>
    **<st c="26897">组件库</st>** <st c="26914">作为组件定义的存储库。</st> <st c="26921">这使得应用程序可以管理其所依赖的组件，这意味着每当组件更新可用时，应用程序开发者将被通知。</st>
    <st c="27151">可用更新的信息会在 Power Apps Studio 中编辑应用程序时显示，或者通过手动点击刷新按钮来检查组件</st> <st
    c="27324">库更新。</st>
- en: <st c="27340">Creating a component library is</st> <st c="27372">different from
    creating a</st> <st c="27399">canvas component:</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27340">创建组件库与创建</st> <st c="27372">画布组件不同：</st>
- en: <st c="27416">Component libraries can be found by navigating to the Power Apps
    home screen and selecting</st> **<st c="27508">Component libraries</st>** <st
    c="27527">from the left navigation panel.</st> <st c="27560">If you do not see
    this option in the left navigation panel, click on</st> **<st c="27629">More</st>**
    <st c="27633">|</st> **<st c="27636">Discover all</st>**<st c="27648">, where
    you can f</st><st c="27665">ind it under</st> **<st c="27679">App enhancements</st>**<st
    c="27695">:</st>
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="27416">可以通过导航到 Power Apps 主屏幕并从左侧导航面板中选择</st> **<st c="27508">组件库</st>**
    <st c="27527">来找到组件库。</st> <st c="27560">如果在左侧导航面板中看不到此选项，请点击</st> **<st c="27629">更多</st>**
    <st c="27633">|</st> **<st c="27636">查看全部</st>**<st c="27648">，在这里可以找到</st> **<st
    c="27679">应用增强</st>**<st c="27695">：</st>
- en: '![Figure 10.5 – Accessing Component libraries](img/B22208_10_5.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.5 – 访问组件库](img/B22208_10_5.jpg)'
- en: <st c="28983">Figure 10.5 – Accessing Component libraries</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28983">图 10.5 – 访问组件库</st>
- en: <st c="29026">Once we are on the</st> <st c="29046">component libraries screen,
    we can click on</st> **<st c="29090">+ New component library</st>** <st c="29113">to
    create a blank canvas for adding</st> <st c="29150">app components.</st>
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29026">一旦我们在</st> <st c="29046">组件库屏幕上，我们可以点击</st> **<st c="29090">+
    新建组件库</st>** <st c="29113">来创建一个空白的画布，用于添加</st> <st c="29150">应用程序组件。</st>
- en: <st c="29165">Here we can import existing components or create new ones by following
    the same process as with the regular canvas component.</st> <st c="29292">Each
    component that is created or imported in a component library allows makers to
    make customizations in the target environment.</st> **<st c="29422">Allow customization</st>**
    <st c="29441">is a property of the component inside Power Apps Studio.</st> <st
    c="29499">If customization is allowed, then once the app maker starts making changes
    to the component in the application, this will break the reference to the component
    library and create a local copy of the component.</st> <st c="29708">In order
    to maintain control over components and allow component changes only from within
    the component library, turning off this component setting is a</st> <st c="29861">good
    practice.</st>
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29165">在这里，我们可以按照与常规画布组件相同的过程导入现有组件或创建新组件。</st> <st c="29292">在组件库中创建或导入的每个组件都允许制作者在目标环境中进行自定义。</st>
    **<st c="29422">允许自定义</st>** <st c="29441">是 Power Apps Studio 内部组件的属性。</st> <st
    c="29499">如果允许自定义，则一旦应用制作者开始在应用程序中对组件进行更改，这将打破对组件库的引用并创建组件的本地副本。</st> <st c="29708">为了保持对组件的控制并仅允许从组件库内部进行组件更改，关闭此组件设置是</st>
    <st c="29861">一个良好的实践。</st>
- en: <st c="29875">Once all components are added to the component library, we need
    to publish the changes.</st> <st c="29964">The publishing process is the same
    as with any other canvas component or canvas app.</st> <st c="30049">If the component
    library is not published, it cannot</st> <st c="30102">be reused.</st>
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="29875">一旦所有组件添加到组件库中，我们需要发布这些更改。</st> <st c="29964">发布过程与任何其他画布组件或画布应用相同。</st>
    <st c="30049">如果组件库没有发布，则无法</st> <st c="30102">重复使用。</st>
- en: <st c="30112">Once published, we are ready to reuse the components from the
    library in our application.</st> <st c="30203">To do so, we open our canvas app
    in Power Apps Studio and, in the left navigation panel, click on</st> **<st c="30301">Insert</st>**<st
    c="30307">, which opens an option for adding controls</st> <st c="30351">and components.</st>
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="30112">发布后，我们可以在应用程序中重新使用库中的组件。</st> <st c="30203">为此，我们在 Power Apps
    Studio 中打开我们的画布应用，在左侧导航面板中点击</st> **<st c="30301">插入</st>**<st c="30307">，这将打开添加控件的选项</st>
    <st c="30351">和组件。</st>
- en: <st c="30366">We click on the icon that</st> <st c="30392">represents directory
    search, which opens an</st> **<st c="30437">Import components</st>** <st c="30454">screen.</st>
    <st c="30463">Here we can find our component library and all components that are
    part of the library.</st> <st c="30551">We can select those that we need and</st>
    <st c="30588">click</st> **<st c="30594">Import</st>**<st c="30600">:</st>
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30366">我们点击代表目录搜索的图标，这将打开一个</st> **<st c="30437">导入组件</st>** <st c="30454">屏幕。</st>
    <st c="30463">在这里，我们可以找到我们的组件库以及库中的所有组件。</st> <st c="30551">我们可以选择需要的组件然后</st>
    <st c="30588">点击</st> **<st c="30594">导入</st>**<st c="30600">：</st>
- en: '![Figure 10.6 – Importing components from a component library](img/B22208_10_6.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – 从组件库导入组件](img/B22208_10_6.jpg)'
- en: <st c="31035">Figure 10.6 – Importing components from a component library</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31035">图 10.6 – 从组件库导入组件</st>
- en: <st c="31094">Components from the component library will appear in the left
    navigation panel under the</st> **<st c="31184">Insert</st>** <st c="31190">option.</st>
    <st c="31199">We can find them in a</st> **<st c="31221">Library components</st>**
    <st c="31239">group, just underneath the</st> **<st c="31267">Custom</st>** <st
    c="31273">category, which holds locally created can</st><st c="31315">vas components,
    as</st> <st c="31335">shown here:</st>
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="31094">组件库中的组件将出现在左侧导航面板的</st> **<st c="31184">插入</st>** <st c="31190">选项下。</st>
    <st c="31199">我们可以在</st> **<st c="31221">库组件</st>** <st c="31239">组中找到它们，位于</st>
    **<st c="31267">自定义</st>** <st c="31273">类别下方，该类别包含本地创建的画布组件，如</st> <st c="31315">下图所示：</st>
- en: '![Figure 10.7 – Accessing components from the added component library](img/B22208_10_7.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – 从添加的组件库中访问组件](img/B22208_10_7.jpg)'
- en: <st c="31417">Figure 10.7 – Accessing components from the added component library</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31417">图 10.7 – 从添加的组件库中访问组件</st>
- en: <st c="31484">Now that we have learned how to build canvas components and component
    libraries that support the reusability of the components across canvas applications
    in an environment, let’s investigate how we can manage the component library</st>
    <st c="31716">life cycle.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31484">现在我们已经学习了如何构建画布组件和组件库，这些组件库支持在环境中跨画布应用程序的组件可重用性，让我们来探讨如何管理组件库的</st>
    <st c="31716">生命周期。</st>
- en: <st c="31727">Managing the life cycle of the component library</st>
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="31727">管理组件库的生命周期</st>
- en: <st c="31776">As we saw earlier, in</st> <st c="31799">order to reuse components
    across multiple apps, they need to be added to the component library.</st> <st
    c="31895">Once added to the library, they can be inserted into the application.</st>
    <st c="31965">With that, the application creates a dependency on the selected
    component from the component library and simplifies our</st> <st c="32085">solution
    management.</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31776">正如我们之前所看到的，</st> <st c="31799">为了在多个应用程序之间重用组件，它们需要被添加到组件库中。</st>
    <st c="31895">一旦添加到库中，它们就可以被插入到应用程序中。</st> <st c="31965">这样，应用程序就会创建一个来自组件库的选定组件的依赖关系，并简化我们的</st>
    <st c="32085">解决方案管理。</st>
- en: <st c="32105">To deploy our application with a component dependency into a different
    environment, we have to make sure that the component library exists in the target
    environment prior to deploying the application.</st> <st c="32307">Otherwise,
    the import solution process will not succeed.</st> <st c="32364">It is on us to
    make sure that the component library is either bundled together with the application
    inside the solution or moved to the target environment in a separate solution,
    prior to deploying the application that has a</st> <st c="32589">component dependency.</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32105">为了将带有组件依赖关系的应用程序部署到不同的环境中，我们必须确保在部署应用程序之前，目标环境中存在该组件库。</st> <st
    c="32307">否则，导入解决方案的过程将无法成功。</st> <st c="32364">我们需要确保组件库要么与应用程序一起打包在解决方案中，要么在部署带有</st>
    <st c="32589">组件依赖关系</st> <st c="32589">的应用程序之前，将其移至目标环境的单独解决方案中。</st>
- en: <st c="32610">We can check whether the application has any dependencies by navigating
    to</st> **<st c="32686">Solutions</st>**<st c="32695">, selecting our solution,
    clicking</st> **<st c="32730">Object</st>**<st c="32736">, clicking on the three
    dots next to the name of the application, clicking</st> **<st c="32811">Advanced</st>**<st
    c="32819">, and clicking</st> **<st c="32834">Show dependen</st><st c="32847">cies</st>**<st
    c="32852">, as shown in</st> *<st c="32866">Figure 10</st>**<st c="32875">.8</st>*<st
    c="32877">:</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32610">我们可以通过导航到</st> **<st c="32686">解决方案</st>**<st c="32695">，选择我们的解决方案，点击</st>
    **<st c="32730">对象</st>**<st c="32736">，点击应用程序名称旁边的三个点，点击</st> **<st c="32811">高级</st>**<st
    c="32819">，然后点击</st> **<st c="32834">显示依赖</st><st c="32847">关系</st>**<st c="32852">，如</st>
    *<st c="32866">图 10.8</st>*<st c="32875">所示</st><st c="32877">：</st>
- en: '![Figure 10.8 – Checking application dependencies](img/B22208_10_8.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – 检查应用程序的依赖关系](img/B22208_10_8.jpg)'
- en: <st c="33489">Figure 10.8 – Checking application dependencies</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33489">图 10.8 – 检查应用程序的依赖关系</st>
- en: <st c="33536">There we will find a tab</st> <st c="33561">called</st> **<st
    c="33569">Uses</st>**<st c="33573">, which shows which objects are being used
    by our application.</st> <st c="33636">Selecting the three dots next to the name
    of the component library will redirect us to</st> **<st c="33723">Default Solution</st>**<st
    c="33739">. It is important to note that component libraries are placed in the
    default solution within the environment.</st> <st c="33849">This will be the same
    when we have moved to the target environment, as long as the environment has</st>
    <st c="33948">Dataverse enabled.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33536">在这里我们会找到一个标签</st> <st c="33561">叫做</st> **<st c="33569">使用</st>**<st
    c="33573">，它显示了哪些对象正在被我们的应用程序使用。</st> <st c="33636">选择组件库名称旁边的三个点将会引导我们到</st>
    **<st c="33723">默认解决方案</st>**<st c="33739">。需要注意的是，组件库会被放置在环境中的默认解决方案中。</st> <st
    c="33849">当我们迁移到目标环境时，只要该环境已启用</st> <st c="33948">Dataverse</st>，情况将保持不变。</st>
- en: <st c="33966">Adding a component library to the solution where our application
    resides can be easily achieved by going to our solution, clicking on</st> **<st
    c="34101">Objects</st>**<st c="34108">, and either creating a new component library
    or adding an existing one.</st> <st c="34181">Creating a new one is done by clicking</st>
    **<st c="34220">New</st>** <st c="34223">|</st> **<st c="34226">More</st>** <st
    c="34230">|</st> **<st c="34233">Component Library</st>**<st c="34250">. Adding
    an existing component library can be done through</st> **<st c="34309">Add existing</st>**
    <st c="34321">|</st> **<st c="34324">More</st>** <st c="34328">|</st> **<st c="34331">Component
    Library</st>**<st c="34348">. Once the component library is added to the solution,
    we can enable/disable the option that allows customizations in the target environment.</st>
    <st c="34490">This setting is available inside the solution explorer.</st> <st
    c="34546">We select our component library, click on the three dots next to its
    name, and then click</st> **<st c="34636">Advanced</st>** <st c="34644">|</st>
    **<st c="34647">Managed properties</st>**<st c="34665">. This will open a screen
    for editing the managed properties of the component library.</st> <st c="34752">Here
    we can toggle on or off the option to allow customizations in the</st> <st c="34823">target
    environment:</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33966">将组件库添加到包含我们应用程序的解决方案中，可以通过进入我们的解决方案，点击</st> **<st c="34101">对象</st>**<st
    c="34108">，然后创建一个新的组件库或添加一个现有的组件库。</st> <st c="34181">创建新组件库的方法是点击</st> **<st
    c="34220">新建</st>** <st c="34223">|</st> **<st c="34226">更多</st>** <st c="34230">|</st>
    **<st c="34233">组件库</st>**<st c="34250">。添加现有组件库的方法是通过</st> **<st c="34309">添加现有</st>**
    <st c="34321">|</st> **<st c="34324">更多</st>** <st c="34328">|</st> **<st c="34331">组件库</st>**<st
    c="34348">。将组件库添加到解决方案后，我们可以启用/禁用允许在目标环境中进行自定义的选项。</st> <st c="34490">该设置可以在解决方案资源管理器中找到。</st>
    <st c="34546">我们选择组件库，点击其名称旁边的三个点，然后点击</st> **<st c="34636">高级</st>** <st c="34644">|</st>
    **<st c="34647">托管属性</st>**<st c="34665">。这将打开一个编辑组件库托管属性的界面。</st> <st c="34752">在这里，我们可以切换启用或禁用允许在</st>
    <st c="34823">目标环境中进行自定义的选项：</st>
- en: '![Figure 10.9 – Enabling/disabling customization in the target environment](img/B22208_10_9.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – 在目标环境中启用/禁用自定义](img/B22208_10_9.jpg)'
- en: <st c="35736">Figure 10.9 – Enabling/disabling customization in the target environment</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35736">图 10.9 – 在目标环境中启用/禁用自定义</st>
- en: '<st c="35808">Once we have added our component library with all components
    in the solution, we can follow the ALM process that we are already familiar with:
    export the solution from Power Apps using the export pipeline, followed by an
    import pipeline to the target environment, with all other relevant steps in between</st>
    <st c="36114">for testing.</st>'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35808">一旦我们将包含所有组件的组件库添加到解决方案中，就可以按照我们已经熟悉的ALM流程进行操作：通过导出管道从Power Apps导出解决方案，然后通过导入管道将其导入目标环境，并在中间执行所有其他相关步骤</st>
    <st c="36114">用于测试。</st>
- en: <st c="36126">Should we wish to</st> <st c="36144">update the component library
    separately from the application, it makes sense to have a separate pipeline process
    just for updating the component libraries.</st> <st c="36301">We can create a
    separate solution and add one or more component libraries that we would like to
    manage the application life cycles of separately.</st> <st c="36447">We need to
    keep in mind that the component library has to be deployed to the target environment
    prior to importing the solution that has reference to that component library.</st>
    <st c="36621">Once the component is updated, the app maker will be informed about
    the updates through the component update process (automatically</st> <st c="36753">or
    proactively).</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36126">如果我们希望</st> <st c="36144">单独更新组件库，而不是与应用程序一起更新，那么拥有一个专门用于更新组件库的管道过程是有意义的。</st>
    <st c="36301">我们可以创建一个单独的解决方案，并添加一个或多个我们希望单独管理其应用生命周期的组件库。</st> <st c="36447">我们需要记住，组件库必须在导入引用该组件库的解决方案之前部署到目标环境。</st>
    <st c="36621">一旦组件更新，应用程序创建者将通过组件更新过程（自动或主动）收到更新通知。</st>
- en: <st c="36769">Now that we have learned about canvas components and their reusability,
    we will go further and look what additional customizations are possible with the</st>
    <st c="36923">code components.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36769">现在我们已经学习了画布组件及其可重用性，接下来我们将进一步探讨在</st> <st c="36923">代码组件中可以进行哪些额外的自定义。</st>
- en: <st c="36939">Getting to know code components</st>
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="36939">了解代码组件</st>
- en: <st c="36971">Going one step further in pro-dev extensibility, the</st> **<st
    c="37025">Power Apps component framework</st>** <st c="37055">(</st>**<st c="37057">PCF</st>**<st
    c="37060">) allows</st> <st c="37070">professional developers to create code components
    that enrich the user experience whenever the look and feel of the built-in components
    is not sufficient.</st> <st c="37225">The PCF is such a big topic that it could
    have its own chapter in this book.</st> <st c="37302">In this section, we will
    try to give you at least an initial understanding of what the PCF is, how the
    PAC CLI can help us to build code components, and how to perform ALM using</st>
    <st c="37480">DevOps tools.</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36971">在专业开发者可扩展性的基础上再进一步，</st> **<st c="37025">Power Apps 组件框架</st>**
    <st c="37055">(</st>**<st c="37057">PCF</st>**<st c="37060">) 使得专业开发者可以创建代码组件，在内置组件的外观和体验不足时，提升用户体验。</st>
    <st c="37225">PCF 是一个非常庞大的话题，足以在本书中单独开设一章。</st> <st c="37302">在本节中，我们将尽量为你提供对
    PCF 的初步理解，了解 PAC CLI 如何帮助我们构建代码组件，以及如何使用</st> <st c="37480">DevOps 工具执行 ALM。</st>
- en: <st c="37493">The PCF</st> <st c="37502">is a unified framework that allows
    developers to build custom code components that are reusable across applications
    in Power Apps and websites in Power Pages.</st> <st c="37661">This opens a great
    opportunity for organizations to build code components and leverage them across
    business solutions.</st> <st c="37780">Using the PCF, we can develop code components
    that will include not only information about the visual appearance of the component
    but also the business logic.</st> <st c="37939">This allows us to make applications
    and websites more appealing and customized to the business problem.</st> <st c="38043">The
    PCF is a successor of HTML web resources, which were used prior to PCF to render
    custom UI components inside model-driven applications.</st> <st c="38183">The
    PCF is more optimized for performance compared to HTML web resources, making it
    suitable for complex</st> <st c="38288">business solutions.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37493">PCF</st> <st c="37502">是一个统一的框架，允许开发人员构建可在 Power Apps 和 Power
    Pages 网站中跨应用重用的自定义代码组件。</st> <st c="37661">这为组织提供了一个绝佳的机会，可以构建代码组件，并在业务解决方案中加以利用。</st>
    <st c="37780">通过使用 PCF，我们可以开发代码组件，这些组件不仅包含关于组件外观的信息，还包括业务逻辑。</st> <st c="37939">这使得我们能够让应用程序和网站在视觉上更具吸引力，并且根据业务需求进行定制。</st>
    <st c="38043">PCF 是 HTML Web 资源的继任者，HTML Web 资源曾用于在 PCF 之前，在模型驱动应用中渲染自定义 UI 组件。</st>
    <st c="38183">与 HTML Web 资源相比，PCF 在性能方面得到了更多的优化，使其更适用于复杂的</st> <st c="38288">业务解决方案。</st>
- en: <st c="38307">Custom pages in model-driven apps</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38307">模型驱动应用中的自定义页面</st>
- en: <st c="38341">Custom pages</st> <st c="38354">are flexible and powerful type
    of pages in model-driven apps that enable us to bring the experience from building
    canvas apps to model-driven apps.</st> <st c="38503">We can add canvas and code
    components to a custom page, which can be shown in a model-driven app as a main
    page, center dialog screen, or side dialog view.</st> <st c="38659">This gives
    us a great range of flexibility for building the experience of our</st> <st c="38737">business
    application.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38341">自定义页面</st> <st c="38354">是模型驱动应用中的一种灵活而强大的页面类型，允许我们将构建画布应用的体验带入模型驱动应用。</st>
    <st c="38503">我们可以向自定义页面中添加画布和代码组件，这些组件可以作为主页面、中心对话框屏幕或侧边对话框视图显示在模型驱动应用中。</st>
    <st c="38659">这为我们构建业务应用的体验提供了极大的灵活性。</st>
- en: <st c="38758">Currently, we know two types of PCF</st> <st c="38795">components:</st>
    **<st c="38807">standard</st>** <st c="38815">and</st> **<st c="38820">virtual</st>**<st
    c="38827">. Both types of components leverage</st> <st c="38863">HTML, CSS, and
    TypeScript.</st> <st c="38890">However, virtual components use two platform-provided
    libraries, React and Fluent UI.</st> <st c="38976">They are added to the parent
    virtual</st> **<st c="39013">Document Object Model</st>** <st c="39034">(</st>**<st
    c="39036">DOM</st>**<st c="39039">), which</st> <st c="39048">means that there
    is no need to instantiate a React virtual DOM separately with each component.</st>
    <st c="39144">Although React and Fluent UI can be used with standard PCF components,
    doing so requires the developer to package libraries individually within the components.</st>
    <st c="39304">In the case of virtual components, we are able to use platform-provided
    libraries, which allows us to improve the performance of our applications using
    these code components.</st> <st c="39479">It is important to note that even if
    we start with a standard code component, we can later convert it to a</st> <st
    c="39586">virtual component.</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38758">目前，我们知道有两种类型的 PCF</st> <st c="38795">组件：</st> **<st c="38807">标准</st>**
    <st c="38815">和</st> **<st c="38820">虚拟</st>**<st c="38827">。这两种组件都利用了</st> <st
    c="38863">HTML、CSS 和 TypeScript。</st> <st c="38890">然而，虚拟组件使用了两个平台提供的库，React 和
    Fluent UI。</st> <st c="38976">它们被添加到父虚拟</st> **<st c="39013">文档对象模型</st>** <st
    c="39034">(</st>**<st c="39036">DOM</st>**<st c="39039">)，这意味着不需要为每个组件单独实例化一个
    React 虚拟 DOM。</st> <st c="39144">尽管 React 和 Fluent UI 可以与标准 PCF 组件一起使用，但这样做需要开发者将库单独打包到组件中。</st>
    <st c="39304">对于虚拟组件，我们能够使用平台提供的库，这使得我们可以在使用这些代码组件时提升应用的性能。</st> <st c="39479">需要注意的是，即使我们开始时使用标准代码组件，后续也可以将其转换为</st>
    <st c="39586">虚拟组件。</st>
- en: <st c="39604">Depending on how the component will be used, we can differentiate
    between two types of</st> <st c="39692">PCF components:</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39604">根据组件的使用方式，我们可以区分两种类型的</st> <st c="39692">PCF 组件：</st>
- en: '**<st c="39707">Field</st>**<st c="39713">, where a code component can be bound
    to a field in</st> <st c="39765">a form</st>'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="39707">字段</st>**<st c="39713">，在这里，代码组件可以绑定到</st> <st c="39765">表单中的字段</st>'
- en: '**<st c="39771">Dataset</st>**<st c="39779">, which is a code component that
    is bound to a view, dataset, or collection in a canvas app and works with the
    rows of data from</st> <st c="39908">a dataset</st>'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="39771">数据集</st>**<st c="39779">，它是一个绑定到视图、数据集或画布应用中的集合的代码组件，可以与来自</st>
    <st c="39908">数据集</st> 的数据行一起工作'
- en: <st c="39917">Using these two types of PCF components, developers can build
    custom fields, columns, and views over datasets and dashboards that can replace
    built-in components in our</st> <st c="40087">business applications.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39917">使用这两种类型的 PCF 组件，开发人员可以在数据集和仪表板上构建自定义字段、列和视图，进而替换我们业务应用中的内建组件。</st>
- en: <st c="40109">Community resources for the PCF</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40109">PCF 的社区资源</st>
- en: <st c="40141">For those who are willing to learn</st> <st c="40177">more about
    the PCF and would like to see some examples that the wider community has developed
    using the PCF, Microsoft offers a set of links (to videos, blogs, and a code component
    gallery) that can be used for this purpose.</st> <st c="40402">For more information,
    go</st> <st c="40427">to:</st> [<st c="40431">https://learn.microsoft.com/en-us/power-apps/developer/component-framework/community-resources</st>](https://learn.microsoft.com/en-us/power-apps/developer/component-framework/community-resources)<st
    c="40525">.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40141">对于那些愿意学习</st> <st c="40177">更多关于PCF的内容，并希望查看更广泛社区使用PCF开发的一些示例，微软提供了一系列链接（视频、博客和代码组件库），可以用于此目的。</st>
    <st c="40402">欲了解更多信息，请访问</st> <st c="40427">：</st> [<st c="40431">https://learn.microsoft.com/en-us/power-apps/developer/component-framework/community-resources</st>](https://learn.microsoft.com/en-us/power-apps/developer/component-framework/community-resources)<st
    c="40525">。</st>
- en: <st c="40526">Code component composition</st>
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="40526">代码组件的组成</st>
- en: <st c="40553">No matter which control type or kind of component we decide to
    build, code components consist of three main elements—a manifest file, a component
    implementation, and</st> <st c="40720">resource files.</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40553">无论我们决定构建哪种控制类型或组件类型，代码组件由三个主要元素组成——清单文件、组件实现和</st> <st c="40720">资源文件。</st>
- en: <st c="40735">Manifest file</st>
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="40735">清单文件</st>
- en: <st c="40749">A control manifest</st> <st c="40768">is an XML file that is used
    to register and manage the code component.</st> <st c="40840">The</st> <st c="40844">name
    of the manifest file</st> <st c="40870">is</st> `<st c="40873">ControlManifest.Input.xml</st>`<st
    c="40898">.</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40749">控制清单</st> <st c="40768">是一个用于注册和管理代码组件的 XML 文件。</st> <st c="40840">清单文件的</st>
    <st c="40844">名称</st> <st c="40870">是</st> `<st c="40873">ControlManifest.Input.xml</st>`<st
    c="40898">。</st>
- en: <st c="40899">It holds all information about the code component, such as</st>
    <st c="40959">the following:</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40899">它包含了关于代码组件的所有信息，例如</st> <st c="40959">以下内容：</st>
- en: <st c="40973">The component</st> <st c="40988">metadata information</st>
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="40973">组件</st> <st c="40988">元数据</st>
- en: <st c="41008">Information about the control type (standard</st> <st c="41054">or
    virtual)</st>
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41008">关于控制类型的信息（标准</st> <st c="41054">或虚拟）</st>
- en: <st c="41065">Whether any external services are going to be used (which would
    require</st> <st c="41138">premium licensing)</st>
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41065">是否将使用任何外部服务（这将需要</st> <st c="41138">高级许可）</st>
- en: <st c="41156">Properties that are available</st> <st c="41187">for use</st>
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41156">可用的属性</st> <st c="41187">供使用</st>
- en: <st c="41194">Used resources</st>
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41194">已使用的资源</st>
- en: <st c="41209">Other</st> <st c="41216">metadata and</st> <st c="41229">config
    data</st>
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="41209">其他</st> <st c="41216">元数据和</st> <st c="41229">配置信息</st>
- en: <st c="41240">The properties available in the code component can then be either
    manually entered or dynamically set to a value or data from other components in</st>
    <st c="41387">the application.</st>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41240">代码组件中可用的属性可以手动输入或动态设置为来自</st> <st c="41387">应用程序中其他组件的值或数据。</st>
- en: <st c="41403">Component implementation</st>
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="41403">组件实现</st>
- en: <st c="41428">Code component logic is</st> <st c="41452">implemented in a file
    called</st> `<st c="41482">index.ts</st>`<st c="41490">. Here we are able to place
    the code that will define the behavior of our code component.</st> <st c="41580">This
    is the place where we can find methods that control the life cycle of our</st>
    <st c="41659">code component.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41428">代码组件的逻辑在一个名为</st> `<st c="41482">index.ts</st>`<st c="41490">的文件中实现。在这里，我们可以放置定义代码组件行为的代码。</st>
    <st c="41580">这是我们可以找到控制代码组件生命周期方法的地方。</st> <st c="41659">代码组件。</st>
- en: <st c="41674">The life cycle of the code component can be divided into four</st>
    <st c="41737">main methods:</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41674">代码组件的生命周期可以分为四个</st> <st c="41737">主要方法：</st>
- en: '`<st c="41750">init</st>`<st c="41755">: This method is used to initialize
    the component instance.</st> <st c="41816">This function not only configures the
    component but can also register any event listeners or add other functionalities
    for the component to properly behave.</st> <st c="41973">This method is required
    to be implemented in the code</st> <st c="42027">implementation file.</st>'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="41750">init</st>`<st c="41755">：此方法用于初始化组件实例。</st> <st c="41816">此功能不仅配置组件，还可以注册任何事件监听器或添加其他功能，以确保组件正确运行。</st>
    <st c="41973">此方法需要在代码</st> <st c="42027">实现文件中实现。</st>'
- en: '`<st c="42047">updateView</st>`<st c="42058">: This method gets called when
    any value in the component’s properties or component metadata changes.</st> <st
    c="42161">It is used to reflect the changes in the component’s UI.</st> <st c="42218">This
    method is required to be implemented in the code</st> <st c="42272">implementation
    file.</st>'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="42047">updateView</st>`<st c="42058">：当组件的属性或组件元数据中的任何值发生变化时，会调用此方法。</st>
    <st c="42161">它用于反映组件 UI 中的变化。</st> <st c="42218">此方法需要在代码</st> <st c="42272">实现文件中实现。</st>'
- en: '`<st c="42292">getOutputs</st>`<st c="42303">: This method gets called prior
    to a component receiving new data.</st> <st c="42371">This method is optional
    in the code</st> <st c="42407">implementation file.</st>'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="42694">资源文件</st>
- en: '`<st c="42427">destroy</st>`<st c="42435">: This method gets called when the
    component is to be removed from the DOM tree.</st> <st c="42517">It should be
    used to perform any cleanup operation and release any memory that the component
    is using.</st> <st c="42620">This method is required to be implemented in the
    code</st> <st c="42674">implementation file.</st>'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="42292">getOutputs</st>`<st c="42303">：此方法在组件接收新数据之前调用。</st> <st c="42371">此方法在代码</st>
    <st c="42407">实现文件中是可选的。</st>'
- en: <st c="42694">Resource files</st>
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="44012">前提条件</st>
- en: <st c="42709">In the manifest file, one of the</st> <st c="42743">nodes that
    defines code components is</st> `<st c="42781">resources</st>`<st c="42790">.
    This node holds the information about the code resource, which is our</st> `<st
    c="42862">index.ts</st>` <st c="42870">file, which contains code logic.</st> <st
    c="42904">Next to the</st> `<st c="42916">code</st>` <st c="42920">resource, we
    have static files that define the visual appearance of the code component.</st>
    <st c="43009">Here we can find a</st> **<st c="43028">Cascading Style Sheets</st>**
    <st c="43050">(</st>**<st c="43052">CSS</st>**<st c="43055">) file</st> <st c="43062">that
    contains code that controls the visual representation of</st> <st c="43125">the
    component.</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42709">在清单文件中，定义代码组件的节点之一是</st> <st c="42743">`resources`</st><st c="42790">。该节点包含关于代码资源的信息，也就是我们的</st>
    `<st c="42862">index.ts</st>` <st c="42870">文件，其中包含代码逻辑。</st> <st c="42904">在</st>
    `<st c="42916">代码</st>` <st c="42920">资源旁边，我们有静态文件，定义了代码组件的视觉外观。</st> <st c="43009">这里我们可以找到一个</st>
    **<st c="43028">层叠样式表</st>** <st c="43050">(</st>**<st c="43052">CSS</st>**<st
    c="43055">) 文件</st> <st c="43062">，其中包含控制组件视觉表现的代码。</st>
- en: <st c="43139">Since code components can be reused across applications and environments,
    support for localization is beneficial, as it allows us to share components across
    applications where there might be other language requirements.</st> <st c="43360">The
    PCF supports localization.</st> <st c="43391">Localized strings can be stored
    in RESX web resource files and registered in the manifest file.</st> <st c="43487">Other
    files, for images, icons, or anything else that is required for the component
    to work properly, can be added.</st> <st c="43603">Files are usually stored in
    a separate folder structure, registered in the manifest file, and referenced in
    the</st> <st c="43715">code logic.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43139">由于代码组件可以在不同的应用和环境中重用，因此支持本地化非常有利，因为它允许我们在有其他语言需求的应用之间共享组件。</st>
    <st c="43360">PCF支持本地化。</st> <st c="43391">本地化字符串可以存储在 RESX Web 资源文件中，并在清单文件中注册。</st>
    <st c="43487">其他文件，如图像、图标或任何其他需要的文件，都可以添加。</st> <st c="43603">文件通常存储在一个单独的文件夹结构中，注册在清单文件中，并在</st>
    <st c="43715">代码逻辑中引用。</st>
- en: <st c="43726">Now that we have learned what the file structure of the code components
    looks like, let us go ahead and create our simple</st> <st c="43849">code component.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43726">现在我们已经了解了代码组件的文件结构，接下来让我们创建一个简单的</st> <st c="43849">代码组件。</st>
- en: <st c="43864">Creating your code component</st>
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="43864">创建代码组件</st>
- en: <st c="43893">In this exercise, we will be creating a</st> <st c="43934">virtual
    (React) control type, since this will be the recommended control type</st> <st
    c="44012">going forward.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43893">在这个练习中，我们将创建一个</st> <st c="43934">虚拟（React）控件类型，因为这是未来推荐的控件类型。</st>
- en: <st c="44026">Prerequisites</st>
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`<st c="42427">destroy</st>`<st c="42435">：当组件从 DOM 树中移除时，会调用此方法。</st> <st
    c="42517">它应被用于执行任何清理操作，并释放组件所使用的任何内存。</st> <st c="42620">此方法需要在代码</st> <st c="42674">实现文件中实现。</st>'
- en: <st c="44040">In order to build the code</st> <st c="44068">component, we need
    to have installed the tools mentioned in the</st> *<st c="44132">Technical</st>*
    *<st c="44142">requirements</st>* <st c="44154">section.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44040">为了构建代码</st> <st c="44068">组件，我们需要安装在</st> *<st c="44132">技术</st>*
    *<st c="44142">要求</st>* <st c="44154">部分中提到的工具。</st>
- en: <st c="44163">To get the .NET build tools, Visual Studio 2019 or higher (Visual
    Studio 2022) should be installed.</st> <st c="44264">Instead of installing the
    complete Visual Studio, we can select just the .NET build tools as the workload
    during the installation wizard.</st> <st c="44402">An alternative to this is to
    install the .NET 8.0 SDK.</st> <st c="44457">Currently, .NET 8.0 is the latest
    long-term</st> <st c="44501">support version.</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44163">要获取 .NET 构建工具，应安装 Visual Studio 2019 或更高版本（Visual Studio 2022）。</st>
    <st c="44264">我们可以选择仅在安装向导中选择 .NET 构建工具作为工作负载，而不是安装完整的 Visual Studio。</st> <st
    c="44402">另一种选择是安装 .NET 8.0 SDK。</st> <st c="44457">目前，.NET 8.0 是最新的长期</st> <st
    c="44501">支持版本。</st>
- en: <st c="44517">Initializing the project</st>
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="44517">初始化项目</st>
- en: <st c="44542">First, we need to initialize the</st> <st c="44576">project.</st>
    <st c="44585">For this, we will be using the PAC CLI and its set of commands specific
    to the PCF.</st> <st c="44669">We can achieve this using the</st> <st c="44699">following
    command:</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44542">首先，我们需要初始化</st> <st c="44576">项目。</st> <st c="44585">为此，我们将使用
    PAC CLI 以及其特定于 PCF 的命令集。</st> <st c="44669">我们可以使用以下命令来实现这一点：</st>
- en: '[PRE5]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="44855">Two parameters stand out –</st> `<st c="44883">template</st>`
    <st c="44891">and</st> `<st c="44896">framework</st>`<st c="44905">. Now,</st>
    `<st c="44912">template</st>` <st c="44920">describes whether we will be creating
    a code component that will be used with fields or datasets.</st> `<st c="45019">framework</st>`
    <st c="45028">defines which framework will we be using.</st> <st c="45071">If
    using</st> `<st c="45080">React</st>`<st c="45085">, then this will be marked
    as a virtual control type; otherwise, it will be a standard control type.</st>
    <st c="45186">If we do not provide a</st> `<st c="45209">--run-npm-install</st>`
    <st c="45226">or</st> `<st c="45230">--npm</st>` <st c="45235">switch in the command,
    we will need to run the</st> `<st c="45283">npm install</st>` <st c="45294">command
    separately, to install the</st> <st c="45330">project dependencies.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44855">有两个参数非常突出—</st> `<st c="44883">template</st>` <st c="44891">和</st>
    `<st c="44896">framework</st>`<st c="44905">。现在，</st> `<st c="44912">template</st>`
    <st c="44920">描述我们是否会创建一个用于字段或数据集的代码组件。</st> `<st c="45019">framework</st>` <st
    c="45028">定义了我们将使用的框架。</st> <st c="45071">如果使用</st> `<st c="45080">React</st>`<st
    c="45085">，那么它将标记为虚拟控制类型；否则，它将是标准控制类型。</st> <st c="45186">如果我们没有在命令中提供</st> `<st
    c="45209">--run-npm-install</st>` <st c="45226">或</st> `<st c="45230">--npm</st>`
    <st c="45235">开关，我们将需要单独运行</st> `<st c="45283">npm install</st>` <st c="45294">命令，以安装</st>
    <st c="45330">项目依赖。</st>
- en: <st c="45351">In our example, we used the</st> <st c="45380">following command
    to initialize the project of a folder structure with some</st> <st c="45456">supporting
    files:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45351">在我们的示例中，我们使用了</st> <st c="45380">以下命令来初始化一个包含一些</st> <st c="45456">支持文件的文件夹结构的项目：</st>
- en: '[PRE6]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="45574">Here is the</st> <st c="45587">folder structure:</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45574">以下是</st> <st c="45587">文件夹结构：</st>
- en: '![Figure 10.10 – Folder structure of the PCF initialized project](img/B22208_10_10.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – PCF 初始化项目的文件夹结构](img/B22208_10_10.jpg)'
- en: <st c="45716">Figure 10.10 – Folder structure of the PCF initialized project</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45716">图 10.10 – PCF 初始化项目的文件夹结构</st>
- en: <st c="45778">Now that we have initialized the project and have files and a
    folder structure, we can move on to start implementing the</st> <st c="45900">code
    logic.</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45778">现在，我们已经初始化了项目，并且有了文件和文件夹结构，接下来可以开始实现</st> <st c="45900">代码逻辑。</st>
- en: <st c="45911">Implementing the code component</st>
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="45911">实现代码组件</st>
- en: <st c="45943">As we can see in the</st> <st c="45964">folder structure of our
    code component, our manifest file is also present in the</st> <st c="46046">PCF
    project.</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45943">正如我们在</st> <st c="45964">代码组件的文件夹结构中看到的那样，我们的清单文件也存在于</st> <st
    c="46046">PCF 项目中。</st>
- en: <st c="46058">Inside the</st> `<st c="46070">ControlManifest.Input.xml</st>`
    <st c="46095">file, we can see the</st> `<st c="46117">control</st>` <st c="46124">element,
    which includes information about our code component, including the control type
    being set</st> <st c="46224">to</st> `<st c="46227">virtual</st>`<st c="46234">:</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46058">在</st> `<st c="46070">ControlManifest.Input.xml</st>` <st c="46095">文件中，我们可以看到</st>
    `<st c="46117">control</st>` <st c="46124">元素，其中包括关于我们的代码组件的信息，包括控制类型设置为</st>
    <st c="46224">virtual</st><st c="46234">：</st>
- en: '[PRE7]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <property name="sampleProperty" display-name-key="Property_Display_Key" description-key="Property_Desc_Key"
    <st c="46761">of-type="Whole.None"</st> usage="bound" required="true" />
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <property name="sampleProperty" display-name-key="Property_Display_Key" description-key="Property_Desc_Key"
    <st c="46761">of-type="Whole.None"</st> usage="bound" required="true" />
- en: '[PRE8]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: pac solution init
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: pac solution init
- en: '[PRE9]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: pac solution add-reference --path <LOCATION_TO_PCFPROJ_FILE>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: pac solution add-reference --path <LOCATION_TO_PCFPROJ_FILE>
- en: '[PRE10]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <ItemGroup>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <ItemGroup>
- en: <ProjectReference Include="..\SamPCF\SamPCF.pcfproj" />
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <ProjectReference Include="..\SamPCF\SamPCF.pcfproj" />
- en: </ItemGroup>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: </ItemGroup>
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: dotnet build /t:build /restore
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: dotnet build /t:build /restore
- en: '[PRE12]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: pac pcf push –solution-unique-name <SOLUTION_NAME>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: pac pcf push –solution-unique-name <SOLUTION_NAME>
- en: '[PRE13]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: pac pcf push -pp <PUBLISHER_PREFIX>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: pac pcf push -pp <PUBLISHER_PREFIX>
- en: '[PRE14]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <PropertyGroup>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <Name>PCF</Name>
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <Name>PCF</Name>
- en: <ProjectGuid>e71d2e10-908c-4123-9f29-3283cbd224ab</ProjectGuid>
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <ProjectGuid>e71d2e10-908c-4123-9f29-3283cbd224ab</ProjectGuid>
- en: <OutputPath>$(MSBuildThisFileDirectory)out\controls</OutputPath>
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <OutputPath>$(MSBuildThisFileDirectory)out\controls</OutputPath>
- en: <PcfBuildMode>production</PcfBuildMode>
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <PcfBuildMode>production</PcfBuildMode>
- en: </PropertyGroup>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: '[PRE15]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <PropertyGroup>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <PropertyGroup>
- en: <SolutionPackageType>Managed</SolutionPackageType>
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <SolutionPackageType>Managed</SolutionPackageType>
- en: </PropertyGroup>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: </PropertyGroup>
- en: '[PRE16]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <control namespace="SimpleReactNS" constructor="SimpleReactPCF" <st c="60190">version="0.0.1"</st>
    display-name-key="SimpleReactPCF" description-key="SimpleReactPCF description"
    control-type="virtual" >
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <control namespace="SimpleReactNS" constructor="SimpleReactPCF" <st c="60190">version="0.0.1"</st>
    display-name-key="SimpleReactPCF" description-key="SimpleReactPCF description"
    control-type="virtual" >
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: pac pcf version --strategy manifest
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: pac pcf version --strategy manifest
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: pac pcf version --patchversion <PATCH VERSION>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: pac pcf version --patchversion <PATCH VERSION>
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '# Show all Power Pages websites'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '# 显示所有 Power Pages 网站'
- en: pac pages list
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: pac pages list
- en: download content of a website with Website Id from Power Pages to a selected
    location. pac pages download -id <PAGES_WEB_ID> -p <DOWNLOAD_LOCATION>
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载 Power Pages 网站的内容并将其传输到选定位置。 pac pages download -id <PAGES_WEB_ID> -p <DOWNLOAD_LOCATION>
- en: we perform changes to the file and decide to upload the changes, using the deployment
    profiles. pac pages upload –path <PATH_LOCATION> --environment <ENVIRONMENT_ID>
    --deploymentProfile <PROFILETAG>
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们对文件进行更改，并决定上传这些更改，使用部署配置文件。 pac pages upload –path <PATH_LOCATION> --environment
    <ENVIRONMENT_ID> --deploymentProfile <PROFILETAG>
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '步骤:'
- en: '- task: PowerPlatformToolInstaller@2'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '- 任务: PowerPlatformToolInstaller@2'
- en: 'inputs:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 'inputs:'
- en: 'DefaultVersion: true'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '默认版本: true'
- en: '- task: PowerPlatformDownloadPaportal@2'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '- 任务: PowerPlatformDownloadPaportal@2'
- en: 'inputs:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 'inputs:'
- en: 'authenticationType: ''PowerPlatformSPN'''
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '认证类型: ''PowerPlatformSPN'''
- en: 'PowerPlatformSPN: ''PP-DevUS-SPN'''
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'PowerPlatformSPN: ''PP-DevUS-SPN'''
- en: 'DownloadPath: ''Portal/'''
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '下载路径: ''Portal/'''
- en: 'WebsiteId: ''$(WebsiteID)'''
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'WebsiteId: ''$(WebsiteID)'''
- en: '- task: CmdLine@2'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '- 任务: CmdLine@2'
- en: 'inputs:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'inputs:'
- en: 'script: |'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '脚本: |'
- en: echo commit all changes
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: echo 提交所有更改
- en: git config user.email "<EMAIL@DOMAIN.COM>"
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: git config user.email "<EMAIL@DOMAIN.COM>"
- en: git config user.name "<USER_NAME>"
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: git config user.name "<USER_NAME>"
- en: git init
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: git init
- en: git checkout -B main
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: git checkout -B main
- en: git add --all
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: git add --all
- en: git commit -m "code commit"
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: git commit -m "代码提交"
- en: git push --set-upstream origin main
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: git push --set-upstream origin main
- en: 'git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" push
    -f origin HEAD:main'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" push
    -f origin HEAD:main'
- en: '[PRE21]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '步骤:'
- en: '- task: PowerPlatformToolInstaller@2'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '- 任务: PowerPlatformToolInstaller@2'
- en: 'inputs:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'inputs:'
- en: 'DefaultVersion: true'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '默认版本: true'
- en: '- task: PowerPlatformUploadPaportal@2'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '- 任务: PowerPlatformUploadPaportal@2'
- en: 'inputs:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 'inputs:'
- en: 'authenticationType: ''PowerPlatformSPN'''
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '认证类型: ''PowerPlatformSPN'''
- en: 'PowerPlatformSPN: ''PP-DevUS-SPN'''
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'PowerPlatformSPN: ''PP-DevUS-SPN'''
- en: 'UploadPath: ''Portal/$(WebsiteName)'''
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '上传路径: ''Portal/$(WebsiteName)'''
- en: 'DeploymentProfile: ''$(profileTag)'''
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'DeploymentProfile: ''$(profileTag)'''
- en: '[PRE22]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
