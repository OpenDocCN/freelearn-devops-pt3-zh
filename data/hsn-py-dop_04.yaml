- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Provisioning Resources
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供资源
- en: Life is chaotic, dangerous, and surprising. Buildings should reflect that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 生活是混乱的，危险的，充满了惊喜。建筑物应该反映这一点。
- en: – Frank Gehry (famous architect)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: – 弗兰克·盖里（著名建筑师）
- en: '**DevOps** is a game of resources. Of taking the resources that you have and
    putting them in the right place. It sounds easy, but it is not. The acquisition
    of resources is based on several criteria and requirements that the DevOps engineer
    receives. If you want to optimally provision resources, then you have to understand
    the logic and reasoning behind provisioning those resources as well as the strategy
    behind the intended use of the underlying infrastructure.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps** 是资源的游戏。是将你拥有的资源放到正确位置的游戏。听起来很容易，但实际上并非如此。资源的获取基于 DevOps 工程师收到的多个标准和要求。如果你想要最优地提供资源，那么你必须理解背后的逻辑和推理，以及底层基础设施使用策略背后的战略。'
- en: 'And if you want all that in plain English: take only what you need.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以简单的英语来表达这一切：只拿你所需的。
- en: 'So, that will be one of the underlying concepts of this chapter: rightsizing.
    **Rightsizing** is the art of finding the optimal resource sizes for your application
    or workload. A lot of this is just trial and error (often yours, but someone else’s
    if you can get it) and trust me when I say this, it is much easier to do that
    programmatically than manually in the modern DevOps landscape.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这将是本章的一个基本概念之一：权益调整。**权益调整**是找到你的应用程序或工作负载的最佳资源大小的艺术。很多时候只是试错（通常是你自己的，但如果可能的话，是别人的），相信我说这一点，现代
    DevOps 景观中，以编程方式进行比手动方式要容易得多。
- en: But that’s easier said than done, because sometimes the load placed upon your
    resources is a lot larger than the size of the resources you’ve provisioned, especially
    if your application becomes popular. You become a victim of your own success.
    Or you provision resources that can hold at maximum capacity, but that capacity
    is only occasional, and you can’t possibly ramp your resources up in time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但说起来容易做起来难，因为有时你的资源承载的负载远大于你配置的资源的大小，特别是如果你的应用程序变得流行起来。你成为了自己成功的受害者。或者你配置了最大容量的资源，但那种容量只是偶尔需要，而你不可能及时增加你的资源。
- en: 'This brings us to the second underlying concept of this chapter: scaling. **Scaling**
    your resources up and down is one of the important aspects of DevOps and removing
    resources is as key an aspect of provisioning them as adding resources is. This
    must almost always be done programmatically, and we will look at a couple of ways
    in which Python can help us with that.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了本章的第二个基本概念：扩展。**扩展**你的资源的增减是 DevOps 的重要方面之一，而删除资源与提供资源同样重要。这几乎总是以编程方式完成的，我们将看看
    Python 如何帮助我们做到这一点的几种方式。
- en: If you master these concepts and how to use them effectively, you can save you
    and your organization a massive amount of time, money, and resources. In addition
    to this, you will be able to deliver on spikes in demand in a way that addresses
    the needs of both your organization and its customers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你掌握了这些概念以及如何有效地使用它们，你可以为你和你的组织节省大量的时间、金钱和资源。此外，你将能够以满足组织和客户需求的方式应对需求激增。
- en: 'In this chapter, we will explore the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: How to provision virtual resources with Python
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Python 配置虚拟资源
- en: How to use Python SDKs for various clouds and provision resources through them
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用各种云的 Python SDK，并通过它们来提供资源
- en: How scaling works, the types of scaling, and choosing the correct type of scaling
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展工作原理，扩展的类型以及选择正确的扩展类型
- en: How containerization of resources can help with rightsizing and easier provisioning
    (and where Python plays a role)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用资源的容器化可以帮助权益调整和更容易的提供资源（以及 Python 在其中的角色）
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here is a list of requirements that you will need to meet to complete the exercises
    in this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是完成本章练习所需满足的要求列表：
- en: Python installation with boto3, Kubernetes, and Docker libraries installed
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Python，并安装了 boto3、Kubernetes 和 Docker 库
- en: An AWS account
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 AWS 账户
- en: Knowledge of how to use a Jupyter Notebook
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉如何使用 Jupyter Notebook
- en: If you are on Windows, the use of **Windows Subsystem for Linux** (**WSL**)
    to use Docker locally
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用 Windows，使用**Windows Subsystem for Linux**（**WSL**）来本地使用 Docker
- en: A GitHub account, and basic knowledge of Git and repositories
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 GitHub 账户，以及 Git 和仓库的基本知识
- en: 'Access to this book’s repository: [https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书代码库的访问地址：[https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps)
- en: A basic understanding of virtualization and Kubernetes
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对虚拟化和 Kubernetes 的基本理解
- en: Python SDKs (and why everyone uses them)
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python SDK（以及为什么大家都在使用它们）
- en: Let’s take it from the top. **SDKs**, or **software development kits**, are
    official programming libraries and **CLIs** released by a platform that allows
    developers to develop tools and applications that leverage that platform. These
    SDKs are usually written in very popular languages so as to cover the largest
    number of developers possible.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始讲。**SDKs**（即 **软件开发工具包**）是由平台发布的官方编程库和 **CLI**，它们允许开发者开发能够利用该平台的工具和应用程序。这些
    SDK 通常使用非常流行的语言编写，以覆盖尽可能多的开发者。
- en: 'The three major clouds (where the majority of DevOps work is done) have the
    following programming languages in common among them for SDKs: **Java**, **.NET**,
    **C++**, **Go**, **JavaScript**/**TypeScript**/**Node.js**, and **Python**. If
    you work on one of these – and the chances that you do are greater than the chances
    that you don’t – you need to choose a programming language.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 三大云平台（大多数 DevOps 工作都在这些平台上完成）在其 SDK 中共享以下编程语言：**Java**、**.NET**、**C++**、**Go**、**JavaScript**/**TypeScript**/**Node.js**
    和 **Python**。如果你从事这些工作——而你从事其中一项的可能性远大于不从事——你需要选择一门编程语言。
- en: So, the question then becomes, why Python? Also, why are we asking this question
    four chapters into this book? Well, I’ll tell you. Python is the exact balance
    between loose and structured that is necessary to pull off a lot of DevOps principles.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，问题就变成了，为什么是 Python？而且，为什么我们要在本书的四个章节后才提出这个问题？我来告诉你。Python 恰好是那种松散和结构化之间的平衡，它是实现许多
    DevOps 原则所必需的。
- en: Strictly typed languages such as Java, .NET, and C++ can be good for development,
    but they will produce awful results for the flexibility that is required of the
    modern DevOps workload. That being said, most clouds are built on these languages.
    But operating on them is a different game entirely. Think of these languages as
    the bones that provide sturdiness and Python as the joints that provide flexibility
    – they should be everywhere that requires flexibility.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 严格类型化的语言，如 Java、.NET 和 C++，对于开发来说是不错的选择，但对于现代 DevOps 工作负载所需的灵活性，它们将产生糟糕的结果。话虽如此，大多数云平台都是建立在这些语言上的。但在这些语言上进行操作完全是另一回事。把这些语言看作是提供坚固性的骨架，而把
    Python 看作是提供灵活性的关节——它们应该存在于任何需要灵活性的地方。
- en: Then, on the other end of the spectrum, you have that JavaScript trio. The reason
    they are sometimes unsuited for this – even though there is a massive amount of
    support for them from the major clouds – is the limitations and syntactic quirks
    that are natural to these languages. They aren’t meant to natively work this way
    and in addition to that, they are single-threaded and difficult to operate concurrently.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在另一个极端，你会看到那组 JavaScript 三重奏。即使这些语言得到了主要云平台的大量支持，它们有时仍然不适合这个用途，原因在于它们固有的局限性和语法怪癖。这些语言本来并不是为了这样原生工作，而且它们是单线程的，难以并发操作。
- en: The primary competitor and, at times, cooperator to Python in this department
    is Go. And let me tell you, Go is good. A majority of cloud-based tools such as
    **Docker** and **Kubernetes** are built in Go, and ones that aren’t are usually
    built in Python. But Go is really the only other language that can go toe to toe
    with Python for how useful it is in DevOps. And I’m telling you this because much
    of what I’m going to work through in this chapter will involve frameworks written
    in Go, such as **Terraform** and Docker.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一领域，Python 的主要竞争对手，有时也是合作伙伴的是 Go。让我告诉你，Go 很棒。大多数云端工具，比如 **Docker** 和 **Kubernetes**，都是用
    Go 编写的，而那些不是用 Go 编写的，通常是用 Python 编写的。但是，Go 真的可以与 Python 一较高下，它在 DevOps 中的实用性不容小觑。我之所以这么说，是因为在本章中，我将处理很多用
    Go 编写的框架，比如 **Terraform** 和 Docker。
- en: With all of this information out of the way, let’s finally put the focus back
    on Python. Python is easygoing. It has variable assignment without strict data
    types, which is incredibly useful for loosely coupled services, a very common
    architectural choice. It has a big community and is almost always the first SDK
    offered by modern infrastructure providers. As mentioned previously in this section,
    Python can essentially enter into a symbiotic relationship with any framework
    written in any language. If there is a popular framework or tool, its Pythonic
    version will likely be well-maintained and properly updated.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了所有这些信息后，让我们终于将注意力重新集中到Python上。Python是非常宽松的。它具有不需要严格数据类型的变量赋值，这对于松耦合的服务非常有用，而松耦合服务是一种非常常见的架构选择。它拥有一个庞大的社区，几乎总是现代基础设施提供商首先提供的SDK。如本节前面所提到的，Python本质上可以与任何用任何语言编写的框架建立共生关系。如果有一个流行的框架或工具，它的Python版本很可能会得到良好的维护并及时更新。
- en: That was a quick look at the importance of and popularity of Python SDKs, now,
    we are now going to see an example of how Python SDKs can be used to provision
    resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是快速了解Python SDK的重要性和受欢迎程度，现在，我们将看到一个示例，展示Python SDK如何用于配置资源。
- en: Creating an AWS EC2 instance with Python’s boto3 library
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python的boto3库创建AWS EC2实例
- en: '**Boto3** – it’s a name you’ve probably heard very often if you’ve worked with
    AWS and Python. It is the SDK that contains nearly every major AWS service that
    is currently available with Python.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Boto3** – 这是你如果在AWS和Python中工作过，可能经常听到的名字。它是包含几乎所有当前可用的AWS服务的SDK，适用于Python。'
- en: 'For this example, we are going to use Boto3 in a script that will provision
    an EC2 instance in your AWS account. It sounds simple, but there are still a lot
    of steps that you need to follow to make it happen, so let’s get started. We will
    now begin by first logging into our AWS account and searching for the Sagemaker
    service. Let’s dive into it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Boto3在脚本中创建一个EC2实例，供你在AWS账户中使用。这听起来很简单，但为了实现这一目标，你仍然需要遵循很多步骤，所以让我们开始吧。首先，我们将登录到AWS账户并搜索Sagemaker服务。让我们深入了解：
- en: 'For this exercise, we need a clean environment where we can write Python code
    but also configure permissions in a terminal. To do this, in my AWS account, I’m
    going to create something else that we will use down the line: a **Sagemaker**
    notebook. A Sagemaker notebook is a Jupyter notebook service run on AWS servers:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个练习，我们需要一个干净的环境，既能编写Python代码，又能在终端中配置权限。为此，在我的AWS账户中，我将创建另一个我们稍后会用到的东西：一个**Sagemaker**笔记本。Sagemaker笔记本是一个在AWS服务器上运行的Jupyter笔记本服务：
- en: '![Figure 4.1 – Console to create a notebook instance in Amazon Sagemaker](img/B21320_04_1.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 在Amazon Sagemaker中创建笔记本实例的控制台](img/B21320_04_1.jpg)'
- en: Figure 4.1 – Console to create a notebook instance in Amazon Sagemaker
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 在Amazon Sagemaker中创建笔记本实例的控制台
- en: If you look at the breadcrumb at the top, you can see that the path is **Amazon
    Sagemaker** -> **Notebook instances** -> **Create** **notebook instance**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看顶部的面包屑导航，你会看到路径是**Amazon Sagemaker** -> **Notebook实例** -> **创建** **Notebook实例**。
- en: 'Any smaller notebook is good. We’re using **ml.t3.medium** for this exercise:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何较小的笔记本都可以。我们将在这个练习中使用**ml.t3.medium**：
- en: '![Figure 4.2 – Created notebook](img/B21320_04_2.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 已创建的笔记本](img/B21320_04_2.jpg)'
- en: Figure 4.2 – Created notebook
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 已创建的笔记本
- en: Once your notebook is up and running, click on **Open Jupyter** to get to your
    **Jupyter IDE**. Now, the instance itself will have some AWS permissions because
    it is an AWS creation, but not enough to provision an EC2 programmatically. It
    will, however, come pre-installed with boto3 and the **AWS CLI**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的笔记本启动并运行，点击**打开Jupyter**，进入你的**Jupyter IDE**。现在，实例本身将具有一些AWS权限，因为它是AWS创建的，但还不足以程序化地配置EC2。然而，它将预装boto3和**AWS
    CLI**。
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you don’t have them installed, install `boto3` with `pip` and the AWS CLI
    through AWS’s official website [(https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)),
    which contains installers for all operating systems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有安装它们，可以通过`pip`安装`boto3`，并通过AWS官网[(https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)安装AWS
    CLI，官网提供了适用于所有操作系统的安装程序。
- en: 'Now, let’s try and provision the EC2 with the pre-existing Sagemaker role that
    comes pre-assigned to Sagemaker:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用Sagemaker预先分配的现有角色来配置EC2：
- en: '![Figure 4.3 – Code to invoke boto3 API](img/B21320_04_3.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 调用 boto3 API 的代码](img/B21320_04_3.jpg)'
- en: Figure 4.3 – Code to invoke boto3 API
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 调用 boto3 API 的代码
- en: It worked. But, as you see here, the Sagemaker instance already came pre-configured
    with a role that had EC2 access.. If that had not been the case, you would have
    had to give the role some permissions or use the AWS CLI to attach a role profile
    to the instance. But it worked, and that is great. You can view your EC2 instance
    in your AWS console.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它成功了。但是，正如你在这里看到的，Sagemaker 实例已经预先配置了一个具有 EC2 访问权限的角色。如果情况不是这样，你将不得不授予角色一些权限或使用
    AWS CLI 将角色配置文件附加到实例上。但它起作用了，这太棒了。你可以在 AWS 控制台上查看你的 EC2 实例。
- en: 'However, there are a few things to note here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在这里需要注意几点：
- en: You always need to define an `ImageID` (AWS has a public catalog). The one I’m
    using is AWS’s proprietary Linux version.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你总是需要定义一个 `ImageID`（AWS 有一个公共目录）。我使用的是 AWS 的专有 Linux 版本。
- en: You need to define the instance size and the maximum and minimum number of instances
    to create.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要定义实例大小以及要创建的实例的最大和最小数量。
- en: Now, that was simple and easy to understand, wasn’t it? Well, that’s good. Now
    we can move on to the concepts that make the provisioning of resources so necessary.
    Scaling and autoscaling are essential concepts in DevOps and they are both just
    a matter of provisioning resources.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这很简单易懂，不是吗？好的。现在我们可以继续讨论使资源配置如此必要的概念。缩放和自动缩放是DevOps中至关重要的概念，它们都只是资源配置的问题。
- en: Scaling and autoscaling
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缩放和自动缩放
- en: '**Scaling** is the act of increasing or decreasing the size of a workload or
    resource depending on the demand for it. **Autoscaling** is doing this automatically
    based on some sort of trigger.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**缩放** 是根据需求增加或减少工作负载或资源的大小的行为。**自动缩放** 是根据某种触发器自动执行此操作。'
- en: As is often the case with workloads and applications, you can become a victim
    of your own success. The more your application succeeds, the greater the strain
    on it due to demand from users or services. To manage this strain often requires
    limitations placed on access to your application. You should do this if you don’t
    want to get overwhelmed with requests, trust me, because someone will try to do
    exactly that. But you should also have provisions in your infrastructure that
    can help it grow naturally with your growing user base.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作负载和应用程序的情况下经常会发生这种情况，你可能会成为自己成功的受害者。你的应用程序成功越多，由于用户或服务的需求而对其造成的压力就越大。要管理这种压力通常需要限制对你的应用程序的访问。如果你不想被请求压倒，你应该这样做，相信我，因为肯定会有人试图做到这一点。但你也应该在你的基础设施中有能力让它随着用户基数的增长而自然增长。
- en: That is where scaling comes in. Scaling can be done either vertically (adding
    greater computing power to a device) or horizontally (adding more computers).
    When performing one powerful act, vertical scaling is ideal and when processing
    a greater number of requests, you’ll need horizontal scaling. Most DevOps workloads
    require the latter over the former.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是缩放发挥作用的地方。缩放可以通过垂直方式（向设备添加更大的计算能力）或水平方式（添加更多计算机）来进行。在执行一项强大的操作时，垂直缩放是理想的选择，在处理更多请求时，你将需要水平缩放。大多数
    DevOps 工作负载需要后者而不是前者。
- en: We will now explore the different types of scaling based on how hands-on you
    have to be with the workload that you are scaling. We will start with manual scaling
    and slowly escalate toward a more automated approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨基于你需要处理的工作负载的参与程度而不同的缩放类型。我们将从手动缩放开始，逐步升级到更自动化的方法。
- en: Manual scaling with Python
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Python 进行手动缩放
- en: 'Before we dive into autoscaling, let’s just look at some regular scaling (done
    with Python, of course). We will vertically scale an instance manually using Python’s
    SDK for AWS. I will be using just my regular local IDE. But you can do this with
    any combination of Python, AWS CLI, and an AWS account. So, let’s head into the
    steps you would need to take to manually scale an EC2 instance using Python scripts:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论自动缩放之前，让我们看看一些常规的缩放（当然要使用 Python）。我们将使用 Python 的 SDK 手动垂直缩放一个实例。我只是使用我的常规本地
    IDE。但你可以使用任何组合的 Python、AWS CLI 和 AWS 账户来执行此操作。所以，让我们进入使用 Python 脚本手动缩放 EC2 实例的步骤：
- en: 'Here is the code to create an EC2 instance (this will be up in the book’s repository
    as well):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是创建 EC2 实例的代码（这也将在书的存储库中发布）：
- en: '![Figure 4.4 – Function to create an EC2 instance](img/B21320_04_4.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 创建 EC2 实例的功能](img/B21320_04_4.jpg)'
- en: Figure 4.4 – Function to create an EC2 instance
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 创建 EC2 实例的功能
- en: 'And when you run it, you’ll get the instance ID (which you will need for this
    next part):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行它时，你会得到实例 ID（你在下一部分中需要用到它）：
- en: '![Figure 4.5 – EC2 instance created with a unique ID](img/B21320_04_5.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – 创建具有唯一 ID 的 EC2 实例](img/B21320_04_5.jpg)'
- en: Figure 4.5 – EC2 instance created with a unique ID
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – 创建具有唯一 ID 的 EC2 实例
- en: 'You’ll see that the instance with that same instance size and ID has been created
    on the AWS EC2 console:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到，在 AWS EC2 控制台上已创建具有相同实例大小和 ID 的实例：
- en: '![Figure 4.6 – Running EC2 instance](img/B21320_04_6.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 运行中的 EC2 实例](img/B21320_04_6.jpg)'
- en: Figure 4.6 – Running EC2 instance
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 运行中的 EC2 实例
- en: 'Now, vertical scaling acts on that same instance but the instance size cannot
    be changed while it is running, so we will stop the instance first:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，垂直扩展作用于同一个实例，但实例大小在运行时无法更改，所以我们需要先停止该实例：
- en: '![Figure 4.7 – Function to stop an EC2 instance](img/B21320_04_7.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 停止 EC2 实例的功能](img/B21320_04_7.jpg)'
- en: Figure 4.7 – Function to stop an EC2 instance
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 停止 EC2 实例的功能
- en: 'This code will stop the instance when it is run. Confirm that the instance
    is stopped and note the size of the instance is still **t2.nano**:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在运行时会停止实例。确认实例已停止，并注意实例的大小仍然是**t2.nano**：
- en: '![Figure 4.8 – Stopped EC2 instance](img/B21320_04_8.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 停止的 EC2 实例](img/B21320_04_8.jpg)'
- en: Figure 4.8 – Stopped EC2 instance
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 停止的 EC2 实例
- en: 'Now, let’s write the code to modify the instance into a `t2.micro` instance:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写代码，将实例修改为`t2.micro`实例：
- en: '![Figure 4.9 – Code to update an EC2 instance](img/B21320_04_9.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 更新 EC2 实例的代码](img/B21320_04_9.jpg)'
- en: Figure 4.9 – Code to update an EC2 instance
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 更新 EC2 实例的代码
- en: 'After running this code, you’ll notice that on the console, your instance is
    now a **t2.micro** instance:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码后，你会发现控制台上显示的实例现在是**t2.micro**实例：
- en: '![Figure 4.10 – Updated EC2 instance size](img/B21320_04_10.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 更新后的 EC2 实例大小](img/B21320_04_10.jpg)'
- en: Figure 4.10 – Updated EC2 instance size
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 更新后的 EC2 实例大小
- en: So, once you restart the instance, it will have that extra power available.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，一旦你重新启动实例，它将具备额外的计算能力。
- en: You may have noticed that this is a slog. And vertical scaling is – more often
    than not – a slog of downtime. While there are use cases for things like these
    (especially when you need to work with bigger individual machines), it’s not the
    norm. Usually, horizontal autoscaling is better for your use case because of the
    lesser amount of downtime associated with the process. We’ll dive into that now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这是一个缓慢的过程。而垂直扩展 – 在很多情况下 – 都是一个停机的缓慢过程。尽管这种做法有其应用场景（尤其是在需要使用更强大单机的情况下），但这并不是常态。通常，水平自动扩展更适合你的使用场景，因为它关联的停机时间较少。接下来我们会深入探讨这个问题。
- en: Autoscaling with Python based on a trigger
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于触发器的 Python 自动扩展
- en: Autoscaling requires automating the process of increasing the available compute
    resources according to some sort of metric or statistic. In order to autoscale,
    we need to design a mechanism that will trigger our SDK call once a certain metric
    or threshold has been reached.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩展需要根据某些度量标准或统计数据自动增加可用的计算资源。为了实现自动扩展，我们需要设计一个机制，当某个度量标准或阈值达到时，它会触发我们的 SDK
    调用。
- en: Understand that looking at this particular example from a singular cloud perspective
    may make it seem a little impractical because most cloud platforms have in-built
    autoscaling. The key here lies in fine-tuning that autoscaling. I’m going to create
    an **autoscaling group** and define the thresholds for scaling using a Python
    script. Then, I’m going to modify those thresholds and I will tell you the significance
    of why after I have done it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请理解，从单一云平台的角度来看这个例子，可能会觉得它有点不切实际，因为大多数云平台都内置了自动扩展。关键在于如何微调这个自动扩展。我将创建一个**自动扩展组**，并使用
    Python 脚本定义扩展的阈值。然后，我将修改这些阈值，修改后我会告诉你为什么这么做的意义。
- en: 'Let’s write a basic script to make an autoscaling group and put a threshold
    on it using a policy for CPU utilization. We’ll go step-by-step from the launch
    configuration to the autoscaling group to the rule by which the instances will
    autoscale:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个基本脚本，创建一个自动扩展组，并使用 CPU 利用率策略设置阈值。我们将从启动配置、自动扩展组到实例扩展的规则一步步来：
- en: 'First, we write the code to create a launch configuration that all machines
    in the autoscaling group will follow:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们编写代码，创建一个启动配置，所有自动扩展组中的机器都会遵循这个配置：
- en: '![Figure 4.11 – Code to create a launch configuration](img/B21320_04_11.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 创建启动配置的代码](img/B21320_04_11.jpg)'
- en: Figure 4.11 – Code to create a launch configuration
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 创建启动配置的代码
- en: 'Next, we create the autoscaling group, which uses the launch configuration
    that we created previously:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建自动伸缩组，该组使用我们之前创建的启动配置：
- en: '![Figure 4.12 – Code to create an autoscaling group](img/B21320_04_12.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 创建自动伸缩组的代码](img/B21320_04_12.jpg)'
- en: Figure 4.12 – Code to create an autoscaling group
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 创建自动伸缩组的代码
- en: 'Finally, we will create a policy that will scale the group upward if CPU utilization
    is greater than 70%:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个策略，如果CPU利用率超过70%，则向上扩展该组：
- en: '![Figure 4.13 – Code to create a scaling policy](img/B21320_04_13.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 创建伸缩策略的代码](img/B21320_04_13.jpg)'
- en: Figure 4.13 – Code to create a scaling policy
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 创建伸缩策略的代码
- en: Running all of these will give you a basic autoscaling group of virtual machines
    with these specifications. Now, you may be asking yourself where Python helps
    with this autoscaling. Well, for that, you first have to look at the metrics produced
    by these virtual machines.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些操作将为你提供一个具有这些规格的基本虚拟机自动伸缩组。现在，你可能会问，Python在这个自动伸缩中起什么作用。好吧，为此，你首先需要查看这些虚拟机生成的指标。
- en: 'If you look through the metrics that are produced by the VMs, you’ll be able
    to find their CPU utilization metrics, which can be exported. Using these metrics,
    you can calculate the average utilization of CPUs over a period of time (that
    programming language Python helps, I’m told), then use that data to find a better
    autoscaling target. To modify the target, you can simply use the same code as
    before with a different metric value:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看虚拟机生成的指标，你将能够找到它们的CPU利用率指标，并且这些指标可以被导出。利用这些指标，你可以计算一段时间内CPU的平均利用率（据说是编程语言Python帮助的），然后使用这些数据来找到更好的自动伸缩目标。要修改目标，你可以简单地使用与之前相同的代码，只需更改指标值：
- en: '![Figure 4.14 – Code for modified scaling policy](img/B21320_04_14.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 修改后的伸缩策略代码](img/B21320_04_14.jpg)'
- en: Figure 4.14 – Code for modified scaling policy
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 修改后的伸缩策略代码
- en: Your findings on the data may even reveal that there is a better metric to use
    for your workload than CPU utilization. You can modify that here as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你的数据分析结果甚至可能揭示出，比CPU利用率更适合你工作负载的指标。你也可以在这里修改它。
- en: This type of scaling is very useful and there are a lot of situations where
    you definitely will use these. However, this isn’t the only way to implement scaling
    and virtualization. In the next section, we will explore containers and their
    roles and purpose in the field of scaling and virtualization.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的伸缩非常有用，很多情况下你肯定会用到它们。然而，这并不是实现伸缩和虚拟化的唯一方式。在下一节中，我们将探讨容器及其在伸缩和虚拟化领域中的角色和目的。
- en: Containers and where Python fits in with containers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器以及Python在容器中的角色
- en: '**Containers** are small packages of software that serve as a unique runtime
    containing all of the necessary resources to run a small facet of an application,
    or sometimes the entire application itself.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**是小型的软件包，作为独特的运行时，包含运行应用程序某个小部分或有时整个应用程序所需的所有资源。'
- en: The containers themselves are written in Go, as is the container orchestration
    service, Kubernetes. Those parts do not require Python unless the application
    code itself is written in Python. Where Python comes in handy is as the glue between
    the various containerized services. Orchestrating the orchestration, if you will.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 容器本身是用Go语言编写的，容器编排服务Kubernetes也是如此。除非应用程序代码本身是用Python编写的，否则这些部分不需要Python。Python的作用是作为各种容器化服务之间的胶水。可以说，它是在编排中的编排。
- en: Now, we are going to learn about the role that Python plays in the overall container
    picture. Python, as always, has a lot of libraries that support the use of containers
    and Kubernetes, and we will explore some of these libraries and how using Python
    can simplify your DevOps work where these important infrastructural elements are
    concerned.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将了解Python在整个容器体系中的角色。Python，一如既往，拥有许多支持容器和Kubernetes使用的库，我们将探索其中一些库，以及如何利用Python简化与这些重要基础设施元素相关的DevOps工作。
- en: Simplifying Docker administration with Python
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python简化Docker管理
- en: 'Keeping Docker images together and organized is tricky. It’s why they invented
    Kubernetes. But Kubernetes itself is tricky. This leaves two gaps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 保持Docker镜像整齐有序是很有挑战的。这就是为什么他们发明了Kubernetes。但Kubernetes本身也很复杂。这留下了两个空白：
- en: First, when there are multiple Docker images but complete orchestration with
    Kubernetes is not required
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，当有多个Docker镜像，但不需要完全使用Kubernetes进行编排时
- en: Second, when Kubernetes APIs need to be frequently called or the cluster needs
    to be frequently updated
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，当Kubernetes API需要频繁调用或集群需要频繁更新时
- en: For both of these purposes, Python can be a useful tool. Remember this is about
    support, not refactoring. We’re the auxiliary player here.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种用途，Python都是一个有用的工具。记住，这只是辅助支持，而不是重构。我们是辅助角色。
- en: So, in this section, we will look at an example of how to use Python to administer
    multiple containers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在这一节中，我们将通过一个例子来展示如何使用Python管理多个容器。
- en: 'We will write a script to get a specific Docker image and create a container
    for it. This script can be rerun to do the same thing over and over again. You
    may also use the `restart` command if a container malfunctions. Now let’s look
    at the code to pull Docker images and start a container:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个脚本来获取特定的Docker镜像并为其创建一个容器。这个脚本可以重复运行，完成相同的操作。如果容器出现故障，你也可以使用`restart`命令。现在让我们看一下拉取Docker镜像并启动容器的代码：
- en: '![Figure 4.15 – Code to pull Docker images and start a container](img/B21320_04_15.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15 – 拉取Docker镜像并启动容器的代码](img/B21320_04_15.jpg)'
- en: Figure 4.15 – Code to pull Docker images and start a container
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 – 拉取Docker镜像并启动容器的代码
- en: It’s simple, but that’s the key to it. Its simplicity provides building blocks
    to improve upon.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但这正是关键所在。它的简洁性为进一步改进提供了基础。
- en: But even if we keep it simple, sometimes the use of containers gets complex,
    which is where Kubernetes comes in. With Kubernetes comes its own challenges.
    These challenges can also be simplified and managed using Python.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们保持简单，有时容器的使用也变得复杂，这就是Kubernetes发挥作用的地方。使用Kubernetes也会带来一些挑战，这些挑战可以通过Python进行简化和管理。
- en: Managing Kubernetes with Python
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Python管理Kubernetes
- en: There will come a time in your container usage when Kubernetes will be the way
    that you need to go. At this time, Python can help as well. Python can help simplify
    a lot of Kubernetes administration tasks and since most Kubernetes workloads are
    run on the cloud, those SDKs are going to come in pretty handy as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在你使用容器的过程中，总有一天Kubernetes会成为你需要的解决方案。这时，Python也能提供帮助。Python可以简化许多Kubernetes管理任务，而且由于大多数Kubernetes工作负载运行在云端，这些SDK也会非常有用。
- en: I’m only going to include one example, which will consist of the manipulation
    of Kubernetes namespaces. Just to be safe, we don’t want to crash and burn with
    computing resources yet, especially if you are new to Kubernetes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我只会提供一个例子，即操作Kubernetes命名空间。为了安全起见，我们不希望因为计算资源问题而崩溃，尤其是当你对Kubernetes还不熟悉时。
- en: '**Namespaces** are abstractions within a Kubernetes cluster that are used to
    divide computer resources based on certain criteria. A criterion can be environment
    (dev, production, etc.), network restrictions, or based on resource quotas available
    to a namespace.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间**是Kubernetes集群中的抽象，用于根据特定标准划分计算资源。标准可以是环境（开发、生产等）、网络限制，或基于可用的资源配额来定义命名空间。'
- en: 'You can use Python to create and modify namespaces and manipulate the resources
    within them. Let’s look at the steps to initialize a Kubernetes cluster and manage
    it using Python:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Python来创建和修改命名空间，并操作其中的资源。让我们来看一下初始化Kubernetes集群并使用Python管理它的步骤：
- en: 'First, you will need to install Kubernetes with `pip` using the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要通过以下命令使用`pip`安装Kubernetes：
- en: '[PRE0]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let’s write a script to create a few namespaces in our cluster. We can
    add resources to these namespaces later:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们写一个脚本，在我们的集群中创建几个命名空间。我们可以稍后为这些命名空间添加资源：
- en: '![Figure 4.16 – Code to create Kubernetes namespaces from a list](img/B21320_04_16.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图4.16 – 从列表创建Kubernetes命名空间的代码](img/B21320_04_16.jpg)'
- en: Figure 4.16 – Code to create Kubernetes namespaces from a list
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 – 从列表创建Kubernetes命名空间的代码
- en: 'Now, let’s write a policy for these namespaces and implement them into Kubernetes:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为这些命名空间写一个策略，并将其实施到Kubernetes中：
- en: '![Figure 4.17 – Creating a policy for namespaces for implementation](img/B21320_04_17.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图4.17 – 为命名空间创建实施策略](img/B21320_04_17.jpg)'
- en: Figure 4.17 – Creating a policy for namespaces for implementation
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 – 为命名空间创建实施策略
- en: This will create policies for both namespaces, which will block external traffic
    from outside the namespace. As you can see here, we’ve implemented the same formatted
    policy to both namespaces using an iterator. This is but one of the ways you can
    automate in Kubernetes using Python.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为两个命名空间创建策略，阻止来自命名空间外部的外部流量。正如你所看到的，我们使用迭代器对两个命名空间实施了相同格式的策略。这只是使用 Python
    在 Kubernetes 中进行自动化的众多方式之一。
- en: Eventually, you can automate these steps to the point where it will be possible
    for you to simply list out and visualize your Kubernetes cluster and press a couple
    of buttons to adjust it to your needs. Everything else, the cluster will take
    care of.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你可以将这些步骤自动化到一个程度，只需列出并可视化你的 Kubernetes 集群，按几个按钮就能根据需求调整。其他所有事情，集群将自动处理。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter sent us on quite a trip in terms of how we use Python. We figured
    out how SDKs work, what advantages they have, and why Python is so useful to have
    in the world of SDK use. You can literally build applications on top of applications,
    I’ve seen it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本章让我们在使用 Python 的过程中进行了相当一番探索。我们搞清楚了 SDK 如何工作，它们的优势是什么，以及为什么 Python 在 SDK 使用的世界里如此有用。你几乎可以在应用之上再构建应用，我亲眼见过。
- en: We also learned about scaling and how much of a hassle that is because of the
    balance you have to strike between availability and cost. Here, we also found
    use for Python and its great SDKs and data processing abilities, helping us strike
    that balance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了扩展性问题，以及如何因为需要在可用性和成本之间找到平衡而变得麻烦。这里，我们也发现了 Python 及其强大的 SDK 和数据处理能力的作用，帮助我们实现了这种平衡。
- en: Containers are also greatly supported by Python libraries, which can help act
    as a glue filler in the gaps between Docker and Kubernetes. We learned about the
    assisting role that Python plays in the management of these services.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 容器也得到了 Python 库的强力支持，这些库可以帮助填补 Docker 与 Kubernetes 之间的空白。我们了解了 Python 在管理这些服务中的辅助作用。
- en: So, in conclusion, in this chapter you have learned quite a bit about Python’s
    SDKs, using them for autoscaling, rightsizing, and containers. In the next chapter,
    we will take a closer look at how Python can be used to manipulate and interact
    with already provisioned resources.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总结来说，在这一章你学到了许多关于 Python SDK 的内容，包括如何使用它们进行自动扩展、调整大小以及管理容器。在下一章，我们将更详细地探讨如何使用
    Python 操控和与已经配置好的资源进行交互。
- en: 'Part 2: Sample Implementations of Python in DevOps'
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：Python 在 DevOps 中的示例实现
- en: This part will cover sample implementations for some common DevOps use cases
    using Python.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分将涵盖一些常见 DevOps 用例的 Python 示例实现。
- en: 'This part has the following chapters:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B21320_05.xhtml#_idTextAnchor099), *Manipulating Resources*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B21320_05.xhtml#_idTextAnchor099)，*资源操作*'
- en: '[*Chapter 6*](B21320_06.xhtml#_idTextAnchor129), *Security and DevSecOps with
    Python*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第六章*](B21320_06.xhtml#_idTextAnchor129)，*使用 Python 进行安全性与 DevSecOps*'
- en: '[*Chapter 7*](B21320_07.xhtml#_idTextAnchor142), *Automating Tasks*'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第七章*](B21320_07.xhtml#_idTextAnchor142)，*自动化任务*'
- en: '[*Chapter 8*](B21320_08.xhtml#_idTextAnchor155), *Understanding Event-Driven
    Architecture*'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第八章*](B21320_08.xhtml#_idTextAnchor155)，*理解事件驱动架构*'
- en: '[*Chapter 9*](B21320_09.xhtml#_idTextAnchor165), *Using Python for CI/CD Pipelines*'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第九章*](B21320_09.xhtml#_idTextAnchor165)，*使用 Python 进行 CI/CD 流水线*'
