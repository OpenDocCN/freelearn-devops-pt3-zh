- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Moving to Continuous Integration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转向持续集成
- en: After setting up source control for your organization and deciding on a branching
    and merging strategy that supports parallel work, you are ready to move on to
    continuous integration. Continuous integration is a method where every developer
    takes their work and integrates it with the work of others, and then verifies
    the quality of the combined work. The value of this is an increase in quality
    early on in the pipeline. This reduces the risk of error later on when merging
    code changes and reduces the number of bugs that are found in production, thereby
    reducing costs and protecting your reputation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在为你的组织设置了源代码管理并决定了支持并行工作的分支和合并策略后，你就可以继续进行持续集成了。持续集成是一种方法，每个开发人员将自己的工作与其他人的工作集成，然后验证组合后的工作质量。这样做的价值在于在管道早期提高质量。这减少了以后在合并代码更改时出现错误的风险，并减少了在生产中发现的缺陷数量，从而降低了成本并保护了你的声誉。
- en: Continuous integration is only possible when you have the proper setup with
    the necessary tools. In this chapter, you will learn how to use Azure DevOps pipelines
    to set up continuous integration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成只有在你具备必要的工具和适当的配置时才有可能实现。在本章中，你将学习如何使用 Azure DevOps 管道来设置持续集成。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introducing continuous integration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍持续集成
- en: Creating a build definition
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建构建定义
- en: Running a build
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行构建
- en: Working with YAML pipelines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 YAML 管道
- en: Agents and agent queues
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理和代理队列
- en: Automate **Continuous Integration** (**CI**) builds using GitHub Actions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 自动化**持续集成**（**CI**）构建
- en: Other tools
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他工具
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To go through the examples that are covered in this chapter, you will need
    the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章中涵盖的示例，你将需要以下内容：
- en: An Azure DevOps organization
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Azure DevOps 组织
- en: Git command-line tools
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 命令行工具
- en: A code editor such as Visual Studio Code
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代码编辑器，如 Visual Studio Code
- en: Introducing continuous integration
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍持续集成
- en: '**Continuous integration** is a methodology where you integrate your own changes
    with those of all of the other developers in your project and test whether the
    combined code still works as expected. This way, you create a fast loop that provides
    you with feedback on your work.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**是一种方法，你将自己的更改与项目中所有其他开发人员的更改集成，并测试组合后的代码是否仍按预期工作。通过这种方式，你创建了一个快速的反馈循环，能够为你的工作提供反馈。'
- en: When working with extensive branching strategies for isolating code changes,
    it is not uncommon for one or more developers to work for days, weeks, or even
    months on an isolated branch. While this is great for making sure that their changes
    do not disrupt others, continuous integration is a great way to make sure that
    there won’t be merge issues later. If you have ever had to merge weeks or months
    of work back into the main branch, you will know how much work is involved and
    how often this results in bugs or other issues.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理用于隔离代码更改的大规模分支策略时，开发人员可能会在一个孤立的分支上工作数天、数周甚至数月。这对于确保他们的更改不会干扰其他人是很有好处的，但持续集成是确保以后不会出现合并问题的好方法。如果你曾经需要将数周或数月的工作合并回主分支，你会知道这涉及多少工作，并且常常会导致错误或其他问题。
- en: To prevent this, developers should make it a habit to integrate their changes
    with those of all the other developers at least once a day. Here, integrating
    means at least merging, compiling, and running unit tests. This way, there is
    a constant stream of feedback on the quality of the developer’s changes, and since
    this feedback is combined, it is a great way to prevent merge issues later.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况，开发人员应养成每天至少一次将自己的更改与其他开发人员的更改集成的习惯。在这里，集成意味着至少合并、编译并运行单元测试。这样，开发人员的更改质量就会得到持续的反馈，并且由于这些反馈是综合的，它是防止以后出现合并问题的好方法。
- en: Continuous integration also enables you to embed other concerns in your pipeline
    to automatically preserve the quality of your code. Static code analysis, unit
    testing, and security scanning are three prime examples of this. These topics
    are discussed in later chapters, but a good continuous integration pipeline is
    the basis for these practices.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成还使你能够将其他关注点嵌入到管道中，以自动保持代码质量。静态代码分析、单元测试和安全扫描是三个典型的例子。这些主题将在后续章节中讨论，但一个好的持续集成管道是这些实践的基础。
- en: In the rest of this chapter, you will learn about the technical means to set
    up continuous integration using Azure Pipelines. But first, let’s look at a common
    misconception and the four pillars of continuous integration.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，你将了解如何使用 Azure Pipelines 设置持续集成的技术手段。但首先，让我们看一个常见的误解以及持续集成的四大支柱。
- en: Important Note
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While an automated continuous integration build is an important ingredient for
    performing continuous integration, continuous integration entails more than just
    having a build pipeline. The important thing to remember is that continuous integration
    is a process where every developer integrates their work with that of their colleagues
    at least daily. Then, the integrated sources are compiled and tested. The value
    comes from compiling and testing the integrated work, not the isolated work.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动化的持续集成构建是执行持续集成的重要组成部分，但持续集成不仅仅是拥有一个构建管道。需要记住的关键点是，持续集成是一个过程，每个开发者至少每天都会将自己的工作与同事的工作进行整合。然后，整合后的源代码会被编译并进行测试。其价值在于编译和测试整合后的工作，而非孤立的工作。
- en: The four pillars of continuous integration
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成的四大支柱
- en: 'There are four pillars that underpin the successful adoption of continuous
    integration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个支柱支撑着持续集成的成功实施：
- en: '**A version control system**: Used for storing all of the changes made to a
    system since its inception. Version control systems were discussed in the previous
    chapter.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制系统**：用于存储自系统创建以来所做的所有更改。版本控制系统在上一章中已讨论。'
- en: '**A package management system**: Used to store the binary packages that you
    use in your own application and the packages that you create. This will be discussed
    in detail in [*Chapter 7*](B18655_07.xhtml#_idTextAnchor453), *Dependency Management*.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包管理系统**：用于存储你在自己应用中使用的二进制包以及你创建的包。这将在 [*第7章*](B18655_07.xhtml#_idTextAnchor453)
    中详细讨论，*依赖管理*。'
- en: '**A continuous integration system**: A system that can pull the changes of
    all developers together – several times a day – and create one integrated source
    version. This can be done using Azure DevOps pipelines.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成系统**：一个可以将所有开发者的更改汇总在一起——一天多次——并创建一个集成的源版本的系统。这可以通过 Azure DevOps 管道来实现。'
- en: '**An automated build process**: Used to compile and test the combined sources.
    We will look at how to implement this process using Azure DevOps pipelines.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化构建过程**：用于编译和测试合并后的源代码。我们将探讨如何使用 Azure DevOps 管道实现这一过程。'
- en: Continuous integration and automated builds can be set up in Azure DevOps. The
    next section explains how to set both up in Azure DevOps.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 Azure DevOps 中设置持续集成和自动化构建。下一节将解释如何在 Azure DevOps 中设置这两者。
- en: Creating a build definition in Azure DevOps
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中创建构建定义
- en: 'The main way to perform continuous integration is by using a continuous integration
    build. In Azure DevOps, builds can be configured as part of the Azure Pipelines
    offering. There are currently two approaches available for creating a build definition:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 执行持续集成的主要方法是使用持续集成构建。在 Azure DevOps 中，构建可以作为 Azure Pipelines 的一部分进行配置。目前，创建构建定义有两种方法：
- en: Via the visual designer (also called **classic builds and releases**)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过可视化设计器（也称为**经典构建和发布**）
- en: Through **Yet Another Markup Language** (**YAML**) files (also called YAML pipelines
    or multistage pipelines)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 **另一种标记语言** (**YAML**) 文件（也称为 YAML 管道或多阶段管道）
- en: The rest of this section will focus on the visual designer. The following section,
    *YAML build definitions*, will go into more detail about YAML pipelines. Both
    approaches support roughly the same capabilities, although there are some differences.
    Some features that are available in classic builds and releases are not (yet)
    available in YAML build definitions. Also, some new features are only provided
    to YAML pipelines.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分将重点讲解可视化设计器。接下来的部分，*YAML 构建定义*，将详细介绍 YAML 管道。两种方法大致支持相同的功能，尽管也有一些差异。某些在经典构建和发布中可用的功能在
    YAML 构建定义中尚不可用。此外，只有 YAML 管道才提供某些新功能。
- en: If you have no experience with pipelines, the classic editor is a good way to
    get familiar with the workings of continuous integration/continuous development
    pipelines before moving on to YAML pipelines. Almost all of the concepts in classic
    builds translate to YAML builds as well.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有管道经验，经典编辑器是一个很好的方式，可以在转向 YAML 管道之前，先熟悉持续集成/持续开发管道的工作原理。经典构建中的几乎所有概念都可以转化为
    YAML 构建。
- en: In the following sections, we will start by building a classic build pipeline.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的各节中，我们将从构建一个经典的构建管道开始。
- en: Connecting to source control
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到源代码管理
- en: 'To get started with a build definition, follow these simple steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始创建构建定义，请按照以下简单步骤操作：
- en: Open the **Pipelines** menu.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**管道**菜单。
- en: 'From this menu, click on **Builds**. Here, you will be presented with a button
    to create a new build. After clicking on this button, a new view for creating
    a build will open, as shown in the following screenshot:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此菜单中，点击**构建**。在这里，您将看到一个按钮，用于创建新的构建。点击此按钮后，将打开一个新的视图，用于创建构建，如下图所示：
- en: '![Figure 5.1 – Source code repository options for pipelines  ](img/B18655_05_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 用于管道的源代码仓库选项](img/B18655_05_01.jpg)'
- en: Figure 5.1 – Source code repository options for pipelines
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 用于管道的源代码仓库选项
- en: You will then be guided to the new YAML experience, but you can still opt to
    go back by choosing the classic editor.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将被引导到新的 YAML 体验，但您仍然可以选择通过选择经典编辑器返回。
- en: After choosing the classic editor, you can configure how to connect to the source
    control. The classical editor is the editor that is visible in all of the screenshots
    in the following sections.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 选择经典编辑器后，您可以配置如何连接到源代码管理。经典编辑器是在以下各节的所有截图中可见的编辑器。
- en: Many source control systems are supported. If you are working with a hosted
    Git repository, pick your specific product, if available, and only choose **Other
    Git** if your product is not available; currently, **GitHub**, **GitHub Enterprise
    Server**, and **Bitbucket Cloud** are supported. The reason for this is that continuous
    integration using **Other Git** works by using a polling model, where all the
    specific products use their known integration Webhooks. The following example
    works with a Git repository that is in the same Azure DevOps organization.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 支持多种源代码管理系统。如果您正在使用托管的 Git 仓库，请选择您的具体产品（如果有的话），如果没有可用的产品，则选择**其他 Git**；目前，支持**GitHub**、**GitHub
    企业服务器**和**Bitbucket Cloud**。这样做的原因是，使用**其他 Git**进行持续集成是通过轮询模型来工作的，所有具体产品使用它们已知的集成
    Webhooks。以下示例适用于位于同一 Azure DevOps 组织中的 Git 仓库。
- en: When you select the **Pipeline** header, you can set the name of the build definition
    and select an agent pool that the phases will run on by default. Agents take care
    of the actual execution of your tasks and will be looked at in more detail in
    the *Agents and agent queues* section of this chapter.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当您选择**管道**标题时，您可以设置构建定义的名称，并选择作业阶段将默认运行的代理池。代理负责实际执行您的任务，关于代理的更多细节将在本章的*代理与代理队列*部分中介绍。
- en: Below the **Pipeline** header, you can see the chronological layout of your
    build definition. First up is downloading sources. Here, you can once again choose
    to connect to a source control system. You can also specify more advanced settings
    that relate to the way sources are fetched, such as whether to clean the build
    directory first, select a branch, or add tags.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在**管道**标题下，您可以看到构建定义的时间轴布局。首先是下载源代码。在这里，您可以再次选择连接到源代码管理系统。您还可以指定更多与获取源代码相关的高级设置，如是否先清理构建目录、选择一个分支或添加标签。
- en: Configuring a job
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置作业
- en: 'Below the source’s node, you can add one or more jobs that will perform the
    bulk of the work that you want to perform. Jobs can be added using the ellipsis
    on the **Pipeline** header. There are two types of jobs available:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在源节点下，您可以添加一个或多个作业来执行您希望执行的大部分工作。可以通过点击**管道**标题上的省略号来添加作业。这里有两种类型的作业：
- en: '**Agentless jobs**: Agentless jobs can be used to run tasks that do not require
    an agent. They are run on Azure DevOps Server.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无代理作业**：无代理作业可以用于运行不需要代理的任务。这些任务在 Azure DevOps 服务器上运行。'
- en: '**Agent jobs**: Agent jobs are used to run tasks that require an agent to run
    on, which is the case for the bulk of the tasks.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理作业**：代理作业用于运行需要代理的任务，绝大多数任务都需要代理来运行。'
- en: 'Some examples of agentless tasks are as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一些无代理任务的示例如下：
- en: Waiting for manual approval before continuing
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待手动批准后继续
- en: Inserting a delay before proceeding
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继续之前插入延迟
- en: Calling a REST API
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 REST API
- en: Calling an Azure function
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 Azure 函数
- en: The main benefit of an agentless job is that it does not keep an agent occupied
    while running. This frees the agent up to do other work, meaning that you need
    fewer agents, which can save costs. Also, the number of agents that you can use
    concurrently is governed by the number of parallel pipelines that you have bought
    in Azure DevOps. Limiting the number of agent jobs will save money here as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 无代理作业的主要优点是它在运行时不会占用代理。这使得代理可以做其他工作，意味着您需要更少的代理，从而节省成本。此外，您可以并行使用的代理数量受限于您在
    Azure DevOps 中购买的并行管道数量。限制代理作业的数量也可以在这里节省费用。
- en: 'Let’s go over the process of configuring a job:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回顾一下配置作业的过程：
- en: 'Select any job. You will see the view shown in the following screenshot. In
    this view, you can change the name of the job and, for agent jobs, override the
    agent pool to execute this job on:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何作业。您将看到以下截图中显示的视图。在此视图中，您可以更改作业的名称，对于代理作业，可以覆盖执行此作业的代理池：
- en: '![Figure 5.2 – Add/update jobs for the pipeline ](img/B18655_05_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 为管道添加/更新作业](img/B18655_05_02.jpg)'
- en: Figure 5.2 – Add/update jobs for the pipeline
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 为管道添加/更新作业
- en: Next, specify which agent pool to use for running the job. Here, it also specifies
    the demands that you have of the agent that will execute this job. Demands will
    be discussed in the *Agents and agent queues* section of this chapter.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，指定用于执行作业的代理池。在这里，还指定了您对执行此作业的代理的需求。需求将在本章的*代理和代理队列*部分中讨论。
- en: 'As part of the execution plan for an agent, you can specify **Parallelism**
    and choose one of three options:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为代理执行计划的一部分，您可以指定**并行性**并选择以下三种选项之一：
- en: '**None**: This will just execute all the tasks you add to the agent job one
    after another on the same agent.'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：这将仅在同一代理上依次执行您添加到代理作业中的所有任务。'
- en: '**Multi-configuration**: Here, you can specify a series of variables that determine
    the number of variations of the build to run. This is useful if you want to create,
    for example, x86 and x64 builds from the same code.'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多配置**：在这里，您可以指定一系列变量，这些变量决定要运行的构建的变体数量。如果您想从同一代码创建例如x86和x64构建，这会非常有用。'
- en: '**Multi-agent**: Here, you can specify the number of agents that will run the
    same tasks in parallel.'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多代理**：在这里，您可以指定将并行运行相同任务的代理数量。'
- en: Next, you can specify one or more dependencies. These are the other jobs that
    need to be completed before the selected job runs.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以指定一个或多个依赖项。这些是需要在所选作业运行之前完成的其他作业。
- en: Also, for any job, you can specify how to cope with errors in previous jobs
    by telling it to continue or stop.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，对于任何作业，您可以通过告诉它继续或停止，来指定如何处理前一个作业中的错误。
- en: 'As an alternative to *step 3* and *step 4*, you can also specify a custom expression
    to specify whether a job should run. This expression should evaluate to a Boolean
    and support rudimentary operations, such as `or()`, `and()`, or `eq()`. The following
    is an example condition:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为*步骤 3*和*步骤 4*的替代方法，您还可以指定一个自定义表达式来确定是否应执行某个作业。此表达式应评估为布尔值，并支持基本操作，如`or()`、`and()`或`eq()`。以下是一个示例条件：
- en: '[PRE0]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This condition specifies that the job will only run when all previous jobs have
    succeeded and the build is not started from the main branch. A link to a detailed
    description of the conditions syntax is included at the end of this chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件指定，只有当所有前置作业成功并且构建未从主分支启动时，作业才会运行。本章末尾附有条件语法的详细描述链接。
- en: Agentless jobs have fewer options available than agent jobs. For example, it
    is not possible to execute the same build for multiple variable values in parallel.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 无代理作业比代理作业可用的选项更少。例如，无法为多个变量值并行执行相同的构建。
- en: Adding tasks to your job
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向作业添加任务
- en: 'After adding one or more jobs, you can add tasks to a job. Tasks define the
    actual work that is to be done during the execution of your build. The following
    screenshot shows you how to add a task and then configure it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个或多个作业后，您可以向作业添加任务。任务定义了在构建执行过程中需要完成的实际工作。以下截图展示了如何添加任务并进行配置：
- en: 'Click on the plus sign next to the job you want to add tasks to:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击您想要添加任务的作业旁边的加号：
- en: '![Figure 5.3 – Select a task and specify the configuration parameters for the
    job ](img/B18655_05_03.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 选择任务并指定作业的配置参数](img/B18655_05_03.jpg)'
- en: Figure 5.3 – Select a task and specify the configuration parameters for the
    job
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 选择任务并指定作业的配置参数
- en: You will then be presented with a task picker, where you can find any task that
    matches your search input and add one or more tasks by clicking the **Add** button.
    A new screen will then open, where you can configure the individual task. The
    options provided here differ for each task.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将看到一个任务选择器，您可以在其中找到与您的搜索输入匹配的任何任务，并通过点击**添加**按钮添加一个或多个任务。接着会打开一个新屏幕，您可以在其中配置单个任务。此处提供的选项对于每个任务有所不同。
- en: There can be multiple versions of a task, and you can switch between the major
    versions of it. This means that the maintainer can push non-breaking updates and
    you will receive them automatically. Major or breaking updates can be pushed with
    a new major version number, and you can upgrade them at your own discretion.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个任务可能有多个版本，您可以在其主要版本之间切换。这意味着维护者可以推送不破坏兼容性的更新，您会自动接收这些更新。重大或破坏性更新可以通过新的主要版本号推送，您可以根据自己的需要进行升级。
- en: It is possible to add as many tasks as needed to a pipeline job.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据需要向管道作业中添加任意数量的任务。
- en: Publishing build artifacts
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布构建工件
- en: An important part of a build definition is its outcomes. Builds are often used
    to produce one or more artifacts that are later used for the deployment of an
    application. Examples of artifacts can be executables or installer files. These
    files need to be made available for use after the execution of the build pipeline
    has beencompleted.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构建定义的重要部分是其输出。构建通常用于生成一个或多个工件，这些工件稍后会用于应用程序的部署。工件的示例包括可执行文件或安装程序文件。这些文件需要在构建管道执行完成后提供以供使用。
- en: The **Publish Build Artifacts** task that is shown in the preceding screenshot
    is a task that is specifically designed to do this. It allows you to select a
    file or directory and publish it under an **artifact name**. The result of this
    is that the file(s) in the selected path are retained with every execution of
    the pipeline for manual download or use in a release definition later. Release
    definitions will be discussed in [*Chapter 6*](B18655_06.xhtml#_idTextAnchor330),
    *Implementing Continuous Deployment and Release Management*.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面截图中显示的**发布构建工件**任务是专门设计用于此目的的任务。它允许您选择一个文件或目录，并以**工件名称**发布它。这样，选定路径中的文件会在每次管道执行时保留，以便稍后手动下载或在发布定义中使用。发布定义将在[*第
    6 章*](B18655_06.xhtml#_idTextAnchor330)中讨论，*实现持续部署和发布管理*。
- en: Next, we’ll learn how to integrate our pipeline with other tools and configure
    our service connection.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何将我们的管道与其他工具集成，并配置我们的服务连接。
- en: Calling other tools
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用其他工具
- en: When building pipelines, we will often need to integrate them with other tools.
    For source control systems, this is part of the flow when creating a pipeline
    and you are limited to the built-in options. For tasks, you can create references
    to any tool or location you want using service connections. An example of a task
    that uses a service connection to an Azure app service is shown in the following
    section.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建管道时，我们通常需要将其与其他工具集成。对于源代码控制系统，这是创建管道时的一个环节，您仅限于使用内置选项。对于任务，您可以使用服务连接创建对任何工具或位置的引用。以下部分展示了一个使用指向
    Azure 应用服务的服务连接的任务示例。
- en: 'A service connection is a pointer to an external system, with a name and series
    of properties that differ for each type of service connection. Often, you will
    need to put in a URL to locate the other service and a mechanism for authentication.
    The following steps will help you configure your service connection:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 服务连接是指向外部系统的指针，具有名称和一系列属性，针对每种类型的服务连接有所不同。通常，您需要提供一个 URL 来定位其他服务，并提供一个认证机制。以下步骤将帮助您配置您的服务连接：
- en: 'After defining one or more service connections, you can select the one to use
    from a drop-down menu:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义一个或多个服务连接后，您可以从下拉菜单中选择要使用的服务连接：
- en: '![Figure 5.4 – Use the service connection in the task ](img/B18655_05_04.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 在任务中使用服务连接](img/B18655_05_04.jpg)'
- en: Figure 5.4 – Use the service connection in the task
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 在任务中使用服务连接
- en: 'Service connections are managed in a central location as project settings.
    You can access them by going to the management view directly from the task you
    are currently configuring, as shown in the preceding screenshot. You can also
    do this by navigating to **Project Settings** and then to **Service connections**,
    as in the following screenshot (see **2**):'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务连接在一个中央位置作为项目设置进行管理。你可以通过从当前配置的任务中直接访问管理视图来访问它们，如前面的截图所示。你也可以通过导航到**项目设置**，然后转到**服务连接**来访问，如下图所示（参见**2**）：
- en: '![Figure 5.5 – Service connection dialog ](img/B18655_05_05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 服务连接对话框](img/B18655_05_05.jpg)'
- en: Figure 5.5 – Service connection dialog
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 服务连接对话框
- en: In this view, you can then either add a new service connection or update an
    existing service connection (see **2** and **3** in the preceding screenshot).
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此视图中，你可以选择添加一个新的服务连接或更新现有的服务连接（参见前面截图中的**2**和**3**）。
- en: By default, service connections are scoped to the project level, meaning they
    are not available for everyone in the Azure DevOps organization. To encourage
    the reuse of service connections, Azure has made it possible to share them between
    projects since mid-2019.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，服务连接的作用域是项目级别，这意味着它们并非对所有 Azure DevOps 组织中的人都可用。为了鼓励服务连接的重用，Azure 自 2019
    年中期以来已经实现了在项目之间共享服务连接的功能。
- en: Task Marketplace
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务市场
- en: A set of frequently used tasks is built into Azure Pipelines; however, there
    are even more available using the Visual Studio Marketplace for Azure DevOps.
    If you are an administrator of the DevOps organization, you can find and install
    extensions that add tasks here. If you are a regular user, you can find tasks
    here as well; however, you cannot install them, only request them. Your Azure
    DevOps administrator will then be notified and can install the extension on your
    behalf if they approve.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Pipelines 内置了一组常用的任务；然而，使用 Azure DevOps 的 Visual Studio 市场，你还可以找到更多的任务。如果你是
    DevOps 组织的管理员，你可以在此找到并安装添加任务的扩展。如果你是普通用户，你也可以在此找到任务；但是，你无法安装它们，只能请求它们。你的 Azure
    DevOps 管理员会收到通知，并在他们批准后代表你安装扩展。
- en: Of course, you can write and distribute extensions with tasks of your own as
    well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你也可以编写并分发带有你自己任务的扩展。
- en: Creating variables and variable groups
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建变量和变量组
- en: When you are configuring your build, there might be values that you need to
    use more than once. It is often wise to extract these values into variables, rather
    than just repeating them throughout your tasks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置构建时，可能会有一些值需要多次使用。通常，提取这些值为变量，而不是在任务中重复使用它们，是明智的做法。
- en: Variables can be used to note down values that you do not want to have stored
    in source control. Values such as passwords and license keys can be safely stored
    as non-retrievable values when locked down using the lock symbol (see **1** in
    the following screenshot). After saving the build definition, these values are
    encrypted and can only be used by the build that they belong to.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可用于记录那些你不希望存储在源代码控制中的值。例如，密码和许可证密钥可以安全地作为不可检索的值存储，当它们被锁定（参见下图中的**1**）时。保存构建定义后，这些值将被加密，并且只能被属于它们的构建使用。
- en: 'To learn how to work with variables in Azure Pipelines, go through the following
    steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何在 Azure Pipelines 中使用变量，请按照以下步骤操作：
- en: 'In Azure Pipelines, you can add variables to your build definition by going
    to the **Variables** | **Pipeline variables** tab (see **3** in the following
    screenshot). Here, you can enter them as name values, as can be seen in the following
    screenshot:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Azure Pipelines 中，你可以通过转到**变量** | **管道变量**选项卡（参见下图中的**3**）来将变量添加到你的构建定义中。在这里，你可以输入变量的名称和值，如下图所示：
- en: '![Figure 5.6 – Pipeline variables  ](img/B18655_05_06.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 管道变量](img/B18655_05_06.jpg)'
- en: Figure 5.6 – Pipeline variables
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 管道变量
- en: 'Once defined, you can use the variables in the configuration of all tasks in
    all jobs of the same build. For this, you can use the following notation:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦定义，你就可以在同一构建的所有任务配置中使用这些变量。为此，你可以使用以下表示法：
- en: '[PRE1]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, you can mark variables as `system.debug` built-in variable. When this
    variable is set to `true`, there is a verbose debug logging included in the build.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以将变量标记为`system.debug`内置变量。当此变量设置为`true`时，构建中将包含详细的调试日志。
- en: Next to your own variables, system variables are also defined. These are variables
    that contain information about the build that is currently running, including
    version numbers, agent names, build definition details, and the source version.
    A link to the full list of system-defined variables is included at the end of
    this chapter.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你自己的变量外，系统变量也会被定义。这些是包含当前正在运行的构建的相关信息的变量，包括版本号、代理名称、构建定义详情和源版本。系统定义变量的完整列表链接将会在本章末尾提供。
- en: Variable groups
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量组
- en: 'As well as creating the variables that go with a specific build, you can create
    variable groups. These variable groups can, in turn, be linked to one or more
    builds. This is an effective way of sharing variables between builds; some examples
    of these might be the name of your company, trademark texts, and product names.
    Let’s see how we can work with variable groups:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为特定构建创建变量外，你还可以创建变量组。这些变量组可以与一个或多个构建关联。这是一种有效的在构建之间共享变量的方式；一些例子可能包括你的公司名称、商标文本和产品名称。我们来看看如何使用变量组：
- en: 'Access variable groups through the menu by clicking on **Library** in the **Pipelines**
    menu (see **1** in the following screenshot). This displays a list of the existing
    variable groups that you can edit, and you can add a new group here as well, as
    shown in the following screenshot:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**库**（**Library**）在**管道**（**Pipelines**）菜单中，你可以通过菜单访问变量组（参见下图中的**1**）。这将显示你可以编辑的现有变量组列表，同时你也可以在这里添加一个新的变量组，如下图所示：
- en: '![Figure 5.7 – A new variable group  ](img/B18655_05_07.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 新的变量组](img/B18655_05_07.jpg)'
- en: Figure 5.7 – A new variable group
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 新的变量组
- en: 'Here, you can work with variables in the same way that you would with the variables
    that come with a build. The only differences are highlighted in the following
    list:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以像使用构建自带的变量一样使用变量。唯一的区别在于以下列表中突出显示的内容：
- en: You cannot mark variables in a group as settable at queue time.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能将变量标记为在队列时可设置。
- en: You can allow or deny the use of this group in all pipelines. If you deny their
    use in all pipelines, then only you can use the variable group. You can authorize
    other users or groups through the **Security** option (see **2** in the preceding
    screenshot).
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以允许或拒绝在所有管道中使用该组。如果你拒绝在所有管道中使用它，那么只有你可以使用该变量组。你可以通过**安全性**（**Security**）选项授权其他用户或组（参见前述截图中的**2**）。
- en: You can reference an Azure key vault for which this variable group will act
    as a placeholder. After logging into Azure, you can select a key vault and which
    values that are stored in the key vault you want to be accessible through the
    variable group.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以引用一个 Azure 密钥保管库，该变量组将作为一个占位符。在登录到 Azure 后，你可以选择一个密钥保管库，并指定希望通过变量组访问的存储在密钥保管库中的值。
- en: '**Azure Key Vault** is an Azure offering that can be used for the secure storage
    of secrets. Secrets in a key vault are automatically versioned, so older values
    are not overwritten but replaced by a newer version. In addition to this, you
    can specify segregated access policies that specify, per user, whether they can
    read, write, update, or delete values. All these actions are audited in a key
    vault, so you can also find who has made which change. If you are linking Azure
    DevOps to a key vault, then a new service principal will be created in your active
    directory that has access to that key vault. Now, whenever Azure DevOps needs
    a variable from the variable group, the actual values will be pulled from the
    key vault.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure 密钥保管库**（**Azure Key Vault**）是 Azure 提供的一项服务，可用于安全存储密钥。密钥保管库中的机密会自动进行版本控制，因此旧的值不会被覆盖，而是被新版本替代。此外，你可以指定分隔的访问策略，按用户指定他们是否可以读取、写入、更新或删除值。所有这些操作都会在密钥保管库中进行审计，因此你也可以追溯到谁进行了哪些更改。如果你将
    Azure DevOps 与密钥保管库链接，则将在你的活动目录中创建一个具有该密钥保管库访问权限的新服务主体。现在，每当 Azure DevOps 需要从变量组中提取变量时，实际的值将从密钥保管库中提取。'
- en: Variable groups can be linked to the variables of a build under the **Variable
    group** tab (refer to the screenshot in *Figure 5.7*).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 变量组可以通过**变量组**标签与构建的变量关联（参见*图 5.7*中的截图）。
- en: 'As well as working with variable groups, you can also work with files in the
    library. You can upload files that are not accessible by other users but that
    can be used within a build. This is useful for files with private keys, license
    keys, and other secrets. Refer to this link for more information: [https://docs.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了与变量组一起工作外，你还可以与库中的文件一起工作。你可以上传其他用户无法访问的文件，但这些文件可以在构建中使用。这对于包含私钥、许可证密钥和其他机密的文件很有用。欲了解更多信息，请参阅此链接：[https://docs.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops)。
- en: Just as you can with variable groups, you can specify whether each secure file
    can be used by any build or authorize specific users only.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量组一样，你可以指定每个安全文件是否可以被任何构建使用，或仅授权特定用户使用。
- en: Triggering the build
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发构建
- en: 'The next tab in a build definition governs what should start or trigger the
    build. To implement continuous integration, go through the following steps:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 构建定义中的下一个标签控制着应该启动或触发构建的内容。要实现持续集成，请按照以下步骤操作：
- en: 'Click on the **Triggers** tab and select the first header on the left:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**触发器**标签页，选择左侧的第一个标题：
- en: '![Figure 5.8 – Defining triggers for the pipeline ](img/B18655_05_08.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 为管道定义触发器 ](img/B18655_05_08.jpg)'
- en: Figure 5.8 – Defining triggers for the pipeline
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 为管道定义触发器
- en: Check the **Enable continuous integration** box. This means that Azure DevOps
    will track for changes in your repository and queue a new build as soon as a new
    chance is available.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选**启用持续集成**框。这意味着 Azure DevOps 将监视你仓库中的变化，并在有新的变更时立即排队新的构建。
- en: Next, you can choose whether you want to build every incoming change individually
    or batch multiple changes when more than one new change comes in while building
    a change. It is recommended that you build every single change separately if this
    is feasible.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以选择是希望单独构建每个传入的更改，还是在构建某个更改时将多个更改批量处理。如果可行，建议每次都单独构建每个更改。
- en: Along with the continuous integration trigger, specify one or more branch and
    path filters. Here, you can specify which branches and files to queue a new build
    for. You can specify either inclusions or exclusions, depending on your needs.
    A common example is to limit your build to the main branch. If you have folders
    named `doc` and `src` in your repository and all your sources are in the latter
    folder, then it might make sense to limit the trigger to this path.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了持续集成触发器外，还需要指定一个或多个分支和路径过滤器。在这里，你可以指定哪些分支和文件需要排队新构建。你可以根据需要指定包括或排除某些内容。一个常见的例子是将构建限制在主分支。如果你的仓库中有名为`doc`和`src`的文件夹，且所有源代码都在后者文件夹中，那么限制触发器仅适用于该路径可能更为合适。
- en: As well as choosing to have a continuous integration trigger, you can also opt
    to execute a build on a recurring schedule where you select one or more weekdays
    and a time.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了选择持续集成触发器外，你还可以选择按计划定期执行构建，选择一个或多个工作日和时间。
- en: You can also schedule a build to run whenever another build completes. This
    is called **chaining** builds.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以安排在另一个构建完成时启动构建。这被称为**链式构建**。
- en: Next, let’s learn how to change the configurations of our build definition.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何更改构建定义的配置。
- en: Build options
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建选项
- en: 'You can change the advanced configuration options for your build definition.
    These options include a description, the format of the build number, and the automated
    creation of work items on failures and times. To set this up, go through the following
    steps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以更改构建定义的高级配置选项。这些选项包括描述、构建编号的格式，以及在失败或超时时自动创建工作项。要进行设置，请按照以下步骤操作：
- en: 'Click on the **Options** tab. You should arrive at the following screen:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**选项**标签页。你应该会看到以下界面：
- en: '![Figure 5.9 – Build options ](img/B18655_05_09.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 构建选项 ](img/B18655_05_09.jpg)'
- en: Figure 5.9 – Build options
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.9 – 构建选项
- en: 'Now, create your build number format. If this field is left empty, then the
    build number for your application will be set to an ever-increasing number that
    will increase by one with every build. This number is unique within a team project
    and counts over all the build definitions. You can also specify a format of your
    own using the variables available to you. A common approach is to specify a major
    and minor version number manually and then add an increasing number using a variable.
    The following example specifies a version of 4.1.xx, where the last part is replaced
    by a two-digit increasing number:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建您的构建号格式。如果该字段为空，则您的应用程序的构建号将设为一个不断增加的数字，每次构建都会增加 1。该数字在团队项目中是唯一的，并且跨所有构建定义进行计数。您也可以使用可用的变量来指定您自己的格式。一种常见的方法是手动指定一个主版本号和次版本号，然后使用变量添加一个递增的数字。以下示例指定了版本号为
    4.1.xx，其中最后部分会被一个两位数递增的数字替代：
- en: '[PRE2]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the right, there are advanced (but rarely used) options for specifying the
    authorization scope for the **Build job** timeouts for each job in the build definition.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右侧有一些高级（但很少使用）选项，用于指定**构建作业**超时的授权范围，适用于构建定义中的每个作业。
- en: It is also possible to specify the agent demands that every agent, for every
    job in the build definition, should fulfill. Again, we will look further at demands
    in the *Agents and agent queues* section of this chapter.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以指定代理需求，要求每个代理在构建定义中的每个作业中都必须满足这些需求。我们将在本章的*代理与代理队列*部分进一步探讨需求。
- en: Other options on the left enable you to suspend the pipeline temporarily.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的其他选项允许您暂时暂停管道。
- en: Build history
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建历史
- en: The final tab, called **History**, shows you a list of every change that has
    been made to the build definition. Build definitions are stored in JSON format,
    and you can pull up side-by-side comparisons for every change. The comment that
    you put in when saving a build is also stored here and can be used to provide
    the rationale for a change. You can revert to an older version of the pipeline
    as well.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一页标签，称为**历史记录**，显示了构建定义中每一次更改的列表。构建定义以 JSON 格式存储，您可以查看每次更改的并排对比。您在保存构建时所输入的评论也会存储在这里，并可以用来提供更改的理由。您还可以恢复到管道的旧版本。
- en: Since builds are an important means of preserving quality, it is important to
    keep track of who has changed them to ensure that automated quality metrics are
    not removed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构建是保持质量的重要手段，因此跟踪是谁更改了它们非常重要，以确保自动化质量度量不会被删除。
- en: With this, you are now ready to run your first build. You can directly run it
    using the **Save & queue** button that is visible in most of the screenshots in
    this section. The *Running a build* section of this chapter will teach you how
    to work with the results that you obtain.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，您现在可以运行您的第一个构建。您可以直接使用在本节大多数截图中可见的**保存并排队**按钮来运行它。本章的*运行构建*部分将教您如何处理您获得的结果。
- en: Task groups
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务组
- en: When working in a team or organization that has more than one pipeline, it often
    doesn’t take long before multiple pipelines that have the same shape emerge. For
    example, in some companies, all pipelines contain tasks for security scanning,
    running tests, and calculating the test coverage.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个拥有多个管道的团队或组织中，往往不会过多久就会出现多个形态相同的管道。例如，在一些公司中，所有管道都包含安全扫描、运行测试和计算测试覆盖率的任务。
- en: Instead of repeating these tasks everywhere, they can be extracted from an existing
    pipeline into a task group. Task groups, in turn, can be used within multiple
    pipelines as if they are tasks themselves. Doing this reduces the effort needed
    to create a new pipeline or update all the pipelines with a new requirement. Doing
    this also ensures that all the pipelines using the task group have the same task
    configuration.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与其在各处重复这些任务，不如将它们从现有的管道中提取到一个任务组中。任务组可以像任务一样在多个管道中使用。这样做可以减少创建新管道或更新所有管道时的工作量。同时，这也确保了所有使用任务组的管道具有相同的任务配置。
- en: 'To create a new task group, open any existing build definition and go through
    the following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的任务组，请打开任何现有的构建定义并按照以下步骤操作：
- en: 'Select one or more tasks by clicking on them while holding down *Ctrl*, or
    by using the selectors that appear when hovering the mouse over a task:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住 *Ctrl* 键并单击一个或多个任务，或者使用鼠标悬停在任务上时出现的选择器来选择任务：
- en: '![Figure 5.10 – Creating a task group ](img/B18655_05_10.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 创建任务组](img/B18655_05_10.jpg)'
- en: Figure 5.10 – Creating a task group
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.10 – 创建任务组
- en: Right-click on the selection and select **Create task group**.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击选项并选择**创建任务组**。
- en: In the popup that now appears (not shown in the screenshot), choose a name,
    description, and category for the task group. If any of the selected tasks have
    a variable value specified, you can now provide a default value and description
    for these parameters. These parameters will be available within the task group
    and need to be configured when the task group is used.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现在出现的弹窗中（截图未显示），为任务组选择一个名称、描述和类别。如果选定的任务中有指定变量值的任务，你现在可以为这些参数提供默认值和描述。这些参数将在任务组中使用，并且在使用任务组时需要进行配置。
- en: After clicking **Create** (not shown in the screenshot), the existing build
    definition is updated by removing the selected tasks and replacing them with the
    new task group.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击**创建**后（截图未显示），现有的构建定义将通过移除选定的任务并用新的任务组替换它们来进行更新。
- en: Adding an already existing task group to a build or release definition is done
    in precisely the same way as adding regular tasks. Task groups show up in the
    same list of tasks to choose from.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将已有任务组添加到构建或发布定义中的方式与添加常规任务完全相同。任务组会出现在同一任务选择列表中。
- en: A list of all the existing task groups can be found by navigating to the **Pipelines**
    menu and then **Task groups**. To edit an existing task group, select it in the
    list that is shown, and then select the **Edit** option. Editing task groups works
    in precisely the same way as editing a build definition.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现有任务组的列表可以通过导航到**管道**菜单，然后选择**任务组**找到。要编辑现有的任务组，在显示的列表中选择它，然后选择**编辑**选项。编辑任务组的方式与编辑构建定义完全相同。
- en: This section was all about creating a build definition and describing how an
    application should be built. The next section is about executing the build.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 本节主要讲解了如何创建构建定义以及如何描述应用程序的构建方式。下一节将介绍如何执行构建。
- en: Running a build
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行构建
- en: In this section, you will learn how to work with the build results and use them
    to report and generate builds. You will also learn how to run a build with every
    pull request and report the quality of the changes back to that pull request to
    assist the reviewer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何处理构建结果，并利用它们报告和生成构建。您还将学习如何在每次拉取请求时运行构建，并将更改的质量报告回该拉取请求，以帮助审阅者。
- en: Viewing the build results
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看构建结果
- en: 'While a build is running, an agent will perform all the configured steps. Azure
    Pipelines will capture detailed information and logs from all these steps. As
    you can see in the following screenshot, a build will display a list of all the
    steps it has executed on the left. Clicking on any of these steps will open a
    detailed view that displays the logs per step:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建运行时，代理将执行所有配置的步骤。Azure Pipelines 会捕获所有这些步骤的详细信息和日志。如以下截图所示，构建会在左侧显示它已执行的所有步骤列表。点击任何一个步骤将打开详细视图，显示该步骤的日志：
- en: '![Figure 5.11 – Build results ](img/B18655_05_11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 构建结果](img/B18655_05_11.jpg)'
- en: Figure 5.11 – Build results
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.11 – 构建结果
- en: Whenever there are warnings or errors during the build, they show up in orange
    or red, respectively.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 每当构建过程中出现警告或错误时，它们会分别以橙色或红色显示。
- en: Building a pull request
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建拉取请求
- en: 'After setting up your build definition and running your first builds, you might
    also see the first failures coming in – for example, when someone accidentally
    commits and pushes changes that do not compile or contain unit tests that do not
    run successfully. You can prevent this by having a build definition run automatically
    whenever a pull request comes in. To configure this, go through the following
    steps:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好构建定义并运行第一次构建后，您可能还会看到第一次失败——例如，当有人不小心提交并推送了无法编译的更改或包含无法成功运行的单元测试时。您可以通过设置使构建定义在每次拉取请求到来时自动运行来防止这种情况。要配置此功能，请按照以下步骤操作：
- en: 'Click on **Policies** under **Project Settings**. The following screen will
    open. Click on **Add build policy**:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目设置**下点击**策略**，将打开以下界面。点击**添加构建策略**：
- en: '![Figure 5.12 – Adding a build policy ](img/B18655_05_12.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – 添加构建策略](img/B18655_05_12.jpg)'
- en: Figure 5.12 – Adding a build policy
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.12 – 添加构建策略
- en: Select a build definition that you want to use to validate the pull request.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个构建定义，用于验证拉取请求。
- en: 'Next, there will be three more things that you can configure:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您可以配置以下三项内容：
- en: '**Trigger**: When the build definition should start, either automatically or
    manually. Of course, the real value comes from running a verification build automatically.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**触发器**：构建定义应该何时开始执行，可以是自动执行或手动执行。当然，真正的价值来自于自动运行验证构建。'
- en: '**Policy requirement**: This determines whether a pull request can be completed
    if the build fails. In other words, this determines whether you can ignore a failing
    build. It is recommended that you avoid setting this to **Optional**, if possible.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略要求**：这决定了当构建失败时，是否可以完成拉取请求。换句话说，这决定了你是否可以忽略失败的构建。建议如果可能，避免将此设置为**可选**。'
- en: '**Build expiration**: This determines how long a positive build result is valid
    for. The default value is **12** hours, but you should consider changing this
    to **Immediately when main is updated**. The advantage of this is that you cannot
    merge changes without first running the build against a combination of the current
    state of the branch that you will merge to and the proposed changes.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建过期时间**：这决定了一个成功的构建结果有效的时间长度。默认值是**12**小时，但你应该考虑将其更改为**当主分支更新时立即过期**。这样做的好处是，必须先执行构建，以检查你将要合并的分支的当前状态和拟议更改的组合，才能进行合并。'
- en: You can add more than one build policy. If you have a lot of things that you
    can automatically validate and want to keep automated validation times to a minimum,
    then this is a good approach.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加多个构建策略。如果你有很多可以自动验证的内容，并希望将自动验证的时间保持在最小值，那么这是一个很好的方法。
- en: Accessing build artifacts
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问构建工件
- en: As well as compiling, testing, and validating your source code, builds can also
    be used to generate what are called **artifacts**. Artifacts are outputs from
    a build and can be anything that you want to save and publish from a build, such
    as test results and application packages.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编译、测试和验证源代码外，构建还可以用于生成所谓的**工件**。工件是构建的输出，可以是任何你想要从构建中保存并发布的内容，比如测试结果和应用程序包。
- en: 'An application package is intended to be an immutable build of a version of
    your application. This package can later be picked up in a release and deployed
    to one or more environments:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序包旨在成为你应用程序版本的不可变构建。这个包稍后可以在发布中使用，并部署到一个或多个环境中：
- en: '![Figure 5.13 – Viewing application packages  ](img/B18655_05_13.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 查看应用程序包](img/B18655_05_13.jpg)'
- en: Figure 5.13 – Viewing application packages
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 查看应用程序包
- en: In the preceding screenshot, you can see that, as part of the summary of an
    executed build, there were two artifacts published. Artifacts can be accessed
    from either the **Artifacts** drop-down menu in the top-right corner of the screen
    or from the **Summary** tab. You can download and explore artifacts from this
    page, and in the next chapter, you will see how to work with them to set up continuous
    delivery.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到，作为已执行构建的总结的一部分，有两个工件被发布。你可以通过屏幕右上角的**工件**下拉菜单或**摘要**标签访问这些工件。你可以从此页面下载并查看工件，在下一章中，你将看到如何使用它们来设置持续交付。
- en: Great! With this, you have learned how to create a definition using the visual
    designer. But wait – as we mentioned earlier, there is another way of doing this,
    which is by using YAML files. Let’s see how this works in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！通过这一步，你已经学会了如何使用可视化设计器创建定义。但等等——正如我们之前提到的，还有另一种方法可以做到这一点，那就是使用YAML文件。让我们在下一节看看它是如何工作的。
- en: Working with YAML pipelines
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用YAML管道
- en: You have seen how to create a build definition using the visual designer. A
    new, alternative approach, which has been available since early 2019, is the use
    of YAML pipelines. When working with YAML pipelines, you specify your complete
    build definition in a YAML file and store it in source control, often next to
    the source code that the build is for.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到如何使用可视化设计器创建构建定义。自2019年初以来，一种新的替代方法是使用YAML管道。在使用YAML管道时，你需要在YAML文件中指定完整的构建定义，并将其存储在源代码管理中，通常与构建所针对的源代码一起存储。
- en: While both pipeline systems coexist, using YAML pipelines is now the preferred
    approach for defining pipelines. This means that it is very likely that new features
    will only surface in YAML pipelines.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然两种管道系统并存，但现在定义管道的首选方法是使用YAML管道。这意味着新的功能很可能只会出现在YAML管道中。
- en: The reason for using build definitions as code
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构建定义作为代码的原因
- en: When you first start working with YAML build definitions, you might find that
    the learning curve is steeper than it is when working with a visual designer.
    This might raise the question as to why you would use YAML-defined builds. There
    are two main advantages that YAML build definitions have over visually designed
    definitions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次开始使用 YAML 构建定义时，你可能会发现学习曲线比使用可视化设计器时更陡峭。这可能会引发一个问题，那就是为什么要使用 YAML 定义的构建。YAML
    构建定义相对于可视化设计定义有两个主要优势。
- en: When you are writing your definition in YAML, it can be hosted in source control
    next to your code. The consequence of this is that all the policies that you have
    in place for changing source control now automatically apply to your build definition.
    This means that any change must go through a pull request, be reviewed by a peer,
    and can be built and verified ahead of time. Enforcing the **four-eyes principle**
    on your build definition, as well as your code, increases the stability of your
    build process. Of course, it also benefits security and compliance, topics that
    will be discussed in later chapters.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 YAML 中编写定义时，它可以与代码一起托管在源代码控制中。这样做的结果是，所有针对源代码控制的更改策略现在自动应用于你的构建定义。这意味着任何更改都必须经过拉取请求，由同行审核，并且可以提前构建和验证。强制实施**四眼原则**于你的构建定义以及代码，有助于提高构建过程的稳定性。当然，它也有助于提高安全性和合规性，这些主题将在后面的章节中讨论。
- en: As well as this increase in security, having the build definition in source
    control also means that it is available in every branch. This means that it can
    be changed in every branch to build that specific branch before merging it with
    the main branch. When working with a visually designed build definition, this
    single definition is responsible for building not only your main branch but also
    all the branches that you want to merge through a pull request.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 除了增强的安全性外，将构建定义放在源代码控制中还意味着它在每个分支中都是可用的。这意味着它可以在每个分支中进行更改，以便在与主分支合并之前构建该特定分支。使用可视化设计的构建定义时，这个单一的定义不仅负责构建你的主分支，还负责构建你想通过拉取请求合并的所有分支。
- en: 'This means that you must do one of the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你必须执行以下其中一项操作：
- en: Update the build definition for the change that you will merge. However, this
    will terminate the building of the current state of the main branch.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新构建定义以适应你将要合并的更改。然而，这将终止当前主分支的构建。
- en: Merge the change, which will also result in a broken build, since the build
    definition has not yet been updated.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并更改，这也会导致构建失败，因为构建定义尚未更新。
- en: Either option has the risk of allowing faulty changes to flow through the target
    branch, defeating the purpose of a continuous integration build. With a build
    definition per branch, we eradicate this problem.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种选项都有允许错误更改流入目标分支的风险，这会破坏持续集成构建的目的。通过每个分支都有一个构建定义，我们消除了这个问题。
- en: Writing a basic YAML pipeline
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个基本的 YAML 管道
- en: 'To get started with YAML builds, there are two things you need to do:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 YAML 构建，你需要做两件事：
- en: First, you need to write your YAML file.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要编写 YAML 文件。
- en: Then, you need to create a build definition out of it.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你需要从中创建一个构建定义。
- en: So, let’s get started.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Writing the YAML file
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写 YAML 文件
- en: 'The following code sample contains an example YAML definition for building
    a .NET Core application and running unit tests. Save a file with any name – for
    example, `pipeline.yaml` – in any Git repository in Azure DevOps. Then, it can
    be used to create a pipeline out of it later on:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例包含一个用于构建 .NET Core 应用程序并运行单元测试的 YAML 定义。将文件以任何名称保存——例如 `pipeline.yaml`——并存储在
    Azure DevOps 中的任何 Git 仓库中。然后，可以稍后使用它来创建一个管道：
- en: '[PRE3]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This YAML example defines a basic pipeline. Every pipeline needs to be triggered
    in some way. Just as with classic builds, this can be done by connecting the pipeline
    to a change in a source code repository. The default repository for this is the
    repository that also contains the YAML definition. The **trigger** keyword is
    used to specify a push to which branches should trigger the pipeline. A good starting
    point is the main branch. As the trigger keyword accepts a list, multiple branches
    can be specified, and wildcards can be used.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 YAML 示例定义了一个基本的管道。每个管道都需要以某种方式触发。就像经典的构建一样，可以通过将管道连接到源代码仓库中的更改来实现。此默认仓库是包含
    YAML 定义的仓库。**trigger** 关键字用于指定哪些分支的推送应触发管道。一个好的起点是主分支。由于 trigger 关键字接受列表，可以指定多个分支，并且可以使用通配符。
- en: A trigger is not mandatory, as a pipeline can also be started manually.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器不是必需的，因为管道也可以手动启动。
- en: Tip
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: There are also alternative options to using the trigger keyword, such as including
    or excluding one or more branches, tags, or paths in the repository. These options
    are described in detail at [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他替代触发器关键字的选项，例如在存储库中包含或排除一个或多个分支、标签或路径。这些选项的详细说明可以参见 [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers)。
- en: As well as a trigger, every pipeline contains one or more tasks, just as in
    classic build definitions. All these tasks need to execute on an agent pool –
    again, just as in classic build definitions. The `pool` keyword is used to specify
    a set of key/value pairs that determine which pool the tasks will run on by specifying
    the name of the pool. When working with the default agents that Microsoft provides,
    the default name of `Azure Pipelines` can be used. When using this specific pool,
    a **Virtual Machine** (**VM** ) image has to be specified. This determines which
    operating system and what software is available on the agent that will execute
    the task.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 每个管道都包含一个或多个任务，和经典构建定义一样，除了触发器外。所有这些任务需要在代理池上执行——同样，和经典构建定义一样。`pool` 关键字用于指定一组键值对，通过指定池的名称来确定任务将在哪个池上运行。使用
    Microsoft 提供的默认代理时，可以使用默认名称 `Azure Pipelines`。使用这个特定池时，必须指定**虚拟机**（**VM**）镜像。这决定了将执行任务的代理上可用的操作系统和软件。
- en: Tip
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: An up-to-date list of all the VM images that are available can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent](https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过 [https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent](https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent)
    查找到所有可用的 VM 镜像的最新列表。
- en: Finally, the definition contains a list of the steps that make up the pipeline
    itself. These steps correspond one to one with the tasks that you can drag into
    a classic build pipeline. A task is added by specifying the name and version –
    separated by the `@` sign – of the task that you want to run. Next, you can optionally
    specify a display name for the task. This display name will later be visible in
    the views that show the results of an executed pipeline. Finally, specify one
    or more inputs for the task. These inputs relate to the task-specific configuration
    that you have already seen for the visual designer.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，定义包含构成管道本身的步骤列表。这些步骤与您可以拖入经典构建管道中的任务一一对应。添加任务时，指定任务的名称和版本——由 `@` 符号分隔——然后您可以选择性地为任务指定显示名称。此显示名称稍后将在显示已执行管道结果的视图中可见。最后，为任务指定一个或多个输入。这些输入与您在可视设计器中已经看到的任务特定配置有关。
- en: Creating a YAML pipeline
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 YAML 管道
- en: 'After saving your YAML file in a repository, you can create a build definition
    from it. When creating a new build definition (see the *Creating a build definition*
    section of this chapter), you should go through the following steps:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 YAML 文件保存在存储库中之后，您可以从中创建构建定义。创建新构建定义时（请参阅本章的*创建构建定义*部分），您应当按照以下步骤进行操作：
- en: Choose the **Azure Repos Git YAML** option when the wizard starts.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当向导启动时，选择**Azure Repos Git YAML**选项。
- en: 'From here, go through the wizard to select and review the YAML you want to
    build, as shown in the following screenshot:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，按照向导的步骤选择并查看您希望构建的 YAML，如下图所示：
- en: '![Figure 5.14 – A YAML pipeline for a repository  ](img/B18655_05_14.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 用于存储库的 YAML 管道](img/B18655_05_14.jpg)'
- en: Figure 5.14 – A YAML pipeline for a repository
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.14 – 用于存储库的 YAML 管道
- en: Then, locate the repository that contains the YAML file that you want to use
    as your pipeline.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，找到包含您要用作管道的 YAML 文件的存储库。
- en: Next, configure the pipeline by choosing an example YAML file to start from
    or by referring to an already existing file.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过选择一个示例 YAML 文件作为起点或引用已有的文件来配置管道。
- en: Finally, you can review the YAML file that you have selected and start a build
    from it.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以查看所选的 YAML 文件并从中启动构建。
- en: Your pipeline is saved automatically. Once the pipeline is saved, it can be
    started, and you can interact with it in the same way as you would with classic
    build pipelines.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你的管道会自动保存。管道保存后，可以启动，并且你可以像操作经典构建管道一样与它交互。
- en: Multi-job pipelines
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多作业管道
- en: 'The pipeline you saw in the previous section does not specify any jobs, as
    you may recall from the section on classic builds. Instead, it contains a list
    of tasks under the `steps` keyword. This means that it implicitly contains only
    a single job. With YAML pipelines, it is also possible to create a definition
    that contains more than one job. To do this, the following structure can be used:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你在前一节中看到的管道没有指定任何作业，正如你可能记得的经典构建部分。相反，它包含了一个 `steps` 关键字下的任务列表。这意味着它隐式地只包含一个作业。在
    YAML 管道中，也可以创建包含多个作业的定义。为此，可以使用以下结构：
- en: '[PRE4]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Instead of adding the `steps` keyword directly to the pipeline, a list of jobs
    is created first. Within that list, one or more `job` keywords are added, followed
    by the name for that job. Next to this technical name, a display name (`displayName`)
    can be specified for each job.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不直接将 `steps` 关键字添加到管道中，而是先创建一个作业列表。在该列表中，添加一个或多个 `job` 关键字，后跟该作业的名称。在该技术名称旁，还可以为每个作业指定一个显示名称
    (`displayName`)。
- en: As the second job in the preceding example shows, it is also possible to specify
    which agent pool to use per job. When no pool is specified for a job, the default
    pool specified at the top of the file is used.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例中的第二个作业所示，也可以为每个作业指定使用的代理池。当没有为作业指定代理池时，将使用文件顶部指定的默认池。
- en: Tip
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The jobs that are discussed in this section are called agent jobs. Besides agent
    jobs, there are also server jobs, container jobs, and deployment jobs available.
    More information about these types of jobs can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的作业称为代理作业。除了代理作业，还有服务器作业、容器作业和部署作业。有关这些类型作业的更多信息，请访问 [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs)。
- en: By default, all the jobs in a pipeline run in parallel, but there are control
    options available to change this.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，管道中的所有作业都是并行运行的，但有可用的控制选项可以更改这一点。
- en: Control options
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制选项
- en: 'To control the order of jobs, the `dependsOn` keyword can be used in the definition
    of a job. This signals that the job can only be started after one or more jobs
    are completed. Besides this, the `condition` keyword can be used to specify a
    condition that a job should run under. These two keywords can be combined to realize
    more complex scenarios, such as the one shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制作业的顺序，可以在作业的定义中使用 `dependsOn` 关键字。这表明该作业只能在一个或多个作业完成后开始。除此之外，`condition`
    关键字可以用于指定作业运行的条件。可以结合这两个关键字来实现更复杂的场景，如下所示：
- en: '[PRE5]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This pipeline will start by running the job named `compile`. Once this job completes,
    the next two jobs, `test` and `build_schema`, will run in parallel, as they both
    depend on the `compile` task. After both of these tasks complete, the `report`
    task runs, as it declares a dependency on both the `test` and `build_schema` jobs.
    Before this job actually starts, the condition is evaluated to determine whether
    the job should actually run or be skipped.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 该管道将通过运行名为 `compile` 的作业开始。一旦该作业完成，接下来的两个作业 `test` 和 `build_schema` 将并行运行，因为它们都依赖于
    `compile` 任务。在这两个任务都完成后，`report` 任务将运行，因为它声明依赖于 `test` 和 `build_schema` 作业。在该作业实际开始之前，会评估条件，以确定该作业是否应该运行或被跳过。
- en: Conditions can be built using a syntax that is similar to many programming languages.
    It checks the successful completion of a job using the `succeeded()` and `failed()`
    functions. There is also support for Boolean operators such as `or()`, `and()`,
    and `ne()`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 条件可以使用类似于许多编程语言的语法来构建。它通过 `succeeded()` 和 `failed()` 函数检查作业是否成功完成。同时还支持布尔运算符，如
    `or()`、`and()` 和 `ne()`。
- en: You can combine the `dependsOn` and `condition` keywords in any way you see
    fit. The only requirement is that there should be at least one job that does not
    depend on any other job.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要以任何方式结合 `dependsOn` 和 `condition` 关键字。唯一的要求是，至少应有一个作业不依赖于任何其他作业。
- en: Variables
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'Just like classic build pipelines, YAML pipelines support the use of variables.
    Variables can be defined at every level of a YAML pipeline (except for within
    a task) using the following syntax:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典构建管道一样，YAML管道支持使用变量。变量可以在YAML管道的每一层级（任务内部除外）使用以下语法进行定义：
- en: '[PRE6]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Variables can later be retrieved using the syntax that you already know from
    classic build pipelines – `$(name)` and `$(anotherName)`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以后可以使用你从经典构建管道中熟悉的语法来检索变量——`$(name)`和`$(anotherName)`。
- en: 'It is also possible to reference existing variable groups from within a YAML
    pipeline. This is done by using the `group` keyword, instead of specifying the
    name of a variable. To also retrieve all the variables from a variable group called
    `myVariableGroup`, you would extend the preceding YAML, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在YAML管道中引用现有的变量组。这是通过使用`group`关键字来完成的，而不是指定变量的名称。若要从名为`myVariableGroup`的变量组中检索所有变量，可以按照以下方式扩展前面的YAML：
- en: '[PRE7]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Variables can be set at every level in a YAML pipeline, but only variables
    set at the root level can be overridden when queuing a new execution manually.
    You can learn more here: [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在YAML管道的每一层级中设置变量，但只有在根级别设置的变量才能在手动排队新执行时被覆盖。你可以在这里了解更多：[https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables)。
- en: Pipeline artifacts
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道工件
- en: Just like classic builds, YAML pipelines can be used to build and publish artifacts.
    As the task used to do this is a task like any other, it can be added directly
    to the list of steps in a job.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 与经典构建一样，YAML管道可以用于构建和发布工件。由于用于此目的的任务与其他任务一样，它可以直接添加到作业中的步骤列表中。
- en: However, with the introduction of YAML pipelines, a new type of artifact has
    become available – the so-called pipeline artifact. This comes with the benefit
    of improving the speed at which large artifacts can be uploaded and downloaded.
    When working with classic releases, pipeline artifacts are not automatically downloaded,
    whereas build artifacts are.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着YAML管道的引入，一种新的工件类型——所谓的管道工件——已经可用。这种工件带来了提高大规模工件上传和下载速度的优势。当使用经典发布时，管道工件不会自动下载，而构建工件则会。
- en: 'To publish a pipeline artifact, the following YAML can be used in the `steps`
    keyword of a job:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要发布管道工件，可以在作业的`steps`关键字中使用以下YAML：
- en: '[PRE8]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Pipeline artifacts are mainly intended to be downloaded in multi-stage YAML
    pipelines, which are also covered in the next chapter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 管道工件主要用于在多阶段YAML管道中下载，相关内容将在下一章中介绍。
- en: Tips for writing YAML pipelines
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写YAML管道的技巧
- en: Writing YAML pipelines from scratch can be complicated when you are just getting
    started. There are two tools available that can help you.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从头开始编写YAML管道可能会比较复杂，尤其是对于刚入门的人。有两个工具可以帮助你。
- en: First, there is the option to export YAML from the visual designer. For every
    task, there is a link with the **View YAML** title. This opens a small pop-up
    box that shows you the YAML corresponding to the task and configuration that you
    currently have open. The same can be done for jobs and, under specific conditions,
    complete build definitions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有一个选项可以从可视化设计器导出YAML。对于每个任务，都会有一个**查看YAML**的链接。点击该链接会打开一个小弹出框，显示当前打开的任务和配置对应的YAML。对于作业也可以执行相同操作，并且在特定条件下，可以对完整的构建定义进行相同操作。
- en: 'The other tool available for writing YAML is the built-in YAML editor:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 写YAML的另一个工具是内置的YAML编辑器：
- en: '![Figure 5.15 – The YAML editor ](img/B18655_05_15.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图5.15 – YAML编辑器](img/B18655_05_15.jpg)'
- en: Figure 5.15 – The YAML editor
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15 – YAML编辑器
- en: Whenever you open a YAML build definition, there are two tools available to
    help you. First, there is autocompletion for every location in your YAML file.
    This shows you the options available at that point in the file. As well as this,
    there are snippets available in the task picker on the right. When selecting any
    of the tasks on the right, you configure them visually and then click the **Add**
    button to add the generated YAML to your definition.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 每次打开YAML构建定义时，有两个工具可供你帮助。首先，在YAML文件的每个位置都有自动完成功能。它会显示该位置可用的选项。此外，右侧的任务选择器中也有代码片段。当选择右侧的任何任务时，你可以通过可视化界面配置它们，然后点击**添加**按钮将生成的YAML添加到定义中。
- en: These two tools aim to bring the ease of the visual designer to the YAML build
    experience as well, combining the best of both worlds.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种工具旨在将可视化设计器的便捷性引入到YAML构建体验中，结合了两者的优点。
- en: 'Refer to these docs for a complete YAML schema reference: [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema/?view=azure-pipelines](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema/?view=azure-pipelines).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考这些文档，获取完整的YAML模式参考：[https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema/?view=azure-pipelines](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema/?view=azure-pipelines)。
- en: Agents and agent queues
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理和代理队列
- en: 'The build definitions that you have created so far can contain agent jobs,
    which in turn contain tasks. These tasks are not executed within your Azure DevOps
    organization directly but are instead executed by agents that run on VMs or in
    containers. In turn, agents are grouped in agent pools. There are two types of
    agent pools that you can work with:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你创建的构建定义可以包含代理作业，而代理作业又包含任务。这些任务不会直接在你的Azure DevOps组织中执行，而是由在虚拟机或容器中运行的代理来执行。代理又被分组到代理池中。你可以使用两种类型的代理池：
- en: Built-in agent pools
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内建代理池
- en: Self-hosted agent pools
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自托管代理池
- en: Let’s go through them one by one.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一一来了解它们。
- en: Built-in agent pools
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内建代理池
- en: Built-in agent pools are managed by Microsoft and are made available to you
    as part of the Azure DevOps product itself. There are different agent pools available,
    depending on your needs. Pools run different versions of Windows and Visual Studio,
    and there are also pools available that run Linux (Ubuntu) and macOS.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 内建代理池由微软管理，并作为Azure DevOps产品的一部分提供给你。根据你的需求，提供了不同的代理池。池运行不同版本的Windows和Visual
    Studio，还有运行Linux（Ubuntu）和macOS的池。
- en: The disadvantage of these managed pools is that you cannot install extra software
    on the machines or containers that host the agents if you need to. This means
    that, in these cases, you have to create your own private agent pools.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些托管池的缺点是，如果你需要的话，你不能在托管代理的机器或容器上安装额外的软件。这意味着，在这种情况下，你必须创建自己的私有代理池。
- en: Creating a private agent pool
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建私有代理池
- en: 'Private pools are defined in your Azure DevOps organization and are provisioned
    from there to one or more of your team projects. However, you can also create
    your private pools at the team project level if they are created and provisioned
    in one go. To do so, go to **Project Settings** | **Agent pools**. You should
    see the following **Add agent pool** option:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 私有池在你的Azure DevOps组织中定义，并从那里提供到一个或多个团队项目。不过，如果在一次操作中创建并配置这些池，你也可以在团队项目级别创建私有池。为此，请进入**项目设置**
    | **代理池**。你应该会看到以下**添加代理池**选项：
- en: '![Figure 5.16 – Agent pool settings ](img/B18655_05_16.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 – 代理池设置](img/B18655_05_16.jpg)'
- en: Figure 5.16 – Agent pool settings
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 代理池设置
- en: After giving the pool a name and determining whether you want to automatically
    provide access to all pipelines, you can save the pool. After creating the pool,
    you can add or remove agents.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在为池命名并确定是否希望自动为所有管道提供访问权限后，你可以保存该池。创建池之后，你可以添加或移除代理。
- en: Adding and removing agents
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和移除代理
- en: 'Adding an agent is done in two steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 添加代理分为两个步骤：
- en: 'Download and extract the agent runtime. You can find the agent runtime by going
    to the section with the overview of the agent pools and opening the details of
    any private agent pool. After the details of the pool are opened, click on **New
    agent** in the top-right corner:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并提取代理运行时。你可以通过进入包含代理池概览的部分并打开任何私有代理池的详细信息来找到代理运行时。打开池的详细信息后，点击右上角的**新建代理**：
- en: '![Figure 5.17 – Adding a new agent ](img/B18655_05_17.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 – 添加新代理](img/B18655_05_17.jpg)'
- en: Figure 5.17 – Adding a new agent
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 添加新代理
- en: In the dialog that opens, you can download a ZIP file with the agent and instructions
    for extracting and installing the agent.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的对话框中，你可以下载一个包含代理程序和提取及安装代理程序的说明的ZIP文件。
- en: Important Note
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: During the configuration phase, you will be prompted to authenticate with your
    Azure DevOps organization and provide the name of the agent pool you want to install
    the agent in. While there are x86 and x64 agents available, it is recommended
    that you work with the x64 agent unless you have a specific reason not to.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置阶段，你将被提示使用你的Azure DevOps组织进行身份验证，并提供你希望安装代理的代理池的名称。虽然有x86和x64版本的代理可供选择，但建议你使用x64代理，除非有特殊原因不这么做。
- en: 'To remove agents from the pool, you can use one of two methods:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要从代理池中移除代理，可以使用以下两种方法之一：
- en: 'You can return to the PowerShell command line, just as you did for the installation,
    and use the following command:'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以像安装时那样返回到 PowerShell 命令行，并使用以下命令：
- en: '[PRE9]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, you can also remove agents from the agent pool overview using
    the **Agents** tab. Go to **Project Settings** | **Agent pools** (see **1** in
    the following screenshot) | **Agents** (see **2** in the following screenshot),
    and then select the options button (see **3** in the following screenshot) on
    the agent you want to remove. Then, click **Delete** (see **4** in the following
    screenshot):'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，你也可以通过**代理**标签从代理池概览中移除代理。前往**项目设置** | **代理池**（见下方截图中的**1**） | **代理**（见下方截图中的**2**），然后选择你想要移除的代理旁边的选项按钮（见下方截图中的**3**）。接着，点击**删除**（见下方截图中的**4**）：
- en: '![Figure 5.18 – Deleting an agent ](img/B18655_05_18.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18 – 删除代理](img/B18655_05_18.jpg)'
- en: Figure 5.18 – Deleting an agent
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.18 – 删除代理
- en: In the preceding screenshot, you can see the steps to remove an agent using
    the interface. Be aware that this does not clean up the binaries and any files
    on the host machine; however, if a machine that is hosting an agent breaks down
    or a VM is removed, this is the only way to remove the agent.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到使用界面移除代理的步骤。请注意，这不会清理主机上的二进制文件和任何文件；然而，如果承载代理的机器故障或虚拟机被移除，这将是唯一可以移除代理的方法。
- en: Agent selection
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理选择
- en: 'Whenever a build job starts running, an agent is selected from the pool that
    will perform the tasks that you have defined in the pipeline. The selection of
    an agent is done in two steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 每当构建任务开始运行时，都会从池中选择一个代理来执行你在管道中定义的任务。代理的选择分为两个步骤：
- en: Only agents that are part of the selected pool are eligible for running the
    tasks. This means that when working with private agent pools, it is wise to have
    multiple agents in a pool. If you then take one agent offline for maintenance,
    the agent jobs that rely on the agent pool can continue running.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只有属于选定代理池的代理才有资格执行任务。这意味着，在使用私有代理池时，最好在池中拥有多个代理。如果你将某个代理下线进行维护，那么依赖该代理池的代理任务可以继续运行。
- en: 'Before an agent job can run, the demands from each job and the tasks it contains
    are gathered. As you learned in the *Variable groups* section, an agent job can
    specify the demands it has of the agent that it uses. The same goes for tasks
    – they can also specify demands. To run a job, only agents that meet all of these
    demands are used. Demands and capabilities are key/value pairs, where the value
    is an integer. Refer to these docs for examples of demands: [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/demands](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/demands).'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代理任务运行之前，来自每个任务及其包含的任务的需求会被收集。如你在*变量组*部分中学到的那样，代理任务可以指定它对所使用的代理的需求。任务也是如此——它们也可以指定需求。要运行一个任务，只有满足所有这些需求的代理才会被使用。需求和能力是键/值对，其中值为整数。有关需求的示例，请参考以下文档：[https://docs.microsoft.com/en-us/azure/devops/pipelines/process/demands](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/demands)。
- en: When there is no eligible agent for a build definition, the build eventually
    fails after a timeout.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有符合条件的代理可用于构建定义时，构建会在超时后最终失败。
- en: Finding agent capabilities
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找代理能力
- en: 'To find the capabilities that are available on the individual agents, go through
    the following steps:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找各个代理上可用的能力，请按照以下步骤操作：
- en: 'Navigate to **Organization Settings** | **Agent pools**:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**组织设置** | **代理池**：
- en: '![Figure 5.19 – Viewing agent settings ](img/B18655_05_19.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19 – 查看代理设置](img/B18655_05_19.jpg)'
- en: Figure 5.19 – Viewing agent settings
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.19 – 查看代理设置
- en: Navigate to the correct agent pool (either hosted or private), then **Agents**,
    and then open the agent details (not shown in the preceding screenshot).
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到正确的代理池（托管或私有），然后选择**代理**，接着打开代理详细信息（在前面的截图中未显示）。
- en: Open the **Capabilities** tab.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**能力**标签。
- en: Here, you can specify one or more custom capabilities for the agent using the
    top block, called **User-defined capabilities**. For self-hosted (private) agents,
    all the capabilities that were discovered on the machine when you installed the
    agent are also shown.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以使用顶部的块来为代理指定一个或多个自定义能力，称为**用户定义的能力**。对于自托管（私有）代理，安装代理时在机器上发现的所有能力也会显示出来。
- en: The benefits of self-hosted agent pools
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自托管代理池的好处
- en: Use of Microsoft (cloud)-hosted agents is a fairly common practice and saves
    you a lot of time in managing and configuring your build infrastructure. Self-hosted
    agents have proven to be beneficial on many occasions. Due to the availability
    of a lot of good documentation, it has become an easy task for administrators
    to provision and configure a self-hosted agent for use in their pipelines.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微软（云）托管代理是一种相当常见的做法，可以节省大量时间来管理和配置构建基础设施。自托管代理在许多场合已被证明非常有益。由于有大量优秀的文档，管理员已能轻松地为其管道配置和设置自托管代理。
- en: 'The main benefits of using a self-hosted agent are as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自托管代理的主要好处如下：
- en: Optimizing the cost of your build agents.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化构建代理的成本。
- en: Installing additional software as required for your specific build tasks.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要安装特定构建任务所需的附加软件。
- en: Improving the performance of your builds, making them run faster by caching
    resources, and enabling incremental builds.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过缓存资源并启用增量构建来提高构建性能，使其运行更快。
- en: The debugging and troubleshooting of build issues are easier.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建问题的调试和故障排除变得更容易。
- en: Allows for **Virtual Network** (**Vnet**) integration, and you can securely
    run your builds behind the firewall.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 **虚拟网络**（**Vnet**）集成，您可以在防火墙后安全地运行构建。
- en: Accessing other corporate resources securely using whitelisted IP addresses.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用白名单 IP 地址安全地访问其他企业资源。
- en: In the next section, we will explore the option to automate CI builds for repositories
    hosted on GitHub.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何自动化托管在 GitHub 上的仓库的 CI 构建。
- en: Automating CI builds using GitHub Actions
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 自动化 CI 构建
- en: 'If you are using a GitHub repository, you can also automate your CI builds
    using GitHub Actions (available as a tab within the repository’s top navigation
    menu). You can either choose from an existing template workflow (with more than
    50 workflows available) or set up a custom workflow of your own:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 GitHub 仓库，您还可以通过 GitHub Actions（作为仓库顶部导航菜单中的一个标签）自动化 CI 构建。您可以从现有的模板工作流中选择（提供超过
    50 个工作流）或创建自己的自定义工作流：
- en: '![Figure 5.20 – The available options in GitHub Actions ](img/B18655_05_20.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20 – GitHub Actions 中的可用选项](img/B18655_05_20.jpg)'
- en: Figure 5.20 – The available options in GitHub Actions
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.20 – GitHub Actions 中的可用选项
- en: 'The experience of authoring a workflow is similar to creating a YAML file and
    saving it within your GitHub repository:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 编写工作流的体验类似于创建一个 YAML 文件并将其保存在您的 GitHub 仓库中：
- en: '![Figure 5.21 – Editing a YAML file in the GitHub repository ](img/B18655_05_21.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21 – 在 GitHub 仓库中编辑 YAML 文件](img/B18655_05_21.jpg)'
- en: Figure 5.21 – Editing a YAML file in the GitHub repository
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.21 – 在 GitHub 仓库中编辑 YAML 文件
- en: In the next sections, we will introduce alternative tools that can be used for
    managing the CI processes.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将介绍可用于管理 CI 流程的其他工具。
- en: Other tools
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他工具
- en: There are many tools available besides Azure DevOps. Two other well-known tools
    are GitLab CI and Jenkins. Some very basic knowledge of these tools will help
    you to understand how to integrate with them if that is ever necessary. Also,
    a limited understanding of other tools will help you to quickly understand the
    concepts and generalize your knowledge of how to work with these other tools.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Azure DevOps 外，还有许多其他工具可供选择。两个其他知名工具是 GitLab CI 和 Jenkins。了解这些工具的一些基础知识有助于您理解如何与它们集成，万一需要时也能更好地应对。此外，对其他工具的有限了解将帮助您快速理解概念，并推广您如何与这些工具协作的知识。
- en: To highlight how these tools work with the same concepts, both examples in this
    section are equivalent to the Azure DevOps YAML pipeline in the *Writing a YAML
    build definition* section.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出这些工具如何在相同的概念下工作，本节中的两个示例与 *编写 YAML 构建定义* 一节中的 Azure DevOps YAML 管道是等效的。
- en: GitLab CI
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab CI
- en: 'GitLab offers build pipelines using the GitLab CI capabilities. GitLab CI is
    configured by putting a file with the `.gitlab-ci.yml` name in the root of a repository.
    In this file, you can define one or more stages and jobs, along with the tasks
    that they should perform. An example YAML file for GitLab CI can appear, as shown
    in the following example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 提供了使用 GitLab CI 功能的构建管道。GitLab CI 通过将一个名为 `.gitlab-ci.yml` 的文件放置在仓库的根目录中进行配置。在此文件中，您可以定义一个或多个阶段和任务，并指定它们应该执行的任务。以下是
    GitLab CI 示例 YAML 文件的样式：
- en: '[PRE10]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just as Azure DevOps uses agent pools with agents, GitLab CI relies on **runners**
    to perform the actual work. In GitLab CI, there is currently no support for visually
    creating or editing your pipelines.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Azure DevOps 使用代理池与代理一样，GitLab CI 依赖于**运行器**来执行实际的工作。在 GitLab CI 中，目前不支持直观地创建或编辑管道。
- en: Jenkins
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jenkins
- en: 'Jenkins is another tool used to run build pipelines. Complex builds can be
    run using Jenkins pipelines, which get their work from a Jenkinsfile. A **Jenkinsfile**
    is written in a Jenkins-specific notation, as shown in the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 是另一个用于运行构建管道的工具。可以使用 Jenkins 管道运行复杂的构建，Jenkins 管道从 Jenkinsfile 中获取工作。**Jenkinsfile**
    使用 Jenkins 特定的符号编写，如下所示：
- en: '[PRE11]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Jenkins has limited support for visually creating and editing a pipeline. This
    is referred to as a freestyle project.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 对直观地创建和编辑管道的支持有限。这被称为自由风格项目。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at continuous integration and learned how it is a
    combination of your mindset, the processes, and tools used by the development
    teams. You learned how to create build definitions using Azure Pipelines, using
    both the graphical designer and YAML, as well as how to run builds. You learned
    that you can use build pipelines to compile and test your code, as well as report
    the outcome back to pull requests.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了持续集成，并了解它是开发团队使用的心态、过程和工具的结合。你学会了如何使用 Azure Pipelines 创建构建定义，既可以使用图形设计器，也可以使用
    YAML，还学会了如何运行构建。你学到可以使用构建管道来编译和测试代码，并将结果反馈给拉取请求。
- en: You learned that builds can produce outputs, termed as Artifacts. Artifacts
    are stored and retained within Azure pipelines and can be used to store reports,
    but they are also the starting point of deployment pipelines, which you will learn
    about in the next chapter. You also learned about the infrastructure that you
    need to run builds – namely, agents and agent pools. Finally, you saw two brief
    examples of how to run a continuous integration build using GitLab CI and Jenkins,
    which are two other tools that you can use for build pipelines.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你学到了构建可以产生输出，这些输出称为工件（Artifacts）。工件存储并保留在 Azure 管道中，可以用于存储报告，但它们也是部署管道的起点，你将在下一章学习到这一点。你还了解了运行构建所需的基础设施——即代理和代理池。最后，你看到了两个简短的示例，展示了如何使用
    GitLab CI 和 Jenkins 运行持续集成构建，它们是你可以用于构建管道的另外两个工具。
- en: With this knowledge, you are now able to create build pipelines for your projects.
    You can hook up to source control and produce the builds that you will use in
    the next chapter to deploy your applications. With this deep knowledge of the
    underlying structure of tasks, jobs, stages, and pipelines, you can solve complex
    application-building problems.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识后，你现在能够为你的项目创建构建管道。你可以连接到源代码管理，并生成将在下一章中用于部署应用程序的构建。通过深入了解任务、作业、阶段和管道的底层结构，你能够解决复杂的应用构建问题。
- en: In the next chapter, you will continue learning about pipelines but this time,
    for releases. You will learn how to pick up builds and release them to one or
    more environments.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将继续学习管道，但这次是关于发布管道。你将学习如何获取构建并将其发布到一个或多个环境中。
- en: Questions
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the appendix:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结时，以下是一些问题，供你测试对本章内容的掌握情况。你可以在附录的*评估*部分找到答案：
- en: True or false? You achieve continuous integration if you compile all the branches
    of your project at least daily.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对还是错？如果你每天至少编译一次项目的所有分支，就能实现持续集成。
- en: True or false? A classic build definition is always connected to a source code
    repository.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对还是错？经典构建定义始终与源代码库连接。
- en: True or false? A YAML pipeline definition is always connected to a source code
    repository.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对还是错？YAML 管道定义始终与源代码库连接。
- en: Which of the following is needed to call an external tool from an Azure pipeline?
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是从 Azure 管道调用外部工具所需的？
- en: An external service definition
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个外部服务定义
- en: An Azure service connection
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 Azure 服务连接
- en: A service connection
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个服务连接
- en: A service locator
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个服务定位器
- en: 'What are some common reasons for using self-hosted agents? Choose all of the
    correct answers from the following:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自托管代理的常见原因有哪些？从以下选项中选择所有正确答案：
- en: Access to closed networks is needed.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要访问封闭网络。
- en: Specific extension tasks need to be available to the agent.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要将特定的扩展任务提供给代理。
- en: The number of parallel pipeline executions needs to be larger than 10.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行管道执行的数量需要大于 10。
- en: Specific software needs to be installed in order for the agent to use it.
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须安装特定软件才能让代理使用它。
- en: Exercises
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Add a folder named `pipelines` under the root directory of the `PacktBookLibrary`
    repository.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`PacktBookLibrary`仓库的根目录下添加一个名为`pipelines`的文件夹。
- en: Create a subfolder named `build` under the `pipelines` directory.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`pipelines`目录下创建一个名为`build`的子文件夹。
- en: Add a build file named `main-ci-build.yml`.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加名为`main-ci-build.yml`的构建文件。
- en: 'Insert the following code block in the file:'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将以下代码块插入到文件中：
- en: '[PRE12]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Save the file and commit your changes to the branch. Push and then raise a pull
    request to merge your changes with the main branch.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存文件并将更改提交到分支。推送更改后，发起拉取请求以将更改合并到主分支。
- en: 'Create a new pipeline in your team project. In the **Configure your pipeline**
    step, select the **Existing Azure Pipelines YAML file** option:'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的团队项目中创建一个新的管道。在**配置管道**步骤中，选择**现有的 Azure Pipelines YAML 文件**选项：
- en: '![Figure 5.22 – Using an existing pipeline option ](img/B18655_05_22.jpg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22 – 使用现有管道选项](img/B18655_05_22.jpg)'
- en: Figure 5.22 – Using an existing pipeline option
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.22 – 使用现有管道选项
- en: When prompted to select the build pipeline, specify the `main-ci-build.yml`
    file. Click **Continue** to finish creating your build pipeline.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提示选择构建管道时，指定`main-ci-build.yml`文件。点击**继续**完成构建管道的创建。
- en: Run the pipeline job to verify that the build pipeline works. On the pipeline
    status page, review for any errors and the successful execution of the pipeline
    job.
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行管道作业以验证构建管道是否正常工作。在管道状态页面上，检查是否有任何错误并确认管道作业成功执行。
- en: Important Note
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The pipeline is composed of tasks to build a .NET Core project. To build other
    types of code components, make use of the appropriate task library.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 该管道由构建 .NET Core 项目的任务组成。要构建其他类型的代码组件，请使用适当的任务库。
- en: 'The source code repository for the starter kit can be found here: [https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide](https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 启动包的源代码仓库可以在这里找到：[https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide](https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide)
- en: Further reading
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: An in-depth definition of continuous integration by Martin Fowler is available
    at [https://martinfowler.com/articles/continuousIntegration.xhtml](https://martinfowler.com/articles/continuousIntegration.xhtml).
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Martin Fowler 对持续集成的深入定义可以在[https://martinfowler.com/articles/continuousIntegration.xhtml](https://martinfowler.com/articles/continuousIntegration.xhtml)查看。
- en: A detailed description of the conditions syntax is available at [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devopstabs=classic](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devopstabs=classic).
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语法的详细描述可以在[https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devopstabs=classic](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devopstabs=classic)找到。
- en: Exercises for practicing with Azure DevOps builds can be found at [https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index](https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index).
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Azure DevOps 构建练习的更多信息可以在[https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index](https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index)找到。
- en: You can find the Visual Studio Marketplace for Azure DevOps at [https://marketplace.visualstudio.com/azuredevops](https://marketplace.visualstudio.com/azuredevops).
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://marketplace.visualstudio.com/azuredevops](https://marketplace.visualstudio.com/azuredevops)找到
    Azure DevOps 的 Visual Studio 市场。
- en: You can find a detailed description of the Azure Pipelines YAML syntax at [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devopstabs=schema](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devopstabs=schema).
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devopstabs=schema](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devopstabs=schema)找到关于
    Azure Pipelines YAML 语法的详细描述。
- en: Details of the pricing of the Azure Pipelines’ hosted and self-hosted agent
    pools are available at [https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/](https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/).
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Pipelines 托管和自托管代理池的定价详情可在[https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/](https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/)找到。
- en: More information about GitLab CI can be found at [https://about.gitlab.com/product/continuous-integration/](https://about.gitlab.com/product/continuous-integration/).
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 GitLab CI 的更多信息，请访问 [https://about.gitlab.com/product/continuous-integration/](https://about.gitlab.com/product/continuous-integration/)。
- en: More information about Jenkins can be found at [https://jenkins.io/](https://jenkins.io/).
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Jenkins 的更多信息，请访问 [https://jenkins.io/](https://jenkins.io/)。
- en: 'Build tasks for .NET Core projects: [https://docs.microsoft.com/en-us/azure/devops/pipelines/ecosystems/dotnet-core?view=azure-devops&tabs=dotnetfive.](https://docs.microsoft.com/en-us/azure/devops/pipelines/ecosystems/dotnet-core?view=azure-devops&tabs=dotnetfive%20)'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 项目的构建任务：[https://docs.microsoft.com/en-us/azure/devops/pipelines/ecosystems/dotnet-core?view=azure-devops&tabs=dotnetfive.](https://docs.microsoft.com/en-us/azure/devops/pipelines/ecosystems/dotnet-core?view=azure-devops&tabs=dotnetfive%20)
- en: '*Develop a web extension*: [https://docs.microsoft.com/en-us/azure/devops/extend/get-started/node?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/extend/get-started/node?view=azure-devops).'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*开发一个网页扩展*：[https://docs.microsoft.com/en-us/azure/devops/extend/get-started/node?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/extend/get-started/node?view=azure-devops)。'
