- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Getting Started with Git
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git入门
- en: Let’s dive into learning Git. This chapter will touch upon the basic usage of
    Git. However, as explained in the previous chapter, this book is not just about
    introducing concepts and methods. It emphasizes communication and collaboration.
    Thus, while you will undoubtedly be able to master the basic usage of Git, you
    will also learn about the communication aspects behind it and how Git is used
    in team development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入学习Git。本章将介绍Git的基本用法。然而，正如上一章所解释的，这本书不仅仅是介绍概念和方法。它强调沟通和协作。因此，尽管您无疑能够掌握Git的基本用法，但您还将了解背后的沟通方面，以及Git如何在团队开发中使用。
- en: In this chapter, we will first get a feel for the basics of Git by quickly going
    hands-on with the basics of file management and branching, and then we will cover
    how Git works. Then, you will get an understanding of the collaboration principles
    to be aware of when you are working with git as an engineer.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过快速实践文件管理和分支的基本操作，首先让您了解Git的基础知识，然后我们将介绍Git的工作原理。接着，您将了解与Git合作时作为工程师需要注意的协作原则。
- en: 'We will cover the following main topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Getting started with Git
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git入门
- en: The anatomy of Git – A beginner-friendly explanation of how Git works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git的基本构造——适合初学者的Git工作原理解释
- en: Becoming a guru of Git communication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为Git通信的高手
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The configuration instructions for proceeding with this section can be found
    in the following GitHub repository link. Please make sure Git and ssh tools are
    installed. For Windows users, it is recommended to use PowerShell. I also encourage
    you to get the most up-to-date information written about the different commands
    and environments:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行此部分的配置说明可以在以下GitHub仓库链接中找到。请确保已安装Git和ssh工具。对于Windows用户，建议使用PowerShell。我还建议您获取有关不同命令和环境的最新信息：
- en: '[https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub](https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub](https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub)'
- en: Getting started with Git
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git入门
- en: In this section, we will proceed with how to use Git, assuming a scenario where
    you are working in an individual environment and simply building up a history.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将假设您在个人环境中工作，并仅仅是在建立历史记录，来进行Git的使用介绍。
- en: Git basics – Begin with a hands-on experience
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git基础——从实践开始
- en: Before we delve into the details, let’s start with some hands-on experience.
    It is likely easier to grasp the concept by trying it out rather than just only
    reading about it at first.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们先进行一些实践体验。通过动手操作来理解概念通常比仅仅阅读更容易。
- en: git config – Introduce yourself to Git
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git config——向Git介绍自己
- en: 'Now, there is something you need to do before you start a project. Introduce
    yourself to Git. To introduce yourself to Git, use the `git` `config` command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在开始项目之前，您需要做一件事。向Git介绍自己。要向Git介绍自己，使用`git` `config`命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`git config` is a command used to set Git configurations at the levels of system,
    user, and repository. The level `system` applies to all users and all repositories.
    The level `global` applies to all repositories of a specific user. The level `local`
    applies only to a single repository.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`git config`是用于设置Git配置的命令，适用于系统、用户和仓库级别。`system`级别适用于所有用户和所有仓库。`global`级别适用于特定用户的所有仓库。`local`级别仅适用于单个仓库。'
- en: 'To verify that your introduction has been registered, you can check with the
    `git congif --``list` command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的介绍是否已注册，可以使用`git congif --``list`命令检查：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, the first task is done! Let’s quickly move on to the basic operations of
    Git.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第一个任务完成了！让我们快速进入Git的基本操作。
- en: git init – Where your code journey begins
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git init——您的代码旅程从这里开始
- en: 'Just as every great journey has its origin, in the world of Git, your code’s
    voyage starts with the `git init` command. The command is used to initialize a
    new Git repository and start tracking existing directories. When you run the command,
    it sets up a `.git` directory packed with all the goodies you need for version
    control. With that out of the way, you are all set to dive into Git’s range of
    commands and start tracking and updating your project:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每一段伟大的旅程都有其起点一样，在 Git 的世界里，你代码的旅程从 `git init` 命令开始。此命令用于初始化一个新的 Git 仓库，并开始跟踪现有的目录。当你运行此命令时，它会设置一个包含版本控制所需所有文件的
    `.git` 目录。完成这些后，你就可以开始使用 Git 的各种命令来跟踪和更新你的项目：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Important note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Another way is to pass a directory name as an argument, such as `git init handson-repo`;
    this will create the directory, so you do not need to run the `mkdir` command.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是将目录名作为参数传递，如 `git init handson-repo`；这将创建该目录，因此你不需要运行 `mkdir` 命令。
- en: Now that the `.git/` directory has been created, changes to files are saved
    under the `.git/` directory, but Git does not automatically save files in the
    same way recent Microsoft Office products do.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`.git/` 目录已创建，文件的更改保存在该目录下，但 Git 并不会像近期的 Microsoft Office 产品那样自动保存文件。
- en: In Git, saving is completed by executing the `git add` command, which consciously
    selects files to be saved from among those that have been edited, added, or deleted,
    and the `git commit` command, which registers those changes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 中，保存是通过执行 `git add` 命令完成的，该命令有意识地从已编辑、已添加或已删除的文件中选择要保存的文件，接着 `git commit`
    命令将这些更改注册到历史中。
- en: Next, let’s add some code to the repository.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们往仓库中添加一些代码。
- en: git add – Preparing your code for the spotlight
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git add – 为你的代码准备亮相
- en: The `git add` command is your bridge between making changes in your working
    directory and getting them ready to be permanently stored in your Git repository.
    When you make changes to your files, Git recognizes that these files have been
    changed, but these changes are not automatically slated to become a part of the
    history. This is where `git add` steps in. This is the process of saving an office
    document, so to speak.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`git add` 命令是你在工作目录中进行更改与准备将这些更改永久存储到 Git 仓库之间的桥梁。当你对文件进行修改时，Git 会识别到文件已被更改，但这些更改不会自动成为历史的一部分。这时，`git
    add` 就发挥作用了。可以把它理解为保存一个文档的过程。'
- en: 'First, create a new file in your `handson-repo` directory:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你的 `handson-repo` 目录中创建一个新文件：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `git status` command shows the current state of your repository, showing
    which files have changes that are tracked and which ones are untracked. When you
    see the `Untracked files` message, it is Git’s way of informing you that there
    is a file it has not been told to keep an eye on just yet. In our example, the
    `README.md` file is new to Git and is not registered; hence, it is labeled as
    untracked:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`git status` 命令显示仓库的当前状态，显示哪些文件的更改是已跟踪的，哪些是未跟踪的。当你看到 `Untracked files` 消息时，Git
    就是在告诉你有一个文件它还没有被告知要监视。在我们的例子中，`README.md` 文件是 Git 新增的文件，并未被注册，因此它被标记为未跟踪：'
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Newly added files are part of your project, but they have not been tracked
    by Git. To move them from the untracked status to a tracked status, you use the
    `git` `add` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 新添加的文件是项目的一部分，但 Git 尚未跟踪它们。要将它们从未跟踪状态转移到已跟踪状态，你需要使用 `git add` 命令：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now Git recognizes `README.md` as a new file, and it is now tracked. The state
    targeted for saving by the `git add` command is called `README.md` file from worktree
    using the `git` `add` command.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Git 已经识别 `README.md` 为一个新文件，并且它现在已被跟踪。`git add` 命令所保存的状态就是通过 `git add` 命令将工作树中的
    `README.md` 文件标记为已跟踪。
- en: Important note
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`git add` has other options as well. You can include everything with `git add
    .`, include multiple files such as `git add file1.md file2.md file3.md`, or use
    a wildcard such as `git add *.md` to add all files with the `.``md` extension.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`git add` 还有其他选项。你可以使用 `git add .` 来包括所有文件，或者像 `git add file1.md file2.md file3.md`
    这样包含多个文件，或者使用通配符如 `git add *.md` 来添加所有 `.md` 扩展名的文件。'
- en: Everything’s in place; it is time to log your modifications into history.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一切就绪；现在是时候将你的修改记录到历史中了。
- en: git commit – Locking in your development progress
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git commit – 锁定你的开发进度
- en: The `git commit` command records the changes you have staged with `git add`
    into the repository’s history. This allows you to track changes over time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`git commit` 命令将你通过 `git add` 暂存的更改记录到仓库历史中。这使你能够随着时间跟踪更改。'
- en: Imagine you are playing a challenging video game. As you progress, you will
    often save your game to lock in your achievements. Similarly, when developing
    software, you will save your work using `git commit`. Each commit is a save point
    to which you can return later if needed.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下您在玩一款具有挑战性的视频游戏。随着您的进展，您经常会保存游戏以锁定成就。类似地，在开发软件时，您将使用`git commit`保存工作。每个提交都是一个保存点，以后如果需要可以返回到该点。
- en: 'To commit changes, you can typically do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要提交更改，通常可以执行以下操作：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the `-m` flag is followed by a short, descriptive message that captures
    the essence of the changes you have made. Writing good commit messages is an art,
    as it aids in understanding the history and intent of changes.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-m`标志后面跟着一个简短的描述性消息，捕捉您所做更改的精髓。编写良好的提交消息是一门艺术，因为它有助于理解更改的历史和意图。
- en: 'Now, let’s use the `git status` command again to see if all the changes in
    the current working directory have been saved:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次使用`git status`命令查看当前工作目录中的所有更改是否已保存：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the message `nothing to commit` appears, your changes have been incorporated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现消息 `nothing to commit`，则表示您的更改已经合并。
- en: 'Well, that is it; it is very easy to save a file in Git. Let’s review it here.
    The edit, stage, and commit flow is still the same no matter how complex your
    project is:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就这些；在Git中保存文件非常容易。让我们在这里回顾一下。编辑、暂存和提交流程始终保持不变，无论您的项目有多复杂：
- en: '**Edit files**: Make necessary changes to your files. For example, in this
    figure, two existing files have been edited for deletions and modifications, and
    another file has been added:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编辑文件**：对文件进行必要的更改。例如，在这个示例中，已编辑两个现有文件进行删除和修改，并添加了另一个文件：'
- en: '![Figure 2.1 – Edit files](img/B21203_02_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 编辑文件](img/B21203_02_01.jpg)'
- en: Figure 2.1 – Edit files
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 编辑文件
- en: '**Stage changes**: Decide which files or specific changes you would like to
    commit and stage them. For example, in this figure, out of the three edits, only
    the deletions and modifications are staged:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**暂存更改**：决定要提交的文件或特定更改，并将它们暂存。例如，在这个示例中，三次编辑中只有删除和修改被暂存：'
- en: '![Figure 2.2 – Stage changes](img/B21203_02_02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 暂存更改](img/B21203_02_02.jpg)'
- en: Figure 2.2 – Stage changes
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 暂存更改
- en: '**Commit changes**: Once satisfied with the staged changes, perform a commit
    to register them. Remember that every commit generates a unique commit ID:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**提交更改**：在满意暂存的更改后，执行提交以注册它们。请记住，每次提交都会生成一个唯一的提交 ID：'
- en: '![Figure 2.3 – Commit changes](img/B21203_02_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – 提交更改](img/B21203_02_03.jpg)'
- en: Figure 2.3 – Commit changes
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 提交更改
- en: git log – Walking through the commit tree
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git log – 遍历提交树
- en: Once you have made a few commits, you might want to look back and see the history
    of changes made in the repository. This is where the `git log` command comes in
    handy. The command displays a list of commits made in a repository in reverse
    chronological order, meaning the most recent commit is displayed first.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您进行了几次提交，您可能希望回顾并查看存储库中所做更改的历史记录。这就是`git log`命令派上用场的地方。该命令按时间顺序反向显示存储库中进行的提交列表，即最近的提交首先显示。
- en: 'To try this out, use the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试此操作，请使用以下命令：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will display a list of all commits, each with the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所有提交的列表，每个提交都包含以下内容：
- en: '**A distinct SHA-1 identifier**: This acts as a signature for the commit and
    can be employed in various Git commands to refer to that specific commit'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独特的SHA-1标识符**：这充当提交的签名，并可以在各种Git命令中用来引用特定的提交'
- en: '**Committer’s details**: Showcases the name and email of the individual who
    executed the commit'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交者的详细信息**：显示执行提交的个人的姓名和电子邮件地址'
- en: '**Timestamp of the commit**: Displays when the commit was made'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交的时间戳**：显示提交的时间'
- en: '**Commit message**: A brief and informative note capturing the essence of the
    alterations in the commit'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交消息**：捕捉提交中改动的要点的简短和信息丰富的注释'
- en: 'In addition to the basic `git log` command, there are numerous options that
    allow you to tailor the output to your needs:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本的`git log`命令外，还有许多选项可以让您根据需要定制输出：
- en: '`git log -p`: This option shows the difference (i.e., the patch) introduced
    at each commit'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git log -p`: 这个选项显示每个提交引入的差异（即补丁）。'
- en: '`git log --stat`: This provides some abbreviated stats for each commit'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git log --stat`: 这提供了每个提交的简略统计信息'
- en: '`git log --oneline`: This gives a more compact output, displaying each commit
    as a single line'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git log --oneline`: 这提供更紧凑的输出，将每个提交显示为单行'
- en: '`git log --graph`: This visualizes the branch and merge history in an ASCII
    graph layout'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git log --graph`：该命令以ASCII图形布局可视化分支和合并历史。'
- en: '`git log --author="John Doe"`: This filters the commits to show only those
    made by a specific individual (in this case, “John Doe”)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git log --author="John Doe"`：此命令筛选提交，仅显示由特定人员（在本例中为“John Doe”）进行的提交。'
- en: 'For example, it can also improve the outlook as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，它还可以改善外观，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下所示：
- en: '![Figure 2.4 – Prettified git log](img/B21203_02_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 美化后的git log](img/B21203_02_04.jpg)'
- en: Figure 2.4 – Prettified git log
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 美化后的git log
- en: 'Now let’s try the `git log` command with you at hand. First, update the `README.md`
    file and create a new `CONTRIBUTING.md` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试使用`git log`命令。首先，更新`README.md`文件，并创建一个新的`CONTRIBUTING.md`文件：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once done, add a sample Python code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，添加一个示例Python代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When it is confirmed in the log that it is properly logged, it is done:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当在日志中确认已正确记录时，任务完成：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In essence, the `git log` command is a vital tool for any developer. It helps
    you easily navigate through your code’s history, whether you are searching for
    a specific change or merely revisiting previous work.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`git log`命令是任何开发者都必备的重要工具。它帮助你轻松浏览代码的历史，无论是查找特定的更改，还是仅仅回顾之前的工作。
- en: Now that we have reviewed what we have learned so far in examining the functionality
    of `git log`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了到目前为止关于`git log`功能的内容。
- en: Working with branches – The cornerstone of collaboration
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分支 – 协作的基石
- en: While the previous sections provide you with a robust understanding of how to
    initialize and manage a Git repository, the concept of branching takes this to
    a new level. While accumulating `git commit` only creates a liner history, `git
    branch` can be used to create a history of the parallel environment. Then, you
    can merge those multiple environments into one, which enables multiple people
    to work on them, giving you the flexibility to experiment with new features, bug
    fixes, or even totally *avant-garde* ideas without affecting the main codebase.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的部分已经为你提供了如何初始化和管理Git仓库的深入理解，但分支的概念将这一过程提升到了一个新层次。虽然仅使用`git commit`会创建一个线性历史，`git
    branch`可以用来创建一个并行环境的历史。然后，你可以将这些多个环境合并为一个，这使得多人可以共同开发，同时为你提供了灵活性，能够在不影响主代码库的情况下尝试新功能、修复bug，甚至是完全的*前卫*创意。
- en: git branch – Understanding the basics of Git branch
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git分支 – 理解Git分支的基础
- en: 'When you initialize a Git repository, it automatically creates a default branch,
    usually called `main` (formerly known as master). When you run the `git branch`
    command, it will show the list of all branches in your repository, with the current
    branch highlighted:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你初始化一个Git仓库时，它会自动创建一个默认分支，通常叫做`main`（之前称为master）。当你运行`git branch`命令时，它会显示仓库中所有分支的列表，并高亮当前分支：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is intuitive to think of a linear main branch like the following figure:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地可以将线性主分支视作如下图所示：
- en: '![Figure 2.5 – git branch](img/B21203_02_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – git分支](img/B21203_02_05.jpg)'
- en: Figure 2.5 – git branch
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – git分支
- en: 'You can create a new branch with the `git branch <branch name>` command. This
    command creates a new command from the current branch:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`git branch <分支名称>`命令创建一个新分支。此命令从当前分支创建一个新分支：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you create a new branch, you can build a line with a different history and
    add commits to that branch, as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建一个新分支，你可以建立一条具有不同历史的分支，并向该分支添加提交，示例如下：
- en: '![Figure 2.6 – Creating a new branch](img/B21203_02_06.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 创建新分支](img/B21203_02_06.jpg)'
- en: Figure 2.6 – Creating a new branch
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 创建新分支
- en: Branch naming conventions are important for communication. A commonly used standard
    is to prefix the branch name with `feature/`, `bugfix/`, or `hotfix/`, followed
    by a brief description. This makes it easier for anyone to understand the purpose
    of the branch at a glance.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 分支命名规范对于沟通非常重要。常用的标准是将分支名称前缀为`feature/`、`bugfix/`或`hotfix/`，后跟简短描述。这使得任何人都能一目了然地理解分支的目的。
- en: 'You can also create a branch from a specific branch or commit that is different
    from the one you are currently on. This is particularly useful when you need to
    create a feature or bugfix branch that should originate from a designated development
    or staging branch rather than from your current working branch:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以从一个特定的分支或提交创建分支，与你当前所在的分支不同。这在你需要创建一个特性分支或修复bug的分支时特别有用，这些分支应该从指定的开发或暂存分支而不是从当前工作分支创建：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: git checkout/git switch – Switching between branches
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git checkout/git switch – 在分支之间切换
- en: In your daily workflow, you will often need to switch from one branch to another,
    especially when working on multiple features or fixing bugs. When you have started
    work on multiple branches, gaining an awareness of the branch you are actively
    on becomes pivotal. In Git, the term **HEAD** refers to the tip of the branch
    you are actively working with.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常工作流中，你将经常需要从一个分支切换到另一个分支，特别是在同时处理多个特性或修复 bug 时。当你已经在多个分支上开始工作时，了解你当前所处的分支变得尤为重要。在Git中，**HEAD**是指你当前正在处理的分支的最新提交。
- en: 'Changing your current working branch is known as checking out a branch. The
    `git checkout` command facilitates this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 更改当前工作分支被称为切换分支。`git checkout`命令可以实现这一操作：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This operation switches the HEAD position, the tip of the branch, to a branch
    called `feature/new-feature`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作将HEAD位置，即分支的最新提交，切换到名为`feature/new-feature`的分支：
- en: '![Figure 2.7 – Checking out a branch](img/B21203_02_07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 切换分支](img/B21203_02_07.jpg)'
- en: Figure 2.7 – Checking out a branch
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 切换分支
- en: The `git checkout` command results in the current position being the tip commit
    on the `feature/new-feature` branch, that is HEAD.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`git checkout`命令将当前的位置切换到`feature/new-feature`分支的最新提交，即HEAD。'
- en: 'Recent versions of Git also offer the `git switch` command, which provides
    a more intuitive way to switch branches:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Git的最新版本还提供了`git switch`命令，它提供了一种更直观的方式来切换分支：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sometimes, you may find it efficient to create a new branch and switch to it
    immediately. Git provides a shorthand command for this, combining the functionality
    of `git branch` and `git checkout` or `git switch`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会发现创建一个新分支并立即切换到它更为高效。Git提供了一个简化命令，结合了`git branch`和`git checkout`或`git
    switch`的功能。
- en: 'To create a new branch and switch to it in one step, you can use the `git checkout
    -``b` command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在一步操作中创建并切换到一个新分支，可以使用`git checkout -b`命令：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is equivalent to running the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于执行以下命令：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In recent versions of Git, you can achieve the same with `git switch` by using
    the `-``c` option:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Git的最新版本中，你也可以通过使用`-c`选项和`git switch`实现相同的操作：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now you can not only save changes linearly with `git commit`, but also create
    parallel worlds with `git branch`, and move back and forth between parallel worlds
    freely with `git checkout`. Now, it is time to merge the two worlds.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你不仅可以通过`git commit`线性保存更改，还可以通过`git branch`创建平行世界，并通过`git checkout`在平行世界之间自由切换。现在，是时候合并这两个世界了。
- en: git merge <Branch Name> – Merging branches
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git merge <分支名称> – 合并分支
- en: 'Once you have made changes in a branch and tested them thoroughly, you may
    want to integrate those changes back into the main branch or another branch. This
    operation is known as **merging**:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在某个分支上做出了更改并彻底测试过，你可能希望将这些更改合并回主分支或其他分支。这个操作被称为**合并**：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Merging allows you to merge lines with different histories, as shown in the
    following figure:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 合并允许你将有不同历史的代码行合并在一起，如下图所示：
- en: '![Figure 2.8 – Merging a branch](img/B21203_02_08.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 合并分支](img/B21203_02_08.jpg)'
- en: Figure 2.8 – Merging a branch
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 合并分支
- en: Merging can be a straightforward operation, but it can also get complicated
    if there are conflicts between the branches. In such cases, Git will require manual
    intervention to resolve the conflicts. Conflict resolution will be addressed in
    the next chapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 合并操作可能很简单，但如果分支之间存在冲突，操作会变得复杂。在这种情况下，Git需要手动干预以解决冲突。冲突解决将在下一章讨论。
- en: git branch –d – Deleting a Branch
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git branch –d – 删除一个分支
- en: 'Once a branch has been successfully merged and is no longer needed, it can
    be deleted to keep the repository clean:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个分支成功合并并且不再需要，它可以被删除，以保持仓库的整洁：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, by this point in the hands-on tutorial, you should have understood the basics
    of Git and gotten a feel for it. You should now be aware of what is happening
    in your project and have learned how to use basic commands.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，到目前为止，在实践教程中，你应该已经掌握了Git的基础，并对其有了一定的了解。你现在应该清楚你的项目中发生了什么，并学会了如何使用基本命令。
- en: On the other hand, there is still a lot to learn for you to flexibly collaborate
    within a team. Going forward, you will learn those methods, but it is also necessary
    to understand how Git actually works in order to fundamentally understand those
    operations.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你仍然需要学习如何灵活地在团队中协作。未来，你将学习这些方法，但同样有必要理解Git的实际工作原理，才能从根本上理解这些操作。
- en: Knowing the mechanisms of Git deepens your understanding of what the commands
    are fundamentally doing, not only enhancing your proficiency in Git operations
    but also improving your communication in Git and GitHub and, consequently, in
    DevOps.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Git 的机制可以加深你对命令本质作用的理解，不仅能提升你在 Git 操作中的熟练度，还能改善你在 Git 和 GitHub 中的沟通，从而促进
    DevOps 的发展。
- en: Let’s take a look at how Git works.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Git 是如何工作的。
- en: The anatomy of Git – A beginner-friendly explanation of how Git works
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 的结构 – 一个对初学者友好的解释，讲解 Git 是如何工作的
- en: Git is incredibly powerful, especially as projects become more complex. Up until
    now, our focus was on a straightforward history. However, where Git really shines
    is in its ability to handle large projects with a large number of contributors
    and manage the dynamically evolving code within a team seamlessly. We have come
    this far intuitively, working with Git operations as commands work. It is time
    to get down to the nitty-gritty. While it is helpful to have an intuitive feel
    for Git, by understanding how Git operates behind the scenes, we can harness its
    full potential.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Git 非常强大，尤其是在项目变得更加复杂时。到目前为止，我们的重点是直观的历史记录。然而，Git 真正的优势在于其处理大型项目的能力，尤其是当有大量贡献者参与并且能够无缝地管理团队中动态发展的代码时。我们通过直观的方式，像使用命令一样操作
    Git。现在是时候深入探讨了。虽然对 Git 有直观的了解是有帮助的，但通过理解 Git 在幕后是如何运作的，我们可以充分发挥它的潜力。
- en: The file lifecycle in Git
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git 中的文件生命周期
- en: In Git, we learned in the previous section that saving changes is a two-step
    action, staging and committing, but Git actually handles files in four states.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 中，我们在上一节中学到，保存更改是一个两步操作，即暂存和提交，但 Git 实际上将文件处理为四种状态。
- en: 'Every file in your project can be in one of four states:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你项目中的每个文件都可以处于四种状态之一：
- en: '**Untracked**: Files that are present in your directory but have not been added
    to Git’s control. They are new files or files that Git has been explicitly told
    to ignore.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未跟踪**：这些是存在于你的目录中的文件，但尚未被 Git 控制。它们是新文件，或是 Git 被明确告知忽略的文件。'
- en: '**Unmodified**: These are files that have previously been added to Git and
    have not experienced any changes since the last commit. They sit quietly, monitored
    by Git but not requiring any immediate action. In other words, they are **committed**.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未修改**：这些是之前已经被添加到 Git 中，并且自上次提交以来没有任何变化的文件。它们安静地存在，被 Git 监控，但不需要立即采取任何行动。换句话说，它们是**已提交的**。'
- en: '**Modified**: Once you make changes to a tracked file, Git flags it as modified.
    At this point, the file has been altered since the last commit but has not been
    prepared (or staged) for the next commit.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已修改**：一旦你对已跟踪的文件进行更改，Git 就会将其标记为已修改。此时，该文件自上次提交以来已经被更改，但尚未为下一次提交做好准备（或暂存）。'
- en: '`git add` command stages your modifications. While these changes have been
    earmarked, they are not saved in the repository until you commit.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git add` 命令会暂存你的修改。虽然这些更改已被标记，但在你提交之前，它们并未被保存到仓库中。'
- en: 'The following figure shows these status transitions. Files go back and forth
    between these states:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了这些状态的转换。文件在这些状态之间来回变化：
- en: '![Figure 2.9 – Four types of the file status of Git](img/B21203_02_09.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – Git 中文件状态的四种类型](img/B21203_02_09.jpg)'
- en: Figure 2.9 – Four types of the file status of Git
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – Git 中文件状态的四种类型
- en: When you create or introduce new files to your project, they begin as `git add`
    command, they transition to the **unmodified**status, signifying that they are
    now under Git’s surveillance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建或引入新文件到项目中时，使用 `git add` 命令后，它们会过渡到**未修改**状态，表示它们现在在 Git 的监控之下。
- en: Subsequent changes to these tracked files will place them in the **modified**
    status. Before they can be committed, these changes need to be staged, moving
    the file to the **staged** status. Staging gives you a preview of the changes
    you are about to commit. Think of it as putting items in a box (staging area),
    and prepping them for shipment (commit). You decide which items (or changes) go
    into that box.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些已跟踪文件的后续更改会将它们置于**已修改**状态。在它们被提交之前，这些更改需要被暂存，从而将文件移动到**已暂存**状态。暂存让你预览即将提交的更改。可以把它想象成将物品放入箱子（暂存区）并准备运送（提交）。你决定哪些物品（或更改）将放入那个箱子。
- en: After staging, you can commit these changes using the `git commit` command.
    When you stage changes, especially through interfaces such as Visual Studio Code,
    it is typically as simple as clicking a button. Once you are satisfied with the
    staged changes, you commit them, permanently saving them to your project history.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在暂存之后，你可以使用 `git commit` 命令提交这些更改。当你通过 Visual Studio Code 等界面进行暂存更改时，通常只需点击一个按钮。一旦你对暂存的更改感到满意，就可以提交它们，永久地将它们保存到你的项目历史中。
- en: Upon committing, these files revert to the **unmodified** status, waiting for
    future edits or changes. In other words, at this stage, the status can be said
    to have become **committed**. In Git, every commit you make records the current
    state of your project at that specific point in time. This recording mechanism
    is foundational to Git’s capabilities, ensuring that every change is documented.
    This allows developers to navigate back to any specific commit, providing the
    flexibility to review or revert to previous versions as required.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 提交后，这些文件将恢复为 **未修改** 状态，等待将来的编辑或更改。换句话说，在此阶段，可以说其状态已经变为 **已提交**。在 Git 中，你所做的每个提交都记录了项目在特定时间点的当前状态。这个记录机制是
    Git 能力的基础，确保每个更改都被文档化。这使得开发者可以回到任何特定的提交，提供了回顾或恢复到以前版本的灵活性。
- en: Additionally, if a tracked file is removed from the directory, Git recognizes
    it as **untracked** until it is explicitly deleted from the repository.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果一个被跟踪的文件从目录中被删除，Git 会将其视为 **未跟踪**，直到它被明确地从仓库中删除。
- en: This lifecycle provides developers with precise control over their project changes,
    allowing for strategic commits and ensuring clear, organized version histories.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生命周期为开发者提供了对项目更改的精确控制，允许进行战略性的提交，并确保清晰、有序的版本历史。
- en: Behind the scenes – Git’s architecture
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幕后 – Git 的架构
- en: First and foremost, what is Git really? At its core, Git is a `.git` directory.
    This concealed directory contains the history of your code–commits, branches,
    configuration files, and more. You may recall from the initial stages of your
    Git journey, during the `git init` command section, that a `.git` directory is
    created.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Git 到底是什么？从本质上讲，Git 就是一个 `.git` 目录。这个隐藏目录包含了你的代码历史记录——提交、分支、配置文件等。你可能记得在
    Git 学习初期，在执行 `git init` 命令时，会创建一个 `.git` 目录。
- en: A deeper dive – Exploring the .git directory
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深入探索 – 探索 .git 目录
- en: 'By running the `ls` command, you can see several sub-directory and configuration
    files. Among these, the `objects` directory is most relevant to our current discussion.
    This is the heart of Git’s key-value store, housing the blobs (actual file content),
    tree objects (directory structures), and commits:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行 `ls` 命令，你可以看到多个子目录和配置文件。其中，`objects` 目录与我们当前的讨论最为相关。它是 Git 键值存储的核心，存放着
    blob（实际文件内容）、树对象（目录结构）和提交记录：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let’s peek into the `objects` folder. This is where the key-value store
    resides. The names of the folders, which are two alphanumeric characters, represent
    the first two characters of the commit ID:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看 `objects` 文件夹。这就是键值存储所在的地方。文件夹的名称由两个字母数字字符组成，代表提交 ID 的前两个字符：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each commit or data piece in Git is uniquely identified by a key, the SHA-1
    hash. This hash, a string of 40 alphanumeric characters, is something like `b641640413035d84b272600d3419cad3b0352d70`.
    This unique identifier for each commit is generated by Git based on the commit’s
    content. These IDs you see include what you see when you run the `git log` command
    and match the changes you have made so far:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 中，每个提交或数据块都通过一个键（SHA-1 哈希）来唯一标识。这个哈希值是一个由 40 个字母数字字符组成的字符串，类似于 `b641640413035d84b272600d3419cad3b0352d70`。这个每个提交的唯一标识符是
    Git 根据提交内容生成的。你在执行 `git log` 命令时看到的这些 ID 对应着你迄今为止所做的更改：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we open the `b6` directory, we will recognize the structure of the key-value
    store, with the commit ID serving as the file name or the key. But what lies within
    these files? To find out, let’s next take a peek inside with the `git` `cat-file`
    command.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开 `b6` 目录，我们会认出键值存储的结构，其中提交 ID 作为文件名或键。但这些文件里到底有什么呢？为了弄清楚，我们接下来可以使用 `git
    cat-file` 命令来查看其中的内容。
- en: Important note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'In the case of this book, the first two characters of Hash are **b6**, but
    a different list should be displayed in your environment. Let’s choose an appropriate
    hash and run the **ls** command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，Hash 的前两个字符是 **b6**，但在你的环境中会显示不同的列表。让我们选择一个合适的哈希值并执行 **ls** 命令：
- en: '**$** **ls .git/objects/b6/**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**$** **ls .git/objects/b6/**'
- en: '**41640413035d84b272600d3419cad3b0352d70**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**41640413035d84b272600d3419cad3b0352d70**'
- en: git cat-file – Dissecting the inner workings
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git cat-file – 解剖 Git 的内部工作原理
- en: 'To inspect the contents of the value in the key-value store, the `git cat-file`
    command can be used. When passing the first seven letters of the commit ID as
    an argument, we get results showcasing the tree and parent, which refers to the
    ID of the parent commit:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查键值存储中值的内容，可以使用 `git cat-file` 命令。当传递提交 ID 的前七个字符作为参数时，我们得到的结果展示了树对象和父对象，它们分别引用了父提交的
    ID：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Important note
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When dealing with hashes in Git commands, it is not necessary to pass the 40
    characters as they are; they can be omitted. In this sample case, the first seven
    letters are passed as an argument, but a minimum requirement is four letters.
    Although it depends on the size of the project, it is relatively safe to specify
    at least seven characters to avoid key collisions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 命令中处理哈希时，不需要传递完整的 40 个字符；可以省略。这个例子中传递了前七个字符作为参数，但最少要求是四个字符。虽然具体情况取决于项目的大小，但为了避免键冲突，建议至少指定七个字符。
- en: 'In Git, there are four main objects that are managed and used:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 中，主要管理和使用四种对象：
- en: '`commit` object: Has a reference to the tree object'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`commit` 对象：引用了 tree 对象'
- en: '`tree` object: Has references to blob and/or other tree objects'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tree` 对象：包含对 blob 和/或其他 tree 对象的引用'
- en: '`blob` object: Has the data (like file content)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blob` 对象：包含数据（如文件内容）'
- en: '`tag` object: Has information about the annotated tag'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tag` 对象：包含有关注释标签的信息'
- en: 'The commit references are structured to embed the Id of the `parent` commit
    in the value. But where did the actual commit file go? In the output, we see a
    `tree` labeled Id as well as `parent`. It seems that this tree also has a SHA-1
    hash, so let’s examine its value using the `git` `cat-file` command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 提交引用结构中嵌入了 `parent` 提交的 ID。但实际的提交文件去了哪里呢？在输出中，我们看到标有 `tree` 的 ID 和 `parent`。看起来这个
    tree 对象也有一个 SHA-1 哈希值，因此让我们使用 `git` 的 `cat-file` 命令来检查其值：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Upon invoking the `git cat-file` command for the Id tagged with `tree`, we
    get a result showcasing a file type named `blob`. Let’s reference the blob ID
    for `README.md` using the `git cat-file` command. This reveals the file content,
    indicating that data stored as the blob type within the key-value store represents
    the actual file. These observations give us a clearer picture of Git’s architecture:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 `git cat-file` 命令查看与 `tree` 标签关联的 ID 时，我们得到的结果展示了一种名为 `blob` 的文件类型。让我们通过
    `git cat-file` 命令引用 `README.md` 的 blob ID。这样可以显示文件内容，表明存储在键值存储中的 blob 类型数据实际上是文件本身。这些观察结果让我们对
    Git 的架构有了更清晰的了解：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now you know how Git stores value in the key-value store. You should understand
    that Git is not a black box; it is a system that manages history as value, keyed
    by a SHA-1 hash.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道 Git 如何在键值存储中存储值。你应该理解，Git 并不是一个黑匣子；它是一个通过 SHA-1 哈希键来管理历史记录的系统。
- en: git show – Easier to use in your daily activities
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git show – 在日常使用中更易于操作
- en: 'Previously, we used the `git cat-file` command to learn how Git works, but
    there is a similar command, `git show`. Both are powerful Git commands, but they
    serve somewhat different purposes and provide different outputs. `git cat-file`
    is a low-level utility that is primarily designed to inspect Git objects, such
    as blobs, trees, commits, and tags. It can display the object’s type, its size,
    and even its raw content. On the other hand, `git show` is more user-friendly
    in nature; this command provides a readable view of various types of Git objects.
    By default, it showcases the log message and textual difference for a commit.
    However, it is versatile enough to display other object types, such as blobs,
    trees, and tags, in an easy-to-read format:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们使用了 `git cat-file` 命令来了解 Git 的工作原理，但有一个类似的命令是 `git show`。这两个命令都是强大的 Git
    工具，但它们的作用有所不同，输出也不同。`git cat-file` 是一个低级工具，主要用于检查 Git 对象，如 blobs、trees、commits
    和 tags。它可以显示对象的类型、大小，甚至是原始内容。而 `git show` 更加用户友好；该命令以可读的方式展示各种 Git 对象的内容。默认情况下，它展示提交的日志信息和文本差异。然而，它也足够灵活，可以以易于阅读的格式展示其他对象类型，如
    blobs、trees 和 tags：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you are a developer or a Git user wanting to see the changes introduced by
    a commit or view the content of a file at a particular revision, `git show` is
    the more intuitive choice. In contrast, `git cat-file` dives deeper into the internal
    structure of Git, allowing users to directly interact with and inspect the raw
    Git objects. For someone deeply involved in the inner workings of Git or developing
    tools that interface with Git’s core system, `git cat-file` provides a granular
    level of detail. However, for the majority of everyday tasks and for those who
    are just starting their journey with Git and GitHub, `git show` offers a more
    user-friendly way to view changes and content without the need to delve into the
    intricacies of Git’s object database.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是开发人员或 Git 用户，想查看某个提交引入的更改或查看特定版本的文件内容，`git show` 是一个更直观的选择。相比之下，`git cat-file`
    更深入地探讨了 Git 的内部结构，允许用户直接与原始 Git 对象进行交互和检查。对于那些深入参与 Git 内部工作或开发与 Git 核心系统接口工具的人来说，`git
    cat-file` 提供了一个详细的层次。然而，对于大多数日常任务，以及那些刚刚开始接触 Git 和 GitHub 的用户，`git show` 提供了一种更友好的方式来查看更改和内容，无需深入了解
    Git 对象数据库的复杂性。
- en: Git tree structure
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git 树结构
- en: Now, we know that Git is essentially a key-value store. Next, let’s look at
    how each object is connected and managed in a consistent manner as historical
    data. In the previous section, we saw the keywords `tree` and `parent`, but what
    are they really? We will now explore the relationship between commits and objects
    to which those keywords link to.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道 Git 本质上是一个键值存储。接下来，让我们看看每个对象是如何连接和管理的，以便作为历史数据的一致性存储。在上一节中，我们看到过关键字
    `tree` 和 `parent`，但它们到底是什么呢？现在，我们将探索提交与这些关键字所链接的对象之间的关系。
- en: Commit, tree, and blob
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交、树和数据块
- en: In Git, the concept of a tree structure plays a vital role in maintaining the
    state of the repository. Each commit is not just a set of changes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 中，树结构的概念在维护仓库状态方面起着至关重要的作用。每个提交不仅仅是一组更改。
- en: 'Explanation of each keyword:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关键字的解释：
- en: '**Commit**: Every commit in Git is uniquely identified by an SHA-1 hash. It
    carries with it a snapshot of the repository’s state by referencing a tree object.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交**：Git 中的每个提交都有一个唯一的 SHA-1 哈希值。它通过引用一个树对象携带着仓库状态的快照。'
- en: '**Tree**: Trees in Git act like directories. They can reference other trees
    (subdirectories) and blobs (files). Each tree has its distinct SHA-1 hash. The
    primary tree, representing the repository’s top-tier directory, is the root tree.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树**：Git 中的树像目录一样工作。它们可以引用其他树（子目录）和数据块（文件）。每个树都有其独特的 SHA-1 哈希值。表示仓库顶级目录的主树被称为根树。'
- en: '**Blob**: A blob represents the content of a file in the repository. Like commits
    and trees, each blob has its unique SHA-1 hash.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据块**：数据块表示仓库中文件的内容。像提交和树一样，每个数据块都有其独特的 SHA-1 哈希值。'
- en: Parent and child
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父与子
- en: The lineage and progression of a repository’s history are captured through the
    parent-child relationships between commits.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库历史的传承和进展通过提交之间的父子关系得以记录。
- en: Most commits in Git reference a single parent commit, representing the direct
    predecessor in the repository’s timeline.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 Git 提交都引用单个父提交，表示仓库时间线中的直接前驱。
- en: As explained in the previous page, a commit holds the ID of its parent commit,
    establishing a referential relationship. In many visual representations of commits,
    arrows often depict this relationship. It is worth noting that the direction of
    these arrows often appears inverse to the sequence of commits. Each commit has
    the relationship shown in the figure.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一页所解释的，提交持有其父提交的 ID，建立了引用关系。在许多提交的可视化表示中，箭头通常表示这种关系。值得注意的是，这些箭头的方向通常与提交的顺序相反。每个提交都具有图中所示的关系。
- en: '![Figure 2.10 – Git commit relation](img/B21203_02_10.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – Git 提交关系](img/B21203_02_10.jpg)'
- en: Figure 2.10 – Git commit relation
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – Git 提交关系
- en: Important note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Commits can sometimes have multiple parents, especially when two branches merge.
    This dual parentage signifies the joining of two separate lines of development.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 提交有时会有多个父级，特别是在两个分支合并时。这种双重父级标志着两个独立开发线的合并。
- en: How does Git store trees and blobs?
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git 如何存储树和数据块？
- en: The marvel of Git’s efficiency is deeply rooted in how it stores its trees and
    blobs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Git 高效性的奇妙之处在于它如何存储其树和数据块。
- en: 'Let’s illustrate the relationship between each of these:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下方式说明这些关系：
- en: '![Figure 2.11 – Git tree structure](img/B21203_02_11.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – Git 树结构](img/B21203_02_11.jpg)'
- en: Figure 2.11 – Git tree structure
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – Git 树结构
- en: Every commit in Git corresponds to a tree, representing the state of the repository’s
    files and directories at that specific moment. For a deeper dive, consider the
    diagram presented. The commit labeled `fb36640` holds a reference to the tree
    `d6f50a2`. This tree mirrors the repository’s root directory during that commit.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Git 中的每个提交都对应一个树，表示在特定时刻仓库中文件和目录的状态。要更深入地了解，可以参考所提供的图表。标签为 `fb36640` 的提交包含了对树
    `d6f50a2` 的引用。这个树反映了该提交时仓库的根目录状态。
- en: As we traverse this tree (`d6f50a2`), we encounter various pointers. Some of
    these lead us to blobs, while others to trees. A blob, such as `2d69956`, corresponds
    to a file—in this case, `LICENSE`. Meanwhile, a tree, such as `1d0f85d`, stands
    for a subdirectory named `contents`. This subdirectory tree can further point
    to its own set of blobs and trees.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遍历这棵树（`d6f50a2`）时，我们会遇到各种指针。有些指向 blobs，有些指向 trees。像 `2d69956` 这样的 blob 对应一个文件——在这种情况下是
    `LICENSE`。而像 `1d0f85d` 这样的 tree 则代表一个名为 `contents` 的子目录。这个子目录树可以进一步指向它自己的一组 blobs
    和 trees。
- en: 'This intricate linkage crafts a hierarchy reminiscent of a traditional filesystem.
    Each layer of this hierarchy denotes different files and directories in your repository.
    Central to Git’s design philosophy is efficiency. By structuring its data in this
    hierarchical manner, Git can swiftly track changes across files and directories
    without redundant storage. For instance, unchanged files across commits point
    to the same blob, optimizing storage and retrieval:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种复杂的关联构建了一个类似传统文件系统的层级结构。这个层级的每一层代表着你仓库中不同的文件和目录。Git 设计哲学的核心是高效。通过以这种层级结构存储数据，Git
    能够快速跟踪文件和目录的变化，而无需冗余存储。例如，不变的文件在不同的提交中会指向相同的 blob，从而优化了存储和检索：
- en: '![Figure 2.12 – Efficient file management in Git](img/B21203_02_12.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.12 – Git 中的高效文件管理](img/B21203_02_12.jpg)'
- en: Figure 2.12 – Efficient file management in Git
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 – Git 中的高效文件管理
- en: Understanding Git’s tree structure and how it relates to blobs and commits is
    fundamental for any developer. It is not just about using Git commands; it is
    about appreciating the ingenious architecture beneath, ensuring that your code’s
    history is efficiently and accurately preserved. As you progress in your Git journey,
    this knowledge will empower you to utilize Git’s capabilities to their fullest.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Git 的树结构以及它与 blobs 和 commits 之间的关系是每个开发者的基础知识。这不仅仅是使用 Git 命令；更重要的是理解其背后的巧妙架构，确保代码的历史得到高效且准确的保存。当你在
    Git 的旅程中不断前进时，这些知识将帮助你充分利用 Git 的功能。
- en: Up to this point, you have learned that Git recognizes the state of each file
    and registers it in a key-value store. You also learned that this key-value store
    has a tree structure with parent-child relationships. If you peek into the `.git/`
    directory, you will see that it has a very simple structure, and it is thanks
    to this simplicity that Git can manage complex projects.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了 Git 如何识别每个文件的状态，并将其记录在一个键值存储中。你还了解到，这个键值存储采用树形结构，具有父子关系。如果你深入 `.git/`
    目录，你会发现它有一个非常简单的结构，正是因为这个简单，Git 才能高效管理复杂的项目。
- en: If you have understood all this, then you are well-prepared for your journey
    to mastering Git. While this book cannot cover every Git command, understanding
    these basics will ensure you will be okay even if you encounter unfamiliar Git
    commands in the future. You have the technical foundation to understand them.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经理解了这些，那么你已经为掌握 Git 之旅做好了充分准备。尽管本书无法覆盖每个 Git 命令，但理解这些基础将确保你在未来遇到不熟悉的 Git
    命令时也能应对自如。你已经具备了理解它们的技术基础。
- en: Now, let’s learn one more thing to conclude your preparation for your Git journey
    in this chapter. That is the mindset for the journey with Git. This mindset is
    not only for using Git but is directly related to collaboration in DevOps as well.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习另一个内容，以结束你在本章中对 Git 之旅的准备工作。那就是 Git 之旅的思维方式。这个思维方式不仅适用于使用 Git，还直接与 DevOps
    中的协作相关。
- en: Becoming a guru of Git communication
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为 Git 通信的专家
- en: Let’s hit the pause button for a moment. While most resources might hurry you
    along to cover essential Git commands, conflict resolutions, merge types, and
    Git workflows, we are taking a breather to focus on the core of the matter.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍作停顿。尽管大多数资源可能会催促你快速学习 Git 的基本命令、冲突解决、合并类型和 Git 工作流，但我们选择暂时休息一下，专注于问题的核心。
- en: So, why was Git even developed in the first place? At its essence, Git was created
    to streamline communication in complex development projects. Since this book aims
    to elevate your role within a DevOps team, understanding the communicative power
    of Git is key. After all, DevOps is not just about technology; it is about improving
    collaboration, breaking down silos, and facilitating smoother workflows.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么 Git 一开始会被开发出来呢？从本质上来说，Git 是为了简化复杂开发项目中的沟通而创建的。由于本书的目的是提升你在 DevOps 团队中的角色，理解
    Git 在沟通方面的力量至关重要。毕竟，DevOps 不仅仅是技术问题；它关乎于改善协作、打破壁垒和促进更顺畅的工作流程。
- en: As you navigate through Git commands and repositories, bear in mind that you
    are not just sharing code; you are also communicating with your team. Your commits,
    pull requests, and merges should be thought of as dialogues in a broader conversation
    aimed at creating something magnificent.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 Git 命令和仓库中导航时，要记住，你不仅仅是在分享代码；你还在与团队进行沟通。你的提交、拉取请求和合并应该被视为在一个更广泛对话中的部分，旨在共同创造出某个宏伟的作品。
- en: So, as you proceed with learning Git, focus on honing your mindset. A well-tuned
    approach to Git goes beyond mere commands; it makes you an invaluable team player,
    aligned with the overarching objectives of your DevOps environment.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在学习 Git 的过程中，专注于磨练你的思维方式。一个经过精心调整的 Git 方法不仅仅是掌握命令，它还能让你成为一名无价的团队成员，与 DevOps
    环境中的整体目标保持一致。
- en: 'Remember: haste makes waste. Take the time to understand the Git essentials
    deeply, and you will not only be a proficient coder but also an exceptional collaborator
    in your DevOps team.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：欲速则不达。花时间深入理解 Git 的基础知识，你不仅能成为一名熟练的编码员，还能成为你 DevOps 团队中的杰出合作者。
- en: git commit – Revisiting the most important command
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: git commit – 重新审视最重要的命令
- en: If you ask me, the most important command in Git is `git commit`. If it is perfect,
    everything else is secondary. This command delineates the scope of all your coding
    activities and solidifies your output, determining the quality of your work. A
    commit serves as a unit of communication. Getting this unit of communication wrong
    can confuse all subsequent communication.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问我，Git 中最重要的命令是 `git commit`。如果这个命令做得完美，其他的一切都是次要的。这个命令界定了你所有编码活动的范围，并巩固了你的输出，决定了你工作的质量。一次提交就像是一个沟通单元。如果这个沟通单元出错，所有后续的沟通都会变得混乱。
- en: 'Have you ever built something using LEGO bricks? The essence of LEGO is not
    only just about following instructions but also about sparking creativity and
    building something original. Sometimes, you collaborate with friends, like building
    a castle together. Everyone might have a role: someone makes the gate, another
    the foundation, and someone else the tower. Your success lies in building a magnificent
    castle as a team. But consider this: even if you individually craft a brilliant
    part, it may not be appreciated if it does not align with others’ visions or does
    not fit with the pieces they have created. It is essential to ensure that the
    parts match in size and to frequently verify this compatibility. In other words,
    you need to continually adjust the way and parts of the build while communicating
    at the right times. As kids, you might have made strange creations without perfect
    communication, and while it might have been praised for its creativity, the situation
    is different now. If you are reading this book, you likely work in an organization,
    creating some product, possibly earning a salary, and holding responsibility.
    This means these considerations are not just nice to have; they are a must.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有用乐高积木做过什么东西？乐高的精髓不仅仅在于按照说明书操作，更在于激发创造力并打造独特的作品。有时，你还需要和朋友一起合作，像一起建造一个城堡。每个人可能都有一个角色：有人负责做城门，有人负责做地基，还有人负责做塔楼。你们的成功在于作为一个团队共同打造出一个宏伟的城堡。但考虑一下：即使你个人做了一部分很棒的作品，如果它不符合其他人设想的效果，或者和他们做的部分不匹配，它可能不会得到认可。确保各个部分的尺寸匹配并经常检查其兼容性是至关重要的。换句话说，你需要在正确的时机进行沟通，并不断调整建造的方式和各个部件。小时候，你可能做过一些奇怪的作品，虽然缺乏完美的沟通，但由于富有创意还是会受到赞扬。然而现在情况不同了。如果你正在阅读这本书，你很可能在一个组织中工作，创造某种产品，可能有工资收入，并且承担责任。这意味着，这些考虑因素不仅仅是可有可无的，它们是必须要有的。
- en: Let’s transition back to coding. When you code within a team, not only you but
    all team members, past and present, will review your code and actions in Git.
    Even when you code alone, your future self and past self are your collaborators.
    Many times, I have struggled to understand my old code or recall what I was trying
    to accomplish by running `git log` command and still have no idea. How well Git
    operations are managed will be reflected in the code management and production
    process. It would be better to have a principle that you can remember when using
    Git.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到编程。当你在团队中编程时，不仅你自己，所有团队成员（包括过去和现在的）都会审查你在 Git 中的代码和操作。即使你一个人编程，你的未来自我和过去自我也是你的合作伙伴。我曾多次因为不理解自己以前写的代码或忘记自己当时想要实现什么，通过运行
    `git log` 命令后还是毫无头绪。Git 操作管理得如何，将直接反映在代码管理和生产流程中。最好有一个你可以记住的原则来使用 Git。
- en: Control quality and quantity to be a good communicator
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制质量和数量，成为一个优秀的沟通者
- en: 'There are plenty of good practices out there on how to use Git. However, many
    things can be categorized somewhere in the four boxes of the following diagram:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用 Git，存在很多良好的实践。然而，许多内容可以归类于下图的四个框中的某个位置：
- en: '![Figure 2.13 – Excellence in git commit](img/B21203_02_13.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – Git 提交的卓越实践](img/B21203_02_13.jpg)'
- en: Figure 2.13 – Excellence in git commit
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – Git 提交的卓越实践
- en: Early and often commit – Embracing a core principle for DevOps success
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 早期和频繁提交 —— 采用 DevOps 成功的核心原则
- en: The modern software development landscape has changed drastically over the past
    few decades. Traditional Waterfall have made way for Agile methodologies, and
    this has further evolved into the DevOps culture that many organizations now embrace.
    Central to this evolution is the notion of **Continuous Integration and Continuous
    Delivery** (**CI**/**CD**). One of the foundational practices supporting this
    methodology is the idea of committing code early and often. In this section, we
    will delve into the importance of this practice, especially in the context of
    Git and GitHub for DevOps.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 过去几十年，现代软件开发的格局发生了巨大的变化。传统的瀑布式开发方法已被敏捷方法取代，进一步演变为如今许多组织所采用的 DevOps 文化。这个演变的核心概念就是
    **持续集成和持续交付** (**CI**/**CD**)。支持这一方法论的基础实践之一就是早期和频繁提交代码的理念。本节将深入探讨这一实践的重要性，尤其是在
    DevOps 的 Git 和 GitHub 上的应用。
- en: The traditional paradigm
  id: totrans-234
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传统范式
- en: In the days of yore, developers would often spend days or even weeks working
    on a feature or a fix, only to merge their changes into the main branch at the
    end. This would often lead to merge conflicts, bugs, and a lot of manual intervention
    to rectify issues. This model was not scalable and was antithetical to the fast-paced,
    customer-centric demands of today’s tech environment.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，开发人员通常会花费几天甚至几周的时间来开发一个功能或修复，然后在最后将其合并到主分支。这通常会导致合并冲突、错误和大量手动干预以修复问题。这种模式不可扩展，与今天快速发展的、以客户为中心的技术环境需求背道而驰。
- en: The shift to early commits
  id: totrans-236
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向早期提交的转变
- en: Committing early means that as soon as you have a logical chunk of work completed,
    you commit it. This does not necessarily mean the entire feature is done, but
    maybe just a function or a class. Why is this beneficial?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽早提交意味着，当你完成一部分逻辑性的工作时，你就应该提交。这并不一定意味着整个功能已经完成，可能只是某个函数或类。为什么这样做有益？
- en: '**Smaller changes**: Smaller changes are easier to review. They are more digestible,
    making the code review process more efficient and effective.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更小的更改**：较小的更改更容易审查。它们更易于理解，使得代码审查过程更高效、更有效。'
- en: '**Reduced merge conflicts**: By committing and pushing your changes early,
    you reduce the chances of running into a merge conflict since you are frequently
    syncing your branch with the main branch.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少合并冲突**：通过尽早提交和推送你的更改，你可以减少遇到合并冲突的机会，因为你会频繁地将分支与主分支同步。'
- en: '**Faster feedback loop**: The sooner you commit and push your changes, the
    sooner automated tests can run, and the sooner you can get feedback on your code.
    This allows for quicker iterations and faster delivery of features and fixes.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的反馈循环**：你越早提交和推送更改，自动化测试就能越早运行，你就能越早获得关于代码的反馈。这有助于更快地迭代和更快地交付功能和修复。'
- en: The benefit of often commits
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 经常提交的好处
- en: 'Committing often goes hand-in-hand with committing early. The more frequently
    you commit, the more the following points are kept to:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 经常提交与尽早提交是相辅相成的。你提交的频率越高，以下几点就越容易做到：
- en: '**Easier to pinpoint issues**: If a bug arises, it is much simpler to identify
    the cause when you are sifting through a small commit rather than a massive one.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易找到问题**：如果出现bug，通过筛选一个小的提交要比筛选一个大的提交要简单得多。'
- en: '**Easier to roll back**: If a commit causes an unforeseen issue, rolling back
    to a previous stable state is straightforward. This safety net can be a lifesaver
    in production environments.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更容易回滚**：如果一个提交引起了意外问题，回滚到之前的稳定状态非常简单。这种安全网在生产环境中可能是一个救命稻草。'
- en: Awesome commit message – Crafting clear, informative, and concise narratives
    for your code
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了不起的提交信息 - 为您的代码打造清晰、信息丰富和简洁的叙述
- en: In the realm of software development, the code we write is not merely a set
    of instructions for machines; it is also a form of communication with our peers.
    However, while code shows the *how*, it is the commit message that illuminates
    the *why*. A well-crafted commit message is a beacon for fellow developers, providing
    context, clarity, and a historical record of code changes.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发领域，我们编写的代码不仅仅是机器的一组指令；它也是与同行交流的一种形式。然而，代码展示了*如何*做到，而提交信息则阐明了*为什么*这样做。一个精心制作的提交信息是同行开发者的灯塔，提供上下文、清晰度和代码变更的历史记录。
- en: The purpose of commit messages
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提交信息的目的
- en: 'At its core, a commit message serves several key functions:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，提交信息具有几个关键功能：
- en: '**Historical record**: It offers a chronological account of changes, allowing
    developers to understand the evolution of a codebase.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史记录**：它提供了变更的按时间排序的账户，使开发人员能够理解代码库的演变。'
- en: '**Context**: It provides reasoning for changes, granting insights that the
    code alone might not convey.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：它提供了变更的理由，提供了单单代码本身无法传达的洞察力。'
- en: '**Documentation**: Beyond inline comments and external documentation, commit
    messages act as a form of documentation that can explain decisions and trade-offs.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：除了内联注释和外部文档之外，提交信息还充当一种文档形式，可以解释决策和权衡。'
- en: Characteristics of an awesome commit message
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 优秀提交信息的特征
- en: 'What differentiates a good commit message from an awesome one? Here are the
    hallmarks of an exceptional commit message:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的提交信息与一个了不起的提交信息有何不同？以下是出色提交信息的标志：
- en: '**Concise subject line**: Begin with a brief and direct subject line, ideally
    under 50 characters, capturing the essence of the commit.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁的主题行**：以简洁直接的主题行开头，理想情况下不超过50个字符，捕捉提交的核心内容。'
- en: '`git commit -m "subject-line" -m "``description-body"` command.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git commit -m "subject-line" -m "``description-body"` 命令。'
- en: '**Use the active voice**: Phrases such as “*Add feature*” or “*Fix bug*” are
    clearer and more direct than “*Added feature*” or “*Fixed bug*.”'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用主动语态**：像“*添加功能*”或“*修复错误*”这样的短语比“*添加了功能*”或“*修复了错误*”更清晰、更直接。'
- en: '**Reference issues**: If the commit relates to a specific issue or task in
    a tracking system, reference its ID or link, aiding in traceability.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用问题**：如果提交与跟踪系统中的特定问题或任务相关，请引用其ID或链接，有助于可追溯性。'
- en: The DevOps connection
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: DevOps的联系
- en: For the contemporary DevOps engineer, commit messages are not just an afterthought;
    they are a core component of the DevOps philosophy.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代的DevOps工程师，提交信息不仅仅是一个附带的想法；它们是DevOps哲学的核心组成部分。
- en: In today’s software landscape, the line between application development and
    infrastructure has become increasingly blurred. Engineers skilled in infrastructure
    might find themselves reading application code and vice versa. More importantly,
    tools across both domains are now integrating with Git, enabling professionals
    to view commit messages alongside Git hashes on various platforms.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的软件领域中，应用程序开发和基础设施之间的界线变得日益模糊。精通基础设施的工程师可能会发现自己阅读应用程序代码，反之亦然。更重要的是，现在两个领域的工具都与Git集成，使专业人士能够在各种平台上查看提交信息以及Git哈希值。
- en: Given this integration, a commit message no longer remains confined to its repository
    or team. It embarks on a journey across different organizational boundaries and
    platforms. This transition highlights the value of a well-crafted commit message
    as a universal language that can be understood and appreciated by diverse stakeholders
    in the software development and delivery pipeline. In the quest to break organizational
    silos and improve developer experience, your awesome commit message will help
    your journey.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这种集成，提交信息不再局限于其仓库或团队。它开始跨越不同的组织边界和平台。这一过渡突显了精心编写的提交信息作为一种通用语言的价值，它可以被软件开发和交付流程中的不同利益相关者理解和欣赏。在打破组织孤岛并改善开发者体验的过程中，你的优秀提交信息将助力你的旅程。
- en: 'Here are some tips for a great commit message:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些优秀提交信息的建议：
- en: '**Transparency is key**: Clear commit messages allow teams, from development
    to operations, to understand code changes, reducing friction and enhancing collaboration.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明性至关重要**：清晰的提交信息使得从开发到运营的团队能够理解代码变更，减少摩擦并促进协作。'
- en: '**Continuous delivery relies on history**: As organizations push towards more
    frequent releases, the ability to quickly understand and verify changes becomes
    paramount. An informative commit message is a critical tool in this process.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续交付依赖历史**：随着组织推动更频繁的发布，快速理解和验证变更的能力变得至关重要。信息丰富的提交信息是这一过程中的重要工具。'
- en: Commit message examples
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提交信息示例
- en: 'Here is an example of a commit message. This is basic, and you can use it as
    a starting point to add your own context from here, but it should not be too long:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个提交信息的示例。它是基础性的，你可以在此基础上添加你自己的上下文，但不应过长：
- en: '| **Category** | **Example** **commit messages** |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **类别** | **示例** **提交信息** |'
- en: '| **Simple changes** | Add `README.md` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **简单变更** | 添加`README.md` |'
- en: '| Update license expiration date |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 更新许可证到期日期 |'
- en: '| Remove deprecated method XYZ |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 移除已废弃的方法XYZ |'
- en: '| **Feature additions/updates** | Implement user authentication flow |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| **功能添加/更新** | 实现用户认证流程 |'
- en: '| Add search functionality to the homepage |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 为主页添加搜索功能 |'
- en: '| Extend API to support versioning |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 扩展API以支持版本控制 |'
- en: '| **Bug fixes** | Fix login bug causing session timeouts |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **错误修复** | 修复导致会话超时的登录错误 |'
- en: '| Resolve memory leak in the data processing module |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 解决数据处理模块中的内存泄漏 |'
- en: '| Correct the typo in the user registration form |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 修正用户注册表单中的拼写错误 |'
- en: '| **Refactoring and code** **quality improvements** | Refactor database connection
    logic for pooling |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| **重构和代码** **质量改进** | 重构数据库连接逻辑以支持连接池 |'
- en: '| Optimize image loading for faster page rendering |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| 优化图片加载以加速页面渲染 |'
- en: '| Improve error handling in the payment gateway |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| 改进支付网关中的错误处理 |'
- en: '| **Documentation** **and comments** | Document main algorithms in XYZ module
    |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| **文档** **和注释** | 记录XYZ模块中的主要算法 |'
- en: '| Update comments for clarity in the X function |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 更新X函数中的注释以提高清晰度 |'
- en: '| Revise API documentation for new endpoints |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 修订API文档以包含新端点 |'
- en: '| **Reverting changes** | Revert “Add experimental feature X” |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| **恢复变更** | 恢复“添加实验性功能X” |'
- en: '| Rollback to a stable state before the caching layer update |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 回滚到缓存层更新之前的稳定状态 |'
- en: '| **Dependency and** **external integrations** | Upgrade to v2.1.3 of ABC library
    |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| **依赖项和** **外部集成** | 升级到ABC库的v2.1.3版本 |'
- en: '| Integrate the latest security patches for the XYZ framework |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 集成XYZ框架的最新安全补丁 |'
- en: '| **With issue/task** **tracking references** | Fix #1234: Address edge case
    in order checkout |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| **带有问题/任务** **跟踪引用** | 修复#1234：处理订单结账中的边缘情况 |'
- en: '| Feature #5678: Add multi-language support |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| 功能#5678：添加多语言支持 |'
- en: '| **Merges operations** | Merge branch ‘feature/user-profiles’ |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **合并操作** | 合并分支‘feature/user-profiles’ |'
- en: '| Resolve merge conflict in main.css |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| 解决main.css中的合并冲突 |'
- en: '| **Test-related changes** | Add unit tests for utility functions |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| **与测试相关的变更** | 为工具函数添加单元测试 |'
- en: '| Refactor integration tests to use mock data |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 重构集成测试以使用模拟数据 |'
- en: '| Fix flaky test in user registration flow |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 修复用户注册流程中的不稳定测试 |'
- en: Table 2.1 – Commit message example
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 表2.1 – 提交信息示例
- en: Single-purpose code
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单一功能代码
- en: In the evolving landscape of software development, where Agile and DevOps practices
    champion swift iteration and robust collaboration, the principle of single-purpose
    code gains heightened importance. Its influence transcends the realm of code structure,
    weaving itself into the very fabric of developer experience and Git communication.
    Let’s delve into the profound connections that intertwine these concepts.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在不断发展的软件开发领域中，敏捷和 DevOps 实践倡导快速迭代和强有力的协作，单一功能代码的原则变得愈发重要。它的影响力不仅限于代码结构的领域，甚至渗透到开发者体验和
    Git 通信的核心。让我们深入探讨这些概念之间深刻的联系。
- en: Aligning with Agile principles
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与敏捷原则的契合
- en: 'Agile methodologies, at their core, promote adaptability, continuous improvement,
    and delivering value in small, manageable increments. Single-purpose code seamlessly
    aligns with these tenets:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷方法论的核心理念是促进适应性、持续改进，并以小而可管理的增量交付价值。单一功能代码与这些原则无缝契合：
- en: '**Incremental development**: Just as Agile breaks down features into smaller
    user stories or tasks, single-purpose code encourages breaking down software components
    into focused, manageable chunks.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量开发**：就像敏捷将特性拆解为更小的用户故事或任务一样，单一功能代码鼓励将软件组件拆分成专注的、可管理的模块。'
- en: '**Adaptability**: Single-purpose components are easier to modify or replace,
    aligning with Agile’s embrace of change.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应性**：单一功能组件更易于修改或替换，符合敏捷方法论对变化的拥抱。'
- en: Enhancing the DevOps pipeline
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提升 DevOps 流水线
- en: 'DevOps emphasizes the continuous integration and delivery of software, bridging
    the worlds of development and operations. Here’s where single-purpose code shines:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 强调软件的持续集成和交付，架起了开发与运维之间的桥梁。此时，单一功能代码的优势便显现出来：
- en: '**Streamlined CI/CD**: With code components being focused and independent,
    the chances of one module unexpectedly affecting another during integrations are
    reduced, leading to smoother CI/CD pipelines.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精简的CI/CD**：由于代码组件专注且独立，集成过程中一个模块意外影响另一个模块的几率降低，从而使得CI/CD流水线更加顺畅。'
- en: '**Better monitoring and logging**: When components have a single responsibility,
    it is easier to monitor their behavior and log relevant events. Any anomalies
    can be traced directly to a specific functionality.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的监控和日志记录**：当组件具有单一责任时，监控其行为和记录相关事件变得更加容易。任何异常都可以直接追溯到特定功能。'
- en: Elevating the developer experience
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提升开发者体验
- en: 'The concept of **Developer Experience** (**DX**) revolves around making developers’
    lives easier, promoting productivity, and reducing friction. Single-purpose code
    plays a pivotal role in this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者体验**（**DX**）的概念围绕着让开发者的工作更轻松、提高生产力和减少摩擦展开。单一功能代码在这一过程中扮演了至关重要的角色：'
- en: '**Intuitive onboarding**: New team members can understand and contribute faster
    when the codebase consists of clear, focused components'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直观的入职体验**：当代码库由清晰且专注的组件组成时，新团队成员能够更快理解并做出贡献。'
- en: '**Efficient debugging**: With each component doing one thing, identifying and
    resolving issues becomes a more streamlined process'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效的调试**：由于每个组件只做一件事，识别和解决问题变得更加高效。'
- en: The deep-rooted connection with Git communication
  id: totrans-309
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与 Git 通信的深厚联系
- en: 'As previously noted, there is a profound synergy between single-purpose code
    and Git:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，单一功能代码与 Git 之间有着深刻的协同作用：
- en: '**Clear commit messages**: Writing single-purpose code results in precise commit
    messages. A change to a singularly focused function or module can be succinctly
    described in Git, promoting transparency and clarity in communication.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清晰的提交信息**：编写单一功能代码能生成精确的提交信息。对单一功能或模块的更改可以在 Git 中简洁地描述，从而促进透明度和沟通清晰度。'
- en: '**Simplified code reviews**: Pull requests on platforms such as GitHub become
    more straightforward when they revolve around focused changes. It is easier for
    reviewers to understand the intent and verify the implementation, leading to more
    meaningful feedback and collaboration.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化的代码审查**：在 GitHub 等平台上，若 Pull 请求围绕着专注的变更进行，审查过程将变得更加直接。审阅者更容易理解意图并验证实现，从而带来更有意义的反馈和协作。'
- en: 'Complete code: Striking a balance between precision and progress'
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整的代码：在精确性和进度之间找到平衡
- en: In the realm of software development, there is an age-old tension between the
    need for perfection and the demands of progress. Developers often grapple with
    the question, When is my code ready? In this discourse, we aim to elucidate the
    concept of complete code, a philosophy that emphasizes producing robust, fully
    realized solutions without getting mired in the unattainable pursuit of perfection.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发领域，完美与进步之间的长期矛盾始终存在。开发人员常常会遇到这样的问题：我的代码什么时候才算准备好了？在本文中，我们旨在阐明“完整代码”这一概念，这一理念强调在不陷入对完美的难以实现追求中，提供稳健、完全实现的解决方案。
- en: The essence of complete code
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整代码的本质
- en: 'The ethos behind **complete code** is simple yet profound: any code written
    should be whole in its intent and execution. This means the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整代码**背后的理念既简单又深刻：任何编写的代码都应在意图和执行上是完整的。这意味着：'
- en: '**No half-measures**: If you are implementing a feature or fixing a bug, the
    code should accomplish its goal fully, not just partially or superficially.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有半途而废**：无论是在实现功能还是修复bug时，代码都应该完全达成目标，而不是部分地或表面地实现。'
- en: '**Review-ready**: The code should be of a quality that it is ready for peer
    review. This means not only being functional but also adhering to coding standards
    and best practices of the team or organization.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备审查**：代码应该达到足够的质量，准备接受同伴审查。这不仅意味着功能正常，还意味着符合团队或组织的编码标准和最佳实践。'
- en: '**Accompanied with tests**: Wherever applicable, the code should come with
    tests, ensuring that it not only works as intended now but continues to do so
    as the software evolves.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**附带测试**：在适用的情况下，代码应附带测试，确保其不仅现在能按预期工作，而且随着软件的演进，依旧能够继续保持这种效果。'
- en: Done is better than perfect
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完成比完美更好
- en: 'While the emphasis is on completeness, it is crucial to recognize that chasing
    perfection can be a counterproductive endeavor. Software is inherently iterative,
    and waiting for the perfect solution can stall progress. The mantra “done is better
    than perfect” serves as a reminder of the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然重点放在完整性上，但必须认识到，追求完美可能是一个适得其反的行为。软件本质上是迭代的，等待完美的解决方案可能会拖慢进展。口号“完成比完美更好”提醒我们以下几点：
- en: '**Iterative improvement is key**: It is okay if the solution is not the most
    optimal out of the gate. It needs to work, and improvements can be made over time.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代改进是关键**：即使一开始解决方案不是最优的，也没有关系。它需要能工作，之后可以随着时间不断改进。'
- en: '**Feedback fuels perfection**: Often, getting the code out and gathering feedback
    leads to better solutions than endless internal iterations.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈推动完美**：通常，发布代码并收集反馈比无休止的内部迭代能得出更好的解决方案。'
- en: The role of testing in complete code
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试在完整代码中的角色
- en: 'Testing is a linchpin in the complete code philosophy:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是完整代码哲学中的关键：
- en: '**Validation**: Tests validate that the code does what it is supposed to do,
    offering a safety net against regressions.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：测试验证代码是否按预期执行，提供防止回归的安全网。'
- en: '**Documentation**: Well-crafted tests also act as documentation, providing
    insights into the expected behavior of the code.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：精心编写的测试也充当文档的角色，提供关于代码预期行为的洞察。'
- en: '**Confidence**: Tests instill confidence. When developers write complete code
    backed by tests, they can make changes or add features with the assurance that
    they will know if something breaks.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自信**：测试能增强信心。当开发人员编写有测试保障的完整代码时，他们可以在修改或添加功能时确信，如果代码出现问题，自己能及时发现。'
- en: The importance of modern development practices
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 现代开发实践的重要性
- en: 'In an era where Agile and DevOps dominate and CI/CD pipelines automate software
    delivery, the importance of complete code becomes even more pronounced:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷和DevOps主导的时代，CI/CD管道自动化软件交付，完整代码的重要性愈加凸显：
- en: '**Streamlined pipelines**: The CI/CD pipeline is executed with the consideration
    that the integrated code may be incomplete. That does not mean it can be incomplete
    at any time, and your team’s testing statistics will turn red if there are too
    many failures. Incomplete code disrupts the pipeline, causes bottlenecks and inefficiencies,
    and is indicative of the quality of your team’s code.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化的管道**：CI/CD管道的执行考虑到集成的代码可能是不完整的。但这并不意味着代码随时都可以不完整，若失败过多，你团队的测试统计数据将变为红色。不完整的代码会破坏管道，造成瓶颈和低效，并且是你团队代码质量的体现。'
- en: '**Collaborative efficiency**: In team settings, when a developer commits complete,
    review-ready code, it fosters a smoother collaboration. Reviewers spend less time
    pointing out basic issues and more time delving into architectural or logical
    discussions.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作效率**：在团队合作中，当开发者提交完整且可以审查的代码时，能够促进更顺畅的协作。审查者花费更少的时间指出基础问题，更多的时间可以用来深入讨论架构或逻辑问题。'
- en: Now you understand how to preserve history in Git. Commit messages are a pain
    to write. You have to describe your work in just a few dozen characters. However,
    it is important to pay attention to these details in Git collaboration.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了如何在 Git 中保留历史记录。编写提交信息是件让人头疼的事。你需要在仅仅几十个字符内描述你的工作。然而，在 Git 协作中，关注这些细节是非常重要的。
- en: Because you are spending a few hours to make the commit (maybe dozens of hours),
    it would be a shame to ruin it when you could make the collaboration great with
    just a few more seconds or a few more minutes of attention.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你花了几个小时来进行提交（可能是几十个小时），如果因为一些小细节的疏忽而破坏了合作的质量，那真是太可惜了。只需要多花几秒钟或几分钟的时间关注细节，就能让协作变得更好。
- en: The excellence is in the details. Let’s practice and become a real guru!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 卓越藏于细节。让我们练习并成为真正的大师！
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As you wrap up this chapter, you should feel more acquainted with Git’s essential
    features, underlying mechanics, and, most importantly, the philosophy of collaboration
    it champions. Understanding these fundamentals is often far more crucial than
    memorizing a litany of Git commands or stashing away snippets for quick use.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章时，你应该对 Git 的基本功能、底层机制以及最重要的协作哲学更加熟悉了。理解这些基础知识通常比死记 Git 命令或存储快捷代码片段更为重要。
- en: If you have internalized the insights from this chapter, rest assured you have
    obtained a solid grasp of Git’s basics. You are not just prepared to commit code;
    you are ready to be a collaborative force within your team.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经内化了本章的洞见，放心，你已经牢牢掌握了 Git 的基础知识。你不仅准备好提交代码，还准备好在团队中成为一个协作的力量。
- en: When you first join a project managed by Git, the initial challenges are usually
    not resolving intricate conflicts or juggling chaotic branches; rather, the challenge
    lies in crafting meaningful commits and proving yourself to be an invaluable team
    player. Each well-considered commit you make not only contributes to the project
    but also fortifies your standing within the team.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次加入一个由 Git 管理的项目时，最初的挑战通常不是解决复杂的冲突或处理混乱的分支；而是如何编写有意义的提交，并证明自己是一个不可或缺的团队成员。每一次经过深思熟虑的提交，不仅有助于项目的发展，还能巩固你在团队中的地位。
- en: Now, let’s move on to more advanced Git usage to help you shine as a team player.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续深入学习更高级的 Git 使用方法，帮助你在团队中大放异彩。
