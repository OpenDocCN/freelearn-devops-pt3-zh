- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Handling Data with Puppet
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Puppet 处理数据
- en: This chapter will focus on how to handle data using Puppet. It will look at
    Hiera, Puppet’s key-value data lookup tool, and how it ensures that Puppet’s reusable
    code is made more configurable without burdening it with excessive logic and variables.
    The basic structure of Hiera will be reviewed, showing how it stores data in hierarchies
    that provide a rules-based key lookup without a lot of fuss and how it can look
    up keys in this data to return values using different backends, which are implementations
    such as YAML files of data or API calls to applications. The use of automatic
    parameter lookup will be discussed showing how this allows the parameterized profiles
    to receive data automatically and how the lookup function can be used in Puppet
    code directly to call data. We will briefly discuss the changes between Hiera
    3 and Hiera 5 in terms of legacy Puppet. Then, the three Hiera layers will be
    reviewed in detail (the global, environment, and module layers), discussing how
    hierarchies and data should be managed in these different layers. The options
    available for lookup merging and priority behavior will be shown to highlight
    how data can either be found on the first match or by combining or merging different
    values found. We will then discuss when and where data should be used depending
    on the use case and best practice, and where the code should be kept in terms
    of directly in a control repo or in its own Hiera data repo. The security of data
    will then be discussed showing how data can be kept secure with different methods
    in storage, in transport, and while being used in Puppet code, highlighting the
    effects and limitations of using the `Sensitive` type, the `node_encrypt` module,
    and encryption of files via `eyaml`. Finally, some common issues and troubleshooting
    approaches/tools will be reviewed, showing how the `lookup` command can be optimally
    used to debug and explain values, and showing why we should never use global variables
    in hierarchies, how to avoid defaults, the dangers of using Hiera for classification,
    and how the **Hiera Data Manager** (**HDM**) can act as a tool to make your data
    more accessible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍如何使用 Puppet 处理数据。我们将讨论 Hiera，Puppet 的键值数据查找工具，以及它如何确保 Puppet 的可重用代码在不增加过多逻辑和变量的情况下更加可配置。将回顾
    Hiera 的基本结构，展示它如何以层级方式存储数据，提供基于规则的键查找，且无需繁琐操作，以及如何使用不同的后端查找数据中的键以返回值，这些后端实现可能是
    YAML 数据文件或应用程序的 API 调用。将讨论自动参数查找的使用，展示它如何让参数化配置文件自动接收数据，以及如何在 Puppet 代码中直接使用查找功能来调用数据。我们将简要讨论
    Hiera 3 和 Hiera 5 在传统 Puppet 中的变化。接下来，将详细回顾三个 Hiera 层级（全局层、环境层和模块层），讨论在这些不同层级中如何管理层级和数据。将展示查找合并和优先级行为的选项，突出如何通过第一次匹配或合并不同的值来查找数据。然后，我们将根据使用案例和最佳实践讨论数据应该在何时何地使用，以及代码应该直接保存在控制仓库中还是保存在单独的
    Hiera 数据仓库中。接着，我们将讨论数据的安全性，展示如何通过不同的方法在存储、传输和在 Puppet 代码中使用时保持数据安全，重点介绍使用 `Sensitive`
    类型、`node_encrypt` 模块以及通过 `eyaml` 加密文件的效果和局限性。最后，将回顾一些常见问题及故障排除方法/工具，展示如何最佳地使用
    `lookup` 命令调试和解释值，以及为什么我们永远不应该在层级中使用全局变量，如何避免使用默认值，使用 Hiera 进行分类的风险，以及如何通过 **Hiera
    数据管理器** (**HDM**) 工具使数据更易于访问。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: What is Hiera?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Hiera？
- en: Hiera levels
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hiera 层级
- en: Deciding when to use static code or dynamic data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定何时使用静态代码或动态数据
- en: Keeping data secure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持数据安全
- en: Pitfalls, gotchas, and issues
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 陷阱、难点和问题
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Clone the control repo from [https://github.com/puppetlabs/control-repo](https://github.com/puppetlabs/control-repo)
    to your GitHub account as `controlrepo-chapter9` and update the following in this
    repo on the production branch:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [https://github.com/puppetlabs/control-repo](https://github.com/puppetlabs/control-repo)
    克隆控制仓库到你的 GitHub 账户，并将其命名为 `controlrepo-chapter9`，然后在生产分支中更新以下内容：
- en: '`Puppetfile` with [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/Puppetfile](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/Puppetfile'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Puppetfile` 与 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/Puppetfile](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/Puppetfile)'
- en: )
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '`Manifests/site.pp` with [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/site.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/site.pp'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Manifests/site.pp` 与 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/site.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/site.pp)'
- en: )
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Create a branch from production called `lab_error` and replace the following:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从生产环境创建一个名为 `lab_error` 的分支，并替换以下内容：
- en: '`data` with [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/data](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/data'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 与 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/data](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/data)'
- en: )
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '`hiera.yaml` with [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/hiera.yaml](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/hiera.yaml)'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hiera.yaml` 与 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/hiera.yaml](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/hiera.yaml)'
- en: 'Build a standard cluster with two Linux clients and two Windows clients by
    downloading the `params.json` file from [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/params.json
    ) and updating it with the location of your control repo and your SSH key from
    the control repo. Then, run the following command from your `pecdm` directory:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/params.json)
    下载 `params.json` 文件，并更新控制仓库位置和控制仓库中的 SSH 密钥，来构建一个包含两个 Linux 客户端和两个 Windows 客户端的标准集群。然后，在
    `pecdm` 目录下运行以下命令：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let us first find out what Hiera is and why it is used.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下 Hiera 是什么以及它为何被使用。
- en: What is Hiera?
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Hiera？
- en: So far, we have discussed how using Puppet creates stateful and reusable code
    and how, by using the roles and profiles method, parameters can be made available
    to make modules configurable. We also showed how to use those parameters in code,
    but to create a scalable, readable, and site-specific data source, Puppet uses
    a tool called **Hiera**. Without using Hiera data in Puppet code, it would require
    endless logic and variables to represent data variations required for node exceptions,
    location differences, OS version variations, organization differences, and many
    other circumstances.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何使用 Puppet 创建有状态且可重用的代码，以及如何通过使用角色和配置文件方法使得参数可用，从而使模块可配置。我们还展示了如何在代码中使用这些参数，但为了创建一个可扩展、可读且特定于站点的数据源，Puppet
    使用了一个名为 **Hiera** 的工具。如果不在 Puppet 代码中使用 Hiera 数据，将需要无休止的逻辑和变量来表示节点例外、位置差异、操作系统版本差异、组织差异以及许多其他情况所需的数据变化。
- en: Hiera is a data lookup tool that looks up values in files of JSON, HOCON, YAML,
    and EYAML, the built-in backends, or using custom backends that can call external
    sources such as websites or databases. It stores data in key-value pairs that
    can be looked up either explicitly via a function call in code or automatically
    using the automatic parameter lookup, which matches parameter names from classes
    to Hiera data values. As this name would suggest, Hiera is focused on using a
    hierarchy to find data, and the lookups follow a common default with a hierarchy
    of data sources that override as a more specific node match is found for the data.
    The hierarchies are configured in a `hiera.yaml` file; this YAML file lists out
    the levels in order of priority. This `hiera.yaml` file sets the version of Hiera
    to be used, which is required, although *5* is the only active version.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 是一个数据查找工具，可以在 JSON、HOCON、YAML 和 EYAML 文件中查找值，支持内置后端，或使用自定义后端调用外部数据源，例如网站或数据库。它以键值对的形式存储数据，可以通过代码中的函数调用显式查找，也可以通过自动参数查找自动查找，后者通过将类中的参数名称与
    Hiera 数据值进行匹配来实现。正如这个名字所暗示的那样，Hiera 专注于使用层级来查找数据，查找过程遵循一个常见的默认值，数据源的层级越具体，匹配的节点数据越精确。这些层级在
    `hiera.yaml` 文件中配置；该 YAML 文件按优先级列出各个层级。此 `hiera.yaml` 文件设置了要使用的 Hiera 版本，这是必需的，虽然
    *5* 是唯一的活跃版本。
- en: Using the built-in backends
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置后端
- en: 'For built-in backends in a hierarchy map, there will be a list of hierarchies,
    each of which will have the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对于层级映射中的内置后端，将会有一个层级列表，每个层级将包含以下内容：
- en: '`name` – A readable label describing the level'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name` – 描述层级的可读标签'
- en: '`datadir` – The base path relative to `hiera.yaml` where all data is stored'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`datadir` – 相对于 `hiera.yaml` 的基础路径，所有数据都存储在此路径下'
- en: '`data_hash` – The Hiera backend/file type to use'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data_hash` – 要使用的 Hiera 后端/文件类型'
- en: Either `path`, `paths`, `glob`, `globs`, or `mapped_paths` – The file path or
    paths to the data relative to `datadir`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path`、`paths`、`glob`、`globs`或`mapped_paths`——文件路径或相对于`datadir`的数据路径。'
- en: A default map can also be created with these keys so that values don’t need
    to be needlessly repeated in each layer of the hierarchy.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用这些键创建默认映射，这样就不需要在每个层次结构中重复值。
- en: The `data_hash` lookup function key accepts `yaml_data`, `json_data`, and `hocon_data`
    as values but most Puppet implementations just use YAML data, so this book will
    default to the `yaml_data` backend.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_hash`查找函数键接受`yaml_data`、`json_data`和`hocon_data`作为值，但大多数Puppet实现仅使用YAML数据，因此本书将默认使用`yaml_data`后端。'
- en: The file path allows a hierarchy level to state a specific location for the
    data file of that hierarchy using variables interpolated in the code associated
    with the node, such as global variables associated with the `%{<variable_name}`,
    and to call a fact, the `facts` array is accessed using dots (`.`). So, `%{facts.application_owner}`
    would access the `application_owner` fact. Further dots can be used to access
    structured facts, such as `%{facts.os.family}` to access the `family` value within
    the `os` fact. Trusted facts similarly are accessed from the `trusted` array,
    such as `%{trusted.certname}`, and trusted external facts can be accessed using
    `%{trusted.external.pds.data}`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文件路径允许层次结构级别使用与节点相关的代码中插值的变量，声明数据文件的特定位置，例如与`%{<variable_name}`相关的全局变量，并通过点（`.`）访问`facts`数组来调用事实。因此，`%{facts.application_owner}`将访问`application_owner`事实。进一步的点可以用来访问结构化事实，例如`%{facts.os.family}`可以访问`os`事实中的`family`值。类似地，受信任的事实可以从`trusted`数组中访问，例如`%{trusted.certname}`，并且可以使用`%{trusted.external.pds.data}`访问受信任的外部事实。
- en: 'So, a simple hierarchy could be created in the `hiera.yaml` file with the following
    piece of code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可以在`hiera.yaml`文件中使用以下代码创建一个简单的层次结构：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This hierarchy would mean that a host with the `certname` trusted fact of `examplehost`
    and a `data_center` fact of `enterprisedc1` would first look in `data/nodes/examplehost.yaml`,
    then in `data/location/enterprisedc1.yaml`, and lastly, in the `/data/common.yaml`
    common file.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个层次结构意味着，具有`certname`可信事实为`examplehost`和`data_center`事实为`enterprisedc1`的主机，首先会在`data/nodes/examplehost.yaml`中查找，然后在`data/location/enterprisedc1.yaml`中查找，最后在`/data/common.yaml`公共文件中查找。
- en: 'It is also possible to combine multiple variable interpolations together on
    a path, such as updating the location layer to differentiate on another fact –
    for example, assuming a `brand` fact existed and different brands within the organization
    would have variation for a data center, `path: "location/%{facts.brand}-%{fact.data_center}.yaml"`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '也可以将多个变量插值组合在路径中，例如更新位置层以根据另一个事实进行区分——例如，假设存在`brand`事实，并且组织中的不同品牌将对数据中心有所不同，那么路径可以写成`path:
    "location/%{facts.brand}-%{fact.data_center}.yaml"`。'
- en: So, if `examplehost` had the `brand` fact set to `retail`, it would look in
    `data/location/retail-enterprisedc1.yaml`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果`examplehost`的`brand`事实设置为`retail`，它将会在`data/location/retail-enterprisedc1.yaml`中查找。
- en: 'In these lookups, if it doesn’t find a matching file for its level, it will
    return nothing and go to the next level. Using the `paths` path file variable
    instead would allow simplification. Since the only real difference between the
    hierarchy levels is the path, it could instead be declared with a single hierarchy
    and paths with an array of `paths`. For example, the hierarchy from the previous
    example could be reduced to one layer with `paths`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些查找中，如果在当前层次找不到匹配的文件，它将返回空值并进入下一层。改用`paths`路径文件变量可以简化这一过程。由于层次结构之间唯一的实际差异是路径，因此可以通过一个单一的层次结构声明和带有`paths`数组的路径来简化。例如，前一个示例中的层次结构可以简化为一个层次结构，使用`paths`：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If additional Hiera layers were required for a different backend, it would need
    to be understood that any hierarchy would have all its paths examined in order
    before moving on to the next hierarchy, which may prevent this simplification
    to maintain the correct order of hierarchy.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要为不同的后端添加额外的Hiera层次结构，那么必须理解，任何层次结构都会按照顺序检查所有路径，然后才会进入下一个层次，这可能会防止简化并保持正确的层次顺序。
- en: In this section, we will cover globs, only because they can be found in code
    bases, but they should *not* be used, as they make the data structure a lot more
    complicated than any environment truly needs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论glob，因为它们在代码库中可能会出现，但它们*不应*被使用，因为它们会使数据结构比任何环境实际需要的更复杂。
- en: 'The file path can use `glob` or `globs` to pass Ruby’s style `Dir.glob` method.
    The full documentation of this can be viewed at [https://www.puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#specifying_file_paths.](https://www.puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#specifying_file_paths
    ) This allows the use of the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '文件路径可以使用`glob`或`globs`来传递Ruby风格的`Dir.glob`方法。此方法的完整文档可以在[https://www.puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#specifying_file_paths](https://www.puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#specifying_file_paths)查看。这允许使用以下功能：  '
- en: An asterisk (`*`) as a wildcard
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '星号（`*`）作为通配符  '
- en: Two asterisks (`**`) to match recursively through directories
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '两个星号（`**`）用于递归匹配目录  '
- en: A question mark (`?`) to match any one character
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '问号（`?`）用于匹配任意一个字符  '
- en: A comma-separated list within curly braces (`{this,that,or,not}`) for a literal
    match with any option in the list
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '用逗号分隔的列表（`{this,that,or,not}`）用于与列表中的任何选项进行字面匹配  '
- en: Sets of characters within square brackets (`[xyz]`) to match any one character
    in the given set
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '方括号内的字符集（`[xyz]`）用于匹配给定集合中的任意一个字符  '
- en: A backslash (`\`) to escape special characters
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反斜杠（`\`）用于转义特殊字符
- en: 'For example, take the `facts.os.windows` fact and then match either from `display_id`
    (which was introduced in later versions of Windows 2019) or from `release_id`
    (which was introduced in Windows 2016 and deprecated in Windows 2019). This combination
    allows a consistent Hiera layer for a source that has changed repeatedly and needs
    a combination of facts to find different versions:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，取`facts.os.windows`事实，然后从`display_id`（在Windows 2019的后续版本中引入）或`release_id`（在Windows
    2016中引入并在Windows 2019中弃用）中进行匹配。这个组合允许为一个反复变化的来源创建一个一致的Hiera层，并且需要组合事实来查找不同的版本：  '
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To create a layer containing network information for the network on the primary
    interface or the network domain, the following code could be created, which would
    search through any directory structure in the network folder to match:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '要创建一个包含主接口或网络域的网络信息层，可以创建以下代码，它将搜索网络文件夹中的任何目录结构以进行匹配：  '
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If multiple matches are found, the files will be searched in alphanumerical
    order. Also, multiple strings can be used in the search using `globs:` and passing
    an array of strings in a similar fashion to paths.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '如果找到多个匹配项，文件将按字母数字顺序进行搜索。此外，多个字符串可以使用`globs:`进行搜索，并以类似路径的方式传递字符串数组。  '
- en: 'The final file path option is `mapped_paths`. This option works by providing
    a variable containing a collection of strings, a variable name (which maps each
    element of the collection of strings), and a template. For example, if a fact
    called `$oracle_sids` contained the `[''ora1'',''ora2'',''ora3'']` array, the
    following hierarchy would perform lookups in the `/oracle_dbs/ora1.yaml`, `/oracle_dbs/ora2.yaml`,
    and `/``oracle_dbs/ora3.yaml` files:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '最终的文件路径选项是`mapped_paths`。此选项通过提供一个包含字符串集合的变量、一个变量名（该变量映射字符串集合中的每个元素）和一个模板来工作。例如，如果一个名为`$oracle_sids`的事实包含`[''ora1'',''ora2'',''ora3'']`的数组，则以下层次结构将在`/oracle_dbs/ora1.yaml`、`/oracle_dbs/ora2.yaml`和`/oracle_dbs/ora3.yaml`文件中执行查找：  '
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Although we have taken some time to cover globs, it’s important to reiterate
    that this should only be used to understand pre-existing complex data structures
    in code and for you to try and refactor and simplify. *This should not be used
    in new* *code bases*.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然我们已经花了一些时间来讲解通配符（globs），但需要重申的是，这应该仅用于理解代码中预先存在的复杂数据结构，并帮助你进行重构和简化。*这不应在新的*
    *代码库* 中使用。  '
- en: Having discussed the hierarchy in detail, it’s now time to shift focus to the
    data used and how to call the lookups to the hierarchy. As was mentioned in the
    *Using the built-in backends* section, YAML is the most commonly used built-in
    data type and will be used in all examples, but the difference will only be in
    the presentation of the language rather than the actual structures used.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '在详细讨论了层次结构之后，现在是时候转向使用的数据以及如何调用该层次结构的查找了。正如在*使用内置后端*部分中提到的，YAML是最常用的内置数据类型，并将在所有示例中使用，但差异仅体现在语言的表示方式，而非实际使用的结构。  '
- en: In the YAML data files, we create key-value pairs and keys with lists of values.
    The keys can just be single values but, more commonly, will be structured with
    the format `<module_name>::<paramater_name>`, where `module_name` can contain
    multiple segments reflecting a certain class namespace within the module.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '在YAML数据文件中，我们创建键值对和带有值列表的键。键可以是单一值，但更常见的是使用格式`<module_name>::<paramater_name>`来构造，其中`module_name`可以包含多个段，反映模块内的某个类命名空间。  '
- en: 'To give an example of this, for the `exampleapp` profile module, a data file
    could contain the settings for the `enable_service` parameter to be `true`, it
    could contain an array of options of `[opt1,opt2,opt3]`, and for a `user`’s parameter,
    it could contain a hash of each user’s settings to be created for `exampleuser`
    and `anotheruser`. This would look like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，对于`exampleapp`配置文件模块，一个数据文件可能包含将`enable_service`参数设置为`true`的设置，它可能包含`[opt1,opt2,opt3]`的选项数组，对于`user`的参数，它可能包含一个每个用户设置的哈希，用于创建`exampleuser`和`anotheruser`。这将如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Accessing data
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数据
- en: 'The next point would be how this hierarchy and data is accessed in Puppet code
    and, as was mentioned at the beginning of this chapter, there are two ways Puppet
    looks up data in code: via the automatic class parameter lookup or via the Puppet
    lookup function. The recommended model involves driving virtually all data required
    via automatic parameter lookups to profile classes using the Role and Profile
    model (discussed in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212)) and the Forge.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要点是如何在Puppet代码中访问这个层级和数据，正如本章开头所提到的，Puppet有两种方式在代码中查找数据：通过自动类参数查找或通过Puppet查找函数。推荐的模型是通过自动参数查找将几乎所有需要的数据传递给配置文件类，使用角色和配置文件模型（在[第8章](B18492_08.xhtml#_idTextAnchor212)中讨论）和Forge。
- en: 'The automatic class parameter lookup works by taking any parameters of a class
    that has been included/declared as a resource and, first, checking whether the
    parameter has been set by the declaration, and if not, performing a Hiera lookup
    on each parameter of the `<module_name>::< parameter_name>` form. It is important
    to note that this is not a namespaced key itself in Hiera; it is just a string
    name and values can’t be inserted into the data structure. In the case of using
    profiles and having a set profile module and an Oracle profile, this could look
    like `profile::oracle::version`. To set data for this, we might have a specific
    version for a `server1.example.com` node in a `data/nodes/server1.example.com.yaml`
    file, such as setting the version parameter for `profile::oracle` to Oracle 21c
    with the following line:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 自动类参数查找通过获取任何已被包含/声明为资源的类的参数来工作，首先检查参数是否已通过声明设置，如果没有，则对每个`<module_name>::<parameter_name>`形式的参数执行Hiera查找。需要注意的是，这本身不是Hiera中的命名空间键；它只是一个字符串名称，值不能插入到数据结构中。在使用配置文件并具有已设置的配置文件模块和Oracle配置文件的情况下，这可能看起来像是`profile::oracle::version`。为了设置此数据，我们可能会在`data/nodes/server1.example.com.yaml`文件中为`server1.example.com`节点设置特定的版本，如以下行所示，将`profile::oracle`的版本参数设置为Oracle
    21c：
- en: '`profile::oracle::version: 21c`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`profile::oracle::version: 21c`'
- en: If this lookup had failed, it would look to see whether any default value was
    set in the parameter in the class manifest, before then assigning it as `undef`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此查找失败，它将查看类清单中是否为参数设置了任何默认值，然后将其赋值为`undef`。
- en: The data found in Hiera by default will return as a string or an array of strings;
    we will show later how this can be converted.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，通过Hiera找到的数据将以字符串或字符串数组的形式返回；稍后我们将展示如何将其转换。
- en: Note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The automatic class parameter lookups do not work for defined resource types,
    only classes. To mimic the functionality, you can use an explicit `lookup()` call
    in your code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 自动类参数查找不适用于定义的资源类型，仅适用于类。为了模仿这一功能，您可以在代码中使用显式的`lookup()`调用。
- en: 'The other mechanism in Puppet code is the `lookup` function. It is more direct
    and can be used within Puppet code; it is called with a key, which can be multiple
    segments, each separated by two colons (`::`), or it can be simple global values.
    The colons are used here simply for convention and do not drill down into a data
    structure. To look up the same Oracle parameter, the following example would assign
    it to an `oracle_version` variable:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet代码中的另一个机制是`lookup`函数。它更直接，可以在Puppet代码中使用；它通过一个键调用，这个键可以是多个段，每个段由两个冒号(`::`)分隔，或者它可以是简单的全局值。这里使用冒号只是约定，并不深入到数据结构中。为了查找相同的Oracle参数，以下示例将其赋值给`oracle_version`变量：
- en: '`$``oracle_version=lookup(profile::oracle::version)`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`$``oracle_version=lookup(profile::oracle::version)`'
- en: 'If the data is an array, it is possible to access a specific key using dot
    notation:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据是一个数组，可以使用点表示法访问特定的键：
- en: '`$``exampleuser_id=lookup(profile::exampleapp::users.exampleuser.id)`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`$``exampleuser_id=lookup(profile::exampleapp::users.exampleuser.id)`'
- en: 'It is possible to provide a default value if no value is returned by using
    the arguments in the function or an options hash (the full options can be viewed
    in the documentation at [https://www.puppet.com/docs/puppet/latest/hiera_automatic.html#puppet_lookup-arguments](https://www.puppet.com/docs/puppet/latest/hiera_automatic.html#puppet_lookup-arguments))
    and providing a value to return – for example, to return the `no id found` string
    if the lookup in the previous example had returned no value, the following could
    be used:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果查找返回的值为空，可以通过函数中的参数或选项哈希提供默认值（完整选项可以在文档中查看：[https://www.puppet.com/docs/puppet/latest/hiera_automatic.html#puppet_lookup-arguments](https://www.puppet.com/docs/puppet/latest/hiera_automatic.html#puppet_lookup-arguments)），并提供一个返回的值——例如，如果上一个示例的查找未返回任何值，可以使用以下内容来返回
    `no id found` 字符串：
- en: '`exampleuser_id=lookup(profile::exampleapp::users.exampleuser.id, {default_value
    => ''no` `id found''})`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`exampleuser_id=lookup(profile::exampleapp::users.exampleuser.id, {default_value
    => ''no` `id found''})`'
- en: This will be discussed in more detail in the *Pitfalls, gotchas, and issues*
    section, but providing defaults is considered poor practice, as it hides failures
    and may make people assume a value has in fact been found and things are functioning
    correctly. It will also be noticed that the second and third arguments are marked
    as `undef`; these are for data type and the merge strategy, which will be discussed
    next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在 *Pitfalls, gotchas, and issues* 部分中详细讨论，但提供默认值被认为是一个不好的实践，因为它隐藏了失败，并可能让人误以为值已经找到且一切正常运行。还可以注意到第二个和第三个参数被标记为
    `undef`；这些是数据类型和合并策略，将在接下来的部分讨论。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `lookup` function replaces the legacy `hiera_<data_type>` and `hiera` functions
    that existed with Hiera 3\. As these functions are deprecated, they should not
    be used as they can produce inconsistent results.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookup` 函数替代了 Hiera 3 中的传统 `hiera_<data_type>` 和 `hiera` 函数。由于这些函数已被弃用，不应使用它们，因为它们可能产生不一致的结果。'
- en: What has been discussed so far is the simplest case, where we expect to simply
    look up a value and find the first match. This is Hiera’s default behavior and
    allows you to override values to varying degrees of specificity. Sometimes, though,
    you might want to return some combination of all the values present in all the
    layers of the hierarchy. Lookup options can be set in the data files to describe
    how this should happen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的内容是最简单的情况，我们只期望查找一个值并找到第一个匹配项。这是 Hiera 的默认行为，允许你根据不同的具体程度重写值。不过，有时候，你可能希望返回所有层级中所有值的某种组合。可以在数据文件中设置查找选项，来描述应该如何进行这种操作。
- en: 'The `lookup_options` reserved key allows for different merge behaviors to be
    set on lookups that are set against either a particular key or against a regular
    expression following this format:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookup_options` 保留键允许为查找操作设置不同的合并行为，查找操作可以是针对特定键或遵循以下格式的正则表达式：'
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The most common approach is to put this behavior in the `common.yaml` file,
    but if, say, a node override or some priority override may be more important,
    it can make sense to then put it into different levels of the hierarchy.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的方法是将这种行为放在`common.yaml`文件中，但如果例如，节点重写或某些优先级重写可能更重要，那么将其放到层次结构的不同层级中也是有意义的。
- en: 'There are four merge behaviors that can be set with the data files:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在数据文件中设置四种合并行为：
- en: '`first` – Return the first match in the hierarchy order'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first` – 返回层次结构顺序中的第一个匹配项'
- en: '`unique` – Return an array of all matching unique values in the hierarchy'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unique` – 返回层次结构中所有匹配的唯一值的数组'
- en: '`hash` – Return a hash of shallow merged hash keys using the highest hierarchy
    key match'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hash` – 返回一个哈希值，浅度合并哈希键，使用最高层次的键匹配'
- en: '`deep` – Return a hash of deep merged hash keys using the highest hierarchy
    key match'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deep` – 返回一个哈希值，深度合并哈希键，使用最高层次的键匹配'
- en: 'Hiera’s default behavior, `first`, will look for the first value to match in
    hierarchy order. Assuming there is no other `lookup_option` value declared for
    the key, there is no need to implicitly declare it. But if, for example, `common.yaml`
    was set to `unique` and, for our node exception, we wanted to set only the values
    we had declared for `profile:oracle::limits`, we could set the following in our
    node’s YAML data file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 的默认行为 `first` 会按照层次结构顺序查找第一个匹配的值。假设没有为该键声明其他的 `lookup_option` 值，那么就不需要隐式声明它。但是，如果例如，`common.yaml`
    被设置为 `unique`，而对于我们的节点异常，我们只希望设置在 `profile:oracle::limits` 中声明的值，我们可以在节点的 YAML
    数据文件中设置以下内容：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `unique` keyword will find all matching keys and return a merged and flattened
    array. So, for example, if we wanted to install all requested Oracle versions
    in a profile, we could set the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique`关键字将查找所有匹配的键，并返回合并后的扁平化数组。因此，例如，如果我们想在一个配置文件中安装所有请求的Oracle版本，我们可以设置如下：'
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the `11` value was found at the node level, `12` at the organizational level,
    and `11,13` found at the common hierarchy level, the returned value would be an
    array of `[11,12,13]`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在节点级别找到了`11`值，在组织级别找到了`12`，并且在公共层级找到了`11,13`，那么返回的值将是一个数组`[11,12,13]`。
- en: 'The `hash` keyword will merge hashes from all matching levels by merging the
    top-level keys of the hashes together. This essentially performs a shallow hash
    merge, which means that top-level keys are merged but the merge will not recursively
    descend and merge data structures nested underneath. This will keep the order
    in which the keys are written as matched from the lowest priority data source
    but will take the values from the highest priority source. It’s easiest to think
    of this as it is adding the keys to a hash as it steps from highest to lowest
    levels. It will override and append values as it does so but it won’t recursively
    merge the values in the keys. For example, imagine a lookup was performed on `profile::oracle::limits`
    and at the lowest level, `common.yaml` existed and contained the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash`关键字将通过合并哈希的顶层键来合并所有匹配级别的哈希。这本质上执行的是浅层哈希合并，意味着顶层键会被合并，但合并不会递归地下降并合并嵌套在其下的数据结构。这将保持键的书写顺序，从最低优先级的数据源中匹配，但会从最高优先级的源中获取值。可以将其理解为在从最高到最低级别的过程中，将键逐步添加到哈希中。它会覆盖并附加值，但不会递归地合并键中的值。例如，假设在`profile::oracle::limits`上执行查找，在最低级别，`common.yaml`存在并包含以下内容：'
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then imagine that `/node/examplenode.server.com.yaml` had a higher priority
    due to the following `hiera.yaml` section:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后假设`/node/examplenode.server.com.yaml`由于以下`hiera.yaml`部分而具有更高优先级：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And `/node/examplenode.server.com.yaml` contained the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 且`/node/examplenode.server.com.yaml`包含以下内容：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The hash lookup on `profile::oracle::limits` would return the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对`profile::oracle::limits`的哈希查找将返回以下内容：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that, in this case, the `profile::oracle::limits.oracle/stack` key was
    taken from the highest priority so only the hard value was seen, and no recursive
    merge was performed. This shortcut syntax with a dot (`.`) can be used to access
    an element in hash or array, where, in the case of an array, the index number
    is used.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这种情况下，`profile::oracle::limits.oracle/stack`键是从最高优先级获取的，因此只看到了硬值，没有执行递归合并。使用带点（`.`）的简化语法可以访问哈希或数组中的元素，在数组的情况下，会使用索引号。
- en: A `deep` merge combines any number of hashes or arrays but is able to merge
    values inside the hash or array recursively. This means that `hash` values are
    merged with another `deep` merge and arrays are not flattened and can contain
    nested arrays. If the previous example lookup options were configured as `deep_merge`,
    then the lookup would return both hard and soft limits for the `oracle/stack`
    key.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`deep`合并结合了任意数量的哈希或数组，并且能够递归地合并哈希或数组中的值。这意味着`hash`值与另一个`deep`合并一起合并，且数组不会被扁平化，可以包含嵌套的数组。如果之前的查找选项被配置为`deep_merge`，则该查找将返回`oracle/stack`键的硬性和软性限制。'
- en: Note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Merging more than three nested levels of nesting in a hash will have a serious
    performance impact on Hiera and should be avoided.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈希中合并超过三个嵌套层级会对Hiera的性能产生严重影响，因此应避免这种做法。
- en: There are also options that can be assigned to affect the merging of arrays.
    For instance, `sort_merged_arrays` will result in the merged array being sorted
    by key rather than the default behavior, where the array is ordered from lowest
    priority to highest, and `merge_hash_arrays`, where hashes within arrays will
    be deep merged if set to `true`. One final option allows `deep` merges to have
    a `knockout_prefix` key, whereby a key containing a value, normally as double
    dashes (`--`), is used as a prefix before the value and will cause a value to
    be removed instead of added.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些选项可以分配以影响数组的合并。例如，`sort_merged_arrays`将导致合并后的数组按键排序，而不是默认行为，即数组按从最低优先级到最高优先级的顺序排序，`merge_hash_arrays`则表示如果设置为`true`，数组中的哈希将进行深度合并。另一个选项允许`deep`合并具有`knockout_prefix`键，其中包含一个值的键，通常以双破折号（`--`）表示，作为值前缀使用，将导致移除而不是添加该值。
- en: 'For example, if the model given in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212)for
    using flexible classes is implemented, using a `deep` merge and a `knockout` prefix
    would allow classes to be added or removed at each hierarchy level:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果在[*第 8 章*](B18492_08.xhtml#_idTextAnchor212)中给出的灵活类模型得到了实现，使用 `deep` 合并和
    `knockout` 前缀将允许在每个层级添加或移除类：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Some example data could be for `node/example.server.com.yaml`, where the highest
    level of the hierarchy, `node`, contained the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例数据可能是 `node/example.server.com.yaml`，其中，层级的最高级别 `node` 包含以下代码：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In contrast, `datacenter/europe.dc.1.yaml`, a lower hierarchy, contained the
    following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`datacenter/europe.dc.1.yaml` 这个较低层级包含了以下内容：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This would result in a lookup on `profile::base::extra_classes` containing `gdpr`
    and `pci::dss`, in that order, but not `email`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 `profile::base::extra_classes` 查找包含 `gdpr` 和 `pci::dss`，按此顺序排列，但不包含 `email`。
- en: 'So far, the examples have used the most common place to set `lookup_options`
    in `common.yaml`. But `lookup_options` performs a hash merge, which will take
    the highest order of each key found. So let’s say, for example, that `/data/common.yaml`,
    the lowest level, contained the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，示例使用了在 `common.yaml` 中设置 `lookup_options` 的最常见位置。但 `lookup_options` 执行哈希合并，这将获取每个键找到的最高顺序。所以举个例子，假设
    `/data/common.yaml`，这个最低层级，包含以下代码：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And `/data/example.server.com.yaml`, at a higher level, contained the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `/data/example.server.com.yaml`，在更高的层级，包含了以下内容：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then a lookup that matched the `profile::base::extra_classes` key in `/data/example.server.com.yaml`
    would use the first match lookup and not a `deep` merge.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `/data/example.server.com.yaml` 中匹配 `profile::base::extra_classes` 键的查找将使用第一个匹配查找，而不是
    `deep` 合并。
- en: 'Another lookup option is to use regex and the `convert_to` option, which converts
    values to something other than a string. One particularly useful example of this
    is when using values we wish to keep sensitive, we could simply add a regex string
    in the common level of the hierarchy, which would match all keys beginning with
    `profile` and a final key name that ended with `password` and ensure that the
    parameter was converted to `Sensitive`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种查找选项是使用正则表达式和 `convert_to` 选项，将值转换为其他类型，而非字符串。一个特别有用的例子是，当使用我们希望保持敏感的值时，我们可以简单地在层级的公共级别添加一个正则表达式字符串，这将匹配所有以
    `profile` 开头，且最终键名以 `password` 结尾的键，并确保该参数被转换为 `Sensitive`：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the *Keeping data secure* section, there will be more discussion on securing
    data.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在*数据安全保持*部分中，将会有更多关于保护数据的讨论。
- en: While it is possible to essentially override the lookup settings set in the
    data file in the `lookup` function itself, we would strongly recommend against
    this as it could be confusing to have the data saying one thing and the `lookup`
    function behaving otherwise. It could lead to changes in the data that have unexpected
    consequences for the `lookup` function. If it is required, the syntax can be found
    in the documentation at [https://www.puppet.com/docs/puppet/8/hiera_automatic.html#puppet_lookup](https://www.puppet.com/docs/puppet/8/hiera_automatic.html#puppet_lookup).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然基本上可以在 `lookup` 函数中覆盖数据文件中设置的查找设置，但我们强烈建议避免这样做，因为数据中可能会说明一种情况，而 `lookup` 函数却表现不同。这可能导致数据的变化对
    `lookup` 函数产生意外的后果。如果确实需要，语法可以在文档中找到：[https://www.puppet.com/docs/puppet/8/hiera_automatic.html#puppet_lookup](https://www.puppet.com/docs/puppet/8/hiera_automatic.html#puppet_lookup)。
- en: Interpolation is also available in Hiera data via both variables and functions.
    While this can be useful to avoid the repetition of data, it can also make the
    data vastly more complicated than we would want it to be, and in general, we would
    advise against it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 插值也可以通过变量和函数在 Hiera 数据中使用。虽然这可以避免数据的重复，但它也可能使数据变得比我们希望的更加复杂，因此一般建议避免这样做。
- en: 'As with hierarchies using facts, `trusted` and `server_facts` can provide consistent
    variables, and the variables are interpolated in the same way, so a simple example
    would be to set a `config` file that uses the hostname as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用事实的层级相同，`trusted` 和 `server_facts` 可以提供一致的变量，且这些变量以相同的方式进行插值，因此，一个简单的例子是设置一个使用主机名的
    `config` 文件，如下所示：
- en: '`tivoli_config_file: ''/opt/app/tivoli/client/%{trusted.hostname}.conf''`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`tivoli_config_file: ''/opt/app/tivoli/client/%{trusted.hostname}.conf''`'
- en: 'Hiera provides a limited number of special interpolation functions. They are
    not the same as Puppet functions. The following functions can be used to interpolate
    Hiera data:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 提供了有限数量的特殊插值函数。它们不同于 Puppet 函数。以下函数可用于插入 Hiera 数据：
- en: '`lookup` (or `hiera`)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lookup`（或 `hiera`）'
- en: '`alias`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alias`'
- en: '`literal`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`literal`'
- en: '`scope`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`'
- en: Using the same format as variables, a function can be declared as `${<function>(<arguments>)}`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与变量相同的格式，可以声明一个函数，如 `${<function>(<arguments>)}`。
- en: 'The `lookup` function allows a Hiera value to be looked up from within the
    data. This can be useful to prevent data having to be repeatedly entered and reduce
    maintenance since, if the data changed, it would only need to be changed in one
    place. For example, something like a repository server could vary depending on
    the client’s location or be used repeatedly to provide the full location of packages.
    The following example shows how two binaries could provide their full paths using
    a lookup and reduce repetition:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookup` 函数允许从数据中查找 Hiera 值。这可以有效地防止数据重复输入并减少维护工作，因为如果数据发生更改，只需在一个地方进行更改。例如，类似于仓库服务器这样的内容可能根据客户端的位置有所不同，或者可能反复使用以提供包的完整位置。以下示例展示了如何使用查找功能来提供两个二进制文件的完整路径，从而减少重复：'
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This would also make maintenance much simpler; if the artifactory server was
    to change, only one line would need to be updated.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这也会使维护变得更加简单；如果 artifactory 服务器发生更改，只需更新一行即可。
- en: 'The `alias` function allows for data structures in Hiera data to be returned
    since `lookup` would only return a string. So, if the `base` profile had an `extensions`
    parameter that took an array of strings and we wanted to pass the same list of
    extensions to another profile, `exampleapp`, it would be coded like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias` 函数允许在 Hiera 数据中返回数据结构，因为 `lookup` 仅返回字符串。因此，如果 `base` 配置文件有一个 `extensions`
    参数，它接受一个字符串数组并且我们希望将相同的扩展名列表传递给另一个配置文件 `exampleapp`，则可以像这样编写：'
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `literal` function allows the escaping of the percentage sign (`%`) so
    that it does not assume it is for a variable or function to be interpolated. To
    do this, we use the `%{literal(''%'')}` function where a `%` sign is to be used.
    This can be useful in scenarios such as Apache configuration files or for Windows
    environmental variables; if, for example, we wanted to have the `%PACKAGEHOME%/External`
    string at `profile::nuget::`, then the following code could be used:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`literal` 函数允许转义百分号符号（`%`），以避免它被解释为变量或函数进行插值。为了做到这一点，我们可以使用 `%{literal(''%'')}`
    函数，其中 `%` 符号需要被使用。这在某些场景下非常有用，比如 Apache 配置文件或 Windows 环境变量；例如，如果我们想在 `profile::nuget::`
    中使用 `%PACKAGEHOME%/External` 字符串，则可以使用以下代码：'
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `scope` function is likely only to be used in legacy code. It really just
    interpolates variables and only had a use case when Puppet variables were dynamically
    scoped. The same Tivoli example in this section would be written as `tivoli_config_file:
    ''/opt/app/tivoli/client/%{scope(facts.hostname)}.conf''`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`scope` 函数可能仅在遗留代码中使用。它实际上只是进行变量插值，只有在 Puppet 变量动态作用域时才有用。在本节中的 Tivoli 示例将写成
    `tivoli_config_file: ''/opt/app/tivoli/client/%{scope(facts.hostname)}.conf''`。'
- en: Using custom backends
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义后端
- en: In addition to the built-in backends described so far, custom backends can be
    written or downloaded from the Forge and configured into Hiera. It is beyond the
    scope of this book to write custom backends but Puppet’s documentation covers
    how to write them at [https://www.puppet.com/docs/puppet/8/hiera_custom_backends.html#custom_backends_overview](https://www.puppet.com/docs/puppet/8/hiera_custom_backends.html#custom_backends_overview).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了到目前为止描述的内置后端外，还可以编写自定义后端或从 Forge 下载并配置到 Hiera 中。编写自定义后端超出了本书的范围，但 Puppet 的文档涵盖了如何编写它们，详见
    [https://www.puppet.com/docs/puppet/8/hiera_custom_backends.html#custom_backends_overview](https://www.puppet.com/docs/puppet/8/hiera_custom_backends.html#custom_backends_overview)。
- en: Custom backends use one of three data types, selected based on their performance
    requirements for the type of data being accessed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义后端使用三种数据类型之一，根据数据访问的性能需求选择。
- en: The `data_hash` backend type, as was seen for the built-in backend, is used
    for data sources that are cheap to read, such as files on a disk. This profile
    is used where the data is small, static, can be read all at once, and most of
    it gets used. It returns a hash of key-value pairs.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_hash` 后端类型，如同内置后端所示，用于读取成本较低的数据源，如磁盘上的文件。该配置文件用于数据小、静态、可以一次性读取且大部分数据都被使用的场景。它返回键值对的哈希值。'
- en: The `lookup_key` type is used for data sources that are expensive to read, such
    as secure HTTP API connections. This profile is used where the data is big, only
    part is used, and it can change during compilation. It returns a key pair. The
    most commonly used custom backend is `hiera-eyaml` for encrypting Hiera, which
    will be covered in detail in the *Keeping data* *secure* section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookup_key` 类型用于读取成本较高的数据源，例如安全的 HTTP API 连接。此配置用于数据量大，且仅部分数据使用，并且在编译过程中可能发生变化的情况。它返回一个键值对。最常用的自定义后端是
    `hiera-eyaml`，用于加密 Hiera，这将在 *保持数据* *安全* 部分详细讲解。'
- en: The `data_dig` backend type is used for data sources that access arbitrary elements
    of a collection, such as a database. With a similar profile to `lookup_key` but
    accessing subkeys of elements to return a key pair, the function will dig into
    a dotted key.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`data_dig` 后端类型用于访问集合中任意元素的数据源，例如数据库。与 `lookup_key` 的配置相似，但它访问元素的子键来返回一个键值对，该函数将深入到一个点分隔的键。'
- en: A final data type to mention is `hiera3_backend`, which was only relevant as
    a stepover from legacy Puppet setups; this book will not cover this configuration,
    but details can be found in the Puppet documentation at [https://www.puppet.com/docs/puppet/8/hiera_config_yaml_5.html](https://www.puppet.com/docs/puppet/8/hiera_config_yaml_5.html).
    The Puppet documentation advises how to migrate from Hiera 3 backends if you encounter
    them in legacy code at [https://www.puppet.com/docs/puppet/8/hiera_migrate.html](https://www.puppet.com/docs/puppet/8/hiera_migrate.html).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要提及的数据类型是 `hiera3_backend`，它仅在从旧版 Puppet 配置中迁移时相关；本书不会覆盖此配置，但详细信息可以在 Puppet
    文档中找到，网址为 [https://www.puppet.com/docs/puppet/8/hiera_config_yaml_5.html](https://www.puppet.com/docs/puppet/8/hiera_config_yaml_5.html)。Puppet
    文档提供了如何从 Hiera 3 后端迁移的指导，如果你在遗留代码中遇到它们，可以访问 [https://www.puppet.com/docs/puppet/8/hiera_migrate.html](https://www.puppet.com/docs/puppet/8/hiera_migrate.html)。
- en: Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: From a user perspective, Hiera version 5 is an evolution of Hiera 3, with Hiera
    4 as an experimental version, but Hiera 5 was fully implemented in Puppet itself
    while Hiera 3 was its own standing implementation. Puppet 7 and below has a dependency
    on a Ruby gem for Hiera version 3 to support any legacy Hiera 3 backends where
    *Hiera:Backend* was extended. This dependency was removed in Puppet 8.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，Hiera 版本 5 是 Hiera 3 的演进，Hiera 4 是实验性版本，但 Hiera 5 在 Puppet 本身中得到了完全实现，而
    Hiera 3 则是独立的实现。Puppet 7 及以下版本依赖于 Ruby gem 来支持 Hiera 版本 3，支持任何扩展了 *Hiera:Backend*
    的遗留 Hiera 3 后端。这个依赖在 Puppet 8 中被移除。
- en: These data types can then be combined with the file paths, as already discussed
    with the built-in backends, but with the additional paths of `uri` and `uris`
    to allow the direction to URIs such as web sources.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据类型可以与文件路径结合使用，正如之前与内置后端讨论的那样，另外还可以使用 `uri` 和 `uris` 路径来指向如 Web 来源等 URI。
- en: The `options` parameter then allows a hash of anything required by the custom
    backend, such as credentials or key information, and the content will depend on
    the implementation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`options` 参数允许传入一个哈希，包含自定义后端所需的任何内容，例如凭证或密钥信息，具体内容将依赖于实现。'
- en: 'Most modules will explain in their README file how to use the `options` parameter.
    For example, [https://forge.puppet.com/modules/petems/hiera_vault/](https://forge.puppet.com/modules/petems/hiera_vault/)
    is a Hiera backend for HashiCorp’s Vault; building on their example, the following
    code shows an example assuming that the keys would all start with `secret_`, come
    from a `vault.example.com` server, and have mounts for two teams (`digital` and
    `trade`), which used the node name, location, and `common` for their secret hierarchy:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数模块会在其 README 文件中解释如何使用 `options` 参数。例如，[https://forge.puppet.com/modules/petems/hiera_vault/](https://forge.puppet.com/modules/petems/hiera_vault/)
    是 HashiCorp Vault 的 Hiera 后端；根据他们的示例，以下代码展示了一个假设的示例，其中密钥都以 `secret_` 开头，来自 `vault.example.com`
    服务器，并为两个团队（`digital` 和 `trade`）设置了挂载点，这些团队使用节点名称、位置和 `common` 作为他们的密钥层次结构：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another example is [https://forge.puppet.com/modules/tragiccode/azure_key_vault/](https://forge.puppet.com/modules/tragiccode/azure_key_vault/),
    allowing access to secrets in Azure, which, if we were to create a lookup based
    on the department assigned to the server looking for keys starting with `secret`,
    would look like the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例是 [https://forge.puppet.com/modules/tragiccode/azure_key_vault/](https://forge.puppet.com/modules/tragiccode/azure_key_vault/)，它允许访问
    Azure 中的秘密。如果我们创建一个基于服务器部门分配的查找，查找以 `secret` 开头的密钥，结果将如下所示：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In [*Chapter 13*](B18492_13.xhtml#_idTextAnchor321), the **Puppet Data Service**
    (**PDS**) will be examined, along with a series of backends useful for extending
    Puppet’s data access.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第13章*](B18492_13.xhtml#_idTextAnchor321)中，将讨论**Puppet数据服务**（**PDS**），以及一系列用于扩展Puppet数据访问的后端。
- en: Now that we have reviewed how Hiera works, let us look at how it works in the
    different layers of Puppet.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Hiera的工作原理，让我们来看看它如何在Puppet的不同层次中工作。
- en: Hiera layers
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hiera层次
- en: Hiera has been discussed just in the context of the levels in a single hierarchy
    but there are three layers of hierarchy, each of which contains its own configuration
    of levels. When a lookup is performed by Puppet as part of a Puppet run, it will
    look through each of these layers, examining the levels of hierarchy within each.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera仅在单一层级的上下文中进行过讨论，但实际上有三个层次的层级，每个层级都有其自身的层次配置。当Puppet在执行时进行查找时，它将遍历这些层级，检查每个层次中的层级结构。
- en: The global layer is the first layer and is configured by default in `$confdir/hiera.yaml`,
    usually `/etc/puppetlabs/puppet/hiera.yaml`. Hiera version 3 only works at this
    layer, and its existence is more just a leftover for compatibility purposes. Puppet’s
    documentation suggests its only purpose should be for Hiera 3 compatibility and
    acting as a global override, but we would advise you to *not use it at all* since
    it exists outside of the code deployment and control processes, which will be
    reviewed in [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272). This would leave
    control of the file localized to the Puppet server, which would only be desirable
    if you wanted to step around the code deployment process.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 全局层是第一层，并默认配置在`$confdir/hiera.yaml`中，通常路径为`/etc/puppetlabs/puppet/hiera.yaml`。Hiera
    3仅在此层工作，它的存在更多是为了兼容性考虑。Puppet的文档建议，它的唯一目的应该是为了Hiera 3兼容性，并作为全局覆盖，但我们建议你*完全不要使用*它，因为它存在于代码部署和控制流程之外，这些将在[*第11章*](B18492_11.xhtml#_idTextAnchor272)中详细讲解。这将使文件的控制局限于Puppet服务器，只有在你希望绕过代码部署过程时，才可能需要这种情况。
- en: The environment layer is the next and main layer of data, and it is configured
    inside each environment usually at a path such as `/etc/puppetlabs/code/production/hiera.yaml`.
    Environments and control repos will be discussed in complete detail in [*Chapter
    11*](B18492_11.xhtml#_idTextAnchor272), but to understand the context here, an
    environment is a set of Puppet modules and manifests at fixed versions for a specific
    group of Puppet nodes, and a control repo is a module structure used to manage
    the environments, containing a file called a Puppetfile detailing the sources
    of the modules, at which version they should be deployed, and where they should
    be deployed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 环境层是下一个也是主要的数据层，它通常配置在每个环境中，路径通常为`/etc/puppetlabs/code/production/hiera.yaml`。环境和控制库将在[*第11章*](B18492_11.xhtml#_idTextAnchor272)中详细讨论，但为了理解这里的背景，环境是为特定组的Puppet节点设置的、具有固定版本的Puppet模块和清单，而控制库是用于管理环境的模块结构，包含一个名为Puppetfile的文件，详细说明了模块的源、应部署的版本以及部署位置。
- en: 'A choice needs to be made as to whether the `hiera.yaml` file and data will
    be contained in the control repo together, or whether to have a separate control
    repo and modules containing Hiera data. This is configured by the control repo
    deploying the modules typically into a data directory in the environment and ensuring
    that Hiera uses that data path in its `hiera.yaml` file. This separation can make
    sense when the control of a set of data needs to be managed by a certain team
    or group and containing it within the control repo would allow too much access/visibility.
    For example, if our `hiera.yaml` file was configured to use data as a source path,
    we could add Hiera data from a module into that path with an entry into a Puppetfile:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 需要决定`hiera.yaml`文件和数据是与控制库一起包含，还是将其与包含Hiera数据的模块分开。这是通过控制库将模块部署到环境中的数据目录，并确保Hiera在其`hiera.yaml`文件中使用该数据路径来配置的。当一组数据的控制需要由特定团队或组进行管理，而将其包含在控制库中可能会导致过多的访问/可见性时，这种分离是有意义的。例如，如果我们的`hiera.yaml`文件配置为使用数据作为源路径，我们可以通过在Puppetfile中添加条目，将模块中的Hiera数据添加到该路径中：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final layer is the module layer, and this is configured by a `hiera.yaml`
    file inside each module, typically with a data folder in the module too. So, when
    deployed in an environment on a server, the `hiera.yaml` file would be in a location
    such as `/etc/puppetlabs/code/environments/production/modules/example_module/hiera.yaml`.
    The best use for the module layer is to set defaults for the parameters of all
    classes in the modules, being careful to keep them relevant to the focus of the
    module, and not external organizational data, which would be better placed into
    the environment layer. An example of setting defaults can be seen in the `puppetlabs/ntp`
    module, available at [https://github.com/puppetlabs/puppetlabs-ntp](https://github.com/puppetlabs/puppetlabs-ntp),
    which sets defaults based on the OS version. The `hiera.yaml` file could also
    be configured to allow for increasing granularity of specific OS versions, going
    from defaults and a general OS family such as Windows to a specific full OS version,
    such as AlmaLinux-8.5, as shown in the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一层是模块层，这一层通过每个模块内的 `hiera.yaml` 文件进行配置，通常模块内还会有一个数据文件夹。因此，当在服务器的环境中部署时，`hiera.yaml`
    文件可能位于类似 `/etc/puppetlabs/code/environments/production/modules/example_module/hiera.yaml`
    的位置。模块层的最佳用途是为模块中所有类的参数设置默认值，同时要小心保持它们与模块的关注点相关，而不是外部的组织数据，这些数据更适合放在环境层中。可以在 `puppetlabs/ntp`
    模块中看到设置默认值的示例，访问地址为 [https://github.com/puppetlabs/puppetlabs-ntp](https://github.com/puppetlabs/puppetlabs-ntp)，该模块根据操作系统版本设置默认值。`hiera.yaml`
    文件还可以配置为支持对特定操作系统版本的逐渐细化，从默认值和一般的操作系统系列（如 Windows）到特定的完整操作系统版本，如 AlmaLinux-8.5，如以下代码所示：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The module layer is often seen as an alternative to the `params.pp` class, which
    used to be part of the module pattern and contained default values and Hiera lookup
    calls. It was used before the modern Hiera layers existed with automatic parameter
    lookups.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 模块层通常被视为 `params.pp` 类的替代方法，后者曾是模块模式的一部分，包含默认值和 Hiera 查找调用。在现代 Hiera 层和自动参数查找机制出现之前，`params.pp`
    类曾被广泛使用。
- en: You can only bind data keys in the module’s namespace, so in the `exampleapp`
    module, only `exampleapp::key` values could be set, not a global key such as `key1`
    or another module such as `anotherapp::key`. This can lead to another pattern
    option particularly useful for in-house written modules, whereby this limitation
    is used to allow application teams to have full control of their environmental
    data for modules without being able to affect other modules. This might be a consideration
    for the profiles modules owned by a particular team who wishes to manage expectations.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能在模块的命名空间中绑定数据键，因此在 `exampleapp` 模块中，只能设置 `exampleapp::key` 的值，不能设置像 `key1`
    这样的全局键或其他模块如 `anotherapp::key`。这可能会导致另一种模式选项，特别适用于内部编写的模块，其中利用这个限制可以让应用团队完全控制模块的环境数据，而不影响其他模块。这对于由特定团队拥有的配置文件模块尤其重要，该团队希望管理期望。
- en: '`default_hierarchy` is sometimes known as the fourth layer and is only available
    in the module layer; it essentially involves declaring a `default_hierarchy` key
    within the module hierarchy. The key difference with this layer is that it will
    only be called if there is no match within the other three layers, so there is
    no merging behavior:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`default_hierarchy` 有时被称为第四层，仅在模块层可用；它本质上是在模块层次结构中声明一个 `default_hierarchy`
    键。与这一层的主要区别在于，只有当其他三层中没有匹配时，才会调用这一层，因此没有合并行为：'
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`default_hierarchy` produces the same behavior as the `params.pp` approach
    did since any match in the three Hiera layers will ignore and not merge any matching
    values.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`default_hierarchy` 产生的行为与 `params.pp` 方法相同，因为在三个 Hiera 层中只要有任何匹配项，它都会忽略并且不会合并任何匹配的值。'
- en: Having reviewed these layers, this leads to a question of how should the hierarchies
    be constructed. Hierarchies can be made complicated very quickly but we should
    remember that the underlying approach is that they should be made to run from
    the most specific data for a node down to general data. They should be as short
    as possible since data files are easier to work with, and the more evaluations
    of hierarchies you create, the greater the impact on Puppet’s infrastructure performance.
    Too many backends (particularly customized backends) will create complications
    and external dependencies, which can break Puppet compilation. The Roles and Profiles
    method should allow less data to be managed in Hiera, and if built-in facts are
    not enough, custom facts can be created and multiple facts can be used in a path
    together.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了这些层次之后，接下来会提出一个问题：应该如何构建这些层次结构。层次结构可以迅速变得复杂，但我们应当记住，基本的方法是应从节点的最具体数据开始，到通用数据为止。它们应尽可能简短，因为数据文件更容易处理，创建的层次结构越多，对
    Puppet 基础设施性能的影响越大。过多的后端（特别是定制的后端）会带来复杂性和外部依赖，可能会破坏 Puppet 的编译。使用角色和配置文件方法应当减少在
    Hiera 中管理的数据量，如果内建事实不够用，可以创建自定义事实，并且可以在路径中一起使用多个事实。
- en: The global level lends itself to just being structured on the name of the node
    and data common to all nodes since it would only be used for overrides outside
    of Puppet code environment control.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 全局层适合仅基于节点名称和所有节点共享的数据来构建，因为它仅在 Puppet 代码环境控制之外进行覆盖时使用。
- en: 'For the environment layer, the common structure of node data to look at is
    as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于环境层，常见的节点数据结构如下所示：
- en: The name of the node
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点的名称
- en: The node owner
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点所有者
- en: The node’s purpose
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点的目的
- en: The location of the node
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点的位置
- en: Data common to all nodes
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有节点共享的数据
- en: 'This could lead to a simple hierarchy such as the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致一个简单的层次结构，如下所示：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The module layer, as discussed, then just becomes a focus for defaults for values
    often based on facts such as OS version and platform.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，模块层则成为以操作系统版本和平台等事实为基础的默认值的集中地。
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use the `environment` fact itself in any hierarchy. Use the environment
    layer for environment-based data.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在任何层次结构中直接使用 `environment` 事实。应当使用环境层来处理基于环境的数据。
- en: Lab – add data to a module
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验 – 向模块添加数据
- en: In this lab, download and update the Grafana module from [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212)to
    contain defaults in Hiera data instead of on the parameters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，从 [*第 8 章*](B18492_08.xhtml#_idTextAnchor212) 下载并更新 Grafana 模块，将默认值存储在
    Hiera 数据中，而不是在参数中。
- en: To do this, let us assume the `common.yaml` file will contain all the present
    defaults in `init.pp`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，假设 `common.yaml` 文件将包含 `init.pp` 中的所有当前默认值。
- en: 'For Red Hat, we will have the following: d`ownload_source = ''`[https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm](https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm)`''package_provider
    =''yum''`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Red Hat，我们将有如下内容：`download_source = '`[https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm](https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm)`'package_provider
    ='yum'`。
- en: 'While for Windows, we will have the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，我们将有如下内容：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can refer to [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/grafana](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/grafana).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/grafana](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/grafana)。
- en: An example answer is at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/grafana.](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/grafana
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例答案可以参考 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/grafana](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/grafana)。
- en: )
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: Later, in the *Keeping data secure* section, it will be shown how the password
    can be properly secured and not just in plain text in the YAML file.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续的*保持数据安全*部分，将展示如何正确地保护密码，而不仅仅是将其作为明文保存在 YAML 文件中。
- en: In this section, we have seen how to use the three layers of Hiera and how to
    structure the hierarchy in these layers. Now, we will look at when data should
    be used in Hiera and when it should just be used in code directly.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们已经看到了如何使用 Hiera 的三层结构，以及如何在这些层中构建层次结构。接下来，我们将探讨何时应当在 Hiera 中使用数据，何时应直接在代码中使用数据。
- en: Deciding when to use static code or dynamic data
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定何时使用静态代码或动态数据
- en: 'Having viewed all the possibilities of managing data structure and looking
    over the code examples covered in this book, it probably raises the question about
    when to write code and when to use data. *Figure 9**.1* highlights a decision
    tree to follow:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览了所有管理数据结构的可能性并查看了本书中介绍的代码示例后，可能会提出一个问题：何时编写代码，何时使用数据。*图 9.1* 展示了一个决策树：
- en: '![Figure 9.1 – Data or code decision tree](img/B18492_09_01.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 数据或代码决策树](img/B18492_09_01.jpg)'
- en: Figure 9.1 – Data or code decision tree
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 数据或代码决策树
- en: The first key thing is if the data doesn’t vary over nodes and it’s only used
    once, the simplest thing is to hardcode the data in Puppet code – for example,
    just directly setting the owner of a file as `exampleuser` in a file resource
    attribute.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个关键点是，如果数据在节点之间没有变化并且仅使用一次，最简单的方法是将数据硬编码在 Puppet 代码中——例如，直接将文件资源属性中的文件所有者设置为`exampleuser`。
- en: If a value is used multiple times, then there is clearly a value in assigning
    a variable and using this variable where it is required. This simplifies maintenance
    if the value needs to be changed but does mean you have to keep track of variables
    when reading the code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个值被多次使用，那么显然将该值分配给一个变量并在需要的地方使用这个变量是有价值的。如果值需要更改，这简化了维护，但这也意味着在阅读代码时需要跟踪变量。
- en: If, on the other hand, there is variation across nodes and overriding the value
    on certain conditions, the first question should be about how complex the logic
    is. If it is as simple as a single check, then the gain from abstracting into
    Hiera is not big; the issue with abstracting values into Hiera is that they are
    no longer clearly visible looking at the code and require translation and thought.
    So, if simple conditional logic can be used, it’s generally better to keep the
    values in code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果在不同节点之间存在变化，并且需要在某些条件下覆盖该值，首先应该考虑逻辑的复杂性。如果只是一个简单的检查，那么将其抽象到 Hiera 中的收益并不大；将值抽象到
    Hiera 中的问题在于它们在查看代码时不再明显，需要进行翻译和思考。因此，如果可以使用简单的条件逻辑，通常更好的做法是将值保留在代码中。
- en: Once logic becomes more complicated and can vary based on combinations of conditions,
    then we can use Hiera data and an auto parameter lookup, or if it was found to
    be required, the `lookup` function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦逻辑变得更加复杂，并且可能会根据条件的组合而变化，我们可以使用 Hiera 数据和自动参数查找，或者如果有必要的话，使用`lookup`函数。
- en: It is also best throughout this to use the simplest method available at the
    time and escalate through the levels of complexity as code changes and grows.
    Creating complex data structures and performing abstraction for the future simply
    creates complexity and requires more work without really gaining benefits.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个过程中，最好使用当时可用的最简单方法，并随着代码的变化和增长逐步增加复杂性。为了将来创建复杂的数据结构和进行抽象仅仅会增加复杂性，需要更多的工作而无法带来实际的好处。
- en: Keeping data secure
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持数据安全
- en: One of the key elements of managing data is ensuring that secret data is kept
    secure, and this can be challenging with Puppet when this data must be stored,
    transferred across the infrastructure to the client, and used within Puppet code
    to set the state. In this section, we will discuss the methods available to secure
    data, what levels data can be secured at, and the limitations of the methods used
    at each level.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 管理数据的一个关键要素是确保机密数据的安全，使用 Puppet 时，必须将数据存储、传输到客户端并在 Puppet 代码中设置状态，这可能会带来挑战。在本节中，我们将讨论保护数据的可用方法、数据可以在哪些层级上进行保护，以及在每个层级使用的方法的局限性。
- en: 'The most common first step is to secure data in storage. This can be achieved
    using `hiera-eyaml`, a custom Hiera backend available at [https://github.com/voxpupuli/hiera-eyaml](https://github.com/voxpupuli/hiera-eyaml).
    This module creates `pkcs7` keys, which are then used to encrypt and decrypt data.
    Having followed the instructions in the module to create and distribute keys,
    a hierarchy can be created, such as the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的第一步是保护存储中的数据。这可以通过使用`hiera-eyaml`来实现，`hiera-eyaml`是一个可用的自定义 Hiera 后端，地址为[https://github.com/voxpupuli/hiera-eyaml](https://github.com/voxpupuli/hiera-eyaml)。该模块创建`pkcs7`密钥，然后用于加密和解密数据。在按照模块中的指示创建并分发密钥后，可以创建一个层次结构，例如以下示例：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It can simplify the hierarchy to note that the `eyaml` backend can read YAML
    files too, and there’s no reason to separate `yaml` and `eyaml` files into different
    hierarchies assuming their path and options are the same, as shown in the previous
    example.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 可以简化层级结构，注意 `eyaml` 后端也可以读取 YAML 文件，且没有理由将 `yaml` 和 `eyaml` 文件分离到不同的层级中，只要它们的路径和选项相同，如前面的示例所示。
- en: '`hiera-eyaml` is fine for simple encryption and limited numbers of users involved
    with encrypting secrets, but for larger setups, using `gpg` keys with [https://github.com/voxpupuli/hiera-eyaml-gpg](https://github.com/voxpupuli/hiera-eyaml-gpg)
    becomes more practical rather than sharing signing keys amongst multiple teams.
    Once the configuration and key management are done, this simply varies by using
    `gpg_gnugpghome` options rather than `pkcs7` key options, such as the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`hiera-eyaml` 对于简单的加密和涉及有限用户加密秘密的情况是可行的，但对于更大的设置，使用 `gpg` 密钥与 [https://github.com/voxpupuli/hiera-eyaml-gpg](https://github.com/voxpupuli/hiera-eyaml-gpg)
    比在多个团队之间共享签名密钥更为实用。配置和密钥管理完成后，这只需通过使用 `gpg_gnugpghome` 选项而不是 `pkcs7` 密钥选项来变化，例如如下所示：'
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: An alternative to these encrypted data file approaches is if an appropriate
    secure key store exists, such as HashiCorp Vault, or a cloud-native key store,
    such as Azure Key Vault, then using a backend that can access these services will
    ensure data is securely stored.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这些加密数据文件方法的替代方案是，如果存在合适的安全密钥存储，例如 HashiCorp Vault，或云原生密钥存储，如 Azure Key Vault，那么使用能够访问这些服务的后端将确保数据安全存储。
- en: Regardless of the backend choice, this will only ensure the data is secured
    in storage. As was discussed in the *Accessing data* section, by default, Hiera
    will return a string when accessed by Puppet code. `lookup_options` can be used
    to convert the parameter type to `Sensitive` in Puppet 5.5 and above, and care
    should be taken to ensure all secure parameters are covered either via wildcards
    or explicit naming.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 无论选择哪个后端，这仅能确保数据在存储中是安全的。正如在*访问数据*部分所讨论的那样，默认情况下，当通过 Puppet 代码访问时，Hiera 将返回一个字符串。在
    Puppet 5.5 及以上版本中，可以使用`lookup_options`将参数类型转换为`Sensitive`，并应谨慎确保所有安全参数都通过通配符或显式命名来覆盖。
- en: Care must be taken to use the `Sensitive` data type well; it can be easy to
    either mistakenly keep it secured so the value can’t be used where it is needed
    or accidentally expose it when using the `unwrap` function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 必须小心使用 `Sensitive` 数据类型；容易错误地将其保密，使得无法在需要的位置使用它，或在使用 `unwrap` 函数时不小心暴露它。
- en: 'When using `file` and `content`, for example, the following attempt to put
    `secret_value` into a `/etc/secure` file would be exposed on a file diff, which,
    as discussed in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), is when a comparison
    of changes to files is recorded into the report logs:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `file` 和 `content` 时，例如，以下尝试将 `secret_value` 放入 `/etc/secure` 文件中的做法会暴露在文件差异中，正如在
    [*第3章*](B18492_03.xhtml#_idTextAnchor048) 中讨论的那样，这是在报告日志中记录文件变化的比较时：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This could be prevented by setting the `file_diff` parameter to `false` or setting
    the server not to use file diffs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将`file_diff`参数设置为`false`或设置服务器不使用文件差异来防止此问题。
- en: 'Similarly, for templates, care must be taken. If using Puppet 6.2 or greater,
    then templates will work directly with Sensitive values and you can simply use
    the Sensitive value in a template:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于模板，也需要小心。如果使用 Puppet 6.2 或更高版本，模板将直接与 `Sensitive` 值一起工作，你可以在模板中直接使用 `Sensitive`
    值：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For versions below Puppet 6.2, you would need to unwrap the variable in the
    template and then mark the contents as Sensitive, as in this example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于低于 Puppet 6.2 的版本，你需要在模板中解包变量，然后将内容标记为 `Sensitive`，如以下示例所示：
- en: '`content => Sensitive(epp(''example.epp'', { ''password'' =>` `unwrap($secure_password)})),`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`content => Sensitive(epp(''example.epp'', { ''password'' =>` `unwrap($secure_password)})),`'
- en: Using `Sensitive` well keeps the data out of the logs, but unfortunately, not
    the catalog file itself, and if you are using PuppetDB, catalogs will be stored
    there too. In this case, using the `node_encrypt` module available at [https://forge.puppet.com/modules/binford2k/node_encrypt](https://forge.puppet.com/modules/binford2k/node_encrypt)
    allows for any secret to be encrypted in the catalog using the clients’ keys,
    and using a `Deferred` function decrypts them at the time of catalog application.
    This keeps secrets out of the catalog and the report produced after a catalog
    is applied.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 正确使用`Sensitive`选项可以避免将数据记录到日志中，但不幸的是，它不会阻止数据出现在目录文件本身中，如果你正在使用 PuppetDB，目录也会在那里存储。在这种情况下，使用[https://forge.puppet.com/modules/binford2k/node_encrypt](https://forge.puppet.com/modules/binford2k/node_encrypt)中提供的`node_encrypt`模块，可以使用客户端的密钥加密目录中的任何机密数据，并通过使用`Deferred`函数在应用目录时解密这些数据。这可以将机密数据从目录和应用目录后生成的报告中排除。
- en: 'Assuming the instructions to configure `node_encrypt` have been followed on
    the infrastructure, this means the line assigning values to the `content` parameter
    in the previous piece of code could be updated to invoke the `node_encrypt::secret`
    function as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在基础设施上已经按照配置`node_encrypt`的说明进行设置，那么在之前代码中为`content`参数赋值的行可以更新为调用`node_encrypt::secret`函数，如下所示：
- en: '[PRE34]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The current version of `node_encrypt` relies on `Deferred` functions, which
    became available in Puppet 6, so version 0.4.1 needs to be used to work on older
    versions, and you would use the `node_encrypt::file` type instead of the `file`
    type to encrypt file resources.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当前版本的`node_encrypt`依赖于 Puppet 6 中引入的`Deferred`函数，因此在旧版本上工作时需要使用版本 0.4.1，并且应使用`node_encrypt::file`类型，而不是`file`类型来加密文件资源。
- en: This section has shown how to keep data secure in storage, transport to catalog,
    and report processing, and some of the issues that can be experienced. In the
    next section, we will discuss general issues and problems when handling data in
    Hiera.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何确保数据在存储、传输到目录和报告处理中的安全性，以及可能遇到的一些问题。在下一节中，我们将讨论在 Hiera 中处理数据时的常见问题。
- en: Lab – use eyaml to store a secret
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 - 使用eyaml存储秘密数据
- en: In this lab, the `puppet-hiera_eyaml` module has been used to set up `eyaml`
    with default `pkcs` keys, with a global Hiera setup to look at the node name,
    OS, and common values. In `site.pp`, a Hiera lookup is performed to look up the
    value of `secret::examplefiles`, which is used as content to create a `/var/tmp/secret_example`
    file on the Puppet primary server. The lookup has a default of not set. In this
    lab, you will encrypt a secret and add it within the OS level so the content of
    the file changes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本实验中，使用了`puppet-hiera_eyaml`模块来配置默认的`pkcs`密钥，设置了一个全局的Hiera配置，以查看节点名称、操作系统和通用值。在`site.pp`中，执行了一个Hiera查找，用来查找`secret::examplefiles`的值，该值作为内容创建了`/var/tmp/secret_example`文件并将其放置在
    Puppet 主服务器上。查找的默认值未设置。在本实验中，你将加密一个秘密并将其添加到操作系统级别，使得文件的内容发生变化。
- en: 'SSH to the primary server and elevate to root:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: SSH到主服务器并提升为 root 用户：
- en: '[PRE35]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run the `eyaml encrypt –p` command from within the `/etc/puppetlabs/puppet`
    directory and enter a secret of your choice at the prompt:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从`/etc/puppetlabs/puppet`目录中运行`eyaml encrypt –p`命令，并在提示符下输入你选择的秘密数据：
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Copy the output after the string starting with `ENC[` and paste it into the
    data section at `/etc/puppetlabs/puppet/data/os/RedHat.eyaml` so it contains something
    like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将以`ENC[`开头的字符串后面的输出复制，并粘贴到`/etc/puppetlabs/puppet/data/os/RedHat.eyaml`的data部分，使其包含如下内容：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run `puppet agent –t` and observe the change in the `/var/tmp/secret_example`
    content to the content you set.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`puppet agent –t`，观察`/var/tmp/secret_example`的内容变化为你设置的内容。
- en: This was a very simple example and it should be noted, as was highlighted in
    the *Hiera layers* section, that you would more likely be using an environment
    hierarchy and keeping your data secure, as was shown in the *Keeping data secure*
    section, by using the Sensitive option in the lookup `options` parameter. Additionally,
    the public key used for `eyaml` could be copied to a desktop to encrypt secrets,
    if that was secure enough for your organization’s policies.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的示例，需要注意的是，正如*Hiera 层*部分所强调的，你更可能使用环境层次结构并保持数据安全，正如*保持数据安全*部分所示，通过在查找的`options`参数中使用Sensitive选项来实现。此外，`eyaml`使用的公钥可以复制到桌面上以加密秘密数据，前提是这对你所在组织的安全政策足够安全。
- en: Now that we have fully reviewed the Hiera configuration, we will show how we
    can understand issues with lookup and data.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经全面回顾了 Hiera 配置，接下来我们将展示如何理解查找和数据的问题。
- en: Pitfalls, gotchas, and issues
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 陷阱、注意事项和问题
- en: When working in large datasets with multiple levels and layers, it can become
    complicated to understand why certain answers have been generated or where errors
    have been inserted. This section will focus on approaches to understanding and
    debugging data lookups and tools that can make the data more visible.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理包含多个层级和层次的大数据集时，可能会变得很难理解为什么某些答案被生成或错误是如何插入的。本节将专注于理解和调试数据查找的方式，以及可以使数据更清晰的工具。
- en: 'Hiera problems tend to fall into a few categories: syntax, formatting, backend
    communication and performance issues, hierarchy ordering mistakes, and many others.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera的问题通常可以归纳为几个类别：语法、格式、后端通信和性能问题、层级顺序错误等。
- en: The `puppet lookup` command is the best way to test Hiera data and is, in effect,
    like the `lookup` function used in Puppet code. Using this on the primary server,
    the basic syntax of this command is `puppet lookup <key> --node <node_name> --``environment
    <environment_name>`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet lookup`命令是测试Hiera数据的最佳方式，实际上就像在Puppet代码中使用的`lookup`函数一样。在主服务器上使用此命令时，其基本语法是`puppet
    lookup <key> --node <node_name> --environment <environment_name>`。'
- en: This command will return the value, if found, or nothing. It is important to
    understand the effect of the various flags available to the command to return
    more detailed information. A common mistake is to use the `--debug` and `--explain`
    flags together; they shouldn’t be used together as the former is focused on high
    levels of logging to allow you to understand why errors such as syntax, formatting,
    or the backend are being generated, while the latter is focused on showing how
    a value was reached, where Hiera looked, and what it found.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将返回值（如果找到），否则返回空。了解此命令的各种标志的效果非常重要，这些标志可以返回更详细的信息。一个常见的错误是同时使用`--debug`和`--explain`标志；它们不应该一起使用，因为前者侧重于高水平的日志记录，帮助你理解为什么会生成如语法、格式或后端之类的错误，而后者侧重于展示如何得到一个值，Hiera查找了哪里，以及它找到了什么。
- en: 'For example, an `explain` lookup on `motd::content` might look like the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`motd::content`的`explain`查找可能如下所示：
- en: '[PRE38]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Looking at the output from debug, we see far more information with regards
    Facter and other system work going on, as can be seen from the command and sample
    output as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从调试输出中，我们可以看到更多关于Facter和其他系统操作的信息，如下所示的命令和示例输出：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Without a node being provided, the lookup will assume the lookup is for the
    server you are running the command from, and the environment will default to `production`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供节点，查找操作将默认假设查找的是你运行命令的服务器，并且环境将默认设置为`production`。
- en: 'In terms of syntax and formatting problems, one of the most common errors is
    when the opening `---` of the YAML file is malformed. This can happen in a couple
    of ways:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在语法和格式问题方面，最常见的错误之一是YAML文件的开头`---`格式错误。这可能会以几种方式发生：
- en: 'A space is inadvertently added to the start of the line or a Unicode character
    conversion takes place, changing it to `—`. In this case, an error in `debug`
    will look like this:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行的开头不小心添加了空格或发生了Unicode字符转换，导致它变成`—`。在这种情况下，`debug`中的错误将如下所示：
- en: '`Error: Could not run: (<unknown>): mapping values are not allowed in this
    context at line 2` `column 8`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`错误：无法运行：（<unknown>）：在第2行` `第8列`的上下文中不允许映射值'
- en: 'If a space is inserted within the dashes, such as `-- -`, then an error in
    `debug` will be seen like this:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在破折号中间插入了空格，例如`-- -`，那么在`debug`中将看到如下错误：
- en: '`Error: Could not run: (<unknown>): did not find expected ''--'' indicator
    while parsing a block collection at line 1` `column 1`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`错误：无法运行：（<unknown>）：在解析块集合时没有找到预期的`--`指示符，在第1行` `第1列`'
- en: 'Another common syntax mistake is using key-value pairs without a space between
    the colon symbol (`:`) and the value; so `key: value` and `key : value` are valid
    but `key:value` is not and it will error in debugging like so:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '另一个常见的语法错误是使用键值对时，冒号符号（`:`）和值之间没有空格；因此`key: value`和`key : value`是有效的，而`key:value`不是，它在调试时会像下面这样报错：'
- en: '`Error: Could not run: (<unknown>): mapping values are not allowed in this
    context at line 3` `column 10`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`错误：无法运行：（<unknown>）：在第3行` `第10列`的上下文中不允许映射值'
- en: 'If tabs are used instead of spaces for indentation, then in debugging, an error
    will be caused such as the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用制表符而不是空格进行缩进，那么在调试时可能会导致类似以下的错误：
- en: '`Error: Could not run: (<unknown>): found character that cannot start any token
    while scanning for the next token at line 4` `column 1`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error: Could not run: (<unknown>): found character that cannot start any token
    while scanning for the next token at line 4` `column 1`'
- en: For formatting, using single quotes in data with variables will result in a
    literal string of the variable name being returned instead of interpolation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式化时，使用单引号包围包含变量的数据会导致返回变量名的字面字符串，而不是变量插值。
- en: File permissions can also be an issue and, therefore, it is worth ensuring you
    are running the lookup commands as the same user, as Puppet will be typically
    running under the `pe-puppet` or `puppet` user.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 文件权限也可能是一个问题，因此，确保以相同用户身份运行查找命令是值得的，因为 Puppet 通常在`pe-puppet`或`puppet`用户下运行。
- en: Using `--debug`, it can be useful to see whether custom backends are the areas
    that experience issues, errors, or slowdowns. In general, we would recommend examining
    patterns such as the PDS and external data providers.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--debug`，可以帮助查看是否是自定义后端出现问题、错误或性能下降。通常，我们建议检查像 PDS 和外部数据提供者这样的模式。
- en: Be careful to note this will not debug the actual data but only the `hiera.yaml`
    file, data files that are not valid YAML will just be ignored, which can be seen
    using `--explain`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不会调试实际数据，只会调试`hiera.yaml`文件，数据文件如果不是有效的 YAML 格式会被忽略，可以通过`--explain`查看。
- en: In terms of hierarchy problems, this is where the `--explain` flag will prove
    most useful since it will step through explaining the configuration files used,
    the hierarchies found, the merge strategy, and the paths examined in detail so
    that it becomes clear how it stepped through the hierarchy and how it may not
    be working as expected.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构问题方面，`--explain`标志会非常有用，因为它会逐步解释所使用的配置文件、找到的层次结构、合并策略和详细检查的路径，从而清楚地展示它如何逐步遍历层次结构，以及为什么它可能没有按预期工作。
- en: Depending on what variables are being used in your hierarchy, it may be required
    to use the `--compile` flag since, by default, when using Puppet `lookup`, it
    will not perform a catalog compilation, so only the `$facts`, `$trusted`, and
    `$server_facts` variables will be available. We strongly advise against using
    arbitrary values from manifests as these can vastly overcomplicate the lookup
    and produce unpredictable results.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 根据在层次结构中使用的变量，可能需要使用`--compile`标志，因为默认情况下，在使用 Puppet `lookup`时，它不会执行目录编译，因此只有`$facts`、`$trusted`和`$server_facts`变量可用。我们强烈建议避免使用清单中的任意值，因为这些值可能会极大地增加查找的复杂度并产生不可预测的结果。
- en: From this, it can be seen that you always want to use the `Facter` array, to
    avoid the risk of module variables and top-scope `Facter` variables clashing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以看出，你总是应该使用`Facter`数组，以避免模块变量和顶层`Facter`变量冲突的风险。
- en: Some other options can be useful to test what would happen if you changed the
    configuration, such as changing the merge strategy with the `--merge` flag or
    by providing updating facts using `--facts`, for example.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他选项可以用来测试更改配置后会发生什么，比如使用`--merge`标志更改合并策略，或者通过`--facts`提供更新的事实数据等。
- en: The full command reference of options for lookups can be seen at [https://www.puppet.com/docs/puppet/latest/man/lookup.html](https://www.puppet.com/docs/puppet/latest/man/lookup.html).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 查找命令选项的完整命令参考可以在[https://www.puppet.com/docs/puppet/latest/man/lookup.html](https://www.puppet.com/docs/puppet/latest/man/lookup.html)查看。
- en: If updating the global Hiera file, be careful to restart the **Puppet Server
    Services** to ensure it is re-read.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更新全局 Hiera 文件，请小心重启**Puppet 服务器服务**以确保重新读取该文件。
- en: Having touched on the point previously in the *Accessing data* section, we do
    not recommend using defaults on `lookup` functions. Data defaults in modules or
    profiles should be meaningful as well. So, providing the default config file location
    makes sense for a module if you expect most users just to use it, but if it is
    being added just to avoid failure in lookup, that can be a serious mistake and
    will mask issues in Hiera data or code that won’t be noticed, as the code is successfully
    applied with defaults. The key thing to avoid is passing a default value that
    then requires lots of logic in Puppet code to work out how to translate it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面*访问数据*部分中提到过，我们不建议在`lookup`函数中使用默认值。模块或配置文件中的数据默认值应该是有意义的。因此，提供默认的配置文件位置对一个模块来说是有意义的，尤其是如果你期望大多数用户只会使用它。但如果仅仅为了避免查找失败而添加默认值，那可能是一个严重的错误，这会掩盖
    Hiera 数据或代码中的问题，这些问题不会被注意到，因为代码会用默认值成功应用。需要避免的关键问题是，传递一个默认值，然后需要在 Puppet 代码中使用大量逻辑来处理该值。
- en: Classification in Hiera is possible since some users choose to look up Hiera
    data and include classes in the `site.pp` file. Modules such as [https://github.com/ripienaar/puppet-classifier](https://github.com/ripienaar/puppet-classifier)
    focus on this sort of approach. There is a balance of coding structure to consider,
    as can also be seen in our flexible roles and profiles approach. By putting too
    much data into Hiera, it can abstract away from clear coding since the data is
    then not directly visible in the code. So, it is best to consider whether the
    complexity elevation is worth it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hiera中进行分类是可能的，因为一些用户选择查找Hiera数据并将类包含在`site.pp`文件中。像[https://github.com/ripienaar/puppet-classifier](https://github.com/ripienaar/puppet-classifier)这样的模块专注于这种方法。需要考虑代码结构的平衡，正如我们灵活的角色和配置文件方法中所展示的那样。通过将过多数据放入Hiera，它可能会使代码不再直观，因为数据在代码中不直接可见。因此，最好考虑提高复杂度是否值得。
- en: One of the issues of Hiera can be its structure, which makes it inaccessible
    to less involved users. To make Hiera data more visible, **Betadots Hiera Data
    Manager (**[https://forge.puppet.com/modules/betadots/hdm)](https://forge.puppet.com/modules/betadots/hdm
    ) is an excellent option as it allows graphical search, updates, and deletion
    of Hiera data. However, in production environments, this should be limited to
    just viewing data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera的一个问题是其结构，这使得不太参与的用户无法访问。为了让Hiera数据更可见，**Betadots Hiera Data Manager**（[https://forge.puppet.com/modules/betadots/hdm](https://forge.puppet.com/modules/betadots/hdm)）是一个很好的选择，因为它允许图形化搜索、更新和删除Hiera数据。然而，在生产环境中，这应仅限于查看数据。
- en: '![Figure 9.2 – Hiera Data Manager example lookup](img/B18492_09_02.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – Hiera数据管理器示例查找](img/B18492_09_02.jpg)'
- en: Figure 9.2 – Hiera Data Manager example lookup
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – Hiera数据管理器示例查找
- en: Another option to make Hiera data more accessible for self-service is the PDS,
    which will be discussed in detail in [*Chapter 13*](B18492_13.xhtml#_idTextAnchor321).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个让Hiera数据更易于自助服务的选项是PDS，详细内容将在[*第13章*](B18492_13.xhtml#_idTextAnchor321)中讨论。
- en: Lab – troubleshoot Hiera
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室 – 排查Hiera问题
- en: 'Troubleshoot the Hiera data in the production environment:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中排查Hiera数据问题：
- en: 'SSH to the primary server, elevate to root, and deploy the `lab_error` environment:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过SSH连接到主服务器，提升为root用户，并部署`lab_error`环境：
- en: '[PRE40]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Perform a lookup with the `debug` flag of the `profile::error::example` key
    on the primary server in the `lab_error` environment and work through the errors
    found, correcting them in your control repo and running the `code deploy` command
    from the previous step:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`lab_error`环境中的主服务器上，以`debug`标志执行对`profile::error::example`键的查找，并解决发现的错误，纠正`control`仓库中的问题，并运行前一步的`code
    deploy`命令：
- en: '[PRE41]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Resolve the errors in the data in `controlrepo-chapter9/data` and `hiera.yaml`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决`controlrepo-chapter9/data`和`hiera.yaml`中的数据错误。
- en: 'Run the same command with `explain` to understand how it gets to the current
    solution and why it is not finding a value based on its `os.family` fact:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行相同的命令并使用`explain`，以了解它如何到达当前解决方案，并找出为什么它没有基于`os.family`事实找到值：
- en: '[PRE42]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Update the Hiera data in the `control` repo branch, `lab_error`, and redeploy
    so that the lookup now finds the value for the `os.family` fact of the primary
    node:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`control`仓库分支中的Hiera数据，`lab_error`，并重新部署，使得查找现在能找到主节点的`os.family`事实值：
- en: '**puppet code deploy environment** **lab_error --wait**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**puppet code deploy environment** **lab_error --wait**'
- en: '**puppet lookup profile::error::example --debug --****environment lab_error**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**puppet lookup profile::error::example --debug --****environment lab_error**'
- en: Check the commented solutions at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/data_solutions](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/data_solutions).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/data_solutions](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/data_solutions)中的评论解决方案。
- en: 'As part of creating the lab environment in the *Technical requirements* section,
    HDM has been installed using the `puppet-HDM` module. Try using HDM to view the
    data following these steps:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在*技术要求*部分创建实验室环境的一部分，已通过`puppet-HDM`模块安装了HDM。尝试使用HDM按照以下步骤查看数据：
- en: Open a web browser at `http://<public IP` `of puppetserver>:3000`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`http://<public IP` `of puppetserver>:3000`处打开一个网页浏览器。
- en: Complete the signup details to create an admin user (the details are not important).
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成注册详细信息以创建管理员用户（详细信息不重要）。
- en: Click `non-admin user` (the details again are not important).
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`non-admin user`（详细信息同样不重要）。
- en: Click the admin user name on the top right, log out, and then log back in as
    the non-admin user you created.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击右上角的管理员用户名，注销，然后以您创建的非管理员用户身份重新登录。
- en: Select `environment production` and `lab_error` in turn.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依次选择 `environment production` 和 `lab_error`。
- en: Explore the Hiera keys and values visible to HDM in each environment.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索在每个环境中 HDM 可见的 Hiera 键值。
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined how Puppet can handle data using the Hiera tool,
    reducing how much complexity would need to be put into code to represent a node,
    data center, organizational, OS, and other configuration differences. Hiera was
    shown to be a tool based on hierarchies of data that allowed us to access different
    files based on facts. It had built-in backends for data to be stored in YAML,
    JSON, HOCON, and EYAML files. The data structure was shown; we examined how values
    could be put into data files and how lookups can be performed; the types of merge
    were examined here as well as how special setups such as `knockout` prefixes can
    be used in arrays.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨了 Puppet 如何通过 Hiera 工具处理数据，从而减少在代码中表示节点、数据中心、组织、操作系统及其他配置差异所需的复杂性。Hiera
    被证明是一个基于数据层级结构的工具，它允许我们根据事实访问不同的文件。它具有内置的后端，可以将数据存储在 YAML、JSON、HOCON 和 EYAML 文件中。展示了数据结构，我们研究了如何将值放入数据文件以及如何执行查找；这里还考察了合并类型，以及如何在数组中使用如
    `knockout` 前缀等特殊设置。
- en: We then showed how some custom backends can be used that have data types on
    different profiles; typically, these are specific integrations such as Vault or
    EYAML from the Forge, or in-house developed integrations to access data.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们展示了一些可以使用的自定义后端，这些后端具有不同配置文件上的数据类型；通常，这些是特定的集成工具，如 Vault 或来自 Forge 的 EYAML，或者是公司内部开发的集成工具，用于访问数据。
- en: We then covered how Hiera worked over three layers – global, environment, and
    module – showing how global layers had little purpose in a modern Puppet setup
    but can be used as an override system, environment as the main source for data,
    and module allowing for defaults to be set on modules. Some common approaches
    to structuring hierarchies were then discussed, including an approach that stepped
    through the name of the node, the node owner, the node’s purpose, the location
    of the node, and common to all nodes’ data.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讲解了 Hiera 如何在三个层级上工作——全局、环境和模块——展示了全局层在现代 Puppet 设置中的作用较小，但可以作为覆盖系统使用，环境作为数据的主要来源，模块则允许为模块设置默认值。然后讨论了一些常见的层级结构设计方法，包括一种通过节点名称、节点所有者、节点目的、节点位置和所有节点共同的数据来逐步构建的方式。
- en: A review of how to make decisions on whether to use data in code or in Hiera
    showed that it depended on how flexible data needed to be, and this can vary from
    static data that is hardcoded in Puppet code to more advanced and flexible data
    requiring the full hierarchy to be described accurately. It was advised not to
    build ahead but to refactor as required so as not to make data more complicated
    than it needs to be.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何决定是在代码中使用数据还是在 Hiera 中使用数据的回顾显示，这取决于数据需要的灵活性，而这从硬编码在 Puppet 代码中的静态数据到需要精确描述完整层级结构的更复杂灵活的数据都有不同的需求。建议不要提前构建，而是根据需要重构，以避免使数据变得比实际需求更复杂。
- en: We then discussed how to keep data secure in storage and transport, and when
    being used in Puppet catalogs, reports, and PuppetDB. We saw how to use `eyaml`
    to secure data in storage by encrypting values with the more flexible PGP approach,
    allowing multiple keys and teams. Then, the `Sensitive` value was shown to ensure
    values were not exposed in logs or code. This did not prevent values in catalogs
    and reports, and the `node_encrypt` module was shown to allow resources and values
    to be encrypted and be applied at configuration time using `Deferred` functions.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们讨论了如何确保数据在存储和传输中的安全性，以及在 Puppet catalogs、报告和 PuppetDB 中使用时的安全性。我们展示了如何使用
    `eyaml` 通过更灵活的 PGP 方法加密值来确保存储中的数据安全，这允许多个密钥和团队的使用。然后，展示了 `Sensitive` 值，以确保值不会暴露在日志或代码中。这不会防止在
    catalogs 和报告中暴露值，`node_encrypt` 模块被展示用于在配置时加密资源和值，并通过 `Deferred` 函数应用。
- en: Approaches to debugging and troubleshooting were then reviewed, highlighting
    the difference between `--explain` and `--debug`. The former allows an understanding
    of how the hierarchy was reviewed and the latter returns errors such as syntax
    and failures with backends. The advice was given to be careful with using Hiera
    as a classifier, as this would abstract classification information away from code,
    but highlighted that the PDS did use this approach in later chapters.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后回顾了调试和故障排除的方法，重点介绍了`--explain`和`--debug`之间的区别。前者可以帮助理解如何审查层级结构，后者则返回如语法错误和后端失败等错误。建议小心使用
    Hiera 作为分类器，因为这会将分类信息从代码中抽象出来，但也强调在后续章节中 PDS 确实采用了这种方法。
- en: In the next chapter, having reviewed the Puppet language in detail, the focus
    will change to the Puppet infrastructure. We will examine the open source components
    that make up the Puppet platform, how they make themselves available to the system
    via APIs, and how they communicate and log. The full Puppet agent life cycle will
    be examined, looking at the process of agent registration and communication with
    the platform. PuppetDB and PostgreSQL will be seen to allow the storage of data
    such as facts, reports, and catalogs, allowing discovery and examination with
    the **Puppet Query Language** (**PQL**). Compile servers will then be discussed
    as Puppet’s method of scaling horizontally.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，在详细回顾了Puppet语言之后，焦点将转向Puppet基础设施。我们将审视构成Puppet平台的开源组件，它们如何通过API向系统提供服务，以及它们如何进行通信和日志记录。将详细探讨Puppet代理的完整生命周期，包括代理注册过程及其与平台的通信。PuppetDB和PostgreSQL将被用来存储诸如事实、报告和清单等数据，并允许通过**Puppet查询语言**（**PQL**）进行发现和审查。然后，我们将讨论编译服务器作为Puppet水平扩展的方法。
- en: Part 3 – The Puppet Platform and Bolt Orchestration
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3部分 – Puppet平台和Bolt编排
- en: In this part, you will understand how Puppet is structured as a platform, how
    the various components work together and communicate, and the common architecture
    approaches used to deliver scale. We will then show the various methods that can
    be used to classify which code is applied to servers and how code is versioned
    and deployed to infrastructure. Bolt will be introduced as Puppet’s way of running
    procedural scripts and code, which can be traditional scripts in various languages
    or plans based on the Puppet language. We will then review how you can monitor,
    tune, and integrate Puppet infrastructure with various tools and third-party products.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你将了解Puppet是如何作为一个平台构建的，各个组件如何协作和通信，以及用于实现规模的常见架构方法。接下来我们将展示可以用来分类哪些代码应用到服务器上的各种方法，以及如何对代码进行版本控制和部署到基础设施。Bolt将作为Puppet执行过程脚本和代码的方式被介绍，它可以是传统脚本，也可以是基于Puppet语言的计划。然后我们将回顾如何通过各种工具和第三方产品来监控、调整和集成Puppet基础设施。
- en: 'This part has the following chapters:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分包含以下章节：
- en: '[*Chapter 10*](B18492_10.xhtml#_idTextAnchor252), *Puppet Platform Parts and
    Functions*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18492_10.xhtml#_idTextAnchor252)，*Puppet平台的组成部分和功能*'
- en: '[*Chapter 11*](B18492_11.xhtml#_idTextAnchor272), *Classification and Release
    Management*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18492_11.xhtml#_idTextAnchor272)，*分类和发布管理*'
- en: '[*Chapter 12*](B18492_12.xhtml#_idTextAnchor293), *Bolt for Orchestration*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18492_12.xhtml#_idTextAnchor293)，*用于编排的Bolt*'
- en: '[*Chapter 13*](B18492_13.xhtml#_idTextAnchor321), *Taking Puppet Server Further*'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B18492_13.xhtml#_idTextAnchor321)，*进一步使用Puppet服务器*'
