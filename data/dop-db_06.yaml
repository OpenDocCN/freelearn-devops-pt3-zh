- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Non-Relational DMSs with DevOps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非关系型 DMS 与 DevOps
- en: In this chapter, we will navigate the intricate yet fascinating landscape of
    integrating non-relational database management systems (also known as NoSQL) with
    DevOps. We will begin by examining the pivotal role that data modeling plays in
    NoSQL databases, shedding light on how it differs from its counterpart in relational
    databases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨将非关系型数据库管理系统（也称为 NoSQL）与 DevOps 集成的复杂而迷人的领域。我们将从数据建模在 NoSQL 数据库中所扮演的关键角色开始，揭示它与关系型数据库中的数据建模的不同之处。
- en: Then, we will explore schema management. As NoSQL databases offer flexible schemas,
    we’ll delve into how this flexibility can be both an asset and a challenge when
    managed within a DevOps framework. From there, we’ll move on to the crucial topic
    of deployment automation, where we will discuss how automated tools and workflows
    can greatly streamline the deployment process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨模式管理。由于 NoSQL 数据库提供灵活的模式，我们将深入分析这种灵活性在 DevOps 框架下既是资产又是挑战的原因。从这里，我们将转向至关重要的部署自动化话题，讨论如何通过自动化工具和工作流大大简化部署过程。
- en: Performance tuning will also command our attention. As the scale of data grows
    exponentially, we’ll learn how to fine-tune our NoSQL databases to meet the demanding
    performance criteria that modern applications require. Subsequently, data consistency
    in a distributed, NoSQL environment will come under the lens, and we’ll learn
    strategies to maintain it effectively.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 性能调优也将成为我们关注的重点。随着数据量的指数增长，我们将学习如何对 NoSQL 数据库进行精细调优，以满足现代应用所需的严格性能标准。随后，分布式
    NoSQL 环境中的数据一致性将成为我们重点探讨的内容，我们将学习如何有效保持数据一致性。
- en: Security, an ever-pressing concern, will not be left out of our discussion.
    We’ll scrutinize the best practices and mechanisms that can safeguard our data
    and infrastructure, aligning them seamlessly with DevOps protocols.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性，作为一个日益紧迫的关注点，也将包含在我们的讨论中。我们将审视能够保护数据和基础设施的最佳实践和机制，并将其与 DevOps 协议无缝对接。
- en: Lastly, but just as importantly, we’ll look at anti-patterns, or what not to
    do when combining NoSQL and DevOps. This section will serve as a cautionary tale,
    guiding us away from common pitfalls and steering us toward successful implementation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们将探讨反模式，或者说在将 NoSQL 与 DevOps 结合时不该做的事。本节将作为一个警示故事，帮助我们避开常见的陷阱，引导我们走向成功的实施之路。
- en: Throughout this chapter, you will gain actionable insights and real-world applications
    of each key milestone. The aim is not just to inform but also to equip you with
    practical knowledge that you can readily apply to your own systems. Let’s embark
    on this educational journey to discover how non-relational Database Managements
    Systems (DMSs) and DevOps can work in harmony to create robust, scalable, and
    efficient systems.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将获得每个关键里程碑的可操作见解和实际应用。我们的目标不仅是提供信息，还要为您提供实用的知识，以便您可以将其迅速应用到自己的系统中。让我们一起踏上这段教育旅程，探索非关系型数据库管理系统（DMSs）与
    DevOps 如何协调工作，打造强大、可扩展且高效的系统。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主要话题：
- en: Activities and challenges
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动与挑战
- en: Data modeling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据建模
- en: Schema management
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式管理
- en: Deployment automation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署自动化
- en: Performance tuning
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能调优
- en: Data consistency
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据一致性
- en: Security
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: Anti-patterns (what not to do…)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反模式（不该做的事……）
- en: Activities and challenges
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动与挑战
- en: 'As part of the DevOps team, some of the main activities and challenges when
    working with non-relational databases include data modeling, schema management,
    and deployment automation, as detailed here, along with other examples:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 DevOps 团队的一部分，使用非关系型数据库时的一些主要活动和挑战包括数据建模、模式管理和部署自动化，如此处详细介绍的，还有其他一些例子：
- en: '**Data modeling**: When working with non-relational databases, data modeling
    requires a different approach compared to traditional relational databases. One
    example of this is choosing the right data structure for the type of data being
    stored. For instance, if storing hierarchical data, a document-based database
    such as MongoDB may be more suitable than a relational database. In a relational
    database, this could be handled using a recursive query, but this would be less
    efficient and more complicated.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据建模**：在使用非关系型数据库时，数据建模需要与传统的关系型数据库采用不同的方法。一个例子是为存储的数据类型选择合适的数据结构。例如，如果存储的是层次结构数据，那么基于文档的数据库（如
    MongoDB）可能比关系型数据库更适合。在关系型数据库中，可以通过递归查询来处理这种情况，但这样做效率较低且更加复杂。'
- en: '**Schema management**: Unlike relational databases, non-relational databases
    don’t require a fixed schema, which can make schema management more challenging.
    One example of this is handling schema migrations, which can be trickier to manage
    when there isn’t a predefined schema to work with. In a relational database, schema
    migrations can be handled through SQL scripts that update the schema, but in a
    non-relational database, you may be required to write custom code or use third-party
    tools.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**架构管理**：与关系型数据库不同，非关系型数据库不需要固定的架构，这可能使架构管理变得更加具有挑战性。一个例子是处理架构迁移，当没有预定义的架构时，迁移的管理可能会更加棘手。在关系型数据库中，架构迁移可以通过SQL脚本来更新架构，但在非关系型数据库中，可能需要编写自定义代码或使用第三方工具。'
- en: '**Deployment automation**: Automating the deployment of non-relational databases
    can be more complex than for relational databases. One example of this is configuring
    the database for high availability and disaster recovery. In a relational database,
    this can be achieved using replication, but in a non-relational database, it may
    require setting up a distributed system or using a cloud-based service.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署自动化**：非关系型数据库的部署自动化可能比关系型数据库更复杂。一个例子是为高可用性和灾难恢复配置数据库。在关系型数据库中，这可以通过复制来实现，但在非关系型数据库中，可能需要设置分布式系统或使用基于云的服务。'
- en: '**Performance tuning**: Non-relational databases often require specific performance
    tuning, depending on the use case. For example, in a document-based database,
    indexes need to be optimized based on the data access patterns. In contrast, a
    relational database typically relies on query optimization and table design to
    achieve optimal performance.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能调优**：非关系型数据库通常需要根据使用场景进行特定的性能调优。例如，在基于文档的数据库中，需要根据数据访问模式优化索引。相反，关系型数据库通常依赖查询优化和表设计来实现最佳性能。'
- en: '**Data consistency**: Unlike relational databases, non-relational databases
    may not enforce strict data consistency across multiple nodes in a distributed
    system. For example, in a document-based database, data may be replicated asynchronously,
    which could result in data inconsistencies. To address this challenge, non-relational
    databases often provide mechanisms to maintain eventual consistency, such as conflict
    resolution algorithms or read-after-write consistency.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据一致性**：与关系型数据库不同，非关系型数据库可能不会强制在分布式系统的多个节点之间保持严格的数据一致性。例如，在基于文档的数据库中，数据可能会异步复制，这可能导致数据不一致。为了解决这个问题，非关系型数据库通常提供机制来维护最终一致性，例如冲突解决算法或写后读一致性。'
- en: '**Security**: Non-relational databases may have different security concerns
    than relational databases, such as preventing unauthorized access to specific
    documents or collections. For example, in a graph database, access control may
    need to be implemented at the node or edge level. In contrast, a relational database
    typically uses role-based access control at the database or table level.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：非关系型数据库可能会面临不同于关系型数据库的安全问题，例如防止对特定文档或集合的未经授权访问。例如，在图形数据库中，可能需要在节点或边缘级别实施访问控制。而关系型数据库通常在数据库或表级别使用基于角色的访问控制。'
- en: Let’s dive deeper into each of these points.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨这些要点。
- en: Data modeling
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据建模
- en: Let’s review together three unique challenges around data modeling that are
    specific to non-relational databases.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起回顾一下非关系型数据库特有的三个数据建模挑战。
- en: Denormalization
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非规范化
- en: In non-relational databases, it’s common to use denormalized data models where
    data is duplicated across multiple documents or collections. This is done to improve
    query performance and avoid expensive joins. In contrast, relational databases
    emphasize normalization, where data is organized into separate tables to avoid
    duplication and maintain data integrity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在非关系型数据库中，通常使用非规范化的数据模型，其中数据会在多个文档或集合之间进行复制。这么做是为了提高查询性能并避免昂贵的连接操作。与之相对，关系型数据库强调规范化，数据被组织成独立的表，以避免重复并保持数据完整性。
- en: Denormalization can introduce unique challenges around data consistency and
    update anomalies. When data is denormalized, it can lead to redundant or inconsistent
    data, which can be difficult to manage. For example, if a customer’s address is
    stored in multiple documents, updating the address in one document may not propagate
    to all the other documents, leading to inconsistent data.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 反规范化可能会引入数据一致性和更新异常方面的独特挑战。当数据被反规范化时，可能会导致冗余或不一致的数据，这些数据可能很难管理。例如，如果客户的地址存储在多个文档中，更新一个文档中的地址可能不会传播到所有其他文档，导致数据不一致。
- en: 'Here’s an example of a denormalized data model in MongoDB:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 MongoDB 中一个反规范化数据模型的示例：
- en: MongoDB
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the book’s title and author are duplicated across multiple
    documents, and the book’s genres and reviews are stored as arrays within the same
    document. This makes it easier to retrieve all the relevant information about
    a book in a single query, but it also introduces the risk of inconsistent data
    if one of the reviews is updated or deleted.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，书籍的标题和作者在多个文档中被重复存储，书籍的类别和评论被作为数组存储在同一个文档内。这使得通过单次查询即可获取与书籍相关的所有信息，但如果某一条评论被更新或删除，也会引入数据不一致的风险。
- en: Nested and dynamic data
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套和动态数据
- en: Non-relational databases are designed to handle nested and dynamic data structures,
    such as JSON or XML documents. This makes it easier to store and retrieve complex
    data structures, but it also introduces unique challenges around indexing and
    querying. In contrast, relational databases have fixed column definitions, which
    makes it more difficult to store and query nested or dynamic data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库被设计用来处理嵌套和动态数据结构，例如 JSON 或 XML 文档。这使得存储和检索复杂数据结构更加容易，但也带来了在索引和查询方面的独特挑战。相比之下，关系型数据库有固定的列定义，这使得存储和查询嵌套或动态数据变得更加困难。
- en: 'Nested data structures are common in non-relational databases, where data is
    stored as a hierarchical tree-like structure. Here’s an example of a nested document
    in MongoDB:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套数据结构在非关系型数据库中很常见，其中数据以树状结构的层次形式存储。以下是 MongoDB 中一个嵌套文档的示例：
- en: MongoDB
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, the `name` and `address` fields are nested within the document,
    which makes it easier to query and update data as a single entity. However, querying
    nested data can be challenging, as it requires traversing the entire tree to find
    the desired data. To address this, non-relational databases often use indexes
    to speed up queries on nested data.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`name` 和 `address` 字段嵌套在文档内，这使得可以将数据作为单一实体查询和更新。然而，查询嵌套数据可能具有挑战性，因为它需要遍历整个树形结构来找到所需的数据。为了解决这个问题，非关系型数据库通常使用索引来加速对嵌套数据的查询。
- en: 'Dynamic data structures are also common in non-relational databases, where
    data can have varying types and properties. For example, a document-based database
    such as MongoDB can store documents with different structures in the same collection.
    Here’s an example of a dynamic document in MongoDB:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数据结构在非关系型数据库中也很常见，在这些数据库中，数据可以具有不同的类型和属性。例如，像 MongoDB 这样的文档型数据库可以在同一个集合中存储具有不同结构的文档。以下是
    MongoDB 中一个动态文档的示例：
- en: MongoDB
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, the `address` field is optional, and the document can contain
    any combination of the `name`, `age`, `email`, `phone`, and `address` fields.
    This flexibility can make it easier to store and retrieve data, but it also introduces
    challenges around data validation and indexing.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`address` 字段是可选的，文档可以包含任何组合的 `name`、`age`、`email`、`phone` 和 `address`
    字段。这种灵活性使得存储和检索数据更加容易，但也带来了数据验证和索引方面的挑战。
- en: Data denormalization
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据反规范化
- en: Non-relational databases often use data denormalization to avoid expensive joins
    and improve query performance. Data denormalization involves duplicating data
    across multiple documents or collections so that related data can be retrieved
    together, without having to perform a join operation.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库经常使用数据反规范化来避免昂贵的连接操作，并提高查询性能。数据反规范化涉及将数据复制到多个文档或集合中，以便可以在不执行连接操作的情况下一起检索相关数据。
- en: However, denormalization can introduce unique challenges around data consistency
    and update anomalies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，反规范化可能会带来数据一致性和更新异常方面的独特挑战。
- en: 'Here’s an example of data denormalization in a document-based database:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于文档的数据库中的数据反规范化示例：
- en: MongoDB
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, the `similar_books` field is denormalized, with the title and
    author of related books stored within the same document. This makes it easier
    to retrieve related data without performing a separate join operation, but it
    also introduces the risk of inconsistent data if one of the related books is updated
    or deleted.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`similar_books` 字段是非规范化的，相关书籍的标题和作者存储在同一个文档内。这使得在不执行单独的连接操作的情况下，更容易检索相关数据，但如果其中一本相关书籍被更新或删除，也可能导致数据不一致的风险。
- en: To address these challenges, non-relational databases offer several features
    and techniques, such as schemaless design, document validation, indexing, and
    sharding.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些挑战，非关系型数据库提供了多个功能和技术，例如无模式设计、文档验证、索引和分片。
- en: Schemaless design means that non-relational databases do not require a predefined
    schema, which makes it easier to store and retrieve data with varying structures.
    Document validation can be used to ensure that data conforms to a specific schema,
    preventing inconsistencies and improving data quality.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 无模式设计意味着非关系型数据库不需要预定义的模式，这使得存储和检索具有不同结构的数据变得更加容易。可以使用文档验证来确保数据符合特定的模式，防止不一致并提高数据质量。
- en: Indexing can be used to speed up queries on nested and dynamic data, by creating
    indexes on specific fields or sub-fields. Sharding can be used to scale non-relational
    databases horizontally across multiple nodes, improving performance and availability.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过为特定字段或子字段创建索引，利用索引加速对嵌套和动态数据的查询。分片可以用来将非关系型数据库水平扩展到多个节点，从而提高性能和可用性。
- en: In summary, non-relational databases offer unique advantages and challenges
    around data modeling, compared to relational databases. While non-relational databases
    offer more flexibility and scalability, they also require a different approach
    to data modeling and management. DevOps teams working with non-relational databases
    need to be familiar with these unique challenges and techniques, ensuring that
    their infrastructure is stable and scalable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，与关系型数据库相比，非关系型数据库在数据建模方面提供了独特的优势和挑战。虽然非关系型数据库提供了更多的灵活性和可扩展性，但它们也需要不同的数据建模和管理方法。与非关系型数据库一起工作的
    DevOps 团队需要熟悉这些独特的挑战和技术，确保他们的基础设施稳定且具有可扩展性。
- en: Schema management
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式管理
- en: Let’s review together three unique challenges around schema management that
    are specific to non-relational databases.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起回顾三个与模式管理相关的独特挑战，这些挑战是非关系型数据库特有的。
- en: Schemaless data modeling
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无模式数据建模
- en: One of the main characteristics of non-relational databases is that they offer
    a schemaless data modeling approach. This means that they don’t enforce a fixed
    schema on the data and allow for flexible and dynamic data structures. While this
    can provide many benefits, such as faster iteration and easier scalability, it
    can also present some challenges in schema management.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库的主要特点之一是它们提供无模式的数据建模方法。这意味着它们不强制执行固定的模式，而是允许灵活和动态的数据结构。虽然这可以带来许多好处，例如更快的迭代和更容易的可扩展性，但在模式管理方面也可能带来一些挑战。
- en: In a schemaless database, there may not be a standard way to define or enforce
    the structure of data. This can make it difficult to ensure data consistency and
    quality across different documents. Additionally, it can be challenging to maintain
    compatibility and manage schema changes over time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个无模式数据库中，可能没有标准的方法来定义或强制执行数据的结构。这使得确保不同文档之间的数据一致性和质量变得困难。此外，随着时间的推移，维护兼容性和管理模式变化也可能面临挑战。
- en: 'For example, in a document-oriented database such as Couchbase, data can be
    stored in JSON documents with any arbitrary structure. Here’s an example of a
    JSON document:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在像 Couchbase 这样的面向文档的数据库中，数据可以以具有任意结构的 JSON 文档的形式存储。以下是一个 JSON 文档的示例：
- en: JSON
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: JSON
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the document has a top-level field called `type` that denotes
    the type of document, as well as a nested `address` field that represents a complex
    structure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，文档有一个顶级字段 `type`，表示文档的类型，同时还有一个嵌套的 `address` 字段，表示一个复杂的结构。
- en: To address the challenges of schemaless data modeling, non-relational databases
    provide features such as schema validation, which allows developers to define
    and enforce the structure of data. This can help ensure data consistency and quality
    across different documents.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决无模式数据建模的挑战，非关系型数据库提供了一些功能，例如模式验证，允许开发人员定义和强制执行数据的结构。这有助于确保不同文档之间的数据一致性和质量。
- en: Dynamic schema evolution
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态模式演化
- en: Non-relational databases also often allow for dynamic schema evolution, which
    means that a schema can change over time to adapt to new requirements or data
    models. This can present some challenges in schema management, especially if the
    schema changes are not carefully planned and managed.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库通常也允许动态架构演进，这意味着架构可以随着时间变化以适应新的需求或数据模型。这可能会在架构管理中带来一些挑战，特别是当架构变化没有经过仔细规划和管理时。
- en: In a dynamically evolving schema, the structure of the data can change frequently,
    which can make it challenging to maintain backward and forward compatibility.
    Additionally, it can be difficult to ensure that all documents conform to the
    latest schema version.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态变化的架构中，数据的结构可能经常发生变化，这可能使得保持向后和向前兼容变得具有挑战性。此外，确保所有文档符合最新架构版本也可能很困难。
- en: 'For example, in a graph database such as Neo4j, the structure of data can change
    over time as new nodes and relationships are added. Here’s an example of schema
    evolution in Neo4j:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在像 Neo4j 这样的图数据库中，随着新节点和关系的添加，数据的结构可能会随时间变化。以下是 Neo4j 中架构演进的一个示例：
- en: Neo4j
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, an initial schema is created for a social network, with a `User`
    node and a `Post` node connected by a `POSTED` relationship. The `User` node does
    not have an `email` field.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，为一个社交网络创建了初始架构，其中有一个 `User` 节点和一个 `Post` 节点，通过一个 `POSTED` 关系连接。`User`
    节点没有 `email` 字段。
- en: To evolve the schema, a new `email` field is added to the `User` node, using
    the `ALTER` command. Additionally, a new label called `Article` is added to the
    `Post` node, and the `Post` label is removed using the `CREATE LABEL` and `REMOVE`
    commands.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演进架构，向 `User` 节点添加了一个新的 `email` 字段，使用 `ALTER` 命令实现。此外，向 `Post` 节点添加了一个新的标签
    `Article`，并使用 `CREATE LABEL` 和 `REMOVE` 命令移除了 `Post` 标签。
- en: To address the challenges of dynamic schema evolution, non-relational databases
    provide features such as versioning and migration tools. These tools can help
    manage changes to the schema and ensure that all documents conform to the latest
    schema version.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决动态架构演进的挑战，非关系型数据库提供了版本控制和迁移工具等功能。这些工具有助于管理架构变化，确保所有文档符合最新架构版本。
- en: Consistency and concurrency control
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致性和并发控制
- en: Another challenge in non-relational schema management is ensuring consistency
    and concurrency control in a distributed environment. Non-relational databases
    often use distributed architectures to achieve scalability and availability, which
    can create challenges in ensuring that data is consistent across different nodes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型架构管理中的另一个挑战是在分布式环境中确保一致性和并发控制。非关系型数据库通常使用分布式架构来实现可扩展性和高可用性，这可能会在确保数据在不同节点之间一致性时带来挑战。
- en: In a distributed database environment, different nodes may have different versions
    of the same data, which can lead to conflicts and inconsistency. Additionally,
    concurrency control can be challenging in a distributed environment, as multiple
    nodes can access and update the same data simultaneously.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式数据库环境中，不同节点可能拥有相同数据的不同版本，这可能导致冲突和不一致。此外，在分布式环境中，多个节点可以同时访问和更新相同的数据，因此并发控制也变得更加具有挑战性。
- en: 'For example, in a key-value store such as Redis, concurrency control can be
    achieved through the use of optimistic locking. Here’s an example of optimistic
    locking in Redis:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在像 Redis 这样的键值存储中，可以通过使用乐观锁实现并发控制。以下是 Redis 中乐观锁的一个示例：
- en: JavaScript
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, the value of a counter is retrieved from Redis using the `get`
    method. The counter is then incremented using optimistic locking, which involves
    using the `watch` method to monitor the `counter` key for changes. If the `counter`
    key is modified by another process, the optimistic locking loop retries the transaction.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，使用 `get` 方法从 Redis 获取计数器的值。然后使用乐观锁对计数器进行递增操作，乐观锁通过使用 `watch` 方法监控 `counter`
    键的变化。如果 `counter` 键被另一个进程修改，乐观锁循环会重试事务。
- en: To address the challenges of consistency and concurrency control, non-relational
    databases provide features such as distributed locking, versioning, and conflict
    resolution. These features can help ensure that data is consistent and up to date
    across different nodes in a distributed environment.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对一致性和并发控制的挑战，非关系型数据库提供了分布式锁、版本控制和冲突解决等功能。这些功能有助于确保在分布式环境中不同节点之间的数据一致性和实时更新。
- en: Non-relational databases present unique challenges around schema management
    compared to relational databases. These challenges include schemaless data modeling,
    dynamic schema evolution, and consistency and concurrency control in a distributed
    environment. To address these challenges, non-relational databases provide features
    such as schema validation, versioning, migration tools, and distributed locking.
    DevOps teams working with non-relational databases need to be familiar with these
    unique challenges and techniques, ensuring that their infrastructure is stable
    and scalable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与关系型数据库相比，非关系型数据库在模式管理方面面临独特的挑战。这些挑战包括无模式的数据建模、动态模式演化以及在分布式环境中的一致性和并发控制。为了应对这些挑战，非关系型数据库提供了如模式验证、版本控制、迁移工具和分布式锁等功能。与非关系型数据库合作的
    DevOps 团队需要熟悉这些独特的挑战和技术，确保其基础设施稳定且具有可扩展性。
- en: Deployment automation
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署自动化
- en: Deployment automation is an important aspect of DevOps for both relational and
    non-relational databases, but there are some unique challenges around deployment
    automation for non-relational databases. Here are three challenges specific to
    non-relational databases, along with explanations and code snippets.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 部署自动化是 DevOps 中关系型和非关系型数据库的重要方面，但在非关系型数据库的部署自动化方面存在一些独特的挑战。以下是与非关系型数据库相关的三个挑战，并附有解释和代码示例。
- en: Deployment of multiple database engines
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多数据库引擎的部署
- en: Non-relational databases often have different database engines, each with its
    own set of deployment and management requirements. For example, a NoSQL database
    such as Cassandra may have different deployment requirements than a document-oriented
    database such as MongoDB.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库通常具有不同的数据库引擎，每个引擎都有自己的一套部署和管理要求。例如，像 Cassandra 这样的 NoSQL 数据库可能与面向文档的数据库（如
    MongoDB）有不同的部署要求。
- en: Deploying and managing multiple database engines can be challenging, as it requires
    specialized knowledge and expertise for each engine. Additionally, it can be difficult
    to maintain consistency across different database engines, especially if they
    have different APIs and query languages.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 部署和管理多个数据库引擎可能具有挑战性，因为每个引擎都需要专门的知识和经验。此外，由于不同数据库引擎可能具有不同的 API 和查询语言，保持它们之间的一致性也可能非常困难。
- en: To address this challenge, DevOps teams may use configuration management tools
    such as Ansible or Chef to automate the deployment and management of different
    database engines. These tools allow for the automation of tasks such as installing
    software, configuring servers, and deploying databases.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个挑战，DevOps 团队可能会使用配置管理工具（如 Ansible 或 Chef）来自动化不同数据库引擎的部署和管理。这些工具可以自动化执行诸如安装软件、配置服务器和部署数据库等任务。
- en: 'Here’s an example of deploying Cassandra using Ansible:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用 Ansible 部署 Cassandra 的示例：
- en: YAML
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: YAML
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, Ansible is used to add the Cassandra repository to the APT
    package manager, install the Cassandra package, and start the Cassandra service.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用 Ansible 将 Cassandra 仓库添加到 APT 包管理器中，安装 Cassandra 包并启动 Cassandra 服务。
- en: Backup and disaster recovery
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份和灾难恢复
- en: Non-relational databases often require specialized backup and disaster recovery
    strategies, due to the different data structures and distributed architectures
    used by these databases. For example, a key-value store, such as Redis, may use
    a distributed architecture that requires different backup and recovery strategies
    than a document-oriented database, such as Couchbase.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库由于使用了不同的数据结构和分布式架构，通常需要专门的备份和灾难恢复策略。例如，像 Redis 这样的键值存储可能使用分布式架构，因此需要与面向文档的数据库（如
    Couchbase）不同的备份和恢复策略。
- en: Backing up and restoring data in a non-relational database can be complex, as
    it often involves managing data across multiple nodes and ensuring that it is
    consistent and up to date. Additionally, disaster recovery can be challenging
    in a distributed environment, as different nodes may have different versions of
    the same data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在非关系型数据库中备份和恢复数据可能很复杂，因为它通常涉及管理多个节点上的数据，并确保数据一致且保持最新。此外，在分布式环境中进行灾难恢复也具有挑战性，因为不同的节点可能有相同数据的不同版本。
- en: To address this challenge, DevOps teams may use specialized backup and recovery
    tools for non-relational databases, such as the AWS Backup service for Amazon
    DynamoDB. These tools allow for the automated backup and recovery of data across
    different nodes, and they can help ensure data consistency and up-to-date backups.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这一挑战，DevOps 团队可以使用专门的备份和恢复工具，用于非关系型数据库，如 Amazon DynamoDB 的 AWS Backup 服务。这些工具允许跨不同节点进行自动化的备份和恢复，并帮助确保数据一致性和最新的备份。
- en: 'Here’s an example of backing up and restoring data in DynamoDB using the AWS
    Backup service:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 AWS Backup 服务备份和恢复 DynamoDB 数据的示例：
- en: AWS CLI
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'apiVersion: autoscaling/v2beta2'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: autoscaling/v2beta2'
- en: 'kind: HorizontalPodAutoscaler'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: HorizontalPodAutoscaler'
- en: 'metadata:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 'metadata:'
- en: 'name: cassandra'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: cassandra'
- en: 'spec:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'spec:'
- en: 'scaleTargetRef:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'scaleTargetRef:'
- en: 'apiVersion: apps/v1'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'apiVersion: apps/v1'
- en: 'kind: StatefulSet'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 'kind: StatefulSet'
- en: 'name: cassandra'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: cassandra'
- en: 'minReplicas: 3'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'minReplicas: 3'
- en: 'maxReplicas: 10'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 'maxReplicas: 10'
- en: 'metrics:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'metrics:'
- en: '- type: Resource'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '- type: Resource'
- en: 'resource:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'resource:'
- en: 'name: cpu'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 'name: cpu'
- en: 'target:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'target:'
- en: 'type: Utilization'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 'type: Utilization'
- en: 'averageUtilization: 70'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 'averageUtilization: 70'
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: // Create an index on the Person node's name property
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: // 在 Person 节点的 name 属性上创建索引
- en: CREATE INDEX ON :Person(name)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE INDEX ON :Person(name)
- en: // Query for all people with the name "Alice"
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: // 查询所有名字为 "Alice" 的人
- en: 'MATCH (p:Person {name: ''Alice''})'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'MATCH (p:Person {name: ''Alice''})'
- en: RETURN p
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: RETURN p
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: // Create a table with a partition key and clustering columns
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: // 创建一个带有分区键和聚类列的表
- en: CREATE TABLE users (
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TABLE users (
- en: id UUID PRIMARY KEY,
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: id UUID PRIMARY KEY,
- en: name TEXT,
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: name TEXT,
- en: email TEXT,
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: email TEXT,
- en: created_at TIMESTAMP
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: created_at TIMESTAMP
- en: ) WITH CLUSTERING ORDER BY (created_at DESC)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ) 按照（created_at DESC）进行聚类排序
- en: // Query for all users with a specific email address
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: // 查询所有具有特定电子邮件地址的用户
- en: SELECT * FROM users WHERE email = 'example@example.com'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM users WHERE email = 'example@example.com'
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: // Get a value from the cache
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: // 从缓存中获取一个值
- en: var cachedValue = await redis.get('key');
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: var cachedValue = await redis.get('key');
- en: // If the value is not in the cache, fetch it from the database and store it
    in the cache
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果值不在缓存中，从数据库中获取并将其存储在缓存中
- en: if (cachedValue === null) {
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: if (cachedValue === null) {
- en: var result = await db.query('SELECT * FROM my_table WHERE id = ?', [id]);
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: var result = await db.query('SELECT * FROM my_table WHERE id = ?', [id]);
- en: if (result.length > 0) {
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: if (result.length > 0) {
- en: cachedValue = result[0];
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: cachedValue = result[0];
- en: await redis.set('key', JSON.stringify(cachedValue), 'EX', 600);
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: await redis.set('key', JSON.stringify(cachedValue), 'EX', 600);
- en: '}'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: console.log('Result is', cachedValue);
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: console.log('结果是', cachedValue);
- en: '[PRE12]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: // Update the user's email address if the current email address matches the
    expected value
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: // 如果当前电子邮件地址与预期值匹配，更新用户的电子邮件地址
- en: db.users.update(
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: db.users.update(
- en: '{ _id: ''123'' },'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '{ _id: ''123'' },'
- en: '{ $set: { email: ''newemail@example.com'' } },'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '{ $set: { email: ''newemail@example.com'' } },'
- en: '{ multi: false, upsert: false, writeConcern: { w: ''majority'' } },'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '{ multi: false, upsert: false, writeConcern: { w: ''majority'' } },'
- en: function(err, result) {
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: function(err, result) {
- en: if (err) {
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: if (err) {
- en: console.log(err);
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(err);
- en: '} else if (result.n === 0) {'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (result.n === 0) {'
- en: console.log('User not found');
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: console.log('用户未找到');
- en: '} else if (result.nModified === 0) {'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '} else if (result.nModified === 0) {'
- en: console.log('Update failed - email address did not match expected value');
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: console.log('更新失败 - 电子邮件地址与预期值不匹配');
- en: '} else {'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: console.log('Update successful');
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: console.log('更新成功');
- en: '}'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: );
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: // Create a Cassandra table with a quorum-based consistency level
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: // 创建一个具有基于多数一致性的 Cassandra 表
- en: CREATE TABLE users (
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TABLE users (
- en: id UUID PRIMARY KEY,
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: id UUID PRIMARY KEY,
- en: name TEXT,
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: name TEXT,
- en: email TEXT,
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: email TEXT,
- en: created_at TIMESTAMP
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: created_at TIMESTAMP
- en: ) WITH read_repair_chance = 0.2 AND dclocal_read_repair_chance = 0.1 AND CL
    = QUORUM
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ) 设置 read_repair_chance = 0.2 和 dclocal_read_repair_chance = 0.1 且 CL = QUORUM
- en: // Query for all users with a specific email address using a quorum-based consistency
    level
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用基于多数一致性的查询获取具有特定电子邮件地址的所有用户
- en: SELECT * FROM users WHERE email = 'example@example.com' AND CL = QUORUM
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM users WHERE email = 'example@example.com' AND CL = QUORUM
- en: '[PRE14]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: // Create a Riak bucket with consistent hashing enabled
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: // 创建一个启用一致性哈希的 Riak 桶
- en: curl -XPUT http://localhost:8098/buckets/my_bucket/props \
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: curl -XPUT http://localhost:8098/buckets/my_bucket/props \
- en: '-H ''Content-Type: application/json'' \'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '-H ''Content-Type: application/json'' \'
- en: '-d ''{ "props": { "consistent_hashing": true } }'''
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '-d ''{ "props": { "consistent_hashing": true } }'''
- en: // Store a value in the Riak bucket with a key
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: // 在 Riak 桶中存储一个带有键的值
- en: curl -XPUT http://localhost:8098/buckets/my_bucket/keys/my_key \
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: curl -XPUT http://localhost:8098/buckets/my_bucket/keys/my_key \
- en: '-H ''Content-Type: application/json'' \'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '-H ''Content-Type: application/json'' \'
- en: '-d ''{ "value": "my_value" }'''
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '-d ''{ "value": "my_value" }'''
- en: // Retrieve the value from the Riak bucket using consistent hashing
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用一致性哈希从 Riak 桶中检索值
- en: curl -XGET http://localhost:8098/buckets/my_bucket/keys/my_key \
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: curl -XGET http://localhost:8098/buckets/my_bucket/keys/my_key \
- en: '-H ''Content-Type: application/json'' \'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '-H ''Content-Type: application/json'' \'
- en: '-H ''X-Riak-Consistent-Hashing: true'''
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '-H ''X-Riak-Consistent-Hashing: true'''
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: // Create a user with a specific role in MongoDB
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: // 在MongoDB中创建一个具有特定角色的用户
- en: db.createUser({
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: db.createUser({
- en: 'user: ''myuser'','
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'user: ''myuser'','
- en: 'pwd: ''mypassword'','
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 'pwd: ''mypassword'','
- en: 'roles: [ { role: ''readWrite'', db: ''mydatabase'' } ]'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'roles: [ { role: ''readWrite'', db: ''mydatabase'' } ]'
- en: '});'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: // Authenticate with MongoDB using the created user
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用创建的用户进行MongoDB认证
- en: db.auth('myuser', 'mypassword');
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: db.auth('myuser', 'mypassword');
- en: // Query for data in MongoDB using the authenticated user
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用认证用户查询MongoDB中的数据
- en: db.my_collection.find({});
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: db.my_collection.find({});
- en: '[PRE16]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: // Configure Redis to use a maximum memory limit of 1GB
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: // 配置Redis使用最大内存限制为1GB
- en: maxmemory 1gb
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: maxmemory 1gb
- en: // Enable Redis rate limiting for incoming requests
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: // 启用Redis对传入请求的速率限制
- en: redis.config set lua-time-limit 1000
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: redis.config set lua-time-limit 1000
- en: redis.config set maxmemory-samples 10
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: redis.config set maxmemory-samples 10
- en: redis.eval("local c=redis.call('incr',KEYS[1]);if tonumber(c)==1 then redis.call('expire',KEYS[1],ARGV[1])
    end;return c",{1,"rate_limiter"},1)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: redis.eval("local c=redis.call('incr',KEYS[1]);if tonumber(c)==1 then redis.call('expire',KEYS[1],ARGV[1])
    end;return c",{1,"rate_limiter"},1)
- en: '[PRE17]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: // Enable network-level encryption for Cassandra
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: // 启用Cassandra的网络级加密
- en: 'server_encryption_options:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'server_encryption_options:'
- en: 'internode_encryption: all'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'internode_encryption: all'
- en: 'keystore: /path/to/keystore.jks'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'keystore: /path/to/keystore.jks'
- en: 'keystore_password: password'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 'keystore_password: 密码'
- en: 'truststore: /path/to/truststore.jks'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'truststore: /path/to/truststore.jks'
- en: 'truststore_password: password'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'truststore_password: 密码'
- en: 'client_encryption_options:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'client_encryption_options:'
- en: 'enabled: true'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 'enabled: true'
- en: 'optional: false'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 'optional: false'
- en: 'keystore: /path/to/keystore.jks'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 'keystore: /path/to/keystore.jks'
- en: 'keystore_password: password'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 'keystore_password: 密码'
- en: '[PRE18]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: // Example of overusing denormalization in MongoDB
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: // 在MongoDB中过度使用反规范化的示例
- en: // Embedding order data within each product document
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: // 在每个产品文档中嵌入订单数据
- en: '{'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"_id": "product123",'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '"_id": "product123",'
- en: '"name": "iPhone",'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "iPhone",'
- en: '"description": "Apple iPhone 12 Pro",'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '"description": "苹果iPhone 12 Pro",'
- en: '"price": 999,'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '"price": 999,'
- en: '"orders": ['
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '"orders": ['
- en: '{'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"_id": "order456",'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '"_id": "order456",'
- en: '"customer_id": "customer789",'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '"customer_id": "customer789",'
- en: '"quantity": 2,'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '"quantity": 2,'
- en: '"price": 1998'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '"price": 1998'
- en: '},'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"_id": "order789",'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '"_id": "order789",'
- en: '"customer_id": "customer123",'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '"customer_id": "customer123",'
- en: '"quantity": 1,'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '"quantity": 1,'
- en: '"price": 999'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '"price": 999'
- en: '}'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE19]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: // Example of underestimating data consistency in Cassandra
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: // 低估Cassandra数据一致性的示例
- en: // Using low consistency levels for reads and writes
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用低一致性级别进行读写
- en: CREATE TABLE posts (
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: CREATE TABLE posts (
- en: post_id UUID PRIMARY KEY,
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: post_id UUID PRIMARY KEY,
- en: user_id UUID,
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: user_id UUID,
- en: text TEXT
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: text TEXT
- en: );
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: );
- en: INSERT INTO posts (post_id, user_id, text) VALUES (
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: INSERT INTO posts (post_id, user_id, text) VALUES (
- en: uuid(), uuid(), 'Hello, world!'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: uuid(), uuid(), 'Hello, world!'
- en: ) USING CONSISTENCY ONE;
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ) USING CONSISTENCY ONE;
- en: SELECT * FROM posts WHERE post_id = uuid() USING CONSISTENCY ONE;
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM posts WHERE post_id = uuid() USING CONSISTENCY ONE;
- en: '[PRE20]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: // Example of failing to secure the database in Elasticsearch
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: // 未能在Elasticsearch中确保数据库安全的示例
- en: // Using default settings without authentication
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用无认证的默认设置
- en: curl -XPUT 'http://localhost:9200/my_index/my_type/1' -d '
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: curl -XPUT 'http://localhost:9200/my_index/my_type/1' -d '
- en: '{'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"name": "John Doe",'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "约翰·多伊",'
- en: '"age": 35,'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '"age": 35,'
- en: '"email": "john.doe@example.com"'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '"email": "john.doe@example.com"'
- en: '}'''
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '}'''
- en: '[PRE21]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: // Example of overlooking performance tuning in Couchbase
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: // 忽视Couchbase性能调优的示例
- en: // Using default settings without optimization
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用默认设置而未进行优化
- en: // Query for all shipments
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: // 查询所有发货记录
- en: SELECT * FROM shipments;
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM shipments;
- en: // Query for shipments with a specific status
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: // 查询具有特定状态的发货记录
- en: SELECT * FROM shipments WHERE status = "delivered";
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: SELECT * FROM shipments WHERE status = "delivered";
- en: '[PRE22]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: // Example of neglecting to plan for growth in DynamoDB
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: // 忽视在DynamoDB中进行增长规划的示例
- en: // Using a single partition key for all users
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: // 使用单一分区键来管理所有用户
- en: '{'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"user_id": "1234567890",'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '"user_id": "1234567890",'
- en: '"name": "John Doe",'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '"name": "约翰·多伊",'
- en: '"score": 1000,'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '"score": 1000,'
- en: '"level": 5'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '"level": 5'
- en: '}'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE23]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
