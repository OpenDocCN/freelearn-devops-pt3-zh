- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Containerization with Docker
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 容器化
- en: In the previous chapter, we talked about source code management with Git, where
    we took a crash course on Git and then discussed GitOps and how it shapes modern
    DevOps practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了 Git 的源代码管理，在那里我们进行了 Git 的速成学习，然后探讨了 GitOps 以及它如何塑造现代 DevOps 实践。
- en: In this chapter, we’ll get hands-on and explore **Docker** – the de facto container
    runtime. By the end of this chapter, you should be able to install and configure
    Docker, run your first container, and then monitor it. This chapter will also
    form the basis for the following chapters, as we will use the same setup for the
    demos later.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将亲自操作并探索 **Docker** —— 当今最常用的容器运行时。到本章结束时，你应该能够安装并配置 Docker，运行你的第一个容器，并进行监控。本章内容也将为后续章节奠定基础，因为我们将在后面的演示中使用相同的设置。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: Installing tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装工具
- en: Installing Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: Introducing Docker storage drivers and volumes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Docker 存储驱动程序和卷
- en: Running your first container
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的第一个容器
- en: Docker logging and logging drivers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 日志记录与日志驱动
- en: Docker monitoring with Prometheus
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Prometheus 进行 Docker 监控
- en: Declarative container management with Docker Compose
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 进行声明式容器管理
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a Linux machine running Ubuntu 18.04 Bionic
    LTS or later with sudo access. We will be using Ubuntu 22.04 Jammy Jellyfish for
    the entirety of this book, but feel free to use any OS of your choice. I will
    post links to alternative installation instructions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容需要一台运行 Ubuntu 18.04 Bionic LTS 或更高版本的 Linux 机器，并且具有 sudo 权限。我们将在本书中使用 Ubuntu
    22.04 Jammy Jellyfish，但你也可以自由选择任何操作系统。我将提供其他安装说明的链接。
- en: 'You will also need to clone the following GitHub repository for some of the
    exercises: [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要克隆以下 GitHub 仓库以进行一些练习：[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)。
- en: We discussed Git extensively in the previous chapter; therefore, you can easily
    clone the repository using that knowledge. Now, let’s move on to installing Docker
    on your machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中详细讨论了 Git；因此，你可以轻松地利用这些知识克隆仓库。现在，让我们继续安装 Docker。
- en: Installing Docker
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: We will be installing Docker in an Ubuntu system. For other OSs, please refer
    to [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Ubuntu 系统上安装 Docker。对于其他操作系统，请参考 [https://docs.docker.com/engine/install/](https://docs.docker.com/engine/install/)。
- en: 'To install Docker, we need to install supporting tools to allow the `apt` package
    manager to download Docker through HTTPS. Let’s do so using the following commands:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 Docker，我们需要安装支持工具，允许 `apt` 包管理器通过 HTTPS 下载 Docker。我们使用以下命令来完成此操作：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Download the Docker gpg key and add it to the apt package manager:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下载 Docker gpg 密钥并将其添加到 apt 包管理器：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, you need to add the Docker repository to your `apt` configuration so
    that you can download packages from there:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要将 Docker 仓库添加到你的 `apt` 配置中，以便从那里下载包：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, install the Docker engine by using the following commands:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过以下命令安装 Docker 引擎：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To verify whether Docker has been installed successfully, run the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 Docker 是否安装成功，请运行以下命令：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should expect a similar output to the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的输出：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next thing you should do is allow regular users to use Docker. You want
    your users to act as something other than root for building and running containers.
    To do that, run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要做的事是允许普通用户使用 Docker。你希望你的用户在构建和运行容器时不是以 root 用户身份进行操作。为此，请运行以下命令：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To apply the changes to your profile, log out from your virtual machine and
    log back in.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要使更改应用到你的配置文件中，请从虚拟机退出并重新登录。
- en: 'Now that Docker has been fully set up on your machine, let’s run a `hello-world`
    container to see this for ourselves:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Docker 已经在你的机器上完全设置好，让我们运行一个 `hello-world` 容器来验证这一点：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You will also receive the following message, which tells you what happened
    behind the scenes to print the `Hello from Docker!` message on your screen:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会看到以下信息，告诉你在后台发生了什么，为什么会在屏幕上显示 `Hello from Docker!` 消息：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All this helpful information is self-explanatory. To explain Docker Hub a bit,
    it is a public Docker container registry that hosts many Docker images for people
    like you and me to consume.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些有用的信息是不言自明的。简单解释一下 Docker Hub，它是一个公共的 Docker 容器注册表，托管着许多供像你我这样的用户使用的 Docker
    镜像。
- en: As Docker works on a layered architecture, most Docker images are derived from
    one or more base images hosted on Docker Hub. So, please create a Docker Hub account
    for yourself to host your containers and share them with the rest of the world.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Docker 使用分层架构，大多数 Docker 镜像都是从一个或多个托管在 Docker Hub 上的基础镜像派生出来的。因此，请为自己创建一个
    Docker Hub 账户，以便托管容器并与世界分享。
- en: Most organizations might want to keep their images private, so you have the
    option of creating private repositories within Docker Hub. You can also host your
    own internal Docker registry using a SaaS service such as **Google Container Registry**
    (**GCR**), or installing an artifact repository such as **Sonatype Nexus** or
    **JFrog Artifactory**. Whatever your choice of tool, the mechanism and how it
    works always remain the same.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组织可能希望保持镜像的私密性，因此你可以选择在 Docker Hub 中创建私有仓库。你还可以使用 **Google 容器注册表** (**GCR**)
    等 SaaS 服务托管自己的内部 Docker 注册表，或者安装如 **Sonatype Nexus** 或 **JFrog Artifactory** 这样的工件仓库。不管你选择哪种工具，机制和工作原理始终是相同的。
- en: Introducing Docker storage drivers and volumes
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Docker 存储驱动和卷
- en: Docker containers are ephemeral workloads. Whatever data you store on your container
    filesystem gets wiped out once the container is gone. The data lives on a disk
    during the container’s life cycle but does not persist beyond it. Pragmatically
    speaking, most applications in the real world are stateful. They need to store
    data beyond the container life cycle and want it to persist.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器是短暂的工作负载。你在容器文件系统上存储的任何数据，在容器消失后都会被清除。数据在容器生命周期内存储在磁盘上，但不会超出其生命周期。实际上，大多数应用程序都是有状态的。它们需要在容器生命周期之外存储数据，并希望数据能够持久化。
- en: So, how do we go along with that? Docker provides several ways you can store
    data. By default, all data is stored on the writable container layer, which is
    ephemeral. The writable container layer interacts with the host filesystem via
    a storage driver. Because of the abstraction, writing files to the container layer
    is slower than writing directly to the host filesystem.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何进行呢？Docker 提供了几种存储数据的方式。默认情况下，所有数据都存储在可写容器层上，而该层是临时的。可写容器层通过存储驱动与主机文件系统交互。由于存在抽象层，写入容器层的文件比直接写入主机文件系统要慢。
- en: To solve that problem and also provide persistent storage, Docker provides volumes,
    bind mounts, and `tmpfs`. With them, you can interact directly with the host filesystem
    (and memory in the case of `tmpfs`) and save a ton of **I/O operations per second**
    (**IOPS**), improving performance. While this section focuses on storage drivers
    that cater to the container filesystem, it is worth discussing multiple data storage
    options within Docker to provide a background.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题并提供持久存储，Docker 提供了卷、绑定挂载和 `tmpfs`。通过这些，你可以直接与主机文件系统（以及在 `tmpfs` 的情况下与内存）交互，并节省大量的
    **每秒 I/O 操作** (**IOPS**)，从而提高性能。尽管本节侧重于容器文件系统的存储驱动，但讨论 Docker 中的多种数据存储选项也很有价值，以便提供背景信息。
- en: Docker data storage options
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 数据存储选项
- en: Every option has a use case and trade-off. Let’s look at each option and where
    you should use which.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个选项都有其使用场景和权衡。让我们来看一下每个选项以及应该在哪些地方使用它们。
- en: Volumes
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卷
- en: Docker volumes store the data directly in the host’s filesystem. They do not
    use the storage driver layer in between, so writing to volumes is faster. They
    are the best way to persist data. Docker stores volumes in `/var/lib/docker/volumes`
    and assumes that no one apart from the Docker daemon can modify the data on them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 卷将数据直接存储在主机的文件系统中。它们不使用中间的存储驱动层，因此写入卷的速度更快。它们是持久化数据的最佳方式。Docker 将卷存储在
    `/var/lib/docker/volumes` 中，并假设除了 Docker 守护进程外，没有人可以修改它们上的数据。
- en: 'As a result, volumes provide the following features:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，卷提供以下功能：
- en: Provide some isolation with the host filesystems. If you don’t want other processes
    to interact with the data, then a volume should be your choice.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供与主机文件系统的某些隔离。如果你不希望其他进程与数据交互，那么卷应该是你的选择。
- en: You can share a volume with multiple containers.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以与多个容器共享一个卷。
- en: Volumes can either be named or anonymous. Docker stores anonymous volumes in
    a directory with a unique random name.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷可以是命名的或匿名的。Docker 将匿名卷存储在一个具有唯一随机名称的目录中。
- en: Volumes enable you to store data remotely or in a cloud provider using volume
    drivers. This helps a lot if multiple containers share the same volume to provide
    a multi-instance active-active configuration.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据卷使你能够将数据远程存储或通过云提供商使用数据卷驱动进行存储。如果多个容器共享同一个数据卷以提供多实例的主动-主动配置，这非常有帮助。
- en: The data in the volume persists even when the containers are deleted.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使容器被删除，数据卷中的数据也会持久存在。
- en: Now, let’s look at another storage option – bind mounts.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下另一种存储选项——绑定挂载。
- en: Bind mounts
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定挂载
- en: 'Bind mounts are very similar to volumes but with a significant difference:
    they allow you to mount an existing host directory as a filesystem on the container.
    This lets you share important files with the Docker container, such as `/etc/resolv.conf`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定挂载与数据卷非常相似，但有一个显著的区别：它允许你将现有的主机目录作为容器的文件系统进行挂载。这使你能够与 Docker 容器共享重要文件，例如`/etc/resolv.conf`。
- en: Bind mounts also allow multiple processes to modify data along with Docker.
    So, if you are sharing your container data with another application that is not
    running in Docker, bind mounts are the way to go.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定挂载也允许多个进程与 Docker 一起修改数据。因此，如果你将容器数据与另一个不在 Docker 中运行的应用程序共享，绑定挂载是最佳选择。
- en: tmpfs mounts
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tmpfs 挂载
- en: '`tmpfs` mounts store data in memory. They do not store any data on disk – neither
    the container nor the host filesystem. You can use them to store sensitive information
    and the non-persistent state during the lifetime of your container.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpfs` 挂载将数据存储在内存中。它们不会在磁盘上存储任何数据——无论是容器还是主机文件系统。你可以使用它们来存储敏感信息和容器生命周期中的非持久状态。'
- en: Mounting volumes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载数据卷
- en: If you mount a host directory that already contains files to an empty volume
    of the container, the container can see the files stored in the host. This is
    an excellent way to pre-populate files for your container(s) to use. However,
    if the directory does not exist in the host filesystem, Docker will create the
    directory automatically. If the volume is non-empty and the host filesystem already
    contains files, Docker will obscure the mount. This means that while you won’t
    see the original files while the Docker volume is mounted to it, the files are
    not deleted, and you can recover them by unmounting the Docker volume.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个已经包含文件的主机目录挂载到容器的空数据卷上，容器就可以看到主机中存储的文件。这是为容器预填充文件的绝佳方式。然而，如果该目录在主机文件系统中不存在，Docker
    会自动创建该目录。如果数据卷非空且主机文件系统中已经包含文件，Docker 将遮蔽该挂载。这意味着，在 Docker 卷挂载到该目录时，你不会看到原始文件，但文件并没有被删除，你可以通过卸载
    Docker 卷来恢复它们。
- en: We’ll look at Docker storage drivers in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一部分讨论 Docker 存储驱动。
- en: Docker storage drivers
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 存储驱动
- en: 'There are numerous storage driver types. Some of the most popular ones are
    as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 存储驱动类型有很多种。以下是一些最受欢迎的存储驱动：
- en: '`overlay2`: This is a production-ready driver and is the preferred storage
    choice for Docker. It works in most environments.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overlay2`：这是一个适用于生产环境的驱动，是 Docker 推荐的存储选择。它适用于大多数环境。'
- en: '`devicemapper`: This was the preferred driver for devices running RHEL and
    CentOS 7 and below that did not support `overlay2`. You can use this driver if
    you have write-intensive activities in your containers.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`devicemapper`：这是 RHEL 和 CentOS 7 及以下版本的设备驱动，这些版本不支持 `overlay2`。如果你的容器中有写密集型操作，你可以使用此驱动。'
- en: '`btrfs` and `zfs`: These drivers are write-intensive and provide many features,
    such as allowing snapshots, and can only be used if you are using `btrfs` or `zfs`
    filesystems within your host.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btrfs` 和 `zfs`：这些驱动程序是写密集型的，提供许多功能，例如允许快照，并且仅在主机使用 `btrfs` 或 `zfs` 文件系统时才可以使用。'
- en: '`vfs`: This storage driver should be used only if no copy-on-write filesystem
    is available. It is extremely slow, and you should refrain from using it in production.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vfs`：此存储驱动仅应在没有写时复制文件系统的情况下使用。它非常慢，不建议在生产环境中使用。'
- en: Let’s concentrate on two of the most popular ones – `overlay2` and `devicemapper`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们集中讨论两种最受欢迎的驱动——`overlay2` 和 `devicemapper`。
- en: overlay2
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: overlay2
- en: '`overlay2` is the default and recommended storage driver in most operating
    systems except RHEL 7 and CentOS 7 and older. They use file-based storage and
    perform best when subject to more reads than writes.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`overlay2`是大多数操作系统中默认和推荐的存储驱动，除了 RHEL 7、CentOS 7 及更早版本。它们使用基于文件的存储，并在读取操作多于写入操作时表现最佳。'
- en: devicemapper
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: devicemapper
- en: '`devicemapper` is block-based storage and performs the best when subject to
    more writes than reads. Though it is compatible and the default with CentOS 7,
    RHEL 7, and below, as they don’t support `overlay2`, it is currently not recommended
    in the newer versions of these operating systems that do support `overlay2`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`devicemapper` 是基于块的存储，当写操作比读操作多时，它的表现最佳。虽然它与 CentOS 7、RHEL 7 及以下版本兼容，并且是默认存储驱动（因为它们不支持
    `overlay2`），但在这些支持 `overlay2` 的新版本操作系统中，当前不推荐使用它。'
- en: Tip
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Use `overlay2` where possible, but if you have a specific use case for not using
    it (such as too many write-intensive containers), `devicemapper` is a better choice.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使用 `overlay2`，但如果你有特定的用例不适合使用它（比如容器写操作过于频繁），那么 `devicemapper` 是一个更好的选择。
- en: Configuring a storage driver
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置存储驱动
- en: For this discussion, we will configure `overlay2` as the storage driver. Although
    it is configured by default, and you can skip the steps if you are following this
    book, it is worth a read in case you want to change it to something else.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本讨论中，我们将配置 `overlay2` 作为存储驱动。虽然它是默认配置，如果你跟随本书的内容，你可以跳过这一步，但如果你想将其更改为其他驱动，还是值得了解一下。
- en: 'First, let’s list the existing storage driver:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们列出当前的存储驱动：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can see that the existing storage driver is already `overlay2`. Let’s learn
    how to change it to `devicemapper` if we had to.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到当前的存储驱动已经是 `overlay2`。如果我们需要更改为 `devicemapper`，下面我们来看如何操作。
- en: 'Edit the `/etc/docker/daemon.json` file using an editor of your choice. If
    you’re using `vim`, run the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你选择的编辑器编辑 `/etc/docker/daemon.json` 文件。如果你使用 `vim`，可以运行以下命令：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `storage-driver` entry to the `daemon.json` configuration file:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `storage-driver` 条目添加到 `daemon.json` 配置文件中：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, restart the Docker service:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重启 Docker 服务：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Check the status of the Docker service:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Docker 服务的状态：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, rerun `docker info` to see what we get:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新运行 `docker info` 查看我们得到的结果：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we can see the `devicemapper` storage driver. We can also see several
    warnings with it that say that the `devicemapper` storage driver is deprecated
    and will be removed in a future version.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以看到 `devicemapper` 存储驱动。我们还看到几个警告，表示 `devicemapper` 存储驱动已被弃用，并将在未来的版本中移除。
- en: Therefore, we should stick with the defaults unless we have a particular requirement.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非有特定需求，否则我们应该坚持使用默认配置。
- en: 'So, let’s roll back our changes and set the storage driver to `overlay2` again:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们撤销之前的更改，并再次将存储驱动设置为 `overlay2`：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Modify the `storage-driver` entry in the `daemon.json` configuration file to
    `overlay2`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `daemon.json` 配置文件中，将 `storage-driver` 条目修改为 `overlay2`：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, restart the Docker service and check its status:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重启 Docker 服务并检查其状态：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you rerun `docker info`, you will see the storage driver as `overlay2`,
    and all the warnings will disappear:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新运行 `docker info`，你将看到存储驱动变为 `overlay2`，所有警告也将消失：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Changing the storage driver will wipe out existing containers from the disk,
    so exercise caution when you do so and take appropriate downtimes if you’re doing
    this in production. You will also need to pull images again since local images
    will fail to exist.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 更改存储驱动会清除磁盘上现有的容器，因此在进行此操作时请小心，并确保在生产环境中安排适当的停机时间。如果你这样做，你还需要重新拉取镜像，因为本地镜像将不再存在。
- en: Now that we have installed Docker on our machine and configured the right storage
    driver, it’s time to run our first container.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在机器上安装了 Docker 并配置了正确的存储驱动，是时候运行我们的第一个容器了。
- en: Running your first container
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行你的第一个容器
- en: You can create Docker containers out of Docker container images. While we will
    discuss container images and their architecture in the following chapters, an
    excellent way to visualize them is as a copy of all files, application libraries,
    and dependencies comprising your application environment, similar to a virtual
    machine image.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 Docker 容器镜像来创建 Docker 容器。虽然我们将在后续章节中讨论容器镜像及其架构，但一个很好的形象化方式是将其视为包含所有文件、应用程序库和依赖项的副本，这些内容构成了你的应用环境，类似于虚拟机镜像。
- en: 'To run a Docker container, we can use the `docker run` command, which has the
    following structure:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行 Docker 容器，我们可以使用 `docker run` 命令，它的结构如下：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let’s look at the `docker run` command and its variations using working examples.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一些实际示例来看一下 `docker run` 命令及其变种。
- en: 'In its simplest form, you can use `docker run` by simply typing the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式下，你只需输入以下命令来使用 `docker run`：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you may recall, we used this command when we installed Docker. Here, I have
    purposefully omitted `tag`, `options`, `command`, and `arguments`. We will cover
    it with multiple examples to show its actual use cases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所记得，我们在安装Docker时使用了这个命令。在这里，我有意省略了`tag`、`options`、`command`和`arguments`。我们将通过多个示例来展示它的实际使用场景。
- en: As we didn’t supply `tag`, Docker automatically assumed the `tag` as `latest`,
    so if you look at the command output, you will see that Docker is pulling the
    `hello-world:latest` image from Docker Hub.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有提供`tag`，Docker自动假设`tag`为`latest`，因此，如果你查看命令输出，你将看到Docker正在从Docker Hub拉取`hello-world:latest`镜像。
- en: Now, let’s look at an example with a specific version tag.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个带有特定版本标签的示例。
- en: Running containers from versioned images
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从有版本标记的镜像运行容器
- en: 'We can run `nginx:1.18.0` using the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令运行`nginx:1.18.0`：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that the prompt will be stuck after this. There is a reason for this:
    `nginx` is a long-running process, also known as a daemon. Since NGINX is a web
    server that needs to listen to HTTP requests continuously, it should never stop.
    In the case of the `hello-world` application, its only job was to print the message
    and exit. NGINX has a different purpose altogether.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，提示符在此后将会卡住。这是有原因的：`nginx`是一个长期运行的进程，也就是守护进程。由于NGINX是一个需要持续监听HTTP请求的Web服务器，所以它应该永远不会停止。而`hello-world`应用程序的唯一任务是打印消息并退出。NGINX的用途完全不同。
- en: Now, no one would keep a Bash session open for a web server to run, so there
    has to be some way to run it in the background. You can run containers in the
    detached mode for that. We’ll have a look at this in the next section.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，没人会为一个Web服务器保持打开的Bash会话，所以必须有某种方法将其运行在后台。你可以通过分离模式来运行容器。我们将在下一节中详细讨论这一点。
- en: Running Docker containers in the background
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在后台运行Docker容器
- en: 'To run a Docker container in the background as a daemon, you can use `docker
    run` in detached mode using the `-``d` flag:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Docker容器作为守护进程在后台运行，你可以使用带有`-d`标志的`docker run`命令：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, it just prints a random ID and provides control back to the
    shell.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它仅打印一个随机ID并将控制权返回到shell。
- en: Troubleshooting containers
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器故障排除
- en: To see what’s going on within the container, you can use the `docker logs` command.
    But before using that, we need to know the container’s ID or name to see the container’s
    logs.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看容器内发生的情况，你可以使用`docker logs`命令。但在使用之前，我们需要知道容器的ID或名称，以便查看容器的日志。
- en: To get a list of containers running within the host, run the following command
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取主机中正在运行的容器列表，请运行以下命令
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding command lists the NGINX container that we just started. Unless
    you specify a particular name for your container, Docker allocates a random name
    to it. In this case, it has called it `fervent_shockley`. It also assigns every
    container a unique container ID, such as `beb5dfd529c9`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令列出了我们刚刚启动的NGINX容器。除非你为容器指定了特定的名称，否则Docker会分配一个随机名称。在这种情况下，它将容器命名为`fervent_shockley`。它还会为每个容器分配一个唯一的容器ID，例如`beb5dfd529c9`。
- en: 'You can use the container ID or the container name to interact with the container
    to list the logs. Let’s use the container ID this time:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用容器ID或容器名称与容器进行交互，以列出日志。我们这次使用容器ID：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As you can see, it prints a similar log output as it did when we ran it in the
    foreground.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它打印出了与我们在前台运行时相似的日志输出。
- en: Practically speaking, you will use `docker logs` 90% of the time unless you
    need to debug something with BusyBox. BusyBox is a lightweight shell container
    that can help you troubleshoot and debug issues with your container – mostly network
    issues.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，除非你需要用BusyBox调试某些问题，否则你90%的时间都会使用`docker logs`。BusyBox是一个轻量级的Shell容器，可以帮助你排查和调试容器的问题——主要是网络问题。
- en: 'Let’s make BusyBox echo `Hello World!` for us:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让BusyBox为我们回显`Hello World!`：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As we can see, Docker pulls the latest `busybox` image from Docker Hub and runs
    the `echo 'Hello` `World'` command.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Docker从Docker Hub拉取了最新的`busybox`镜像并运行了`echo 'Hello` `World'`命令。
- en: 'You can also use BusyBox in interactive mode by using the `-it` flag, which
    will help you run a series of commands on the BusyBox shell. It is also a good
    idea to add an `--rm` flag to it to tell Docker to clean up the containers once
    we have exited from the shell, something like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用`-it`标志在交互模式下使用BusyBox，这将帮助你在BusyBox shell上运行一系列命令。最好还加上`--rm`标志，告诉Docker在我们退出shell后清理容器，像这样：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Upon listing all the containers, we do not see the `busybox` container in there:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出所有容器时，我们没有看到 `busybox` 容器：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are various other flags that you can use with your containers, each serving
    a specific purpose. Let’s look at a few common ones.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用各种其他标志来配置容器，每个标志都有特定的用途。让我们看几个常见的。
- en: Putting it all together
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 综合起来
- en: 'The best setting for a highly available NGINX container should be something
    like the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 高可用 NGINX 容器的最佳设置应类似于以下内容：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let’s take a look at this in more detail:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个：
- en: '`-d`: Run as a daemon in detached mode.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：以守护进程模式在分离模式下运行。'
- en: '`--name nginx`: Give the name `nginx`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--name nginx`：为容器命名为 `nginx`。'
- en: '`--restart unless-stopped`: Always automatically restart on failures unless
    explicitly stopped manually, and also start automatically on Docker daemon startup.
    Other options include `no`, `on_failure`, and `always`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--restart unless-stopped`：除非手动停止，否则始终在失败时自动重启，并且在 Docker 守护进程启动时自动启动。其他选项包括
    `no`、`on_failure` 和 `always`。'
- en: '`-p 80:80`: Forward traffic from host port `80` to container port `80`. This
    allows you to expose your container to your host network.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p 80:80`：将主机端口 `80` 转发到容器端口 `80`。这允许你将容器暴露到主机网络。'
- en: '`--memory 1000M`: Limit the container memory consumption to `1000M`. If the
    memory exceeds this limit, the container stops and acts according to the `--``restart`
    flag.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--memory 1000M`：将容器的内存消耗限制为 `1000M`。如果内存超出此限制，容器会停止，并根据 `--restart` 标志进行处理。'
- en: '`--memory-reservation 250M`: Allocate a soft limit of `250M` memory to the
    container if the server runs out of memory.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--memory-reservation 250M`：为容器分配一个软限制 `250M` 内存，如果服务器内存不足时使用。'
- en: We will look into other flags in the subsequent sections as we get more hands-on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将深入探讨其他标志，并进行更多实操。
- en: Tip
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Consider using `unless-stopped` instead of `always` as it allows you to stop
    the container manually if you want to do some maintenance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用 `unless-stopped` 代替 `always`，因为它允许在需要进行维护时手动停止容器。
- en: 'Now, let’s list the containers and see what we get:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们列出容器，看看我们得到什么：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you look carefully, you’ll see a container called `nginx` and a port forward
    from `0.0.0.0:80 ->` `80`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细观察，你会看到一个名为 `nginx` 的容器，并且有一个从 `0.0.0.0:80 ->` `80` 的端口转发。
- en: 'Now, let’s `curl` on `localhost:80` on the host to see what we get:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在主机的 `localhost:80` 上使用 `curl` 来查看结果：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We get the NGINX welcome message. This means NGINX is running successfully,
    and we can access it from the machine. If you have exposed your machine’s port
    `80` to the external world, you can also access this using your browser as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了 NGINX 欢迎信息。这意味着 NGINX 正常运行，我们可以从机器上访问它。如果你已将机器的端口 `80` 暴露到外部世界，你也可以通过浏览器访问它，如下所示：
- en: '![Figure 3.1 – The NGINX welcome page](img/B19877_Figure_3.01.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – NGINX 欢迎页面](img/B19877_Figure_3.01.jpg)'
- en: Figure 3.1 – The NGINX welcome page
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – NGINX 欢迎页面
- en: You also might want to restart or remove your container occasionally. We’ll
    look at ways to do that in the next section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还希望偶尔重启或删除容器。我们将在下一节中介绍如何做到这一点。
- en: Restarting and removing containers
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重启和删除容器
- en: To restart your containers, you must stop them first and then start them.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要重启容器，你必须先停止它们，然后再启动它们。
- en: 'To stop your container, run the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止容器，请运行以下命令：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To start your container, run the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动容器，请运行以下命令：
- en: '[PRE33]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you want to get rid of your container completely, you need to stop your
    container first and then remove it, using the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想完全删除容器，首先需要停止容器，然后使用以下命令删除它：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Alternatively, you can use the following command to do it in one go:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下命令一次性完成：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, let’s look at how we can monitor our containers with tools such as `journald`
    and Splunk.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `journald` 和 Splunk 等工具监控容器。
- en: Docker logging and logging drivers
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 日志和日志驱动程序
- en: Docker not only changed how applications are deployed but also the workflow
    for log management. Instead of writing logs to files, containers write logs to
    the console (`stdout`/`stderr`). Docker then uses a logging driver to export container
    logs to the specified destinations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 不仅改变了应用程序的部署方式，还改变了日志管理的工作流。容器不再将日志写入文件，而是将日志写入控制台（`stdout`/`stderr`）。然后，Docker
    使用日志驱动程序将容器日志导出到指定的目标位置。
- en: Container log management
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器日志管理
- en: Log management is an essential function within Docker, as with any application.
    However, due to the transient nature of Docker workloads, it becomes more critical
    as we lose the filesystem and potentially logs when the container is deleted or
    faces any issue. So, we should use log drivers to export the logs into a particular
    place and store and persist it. If you have a log analytics solution, the best
    place for your logs to be is within it. Docker supports multiple log targets via
    logging drivers. Let’s have a look.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 日志管理是 Docker 中的一个重要功能，就像任何应用程序一样。然而，由于 Docker 工作负载的临时性质，它变得更加重要，因为当容器被删除或遇到任何问题时，我们可能会丢失文件系统和日志。因此，我们应该使用日志驱动程序将日志导出到特定的位置并存储和持久化它。如果你有日志分析解决方案，那么将日志存储在其中是最好的地方。Docker
    通过日志驱动程序支持多个日志目标。让我们来看看。
- en: Logging drivers
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志驱动程序
- en: 'At the time of writing, the following logging drivers are available:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写时，以下日志驱动程序可用：
- en: '`none`: No logs are available for the container, and therefore they are not
    stored anywhere.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`: 容器没有日志，因此日志不会存储在任何地方。'
- en: '`local`: Logs are stored locally in a custom format, which minimizes overhead.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`: 日志以自定义格式本地存储，从而最小化开销。'
- en: '`json-file`: The log files are stored in JSON format. This is the default Docker
    logging driver.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json-file`: 日志文件以 JSON 格式存储。这是默认的 Docker 日志驱动程序。'
- en: '`syslog`: This driver uses `syslog` for storing the Docker logs as well. This
    option makes sense when you use `syslog` as your default logging mechanism.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syslog`: 该驱动程序也使用 `syslog` 来存储 Docker 日志。当你将 `syslog` 作为默认日志机制时，这个选项是有意义的。'
- en: '`journald`: Uses `journald` to store Docker logs. You can use the `journald`
    command line to browse the container and the Docker daemon logs.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`journald`: 使用 `journald` 存储 Docker 日志。你可以使用 `journald` 命令行来浏览容器和 Docker 守护进程日志。'
- en: '`gelf`: Sends logs to a **Graylog Extended Log Format** (**GELF**) endpoint
    such as Graylog or Logstash.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gelf`: 将日志发送到 **Graylog 扩展日志格式** (**GELF**) 端点，如 Graylog 或 Logstash。'
- en: '`fluentd`: Sends logs to Fluentd.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fluentd`: 将日志发送到 Fluentd。'
- en: '`awslogs`: Sends logs to AWS CloudWatch.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awslogs`: 将日志发送到 AWS CloudWatch。'
- en: '`splunk`: Sends logs to Splunk using the HTTP Event Collector.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splunk`: 使用 HTTP 事件收集器将日志发送到 Splunk。'
- en: '`etwlogs`: Sends logs to **Event Tracing for Windows** (**ETW**) events. You
    can only use it on Windows platforms.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etwlogs`: 将日志发送到 **Windows 事件追踪** (**ETW**) 事件。只能在 Windows 平台上使用。'
- en: '`gcplogs`: Sends logs to Google Cloud Logging.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcplogs`: 将日志发送到 Google Cloud Logging。'
- en: '`logentries`: Sends logs to Rapid7 Logentries.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logentries`: 将日志发送到 Rapid7 Logentries。'
- en: While all these are viable options, we will look at `journald` and Splunk. While
    `journald` is a native operating system service monitoring option, Splunk is one
    of the most famous log analytics and monitoring tools. Now, let’s understand how
    to configure a logging driver.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些选项都可行，我们将重点查看 `journald` 和 Splunk。`journald` 是一种本地操作系统服务监控选项，而 Splunk 是最著名的日志分析和监控工具之一。现在，让我们了解如何配置日志驱动程序。
- en: Configuring logging drivers
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置日志驱动程序
- en: 'Let’s start by finding the current logging driver:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查找当前的日志驱动程序开始：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Currently, the default logging driver is set to `json-file`. If we want to use
    `journald` or Splunk as the default logging driver, we must configure the default
    logging driver in the `daemon.json` file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，默认日志驱动程序设置为 `json-file`。如果我们希望使用 `journald` 或 Splunk 作为默认日志驱动程序，必须在 `daemon.json`
    文件中配置默认日志驱动程序。
- en: 'Edit the `/etc/docker/daemon.json` file using an editor of your choice. If
    you’re using `vim`, run the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器编辑 `/etc/docker/daemon.json` 文件。如果你使用 `vim`，运行以下命令：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Add the `log-driver` entry to the `daemon.json` configuration file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `daemon.json` 配置文件中添加 `log-driver` 项：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, restart the Docker service:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重启 Docker 服务：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Check the status of the Docker service:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 Docker 服务的状态：
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, rerun `docker info` to see what we get:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新运行 `docker info` 查看我们得到的结果：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now that `journald` is the default logging driver, let’s launch a new NGINX
    container and visualize the logs:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`journald` 是默认的日志驱动程序，让我们启动一个新的 NGINX 容器并查看日志：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let’s look at the `journald` logs to see what we get:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看 `journald` 日志，看看我们能得到什么：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We can see the logs in the journal.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在日志中查看到这些内容。
- en: Similarly, we can configure the Splunk logging driver to send data to Splunk
    for analytics and visualization. Let’s have a look.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以配置 Splunk 日志驱动程序将数据发送到 Splunk 进行分析和可视化。让我们来看看。
- en: 'Edit the `/etc/docker/daemon.json` file using an editor of your choice. If
    you’re using `vim`, run the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器编辑 `/etc/docker/daemon.json` 文件。如果你使用 `vim`，运行以下命令：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the log-driver entry to the `daemon.json` configuration file:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将log-driver条目添加到`daemon.json`配置文件：
- en: '[PRE45]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Then, restart the Docker service:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重启Docker服务：
- en: '[PRE46]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Check the status of the Docker service:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Docker服务的状态：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, rerun `docker info` to see what we get:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新运行`docker info`，看看我们得到什么：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Since Splunk is now the default logging driver, let’s launch a new NGINX container
    and visualize the logs:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Splunk现在是默认的日志驱动程序，让我们启动一个新的NGINX容器并可视化日志：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Log in to your Splunk instance; you will see the Docker logs streaming. You
    can then analyze the logs and create visualizations out of them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到你的Splunk实例；你将看到Docker日志正在流式传输。然后，你可以分析日志并从中创建可视化。
- en: 'You can also have different logging drivers for different containers, and you
    can do so by overriding the defaults by passing the `log-driver` and `log-opts`
    flags from the command line. As our current configuration is Splunk, and we want
    to export data to a JSON file, we can specify `log-driver` as `json-file` while
    running the container. Let’s have a look:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以为不同的容器配置不同的日志驱动程序，方法是通过命令行传递`log-driver`和`log-opts`标志来覆盖默认设置。由于我们当前的配置是Splunk，并且我们希望将数据导出到JSON文件，因此可以在运行容器时将`log-driver`指定为`json-file`。让我们来看一下：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To visualize JSON logs, we need to look into the JSON log directory – that is,
    `/var/lib/docker/containers/<container_id>/<container_id>-json.log`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看JSON日志，我们需要查看JSON日志目录——即`/var/lib/docker/containers/<container_id>/<container_id>-json.log`。
- en: 'For the `nginx-json-file` container, we can do the following:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`nginx-json-file`容器，我们可以执行以下操作：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can see that the logs are now streaming to the JSON file instead of Splunk.
    That is how we override the default log driver.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，日志现在正在流式传输到JSON文件，而不是Splunk。这就是我们如何覆盖默认日志驱动程序的方式。
- en: Tip
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In most cases, it is best to stick with one default logging driver so that you
    have one place to analyze and visualize your logs.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最好坚持使用一个默认的日志驱动程序，这样你就可以在一个地方分析和可视化你的日志。
- en: Now, let’s understand some of the challenges and best practices associated with
    Docker logging.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解一下与Docker日志相关的一些挑战和最佳实践。
- en: Typical challenges and best practices to address these challenges with Docker
    logging
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker日志的典型挑战以及应对这些挑战的最佳实践：
- en: Docker allows you to run multiple applications in a single machine or a cluster
    of machines. Most organizations run a mix of virtual machines and containers,
    and they have their logging and monitoring stack configured to support virtual
    machines.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Docker允许你在单台机器或一组机器上运行多个应用程序。大多数组织同时运行虚拟机和容器，并且已经配置了日志记录和监控堆栈以支持虚拟机。
- en: Most teams struggle to make Docker logging behave the way virtual machine logging
    works. So, most teams will send logs to the host filesystem, and the log analytics
    solution then consumes the data from there. This is not ideal, and you should
    avoid making this mistake. It might work if your container is static, but it becomes
    an issue if you have a cluster of servers, each running Docker, and you can schedule
    your container in any virtual machine you like.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数团队在让Docker日志像虚拟机日志一样工作时遇到困难。因此，大多数团队会将日志发送到主机文件系统，然后日志分析解决方案从中获取数据。这并不是理想的做法，你应该避免犯这个错误。如果你的容器是静态的，这种做法可能有效，但如果你有一组运行Docker的服务器集群，并且可以将容器调度到任意虚拟机上，那么就会成为一个问题。
- en: So, treating a container as an application running on a virtual machine is a
    mistake from a logging point of view. Instead, you should visualize the container
    as an entity – just like a virtual machine. It would be best if you never associated
    containers with a virtual machine.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志的角度来看，将容器视为运行在虚拟机上的应用程序是一个错误。相反，你应该将容器视为一个实体——就像虚拟机一样。你绝不应该将容器与虚拟机关联在一起。
- en: One solution is to use the logging driver to forward the logs to a log analytics
    solution directly. But then, the logging becomes heavily dependent on the availability
    of the log analytics solution. So, it might not be the best thing to do. People
    faced issues when their services running on Docker went down because the log analytics
    solution was unavailable or there were network issues.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是使用日志驱动程序将日志直接转发到日志分析解决方案中。但是，日志记录就会严重依赖于日志分析解决方案的可用性。所以，这可能不是最好的做法。当Docker上的服务因为日志分析解决方案不可用或网络问题而宕机时，很多人都遇到过问题。
- en: Well, the best way to approach this problem is to use JSON files to store the
    logs temporarily in your virtual machine and use another container to push the
    logs to your chosen log analytics solution the old-fashioned way. That way, you
    decouple from the dependency on an external service to run your application.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，解决这个问题的最佳方法是使用 JSON 文件暂时存储虚拟机中的日志，并使用另一个容器将日志以传统方式推送到你选择的日志分析解决方案。这样，你就将应用程序的运行与外部服务的依赖解耦了。
- en: You can use the logging driver to export logs directly to your log analytics
    solution within the log forwarder container. There are many logging drivers available
    that support many log targets. Always mark the logs in such a way that the containers
    appear as their own entities. This will disassociate containers from virtual machines,
    and you can then make the best use of a distributed container-based architecture.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用日志驱动程序直接将日志导出到日志转发容器中的日志分析解决方案。有许多日志驱动程序支持多个日志目标。始终以这样的方式标记日志，使容器作为独立实体出现。这将使容器与虚拟机解耦，之后你就可以充分利用分布式容器架构。
- en: So far, we’ve looked at the logging aspects of containers, but one of the essential
    elements of a DevOps engineer’s role is monitoring. We’ll have a look at this
    in the next section.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过容器的日志方面，但 DevOps 工程师角色的一个重要元素是监控。我们将在下一节中详细探讨这一点。
- en: Docker monitoring with Prometheus
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Prometheus 进行 Docker 监控
- en: Monitoring Docker nodes and containers is an essential part of managing Docker.
    There are various tools available for monitoring Docker. While you can use traditional
    tools such as Nagios, Prometheus is gaining ground in cloud-native monitoring
    because of its simplicity and pluggable architecture.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 监控 Docker 节点和容器是管理 Docker 的关键部分。有许多工具可以用于监控 Docker。虽然你可以使用传统工具，如 Nagios，但 Prometheus
    在云原生监控中逐渐崭露头角，因为它简单且具有可插拔的架构。
- en: Prometheus is a free, open source monitoring tool that provides a dimensional
    data model, efficient and straightforward querying using the **Prometheus query
    language** (**PromQL**), efficient time series databases, and modern alerting
    capabilities.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 是一个免费的开源监控工具，它提供了维度数据模型、使用 **Prometheus 查询语言**（**PromQL**）的高效且简单的查询、有效的时间序列数据库和现代的告警功能。
- en: It has several exporters available for exporting data from various sources and
    supports both virtual machines and containers. Before we delve into the details,
    let’s look at some of the challenges with container monitoring.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了多个导出器，可从各种来源导出数据，支持虚拟机和容器。在深入细节之前，让我们看看容器监控的一些挑战。
- en: Challenges with container monitoring
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器监控的挑战
- en: 'From a conceptual point of view, there is no difference between container monitoring
    and the traditional method. You still need metrics, logs, health checks, and service
    discovery. These aren’t things that are unknown or haven’t been explored before.
    The problem with containers is the abstraction that they bring with them; let’s
    look at some of the issues:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，容器监控与传统方法没有区别。你仍然需要指标、日志、健康检查和服务发现。这些并不是未知的或没有被探索过的东西。容器面临的问题是它们带来的抽象；让我们来看一下其中的一些问题：
- en: Containers behave like mini virtual machines; however, in reality, they are
    processes running on a server. However, they still have everything to monitor
    that we would in a virtual machine. A container process will have many metrics,
    very similar to virtual machines, to be treated as separate entities altogether.
    When dealing with containers, most people make this mistake when they map containers
    to a particular virtual machine.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器表现得像迷你虚拟机；然而，实际上，它们是运行在服务器上的进程。但它们仍然有许多需要监控的内容，就像我们在虚拟机中一样。容器进程会有许多指标，类似于虚拟机，需要作为独立实体来处理。处理容器时，大多数人会犯一个错误，那就是把容器映射到特定的虚拟机。
- en: Containers are temporary, and most people don’t realize that. When you have
    a container and it is recreated, it has a new IP. This can confuse traditional
    monitoring systems.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是临时的，大多数人没有意识到这一点。当你有一个容器并且它被重建时，它会有一个新的 IP 地址。这可能会混淆传统的监控系统。
- en: Containers running on clusters can move from one node (server) to another. This
    adds another layer of complexity as your monitoring tool needs to know where your
    containers are to scrape metrics from them. This should not matter with the more
    modern, container-optimized tools.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行在集群中的容器可以从一个节点（服务器）移动到另一个节点。这增加了一个复杂性层，因为您的监控工具需要知道容器的位置，以便从中抓取指标。使用现代的、容器优化的工具，这不应该成为问题。
- en: Prometheus helps us address these challenges as it is built from a distributed
    application’s point of view. To understand this, we’ll look at a hands-on example.
    However, before that, let’s install Prometheus on a separate Ubuntu 22.04 Linux
    machine.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 帮助我们解决这些挑战，因为它是从分布式应用程序的角度构建的。为了理解这一点，我们将通过一个实践示例来进行说明。但是，在此之前，让我们在另一台
    Ubuntu 22.04 Linux 机器上安装 Prometheus。
- en: Installing Prometheus
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Prometheus
- en: Installing Prometheus consists of several steps, and for simplicity, I’ve created
    a Bash script for installing and setting up Prometheus on an Ubuntu machine.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Prometheus 包括几个步骤，为了简化，我创建了一个 Bash 脚本，用于在 Ubuntu 机器上安装和设置 Prometheus。
- en: 'Use the following commands on a separate machine where you want to set up Prometheus:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在您想要设置 Prometheus 的另一台机器上使用以下命令：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To check whether Prometheus is installed and running, check the status of the
    Prometheus service using the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 Prometheus 是否已安装并正在运行，可以使用以下命令检查 Prometheus 服务的状态：
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As the service is `Active`, we can conclude that Prometheus has been installed
    and is running successfully. The next step is configuring the Docker server to
    enable Prometheus to collect logs from it.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务处于`活动`状态，我们可以得出结论，Prometheus 已成功安装并正在运行。下一步是配置 Docker 服务器，以便 Prometheus
    能够从中收集日志。
- en: Configuring cAdvisor and the node exporter to expose metrics
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 cAdvisor 和节点出口程序以暴露指标
- en: 'Now, we’ll launch a cAdvisor container on the machine running Docker to expose
    the metrics of the Docker containers. cAdvisor is a metrics collector that scrapes
    metrics from containers. To launch the container, use the following command:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在运行 Docker 的机器上启动一个 cAdvisor 容器，以暴露 Docker 容器的指标。cAdvisor 是一个指标收集器，用于从容器中抓取指标。要启动容器，请使用以下命令：
- en: '[PRE54]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now that cAdvisor is running, we need to configure the node exporter to export
    node metrics on the Docker machine. To do so, run the following commands:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 cAdvisor 正在运行，我们需要配置节点导出器，以便在 Docker 机器上导出节点指标。为此，运行以下命令：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now that the node exporter is running, let’s configure Prometheus to connect
    to cAdvisor and the node exporter and scrape metrics from there.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在节点导出器正在运行，让我们配置 Prometheus 以连接到 cAdvisor 和节点导出器，并从那里抓取指标。
- en: Configuring Prometheus to scrape metrics
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 Prometheus 以抓取指标
- en: 'We will now configure Prometheus on the Prometheus machine so that it can scrape
    the metrics from cAdvisor. To do so, modify the `/etc/prometheus/prometheus.yml`
    file so that it includes the following within the server running Prometheus:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在 Prometheus 机器上配置 Prometheus，以便它可以从 cAdvisor 抓取指标。为此，修改 `/etc/prometheus/prometheus.yml`
    文件，使其在运行 Prometheus 的服务器中包含以下内容：
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After changing this configuration, we need to restart the Prometheus service.
    Use the following command to do so:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 更改此配置后，我们需要重新启动 Prometheus 服务。使用以下命令执行此操作：
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, let’s launch a sample web application that we will monitor using Prometheus.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动一个示例 Web 应用程序，我们将使用 Prometheus 来监控它。
- en: Launching a sample container application
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动一个示例容器应用程序
- en: 'Now, let’s run an NGINX container called `web` that runs on port `8081` on
    the Docker machine. To do so, use the following command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行一个名为 `web` 的 NGINX 容器，该容器在 Docker 机器上的 `8081` 端口上运行。为此，请使用以下命令：
- en: '[PRE58]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now that we’ve set up the Docker container, let’s go ahead and open the Prometheus
    UI by visiting `https://<PROMETHEUS_SERVER_EXTERNAL_IP>:9090` and then running
    the following query by typing it in the textbox:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好 Docker 容器，让我们通过访问 `https://<PROMETHEUS_SERVER_EXTERNAL_IP>:9090` 打开
    Prometheus UI，然后在文本框中输入以下查询来运行它：
- en: '[PRE59]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It should show something like the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该显示类似以下内容：
- en: '![Figure 3.2 – Prometheus – container_memory_usage_bytes](img/B19877_Figure_3.02.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – Prometheus – container_memory_usage_bytes](img/B19877_Figure_3.02.jpg)'
- en: Figure 3.2 – Prometheus – container_memory_usage_bytes
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – Prometheus – container_memory_usage_bytes
- en: We can also view the time series of this metric by clicking on the **Graph**
    tab. However, before doing so, let’s load our NGINX service using the Apache Bench
    tool. Apache Bench is a load-testing tool that helps us fire HTTP requests to
    the NGINX endpoint using the command line.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过点击**图表**标签页来查看此指标的时间序列。然而，在此之前，让我们使用 Apache Bench 工具加载我们的 NGINX 服务。Apache
    Bench 是一款负载测试工具，帮助我们通过命令行向 NGINX 端点发送 HTTP 请求。
- en: 'On your Docker server, run the following command to start a load test:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Docker 服务器上，运行以下命令来启动负载测试：
- en: '[PRE60]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It will hit the endpoint with 100,000 requests, which means it provides a fair
    amount of load to do a memory spike. Now, if you open the **Graph** tab, you should
    see something like the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 它将向端点发送 100,000 个请求，这意味着它提供了相当大的负载来进行内存突增。现在，如果你打开**图表**标签页，你应该会看到类似以下内容：
- en: '![Figure 3.3 – Prometheus – container_memory_usage_bytes – Graph](img/B19877_Figure_3.03.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – Prometheus – container_memory_usage_bytes – 图表](img/B19877_Figure_3.03.jpg)'
- en: Figure 3.3 – Prometheus – container_memory_usage_bytes – Graph
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Prometheus – container_memory_usage_bytes – 图表
- en: 'To visualize node metrics, we can use the following PromQL statement to get
    the `node_cpu` value of the Docker host:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要可视化节点指标，我们可以使用以下 PromQL 语句来获取 Docker 主机的 `node_cpu` 值：
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As shown in the following screenshot, it will provide us with the `node_cpu`
    metrics for multiple modes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，它将为我们提供多种模式的 `node_cpu` 指标：
- en: '![Figure 3.4 – Prometheus – node_cpu](img/B19877_Figure_3.04.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – Prometheus – node_cpu](img/B19877_Figure_3.04.jpg)'
- en: Figure 3.4 – Prometheus – node_cpu
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – Prometheus – node_cpu
- en: There are a variety of other metrics that Prometheus gives you to visualize.
    Let’s understand some of the metrics you can monitor.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus 还提供了多种其他可视化的指标。让我们来了解一些你可以监控的指标。
- en: Metrics to monitor
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要监控的指标
- en: Monitoring metrics is a complex subject, and it would depend mostly on your
    use case. However, the following are some guidelines on what metrics you want
    to monitor.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 监控指标是一个复杂的话题，主要取决于你的使用场景。不过，以下是一些关于你需要监控的指标的指南。
- en: Host metrics
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主机指标
- en: 'You need to monitor your host metrics as your containers run on them. Some
    of the metrics that you can watch are as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要监控你的主机指标，因为你的容器是在它们上面运行的。你可以监控的一些指标如下：
- en: '**Host CPU**: It’s good to know whether your host has sufficient CPU to run
    your containers. If not, it might terminate some of your containers to account
    for that. So, to ensure reliability, you need to keep this in check.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机 CPU**：了解你的主机是否有足够的 CPU 来运行容器非常重要。如果没有，它可能会终止一些容器来弥补这一点。因此，为了确保可靠性，你需要时刻监控这一点。'
- en: '**Host memory**: Like the host CPU, you need to watch the host memory to detect
    issues such as memory leaks and runaway memory.'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机内存**：像监控主机 CPU 一样，你需要监控主机内存，以便发现内存泄漏或内存异常等问题。'
- en: '**Host disk space**: As Docker containers use the host filesystem to store
    transient and persistent files, you need to monitor it.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机磁盘空间**：由于 Docker 容器使用主机文件系统来存储临时和持久化文件，因此你需要监控它。'
- en: Docker container metrics
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker 容器指标
- en: 'Docker container metrics are the next thing to consider:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器指标是下一个需要考虑的事项：
- en: '**Container CPU**: This metric will provide the amount of CPU used by the Docker
    container. You should monitor it to understand the usability pattern and decide
    where to place your container effectively.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器 CPU**：此指标将提供 Docker 容器使用的 CPU 数量。你应该监控它，以了解容器的使用模式，并决定如何有效地放置容器。'
- en: '**Throttled CPU time**: This metric allows us to understand the total time
    when the CPU was throttled for a container. This lets us know whether a particular
    container needs more CPU time than others, and you can adjust the CPU share constraint
    accordingly.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限速 CPU 时间**：此指标帮助我们了解容器 CPU 被限速的总时间。这可以让我们知道是否某个特定的容器比其他容器需要更多的 CPU 时间，从而可以相应地调整
    CPU 份额限制。'
- en: '**Container memory fail counters**: This metric provides the number of times
    the container requested more than the allocated memory. It will help you understand
    what containers require more than the allocated memory, and you can plan to run
    those containers accordingly.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器内存失败计数器**：此指标提供容器请求的内存超过分配内存的次数。这将帮助你了解哪些容器需要更多的内存，从而可以根据需要调整容器运行。'
- en: '**Container memory usage**: This metric will provide the amount of memory used
    by the Docker container. You can set memory limits according to the usage.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器内存使用量**：此指标将提供 Docker 容器使用的内存量。你可以根据使用情况设置内存限制。'
- en: '**Container swap**: This metric will tell you what containers were using swap
    instead of RAM. It helps us identify memory-hungry containers.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器交换**：这个指标会告诉你哪些容器使用了交换空间而不是内存。它帮助我们识别占用内存较多的容器。'
- en: '**Container disk I/O**: This is an important metric and will help us understand
    containers’ disk profiles. Spikes can indicate a disk bottleneck or suggest that
    you might want to revisit your storage driver configuration.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器磁盘 I/O**：这是一个重要的指标，帮助我们了解容器的磁盘使用情况。峰值可能表明磁盘存在瓶颈，或者提示你可能需要重新审视存储驱动程序的配置。'
- en: '**Container network metrics**: This metric will tell us how much network bandwidth
    the containers use and help us understand traffic patterns. You can use these
    to detect an unexpected network spike or a denial-of-service attack.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器网络指标**：这个指标将告诉我们容器使用了多少网络带宽，并帮助我们理解流量模式。你可以使用这些指标来检测意外的网络高峰或拒绝服务攻击。'
- en: Important tip
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Profiling your application during the performance testing phase in the non-production
    environment will give you a rough idea of how the system will behave in production.
    The actual fine-tuning of your application begins when you deploy them to production.
    Therefore, monitoring is critical, and fine-tuning is a continuous process.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在非生产环境的性能测试阶段对你的应用程序进行性能分析，将给你一个系统在生产环境中表现的粗略概念。应用程序的实际调优工作开始于你将其部署到生产环境时。因此，监控至关重要，调优是一个持续的过程。
- en: So far, we have been running commands to do most of our work. That is the imperative
    way of doing this. But what if I told you that instead of typing commands, you
    could declare what you want, and something could run all the required commands
    on your behalf? That is known as the declarative method of managing an application.
    Docker Compose is one of the popular tools to achieve this. We’ll have a look
    at this in the next section.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在运行命令来完成大部分工作。这是命令式的做法。但如果我告诉你，你不需要输入命令，而是可以声明你想要的内容，接着某个工具就能代表你执行所有需要的命令呢？这就是所谓的声明式应用程序管理方法。Docker
    Compose 是实现这一目标的流行工具之一。我们将在下一节中对此进行详细了解。
- en: Declarative container management with Docker Compose
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 进行声明式容器管理
- en: Docker Compose helps you manage multiple containers in a declarative way. You
    can create a YAML file and specify what you want to build, what containers you
    want to run, and how the containers interact with each other. You can define mounts,
    networks, port mapping, and many different configurations in the YAML file.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 帮助你以声明的方式管理多个容器。你可以创建一个 YAML 文件，指定你想构建的内容、要运行的容器以及容器之间如何交互。你可以在
    YAML 文件中定义挂载、网络、端口映射以及许多不同的配置。
- en: After that, you can simply run `docker compose up` to run your entire containerized
    application.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你只需运行`docker compose up`来启动整个容器化应用程序。
- en: Declarative management is quickly gaining ground because of its power and simplicity.
    Now, sysadmins don’t need to remember what commands they had run or write lengthy
    scripts or playbooks to manage containers. Instead, they can simply declare what
    they want in a YAML file, and `docker compose` or other tools can help them achieve
    that state. We installed Docker Compose when we installed Docker, so let’s see
    it in action with a sample application.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式管理因其强大和简便正在迅速获得认可。现在，系统管理员不再需要记住他们运行过的命令，也不需要编写冗长的脚本或剧本来管理容器。相反，他们只需在 YAML
    文件中声明自己想要的内容，然后`docker compose`或其他工具可以帮助他们实现这一状态。我们在安装 Docker 时也安装了 Docker Compose，接下来我们将通过示例应用程序来实际操作。
- en: Deploying a sample application with Docker Compose
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Docker Compose 部署示例应用程序
- en: We have a Python Flask application that listens on port `5000`, which we will
    eventually map to host port `80`. The application will connect to the Redis database
    as a backend service on its default port, `6379`, and fetch the page’s last visit
    time. We will not expose that port to the host system. This means the database
    is entirely out of bounds for any external party with access to the application.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 Python Flask 应用程序，监听端口`5000`，最终我们将其映射到主机端口`80`。该应用程序将作为后端服务连接到 Redis 数据库，使用默认端口`6379`，并获取页面的最后访问时间。我们不会将该端口暴露给主机系统。这意味着数据库对于任何能够访问应用程序的外部方来说完全是不可触及的。
- en: 'The following diagram depicts the application architecture:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了应用程序架构：
- en: '![Figure 3.5 – Sample application](img/B19877_Figure_3.05.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 示例应用程序](img/B19877_Figure_3.05.jpg)'
- en: Figure 3.5 – Sample application
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 示例应用程序
- en: 'The necessary files are available in this book’s GitHub repository. Run the
    following command to locate the files:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 必要的文件可以在本书的 GitHub 仓库中找到。运行以下命令来定位文件：
- en: '[PRE62]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `app.py` file looks as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py` 文件如下所示：'
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `requirements.txt` file looks as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`requirements.txt` 文件如下所示：'
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: I’ve already built the application for you, and the image is available on Docker
    Hub. The next chapter will cover how to build a Docker image in detail. For now,
    let’s have a look at the `docker-compose` file.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为你构建了应用程序，镜像已上传到 Docker Hub。下一章将详细介绍如何构建 Docker 镜像。现在，让我们先看一下 `docker-compose`
    文件。
- en: Creating the docker-compose file
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 docker-compose 文件
- en: 'The next step in the process is to create a `docker-compose` file. A `docker-compose`
    file is a YAML file that contains a list of services, networks, volumes, and other
    associated configurations. Let’s look at the following example `docker-compose.yaml`
    file to understand it better:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的下一步是创建一个 `docker-compose` 文件。`docker-compose` 文件是一个 YAML 文件，其中包含服务、网络、卷和其他相关配置的列表。让我们看一下以下示例
    `docker-compose.yaml` 文件，以便更好地理解：
- en: '[PRE65]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The YAML file describes two services – `flask` and `redis`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 文件描述了两个服务——`flask` 和 `redis`。
- en: The `flask` service uses the `python-flask-redis:latest` image – the image we
    built with the preceding code. It also maps host port `80` to container port `5000`,
    exposing this application to your host machine on port `80`, and you can access
    it via `http://localhost`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`flask` 服务使用 `python-flask-redis:latest` 镜像——这是我们使用前述代码构建的镜像。它还将主机端口 `80` 映射到容器端口
    `5000`，将此应用程序暴露给主机机器的端口 `80`，你可以通过 `http://localhost` 访问它。'
- en: The `redis` service uses the official `redis:alpine` image and does not expose
    any port, as we don’t want this service outside the container network’s confines.
    However, it declares a persistent volume, `redis-data`, that comprises the `/data`
    directory. We can mount this volume on the host filesystem for persistence beyond
    the container life cycle.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis` 服务使用官方的 `redis:alpine` 镜像，并且不暴露任何端口，因为我们不希望此服务位于容器网络的外部。然而，它声明了一个持久化卷
    `redis-data`，该卷包含 `/data` 目录。我们可以将此卷挂载到主机文件系统中，以便在容器生命周期之外保持数据持久性。'
- en: There is also a `flask-app-net` network that uses the bridge driver, and both
    services share the same network. This means the services can call each other by
    using their service names. If you look at the `app.py` code, you will see that
    we established a Redis service connection using the `redis` hostname.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个使用桥接驱动的 `flask-app-net` 网络，两个服务共享同一个网络。这意味着这些服务可以通过服务名称相互调用。如果你查看 `app.py`
    代码，你会看到我们使用 `redis` 主机名建立了与 Redis 服务的连接。
- en: 'To apply the configuration, simply run `docker-compose` `up -d`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用配置，只需运行 `docker-compose` `up -d`：
- en: '[PRE66]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, let’s list the Docker containers to see how we fare:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们列出 Docker 容器，看看情况如何：
- en: '[PRE67]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We can see that two containers are running for both services. We can also see
    host port `80` forwarding connections to container port `5000` on the `flask`
    service.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两个容器正在为这两个服务运行。我们还可以看到主机端口 `80` 将连接转发到 `flask` 服务的容器端口 `5000`。
- en: The `redis` service is internal and therefore, there is no port mapping.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis` 服务是内部的，因此没有端口映射。'
- en: 'Let’s run `curl localhost` and see what we get:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行 `curl localhost` 看看我们得到什么：
- en: '[PRE68]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, we get the last visited page from the Redis cache according to the sample
    Flask application code.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据示例 Flask 应用程序代码从 Redis 缓存中获取最后访问的页面。
- en: 'Let’s run this a few times and see whether the time changes:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行几次，看看时间是否会变化：
- en: '[PRE69]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We can see that the last visited time changes every time we `curl`. Since the
    volume is persistent, we should get similar last visited times even after a container
    restarts.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到每次执行 `curl` 时，最后访问时间都会变化。由于卷是持久的，即使容器重新启动，我们应该能得到类似的最后访问时间。
- en: 'First, let’s `curl` and get the last visited time and also the current date:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们执行 `curl`，获取最后访问时间以及当前日期：
- en: '[PRE70]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, the next time we `curl`, we should get a date-time similar to `2023-06-01,
    06:55:50`. But before that, let’s restart the container and see whether the data
    persists:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，下次执行 `curl` 时，我们应该得到类似 `2023-06-01, 06:55:50` 的日期时间。但在此之前，让我们重新启动容器，看看数据是否持久：
- en: '[PRE71]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now that Redis has been restarted, let’s run `curl` again:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Redis 已重新启动，让我们再次运行 `curl`：
- en: '[PRE72]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As we can see, we get the correct last visited time, even after restarting the
    `redis` service. This means that data persistence works correctly, and the volume
    is adequately mounted.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，即使重新启动 `redis` 服务，我们也能获取到正确的最后访问时间。这意味着数据持久性工作正常，卷已经正确挂载。
- en: You can do many other configurations on `docker compose` that you can readily
    get from the official documentation. However, you should now have a general idea
    about using `docker compose` and its benefits. Now, let’s look at some of the
    best practices associated with Docker Compose.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `docker compose` 上进行许多其他配置，这些内容可以从官方文档中轻松获取。然而，你现在应该对如何使用 `docker compose`
    及其优点有一个大致的了解。接下来，让我们看看一些与 Docker Compose 相关的最佳实践。
- en: Docker Compose best practices
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Compose 最佳实践
- en: Docker Compose provides a declarative way of managing Docker container configuration.
    This enables GitOps for your Docker workloads. While Docker Compose is primarily
    used in development environments, you can use it in production very effectively,
    especially when Docker runs in production and does not use another container orchestrator
    such as Kubernetes.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose 提供了一种声明式的方式来管理 Docker 容器配置。这使得 GitOps 成为可能，适用于你的 Docker 工作负载。虽然
    Docker Compose 主要用于开发环境，但你可以在生产环境中非常有效地使用它，特别是当 Docker 在生产环境中运行，并且没有使用像 Kubernetes
    这样的容器编排工具时。
- en: Always use docker-compose.yml files alongside code
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 始终与代码一起使用 docker-compose.yml 文件
- en: The YAML file defines how to run your containers. So, it becomes a valuable
    tool for declaratively building and deploying your containers from a single space.
    You can add all dependencies to your application and run related applications
    in a single network.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 文件定义了如何运行你的容器。因此，它成为一个非常有价值的工具，可以从一个地方声明性地构建和部署你的容器。你可以将所有依赖项添加到你的应用程序中，并在同一个网络中运行相关的应用程序。
- en: Separate multiple environment YAMLs using overrides
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用覆盖文件来分隔多个环境的 YAML 文件
- en: Docker Compose YAML files allow us to both build and deploy Docker images. Docker
    has enabled the *build once, run anywhere* concept. This means we build once in
    the development environment and then use the created image in subsequent environments.
    So, the question arises of how we can achieve that. Docker Compose allows us to
    apply multiple YAML files in a sequence where the next configuration overrides
    the last. That way, we can have separate override files for various environments
    and manage multiple environments using a set of these files.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose YAML 文件允许我们同时构建和部署 Docker 镜像。Docker 实现了 *一次构建，随处运行* 的概念。这意味着我们在开发环境中构建一次，然后在随后的环境中使用创建的镜像。因此，问题就来了：我们如何实现这一点呢？Docker
    Compose 允许我们按顺序应用多个 YAML 文件，其中下一个配置会覆盖上一个配置。这样，我们就可以为不同的环境创建单独的覆盖文件，并使用这些文件来管理多个环境。
- en: 'For example, say we have the following base `docker-compose.yaml` file:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有以下基础的 `docker-compose.yaml` 文件：
- en: '[PRE73]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We only have to build the Flask application container image in the development
    environment so that we can create an override file for the development environment
    – that is, `docker-compose.override.yaml`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在开发环境中构建 Flask 应用程序容器镜像，以便为开发环境创建一个覆盖文件——即 `docker-compose.override.yaml`：
- en: '[PRE74]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, we added a `build` parameter within the web service. This means the Python
    Flask application will be rebuilt and then deployed. We also set the `DEBUG` environment
    variable within the `web` service and exposed the `redis` port to the host filesystem.
    This makes sense in the development environment, as we might want to debug Redis
    from the development machine directly. Still, we would not want something of that
    sort in the production environment. Therefore, the default `docker-compose.yaml`
    file will work in the production environment, as we saw in the previous section.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 web 服务中添加了一个 `build` 参数。这意味着 Python Flask 应用程序将被重新构建并部署。我们还在 `web` 服务中设置了
    `DEBUG` 环境变量，并将 `redis` 端口暴露到宿主文件系统。这在开发环境中是有意义的，因为我们可能希望直接从开发机器调试 Redis。不过，我们不希望在生产环境中出现这种情况。因此，默认的
    `docker-compose.yaml` 文件将在生产环境中工作，正如我们在上一节中所看到的那样。
- en: Use an .env file to store sensitive variables
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `.env` 文件存储敏感变量
- en: You might not want to store sensitive content such as passwords and secrets
    in version control. Instead, you can use an `.env` file that contains a list of
    variable names and values and keep it in a secret management system such as HashiCorp
    Vault.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不想将密码和机密等敏感内容存储在版本控制中。相反，你可以使用一个 `.env` 文件，里面包含变量名和值的列表，并将其保存在像 HashiCorp
    Vault 这样的机密管理系统中。
- en: Be mindful of dependencies in production
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在生产环境中要注意依赖关系
- en: 'When you change a particular container and want to redeploy it, `docker-compose`
    also redeploys any dependencies. Now, this might not be something that you wish
    to do, so you can override this behavior by using the following command:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改某个容器并希望重新部署时，`docker-compose` 也会重新部署所有依赖项。不过，这可能并不是你想要的行为，因此你可以通过使用以下命令来覆盖这一行为：
- en: '[PRE75]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Treat docker-compose files as code
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 docker-compose 文件视为代码
- en: Always version control your `docker-compose` files and keep them alongside the
    code. This will allow you to track their versions and use gating and Git features
    such as pull requests.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 永远对你的 `docker-compose` 文件进行版本控制，并将其与代码一起保存。这将允许你跟踪文件版本，并使用 Git 特性，如拉取请求（pull
    request）。
- en: Summary
  id: totrans-373
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was designed to cater to both beginners and experienced individuals.
    We started by covering the foundational concepts of Docker and gradually delved
    into more advanced topics and real-world use cases. This chapter began with installing
    Docker, running our first Docker container, understanding various modes of running
    a container, and understanding Docker volumes and storage drivers. We also learned
    how to select the right storage driver, volume options, and some best practices.
    All these skills will help you easily set up a production-ready Docker server.
    We also discussed the logging agent and how to quickly ship Docker logs to multiple
    destinations, such as **journald**, **Splunk**, and JSON files, to help you monitor
    your containers. We looked at managing Docker containers declaratively using **Docker
    Compose** and deployed a complete composite container application. Please try
    out all the commands mentioned in this chapter for a more hands-on experience
    – practice is vital to achieving something worthwhile and learning something new.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在同时满足初学者和有经验的用户需求。我们从介绍 Docker 的基础概念开始，逐步深入到更高级的主题和实际应用场景。本章首先介绍了 Docker
    的安装，运行第一个 Docker 容器，理解不同的容器运行模式，了解 Docker 卷和存储驱动程序。我们还学习了如何选择合适的存储驱动程序、卷选项以及一些最佳实践。所有这些技能将帮助你轻松搭建一个生产就绪的
    Docker 服务器。我们还讨论了日志代理，如何将 Docker 日志快速发送到多个目的地，如 **journald**、**Splunk** 和 JSON
    文件，帮助你监控容器。我们还探讨了如何使用 **Docker Compose** 声明性地管理 Docker 容器，并部署了一个完整的复合容器应用。请尝试本章中提到的所有命令，进行更多的实践体验——实践是实现有价值的成果和学习新知识的关键。
- en: As a next step, in the following chapter, we will look at Docker images, creating
    and managing them, and some best practices.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，在接下来的章节中，我们将研究 Docker 镜像，创建和管理它们，以及一些最佳实践。
- en: Questions
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题，测试你对本章内容的掌握：
- en: You should use `overlay2` for CentOS and RHEL 7 and below. (True/False)
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于 CentOS 和 RHEL 7 及以下版本，应该使用 `overlay2`。（正确/错误）
- en: Which of the following statements is true? (Choose four)
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个陈述是正确的？（选择四个）
- en: A. Volumes increase IOPS.
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 卷增加 IOPS。
- en: B. Volumes decrease IOPS.
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 卷减少 IOPS。
- en: C. `tmpfs` mounts use system memory.
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. `tmpfs` 挂载使用系统内存。
- en: D. You can use bind mounts to mount host files to containers.
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 你可以使用绑定挂载将主机文件挂载到容器中。
- en: E. You can use volume mounts for a multi-instance active-active configuration.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: E. 你可以使用卷挂载进行多实例的活动-活动配置。
- en: Changing the storage driver removes existing containers from the host. (True/False)
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改存储驱动会删除主机上的现有容器。（正确/错误）
- en: '`devicemapper` is a better option than `overlay2` for write-intensive containers.
    (True/False)'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`devicemapper` 是比 `overlay2` 更适合写密集型容器的选项。（正确/错误）'
- en: Which of the following logging drivers are supported by Docker? (Choose four)
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 支持以下哪些日志驱动？（选择四个）
- en: A. `journald`
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. `journald`
- en: B. Splunk
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. Splunk
- en: C. JSON files
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. JSON 文件
- en: D. Syslog
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. Syslog
- en: E. Logstash
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: E. Logstash
- en: Docker Compose is an imperative approach to managing containers. (True/False)
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose 是一种管理容器的命令式方法。（正确/错误）
- en: Which of the following `docker run` configurations are correct? (Choose three)
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些 `docker run` 配置是正确的？（选择三个）
- en: A. `docker` `run nginx`
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. `docker` `run nginx`
- en: B. `docker run --name` `nginx nginx:1.17.3`
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. `docker run --name` `nginx nginx:1.17.3`
- en: C. `docker run -d --name` `nginx nginx`
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. `docker run -d --name` `nginx nginx`
- en: D. `docker run -d --name nginx nginx --``restart never`
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. `docker run -d --name nginx nginx --``restart never`
- en: Answers
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'The following are the answers to this chapter’s questions:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的答案：
- en: False – You should use `devicemapper` for CentOS and RHEL 7 and below as they
    do not support `overlay2`.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误 – 对于 CentOS 和 RHEL 7 及以下版本，应该使用 `devicemapper`，因为它们不支持 `overlay2`。
- en: B, C, D, E.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B、C、D、E。
- en: True.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确。
- en: True.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确。
- en: A, B, C, D.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A、B、C、D。
- en: False – Docker Compose is a declarative approach to container management.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误 – Docker Compose 是一种声明式的容器管理方法。
- en: A, B, C.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B, C.
