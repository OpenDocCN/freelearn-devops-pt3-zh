- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Implementing Traffic Management, Security, and Observability with Istio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Istio实施流量管理、安全性和可观察性
- en: In the previous chapter, we covered **site reliability engineering** (**SRE**)
    and how it has helped manage production environments using DevOps practices. In
    this chapter, we’ll dive deep into a service mesh technology called Istio, which
    will help us implement SRE practices and manage our application better in production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了**站点可靠性工程**（**SRE**）及其如何通过DevOps实践帮助管理生产环境。在本章中，我们将深入探讨一种名为Istio的服务网格技术，它将帮助我们实施SRE实践，并在生产中更好地管理我们的应用。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Revisiting the Blog App
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视博客应用
- en: Introduction to service mesh
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务网格简介
- en: Introduction to Istio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio简介
- en: Understanding the Istio architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Istio架构
- en: Installing Istio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Istio
- en: Using Istio Ingress to allow traffic
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istio Ingress来允许流量
- en: Securing your microservices using Istio
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istio保护你的微服务
- en: Managing traffic with Istio
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istio管理流量
- en: Observing traffic and alerting with Istio
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istio观察流量并设置告警
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we will spin up a cloud-based Kubernetes cluster, **Google
    Kubernetes Engine** (**GKE**), for the exercises. At the time of writing, **Google
    Cloud Platform** (**GCP**) provides a free $300 trial for 90 days, so you can
    go ahead and sign up for one at [https://console.cloud.google.com/](https://console.cloud.google.com/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将启动一个基于云的Kubernetes集群——**Google Kubernetes Engine**（**GKE**），用于练习。在撰写本文时，**Google
    Cloud Platform**（**GCP**）提供了一个为期90天、价值300美元的免费试用，你可以在[https://console.cloud.google.com/](https://console.cloud.google.com/)注册一个。
- en: 'You will also need to clone the following GitHub repository for some of the
    exercises: [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要克隆以下GitHub仓库以完成一些练习：[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)。
- en: 'You can use the Cloud Shell offering available from GCP to follow this chapter.
    Go to Cloud Shell and start a new session. Run the following command to clone
    the repository into your home directory to access the required resources:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用GCP提供的Cloud Shell来完成本章内容。进入Cloud Shell并启动一个新的会话。运行以下命令将仓库克隆到你的主目录中，以便访问所需资源：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also need to set the project ID and enable a few GCP APIs we will use in
    this chapter. To do so, run the following commands:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置项目ID，并启用一些我们将在本章中使用的GCP API。为此，运行以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you haven't followed the previous chapters and want to start quickly with
    this, you can follow the next part, *Setting up the baseline*, though I highly
    recommend that you go through the last few chapters to get a flow. If you have
    been following the hands-on exercises in the previous chapters, feel free to skip
    this part.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有按照前几章的内容进行学习，想要快速开始，可以继续阅读下一个部分，*设置基础环境*，不过我强烈建议你先阅读前几章，了解整个流程。如果你已经跟着前几章的实操练习走了，那么可以跳过这一部分。
- en: Setting up the baseline
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基础环境
- en: 'To ensure continuity with the previous chapters, let’s start by creating a
    service account for Terraform so that we can interact with our GCP project:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保与前几章的连续性，我们首先创建一个服务账户，用于Terraform与我们的GCP项目进行交互：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will see that a file called `key-file` has been created within your working
    directory. Now, create a new repository called `mdo-environments` with a `README.md`
    file on GitHub, rename the `main` branch to `prod`, and create a new branch called
    `dev` using GitHub. Navigate to `https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions/new`
    and create a secret named `GCP_CREDENTIALS`. For the value, print the `key-file`
    file, copy its contents, and paste it into the **values** field of the GitHub
    secret.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个名为`key-file`的文件已经在你的工作目录中创建。现在，在GitHub上创建一个名为`mdo-environments`的新仓库，并添加一个`README.md`文件，重新命名`main`分支为`prod`，并使用GitHub创建一个名为`dev`的新分支。导航至`https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions/new`，创建一个名为`GCP_CREDENTIALS`的密钥。在**values**字段中，打印`key-file`文件，复制其内容并粘贴到GitHub密钥的**values**字段中。
- en: Next, create another secret, `PROJECT_ID`, and specify your GCP project ID within
    the **values** field.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个密钥`PROJECT_ID`，并在**values**字段中指定你的GCP项目ID。
- en: 'Next, we need to create a **GCS bucket** for Terraform to use as a remote backend.
    To do this, run the following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为Terraform创建一个**GCS bucket**作为远程后端。为此，运行以下命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next thing we need to do is set up our Secrets Manager. Let’s create a
    secret called `external-secrets`, where we will pass the MongoDB credentials in
    the JSON format. To do so, run the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们的 Secrets Manager。让我们创建一个名为 `external-secrets` 的密钥，在其中传递 MongoDB
    的凭证，格式为 JSON。为此，请运行以下命令：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to create the `Secret` resource, which will interact with GCP to fetch
    the stored secret. First, we need to create a GCP service account to interact
    with Secrets Manager using the following commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建 `Secret` 资源，它将与 GCP 交互以获取存储的密钥。首先，我们需要使用以下命令创建一个 GCP 服务账户与 Secrets Manager
    进行交互：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we’re following the principle of least privilege, we will add the following
    role binding to provide access only to the `external-secrets` secret, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们遵循最小权限原则，我们将添加以下角色绑定，仅提供对 `external-secrets` 密钥的访问，具体如下：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s generate the service account key file using the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令生成服务账户密钥文件：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, copy the contents of the `key.json` file into a new GitHub Actions secret
    called `GCP_SM_CREDENTIALS`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `key.json` 文件的内容复制到一个新的 GitHub Actions 密钥 `GCP_SM_CREDENTIALS` 中。
- en: 'We also need to create the following GitHub Actions secrets for binary authorization
    to work:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建以下 GitHub Actions 密钥，以使二进制授权生效：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As the workflow automatically raises pull requests at the end, we need to define
    a GitHub token. This token allows the workflow to act on behalf of the current
    user when creating the pull request. Here are the steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工作流在结束时会自动提交拉取请求，我们需要定义一个 GitHub token。这个 token 允许工作流在创建拉取请求时代表当前用户执行操作。以下是步骤：
- en: Go to [https://github.com/settings/personal-access-tokens/new](https://github.com/settings/personal-access-tokens/new).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://github.com/settings/personal-access-tokens/new](https://github.com/settings/personal-access-tokens/new)。
- en: Create a new token with “Repository” access for the `mdo-environments` repository,
    granting it `read-write` pull request permissions. This approach aligns with the
    principle of least privilege, offering more granular control.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `mdo-environments` 仓库创建一个具有“仓库”访问权限的新 token，授予它 `读写` 拉取请求权限。这种方法符合最小权限原则，提供更精细的控制。
- en: Once the token is created, copy it.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 token 后，复制它。
- en: Now, create a GitHub Actions secret named `GH_TOKEN` and paste the copied token
    as the value.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `GH_TOKEN` 的 GitHub Actions 密钥，并将复制的 token 作为值粘贴进去。
- en: 'Now that all the prerequisites have been met, we can clone our repository and
    copy the baseline code. Run the following commands to do this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有先决条件都已满足，我们可以克隆我们的仓库并复制基础代码。运行以下命令进行此操作：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we’re now on the baseline, let’s proceed further and understand the sample
    Blog App that we will deploy and manage in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处于基础阶段，让我们进一步了解本章将要部署和管理的示例博客应用。
- en: Revisiting the Blog App
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温博客应用
- en: 'Since we discussed the Blog App previously, let’s look at the services and
    their interactions again:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们之前讨论过博客应用，那么让我们再看一遍它的服务及其交互：
- en: '![Figure 15.1 – The Blog App and its services and interactions](img/B19877_15__1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1 – 博客应用及其服务和交互](img/B19877_15__1.jpg)'
- en: Figure 15.1 – The Blog App and its services and interactions
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 博客应用及其服务和交互
- en: So far, we’ve created CI and CD pipelines for building, testing, and pushing
    our Blog App microservices containers using GitHub Actions, deploying them using
    Argo CD in a GKE cluster.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用 GitHub Actions 为构建、测试和推送博客应用微服务容器创建了 CI 和 CD 管道，并通过 Argo CD 在 GKE
    集群中部署它们。
- en: 'As you may recall, we created the following resources for the application to
    run seamlessly:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，我们为确保应用的顺利运行创建了以下资源：
- en: '**MongoDB**: We deployed an auth-enabled MongoDB database with root credentials.
    The credentials were injected via environment variables sourced from a Kubernetes
    **Secret** resource. To persist our database data, we created a **PersistentVolume**
    mounted to the container, which we provisioned dynamically using a **PersistentVolumeClaim**.
    As the container is stateful, we used a **StatefulSet** to manage it and, therefore,
    a headless **Service** to expose the database.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**：我们部署了一个启用了身份验证的 MongoDB 数据库，并使用 root 凭证。凭证通过来自 Kubernetes **Secret**
    资源的环境变量注入。为了持久化数据库数据，我们创建了一个挂载到容器的 **PersistentVolume**，并使用 **PersistentVolumeClaim**
    动态供应它。由于容器是有状态的，我们使用 **StatefulSet** 来管理它，并因此使用无头 **Service** 来公开数据库。'
- en: '**Posts, reviews, ratings, and users**: The *posts*, *reviews*, *ratings*,
    and *users* microservices interacted with MongoDB through the root credentials
    that were injected via environment variables sourced from the same **Secret**
    as MongoDB. We deployed them using their respective **Deployment** resources and
    exposed all of them via individual **ClusterIP Services**.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帖子、评论、评分和用户**：*帖子*、*评论*、*评分*和*用户*微服务通过根凭证与MongoDB交互，这些凭证通过来自同一**Secret**的环境变量注入。我们使用各自的**Deployment**资源部署它们，并通过单独的**ClusterIP
    Services**暴露它们。'
- en: '**Frontend**: The *frontend* microservice does not need to interact with MongoDB,
    so there was no interaction with the Secret resource. We also deployed this service
    using a **Deployment** resource. As we wanted to expose the service on the internet,
    we created a **LoadBalancer Service** for it.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端**：*前端*微服务不需要与MongoDB交互，因此没有与Secret资源的交互。我们也使用**Deployment**资源部署了该服务。由于我们希望将该服务暴露到互联网，我们为其创建了一个**LoadBalancer
    Service**。'
- en: 'We can summarize them with the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下图示来总结它们：
- en: '![Figure 15.2 – Blog App – Kubernetes resources and interactions](img/B19877_15_2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.2 – 博客应用 – Kubernetes 资源和交互](img/B19877_15_2.jpg)'
- en: Figure 15.2 – Blog App – Kubernetes resources and interactions
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – 博客应用 – Kubernetes 资源和交互
- en: Now that we understand the application, let’s understand what a service mesh
    is and how it is beneficial in this use case.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了应用的结构，接下来我们了解一下服务网格是什么以及它在这个用例中的优势。
- en: Introduction to service mesh
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务网格介绍
- en: 'Imagine being in a bustling city with a complex network of roads and highways.
    You’re driving your car from one side of the city to the other. In this scenario,
    you deal with the following entities:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你处在一个繁忙的城市中，城市里有着复杂的道路和高速公路网络。你正在驾驶汽车，从城市的一侧开到另一侧。在这种情况下，你会接触到以下实体：
- en: '**Your car**: Your car represents an individual service or application in a
    computer system. It has a specific purpose, just like a microservice or application
    in a software architecture.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你的汽车**：你的汽车代表计算机系统中的一个独立服务或应用。它有一个特定的目的，就像软件架构中的微服务或应用一样。'
- en: '**Roads and highways**: The roads and highways are like the network connections
    and communication pathways between different services in your application. Services
    need to interact and communicate with each other to perform various functions,
    just as vehicles need roads to get from one place to another.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**道路和高速公路**：道路和高速公路就像是你应用中不同服务之间的网络连接和通信路径。服务需要互相交互和通信来执行各种功能，就像车辆需要道路从一个地方开到另一个地方。'
- en: '**Traffic lights and signs**: Traffic lights, signs, and road rules help manage
    traffic flow, ensuring that vehicles (services) can safely and efficiently navigate
    the city. These are like the rules, protocols, and tools in a service mesh regulating
    communication and data exchange between services.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交通灯和标志**：交通灯、标志和交通规则帮助管理交通流量，确保车辆（服务）能够安全、高效地在城市中行驶。这些就像服务网格中的规则、协议和工具，调节服务之间的通信和数据交换。'
- en: '**Traffic control center**: Think of the traffic control center as the service
    mesh. It’s a centralized system that monitors and manages traffic flow across
    the city. Similarly, a service mesh is a centralized infrastructure that oversees
    and facilitates communication between services, ensuring they can communicate
    reliably and securely.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交通控制中心**：可以把交通控制中心看作是服务网格。它是一个集中式的系统，监控和管理城市的交通流量。类似地，服务网格是一个集中式基础设施，监督并促进服务之间的通信，确保它们能够可靠、安全地通信。'
- en: '**Traffic monitoring and optimization**: The traffic control center ensures
    safe travel and can optimize traffic flow. It can reroute vehicles to avoid congestion
    or accidents. In the context of a service mesh, it can optimize the flow of data
    and requests between services, ensuring efficient and resilient communication.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量监控与优化**：交通控制中心确保安全通行并能够优化交通流量。它可以重新规划车辆路线，避免拥堵或事故。在服务网格的上下文中，它能够优化数据和请求在服务之间的流动，确保高效和弹性的通信。'
- en: '**Safety and reliability**: In the city, the traffic control center helps prevent
    accidents and ensures everyone reaches their destinations safely. Similarly, a
    service mesh enhances the safety and reliability of your computer system by providing
    features such as load balancing, security, and fault tolerance.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性和可靠性**：在城市中，交通控制中心有助于防止事故，确保每个人都能安全到达目的地。同样，服务网格通过提供负载均衡、安全性和容错等功能，提高计算机系统的安全性和可靠性。'
- en: So, just as the traffic control center makes your journey in a complex city
    more manageable and secure, a service mesh in a computer system simplifies and
    secures the communication between different services, ensuring that data and requests
    can flow smoothly, reliably, and safely.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就像交通控制中心让你在复杂的城市中更容易、安全地出行一样，计算机系统中的服务网格简化并保护了不同服务之间的通信，确保数据和请求能够顺畅、可靠、安全地流动。
- en: Containers and the orchestration platforms that manage them, such as Kubernetes,
    have streamlined how we handle microservices. The introduction of container technology
    played a pivotal role in popularizing this concept by allowing for the execution
    and scalability of individual application components as self-contained entities,
    each with an isolated runtime environment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 容器及其管理平台，如 Kubernetes，简化了我们处理微服务的方式。容器技术的引入在推广这一概念方面起到了关键作用，它使得各个应用组件能够作为独立的实体执行和扩展，每个组件都有一个隔离的运行环境。
- en: While adopting a microservices architecture offers advantages such as accelerated
    development, enhanced system robustness, simplified testing, and the ability to
    scale different aspects of an application independently, it isn’t without its
    challenges. Managing microservices can be a complex endeavor. Instead of dealing
    with a single, monolithic application, you now have multiple dynamic components,
    each catering to specific functionalities.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管采用微服务架构提供了加速开发、增强系统稳定性、简化测试和能够独立扩展应用各个部分等优势，但它也有其挑战。管理微服务可能是一项复杂的工作。你不再处理单一的单体应用，而是拥有多个动态组件，每个组件都承担特定的功能。
- en: 'In the context of extensive applications, it’s not uncommon to see hundreds
    of microservices interacting with each other, which can quickly become overwhelming.
    The primary concerns that may be raised by your security and operations teams
    are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模应用的背景下，看到数百个微服务相互交互并不罕见，这可能会迅速变得令人不知所措。你的安全和运维团队可能会提出以下主要问题：
- en: Ensuring secure communication between microservices. You need to secure numerous
    smaller services rather than securing a single monolithic application.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保微服务之间的安全通信。你需要保护许多小服务，而不是保护一个单体应用。
- en: Isolating a problematic microservice in case of an issue.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现问题时，如何隔离一个有问题的微服务。
- en: Testing deployments with a limited percentage of traffic before a full release
    to establish trust.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在全面发布前，以有限比例的流量进行部署测试，以建立信任。
- en: Consolidating application logs that are now distributed across multiple sources.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合现在分布在多个来源的应用日志。
- en: Monitoring the health of the services becomes more intricate, with many components
    constituting the application.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控服务的健康状况变得更加复杂，因为应用由许多组件组成。
- en: While Kubernetes effectively addresses some management issues, it primarily
    serves as a container orchestration platform and excels in that role. However,
    it doesn’t inherently solve all the complexities of a microservices architecture
    as they require specific solutions. Kubernetes does not inherently provide robust
    service management capabilities.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 有效地解决了一些管理问题，但它主要作为容器编排平台，并且在这一角色中表现出色。然而，它并没有固有地解决微服务架构的所有复杂性，因为这些架构需要特定的解决方案。Kubernetes
    本身并不提供强大的服务管理功能。
- en: By default, communication between Kubernetes containers lacks security measures,
    and enforcing TLS between pods involves managing an extensive number of TLS certificates.
    Identity and access management between pods is also not applied out of the box.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes 容器之间的通信缺乏安全措施，强制在 Pod 之间使用 TLS 需要管理大量的 TLS 证书。Pod 之间的身份和访问管理也不是开箱即用的。
- en: While tools such as Kubernetes Network Policy can be employed to implement a
    firewall between pods, they function at a Layer 3 level rather than Layer 7, which
    is what modern firewalls operate at. This means you can identify the source of
    traffic but cannot inspect the data packets to make metadata-driven decisions,
    such as routing based on an HTTP header.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像 Kubernetes 网络策略这样的工具可以用于在 Pod 之间实施防火墙，但它们在第 3 层而非第 7 层运作，而现代防火墙正是基于第 7 层操作。这意味着你可以识别流量的来源，但无法检查数据包，从而做出基于元数据的决策，例如基于
    HTTP 头进行路由。
- en: 'Although Kubernetes offers methods for deploying pods and conducting A/B testing
    and canary deployments, these processes often involve scaling container replicas.
    For example, deploying a new microservice version with just 10% of traffic directed
    to it requires at least 10 containers: 9 for the old version and 1 for the new
    version. Kubernetes distributes traffic evenly among pods without intelligent
    traffic splitting.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Kubernetes 提供了部署 Pod、进行 A/B 测试和金丝雀发布的方法，但这些过程通常涉及容器副本的扩展。例如，部署一个新版本的微服务并将
    10% 的流量导向它，至少需要 10 个容器：9 个用于旧版本，1 个用于新版本。Kubernetes 在 Pod 之间平均分配流量，而没有智能流量拆分。
- en: Each Kubernetes container within a pod maintains separate logging, necessitating
    a custom solution for capturing and consolidating logs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Kubernetes 容器在 Pod 内保持独立的日志记录，因此需要一个定制的解决方案来捕获和汇总日志。
- en: While the Kubernetes dashboard provides features such as monitoring pods and
    checking their health, it does not offer insights into how components interact,
    the traffic distribution among pods, or the container chains that constitute the
    application. The inability to trace traffic flow through Kubernetes pods means
    you cannot pinpoint where in the chain a request encountered a failure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 仪表盘提供了监控 Pod 和检查其健康状况等功能，但它无法提供关于组件如何交互、Pod 之间流量分配情况或构成应用程序的容器链的信息。无法追踪流量在
    Kubernetes Pod 中的流动意味着你无法确定请求在链中遇到故障的位置。
- en: To address these challenges comprehensively, a service mesh technology such
    as Istio can be of extreme help. This can effectively tackle the intricacies of
    managing microservices in Kubernetes and offer solutions for secure communication,
    intelligent traffic management, monitoring, and more. Let’s understand what the
    Istio service mesh is through a brief introduction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面应对这些挑战，像 Istio 这样的服务网格技术可以提供极大的帮助。它可以有效应对 Kubernetes 中微服务管理的复杂性，并为安全通信、智能流量管理、监控等提供解决方案。让我们通过简要介绍来了解
    Istio 服务网格是什么。
- en: Introduction to Istio
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Istio 简介
- en: Istio is a service mesh technology designed to streamline service connectivity,
    security, governance, and monitoring.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 是一种服务网格技术，旨在简化服务连接、安全性、治理和监控。
- en: In the context of a microservices application, each microservice operates independently
    using containers, resulting in a complex web of interactions. This is where a
    service mesh comes into play, simplifying the discovery, management, and control
    of these interactions, often accomplished through a sidecar proxy. Allow me to
    break it down for you step by step.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务应用的背景下，每个微服务独立运行，使用容器，从而产生了一个复杂的交互网络。这就是服务网格发挥作用的地方，它简化了这些交互的发现、管理和控制，通常通过旁车代理来实现。让我一步一步为你解析。
- en: Imagine a standard Kubernetes application comprising a frontend and a backend
    pod. Kubernetes offers built-in service discovery between pods using Kubernetes
    services and CoreDNS. Consequently, you can direct traffic using the service name
    from one pod to another. However, you won’t have significant control over these
    interactions and runtime traffic management.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个标准的 Kubernetes 应用，由前端和后端 Pod 组成。Kubernetes 提供了使用 Kubernetes 服务和 CoreDNS
    进行 Pod 之间的内建服务发现。因此，你可以使用服务名称将流量从一个 Pod 引导到另一个 Pod。然而，你对这些交互和运行时流量管理的控制将有限。
- en: Istio steps in by injecting a sidecar container into your pod, which acts as
    a proxy. Your containers communicate with other containers via this proxy. This
    architecture allows all requests to flow through the proxy, enabling you to exert
    control over the traffic and collect data for further analysis. Moreover, Istio
    provides the means to encrypt communication between pods and enforce identity
    and access management through a unified control plane.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 通过将旁车容器注入到 Pod 中，充当代理。你的容器通过这个代理与其他容器进行通信。这种架构使得所有请求都通过代理流动，从而使你能够控制流量并收集数据以供进一步分析。此外，Istio
    提供了加密 Pod 之间通信的手段，并通过统一的控制平面实施身份和访问管理。
- en: Due to this architecture, Istio boasts a range of core functionalities that
    enhance the traffic management, security, and observability of your microservices
    environment.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种架构，Istio 拥有一系列核心功能，能够提升微服务环境中的流量管理、安全性和可观测性。
- en: Traffic management
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流量管理
- en: Istio effectively manages traffic by harnessing the power of the sidecar proxy,
    often referred to as the envoy proxy, alongside **ingress** and **egress gateways**.
    With these components, Istio empowers you to shape traffic and define service
    interaction rules. This includes implementing features such as **timeouts**, **retries**,
    **circuit breakers**, and much more, all through configurations within the control
    plane.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 通过利用 sidecar 代理（通常称为 envoy 代理）以及**入口**和**出口网关**，有效地管理流量。借助这些组件，Istio 使你能够塑造流量并定义服务交互规则。这包括实现诸如**超时**、**重试**、**熔断器**等功能，所有这些都可以通过控制面中的配置进行设置。
- en: These capabilities open the door to intelligent practices such as **A/B testing**,
    **canary deployments**, and **staged rollouts** with **traffic division based
    on percentages**. You can seamlessly execute gradual releases, transitioning from
    an existing version (**Blue**) to a new one (**Green**), all with user-friendly
    controls.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能为智能实践提供了可能，比如**A/B 测试**、**金丝雀部署**和**分阶段发布**，以及**基于百分比的流量划分**。你可以无缝执行渐进式发布，从现有版本（**Blue**）过渡到新版本（**Green**），所有操作都可以通过用户友好的控制界面完成。
- en: Moreover, Istio allows you to conduct operational tests in a live production
    environment, offering **live traffic mirroring** to test instances. This enables
    you to gather real-time insights and identify potential production issues before
    they impact your application. Additionally, you can route requests to different
    language-specific microservices versions based on **geolocation or user profiles**,
    among other possibilities.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Istio 允许你在生产环境中进行操作测试，通过**实时流量镜像**来测试实例。这使你能够收集实时数据并在问题影响应用程序之前识别潜在的生产问题。此外，你还可以基于**地理位置或用户档案**等因素，将请求路由到不同语言版本的微服务。
- en: Security
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Istio takes security seriously by securing your microservices through the envoy
    proxy and establishing identity access management between pods via mutual TLS.
    It is a robust defense against man-in-the-middle attacks through out-of-the-box
    **traffic encryption** between pods. This mutual authentication ensures that only
    trusted frontends can connect to backends, creating a strong trust relationship.
    Consequently, even if one of the pods is compromised, it cannot compromise the
    rest of your application. Istio further enhances security with **fine-grained
    access control policies** and introduces auditing tools currently lacking in Kubernetes,
    enhancing your cluster’s overall security posture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 重视安全性，通过 envoy 代理保护你的微服务，并通过互信 TLS 在 pods 之间建立身份访问管理。这是一种强大的防御机制，能够防止中间人攻击，且在
    pods 之间提供开箱即用的**流量加密**。这种互认证确保只有受信任的前端可以连接到后台，从而建立强大的信任关系。因此，即使其中一个 pod 被攻破，它也无法威胁到应用程序的其他部分。Istio
    进一步增强了安全性，提供了**细粒度的访问控制策略**，并引入了目前 Kubernetes 中缺乏的审计工具，从而提升了集群的整体安全性。
- en: Observability
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察性
- en: Thanks to the envoy sidecar, Istio maintains a keen awareness of the traffic
    flowing through the pods, enabling you to gather crucial telemetry data from the
    services. This wealth of data aids in gaining insights into service behavior and
    offers a window into future optimization possibilities for your applications.
    Additionally, Istio consolidates application logs and facilitates **traffic tracing**
    through multiple microservices. These features empower you to identify and resolve
    issues more swiftly, helping you isolate problematic services and expedite debugging.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 envoy sidecar 的存在，Istio 能够敏锐地感知流经 pod 的流量，从而使你能够从服务中收集至关重要的遥测数据。这些丰富的数据有助于深入了解服务行为，并为应用程序未来的优化提供了一个窗口。此外，Istio
    还整合了应用程序日志，并通过多个微服务实现**流量追踪**。这些功能使你能够更迅速地识别和解决问题，帮助你隔离有问题的服务并加快调试过程。
- en: Developer-friendly
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向开发者的友好性
- en: Istio’s most remarkable feature is its ability to relieve developers from the
    burdens of managing security and operational intricacies within their implementations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 最显著的特点是，它能够减轻开发者在实现过程中管理安全性和操作复杂性的负担。
- en: Istio’s Kubernetes-aware nature permits developers to continue building their
    applications as standard Kubernetes deployments. Istio seamlessly and automatically
    injects sidecar containers into the pods, sparing developers the need to worry
    about these technical intricacies.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 对 Kubernetes 的深刻理解使得开发者可以继续像标准 Kubernetes 部署那样构建应用程序。Istio 会无缝且自动地将 sidecar
    容器注入到 pods 中，免去开发者对这些技术细节的担忧。
- en: Once these sidecar containers have been integrated, operations and security
    teams can then step in to enforce policies related to traffic management, security,
    and the overall operation of the application. This results in a mutually beneficial
    scenario for all involved parties.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些边车容器被集成，运维和安全团队就可以介入，执行与流量管理、安全性及应用程序整体运营相关的政策。这为所有相关方创造了互利的局面。
- en: Istio empowers security and operations teams to efficiently oversee microservices
    applications without hampering the development team’s productivity. This collaborative
    approach ensures that each team within the organization can maintain its specialized
    focus and effectively contribute to the app’s success. Now that we understand
    Istio, let’s look at its architecture.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 使安全和运维团队能够高效地监管微服务应用程序，而不妨碍开发团队的生产力。这种协作方法确保组织内的每个团队都能保持其专业焦点，并有效地为应用程序的成功做出贡献。现在我们已经了解了
    Istio，接下来我们将看看它的架构。
- en: Understanding the Istio architecture
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Istio 架构
- en: 'Istio simplifies microservices management through two fundamental components:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 通过两个基本组件简化了微服务的管理：
- en: '**Data plane**: This comprises the sidecar envoy proxies that Istio injects
    into your microservices. These proxies take on the essential role of routing traffic
    between various services, and they also collect crucial telemetry data to facilitate
    monitoring and insights.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据平面**：数据平面由 Istio 注入到微服务中的边车 envoy 代理组成。这些代理承担着在不同服务之间路由流量的关键角色，并收集重要的遥测数据，以便于监控和分析。'
- en: '**Control plane**: The control plane serves as the command center, instructing
    the data plane on how to route traffic effectively. It also handles the storage
    and management of configuration details, making it easier for administrators to
    interact with the sidecar proxy and take control of the Istio service mesh. In
    essence, the control plane functions as the intelligence and decision-making hub
    of Istio.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制平面**：控制平面充当指挥中心，指示数据平面如何有效地路由流量。它还负责配置细节的存储和管理，便于管理员与边车代理交互并控制 Istio 服务网格。本质上，控制平面是
    Istio 的智能和决策中心。'
- en: 'Similarly, Istio manages two types of traffic:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Istio 管理两种类型的流量：
- en: '**Data plane traffic**: This type of traffic consists of the core business-related
    data exchanged between your microservices. It encompasses the actual interactions
    and transactions that your application handles.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据平面流量**：这种流量由微服务之间交换的核心业务相关数据组成。它涵盖了应用程序处理的实际交互和事务。'
- en: '**Control plane traffic**: In contrast, the control plane traffic consists
    of messages and communications between Istio components, and it is chiefly responsible
    for governing the behavior of the service mesh. It acts as the control mechanism
    that orchestrates the routing, security, and overall functioning of the microservices
    architecture.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制平面流量**：相反，控制平面流量由 Istio 组件之间的消息和通信组成，主要负责管理服务网格的行为。它充当着控制机制，协调微服务架构中的路由、安全性和整体功能。'
- en: 'The following diagram describes the Istio architecture in detail:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下图详细描述了 Istio 架构：
- en: '![Figure 15.3 – Istio architecture](img/B19877_15_3.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.3 – Istio 架构](img/B19877_15_3.jpg)'
- en: Figure 15.3 – Istio architecture
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 – Istio 架构
- en: As we can see two distinct parts in the preceding diagram, the control plane
    and the data plane, let’s go ahead and understand them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的图示中看到的，控制平面和数据平面是两个不同的部分，接下来我们将深入了解它们。
- en: The control plane architecture
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制平面架构
- en: Istio ships the control plane as a single **istiod** component. The Istio control
    plane, or istiod, comprises several critical components, each playing a distinct
    role in managing your service mesh.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 将控制平面作为一个单独的 **istiod** 组件进行部署。Istio 控制平面，或称 istiod，包含多个关键组件，每个组件在管理服务网格中扮演着独特的角色。
- en: Pilot
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pilot
- en: '**Pilot** serves as the central control hub of the service mesh. It communicates
    with the envoy sidecars using the Envoy API and translates the high-level rules
    specified in Istio manifests into envoy configurations. Pilot enables service
    discovery, intelligent traffic management, and routing capabilities. It empowers
    you to implement practices such as A/B testing, Blue/Green deployments, canary
    rollouts, and more. Additionally, Pilot enhances the resiliency of your service
    mesh by configuring sidecars to handle tasks such as timeouts, retries, and circuit
    breaking. One of its notable features is providing a bridge between Istio configuration
    and the underlying infrastructure, allowing Istio to run on diverse platforms
    such as Kubernetes, **Nomad**, and **Consul**. Regardless of the platform, Pilot
    ensures consistent traffic management.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pilot** 作为服务网格的中央控制中心，使用 Envoy API 与 envoy sidecar 通信，并将 Istio 清单中指定的高级规则转换为
    envoy 配置。Pilot 支持服务发现、智能流量管理和路由功能。它使您能够实施 A/B 测试、蓝绿部署、金丝雀发布等实践。此外，Pilot 通过配置 sidecar
    处理超时、重试和断路等任务，增强了服务网格的弹性。它的一个显著特点是提供 Istio 配置与底层基础设施之间的桥梁，使 Istio 能够在多种平台上运行，如
    Kubernetes、**Nomad** 和 **Consul**。无论平台如何，Pilot 都能确保一致的流量管理。'
- en: Citadel
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Citadel
- en: '**Citadel** focuses on identity and access management within your service mesh,
    fostering secure communication between Kubernetes pods. It safeguards your pods
    by ensuring encrypted communication, even if your developers have designed components
    with insecure TCP connections. Citadel simplifies the implementation of mutual
    TLS by managing the complexities of certificates. It offers user authentication,
    credential management, certificate handling, and traffic encryption, ensuring
    pods can securely validate one another when necessary.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**Citadel** 专注于在您的服务网格内进行身份和访问管理，促进 Kubernetes pod 之间的安全通信。它通过确保加密通信来保护您的 pod，即使您的开发人员设计的组件使用了不安全的
    TCP 连接。Citadel 通过管理证书的复杂性简化了相互 TLS 的实现。它提供用户身份验证、凭证管理、证书处理和流量加密，确保 pod 在必要时能够安全地相互验证。'
- en: Galley
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Galley
- en: '**Galley** is responsible for essential configuration tasks within your service
    mesh. It validates, processes, and distributes configuration changes throughout
    the Istio control plane. For example, when you apply a new policy, Galley ingests
    the configuration, validates its accuracy, processes it for the intended components,
    and seamlessly disseminates it within the service mesh. In essence, Galley serves
    as the interface through which the Istio control plane interacts with the underlying
    APIs, facilitating the smooth management of your service mesh.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Galley** 负责服务网格中的基本配置任务。它验证、处理并分发配置更改到 Istio 控制平面。例如，当您应用新的策略时，Galley 会摄取该配置，验证其准确性，处理并为目标组件准备，最后无缝地在服务网格中分发。简而言之，Galley
    作为 Istio 控制平面与底层 API 之间的接口，促进了服务网格的顺利管理。'
- en: Now, let’s dive deep into understanding the data plane architecture.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解数据平面架构。
- en: The data plane architecture
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据平面架构
- en: The data plane component of Istio is composed of **envoy proxies**, **ingress
    gateways**, and **egress gateways**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 的数据平面组件由 **envoy 代理**、**入口网关** 和 **出口网关** 组成。
- en: Envoy proxies
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Envoy 代理
- en: 'Envoy proxies play a pivotal role in enabling various aspects of your service
    mesh. These **Layer 7** proxies are uniquely capable of making crucial decisions
    based on the content of the messages they handle, and they are the sole components
    that directly interact with your business traffic. Here’s how these envoy proxies
    contribute to the functionality of Istio:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 代理在启用服务网格的各个方面中发挥着至关重要的作用。这些 **第 7 层** 代理能够根据它们处理的消息内容做出重要决策，并且它们是唯一直接与您的业务流量交互的组件。以下是这些
    envoy 代理如何贡献于 Istio 的功能：
- en: '**Traffic control**: They provide fine-grained control over how traffic flows
    within your service mesh, allowing you to define routing rules for various types
    of traffic, including **HTTP**, **TCP**, **WebSockets**, and **gRPC**.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量控制**：它们提供对服务网格内流量流动的细粒度控制，允许您为各种类型的流量定义路由规则，包括 **HTTP**、**TCP**、**WebSockets**
    和 **gRPC**。'
- en: '**Security and authentication**: Envoy proxies enforce **identity and access
    management**, ensuring that only authorized pods can interact with one another.
    They implement **mutual TLS** and **traffic encryption** to prevent **man-in-the-middle
    attacks** and offer features such as rate limiting to safeguard against runaway
    costs and **denial-of-service attacks**.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性和认证**：Envoy 代理执行**身份和访问管理**，确保只有经过授权的 pod 可以相互交互。它们实现**相互 TLS**和**流量加密**，以防止**中间人攻击**，并提供如速率限制等特性，以防止超出预算的成本和**拒绝服务攻击**。'
- en: '**Network resiliency**: They enhance network resiliency by supporting features
    such as **retries**, **failover**, **circuit breaking**, and **fault injection**
    to maintain the reliability and robustness of your services.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络弹性**：它们通过支持**重试**、**故障转移**、**断路器**和**故障注入**等特性来增强网络弹性，保持服务的可靠性和健壮性。'
- en: Next, let’s look at Ingress and egress gateways.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看入站和出站网关。
- en: Ingress and egress gateways
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入站和出站网关
- en: In Istio, ingress is a collection of one or more envoy proxies, which Pilot
    dynamically configures upon their deployment. These envoy proxies are crucial
    in controlling and routing incoming external traffic into your service mesh, ensuring
    that it is appropriately directed to the relevant services based on defined routing
    rules and policies. This dynamic configuration allows Istio to effectively manage
    and secure external traffic flows without requiring extensive manual intervention,
    ensuring that your applications can operate efficiently and securely within the
    service mesh.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Istio 中，入站网关是一组一个或多个 envoy 代理，Pilot 在其部署时动态配置这些代理。这些 envoy 代理在控制和路由外部流量进入您的服务网格中至关重要，确保流量根据定义的路由规则和策略正确地指向相关服务。这种动态配置使得
    Istio 能够有效地管理和保护外部流量流动，而无需大量的人工干预，确保您的应用程序可以在服务网格内高效、安全地运行。
- en: Egress gateways are similar to ingress gateways but they work on outgoing traffic
    instead. To understand this better, let’s use *Figure 15**.3* as a reference and
    understand the traffic flow through **Service A** and **Service B**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 出站网关与入站网关相似，但它们处理的是出站流量。为了更好地理解这一点，我们可以参考*图 15.3*，了解**服务 A**和**服务 B**之间的流量流向。
- en: In this architecture, traffic within the service mesh follows a structured path
    through **Ingress**, microservices (**Service A** and **Service B**), and **Egress**,
    ensuring efficient routing and security measures. Let’s break down the flow of
    a traffic packet through your service mesh.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个架构中，服务网格中的流量遵循一个结构化的路径，通过**入站**、微服务（**服务 A**和**服务 B**）以及**出站**，确保高效的路由和安全措施。让我们分解一下流量包在服务网格中的流动过程。
- en: Ingress
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 入站
- en: Traffic enters the service mesh through an ingress resource, which is essentially
    a cluster of envoy proxies. Pilot configures these envoy proxies upon deployment.
    Ingress proxies are aware of their backends due to configurations based on Kubernetes
    service endpoints. Ingress proxies conduct health checks, perform load balancing,
    and make intelligent routing decisions based on metrics such as load, packets,
    quotas, and traffic balancing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 流量通过入站资源进入服务网格，入站资源本质上是一个 envoy 代理集群。Pilot 在部署时配置这些 envoy 代理。由于基于 Kubernetes
    服务端点的配置，入站代理了解其后端服务。入站代理执行健康检查、负载均衡，并基于负载、数据包、配额和流量平衡等指标做出智能路由决策。
- en: Service A
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务 A
- en: Once Ingress routes the traffic to a pod, it encounters the sidecar proxy container
    of the Service A pod, not the actual microservice container. The envoy proxy and
    the microservice container share the same network namespace within the pod and
    have identical IP addresses and IP Table rules. The envoy proxy takes control
    of the pod, handling all traffic passing through it. The proxy interacts with
    Citadel to enforce policies, checks whether traffic needs encryption, and establishes
    TLS connections with the backend pod.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦入站网关将流量路由到一个 pod，它会遇到服务 A pod 的边车代理容器，而不是实际的微服务容器。envoy 代理和微服务容器共享 pod 内的同一网络命名空间，并且具有相同的
    IP 地址和 IP 表规则。envoy 代理控制 pod，处理通过它的所有流量。该代理与 Citadel 进行交互，执行策略，检查流量是否需要加密，并与后端
    pod 建立 TLS 连接。
- en: Service B
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务 B
- en: Service A’s encrypted packet is sent to Service B, where similar steps are followed.
    Service B’s proxy verifies the sender’s identity through a TLS handshake with
    the source proxy. Upon establishing trust, the packet is forwarded to the Service
    B container, continuing the flow toward the egress layer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 服务A的加密数据包被发送到服务B，服务B会遵循类似的步骤。服务B的代理通过与源代理进行TLS握手来验证发送者的身份。在建立信任后，数据包被转发到服务B的容器，继续流向出口层。
- en: Egress
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 出口
- en: The egress resource manages outbound traffic from the mesh. Egress defines which
    traffic can exit the mesh and employs Pilot for configuration, similar to the
    ingress layer. Egress resources enable the implementation of policies restricting
    outbound traffic to only necessary services.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 出口资源管理着来自网格的出站流量。出口定义了哪些流量可以离开网格，并使用Pilot进行配置，类似于入口层。出口资源使得可以实施限制出站流量只流向必要服务的策略。
- en: Telemetry data collection
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遥测数据收集
- en: Throughout these steps, proxies collect telemetry data from the traffic. This
    telemetry data is sent to **Prometheus** for storage and analysis. This data can
    be visualized in **Grafana**, offering insights into the service mesh’s behavior.
    The telemetry data can also be sent to external tools such as **ELK** for more
    in-depth analysis and machine learning applications on metrics collected.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤中，代理收集来自流量的遥测数据。这些遥测数据会发送到**Prometheus**进行存储和分析。这些数据可以在**Grafana**中可视化，提供对服务网格行为的洞察。遥测数据也可以发送到外部工具，如**ELK**，以便对收集的指标进行更深入的分析和机器学习应用。
- en: This structured flow ensures traffic moves securely and efficiently through
    the service mesh while providing valuable insights for monitoring, analysis, and
    decision-making processes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这一结构化流程确保流量在服务网格中安全高效地流动，同时为监控、分析和决策过程提供宝贵的洞察。
- en: Now that we’ve understood the Istio architecture and its features, let’s go
    ahead and see how we can install it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了Istio的架构和特点，接下来让我们看看如何安装它。
- en: Installing Istio
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Istio
- en: The general way of installing Istio is to download Istio using the provided
    link and run a shell, which will install Istio on our system, including the **istioctl**
    component. Then, we need to use **istioctl** to install Istio within a Kubernetes
    cluster. However, since we’re using GitOps, we will use the GitOps principles
    to install it. Istio offers another method to install Istio – that is, using Helm.
    Since we know that Argo CD supports Helm, we will use that instead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Istio的一般方式是通过提供的链接下载Istio并运行一个shell，这将把Istio安装到我们的系统中，包括**istioctl**组件。然后，我们需要使用**istioctl**在Kubernetes集群中安装Istio。然而，由于我们使用的是GitOps，我们将使用GitOps原则来安装它。Istio还提供了另一种安装方式——使用Helm。由于我们知道Argo
    CD支持Helm，因此我们将使用它。
- en: 'Therefore, we will create new Argo CD applications to deploy it. We will create
    an Argo CD application for `istio-base`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建新的Argo CD应用程序来部署它。我们将为`istio-base`创建一个Argo CD应用程序：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we can see, it will deploy `v1.19.1` of the `istio-base` helm chart from
    [https://istio-release.storage.googleapis.com/charts](https://istio-release.storage.googleapis.com/charts)
    to the `istio-system` namespace of the Kubernetes cluster. Similarly, we will
    deploy `istiod` to the `istio-system` namespace using the following config:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它将从[https://istio-release.storage.googleapis.com/charts](https://istio-release.storage.googleapis.com/charts)部署`istio-base`的`v1.19.1`
    helm图表到Kubernetes集群的`istio-system`命名空间。类似地，我们将使用以下配置将`istiod`部署到`istio-system`命名空间：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we will install the `istio-ingress` component on the `istio-ingress`
    namespace using the following config:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用以下配置在`istio-ingress`命名空间中安装`istio-ingress`组件：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will also define the configuration on Terraform so that we can use push-based
    GitOps to create our application automatically. So, we will append the following
    to the `app.tf` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在Terraform中定义配置，以便我们可以使用基于推送的GitOps自动创建我们的应用。因此，我们将以下内容附加到`app.tf`文件中：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can commit and push these files to our remote repository and wait for
    Argo CD to reconcile the changes using the following commands:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以提交并推送这些文件到我们的远程仓库，并等待Argo CD使用以下命令进行变更协调：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As soon as we push the code, we’ll see that the GitHub Actions workflow has
    been triggered. To access the workflow, go to `https://github.com/<your_github_user>/mdo-environments/actions`.
    Soon, the workflow will apply the configuration and create the Kubernetes cluster,
    deploy Argo CD, external secrets, our Blog App, and Istio.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推送代码，我们将看到GitHub Actions工作流已触发。要访问该工作流，请前往`https://github.com/<your_github_user>/mdo-environments/actions`。不久后，工作流将应用配置并创建Kubernetes集群，部署Argo
    CD、外部机密、我们的Blog应用和Istio。
- en: 'Once the workflow succeeds, we must access the Argo Web UI. To do that, we
    need to authenticate with the GKE cluster. To do so, run the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工作流成功执行，我们必须访问Argo Web UI。为此，我们需要使用GKE集群进行身份验证。执行以下命令来完成身份验证：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To utilize the Argo CD Web UI, you will require the external IP address of
    the `argo-server` service. To get that, run the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Argo CD Web UI，您需要`argo-server`服务的外部IP地址。要获取该地址，请运行以下命令：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we know that Argo CD can be accessed at `https://34.122.51.25/`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道可以通过`https://34.122.51.25/`访问Argo CD。
- en: 'Next, we will run the following commands to reset the admin password:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行以下命令来重置管理员密码：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, allow 2 minutes for the new credentials to be generated. After that, execute
    the following command to retrieve the password:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，等待2分钟让新凭证生成。之后，执行以下命令以获取密码：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have the credentials, we can log in. We will see the following
    page:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了凭证，可以登录了。我们将看到以下页面：
- en: '![Figure 15.4 – Argo CD Web UI – home page](img/B19877_15_4.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.4 – Argo CD Web UI – 主页](img/B19877_15_4.jpg)'
- en: Figure 15.4 – Argo CD Web UI – home page
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 – Argo CD Web UI – 主页
- en: As we can see, the Istio applications are up and running. Though Istio is installed
    and running, the sidecars won’t be injected unless we ask Istio to do so. We’ll
    look at this next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Istio应用程序已启动并运行。尽管Istio已经安装并运行，但除非我们要求Istio注入侧车，否则侧车不会被注入。接下来我们会讲解这个部分。
- en: Enabling automatic sidecar injection
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用自动侧车注入
- en: 'Since envoy sidecars are the key technology behind Istio’s capabilities, they
    must be added to your existing pods to enable Istio to manage them. Updating each
    pod’s configuration to include these sidecars can be challenging. To address this
    challenge, Istio offers a solution by enabling the automatic injection of these
    sidecars. To allow automatic sidecar injection on a namespace, we must add a label
    – that is, `istio-injection: enabled`. To do so, we will modify the `blog-app.yaml`
    file and add the label to the namespace resource:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '由于envoy侧车是Istio功能背后的关键技术，它们必须添加到现有的Pod中，以便Istio能够管理它们。更新每个Pod的配置以包含这些侧车可能具有挑战性。为了解决这个问题，Istio提供了解决方案，通过启用这些侧车的自动注入功能。要在命名空间上启用自动侧车注入，我们必须添加一个标签——即`istio-injection:
    enabled`。为此，我们将修改`blog-app.yaml`文件，并将标签添加到命名空间资源中：'
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can commit this resource to Git and push the changes remotely using
    the following commands:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将此资源提交到Git并使用以下命令将更改推送到远程：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the next Argo CD sync, we will soon find the label attached to the namespace.
    As soon as the label is applied, we need to restart our deployments and stateful
    sets, at which point new pods will come up with the injected sidecars. Use the
    following commands to do so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次Argo CD同步中，我们将很快找到附加到命名空间的标签。标签应用后，我们需要重新启动部署和有状态集，此时新Pod将启动并带有注入的侧车。使用以下命令进行操作：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let’s list the pods in the `blog-app` namespace using the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令列出`blog-app`命名空间中的Pod：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see, the pods now show two containers instead of one. The extra container
    is the envoy sidecar. Istio’s installation and setup are complete.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Pod现在显示两个容器，而不是一个。额外的容器是envoy侧车。Istio的安装和设置已完成。
- en: Now that our application has the Istio sidecar injected, we can use Istio ingress
    to allow traffic to our application, which is currently exposed via a load balancer
    service.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用已经注入了Istio侧车，我们可以使用Istio入口控制器来允许流量访问我们的应用，当前该应用通过负载均衡服务暴露。
- en: Using Istio ingress to allow traffic
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Istio入口控制器来允许流量
- en: We need to create a Blog App ingress gateway to associate our application with
    the Istio ingress gateway. It is necessary for configuring our application to
    route traffic through the Istio ingress gateway as we want to leverage Istio’s
    traffic management and security features.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个Blog应用的入口网关，将我们的应用与Istio入口网关关联起来。这是配置我们的应用通过Istio入口网关路由流量所必需的，因为我们希望利用Istio的流量管理和安全功能。
- en: 'Istio deploys the Istio ingress gateway as a part of the installation process,
    and it’s exposed on a load balancer by default. To determine the load balancer’s
    IP address and ports, you can run the following commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 在安装过程中会部署 Istio 入口网关，并且默认将其暴露在负载均衡器上。要确定负载均衡器的 IP 地址和端口，你可以运行以下命令：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see, Istio exposes various ports on your load balancer, and as our
    application needs to run on port 80, we can access it using `http://<IngressLoadBalancerExternalIP>:80`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Istio 在负载均衡器上暴露了多个端口，而我们的应用程序需要运行在端口 80，因此我们可以使用`http://<IngressLoadBalancerExternalIP>:80`来访问它。
- en: The next step would be to use this ingress gateway and expose our application.
    For that, we need to create **Gateway** and **VirtualService** resources.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用这个入口网关并暴露我们的应用程序。为此，我们需要创建**网关（Gateway）**和**虚拟服务（VirtualService）**资源。
- en: Istio gateway is a **custom resource definition** (**CRD**) that helps you define
    how incoming external traffic can access services in your mesh. It acts as an
    entry point to your service and a load balancer for incoming traffic. When external
    traffic arrives at a gateway, it determines how to route it to the appropriate
    services based on the specified routing rules.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 网关是一个**自定义资源定义**（**CRD**），它帮助你定义外部流量如何访问你的服务网格中的服务。它充当服务的入口点，并作为传入流量的负载均衡器。当外部流量到达网关时，它会根据指定的路由规则来决定如何将流量路由到相应的服务。
- en: When we define an Istio gateway, we also need to define a `VirtualService` resource
    that uses the gateway and describes the routing rules for the traffic. Without
    a `VirtualService` resource, the Istio gateway will not know where and how to
    route the traffic it receives. A `VirtualService` resource is not only used for
    routing traffic from gateways but also for routing traffic within different services
    of the mesh. It allows you to define sophisticated routing rules, including traffic
    splitting, retries, timeouts, and more. Virtual services are often associated
    with specific services or workloads and determine how traffic should be routed
    to them. You can use virtual services to control how traffic is distributed among
    different versions of a service, enabling practices such as A/B testing, canary
    deployments, and Blue/Green deployments. Virtual services can also route traffic
    based on HTTP headers, paths, or other request attributes. In the current context,
    we will use the `VirtualService` resource to filter traffic based on paths and
    route them all to the **frontend** microservice.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个 Istio 网关时，我们还需要定义一个使用该网关并描述流量路由规则的`VirtualService`资源。如果没有`VirtualService`资源，Istio
    网关将不知道如何以及将流量路由到哪里。`VirtualService`资源不仅用于从网关路由流量，还用于在网格中的不同服务之间路由流量。它允许你定义复杂的路由规则，包括流量分配、重试、超时等。虚拟服务通常与特定的服务或工作负载关联，并决定如何将流量路由到这些服务。你可以使用虚拟服务来控制流量如何在服务的不同版本之间分配，从而支持
    A/B 测试、金丝雀发布和蓝绿部署等实践。虚拟服务还可以根据 HTTP 头、路径或其他请求属性来路由流量。在当前的上下文中，我们将使用`VirtualService`资源根据路径过滤流量，并将它们全部路由到**前端**微服务。
- en: 'Let’s look at the definition of the `Gateway` resource first:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先查看`Gateway`资源的定义：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we can see, we define a `Gateway` resource that uses the Istio ingress gateway
    (defined by the `istio: ingress` selector) and listens on HTTP port `80`. It allows
    connection to all hosts as we’ve set that to `"*"`. For gateways to work correctly,
    we need to define a `VirtualService` resource. Let’s look at that next:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们所见，我们定义了一个使用 Istio 入口网关（由`istio: ingress`选择器定义）的`Gateway`资源，并监听 HTTP 端口`80`。它允许连接到所有主机，因为我们将其设置为`"*"”。为了使网关正常工作，我们需要定义一个`VirtualService`资源。接下来我们来看看这个资源：'
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `VirtualService` resource listens on all hosts and applies to `blog-app-gateway`
    as specified. It allows `/static`, and `/posts` as a `prefix` match. This means
    all requests with a URI that begins with them would be routed. The `/login`, `/logout`,
    `/register`, `/updateprofile`, and `/` paths have an `exact` match, which means
    that the exact URI is matched and allowed. These are routed to the `frontend`
    service on port `80`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualService`资源监听所有主机，并如指定的那样应用于`blog-app-gateway`。它允许`/static`和`/posts`作为`前缀（prefix）`匹配。这意味着所有以这些路径开头的
    URI 请求都会被路由。`/login`、`/logout`、`/register`、`/updateprofile`和`/`路径具有`精确（exact）`匹配，这意味着只有完全匹配的
    URI 才会被允许。这些请求将被路由到`frontend`服务的端口`80`。'
- en: We must also modify the `frontend` service within the `blog-app.yaml` file to
    change the service type to `ClusterIP`. This will remove the attached load balancer
    from the service, and all requests will be routed via the ingress gateway.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须修改`blog-app.yaml`文件中的`frontend`服务，将服务类型更改为`ClusterIP`。这样会将附加的负载均衡器从服务中移除，所有请求将通过入口网关路由。
- en: 'Now, let’s go ahead and apply these changes using the following commands:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下命令来应用这些更改：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will wait 5 minutes for the sync to work, after which we can go to `http://<Ingress`
    **LoadBalancerExternalIP>** to access our Blog App. You should see the following
    page. This shows that the application is working correctly:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将等待 5 分钟以便同步生效，之后可以访问`http://<Ingress` **LoadBalancerExternalIP>** 来访问我们的博客应用。你应该能看到以下页面。这表明应用程序运行正常：
- en: '![Figure 15.5 – Blog App – home page](img/B19877_15_5.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.5 – 博客应用 – 主页](img/B19877_15_5.jpg)'
- en: Figure 15.5 – Blog App – home page
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5 – 博客应用 – 主页
- en: You can play around with the application by registering, logging in, creating
    a post, and writing a review. Try updating the post and reviews to see whether
    all aspects of the application are working. Now, let’s look at the security aspects
    of our microservices.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过注册、登录、创建帖子和写评论来玩一下这个应用程序。尝试更新帖子和评论，看看应用的各个方面是否正常工作。现在，让我们看看我们微服务的安全性方面。
- en: Securing your microservices using Istio
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Istio 保护你的微服务
- en: Running microservices in production offers numerous advantages, such as independent
    scalability, enhanced agility, reduced scope of change, frequent deployments,
    and reusability. However, they also introduce unique challenges, particularly
    in terms of security.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行微服务具有众多优势，如独立的可扩展性、增强的敏捷性、减少的变更范围、频繁的部署和可重用性。然而，它们也带来了独特的挑战，尤其是在安全方面。
- en: 'In a monolithic architecture, the security focus revolves around safeguarding
    a single application. However, in a typical enterprise-grade microservices application,
    hundreds of microservices may need to interact securely with each other. Kubernetes
    serves as an excellent platform for hosting and orchestrating microservices. Nevertheless,
    the default communication between microservices is insecure, as they typically
    use plaintext HTTP. This may not meet your security requirements. To apply the
    same security principles to microservices as you would to a traditional enterprise
    monolith, you must ensure the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中，安全性关注的是保护单一应用程序。然而，在典型的企业级微服务应用中，可能需要数百个微服务相互安全地互动。Kubernetes 是托管和编排微服务的绝佳平台。然而，微服务之间的默认通信是不安全的，因为它们通常使用明文
    HTTP。这可能无法满足你的安全需求。为了将与传统企业单体应用相同的安全原则应用到微服务中，必须确保以下几点：
- en: '**Encrypted communications**: All interactions between microservices must be
    encrypted to prevent potential man-in-the-middle attacks'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密通信**：微服务之间的所有交互必须加密，以防止潜在的中间人攻击。'
- en: '**Access control**: Access control mechanisms need to be in place to ensure
    that only authorized microservices can interface with each other'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问控制**：需要实施访问控制机制，以确保只有经过授权的微服务才能相互通信。'
- en: '**Telemetry and audit logging**: Capturing, logging, and auditing telemetry
    data is crucial to understanding traffic behavior and proactively detecting intrusions'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遥测和审计日志**：捕获、记录和审计遥测数据对于了解流量行为并主动检测入侵至关重要。'
- en: Istio simplifies addressing these security concerns and provides these essential
    security features out of the box. With Istio, you can enforce strong **identity
    and access management**, mutual **TLS** and **encryption**, **authentication**
    and **authorization**, and comprehensive **audit logging** – all within a unified
    control plane. This means you can establish robust security practices for your
    microservices, promoting the safety and reliability of your applications in a
    dynamic and distributed environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 简化了处理这些安全问题，并提供了开箱即用的核心安全功能。通过 Istio，你可以强制执行强大的**身份和访问管理**、相互**TLS**和**加密**、**认证**和**授权**以及全面的**审计日志**—所有这些都在统一的控制平面内。这意味着你可以为你的微服务建立强大的安全实践，在动态分布的环境中提升应用程序的安全性和可靠性。
- en: In the context of Istio, you should be aware that it automatically injects sidecar
    proxies into your pods and modifies the IP tables of your Kubernetes cluster to
    ensure that all connections occur through these proxies. This setup is designed
    to enforce TLS encryption by default, enhancing the security of your microservices
    without requiring specific configurations. The communication between these envoy
    proxies within the service mesh is automatically secured through TLS.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Istio的背景下，你应该了解它会自动将边车代理注入到你的Pod中，并修改Kubernetes集群的IP表，以确保所有连接都通过这些代理进行。这种设置旨在默认强制启用TLS加密，增强你的微服务安全性，而无需特定配置。这些Envoy代理之间的通信会通过TLS自动加密。
- en: While the default setup offers a foundational level of security and effectively
    prevents man-in-the-middle attacks, it’s advisable to further bolster the security
    of your microservices by applying specific policies. Before delving into the detailed
    features, having a high-level understanding of how security functions in Istio
    is beneficial.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认配置提供了基础的安全性，并有效防止了中间人攻击，但建议通过应用特定策略来进一步增强微服务的安全性。在深入了解详细功能之前，理解Istio中安全性如何运作是有益的。
- en: 'Istio incorporates the following key components for enforcing security:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Istio包含以下关键组件来执行安全策略：
- en: '**Certificate authority** (**CA**): This component manages keys and certificates,
    ensuring secure and authenticated communication within the service mesh.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书颁发机构**（**CA**）：此组件管理密钥和证书，确保在服务网格中进行安全和认证的通信。'
- en: '**Configuration API Server**: The Configuration API Server distributes authentication
    policies, authorization policies, and secure naming information to the envoy proxies.
    These policies define how services can authenticate and authorize each other and
    manage secure communication.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置API服务器**：配置API服务器将身份验证策略、授权策略和安全命名信息分发给Envoy代理。这些策略定义了服务如何进行身份验证和授权，并管理安全通信。'
- en: '**Sidecar proxies**: Sidecar proxies, deployed alongside your microservices,
    are crucial in enforcing security policies. They act as policy enforcement points,
    implementing the policies supplied to them.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边车代理**：边车代理作为微服务的配套部署，对于强制执行安全策略至关重要。它们充当策略执行点，实施提供给它们的策略。'
- en: '**Envoy proxy extensions**: These extensions enable the collection of telemetry
    data and auditing, providing insights into traffic behavior and helping to identify
    and mitigate security issues.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Envoy代理扩展**：这些扩展使得可以收集遥测数据和审计信息，提供流量行为的洞察，并帮助识别和缓解安全问题。'
- en: With these components working in concert, Istio ensures a robust security framework
    for your microservices, which can be further fine-tuned by defining and enforcing
    specific security policies tailored to your application’s needs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些组件协同工作下，Istio为你的微服务提供了一个强大的安全框架，可以通过定义和执行特定的安全策略进一步优化，以满足你应用的需求。
- en: As our application currently runs on HTTP, it would be a great idea to implement
    TLS in our Blog App and expose it over HTTPS. Let’s start by creating a secure
    ingress gateway for this.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序目前运行在HTTP上，因此在博客应用中实现TLS并通过HTTPS暴露是一个很好的主意。让我们从创建一个安全的入口网关开始。
- en: Creating secure ingress gateways
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建安全的入口网关
- en: Secure ingress gateways are nothing but **TLS-enabled ingress gateways**. To
    enable TLS on an ingress gateway, we must provide it with a **private key** and
    a **certificate** chain. We will use a self-signed certificate chain for this
    exercise, but you must use a proper CA certificate chain in production. A CA certificate
    is a digital certificate that’s granted by a reputable CA, such as Verisign or
    Entrust, within a **public key infrastructure** (**PKI**). It plays a pivotal
    role in guaranteeing the security and reliability of digital interactions and
    transactions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的入口网关就是**启用了TLS的入口网关**。要在入口网关上启用TLS，我们必须为其提供**私钥**和**证书链**。我们将在这个练习中使用自签名证书链，但在生产环境中你必须使用正确的CA证书链。CA证书是由可信的CA（如Verisign或Entrust）授予的数字证书，属于**公钥基础设施**（**PKI**）的一部分。它在保障数字交互和交易的安全性与可靠性方面发挥着关键作用。
- en: 'Let’s start by creating a **root certificate** and **private key** to sign
    certificates for our application by using the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建**根证书**和**私钥**开始，通过以下命令签署应用程序的证书：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the generated root certificate, we can now generate the **server certificate**
    and the key using the following commands:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成的根证书，我们现在可以使用以下命令生成 **服务器证书** 和密钥：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next step is to generate a Kubernetes TLS secret within the `istio-ingress`
    namespace for our ingress gateway to read it. However, as we don’t want to store
    the TLS key and certificate in our Git repository, we will use **Google Secrets
    Manager** instead. Therefore, let’s run the following command to do so:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在 `istio-ingress` 命名空间中生成一个 Kubernetes TLS 秘密供我们的入口网关读取。然而，考虑到我们不希望将 TLS
    密钥和证书存储在 Git 仓库中，我们将改用 **Google Secrets Manager**。因此，我们将运行以下命令来实现：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we must create an external secret manifest to fetch the keys and certificates
    from Secrets Manager and generate a TLS secret. The following manifest will help
    us achieve that:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个外部秘密清单，从 Secrets Manager 获取密钥和证书，并生成 TLS 秘密。以下清单将帮助我们实现这一目标：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let’s create a directory within our Environment Repository and copy the
    external secret manifest there. Use the following commands for that:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在环境仓库中创建一个目录，并将外部秘密清单复制到其中。使用以下命令进行操作：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we need to modify the ingress gateway resource to configure TLS. To do
    so, we must modify the `Gateway` resource to the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改入口网关资源以配置 TLS。为此，我们必须将 `Gateway` 资源修改为以下内容：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The gateway configuration is similar to the previous one, but instead of `port
    80`, we’re using `port 443` for `HTTPS`. We also have a `tls` section with a `SIMPLE`
    mode, which means it is a standard TLS connection. We’ve specified `credentialName`,
    pointing to the secret we created using the TLS key and certificate. Since all
    the setup is now ready, let’s commit and push the code using the following commands:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 网关配置与之前类似，但我们使用 `port 443` 来替代 `port 80`，用于 `HTTPS`。我们还有一个 `tls` 部分，并设置为 `SIMPLE`
    模式，这意味着它是一个标准的 TLS 连接。我们已经指定了 `credentialName`，指向我们使用 TLS 密钥和证书创建的秘密。由于所有设置已就绪，让我们使用以下命令提交并推送代码：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Wait for `blog-app` to sync. Once we’ve done this, we can access our application
    at `https:` **//<IngressLoadBalancerExternalIP>**. With that, the connection coming
    into our application has been encrypted.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 `blog-app` 同步。一旦完成，我们可以通过 `https:` **//<IngressLoadBalancerExternalIP>**
    访问我们的应用程序。这样，进入应用程序的连接就已经加密。
- en: Though we’ve secured connection coming into our mesh, securing all internal
    service interactions with services using TLS within your service mesh would be
    good as an additional security layer. We’ll implement that next.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经保护了进入服务网格的连接，但作为额外的安全层，保护所有内部服务之间的 TLS 通信也是非常重要的。接下来，我们将实施这一措施。
- en: Enforcing TLS within your service mesh
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务网格中强制启用 TLS
- en: As we know by now, by default, Istio provides TLS encryption for communication
    between workloads that have sidecar proxies injected. However, it’s important
    to note that this default setting operates in compatibility mode. In this mode,
    traffic between two services with sidecar proxies injected is encrypted. However,
    workloads without sidecar proxies can still communicate with backend microservices
    over plaintext HTTP. This design choice is made to simplify the adoption of Istio,
    as teams newly introducing Istio don’t need to immediately address the issue of
    making all source traffic TLS-enabled.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，默认情况下，Istio 为注入了 sidecar 代理的工作负载之间的通信提供 TLS 加密。然而，需要注意的是，这个默认设置处于兼容模式。在这种模式下，两个具有
    sidecar 代理的服务之间的流量是加密的。但是，没有 sidecar 代理的工作负载仍然可以通过明文 HTTP 与后端微服务通信。这个设计选择是为了简化
    Istio 的采用，因为新引入 Istio 的团队不需要立即解决将所有源流量启用 TLS 的问题。
- en: 'Let’s create and get a shell to a pod in the `default` namespace. The backend
    traffic will be plaintext because the namespace does not have automatic sidecar
    injection. We will then `curl` the `frontend` microservice from there and see
    whether we get a response. Run the following command to do so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建并进入 `default` 命名空间中的一个 Pod 的 shell。由于该命名空间没有自动的 sidecar 注入，后端流量将是明文的。然后，我们将在那里
    `curl` `frontend` 微服务，看看是否能收到响应。运行以下命令进行操作：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, we get an `HTTP 200` response back.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们得到了 `HTTP 200` 响应。
- en: This approach balances security and compatibility, allowing a gradual transition
    to a fully encrypted communication model. Over time, as more services have sidecar
    proxies injected, the overall security posture of the microservices application
    improves. However, as we are starting fresh, enforcing strict TLS for our Blog
    App would make sense. So, let’s do that.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在安全性和兼容性之间取得了平衡，允许逐步过渡到完全加密的通信模型。随着时间的推移，随着更多服务注入了边车代理，微服务应用程序的整体安全态势将得到改善。然而，由于我们是从头开始，强制执行严格的
    TLS 来保护我们的 Blog 应用程序是有意义的。所以，让我们这样做。
- en: 'To enable strict TLS on a workload, namespace, or the entire cluster, Istio
    provides peer authentication policies using the `PeerAuthentication` resource.
    As we only need to implement strict TLS on the Blog App, enabling it at the namespace
    level would make sense. To do that, we will use the following `PeerAuthentication`
    resource:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要在工作负载、命名空间或整个集群启用严格的 TLS，Istio 提供了使用 `PeerAuthentication` 资源的对等身份验证策略。由于我们只需要在
    Blog 应用程序上实现严格的 TLS，因此在命名空间级别启用它是有意义的。为此，我们将使用以下 `PeerAuthentication` 资源：
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s apply this using the following commands:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令应用此配置：
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Argo CD should pick up the new configuration and apply the strict TLS policy
    as soon as we push the changes. Wait for the Argo CD sync to be in a clean state,
    and run the following commands to check whether strict TLS is working:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推送更改，Argo CD 应该会接收新配置并应用严格的 TLS 策略。等待 Argo CD 同步处于干净状态，并运行以下命令检查严格的 TLS
    是否工作：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we can see, the request has now been rejected as it is a plaintext request,
    and the backend will only allow TLS. This shows that strict TLS is working fine.
    Now, let’s move on and secure our services even better.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，请求已被拒绝，因为它是明文请求，后台将只允许 TLS。这表明严格的 TLS 工作正常。现在，让我们继续并进一步增强服务的安全性。
- en: 'From our design, we know how services interact with each other:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的设计中，我们知道服务如何相互交互：
- en: The `frontend` microservice can only connect to the `posts`, `reviews`, and
    `users` microservices
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frontend` 微服务只能连接到 `posts`、`reviews` 和 `users` 微服务。'
- en: Only the `reviews` microservice can connect to the `ratings` microservice.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有 `reviews` 微服务可以连接到 `ratings` 微服务。
- en: Only the `posts`, `reviews`, `users`, and `ratings` microservices can connect
    to the `mongodb` database
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有 `posts`、`reviews`、`users` 和 `ratings` 微服务可以连接到 `mongodb` 数据库
- en: Therefore, we can define these interactions and only allow these connections
    explicitly. Therefore, the `frontend` microservice will not be able to connect
    with the `mongodb` database directly, even if it tries to.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以定义这些交互，并仅显式允许这些连接。因此，`frontend` 微服务将无法直接连接到 `mongodb` 数据库，即使它尝试这样做。
- en: Istio provides the `AuthorizationPolicy` resource to manage this. Let’s implement
    the preceding scenario using that.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 提供了 `AuthorizationPolicy` 资源来管理这个问题。让我们使用它来实现上述场景。
- en: 'Let’s start with the `posts` microservice:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `posts` 微服务开始：
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `AuthorizationPolicy` has multiple sections. It starts with `name` and
    `namespace`, which are `posts` and `blog-app`, respectively. The `spec` section
    contains `selector`, where we specify that we need to apply this policy to all
    pods with the `app: posts` label. We use an `ALLOW` action for this. Note that
    Istio has an implicit `deny-all` policy for all pods that match the selector,
    and any `ALLOW` rules will be applied on top of that. Any traffic that does not
    match the `ALLOW` rules will be denied by default. We have rules to define what
    traffic to allow; here, we’re using the `from` > `source` > `principals` and setting
    the `frontend` service account on this. So, in summary, this rule will apply to
    the `posts` microservice and only allow traffic from the `frontend` microservice.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`AuthorizationPolicy` 有多个部分。它从 `name` 和 `namespace` 开始，分别为 `posts` 和 `blog-app`。`spec`
    部分包含 `selector`，在这里我们指定需要将此策略应用于所有具有 `app: posts` 标签的 pod。我们为此使用 `ALLOW` 动作。请注意，Istio
    对所有匹配选择器的 pod 有一个隐式的 `deny-all` 策略，任何 `ALLOW` 规则都将在此基础上应用。任何不匹配 `ALLOW` 规则的流量将默认被拒绝。我们有规则来定义允许哪些流量；在这里，我们使用
    `from` > `source` > `principals`，并将 `frontend` 服务帐户设置在此。因此，总结起来，这条规则将应用于 `posts`
    微服务，并仅允许来自 `frontend` 微服务的流量。'
- en: 'Similarly, we will apply the same policy to the `reviews` microservice, as
    follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们将对 `reviews` 微服务应用相同的策略，如下所示：
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `users` microservice also only needs to accept traffic from the `frontend`
    microservice:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`users` 微服务也只需要接受来自 `frontend` 微服务的流量：'
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `ratings` microservice should accept traffic only from the `reviews` microservice,
    so we will make a slight change to the principals, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`ratings` 微服务应该仅接受来自 `reviews` 微服务的流量，因此我们将对主体部分进行一些小的修改，如下所示：'
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, the `mongodb` service needs a connection from all microservices apart
    from `frontend`, so we must specify multiple entries in the principal section:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`mongodb` 服务需要来自所有微服务的连接，除了 `frontend`，因此我们必须在主体部分指定多个条目：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since we’ve used service accounts to understand where the requests are coming
    from, we must also create and assign service accounts to respective services.
    So, we will modify the `blog-app.yaml` file and add service accounts for each
    service, something like the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了服务帐户来了解请求的来源，因此我们还必须为相应的服务创建并分配服务帐户。所以，我们将修改 `blog-app.yaml` 文件，并为每个服务添加服务帐户，类似于以下内容：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'I’ve already replicated the same in the new `blog-app.yaml` file. Let’s commit
    the changes and push them to GitHub so that we can apply them to our cluster:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在新的 `blog-app.yaml` 文件中复制了相同的设置。让我们提交更改并推送到 GitHub，以便我们可以将其应用到集群中：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we must wait for the sync to complete and then verify the setup. First,
    we’ll get a shell to the `frontend` pod and try to use `wget` to connect with
    the backend microservices. We will try to connect with each microservice and see
    what we get. If we get `HTTP 200` or `404`, this means the backend is allowing
    connections, while if we get `HTTP 403` or `Error`, this signifies the backend
    is blocking connections. Run the following commands to do so:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须等待同步完成，然后验证设置。首先，我们将获取 `frontend` pod 的 shell，并尝试使用 `wget` 连接后端微服务。我们将尝试与每个微服务连接，看看结果。如果返回
    `HTTP 200` 或 `404`，则表示后端允许连接；如果返回 `HTTP 403` 或 `Error`，则表示后端正在阻止连接。运行以下命令进行操作：
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we can see, we get an `HTTP 404` response from the `posts`, `reviews`, and
    `users` microservices. The `ratings` microservice returns a `403 Forbidden` response,
    and the `mongodb` service reports that the resource is unavailable. This means
    that our setup is working correctly.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`posts`、`reviews` 和 `users` 微服务返回了 `HTTP 404` 响应。`ratings` 微服务返回了 `403
    Forbidden` 响应，而 `mongodb` 服务报告资源不可用。这意味着我们的设置工作正常。
- en: 'Let’s try the same with the `posts` microservice:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来试试 `posts` 微服务：
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we can see, the `posts` microservice can communicate successfully with `mongodb`,
    but the rest of the microservices return `403 Forbidden`. This is what we were
    expecting. Now, let’s do the same with the `reviews` microservice:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`posts` 微服务可以成功与 `mongodb` 通信，但其他微服务返回 `403 Forbidden`。这正是我们预期的结果。现在，我们来试试
    `reviews` 微服务：
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we can see, the `reviews` microservice can successfully connect with the
    `ratings` microservice and `mongodb`, while getting a `403` response from other
    microservices. This is what we expected. Now, let’s check the `ratings` microservice:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`reviews` 微服务能够成功地与 `ratings` 微服务和 `mongodb` 连接，同时从其他微服务获得 `403` 响应。这正是我们预期的结果。现在，我们来检查
    `ratings` 微服务：
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As we can see, the `ratings` microservice can only connect successfully with
    the `mongdb` database and gets a `403` response for other services.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`ratings` 微服务只能成功连接到 `mongodb` 数据库，并且对其他服务返回 `403` 响应。
- en: Now that we’ve tested all the services, the setup is working fine. We’ve secured
    our microservices to a great extent! Now, let’s look at another aspect of managing
    microservices with Istio – traffic management.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经测试了所有服务，设置正常工作。我们的微服务已经得到了极大程度的安全保护！接下来，让我们看看使用 Istio 管理微服务的另一个方面——流量管理。
- en: Managing traffic with Istio
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Istio 管理流量
- en: Istio offers robust traffic management capabilities that form a core part of
    its functionality. When leveraging Istio for microservice management within your
    Kubernetes environment, you gain precise control over how these services communicate
    with each other. This empowers you to define the traffic path within your service
    mesh meticulously.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 提供了强大的流量管理功能，构成了其核心功能的一部分。当您在 Kubernetes 环境中使用 Istio 进行微服务管理时，您可以精确控制这些服务之间的通信方式。这使您能够在服务网格中精确地定义流量路径。
- en: 'Some of the traffic management features at your disposal are as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以使用的一些流量管理功能：
- en: Request routing
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求路由
- en: Fault injection
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障注入
- en: Traffic shifting
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流量切换
- en: TCP traffic shifting
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP 流量切换
- en: Request timeouts
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求超时
- en: Circuit breaking
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路断路
- en: Mirroring
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像
- en: The previous section employed an ingress gateway to enable traffic entry into
    our mesh and used a virtual service to distribute traffic to the services. With
    virtual services, the traffic distribution happens in a round-robin fashion by
    default. However, we can change that using destination rules. These rules provide
    us with an intricate level of control over the behavior of our mesh, allowing
    for a more granular management of traffic within the Istio ecosystem.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节使用了入口网关来启用流量进入我们的服务网格，并使用虚拟服务将流量分配到各个服务。在虚拟服务的情况下，流量分配默认是轮询方式。然而，我们可以通过目的地规则来更改这一点。这些规则为我们提供了对服务网格行为的精细控制，允许我们在
    Istio 生态系统中更细粒度地管理流量。
- en: 'Before we delve into that, we need to update our Blog App so that it includes
    a new version of the `ratings` service deployed as `ratings-v2`, which will return
    black stars instead of orange stars. I’ve already updated the manifest for that
    in the repository. Therefore, we just need to copy that to the `mdo-environments`
    repository, commit it, and push it remotely using the following commands:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讨论之前，我们需要更新我们的博客应用程序，使其包含一个作为 `ratings-v2` 部署的新版本的 `ratings` 服务，该服务将返回黑色星星而不是橙色星星。我已经在代码库中更新了该清单。因此，我们只需要将其复制到
    `mdo-environments` 仓库，提交并通过以下命令推送到远程：
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Wait for the application to sync. After this, we need to do a few things:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 等待应用程序同步。完成后，我们需要做以下几件事：
- en: Go to the Blog App home page > **Sign In** > **Not a User? Create an account**
    and create a new account.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到博客应用主页 > **登录** > **还不是用户？创建帐户**，然后创建一个新帐户。
- en: Click on the **Actions** tab > **Add a Post**, add a new post with a title and
    content of your choice, and click **Submit**.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **操作** 标签 > **添加帖子**，添加一个新帖子，选择标题和内容，然后点击**提交**。
- en: Use the **Add a Review** text field to add a review, provide a rating, and click
    **Submit**.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**添加评论**文本框添加评论，提供评分，并点击**提交**。
- en: Click on **Posts** again and access the post that we had created.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击**帖子**并访问我们创建的帖子。
- en: 'Now, keep refreshing the page. We will see that we get orange stars half the
    time and black stars for the rest. Traffic is splitting equally across `v1` and
    `v2` (that is, the orange and black stars):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续刷新页面。我们会看到，流量一半时间会得到橙色星星，另一半时间则是黑色星星。流量在 `v1` 和 `v2` 之间平分（即橙色和黑色星星）：
- en: '![Figure 15.6 – Round robin routing](img/B19877_15_6.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.6 – 循环路由](img/B19877_15_6.jpg)'
- en: Figure 15.6 – Round robin routing
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.6 – 循环路由
- en: This occurs due to the absence of destination rules, which leaves Istio unaware
    of the distinctions between `v1` and `v2`. Let’s define destination rules for
    our microservices to rectify this, clearly informing Istio of these versions.
    In our case, we have one version for each microservice, except for the `ratings`
    microservice, so we’ll define the following destination rules accordingly.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以发生这种情况，是因为缺少目的地规则，导致 Istio 无法区分 `v1` 和 `v2`。让我们为我们的微服务定义目的地规则，以此纠正问题，清楚地告诉
    Istio 这些版本的区别。在我们的例子中，每个微服务有一个版本，除了 `ratings` 微服务，因此我们将相应地定义以下目的地规则。
- en: 'Let’s start by defining the destination rule of the `frontend` microservice:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义 `frontend` 微服务的目的地规则开始：
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The provided YAML manifest introduces a `DestinationRule` resource named `frontend`
    within the `blog-app` namespace. This resource is associated with the host named
    `frontend`. Subsequently, we define subsets labeled as `v1`, targeting pods with
    the `version: v1` label. Consequently, configuring our virtual service to direct
    traffic to the `v1` destination will route requests to pods bearing the `version:`
    `v1` label.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '提供的 YAML 清单在 `blog-app` 命名空间内引入了一个名为 `frontend` 的 `DestinationRule` 资源。这个资源与名为
    `frontend` 的主机相关联。随后，我们定义了标记为 `v1` 的子集，目标是带有 `version: v1` 标签的 pods。因此，配置我们的虚拟服务将流量定向到
    `v1` 目的地时，将请求路由到带有 `version:` `v1` 标签的 pods。'
- en: 'This same configuration approach can be replicated for the `posts`, `users`,
    and `reviews` microservices. However, the `ratings` microservice requires a slightly
    different configuration due to the deployment of two versions, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的配置方式可以复制到 `posts`、`users` 和 `reviews` 微服务。但是，由于部署了两个版本，`ratings` 微服务需要稍微不同的配置，如下所示：
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The YAML manifest for the `ratings` microservice closely resembles that of
    the other microservices, with one notable distinction: it features a second subset
    labeled as `v2`, corresponding to pods bearing the `version:` `v2` label.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`ratings` 微服务的 YAML 清单与其他微服务非常相似，唯一显著的区别是：它包含一个标记为 `v2` 的第二子集，对应着带有 `version:`
    `v2` 标签的 pods。'
- en: 'Consequently, requests routed to the `v1` destination target all pods with
    the `version: v1` label, while requests routed to the `v2` destination are directed
    to pods labeled `version: v2`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，路由到 `v1` 目标的请求会定向到所有具有 `version: v1` 标签的 Pod，而路由到 `v2` 目标的请求则会定向到标记为 `version:
    v2` 的 Pod。'
- en: 'To illustrate this in a practical context, we will proceed to define virtual
    services for each microservice. Our starting point will be defining the virtual
    service for the `frontend` microservice, as illustrated in the following manifest:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在实际应用中说明这一点，我们将继续为每个微服务定义虚拟服务。我们的起点是定义 `frontend` 微服务的虚拟服务，如以下清单所示：
- en: '[PRE52]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The provided YAML manifest outlines a `VirtualService` resource named `frontend`
    within the `blog-app` namespace. This resource configures the host `frontend`
    with an HTTP route destination, directing all traffic to the `frontend` host and
    specifying the `v1` subset. Consequently, all requests targeting the `frontend`
    host will be routed to the `v1` destination that we previously defined.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的 YAML 清单描述了一个名为 `frontend` 的 `VirtualService` 资源，位于 `blog-app` 命名空间内。该资源将主机
    `frontend` 配置为具有 HTTP 路由目标，所有流量都被导向 `frontend` 主机，并指定了 `v1` 子集。因此，所有面向 `frontend`
    主机的请求都会路由到我们之前定义的 `v1` 目标。
- en: We will replicate this configuration approach for the `posts`, `reviews`, and
    `users` microservices, creating corresponding `VirtualService` resources. In the
    case of the `ratings` microservice, the decision is made to route all traffic
    to the `v1` (orange stars) version. Therefore, we apply a similar `VirtualService`
    resource for the `ratings` microservice as well.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 `posts`、`reviews` 和 `users` 微服务复制这种配置方式，创建相应的 `VirtualService` 资源。对于 `ratings`
    微服务，决定将所有流量路由到 `v1`（橙色星标）版本。因此，我们也为 `ratings` 微服务应用类似的 `VirtualService` 资源。
- en: 'Now, let’s copy the manifests to the `mdo-environments` repository and commit
    and push the code to the remote repository using the following commands:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将清单复制到 `mdo-environments` 仓库，并使用以下命令提交并推送代码到远程仓库：
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Wait for Argo CD to sync the changes. Now, all requests will route to `v1`.
    Therefore, you will only see orange stars in the reviews, as shown in the following
    screenshot:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 Argo CD 同步更改。现在，所有请求都将路由到 `v1`。因此，您将只看到评论中的橙色星标，如下图所示：
- en: '![Figure 15.7 – Route to v1](img/B19877_15_7.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.7 – 路由到 v1](img/B19877_15_7.jpg)'
- en: Figure 15.7 – Route to v1
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.7 – 路由到 v1
- en: Now, let’s try to roll out `v2` using a canary rollout approach.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过金丝雀发布方法发布 `v2`。
- en: Traffic shifting and canary rollouts
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流量切换和金丝雀发布
- en: Consider a scenario where you’ve developed a new version of your microservice
    and are eager to introduce it to your user base. However, you’re understandably
    cautious about the potential impact on the entire service. In such cases, you
    may opt for a deployment strategy known as **canary rollouts**, also known as
    a **Blue/Green deployment**.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经开发了一个新的微服务版本，并迫切希望将其推向用户群。然而，你显然会对其对整个服务的潜在影响感到谨慎。在这种情况下，你可以选择一种名为**金丝雀发布**（也称为**蓝绿部署**）的部署策略。
- en: 'The essence of a canary rollout lies in its incremental approach. Instead of
    an abrupt transition, you methodically shift traffic from the previous version
    (referred to as **Blue**) to the new version (**Green**). This gradual migration
    allows you to thoroughly test the functionality and reliability of the new release
    with a limited subset of users before implementing it across the entire user base.
    This approach minimizes the risks associated with deploying new features or updates
    and ensures a more controlled and secure release process. The following figure
    illustrates this process beautifully:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 金丝雀发布的本质在于其渐进式方法。与其进行突兀的版本过渡，不如通过有条不紊地将流量从先前版本（称为**蓝色**）转移到新版本（**绿色**）。这种渐进的迁移方式允许你在将其应用到整个用户群体之前，先在有限的用户子集上彻底测试新版本的功能性和可靠性。这种方法能够最大程度地减少发布新特性或更新时的风险，并确保发布过程更加可控和安全。下图形象地展示了这一过程：
- en: '![Figure 15.8 – Canary rollouts](img/B19877_15_8.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.8 – 金丝雀发布](img/B19877_15_8.jpg)'
- en: Figure 15.8 – Canary rollouts
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.8 – 金丝雀发布
- en: 'Here’s how a *canary rollout* strategy works:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是*金丝雀发布*策略的工作原理：
- en: '**Initial release**: The existing version (referred to as the *baseline* or
    *current version*) continues to serve the majority of users.'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**初始发布**：现有版本（称为*基准*或*当前版本*）继续服务大多数用户。'
- en: '**Early access**: A small group of users or systems, typically selected as
    a representative sample, is identified as the *canary group*. They receive the
    new version.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**早期访问**：一个小的用户或系统组，通常选定为具有代表性的样本，被认定为*金丝雀组*。他们将接收到新版本。'
- en: '**Monitoring and evaluation**: The software’s performance and behavior in the
    canary group are closely monitored. Metrics, logs, and user feedback are collected
    to identify issues or anomalies.'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**监控与评估**：金丝雀组中软件的性能和行为会被密切监控。通过收集度量、日志和用户反馈，及时发现问题或异常。'
- en: '**Gradual expansion**: If the new version proves stable and performs as expected
    in the canary group, its exposure is incrementally expanded to a broader user
    base. This expansion can occur in stages, with a small percentage of users being
    “promoted” to the new version at each stage.'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逐步扩展**：如果新版本在金丝雀组中表现稳定且符合预期，其曝光度将逐步扩展到更广泛的用户群体。此扩展可以分阶段进行，每个阶段将“晋升”一定百分比的用户使用新版本。'
- en: '**Continuous monitoring**: Throughout the rollout, continuous monitoring and
    analysis are critical to identify and address any emerging issues promptly. If
    problems are detected, the rollout can be halted or reversed to protect the majority
    of users.'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持续监控**：在发布过程中，持续的监控和分析至关重要，以便及时识别并解决任何新出现的问题。如果发现问题，可以暂停或回滚发布，以保护大多数用户。'
- en: '**Full deployment**: Once the new version has been successfully validated through
    the canary rollout stages, it is eventually made available to the entire user
    base.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**完全部署**：一旦新版本通过金丝雀发布阶段成功验证，它将最终对所有用户开放。'
- en: 'So, let’s roll out the `ratings-v2` service to `20%` of our users. For that,
    we’ll use the following `VirtualService` resource:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们将`ratings-v2`服务推送到`20%`的用户中。为此，我们将使用以下`VirtualService`资源：
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we can see, we’ve modified the `ratings` virtual service to introduce a second
    destination pointing to the `v2` subset. A noteworthy addition in this configuration
    is the introduction of the `weight` attribute. For the `v1` destination, we have
    assigned a weight of `80`, while the `v2` destination carries a weight of `20`.
    This means that `20%` of the traffic will be directed to the `v2` version of the
    `ratings` microservice, providing a controlled and adjustable distribution of
    traffic between the two versions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们已修改了`ratings`虚拟服务，引入了指向`v2`子集的第二个目标。在此配置中一个值得注意的新增项是引入了`weight`属性。对于`v1`目标，我们分配了`80`的权重，而`v2`目标的权重为`20`。这意味着`20%`的流量将被引导到`ratings`微服务的`v2`版本，从而提供了两版本之间的流量控制和可调分配。
- en: 'Let’s copy the manifest and then commit and push the changes to the remote
    repository using the following commands:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制清单，然后使用以下命令将更改提交并推送到远程仓库：
- en: '[PRE55]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Following the completion of the Argo CD sync, if you refresh the page 10 times,
    you’ll observe that black stars appear twice out of those 10 times. This is a
    prime example of a canary rollout in action. You can continue monitoring the application
    and gradually adjust the weights to shift traffic toward `v2`. Canary rollouts
    effectively mitigate risks during production rollouts, providing a method to address
    the fear of the unknown, especially when implementing significant changes.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 完成 Argo CD 同步后，如果你刷新页面 10 次，你会观察到在其中的 10 次中，黑色星星会出现两次。这是金丝雀发布实践的一个典型例子。你可以继续监控应用程序，并逐步调整权重，将流量转向`v2`。金丝雀发布有效地降低了生产发布过程中的风险，提供了一种应对未知风险的方法，尤其是在实施重大变更时。
- en: However, another approach exists to test your code in a production environment
    that involves using live traffic without exposing your application to end users.
    This method is known as traffic mirroring. We’ll delve into it in the following
    discussion.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一种方法可以在生产环境中测试你的代码，这种方法涉及使用实时流量，但不会将应用程序暴露给最终用户。这种方法称为流量镜像。我们将在接下来的讨论中深入探讨它。
- en: Traffic mirroring
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流量镜像
- en: '**Traffic mirroring**, also called shadowing, is a concept that has recently
    gained traction. It is a powerful approach that allows you to assess your releases
    in a production environment without posing any risk to your end users.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**流量镜像**，也称为影像，是一种最近受到关注的概念。它是一种强大的方法，允许你在生产环境中评估发布，而不对最终用户造成任何风险。'
- en: Traditionally, many enterprises maintained a staging environment that closely
    mimicked the production setup. The Ops team deployed new releases to the staging
    environment in this setup while testers generated synthetic traffic to simulate
    real-world usage. This approach provided a means for teams to evaluate how the
    code would perform in the production environment, assessing its functional and
    non-functional aspects before promoting it to production. The staging environment
    served as the ground for performance, volumetric, and operational acceptance testing.
    While this approach had its merits, it was not without its challenges. Maintaining
    static test environments, which involved substantial costs and resources, was
    one of them. Creating and sustaining a replica of the production environment required
    a team of engineers, leading to high overhead.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，许多企业维持了一个与生产环境高度相似的暂存环境。在这种设置中，运维团队将新版本发布到暂存环境，而测试人员生成合成流量来模拟真实世界的使用。这种方法为团队提供了一种评估代码在生产环境中表现的方式，评估其功能性和非功能性方面，在推广到生产环境之前。暂存环境充当性能、体量和操作验收测试的基础。虽然这种方法有其优点，但也并非没有挑战。维持静态测试环境是其中之一，这需要大量的成本和资源。创建和维护一个生产环境的副本需要一支工程师团队，从而导致高额的开销。
- en: Moreover, synthetic traffic often deviated from real live traffic since the
    former relied on historical data, while the latter reflected current user interactions.
    This discrepancy occasionally led to overlooked scenarios.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，合成流量通常偏离真实的实时流量，因为前者依赖于历史数据，而后者反映的是当前用户的交互。这种差异偶尔会导致某些场景被忽视。
- en: On the other hand, traffic mirroring offers a solution that similarly enables
    operational acceptance testing while going a step further. It allows you to conduct
    this testing using live, real-time traffic without any impact on end users.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，流量镜像提供了一种解决方案，它同样使得操作验收测试成为可能，同时更进一步。它允许你使用实时流量进行测试，而不会对终端用户产生任何影响。
- en: 'Here’s how traffic mirroring operates:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是流量镜像的工作原理：
- en: Deploy a new version of the application and activate traffic mirroring.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署应用程序的新版本并激活流量镜像。
- en: The old version continues to respond to requests as usual but concurrently sends
    an asynchronous copy of the traffic to the new version.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旧版本继续照常响应请求，同时将流量的异步副本发送到新版本。
- en: The new version processes the mirrored traffic but refrains from responding
    to end users.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新版本处理镜像流量，但不会对终端用户做出响应。
- en: The ops team monitors the behavior of the new version and reports any issues
    to the development team.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运维团队监控新版本的行为，并将任何问题报告给开发团队。
- en: 'This process is depicted in the following figure:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程如以下图所示：
- en: '![Figure 15.9 – Traffic mirroring](img/B19877_15_9.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.9 – 流量镜像](img/B19877_15_9.jpg)'
- en: Figure 15.9 – Traffic mirroring
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.9 – 流量镜像
- en: Traffic mirroring revolutionizes the testing process by enabling teams to uncover
    issues that might remain hidden in a traditional staging environment. Additionally,
    you can utilize monitoring tools such as Prometheus and Grafana to record and
    monitor the outcomes of your testing efforts, enhancing the overall quality and
    reliability of your releases.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 流量镜像通过使团队能够发现传统暂存环境中可能隐藏的问题，彻底改变了测试过程。此外，你可以利用诸如 Prometheus 和 Grafana 等监控工具来记录和监控测试结果，提升发布的整体质量和可靠性。
- en: 'Now, without further ado, let’s configure traffic mirroring for our `ratings`
    service. Traffic mirroring is managed through the `VirtualService` resource, so
    let’s modify the `ratings` virtual service to the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，废话不多说，让我们为我们的`ratings`服务配置流量镜像。流量镜像通过`VirtualService`资源进行管理，因此让我们将`ratings`虚拟服务修改为以下内容：
- en: '[PRE56]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this configuration, we set up a single `destination` targeting `v1` with
    a `weight` value of `100`. Additionally, we defined a `mirror` section that directs
    traffic to `ratings:v2` with a `mirror_percent` value of 100\. This signifies
    that all traffic initially routed to `ratings:v1` is mirrored and simultaneously
    sent to `v2`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，我们设置了一个单一的`destination`，目标为`v1`，`weight`值为`100`。此外，我们定义了一个`mirror`部分，将流量引导到`ratings:v2`，并设置`mirror_percent`为100。这意味着，所有最初路由到`ratings:v1`的流量都被镜像并同时发送到`v2`。
- en: 'Let’s commit the changes and push them to the remote repository using the following
    commands:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令提交更改并将其推送到远程仓库：
- en: '[PRE57]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Following the completion of the Argo CD synchronization process, we’ll proceed
    to refresh the page five times. Subsequently, we can inspect the logs of the `ratings:v1`
    service using the following command:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成Argo CD同步过程后，我们将刷新页面五次。随后，我们可以使用以下命令检查`ratings:v1`服务的日志：
- en: '[PRE58]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With traffic mirroring active, it’s expected that the same set of logs observed
    in the `ratings:v1` service will also be mirrored in the `ratings:v2` service.
    To confirm this, we can list the logs for the `ratings:v2` service using the following
    command:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用流量镜像后，预计在`ratings:v1`服务中观察到的相同日志集也会被镜像到`ratings:v2`服务中。为了确认这一点，我们可以使用以下命令列出`ratings:v2`服务的日志：
- en: '[PRE59]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Indeed, the logs and timestamps match precisely, providing clear evidence of
    concurrent log entries in `ratings:v1` and `ratings:v2`. This observation effectively
    demonstrates the mirroring functionality in operation, showcasing how traffic
    is duplicated for real-time monitoring and analysis in both versions.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，日志和时间戳完全匹配，提供了`ratings:v1`和`ratings:v2`中并发日志条目的清晰证据。这一观察有效地展示了镜像功能的运作，展示了如何在两个版本中复制流量以进行实时监控和分析。
- en: Traffic mirroring is a highly effective method for identifying issues that often
    elude detection within traditional infrastructure setups. It is a potent approach
    for conducting operational acceptance testing of your software releases. This
    practice simplifies testing and safeguards against potential customer incidents
    and operational challenges.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 流量镜像是一种非常有效的方法，用于识别传统基础设施设置中常常难以发现的问题。它是一种强大的方法，用于对软件版本进行操作验收测试。这种做法简化了测试并防范了潜在的客户事件和操作挑战。
- en: 'There are other aspects of traffic management that Istio provides, but covering
    all of them is beyond the scope of this chapter. Please feel free to explore other
    aspects of it by visiting the Istio documentation: [https://istio.io/latest/docs/tasks/traffic-management/](https://istio.io/latest/docs/tasks/traffic-management/).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Istio提供了其他流量管理方面的功能，但本章无法涵盖所有内容。请随时访问Istio文档，探索它的其他功能：[https://istio.io/latest/docs/tasks/traffic-management/](https://istio.io/latest/docs/tasks/traffic-management/)。
- en: As we already know, Istio leverages envoy proxies as sidecar components alongside
    your microservice containers. Given that these proxies play a central role in
    directing and managing the traffic within your service mesh, they also collect
    valuable telemetry data.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Istio利用envoy代理作为边车组件，配合你的微服务容器。鉴于这些代理在流量的引导和管理中发挥着核心作用，它们还会收集宝贵的遥测数据。
- en: This telemetry data is subsequently transmitted to Prometheus, a monitoring
    and alerting tool, where it can be stored and effectively visualized. Tools such
    as Grafana are often employed in conjunction with Prometheus to provide insightful
    and accessible visualizations of this telemetry data, empowering you to monitor
    and manage your service mesh effectively. Therefore, we’ll go ahead and explore
    the observability portion of Istio in the next section.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这些遥测数据随后被传输到Prometheus，一个监控和告警工具，在那里它可以被存储并有效地可视化。Grafana等工具通常与Prometheus一起使用，为这些遥测数据提供深刻且易于访问的可视化，帮助你有效地监控和管理服务网格。因此，我们将在下一节中进一步探讨Istio的可观察性部分。
- en: Observing traffic and alerting with Istio
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Istio观察流量并发出警报
- en: Istio provides several tools to visualize traffic through our mesh through Istio
    add-ons. While **Prometheus** is the central telemetry data collection, storage,
    and query layer, **Grafana** and **Kiali** provide us with interactive graphical
    tools to interact with that data.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Istio提供了多种工具，通过Istio附加组件来可视化流经我们网格的流量。**Prometheus**是遥测数据收集、存储和查询的核心层，**Grafana**和**Kiali**为我们提供了互动的图形工具，帮助我们与这些数据进行交互。
- en: 'Let’s start this section by installing the observability add-ons using the
    following commands:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下命令安装可观察性附加组件来开始这一节：
- en: '[PRE60]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As soon as we push the code, Argo CD should create a new `istio-system` namespace
    and install the add-ons. Once they have been installed, we can start by accessing
    the Kiali dashboard.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推送代码，Argo CD应该会创建一个新的`istio-system`命名空间并安装附加组件。安装完成后，我们可以从访问Kiali仪表盘开始。
- en: Accessing the Kiali dashboard
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问Kiali仪表盘
- en: '**Kiali** is a powerful observability and visualization tool for microservices
    and service mesh management. It offers real-time insights into the behavior of
    your service mesh, helping you monitor and troubleshoot issues efficiently.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kiali** 是一个强大的可观察性和可视化工具，专门用于微服务和服务网格管理。它提供了有关你的服务网格行为的实时洞察，帮助你高效地监控和故障排除问题。'
- en: 'As the Kiali service is deployed on a cluster IP and hence not exposed externally,
    let’s do a port forward to access the Kiali dashboard using the following command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Kiali服务部署在集群IP上，因此不对外暴露，我们需要做一个端口转发，以便使用以下命令访问Kiali仪表板：
- en: '[PRE61]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once the port forward session has started, click on the web preview icon of
    Google Cloud Shell, choose **Change port to 20001**, and click **preview**. You
    will see the following dashboard. This dashboard provides valuable insights into
    the applications running across the mesh:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦端口转发会话开始，点击Google Cloud Shell的网页预览图标，选择**更改端口为20001**，然后点击**预览**。你将看到以下仪表板。该仪表板为我们提供了有关在服务网格中运行的应用程序的宝贵见解：
- en: '![Figure 15.10 – Kiali dashboard](img/B19877_15_10.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.10 – Kiali 仪表板](img/B19877_15_10.jpg)'
- en: Figure 15.10 – Kiali dashboard
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.10 – Kiali 仪表板
- en: 'To visualize service interactions, we can switch to the graph view by clicking
    on the `blog-app` namespace. We will see the following dashboard, which provides
    an accurate view of how traffic flows, the percentage of successful traffic, and
    other metrics:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化服务之间的交互，我们可以通过点击`blog-app`命名空间切换到图形视图。我们将看到以下仪表板，该仪表板提供了流量流动情况、成功流量百分比以及其他指标的准确视图：
- en: '![Figure 15.11 – Kiali service interaction graph](img/B19877_15_11.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.11 – Kiali 服务交互图](img/B19877_15_11.jpg)'
- en: Figure 15.11 – Kiali service interaction graph
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.11 – Kiali 服务交互图
- en: While Kiali dashboards provide valuable insights regarding our mesh and help
    us observe service interactions in real time, they lack the capability of providing
    us with advanced monitoring and alerting capabilities. For that, we can use Grafana.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kiali仪表板提供了有关我们的服务网格的宝贵见解，并帮助我们实时观察服务交互，但它缺乏提供高级监控和告警功能的能力。为此，我们可以使用Grafana。
- en: Monitoring and alerting with Grafana
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Grafana进行监控和告警
- en: '**Grafana** is a leading open source platform for observability and monitoring,
    offering dynamic dashboards and robust alerting capabilities. It enables users
    to visualize data from diverse sources while setting up alerts for proactive issue
    detection.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grafana** 是一个领先的开源平台，用于可观察性和监控，提供动态仪表板和强大的告警功能。它使用户能够可视化来自不同来源的数据，同时设置告警以主动检测问题。'
- en: 'As we’ve already installed Grafana with the necessary add-ons, let’s access
    it by opening a port forward session. Ensure you terminate the existing Kiali
    port-forwarding session or use a different port. Run the following command to
    do so:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经安装了带有必要插件的Grafana，让我们通过打开一个端口转发会话来访问它。确保终止现有的Kiali端口转发会话，或者使用不同的端口。运行以下命令来实现：
- en: '[PRE62]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Once the port forwarding session has started, access the Grafana page like
    we did for Kiali, and go to **Home** > **Dashboards** > **Istio** > **Istio Service
    Dashboard**. We should see a dashboard similar to the following:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦端口转发会话开始，就像我们对Kiali所做的那样访问Grafana页面，然后进入**首页** > **仪表板** > **Istio** > **Istio
    服务仪表板**。我们应该能看到类似于以下的仪表板：
- en: '![Figure 15.12 – Istio service dashboard ](img/B19877_15_12.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.12 – Istio 服务仪表板 ](img/B19877_15_12.jpg)'
- en: Figure 15.12 – Istio service dashboard
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.12 – Istio 服务仪表板
- en: This dashboard provides rich visualizations regarding some standard SLIs we
    may want to monitor, such as the request’s *success rate*, *duration*, *size*,
    *volume*, and *latency*. It helps you observe your mesh meticulously, and you
    can also build additional visualizations based on your requirements by using the
    **Prometheus Query Language** (**PromQL**), which is simple to learn and apply.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 该仪表板提供了有关我们可能想要监控的一些标准SLI（服务级指标）的丰富可视化，例如请求的*成功率*、*持续时间*、*大小*、*流量*和*延迟*。它帮助你细致地观察你的服务网格，并且你还可以通过使用**Prometheus查询语言**（**PromQL**）构建额外的可视化，PromQL学习和应用起来都很简单。
- en: However, monitoring and visualization must be complemented by alerting for complete
    reliability. So, let’s delve into that.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，监控和可视化必须与告警相结合，才能确保完整的可靠性。所以，让我们深入探讨一下。
- en: Alerting with Grafana
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Grafana进行告警
- en: To initiate the alerting process, it’s crucial to establish clear criteria.
    Given the limited volume at hand, simulating an accurate SLO breach can be challenging.
    For simplicity, our alerting criteria will trigger when traffic volume surpasses
    one transaction per second.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动告警过程，建立清晰的标准至关重要。鉴于目前的流量较低，模拟准确的 SLO 违约可能具有挑战性。为简化起见，我们的告警标准将在流量超过每秒一个事务时触发。
- en: 'The initial phase of this process involves crafting the query to retrieve the
    necessary metrics. We will employ the following query to achieve this objective:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的初始阶段涉及编写查询以获取必要的度量指标。我们将使用以下查询来实现这一目标：
- en: '[PRE63]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The provided query determines the traffic rate for all transactions passing
    through the Istio ingress gateway to the `frontend` microservice.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的查询确定了通过 Istio 入口网关传递到`frontend`微服务的所有事务的流量速率。
- en: 'The next step involves creating the alert rules with the query in place. To
    do this, navigate to **Home** > **Alerting** > **Alert rules**. Then, fill in
    the form, as illustrated in the following screenshot:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建警报规则并应用查询。为此，导航至**首页** > **告警** > **告警规则**。然后，填写表单，如下方截图所示：
- en: '![Figure 15.13 – Defining alert rules](img/B19877_15_13.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.13 – 定义警报规则](img/B19877_15_13.jpg)'
- en: Figure 15.13 – Defining alert rules
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.13 – 定义警报规则
- en: The alert rule is configured to monitor for violations at a 1-minute interval
    for 2 consecutive minutes. Once the alert rule has been established, triggering
    the alert is as simple as refreshing the Blog App home page about 15–20 times
    rapidly every 1 to 2 minutes. This action should activate the alert. To observe
    this process, navigate to **Home** > **Alerting** > **Alert rules**. You will
    notice the alert in a **Pending** state in the first minute. This means it has
    detected a violation in one of its checks and will wait for another violation
    within the 2-minute duration before triggering the alert.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 警报规则配置为在 1 分钟的间隔内监控违反情况，持续 2 分钟。一旦设置了警报规则，触发警报就非常简单，只需每 1 到 2 分钟快速刷新博客应用首页 15
    到 20 次即可。这一操作应该会激活警报。要观察此过程，导航至**首页** > **告警** > **告警规则**。你会发现警报在第一分钟内处于**待处理**状态。这意味着它已经在其中一次检查中检测到违反情况，并将在
    2 分钟内等待另一次违反情况，之后触发警报。
- en: 'In a production environment, setting longer check intervals, typically around
    5 minutes, with alerting intervals of 15 minutes is typical. This approach helps
    avoid excessive alerting for self-resolving transient issues, ensuring the SRE
    team is not inundated with false alerts. The goal is to maintain a balance and
    prevent the team from treating every alert as a potential false alarm. The following
    screenshot shows a pending alert:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，通常会设置较长的检查间隔，通常为 5 分钟，并设置 15 分钟的告警间隔。这种做法有助于避免对自我解决的短暂问题发出过多警报，从而确保 SRE
    团队不会被虚假警报淹没。目标是保持平衡，避免团队将每个警报都视为潜在的虚假警报。以下截图显示了一个待处理的警报：
- en: '![Figure 15.14 – Alert pending](img/B19877_15_15.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.14 – 警报待处理](img/B19877_15_15.jpg)'
- en: Figure 15.14 – Alert pending
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.14 – 警报待处理
- en: 'After the 2-minute monitoring period, you should observe the alert being triggered,
    as depicted in the following screenshot. This indicates that the alert rule has
    successfully identified a sustained violation of the defined criteria and is now
    actively notifying relevant parties or systems:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2 分钟的监控期结束后，你应该观察到警报被触发，如下方截图所示。这表示警报规则已经成功识别出持续违反定义标准的情况，并正在积极通知相关方或系统：
- en: '![Figure 15.15 – Alert firing](img/B19877_15_16.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.15 – 警报触发](img/B19877_15_16.jpg)'
- en: Figure 15.15 – Alert firing
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.15 – 警报触发
- en: Since no specific alert channels have been configured in this context, the fired
    alerts will be visible within the Grafana dashboard only. It is highly advisable
    to set up a designated alert destination for sending alerts to your designated
    channels, using a tool such as **PagerDuty** to page on-call engineers or **Slack**
    notifications to alert your on-call team. Proper alert channels ensure that the
    right individuals or teams are promptly notified of critical issues, enabling
    rapid response and issue resolution.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在此上下文中未配置特定的警报通道，触发的警报将仅在 Grafana 仪表盘中可见。强烈建议设置专门的警报目标，将警报发送到指定的通道，使用如**PagerDuty**之类的工具通知值班工程师，或通过**Slack**通知你的值班团队。合适的警报通道确保相关个人或团队能及时收到关键问题通知，从而快速响应并解决问题。
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As we conclude this chapter and wrap up this book, our journey has taken us
    through an array of diverse concepts and functionalities. While we’ve covered
    substantial ground in this chapter, it’s essential to recognize that Istio is
    a rich and multifaceted technology, making it a challenge to encompass all its
    intricacies within a single chapter.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束本章并总结本书，我们的旅程带领我们走过了各种各样的概念和功能。虽然本章我们已覆盖了大量内容，但必须认识到 Istio 是一项丰富而多面的技术，很难在一章内涵盖其所有复杂性。
- en: This chapter marked our initiation into the world of service mesh, shedding
    light on its particular advantages in the context of microservices. Our exploration
    extended to various dimensions of Istio, beginning with installing Istio and extending
    our sample Blog App to utilize it using automatic sidecar injection. We then moved
    on to security, delving into the intricacies of securing ingress gateways with
    mTLS, enforcing strict mTLS among microservices, and harnessing authorization
    policies to manage traffic flows.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着我们进入了服务网格的世界，阐明了它在微服务环境中的独特优势。我们的探索涉及 Istio 的各个方面，从安装 Istio 开始，到通过自动 sidecar
    注入扩展我们的示例博客应用。随后，我们进入了安全部分，深入探讨了如何使用 mTLS 加强入口网关的安全性，强制微服务间使用严格的 mTLS，并利用授权策略来管理流量。
- en: Our journey then led us to traffic management, where we introduced essential
    concepts such as destination rules and virtual services. These enabled us to carry
    out canary rollouts and traffic mirroring, demonstrating the power of controlled
    deployments and real-time traffic analysis. Our voyage culminated in observability,
    where we harnessed the Kiali dashboard to visualize service interactions and ventured
    deep into advanced monitoring and alerting capabilities using Grafana.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们的旅程带领我们进入流量管理，我们介绍了诸如目标规则和虚拟服务等基本概念。这些概念使我们能够执行金丝雀发布和流量镜像，展示了受控部署和实时流量分析的强大功能。我们的探索最终进入了可观察性，我们利用
    Kiali 仪表盘可视化服务交互，并深入探讨了使用 Grafana 进行高级监控和告警功能。
- en: As we end this remarkable journey, I want to extend my heartfelt gratitude to
    you for choosing this book and accompanying me through its pages. I trust you’ve
    found every part of this book enjoyable and enlightening. I hope this book has
    equipped you with the skills necessary to excel in the ever-evolving realm of
    modern DevOps. I wish you the utmost success in all your present and future endeavors.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们结束这段精彩的旅程，我想对你表达衷心的感谢，感谢你选择了这本书并陪伴我走过它的每一页。我相信你已经从书中的每个部分获得了愉悦和启发。我希望这本书能为你提供必要的技能，让你在不断发展的现代
    DevOps 领域中脱颖而出。祝愿你在当前和未来的所有努力中取得最大的成功。
- en: Questions
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章的理解：
- en: Which approach would you use to install Istio among the available options using
    GitOps methodology?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用 GitOps 方法的可选选项中，你会选择哪种方式来安装 Istio？
- en: A. Istioctl
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. Istioctl
- en: B. Helm charts
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. Helm charts
- en: C. Kustomize
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Kustomize
- en: D. Manifest bundle
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. Manifest bundle
- en: What configuration is necessary for Istio to inject sidecars into your workloads
    automatically?
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要让 Istio 自动将 sidecar 注入到你的工作负载中，必须进行哪些配置？
- en: 'A. Apply the `istio-injection-enabled: true` label to the namespace'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'A. 将 `istio-injection-enabled: true` 标签应用到命名空间'
- en: B. No configuration is needed – Istio automatically injects sidecars into all
    pods
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 不需要配置 — Istio 会自动将 sidecar 注入所有 pod
- en: C. Modify the manifests so that they include the Istio sidecars and redeploy
    them
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 修改清单以包含 Istio sidecar 并重新部署
- en: Istio sidecars automatically communicate with each other using mTLS. (True/False)
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Istio sidecar 会自动使用 mTLS 进行相互通信。（正确/错误）
- en: Which resource enforces policies that dictate which services are permitted to
    communicate with each other?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种资源强制执行指定哪些服务可以相互通信的策略？
- en: A. `AuthenticationPolicy`
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. `AuthenticationPolicy`
- en: B. `AuthorizationPolicy`
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. `AuthorizationPolicy`
- en: C. `PeerAuthentication`
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. `PeerAuthentication`
- en: Which of the following resources would you use for canary rollouts? (Choose
    two)
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项资源适用于金丝雀发布？（选择两项）
- en: A. `VirtualService`
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. `VirtualService`
- en: B. `IngressGateway`
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. `IngressGateway`
- en: C. `DestinationRule`
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. `DestinationRule`
- en: D. `Egress Gateway`
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. `Egress Gateway`
- en: Why would you use traffic mirroring in production? (Choose three)
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在生产环境中使用流量镜像？（选择三项）
- en: A. Real-time monitoring for production performance and behavior analysis
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 实时监控生产环境性能和行为分析
- en: B. To route traffic to a new version to duplicate traffic to test the performance
    of your backend service
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 将流量路由到新版本并复制流量以测试后端服务的性能
- en: C. Safe testing of changes or updates without risking production disruptions
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 在不冒生产中断风险的情况下安全地测试更改或更新
- en: D. Streamlined troubleshooting and debugging for issue identification and resolution
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 简化故障排除和调试，以便识别和解决问题
- en: Which observability tool would you use to visualize real-time service interactions?
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪种可观察性工具来可视化实时服务交互？
- en: A. Prometheus
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. Prometheus
- en: B. Grafana
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. Grafana
- en: C. Kiali
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Kiali
- en: D. Loki
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. Loki
- en: Answers
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的答案：
- en: B
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: A
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: 'True'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: B
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: A and C
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A 和 C
- en: A, C, and D
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A、C 和 D
- en: C
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: 'Appendix: The Role of AI in DevOps'
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录：AI 在 DevOps 中的角色
- en: The recent developments in **artificial intelligence** (**AI**) with the launch
    of generative AI using ChatGPT have taken the tech industry by storm. It has made
    many existing AI players pivot, and most companies are now looking at the best
    ways to use it in their products. Naturally, DevOps and the tooling surrounding
    it are no exceptions, and slowly, AI is gaining firm ground in this discipline,
    which historically relied upon more traditional automation methods. Before we
    delve into how AI changes DevOps, let’s first understand what AI is.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 ChatGPT 推出的生成性 AI，**人工智能**（**AI**）的最新发展震动了科技行业。许多现有的 AI 参与者纷纷转型，且大多数公司现在都在寻找最佳方式将其应用到产品中。自然，DevOps
    及其相关工具也不例外，AI 正在慢慢地在这一领域站稳脚跟，而这个领域历史上更多依赖传统的自动化方法。在我们深入探讨 AI 如何改变 DevOps 之前，让我们先了解什么是
    AI。
- en: 'This appendix will cover the following topics:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录将涵盖以下主题：
- en: What is AI?
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 AI？
- en: The role of AI in the DevOps infinity loop
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AI 在 DevOps 无限循环中的角色
- en: What is AI?
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 AI？
- en: AI emulates human intelligence in computing. You know how our computers do fantastic
    things, but they need to be told everything to do? Well, AI doesn’t work like
    that. It learns a ton from looking at lots of information, like how we learn from
    our experiences. That way, it can figure out patterns independently and make decisions
    without needing someone to tell it what to do every time. This makes AI intelligent
    because it can keep learning new things and get better at what it does.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: AI 模拟计算中的人类智能。你知道我们的计算机能做出惊人的事情，但它们需要告诉每一步该做什么，对吧？而 AI 不需要那样，它通过大量的信息学习，就像我们从经验中学习一样。这样，它就能独立发现模式，并做出决策，而不需要每次都有人告诉它该做什么。这使得
    AI 变得智能，因为它能够不断学习新事物，并在其执行的任务中不断变得更好。
- en: Imagine if your computer could learn from everything it sees, just like you
    remember from everything around you. That’s how AI works—it’s a computer’s way
    of getting more intelligent. Instead of needing step-by-step instructions, AI
    learns from vast amounts of information. This makes it great at spotting patterns
    in data and deciding things on its own. And when it comes to DevOps, AI can be
    of great help! Let’s look at that next.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果你的计算机能够从它所看到的每一件事中学习，就像你从周围的一切中记住一样。这就是 AI 的工作原理——它是计算机变得更智能的一种方式。AI
    不再需要逐步指令，它可以从大量信息中学习。这使得它非常擅长在数据中发现模式并做出决策。而在 DevOps 中，AI 可以提供极大的帮助！我们接下来来看一下。
- en: The role of AI in the DevOps infinity loop
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AI 在 DevOps 无限循环中的角色
- en: 'As we are already aware, instead of following a linear path of software delivery,
    DevOps practices generally follow an infinity loop, as shown in the following
    figure:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的那样，DevOps 实践通常遵循一个无限循环，而不是传统的线性软件交付路径，如下图所示：
- en: '![](img/B19877_Appendix_1.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19877_Appendix_1.jpg)'
- en: Figure A.1 – DevOps infinity loop
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图 A.1 – DevOps 无限循环
- en: DevOps practices heavily emphasize automation to ensure that this infinity loop
    operates smoothly, and we need tools. Most of these tools help build, deploy,
    and operate your software. You will typically start writing code in an **integrated
    development environment** (**IDE**) and then check code into a central source
    code repository such as Git. There will be a continuous integration pipeline that
    will build code from your Git repository and push it to an artifact repository.
    Your QA team might write automated tests to ensure the artifact is tested before
    it is deployed to higher environments using a continuous deployment pipeline.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 实践极大地强调自动化，以确保这个无限循环顺利运行，我们需要工具。大多数这些工具帮助构建、部署和运营软件。通常，你会在**集成开发环境**（**IDE**）中开始编写代码，然后将代码提交到如
    Git 这样的中央源代码仓库。会有一个持续集成流水线，它从你的 Git 仓库构建代码并将其推送到制品仓库。你的 QA 团队可能会编写自动化测试，以确保在使用持续部署流水线将制品部署到更高环境之前进行测试。
- en: Before the advent of AI, setting up all of the toolchains and operating them
    relied on traditional coding methods; that is, you would still write code to automate
    the processes, and the automation would behave more predictably and do what it
    was told to. However, with AI, things are changing.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在AI出现之前，设置所有工具链并操作它们依赖于传统的编码方法；也就是说，你仍然需要编写代码来自动化过程，而自动化会更可预测地按照指令执行。然而，随着AI的出现，事情正在发生变化。
- en: AI is transforming DevOps by automating tasks, predicting failures, and optimizing
    performance. In other words, by leveraging AI’s capabilities, DevOps teams can
    achieve greater efficiency, reduce errors, and deliver software faster and more
    reliably.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: AI正在通过自动化任务、预测故障和优化性能来改变DevOps。换句话说，通过利用AI的能力，DevOps团队可以实现更高的效率，减少错误，并更快、更可靠地交付软件。
- en: 'Here are some key roles of AI in DevOps:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是AI在DevOps中的一些关键角色：
- en: '**Automating Repetitive Tasks**: AI can automate repetitive and tedious tasks,
    such as code testing, deployment, and infrastructure provisioning. This frees
    up DevOps engineers to focus on more strategic and creative work, such as developing
    new features and improving application performance.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化重复任务**：AI可以自动化重复且乏味的任务，如代码测试、部署和基础设施供应。这让DevOps工程师能够专注于更具战略性和创造性的工作，如开发新特性和改进应用性能。'
- en: '**Predicting and Preventing Failures**: AI can analyze vast amounts of data,
    including logs, performance metrics, and user feedback, to identify patterns and
    predict potential failures. This proactive approach allows DevOps teams to address
    issues before they impact users or cause major disruptions.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预测和防止故障**：AI可以分析大量数据，包括日志、性能指标和用户反馈，以识别模式并预测潜在故障。这种主动的方式使DevOps团队能够在问题影响用户或导致重大中断之前就进行处理。'
- en: '**Optimizing Resource Utilization**: AI can analyze resource usage data to
    optimize infrastructure allocation and prevent resource bottlenecks. This ensures
    that applications have the resources they need to perform optimally, minimizing
    downtime and improving overall system efficiency.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化资源利用率**：AI可以分析资源使用数据，优化基础设施分配并防止资源瓶颈。这确保了应用程序能够获得所需的资源以实现最佳性能，从而减少停机时间并提高整体系统效率。'
- en: '**Enhancing Security**: AI can be used to detect and prevent security threats
    by analyzing network traffic, identifying anomalous behavior, and flagging suspicious
    activity. This helps DevOps teams maintain a robust security posture and protect
    sensitive data.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强安全性**：AI可以通过分析网络流量、识别异常行为并标记可疑活动来检测和防止安全威胁。这帮助DevOps团队保持强大的安全态势并保护敏感数据。'
- en: '**Improving Collaboration and Communication**: AI can facilitate collaboration
    and communication among DevOps teams by providing real-time insights, automating
    workflows, and enabling seamless communication channels. This breaks down silos
    and promotes a more cohesive DevOps culture.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改善协作与沟通**：AI可以通过提供实时见解、自动化工作流和启用无缝沟通渠道来促进DevOps团队之间的协作与沟通。这打破了信息孤岛，促进了更具凝聚力的DevOps文化。'
- en: Let’s look at the areas of the DevOps infinity loop and see how AI impacts them.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看DevOps无限循环的各个领域，看看AI如何影响它们。
- en: Code development
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码开发
- en: This area is where we see the most significant impact of generative AI and other
    AI technologies. AI revolutionizes code development by automating tasks such as
    code generation, bug detection, optimization, and testing. Through autocomplete
    suggestions, bug detection algorithms, and predictive analytics, AI accelerates
    coding, enhances code quality, and ensures better performance while aiding in
    documentation and code security analysis. Its role spans from assisting in writing
    code to predicting issues, ultimately streamlining the software development life
    cycle, and empowering developers to create more efficient, reliable, and secure
    applications.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个领域，我们看到了生成式AI和其他AI技术的最大影响。AI通过自动化任务如代码生成、错误检测、优化和测试，彻底改变了代码开发。通过自动完成功能、错误检测算法和预测分析，AI加速了编码过程，提升了代码质量，并确保了更好的性能，同时帮助文档编写和代码安全分析。它的角色贯穿于从辅助编写代码到预测问题，最终简化软件开发生命周期，赋能开发者创造更高效、更可靠和更安全的应用程序。
- en: Many tools employ AI in code development, and one of the most popular tools
    in this area is **GitHub Copilot**.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 许多工具在代码开发中应用了AI，其中最受欢迎的工具之一是**GitHub Copilot**。
- en: GitHub Copilot is a collaborative effort between **GitHub** and **OpenAI**,
    introducing a code completion feature that utilizes OpenAI’s **Codex**. Codex,
    trained on vast code repositories from GitHub, quickly generates code based on
    the current file’s content and cursor location. Compatible with popular code editors
    such as **Visual Studio Code**, **Visual Studio**, **Neovim**, and **JetBrains
    IDEs**, Copilot supports languages such as **Python**, **JavaScript**, **TypeScript**,
    **Ruby**, and **Go**.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Copilot 是 **GitHub** 和 **OpenAI** 的合作成果，推出了一项代码补全功能，利用 OpenAI 的 **Codex**。Codex
    在 GitHub 上大量的代码库中进行训练，能够根据当前文件的内容和光标位置快速生成代码。它兼容流行的代码编辑器，如 **Visual Studio Code**、**Visual
    Studio**、**Neovim** 和 **JetBrains IDEs**，并支持 **Python**、**JavaScript**、**TypeScript**、**Ruby**
    和 **Go** 等语言。
- en: Praised by GitHub and users alike, Copilot generates entire code lines, functions,
    tests, and documentation. Its functionality relied on the context provided and
    the extensive code contributions by developers on GitHub, regardless of their
    software license. Dubbed the world’s first AI pair programmer by **Microsoft**,
    it is a paid tool and charges a subscription fee of $10 per month or $100 per
    year per user after a 60-day trial period.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 受到 GitHub 和用户们的共同赞誉，Copilot 能生成完整的代码行、函数、测试和文档。其功能依赖于所提供的上下文以及 GitHub 上开发者的广泛代码贡献，无论其软件许可如何。被**微软**称为世界上首个
    AI 配对程序员，它是一个付费工具，提供 60 天试用期后，每位用户每月收取 10 美元或每年 100 美元的订阅费。
- en: With Copilot, you can start by writing comments on what you intend to do, and
    it will generate the required code for you. This speeds up development many times,
    and most of the time, you just need to review and test your code to see whether
    it does what you intend it to do. A great power indeed! It can optimize existing
    code and provide feedback by generating code snippets. It can also scan your code
    for security vulnerabilities and suggest alternative approaches.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Copilot，你可以通过先写下你打算做的事情的注释来开始，它会为你生成所需的代码。这大大加快了开发速度，大多数时候，你只需要审查和测试你的代码，看看它是否按预期运行。的确是一股强大的力量！它能够优化现有代码并通过生成代码片段提供反馈。它还可以扫描你的代码，查找安全漏洞，并建议替代方案。
- en: If you don’t want to pay that $10, you can also look at free alternatives such
    as **Tabnine**, **Captain Stack**, **GPT-Code Clippy**, **Second Mate**, and **Intellicode**.
    Paid alternatives include Amazon’s **Code Whisperer** and Google’s **ML-enhanced**
    **code completion**.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想支付那 10 美元，你也可以选择一些免费的替代工具，如 **Tabnine**、**Captain Stack**、**GPT-Code Clippy**、**Second
    Mate** 和 **Intellicode**。付费替代工具包括亚马逊的 **Code Whisperer** 和谷歌的 **基于 ML 的** **代码补全**。
- en: AI tools not only help enhance the development workflow but also help in software
    testing and quality assurance. Let’s look at that next.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: AI 工具不仅有助于增强开发工作流，还能帮助软件测试和质量保证。接下来我们来看看这一点。
- en: Software testing and quality assurance
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件测试与质量保证
- en: Traditionally, software testing has taken more of a manual approach because
    most developers don’t want software testing as a full-time profession. Though
    automation testing has gained ground recently, the knowledge gap has hindered
    this process in most organizations. Therefore, AI would most impact the testing
    function as it bridges the human-machine gap.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，软件测试更倾向于手动方式，因为大多数开发者并不希望将软件测试作为全职职业。尽管自动化测试近年来逐渐普及，但知识差距仍然制约着大多数组织的这一进程。因此，AI
    将对测试功能产生重大影响，因为它弥补了人类与机器之间的差距。
- en: 'AI-integrated testing techniques revolutionize every stage of the **software
    testing life cycle** (**STLC**); some of them are as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 集成 AI 的测试技术正在革新 **软件测试生命周期**（**STLC**）的每个阶段，其中一些如下：
- en: '**Test script generation**: Traditionally, creating test scripts was time-consuming,
    involving deep system understanding. AI and **machine learning** (**ML**) now
    expedite this process by analyzing requirements, existing test cases, and application
    behavior to craft more optimized test scripts, offering ready-to-use templates
    with preconfigured code snippets and comprehensive comments, and translating plain
    language instructions into complete test scripts using **natural language processing**
    (**NLP**) techniques.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试脚本生成**：传统上，创建测试脚本是一个耗时的过程，需要对系统有深入的理解。现在，AI 和 **机器学习**（**ML**）通过分析需求、现有测试用例和应用行为，快速生成更优化的测试脚本，提供可直接使用的模板，内含预配置的代码片段和详尽的注释，并使用
    **自然语言处理**（**NLP**）技术将简单语言指令转化为完整的测试脚本。'
- en: '**Test data generation**: AI-equipped testing tools provide detailed and ample
    test data for comprehensive coverage. They achieve this by generating synthetic
    data from existing sets for specific test objectives, transforming data to create
    diverse testing scenarios, refining existing data for higher precision and relevance,
    and scanning large code bases for context comprehension.'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试数据生成**：AI装备的测试工具提供详细且丰富的测试数据，以实现全面覆盖。它们通过从现有数据集中生成合成数据来针对特定测试目标，转换数据以创建多样的测试场景，优化现有数据以提高精度和相关性，以及扫描大规模代码库以理解上下文。'
- en: '**Intelligent test execution**: AI alleviates test execution challenges by
    automatically categorizing and organizing test cases, efficiently selecting tests
    for various devices, operating systems, and configurations, and smartly executing
    regression tests for critical functionalities.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能测试执行**：AI通过自动分类和组织测试用例，针对不同设备、操作系统和配置智能地选择测试，并巧妙地执行关键功能的回归测试，从而缓解了测试执行的挑战。'
- en: '**Intelligent test maintenance**: AI/ML minimizes test maintenance challenges
    by implementing self-healing mechanisms to handle broken selectors and analyzing
    UI and code change relationships to identify affected areas.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**智能测试维护**：AI/机器学习通过实施自我修复机制处理选择器故障，并分析UI和代码变更关系，以识别受影响的区域，从而最大限度减少测试维护的挑战。'
- en: '**Root cause analysis**: AI aids in understanding and rectifying issues by
    analyzing logs, performance metrics, and anomalies to pinpoint impact areas, tracing
    issues back to affected user stories and feature requirements, and utilizing knowledge
    repositories for comprehensive root cause analysis.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根本原因分析**：AI通过分析日志、性能指标和异常来帮助理解和修复问题，准确找出影响区域，追溯问题到受影响的用户故事和功能需求，并利用知识库进行全面的根本原因分析。'
- en: 'Multiple tools in the market help you achieve all of it; some of the most popular
    ones are the following:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有多个工具可以帮助你实现这一切，其中一些最流行的工具如下：
- en: '**Katalon platform**: A comprehensive quality management tool that simplifies
    test creation, execution, and maintenance across various applications and environments.
    It boasts AI features such as **TrueTest**, **StudioAssist**, **self-healing**,
    **visual testing**, and **AI-powered test** **failure analysis**.'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Katalon平台**：一款全面的质量管理工具，简化了跨多个应用和环境的测试创建、执行和维护。它拥有AI功能，如**TrueTest**、**StudioAssist**、**自我修复**、**视觉测试**和**AI驱动的测试失败分析**。'
- en: '**TestCraft**: Built on **Selenium**, TestCraft offers both manual and automated
    testing capabilities with a user-friendly interface and AI-driven element identification,
    allowing tests to run across multiple browsers in parallel.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TestCraft**：基于**Selenium**构建，TestCraft提供了手动和自动化测试功能，具有用户友好的界面和AI驱动的元素识别，支持多浏览器并行运行测试。'
- en: '**Applitools**: Known for its AI-based visual testing, Applitools efficiently
    identifies visual bugs, monitors app visual aspects, and provides accurate visual
    test analytics using AI and ML.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Applitools**：以其基于AI的视觉测试而闻名，Applitools高效地识别视觉缺陷，监控应用程序的视觉方面，并使用AI和机器学习提供准确的视觉测试分析。'
- en: '**Function**: Utilizes AI/ML for functional, performance, and load testing
    with simplicity, allowing test creation through plain English input, self-healing,
    test analytics, and multi-browser support.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能**：利用AI/机器学习进行功能、性能和负载测试，简单易用，支持通过简单的英语输入创建测试、自动修复、测试分析和多浏览器支持。'
- en: '**Mabl**: An AI-powered tool offering low-code testing, intuitive intelligence,
    data-driven capabilities, end-to-end testing, and valuable insights generation,
    promoting team collaboration.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mabl**：一款AI驱动的工具，提供低代码测试、直观智能、数据驱动功能、端到端测试以及有价值的洞察生成，促进团队协作。'
- en: '**AccelQ**: Automates test designs, plans, and execution across the UI, mobile,
    API, and PC software, featuring **automated test generation**, **predictive analysis**,
    and comprehensive test management.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AccelQ**：自动化UI、移动端、API和PC软件的测试设计、计划和执行，具备**自动化测试生成**、**预测分析**和全面的测试管理功能。'
- en: '**Testim**: Uses ML to expedite test creation and maintenance, allowing for
    quick end-to-end test creation, smart locators for resilient tests, and a blend
    of recording functions and coding for robust test creation.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Testim**：通过机器学习加速测试创建和维护，允许快速的端到端测试创建、智能定位器用于可靠测试，并结合录制功能和编码来创建强大的测试。'
- en: As we’ve already seen the benefits of AI in development and testing, let’s move
    on to software delivery.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，AI在开发和测试中的好处，我们接下来看看软件交付。
- en: Continuous integration and delivery
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成和交付
- en: In **continuous integration** (**CI**) and **continuous delivery** (**CD**),
    AI brings a transformative edge by optimizing and automating various stages of
    the software development pipeline. AI augments CI by automating code analysis,
    identifying patterns, and predicting potential integration issues. It streamlines
    the process by analyzing code changes, suggesting appropriate test cases, and
    facilitating faster integration cycles. Through ML, AI can understand historical
    data from past builds, recognizing patterns that lead to failures, thereby aiding
    in more efficient debugging and code quality improvement.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在**持续集成**（**CI**）和**持续交付**（**CD**）中，人工智能通过优化和自动化软件开发流程的各个阶段，带来了变革性的优势。人工智能增强了持续集成，通过自动化代码分析、识别模式和预测潜在的集成问题。它通过分析代码变化、建议适当的测试用例并促进更快的集成周期，从而简化了流程。通过机器学习（ML），人工智能可以理解过去构建的历史数据，识别导致失败的模式，从而帮助更高效地调试和改善代码质量。
- en: In CD, AI optimizes deployment pipelines by automating release strategies, predicting
    performance bottlenecks, and suggesting optimizations for smoother delivery. It
    analyzes deployment patterns, user feedback, and system performance data to recommend
    the most efficient delivery routes. Additionally, AI-driven CD tools enhance risk
    prediction, allowing teams to foresee potential deployment failures and make informed
    decisions to mitigate risks before they impact production environments. Ultimately,
    AI’s role in CI/CD accelerates the development cycle, improves software quality,
    and enhances the reliability of software releases.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续交付（CD）中，人工智能通过自动化发布策略、预测性能瓶颈并建议优化方案，以实现更顺畅的交付。它分析部署模式、用户反馈和系统性能数据，推荐最有效的交付路线。此外，人工智能驱动的CD工具提高了风险预测能力，帮助团队预见潜在的部署失败，并在生产环境受到影响之前做出明智决策以减轻风险。最终，人工智能在持续集成/持续交付（CI/CD）中的作用加速了开发周期，提升了软件质量，并增强了软件发布的可靠性。
- en: 'Here are some AI-powered tools used in software release and delivery:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用于软件发布和交付的人工智能驱动工具：
- en: '**Harness**: Harness utilizes AI to automate software delivery processes, including
    continuous integration, deployment, and verification. It employs ML to analyze
    patterns from deployment pipelines, predict potential issues, and optimize release
    strategies for better efficiency and reliability.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Harness**：Harness利用人工智能自动化软件交付流程，包括持续集成、部署和验证。它通过机器学习分析部署管道中的模式，预测潜在问题，并优化发布策略，以提高效率和可靠性。'
- en: '**GitClear**: GitClear employs AI algorithms to analyze code repositories and
    provides insights into developer productivity, code contributions, and team performance.
    It helps understand code base changes, identify bottlenecks, and optimize development
    workflows.'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitClear**：GitClear采用人工智能算法分析代码库，提供关于开发者生产力、代码贡献和团队表现的洞察。它帮助了解代码库变化、识别瓶颈并优化开发工作流。'
- en: '**Jenkins**: Thanks to its plugin-based architecture, Jenkins, a widely used
    automation server, employs a lot of AI plugins and extensions to enhance its capabilities
    in CI/CD. AI-powered plugins help automate tasks, optimize build times, and predict
    build failures by analyzing historical data.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins**：得益于其插件架构，广泛使用的自动化服务器Jenkins采用了大量人工智能插件和扩展，增强了其在CI/CD中的能力。人工智能驱动的插件通过分析历史数据，帮助自动化任务、优化构建时间并预测构建失败。'
- en: '**CircleCI**: CircleCI integrates AI and ML to optimize CI/CD workflows. It
    analyzes build logs, identifies patterns leading to failures, and provides recommendations
    to improve build performance and reliability.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CircleCI**：CircleCI整合了人工智能和机器学习，以优化CI/CD工作流。它分析构建日志，识别导致失败的模式，并提供改善构建性能和可靠性的建议。'
- en: These AI-powered tools improve software release and delivery processes’ speed,
    quality, and reliability by automating tasks, optimizing workflows, predicting
    issues, and providing valuable insights for better decision-making.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这些人工智能驱动的工具通过自动化任务、优化工作流、预测问题并提供有价值的洞察，改善了软件发布和交付过程的速度、质量和可靠性，从而帮助做出更好的决策。
- en: Now, let’s look at the next stage in the process—software operations.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下流程中的下一阶段——软件运维。
- en: Software operations
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件运维
- en: AI is pivotal in modern software operations, revolutionizing how systems are
    monitored, managed, and optimized. By leveraging ML algorithms, AI helps automate
    routine tasks such as monitoring system performance, analyzing logs, and identifying
    anomalies in real time. It enables predictive maintenance by detecting patterns
    that precede system failures, allowing for proactive intervention and preventing
    potential downtime. Additionally, AI-powered tools streamline incident management
    by correlating alerts, prioritizing critical issues, and providing actionable
    insights, enhancing the overall resilience and reliability of software operations.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: AI在现代软件运维中至关重要，彻底改变了系统监控、管理和优化的方式。通过利用机器学习算法，AI帮助自动化日常任务，如监控系统性能、分析日志和实时识别异常。它通过检测系统故障前的模式来实现预测性维护，从而进行主动干预，防止潜在的停机。此外，AI驱动的工具通过关联警报、优先处理关键问题和提供可操作的见解来简化事件管理，增强了软件运维的整体弹性和可靠性。
- en: Moreover, AI augments decision-making processes by analyzing vast amounts of
    data to identify trends, forecast resource requirements, and optimize infrastructure
    utilization. AI adapts to changing environments through its continuous learning
    capabilities, enabling software operations teams to stay ahead of evolving challenges
    and complexities. Overall, AI’s role in software operations ensures greater efficiency,
    improved system performance, and proactive problem resolution, contributing significantly
    to the seamless functioning of IT infrastructures.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，AI通过分析大量数据来增强决策过程，识别趋势、预测资源需求，并优化基础设施利用率。AI通过其持续学习的能力适应变化的环境，使软件运维团队能够应对不断变化的挑战和复杂性。总体而言，AI在软件运维中的作用确保了更高的效率、提升的系统性能和主动的问题解决，从而显著地促进了IT基础设施的无缝运行。
- en: 'Here are some AI-powered tools used in software operations:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在软件运维中使用的AI驱动工具：
- en: '**Dynatrace**: Dynatrace utilizes AI for application performance monitoring
    and management. It employs AI algorithms to analyze vast amounts of data, providing
    real-time insights into application performance, identifying bottlenecks, and
    predicting potential issues before they impact end users.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dynatrace**：Dynatrace利用AI进行应用性能监控和管理。它使用AI算法分析大量数据，提供应用性能的实时洞察，识别瓶颈，并在问题影响最终用户之前预测潜在问题。'
- en: '**PagerDuty**: PagerDuty integrates AI-driven incident management, alerting,
    and on-call scheduling. It uses ML to correlate events and alerts, reducing noise
    and providing intelligent notifications for critical incidents.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PagerDuty**：PagerDuty集成了AI驱动的事件管理、警报和值班调度。它使用机器学习关联事件和警报，减少噪音并为关键事件提供智能通知。'
- en: '**Opsani**: Opsani leverages AI for autonomous optimization of cloud applications.
    It analyzes application performance, dynamically adjusts configurations, and optimizes
    resources to maximize performance and cost-efficiency.'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Opsani**：Opsani利用AI实现云应用的自主优化。它分析应用性能，动态调整配置，并优化资源以最大化性能和成本效益。'
- en: '**Moogsoft**: Moogsoft offers AI-driven IT operations and AIOps platforms.
    It uses ML to detect anomalies, correlate events, and automate incident resolution,
    helping teams proactively manage and resolve issues in complex IT environments.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Moogsoft**：Moogsoft提供AI驱动的IT运维和AIOps平台。它使用机器学习检测异常、关联事件并自动化事件解决，帮助团队主动管理和解决复杂IT环境中的问题。'
- en: '**Sumo Logic**: Sumo Logic employs AI for log management, monitoring, and analytics.
    It uses ML to identify patterns, anomalies, and security threats within logs and
    operational data, enabling proactive troubleshooting and security incident detection.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sumo Logic**：Sumo Logic使用AI进行日志管理、监控和分析。它利用机器学习识别日志和操作数据中的模式、异常和安全威胁，从而实现主动故障排除和安全事件检测。'
- en: '**New Relic**: New Relic utilizes AI for application and infrastructure monitoring.
    Its AI-powered platform helps identify performance issues, predict system behavior,
    and optimize resource utilization for better application performance.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**New Relic**：New Relic利用AI进行应用和基础设施监控。其AI驱动的平台有助于识别性能问题、预测系统行为，并优化资源利用，以提高应用性能。'
- en: '**LogicMonitor**: LogicMonitor uses AI for infrastructure monitoring and observability.
    It analyzes metrics and performance data to provide insights into system health,
    predict potential issues, and optimize resource allocation in complex environments.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LogicMonitor**：LogicMonitor利用AI进行基础设施监控和可观察性分析。它分析度量数据和性能数据，提供系统健康状况的洞察，预测潜在问题，并在复杂环境中优化资源分配。'
- en: '**OpsRamp**: OpsRamp employs AI for IT operations management, offering capabilities
    for monitoring, incident management, and automation. It uses ML to detect anomalies,
    automate routine tasks, and optimize workflows for better operational efficiency.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpsRamp**：OpsRamp利用AI进行IT运维管理，提供监控、事件管理和自动化功能。它使用机器学习（ML）来检测异常、自动化常规任务并优化工作流，从而提高运维效率。'
- en: These AI-powered tools assist in automating tasks, predicting and preventing
    issues, optimizing resource allocation, and enhancing overall system reliability
    in software operations.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这些AI驱动的工具有助于自动化任务、预测和防止问题、优化资源分配，并提高软件运维中整体系统的可靠性。
- en: The integration of AI into DevOps practices is still in its early stages, but
    its potential impact is significant. By automating tasks, optimizing processes,
    and enhancing collaboration, AI can revolutionize the way software is developed,
    deployed, and managed. As AI technology continues to develop, we can expect to
    see even more ways in which AI is used to improve the DevOps process.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: AI在DevOps实践中的集成仍处于初级阶段，但其潜在影响巨大。通过自动化任务、优化流程和增强协作，AI可以彻底改变软件的开发、部署和管理方式。随着AI技术的不断发展，我们可以期待看到更多AI被用于改进DevOps过程的方式。
- en: Summary
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: AI revolutionizes DevOps practices by infusing intelligence into every development
    and operations cycle stage. It streamlines processes, enhances efficiency, and
    ensures smoother collaboration between development and operations teams. AI automates
    routine tasks, predicts potential bottlenecks, and optimizes workflows, transforming
    how software is built, tested, deployed, and monitored. From automating code analysis
    to predicting system failures, AI empowers DevOps by enabling quicker decision-making,
    reducing errors, and fostering a more agile and responsive software development
    environment.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: AI通过在每个开发和运维周期阶段注入智能，彻底改变了DevOps实践。它简化了流程，提高了效率，并确保开发和运维团队之间的协作更加顺畅。AI自动化常规任务，预测潜在瓶颈，优化工作流，改变了软件的构建、测试、部署和监控方式。从自动化代码分析到预测系统故障，AI通过加快决策过程、减少错误以及促进更加敏捷和响应迅速的软件开发环境，赋能DevOps。
- en: In essence, AI acts as a silent partner, continuously learning from data, suggesting
    improvements, and helping DevOps teams foresee and address issues before they
    impact the software’s performance. It’s the catalyst that drives agility and innovation,
    allowing DevOps to evolve from a mere collaboration between teams to a symbiotic
    relationship where AI enhances the capabilities of both development and operations,
    paving the way for more efficient and reliable software delivery.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，AI充当着一个无声的伙伴，持续从数据中学习，提出改进建议，并帮助DevOps团队在问题影响软件性能之前预见并解决问题。它是推动敏捷性和创新的催化剂，使DevOps从仅仅是团队之间的协作，发展为AI提升开发和运维双方能力的共生关系，为更高效、可靠的软件交付铺平道路。
