- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Kubernetes Deployment– Same Game, Next Level
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 部署– 同样的游戏，下一阶段
- en: In the previous chapter, you dove into different deployment scenarios and how
    you should think not only about controllers, but also about upgrading apps, different
    types of apps to deploy, and different methods for getting an app up and running.
    In this chapter, you’re going to dive a bit deeper into the different styles of
    deploying and troubleshooting versus just doing the deployment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你深入探讨了不同的部署场景，以及如何不仅仅考虑控制器，还要考虑应用的升级、要部署的不同类型的应用，以及让应用运行起来的不同方法。在本章中，你将进一步深入探讨不同的部署风格以及故障排除，而不仅仅是进行部署。
- en: The first step in any type of deployment is figuring out what you’re doing –
    what type of application it is, what type of Kubernetes resource you want to use,
    and the different plugins that you may want to use, such as a CSI. After you figure
    out the logistics of what you want to deploy, the next step is to think about
    how you want to deploy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的第一步是搞清楚你要做什么——它是什么类型的应用，想使用哪种类型的 Kubernetes 资源，以及你可能想使用的不同插件，比如 CSI。了解了你要部署的内容后，下一步就是思考如何部署。
- en: With Kubernetes, there are many different deployment methods – automated deployments,
    manual deployments, and something in between automated and manual. There’s a vast
    number of different ways to perform deployments, so you won’t learn about all
    of them because that could take up more than six chapters of a book in itself,
    but you will learn about the primary ways to deploy and package up Kubernetes
    Manifests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 有很多不同的部署方法——自动化部署、手动部署，以及介于自动化和手动之间的一些方法。执行部署的方法有很多种，因此你不会学到所有方法，因为那可能会占据六章书的篇幅，但你会学习主要的部署方式以及如何打包
    Kubernetes Manifests。
- en: After you learn about deployments, thinking about how to troubleshoot once something
    inevitably goes wrong is a good, logical next step. Typically, engineers will
    learn troubleshooting on the fly, but it’s a good approach to think about troubleshooting
    techniques prior to something going wrong.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了部署之后，思考当某些事情不可避免地出错时如何进行故障排除是一个好的、合乎逻辑的下一步。通常，工程师会在实际操作中学习故障排除技巧，但在问题发生之前就思考故障排除技术是一种很好的方法。
- en: After learning about troubleshooting and deploying containerized apps, you’re
    going to wrap up with how to manage network connectivity between apps running
    on Kubernetes and how to migrate existing, more monolithic-style applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了故障排除和部署容器化应用后，你将学习如何管理运行在 Kubernetes 上的应用之间的网络连接，以及如何迁移现有的、更为单体化的应用。
- en: 'In this chapter, we’re going to cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting to know Helm charts and Kustomize
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Helm charts 和 Kustomize
- en: Deploying with CI/CD and GitOps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 CI/CD 和 GitOps 进行部署
- en: Troubleshooting application deployments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障排除应用部署
- en: Service meshes and Ingresses
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务网格和 Ingress
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this section, you’re going to take what you learned about the different
    types of deployments and methodologies for thinking about Kubernetes resources
    from the last chapter and expand upon that knowledge in this chapter. You should
    have a brief understanding of automated deployment methodologies such as CI/CD,
    and have a high-level understanding of what a service mesh is, along with some
    application architecture knowledge. As usual, you’ll find the code for this chapter
    on GitHub: [https://github.com/PacktPublishing/50-Kubernetes-Concepts-Every-DevOps-Engineer-Should-Know/tree/main/Ch6](https://github.com/PacktPublishing/50-Kubernetes-Concepts-Every-DevOps-Engineer-Should-Know/tree/main/Ch6)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将基于上一章中学习到的不同类型的部署和 Kubernetes 资源思考方法的知识，进一步拓展这一知识。你应该对自动化部署方法如 CI/CD
    有一个简要了解，并对服务网格的概念有一个高层次的理解，同时也具备一些应用架构的知识。如往常一样，你会在 GitHub 上找到本章的代码：[https://github.com/PacktPublishing/50-Kubernetes-Concepts-Every-DevOps-Engineer-Should-Know/tree/main/Ch6](https://github.com/PacktPublishing/50-Kubernetes-Concepts-Every-DevOps-Engineer-Should-Know/tree/main/Ch6)
- en: Getting to know Helm charts and Kustomize
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Helm charts 和 Kustomize
- en: When you’re working with Kubernetes, unless it’s a dev environment for your
    testing, there’s an extremely slim chance that you only have one Kubernetes Manifest.
    You most likely have multiple for various resources such as Deployments, Services,
    DaemonSets, ConfigMaps, Ingresses, and a ton of the other Kubernetes resources
    out there. Utilizing almost every single Kubernetes platform or tool that’s deployed
    to your cluster uses a Kubernetes Manifest.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在使用 Kubernetes 时，除非是用于测试的开发环境，否则几乎不可能只有一个 Kubernetes 清单。你很可能有多个清单，涉及各种资源，例如部署（Deployments）、服务（Services）、守护进程集（DaemonSets）、配置映射（ConfigMaps）、入口（Ingresses），以及其他许多
    Kubernetes 资源。几乎每个部署到集群的 Kubernetes 平台或工具都使用 Kubernetes 清单。
- en: With all those Kubernetes Manifests, there are a ton of different values and
    parameters that you need to pass at runtime to make it all work. In this section,
    you’ll learn about two different methods of managing Kubernetes Manifests – **Helm
    charts** and **Kustomize**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些 Kubernetes 清单中，你需要传递许多不同的值和参数才能让一切正常工作。在这一部分，你将学习两种不同的 Kubernetes 清单管理方法——**Helm
    charts** 和 **Kustomize**。
- en: Why think about deployment methods for manifests?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要考虑清单的部署方法？
- en: Before diving into different deployment methods, it makes sense to understand
    why you’d want to consider deployment methods other than using the terminal for
    the deploying Manifests first.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨不同的部署方法之前，首先理解为什么你会考虑使用其他部署方法而不是仅仅通过终端部署清单，是有意义的。
- en: There are three primary points, which we discuss in the following subsections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个主要的要点，我们将在接下来的子部分中讨论。
- en: Scale
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展性
- en: When thinking about scale, there’s absolutely no way to scale a deployment if
    an engineer is always doing it from their laptop. The engineer could be using
    different plugins, different IDEs, different terminal settings, and even a different
    operating system. With all of that, the uncertainty alone of the environment can
    cause a massive amount of error. If every engineer is relying on their computer
    to deploy an environment, what happens if their laptop crashes? Or there’s a random
    update during the day? Or someone is out of office? There are so many variables
    that come into play that make utilizing a local computer a bad idea when it comes
    to deployments. Instead, it makes far more sense to have a central location from
    which you conduct your deployments. The environment stays the same, everyone can
    use it, you can customize it to your team’s needs, and you don’t have to worry
    about anyone being out of office.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑到扩展性时，如果工程师总是从他们的笔记本电脑进行部署，根本无法扩展部署。工程师可能使用不同的插件、不同的 IDE、不同的终端设置，甚至是不同的操作系统。所有这些环境的不确定性本身就可能导致大量的错误。如果每个工程师都依赖于自己的计算机来部署环境，那如果他们的笔记本电脑崩溃了怎么办？或者在一天中的某个时刻突然有了更新？又或者有些人不在办公室？有如此多的变量影响，依赖本地计算机进行部署是一个糟糕的主意。相反，从一个中心化的位置进行部署更加合理。环境保持一致，每个人都能使用，你可以根据团队的需求进行定制，而且不必担心有人不在办公室。
- en: Anything can go wrong
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任何事情都有可能出错
- en: Going into the second point, which echoes the first point in a sense, anything
    can go wrong. The goal of every organization is to have a successful deployment
    all the time, zero hiccups, and the ability to deploy at any time. Marketing teams
    paint this picture in our heads of “deploy 20 times per day with this tool and
    it’ll always work,” but as all engineers know, that’s not reality. Anything as
    simple as a network hiccup or making an error when entering a variable name can
    lead to a failed deployment, and, in turn, an application being down. Because
    of that, having a proper deployment strategy is key not only to repeatability
    with Kubernetes but also to repeatability in general. Having a proper process
    and *rules* in place of how something is deployed and when or where it’s deployed
    is the make or break between a successful update and everyone on the engineering
    team sitting in the office fixing an issue until 1:00 A.M.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 进入第二个要点，这与第一个要点有些相似，任何事情都有可能出错。每个组织的目标都是确保每次部署都能成功，零差错，并能够随时进行部署。市场团队在我们的脑海中描绘出这样的场景：“使用这个工具每天可以部署
    20 次，而且每次都能成功。”但正如所有工程师所知道的那样，这并不是现实。任何像网络波动或者在输入变量名时犯错误这样的简单事情，都可能导致部署失败，进而导致应用程序宕机。因此，拥有一个正确的部署策略对于
    Kubernetes 的可重复性至关重要，而对于一般的可重复性也是如此。拥有一个正确的流程和*规则*来规定某个部署任务如何进行、何时进行或在哪里进行，是成功更新和团队成员通宵修复问题之间的分水岭。
- en: It’s manual
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是手动的
- en: The last point, which goes without saying, is that it’s an incredibly manual
    process to sit at a terminal and run commands to deploy a configuration. In today’s
    world, engineers want to spend their time focusing on value-driven work, not putting
    out fires. In fact, that’s a huge reason why automation and repeatability exist
    in the first place. Engineers wanted to get their time back and stop working on
    mundane tasks. If you’re constantly deploying on your computer to an environment,
    you’re putting the “this is awful” back into manual work. Now, there are circumstances
    where you’d want to deploy from your localhost. For example, when I’m deploying
    to a dev environment or testing a new config for the first time, I’m not going
    to create a repeatable solution around it because I’m unsure whether it even works
    yet. However, once I know that it works and my initial dev testing is complete,
    I’ll automate the workflow.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点需要明确的是，在终端上运行命令来部署配置是一个非常手动的过程。在今天的世界里，工程师们希望花时间专注于价值驱动的工作，而不是解决问题。事实上，这正是自动化和可重复性存在的重要原因。工程师们希望节省时间，停止处理单调的任务。如果您经常在计算机上部署到环境中，那么您正在重复手动工作的“糟糕”体验。当然，有些情况下，您可能希望从
    localhost 部署。例如，当我部署到开发环境或第一次测试新配置时，我不会创建一个可重复使用的解决方案，因为我不确定它是否有效。然而，一旦我知道它有效并且我的初始开发测试完成，我将自动化工作流程。
- en: Going forward in this chapter, keep in mind that the reason why you want to
    think about deployment workflows is to mitigate as much of the three aforementioned
    points as possible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，继续前进时，请记住，思考部署工作流的原因是尽可能减少上述三点的影响。
- en: Helm charts
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm 图表
- en: The idea behind repeatable deployment strategies is to make your life easier,
    but with new strategies comes the need to learn about different methods of implementation.
    The first method to learn about is Helm charts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可重复部署策略的理念是为了让您的生活更轻松，但随着新策略的出现，您需要了解不同的实施方法。了解的第一种方法是 Helm 图表。
- en: Helm is an open source project originally created by DeisLabs and donated to
    the CNCF; the CNCF now maintains the project. The objective of Helm when it first
    came out was to provide engineers with a better way to manage all the Kubernetes
    Manifests created. Helm was built with Kubernetes in mind and it’s a tool and
    platform specifically for Kubernetes, so it’s the same YAML you’re used to, just
    packaged differently – literally just YAML. Kubernetes was meant to give you a
    way to declaratively deploy containerized apps. It wasn’t necessarily meant to
    give you a meaningful way to package a bunch of Kubernetes Manifests so you could
    use them together. That’s where Helm comes into play. In addition, Helm keeps
    a release history of all deployed charts. This means you could go back to a previous
    release if something went wrong.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 是一个开源项目，最初由 DeisLabs 创建，并捐赠给 CNCF；现在由 CNCF 维护该项目。Helm 最初发布时的目标是为工程师提供一种更好的方式来管理所有创建的
    Kubernetes Manifests。Helm 是为 Kubernetes 设计的工具和平台，所以它使用的仍然是您熟悉的 YAML，只是以不同的方式打包
    - 确切地说，只是 YAML。Kubernetes 的初衷是提供一种声明式地部署容器化应用程序的方法。它并非旨在为您提供一种有意义地打包一堆 Kubernetes
    Manifests 以便一起使用的方式。这就是 Helm 的作用所在。此外，Helm 还会保留所有已部署图表的发布历史记录。这意味着如果出现问题，您可以返回到先前的一个发布版本。
- en: In January 2016, the project merged with a GCS tool called Kubernetes Deployment
    Manager, and the project was moved under Kubernetes. Helm was promoted from a
    Kubernetes subproject to a CNCF project in June 2018.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年1月，该项目与名为 Kubernetes 部署管理器的 GCS 工具合并，并将项目移到 Kubernetes 之下。Helm 于2018年6月从
    Kubernetes 子项目晋升为 CNCF 项目。
- en: In short, Helm is a way to take a bunch of Kubernetes Manifests and package
    them up to be deployed like an application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Helm 是一种将一堆 Kubernetes Manifests 打包成应用程序并部署的方法。
- en: Using Helm charts
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Helm 图表
- en: 'Now that you know about Helm, let’s go ahead and dive into it from a hands-on
    perspective:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了 Helm，让我们从实践的角度深入了解它：
- en: 'The first thing that you’ll need to do is install Helm. Because it varies based
    on the operating system, you can find a few different installation methods here:
    [https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/).'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要安装 Helm。由于基于操作系统的不同，您可以在这里找到几种不同的安装方法：[https://helm.sh/docs/intro/install/](https://helm.sh/docs/intro/install/)。
- en: 'Once Helm is installed, find or create a directory in which you want your first
    Helm chart to exist. Preferably, this will be an empty directory:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Helm 后，请找到或创建一个目录，您希望您的第一个 Helm 图表存在于其中。最好是一个空目录：
- en: '[PRE0]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, go into that directory on your terminal.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，进入终端中的那个目录。
- en: 'In the new directory, run the following command to create a Helm chart:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新目录中，运行以下命令创建一个 Helm chart：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once you do that, you should see a directory structure similar to the following
    screenshot. In this case, the chart was called `newchart`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做，你应该会看到一个类似以下截图的目录结构。在这个例子中，chart 被命名为 `newchart`。
- en: '![Figure 6.1 – Helm chart'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – Helm chart'
- en: '](img/B19116_06_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_01.jpg)'
- en: Figure 6.1 – Helm chart
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – Helm chart
- en: If you open up the `templates` directory, you’ll see a bunch of examples for
    Deployments, Ingresses, and a lot more.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 `templates` 目录，你会看到一堆关于部署、Ingress 和其他很多内容的示例。
- en: '![Figure 6.2 – Example Helm'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 示例 Helm'
- en: '](img/B19116_06_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_02.jpg)'
- en: Figure 6.2 – Example Helm
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 示例 Helm
- en: If you open up `values.yaml`, you’ll see where you can start adding values that
    you want to pass into your templates.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打开 `values.yaml` 文件，你会看到可以开始添加你希望传递到模板中的值的位置。
- en: '![Figure 6.3 – Values file'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 值文件'
- en: '](img/B19116_06_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_03.jpg)'
- en: Figure 6.3 – Values file
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 值文件
- en: 'To deploy a Helm chart, run the following command:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要部署 Helm chart，请运行以下命令：
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To install the Helm chart, run the following command. The `.` symbol indicates
    the current directory, which is where the Helm chart exists:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装 Helm chart，请运行以下命令。` . ` 符号表示当前目录，即 Helm chart 所在的目录：
- en: '[PRE3]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Of course, this isn’t everything there is to know about Helm. In fact, there
    are literally entire books on Helm. The goal of this section was to get you on
    the right path.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是关于 Helm 所有的知识。实际上，关于 Helm 的书籍有很多。这一节的目标是让你走上正确的道路。
- en: Helm chart best practices
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Helm Chart 最佳实践
- en: 'The following is a list of best practices to follow in production when using
    Helm:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 Helm 在生产环境中遵循的最佳实践列表：
- en: When storing Helm charts, ensure that they’re set to be public or private as
    required. The last thing you want is to push a Helm chart to a registry that’s
    public-facing when it’s not supposed to be.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储 Helm Charts 时，确保根据需要将其设置为公开或私有。你最不希望的就是将 Helm chart 推送到本不该公开的公共注册表。
- en: Document what your charts do.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录你的 charts 做了什么。
- en: Ensure you store charts in source control.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保将 Charts 存储在源代码控制中。
- en: Always test Helm charts after a change is made.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在做出更改后，始终测试 Helm charts。
- en: Kustomize
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kustomize
- en: Helm and Kustomize are pretty similar but have some unique differences. One
    of the primary use cases of Helm is to have a `values.yaml` file to store values
    to pass into a Kubernetes Manifest. Kustomize has the same type of idea.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 和 Kustomize 很相似，但也有一些独特的差异。Helm 的一个主要用例是拥有一个 `values.yaml` 文件来存储要传递到 Kubernetes
    Manifest 的值。Kustomize 也有类似的概念。
- en: With Kustomize, you have a template, typically called a base. The base is the
    template that you want to use. It could be for a Kubernetes Deployment, Service,
    Pod, or anything else you’d like. The template is the literal base where your
    values get pushed into. Along with the template, you have a `kustomization.yaml`
    file, which tells Kustomize which templates to use. For example, let’s say you
    have a `deployment.yaml` and `service.yaml` file. You would put those two filenames
    into the `kustomization.yaml` file so Kustomize knows it should push values into
    those two files.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kustomize 时，你有一个模板，通常称为基础模板。这个基础模板是你想要使用的模板，可能是 Kubernetes 的部署、服务、Pod，或任何你想要的东西。模板就是你传入值的实际基础。除了模板之外，你还有一个
    `kustomization.yaml` 文件，它告诉 Kustomize 使用哪些模板。例如，假设你有一个 `deployment.yaml` 和 `service.yaml`
    文件，你会将这两个文件名放入 `kustomization.yaml` 文件中，这样 Kustomize 就会知道应该将值推送到这两个文件中。
- en: '*Values* were mentioned a few times already, but not thoroughly explained.
    A value can be anything that you want to essentially pass in at runtime. For example,
    let’s say you have three environments – dev, staging, and prod. In dev, you have
    one replica. In staging, you have two replicas. In prod, you have three to four
    replicas. You can use Kustomize to pass those values into one template, so instead
    of having three Manifests that have different replica values, you have one template
    that you pass the values into.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*值*已经提到过几次，但没有彻底解释。值可以是你在运行时希望传递的任何内容。例如，假设你有三个环境——开发（dev）、预发布（staging）和生产（prod）。在开发环境中，你有一个副本；在预发布环境中，你有两个副本；在生产环境中，你有三个到四个副本。你可以使用
    Kustomize 将这些值传递到一个模板中，这样你就不需要拥有三个具有不同副本值的清单，而是通过一个模板来传递这些值。'
- en: But how do you pass in the values?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何传递这些值呢？
- en: Within a Kustomize directory, you typically have two directories – base and
    overlays. The base is where the template goes. The overlay directory is where
    each environment goes with specific values. For example, let’s say you have a
    `dev`, `staging`, and `prod` overlay.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kustomize目录中，通常有两个目录——base和overlays。base是模板存放的地方，overlay目录是每个环境存放特定值的地方。例如，假设你有`dev`、`staging`和`prod`等环境。
- en: '![Figure 6.4 – Base configuration'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 基础配置'
- en: '](img/B19116_06_04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_04.jpg)'
- en: Figure 6.4 – Base configuration
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 基础配置
- en: The `dev` overlay, along with the others, would have a `kustomization.yaml`
    file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`dev`覆盖目录，以及其他目录，都应包含一个`kustomization.yaml`文件。'
- en: '![Figure 6.5 – Dev overlay configuration'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.5 – 开发环境覆盖配置'
- en: '](img/B19116_06_05.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_05.jpg)'
- en: Figure 6.5 – Dev overlay configuration
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 开发环境覆盖配置
- en: Within the `kustomization.yaml` file is where you’d find the config for the
    replica count.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`kustomization.yaml`文件中，你可以找到副本数的配置。
- en: '![Figure 6.6 – Kustomization file'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.6 – Kustomization文件'
- en: '](img/B19116_06_06.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_06.jpg)'
- en: Figure 6.6 – Kustomization file
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – Kustomization文件
- en: Notice how the `resources` map is pointing to the `base` directory, and the
    `replicas` map is specifying the deployment along with the replica count.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`resources`映射指向的是`base`目录，`replicas`映射指定了部署以及副本数。
- en: The primary difference between Helm and Kustomize is that Helm’s primary purpose
    is to package up a bunch of Kubernetes Manifests and deploy them like an app,
    whereas the primary purpose of Kustomize is to have a template that you push your
    values into (such as the replica count). Helm does this as well, but it’s not
    the primary purpose of Helm.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Helm和Kustomize的主要区别在于，Helm的主要目的是将多个Kubernetes清单打包并像应用程序一样进行部署，而Kustomize的主要目的是拥有一个模板，将你的值（如副本数）推送进去。Helm也可以做到这一点，但这不是Helm的主要目的。
- en: Using Kustomize configurations
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Kustomize配置
- en: 'Now that you know about Kustomize, let’s dive into it from a hands-on perspective:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了Kustomize，让我们从实践的角度深入了解它：
- en: 'The first thing that you’ll need to do is install Kustomize. Because it varies
    based on the operating system, you can find a few different installation methods
    here: [https://kubectl.docs.kubernetes.io/installation/kustomize/](https://kubectl.docs.kubernetes.io/installation/kustomize/).'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要安装Kustomize。由于安装方法因操作系统而异，你可以在这里找到几种不同的安装方法：[https://kubectl.docs.kubernetes.io/installation/kustomize/](https://kubectl.docs.kubernetes.io/installation/kustomize/)。
- en: Once Kustomize is installed, find or create a new directory in which you want
    your Kustomize config to live. You can call it `kustomize`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完Kustomize后，找到或创建一个目录，存放你的Kustomize配置。你可以将其命名为`kustomize`。
- en: Create two new directories under the `kustomize` directory called `overlays`
    and `base`. Inside the `overlays` directory, create a new child directory called
    `dev`. It should look similar to the following screenshot.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`kustomize`目录下创建两个新目录，分别命名为`overlays`和`base`。在`overlays`目录下，创建一个名为`dev`的新子目录。它应该类似于以下截图所示。
- en: '![Figure 6.7 – Dev overlay configuration'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.7 – 开发环境覆盖配置'
- en: '](img/B19116_06_07.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_07.jpg)'
- en: Figure 6.7 – Dev overlay configuration
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 开发环境覆盖配置
- en: 'Inside the `base` directory, create a new file called `deployment.yaml` and
    paste the following code into it:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`base`目录下，创建一个名为`deployment.yaml`的新文件，并将以下代码粘贴进去：
- en: '[PRE4]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, create a new file in the `base` directory called `kustomization.yaml`
    and paste the following configuration into it, which tells Kustomize which Kubernetes
    Manifest to utilize:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`base`目录下创建一个名为`kustomization.yaml`的新文件，并将以下配置粘贴进去，告诉Kustomize使用哪个Kubernetes清单：
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For the last step, inside of `overlays` | `dev`, create a new file, call it
    `kustomization.yaml`, and paste the following Manifest into it:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，在`overlays` | `dev`目录下创建一个新文件，命名为`kustomization.yaml`，并将以下清单粘贴进去：
- en: '[PRE27]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Once the directories and configurations are in place, `cd` into the `base`
    | `dev` directory and run the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置和目录准备好后，`cd`进入`base` | `dev`目录并运行以下命令：
- en: '[PRE34]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You’ll see an output similar to the following screenshot, which gives you a
    config with one replica, instead of two, which is what the template contains.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下截图的输出，它为你提供了一个副本数为1的配置，而不是模板中包含的2个副本。
- en: '![Figure 6.8 – Kustomize output'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.8 – Kustomize输出'
- en: '](img/B19116_06_08.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_08.jpg)'
- en: Figure 6.8 – Kustomize output
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – Kustomize输出
- en: As with Helm charts, the topic of Kustomize could fill a small book itself,
    which means this section couldn’t cover it all. It should, however, get you started
    in the right direction.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与Helm图表一样，Kustomize的主题可以写成一本小书，这意味着本节内容无法涵盖所有内容。然而，它应该能帮助你朝着正确的方向迈出第一步。
- en: Kustomize best practices
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kustomize最佳实践
- en: 'The following is a list of best practices to follow in production when using
    Kustomize:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用Kustomize时在生产环境中应遵循的最佳实践清单：
- en: Ensure that you put overlays into their own directories. You don’t have to do
    this, but it makes for a much cleaner config.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保将`overlays`放入各自的目录中。你不必这样做，但这样可以使配置更整洁。
- en: Ensure that all code is stored in source control.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有代码都存储在源代码控制中。
- en: Follow a standard directory structure – `base` for the directory where the template
    goes and `overlays` for values that you wish to pass into the template.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循标准目录结构——`base`是模板所在的目录，`overlays`是你希望传递给模板的值。
- en: In the next section, you’ll learn about the two primary deployment methods when
    it comes to containerized apps.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习关于容器化应用的两种主要部署方法。
- en: Deploying with CI/CD and GitOps
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CI/CD和GitOps进行部署
- en: 'Kubernetes deployments come in three stages:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes部署分为三个阶段：
- en: Deploying Manifests on your local computer
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地计算机上部署清单
- en: Deploying Manifests with an automated solution such as CI/CD, which ultimately
    just runs `kubectl apply -f` commands, the same as your local computer
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动化解决方案（如CI/CD）部署清单，最终只会运行`kubectl apply -f`命令，和你本地计算机上的操作相同
- en: A new and completely automated solution that’s (usually) 100% hands-off from
    a deployment perspective
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种全新的、完全自动化的解决方案，从部署角度来看，它（通常）是100%免操作的
- en: With the first stage, it wasn’t scalable at all. A bunch of engineers were running
    commands on their localhost to deploy a containerized app, and they were all doing
    it in different ways with different code editors and different plugins. It was
    a mess and didn’t allow scalability for the deployment process. It also held engineers
    up from doing value-driven work and instead, they had to sit on their terminals
    and run commands all day.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，它根本不可扩展。一堆工程师在自己的本地机器上运行命令来部署一个容器化应用，而且每个人的做法都不一样，使用不同的代码编辑器和插件。那是一团糟，无法支持部署过程的扩展性，也阻碍了工程师们进行价值驱动的工作，反而他们不得不整天呆在终端上运行命令。
- en: In this section, you’ll learn about more common, automated, and new approaches
    to deploying apps, which will be around CI/CD and GitOps.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习更多常见的、自动化的以及新的应用部署方法，这些方法主要围绕CI/CD和GitOps展开。
- en: What is CI/CD?
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是CI/CD？
- en: When it comes to CI/CD, it’s assumed that if you’re reading this book, you’re
    already doing work in CI/CD and know what it is. Because of that, there won’t
    be an entire breakdown of CI/CD. Let’s do a brief overview.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI/CD方面，假设你正在阅读这本书，你已经在CI/CD中工作并知道它是什么。因此，本书不会对CI/CD进行全面的拆解，而是提供一个简要概述。
- en: By definition, CI/CD is a way to create an artifact of your application and
    deploy it to the desired destination in an automated fashion. As CI/CD increased
    in popularity, engineers started using it for other purposes – for example, packaging
    up Terraform code into an artifact and running it so infrastructure can be created
    automatically.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 从定义上讲，CI/CD是一种创建应用程序工件并将其自动化地部署到目标目的地的方法。随着CI/CD的普及，工程师们开始将其用于其他目的——例如，将Terraform代码打包成工件并运行，以便自动创建基础设施。
- en: 'In the CI process, engineers are worried about the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI过程中，工程师们关注以下问题：
- en: Testing code
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码
- en: Packaging up code
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包代码
- en: Ensuring that all prerequisites and dependencies are met
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有前提条件和依赖项都已满足
- en: Building container images
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: 'In the CD process, engineers are worried about the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在CD过程中，工程师们关注以下问题：
- en: Deploying workloads
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署工作负载
- en: Ensuring that they reached the correct destination
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保它们到达正确的目的地
- en: Ensuring that the app or services and infrastructure are up and running as expected
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保应用或服务和基础设施按预期启动并运行
- en: Using CI/CD for Kubernetes deployments
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CI/CD进行Kubernetes部署
- en: As with everything else in tech, there are what feels like a million ways to
    do one thing. Because of that, we cannot specify every CI/CD, automation, and
    cloud scenario here. To make things simplistic, Terraform code for GKE and YAML
    pipelines for GitHub Actions will be shown. This is considered pseudocode, but
    it’ll actually work in the right environments.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他技术一样，几乎每件事都有成千上万种方式可以做。因此，我们不能在这里列出每种 CI/CD、自动化和云场景。为了简化起见，本文将展示 GKE 的 Terraform
    代码和 GitHub Actions 的 YAML 流水线。这被视为伪代码，但它在正确的环境中是可以工作的。
- en: 'First, let’s start with the Terraform code and break it down:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从 Terraform 代码开始，并逐步拆解：
- en: 'You’ll start with the Google provider, specifying the region:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你将从 Google 提供者开始，指定区域：
- en: '[PRE35]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, `google_container_cluster` will be specified so you can implement the
    VPC you want to use, subnet, and worker node count:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，指定`google_container_cluster`，以便你可以实现你想要使用的 VPC、子网和工作节点数量：
- en: '[PRE39]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The last resource is for `google_container_node_pool`, which implements the
    needed Google APIs for GKE, the node count, node names, and node size or type:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个资源是`google_container_node_pool`，它实现了 GKE 所需的 Google API，包括节点数量、节点名称和节点大小或类型：
- en: '[PRE47]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With the Terraform code, you’ll want a way to deploy it. The best way in today’s
    world is with CI/CD. When it comes to deploying infrastructure and services, CI/CD
    is a great and repeatable process.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 代码时，你需要一种部署方法。在当今的世界里，最好的方法是使用 CI/CD。谈到基础设施和服务的部署，CI/CD 是一种非常好且可重复的过程。
- en: To deploy the code, you can use any CI/CD platform of your choosing, but the
    code here is an example of how you can deploy the Terraform code via GitHub Actions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署代码，你可以使用任何你选择的 CI/CD 平台，但这里的代码是如何通过 GitHub Actions 部署 Terraform 代码的示例。
- en: 'The pipeline does the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线执行以下操作：
- en: Specifies `workflow_dispatch`, which means the code will only run if you click
    the `Deployment` button
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定`workflow_dispatch`，这意味着代码只有在你点击`Deployment`按钮时才会运行
- en: Uses an Ubuntu container to run the pipeline
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ubuntu 容器运行流水线
- en: Checks out the code (clones it) to the Ubuntu container
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码（克隆）签出到 Ubuntu 容器中
- en: Configures Terraform in the Ubuntu container
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 容器中配置 Terraform
- en: Configures the GCP SDK in the Ubuntu container
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 容器中配置 GCP SDK
- en: 'Runs `terraform init`, and formats, plans, and applies it to the directory
    where the GKE code lives:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`terraform init`，并将其格式化、规划并应用到 GKE 代码所在的目录：
- en: '[PRE67]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: When using CI/CD, it makes the most sense to use it in this type of way for
    Kubernetes. You rarely ever want to use CI/CD to deploy a Kubernetes Manifest
    and instead, you’d want to use something such as a GitOps solution, as it’s far
    more efficient, manages the state, monitors the workloads, and a lot more.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CI/CD 时，最合理的方式是在 Kubernetes 中使用它。你几乎不会用 CI/CD 来部署 Kubernetes 清单，而是想使用像 GitOps
    这样的解决方案，因为它更高效，管理状态，监控工作负载，等等。
- en: What is GitOps?
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 GitOps？
- en: By definition, GitOps is a set of tools that utilizes Git repositories as a
    source of truth to deliver Kubernetes resources as code. It’s an operational best
    practice used for app development, collaboration, compliance, and CI/CD, and applies
    the best practices to infrastructure automation. Now, let’s see a simpler explanation.
    It’s configuration management for Kubernetes; that’s it, plain and simple. Configuration
    management is all about ensuring that the desired state is the current state,
    which is what GitOps gives us.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义，GitOps是一组工具，利用 Git 仓库作为可信来源，以代码的形式交付 Kubernetes 资源。它是应用开发、协作、合规和 CI/CD
    的最佳操作实践，并将最佳实践应用于基础设施自动化。现在，让我们来看一个更简单的解释。这就是 Kubernetes 的配置管理，仅此而已，简单明了。配置管理就是确保所需状态与当前状态一致，而这正是
    GitOps 提供给我们的。
- en: Now that you know the definition of GitOps, let’s talk about what it actually
    does for Kubernetes. First things first, you have a source control repository.
    The repository contains your Kubernetes manifests that you wish to deploy to Kubernetes
    to run your applications. You also have a Kubernetes cluster, which is running
    on any environment you’d like. It could be on-premises, in a raw Kubernetes cluster,
    or even in a cloud-based service such as GKE or EKS. Now, you have the Kubernetes
    Manifests that you want to run in your production environment and the Kubernetes
    cluster that you want to run the Kubernetes manifests on, but how do you deploy
    them? The typical way is running something such as `kubectl apply -f` against
    the Kubernetes manifests, but that requires manual effort and leaves a lot to
    be desired. Instead, you can implement GitOps. To implement GitOps, there are
    a few solutions. You decide to implement a GitOps solution, and that GitOps solution
    needs access to both the Kubernetes cluster that you’re running and the source
    control system, such as GitHub or any other Git system where your source code
    is stored. To do that, you install the GitOps solution on the Kubernetes cluster
    and while doing that, you give the GitOps solution access to your source control
    system with some type of `kubectl apply -f` or `kubectl create -f` anymore. Instead,
    you’re using the CLI or whatever other solution comes with the GitOps platform
    to deploy the Kubernetes Manifests – and boom, just like that, you have an application
    deployed! Now, of course, we all wish it were that easy. A couple of sentences
    to explain and poof, you’re up and running in a production environment. However,
    it’s not that simple, which is why GitOps is in such high demand and isn’t the
    easiest thing to crack.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 GitOps 的定义，让我们来讨论它到底对 Kubernetes 做了什么。首先，你有一个源代码控制库。该库包含你希望部署到 Kubernetes
    上运行应用程序的 Kubernetes 清单。你还有一个 Kubernetes 集群，它可以运行在你喜欢的任何环境中。它可以是本地部署的、原始 Kubernetes
    集群，甚至可以是基于云的服务，如 GKE 或 EKS。现在，你有了希望在生产环境中运行的 Kubernetes 清单，以及你希望在其上运行 Kubernetes
    清单的 Kubernetes 集群，那么如何部署它们呢？传统的方式是使用类似 `kubectl apply -f` 的命令针对 Kubernetes 清单进行操作，但这需要手动操作，并且存在很多不足之处。相反，你可以实施
    GitOps。要实施 GitOps，有几种解决方案。你决定实现一个 GitOps 解决方案，而这个 GitOps 解决方案需要访问你正在运行的 Kubernetes
    集群以及源代码控制系统，例如 GitHub 或任何其他存储源代码的 Git 系统。为此，你需要在 Kubernetes 集群上安装 GitOps 解决方案，同时将
    GitOps 解决方案与源代码控制系统连接，并进行一些类型的 `kubectl apply -f` 或 `kubectl create -f` 操作。你不再需要手动执行这些命令，而是通过
    CLI 或 GitOps 平台提供的其他解决方案来部署 Kubernetes 清单——而且“砰”的一声，你就完成了应用程序的部署！当然，我们都希望它能这么简单。几句话解释一下，啪嗒一下，你就能在生产环境中运行了。然而，事实并没有那么简单，这也是为什么
    GitOps 需求如此高，并且它并不是那么容易实现的原因。
- en: At the time of writing this, the most popular GitOps platforms are **ArgoCD**
    and Flux.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最流行的 GitOps 平台是**ArgoCD**和 Flux。
- en: Using GitOps for automated deployments
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GitOps 进行自动化部署
- en: Knowing the process to create the Kubernetes infrastructure, you can now deploy
    and manage a containerized app using GitOps. To follow this section, you’ll need
    a Kubernetes environment up and running, as ArgoCD will be deployed to the cluster.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了创建 Kubernetes 基础设施的过程后，你现在可以使用 GitOps 部署和管理容器化应用程序了。要完成本节内容，你需要有一个正在运行的 Kubernetes
    环境，因为 ArgoCD 将被部署到该集群中。
- en: This section is going to be more of a step-by-step guide because regardless
    of where you’re running Kubernetes, these are the steps to get ArgoCD up and running.
    Unlike with the CI/CD section, there aren’t tons of different platforms, cloud
    environments, or configuration code choices that can come into play, and because
    of that, the following solution can work in any environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将提供一个更为详细的步骤指南，因为无论你在什么地方运行 Kubernetes，以下步骤都可以帮助你启动 ArgoCD。与 CI/CD 部分不同，这里没有大量不同的平台、云环境或配置代码选择，因此，以下解决方案可以在任何环境中使用。
- en: Configuring ArgoCD
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 ArgoCD
- en: 'First, create a namespace for ArgoCD in your Kubernetes cluster:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的 Kubernetes 集群中为 ArgoCD 创建一个命名空间：
- en: '[PRE68]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Install ArgoCD using the preconfigured Kubernetes Manifest from ArgoCD that
    provides a highly available installation:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用来自 ArgoCD 的预配置 Kubernetes 清单安装 ArgoCD，该清单提供了一个高度可用的安装：
- en: '[PRE69]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '![Figure 6.9 – ArgoCD creation output'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 6.9 – ArgoCD 创建输出'
- en: '](img/B19116_06_09.jpg)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B19116_06_09.jpg)'
- en: Figure 6.9 – ArgoCD creation output
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – ArgoCD 创建输出
- en: 'Get the initial admin password to log in to ArgoCD:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 ArgoCD 的初始管理员密码以便登录：
- en: '[PRE70]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Open up ArgoCD’s UI via Kubernetes port forwarding. That way, you can access
    the frontend of ArgoCD without having to attach a load balancer to the service:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 Kubernetes 端口转发打开 ArgoCD 的界面。这样，您可以访问 ArgoCD 的前端，而无需将负载均衡器附加到服务上：
- en: '[PRE71]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Now that you know the UI works, log in to the server via the CLI. That way,
    you can deploy containerized apps with ArgoCD via the CLI to create a repeatable
    process instead of doing it through the UI, which is manual and repetitive.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您知道 UI 可用，登录到服务器通过 CLI。这样，您可以通过 CLI 使用 ArgoCD 部署容器化应用程序，创建一个可重复的过程，而不是通过 UI
    执行，因为 UI 操作是手动且重复的。
- en: '![Figure 6.10 – ArgoCD portal'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.10 – ArgoCD 门户'
- en: '](img/B19116_06_10.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_10.jpg)'
- en: Figure 6.10 – ArgoCD portal
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – ArgoCD 门户
- en: 'The port is what ArgoCD is hosting from the `kubectl port-forward` command
    that you ran in the previous step. Use the following command to log in to ArgoCD:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 端口是 ArgoCD 从您在上一步中运行的 `kubectl port-forward` 命令中托管的端口。使用以下命令登录 ArgoCD：
- en: '[PRE72]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![Figure 6.11 – Login output'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.11 – 登录输出'
- en: '](img/B19116_06_11.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_11.jpg)'
- en: Figure 6.11 – Login output
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 登录输出
- en: In the Argo CD UI, go to **User Info** | **Update Password**. Change the password
    from the initial admin password to a password of your choosing.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Argo CD 界面中，前往 **用户信息** | **更新密码**。将密码从初始的管理员密码更改为您选择的密码。
- en: You now have officially deployed ArgoCD and have the ability to work with the
    GitOps platform on your terminal and locally on your computer.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经正式部署了 ArgoCD，并且可以在终端和本地计算机上与 GitOps 平台进行交互。
- en: Deploying an app
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: 'In this section, you’re going to deploy an app. The app that you’ll use is
    a very popular demo-related app that a lot of folks use to showcase how an environment
    will work:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将部署一个应用程序。您将使用的应用程序是一个非常流行的示范应用，许多人用它来展示一个环境如何工作：
- en: 'Create a namespace for your new app:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的新应用程序创建一个命名空间：
- en: '[PRE73]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The Sock Shop is a popular microservice demo that you can find here: [https://microservices-demo.github.io/deployment/kubernetes-start.html](https://microservices-demo.github.io/deployment/kubernetes-start.html).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Sock Shop 是一个流行的微服务示范应用，您可以在这里找到它：[https://microservices-demo.github.io/deployment/kubernetes-start.html](https://microservices-demo.github.io/deployment/kubernetes-start.html)。
- en: 'Deploy the Sock Shop in ArgoCD. To deploy the app, you will need to do the
    following:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 ArgoCD 中部署 Sock Shop。要部署该应用程序，您需要执行以下操作：
- en: Create a new ArgoCD app.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 ArgoCD 应用程序。
- en: Point to the repo where the app exists.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向应用程序所在的仓库。
- en: Point to the destination server, which is the server or service that you’re
    running Kubernetes on.
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指向目标服务器，即运行 Kubernetes 的服务器或服务。
- en: 'Specify the destination namespace:'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定目标命名空间：
- en: '[PRE74]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now that the app is deployed, you can check the status of the app:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应用程序已经部署，您可以检查应用程序的状态：
- en: '[PRE75]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '![Figure 6.12 – Sock Shop resources'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.12 – Sock Shop 资源'
- en: '](img/B19116_06_12.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_12.jpg)'
- en: Figure 6.12 – Sock Shop resources
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – Sock Shop 资源
- en: You can now check that the app was deployed in the ArgoCD UI.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以检查应用程序是否已在 ArgoCD 界面中部署。
- en: '![Figure 6.13 – Sock Shop app connection'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.13 – Sock Shop 应用程序连接'
- en: '](img/B19116_06_13.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_13.jpg)'
- en: Figure 6.13 – Sock Shop app connection
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – Sock Shop 应用程序连接
- en: You’ll see the health of the app, whether it’s synced, and whether the status
    of the application is as expected.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到应用程序的健康状况、是否同步，以及应用程序的状态是否符合预期。
- en: Production use cases for CI/CD and GitOps
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD 和 GitOps 的生产使用案例
- en: 'Two ways to think about CI/CD and GitOps in production are as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中考虑 CI/CD 和 GitOps 的两种方式如下：
- en: CI/CD should be used to deploy the cluster
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI/CD 应用于部署集群。
- en: GitOps should be used to manage the Kubernetes resources inside the cluster
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps 应用于管理集群内部的 Kubernetes 资源。
- en: In other words, CI/CD deploys the infrastructure and clusters and GitOps deploys
    and manages the apps. Use the best tool for the job, which is the infrastructure
    deployment type of workflow.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，CI/CD 部署基础设施和集群，而 GitOps 部署并管理应用程序。使用最适合的工具进行工作，这就是基础设施部署类型的工作流程。
- en: Regardless of which GitOps and CI/CD solution you use, you always want to keep
    in mind that your goal is to automate and create repeatable workflows that work
    for you and your team. Regardless of what *hot* tool or platform is out right
    now, you want to use what’s best for your team, not whatever is the *new thing*.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪种 GitOps 和 CI/CD 解决方案，您始终要记住，目标是自动化并创建对您和您的团队有效的可重复工作流程。无论现在是什么 *热门* 工具或平台，您都要使用最适合您团队的工具，而不是追随
    *新兴事物*。
- en: In the next section, you’ll dive into multiple methods of troubleshooting containerized
    apps running in your Kubernetes cluster.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将深入了解在 Kubernetes 集群中运行的容器化应用程序的多种故障排除方法。
- en: Troubleshooting application deployments
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障排除应用程序部署
- en: 'Troubleshooting environments and applications typically always looks the same
    and follows a typical order:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除环境和应用程序通常总是看起来相似，并遵循典型的顺序：
- en: When was the last deployment?
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上次部署是什么时候？
- en: What has changed?
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生了什么变化？
- en: Look at the logs
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看日志
- en: Who can access the app and who cannot, if anyone at all?
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谁可以访问这个应用，谁不能访问，如果有的话？
- en: 'With Kubernetes, it’s pretty similar when it comes to application troubleshooting.
    The usual workflow is as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Kubernetes，应用程序故障排除也非常相似。通常的工作流程如下：
- en: Check the app itself running in the container.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查容器中运行的应用程序。
- en: Check the overall health of the Pod(s).
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查 Pod(s) 的整体健康状态。
- en: Check the Service or route.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查服务或路由。
- en: With these three steps, you can usually get to the bottom of what’s happening
    because, in reality, there can’t be any other problems. It’s either that the app
    itself isn’t working, the Pod itself has an issue, or the service or route isn’t
    working as expected.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这三个步骤，你通常可以找出发生了什么问题，因为实际上，其他问题不可能存在。要么是应用本身没有工作，要么是 Pod 本身有问题，要么是服务或路由没有按预期工作。
- en: Although there could only be three potential problems at a high level, when
    you dive deeper into those problems, there could be various ways to troubleshoot
    the current issue you’re facing, which you’ll learn about in this section.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从高层次来看，可能只有三个潜在问题，但当你深入探讨这些问题时，可能会有多种方式来排除你当前遇到的故障，你将在本节中了解这些方法。
- en: 'As with all troubleshooting techniques, you should think about it in the following
    order:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有故障排除技术一样，你应该按以下顺序考虑问题：
- en: What’s the problem?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题是什么？
- en: What’s changed?
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有什么变化吗？
- en: What could be the problem in the problem? As in, a Pod may be down, but it might
    not be because of the app. It could be because of a problem with the replication
    controller.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题可能出在哪里？也就是说，Pod 可能出现故障，但它可能不是因为应用程序的问题。它可能是由于复制控制器的问题。
- en: Troubleshooting Pods
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除 Pods
- en: 'The two commands that’ll help you debug Pods are as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是帮助你调试 Pods 的两个命令：
- en: '`kubectl describe`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl describe`'
- en: '`kubectl logs`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl logs`'
- en: 'Take the following Kubernetes Manifest and deploy it. Notice how, for the container
    tag, it’s spelled as `lates`. That’s on purpose, as you want the container to
    fail:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 Kubernetes Manifest 并进行部署。注意，容器标签拼写为 `lates`。这是故意为之，因为你希望容器失败：
- en: '[PRE76]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Retrieve the name of the Pod with the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令获取 Pod 的名称：
- en: '[PRE77]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'You’ll see an output similar to the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下的输出：
- en: '![Figure 6.14 – Error container image pull'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.14 – 容器镜像拉取错误'
- en: '](img/B19116_06_14.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_14.jpg)'
- en: Figure 6.14 – Error container image pull
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – 容器镜像拉取错误
- en: Notice how, right off the bat, you can start the troubleshooting process. The
    status states that there was an error pulling the image. Now you know that there’s
    an issue with the image, let’s dive a bit deeper.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一开始你就可以开始故障排除过程。状态显示拉取镜像时出错。现在你知道问题出在镜像上，接下来我们可以更深入地探讨。
- en: 'Run the following command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE78]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You’ll see an output similar to the following screenshot:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下的屏幕截图输出：
- en: '![Figure 6.15 – Pod description'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.15 – Pod 描述'
- en: '](img/B19116_06_15.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_15.jpg)'
- en: Figure 6.15 – Pod description
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – Pod 描述
- en: The great thing about the `describe` command is that it gives you a log output
    underneath the `Events` section. You can now see that the issue is that it couldn’t
    pull the container image based on the name and tag that you gave.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe` 命令的一个优点是，它会在 `Events` 部分下方显示日志输出。你现在可以看到问题出在它无法根据你提供的名称和标签拉取容器镜像。'
- en: 'The last step would be to run the `logs` command to see whether there’s any
    other data you can use:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是运行 `logs` 命令，查看是否有其他数据可以使用：
- en: '[PRE79]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![Figure 6.16 – Pod logs'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.16 – Pod 日志'
- en: '](img/B19116_06_16.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_16.jpg)'
- en: Figure 6.16 – Pod logs
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – Pod 日志
- en: You can see from the screenshot here that there isn’t much more to go off of
    other than what was given in the `describe` command, so the troubleshooting has
    been successfully completed.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里的屏幕截图可以看到，除了 `describe` 命令提供的信息外，几乎没有更多线索，因此故障排除已成功完成。
- en: Troubleshooting Services
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除服务
- en: 'When troubleshooting Services, the first thing that you always want to confirm
    is whether the Service exists. If you don’t have a Service running in a Kubernetes
    cluster, you can use this example Manifest:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在故障排除服务时，首先要确认的是服务是否存在。如果在 Kubernetes 集群中没有运行服务，你可以使用这个示例清单：
- en: '[PRE80]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Because Pod networks are separate from a host network, you’ll need a Pod to
    exec or SSH into so you can do the troubleshooting. The following is a command
    that you can use to configure a Pod for troubleshooting purposes based on a `busybox`
    container image, which is a popular image used for troubleshooting purposes:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Pod 网络与主机网络是分开的，你需要有一个 Pod 来执行或通过 SSH 进入，以便进行故障排除。以下是你可以使用的命令，用于基于 `busybox`
    容器镜像配置一个用于故障排除的 Pod，这是一种常用于故障排除的镜像：
- en: '[PRE81]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'First, see whether the service is running. You’ll do this outside of the `busybox`
    container image:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看服务是否正在运行。你将在 `busybox` 容器镜像外部执行此操作：
- en: '[PRE82]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: You should get the following output.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到以下输出。
- en: '![Figure 6.17 – Service configuration'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.17 – 服务配置'
- en: '](img/B19116_06_17.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_17.jpg)'
- en: Figure 6.17 – Service configuration
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 服务配置
- en: 'If the service is running, confirm that you can reach the service via DNS:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务正在运行，请确认你可以通过 DNS 访问该服务：
- en: '[PRE83]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You’ll see an output similar to the following configuration:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似于以下配置的输出：
- en: '![Figure 6.18 – nslookup of Pod'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.18 – Pod 的 nslookup'
- en: '](img/B19116_06_18.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_18.jpg)'
- en: Figure 6.18 – nslookup of Pod
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.18 – Pod 的 nslookup
- en: 'If the standard `nslookup` command doesn’t work, or if you want another type
    of confirmation, try an FQDN:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果标准的 `nslookup` 命令无效，或者你需要其他类型的确认，请尝试 FQDN：
- en: '[PRE84]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: You’ll see an output similar to the following screenshot.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似于以下截图的输出。
- en: '![Figure 6.19 – FQDN service lookup'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.19 – FQDN 服务查找'
- en: '](img/B19116_06_19.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_19.jpg)'
- en: Figure 6.19 – FQDN service lookup
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.19 – FQDN 服务查找
- en: 'Check to confirm that the service is defined correctly:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 检查并确认服务是否正确定义：
- en: '[PRE85]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You’ll see an output similar to the following screenshot.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似于以下截图的输出。
- en: '![Figure 6.20 – JSON output of service'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.20 – 服务的 JSON 输出'
- en: '](img/B19116_06_20.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_20.jpg)'
- en: Figure 6.20 – JSON output of service
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.20 – 服务的 JSON 输出
- en: 'Check that the service has endpoints – as in, confirm that there are Pods that
    the service is pointing to:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 检查服务是否有端点——即确认服务指向的 Pods 是否存在：
- en: '[PRE86]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You’ll see an output similar to the following screenshot:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似于以下截图的输出：
- en: '![Figure 6.21 – Retrieving Pods based on label'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.21 – 基于标签检索 Pods'
- en: '](img/B19116_06_21.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_21.jpg)'
- en: Figure 6.21 – Retrieving Pods based on label
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.21 – 基于标签检索 Pods
- en: 'Finally, which should already be known, but just in case, check to confirm
    that the Pods that the service is pointing to are working:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，虽然应该已经知道，但为了保险起见，检查并确认服务指向的 Pods 是否正常工作：
- en: '[PRE87]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The final piece, which you’ll learn about in the next section, is implementing
    a service mesh for troubleshooting. A service mesh has several jobs, and one of
    the jobs is making it easier to troubleshoot latency issues between Services,
    along with ensuring that Services are working as expected.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分，你将在下一节中学习到，它涉及到实现服务网格以进行故障排除。服务网格有几个功能，其中一个功能是简化服务之间延迟问题的故障排除，同时确保服务按预期运行。
- en: Troubleshooting Deployments
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除部署
- en: 'The primary command that’ll help you debug Deployments is similar to Pod debugging:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助你调试部署的主要命令类似于调试 Pods：
- en: '`kubectl` `describe deployment`'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` `describe deployment`'
- en: Unless there’s something wrong with the Deployment controller itself, there
    usually isn’t a problem with the actual Deployment. It’s typically a problem with
    the Pods running inside of the Deployment. However, you still may want to check
    the Deployment itself.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 除非 Deployment 控制器本身有问题，否则通常不会出现实际的 Deployment 问题。通常是部署内的 Pods 存在问题。然而，你仍然可能需要检查
    Deployment 本身。
- en: 'To do that, you would run the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你需要运行以下命令：
- en: '[PRE88]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'You should get an output similar to the following screenshot:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到类似于以下截图的输出：
- en: '![Figure 6.22 – Describing the nginx Deployment'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.22 – 描述 nginx 部署'
- en: '](img/B19116_06_22.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_22.jpg)'
- en: Figure 6.22 – Describing the nginx Deployment
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.22 – 描述 nginx 部署
- en: The goal of the `describe` command isn’t to tell you about logs or events or
    what’s happening – it’s to help you fully understand what’s deployed and how it’s
    deployed. That way, you can backtrack and see whether what’s deployed is actually
    supposed to be there.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`命令的目标不是告诉你日志、事件或发生了什么——而是帮助你完全理解已部署的内容及其部署方式。这样，你就可以追溯并查看部署的内容是否是实际应该存在的。'
- en: In the next section, we’ll wrap up this chapter by talking about what a service
    mesh is, what an Ingress is, and how to think about implementing them.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将通过讨论什么是服务网格，什么是 Ingress，以及如何思考实施它们来总结本章内容。
- en: Service meshes and Ingresses
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务网格和 Ingress
- en: Almost every containerized application needs to be routed in one way or another
    – whether it’s so outside users can use the application, applications can talk
    to each other, or one application needs to connect to another. Routes and Services
    are extremely important in Kubernetes, which is why service meshes and Ingresses
    play a huge part.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个容器化应用程序都需要以某种方式进行路由——无论是让外部用户使用应用程序、应用程序之间进行通信，还是一个应用程序需要连接到另一个应用程序。在 Kubernetes
    中，路由和服务至关重要，这也是服务网格和 Ingress 在其中发挥巨大作用的原因。
- en: In many cases, you’ll need better visuals into what’s happening with services,
    how traffic is being routed, and what applications are routing to which load balancers
    and IP addresses. You’ll also eventually want a way to encrypt traffic between
    services, which Kubernetes doesn’t give you out of the box.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你需要更好地可视化服务的运行状况、流量是如何路由的，以及应用程序如何路由到不同的负载均衡器和 IP 地址。你最终还需要一种加密服务间流量的方式，而
    Kubernetes 默认并不提供。
- en: Service meshes and Ingresess are typically more advanced-level topics, but in
    this book and possibly at this stage in your career, you’ll be ready to dive in
    and fully understand the pros and cons of using these two tools, plugins, and
    platforms.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格和 Ingress 通常是更高级的主题，但在本书中，也许在你职业生涯的这个阶段，你已经准备好深入了解并完全理解使用这两个工具、插件和平台的优缺点。
- en: Why Ingress?
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要 Ingress？
- en: At this point in your Kubernetes journey, it’s almost certain that you’ve seen
    a Kubernetes Service. In fact, you’ve seen them throughout this book. A lot of
    the time, a Kubernetes Service comes with a frontend app that’s attached to it,
    in which you need a way for users to interact with the Kubernetes Service. It’s
    typically in front of a load balancer.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 之旅的这一阶段，你几乎可以确定已经见过 Kubernetes 服务。事实上，你在本书中已经多次见到它们。很多时候，Kubernetes
    服务会附带一个前端应用，需要为用户提供与 Kubernetes 服务交互的方式。它通常位于负载均衡器前面。
- en: 'The problem with that is if you have a load balancer in front of your service,
    you have to do the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的问题在于，如果你在服务前面有负载均衡器，则需要执行以下操作：
- en: Pay extra for the cloud load balancer if you’re using a cloud Kubernetes service
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是云 Kubernetes 服务，则需要额外支付云负载均衡器的费用
- en: Set up a virtual load balancer if you’re using an on-premises Kubernetes cluster
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是本地 Kubernetes 集群，则需要设置虚拟负载均衡器
- en: Have a bunch of load balancers to manage
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要管理一堆负载均衡器
- en: With an Ingress controller, you don’t have to worry about that.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 Ingress 控制器，你就不必担心这个问题了。
- en: You can have several different Kubernetes Services and have an Ingress controller
    point to all of them, and each of the services can be reached by a different path.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以拥有多个不同的 Kubernetes 服务，并让 Ingress 控制器指向它们，且每个服务都可以通过不同的路径进行访问。
- en: Ingress controllers save time, money, management, and effort for engineers.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Ingress 控制器为工程师节省了时间、金钱、管理和精力。
- en: Using Ingresses
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Ingress
- en: Now that you know about Ingress controllers, let’s see how one can be configured
    using (at the time of writing) the most popular option, Nginx Ingress.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了 Ingress 控制器，让我们来看看如何使用（在撰写时）最流行的选项 Nginx Ingress 来配置它。
- en: 'First things first – you’ll need a Kubernetes Deployment and Service to deploy.
    If you don’t already have them and would like to keep things simple, you can use
    the following Kubernetes Manifest, which is a sample Azure app. It doesn’t have
    to be running in Azure to work:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个 Kubernetes 部署和服务来进行部署。如果你还没有这些，且希望保持简单，可以使用以下 Kubernetes 清单，它是一个示例
    Azure 应用。它不一定要在 Azure 上运行才可以工作：
- en: '[PRE89]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Once the app itself is deployed, you can deploy the Ingress controller. The
    Ingress controller is part of the native Kubernetes API set from the named group,
    so you don’t have to worry about installing other CRDs or controllers:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序本身部署完成，你就可以部署 Ingress 控制器。Ingress 控制器是 Kubernetes 原生 API 集的一部分，因此你无需担心安装其他
    CRD 或控制器：
- en: '[PRE90]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The last step is to forward to the port for the app’s service so you can reach
    the app locally:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的步骤是将端口转发到应用服务，以便你可以在本地访问该应用：
- en: '[PRE91]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You should get an output similar to the following screenshot:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能得到类似以下截图的输出：
- en: '![Figure 6.23 – Port-forwarding service communication'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.23 – 端口转发服务通信'
- en: '](img/B19116_06_23.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_23.jpg)'
- en: Figure 6.23 – Port-forwarding service communication
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.23 – 端口转发服务通信
- en: You should be able to reach out to the app over localhost.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够通过本地主机访问该应用。
- en: '![Figure 6.24 – AKS app'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.24 – AKS 应用'
- en: '](img/B19116_06_24.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B19116_06_24.jpg)'
- en: Figure 6.24 – AKS app
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.24 – AKS 应用
- en: Now that you know what an Ingress is from a theoretical and practical perspective,
    let’s move on to service meshes and look at how communication can occur more securely.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你从理论和实践的角度了解了什么是 Ingress，让我们继续探讨服务网格，并看看如何使通信更安全。
- en: Why service meshes?
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择服务网格？
- en: 'When you deploy containerized applications into a Kubernetes cluster, there
    are two primary ways that those applications communicate:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将容器化应用程序部署到 Kubernetes 集群时，有两种主要的通信方式：
- en: Services
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Pod-to-Pod communication
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 到 Pod 的通信
- en: Pod-to-Pod communication isn’t recommended because Pods are ephemeral, which
    means they aren’t permanent. They are designed to go down at any time and only
    if they were part of a StatefulSet would they keep any type of unique identifier.
    However, Pods still need to be able to communicate with each other. Backends need
    to talk to frontends, middleware needs to talk to backends and frontends, and
    so on.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 不推荐 Pod 到 Pod 的通信，因为 Pod 是短暂的，这意味着它们不是永久性的。它们设计为随时可能停止运行，只有当它们是 StatefulSet
    的一部分时，才会保留任何类型的唯一标识符。然而，Pod 仍然需要能够相互通信。后端需要与前端通信，中间件需要与后端和前端通信，等等。
- en: The next communication method, which is the primary, is service-to-service.
    Service-to-service is the preferred method because a Service isn’t ephemeral and
    only gets deleted if manually deleted. Pods can connect to Services with Selectors
    or Tags. If a Pod goes down, but the Selector in the Kubernetes Manifest that
    deployed the Pod doesn’t change, the new Pod will be connected to the Service.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 下一种通信方式，也是主要的通信方式，是服务到服务。服务到服务是首选方法，因为服务不是短暂的，只有在手动删除时才会被删除。Pod 可以通过选择器或标签连接到服务。如果一个
    Pod 停止运行，但部署该 Pod 的 Kubernetes 清单中的选择器没有改变，新的 Pod 将会连接到该服务。
- en: Here’s the primary concern with everything described so far – all this traffic
    is unencrypted. Pod-to-Pod communication, or as some people like to call it, East-West
    traffic, is unencrypted. That means if for any reason a Pod is compromised or
    you have some segregation issues, there’s nothing out of the box that you can
    do.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，所有描述的内容存在一个主要问题——所有的流量都是未加密的。Pod 到 Pod 的通信，或者有些人喜欢称之为东-西流量，都是未加密的。这意味着如果因为某种原因一个
    Pod 被攻破，或者你有一些隔离问题，默认情况下你无法采取任何措施。
- en: 'That’s where a service mesh comes into play. A service mesh has the ability
    to do the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是服务网格发挥作用的地方。服务网格具有以下功能：
- en: Encrypt traffic between microservices
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密微服务之间的流量
- en: Help with network latency troubleshooting
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助排查网络延迟问题
- en: Securely connect Kubernetes Services
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全连接 Kubernetes 服务
- en: Perform observability for tracing and alerting
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行可观察性以进行跟踪和警报
- en: Using a service mesh
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用服务网格
- en: Now that you know about a service mesh, let’s learn how to set one up. There
    are a ton of different service mesh platforms out there, all of which have their
    own method of being installed and configured.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了服务网格，让我们学习如何设置一个。市面上有很多不同的服务网格平台，它们各自有不同的安装和配置方法。
- en: Because it’s a complicated topic in itself, there’s no way to get through it
    all in this section. In fact, there are literal books for just service meshes.
    Let’s learn how to set up an Istio service mesh.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个复杂的话题，无法在这一部分全部讲解。事实上，关于服务网格有专门的书籍。让我们学习如何设置一个 Istio 服务网格。
- en: 'First, download Istio:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载 Istio：
- en: '[PRE92]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Next, export the path to the `$``PATH` variable:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，导出 `$PATH` 变量的路径：
- en: '[PRE93]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Output the `$PATH` variable int, `bashrc`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 输出 `$PATH` 变量到 `bashrc`：
- en: '[PRE94]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Install Istio on your Kubernetes cluster. Notice how Ingress is set to `false`.
    You can set it to `true` if you want to use the Istio Ingress. If you’re using
    another Ingress controller, such as Nginx Ingress, you can leave it as `false`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Kubernetes 集群上安装 Istio。注意，Ingress 设置为 `false`。如果你想使用 Istio Ingress，可以将其设置为
    `true`。如果你使用的是其他 Ingress 控制器，如 Nginx Ingress，可以将其保持为 `false`：
- en: '[PRE95]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Istio is a great service mesh but doesn’t have a UI out of the box. One of
    the most popular ways to look at your service mesh graphically is by using Kiali,
    which is a simple install:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 是一个优秀的服务网格，但开箱即用时没有 UI。查看服务网格图形化界面的一种流行方式是使用 Kiali，这是一种简单的安装方式：
- en: '[PRE96]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Set up port forwarding to Kiali so you can reach the UI locally:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 设置端口转发到 Kiali，以便你可以在本地访问 UI：
- en: '[PRE97]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The last step is to take a Kubernetes Manifest, like the one you used in this
    chapter, and inject the sidecar (the service mesh container) into your Kubernetes
    Deployment:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是获取一个 Kubernetes 清单，就像你在本章中使用的那样，并将 sidecar（服务网格容器）注入到你的 Kubernetes 部署中：
- en: '[PRE98]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: At this point, you now have the theoretical grounding and a bit of hands-on
    knowledge for how to move forward on your service mesh journey.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经拥有了理论基础，并且掌握了一些实践知识，了解如何在你的服务网格之旅中向前迈进。
- en: Summary
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Overall, containerized application deployment, troubleshooting, and third-party
    tooling are going to be the core pieces of what your Kubernetes cluster looks
    like. Without proper troubleshooting, you won’t have successful deployments. Without
    third-party tooling such as Ingress controllers, you won’t be able to properly
    manage frontend apps. Out of the box, Kubernetes gives you a ton to use to make
    things work. However, there are more steps you need to take. For better or for
    worse, Kubernetes isn’t one of those platforms where you can just deploy it and
    walk away. It takes management and engineering skills to ensure it’s working as
    expected.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，容器化应用程序的部署、故障排除以及第三方工具将成为你 Kubernetes 集群的核心组成部分。如果没有适当的故障排除，你将无法成功部署。如果没有像
    Ingress 控制器这样的第三方工具，你将无法正确管理前端应用程序。Kubernetes 开箱即用，提供了大量工具来使事情顺利运行。然而，你还需要采取更多步骤。无论是好是坏，Kubernetes
    不是那种你可以轻松部署后就不管的个平台。它需要管理和工程技能来确保其按预期工作。
- en: In the next chapter, you’ll learn about how to monitor the workloads you’ve
    been deploying throughout this book.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何监控你在本书中部署的工作负载。
- en: Further reading
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Learn Helm* by Andrew Block and Austin Dewey: [https://www.packtpub.com/product/learn-helm/9781839214295](https://www.packtpub.com/product/learn-helm/9781839214295%0D)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*学习 Helm* 由 Andrew Block 和 Austin Dewey 编写：[https://www.packtpub.com/product/learn-helm/9781839214295](https://www.packtpub.com/product/learn-helm/9781839214295%0D)'
- en: '*Mastering Service Mesh* by Anjali Khatri and Vikram Khatri: [https://www.packtpub.com/product/mastering-service-mesh/9781789615791?_ga=2.161313023.37784508.1672298745-664251363.1663254593](https://www.packtpub.com/product/mastering-service-mesh/9781789615791?_ga=2.161313023.37784508.1672298745-664251363.1663254593)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*精通服务网格* 由 Anjali Khatri 和 Vikram Khatri 编写：[https://www.packtpub.com/product/mastering-service-mesh/9781789615791?_ga=2.161313023.37784508.1672298745-664251363.1663254593](https://www.packtpub.com/product/mastering-service-mesh/9781789615791?_ga=2.161313023.37784508.1672298745-664251363.1663254593)'
