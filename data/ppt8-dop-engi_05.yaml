- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Facts and Functions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facts 和 Functions（函数）
- en: This chapter will cover facts. We will show you how the Facter tool gathers
    them to show the profile of systems, how to interact with Facter, and how to use
    them in Puppet code. We will also cover how custom and external facts can be added
    to the provided core facts, to allow for more user-specific facts to be gathered.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讲解 facts（事实）。我们将展示 Facter 工具如何收集它们以显示系统配置文件，如何与 Facter 交互，以及如何在 Puppet 代码中使用它们。我们还将介绍如何将自定义和外部的
    facts 添加到提供的核心 facts 中，以便收集更多特定于用户的 facts。
- en: Then, we will cover functions. We will explain what functions do and the three
    types of functions – statement, prefix, and chained. We will examine a selection
    of the core provided functions to show you their capabilities. A selection of
    functions will also be shown from the `stdlib` module, where we will explain the
    module’s approach and uses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍函数。我们将解释函数的作用以及三种类型的函数——语句函数、前缀函数和链式函数。我们将考察一些核心函数，展示它们的功能。同时，也会展示来自
    `stdlib` 模块的一些函数，并解释该模块的使用方法和方式。
- en: Deferred functions, which were introduced in Puppet 6, will also be covered.
    Here, we will show you how deferred functions differ from normal functions, how
    to make a function deferred, and pitfalls to avoid while using deferred functions.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟函数（Deferred functions）是在 Puppet 6 中引入的，本节将对此进行讲解。在这里，我们将向您展示延迟函数与普通函数的区别，如何使一个函数成为延迟函数，以及在使用延迟函数时应避免的陷阱。
- en: 'In a nutshell, the following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，本章将涵盖以下主题：
- en: Facts and Facter
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Facts 和 Facter
- en: Custom facts and external facts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义 facts 和外部 facts
- en: Functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: The stdlib module functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stdlib 模块函数
- en: Deferred functions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟函数
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to provision a Puppet server standard architecture
    with a Windows client and a Linux client by downloading the `params.json` file
    from [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/params.json)
    and then using the following command from your `pecdm` directory:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您需要通过下载 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/params.json)
    文件，并使用以下命令从 `pecdm` 目录中配置一个标准的 Puppet 服务器架构，其中包含一个 Windows 客户端和一个 Linux 客户端：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Facts and Facter
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Facts 和 Facter
- en: Facter is Puppet’s system profiler, a set of Ruby libraries that work cross-platform
    and gather information, known as **facts**, about clients. This tooling provides
    the necessary information to evaluate the profile of the client and allows configuration
    decisions to be made based on the pre-existing state of the host in Puppet code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Facter 是 Puppet 的系统分析工具，是一组跨平台的 Ruby 库，用于收集关于客户端的信息（称为 **facts**）。这些工具提供了评估客户端配置文件所需的信息，并允许根据主机在
    Puppet 代码中的先前状态做出配置决策。
- en: Puppet 5 and 6 use Facter 3, while Puppet 7 uses Facter 4\. Only a handful of
    features are available in Facter 4, which will be highlighted, and a small number
    of facts have changed, but most users will find no difference. These differences
    can be viewed by running the `puppet facts diff` command. In [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212),
    we will highlight how module testing can ensure code is compatible across different
    versions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 5 和 6 使用 Facter 3，而 Puppet 7 使用 Facter 4。Facter 4 中仅提供了一小部分功能，本文将重点介绍这些功能，并且少量事实（facts）有所变化，但大多数用户将不会发现差异。您可以通过运行
    `puppet facts diff` 命令查看这些差异。在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中，我们将重点介绍如何通过模块测试确保代码在不同版本间的兼容性。
- en: The output of Facter can be seen by running the `facter -p` or `puppet facts`
    command on the command line or VSCode terminal. Running either of these commands
    without any further options will return all the core facts. The `-p` flag ensures
    that Puppet-specific facts are gathered. Due to a circular dependency being created
    between Facter and Puppet, it had been previously planned to depreciate the `-p`
    flag and replace it with the `puppet facts` command. This approach was abandoned
    with the release of Facter 4\. This book will use the `facter` command for its
    examples, which follows the documentation and community practices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在命令行或 VSCode 终端中运行 `facter -p` 或 `puppet facts` 命令查看 Facter 的输出。运行这些命令而不添加任何额外选项时，将返回所有核心
    facts。`-p` 标志确保收集 Puppet 特定的 facts。由于 Facter 和 Puppet 之间创建了循环依赖，之前计划废弃 `-p` 标志并用
    `puppet facts` 命令代替，但随着 Facter 4 的发布，这一做法被放弃了。本书的示例将使用 `facter` 命令，这与文档和社区的实践一致。
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: By default, the `facter` command outputs in a Puppet hash format, while `puppet
    facts` outputs in JSON format. Both of these commands accept options for choosing
    the appropriate format.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`facter` 命令以 Puppet 哈希格式输出，而 `puppet facts` 以 JSON 格式输出。这两个命令都接受选择适当格式的选项。
- en: 'We will now look at some examples of Facter output. The simplest type of fact
    is a simple key-value pair, such as the `Kernel` fact, which in this case tells
    us that the kernel is Windows-based:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些 Facter 输出的示例。最简单的事实类型是简单的键值对，例如 `Kernel` 事实，在本例中，它告诉我们内核是基于 Windows
    的：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are also hashes, known as structured facts, which can be broken into
    nested levels. The `os` fact is commonly used. The following example of a Windows
    10 laptop shows the various levels that are available:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些称为结构化事实的哈希值，它们可以分解成嵌套级别。`os` 事实是常用的。以下是 Windows 10 笔记本电脑的示例，展示了可用的各种级别：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The full list of core facts can be found at [https://puppet.com/docs/puppet/latest/core_facts.html](https://puppet.com/docs/puppet/latest/core_facts.html);
    running `facter -p` on your client system and reviewing the output is recommended.
    An individual fact can be accessed by running the `facter` command against the
    fact’s name, such as `facter -p kernel`, to return the `kernel` fact. To access
    a specific nested level value in a structured fact, dot notation is used, which
    separates each key level name with dots (`.`). So, to access the `family` fact
    within the `os` structured fact, the `facter -p os.family` command can be run.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 核心事实的完整列表可以在 [https://puppet.com/docs/puppet/latest/core_facts.html](https://puppet.com/docs/puppet/latest/core_facts.html)
    中找到；建议在客户端系统上运行 `facter -p` 并查看输出。可以通过运行 `facter` 命令并指定事实名称来访问单个事实，例如运行 `facter
    -p kernel` 来返回 `kernel` 事实。要访问结构化事实中的特定嵌套级别值，使用点符号表示法，点号（`.`）分隔每个键级名称。因此，要访问 `os`
    结构化事实中的 `family` 事实，可以运行 `facter -p os.family` 命令。
- en: As Facter has gone through several iterations and structured facts were not
    in earlier versions, Facter 3 hid several legacy facts such as architecture, which
    was put into the `os` structured fact as `os.structured`. The `--show-legacy`
    flag allows these facts to be made visible in the Facter output; they are documented
    in the core fact documentation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Facter 经历了多个版本迭代，并且早期版本没有结构化事实，Facter 3 隐藏了多个遗留事实，如架构，它被放入 `os` 结构化事实中作为
    `os.structured`。`--show-legacy` 标志可以使这些事实在 Facter 输出中可见；它们在核心事实文档中有记录。
- en: When Puppet is run, either via the agent or by running `puppet apply` on the
    command line, Facter will run, with legacy facts, and the output will be assigned
    to global variables.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Puppet 运行时，无论是通过代理还是在命令行上运行 `puppet apply`，Facter 都会运行，使用遗留事实，并且输出将分配给全局变量。
- en: These variables can then be accessed in Puppet manifests in two ways – either
    directly by the name of the fact on a global variable or via the facts array.
    It is strongly recommended to access facts only via the facts array since this
    makes it clear that facts are being accessed and not potentially other global
    variables.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些变量可以通过两种方式在 Puppet 清单中访问——要么直接通过事实的名称作为全局变量，要么通过 facts 数组。强烈建议仅通过 facts
    数组访问事实，因为这样可以明确表示正在访问事实，而不是其他潜在的全局变量。
- en: 'For example, in the following code, the `notify` resources would access the
    `kernel` and `os family` variables and print logging messages containing the `kernel`
    and `os` families of the host it was run on:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下代码中，`notify` 资源将访问 `kernel` 和 `os family` 变量，并打印包含主机 `kernel` 和 `os` 系列的日志信息：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that not all facts will appear on all clients. Facts often have a context
    on which to filter themselves, such as which operating system is running or if
    a particular underlying hardware is being used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有事实都会出现在所有客户端上。事实通常会根据某些上下文进行过滤，例如正在运行的操作系统，或者是否使用了特定的底层硬件。
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As you’ll see in the next section, functions use dots for chained functions,
    so the dot-separated access syntax of the `facter` command cannot be used to call
    the `facts` variable directly. However, the `getvar` function can be used.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一节中看到的那样，函数使用点号来表示链式函数，因此 `facter` 命令的点分隔访问语法不能用于直接调用 `facts` 变量。然而，可以使用
    `getvar` 函数。
- en: Facter can be customized and tuned on a host-by-host basis by configuring a
    `facter.conf` file. This file is not created by default and should be created
    at `/etc/puppetlabs/facter/facter.conf` on Nix-based systems and `C:\ProgramData\PuppetLabs\facter\etc\facter.conf`
    on Windows. For testing purposes, the `facter` command can be run with the `-c`
    flag to select a configuration file to be run.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Facter 可以通过配置 `facter.conf` 文件，在每个主机上进行自定义和调整。默认情况下，此文件不会创建，应在 Nix 系统上的 `/etc/puppetlabs/facter/facter.conf`
    和 Windows 上的 `C:\ProgramData\PuppetLabs\facter\etc\facter.conf` 创建。为了测试，可以使用 `-c`
    标志运行 `facter` 命令，选择要运行的配置文件。
- en: 'An example `facter.conf` group looks like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例 `facter.conf` 组如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The first section, `facts`, includes a blocklist, which allows us to list facts
    and fact groups that will not be run. This can be useful in situations where calculating
    the fact can be computationally expensive. For example, in the preceding example,
    we block the `disks` and `file system` groups since, in some legacy UNIX systems,
    SAN storage can be configured with thousands of paths. It also disables `dmi.product.serial_number`,
    which might be decided as something secure that should not be visible in Puppet.
    To see a full list of blockable groups, you can run the `facter --list-block-groups`
    command, which will list the group names and a list of the facts inside it. For
    example, the `disks` group looks like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分 `facts` 包括一个阻止列表，它允许我们列出将不会运行的事实和事实组。这在计算事实可能会非常耗费资源的情况下很有用。例如，在前面的示例中，我们阻止了
    `disks` 和 `file system` 组，因为在一些传统的 UNIX 系统中，SAN 存储可能会配置有成千上万条路径。它还禁用了 `dmi.product.serial_number`，这可能被认为是某些安全信息，不应在
    Puppet 中显示。要查看所有可阻止组的完整列表，可以运行 `facter --list-block-groups` 命令，它将列出组名以及其中包含的事实列表。例如，`disks`
    组如下所示：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The other part of the facts section is `ttls`, which allows caching to be configured.
    Cached facts are stored as JSON in `/opt/puppetlabs/facter/cache/cached_facts`
    on UNIX-based systems and `C:\ProgramData\PuppetLabs\facter\cache\cached_facts`
    on Windows. In the preceding example, the `processor` group will only be refreshed
    every 30 days. To see a full list of cacheable groups, you can run the `facter
    --list-cache-groups` command, which will display a similar format to the block
    groups.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 事实部分的另一部分是 `ttls`，它允许配置缓存。缓存的事实以 JSON 格式存储在 UNIX 系统上的 `/opt/puppetlabs/facter/cache/cached_facts`
    和 Windows 上的 `C:\ProgramData\PuppetLabs\facter\cache\cached_facts` 中。在前面的示例中，`processor`
    组将每 30 天刷新一次。要查看所有可缓存组的完整列表，可以运行 `facter --list-cache-groups` 命令，这将显示类似于块组的格式。
- en: The `global` section allows an array of directories to be passed to `external-dir`
    so that you can define where `facter` should look for external facts. Similarly,
    an array directory can be passed to `custom-dir` to define where `facter` should
    look for custom facts. Custom and external facts will be covered in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`global` 部分允许传递一个目录数组到 `external-dir`，以便定义 `facter` 应该在何处查找外部事实。类似地，可以传递一个目录数组到
    `custom-dir`，定义 `facter` 应该在何处查找自定义事实。自定义和外部事实将在下一部分中讨论。'
- en: 'The `global` section has three Boolean values:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`global` 部分有三个布尔值：'
- en: '`no-external-facts`: To disable external facts if set to `true`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no-external-facts`：如果设置为 `true`，则禁用外部事实。'
- en: '`no-custom-facts`: To disable custom facts if set to `true`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no-custom-facts`：如果设置为 `true`，则禁用自定义事实。'
- en: '`no-ruby`: To prevent Facter loading via Ruby. Any facts that use Ruby and
    custom facts are set to `true`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no-ruby`：防止通过 Ruby 加载 Facter。任何使用 Ruby 和自定义事实的事实如果设置为 `true`，则会被禁用。'
- en: All these settings are more likely to be used for debugging and development
    purposes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些设置更可能用于调试和开发目的。
- en: 'The `cli` section sets a log level with a string of (`none`, `trace`, `debug`,
    `info`, `warn`, `error`, `fatal`) and has three options: `verbose`, `trace`, and
    `debug`. Each of these three options is enabled or disabled with a `true` or `false`
    Boolean. The `trace` option will show a backtrace if an exception occurs in a
    custom fact. This should not be confused with the trace log level; a better name
    for this option might have been stacktrace. The `verbose` option enables `verbose`
    information output from Facter, while the `debug` option enables debug-level output
    from Facter.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`cli` 部分设置日志级别，值为（`none`、`trace`、`debug`、`info`、`warn`、`error`、`fatal`）的字符串，并有三个选项：`verbose`、`trace`
    和 `debug`。这三个选项的启用或禁用通过布尔值 `true` 或 `false` 来设置。`trace` 选项将在自定义事实发生异常时显示回溯。这个选项不应与追踪日志级别混淆；这个选项的更合适名称可能是
    stacktrace。`verbose` 选项启用 Facter 的详细信息输出，而 `debug` 选项启用 Facter 的调试级别输出。'
- en: The `fact-group` section is new to Facter 4 for Puppet and allows you to define
    custom groups for caching and blocking. Core facts and custom facts can be specified
    but not external facts.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`fact-group` 部分是 Facter 4 中 Puppet 新增的功能，允许你为缓存和阻止定义自定义组。可以指定核心事实和自定义事实，但不能指定外部事实。'
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As the `facter.conf` file uses a HOCON format, it can be easier to manage it
    via the HOCON module from Puppet Forge ([https://forge.puppet.com/modules/puppetlabs/hocon](https://forge.puppet.com/modules/puppetlabs/hocon)),
    where it can be classified on an individual node or group of nodes basis as required.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `facter.conf` 文件使用 HOCON 格式，因此可以通过 Puppet Forge 的 HOCON 模块（[https://forge.puppet.com/modules/puppetlabs/hocon](https://forge.puppet.com/modules/puppetlabs/hocon)）更轻松地管理它，在此过程中可以根据需要按单个节点或节点组进行分类。
- en: 'Facter 4 in Puppet 7 also reintroduced benchmarking of facts, which had previously
    been in Facter 2\. To run benchmarks on a particular fact, you can run the `facter
    -t <fact name>` command. For example, running `facter -t os` will produce an output
    similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 7 中的 Facter 4 重新引入了事实基准测试功能，这一功能之前在 Facter 2 中就已存在。要对某个特定的事实进行基准测试，可以运行
    `facter -t <fact name>` 命令。例如，运行 `facter -t os` 将生成类似于以下的输出：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If a structured fact is selected, it will time each part of the fact and will
    return it to the normal output of the facter call after.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了结构化事实，它将对事实的每个部分进行计时，并在执行完后将其返回到 facter 调用的正常输出中。
- en: Having covered what core facts are and how to run and configure Facter to test
    and manage them, the next stage is adding customizations via custom and external
    facts.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了核心事实是什么以及如何运行和配置 Facter 来测试和管理它们之后，下一步是通过自定义和外部事实添加个性化配置。
- en: Custom facts and external facts
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义事实和外部事实
- en: In this section, you will learn how to add to the facts provided by core via
    custom facts. These are written in Ruby, similar to core facts or external facts,
    which are either hard-rigged values or client-native executable scripts. While
    it can be tempting to gather everything, the extra burden facts put on the Puppet
    infrastructure, particularly with many agents, should be considered and balanced
    with the need for data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何通过自定义事实将其添加到核心事实提供的事实中。这些事实是用 Ruby 编写的，类似于核心事实或外部事实，它们可以是硬编码的值，也可以是客户端本地可执行的脚本。虽然收集所有数据可能很有诱惑力，但应考虑到外部事实对
    Puppet 基础架构的额外负担，特别是在有大量代理的情况下，并需要平衡数据需求与系统性能。
- en: External facts
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部事实
- en: External facts are executables that can set facts based on the logic within
    the scripts or facts set statically by the structured data of the file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 外部事实是可执行文件，它们可以根据脚本中的逻辑设置事实，或者根据文件的结构化数据静态设置事实。
- en: 'External facts can be stored in the following directories for Unix-based operating
    systems:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 外部事实可以存储在以下目录中，适用于基于 Unix 的操作系统：
- en: '`/``opt/puppetlabs/facter/facts.d/`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``opt/puppetlabs/facter/facts.d/`'
- en: '`/``etc/puppetlabs/facter/facts.d/`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``etc/puppetlabs/facter/facts.d/`'
- en: '`/``etc/facter/facts.d/`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/``etc/facter/facts.d/`'
- en: For Windows systems, they can be stored in `C:\ProgramData\PuppetLabs\facter\facts.d\`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 系统，外部事实可以存储在 `C:\ProgramData\PuppetLabs\facter\facts.d\` 中。
- en: In [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212), you will learn how external
    facts can be distributed to clients from modules via the plugin sync process,
    where facts are added from modules contained in a `facts.d` folder within the
    module.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 8 章*](B18492_08.xhtml#_idTextAnchor212) 中，你将学习如何通过插件同步过程将外部事实从模块分发到客户端，在此过程中，模块中
    `facts.d` 文件夹内的事实会被添加进来。
- en: Note
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Puppet can be run as a non-root user on UNIX-based systems, while external facts
    can be stored in `~/.facter/facts.d/`. However, this book will not cover running
    as a non-root user.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 可以在基于 UNIX 的系统上作为非 root 用户运行，而外部事实可以存储在 `~/.facter/facts.d/` 中。然而，本书不会涉及作为非
    root 用户运行的相关内容。
- en: Static external facts
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态外部事实
- en: 'Static external facts must be in JSON, YAML, or TXT format. As an example,
    let’s set an `Application` fact to `exampleapp`, a `Use` fact to `production`,
    and an `Owner` fact to `exampleorg`. In a YAML file, this can be created like
    so:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 静态外部事实必须采用 JSON、YAML 或 TXT 格式。例如，我们可以将 `Application` 事实设置为 `exampleapp`，将 `Use`
    事实设置为 `production`，将 `Owner` 事实设置为 `exampleorg`。在 YAML 文件中，可以像这样创建：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In a JSON file, they would be set like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JSON 文件中，可以像这样设置它们：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In a TXT file, the same facts would be set like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TXT 文件中，同样的事实可以像这样设置：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For Windows, the line endings used in these files must be either LF (Line feed,
    Unicode character 000A) or CRLF (Carriage return and line feed, Unicode characters
    000D and 000A) and the file encoding used for the files must be either ANSI or
    UTF8 without BOM.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，这些文件中使用的行结束符必须是 LF（换行符，Unicode 字符 000A）或 CRLF（回车符和换行符，Unicode 字符
    000D 和 000A），且文件的编码必须是 ANSI 或 UTF8 且不带 BOM。
- en: 'The examples we’ve looked at so far are all known as **flat facts**. However,
    structured facts can be returned by creating an array format. For example, in
    YAML, we could allow two owners by adding arrays and nested arrays to YAML. In
    this example, let’s assume there are multiple applications, and each application
    can have joint ownership:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所看过的示例都被称为**平面事实**。然而，通过创建数组格式，可以返回结构化的事实。例如，在 YAML 中，我们可以通过添加数组和嵌套数组来允许两个所有者。在这个示例中，假设有多个应用程序，每个应用程序可以有联合所有权：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This would allow us to call `facter application.exampleapp.owner` to retrieve
    an array of owners or to call `facter application.anotherapp` to receive the use
    and owner key pairs.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们调用 `facter application.exampleapp.owner` 来检索所有者数组，或者调用 `facter application.anotherapp`
    来接收使用者和所有者的键值对。
- en: Note that static external facts will always return a string type in their output.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，静态外部事实在输出中将始终返回字符串类型。
- en: Executable external facts
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可执行外部事实
- en: Executable external facts differ on Windows and UNIX, but both are runnable
    scripts that output key pairs or arrays to return facts or structured facts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行外部事实在 Windows 和 UNIX 上有所不同，但它们都是可运行的脚本，输出键值对或数组以返回事实或结构化事实。
- en: 'On Windows, the following file types can be used:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，可以使用以下文件类型：
- en: Binary executables (`.com` and `.``exe` files)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制可执行文件（`.com` 和 `.exe` 文件）
- en: Batch scripts (`.bat` and `.``cmd` files)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批处理脚本（`.bat` 和 `.cmd` 文件）
- en: PowerShell scripts (`.``ps1` files)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PowerShell 脚本（`.ps1` 文件）
- en: On UNIX platforms, any executable file with a valid shebang (`#!`) statement
    can be run. If the shebang statement is missing, the execution of the script will
    fail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UNIX 平台上，任何具有有效 shebang (`#!`) 声明的可执行文件都可以运行。如果缺少 shebang 声明，脚本执行将失败。
- en: For both platforms, the scripts should return text. This will be read as key
    pairs or as YAML or JSON, which can be parsed into a structured fact.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个平台，这些脚本应该返回文本。文本将被读取为键值对，或作为 YAML 或 JSON，可以解析成结构化事实。
- en: 'For example, a Unix bash script that returns the PID of the `exampleapp` process
    as a fact, along with a fact for `exampleapp_cpu_use` and `example_memory_use`,
    may look like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个返回 `exampleapp` 进程 PID 作为事实的 Unix bash 脚本，同时返回 `exampleapp_cpu_use` 和 `example_memory_use`
    的事实，可能如下所示：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For Windows, a PowerShell script to return the same facts would look like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，一个 PowerShell 脚本返回相同的事实将如下所示：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To find issues with external facts, you can run `facter –debug`. This will highlight
    if the fact is visible to Facter and if any output is not being parsed and getting
    ignored.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找外部事实的问题，可以运行 `facter --debug`。这将显示事实是否对 Facter 可见，以及是否有任何输出未被解析并被忽略。
- en: Custom facts
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义事实
- en: Custom facts are sections of Ruby code that can be used to set facts and expand
    on the core Facter facts. The main advantage of using custom facts over external
    facts surrounds the built-in mechanisms that are available. In this section, you
    will learn how the use of custom facts allows you to access the value of other
    facts within custom facts, how you can have multiple weighted resolutions, and
    how to use `confine` to ensure only certain nodes will attempt to run the fact.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事实是可以用来设置事实并扩展核心 Facter 事实的 Ruby 代码段。使用自定义事实相较于外部事实的主要优势在于其内置的机制。在本节中，您将了解如何使用自定义事实访问其他事实的值，如何进行多个加权解析，以及如何使用
    `confine` 确保只有特定的节点会尝试运行该事实。
- en: The main disadvantage of using custom facts is that they need to be written
    in Ruby, which is a learning curve. It’s beyond the scope of this book to dive
    deeper into the details of Ruby, but its basic structure and some of its core
    libraries, which work well on Windows and UNIX-based systems, will be shown to
    give enough you a head start so that you can research them further.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义事实的主要缺点是它们需要用 Ruby 编写，而 Ruby 存在学习曲线。深入学习 Ruby 的细节超出了本书的范围，但本书将展示其基本结构以及一些在
    Windows 和 UNIX 系统上运行良好的核心库，以便您能够为进一步研究打下基础。
- en: 'Like external facts, custom facts are normally distributed by Puppet modules.
    However, when performing local testing, there are three ways to direct Facter
    to locations where we store our facts locally while testing:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与外部事实类似，自定义事实通常通过 Puppet 模块分发。然而，在进行本地测试时，有三种方法可以指示 Facter 查找我们存储本地事实的位置：
- en: The Ruby library load path
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby 库加载路径
- en: Using the `–custom-dir` option on the Facter command (note that this can be
    flagged multiple times)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Facter 命令中使用 `--custom-dir` 选项（请注意，此选项可以多次标记）
- en: Setting the `FACTERLIB` environment variable
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 `FACTERLIB` 环境变量
- en: The Ruby library load path can be checked by running `ruby -e 'puts $LOAD_PATH'`.
    Remember to make sure that the Ruby binary being used is the Puppet-provided version
    at `C:\Program Files\Puppet Labs\Puppet\puppet\bin\ruby.exe` on Windows or `/opt/puppetlabs/puppet/bin`
    on UNIX-based systems.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 库加载路径可以通过运行 `ruby -e 'puts $LOAD_PATH'` 来检查。记得确保所使用的 Ruby 二进制文件是 Puppet
    提供的版本，在 Windows 上是 `C:\Program Files\Puppet Labs\Puppet\puppet\bin\ruby.exe`，在
    UNIX 系统上是 `/opt/puppetlabs/puppet/bin`。
- en: 'Custom facts declare themselves using `Facter.add(''<fact_name>'')` and use
    a `setcode` statement to run a code block to resolve the fact. This is the way
    a fact’s value is determined. As a simple example, it is possible to run a UNIX
    shell or Windows terminal command directly by surrounding the command with backticks
    (`` ` ``):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事实使用 `Facter.add('<fact_name>')` 声明自己，并使用 `setcode` 语句运行代码块来解析事实。这就是事实值确定的方式。作为一个简单的例子，可以通过将命令括起来使用反引号（``
    ` ``）直接运行 UNIX shell 或 Windows 终端命令：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since there is only one command, this could also be written with a single `setcode`
    line:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只有一个命令，这也可以用单个 `setcode` 行来编写：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Both would set the `exampleapp_version` fact to the output of the `exampleapp
    –``version` command.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 两者都会将 `exampleapp_version` 事实设置为 `exampleapp --version` 命令的输出结果。
- en: If your facts were more complicated and you needed to run multiple commands
    or manipulate the output, the command could be run using a Ruby class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的事实更加复杂，需要运行多个命令或处理输出，可以通过 Ruby 类来运行命令。
- en: 'In the following example, the `Facter::Core::Execution.execute` Ruby class
    will run a command called `exampleapp`, with a flag of `version`, and then pipe
    the output of the command to `awk` to print the second returned value:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`Facter::Core::Execution.execute` Ruby 类将运行名为 `exampleapp` 的命令，并带有 `version`
    标志，然后将命令的输出通过管道传递给 `awk`，以打印第二个返回值：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'PowerShell commands can be executed using the `powershell` command, like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `powershell` 命令执行 PowerShell 命令，示例如下：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It can be tempting to run everything as terminal commands for familiarity, but
    care must be taken as not everything that can be used in a terminal will work.
    For example, bash-style `if` statements will not work and should be written in
    Ruby code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然出于熟悉感，可以将所有操作都当作终端命令来执行，但需要小心，并不是所有终端中可以使用的命令都能正常工作。例如，bash 风格的 `if` 语句无法使用，应当用
    Ruby 代码来编写。
- en: 'It can be useful to call the value of another fact into a variable. The following
    code will put the `os arch` fact into the `arch` variable:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 调用另一个事实的值到变量中可能会很有用。以下代码将 `os arch` 事实的值存入 `arch` 变量：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Confining custom facts
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制自定义事实
- en: 'One of the main advantages of custom facts is the ability to confine the nodes
    they will run on. This can be achieved with the `confine` statement and by selecting
    the facts and values to match for the fact to run. The `confine` functions syntax
    follows this format:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义事实的主要优点之一是可以限制它们将运行的节点。可以通过 `confine` 语句实现，并选择事实和值来匹配运行的事实。`confine` 函数的语法如下所示：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The fact defined after the `confine` function will only run if the conditions
    are met. For example, you can confine a fact to only run on nodes with Windows-based
    kernels:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `confine` 函数之后定义的事实，只有在条件满足时才会运行。例如，你可以将事实限制为仅在 Windows 内核节点上运行：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'An array can also be used, where matching any of the values will allow the
    fact to run. For example, we can check if the kernel is from Linux or Solaris:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用数组，匹配任何一个值都可以让事实运行。例如，我们可以检查内核是否来自 Linux 或 Solaris：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For structured facts, the `Facter.value` method can be used to access it. For
    example, to test that the `os.release.major` fact is equal to `10`, the following
    code can be used, where `=>` is used instead of a colon (`:`) to match the fact
    to its value:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构化事实，可以使用 `Facter.value` 方法来访问。例如，要测试 `os.release.major` 事实是否等于 `10`，可以使用以下代码，其中
    `=>` 被用来代替冒号（`:`）来匹配事实的值：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In addition to facts, Ruby commands and library commands can be used to confine
    facts. For example, `confine` can be used with `Facter::Core::Execution.where`
    or `Facter::Core::Execution.which` to confirm a command exists in the path for
    Windows or Linux, respectively. Additionally, Ruby libraries such as File can
    be used to check this.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 除了事实之外，Ruby 命令和库命令也可以用来限制事实。例如，`confine` 可以与 `Facter::Core::Execution.where`
    或 `Facter::Core::Execution.which` 一起使用，分别用于确认 Windows 或 Linux 的路径中是否存在某个命令。此外，Ruby
    库如 File 也可以用来检查这一点。
- en: 'For example, to confine a fact if the `git` command was found in the Windows
    path, the following code can be run:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要限制一个事实，仅在 Windows 路径中找到 `git` 命令时运行，可以运行以下代码：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following code would confine a fact to only run if `/opt/app/exampleapp`
    existed as a file or as a directory:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码会限制事实仅在 `/opt/app/exampleapp` 存在作为文件或目录时运行：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To write a single fact that can cover multiple implementations and confine
    with granularity, we can use both resolutions (`Facter.add` statements) and multiple
    confine blocks. The following example shows a simple example of setting the Facter
    value of `whoami` to either `I am windows 10` if the kernel fact is Windows and
    `os.release.major` is `10` or to the `I am Sparc` string if the kernel is `sparc`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个可以涵盖多种实现并且具有粒度限制的单一事实，我们可以同时使用多个解析（`Facter.add` 语句）和多个限制块。以下示例展示了一个简单的示例，设置
    `whoami` 的 Facter 值为 `I am windows 10`，如果内核事实是 Windows 并且 `os.release.major` 为
    `10`，或者设置为 `I am Sparc` 字符串，如果内核是 `sparc`：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Another method of confining facts is using features. A feature is a section
    of Ruby code that’s added to `lib/puppet/feature` in a module. For example, the
    `exampleapp` module could contain an `exampleapp.rb` feature that checks whether
    `exampleapp` was installed on either Windows or Linux:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种限制事实的方法是使用特性。特性是 Ruby 代码的一部分，添加到模块的 `lib/puppet/feature` 目录下。例如，`exampleapp`
    模块可以包含一个 `exampleapp.rb` 特性，用来检查 `exampleapp` 是否安装在 Windows 或 Linux 上：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A custom fact could then use a `confine` statement so that only nodes with
    the `exampleapp` command available would run the fact:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，自定义事实可以使用 `confine` 语句，这样只有在 `exampleapp` 命令可用的节点上才会运行该事实：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This removes the need to create additional facts and gather and process information
    not needed except for evaluating confinement.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这消除了需要创建额外事实并收集和处理不必要的信息（除了评估限制之外）的需求。
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to perform all logical code inside the `setcode` and `confine`
    blocks; otherwise, when the facts are loaded, it will run this code, rather than
    when the fact is queried for resolution. The order in which facts will be loaded
    is not predictable, so if code is required by the fact but it is outside of the
    blocks, it can result in ordering errors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setcode` 和 `confine` 块中执行所有逻辑代码非常重要；否则，在加载事实时，它会运行这些代码，而不是在查询事实进行解析时运行。这是因为事实加载的顺序是不可预测的，因此如果代码被事实要求但位于块外部，可能会导致顺序错误。
- en: Weighted resolutions
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加权解析
- en: Another approach to writing custom facts is to have multiple resolutions while
    knowing that some may return null values, but we want to work through various
    options. When reviewing resolutions, Facter eliminates any that are not confined.
    Then, it looks at the weight of each resolution. By default, this is set to `0`
    but it can be set using the `has_weight` function. If two resolutions have the
    same weight, Facter will use whichever was listed in the code first.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 写自定义事实的另一种方法是有多个解析，同时知道某些解析可能返回 null 值，但我们希望逐一尝试不同选项。审查解析时，Facter 会排除所有没有被限制的解析。然后，它会查看每个解析的权重。默认情况下，权重为
    `0`，但可以通过 `has_weight` 函数进行设置。如果两个解析的权重相同，Facter 会使用代码中列出的第一个解析。
- en: 'For example, to set the `exampleapp_version` fact with multiple resolution
    options, in the first resolution, it will run the command with the `version` flag
    weighted at `100` and then try to look for the version in the config file weighted
    at `50`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要使用多个解析选项设置 `exampleapp_version` 事实，在第一个解析中，它将以 `100` 权重运行带有 `version` 标志的命令，然后尝试以
    `50` 权重在配置文件中查找版本：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This allows the command to fail so that it can be backed up with a second source.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许命令失败，从而可以通过第二个来源进行备份。
- en: Note
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: External facts have a weight of `1000`. So, to prevent an external fact from
    being able to overwrite your custom fact resolutions, you can set a value higher
    than `1000` on the resolution weight.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 外部事实的权重为 `1000`。因此，为了防止外部事实覆盖自定义事实解析，可以将解析权重设置为高于 `1000` 的值。
- en: Rescue blocks
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异常处理块
- en: By default, Facter will error and fail to return any value if any resolution
    fails with an error. Using rescue blocks can allow default values to be returned
    as a result of failures and to opt to print warnings. This works in conjunction
    with weighted resolutions, where it’s common to expect failures in resolutions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果任何解析失败并产生错误，Facter 将报告错误并无法返回任何值。使用`rescue`块可以在失败时返回默认值，并选择打印警告。这与加权解析配合使用，在加权解析中，通常会预期解析失败。
- en: 'A simple rescue block that returns `nil` on the failure of resolution after
    running the `exampleapp –version` command and logging a failure would look like
    this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的`rescue`块，在运行`exampleapp –version`命令并记录失败后，返回`nil`，看起来像这样：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using `Facter.warn` ensures this message is printed to STDERR when used via
    the `Facter` command. When used during the Puppet catalog application, it will
    ensure it is printed in Puppet’s logs. Returning `nil` would ensure other resolutions
    can be used if they return non-nil values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Facter.warn`可以确保当通过`Facter`命令使用时，这条消息会打印到 STDERR。当在 Puppet catalog 应用过程中使用时，它将确保该消息打印到
    Puppet 的日志中。返回`nil`将确保其他解析可以在返回非 nil 值时被使用。
- en: Timeouts
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超时
- en: 'As part of Facter 4, which was made available in Puppet 7, it is now possible
    to add a timeout to a resolution. This can be done by adding a comma after the
    fact’s name as part of the `Facter.add` resolution statement and using the `{timeout:
    <value in seconds>}` syntax, where the value in seconds can be an integer or a
    float. For example, to ensure a 0.2-second timeout on the `exmpleapp_version`
    fact, the code can be set like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '作为 Puppet 7 中的 Facter 4 的一部分，现在可以为解析添加超时。可以通过在事实的名称后添加逗号，作为`Facter.add`解析语句的一部分，并使用`{timeout:
    <秒数值>}`语法来实现，其中秒数值可以是整数或浮动值。例如，要确保`exampleapp_version`事实的超时时间为 0.2 秒，代码可以像这样设置：'
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Although this is only a feature in Facter 4 and Puppet 7, in Facter 3 and Puppet
    5 and higher, it is possible to put timeouts on the execution command by directly
    setting the `options` variable on the `execute` function. For example, the same
    0.2-second timeout could be applied to the execution of the `exampleapp –version`
    command rather than the whole resolution by modifying the `execute` command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是 Facter 4 和 Puppet 7 中的一个功能，但在 Facter 3 和 Puppet 5 及更高版本中，仍然可以通过直接在`execute`函数上设置`options`变量来对执行命令设置超时。例如，可以通过修改`execute`命令来将相同的
    0.2 秒超时应用于`exampleapp –version`命令的执行，而不是整个解析：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Aggregate and structured facts
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合和结构化事实
- en: Aggregate facts allow the resolutions of a fact to be broken up into chunks.
    These chunks can then be merged. Merging arrays or hashes creates a structured
    fact or performs other functions, such as adding the values of facts together.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合事实允许将事实的解析分成多个块。然后，这些块可以合并。合并数组或哈希会创建结构化的事实或执行其他功能，例如将事实的值相加。
- en: An aggregate fact still has a `Facter.add` declaration, but within `Facter.add`,
    it sets the type variable to `aggregate`. Then, instead of using `setcode` sections,
    it uses `chunk` sections for the resolutions. By default, each `chunk` will be
    merged unless an aggregate block is declared to perform another function.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合事实仍然有一个`Facter.add`声明，但在`Facter.add`内，它将类型变量设置为`aggregate`。然后，代替使用`setcode`部分，它使用`chunk`部分来进行解析。默认情况下，每个`chunk`都会被合并，除非声明了聚合块来执行其他功能。
- en: 'For example, the following code would create a structured fact called `exampleapp`.
    It would have `exampleapp.version` and `exampleapp.fullpath` containing the output
    of the commands in the chunks:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码将创建一个名为`exampleapp`的结构化事实。它将包含`exampleapp.version`和`exampleapp.fullpath`，其中包含在块中运行的命令的输出：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To use an aggregate block and sum facts together, you can use the following
    code, which makes a fact called `exampleapp_memory_usage` that takes a chunk using
    a fact containing the total memory used by `exampleapp` and adds it to the memory
    used by `exampleapp2` to give us the total memory usage:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用聚合块并将事实合并，可以使用以下代码，它创建了一个名为`exampleapp_memory_usage`的事实，该事实使用一个包含`exampleapp`使用的总内存的事实，并将其添加到`exampleapp2`使用的内存中，从而得出总内存使用情况：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'A new method to return structured facts is available in Puppet 7 with Facter
    4\. This follows the use of dot notation in the fact’s name, which allows a definition
    to assign different levels of a structured fact. For example, to set the `exampleapp`
    fact with a nested level of `exampleapp.version` and `exampleapp.pid`, you can
    use the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 7与Facter 4中提供了一种新的返回结构化事实的方法。这采用了事实名称中的点表示法，允许定义将不同层次的结构化事实进行赋值。例如，要设置带有嵌套层次的`exampleapp`事实，包括`exampleapp.version`和`exampleapp.pid`，可以使用以下代码：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This has a core advantage over using an aggregate. Unlike an aggregate, a failure
    of one part of the declaration will only affect that declaration; the rest will
    be assigned.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这相比使用聚合有一个核心优势。与聚合不同，声明中某一部分的失败只会影响该声明，其他部分将继续赋值。
- en: Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section has tried to give you enough information to get started with custom
    facts. In Puppet’s documentation for custom facts and module code, you will find
    alternative syntax for many of the features we’ve discussed. Since it is in Ruby
    code, there is a greater variation of what can be declared. This book has chosen
    what it considers the best style and practice to follow to keep things simple
    and avoid listing too many options.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本节试图为你提供足够的信息，以便你开始使用自定义事实。在Puppet的自定义事实和模块代码文档中，你会发现许多我们讨论过的功能的替代语法。由于它是Ruby代码，声明的方式有更多变化。本书选择了它认为最好的风格和实践，以保持简洁并避免列出过多选项。
- en: 'Some modules that can be useful to follow examples further are available on
    GitHub:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一些可以帮助你进一步跟随示例的模块可以在GitHub上找到：
- en: '[https://github.com/puppetlabs/puppetlabs-pe_status_check/blob/main/lib/facter/](https://github.com/puppetlabs/puppetlabs-pe_status_check/blob/main/lib/facter/)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/puppetlabs/puppetlabs-pe_status_check/blob/main/lib/facter/](https://github.com/puppetlabs/puppetlabs-pe_status_check/blob/main/lib/facter/)'
- en: '[https://github.com/puppetlabs/puppetlabs-stdlib/tree/main/lib/facter](https://github.com/puppetlabs/puppetlabs-stdlib/tree/main/lib/facter)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/puppetlabs/puppetlabs-stdlib/tree/main/lib/facter](https://github.com/puppetlabs/puppetlabs-stdlib/tree/main/lib/facter)'
- en: '[https://github.com/puppetlabs/puppetlabs-lvm/tree/master/lib/facter](https://github.com/puppetlabs/puppetlabs-lvm/tree/master/lib/facter)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/puppetlabs/puppetlabs-lvm/tree/master/lib/facter](https://github.com/puppetlabs/puppetlabs-lvm/tree/master/lib/facter)'
- en: '[https://github.com/puppetlabs/puppetlabs-java/tree/main/lib/facter](https://github.com/puppetlabs/puppetlabs-java/tree/main/lib/facter)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/puppetlabs/puppetlabs-java/tree/main/lib/facter](https://github.com/puppetlabs/puppetlabs-java/tree/main/lib/facter)'
- en: Lab
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验
- en: For this lab, we will create a static external fact and a custom fact and distribute
    them with `bolt upload` before running the facts and viewing them on the console
    to see if they have become visible.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实验，我们将创建一个静态外部事实和一个自定义事实，并使用`bolt upload`进行分发，然后运行这些事实并在控制台上查看它们是否已变得可见。
- en: For the static external fact, create a structure that sets `packtlab.use` equal
    to `lab` and `packlab.student` equal to your name.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于静态外部事实，创建一个结构，将`packtlab.use`设置为`lab`，并将`packlab.student`设置为你的名字。
- en: For the custom fact, a `tmp_count` fact will be created, which will count the
    number of files in the `/tmp` directory on Linux and `C:\Users\admin\AppData\Local\Temp`
    on Windows. For Linux, the first resolution with a higher weighting should be
    `'find /tmp` `-type f | wc -l'`, while the second with a lower weighting should
    be `ls /tmp | wc -l`. For Windows, the first higher-weighted resolution should
    be the `(ls $env:Temp | Measure-Object -line).Lines` PowerShell command and the
    lower weighted resolution – that is, `(Get-ChildItem $env:Temp |` `Measure-Object).Count`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自定义事实，将创建一个`tmp_count`事实，它将计算Linux中`/tmp`目录和Windows中`C:\Users\admin\AppData\Local\Temp`目录中的文件数量。对于Linux，第一个权重较高的解析应为`'find
    /tmp -type f | wc -l'`，而第二个权重较低的解析应为`ls /tmp | wc -l`。对于Windows，第一个权重较高的解析应为`(ls
    $env:Temp | Measure-Object -line).Lines` PowerShell命令，权重较低的解析应为`(Get-ChildItem
    $env:Temp | Measure-Object).Count`。
- en: All resolutions should return `undef` in the result of an error and should time
    out after 10 seconds.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 所有解析应在错误结果中返回`undef`，并且在10秒后超时。
- en: Note that it can be useful to look at your clients’ current facts on the web
    console so that you know how to confine them.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Web控制台查看客户端当前的事实可能很有用，这样你就能知道如何限制它们。
- en: 'For each of the facts, use the `bolt` command as follows to upload them to
    the correct locations:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个事实，使用以下`bolt`命令将其上传到正确的位置：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Go to the web console and view the facts in your nodes to confirm they are on
    your clients.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 前往Web控制台并查看节点中的事实，以确认它们是否已出现在客户端。
- en: You can find the example solutions at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/tmp_count.rb](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/tmp_count.rb)
    and [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/packlab.yaml](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/packlab.yaml).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/tmp_count.rb](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/tmp_count.rb)
    和 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/packlab.yaml](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/packlab.yaml)
    找到示例解决方案。
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When testing custom or external facts, they can be set manually with environment
    variables by setting `FACTER_<fact_name>` in UNIX environments using `export FACTER_exampleapp
    ="test"` or in Windows environments by using `env FACTER_exampleapp="test"` –
    this would hard-set the `exampleapp` fact. This method only works with custom
    or external facts and not core facts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试自定义或外部事实时，可以通过设置环境变量手动设置它们，在 UNIX 环境中使用 `export FACTER_exampleapp ="test"`，或者在
    Windows 环境中使用 `env FACTER_exampleapp="test"` —— 这样会强制设置 `exampleapp` 事实。此方法仅适用于自定义或外部事实，而不适用于核心事实。
- en: Functions
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Functions are sections of Ruby code that can be run during catalog compilation
    and allow you to modify the catalog or calculate and return values. Puppet has
    many built-in functions and more can be supplied via modules from Puppet Forge,
    such as [https://forge.puppet.com/modules/puppetlabs/stdlib](https://forge.puppet.com/modules/puppetlabs/stdlib),
    or custom-written functions added to modules. This book will not cover writing
    functions, but a complete guide can be found at [https://puppet.com/docs/puppet/latest/writing_custom_functions.html](https://puppet.com/docs/puppet/latest/writing_custom_functions.html).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是可以在目录编译过程中运行的 Ruby 代码段，允许你修改目录或计算并返回值。Puppet 提供了许多内建函数，更多的函数可以通过 Puppet Forge
    模块提供，如 [https://forge.puppet.com/modules/puppetlabs/stdlib](https://forge.puppet.com/modules/puppetlabs/stdlib)，或者通过自定义编写的函数添加到模块中。本书不会涵盖编写函数的内容，但可以在
    [https://puppet.com/docs/puppet/latest/writing_custom_functions.html](https://puppet.com/docs/puppet/latest/writing_custom_functions.html)
    找到完整的指南。
- en: 'In this section, we will cover the three different types of functions: statement,
    prefix, and chained. A selection of the core Puppet functions will be shown, grouped
    by purpose to demonstrate the most used and useful functions.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍三种不同类型的函数：语句函数、前缀函数和链式函数。我们将展示一组核心的 Puppet 函数，并按目的分组，展示最常用和最有用的函数。
- en: Note
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A lot of functions were moved from sources such as the `stdlib` module into
    the core Puppet function. The full list can be reviewed at [https://puppet.com/docs/puppet/6/release_notes_puppet.html#release_notes_puppet_x-0-0](https://puppet.com/docs/puppet/6/release_notes_puppet.html#release_notes_puppet_x-0-0).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数已从如 `stdlib` 模块等源移入核心 Puppet 函数。完整列表可在 [https://puppet.com/docs/puppet/6/release_notes_puppet.html#release_notes_puppet_x-0-0](https://puppet.com/docs/puppet/6/release_notes_puppet.html#release_notes_puppet_x-0-0)
    中查看。
- en: Statement functions
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句函数
- en: Statement functions are Puppet language-provided functions used only for their
    side effects, which always return `undef` values. Statement functions can omit
    brackets, unlike the other functions we will review in this section. You cannot
    add custom or Forge-provided statement functions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 语句函数是 Puppet 语言提供的函数，仅用于它们的副作用，这些函数总是返回 `undef` 值。语句函数可以省略括号，不像我们将在本节中介绍的其他函数那样。你不能添加自定义的或由
    Forge 提供的语句函数。
- en: Catalog statements
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录语句
- en: 'Catalog statements affect the content of the catalog, allowing classes to be
    included, dependencies and containment to affect the order of the catalog, and
    tags to be applied. The following shows an example syntax of catalog statements:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 目录语句会影响目录的内容，允许类被包含，依赖关系和包含关系影响目录的顺序，并且可以应用标签。以下是目录语句的示例语法：
- en: '[PRE35]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The use of `Include` and `tag` was discussed in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048),
    but we didn’t look at the `tag` function in much detail. The `tag` function is
    used within a class to mark that class, and all contained objects with the tag
    or list of tags.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Include` 和 `tag` 的使用已在 [*第 3 章*](B18492_03.xhtml#_idTextAnchor048) 中讨论，但我们没有详细探讨
    `tag` 函数。`tag` 函数用于在类中标记该类，并将标签或标签列表应用于所有包含的对象。'
- en: In [*Chapter 6*](B18492_06.xhtml#_idTextAnchor185), we will cover the full use
    of `require` and `contain`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 6 章*](B18492_06.xhtml#_idTextAnchor185) 中，我们将详细介绍 `require` 和 `contain`
    的完整使用。
- en: Logging statements
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志语句
- en: Logging statements allow for string messages to be sent to log output on the
    Puppet server. In [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252), server and
    agent logging will be reviewed in full as logging locations depend on the configuration
    and whether Puppet enterprise or open source is used. The syntax for a logging
    statement is simply `<logging` `level>(<string >)`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 日志语句允许将字符串消息发送到 Puppet 服务器的日志输出。在 [*第10章*](B18492_10.xhtml#_idTextAnchor252)
    中，将全面回顾服务器和代理的日志记录，因为日志位置取决于配置以及使用的是 Puppet 企业版还是开源版。日志语句的语法就是 `<logging` `level>(<string
    >)`。
- en: 'The following log levels can be applied:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 可以应用以下日志级别：
- en: '`debug`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`'
- en: '`info`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`'
- en: '`notice`'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notice`'
- en: '`warning`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warning`'
- en: '`err`'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`err`'
- en: '`fail`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail`'
- en: 'To log a warning message of `''code unexpected''`, the Puppet code would be
    as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要记录 `'code unexpected'` 的警告信息，Puppet 代码如下：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The string message can include variables if they are double-quoted for interpolation.
    So, to produce an error message of `''pa-risc is unsupported''` on a pa-risc architecture
    system, the Facter `os.arch` fact can be used within the error function string:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串消息可以包含变量，如果它们被双引号包围以进行插值。因此，为了在 pa-risc 架构系统上产生 `'pa-risc is unsupported'`
    错误消息，可以在错误函数的字符串中使用 Facter `os.arch` 的事实：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This differs from the examples this book has used up till now, particularly
    with the `notify` resource used in the previous chapter’s examples. The `notify`
    resource returns to the client’s logging while the log-level functions will log
    to the Puppet server. As `notify` is a resource and not a function, it will result
    in the report showing that a resource is changed every time a `notify` resource
    is called.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这与本书之前使用的示例不同，特别是前一章示例中使用的 `notify` 资源。`notify` 资源会返回到客户端的日志，而日志级别函数则会记录到 Puppet
    服务器上。由于 `notify` 是资源而不是函数，每次调用 `notify` 资源时，报告都会显示该资源发生了变化。
- en: '`fail` differs from the other levels as calling it as a function will terminate
    the compilation and result in no catalog being sent to the agent.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`fail` 与其他级别不同，因为将其作为函数调用时会终止编译，并且不会将目录发送到代理。'
- en: Prefix and chained functions
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前缀和链式函数
- en: Puppet functions can be called in two ways and for many functions, either can
    be applicable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 函数可以通过两种方式调用，对于许多函数，两种方式都可以适用。
- en: 'Prefix functions are called by writing the name of the function and then providing
    a list of arguments in brackets:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀函数通过编写函数名称然后提供一个括号中的参数列表来调用：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Chained functions are created from an argument, a full stop (`.`), then the
    function name with brackets, and any further arguments in those brackets:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 链式函数是通过一个参数、一个句点 (`.`)，然后是函数名称和括号，以及括号内的任何其他参数来创建的：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: A selection of built-in functions
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些内置函数的选择
- en: There are many functions available in core Puppet, and this section will group
    different functions to show examples of how they can be used or refer to where
    in this book we will cover them in more detail. The intention of this chapter
    is not to give the full syntax of every function but to expose a breadth of functions.
    You can refer to the full functions list at [https://puppet.com/docs/puppet/latest/function.html](https://puppet.com/docs/puppet/latest/function.html).
    Make sure you select the correct version of the documentation for the Puppet environment
    you are working with.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 核心 Puppet 中有许多可用的函数，本节将对不同函数进行分组，展示它们如何使用，或指明本书中的哪些地方会更详细地介绍它们。本章的目的是展示函数的多样性，而不是给出每个函数的完整语法。你可以在
    [https://puppet.com/docs/puppet/latest/function.html](https://puppet.com/docs/puppet/latest/function.html)
    查阅完整的函数列表。确保选择适合你正在使用的 Puppet 环境的文档版本。
- en: Comparison and sizing
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较和大小测量
- en: The following functions allow you to compare and measure the size of variables.
    They provide additional capability beyond what can directly be done with data
    types.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数允许你比较和测量变量的大小。它们提供了比数据类型直接操作更多的功能。
- en: 'The `length` and `size` functions are effectively the same and can both be
    used as prefixes or chained functions on arrays (number of elements), hashes (number
    of key-value pairs), strings (characters), or binaries (bytes) to confirm the
    relative size/length of the variable. For example, the following command would
    return `4` as the length of the string four and `5` as the size of the array:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 和 `size` 函数实际上是相同的，都可以作为前缀或链式函数应用于数组（元素数量）、哈希（键值对数量）、字符串（字符数）或二进制数据（字节数），以确认变量的相对大小/长度。例如，以下命令将返回
    `4` 作为字符串 "four" 的长度，返回 `5` 作为数组的大小：'
- en: '[PRE40]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`match` is used as a chained function on a string or an array of strings with
    a regular expression to match patterns. It returns an array containing the string
    that has been matched in index 0, followed by the pattern(s) that matched. If
    there are no patterns in the following example, where there’s a string that must
    start with a lowercase letter to start, then the numbers will be `6` to `8` in
    length. The variable matches `a123456` and returns an array containing `[ ''a123456'',
    ''a'' , ''``123456'' ]`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`match` 用作字符串或字符串数组上的链式函数，结合正则表达式匹配模式。它返回一个数组，包含第一个匹配的字符串，后跟匹配的模式。如果没有匹配模式，则会返回一个示例，其中字符串必须以小写字母开头，长度为
    `6` 到 `8` 的数字。变量匹配 `a123456` 并返回一个包含 `[ ''a123456'', ''a'' , ''123456'' ]` 的数组：'
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we tried this same regular expression on a non-matching string, `1a23456`,
    `undef` will be returned:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个不匹配的字符串 `1a23456` 上尝试相同的正则表达式，则会返回 `undef`：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using an array of strings (`''a123456''`, `''b1254678''`, and `''1a23456''`)
    with the same regular expression results in the `multi_match` variable containing
    an array of arrays. This is the output if `match` had been used on each string
    individually:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串数组（`'a123456'`、`'b1254678'` 和 `'1a23456'`）和相同的正则表达式，会导致 `multi_match` 变量包含一个数组的数组。如果对每个字符串单独使用
    `match`，则输出将是：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This means `multi_match` will contain `[['a123456','a','123456'],['b1254678','b','1254678'],undef]`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 `multi_match` 将包含 `[['a123456','a','123456'],['b1254678','b','1254678'],undef]`。
- en: '`max` and `min` are used as prefix functions. They take an array of strings
    or numeric values and return the largest and smallest values in each case. Before
    Puppet 6.0, there was guidance as to how it would convert and handle mixed types
    used in these functions. However, now that it’s deprecated, it is strongly advised
    that you ensure comparisons are like for like. In the following example, the variable
    highest number would contain `88`, while the lowest letter would contain `''a''`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`max` 和 `min` 用作前缀函数。它们接受一个字符串或数字的数组，并返回每种情况中的最大值和最小值。在 Puppet 6.0 之前，关于如何转换和处理这些函数中使用的混合类型有一些指导意见。然而，由于它已经被弃用，现在强烈建议确保比较的类型一致。在以下示例中，`highest
    number` 变量将包含 `88`，而 `lowest letter` 变量将包含 `''a''`：'
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`empty` is used as a prefix or chained function to confirm if an array or hash
    contains no elements or if a string or binary contains no length. In the following
    examples, the `empty_array` and `empty` strings would contain `true`, while the
    `non_empty_string` variable would contain `false`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`empty` 用作前缀或链式函数，用来确认一个数组或哈希是否不包含元素，或者一个字符串或二进制是否为空。在以下示例中，`empty_array` 和
    `empty` 字符串将包含 `true`，而 `non_empty_string` 变量将包含 `false`：'
- en: '[PRE45]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`compare` is used as a prefix function that compares two values and returns
    `-1`, `0`, or `1` if the first value is less than, equal to, or greater than the
    second, respectively. The two values must be of the same type and can be numeric,
    strings, timespans, timestamps, or semvars. For two strings, a third argument
    (a Boolean) can be used to check whether the comparison should ignore casing.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`compare` 用作前缀函数，用于比较两个值，并返回 `-1`、`0` 或 `1`，分别表示第一个值小于、等于或大于第二个值。两个值必须为相同类型，可以是数字、字符串、时间段、时间戳或语义版本。对于两个字符串，可以使用第三个参数（布尔值）来检查比较是否忽略大小写。'
- en: 'For example, the `numeric_compare` variable would contain `-1`, while the `string_compare`
    variable would contain `1` as capitals would be greater than lowercase letters
    and `A` would come before `b`. If the Boolean were set to `true`, it would return
    `1`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`numeric_compare` 变量将包含 `-1`，而 `string_compare` 变量将包含 `1`，因为大写字母大于小写字母，`A`
    会排在 `b` 前面。如果布尔值设置为 `true`，则返回 `1`：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Change case
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变大小写
- en: The following functions change the case of strings or arrays/hashes of strings.
    In the case of integers, they remain unchanged and will contain other incomputable
    data type errors.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于改变字符串或字符串的数组/哈希的大小写。对于整数，它们保持不变，并可能包含其他无法计算的数据类型错误。
- en: '`capitalize`, `camelCase`, `downcase`, and `upcase` are all used as prefixes
    or chained functions to change the capitalization of a string or a set of strings
    on an iterable, such as an array. `downcase` and `upcase` can also be used on
    an array. All can be used on a numeric but will simply return the numeric unaffected.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitalize`、`camelCase`、`downcase` 和 `upcase` 都用作前缀或链式函数来改变字符串或可迭代对象（如数组）中字符串的大小写。`downcase`
    和 `upcase` 也可以在数组上使用。它们都可以用于数字类型，但会返回未受影响的数字。'
- en: CamelCase removes any underscores (`_`) that were used when applied. `camelCase`
    and `capitalize` are not recursive on an array but `upcase` and `downcase` are.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: CamelCase 会去除应用时使用的所有下划线 (`_`)。`camelCase` 和 `capitalize` 对数组不是递归的，而 `upcase`
    和 `downcase` 是递归的。
- en: 'If `downcase` or `upcase` changes keys in an array while being used recursively
    and this creates duplicates, it will overwrite the key, using the last key-value
    pair that was updated in its place. To show some examples, the `upper_case` variable
    will contain a string called `UPANDDOWN` upon making the whole string upper case,
    while `downcase` will contain a hash of `{''lower'' => ''case2''}` upon downcasing
    both keys and overwriting the first:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `downcase` 或 `upcase` 在递归使用时更改了数组中的键，并且因此产生了重复项，它将覆盖该键，使用最后更新的键值对替代。为了举例说明，`upper_case`
    变量在将整个字符串转换为大写后将包含一个名为 `UPANDDOWN` 的字符串，而 `downcase` 变量在将键都转换为小写并覆盖第一个时，将包含一个哈希值
    `{'lower' => 'case2'}`：
- en: '[PRE47]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `capitals` variable will contain an array called `[''Up, Mix'']` after
    capitalizing each string in the array:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`capitals` 变量在将数组中的每个字符串首字母大写后，将包含一个名为 `[''Up, Mix'']` 的数组：'
- en: '[PRE48]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The `downcase` variable will contain a hash of `{''lower'' => ''case2''}` after
    downcasing both keys and overwriting the first:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`downcase` 变量在将键值都转换为小写并覆盖第一个值后，将包含一个哈希值 `{''lower'' => ''case2''}`：'
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `camel` variable will contain `Word1Word2Word3` after removing the underscores
    and setting the capitalization to `camelCase`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`camel` 变量在去除下划线并将大写方式设置为 `camelCase` 后，将包含 `Word1Word2Word3`：'
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you’re using international characters, you need to review how to Ruby system
    locale handles these characters as it is used to handle changes in casing.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用国际字符，你需要检查 Ruby 系统的区域设置是如何处理这些字符的，因为它用于处理大小写转换。
- en: String manipulation
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串操作
- en: The `lstrip`, `rstrip`, and `strip` functions allow spacing to be removed from
    strings. They are all prefixes or chained functions that are used to remove spaces
    from a string. `lstrip` removes leading spacing, `rstrip` removes trailing spacing,
    and `strip` removes both leading and trailing white spacing such as space, tab,
    newline, and return but not hard space. They can be used on a string or an iterable
    but not recursively. If used on numerics, they will return numeric unadjusted
    types but will result in an error on any other unsupported type.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`lstrip`、`rstrip` 和 `strip` 函数可以移除字符串中的空格。它们都是前缀或链式函数，用于从字符串中移除空格。`lstrip`
    移除前导空格，`rstrip` 移除尾随空格，`strip` 同时移除前导和尾随空格（如空格、制表符、换行符和回车符），但不包括硬空格。它们可以在字符串或可迭代对象上使用，但不能递归使用。如果用于数字类型，它们将返回未经调整的数字类型，但在任何其他不支持的类型上会产生错误。'
- en: 'The following example, which uses all three functions, will result in the `left`
    variable containing `''first second''`, the `right` variable containing `''first
    second''`, and the `all` variable containing `''firstsecond''`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用了所有三个函数，最终将使 `left` 变量包含 `'first second'`，`right` 变量包含 `'first second'`，并且
    `all` 变量包含 `'firstsecond'`：
- en: '[PRE51]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Lambdas
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包
- en: 'These functions are not lambdas themselves but are most useful when used with
    lambdas since they allow arrays or hashes variables to be iterated over or transformed
    and passed to lambdas, which are sections of Puppet code. The following functions
    are used on variables to define their behavior: `all`, `any`, `break`, `each`,
    `filter`, `index`, `lest`, `map`, `next`, `return`, `reduce`, `reverse_each`,
    `step`, `then`, `tree_each`, `unique`, and `with`.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数本身不是闭包，但在与闭包一起使用时最为有用，因为它们允许对数组或哈希变量进行迭代或转换，并传递给闭包，闭包是 Puppet 代码的一个部分。以下函数用于定义变量的行为：`all`、`any`、`break`、`each`、`filter`、`index`、`lest`、`map`、`next`、`return`、`reduce`、`reverse_each`、`step`、`then`、`tree_each`、`unique`
    和 `with`。
- en: 'The syntax and behaviors of these functions will be covered in full in [*Chapter
    6*](B18492_06.xhtml#_idTextAnchor185), but to show an example, here, we are using
    the `each` function and a hash containing user name keys and numbers representing
    their user ID. The `each` function can take each key pair as an array and allow
    user resources to be created with the assigned IDs:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的语法和行为将在[*第6章*](B18492_06.xhtml#_idTextAnchor185)中详细讲解，但为了举个例子，这里我们使用了 `each`
    函数和一个包含用户名键及其对应用户ID数字的哈希。`each` 函数可以将每对键值作为一个数组，并允许为用户资源创建已分配的ID：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Many functions can use lambdas for error handling, which allows you to loop
    through the error sections, messages, and issue codes and allows for more detailed
    messages or actions to be taken. This will be covered in [*Chapter 6*](B18492_06.xhtml#_idTextAnchor185).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数可以使用lambda进行错误处理，这使得您可以循环处理错误部分、消息和问题代码，并允许采取更详细的消息或动作。这将在[*第6章*](B18492_06.xhtml#_idTextAnchor185)中讨论。
- en: Templating
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板
- en: 'Templates allow you to create complicated text with simple inputs for substitution.
    In [*Chapter 6*](B18492_06.xhtml#_idTextAnchor185), we will cover templates in
    full, but the `template` and `epp` functions allow the ERB and EPP formats for
    templates to be used via the `content` attribute of the `file` resource. An example
    of using the ERB format and informing the `content` attribute can be found in
    the `exampleapp` module:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 模板允许您通过简单的输入替换创建复杂的文本。在[*第6章*](B18492_06.xhtml#_idTextAnchor185)中，我们将详细讨论模板，但`template`和`epp`函数允许通过`file`资源的`content`属性使用ERB和EPP格式的模板。使用ERB格式并通知`content`属性的示例可以在`exampleapp`模块中找到：
- en: '[PRE53]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The structure of modules and how to store template files will be covered in
    [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的结构以及如何存储模板文件将在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中介绍。
- en: 'Alternatively, to use a string containing a template format and pass the value,
    `inline_template` and `epp_inline` can be used. For example, to use an EPP style
    template where it is presumed `$exampleapp_conf_template` contains a string in
    EPP template format, `inline_epp` will substitute the port and debug the variable
    values of `exampleapp_port` and `exampleapp_debugging_enabled`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了使用包含模板格式的字符串并传递值，可以使用`inline_template`和`epp_inline`。例如，要使用EPP样式模板，假设`$exampleapp_conf_template`包含EPP模板格式的字符串，`inline_epp`将替换端口和调试变量值`exampleapp_port`和`exampleapp_debugging_enabled`：
- en: '[PRE54]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Hash/array
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 哈希/数组
- en: The following functions are used to either access and manipulate hash and array
    data beyond the normal operators available, which were discussed in [*Chapter
    4*](B18492_04.xhtml#_idTextAnchor078), or to manipulate variables into hashes
    and arrays.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数用于访问和操作哈希和数组数据，超出了[*第4章*](B18492_04.xhtml#_idTextAnchor078)中讨论的常规操作符，或者用于将变量转换为哈希和数组。
- en: 'The `dig` function is used to search through a complex data structure by providing
    various keys or indices. It is particularly useful in situations where the structure
    is not well defined. For instance, suppose we have a data structure called `exampleapp_proc`,
    and we want to access the state of the process with ID `124`. If we tried to access
    it using a hash index such as `exampleapp_proc[''exampleapp_pids''][''124''][''state'']`,
    but the `124` key was not present in the hash, we would get an error and the catalog
    run would fail. However, by using the `dig` function instead, the notice will
    be undefined:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`dig`函数用于通过提供各种键或索引在复杂数据结构中进行查找。当结构不明确时，它特别有用。例如，假设我们有一个名为`exampleapp_proc`的数据结构，并且我们想访问ID为`124`的进程状态。如果我们尝试使用哈希索引如`exampleapp_proc[''exampleapp_pids''][''124''][''state'']`来访问，但哈希中没有`124`这个键，我们将收到错误，目录运行将失败。然而，通过使用`dig`函数，通知将为未定义：'
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `getvar` function is used to return parts of a structured variable using
    dot notation. If the variable does not exist, it will return `undef` instead of
    throwing an error, unlike direct access to structured variables. You can also
    set a default value if the value is not found; otherwise, it will return `undef`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`getvar`函数用于使用点符号返回结构化变量的部分。如果变量不存在，它将返回`undef`，而不是抛出错误，这与直接访问结构化变量不同。如果没有找到值，您还可以设置默认值；否则，它将返回`undef`。'
- en: 'The first command uses `getvar` to access the `os.release.full` fact, while
    the second command sets the return value to `''not_found''` if the structured
    fact is not found:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令使用`getvar`访问`os.release.full`事实，而第二个命令在未找到结构化事实时将返回`'not_found'`：
- en: '[PRE56]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `join` function is used to convert an array into a string of elements using
    a specified delimiter. For instance, if you have an array of data center locations
    such as `dc_locations = [''london'', ''falkirk'', ''portland'', ''belfast'']`,
    you can use the `join` function to print a colon-separated string of those locations;
    for example, `notice(join(${dc_locations}, ":"))` This will produce the `"london:falkirk:portland:belfast"`
    string in the notice:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`函数用于将一个数组转换为使用指定分隔符的元素字符串。例如，如果你有一个数据中心位置数组`dc_locations = [''london'',
    ''falkirk'', ''portland'', ''belfast'']`，你可以使用`join`函数打印一个以冒号分隔的字符串，表示这些位置；例如，`notice(join(${dc_locations},
    ":"))`。这将在通知中生成字符串`"london:falkirk:portland:belfast"`：'
- en: '[PRE57]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'However, if you use `join` on an array that contains a nested array, it will
    flatten the array, but it won’t affect hashes or arrays within hashes. For example,
    `join([{London => [''bromley'', ''brentford'']}, ''Berlin'', ''Falkirk'', ''Grangemouth''],
    ''@@'')` would print `[ { London => [ ''bromley'', ''brentford'' ] }@@Berlin@@Falkirk@@Grangemouth
    ]` because the first element of the array is a hash and it won’t be flattened
    despite it containing a hash:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你对包含嵌套数组的数组使用`join`，它将展平数组，但不会影响哈希或哈希中的数组。例如，`join([{London => ['bromley',
    'brentford']}, 'Berlin', 'Falkirk', 'Grangemouth'], '@@')`将打印`[ { London => [
    'bromley', 'brentford' ] }@@Berlin@@Falkirk@@Grangemouth ]`，因为数组的第一个元素是哈希，它不会被展平，尽管它包含了哈希：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `keys` and `values` functions take a hash and return an array of the keys
    in the hash it can be run as a prefix or chained function. For example, to print
    the list of keys of the `offices` variable, the first two `notice` functions would
    print an array of `[''Germany'',''Holland'']`, while the next two would print
    an array of `[''Berlin'',Amsterdam'']`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`keys`和`values`函数接受一个哈希并返回哈希中键的数组，可以作为前缀或链式函数运行。例如，要打印`offices`变量的键列表，前两个`notice`函数将打印数组`[''Germany'',''Holland'']`，而接下来的两个将打印数组`[''Berlin'',Amsterdam'']`：'
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: These keys or values will be in the same order as they were declared in the
    hash. If the hash is empty, it will return an empty array.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这些键或值将与它们在哈希中声明时的顺序相同。如果哈希为空，则返回一个空数组。
- en: 'The `split` function takes a string and, using a pattern to represent a field
    separator, can break a string into an array of elements. This pattern can be a
    string, regexp, or regexp. The following example shows how to split using each
    pattern method and pick different separators or multiple separators:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`split`函数接受一个字符串，并使用一个模式来表示字段分隔符，可以将字符串拆分为一个数组元素。这个模式可以是字符串、正则表达式或正则表达式。以下示例展示了如何使用不同的模式方法进行拆分，并选择不同的分隔符或多个分隔符：'
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `split_on_at` variable would contain an array of `['north','south.east','west']`,
    `split_on_fullstop` would contain an array of `['north@south ', 'east@west']`
    and `split_on_both` would contain an array of `['north','south,'east','west']`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`split_on_at`变量将包含数组`[''north'',''south.east'',''west'']`，`split_on_fullstop`将包含数组`[''north@south
    '',''east@west'']`，而`split_on_both`将包含数组`[''north'',''south'',''east'',''west'']`。'
- en: The `sort` function takes an array and sorts the array numerically or by lexicographical
    order. It is not possible to mix these orderings and have numeric and lexigraphic
    values as this will result in an error and no conversion. Comparing characters
    is based on system locale and is case-sensitive unless `compare` and lambdas are
    used.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数接受一个数组，并按数字顺序或字典顺序对数组进行排序。无法混合这些排序方式，也无法同时进行数字和字典值的排序，否则会导致错误且没有转换。字符比较基于系统语言环境，并且区分大小写，除非使用`compare`和匿名函数。'
- en: 'In its simplest form, `sort` will sort numbers and strings in ascending order
    – for example, we can take an unordered array of numbers and an unordered array
    of strings and use `sort` as a prefix or a chained function. In this example,
    the code will result in ordered numbers containing `[0,1,2,3,4,5,7,8,9]` and ordered
    strings containing `[''a'',''b'',''c'',''d'']`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式下，`sort`将按升序对数字和字符串进行排序——例如，我们可以拿一个无序的数字数组和一个无序的字符串数组，并使用`sort`作为前缀或链式函数。在这个示例中，代码将得到按升序排列的数字`[0,1,2,3,4,5,7,8,9]`和按升序排列的字符串`['a','b','c','d']`：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To specify the order explicitly, you can use the `compare` function to order
    the variables, highlighting if they should be ascending or descending. In the
    following example, the integers will be ordered `[1950,1980,1984,1985]` in the
    ascending variable and `[1985,1984,1980,1950]` in the descending variable:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确指定顺序，你可以使用`compare`函数对变量进行排序，强调它们应该是升序还是降序。在以下示例中，整数将在升序变量中按`[1950,1980,1984,1985]`排序，而在降序变量中按`[1985,1984,1980,1950]`排序：
- en: '[PRE62]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As we learned when we discussed `compare` in the *Comparison and sizing* section,
    a Boolean can be used on `compare` to order by capitals or not.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在讨论 *比较和大小* 部分的 `compare` 时学到的，布尔值可以用于 `compare`，以确定是否按大写字母排序。
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Instead of using the `compare` function, other functions from the *Comparison
    and sizing* section such as `max` or `min` can be used.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 *比较和大小* 部分中的其他函数，如 `max` 或 `min`，来替代使用 `compare` 函数。
- en: Data handling
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据处理
- en: There are several data-related functions for Hiera and encrypted EYAML. These
    will be covered in full in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233), but
    for reference, they are `eyaml_look_up_key`, `lookup`, and `yaml_data`. The function
    documentation states that a few `hiera_<type>` functions were depreciated for
    the `lookup` function.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 针对 Hiera 和加密的 EYAML，提供了几个与数据相关的函数。它们将在[*第9章*](B18492_09.xhtml#_idTextAnchor233)中详细讨论，但作为参考，它们是
    `eyaml_look_up_key`，`lookup` 和 `yaml_data`。函数文档指出，几个 `hiera_<type>` 函数已被废弃，取而代之的是
    `lookup` 函数。
- en: The `unwrap` function was previously covered in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048),
    whereby the function was used to make sensitive data types visible/accessible
    in Puppet code, as necessary.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`unwrap` 函数已在[*第3章*](B18492_03.xhtml#_idTextAnchor048)中讨论过，该函数用于在必要时使敏感数据类型在
    Puppet 代码中可见/可访问。'
- en: stdlib module functions
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: stdlib 模块函数
- en: Modules will be discussed in full in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212),
    but the `stdlib` module ([https://forge.puppet.com/modules/puppetlabs/stdlib](https://forge.puppet.com/modules/puppetlabs/stdlib))
    is so widely used that it is worth highlighting some of the functions that are
    available from the module as virtually every install of Puppet will make them
    available.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 模块将在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中详细讨论，但 `stdlib` 模块（[https://forge.puppet.com/modules/puppetlabs/stdlib](https://forge.puppet.com/modules/puppetlabs/stdlib)）被广泛使用，值得突出一些该模块提供的函数，因为几乎每个
    Puppet 安装都会使其可用。
- en: It is important to be aware that the functions in `stdlib` allow advanced behaviors
    that are not always best practice approaches to Puppet code, such as being able
    to read the contents of a YAML file into a string and using the `ensure_package`
    function, which is used to allow for multiple declarations of a package resource.
    They can provide useful workarounds in complex situations or when code is managed
    in multiple teams’ political situations.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`stdlib` 中的函数允许一些高级行为，这些行为并不总是 Puppet 代码的最佳实践方式，例如能够将 YAML 文件的内容读取为字符串，并使用
    `ensure_package` 函数，后者用于允许对包资源进行多次声明。在复杂的情况下或代码在多个团队的政治环境中进行管理时，它们可以提供有用的变通方法。
- en: Note
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Many functions have been made redundant by file type conversion, which was made
    available in Puppet 5, as well as other new features, but those have been left
    for compatibility purposes.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 许多函数已被文件类型转换所替代，该功能自 Puppet 5 版本开始提供，此外还有其他新特性，但这些函数为了兼容性目的被保留。
- en: Array and strings
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组和字符串
- en: The following functions interact with strings and arrays by combining, manipulating,
    and producing new arrays in several ways.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数通过合并、操作和以多种方式生成新数组来与字符串和数组进行交互。
- en: 'The `intersection` function is a chained function that, when provided with
    two arrays, will produce a single array of values contained in both. For example,
    the following code will put the `[''both'']` array into the `chained_array` variable:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`intersection` 函数是一个链式函数，当提供两个数组时，会生成一个包含两个数组中都存在的值的单一数组。例如，以下代码将 `[''both'']`
    数组放入 `chained_array` 变量中：'
- en: '[PRE63]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `union` function is a chained function that, when provided with two arrays,
    will produce a single array of unique values. In the following example, the `union_array`
    variable will contain the `[''``first'',''second'']` array:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`union` 函数是一个链式函数，当提供两个数组时，会生成一个包含唯一值的单一数组。在以下示例中，`union_array` 变量将包含 `[''first'',''second'']`
    数组：'
- en: '[PRE64]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The `range` function is a chained function that can be provided a start, end,
    or step interval (if not provided, this defaults to `1`). The start and end can
    be strings or numerics, while the optional step should be an integer.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`range` 函数是一个链式函数，提供起始、结束或步长区间（如果没有提供，默认步长为 `1`）。起始和结束可以是字符串或数字，而可选的步长应该是整数。'
- en: 'For example, the `onetoten` variable would contain an array of `[1,2,3,4,5,6,7,8,9,10]`,
    the `etog` variable would contain `[''E'',''F'',''G'']`, and `good_trek` would
    contain `[''StarTrek2'',''startrek4'',startrek6'',''starttrek8'']`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`onetoten` 变量将包含一个数组 `[1,2,3,4,5,6,7,8,9,10]`，`etog` 变量将包含 `['E','F','G']`，而
    `good_trek` 变量将包含 `['StarTrek2','startrek4','startrek6','starttrek8']`：
- en: '[PRE65]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `start_with` and `end_with` functions are chained functions that allow
    you to check if a string starts or ends with a provided string or list of strings,
    attempting to match any string in the list. It will return `true` or `false`,
    depending on the match. In the following example, `truestart` will contain `true`
    as `server` matches the start of `server1234`, `falseend` will contain `false`
    as `wales` does not end in `land`, and `trueoptions` will contain `true` as `aws104`
    starts with `aws` and could match other strings starting with `gcp` or `az`:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_with`和`end_with`函数是链式函数，允许你检查一个字符串是否以提供的字符串或字符串列表开始或结束，尝试匹配列表中的任意字符串。它将根据匹配情况返回`true`或`false`。在以下示例中，`truestart`将包含`true`，因为`server`匹配了`server1234`的开头，`falseend`将包含`false`，因为`wales`并没有以`land`结尾，而`trueoptions`将包含`true`，因为`aws104`以`aws`开头，并且可能匹配以`gcp`或`az`开头的其他字符串：'
- en: '[PRE66]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: File information
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件信息
- en: 'The `basename`, `dirname`, and `extname` functions can be used either as separate
    functions or chained together to extract the filename, directory, or extension
    from a file path. Here’s an example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`basename`、`dirname`和`extname`函数可以作为单独的函数使用，也可以链式使用，从文件路径中提取文件名、目录或扩展名。以下是一个示例：'
- en: '[PRE67]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note that `extname` only works with filenames in the format of `filename.extension`.
    If the string does not contain a dot (`.`), or if the dot appears at the beginning
    or end of the string, it will simply return an empty string.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`extname`仅适用于格式为`filename.extension`的文件名。如果字符串不包含点（`.`），或者点出现在字符串的开头或结尾，它将仅返回空字符串。
- en: Lab
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验
- en: 'Having covered a wide variety of functions, let’s practice using a handful
    of them. Let’s create a class called `example_functions` that takes the parameters
    of the user prefix as a string and several users as an integer. This class should
    take two parameters: a user prefix as a string, and several users as an integer.
    Ensure that the prefix is in lowercase. An array of usernames should be created
    starting from `0` up to the number of users specified. This array should then
    be passed to a user resource to create the users.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在涵盖了各种功能之后，让我们练习使用其中的一些。我们创建一个名为`example_functions`的类，它接受一个作为字符串的用户前缀和若干个作为整数的用户数量。此类应接受两个参数：一个用户前缀字符串和若干个用户整数。确保前缀是小写的。应从`0`开始创建一个用户名数组，直到指定的用户数量。然后将该数组传递给用户资源来创建用户。
- en: Define your class with the `user` string and the number `5`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`user`字符串和数字`5`来定义你的类。
- en: The code should also log a warning message containing text with the contents
    of the `os.windows.product_name` fact or `linux` if you’re not using a Windows
    machine.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 代码还应记录一条警告消息，其中包含`os.windows.product_name`事实的内容，或者如果你不使用Windows机器，则为`linux`。
- en: 'Finally, the code should take the `fact` path and ensure every directory is
    audited. Hint: you will want to separate this path into an array and pass it to
    a file resource. `windows` and `linux` use different separators for path objects
    – that is, `;` and `:`. The following `if` statement should help:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码应采用`fact`路径，并确保每个目录都经过审计。提示：你可能需要将此路径拆分为一个数组，并将其传递给文件资源。`windows`和`linux`使用不同的路径分隔符——即`；`和`:`。以下的`if`语句应该能帮助你：
- en: '[PRE68]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You should use `bolt` to make `stdlib` available locally on our clients:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你应使用`bolt`使`stdlib`在我们的客户端上可用：
- en: '[PRE69]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, apply the `puppet` class via `bolt` with the following command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过以下命令使用`bolt`应用`puppet`类：
- en: '[PRE70]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You can find some example solutions at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/example_functions.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/example_functions.pp).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/example_functions.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch05/example_functions.pp)找到一些示例解决方案。
- en: Deferred functions
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟函数
- en: A `Deferred` function (also known as an agent side function) is a function with
    the `Deferred` type applied to it. This causes the function to run locally on
    a client when the catalog is applied, rather than on a Puppet server during compilation.
    The catalog for a deferred function contains what to run on the client rather
    than the output of the function. The deferred type was introduced in Puppet 6.0
    and is available in all later versions.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deferred`函数（也称为代理端函数）是应用了`Deferred`类型的函数。这会导致该函数在应用目录时在客户端本地运行，而不是在Puppet服务器编译时运行。一个延迟函数的目录包含要在客户端运行的内容，而不是函数的输出。`Deferred`类型是在Puppet
    6.0中引入的，并且在所有后续版本中可用。'
- en: This is typically used when the compilation server can’t access a necessary
    source in a function – for example, when retrieving a secret from a HashiCorp
    Vault server, where security is set up to only allow the client to access a secret.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译服务器无法访问函数中所需的源时，通常会使用此方法——例如，当从HashiCorp Vault服务器检索秘密时，安全设置只允许客户端访问秘密。
- en: 'The syntax for applying `Deferred` is as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 应用`Deferred`的语法如下：
- en: '[PRE71]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The following is an example of retrieving a secret from `vault`. This can be
    used within a user resource for `exampleapp` to set the password from a Vault
    path of `exampleapp/password`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`vault`检索秘密的示例。这可以在`exampleapp`的用户资源中使用，从Vault路径`exampleapp/password`设置密码：
- en: '[PRE72]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This function is from the `vault_lookup` module ([https://forge.puppet.com/modules/puppet/vault_lookup](https://forge.puppet.com/modules/puppet/vault_lookup))
    and requires an underlying vault client setup to be available, as per the instructions
    within the module and the guide from Hashicorp: [https://www.hashicorp.com/resources/agent-side-lookups-with-hashicorp-vault-puppet-6](https://www.hashicorp.com/resources/agent-side-lookups-with-hashicorp-vault-puppet-6).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数来自`vault_lookup`模块（[https://forge.puppet.com/modules/puppet/vault_lookup](https://forge.puppet.com/modules/puppet/vault_lookup)），并需要根据模块中的说明以及Hashicorp的指南：[https://www.hashicorp.com/resources/agent-side-lookups-with-hashicorp-vault-puppet-6](https://www.hashicorp.com/resources/agent-side-lookups-with-hashicorp-vault-puppet-6)）设置底层的Vault客户端。
- en: 'It is important to understand the difference in using functions with `Deferred`.
    You cannot use a `Deferred` function to pass a variable to a string. This would
    result in the catalog creating a stringified version of the object. In the following
    example, which involves looking up a key value from `vault` called `exampleapp/message`,
    the first `notify` will return a string containing a stringified translation of
    the function name in the catalog, while the second `notify` will return the value
    of the vault lookup itself:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 理解使用带有`Deferred`的函数之间的差异很重要。你不能使用`Deferred`函数将变量传递给字符串。这样会导致目录创建该对象的字符串化版本。在以下示例中，涉及从`vault`查找名为`exampleapp/message`的键值，第一个`notify`将返回一个字符串，其中包含目录中函数名称的字符串化翻译，而第二个`notify`将返回`vault
    lookup`本身的值：
- en: '[PRE73]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This reflects the catalog compilation calculating the string value at compilation
    time. This mismatch can happen in other places, such as templates, but can be
    overcome by ensuring any deferred values are only used in isolation or within
    other deferred functions. In [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194),
    you will learn how to use a deferred template.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这反映了在编译时计算字符串值的目录编译过程。这种不匹配可能会出现在其他地方，例如模板中，但可以通过确保任何延迟的值仅在单独使用或在其他延迟函数中使用来克服。在[*第7章*](B18492_07.xhtml#_idTextAnchor194)中，你将学习如何使用延迟模板。
- en: A function can only be deferred if it uses core data types because the client
    only has core data types made available to it at runtime via plugin sync. In [*Chapter
    10*](B18492_10.xhtml#_idTextAnchor252), you will learn how plugin sync works with
    the client.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 函数只能在使用核心数据类型时延迟，因为客户端在运行时通过插件同步仅提供核心数据类型。在[*第10章*](B18492_10.xhtml#_idTextAnchor252)中，你将学习插件同步如何与客户端协作。
- en: Also, note that it is down to the implementation of the function itself whether
    it returns a sensitive value, and how it fails. In the case of the `vault_lookup`
    function, there is no graceful failure; it will return an error, resulting in
    an errored catalog run.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 同时需要注意，是否返回敏感值以及如何失败，取决于函数本身的实现。对于`vault_lookup`函数，无法优雅地失败；它将返回一个错误，导致目录运行出错。
- en: Note
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: As of Puppet 7.17.0, deferred functions can now be called on demand instead
    of being preprocessed. Using this method, the catalog can provide inputs to the
    deferred function. If the deferred function fails, then only the affected resource
    will fail, while all other resources will still be applied. To enable this behavior,
    set `Puppet[:preprocess_deferred] = false` or use `--no-preprocess_deferred`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 从Puppet 7.17.0开始，延迟函数现在可以按需调用，而不是预处理。使用此方法，目录可以为延迟函数提供输入。如果延迟函数失败，则只有受影响的资源会失败，而所有其他资源仍然会被应用。要启用此行为，设置`Puppet[:preprocess_deferred]
    = false`或使用`--no-preprocess_deferred`。
- en: All these behaviors apply to a local `puppet apply run` since a `puppet apply
    run` will generate a catalog and apply it locally.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些行为适用于本地的`puppet apply run`，因为`puppet apply run`将生成目录并在本地应用。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how the Facter tool provides system profiling information
    with its facts and how this can be expanded using external facts and custom facts.
    We warned you that there is an infrastructure cost to gathering facts and that
    the scale it will work with should be balanced. We stated that external facts
    can be simple flat files of static data or executable scripts, as allowed by the
    operating system. Custom facts, although written in Ruby, were shown to have several
    advantages over external facts. Being able to confine the custom fact to only
    run on certain systems allows you to choose different resolutions with a weight
    as to which should be selected and timeouts at the resolution level in Puppet
    7 or the execution level in Puppet 6 and below.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Facter工具如何通过其事实提供系统配置文件信息，以及如何使用外部事实和自定义事实来扩展这些信息。我们提醒你，收集事实会产生基础设施成本，且应平衡其适用的规模。我们指出，外部事实可以是操作系统允许的简单静态数据的平面文件或可执行脚本。尽管自定义事实是用Ruby编写的，但它们相比外部事实具有若干优势。能够将自定义事实仅限于在某些系统上运行，可以让你选择不同的分辨率，并根据权重选择应被选中的分辨率，以及在Puppet
    7中的分辨率级别或Puppet 6及以下版本中的执行级别设置超时。
- en: Next, we reviewed functions and highlighted the vast range of tasks functions
    can do to manipulate the catalog or return calculated values in Puppet code. Here,
    we discussed catalog statements, which are used to include classes in the catalog,
    and logging statements, which are used to set logging messages. The other two
    types of functions, prefix and chained, were highlighted, along with their syntax.
    Then, a selection of core functions was shown, along with various categories that
    expose the available functions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们回顾了函数，并强调了函数在操控目录或返回计算值方面可以完成的广泛任务。在这里，我们讨论了目录语句，它们用于在目录中包含类，以及日志记录语句，它们用于设置日志信息。我们还突出了另外两种类型的函数，即前缀函数和链式函数，并展示了它们的语法。然后，我们展示了一个核心函数的选择，并介绍了暴露可用函数的各种类别。
- en: Then, we discussed a small selection of functions from the `stdlib` module to
    highlight what can be provided. Note that some of the `stdlib` functions have
    been deprecated and are only there for backward compatibility or to be used for
    edge cases, which is not a best practice.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了`stdlib`模块中的一小部分函数，重点介绍了可以提供的内容。请注意，一些`stdlib`函数已经被弃用，仅用于向后兼容或处理极限情况，这并不是最佳实践。
- en: Finally, we discussed deferred functions, which allow functions to run during
    the application of the catalog on a client. We highlighted the advantage of this
    for services that may only be available to the client, such as making API calls
    to secure services, or may be undesirable to be run on Puppet infrastructure shared
    with other services.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了延迟函数，这些函数允许在客户端应用目录时运行。我们强调了这对某些只对客户端可用的服务（例如对安全服务进行API调用）或可能不希望在与其他服务共享的Puppet基础设施上运行的服务的优势。
- en: In the next chapter, you will learn how relationships and dependencies work
    between resources and classes. We will look at how scope and containment affect
    resources, variables, and classes and how to structure code and necessary dependencies
    without encountering common pitfalls and dependency hell.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习资源和类之间的关系和依赖关系如何工作。我们将查看作用域和包含性如何影响资源、变量和类，以及如何构建代码和必要的依赖关系，而不陷入常见的陷阱和依赖地狱。
- en: Part 2 – Structuring, Ordering, and Managing Data in the Puppet Language
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分——在Puppet语言中结构化、排序和管理数据
- en: This part will look at the more advanced Puppet language features. We will show
    how to manage dependencies and flow within code using iteration and conditions.
    We will then see how to use best practices to structure Puppet into modules using
    roles and profile patterns. Puppet Forge will be shown to be a useful source of
    pre-built modules and we will look at how to understand and review the source
    and content of those modules. We will then look at how to manage data with Puppet
    using Hiera and understand the best practices in terms of when to use separate
    data sources and variables.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分将介绍更高级的Puppet语言特性。我们将展示如何使用迭代和条件来管理代码中的依赖关系和流程。接着，我们将看到如何使用最佳实践将Puppet结构化为模块，采用角色和配置模式。Puppet
    Forge将展示为一个有用的预构建模块源，我们将查看如何理解和审查这些模块的源代码和内容。接着，我们将查看如何使用Hiera管理Puppet中的数据，并了解何时使用独立的数据源和变量的最佳实践。
- en: 'This part has the following chapters:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 6*](B18492_06.xhtml#_idTextAnchor185), *Relationships, Ordering,
    and Scope*'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18492_06.xhtml#_idTextAnchor185)，*关系、排序与作用域*'
- en: '[*Chapter 7*](B18492_07.xhtml#_idTextAnchor194), *Templating, Iterating**,
    and Conditionals*'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18492_07.xhtml#_idTextAnchor194)，*模板化、迭代**和条件语句*'
- en: '[*Chapter 8*](B18492_08.xhtml#_idTextAnchor212), *Developing and Managing Modules*'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18492_08.xhtml#_idTextAnchor212)，*开发与管理模块*'
- en: '[*Chapter 9*](B18492_09.xhtml#_idTextAnchor233), *Handling Data with Puppet*'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18492_09.xhtml#_idTextAnchor233)，*使用Puppet处理数据*'
