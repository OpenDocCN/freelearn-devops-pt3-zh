- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Automating Tasks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化任务
- en: The goal of the future is full unemployment. So that we can play.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 未来的目标是实现完全失业。这样我们就可以去玩了。
- en: – Arthur C Clarke
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: – 亚瑟·C·克拉克
- en: This is probably going to be my favorite chapter. Seriously, once you have drunk
    the sweet nectar of automation, you won’t look back. Well, I guess I’m getting
    ahead of myself. I will start with the concept of time. The only way you control
    your destiny, the way you live, and what you do is by controlling your own time,
    by choosing what you do. And to do that, you need to choose what it is that you
    do with your time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会是我最喜欢的章节。说真的，一旦你品尝过自动化的甜美甘露，你就不会再回头了。嗯，我猜我有点超前了。我将从时间的概念开始。控制你命运、生活方式以及你做什么的唯一方法，就是控制你自己的时间，通过选择你要做的事。为了做到这一点，你需要选择如何使用你的时间。
- en: All human advancement correlates to doing something in a way that requires fewer
    and fewer workers and continually decreased effort so that greater effort can
    then be applied elsewhere. All of this defines the concept of automation. It is
    inventing ways to reduce time investment in the boring stuff so that you can move
    on and do more exciting or engaging stuff.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的人类进步都与以一种方式做事情相关，这种方式需要越来越少的工人，并且持续减少努力，以便将更多的努力应用到其他地方。所有这些都定义了自动化的概念。它就是发明减少在乏味工作中时间投入的方法，以便你可以继续前进，做更多令人兴奋或有趣的事情。
- en: Human beings invented agriculture so that they wouldn’t have to spend so much
    time hunting and gathering food. They could grow their own; the food, in many
    ways, grew itself (automatically some would say) and a little bit of tinkering
    led to the food that we eat to this day. The creation of farming automated the
    food creation process, which kickstarted towns and owning property and most of
    human civilization.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 人类发明农业是为了不必花太多时间去打猎和采集食物。他们可以自己种植；食物在很多方面自己就能生长（有人说是自动化的），而一点点的改良让我们今天吃到的食物得以诞生。农业的创造使得食物生产过程实现了自动化，进而推动了城镇的发展、地产的拥有以及大部分人类文明的诞生。
- en: During the Industrial Revolution, the automation of manufacturing processes
    resulted in cheap, mass-manufactured goods being brought to practically every
    household. The ability to create identical goods that were of high quality and
    worked perfectly was revolutionary. It meant that the labor required to create
    something was greatly reduced meaning that that labor could be focused elsewhere.
    The invention of the steam engine, electricity, and motor vehicles also reduced
    labor in a number of different areas while saving time in many others.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在工业革命期间，制造过程的自动化使得廉价的大规模生产商品几乎进入了每个家庭。创造出质量高、工作完美且完全相同的商品是一项革命性的成就。这意味着创造某样东西所需的劳动大大减少，从而可以将这些劳动力集中到其他地方。蒸汽机、电力和汽车的发明也在多个领域减少了劳动，同时在许多其他领域节省了时间。
- en: '*Around the World in Eighty Days* by *Jules Verne* was a novel symbolizing
    how far human innovation had gone toward shortening trips around the globe. Within
    a hundred years of the publication of that novel, man had conquered all forms
    of terrestrial travel, making the book trivial. The next question that was then
    asked was how the human mind could be made faster and more automated. This is
    where computers came in. Computers turn the human brain into the most efficient
    tool in the world. They have automated a lot of our menial mental workload, allowing
    the human brain to be freed up for more leisurely tasks.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*环游世界八十天*是*儒勒·凡尔纳*所著的一本小说，象征着人类创新在缩短全球旅行时间方面的巨大进步。在那本小说发布后的不到一百年里，人类征服了所有形式的陆地旅行，使得这本书显得微不足道。接下来被提出的问题是，如何让人类大脑变得更快、更自动化。这就是计算机登场的地方。计算机将人类大脑转变为世界上最有效的工具。它们自动化了我们许多繁琐的思维工作，让人类大脑有更多的空闲时间去做更轻松的任务。'
- en: However, this process is a never-ending one. There is always some way to get
    better and to do something faster and without taking up any more of one’s focus.
    In the DevOps field, we have made it into one of our core principles because of
    how much innovation, creativity, and coming up with new ideas are valued in the
    field of technology. You cannot stay in the same place you were yesterday. You
    must automate and move on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这一过程是一个永无止境的循环。总有办法变得更好，做得更快，并且不会再占用更多的注意力。在DevOps领域，我们已将其作为核心原则之一，因为在技术领域中，创新、创造力和提出新想法被高度重视。你不能停留在昨天的地方。你必须自动化并继续前进。
- en: And that is what this chapter will be about. It will concern *Automating the
    Boring Stuff with Python* (another great Python book by *Al Sweigart*) and letting
    you use your mind and your creativity to maximum utilization. You do not want
    to be stuck in the causal loop of doing the same upload, running the same script
    manually, or fixing that recurring server issue manually even though it only takes
    about 5 seconds but logging into it takes 10 minutes. All of these are problems
    where automation is the answer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章的内容。本章将涉及*用 Python 自动化枯燥工作*（这是*Al Sweigart*的另一本优秀的 Python 书籍），并让你最大限度地利用你的思维和创造力。你不想陷入反复上传、手动运行相同脚本或手动修复那些虽然只需要
    5 秒钟但登录却需要 10 分钟的重复服务器问题的因果循环中。这些问题的答案就是自动化。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学到以下内容：
- en: Automation of server maintenance within the server and outside of it
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器内外的自动化维护
- en: Automation of container creation through managed services and otherwise
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过托管服务及其他方式自动化容器创建
- en: Automated launching of a playbook using Google Forms
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Google 表单自动启动播放本
- en: Automating server maintenance and patching
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化服务器维护和修补
- en: I once had a friend whose only job most days was to wait for a website to go
    down, check why it had gone done, and do one of two things or commands that he
    had been given to bring it back up again. I had another friend whose job was to
    manually restart an NGINX server whenever it went down. I once met a man whose
    job largely involved just downloading CSVs from one place, putting them somewhere
    else, and clicking a start button. Now, to some of you, that might sound like
    a swell gig (to me, it doesn’t sound half bad either), but the thing about it
    is that it is a waste of time for both that individual’s employers and that individual
    themselves. There is no growth or improvement for either, and in my experience
    of life, that is a waste of human life.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经有一个朋友，他的工作大多数日子里只是等待一个网站宕机，检查它为什么宕机，并执行他被指派的两项命令之一来将其恢复。我还有另一个朋友，他的工作是每次
    NGINX 服务器宕机时手动重启它。我曾遇到一个人，他的工作基本上就是从一个地方下载 CSV 文件，把它们放到另一个地方，然后点击一个启动按钮。现在，对于一些人来说，这听起来可能是个不错的工作（对我来说也不算差），但问题在于，这对那个员工的雇主和员工自己来说都是浪费时间。对双方而言没有成长或改进，在我的生活经验中，这简直就是浪费人类的生命。
- en: In the coming samples, we are going to see how we can maintain multiple instance
    fleets based on a series of common commands and then we are going to find a way
    to patch an OS after we have discovered the type of OS it is running. We are going
    to do all of this with the help of Python.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的示例中，我们将看到如何基于一系列常用命令来维护多个实例集群，然后在发现操作系统类型后，找到一种方法来修补操作系统。我们将借助 Python 来完成这一切。
- en: 'Sample 1: Running fleet maintenance on multiple instance fleets at once'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 1：同时对多个实例集群进行集群维护
- en: 'Maintaining a server involves a lot of work – a lot of repetitive work. This
    is why server maintenance was initially automated. It minimizes human error and
    also makes sure that the process occurs the same way every time. A fleet of servers
    works similarly. It is just about using the automation script for all of them
    since they are copies of an original server. But what about multiple instance
    fleets with different needs? Here, Python can be of assistance. All you need to
    do is associate each fleet with the correct script for maintaining it. This can
    allow you to manage multiple fleets over multiple clouds if you want to. So, without
    further ado, let’s see how we can do that:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 维护服务器涉及大量工作——很多重复的工作。这也是最初服务器维护实现自动化的原因。它最小化了人为错误，并确保每次都按相同方式进行。服务器集群的工作原理类似。只需对所有服务器使用自动化脚本，因为它们是原始服务器的副本。那么，如何处理具有不同需求的多个实例集群呢？在这里，Python
    可以提供帮助。你需要做的就是将每个集群与正确的维护脚本关联起来。这可以让你在多个云环境中管理多个集群。所以，话不多说，让我们看看如何做到这一点：
- en: 'Let’s first write the code for AWS instances to find the instances that are
    running:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先编写 AWS 实例的代码，找出正在运行的实例：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will give us a list of instances from EC2 to use. You can use a number
    of identifiers to define your fleet. You can even use a pre-defined system manager
    fleet.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将为我们提供一个来自 EC2 的实例列表。你可以使用多个标识符来定义你的集群。你甚至可以使用预定义的系统管理集群。
- en: 'Let’s now do the same thing for Google Cloud Compute Engine instances:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们为 Google Cloud Compute Engine 实例做同样的事情：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the **Google Cloud Platform** (**GCP**) code, there are a few differences
    because you need to specify the GCP project ID and you have to define the request
    to the API along with the API itself.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**Google Cloud Platform**（**GCP**）代码中，由于需要指定GCP项目ID，并且必须定义请求API及其本身，因此存在一些差异。
- en: 'Now, let’s find a command to run through these instances. It can be any placeholder
    command. You can later use the commands you want for it:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们找一个命令来在这些实例中运行。它可以是任何占位符命令。你可以之后用你想要的命令来替代它：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code for GCP and AWS differs a bit because of the way that the
    APIs have been developed for it. However, they both will produce the result of
    executing an SSH command on their servers.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于API的开发方式不同，之前的GCP和AWS代码有所不同。然而，它们都会产生在服务器上执行SSH命令的结果。
- en: So, if we iterate through the lists that we previously produced through the
    function to update them with a command, we can make a mass change or update to
    our entire instance fleet.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，如果我们遍历之前通过函数生成的列表，并用命令更新它们，我们就可以对整个实例集群进行批量更改或更新。
- en: This method is good for a generic fleet where we presume that all the OS are
    the same or that they run the same commands. But what if we were in an environment
    where the OS could be different? How would we then go about using commands? In
    the next section, we will explore this possibility.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法适用于通用的服务器集群，我们假设所有操作系统（OS）都是相同的，或者它们运行相同的命令。但是如果我们处于一个操作系统可能不同的环境中呢？那我们该如何使用命令呢？在接下来的部分，我们将探索这一可能性。
- en: 'Sample 2: Centralizing OS patching for critical updates'
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 2：为关键更新集中管理操作系统补丁
- en: OS are like any brand, really. Well, at least among most of the tech community,
    it’s like Coke and Pepsi – except if Coke or Pepsi was your belligerent pet who
    constantly wanted your attention and needed maintenance. What I’m trying to say
    is the flavor you want is your preference. But, if you’re going to share a fridge,
    there will probably be flavors that you are not familiar with. So, the fridge
    needs to be accommodating to all flavors. This is a rather long-winded analogy,
    but you’ll get what I’m saying as we keep going. This fridge sorting is even more
    difficult (and important) when dealing with servers, which can have a similar
    diversity. To patch OS correctly, we must first understand which OS we are operating
    on. Then, we need to apply the correct command to ensure that the patching is
    done correctly for that OS. This again is where Python comes in. It has libraries
    that can do both and when combined can be a powerful asset.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统就像任何品牌一样。至少在大多数技术社区中，它就像可口可乐和百事可乐——只是如果可口可乐或百事可乐是你的好斗宠物，时常需要你的关注并且需要维护的话就另当别论了。我想表达的是，你喜欢的口味是个人偏好。但如果你要共享一个冰箱，可能会有一些你不熟悉的口味。所以，冰箱需要适应所有口味。当我们处理服务器时，这种“冰箱分类”变得更加困难（而且重要），因为服务器可能有类似的多样性。要正确修补操作系统，我们首先必须了解我们正在使用的操作系统。然后，我们需要应用正确的命令，以确保该操作系统的补丁正确安装。这正是Python的用武之地。它有能够同时完成这两项工作的库，结合起来可以成为强大的工具。
- en: 'Let’s start off with the process of patching a single OS. We will use a `apt`
    package manager for this case:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修补单个操作系统的过程开始。在这个案例中，我们将使用`apt`包管理器：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see in the code, it’s simply a matter of running an `update` command
    using Python’s `subprocess` module, which once again reinforces the incredible
    connection that Python has with the OS that it is working on.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在代码中看到的，这仅仅是通过Python的`subprocess`模块运行一个`update`命令，这再次强调了Python与其运行的操作系统之间的紧密联系。
- en: 'But this is just for a Debian Linux instance. What would happen if that instance
    was, say, Red Hat or CentOS? What if the script had to function for both? Then
    we just need to add an additional library: `platform`. This library will give
    us the knowledge we need to distinguish between the platforms and the ability
    to write all the patch code in one script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是针对Debian Linux实例的情况。如果该实例是Red Hat或CentOS呢？如果脚本需要同时支持这两者该怎么办？那我们只需要添加一个额外的库：`platform`。这个库将为我们提供区分平台所需的知识，并且使我们能够在一个脚本中编写所有补丁代码：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code works for Debian distributions, the latest RedHat distributions
    (older ones use `yum` instead), and Windows PowerShell. The script will determine
    which OS you are currently running on and run an update accordingly. Since the
    command can be modified, you can change it and make the update whatever you’d
    like it to be. You can also add on OS such as Darwin for macOS or more obscure
    Linux distributions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码适用于 Debian 发行版、最新的 RedHat 发行版（旧版使用 `yum` 命令），以及 Windows PowerShell。脚本会根据你当前使用的操作系统，运行相应的更新。由于命令是可以修改的，你可以更改它并使更新符合你的需求。你还可以添加像
    Darwin（适用于 macOS）或其他不常见的 Linux 发行版等操作系统。
- en: You may now be thinking “*Patching an OS is going to break my server.*” Fair
    enough. That can happen a lot, especially for older dependencies. And in the case
    of a lot of Linux servers, the latest versions of OS can take years to become
    approved server versions. If you feel that this is a hassle, then maybe you should
    try out containers. There’s plenty of opportunity there for the automation enthusiast
    as well.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能在想“*修补操作系统会破坏我的服务器*。” 有道理，尤其是对于旧的依赖关系，这种情况发生得很频繁。对于许多 Linux 服务器来说，操作系统的最新版本可能需要几年时间才能成为正式的服务器版本。如果你觉得这很麻烦，那么或许你应该试试容器。对于自动化爱好者来说，这里有很多机会。
- en: Automating container creation
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化容器创建
- en: '**Containers** – in the eyes of many – are magic. You can put all the stuff
    you need for a smaller application or a section of a larger application into an
    environment solely catered to it where it can function on its own. It’s like creating
    a separate planet where polar bears can live in their native environment forever
    free from the terrors of global warming. In this way, containers are amazing since
    they can help maintain nearly extinct technologies in environments that can sustain
    them. That is truly magic. But casting the spell is rather bothersome, which is
    why we automate stuff.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**——在许多人眼中——是魔法。你可以将一个小型应用程序或大型应用程序的一部分所需的所有内容放入一个专门为其服务的环境中，使其能够独立运行。这就像创造一个独立的星球，让北极熊永远生活在其本土环境中，免受全球变暖的恐惧。通过这种方式，容器令人惊叹，因为它们可以帮助保持几乎已灭绝的技术，且这些技术能够在适合它们的环境中得以持续运行。这的确是魔法。但施法过程相当繁琐，这也是我们为什么要自动化操作的原因。'
- en: 'Sample 1: Creating containers based on a list of requirements'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 1：基于需求列表创建容器
- en: 'Containers change between initialization and stoppage based on changes in the
    state of the files and configurations within the container. Capturing an image
    from this changed container will give an image that has several layers added on
    top of the initial layer. This is a way to create custom containers as well. This
    can be useful when the containers that we find are largely what our requirements
    are but are not exactly our requirements. We can add a few steps (and a few layers)
    to make our container just as we would like it. We can then turn this into an
    image, which can then be replicated for other containers. We can do all of this
    with Python (big surprise, amirite?):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在初始化和停止之间会根据容器内文件和配置的状态变化而变化。从这个变化的容器中捕获镜像，将得到一个在初始层之上添加了几个层的镜像。这也是创建自定义容器的一种方式。当我们找到的容器大致符合我们的需求，但并不完全符合时，这种方法非常有用。我们可以添加几个步骤（以及几个层），使容器完全符合我们的要求。然后，我们可以将其转换为镜像，随后可以复制到其他容器中。所有这些操作都可以通过Python来完成（大惊喜，不是吗？）：
- en: 'Let’s once again start off with some simple code to start a container based
    on an image:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次从一些简单的代码开始，基于镜像启动一个容器：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This set of commands will run a container containing the latest version of Ubuntu.
    It will also give us the ID of the container, which will be important in the next
    step. This will be our starting point.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这组命令将启动一个包含最新版本 Ubuntu 的容器。它还会给我们容器的 ID，这在下一步中非常重要。这将是我们的起点。
- en: 'Now, let’s add on to it:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们进一步完善它：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, we have a new container that has the new command added on top of everything
    else in Ubuntu. This container is different from the original one but built upon
    the original.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们有了一个新容器，它在 Ubuntu 中所有其他内容的基础上添加了新命令。这个容器与原始容器不同，但它是基于原始容器构建的。
- en: 'Next, we need to export this image for later use:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将这个镜像导出以便以后使用：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will save your image in the desired file path. Putting all of this code
    together, we get the following:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把你的镜像保存在所需的文件路径中。将所有代码合并后，我们得到如下内容：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The full code gives us the complete picture and shows us that all of this can
    be done in just a few short steps. Adding layers simply means adding more commands.
    You can even start with an empty template that has nothing in it if you want.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的代码给我们呈现了完整的图景，展示了所有这些可以在短短几步之内完成。添加层次意味着添加更多的命令。如果你愿意，你甚至可以从一个什么都没有的空模板开始。
- en: This is all good if you are creating individual customized images, but another
    complicated aspect of containers is orchestrating multiple containers together
    to perform a task. This requires a lot of work and is why Kubernetes was created.
    Kubernetes clusters – even though they simplify container orchestration a lot
    – can be quite a handful. This is another area of container automation, then,
    that Python can be useful for.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在创建单独定制的图像，这一切都很好，但容器的另一个复杂方面是将多个容器编排在一起以执行某个任务。这需要大量的工作，也正是因此Kubernetes应运而生。Kubernetes集群——尽管它们简化了容器编排很多——仍然可能非常复杂。这是容器自动化的另一个领域，Python在其中可以发挥作用。
- en: 'Sample 2: Spinning up Kubernetes clusters'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例2：启动Kubernetes集群
- en: 'I will start off with a personal note: when I first got into Kubernetes, it
    was probably the hardest thing in the world for me. I came from a development
    background and something like container orchestration was completely alien to
    me at the time. Kubernetes was born out of a very complicated need because of
    the rise in popularity of microservices. It was created to make life simpler for
    larger projects that were a mishmash of smaller projects. When it finally clicked
    for me, I realized how important Kubernetes was. It didn’t stop me from still
    being confused, though. So, I went to the coding well and it turns out there are
    a bunch of resources for guys like me. Once again, Python was a big help.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我先来讲一个个人经历：当我第一次接触Kubernetes时，它对我来说可能是世界上最难的事情。我来自开发背景，而像容器编排这样的东西当时对我来说完全是外来的。Kubernetes是因为微服务的流行而应运而生的，它的目的是让大型项目中那些大小不一的小项目能够更轻松地管理。当我终于弄明白它的时候，我意识到Kubernetes是多么重要。然而，这并没有让我不再困惑。所以，我再次求助于编码，结果发现有许多资源适合像我这样的人。再次强调，Python是一个大帮手。
- en: 'Creating a Kubernetes cluster usually involves using it in a cloud service.
    For this exercise, we are going to write code for setting up clusters in Google
    Cloud and Microsoft Azure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Kubernetes集群通常需要在云服务中使用它。对于这个练习，我们将编写代码来设置Google Cloud和Microsoft Azure中的集群：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This operation will create a Kubernetes cluster in your Google Cloud project.
    Now let’s look at a way to do it in Azure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作将在你的Google Cloud项目中创建一个Kubernetes集群。现在，让我们看看如何在Azure中执行这个操作：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This creation code is fairly standard as well; it is simply a change in terminology.
    This is probably not the most efficient way to write code for this function (that
    will come later with Infrastructure as Code), but it gets the job done.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个创建代码也相当标准；它只是术语的不同。这可能不是为这个功能编写代码的最有效方式（这将在基础设施即代码（Infrastructure as Code）中进一步展开），但它完成了任务。
- en: A lot of what we have looked at so far is gibberish to the layman, and sometimes
    the layman is the one most frequently operating resources. So let’s now look at
    a process that can be a blueprint for automating more complex processes to involve
    the layman more in the resource creation process.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所看到的许多内容对外行来说都是一堆胡言乱语，而外行人有时是最频繁操作资源的人。所以让我们来看一个过程，它可以作为自动化更复杂流程的蓝图，使外行人更多地参与到资源创建的过程中。
- en: Automated launching of playbooks based on parameters
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于参数自动启动playbook
- en: Most of the time, even the most basic tasks when automated can become difficult
    to understand. If you have to automate or trigger multiple tasks, the complexity
    starts to increase. Not everyone can understand them, and it shouldn’t be the
    job of everyone to understand them. That is why even a lot of modern servers have
    user interfaces that make the processing of information easier for many.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，即使是最基本的自动化任务也可能变得难以理解。如果你需要自动化或触发多个任务，复杂性就会开始增加。并不是每个人都能理解它们，而且也不应该是每个人的工作去理解它们。这就是为什么即使是许多现代服务器也有用户界面，使得信息处理对许多人来说更加容易。
- en: 'However, in many cases, even this level of abstraction isn’t enough. It may
    be necessary to create a tool in which users can simply enter their inputs and
    the server handles the creation of complex workflows and resources automatically.
    In short, you can make playbooks with parameters that will create resources based
    on an overview given to it by someone who would like the creation of the resource
    but does not want to bother with the intricacies behind it (in most places, these
    rather whimsical folk are called customers). Let’s see how to do that:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，即使这种抽象层级也不足够。可能需要创建一个工具，让用户可以简单地输入他们的内容，而服务器自动处理复杂的工作流和资源的创建。简而言之，你可以制作带有参数的剧本，根据那些希望创建资源但不想处理其中复杂细节的人（在大多数地方，这些比较随意的人叫做客户）所提供的概述来创建资源。让我们看看如何做到这一点：
- en: We will start by making a Google Form (yes, seriously). Go to [forms.google.com](http://forms.google.com)
    and click on the big plus (+) button.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从制作一个 Google 表单开始（是的，没错）。前往 [forms.google.com](http://forms.google.com) 并点击大大的加号（+）按钮。
- en: '![Figure 7.1 – Instance selection](img/B21320_07_1.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 实例选择](img/B21320_07_1.jpg)'
- en: Figure 7.1 – Instance selection
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 实例选择
- en: It’s a simple Google Form for two different sizes of EC2 instances.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 Google 表单，用于选择两种不同大小的 EC2 实例。
- en: 'Now, we are going to write a Google Apps Script script and an AWS Lambda function:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编写一个 Google Apps Script 脚本和一个 AWS Lambda 函数：
- en: '[PRE11]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This Lambda function takes an input consisting of the size of the EC2 instance
    to be created and then creates that instance. We can define an endpoint for it
    using the Lambda URL or the API gateway.
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 Lambda 函数接收一个输入，包含要创建的 EC2 实例的大小，然后创建该实例。我们可以使用 Lambda URL 或 API 网关为其定义一个端点。
- en: 'Once this function and this endpoint have been made, you can then call the
    endpoint from Apps Script and make the trigger and the input from the form. In
    the form editor, click on the three dots at the top right and click on **Script
    editor**:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦这个函数和端点创建完成，你可以从 Apps Script 调用该端点，并根据表单中的触发器和输入进行处理。在表单编辑器中，点击右上角的三个点，并选择**脚本编辑器**：
- en: '![Figure 7.2 – Accessing Script editor](img/B21320_07_2.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 访问脚本编辑器](img/B21320_07_2.jpg)'
- en: Figure 7.2 – Accessing Script editor
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 访问脚本编辑器
- en: 'You can now write the API script in what is essentially JavaScript:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以编写本质上是 JavaScript 的 API 脚本：
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will run the Lambda function, though there is a final step to trigger it
    by adding a trigger. On the left pane of the Apps Script project, click on the
    **Triggers** option.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将运行 Lambda 函数，不过需要最后一步通过添加触发器来触发它。在 Apps Script 项目的左侧窗格中，点击**触发器**选项。
- en: '![Figure 7.3 – Calling Lambda using Apps Script](img/B21320_07_3.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 使用 Apps Script 调用 Lambda](img/B21320_07_3.jpg)'
- en: Figure 7.3 – Calling Lambda using Apps Script
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 使用 Apps Script 调用 Lambda
- en: 'At the bottom right, click on **Add Trigger**, which will open the form to
    create a trigger where you can define all the necessary parameters:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右下角，点击**添加触发器**，这将打开一个表单，用于创建触发器，在那里你可以定义所有必要的参数：
- en: '![Figure 7.4 – Adding a trigger for when the form is submitted…](img/B21320_07_4.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 添加一个触发器，用于在表单提交时触发…](img/B21320_07_4.jpg)'
- en: Figure 7.4 – Adding a trigger for when the form is submitted…
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 添加一个触发器，用于在表单提交时触发…
- en: Here, we can add the source of the event, and the function, and select the event
    type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以添加事件的来源、功能，并选择事件类型。
- en: In doing so, we will create a workflow that will trigger a function when form
    data is submitted and use the data provided to the function to trigger an API
    URL.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就创建了一个工作流，当表单数据提交时触发一个函数，并使用该函数提供的数据来触发一个 API URL。
- en: And there you have it, that’s one way to connect all of the machinations that
    happen behind the scenes in a Lambda function with a simple Google Form.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，这就是一种将所有幕后操作（发生在 Lambda 函数中的）与简单 Google 表单连接起来的方法。
- en: Summary
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed the beauty of automation along with the means
    to achieve it. We learned how to automate virtual machine maintenance and container
    operations. We even learned how to add a layer of automation on top of that that
    would allow us to get people who are significantly less in the know involved in
    our process. Automation is a good thing. People will often believe otherwise and
    fear the automation of a lot of tasks, but the point of automation is to ensure
    that it is easier for people to live their lives. A life is not meant for boring
    repetitive tasks, it is meant for exploration. Automation is key to free up time
    for exploration. You control your life by controlling your time. Automation lets
    you do that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们讨论了自动化的美妙及其实现手段。我们学习了如何自动化虚拟机维护和容器操作。我们甚至学习了如何在此基础上添加一层自动化，允许那些对相关领域了解较少的人参与到我们的过程当中。自动化是件好事。人们常常会有相反的看法，并且害怕很多任务的自动化，但自动化的目的是确保人们的生活变得更加轻松。生活不应当充满无聊的重复任务，它应该是为了探索。自动化是释放时间进行探索的关键。你通过控制时间来控制你的生活。自动化让你做到了这一点。
- en: In the next chapter, we will discuss the events that drive not only automation
    but most DevOps infrastructure in general. We will look into event-driven architecture
    and use cases where it is advantageous, as well as – of course – how Python can
    help.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论推动自动化乃至大多数DevOps基础设施的事件。我们将深入了解事件驱动架构及其有利的应用场景，当然，*还会讨论* Python如何提供帮助。
