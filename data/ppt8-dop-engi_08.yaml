- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Developing and Managing Modules
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的开发与管理
- en: Having reviewed many aspects of the Puppet language, it is clear that using
    manifest files and classes alone would not scale or provide the structure needed
    as a code base grows for a diverse range of servers and customer requirements.
    In this chapter, we will review the components required to create Puppet code
    at scale. We will be looking at Puppet **modules**, which allow us to bundle code
    and data focused on a single technology implementation, thus making it easy to
    share and combine with other implementations. Then, we’ll explore the **roles
    and profiles method** to show you how profiles can group modules to create technology
    stacks and roles, then combine profiles to match business requirements. After,
    we’ll cover the **Puppet Development Kit** (**PDK**), showing how it can automate
    the process of creating and managing modules. The directories and files templated
    by the PDK will be shown, highlighting its built-in validation and linting checks,
    as well as unit compilation checks. Next, we’ll look at **Rspec**, as a method
    that expands on this to provide more thorough unit testing, as well as **ServerSpec**,
    which is used for server testing, at a high level. Then, we’ll discuss the **Puppet
    Forge** catalog, which acts as the source of modules developed by Puppet itself,
    as well as vendors and members of the community. We will show you how to filter
    various aspects of modules to understand how they are supported, their compatibility
    with OS and Puppet versions, and scoring/scanning ratings so that you can choose
    the best module for your organization’s needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在审视了 Puppet 语言的许多方面后，我们可以清楚地看到，仅使用清单文件和类是不够的，随着代码库的增长，无法提供所需的结构，特别是在需要支持多种服务器和客户需求时。在本章中，我们将回顾在大规模创建
    Puppet 代码时所需的组件。我们将讨论 Puppet **模块**，它们允许我们将代码和数据捆绑在一起，专注于单一的技术实现，从而使得与其他实现共享和结合变得更加容易。接着，我们将探索
    **角色与配置文件方法**，展示如何通过配置文件将模块组合在一起，创建技术栈和角色，然后通过组合配置文件来满足业务需求。之后，我们将介绍 **Puppet
    开发工具包**（**PDK**），展示如何通过它自动化创建和管理模块的过程。我们将展示 PDK 模板化的目录和文件，重点介绍其内置的验证、代码检查和单元编译检查。接下来，我们将介绍
    **Rspec**，一种扩展方法，用于提供更为彻底的单元测试，以及用于服务器测试的 **ServerSpec**，并进行概述。然后，我们将讨论 **Puppet
    Forge** 目录，它作为 Puppet 官方、供应商和社区成员开发模块的来源。我们将展示如何过滤模块的各个方面，以了解它们的支持情况、与操作系统和 Puppet
    版本的兼容性，以及评分/扫描评分，从而帮助你选择最适合组织需求的模块。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主要内容：
- en: What is a module and what is in it?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是模块？它包含哪些内容？
- en: Roles and profiles method
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色与配置文件方法
- en: The PDK and how to write and test a module
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PDK 及如何编写和测试模块
- en: Testing using RSpec with PDK
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RSpec 与 PDK 进行测试
- en: Understanding Puppet Forge
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Puppet Forge
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter does not require any infrastructure to be deployed. All actions
    can be performed from your developer desktop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不需要部署任何基础设施。所有操作都可以从开发者的桌面进行。
- en: What is a module and what is in it?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模块？它包含哪些内容？
- en: Modules provide us with a way to group code and data, making it easier to share
    and reuse code that is part of a specific technology implementation. Almost all
    of your Puppet code will be stored in modules of one kind or another. You should
    work out the scope of your module to create focused modules with a single clear
    responsibility. If you were deploying a LAMP or WAMP stack, you would not make
    a single module that configured all components; instead, you would break it into
    individual modules, including OS settings, MySQL, and Apache. This allows greater
    code reuse and reduces the complexity of any individual module.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块为我们提供了一种将代码和数据进行分组的方式，使得共享和重用特定技术实现的代码变得更加容易。几乎所有的 Puppet 代码都将存储在各种类型的模块中。你应该明确模块的范围，以创建具有单一明确职责的专注模块。如果你正在部署
    LAMP 或 WAMP 堆栈，你不会创建一个包含所有组件的单一模块；而是会将其拆分成多个独立的模块，包括操作系统设置、MySQL 和 Apache。这种方式可以更好地重用代码，并减少单个模块的复杂性。
- en: A module is a directory named with similar criteria to a class, so it must begin
    with a lowercase letter and can only contain lowercase letters, numbers, and underscores.
    Unlike classes, modules cannot be nested and do not use the `::` symbol. Reserved
    words and class names should not be used as module names.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一个目录，其命名规则类似于类，因此必须以小写字母开头，并且只能包含小写字母、数字和下划线。与类不同，模块不能嵌套，也不使用 `::` 符号。保留字和类名不应作为模块名使用。
- en: 'Modules have a directory structure that allows Puppet to know where various
    types of code and data will be stored and autoloaded as requested. As discussed
    in [*Chapter 6*](B18492_06.xhtml#_idTextAnchor185), a scope namespace and file
    service namespace for that module will be created. The core code and data are
    stored in the following directories:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模块具有一种目录结构，使Puppet能够知道各种类型的代码和数据将存储在何处，并按请求自动加载。如[*第6章*](B18492_06.xhtml#_idTextAnchor185)所述，该模块将创建一个作用域命名空间和文件服务命名空间。核心代码和数据存储在以下目录中：
- en: '`data`: Contains module-based data for parameter defaults, which will be covered
    in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233)*.*'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：包含模块化数据，用于参数默认值，相关内容将在[*第9章*](B18492_09.xhtml#_idTextAnchor233)中讲解。'
- en: '`examples`: Contains examples of how to declare the modules’ classes and defined
    types.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`examples`：包含如何声明模块类和定义类型的示例。'
- en: '`files`: Contains static file content that can be placed by Puppet.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`：包含可以由Puppet放置的静态文件内容。'
- en: '`manifests`: Contains all the manifests of the module and directories that
    provide structure.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`manifests`：包含模块的所有清单以及提供结构的目录。'
- en: '`template`: Contains the EPP and ERB template files to be used by Puppet code.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：包含将由Puppet代码使用的EPP和ERB模板文件。'
- en: '`tasks`: Contains tasks for procedural work. This will be covered in [*Chapter
    12*](B18492_12.xhtml#_idTextAnchor293)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`：包含程序化工作的任务。将在[*第12章*](B18492_12.xhtml#_idTextAnchor293)中讲解'
- en: 'Modules also have what is known as **plugins**, allowing them to distribute
    various custom Puppet components to the Puppet server or agent, as relevant. Some
    of these plugins are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模块还有一种叫做**插件**的功能，可以将各种自定义的Puppet组件分发到Puppet服务器或代理端，具体取决于相关情况。以下是一些插件示例：
- en: '`lib/facter`: Custom facts written in **Ruby** that are used on the agent'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/facter`：由**Ruby**编写的自定义事实，在代理端使用'
- en: '`lib/puppet/functions`: Custom functions written in Ruby that are used by the
    server'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/puppet/functions`：由Ruby编写的自定义函数，供服务器使用'
- en: '`lib/puppet/type`: Custom resource types that are used on both the server and
    agent'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/puppet/type`：在服务器和代理端都可以使用的自定义资源类型'
- en: '`lib/puppet/provider`: Custom resource providers written in Puppet that are
    used on both the server and agent'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/puppet/provider`：由Puppet编写的自定义资源提供者，服务器和代理端都可以使用'
- en: '`lib/augeaus/lenses`: Custom Augeas lenses that are used on the agent side'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lib/augeaus/lenses`：在代理端使用的自定义Augeas镜头'
- en: '`facts.d`: External facts or static scripts that are used on the agent'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`facts.d`：在代理端使用的外部事实或静态脚本'
- en: '`functions`: Customs functions written in Puppet that are used on the server'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functions`：由Puppet编写的自定义函数，供服务器使用'
- en: 'It is important to note that certain plugin types, such as resource types,
    are not isolated fully in environments. Environments will be discussed in detail
    in [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272), where we will focus on classification
    and release management, but for now, note that environments allow isolated code
    bases to be used by nodes so that they can use different versions of code. This
    is due to the way Ruby loads the first resource type and makes it global, ignoring
    any duplicates found. Therefore, it is important to consult the Puppet documentation:
    [https://puppet.com/docs/puppet/latest/environment_isolation.html#environment_isolation](https://puppet.com/docs/puppet/latest/environment_isolation.html#environment_isolation).
    You can configure environment isolation as necessary if you use modules containing
    plugins that cannot be isolated. Puppet Enterprise provides isolation in environments
    by default.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，某些插件类型，例如资源类型，并没有在环境中完全隔离。环境将在[*第11章*](B18492_11.xhtml#_idTextAnchor272)中详细讨论，我们将重点讨论分类和发布管理，但现在需要注意的是，环境允许通过节点使用隔离的代码库，从而使用不同版本的代码。这是由于Ruby加载第一个资源类型并将其设置为全局，忽略任何发现的重复项。因此，如果使用包含无法隔离插件的模块，请务必查阅Puppet文档：[https://puppet.com/docs/puppet/latest/environment_isolation.html#environment_isolation](https://puppet.com/docs/puppet/latest/environment_isolation.html#environment_isolation)。如果需要，您可以配置环境隔离，Puppet
    Enterprise默认提供环境隔离。
- en: Modules can be used in different ways. While most of this chapter will focus
    on modules that use Puppet code for configuration, modules can be used to distribute
    an item or items. An example of this is the PowerShell module in Puppet Forge
    ([https://forge.puppet.com/modules/puppetlabs/powershell](https://forge.puppet.com/modules/puppetlabs/powershell)),
    which is used only to distribute a new exec provider using the provider plugin
    directory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以以不同的方式使用。尽管本章的大部分内容将集中在使用 Puppet 代码进行配置的模块上，但模块也可以用于分发一个或多个项目。例如，Puppet
    Forge 中的 PowerShell 模块（[https://forge.puppet.com/modules/puppetlabs/powershell](https://forge.puppet.com/modules/puppetlabs/powershell)）仅用于通过提供者插件目录分发新的执行提供者。
- en: Focusing on the `manifests` directory, the manifest files will have the same
    name as the class name they contain. The major exception to this is the main manifest,
    which is named `init.pp`, but has the class name of the module. This main manifest
    is often used as the entry point to the module. As discussed in [*Chapter 6*](B18492_06.xhtml#_idTextAnchor185),
    a module namespace is created for the module, allowing us to include the module
    in code by running `include <``module name>`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 关注`manifests`目录时，清单文件将与其包含的类名相同。一个主要的例外是主清单，它命名为`init.pp`，但其类名为模块的类名。这个主清单通常用作模块的入口点。如[*第6章*](B18492_06.xhtml#_idTextAnchor185)中讨论的那样，为模块创建了一个模块命名空间，允许我们通过运行`include
    <module name>`来在代码中包含该模块。
- en: 'The classes should be self-contained and small, focusing on one aspect. A common
    piece of advice on how to identify a class that is too big is when it is too large
    to view in a single editor screen. With this in mind, one of the most common patterns
    when starting with modules is to use the main manifest, `init.pp`, as an entry
    point that takes parameters to be used across the module. After, it calls other
    classes that are used and sets their ordering. An example of this is using an
    `install` class to install resources such as packages, a `config` class to add
    any configuration files or users, and a `service` class to manage the service.
    The following code shows an example of a main manifest for this pattern:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类应该是自包含的并且简洁，专注于一个方面。识别类是否过大的一个常见建议是，当它太大，以至于无法在单个编辑器屏幕中查看时，就是过大了。考虑到这一点，开始使用模块时最常见的模式之一是使用主清单`init.pp`作为入口点，接受参数以供整个模块使用。然后，它调用其他类并设置它们的顺序。例如，使用`install`类来安装资源（如包），使用`config`类来添加任何配置文件或用户，以及使用`service`类来管理服务。以下代码展示了这一模式的主清单示例：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Considering the available parameters, such as the public API of the module,
    would allow the module to be flexible; in addition, consistency should be maintained
    when naming these parameters. Here, we use an approach where parameters are named
    based on their effect. So, for `exampleapp`, it can be seen that both the package
    and user take a Boolean to declare if the module is managing them as a resource.
    A Boolean is used on `service_enable` to decide if the service is enabled on boot,
    while integers are provided for `user_id` and `package_version`. Two additional
    integers are then used for configuring the application, setting the Java memory
    size, and the thread number. These parameters can be accessed using the module
    namespace and performing a data lookup for the variable at `modulename::variablename`.
    This is known as automatic parameter lookup and will be covered in detail when
    we review how Puppet handles data in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到可用的参数，如模块的公共 API，可以使模块具有灵活性；此外，命名这些参数时应该保持一致性。在这里，我们使用一种方法，根据参数的作用来命名参数。因此，对于`exampleapp`，可以看到包和用户都采用布尔值来声明模块是否将其作为资源进行管理。布尔值用于`service_enable`来决定服务是否在启动时启用，而`user_id`和`package_version`则使用整数。接着，使用两个额外的整数来配置应用程序，设置
    Java 内存大小和线程数。这些参数可以通过模块命名空间访问，并通过在`modulename::variablename`处执行数据查找。此方法被称为自动参数查找，我们将在回顾
    Puppet 如何处理数据时，在[*第9章*](B18492_09.xhtml#_idTextAnchor233)中详细讲解。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Parameters and other aspects of a module can be documented via comments in
    the header of the code, which can then be generated in different formats using
    the Puppet Strings gem. Details can be found in the Puppet Strings style guide
    and on the following web page: [https://puppet.com/docs/puppet/latest/puppet_strings_style.html](https://puppet.com/docs/puppet/latest/puppet_strings_style.html).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的参数及其他方面可以通过代码头部的注释进行文档化，然后使用 Puppet Strings gem 生成不同格式的文档。详细信息可以在 Puppet
    Strings 风格指南和以下网页中找到：[https://puppet.com/docs/puppet/latest/puppet_strings_style.html](https://puppet.com/docs/puppet/latest/puppet_strings_style.html)。
- en: We adopt the approach of using containment and ordering on the classes within
    the module. This ensures, if requested, that the package is installed, the configuration
    is added, and the service is then managed or refreshed since each stage depends
    on the next. The `contain` keyword should not be considered a default to be used
    instead of `include`; it should only be used when it is this component module
    style and when the classes will only ever only be used within the main class.
    In the *Roles and profiles method* section, you will see where containment and
    ordering like this would be inappropriate.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用在模块内对类进行包含和排序的方法。这确保了在请求时，先安装软件包，添加配置，再管理或刷新服务，因为每个阶段都依赖于下一个阶段。`contain`
    关键字不应被视为替代 `include` 的默认关键字；它应仅在组件模块风格下使用，并且类只会在主类中使用。在 *角色和配置方法* 部分，你会看到类似的包含和排序在某些情况下是不合适的。
- en: 'From this, we can see how these subclasses use the parameters from the main
    manifest. For example, the `install` manifest uses an `if` statement on the `package_managed`
    variable; if it’s `True`, it installs the version of the `exampleapp` package
    set by the `package_version` variable:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以看出，这些子类是如何使用来自主清单的参数的。例如，`install` 清单对 `package_managed` 变量使用 `if` 语句；如果它为
    `True`，则安装由 `package_version` 变量设置的 `exampleapp` 包版本：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the `config` manifest, we can see how the `jmx_heap_size` and `thread_number`
    variables can be substituted into a template by using the module namespace to
    access the template stored in the templates folder in the `exampleapp` module:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `config` 清单，我们可以看到如何通过使用模块命名空间将 `jmx_heap_size` 和 `thread_number` 变量替换到模板中，并通过该命名空间访问存储在
    `exampleapp` 模块中的模板：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `service` class is very similar in style to the `install` class. It uses
    an `if` statement; if this is `True`, it adds a service of `exampleapp` and sets
    the `enable` parameter based on the `service_enable` variable:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`service` 类的风格与 `install` 类非常相似。它使用 `if` 语句；如果条件为 `True`，则添加 `exampleapp` 服务，并根据
    `service_enable` 变量设置 `enable` 参数：'
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A common module pattern was to use a `params.pp` file to manage default module
    data. Hiera 5 can now manage module-level data in a more structured way than a
    manifest file, as will be shown in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233).
    The `params.pp` file is still commonly seen in code, particularly where the structure
    of the data is simple and there is little value in changing it to Hiera.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模块模式是使用 `params.pp` 文件来管理默认的模块数据。现在，Hiera 5 能比清单文件以更结构化的方式管理模块级数据，具体内容将在
    [*第 9 章*](B18492_09.xhtml#_idTextAnchor233) 中展示。`params.pp` 文件仍然常见于代码中，特别是在数据结构简单且没有太大意义改变为
    Hiera 的情况下。
- en: 'The `examples` directory could contain a file called `init.pp`, specifying
    how the class could be called:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`examples` 目录中可能包含一个名为 `init.pp` 的文件，指定如何调用类：'
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The naming of files is not important in the `examples` directory; there could
    be several different examples to show common selections of module attributes for
    different setups. For example, a module might show how it can be included with
    the minimum default values, but also the required attributes for a specific architecture,
    such as deploying in a cluster setup.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `examples` 目录中，文件的命名并不重要；可以有多个不同的示例，展示不同设置下常见模块属性的选择。例如，一个模块可能展示如何使用最小默认值包含它，也可能展示特定架构所需的属性，例如在集群设置中进行部署。
- en: 'As the configuration use case becomes more complex, the other most common approach
    to the module structure can be seen in the Apache module in the Puppet Forge catalog:
    [https://forge.puppet.com/modules/puppetlabs/apache](https://forge.puppet.com/modules/puppetlabs/apache).
    Instead of grouping resources based on simple `package` and `config` classes,
    the `apache` module breaks down the different components of the application. In
    this example, the main manifest for Apache performs a default installation of
    Apache, with a default virtual host and a document root directory, and starts
    the Apache service. This can be configured by using the relevant module parameters.
    Here, the Apache service is managed in a separate class, but the resources that
    would normally have been in the `package` and `config` classes are managed within
    the Apache main class. There are also various implementation classes, such as
    `vhosts`, `mod`, and `mpm`, for different `apache` configuration items. This gives
    the main class a clear purpose of performing the basic installation and configuring
    the `apache` server so that the implementation classes can focus on specific customizations.
    For example, the `vhosts` classes are defined types that can be defined for each
    virtual host the `apache` server requires.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 随着配置用例变得更加复杂，模块结构的另一种常见方法可以在 Puppet Forge 目录中的 Apache 模块中看到：[https://forge.puppet.com/modules/puppetlabs/apache](https://forge.puppet.com/modules/puppetlabs/apache)。与基于简单
    `package` 和 `config` 类的资源分组不同，`apache` 模块将应用程序的不同组件进行了拆分。在此示例中，Apache 的主清单执行了
    Apache 的默认安装，具有默认虚拟主机和文档根目录，并启动了 Apache 服务。可以通过使用相关模块参数来配置此操作。在这里，Apache 服务由单独的类管理，但通常在
    `package` 和 `config` 类中管理的资源是在 Apache 主类中管理的。还有各种实现类，例如 `vhosts`、`mod` 和 `mpm`，用于不同的
    `apache` 配置项。这使得主类具有执行基本安装和配置 `apache` 服务器的明确目的，以便实现类可以专注于特定的定制。例如，`vhosts` 类是定义类型，可以为
    `apache` 服务器所需的每个虚拟主机定义。
- en: These examples provide a structure that you can follow for your modules and
    can be adapted as needed. However, the key lessons to take away are that modules
    should focus on a single task, only manage their resources (no cross-module dependencies),
    and be granular and portable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例提供了一个结构，您可以根据需要为您的模块进行调整。但是，需要记住的关键教训是，模块应专注于单一任务，仅管理其资源（无跨模块依赖），并且应该是细粒度且可移植的。
- en: In this section, we looked at the directory and file structure of a Puppet module
    and two common patterns for creating modules. These modules, by themselves, configure
    focused individual technical implementations. In the next section, we will see
    how a module’s structure can be used to combine modules to produce technical stacks
    and, by combining technical stacks and configuration, meet the business requirements
    customers have for servers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们查看了 Puppet 模块的目录和文件结构，以及创建模块的两种常见模式。这些模块本身配置了专注于个别技术实现。在下一节中，我们将看到如何使用模块的结构来组合模块以生成技术堆栈，并通过组合技术堆栈和配置，满足客户对服务器的业务需求。
- en: Lab – reviewing the apache module
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室 - 审查 Apache 模块
- en: It would be impractical to print all the key parts of the `apache` module’s
    code in this book. However, reviewing the code at [https://forge.puppet.com/modules/puppetlabs/apache](https://forge.puppet.com/modules/puppetlabs/apache)
    and reading the `examples` directory to see how the main class, `apache`, is combined
    with various classes within the module to configure different components will
    help you understand how this module pattern can be structured.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中打印 `apache` 模块代码的所有关键部分是不切实际的。但是，查看 [https://forge.puppet.com/modules/puppetlabs/apache](https://forge.puppet.com/modules/puppetlabs/apache)
    上的代码并阅读 `examples` 目录，以了解如何将主类 `apache` 与模块内的各种类结合起来配置不同组件，将帮助您理解如何结构化此模块模式。
- en: Roles and profiles method
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色和配置文件方法
- en: In the previous section, the modules we discussed are what are known as component
    modules since they cover single implementations. These modules are mostly of interest
    to users directly involved with the technology implementation, such as Unix or
    Windows administrators, where understanding that specific resources have been
    applied is the most important aspect of the configuration. But different users
    are not interested in how a node is configured; instead, they are interested in
    what it does. An application specialist, for example, would care that, for their
    application, Tomcat and MySQL were installed, not how it was configured. A project
    manager would care that they got a server that met a business need but not what
    technical stacks were used. The project manager may also see each implementation
    as unique, but there will often be a lot of similarities, such as various technology
    stacks being used across multiple applications using Apache or Java with variations
    of settings based on location or environment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论的模块是所谓的组件模块，因为它们覆盖单一实现。这些模块主要引起那些直接参与技术实现的用户的兴趣，例如Unix或Windows管理员，在他们看来，理解哪些特定资源已被应用是配置中最重要的方面。但不同的用户并不关心节点如何配置；他们关心的是它的作用。例如，一个应用程序专家关心的是，Tomcat和MySQL已为他们的应用程序安装，而不关心如何配置。项目经理关心的是他们获得了一台满足业务需求的服务器，而不关心使用了哪些技术栈。项目经理也可能认为每个实现都是独特的，但通常会有很多相似之处，例如在多个应用程序中使用Apache或Java的不同技术栈，并根据位置或环境的不同而有所不同的设置。
- en: Without providing some sort of structure for these levels of logic, trying to
    apply these modules to nodes would require a lot of duplication and complexity
    of `if` statements.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有为这些逻辑层次提供某种结构，将这些模块应用于节点将需要大量的重复和复杂的`if`语句。
- en: A pattern called roles and profiles uses a modular structure to achieve this.
    Role and profile are not keywords but just patterns to use within modules and
    classes. A simple approach can be to have a module called `role` and a module
    called `profile`, with each class in these modules representing a role or profile.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一种名为角色和配置文件的模式采用模块化结构来实现这一点。角色和配置文件不是关键字，而只是模块和类中使用的模式。一个简单的方法是有一个名为`role`的模块和一个名为`profile`的模块，模块中的每个类表示一个角色或配置文件。
- en: These roles represent the business need that a customer, such as a project manager,
    would require, while a profile would reflect a technical stack for an application.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些角色代表了客户（如项目经理）所需的业务需求，而配置文件则反映了应用程序的技术栈。
- en: When looking at how to apply the role and profiles method to the configuration
    of pre-existing applications, it’s important to look from the role down to the
    module to avoid the natural temptation of trying to find the technical solution
    first without the business logic. This involves breaking things down into components
    and granularly thinking about what it is and not what it looks like. One trick
    to identifying roles is often to take hostnames, which generally contain information
    about the location, environment use, and application. For example, a hostname
    may look like `fk1ora005prd`, where `fk1` is a data center location, `005` is
    a numerator, and `prd` is the production environment, leaving `ora` as the Oracle
    application, which would match the role’s name. So, roles should be business names
    such as `buildserver`, `proxyserver`, or `ecomwebserver`, while the profile should
    be the technology stack name, such as Apache, Jenkins, or nginx.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在将角色和配置文件方法应用于现有应用程序的配置时，重要的是从角色开始到模块结束，避免自然地首先寻求技术解决方案而忽视业务逻辑。这个过程涉及将事物拆解成组件，并且要具体思考它是什么，而不是它看起来像什么。识别角色的一个技巧是使用主机名，主机名通常包含关于位置、环境使用和应用程序的信息。例如，主机名可能看起来像`fk1ora005prd`，其中`fk1`是数据中心的位置，`005`是一个编号，`prd`是生产环境，而`ora`则是Oracle应用程序，它与角色的名称相匹配。因此，角色应该是业务名称，例如`buildserver`、`proxyserver`或`ecomwebserver`，而配置文件应该是技术栈的名称，例如Apache、Jenkins或nginx。
- en: This naming isn’t always perfect and sometimes, some of the terms may simply
    be the same ones that project managers use for ordering Oracle servers. They may
    be unaware of the underlying profiles of the Oracle role, which would include
    an Oracle profile and other relevant profiles.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种命名并不总是完美的，有时其中一些术语可能只是项目经理用来订购Oracle服务器的术语。他们可能没有意识到Oracle角色背后的配置文件，这些配置文件包括一个Oracle配置文件和其他相关的配置文件。
- en: 'In this case, a `role` class should simply call the required profiles with
    no variables, as shown here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`role` 类应简单地调用所需的配置文件，不带变量，如下所示：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In contrast, a `profile` class should contain parameters to customize the module
    and class declarations to add the required modules:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`profile` 类应包含参数，以定制模块和类声明，进而添加所需的模块：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233), which deals with Puppet
    and data, you’ll see how Hiera can model the data that overrides the profile defaults.
    A server should only have one role; if it needs two roles, then it is in itself
    a new role, but a role will have multiple profiles. *Figure 8**.1* shows a simple
    example of using roles, profiles, and modules and how the classes would include
    one another. With this setup, as we’ll see later in [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272),
    classifying a box is as simple as ensuring the right role is assigned to the node:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 9 章*](B18492_09.xhtml#_idTextAnchor233) 中，涉及到 Puppet 和数据，你将看到 Hiera 如何对覆盖配置文件默认值的数据建模。每个服务器应该只拥有一个角色；如果需要两个角色，那么它本身就是一个新角色，但一个角色会有多个配置文件。*图
    8.1* 展示了使用角色、配置文件和模块的简单示例，以及这些类如何相互包含。在这个设置中，正如我们稍后在 [*第 11 章*](B18492_11.xhtml#_idTextAnchor272)
    中看到的那样，对主机进行分类就像确保正确的角色被分配到节点一样简单：
- en: '![Figure 8.1 – An example of roles, profiles, and modules](img/B18492_08_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 角色、配置文件和模块的示例](img/B18492_08_01.jpg)'
- en: Figure 8.1 – An example of roles, profiles, and modules
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 角色、配置文件和模块的示例
- en: The framework shown in the preceding figure is all about abstraction, so we
    decouple the business logic, implementation, and resource management and reduce
    the node-level complexity.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上图中显示的框架完全是关于抽象的，因此我们将业务逻辑、实现和资源管理解耦，并减少节点级别的复杂性。
- en: This pattern is not a requirement but provides suggestions on how you can structure
    code to avoid duplication and provide a model. In this scenario, several adaptations
    could be considered.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式不是强制要求，而是提供了一些如何构建代码的建议，以避免重复并提供一种模型。在这种情况下，可以考虑几种适应性调整。
- en: Using complexity escalation allows us to not create too much structure when
    we have little code initially. If there are only a couple of resources in a profile,
    then it may be easier to keep it that way and expand to a module when it becomes
    more complicated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复杂度升级允许我们在最初代码较少时不创建过多结构。如果配置文件中只有少量资源，那么保持这种方式并在变得复杂时扩展到模块可能更容易。
- en: Depending on your organization’s change management and delivery requirements,
    it may make sense to have multiple profile or role modules to allow for more granular
    control and access – for example, `teama_profiles` and `teamb_profiles`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你所在组织的变更管理和交付要求，可能有多个配置文件或角色模块，以便实现更细粒度的控制和访问——例如，`teama_profiles` 和 `teamb_profiles`。
- en: As discussed in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), it is generally
    advised against using inheritance in Puppet code, but it may be worthwhile expanding
    the namespaces of a `profile` module by grouping manifests in a directory, such
    as creating an `exampleapp` directory within `profile` and creating `client.pp`
    and `server.pp` to represent the server and client versions (`profile::exampleapp::server`
    and `profile::exampleapp::client`, respectively). This could also be done for
    specific OSs. Before considering this approach, note that this structure is an
    edge case and carries a lot of risks when using inheritance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 [*第 3 章*](B18492_03.xhtml#_idTextAnchor048) 中讨论的那样，一般不建议在 Puppet 代码中使用继承，但通过在目录中分组清单（例如，在
    `profile` 中创建 `exampleapp` 目录，并创建 `client.pp` 和 `server.pp` 来表示服务器和客户端版本（分别为 `profile::exampleapp::server`
    和 `profile::exampleapp::client`））来扩展 `profile` 模块的命名空间可能是值得的。这也可以针对特定的操作系统进行。在考虑这种方法之前，请注意，这种结构是一个边缘情况，使用继承时风险较大。
- en: If profiles are found to be too rigid to plan for in a changing stack or if
    adopting heritage servers means that it becomes necessary to drop certain parts
    of profiles or roles, then using parameters to make the profile more dynamic can
    allow classes to be defined through the parameter of the profile class, either
    by Hiera or default values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现配置文件在变化的技术栈中过于死板，或者采用遗留服务器意味着必须丢弃配置文件或角色的某些部分，那么使用参数使配置文件更具动态性，可以通过配置文件类的参数（无论是通过
    Hiera 还是默认值）来定义类。
- en: 'As a simple example, the following code uses `include_classes` with the default
    values listed in the `exampleapp` module:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的示例，以下代码使用 `include_classes` 和 `exampleapp` 模块中列出的默认值：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This would allow us to override the `include_classes` array from Hiera or the
    module data in the profile. This could be made tighter for inclusions by us only
    allowing classes from a set module:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以覆盖 Hiera 或配置文件中的 `include_classes` 数组。通过只允许来自某个特定模块的类，我们可以使包含更加严格：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To add more structure to the parameters and make it clear in approval and code
    review processes, the class parameters could be broken out further. Here, we can
    add default, mandatory, additional, and knockout arrays, thus providing full flexibility:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为参数增加更多结构，并在审批和代码审核过程中使其更加清晰，可以进一步细分类参数。在这里，我们可以添加默认、必需、附加和剔除数组，从而提供完全的灵活性：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is possible to mix this pattern even further by, say, limiting multiple namespaces
    and having lists of class arrays for each namespace. This will be dictated by
    what approach will give your organization enough flexibility while making it clear
    what will be affected by the code and who should review it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过限制多个命名空间，并为每个命名空间创建类数组的列表，可以进一步混合这一模式。这将取决于采用什么方法，能够为组织提供足够的灵活性，同时明确代码会影响什么内容以及谁应进行审核。
- en: With this method, it may also be useful to define a `noop` flag using a parameter
    and then noop on resources. You could also do this via the `noop` function from
    [https://forge.puppet.com/modules/trlinkin/noop](https://forge.puppet.com/modules/trlinkin/noop)
    to allow modules to be added and put into noop mode until they are accepted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，也许可以通过参数定义一个 `noop` 标志，并在资源上执行 noop 操作。你也可以通过 [https://forge.puppet.com/modules/trlinkin/noop](https://forge.puppet.com/modules/trlinkin/noop)
    中的 `noop` 函数来实现，让模块在被接受之前处于 noop 模式。
- en: These adjustments to the patterns are more complex and involve reading the Hiera
    data to understand what a role and profile represent, but it will be up to your
    organization to decide which approach will work best. While a reduction in variation
    with rigid roles and profiles is ideal, this can lead to adoption resistance or
    issues with heritage if there are no appropriate ways to manage it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式的调整更加复杂，需要读取 Hiera 数据以理解角色和配置文件所代表的含义，但最终的决定将取决于贵组织，选择哪种方法最适合。虽然通过使用严格的角色和配置文件来减少变化是理想的，但如果没有适当的管理方法，这可能会导致采用上的阻力或遗留问题。
- en: Having reviewed the structure of modules that the roles and profiles pattern
    can create and the contents of such modules, we can see that this is a lot of
    content to manage manually by creating files and managing various testing tools.
    The next section looks at how to automate the life cycle of module creation and
    testing using the PDK.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在审视了角色和配置文件模式所能创建的模块结构及其内容后，我们可以看到，这需要大量的内容来手动管理，通过创建文件并管理各种测试工具。下一部分将讨论如何通过使用
    PDK 来自动化模块创建和测试的生命周期。
- en: Writing and testing a module using the PDK
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PDK 编写和测试模块
- en: 'The PDK was introduced to ease the effort required to consistently create the
    directories and files for modules and to also group some commonly used testing
    and validation tooling. We will be reviewing PDK version 2.7.1, the latest available
    at the time of writing. PDK installs its own Ruby gems and environment to provide
    the following tools:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: PDK 的引入旨在减少一致性地创建模块目录和文件的工作量，同时将一些常用的测试和验证工具组合在一起。我们将回顾 PDK 版本 2.7.1，这是写作时可用的最新版本。PDK
    安装了自己的 Ruby gems 和环境，以提供以下工具：
- en: '| **Ruby** **Gem Name** | **Ruby** **Gem Purpose** | **Project Page** |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **Ruby** **Gem 名称** | **Ruby** **Gem 功能** | **项目页面** |'
- en: '| `metadata-json-lint` | Validates the syntax and lints `metadata.json` to
    style guidelines | [https://github.com/voxpupuli/metadata-json-lint](https://github.com/voxpupuli/metadata-json-lint)
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `metadata-json-lint` | 验证语法并根据样式指南检查 `metadata.json` | [https://github.com/voxpupuli/metadata-json-lint](https://github.com/voxpupuli/metadata-json-lint)
    |'
- en: '| `pdk` | Generates modules and module content with automated testing commands
    | [https://github.com/puppetlabs/pdk](https://github.com/puppetlabs/pdk) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `pdk` | 生成模块及模块内容，并使用自动化测试命令 | [https://github.com/puppetlabs/pdk](https://github.com/puppetlabs/pdk)
    |'
- en: '| `puppet-lint` | Lints Puppet manifest code against the Puppet language style
    guide | [https://github.com/puppetlabs/puppet-lint](https://github.com/puppetlabs/puppet-lint)
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `puppet-lint` | 根据 Puppet 语言样式指南检查 Puppet 清单代码 | [https://github.com/puppetlabs/puppet-lint](https://github.com/puppetlabs/puppet-lint)
    |'
- en: '| `puppet-syntax` | Checks Puppet manifests, templates, and Hiera YAML for
    correct syntax | [https://github.com/voxpupuli/puppet-syntax](https://github.com/voxpupuli/puppet-syntax)
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `puppet-syntax` | 检查 Puppet 清单、模板和 Hiera YAML 的语法是否正确 | [https://github.com/voxpupuli/puppet-syntax](https://github.com/voxpupuli/puppet-syntax)
    |'
- en: '| `puppetlabs_spec_helper` | Provides the tooling necessary to test against
    different versions of Puppet | [https://github.com/puppetlabs/puppetlabs_spec_helper](https://github.com/puppetlabs/puppetlabs_spec_helper)
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `puppetlabs_spec_helper` | 提供必要的工具，以便在不同版本的 Puppet 中进行测试 | [https://github.com/puppetlabs/puppetlabs_spec_helper](https://github.com/puppetlabs/puppetlabs_spec_helper)
    |'
- en: '| `rspec-puppet` | Compiles Puppet code and tests the expected behavior using
    a Puppet-specific implementation of Ruby RSpec | [https://github.com/puppetlabs/rspec-puppet](https://github.com/puppetlabs/rspec-puppet)
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `rspec-puppet` | 编译 Puppet 代码并使用 Puppet 特定实现的 Ruby RSpec 测试预期行为 | [https://github.com/puppetlabs/rspec-puppet](https://github.com/puppetlabs/rspec-puppet)
    |'
- en: '| `Rspec-puppet-facts` | Gives a method that provides facts for supported OSs
    using the output of `facterdb` | [https://github.com/voxpupuli/rspec-puppet-facts](https://github.com/voxpupuli/rspec-puppet-facts)
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `Rspec-puppet-facts` | 提供一种方法，通过 `facterdb` 的输出为支持的操作系统提供事实数据 | [https://github.com/voxpupuli/rspec-puppet-facts](https://github.com/voxpupuli/rspec-puppet-facts)
    |'
- en: '| `facterdb` | Provides example output of facts for various OSs on different
    Facter versions | [https://github.com/voxpupuli/facterdb](https://github.com/voxpupuli/facterdb)
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `facterdb` | 提供不同操作系统和不同 Facter 版本的事实输出示例 | [https://github.com/voxpupuli/facterdb](https://github.com/voxpupuli/facterdb)
    |'
- en: Table 8.1 – PDK gem list
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 – PDK gem 列表
- en: The common misconception about the PDK is that it is packaging and installing
    these tools. What it is actually doing is running a `bundle install` in each module
    that’s created. After, the PDK cache is saved, making it appear like PDK is packaging
    the tools.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 PDK 的常见误解是，它在打包和安装这些工具。实际上，它正在为每个创建的模块运行 `bundle install`。之后，PDK 缓存被保存，看起来像是
    PDK 正在打包这些工具。
- en: 'Using the gems discussed in *Table 8.1*, the PDK can generate the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *表 8.1* 中讨论的 gem，PDK 可以生成以下内容：
- en: Modules with complete module skeletons, metadata, and README templates
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含完整模块骨架、元数据和 README 模板的模块
- en: Classes, defined types, tasks, custom facts and functions, and Ruby providers
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类、定义类型、任务、自定义事实、函数和 Ruby 提供者
- en: Unit test templates for classes and defined types
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和定义类型的单元测试模板
- en: 'The PDK performs linting to check styles and best practices and to run syntax
    validation against the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: PDK 会执行 lint 检查样式和最佳实践，并对以下内容进行语法验证：
- en: The `metadata.json` file; see *Table 8.2* for details
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata.json` 文件；有关详细信息，请参见 *表 8.2*'
- en: Puppet manifest files (`.pp`) against specific Puppet versions
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对特定 Puppet 版本的 Puppet 清单文件（`.pp`）
- en: Ruby files (`.rb`) against specific Puppet versions of Ruby
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对特定 Puppet 版本的 Ruby 文件（`.rb`）
- en: EPP and ERB template files
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EPP 和 ERB 模板文件
- en: '`Puppetfile` and `environment.conf`, which provides the module list for an
    environment and its environment settings, as will be discussed in [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Puppetfile` 和 `environment.conf`，它提供了环境的模块列表及其环境设置，具体内容将在 [*第 11 章*](B18492_11.xhtml#_idTextAnchor272)
    中讨论'
- en: YAML files
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML 文件
- en: The PDK runs RSpec unit tests on modules and classes. This will be discussed
    in detail in the *Testing with RSpec using the* *PDK* section.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: PDK 在模块和类上运行 RSpec 单元测试。有关详细信息，请参阅 *使用 PDK 的 RSpec 测试* 部分。
- en: The PDK has build and release commands to make a .`tar` file for uploading to
    Puppet Forge and the Puppet debugging console.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: PDK 具有构建和发布命令，可以生成 `.tar` 文件，用于上传到 Puppet Forge 和 Puppet 调试控制台。
- en: 'To create a module, the `pdk new module` command (optionally with the module’s
    name at the end) is run. Answer the questions regarding the module’s name (if
    it wasn’t provided, specify your Puppet Forge username, if you have one), who
    wrote the module, the license the code should fall under, and the OSs that will
    be supported. This process can be seen in the following screenshot:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个模块，执行 `pdk new module` 命令（可选地在末尾加上模块名称）。回答关于模块名称的问题（如果没有提供模块名称，则指定你的 Puppet
    Forge 用户名，若有的话），模块的作者，代码应遵循的许可协议，以及支持的操作系统。此过程可以在以下截图中看到：
- en: '![Figure 8.2 – pdk new module questions](img/B18492_08_02.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – pdk 新模块问题](img/B18492_08_02.jpg)'
- en: Figure 8.2 – pdk new module questions
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – pdk 新模块问题
- en: The answers provided for user details and licenses will be offered as defaults
    in future runs and can be checked by running `pdk get config` and reviewing the
    `user.module_defaults` settings.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对用户详细信息和许可协议提供的答案将作为默认值，在以后运行时提供，并可以通过运行 `pdk get config` 并检查 `user.module_defaults`
    设置来查看。
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `puppet module generate` command, which was used before the introduction
    of the PDK, was deprecated in Puppet 5 and removed in Puppet 6.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入 PDK 之前使用的 `puppet module generate` 命令，在 Puppet 5 中已弃用，并在 Puppet 6 中被移除。
- en: 'Once the answers have been entered and confirmed, a directory containing the
    module names will be created. It will contain the following content directories,
    which were previously discussed in the *What is a module and what is in* *it?*
    section:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入并确认了答案，将创建一个包含模块名称的目录。该目录将包含先前在 *模块是什么及其内容* 部分中讨论的以下内容目录：
- en: '`data`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`'
- en: '`examples`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`examples`'
- en: '`files`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`files`'
- en: '`Manifests`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Manifests`'
- en: '`spec`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`'
- en: '`tasks`'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tasks`'
- en: '`templates`'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`templates`'
- en: 'Using the default built-in template, it then creates the following additional
    configuration files and directories:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的内建模板后，它将创建以下额外的配置文件和目录：
- en: '| **File/Directory Name** | **File/Directory Use** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **文件/目录名称** | **文件/目录用途** |'
- en: '| `appveyor.yml` | Appveyor CI integration configuration file |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `appveyor.yml` | Appveyor CI 集成配置文件 |'
- en: '| `CHANGELOG.md` | A change log that can be maintained |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `CHANGELOG.md` | 可维护的变更日志 |'
- en: '| `.``devcontainer` | How a container should be configured to test this module
    |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `.``devcontainer` | 配置容器以测试此模块的方式 |'
- en: '| `.``fixtures.yml` | Test module dependencies configuration |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `.``fixtures.yml` | 测试模块依赖配置 |'
- en: '| `Gemfile` | Ruby gem dependencies |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `Gemfile` | Ruby gem 依赖 |'
- en: '| `Gemfile.lock` | Ruby gem dependencies |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `Gemfile.lock` | Ruby gem 依赖 |'
- en: '| `.``gitattributes` | Associates attributes and behaviors with file types
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `.``gitattributes` | 将属性和行为与文件类型关联 |'
- en: '| `.``gitignore` | Files Git should ignore |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `.``gitignore` | Git 应忽略的文件 |'
- en: '| `.``gitlab-ci.yml` | Example configuration for using with GitLab CI |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `.``gitlab-ci.yml` | 用于 GitLab CI 的示例配置 |'
- en: '| `metadata.json` |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `metadata.json` |'
- en: Metadata, including questions filled out during creation
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建时填写的元数据，包括问题回答
- en: '|'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `.``pdkignore` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `.``pdkignore` |'
- en: Files to ignore when building a package for Puppet Forge
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建 Puppet Forge 包时忽略的文件
- en: '|'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `.``puppet-lint.rc` | Configuration for the `puppet-lint` gem |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `.``puppet-lint.rc` | `puppet-lint` gem 的配置 |'
- en: '| `Rakefile` | Ruby task configuration |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `Rakefile` | Ruby 任务配置 |'
- en: '| `README.md` | A template for a README page for the module |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `README.md` | 模块的 README 页模板 |'
- en: '| `.``rspec` | Configuration defaults for `rspec` for unit testing |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `.``rspec` | `rspec` 单元测试的配置默认值 |'
- en: '| `.``rubocop.yml` | Settings for Ruby style checking |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `.``rubocop.yml` | Ruby 风格检查设置 |'
- en: '| `/``spec` | A directory containing files for `rspec` unit testing |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `/``spec` | 包含 `rspec` 单元测试文件的目录 |'
- en: '| `/``spec/default_facts.yaml` | Default facts available for all tests |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `/``spec/default_facts.yaml` | 所有测试都可用的默认事实 |'
- en: '| `/``spec/spec_helper.rb` | Entry point script for `rspec` that sets various
    configurations |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `/``spec/spec_helper.rb` | `rspec` 的入口脚本，设置各种配置 |'
- en: '| `.``sync.yml` | A file to customize the PDK template in use |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `.``sync.yml` | 自定义正在使用的 PDK 模板的文件 |'
- en: '| `.``vscode` | Configuration for VSCode, such as recommended extensions |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `.``vscode` | VSCode 配置，例如推荐的扩展 |'
- en: '| `.``yardopts` | Configuration file for Puppet Strings |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `.``yardopts` | Puppet Strings 配置文件 |'
- en: Table 8.2 – PDK default template files and directories
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.2 – PDK 默认模板文件和目录
- en: For a pre-existing module, it is also possible to run `pdk convert` to adapt
    the module to the template. It will confirm the changes it would make before applying
    them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已有的模块，也可以运行 `pdk convert` 将模块适配到模板中。它会在应用更改之前确认将要做出的修改。
- en: 'The size of the contents of PDK has grown over time and the default template
    can contain a lot of unused files. It is possible to create a custom template
    simply by forking from [https://github.com/puppetlabs/pdk-templates](https://github.com/puppetlabs/pdk-templates)
    and following the README file to adjust the template as required. It can then
    be used in a module by using `--template-url` on the new module or convert commands.
    Alternatively, the `.sync.yml` files can be set to be deleted, unmanaged, or have
    settings changed. The following `.sync.yml` file example would set the `.gitlab-ci.yml`
    file so that it’s not in the module. It would ensure the `.vscode` directory is
    not managed by PDK templates, avoiding any future updates. It would also disable
    legacy facts (global variables of facts, which were covered in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123)):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: PDK 内容的大小随着时间的推移而增长，默认模板可能包含许多未使用的文件。可以通过从 [https://github.com/puppetlabs/pdk-templates](https://github.com/puppetlabs/pdk-templates)
    进行 fork 并按照 README 文件的指导调整模板，来创建自定义模板。然后，可以通过在新模块或转换命令中使用 `--template-url` 来使用该模板。此外，`.sync.yml`
    文件可以设置为删除、不受管理或更改设置。以下的 `.sync.yml` 文件示例将设置 `.gitlab-ci.yml` 文件，使其不包含在模块中。它将确保
    `.vscode` 目录不受 PDK 模板管理，从而避免将来的更新。它还将禁用旧版事实（事实的全局变量，详细介绍见 [*第 5 章*](B18492_05.xhtml#_idTextAnchor123)）：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The full settings that can be adjusted are documented in the PDK template README
    file: [https://github.com/puppetlabs/pdk-templates/blob/main/README.md](https://github.com/puppetlabs/pdk-templates/blob/main/README.md).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调整的完整设置已在 PDK 模板的 README 文件中进行了文档化：[https://github.com/puppetlabs/pdk-templates/blob/main/README.md](https://github.com/puppetlabs/pdk-templates/blob/main/README.md)。
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If a configuration change is required across several existing modules, the
    `modulesync` module can be useful for managing this. It is available on the following
    web page: [https://github.com/voxpupuli/modulesync](https://github.com/voxpupuli/modulesync).'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在多个现有模块中进行配置更改，可以使用 `modulesync` 模块来管理此操作。它可以通过以下网页获得：[https://github.com/voxpupuli/modulesync](https://github.com/voxpupuli/modulesync)。
- en: Now that the contents of a PDK module and its tooling have been described in
    detail, we will describe the workflow of developing a module, as shown in *Figure
    8**.3*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细描述了 PDK 模块及其工具的内容，接下来我们将描述开发模块的工作流程，如 *图 8.3* 所示。
- en: ¶¶¶
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ¶¶¶
- en: '![](img/B18492_08_03.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18492_08_03.jpg)'
- en: Figure 8.3 – The PDK workflow
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – PDK 工作流程
- en: As was discussed, by running `pdk new` to create a new module or `pdk convert`
    on an uncontrolled module, an initial module of PDK content and its settings is
    established. Using `pdk update`, the configuration of a module can be updated
    since we can change its settings, provide a new template, or change the PDK version.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通过运行 `pdk new` 创建新模块或在未受控模块上运行 `pdk convert`，可以建立一个初始的 PDK 内容模块及其设置。使用
    `pdk update`，可以更新模块的配置，因为我们可以更改其设置、提供新的模板或更改 PDK 版本。
- en: The next step is to add any new content files that are required. This may include
    a `class`, `defined_type`, fact, function provider, task, or transport and can
    be done by using the `pdk new` command and the relevant content. This will create
    a file by using the template for the chosen content and a `rspec` test file. For
    content that’s not available through PDK, such as external facts or plans, the
    files and tests must be created manually.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加任何需要的新内容文件。这可能包括 `class`、`defined_type`、fact、函数提供者、任务或传输，可以通过使用 `pdk new`
    命令和相关内容来完成。这将使用所选内容的模板和一个 `rspec` 测试文件创建一个文件。对于 PDK 无法提供的内容，例如外部 facts 或计划，必须手动创建文件和测试。
- en: 'Once the file and test for the content are in place, your code should be added.
    At regular intervals, the code can be validated and tested via the `pdk validate`
    command, which checks the linting and syntax parsing. This command can also be
    used with the `-a` flag, which will attempt to auto-correct any errors. For linting
    errors, specific checks can be ignored in a section of a file by using inline
    comments or by surrounding areas of code with comments via `lint:ignore:<rule
    name>`. The following example shows how a line could be set to ignore the 140-character
    lint rule. In this case, the section of code would ignore the check for double
    quotes, which should only be used where both strings and variables are used in
    variable assignment:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件和内容测试就位，应该添加你的代码。可以通过定期运行`pdk validate`命令来验证和测试代码，这个命令会检查代码的代码风格和语法解析。此命令也可以与`-a`标志一起使用，该标志会尝试自动修正任何错误。对于代码风格错误，可以通过使用内联注释或通过在代码区域周围加注释`lint:ignore:<rule
    name>`来忽略文件某部分的特定检查。以下示例展示了如何设置某一行忽略140字符的代码风格规则。在这种情况下，该段代码会忽略双引号检查，双引号只应在同时使用字符串和变量进行变量赋值时使用：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the check must be ignored in all code, the `.puppet-lint.rc` file could be
    updated by adding a flag such as `--no-selector_inside_resource-check` to ensure
    `puppet-lint` does not run the check to ensure selector code is inside a resource.
    The full list of `puppet-lint` checks can be viewed at [https://github.com/puppetlabs/puppet-lint/tree/gh-pages/checks](https://github.com/puppetlabs/puppet-lint/tree/gh-pages/checks).
    Note that disabling checks should be avoided as much as possible as this may affect
    your module scoring or ability to get a module endorsed in Puppet Forge. This
    drives your code further away from recommended Puppet practices.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须在所有代码中忽略该检查，可以通过添加类似`--no-selector_inside_resource-check`的标志更新`.puppet-lint.rc`文件，以确保`puppet-lint`不执行检查，确保选择器代码位于资源内部。可以在[https://github.com/puppetlabs/puppet-lint/tree/gh-pages/checks](https://github.com/puppetlabs/puppet-lint/tree/gh-pages/checks)查看`puppet-lint`检查的完整列表。请注意，尽可能避免禁用检查，因为这可能会影响模块评分或影响模块是否能在Puppet
    Forge获得认证。这会使你的代码远离推荐的Puppet实践。
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[http://puppet-lint.com/checks/](http://puppet-lint.com/checks/) is not owned
    by Puppet and is out of date. Puppet forked the module to [https://github.com/puppetlabs/puppet-lint](https://github.com/puppetlabs/puppet-lint),
    which is why it is recommended that [https://puppetlabs.github.io/puppet-lint](https://puppetlabs.github.io/puppet-lint)
    is used instead.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://puppet-lint.com/checks/](http://puppet-lint.com/checks/) 不是Puppet公司所有，并且已经过时。Puppet将该模块分支到[https://github.com/puppetlabs/puppet-lint](https://github.com/puppetlabs/puppet-lint)，因此建议使用[https://puppetlabs.github.io/puppet-lint](https://puppetlabs.github.io/puppet-lint)。'
- en: Once `pdk validate` is running cleanly, the `pdk test unit` command can be run
    to perform unit testing. The checks provided by the templates are basic and are
    meant to check if the code works at all; in the case of Puppet code, it ensures
    the code will compile. A powerful feature is that checks can be run against specific
    Puppet or Puppet Enterprise versions by using the `--puppet-version` flag or `--pe-version`
    – for example, `pdk test unit –pe-version=2019.11` – so that code testing can
    take place before upgrades. In the next section, you will learn how to expand
    the `rspec` checks further.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`pdk validate`成功运行，可以执行`pdk test unit`命令来进行单元测试。模板提供的检查是基础性的，旨在检查代码是否能正常工作；对于Puppet代码，它确保代码能够编译。一个强大的功能是，通过使用`--puppet-version`标志或`--pe-version`，检查可以针对特定的Puppet或Puppet
    Enterprise版本进行运行——例如，`pdk test unit –pe-version=2019.11`——这样可以在升级之前进行代码测试。在下一部分，你将学习如何进一步扩展`rspec`检查。
- en: Puppet Forge will be discussed in detail at the end of this chapter. Releasing
    to Puppet Forge is beyond the scope of this book but if the code is to be released
    for use in Puppet Forge, you can run the `pdk build` command to create a `.tar`
    file to be uploaded or the `pdk release` command to automate the process of uploading
    modules to Puppet Forge.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Forge将在本章最后详细讨论。本书不涉及发布到Puppet Forge的内容，但如果要将代码发布到Puppet Forge供使用，可以运行`pdk
    build`命令来创建`.tar`文件进行上传，或者运行`pdk release`命令来自动化上传模块到Puppet Forge的过程。
- en: It is important to keep `metadata.json` up to date as it will restrict what
    testing takes place based on Puppet’s supported version and is a key part of the
    documentation. The format and its options can be viewed at [https://docs.puppet.com/puppet/latest/modules_metadata.html](https://docs.puppet.com/puppet/latest/modules_metadata.html).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 保持 `metadata.json` 文件的最新状态非常重要，因为它将限制根据 Puppet 支持的版本进行的测试，并且是文档的重要部分。可以在 [https://docs.puppet.com/puppet/latest/modules_metadata.html](https://docs.puppet.com/puppet/latest/modules_metadata.html)
    查看其格式及选项。
- en: To view all the options available, you can review the full PDK command reference
    at [https://puppet.com/docs/pdk/2.x/pdk_reference.html](https://puppet.com/docs/pdk/2.x/pdk_reference.html).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查看所有可用的选项，您可以在 [https://puppet.com/docs/pdk/2.x/pdk_reference.html](https://puppet.com/docs/pdk/2.x/pdk_reference.html)
    中查阅完整的 PDK 命令参考。
- en: Having reviewed how to use the PDK to create and manage modules, as well as
    its validation and testing capabilities, let’s learn how to perform full unit
    testing using RSpec.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了如何使用 PDK 创建和管理模块，以及其验证和测试功能后，我们来学习如何使用 RSpec 进行完整的单元测试。
- en: Testing with RSpec using the PDK
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PDK 进行 RSpec 测试
- en: To take this initial validation and compilation testing further at the unit
    test level, RSpec can be used to test the behavior and logic of modules, while
    ServerSpec can be used to test at the system integration level.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在单元测试层面进一步进行初步验证和编译测试，RSpec 可用于测试模块的行为和逻辑，而 ServerSpec 可用于进行系统集成测试。
- en: RSpec is a Ruby framework for testing Ruby code and is written in a `rspec-puppet`
    test is an implementation of RSpec, specifically designed for testing Puppet modules.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: RSpec 是一个用于测试 Ruby 代码的 Ruby 框架，`rspec-puppet` 测试是 RSpec 的一个实现，专门用于测试 Puppet
    模块。
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is important to note that the current project code is available at [https://github.com/puppetlabs/rspec-puppet](https://github.com/puppetlabs/rspec-puppet),
    forked from [https://github.com/rodjek/rspec-puppet](https://github.com/rodjek/rspec-puppet),
    with core guides and documentation available at [http://rspec-puppet.com/](http://rspec-puppet.com/).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，当前项目代码可以在 [https://github.com/puppetlabs/rspec-puppet](https://github.com/puppetlabs/rspec-puppet)
    中找到，它是从 [https://github.com/rodjek/rspec-puppet](https://github.com/rodjek/rspec-puppet)
    派生的，核心指南和文档可以在 [http://rspec-puppet.com/](http://rspec-puppet.com/) 找到。
- en: When users start using RSpec, some may feel that it is just mimicking the Puppet
    code but in a different language. RSpec runs through the different logic and behavior
    of your Puppet code and ensures that the correct catalogs and output will be produced
    in various environments and cases. This protects against regressions when refactoring
    or upgrading to new Puppet releases. If the RSpec code is becoming a simple mimic
    of the code in the manifest, then the test scenarios are not being reviewed properly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户开始使用 RSpec 时，有些人可能会觉得它只是用不同的语言模仿 Puppet 代码。RSpect 会运行 Puppet 代码中的不同逻辑和行为，确保在各种环境和情况下会产生正确的目录和输出。这可以防止在重构或升级到新版本的
    Puppet 时出现回归。如果 RSpec 代码只是简单地模仿清单中的代码，那么测试场景就没有得到正确的审查。
- en: The advantage of this style of unit testing is that it allows you to test code
    without having to spin up any specific infrastructure or make any changes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这种单元测试风格的优点在于，它允许你在不启动任何特定基础设施或进行任何更改的情况下测试代码。
- en: RSpec tests are contained in Ruby files in a module inside the `spec` directory,
    with directories containing the tests for different types of code, such as classes
    in the `spec/classes` directory, and defined types in the `spec/defines` directory.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: RSpec 测试包含在 `spec` 目录下的 Ruby 文件中的模块里，目录中包含了针对不同类型代码的测试，例如 `spec/classes` 目录中的类，和
    `spec/defines` 目录中的定义类型。
- en: We are ignoring the other possible test directories (the `types`, `type_alias`,
    and `functions` test directories) as creating them is beyond the scope of this
    book. However, most of what will be discussed here can apply to these types.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将忽略其他可能的测试目录（如 `types`、`type_alias` 和 `functions` 测试目录），因为创建它们超出了本书的范围。然而，这里讨论的大部分内容可以应用于这些类型。
- en: RSpec configuration is covered within the PDK and the files are created automatically
    with the `pdk new` commands. However, they can be added either when converting
    a module or using the PDK by adding the `--add-tests` flag to the `convert` command,
    `pdk convert --add-tests`, and with the `pdk new test --unit <name>` command,
    respectively.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: RSpec 配置包含在 PDK 中，文件会通过 `pdk new` 命令自动创建。但是，当转换模块或使用 PDK 时，可以通过向 `convert` 命令添加
    `--add-tests` 标志 (`pdk convert --add-tests`)，以及使用 `pdk new test --unit <name>`
    命令分别进行添加。
- en: 'Before we look at what a defined type and class will get by default from the
    PDK, we must run the `pdk new class exampleapp` and `pdk new define example_define`
    commands on the `exampleapp` module to create the main manifest and a defined
    type called `example_define`. This will result in a file called `spec/classes/exampleapp.rb`
    with the following contents:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看PDK默认为定义类型和类提供的内容之前，我们必须在`exampleapp`模块上运行`pdk new class exampleapp`和`pdk
    new define example_define`命令，以创建主清单和一个名为`example_define`的定义类型。这样会生成一个名为`spec/classes/exampleapp.rb`的文件，内容如下：
- en: '[PRE12]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Further, `spec/defined/example_define.rb` can be created as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`spec/defined/example_define.rb`可以如下创建：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Breaking this down, the first step is to `require spec_helper`, which results
    in the `spec/spec_helper.rb` file being loaded. Because the `spec` directory is
    loaded into the path automatically, it only needs to state the title; this configures
    RSpec, which will be discussed in more detail later in this section. The next
    part, `describe`, is an RSpec keyword that’s used to describe a group of tests.
    For both the `exampleapp` and `example_define` tests, the name of the class and
    defined class are described since there is only one basic group of tests for each.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 分解这个过程，第一步是`require spec_helper`，它会加载`spec/spec_helper.rb`文件。由于`spec`目录会自动加载到路径中，因此只需要声明标题；这将配置RSpec，稍后将在本节中详细讨论。接下来的部分是`describe`，它是RSpec中的一个关键字，用于描述一组测试。对于`exampleapp`和`example_define`测试，描述的是类和定义类的名称，因为每个测试组只有一个基本的测试组。
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have used `puppet-rspec` previously, you may have set an additional type
    definition in the `describe` statement, such as `describe 'exampleapp'`, `:type
    => :class do`. This is unnecessary due to the folders acting as auto identifiers
    of the type.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前使用过`puppet-rspec`，你可能在`describe`语句中设置了额外的类型定义，比如`describe 'exampleapp'`,
    `:type => :class do`。由于文件夹本身充当了类型的自动标识符，这一步是多余的。
- en: A defined type always needs a title and any parameters. Upon using the `let`
    keyword, a title is set, as well as parameters, which in this case are blank.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类型始终需要一个标题和任何参数。使用`let`关键字时，设置了标题以及参数，在这种情况下，参数为空。
- en: Both the `exampleapp` and `example_define` classes then perform a loop using
    the `on_supported_os` function, which is provided by the `rspec-puppet-facts`
    gem, taking the input from the `metadata.json` file, which contains details regarding
    the OSs that are supported and producing an array of facts in the `os_facts` variable.
    This is then passed to another `let`, which assigns these facts to the contents
    of the `os_facts` array.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`exampleapp`和`example_define`类使用`on_supported_os`函数进行循环，该函数由`rspec-puppet-facts`宝石提供，输入来自`metadata.json`文件，该文件包含有关支持的操作系统的详细信息，并生成一个存储在`os_facts`变量中的事实数组。接着，这些事实被传递到另一个`let`中，将这些事实赋值给`os_facts`数组的内容。
- en: The `it` keyword is known as an `rspec` terms and can be either a single line
    or encased within a `do` end block. This is a test case and contains an expect
    statement called `is_expected.to`, which is a verification step of a condition.
    This condition is expressed via a matcher. In this case, this will compile the
    Puppet code of the class and defined type and confirm that a catalog will be generated
    successfully.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`it`关键字是一个RSpec术语，可以是单行的，也可以包含在`do`和`end`块内。它是一个测试用例，包含一个叫做`is_expected.to`的期望语句，这是对某个条件的验证步骤。这个条件通过匹配器来表达。在这种情况下，它将编译类和定义类型的Puppet代码，并确认会成功生成目录。'
- en: Note
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We recommend the styling guide available at [https://www.betterspecs.org/](https://www.betterspecs.org/),
    which is for the general Ruby RSpec style. We will be quoting recommendations
    from it throughout this chapter.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们推荐使用[https://www.betterspecs.org/](https://www.betterspecs.org/)上的样式指南，它适用于通用的Ruby
    RSpec风格。我们将在本章中引用其中的建议。
- en: Having briefly examined the default compile test, let’s look at each component
    and how to expand them further.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 简要查看了默认的编译测试后，让我们看看每个组件以及如何进一步扩展它们。
- en: The describe and context keywords
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`describe`和`context`关键字'
- en: One of the big confusions for many Puppet developers who have previously tried
    to use RSpec is understanding where to use the `describe` keyword and where to
    use `context`. They seem to be interchangeable, and this is for a very good reason.
    The `context` keyword is an alias of `describe`, so they are interchangeable,
    and your use only affects how your code reads.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多曾尝试使用RSpec的Puppet开发者来说，一个大的困惑是理解何时使用`describe`关键字，何时使用`context`。它们看起来是可以互换的，这有充分的理由。`context`关键字是`describe`的别名，所以它们是可以互换的，你的使用仅影响代码的可读性。
- en: '*Betterspecs* recommends using `describe` to describe the method being tested.
    In terms of Puppet RSpec, this was why we saw `describe` with a class name of
    `exampleapp` and `exampleapp::example_define` as its defined class in the *Testing
    with RSpec using the* *PDK* section.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*Betterspecs*建议使用`describe`来描述正在测试的方法。在Puppet RSpec中，这也是我们在*使用PDK进行RSpec测试*部分看到`describe`与类名`exampleapp`以及其定义类`exampleapp::example_define`的原因。'
- en: It is recommended that `context` be written in a style of *when*, *with*, or
    *without* situations, which should make it clear what scenario is being tested.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐将`context`写成*何时*、*与*或*不与*等情境方式，这样可以明确说明正在测试的场景。
- en: The style recommendation of this book is to write a single `describe` to match
    the Puppet type, such as `class`, and then `context` to match the scenarios to
    be tested.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的风格推荐是写一个单独的`describe`来匹配Puppet类型，比如`class`，然后使用`context`来匹配要测试的场景。
- en: The blocks of `describe` and `context` allow the situation being tested to be
    described and for us to set facts, variables, and parameters. Since they can be
    nested, it allows inheritance to take place, which will build up more detailed
    scenarios, or different logical routes to be tried, though care should be taken
    not to make the cases too hard to read.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`和`context`的块允许描述正在测试的情况，并设置事实、变量和参数。由于它们可以嵌套，因此可以实现继承，这将构建更详细的场景，或尝试不同的逻辑路径，但需要注意不要使这些案例过于难以阅读。'
- en: 'The aim should be to test all cases. So, a plan should be made to test valid,
    edge, and invalid cases, allowing both positive and negative cases to be tested.
    As a simple example without any code tests or parameters set, the following code
    for the `exampleapp` class would look at the contexts for each supported OS, based
    on whether the `install` version is a middle value, a low edge version, or an
    invalid version:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 目标应该是测试所有情况。因此，应该计划测试有效、边缘和无效情况，允许正面和负面情况都能被测试。作为一个简单的示例，在没有任何代码测试或参数设置的情况下，以下`exampleapp`类的代码将根据`install`版本是否为中间值、低边缘版本或无效版本来查看每个受支持操作系统的上下文：
- en: '[PRE14]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that we have the basic structure of the scenarios to test, the next step
    is to use matchers to test what is produced in the catalog based on `context`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了测试场景的基本结构，下一步是使用匹配器来测试根据`context`在目录中生成的内容。
- en: Examples, expectations, and matchers
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例、期望和匹配器
- en: 'The sample `it` statements can be either a single line, as demonstrated in
    the *Testing with RSpec using the PDK* section, or can be broken up over multiple
    lines when the matcher that’s used is too long to be on a single line. Using `do`
    and `end`, the same compile example could be expressed as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 示例`it`语句可以是单行的，如在*使用PDK进行RSpec测试*部分所示，或者当所使用的匹配器太长，无法放在一行时，可以分成多行。使用`do`和`end`，相同的编译示例可以表示如下：
- en: '[PRE15]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the general Ruby RSpec implementation, expectations have a broader choice,
    but in `puppet-rspec`, our expectations will be limited to just using the `is_expected`
    keyword. However, this can be negated by using `not_to` – for example, `It {`
    `is_expected.not_to`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般的Ruby RSpec实现中，期望有更广泛的选择，但在`puppet-rspec`中，我们的期望将仅限于使用`is_expected`关键字。不过，可以通过使用`not_to`来否定它——例如，`It
    { is_expected.not_to }`。
- en: The matchers provide a variety of tests for testing various resource types.
    The matcher syntax is `contain_<resource_type>('<title>').<options>`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器提供了多种测试，用于测试不同的资源类型。匹配器的语法为`contain_<resource_type>('<title>').<options>`。
- en: For the compile matcher, we could be more explicit by adding the `with_all_deps`
    option to the compile – for example, `it { is_expected.to compile.with_all_deps
    }`. This would test that all the relationships in the catalog contain resources.
    Alternatively, we could look for a compile error with the `and_raise_error('error_message')`
    option, which will contain the message we expect to be thrown as a string – for
    example, `it { is_expected.to compile.raise_error('lets cause` `failure' }`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译匹配器，我们可以通过添加`with_all_deps`选项来更明确地进行编译测试——例如，`it { is_expected.to compile.with_all_deps
    }`。这将测试目录中所有关系是否包含资源。或者，我们可以通过使用`and_raise_error('error_message')`选项来查找编译错误，这将包含我们期望抛出的消息作为字符串——例如，`it
    { is_expected.to compile.raise_error('lets cause` `failure' }`。
- en: The main set of matches is based on resource types using a pattern of `contain_<resource_type>('<resource_title>')`
    – for example,
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的匹配集合是基于资源类型，使用`contain_<resource_type>('<resource_title>')`模式——例如，
- en: '`it { is_expected.to contain_class(''exampleclass::install'') }` and `it {
    is_expected.to` `contain_service(''httpd'') }`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`it { is_expected.to contain_class(''exampleclass::install'') }` 和 `it { is_expected.to
    contain_service(''httpd'') }`。'
- en: '`Rspec-puppet` does not do class name parsing or lookup, so the matcher will
    only accept qualified classes without leading colons. So, `install` won’t be found
    in `exampleclass`, but `exampleclass::install` will. If a resource type contains
    a `::` symbol, this needs to be converted into a `__` symbol, which will make
    it `contain_exampleapp__exampletype`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rspec-puppet`不会进行类名解析或查找，因此匹配器只接受没有前导冒号的限定类。因此，`install`在`exampleclass`中找不到，但`exampleclass::install`可以找到。如果资源类型包含`::`符号，则需要将其转换为`__`符号，这样它将变成`contain_exampleapp__exampletype`。'
- en: 'Resource matchers can be further expanded by chaining them using the `with`,
    `only_with`, and `without` methods. This allows us to check the parameters of
    resources; `with` ensures the resource in the catalog has the parameters as specified,
    `only_with` ensures that only the parameters provided have been set and no others,
    and `without` accepts an array of parameters and ensures those parameters are
    not set. When using these methods, it is more readable to use an `it do...end`
    format, as shown in the following example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 资源匹配器可以通过使用`with`、`only_with`和`without`方法进一步扩展。这使我们能够检查资源的参数；`with`确保目录中的资源具有指定的参数，`only_with`确保仅设置提供的参数而没有其他参数，`without`接受一个参数数组并确保这些参数没有被设置。在使用这些方法时，使用`it
    do...end`格式更具可读性，以下是一个示例：
- en: '[PRE16]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This can be shortened to only one parameter by following the method syntax
    for `with` and `only_with`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循`with`和`only_with`的方法语法，这可以简化为仅一个参数：
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For `without`, the method accepts an array of parameters that should not be
    set on the resource:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`without`，该方法接受一个不应设置在资源上的参数数组：
- en: '[PRE18]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'These methods can be chained together either as the same methods or as a mix:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可以通过链式调用的方式组合在一起，无论是作为相同的方法，还是作为混合方法：
- en: '[PRE19]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'A different kind of matcher for resources is using a `count`, which allows
    the `have_<resource_type>_count` syntax. For example, to verify if the total number
    of resources is `5` and the total number of classes is `4`, the following code
    can be run:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种资源匹配器是使用`count`，它允许使用`have_<resource_type>_count`语法。例如，要验证资源的总数是否为`5`，类的总数是否为`4`，可以运行以下代码：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Having reviewed how to set examples, it is clear that for the `describe` and
    `context` keywords, parameters and pre-conditions will need to be set for there
    to be a testing scenario. For example, if the context is that the install version
    is 1, then the parameter install version will need to be set to 1.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了如何设置示例后，显然对于`describe`和`context`关键字，必须设置参数和前置条件才能形成测试场景。例如，如果上下文是安装版本为1，则需要将安装版本参数设置为1。
- en: Parameters and preconditions
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数和前置条件
- en: In the default example for defined types, we explained how the `let` keyword
    can be used to set specify the title and empty parameters of a test instantiation
    of a defined type. However, these can also be used for other types, such as parameterized
    classes.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义类型的默认示例中，我们解释了如何使用`let`关键字来指定定义类型的测试实例的标题和空参数。然而，这些也可以用于其他类型，如带参数的类。
- en: 'To populate parameters, an array of keys and values separated by a `=>` symbol
    can be supplied in strings with an undefined value declared as `:undef`, which
    is translated to `undef` when it compiles the test. For example, to set `param1`
    to the `yup` string and `param2` to `undef`, the following `let` could be used:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要填充参数，可以提供一个由`=>`符号分隔的键值对数组，在字符串中未定义的值声明为`:undef`，在编译测试时会转换为`undef`。例如，要将`param1`设置为`yup`字符串，并将`param2`设置为`undef`，可以使用以下`let`：
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In addition to parameters, preconditions can also be set. So, if the manifest
    being tested is dependent on another class or variable being in the catalog, this
    could be added so it will be evaluated before the test class. For example, in
    the module pattern, we showed that the `config` class needed to be evaluated after
    the `install` class in the catalog but before the `service` class. This could
    be done using the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 除了参数外，还可以设置前置条件。因此，如果正在测试的清单依赖于目录中存在另一个类或变量，则可以将其添加，以便在测试类之前进行评估。例如，在模块模式中，我们展示了`config`类需要在`install`类之后但在`service`类之前在目录中进行评估。这可以通过以下代码完成：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'An array of strings can also be used if there are multiple conditions. If the
    test is for a specific node or environment, this can be set as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个条件，也可以使用字符串数组。如果测试针对特定的节点或环境，可以按如下方式设置：
- en: '[PRE23]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The node should be a **fully qualified domain** **name** (**FQDN**).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 节点应该是**完全合格的域名**（**FQDN**）。
- en: Relationships
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系
- en: The relationships of resources can be tested with the `that_requires`, `that_comes_before`,
    `that_notifies`, and `that_subscribes_to` methods. It is not important if the
    Puppet code is using a `require` and RSpec is using `that_comes_before` or if
    the Puppet code is using directional arrows, so long as the variants are logically
    equivalent to each other since the test is on the catalog.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 资源之间的关系可以通过`that_requires`、`that_comes_before`、`that_notifies`和`that_subscribes_to`方法进行测试。无论Puppet代码使用`require`，还是RSpec使用`that_comes_before`，或者Puppet代码使用方向箭头，只要这些变体在逻辑上是等价的，都不重要，因为测试是在目录上进行的。
- en: 'These methods are chained into the example with the requirement, but there
    are some differences between how relationships are declared in a Puppet manifest
    and how they are declared in a `rspec` test: the name should not be quoted, it
    cannot have multiple resource names under a single type, and if a class is referenced,
    there should be no leading `::` to mark it as the top scope. As a simple example,
    a file called `exampleconfig` that requires the `exampleapp` package can be checked
    as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法被链式调用到示例中与需求一起，但是在Puppet清单中声明关系与在`rspec`测试中声明关系之间存在一些区别：名称不应加引号，不能在单一类型下有多个资源名称，如果引用了类，则不应使用前导`::`标记它为顶级作用域。举个简单的例子，一个名为`exampleconfig`的文件要求`exampleapp`包，可以通过以下方式进行检查：
- en: '[PRE24]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To check that the `exampleapp` package was before the `exampleapp::service`
    and `exampleapp::config` classes, an array can be passed. However, note that they
    cannot be under one class:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查`exampleapp`包是否在`exampleapp::service`和`exampleapp::config`类之前，可以传递一个数组。然而，请注意，它们不能在一个类下：
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: An example of a resource with parameters using `it do...end` that notified two
    files is as follows
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`it do...end`的带参数资源示例如下，其中通知了两个文件：
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the test is on something like a defined class that has `require` or `before`
    as part of its definition, this relationship can be set in parameters. However,
    the `ref` helper must be used to name the resource it is dependent on, using the
    `ref(''<type>'',''<title''>)` syntax. For a defined type that requires the `exampleapp`
    package, the following code would add the relationship via parameters:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试的是类似定义类的内容，并且它的定义中包含`require`或`before`，则可以在参数中设置此关系。然而，必须使用`ref`辅助函数来命名它所依赖的资源，使用`ref('<type>','<title>')`语法。对于一个需要`exampleapp`包的定义类型，以下代码会通过参数添加该关系：
- en: '[PRE27]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Data from Hiera and facts
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自Hiera和事实的数据
- en: 'Data from Hiera and facts have a huge influence on the logic in our code, so
    it must be able to be supplied and customized to cover the different scenarios
    to be tested. As was shown in the default examples in the *Testing with RSpec
    using the PDK* section, the `rspec-puppet-facts` gem checks the `metadata.json`
    file to find the list of supported OSs. However, `metadata.json` does not have
    a way to provide architectures, and by default, `rspec-puppet-facts` chooses a
    default architecture depending on the OS, such as i86PC for Solaris or x86_64
    for Fedora. If you want to be able to check additional architectures, you can
    pass hardware models in a comma-separated array. This will be combined with the
    following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Hiera和事实的数据对我们代码中的逻辑有很大的影响，因此必须能够提供并自定义，以覆盖不同的测试场景。如在*使用PDK进行RSpec测试*章节中的默认示例所示，`rspec-puppet-facts`
    gem会检查`metadata.json`文件以查找支持的操作系统列表。然而，`metadata.json`并没有提供架构的方式，默认情况下，`rspec-puppet-facts`会根据操作系统选择一个默认架构，例如Solaris的i86PC或Fedora的x86_64。如果您希望能够检查其他架构，可以通过逗号分隔的数组传递硬件模型。这样将与以下代码结合使用：
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If it only makes sense to test a subsection such as a class that has been specifically
    made for an OS, then you can pass the relevant details using the `operatingsystem`
    and `operatingsystemreleases` parameters; this will override `metadata.json`:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要测试一个子集，例如专为某个操作系统制作的类，则可以通过`operatingsystem`和`operatingsystemreleases`参数传递相关的详细信息；这将覆盖`metadata.json`：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using the `on_supported_os` method, this can only be set on all choices. If
    nothing is found, such as i386 on Windows 11, it fails to find it silently. View
    the `facterdb` module at [https://github.com/voxpupuli/facterdb](https://github.com/voxpupuli/facterdb)
    to see what is available.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`on_supported_os`方法时，这只能在所有选择上进行设置。如果没有找到任何内容，例如Windows 11上的i386，它将默默地失败。查看`facterdb`模块[https://github.com/voxpupuli/facterdb](https://github.com/voxpupuli/facterdb)以查看可用的内容。
- en: 'It is not mandatory to use `on_supported_os` but without it, by default, there
    will be no facts. When you need to test data that doesn’t exist in `facterdb`,
    it is possible to declare the facts using `let(:facts)` and the values you wish.
    For example, if you were testing what would happen with a theoretical RedHat 10
    fact set, you would use the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`on_supported_os`并不是强制性的，但如果没有它，默认情况下将不会有任何事实。当你需要测试`facterdb`中不存在的数据时，可以通过`let(:facts)`声明事实以及你想要的值。例如，如果你要测试一个理论上的RedHat
    10事实集，你可以使用以下代码：
- en: '[PRE30]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Similarly, if additional facts were to be added to the `os_facts` variable
    in a nested `context`, the `merge` method could be used with the `super` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果要在嵌套的`context`中向`os_facts`变量添加额外的事实，可以使用`merge`方法与`super`方法：
- en: '[PRE31]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For structured facts, these merges can become more difficult. Voxpupli has an
    `override_facts` helper in [https://github.com/voxpupuli/voxpupuli-test](https://github.com/voxpupuli/voxpupuli-test)
    that can assist with this.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构化事实，这些合并可能变得更加复杂。Voxpupli在[https://github.com/voxpupuli/voxpupuli-test](https://github.com/voxpupuli/voxpupuli-test)中提供了一个`override_facts`助手，可以帮助解决这个问题。
- en: 'To add facts that can be consumed by the PDK for validation and testing the
    code, add a `spec/default_module_facts.yml`. This will contain YAML similar to
    the following:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加可以被PDK用于验证和测试代码的事实，请添加一个`spec/default_module_facts.yml`文件。这个文件将包含类似下面的YAML内容：
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `default_facts.yml` file should not be edited as it is managed by the PDK
    and provides minimal facts for the PDK to run.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`default_facts.yml`文件不应被编辑，因为它由PDK管理，并提供PDK运行所需的最小事实。'
- en: It is possible to add default facts via `.sync.yaml` either by adding a standard
    code block or by adding `default_facts.yml`, but this is needlessly complicated
    compared to `default_module_facts.yml`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`.sync.yaml`添加默认事实是可能的，方法是添加标准代码块或`default_facts.yml`，但与`default_module_facts.yml`相比，这种方式不必要地复杂。
- en: Any facts you provided with `let(:facts)` in a spec will merge on top of default
    facts.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在spec中通过`let(:facts)`提供的任何事实将会覆盖默认事实。
- en: 'In addition to these facts, three additional variables come from classification
    and external data sources: node parameters, which are global variables assigned
    from the classification to a node, trusted facts, which are variables assigned
    from within a Puppet client certificate, and trusted external facts, which are
    variables sourced from an external data source by a script. The full implementation
    of these will be described in detail in [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272)and
    [*Chapter 14*](B18492_14.xhtml#_idTextAnchor340).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些事实外，还有三个额外的变量来自分类和外部数据源：节点参数，这是从分类中分配给节点的全局变量；可信事实，这是从Puppet客户端证书中分配的变量；以及可信外部事实，这是由脚本从外部数据源获取的变量。这些的完整实现将在[*第11章*](B18492_11.xhtml#_idTextAnchor272)和[*第14章*](B18492_14.xhtml#_idTextAnchor340)中详细描述。
- en: All three types of variables can be added by using a `let` statement in the
    spec file or by setting them as defaults in `spec_helper`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在spec文件中使用`let`语句或在`spec_helper`中设置为默认值来添加所有三种类型的变量。
- en: Trusted facts from Puppet 4.3 onwards will contain trusted fact keys (`certname`,
    `domain`, and `hostname`) that are populated based on the node name, as set with
    `:node`. However, trusted external facts and node parameters will be empty.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从Puppet 4.3版本开始，可信事实将包含基于节点名称（通过`:node`设置）填充的可信事实键（`certname`，`domain`，`hostname`）。然而，可信外部事实和节点参数将为空。
- en: 'Trusted facts use `trusted_facts`, trusted external data uses `trusted_external_data`,
    and node parameters use `node_params`. For example, to declare trusted facts and
    trusted external data, the following `let` statements can be used:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可信事实使用`trusted_facts`，可信外部数据使用`trusted_external_data`，节点参数使用`node_params`。例如，要声明可信事实和可信外部数据，可以使用以下`let`语句：
- en: '[PRE33]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To set defaults, `.sync.yaml` can add additional lines by passing an array
    via `spec_overrides`; however, adding a `spec_helper_local.rb` file that contains
    the necessary lines will be easier than following the YAML syntax. Within a `Rspec.config`
    block, it is about following the `c.<fact_type> = {<fact/parameters_keys>}` format
    and using the fact/parameter name with `default_` at the beginning. So, to assign
    node parameters as defaults, `spec_helper_local.rb` can be updated as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置默认值，`.sync.yaml` 可以通过传递一个数组给 `spec_overrides` 来添加额外的行；然而，添加一个包含必要行的 `spec_helper_local.rb`
    文件会比遵循 YAML 语法更为简便。在 `Rspec.config` 块中，需要按照 `c.<fact_type> = {<fact/parameters_keys>}`
    格式，并使用带有 `default_` 前缀的 fact/parameter 名称。因此，要将节点参数指定为默认值，可以按如下方式更新 `spec_helper_local.rb`：
- en: '[PRE34]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, trusted external data can be set like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可信的外部数据也可以像这样设置：
- en: '[PRE35]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Hiera will be covered in full in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233),
    but for now, it is adequate to know that Hiera provides a `hiera.yaml` file to
    help you learn how to look up the data and a configuration file. We have created
    a `hiera.yaml` definition at `spec/fixtures/hiera/hiera.yaml`, which would typically
    have a `datadir` defined at `spec/fixtures/hieradata`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 会在 [*第 9 章*](B18492_09.xhtml#_idTextAnchor233) 中详细介绍，但现在知道 Hiera 提供一个
    `hiera.yaml` 文件来帮助你学习如何查找数据和配置文件就足够了。我们在 `spec/fixtures/hiera/hiera.yaml` 中创建了一个
    `hiera.yaml` 定义，通常会在 `spec/fixtures/hieradata` 中定义一个 `datadir`。
- en: 'This configuration for Hiera can be set in two ways, as documented at [https://github.com/puppetlabs/rspec-puppet](https://github.com/puppetlabs/rspec-puppet).
    The first option is to use `let` and set the necessary variables, as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Hiera 的配置可以通过两种方式进行设置，具体文档可以参考 [https://github.com/puppetlabs/rspec-puppet](https://github.com/puppetlabs/rspec-puppet)。第一种方式是使用
    `let` 并设置必要的变量，如下所示：
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lookups can then be performed as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 查找操作可以按如下方式进行：
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alternatively, the following could be added to `spec_helper_local.rb`. Here,
    automatic lookup of parameters would take place:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以将以下内容添加到 `spec_helper_local.rb` 中。这里，参数的自动查找将会发生：
- en: '[PRE38]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Having reviewed how to create tests for individual modules, one of the issues
    that you’ll quickly find is that various resources, such as functions, are used
    within modules. These are dependent on the content of other modules. In this next
    section, you will learn how to use fixtures to make this content available for
    testing.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何为单独的模块创建测试后，你会很快发现，模块内使用了各种资源，例如函数，而这些资源依赖于其他模块的内容。在接下来的章节中，你将学习如何使用 fixtures
    使这些内容可用于测试。
- en: Managing dependencies with fixtures
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 fixtures 管理依赖关系
- en: '`puppetlabs_spec_helper` can put dependent modules in `spec/fixtures/modules`
    for when an RSpec test unit is run. The `.fixtures.yml` file can specify `repositories:`
    for GitHub repository sources and `forge_modules:` for modules from Puppet Forge.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppetlabs_spec_helper` 可以将依赖的模块放在 `spec/fixtures/modules` 目录下，供运行 RSpec 测试单元时使用。`.fixtures.yml`
    文件可以指定 GitHub 仓库源的 `repositories:` 和 Puppet Forge 模块的 `forge_modules:`。'
- en: The main arguments that are taken are `repo`, which is either the Git repository
    link or the Puppet Forge module name, `ref` for a Git commit ID, or Forge module
    version number and `branch`, which is for a Git branch. The `ref` and `branch`
    arguments can be used together to revise a branch.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的参数是 `repo`，它可以是 Git 仓库链接或 Puppet Forge 模块名，`ref` 表示 Git 提交 ID，或 Forge 模块版本号，`branch`
    是 Git 分支名。`ref` 和 `branch` 参数可以一起使用来修改分支。
- en: 'So, an example `.fixtures.yml` containing two Git repositories and two Forge
    modules would look like this:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，包含两个 Git 仓库和两个 Forge 模块的 `.fixtures.yml` 示例文件如下：
- en: '[PRE39]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If there are no arguments other than `repo`, it can be shortened to one line,
    as shown here. If the fixtures file has changed, it is possible to run the `--clean-fixtures`
    flag with a `pdk test unit` command to ensure all contents are deleted.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除了 `repo` 之外没有其他参数，则可以简化为一行，如此所示。如果 fixtures 文件发生了变化，可以使用 `--clean-fixtures`
    标志和 `pdk test unit` 命令来确保所有内容被删除。
- en: More flags and options can be used with fixtures, as documented at [https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples](https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的标志和选项可以与 fixtures 一起使用，具体文档请参考 [https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples](https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples)。
- en: Coverage reports
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖率报告
- en: 'It is possible to produce coverage reports by adding the following piece of
    code to `spec_helper_local.rb`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将以下代码添加到 `spec_helper_local.rb` 来生成覆盖率报告：
- en: '[PRE40]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This checks whether Puppet resources have been covered and produces a percentage
    of resources covered and a list of untouched resources. The resource that’s checked
    must be within the module being tested and not contain any dependencies brought
    in by fixtures. The resource coverage percentage can also be made into a pass
    or failure point by adding a percentage pass rate in brackets. For example, by
    updating the line to `RSpec::Puppet::Coverage.report! (100`), this would ensure
    every resource (100%) is covered. This can sometimes be a motivator to push for
    RSpec use and coverage and only allow the resource percentage coverage to be reduced
    due to any particular issue or exception.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具检查 Puppet 资源是否被覆盖，并生成覆盖的资源百分比和未覆盖资源的列表。被检查的资源必须位于正在测试的模块内，并且不能包含任何由 fixtures
    引入的依赖。资源覆盖的百分比也可以通过在括号中添加通过率来设定为通过或失败的标准。例如，通过将代码行更新为 `RSpec::Puppet::Coverage.report!
    (100)`，可以确保每个资源（100%）都被覆盖。这有时可以作为推动 RSpec 使用和覆盖的动力，且只有在出现特定问题或例外时，资源覆盖百分比才会减少。
- en: Further research and tools for RSpec
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步的 RSpec 研究和工具
- en: This section has tried to provide you with enough information that you can build
    meaningful `rspec-puppet` tests with facts data and dependencies. Also, note that
    normal Ruby code can be used, such as `case` or `if` statements and variables,
    and that there are many more options for advanced configurations in `spec_helper_local`,
    as documented at [https://rspec-puppet.com/documentation/configuration/](https://rspec-puppet.com/documentation/configuration/).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 本节旨在为你提供足够的信息，以便你能够使用事实数据和依赖关系构建有意义的 `rspec-puppet` 测试。同时，请注意，可以使用普通的 Ruby 代码，如
    `case` 或 `if` 语句和变量，并且在 `spec_helper_local` 中还有许多更多高级配置选项，相关文档请见：[https://rspec-puppet.com/documentation/configuration/](https://rspec-puppet.com/documentation/configuration/)。
- en: 'This book advises against Augeas use, but it is possible to test Augeas in
    RSpec. Details can be found here: [https://github.com/domcleal/rspec-puppet-augeas](https://github.com/domcleal/rspec-puppet-augeas).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不建议使用 Augeas，但实际上可以在 RSpec 中测试 Augeas。详细信息请参阅：[https://github.com/domcleal/rspec-puppet-augeas](https://github.com/domcleal/rspec-puppet-augeas)。
- en: Although it’s beyond the scope of this book, when using custom functions and
    types, it is necessary to perform stubs and mocks, which can be done via `rspec-mocks`,
    as documented at [https://github.com/puppetlabs/puppetlabs_spec_helper#mock_with](https://github.com/puppetlabs/puppetlabs_spec_helper#mock_with).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这超出了本书的范围，但在使用自定义函数和类型时，必须执行存根和模拟，这可以通过 `rspec-mocks` 完成，相关文档可见：[https://github.com/puppetlabs/puppetlabs_spec_helper#mock_with](https://github.com/puppetlabs/puppetlabs_spec_helper#mock_with)。
- en: It was mentioned at the start of the *Testing with RSpec using the PDK* section
    that for large manifests, having to type out all the RSpec for resources can be
    painful. However, several tools can do this for you. These include [https://github.com/logicminds/puppet-retrospec](https://github.com/logicminds/puppet-retrospec),
    [https://github.com/enterprisemodules/puppet-catalog_rspec](https://github.com/enterprisemodules/puppet-catalog_rspec),
    and [https://github.com/alexharv074/create_specs.git](https://github.com/alexharv074/create_specs.git);
    all of these can be used to generate RSpec from code or catalogs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用 PDK 进行 RSpec 测试*部分的开头提到，对于大型清单，必须为资源编写所有 RSpec 代码可能会很痛苦。然而，有几个工具可以为你完成这项工作。这些工具包括
    [https://github.com/logicminds/puppet-retrospec](https://github.com/logicminds/puppet-retrospec)、[https://github.com/enterprisemodules/puppet-catalog_rspec](https://github.com/enterprisemodules/puppet-catalog_rspec)
    和 [https://github.com/alexharv074/create_specs.git](https://github.com/alexharv074/create_specs.git)；这些工具都可以从代码或清单生成
    RSpec。
- en: As with almost everything, it is possible to do all these tasks in YAML instead
    by using the `rspec-puppet-yaml` gem at [https://rubydoc.info/gems/rspec-puppet-yaml](https://rubydoc.info/gems/rspec-puppet-yaml).
    However, we would strongly advise against this.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有任务也可以通过使用 `rspec-puppet-yaml` gem 在 YAML 中完成，相关文档可见：[https://rubydoc.info/gems/rspec-puppet-yaml](https://rubydoc.info/gems/rspec-puppet-yaml)。然而，我们强烈不推荐这样做。
- en: For further research on RSpec, it can be useful to review the core RSpec documentation
    at [https://rspec.info/documentation/](https://rspec.info/documentation/).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于进一步的 RSpec 研究，查看核心 RSpec 文档可能会很有帮助，网址是：[https://rspec.info/documentation/](https://rspec.info/documentation/)。
- en: Serverspec
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Serverspec
- en: Serverspec is an RSpec implementation that’s designed to test at the server
    level once configuration management has been deployed. It is a tool that’s independent
    of Puppet and doesn’t integrate with PDK; it is typically added to a pipelining
    tool to run and requires you to remotely connect from a server to a test target.
    Many of the same principles and ideas that we saw in the RSpec apply. The documentation
    and a tutorial for this can be found at [https://serverspec.org/](https://serverspec.org/).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Serverspec 是一个 RSpec 实现，用于在配置管理部署完成后进行服务器级别的测试。它是一个独立于 Puppet 的工具，且不与 PDK 集成；通常，它会被添加到流水线工具中运行，并需要你从服务器远程连接到测试目标。许多我们在
    RSpec 中看到的相同原理和理念仍然适用。相关的文档和教程可以在 [https://serverspec.org/](https://serverspec.org/)
    找到。
- en: Having learned all about how to create and test modules in this chapter, we
    can now look at how to use Puppet Forge to source pre-written modules.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章了解了如何创建和测试模块后，我们现在可以看看如何使用 Puppet Forge 获取预编写的模块。
- en: Understanding Puppet Forge
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Puppet Forge
- en: Puppet Forge provides a rich resource of modules from Puppet, the Puppet community,
    and third-party vendors to reduce the amount of code your organization must write
    and maintain. It also allows you to contribute to projects or publish modules,
    allowing others to contribute to your projects.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Forge 提供了一个丰富的资源库，包括 Puppet、Puppet 社区和第三方供应商提供的模块，旨在减少你组织必须编写和维护的代码量。它还允许你为项目做出贡献或发布模块，进而让他人也能为你的项目做贡献。
- en: It is important to understand the different types of authors, endorsements,
    and quality scores available in Puppet Forge to understand who is developing the
    modules, what you can expect from them, and how to make choices regarding the
    7,000+ modules.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Puppet Forge 中不同类型的作者、认可和质量评分非常重要，这有助于你了解是谁在开发模块、可以期待什么样的模块，以及如何在 7000 多个模块中做出选择。
- en: Anyone can register and publish modules. However, the Puppet company itself
    publishes under the `puppetlabs` username, while the `puppet` username. This confusion
    originates from Puppet originally being called Puppet Labs. This should not detract
    from the fact the Vox Pupli community develops to very high standards and works
    closely with Puppet, with both organizations contributing to one another. Full
    details about the Vox Pupuli community can be viewed at [https://voxpupuli.org/](https://voxpupuli.org/),
    including how to contribute and be involved.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 任何人都可以注册并发布模块。然而，Puppet 公司本身是通过 `puppetlabs` 用户名发布的，而 `puppet` 用户名则是由 Vox Pupuli
    社区发布的。这种混淆源于 Puppet 最初被称为 Puppet Labs。尽管如此，这并不影响 Vox Pupuli 社区在 Puppet 的高标准开发以及与
    Puppet 的紧密合作，两个组织在相互贡献。有关 Vox Pupuli 社区的详细信息可以访问 [https://voxpupuli.org/](https://voxpupuli.org/)，包括如何贡献和参与其中。
- en: 'There are several other key consultancy contributors, such as `example42`,
    `enterprisemodules`, `camptocamp`, and `betadots`, who contribute modules and
    offer services. There are vendor organizations, such as `foreman`, `datadog`,
    `SIMP`, `cyberark`, and `Elastic`, that provide modules related to their products.
    Finally, individual contributors such as `saz` and `ghoneycut` have contributed
    several quality modules. Puppet has a Champions program, highlighting known contributors
    to Puppet, which can assist in understanding the reliability of module authors:
    [https://puppet-champions.github.io/profiles.html](https://puppet-champions.github.io/profiles.html).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他重要的咨询贡献者，比如 `example42`、`enterprisemodules`、`camptocamp` 和 `betadots`，他们贡献了模块并提供服务。还有一些供应商组织，如
    `foreman`、`datadog`、`SIMP`、`cyberark` 和 `Elastic`，它们提供与自己产品相关的模块。最后，像 `saz` 和
    `ghoneycut` 这样的个人贡献者也贡献了多个高质量的模块。Puppet 有一个 Champions 计划，专门突出介绍 Puppet 知名贡献者，这有助于了解模块作者的可靠性：[https://puppet-champions.github.io/profiles.html](https://puppet-champions.github.io/profiles.html)。
- en: Note
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The process of releasing modules to Puppet Forge is beyond the scope of this
    book, but it can be reviewed at [https://puppet.com/docs/puppet/latest/modules_publishing.html](https://puppet.com/docs/puppet/latest/modules_publishing.html)
    and used along with the `pdk build` and `pdk release` commands, as discussed in
    the *Writing and testing a module using the* *PDK* section.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块发布到 Puppet Forge 的过程超出了本书的范围，但可以通过访问 [https://puppet.com/docs/puppet/latest/modules_publishing.html](https://puppet.com/docs/puppet/latest/modules_publishing.html)
    进行查看，并配合 `pdk build` 和 `pdk release` 命令使用，如在 *使用 PDK 编写和测试模块* 部分中所讨论。
- en: 'In terms of understanding how to filter for modules to use while looking at
    the screen shown in *Figure 8**.4*, which allows us to search for all the modules
    that are available in Puppet Forge, we have various options:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解如何在查看如*图 8.4*所示的屏幕时筛选使用模块时，我们有多种选择，该屏幕允许我们搜索 Puppet Forge 中所有可用的模块：
- en: '![Figure 8.4 – Puppet Forge search screen](img/B18492_08_04.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – Puppet Forge 搜索屏幕](img/B18492_08_04.jpg)'
- en: Figure 8.4 – Puppet Forge search screen
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – Puppet Forge 搜索屏幕
- en: The most immediate valuable filter is `metadata.json` file for OS and Puppet
    version compatibility. The release date, latest release, and number of downloads
    can be key measures to show if this is a commonly used module and if it is being
    kept up to date.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的有用过滤器是`metadata.json`文件，用于操作系统和 Puppet 版本兼容性。发布日期、最新版本和下载次数是衡量模块是否常用以及是否保持更新的关键指标。
- en: 'Puppet implements an endorsement scheme that’s managed by the **Content and
    Tooling Team** (**CAT**) with three different types: Partner, Approved, and Supported.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 实施了一种认可方案，由**内容与工具团队**（**CAT**）管理，分为三种类型：合作伙伴、批准和支持。
- en: Approved modules pass specific criteria documented at [https://forge.puppet.com/about/approved/criteria](https://forge.puppet.com/about/approved/criteria),
    which ensure the modules meet usability and quality standards. This can help you
    when you’re trying to choose a reliable module or allow your team to aim for a
    standard and submit your modules via [https://github.com/puppetlabs/puppet-approved-modules](https://github.com/puppetlabs/puppet-approved-modules).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 批准的模块通过了[https://forge.puppet.com/about/approved/criteria](https://forge.puppet.com/about/approved/criteria)中记录的具体标准，这些标准确保模块符合可用性和质量标准。这可以帮助你在选择可靠模块时，或让你的团队以标准为目标，并通过[https://github.com/puppetlabs/puppet-approved-modules](https://github.com/puppetlabs/puppet-approved-modules)提交模块。
- en: Supported modules follow the same standards as approved modules but are fully
    supported by Puppet or a Puppet-approved third-party vendor, allowing Puppet Enterprise
    customers to raise support cases if issues are experienced. Note that only the
    latest version of the module is supported, and Puppet Enterprise OS versions have
    limited windows of support beyond end-of-life dates. The full details can be viewed
    at [https://forge.puppet.com/about/supported](https://forge.puppet.com/about/supported).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的模块遵循与批准模块相同的标准，但由 Puppet 或 Puppet 批准的第三方供应商完全支持，允许 Puppet Enterprise 客户在遇到问题时提交支持案例。请注意，只有模块的最新版本才会得到支持，且
    Puppet Enterprise 操作系统版本在生命周期结束后的支持窗口有限。详细信息可以在[https://forge.puppet.com/about/supported](https://forge.puppet.com/about/supported)查看。
- en: The third type of partner is when support and testing are provided but not by
    Puppet. For this support to be valid, a separate partner licensing scheme might
    be required.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种合作伙伴类型是由非 Puppet 提供支持和测试。但为了使此支持有效，可能需要单独的合作伙伴许可方案。
- en: As well as this endorsement approach, a score is put on each Puppet module.
    Since the mechanism for scoring was last updated, the details haven’t been published
    in full and a breakdown of the scoring is not visible, but the module quality
    score is based on code style checks, compatibility tests, and metadata validation.
    This score gives you an idea of the module’s overall adherence to Puppet code
    standards upon running `anubis-docker` to evaluate [https://github.com/puppetlabs/anubis-docker](https://github.com/puppetlabs/anubis-docker).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种认可方法，每个 Puppet 模块都会有一个评分。自从评分机制最后一次更新以来，详细信息尚未完全公开，评分的细分也不可见，但模块质量评分基于代码风格检查、兼容性测试和元数据验证。这个评分可以帮助你了解模块在运行`anubis-docker`评估时是否符合
    Puppet 代码标准。[https://github.com/puppetlabs/anubis-docker](https://github.com/puppetlabs/anubis-docker)
- en: Malware scanning was introduced in 2021 using VirtusTotal. A visible pass or
    failure of the module is visible on the `puppetlabs` user modules, but this will
    be extended to Approved, Partner, and all future module releases at a later date.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件扫描于 2021 年引入，使用 VirtusTotal。`puppetlabs`用户模块上可以看到模块的通过或失败情况，但这将在稍后的日期扩展到已批准、合作伙伴以及所有未来模块版本。
- en: Modules can be deprecated as new implementations come out or simply because
    the use case is no longer valid and won’t be supported. These modules will be
    hidden by default but can be made visible by selecting the **show** **deprecated**
    option.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新实现的推出，或者因为用例不再有效而不再得到支持，模块可能会被弃用。这些模块默认会被隐藏，但可以通过选择**显示****已弃用**选项使其可见。
- en: Premium modules were recently added with the release of the Puppet Comply product
    but they currently only apply to `cem_windows` and `cem_linux` modules, which
    can only be used upon purchasing Puppet Comply.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最近发布的Puppet Comply产品新增了高级模块，但它们目前仅适用于`cem_windows`和`cem_linux`模块，这些模块只有在购买Puppet
    Comply后才能使用。
- en: 'One area that had previously been neglected in Puppet due to its historic development
    focus on Linux is the Windows platform. Puppet Forge has a collection page ([https://forge.puppet.com/collections/windows](https://forge.puppet.com/collections/windows))
    that highlights modules designed for Windows, such as the Chocolatey package provider:
    [https://forge.puppet.com/modules/puppetlabs/chocolatey](https://forge.puppet.com/modules/puppetlabs/chocolatey).
    Another major development has been the auto-generation of PowerShell `xInternetExplorerHomePage`
    for setting the home page for Internet Explorer and modules such as `xActiveDirectory`,
    which is used to deploy and configure Active Directory. `xInternetExplorerHomePage`
    is simple and has a single resource type called `dsc_xinternetexplorerhomepage`
    that can be used to set the default home page, like so:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于历史发展重点在Linux平台，Puppet在Windows平台上的支持曾一度被忽视。Puppet Forge提供了一个集合页面（[https://forge.puppet.com/collections/windows](https://forge.puppet.com/collections/windows)），该页面展示了为Windows设计的模块，例如Chocolatey包提供程序：[https://forge.puppet.com/modules/puppetlabs/chocolatey](https://forge.puppet.com/modules/puppetlabs/chocolatey)。另一个重要的发展是自动生成PowerShell
    `xInternetExplorerHomePage`，用于设置Internet Explorer的首页，以及如`xActiveDirectory`等模块，用于部署和配置Active
    Directory。`xInternetExplorerHomePage`非常简单，只有一个名为`dsc_xinternetexplorerhomepage`的资源类型，可以用来设置默认首页，如下所示：
- en: '[PRE41]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`xActiveDirectory` has various resource types to configure and deploy different
    aspects of Active Directory.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`xActiveDirectory`具有多种资源类型，用于配置和部署Active Directory的不同方面。'
- en: This has limitations since it is a fully automatic conversion and Puppet has
    no ownership of the DSC code. This makes testing limited and dependent on the
    quality of the code and documentation provided by the DSC code owner. You may
    also find some modules are deprecated in the PowerShell Gallery, so it is worth
    checking this. Also, note that due to a bug in `minitar`, only the Puppet Enterprise
    code manager can correctly unpack these modules from Puppet Forge directly. For
    open source users, refer to the module documentation instructions, which explain
    how to download the module from a web link to Puppet Forge and unpack the archive
    manually, ensuring that the module is installed and the DSC code is unpacked fully.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是完全自动化的转换，而且Puppet并不拥有DSC代码，因此存在一定限制。这使得测试受到限制，并且依赖于DSC代码所有者提供的代码和文档质量。你还可能会发现一些模块在PowerShell
    Gallery中已被弃用，因此值得检查。此外，由于`minitar`中的一个bug，只有Puppet Enterprise代码管理器才能正确地从Puppet
    Forge直接解压这些模块。对于开源用户，请参阅模块文档说明，了解如何从Puppet Forge的Web链接下载模块并手动解压归档文件，确保模块已安装并且DSC代码完全解压。
- en: 'There are some further blogs and tools to be aware of, which are beyond the
    scope of this book but would be worth investigating for further information. To
    keep up to date with Puppet Forge and Puppet-managed modules, the CAT team runs
    a blog [https://puppetlabs.github.io/content-and-tooling-team/](https://puppetlabs.github.io/content-and-tooling-team/).
    Puppet Forge also has an API, available at [https://forgeapi.puppet.com/](https://forgeapi.puppet.com/),
    that allows more programmatic queries to be run, and the `denmark` module, developed
    by Ben Ford, provides additional scans and checks to assist with reviewing modules:
    [https://github.com/binford2k/denmark](https://github.com/binford2k/denmark).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些进一步的博客和工具需要关注，虽然它们超出了本书的范围，但值得调查以获取更多信息。为了跟上Puppet Forge和Puppet管理模块的最新动态，CAT团队运行了一个博客：[https://puppetlabs.github.io/content-and-tooling-team/](https://puppetlabs.github.io/content-and-tooling-team/)。Puppet
    Forge还提供了一个API，地址为[https://forgeapi.puppet.com/](https://forgeapi.puppet.com/)，可以执行更多的编程查询，而Ben
    Ford开发的`denmark`模块提供了额外的扫描和检查，帮助审查模块：[https://github.com/binford2k/denmark](https://github.com/binford2k/denmark)。
- en: Lab – creating a module and testing it
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验—创建并测试一个模块
- en: 'In this lab, you will use the knowledge you’ve gained about module structure,
    the PDK, and testing to create and test a Grafana module. Then, using what you
    learned about Puppet Forge, you will explore the Forge site to choose modules:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，你将运用你所学到的关于模块结构、PDK和测试的知识，创建并测试一个Grafana模块。然后，利用你对Puppet Forge的了解，你将探索Forge网站并选择模块：
- en: Using either the code you wrote for [*Chapter 4*](B18492_04.xhtml#_idTextAnchor078)for
    the combined Grafana, Windows, and Linux class or the example answer at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp),
    create a new module called `packt_grafana`, with this Puppet code broken up into
    appropriate classes following the `init`, `service`, `config`, and `install` pattern
    (for this number of resources, a single class in the real world would be more
    appropriate, but this is just for practice). I recommend creating classes with
    `pdk new class`. Follow [https://puppet.com/docs/puppet/latest/puppet_strings_style.html](https://puppet.com/docs/puppet/latest/puppet_strings_style.html)
    to ensure classes are fully documented and pass tests.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用你为 [*第4章*](B18492_04.xhtml#_idTextAnchor078) 编写的结合了 Grafana、Windows 和 Linux
    的类代码，或者参考 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp)
    的示例答案，创建一个名为 `packt_grafana` 的新模块，并按照 `init`、`service`、`config` 和 `install` 模式将
    Puppet 代码拆分为适当的类（在实际应用中，对于这么多资源，单个类更为合适，但此处仅为练习）。建议使用 `pdk new class` 创建类。请遵循
    [https://puppet.com/docs/puppet/latest/puppet_strings_style.html](https://puppet.com/docs/puppet/latest/puppet_strings_style.html)，确保类的完整文档，并通过测试。
- en: Expand the default tests provided by the PDK and design the contexts to be covered
    while considering the parameters that could be passed and the OS choices available.
    Use the [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/.sync.yml](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/.sync.yml)
    file in the module, which will include the gem file for `puppet-catalog_rspec`,
    and run `pdk update`. To generate some of the RSpec resources automatically, you
    can add `it` `{` `dump_catalog` `}` to each class spec file (you will need to
    define some parameters for this to work) and remove the line once you have got
    the output. Add a coverage test at 100% and ensure your tests achieve this.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 PDK 提供的默认测试，并在考虑可能传递的参数和可用的操作系统选择时设计要覆盖的上下文。使用模块中的 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/.sync.yml](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/.sync.yml)
    文件，该文件将包含 `puppet-catalog_rspec` 的 gem 文件，并运行 `pdk update`。为了自动生成一些 RSpec 资源，你可以在每个类的规格文件中添加
    `it` `{` `dump_catalog` `}`（你需要为此定义一些参数），并在获得输出后删除该行。添加 100% 覆盖率的测试，并确保测试能够达到该目标。
- en: 'Using `pdk validate` and `pdk test unit`, correct the errors that can be found
    in the module, as shown here: [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/mistakemodule](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/mistakemodule).'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pdk validate` 和 `pdk test unit`，修正模块中可以找到的错误，示例见此处：[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/mistakemodule](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/mistakemodule)。
- en: 'Go to Puppet Forge and decide which module you wish to use for the following
    tasks:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Puppet Forge 并决定你希望为以下任务使用哪个模块：
- en: Configuring SSH on Ubuntu
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ubuntu 上配置 SSH
- en: Installing and configuring IIS
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和配置 IIS
- en: 'Configuring the time zone using DSC on a Windows machine (hint: It’s not `xtimezone`;
    refer to [https://www.powershellgallery.com/](https://www.powershellgallery.com/))'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Windows 机器上使用 DSC 配置时区（提示：不是 `xtimezone`；参考 [https://www.powershellgallery.com/](https://www.powershellgallery.com/)）
- en: Install and configure Logstash
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并配置 Logstash
- en: See suggested answers at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/module_choice.txt](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/module_choice.txt)
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 查看建议答案，链接地址为 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/module_choice.txt](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/module_choice.txt)
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how modules allow you to group code and data, making
    it easier to share and reuse code. We discussed that modules should focus on a
    clear single-use responsibility. We examined the directory structure of a module
    and highlighted where specific Puppet code and data were stored. A good starter
    manifest structure was shown, highlighting the main manifest (`init.pp`) that’s
    used as an entry point, with parameters acting like public APIs to allow the module
    to be flexible and include the other classes required. We also saw that the `install.pp`,
    `config.pp`, and `service.pp` classes focused on installation, configuration,
    and services, respectively. In the case that the application becomes more complex
    than this, we discussed how a module can use classes and directories for different
    components.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了模块如何帮助您将代码和数据进行分组，从而更容易共享和重用代码。我们讨论了模块应该专注于清晰的单一用途责任。我们检查了模块的目录结构，并重点介绍了存储特定
    Puppet 代码和数据的位置。展示了一个好的入门清单结构，重点介绍了用作入口点的主清单（`init.pp`），并通过参数像公共 API 一样使模块灵活，能够包含其他所需的类。我们还看到了
    `install.pp`、`config.pp` 和 `service.pp` 类，分别聚焦于安装、配置和服务。在应用程序变得比这更复杂的情况下，我们讨论了模块如何使用类和目录来处理不同的组件。
- en: Next, we looked at the PDK as a way to automate how modules are created and
    group common tooling to help us manage and test Puppet modules. We created a Ruby
    environment and installed the communities’ most used development tools with configuration
    files in the module directory. The default template for producing modules was
    examined, as well as how to customize this by forking on `sync.yaml`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们了解了 PDK 如何作为一种自动化模块创建的工具，并将常用的工具集成在一起，帮助我们管理和测试 Puppet 模块。我们创建了一个 Ruby
    环境，并在模块目录中安装了社区最常用的开发工具和配置文件。我们审查了生成模块的默认模板，以及如何通过在 `sync.yaml` 上进行分支来定制它。
- en: After, we looked at the life cycle of development when using various PDK commands
    to create or convert a module, as well as adding different Puppet types such as
    classes or defined types, which create unit tests. We looked at the `pdk validate`
    command as a way to perform linting and syntax validation, as well as to autocorrect
    where possible with the `-a` flag. The templates created basic RSpec tests to
    check the compilation of catalogs. The PDK `build` and `release` commands were
    also mentioned as ways to bundle the PDK for Puppet Forge or to bundle and upload
    it as one command – `release`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们了解了在使用各种 PDK 命令创建或转换模块时，开发生命周期的过程，以及添加不同的 Puppet 类型，如类或定义类型，这些都用于创建单元测试。我们还查看了
    `pdk validate` 命令，它用于执行代码检查和语法验证，并通过 `-a` 标志在可能的情况下进行自动修正。模板创建了基本的 RSpec 测试，用于检查目录的编译。PDK
    的 `build` 和 `release` 命令也被提及，作为将 PDK 打包到 Puppet Forge 中或将其作为一个命令打包并上传的方法——`release`。
- en: Next, you learned how to expand RSpec using `describe` and `context` to structure
    the test cases and expectations and matchers for defining individual tests. You
    learned that preconditions can be set via `let` statements, allowing dependencies
    for the class to be created in the test. You also learned how relationships can
    be defined by chaining the relevant function. You saw how `let` statements can
    be used to define facts, node data, trusted facts, and trusted external facts
    in data and that by using the `default_module_facts.yaml` and `spec_helper_local`
    files, defaults can be set for the module. After this, we covered Hiera, detailing
    how the configuration file can be set in a spec or via `spec_helper` and how lookups
    can be performed. For external dependencies, the `fixtures.yml` file was shown
    to be able to bring in module dependencies from Puppet Forge or local repositories
    to allow for catalog compilation. Coverage reporting was then added to the local
    spec helper, allowing unit tests to show what resources were not covered by tests
    and to put a pass percentage on the test. Then, we looked at some further RSpec
    tooling and sources, which allow you to generate RSpec code and some checks that
    are beyond the scope of this book. ServerSpec was then highlighted as a server-level
    testing framework that uses RSpec. It’s independent of Puppet and beyond the scope
    of this book, but it’s worth investing in and, ideally, adding to a pipeline.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你学习了如何使用 `describe` 和 `context` 扩展 RSpec，以构建测试用例和期望，并使用匹配器来定义单个测试。你了解到，可以通过
    `let` 语句设置前置条件，从而在测试中创建类的依赖关系。你还学习了如何通过链式调用定义关系。你看到，`let` 语句可以用于在数据中定义事实、节点数据、受信任的事实和受信任的外部事实，并且通过使用
    `default_module_facts.yaml` 和 `spec_helper_local` 文件，可以为模块设置默认值。随后，我们讨论了 Hiera，详细介绍了如何在
    spec 或通过 `spec_helper` 设置配置文件，以及如何执行查找操作。对于外部依赖，展示了 `fixtures.yml` 文件，能够从 Puppet
    Forge 或本地仓库引入模块依赖，以支持目录编译。然后，将覆盖率报告添加到本地 spec helper，使单元测试能够显示哪些资源未被测试覆盖，并在测试中显示通过百分比。接着，我们了解了一些进一步的
    RSpec 工具和资源，这些工具允许你生成 RSpec 代码，并进行一些超出本书范围的检查。然后，重点介绍了 ServerSpec，它是一个基于 RSpec
    的服务器级测试框架。它独立于 Puppet，超出了本书的范围，但值得投资，理想情况下应该加入到流水线中。
- en: Having shown you how to develop and structure your modules, you learned how
    to source modules from Puppet Forge, understand the different types of module
    support and endorsement available from Puppet, how scoring and scanning took place
    on modules, and ways to understand who contributors were and their place in the
    Puppet community. The Windows collection of modules was mentioned, as well as
    the PowerShell DSC collection, which provides automated wraparounds for modules
    in the PowerShell Gallery, allowing the content to be downloaded and used within
    Puppet code. The CAT team was mentioned as maintainers of Puppet Forge that support
    content with their blog publishing updates. The Denmark module was then highlighted
    as an additional way to score modules.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在向你展示如何开发和构建模块之后，你学习了如何从 Puppet Forge 获取模块，了解了 Puppet 提供的不同类型的模块支持和背书，如何对模块进行评分和扫描，以及如何了解贡献者及其在
    Puppet 社区中的地位。提到了 Windows 模块集合，以及 PowerShell DSC 集合，它为 PowerShell Gallery 中的模块提供了自动封装，使内容可以在
    Puppet 代码中下载和使用。还提到 CAT 团队作为 Puppet Forge 的维护者，通过博客发布更新来支持内容。接着，介绍了丹麦模块，作为一种额外的模块评分方式。
- en: In the next chapter, you will learn how Puppet handles data and be introduced
    to Hiera and explore how it layers data into different scopes. We will discuss
    when best to use Puppet code, variables, and Hiera to store data and how to structure
    and feed this data to module parameters. We will also cover the correct ways to
    store data security at rest and in transport, as well as some common issues with
    using data in Puppet and how to approach them.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习 Puppet 如何处理数据，并了解 Hiera，探讨它如何将数据分层到不同的作用域。我们将讨论何时最好使用 Puppet 代码、变量和
    Hiera 来存储数据，以及如何构建和将数据传递给模块参数。我们还将涵盖如何正确存储数据的安全性，无论是在静止状态还是传输过程中，以及使用 Puppet 数据时的一些常见问题和如何应对它们。
