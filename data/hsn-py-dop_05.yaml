- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Manipulating Resources
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作资源
- en: And into this Ring he poured his cruelty, his malice, and his will to dominate
    all life. One Ring to rule them all.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这枚戒指中，他倾注了自己的残忍、恶意和支配一切生命的意志。一枚戒指，统治所有人。
- en: – Galadriel (Lord of the Rings)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: – 加拉德瑞尔（《魔戒》）
- en: In the previous chapter, we talked about creating resources. We talked about
    using automation to provision the correct specifications of resources every single
    time. But what about pre-existing resources?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何创建资源。我们讨论了使用自动化每次都能正确配置资源的规格。那么，对于已有资源怎么办呢？
- en: In some real-world scenarios, you may be expected to work with projects or workloads
    that you haven’t created from scratch, or that need to be touched with a very
    fine hand. You may also be working with resources that you have a lot less power
    over, such as managed resources in your cloud that are managed by your cloud provider.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些实际场景中，你可能需要处理一些你没有从零开始创建的项目或工作负载，或者需要非常小心地调整它们。你也可能会与一些你控制权较小的资源打交道，比如在云中由云服务商管理的托管资源。
- en: It’s easy to manipulate the resources that you have made, but these legacy resources
    and resources that have fewer controls are the challenge for **DevOps** engineers.
    Conquering these challenges requires learning how to manipulate resources to make
    them more inclined to the DevOps philosophy. Whether that involves a change in
    approach in the resources, the code, the architecting process, or just understanding
    the workload better, we can use the philosophy of DevOps to make resources better
    provisioned and better performing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 操作自己创建的资源很容易，但这些遗留资源和控制较少的资源是**DevOps**工程师的挑战。征服这些挑战需要学习如何操作资源，使其更符合DevOps理念。这可能涉及资源、代码、架构过程的改变，或者只是更好地理解工作负载，我们可以运用DevOps理念，使资源得到更好的配置和更好的性能。
- en: Speaking of performance, one of the best indicators of how future performance
    should look is past performance. If the usage of resources can give us a pattern,
    we can use this pattern to predict the provisioning of resources better and streamline
    our workload. Besides that, any insight that we gain regarding not just usage
    patterns but how the DevOps team and the application team handle the resources
    and react to events is useful for future reference.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 说到性能，未来性能的最佳指标之一就是过去的性能。如果资源的使用情况能为我们提供一个模式，我们就可以利用这个模式来更好地预测资源的配置，并简化我们的工作负载。此外，任何关于使用模式的洞察，尤其是DevOps团队和应用团队如何处理资源并响应事件的方式，都是未来参考的有用信息。
- en: Being predictive in the approaches that you take can be very useful, but these
    predictions must always be made on the back of solid data. If we are to predict
    and adapt, it must be done according to some sort of logic. This logic must be
    understood (there are people in this world who do things just because they’re
    told how to do it one way; they’re useful but they cannot adapt) fully to allow
    for effective action to be taken.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 采取预测性的方法非常有用，但这些预测必须建立在坚实的数据基础上。如果我们要进行预测和适应，必须根据某种逻辑来进行。这种逻辑必须被理解（这个世界上有些人做事只是因为别人告诉他们应该这么做，他们有用，但不能适应变化）才能采取有效的行动。
- en: The primary goal of this chapter is to help you learn how to look at the resources
    you have and to use them to maximum effect. This means understanding how the resources
    scale up and down, as well as the history and historical components of those resources.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是帮助你学习如何查看已有资源，并充分利用它们。这意味着了解资源如何扩展和缩减，以及这些资源的历史和历史组成部分。
- en: 'With that, in this chapter, we will cover the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Modifying resources to adjust to demand using Python as a trigger for events
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python作为事件触发器来调整资源以适应需求
- en: Analyzing live and historical data and using it for future workloads
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析实时和历史数据，并将其应用于未来的工作负载
- en: Refactoring a legacy application slowly over time
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐步重构一个遗留应用
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete this chapter, you will require the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章，你将需要以下内容：
- en: A GitHub account
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个GitHub账户
- en: Python
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python
- en: An AWS account
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个AWS账户
- en: Event-based resource adjustment
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于事件的资源调整
- en: Resources are money. Literally. In the world of DevOps, the norm is that the
    more resources you use, the more money that you spend. That’s simple enough, right?
    But the problem comes when the return from those resources is not enough to cover
    their costs. One of the main reasons this happens is because the resources that
    are consumed are done so at a constant rate, even if they are not required. For
    optimal resource consumption, a new method was created one with which resources
    are only consumed at the time of their use and are then downsized appropriately
    until their next use. Let’s say that you are on a shopping spree. You don’t know
    exactly how much you’re going to spend, you have only a vague idea of how much
    you are going to spend on the items. You are probably going to go over the tentative
    budget that you have set for yourself and in addition to that, you might not even
    be happy with everything that you bought.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 资源就是金钱。字面意思。在 DevOps 的世界里，常规做法是，你使用的资源越多，花费的金钱也就越多。这一点很简单，对吧？但是问题在于，当这些资源的回报不足以覆盖其成本时，问题就出现了。这种情况发生的主要原因之一是，资源的消耗是按照固定的速率进行的，即使它们并不需要。为了实现最优的资源消耗，出现了一种新方法：资源只有在实际使用时才会消耗，之后会根据需要适当缩减，直到下次使用。假设你正在进行购物狂欢。你并不清楚自己究竟会花多少钱，只是大致知道会在物品上花费多少。你很可能会超出自己预设的预算，除此之外，你可能还不一定对自己买的每一件商品感到满意。
- en: DevOps is a lot like that – it is about the groceries (resources), how much
    you spend on them, and how much value you can get out of them. One of the most
    common ways to keep track of a grocery/expenses budget is to make a nice spreadsheet
    where you can tally up everything. Here, again, there are similarities to DevOps,
    though in DevOps, you are usually given an exact quote by your resource provider
    and it’s easier to find better deals than with groceries – trust me.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 很像这种情况——它涉及到商品（资源）、你在这些商品上花费多少以及你能从中获得多少价值。保持购物/开销预算的一种常见方式是做一个漂亮的电子表格，记录下每一项支出。在这里，DevOps
    也有相似之处，尽管在 DevOps 中，通常你会得到资源提供商提供的确切报价，并且你能比买菜更容易找到更好的交易——相信我。
- en: Now, for the final part of the grocery section, you adjust the groceries you
    buy according to the events that you have, right? If your friend’s vegan, you
    cook vegan stuff. If they have diabetes, sugar is off the menu. If you’re by yourself,
    you can buy a tub of ice cream with no judgment. That’s exactly what we want with
    our event-based adjustments. You can use the type of event that is being brought
    to you to adjust the resources being provided. You can look at the events that
    are going on and adapt your resources accordingly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，购物部分的最后一步是根据你所遇到的情况调整你购买的商品，对吧？如果你的朋友是素食主义者，你就做素食。如果他们得了糖尿病，菜单上就不再有糖分。如果你自己一个人，你可以买一桶冰淇淋，没有人会评判你。这正是我们希望在基于事件的调整中实现的目标。你可以根据接收到的事件类型来调整所提供的资源。你可以观察当前的事件，并相应地调整你的资源。
- en: We are going to show this concept while considering a couple of examples – one
    that deals with the global distribution of localized content and another that
    deals with testing a new feature for a website on a small subset of users.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过几个例子来展示这个概念——一个涉及到本地化内容的全球分发，另一个涉及到对网站的新功能进行小范围用户测试。
- en: Edge location-based resource sharing
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于边缘位置的资源共享
- en: One of the most difficult challenges that we have with a global application
    is load time for resources. If a user is too far from the closest data center,
    it can result in a significant amount of lag and latency when they use their application.
    For this reason, most companies with applications on a major scale have data centers
    and edge caches in high-population areas/areas with high web traffic. An **edge**
    or **edge location** is just a data center that is closer to the target user,
    making their load time faster. **Edge caches** are user and website data (such
    as cookies) stored in edge locations for faster access for that user. This helps
    users get to data centers that can serve them the fastest.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在全球应用中面临的最困难的挑战之一就是资源的加载时间。如果用户距离最近的数据中心太远，可能会导致他们使用应用时出现显著的延迟和卡顿。因此，大多数有大规模应用的公司都会在人口密集区域/网络流量高的区域设置数据中心和边缘缓存。**边缘**或**边缘位置**只是一个离目标用户更近的数据中心，使得他们的加载时间更快。**边缘缓存**是存储在边缘位置的用户和网站数据（如
    cookie），用于加速该用户的访问。这有助于用户快速访问能够提供最快响应的数据中心。
- en: However, the question now becomes, how do we direct these users to the appropriate
    data centers or caches that will give them the lowest latency? To do that, we
    must find a way to acquire the location data for the user’s device and reference
    that data to redirect that user to the closest data center.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在的问题是，我们如何将这些用户引导到能够为他们提供最低延迟的适当数据中心或缓存？为了做到这一点，我们必须找到一种获取用户设备位置数据并将该数据用于重定向用户到最近数据中心的方法。
- en: 'To do this, we can write a function that takes a web traffic request and extracts
    certain headers from it. Let’s look at the code for this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以编写一个函数，从网页流量请求中提取特定的头部信息。让我们看看这段代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What this code does is pick out the country header, which you will need to
    define yourself (which is good, because you can customize it), and then direct
    the web request to the appropriate server. A small layer in between the request
    and response can work wonders for connectivity. You can see an illustration of
    this in the subsequent figure:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用是挑选出国家头部，你需要自己定义（这是件好事，因为你可以自定义它），然后将网页请求引导到适当的服务器。请求和响应之间的这个小层能够对连接质量产生奇效。你可以在随后的图中看到这一点：
- en: '![Figure 5.1 – Function to facilitate location mapping for servers](img/B21320_05_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 用于服务器位置映射的功能](img/B21320_05_1.jpg)'
- en: Figure 5.1 – Function to facilitate location mapping for servers
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 用于服务器位置映射的功能
- en: Now that we have learned how to redirect users to custom locations, let’s look
    at how to redirect features toward a custom set of users.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何将用户重定向到自定义位置，让我们看看如何将功能重定向到一组自定义用户。
- en: Testing features on a subset of users
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在一小部分用户上测试功能
- en: When an application needs to implement a new feature and the application team
    wants that feature to be tested in a live environment, the need arises for some
    sort of mechanism that sorts a small subset of users into a group that will receive
    that new feature. The analytical data acquired from this group will then be used
    to judge the feature and its effectiveness based on certain criteria. The reverse
    – removal of a feature – works this way as well. If you recall when YouTube removed
    the numbers from their dislike button, some users still had their numbers for
    weeks because of their cached website versions. Even after that, browser extensions
    came out that extracted the dislike number from the YouTube API itself for whichever
    video you were watching (that is, until YouTube took it out of their API entirely).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个应用程序需要实现新功能，应用程序团队希望在实时环境中测试该功能时，就需要一种机制将一小部分用户分类到将接收该新功能的组中。从这个组中获得的分析数据将用于根据特定标准评估该功能及其效果。反向操作——移除功能——也是这样进行的。如果你还记得
    YouTube 删除他们不喜欢按钮上的数字时发生的情况，一些用户因为他们缓存的网站版本仍然保留了数周。即使如此，浏览器扩展程序也出现了，从 YouTube
    API 中提取正在观看的视频的不喜欢数字（直到 YouTube 完全从他们的 API 中删除这个功能）。
- en: 'Now, you may be wondering why such a test would be necessary given the fact
    that the feature had probably been tested over and over again, even before it
    had been launched. Well, here’s the thing:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想知道，鉴于这个功能可能已经在推出之前经过了一次又一次的测试，为什么还需要进行这样的测试呢？好吧，事实是这样的：
- en: '**It might not have been**: You’ll be surprised how many companies are willing
    to put a new thing out there for a small subset to use without going through user
    acceptance testing. You’ll be even more surprised to learn that this isn’t a bad
    strategy sometimes (but if you are going to do this, I suggest you do it with
    the example I’m going to give you in the upcoming code block).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**也许并不是**: 你会惊讶地发现，有多少公司愿意为一小部分用户推出新事物，而不经过用户验收测试。更令人惊讶的是，有时这并不是一种坏策略（但如果你要这样做，我建议你用我接下来要给你的示例）。'
- en: '**Users break stuff**: It is the nature of users to break stuff in ways that
    testers cannot comprehend. You cannot fully understand human nature and the chaos
    behind it and any invention you make must be tested against it. Having a more
    controlled approach requires throwing your work to a subsample of chaos and hoping
    that it can endure.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户会弄乱事情**: 这是用户的本性，他们会以测试人员无法理解的方式搞砸事情。你无法完全理解人类的本性和其背后的混乱，而你所做的任何发明都必须经过其考验。采用更加受控的方法需要将你的工作扔给一小部分混乱，希望它能够经受住考验。'
- en: This method of testing is commonly referred to as the **A/B** **testing method**.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试方法通常被称为**A/B测试方法**。
- en: Now that that’s out of the way, we can get to the implementation. This implementation
    is very similar to that of the implementation for the edge locations and involves
    a proxy very much in that vein.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 既然这些都解决了，我们就可以开始实施了。这个实现与边缘位置的实现非常相似，并且涉及到一个在这一方面非常相似的代理。
- en: 'We’re going to subset our users in two ways: randomly and based on some criteria.
    First, let’s look at the code for the random distribution of user requests (20%
    to one server and 80% to the other server):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以两种方式对用户进行子集划分：随机划分和基于某些标准划分。首先，让我们看看用于随机分配用户请求的代码（20% 分配到一台服务器，80% 分配到另一台服务器）：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can choose a less arbitrary range if you’d like. Just remember to track
    the statistics between these two responses differently to get the correct insights.
    An alternative to this is **feature flags**, but that requires dividing users
    into subsets based on certain criteria, which is what we are about to cover in
    the following code block. The preceding method is good if you don’t want to distinguish
    between users or can’t and just want activity data:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以选择一个不那么随意的范围。只需记得以不同的方式追踪这两个响应之间的统计数据，以获得正确的洞察。另一种选择是**功能标志**，但这需要根据特定标准将用户划分为子集，这正是我们在接下来的代码块中要讨论的内容。如果你不想区分用户或无法区分，只是想要活动数据，那么前一种方法是不错的选择。
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we can see the users who have feature flags getting the featured response
    (the unique response they get if their feature flag is on). These featured responses
    are different from the regular responses. The activation of the feature flag can
    be a random edit made to the database or an opt-in offer given to the user. Once
    again, the data for these two resources needs to be distinguished for maximum
    effectiveness.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到启用了功能标志的用户获得了特色响应（如果他们的功能标志开启，他们会收到的独特响应）。这些特色响应与常规响应不同。功能标志的激活可以是对数据库的随机编辑，或者是提供给用户的选择加入优惠。再次强调，这两个资源的数据需要区分开来，以确保最大效果。
- en: Speaking of data (and I have been), now that we have all of this analytical
    and operational data from people using the feature flags and those who are not,
    as well as the occurrence of all of these events, we must do something with it
    – we need to analyze it and generate insights.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 说到数据（我一直在说），现在我们拥有了来自使用功能标志的用户和未使用功能标志的用户的所有分析和操作数据，以及所有这些事件的发生，我们必须对这些数据做些事情——我们需要分析它并生成洞察。
- en: Analyzing data
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据分析
- en: I have found that – as an adult – I have increasingly become more and more responsible
    for myself. However, this responsibility and the person that I am right now have
    come from a series of events in my past. Mistakes, successes, and everything in
    between have defined me and my approach to life.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现——作为一个成年人——我越来越变得对自己更有责任感。然而，这种责任以及我现在的这个人，来自我过去的一系列事件。错误、成功和介于其中的一切，塑造了我和我对生活的态度。
- en: 'A lot of my approaches to life also happen to be approaches to DevOps – that’s
    just how that panned out. Through the life (and DevOps) lessons that I have learned,
    I’ve found two things: you must live for the person you are right now, and that
    person is defined by your past and yet is not the same person as in the past.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我的许多生活方法也恰好是我对 DevOps 的方法——这就是事情的演变过程。通过我在生活（和 DevOps）中的经验，我发现了两件事：你必须为现在的自己而活，而这个人是由你的过去定义的，但又不完全是过去的那个人。
- en: Your workload follows a similar pattern. It is based on your history but cannot
    completely be considered the same as it was previously. The code has probably
    changed, the infrastructure is different, and even the personnel that implement
    it most likely have changed. However, with all that being said, there are still
    lessons to be learned from the past. Important lessons.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你的工作负载遵循类似的模式。它基于你的历史，但不能完全被认为是以前的样子。代码可能已经改变，基础设施也不同，甚至实施它的人员很可能已经发生变化。然而，尽管如此，过去的经验中仍有值得学习的教训。重要的教训。
- en: Earlier in this book ([*Chapter 1*](B21320_01.xhtml#_idTextAnchor015)*, Introducing
    DevOps Principles,* to be exact), I emphasized the need for **monitoring** and
    **logging**, and I said that these were great tools for event handling and maintaining
    the historical performance of your workload. Now, we will begin exploring how
    that historical performance can give us insights that we can use to our advantage.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期部分（准确地说是[*第一章*](B21320_01.xhtml#_idTextAnchor015)，《引入 DevOps 原则》），我强调了**监控**和**日志记录**的必要性，并表示这些是处理事件和维护工作负载历史性能的绝佳工具。现在，我们将开始探索如何利用这些历史性能为我们提供可用的洞察。
- en: 'We will look at a couple of analysis techniques: analysis of **live data**
    and analysis of **historical data**. Each presents challenges. Each can act as
    a template to solve a fairly common DevOps problem.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论几种分析技术：**实时数据**分析和**历史数据**分析。每一种都有其挑战。每一种都可以作为解决相当常见的 DevOps 问题的模板。
- en: Analysis of live data
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实时数据分析
- en: Live or streaming data is data that is constantly being processed by a system
    at present. It is data that’s being received or returned by a system. A system
    lives off of the data that it absorbs and generates (*input* -> *process* -> *output*).
    The system is shaped by this data and sometimes, in the case of critical systems,
    it needs to be molded by this data. To make tactical decisions based on recent
    data, collecting live data and immediate insights on that data is necessary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实时或流式数据是系统当前不断处理的数据。它是系统接收或返回的数据。一个系统依赖于它所吸收和生成的数据（*输入* -> *处理* -> *输出*）。系统是由这些数据塑造的，有时，在关键系统中，它需要由这些数据来塑造。要根据最近的数据做出战术决策，收集实时数据并对其进行即时分析是必需的。
- en: Most clouds and monitoring systems come with default ways to store and analyze
    live data. And for the most part, they are quite effective. They can store data
    and generate insights on that data to a certain extent. However, sometimes, a
    custom approach is necessary. And this is where Python excels. Not because of
    speed, but because of convenience and a pre-built library for analysis, Python
    (even with only its default libraries) can perform data analysis and conversion
    on practically any kind of data that a system gives out.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数云服务和监控系统都提供了存储和分析实时数据的默认方式。通常情况下，它们非常有效。它们可以存储数据，并在一定程度上生成数据的洞察。然而，有时需要采用自定义方法，这就是
    Python 的优势所在。不是因为速度，而是因为方便性和预构建的分析库，Python（即使只有其默认库）也可以对系统输出的几乎任何类型的数据进行数据分析和转换。
- en: 'So, let’s look at an example where we use Python’s built-in **marshal library**
    to decode a **byte string**:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们来看一个示例，使用 Python 的内建**marshal 库**解码一个**字节字符串**：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Byte strings are often used in **network communication** and **cryptography**
    (both of which usually involve live data), and converting them into other languages
    may require adding libraries and possibly creating custom data types. There’s
    no such need with Python.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 字节字符串常用于**网络通信**和**密码学**（这两者通常涉及实时数据），将其转换为其他语言可能需要添加库并可能创建自定义数据类型。而使用 Python
    时没有这样的需求。
- en: But this usually accounts for smaller sizes of data and recent data, sometimes
    as recent as the last millisecond. For a truly historic analysis, you need millions
    of rows of data. You also need something that can analyze that data. Here, Python
    excels even more.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 但这通常适用于较小的数据量和最近的数据，有时甚至是最近的毫秒级数据。对于真正的历史分析，你需要数百万行数据。你还需要能够分析这些数据的工具。在这方面，Python
    更加出色。
- en: Analysis of historical data
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 历史数据分析
- en: Live data can help us make adjustments; they are tactical. But to be truly strategic
    – to think about the big picture and to think long term – you need historical
    data and a way to analyze it. The past contains a lot of data; this data contains
    patterns, and it is in these patterns that the key to optimizing your workload
    lies.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实时数据可以帮助我们进行调整；它们是战术性的。但要真正具备战略眼光——考虑全局并着眼长远——你需要历史数据和分析历史数据的方法。过去包含了大量数据；这些数据中蕴含了模式，而这些模式正是优化工作负载的关键所在。
- en: The analysis of historical data requires converting the data into a format where
    it can be mass-read by a program. Once this data has been formatted, it can be
    fed into an algorithm that processes the data into useful information that the
    data engineer may want.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 历史数据分析需要将数据转换为程序可以大规模读取的格式。一旦数据被格式化，它就可以输入到一个算法中，处理成数据工程师可能需要的有用信息。
- en: Dealing with historical data usually means dealing with data that is consistent
    and high in volume. However, one of the potential variables can be whether the
    data is uniform or not. Oftentimes, when the software to record data is changed
    or upgraded, certain aspects of the data change as well. Reconciling the old and
    the new historical data is one of the challenges that DevOps engineers working
    with data can face.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 处理历史数据通常意味着处理一致且数据量大的数据。然而，其中一个潜在的变量是数据是否一致。通常，当记录数据的软件被更换或升级时，数据的某些方面也会发生变化。调和旧的和新的历史数据是
    DevOps 工程师在处理数据时可能面临的挑战之一。
- en: The next challenge that the engineers potentially face is the ability to present
    the data in a format that either humans or machines can read. For humans, this
    would be some sort of document or visualization. For machines, this would be some
    data format that they can read.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，工程师可能面临的挑战是如何以人类或机器都能读取的格式展示数据。对于人类来说，这通常是某种文档或可视化。对于机器来说，则是某种可以读取的数据格式。
- en: 'Regardless, all of this data requires mass data analysis. You can achieve this
    even faster by using Python’s **multiprocessing library** to batch-process a large
    amount of data in parallel by leveraging multiple CPU cores for this purpose.
    Let’s dive into the process of using multiple CPU cores with code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，所有这些数据都需要进行大规模的数据分析。你可以通过使用 Python 的**多进程库**来加速这一过程，通过利用多个 CPU 核心并行批处理大量数据。让我们通过代码来深入了解如何使用多个
    CPU 核心：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, in this code, an array of 1 million values is divided into 100 arrays of
    10,000 values, each of which is summed up to calculate the total for their array.
    This is done on one of four different processors at the same time using the multiprocessing
    library. Breaking down this large task into smaller tasks can optimally use resources
    for data processing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，一个包含100万个值的数组被分割成100个包含10,000个值的小数组，每个小数组的总和用于计算该数组的总值。这个过程通过多进程库在四个不同的处理器上同时进行。将这个庞大的任务拆分成较小的任务，可以优化资源用于数据处理。
- en: Well, all of this is nice enough. But where does the data come from? Usually,
    your applications. Well, for the data to be good, the application has to be good,
    right? Yes, but that is not always the case. Let’s look at what happens when some
    applications remain stagnant and become stale.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这一切听起来都不错。但数据从哪里来呢？通常是你的应用程序。好吧，既然数据要好，应用程序就得好，对吧？是的，但这并不总是如此。让我们看看当一些应用程序停滞不前并变得过时时会发生什么。
- en: Refactoring legacy applications
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构旧应用程序
- en: 'A clean slate is one of the most convenient things in the world. I am going
    to show you two sheets of paper, and you can tell me which one you’d want to draw
    on:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一个干净的白板是世上最方便的东西之一。我将给你看两张纸，你可以告诉我你想在其中哪一张上画画：
- en: '![Figure 5.2 – A new application versus a legacy application, illustrated](img/B21320_05_2.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 新应用程序与旧应用程序的对比图](img/B21320_05_2.jpg)'
- en: Figure 5.2 – A new application versus a legacy application, illustrated
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 新应用程序与旧应用程序的对比图
- en: If you chose the right one, congratulations – you are now a DevOps engineer!
    Don’t look too deeply into this particular drawing; it’s just some rubbish I put
    together.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择了正确的道路，恭喜你——你现在是一名 DevOps 工程师！别太过深究这张图，它只是我随便拼凑的些东西。
- en: You see, DevOps engineers rarely get to work with their code. Even developers
    getting to work with their code is getting rarer these days. In my experience,
    I have only worked with a clean slate on a project in any non-personal capacity
    once or twice. Many of you who are just starting may have only worked with either
    projects you coded yourself or little template projects you may have found. However,
    in a real-life scenario, that is quite rare.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，DevOps 工程师很少会直接工作在自己的代码上。即便是开发者，现在也很少能完全自己编写代码了。根据我的经验，我在任何非个人项目中，最多只有一两次真正从零开始做项目。对于那些刚刚起步的人来说，可能只处理过自己编写的项目或者一些找到的模板项目。然而，在实际工作中，这种情况是非常罕见的。
- en: Even if you work with a blank slate, unless you have built assembly code with
    your own customized operating system, there are still a lot of dependencies that
    your workload relies on (and if you are doing it this way, how bored are you?).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你在一个干净的白板上工作，除非你已经用自己定制的操作系统编写了汇编代码，否则你的工作负载仍然依赖于大量的依赖项（如果你真是这样做的，你得多无聊啊？）。
- en: 99% of what you work with is built with something somebody else worked on –
    sometimes, hundreds and thousands of somebodies with varying levels of skill,
    competencies, and opinions. You walk a path built by a multitude of architects
    (and sometimes with no roadmaps/documentation).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你所使用的99%的工具都是由别人开发的——有时是数百或数千个不同技能水平、能力和观点的人的工作成果。你走的是由众多架构师（有时没有路线图/文档的情况下）所铺就的道路。
- en: You see, initially, it’s simple – you start with the latest version of the code,
    you host it on `localhost`, and voila, you are the master of your world. But then,
    you realize that everyone did this and everyone is desperate to hold onto that
    sense of control, even in a professional environment, regardless of the consequences
    upon the quality of their work. That is how you end up with critical infrastructure
    that hasn’t been updated in 5 years, critical services that run on discontinued
    products, and a team that is unwilling *and* unable (not either, both) to change
    it for the better. That is how you end up with tech debt (technical slang for
    horrible planning skills).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，最初，这很简单——你从代码的最新版本开始，将它托管在`localhost`上，瞧，瞬间你成为了你世界的主宰。但随之而来的是，你会意识到每个人都这么做，大家都急于保持那种控制感，即使是在专业环境中，也不顾其对工作质量的后果。这就导致了你会看到关键基础设施已经5年没有更新，关键服务仍然运行在已停产的产品上，而且团队既不愿意*也*无法（不是任意一个，而是都）做出改进。这就是如何陷入技术债务的原因（技术术语，指糟糕的规划能力）。
- en: 'To get out of technical debt, you have three options: optimize, refactor, or
    restart. What that means is you have three choices (not just in DevOps, but in
    life too): live with your mistakes, improve upon them, or start fresh. What you
    want to do (and what you can do) depends on both you and your circumstances. We
    will look at all three of these options so that you can figure out which one is
    best for your workload.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要摆脱技术债务，你有三种选择：优化、重构或重新启动。这意味着你有三种选择（不仅仅是在DevOps中，实际上在人生中也是如此）：接受你的错误、改善它们，或重新开始。你想做什么（以及你能做什么）取决于你和你的具体情况。我们将一起探讨这三种选择，帮助你找出最适合你工作负载的方案。
- en: Optimize
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化
- en: Your first option is **optimization**. You can look at what you have right now
    and make sure that it runs optimally, consuming the optimum amount of resources
    while being available to the user with all of its functions intact. A lot of the
    time (especially in **Site Reliability Engineering** (**SRE**), a field where
    you work in practically nothing but legacy applications) optimizing your legacy
    application might be your only option if you’re working with a critical application
    that cannot change one aspect without having to change many others – a monolith,
    if you will. These limitations are why a lot of companies look to break out of
    the monolith.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一个选择是**优化**。你可以查看当前的状态，确保它运行得尽可能高效，消耗最小的资源，同时保持所有功能完好并对用户可用。很多时候（尤其是在**网站可靠性工程**（**SRE**）领域——一个你几乎只处理遗留应用的领域），优化你的遗留应用可能是唯一的选择，尤其是当你在处理一个关键应用时，无法改变其中一个方面而不需要同时改变许多其他方面——你可以称之为一个单体应用。这些限制就是为什么许多公司希望摆脱单体架构。
- en: In the case of optimizing legacy applications, we are very limited in what we
    can do. But that doesn’t mean we can’t do anything. One of the most important
    DevOps concepts is **Desired State Configuration** (**DSC**) and the reason for
    that is maintaining systems such as these.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化遗留应用的情况下，我们的选择非常有限。但这并不意味着我们什么都不能做。DevOps中最重要的概念之一是**期望状态配置**（**DSC**），其重要性就在于维护这些系统。
- en: In a DSC, the virtual machine is given certain configurations that it must maintain.
    The state of these configurations is checked from time to time. If the state has
    changed significantly, then it is reset and brought back to the original desired
    state.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在DSC中，虚拟机会被配置为必须维持某些设定。会不时检查这些设定的状态。如果状态发生了显著变化，那么它将被重置，恢复到原本的期望状态。
- en: This all happens behind the scenes and doesn’t truly affect the application.
    It is probably the best way to handle an application that cannot be refactored
    or containerized into Docker containers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都发生在幕后，并不会真正影响应用本身。这可能是处理无法重构或容器化到Docker容器中的应用的最佳方式。
- en: Refactor
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构
- en: If you’re working with anything resembling decent code or resembling a decent
    project team (big ifs, but bear with me), then you may only be working with a
    workload that is either outdated and needs an update plus adjustments or one that
    no longer fulfills all that is required of it. In these cases, there is a healthy
    middle ground between the old and the new in **refactoring**.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在处理的代码质量尚可，或者你的项目团队相对可靠（这需要一些假设，但请耐心），那么你可能仅仅在处理一个已经过时并需要更新和调整的工作负载，或者是一个不再能满足所有需求的工作负载。在这些情况下，**重构**提供了一个健康的折衷方案，连接旧与新。
- en: Refactoring your code base could involve simple things such as upgrading a dependency,
    writing a new component, or removing unnecessary components. It could also involve
    a long and arduous process such as separating a website’s frontend and backend.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 重构你的代码库可能包括一些简单的操作，比如升级依赖项、编写新组件，或移除不必要的组件。也可能涉及一个漫长且艰难的过程，比如将网站的前端和后端分离。
- en: 'So, let’s look at the most prominent method of refactoring that there is: the
    strangler fig. In nature, a strangler fig is a plant that uses a tree as a base
    to grow and eventually strangles the tree to death and replaces it. The strangler
    fig works similarly for legacy applications.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下最著名的重构方法：strangler fig。在自然界中，strangler fig 是一种植物，它以树木为基础生长，最终将树木勒死并取而代之。strangler
    fig 对于遗留应用的工作原理也类似。
- en: 'Here are the steps to perform strangler fig refactoring:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是进行 strangler fig 重构的步骤：
- en: '**Separate the database**: If the database server hasn’t been separated from
    the application server, do so now. This will help the scalability of both.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**分离数据库**：如果数据库服务器还没有与应用服务器分离，现在就分离。这将有助于两者的可扩展性。'
- en: '**Turn third-party API calls into functions/microservices**: If any third-party
    APIs are being called that you do not directly maintain, separate them into function
    calls that can later be called by your refactored application. Separate them from
    the rest of the backend.'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将第三方 API 调用转化为函数/微服务**：如果调用了任何你没有直接维护的第三方 API，将它们拆分成可以在重构后的应用中调用的函数。将它们与其余的后端部分分开。'
- en: '**Separate the backend and frontend**: Separate the backend parts that deal
    with the data and the frontend parts that deal with user interaction. These parts
    need to communicate with each other using a buffer known as a **frontend for backend**,
    which is a middleman for API interactions with the frontend.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将后端和前端分离**：将处理数据的后端部分和处理用户交互的前端部分分开。这些部分需要通过一个称为**前端代理后端**的缓冲区进行通信，后者是前端与
    API 交互的中介。'
- en: '**Separate non-critical backend functions into microservices**: Separate the
    services that only process data and do not interact with the database into smaller
    microservices that can then process data independently and with greater scale.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将非关键的后端功能拆分为微服务**：将那些仅处理数据且不与数据库交互的服务拆分为更小的微服务，这样它们就能独立且更具规模地处理数据。'
- en: '**Create a database connection mechanism and put the rest of the backend into
    microservices**: Finally, the heart of the application becomes loosely coupled
    thanks to **database connection strings**, which allow the data to be manipulated
    from anywhere given the correct credentials.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建数据库连接机制，并将其余的后端拆分为微服务**：最后，应用的核心通过**数据库连接字符串**实现松耦合，这使得只要有正确的凭证，数据就能从任何地方进行操作。'
- en: That sounds a bit tricky, doesn’t it? Well, it is. But it’s also rewarding…
    sometimes. Refactoring an application – regardless of effectiveness – is one of
    the most effective ways you can practically learn about making an application
    and maintaining it. But it is quite a drain on the mind. Don’t you wish you could
    just get away from all of these mistakes other people before you made and start
    with a clean slate? Well, if you do, then the next section will fit in great with
    your plans.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来有点棘手，对吧？确实如此。但它也有回报……有时候。重构应用——无论其效果如何——是你实践学习构建和维护应用的最有效方式之一。但它确实是一个心力消耗的过程。你不希望能从前人的错误中解脱出来，重新开始一张白纸吗？如果是的话，那么接下来的部分将非常适合你的计划。
- en: Restart
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重启
- en: Sometimes – and I hope for your sake that that time is early in the development
    process – you need to throw the things you have out entirely and start fresh.
    A blank slate, as I have stated before, is the easiest starting point. If you
    believe that your application is beyond saving and that no insight or use can
    be salvaged from it, then you can build your application from scratch.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候——希望这个时机能在开发过程的早期——你需要将已有的东西完全抛弃，重新开始。如我之前所说，白纸化是最容易的起点。如果你认为你的应用已经无法挽救，且无法从中挽回任何有价值的东西，那么你可以从头开始构建应用。
- en: A lot of the time, it doesn’t make sense to migrate components between old and
    new applications either because of stack incompatibility or because the old components
    offer nothing of value. In these cases, the most valuable thing is the data generated
    by the old application and migrating that data to a database that can interact
    with the new application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，因为栈的不兼容，或者旧组件没有任何价值，迁移组件在旧应用程序和新应用程序之间并不合适。在这些情况下，最有价值的是旧应用程序生成的数据，并将这些数据迁移到可以与新应用程序互动的数据库中。
- en: 'If you’re making a new application, honestly, do it your way. But here’s some
    advice:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在开发一个新应用程序，老实说，按你的方式做吧。但有一些建议：
- en: Make decisions that are long term and not just based on what you’re thinking
    about now.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做出长期的决策，而不仅仅是基于你现在的想法。
- en: Make decisions that put quality first, but also understand that mistakes will
    always be there.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 做出以质量为优先的决策，但也要明白，错误总是不可避免的。
- en: Don’t react to everything; being reactive will 100% result in a worse application.
    If you can help it, don’t react to anything. Be proactive.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要对每件事做出反应；过于反应性地处理问题100%会导致应用程序变得更差。如果可以的话，不要对任何事情做出反应，要主动出击。
- en: Put quality, readability, and maintainability first. Don’t think that you’ll
    come back to something later. That kind of thinking adds many hours of work on
    your shoulders (or even worse, somebody else’s) later.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将质量、可读性和可维护性放在首位。不要认为以后会回头处理某些事情。这种想法会在以后给你（或者更糟的是，给别人）带来许多额外的工作。
- en: Restarting an application and building it from scratch is an appealing concept.
    Don’t restart too much, though, because you’ll never get anything done. There
    are only so many times you can restart a project before you realize that maybe
    your approach is the problem.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动一个应用程序并从头开始构建是一个具有吸引力的概念。然而，别重启太多次，因为你最终什么都做不成。你最多只能重启一个项目这么多次，直到你意识到，或许是你的方法本身出了问题。
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter took a few detours that you may have not seen coming. It was a
    chapter about simplicity, finding better ways to get your work done, and optimizing
    the use of your resources to get that work done.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有一些你可能没有预见到的绕道。这是一个关于简化、寻找更好方式完成工作，以及优化资源利用以完成工作的章节。
- en: You learned how to deliver content to your users faster and in a more customized
    way while at the same time collecting their data for analytical insights. You
    also learned the methods and formats of this data collection process, as well
    as the important role that Python can play in processing this data.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你学会了如何更快速、更定制化地向用户传递内容，同时收集他们的数据以便进行分析。你还学习了数据收集过程的方法和格式，以及 Python 在处理这些数据中所扮演的重要角色。
- en: You also learned about applications, how most application waste is created,
    and how this can bog down your workload and your successors for years to come.
    You also learned a few ways to either mitigate, get around, or eliminate this
    problem.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解了应用程序、应用程序浪费是如何产生的，以及这种浪费如何在未来几年影响你的工作负载和继任者。你也学习了一些方法，可以缓解、绕过或消除这个问题。
- en: So, in conclusion, you have now figured out that manipulating resources is about
    being efficient not just for the resources, but for the sake of your own time.
    I hope that you reflect on this chapter for your DevOps workloads and your grocery
    shopping.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，你现在已经明白了，资源的利用效率不仅仅是为了资源本身，更是为了节省你自己的时间。我希望你能从这一章的内容中反思，应用到你的 DevOps 工作负载和你的购物清单中。
- en: 'In the next chapter, we are going to cover a particularly favorite topic of
    mine: automation. We are going to find ways we can make our lives easier and less
    bothered by things we shouldn’t be bothered with.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论一个我特别喜欢的话题：自动化。我们将找到一些方法，使我们的生活更轻松，减少那些我们不该被打扰的事情。
