- en: '*Chapter 12*: Shift Left Testing for Increased Quality'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：通过左移测试提高质量'
- en: '**Testing** and **quality assurance** (**QA**) is still one of the practices
    that holds back most companies. In this chapter, we''ll take a closer look at
    the role that QA and testing play in terms of developer velocity and how to shift
    left test.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**和**质量保证**（**QA**）仍然是大多数公司面临的瓶颈。在本章中，我们将深入探讨QA和测试在开发者速度中的作用，以及如何进行左移测试。'
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Shift left testing with test automation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试自动化进行左移测试
- en: Eradicating flaky tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消除不稳定的测试
- en: Code coverage
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Shift right – testing in production
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移——生产环境中的测试
- en: Fault injection and chaos engineering
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障注入与混沌工程
- en: Testing and compliance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试与合规性
- en: Test management in GitHub
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub中的测试管理
- en: Shift left testing with test automation
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试自动化进行左移测试
- en: If you practice agile development and try to ship frequently, then manual testing
    isn't a scalable option. Even if you don't practice CI/CD and only ship on a sprint
    cadence, running all the necessary regression tests would take enormous manpower
    and a lot of time and money. But getting test automation right is not an easy
    task. Automated tests that have been created and maintained by a QA department
    or outsourced entity, for example, are *not* correlated with higher engineering
    velocity (*Forsgren N., Humble, J., & Kim, G., 2018*, *Page 95*). To notice an
    impact on your velocity, you need reliable tests that have been created and maintained
    by the team. The theory behind this is that if developers maintain tests, they
    produce more testable code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你实践敏捷开发并尝试频繁发布，那么手动测试就不是一个可扩展的选项。即使你不进行CI/CD，且仅在一个迭代周期内发布，运行所有必要的回归测试仍然会消耗大量人力、时间和金钱。但是，要做到自动化测试正确并不容易。例如，自动化测试如果由QA部门或外包机构创建和维护，*并不*会与更高的工程速度相关联（*Forsgren
    N., Humble, J., & Kim, G., 2018*, *第95页*）。要看到速度上的提升，你需要由团队创建并维护的可靠测试。其背后的理论是，如果开发人员维护测试，他们会生成更多可测试的代码。
- en: 'Everybody knows what a good test portfolio should look like: you have a big
    base of automated unit tests (Level 0), fewer integration tests (Level 1), some
    integration tests that need test data (Level 2), and only a few functional tests
    (Level 3). This is called the test pyramid (*see Figure 12.1*):'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道一个好的测试组合应该是什么样的：你应该有大量自动化的单元测试（Level 0），较少的集成测试（Level 1），一些需要测试数据的集成测试（Level
    2），以及少数功能性测试（Level 3）。这被称为测试金字塔（*见图12.1*）：
- en: '![Figure 12.1 – The test pyramid'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 测试金字塔'
- en: '](img/B17827_12_001.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_001.jpg)'
- en: Figure 12.1 – The test pyramid
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 测试金字塔
- en: 'However, in most companies, the portfolio does not look like this. Sometimes,
    there are some unit tests, but most of the other tests are still at a very high
    level (*see Figure 12.2*):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在大多数公司中，测试组合并非如此。有时会有一些单元测试，但其他大多数测试仍然停留在较高的层次（*见图12.2*）：
- en: '![Figure 12.2 – Example test portfolio'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – 示例测试组合'
- en: '](img/B17827_12_002.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_002.jpg)'
- en: Figure 12.2 – Example test portfolio
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 示例测试组合
- en: 'These high-level tests might be automated or manual. But still, it is not a
    test portfolio that will help you to release continuously with high quality. To
    achieve continuous quality, you must shift left your test portfolio (*see Figure
    12.3*):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些高级测试可能是自动化的，也可能是手动的。但即便如此，这也不是一个能帮助你持续高质量发布的测试组合。要实现持续的质量，你必须将测试组合“左移”(*见图12.3*)：
- en: '![Figure 12.3 – Shift left testing'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – 左移测试'
- en: '](img/B17827_12_003.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_003.jpg)'
- en: Figure 12.3 – Shift left testing
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 左移测试
- en: 'This is not an easy task. Here are some principles that help with shift left
    testing:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一项容易的任务。以下是一些有助于左移测试的原则：
- en: '**Ownership**: The team is responsible for QA and the tests are developed alongside
    the code – preferably with the test-first approach. QA engineers should be included
    in the team.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有权**：团队对质量保证（QA）负责，测试与代码一同开发——最好采用先测试后编码的方法。QA工程师应该成为团队的一部分。'
- en: '**Shift left**: Tests should always be written at the lowest level possible.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左移**：测试应该始终在可能的最低层次编写。'
- en: '**Write once – execute everywhere**: Tests should be executed in all environments,
    even in production.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一次编写，处处执行**：测试应在所有环境中执行，甚至在生产环境中。'
- en: '**Test code is production code**: The same quality standards that apply to
    normal code apply to test code. No shortcuts should be allowed here.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试代码就是生产代码**：适用于普通代码的质量标准同样适用于测试代码。这里不应允许任何捷径。'
- en: '**You code it – you test it**: As a developer, you are responsible for the
    quality of your code, and you must make sure that all the tests are in place to
    ensure this quality.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你写代码 – 你测试它**：作为开发者，你对代码的质量负责，必须确保所有的测试都到位，以确保质量。'
- en: 'In 2013, a testing manifesto was created that describes the transformation
    of the QA role (*Sam Laing, 2015*):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，创建了一个测试宣言，描述了QA角色的转变（*Sam Laing, 2015*）：
- en: Testing throughout *over* testing at the end
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试贯穿整个过程 *而不是* 在最后进行测试
- en: Preventing bugs *over* finding bugs
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止错误 *而不是* 发现错误
- en: Testing understanding *over* checking functionality
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试理解 *而不是* 检查功能
- en: Building the best system *over* breaking the system
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建最佳系统 *而不是* 破坏系统
- en: Team responsibility for quality *over* tester responsibility
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队对质量的责任 *而不是* 测试员的责任
- en: This sounds easy, but it isn't. Developers have to learn to think like testers
    and testers have to learn to think like engineers. Selling the vision and establishing
    the change's sustainability is not an easy task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单，但实际上并非如此。开发人员必须学会像测试员一样思考，而测试员必须学会像工程师一样思考。传达愿景并确保变革的可持续性不是一项容易的任务。
- en: Test-driven development
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: The key to test automation is having a testable software architecture. To get
    one, you must start as early as possible – that is, in the inner loop, when developers
    write their code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化的关键是拥有一个可测试的软件架构。为了实现这一点，你必须尽早开始——也就是说，在内部循环中，当开发人员编写代码时。
- en: '**Test-driven development** (**TDD**) is a software development process where
    you write your automated test first and then the code that makes the test pass.
    It has been around for more than 20 years and the quality benefits have been proven
    in different studies (for example, *Müller, Matthias M.; Padberg, Frank, 2017*
    and *Erdogmus, Hakan; Morisio, Torchiano, 2014*). TDD not only has a big impact
    on the time that''s spent on debugging and overall code quality; it also has a
    big influence on solid and testable software design. That''s why it is also called
    **test-driven design**.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发** (**TDD**) 是一种软件开发过程，你首先编写自动化测试，然后编写使测试通过的代码。它已经存在超过20年，并且通过不同的研究证明了其质量效益（例如，*Müller,
    Matthias M.; Padberg, Frank, 2017* 和 *Erdogmus, Hakan; Morisio, Torchiano, 2014*）。TDD不仅对调试所花费的时间和整体代码质量有很大影响；它还对稳固和可测试的软件设计产生重要影响。正因如此，它也被称为**测试驱动设计**。'
- en: 'TDD is simple. The steps are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: TDD很简单。步骤如下：
- en: '**Add or modify a test**: Always start with a test. While writing the test,
    you **design** what your code will look like. There will be a time when your test
    will not compile because the classes and functions that you are calling do not
    exist yet. Most development environments support creating the necessary code right
    from within your test. This step is completed once your code compiles and the
    test can be executed. The test is supposed to fail. If the test passes, modify
    it or write a new test until it fails.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加或修改测试**：总是从一个测试开始。在编写测试时，你**设计**你的代码的样子。有时候你的测试不会编译，因为你调用的类和函数还不存在。大多数开发环境支持直接在测试中创建必要的代码。当你的代码编译并且测试可以执行时，这一步就完成了。测试应该失败。如果测试通过，修改它或编写一个新测试，直到它失败。'
- en: '**Run all tests**: Run all the tests and verify that only the new test fails.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行所有测试**：运行所有测试并验证只有新测试失败。'
- en: '**Write code**: Write some simple code that makes the test pass. Always run
    all your tests to check if the test passes. The code does not need to be pretty
    in this stage and shortcuts are allowed. Just make the test pass. Bad code will
    give you an idea of what test you need next to ensure that the code gets better.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写代码**：编写一些简单的代码使测试通过。在这个阶段，代码不需要很漂亮，允许使用快捷方式。只需确保测试通过。糟糕的代码能让你知道接下来需要什么测试，以确保代码变得更好。'
- en: '**All tests pass**: If all the tests pass, you have two options: write a new
    test or modify the existing one. Alternatively, you can refactor your code and
    tests.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**所有测试通过**：如果所有测试都通过，你有两个选择：编写一个新测试或修改现有的测试。或者，你可以重构你的代码和测试。'
- en: '**Refactor**: Refactor the code and the tests. Since you have a solid test
    harness, you can do more extreme refactoring than you normally would without TDD.
    Make sure that you run all the tests after each refactoring. If one test fails,
    undo the last step and retry until the tests keep passing after the refactoring
    step. After a successful refactoring, you can start a new iteration with a new
    failing test.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构**：重构代码和测试。由于你已经拥有了一个可靠的测试框架，你可以进行比通常情况下更加极端的重构，而无需担心没有TDD的支持。确保在每次重构后都运行所有的测试。如果有一个测试失败，撤销上一步并重试，直到所有测试在重构后都通过。成功重构后，你可以开始一个新的迭代，进行新的失败测试。'
- en: 'Figure 12.4 shows an overview of the TDD cycle:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 展示了 TDD 循环的概览：
- en: '![Figure 12.4 – The TDD cycle'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.4 – TDD 循环'
- en: '](img/B17827_12_004.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_004.jpg)'
- en: Figure 12.4 – The TDD cycle
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – TDD 循环
- en: 'A good test follows the following pattern:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的测试遵循以下模式：
- en: '**Arrange**: Set up the necessary objects for the test and the **system under
    test** (**SUT**) itself – normally, this is a class. You can use **mocks** and
    **stubs** to simulate system behavior (to learn more about mocks and stubs, see
    *Martin Fowler, 2007*).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安排**：为测试设置必要的对象以及**待测试系统**（**SUT**）本身——通常这是一个类。你可以使用**模拟**和**存根**来模拟系统行为（要了解更多关于模拟和存根的内容，请参考*马丁·福勒，2007*）。'
- en: '**Act**: Execute the code that you want to test.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行**：执行你想要测试的代码。'
- en: '**Assert**: Verify the results, ensure that the state of the system is in the
    desired state, and ensure that the method has called the correct methods with
    the correct parameters.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断言**：验证结果，确保系统的状态符合预期，并确保方法已调用正确的方法，并传递了正确的参数。'
- en: Each test should be completely autarkic – that is, it shouldn't depend on a
    system state that's been manipulated by previous tests, and it can be executed
    in isolation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试应该是完全自给自足的——也就是说，它不应该依赖于先前测试所操作的系统状态，并且可以在隔离环境下执行。
- en: TDD can also be used in pair programming. This is called **Ping Pong Pair Programming**.
    In this form of pair programming, one developer writes the test and the other
    writes the code that makes the test pass. This is a great pattern for pair programming
    and a good way to teach younger colleagues the benefits of TDD.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 也可以用于结对编程，这被称为**乒乓结对编程**。在这种形式的结对编程中，一位开发者编写测试，另一位开发者编写代码使得测试通过。这是一种非常适合结对编程的模式，也是一种很好的方式，帮助年轻的同事理解TDD的好处。
- en: TDD has been around for so long and the teams that practice it gain so much
    value – and yet I have met many teams that are not using it. Some don't use it
    because their code runs on embedded systems, while others don't use it because
    their code depends on SharePoint classes that are hard to mock. But these are
    just excuses. There might be some plumbing code that cannot be tested, but when
    you write logic, you can always test it first.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: TDD 已经存在很久了，并且实践它的团队收获了巨大的价值——然而我遇到过许多没有使用它的团队。有些团队因为他们的代码运行在嵌入式系统上而没有使用 TDD，另一些团队则因为他们的代码依赖于难以模拟的
    SharePoint 类而放弃使用它。但这些都只是借口。虽然可能有一些无法测试的管道代码，但当你编写逻辑时，你总是可以先进行测试。
- en: Managing your test portfolio
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理你的测试组合
- en: 'With TDD, you should get a testable design in no time. And even in a brownfield
    environment, the number of automated tests will grow rapidly. The problem is that
    often, the quality of the tests is not optimal and with a growing test portfolio,
    you often get very long execution times and non-deterministic (flaky) tests. It
    is better to have fewer tests that are of higher quality. Long execution times
    hinder you from releasing quickly, and flaky tests produce unreliable quality
    signals and reduce the trust in your test suite (*see Figure 12.5*). With more
    QA maturity in the team, the quality of the test suite constantly rises – even
    if the amount of tests reduces after the first peak:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TDD，你应该能够迅速得到一个可测试的设计。即使在已有项目的环境中，自动化测试的数量也会迅速增长。问题在于，测试的质量往往不是最优的，而且随着测试库的增长，执行时间会变得非常长，并且测试结果可能会变得不稳定（例如间歇性失败）。最好是有更少但质量更高的测试。长时间的执行会妨碍你快速发布，而不稳定的测试会产生不可靠的质量信号，降低对测试套件的信任（*参见图
    12.5*）。随着团队质量保证能力的提升，测试套件的质量会不断提高——即使在首次增长后的测试数量减少：
- en: '![Figure 12.5 – Amount and quality of automated tests'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.5 – 自动化测试的数量和质量'
- en: '](img/B17827_12_005.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_005.jpg)'
- en: Figure 12.5 – Amount and quality of automated tests
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 自动化测试的数量和质量
- en: To actively manage your test portfolio, you should define ground rules for your
    tests and constantly monitor the number of tests and their execution time. As
    an example, let's look at the **taxonomy** that's used by a team at Microsoft
    for their test portfolio.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了积极管理你的测试组合，你应该为你的测试定义基本规则，并不断监控测试数量及其执行时间。例如，我们来看微软团队用于其测试组合的**分类法**。
- en: Unit tests (Level 0)
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试（Level 0）
- en: Here, we have in-memory unit tests with no external dependencies and no deployment.
    They should be fast with an average execution time of fewer than 60 milliseconds.
    Unit tests are co-located with the code under test.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有的是内存中的单元测试，没有外部依赖，也没有部署。它们应该很快，平均执行时间少于60毫秒。单元测试与被测试的代码共同存在。
- en: With unit tests, you can't change to the system's state (such as the filesystem
    or its registry), queries to external data sources (web services and databases),
    or the mutexes, semaphores, stopwatches, and `Thread.sleep` operations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，你不能更改系统的状态（如文件系统或注册表）、查询外部数据源（如Web服务和数据库）或使用互斥锁、信号量、计时器以及`Thread.sleep`等操作。
- en: Integration tests (Level 1)
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试（Level 1）
- en: This level involves tests with more complex requirements that may depend on
    a lightweight deployment and configuration. The tests should still be very fast,
    and each test must run under 2 seconds.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层涉及更复杂的测试需求，可能依赖于轻量级部署和配置。测试仍然应该非常快速，每个测试必须在2秒内完成。
- en: With integration tests, you can't have dependencies on other tests and store
    large amounts of data. You also can't have too many tests in one assembly as this
    prevents the tests from being executed in parallel.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于集成测试，你不能依赖于其他测试并存储大量数据。你也不能在一个组件中放入太多的测试，因为这会阻止测试并行执行。
- en: Functional tests with data (Level 2)
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带数据的功能性测试（Level 2）
- en: Functional tests run against a testable deployment with test data. Dependencies
    on systems such as the authentication provider can be stubbed out and allow dynamic
    identities to be used. This means that there's an isolated identity for every
    test so that the test can be executed in parallel against a deployment without
    them impacting each other.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 功能性测试在可测试的部署环境中运行，并使用测试数据。对像身份验证提供者这样的系统的依赖可以被模拟，从而允许使用动态身份。这意味着每个测试都有一个独立的身份，以便可以在部署环境中并行执行这些测试，且不会互相影响。
- en: Production tests (Level 3)
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生产测试（Level 3）
- en: Production tests run against production and require a full product deployment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 生产测试在生产环境中运行，且需要完全的产品部署。
- en: This is just an example, and your taxonomy may look different, depending on
    your programming language and product.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个示例，你的分类法可能会有所不同，具体取决于你的编程语言和产品。
- en: If you have defined your taxonomy, you can set up reporting and start to transform
    your test portfolio. Make sure that you make it easy to write and execute high-quality
    unit and integration tests first. Then, start analyzing your legacy tests – manual
    or automated – and check which ones you can throw away. Convert the others into
    good functional tests (*Level 2*). The last step is to write your tests for production.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经定义了你的分类法，你可以设置报告并开始转变你的测试组合。确保首先让编写和执行高质量的单元测试和集成测试变得容易。然后，开始分析你的遗留测试——无论是手动测试还是自动化测试——并检查哪些可以丢弃。将其余的转换为良好的功能性测试（*Level
    2*）。最后一步是编写你的生产测试。
- en: 'The team at Microsoft started with 27,000 legacy tests (in orange) and reduced
    them to zero in 42 sprints (126 weeks). Most of the tests were replaced with unit
    tests; some were replaced with functional tests. Many were simply deleted, but
    there was a steady growth in unit tests, with there being over 40,000 in the end
    (*see Figure 12.6*):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 微软团队从27,000个遗留测试（橙色）开始，并在42个迭代（126周）内将其减少为零。大多数测试被替换为单元测试；一些被替换为功能性测试。许多测试直接删除了，但单元测试数量稳步增长，最终超过了40,000个（*见图
    12.6*）：
- en: '![Figure 12.6 – Test portfolio over time'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.6 – 测试组合随时间的变化'
- en: '](img/B17827_12_006.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_006.jpg)'
- en: Figure 12.6 – Test portfolio over time
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 测试组合随时间的变化
- en: See *Shift left to make testing fast and reliable*, in the *Further reading*
    section, for more information on how the team at Microsoft shifted their test
    portfolio left.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 参见*向左移动以使测试快速且可靠*，在*进一步阅读*部分，了解微软团队如何将其测试组合向左移动。
- en: Eradicating flaky tests
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根除不稳定的测试
- en: '**Non-deterministic** or **flaky tests** are tests that sometimes pass and
    sometimes fail with the same code (*Martin Fowler, 2011*). Flaky tests can destroy
    the trust in your test suite. This can lead to teams just ignoring red test results,
    or developers deactivating tests, thereby reducing the test coverage and reliability
    of the suite.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**非确定性**或**不稳定测试**是那些有时通过、有时失败的测试，即使代码相同（*Martin Fowler, 2011*）。不稳定的测试会破坏对测试套件的信任。这可能导致团队忽略红色测试结果，或者开发人员停用测试，从而降低测试覆盖率和套件的可靠性。'
- en: There are lots of reasons for flaky tests. Often, they are due to a lack of
    isolation. Many tests run in the same process on a machine – so each test must
    find and leave a clean state of the system. Another common reason is asynchronous
    behavior. Testing asynchronous code has its challenges as you never know which
    order the asynchronous tasks are executed in. Other reasons may include resource
    leaks or calls to remote resources.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定测试有很多原因。通常，它们是由于缺乏隔离性造成的。许多测试在同一台机器上的同一个进程中运行 —— 所以每个测试必须找到并保持系统的干净状态。另一个常见的原因是异步行为。测试异步代码具有挑战性，因为你无法知道异步任务的执行顺序。其他原因可能包括资源泄漏或对远程资源的调用。
- en: 'There are different ways to deal with flaky tests:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 处理不稳定测试的方式有很多种：
- en: '`git blame`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git blame`。'
- en: '`git blame`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git blame`。'
- en: Some companies quarantine flaky tests, but this also keeps you from collecting
    additional data as the test can't run. It's best practice to keep executing flaky
    tests but exclude them from the reporting.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一些公司会将不稳定测试隔离，但这样也会阻止你收集额外的数据，因为测试无法运行。最好的做法是继续执行不稳定测试，但将它们从报告中排除。
- en: If you want to learn how GitHub or Google are dealing with flaky tests, read
    *Jordan Raine, 2020* or *John Micco, 2016*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解GitHub或Google是如何处理不稳定测试的，可以阅读 *Jordan Raine, 2020* 或 *John Micco, 2016*。
- en: Code coverage
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: '**Code coverage** is a metric (in percent) that calculates the number of code
    elements that get called by tests, divided by the total amount of code elements.
    Code elements can be anything, but lines of code, code blocks, or functions are
    common.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码覆盖率**是一个衡量指标（以百分比表示），它计算通过测试调用的代码元素的数量，除以总的代码元素数量。代码元素可以是任何东西，但常见的有代码行、代码块或函数。'
- en: Code coverage is an important metric as it shows you what parts of your code
    are not covered by your test suite. I like to watch the code coverage before I
    finish a code change as I often forget to write tests for edge cases such as exception
    handling, or more complex statements such as lambda expressions. It's no problem
    to add these tests the moment you are coding – it's much harder to add them later.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是一个重要的指标，因为它能显示哪些代码部分没有被你的测试套件覆盖。我喜欢在完成代码更改之前查看代码覆盖率，因为我经常忘记为一些边界情况（如异常处理）或更复杂的语句（如lambda表达式）编写测试。现在添加这些测试没有问题
    —— 但事后再添加就困难得多。
- en: But you should not focus on the absolute number as code coverage itself says
    nothing about the quality of the tests. It's better to have 70% code coverage
    with high-quality tests than 90% percent code coverage with low-quality tests.
    Depending on the programming language and frameworks you use, there might be some
    plumbing code that has a high effort in terms of testing but with very low value.
    Normally, you can exclude that code from code coverage calculations, but this
    is why the absolute value of code coverage is limited. However, measuring the
    value in each pipeline and focusing on new code helps improve the quality of your
    automated tests over time.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但你不应过于关注绝对数字，因为代码覆盖率本身并不能说明测试的质量。拥有70%的代码覆盖率且测试质量高，比拥有90%代码覆盖率但测试质量差更好。根据你使用的编程语言和框架，可能存在一些在测试中耗费大量精力但价值很低的代码。通常，你可以将这些代码排除在代码覆盖率计算之外，这就是为什么代码覆盖率的绝对值是有限的。不过，在每个管道中测量其价值并专注于新代码，有助于随着时间的推移提高自动化测试的质量。
- en: Shift right – testing in production
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向右移动 —— 在生产环境中测试
- en: 'If you start with automated testing, you rapidly see improved quality and a
    decline in the debugging effort of your engineers. But at some point, you must
    increase the effort tremendously to see a significant impact on quality. On the
    other hand, the time your tests need to execute slows down your release pipeline,
    especially if you add **performance tests** and **load tests** to the mix (*see
    Figure 12.7*):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从自动化测试开始，你会迅速看到质量提升和工程师调试工作的减少。但在某个时刻，你必须大幅增加投入才能看到质量的显著改善。另一方面，测试执行所需的时间会减缓发布管道的速度，尤其是当你将**性能测试**和**负载测试**加入其中时（*见图12.7*）：
- en: '![Figure 12.7 – The impact of testing effort on quality and velocity'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – 测试工作量对质量和速度的影响'
- en: '](img/B17827_12_007.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_007.jpg)'
- en: Figure 12.7 – The impact of testing effort on quality and velocity
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 测试工作量对质量和速度的影响
- en: It's impossible to release multiple times a day if your pipeline runs for more
    than 24 hours! The increased execution time of your pipeline also reduces your
    ability to roll forward quickly and deploy a fix if a bug occurs in production.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的流水线运行时间超过24小时，那么一天发布多次是无法实现的！流水线执行时间的增加还会减少你快速推进和部署修复的能力，特别是当生产环境出现bug时。
- en: 'The solution to this is simple: **shift right** some of the tests to production.
    All the tests that you run in production do not impact your ability to release
    fast, and you don''t need performance or load tests as your code already has production
    load.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法很简单：**向右移**一些测试到生产环境中。所有在生产环境中执行的测试不会影响你快速发布的能力，而且你不需要性能测试或负载测试，因为你的代码已经经历了生产负载。
- en: However, there are some prerequisites to testing in production that increase
    the performance quality for your users instead of decreasing it. Let's take a
    look.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在生产环境中进行测试有一些前提条件，这些条件能够提高用户的性能质量，而不是降低它。让我们一起来看看。
- en: Health data and monitoring
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 健康数据和监控
- en: For testing in production, you must be constantly aware of the health of your
    application. This goes beyond normal logging. You need deep insights into how
    your application is operating. A good practice is to have test code that calls
    all dependent systems – such as the database, a Redis cache, or dependent REST
    services – and makes these tests available to your logging solutions. This way,
    you can have a constant **heartbeat** that indicates that all the systems are
    up and running and working together. If the test fails, you can have an alert
    that instantly notifies the team that something is wrong. You can also automate
    these alerts and have them trigger certain functions, such as activating a **circuit
    breaker**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境中的测试，你必须时刻关注应用程序的健康状况。这超出了普通日志记录的范畴。你需要深入了解应用程序的运行情况。一种好的做法是编写测试代码，调用所有依赖的系统——例如数据库、Redis缓存或依赖的REST服务——并将这些测试结果提供给你的日志解决方案。这样，你可以拥有一个持续的**心跳**，以指示所有系统都在运行并且正常协作。如果测试失败，可以通过警报立即通知团队某些地方出了问题。你还可以自动化这些警报，并触发某些功能，比如启动**熔断器**。
- en: Circuit Breaker
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 熔断器
- en: A **circuit breaker** is a pattern that prevents an application from repeatedly
    trying to execute an operation that is likely to fail, allowing the application
    to continue with altered functionality without having to wait for the failing
    operation to succeed (see *Michael Nygard, 2018*).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**熔断器**是一种模式，防止应用程序反复尝试执行可能失败的操作，使得应用程序能够在不等待失败操作成功的情况下，继续执行经过修改的功能（参见 *Michael
    Nygard, 2018*）。'
- en: Feature flags and canary releases
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性标志和金丝雀发布
- en: You don't want to test in production and cause a complete outage for all your
    customers. That's why you need feature flags, canary releases, a ring-based deployment,
    or a mix of those techniques (see [*Chapter 9*](B17827_09_Epub.xhtml#_idTextAnchor216)
    and [*Chapter 10*](B17827_10_Epub.xhtml#_idTextAnchor239)). It's important to
    gradually expose the changes so that if an outage occurs, you don't take down
    the complete production environment.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望在生产环境中进行测试，从而导致所有客户的完全宕机。这就是为什么你需要特性标志、金丝雀发布、基于环的部署，或者这些技术的组合（参见 [*第9章*](B17827_09_Epub.xhtml#_idTextAnchor216)
    和 [*第10章*](B17827_10_Epub.xhtml#_idTextAnchor239)）。逐步暴露变更非常重要，这样如果发生宕机，你就不会让整个生产环境崩溃。
- en: Business continuity and disaster recovery
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务连续性与灾难恢复
- en: Another form of testing in production is **business continuity and disaster
    recovery** (**BCDR**) or failover testing. There should be a BCDR for every service
    or subsystem of your product, and you should execute a BCDR drill regularly. There
    is nothing worse than disaster recovery that is not working if your system is
    down. And you only know that it is working if you regularly test it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种生产环境测试的形式是**业务连续性与灾难恢复**（**BCDR**）或故障转移测试。每个服务或子系统都应该有一个BCDR，并且你应该定期执行BCDR演练。如果系统宕机，而灾难恢复无法正常工作，那是最糟糕的情况。只有定期测试，才能确保它正常工作。
- en: Exploratory testing and usability testing
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索性测试和可用性测试
- en: Test automation does not imply that you should completely abandon manual testing.
    But the focus of manual tests shifts away from validating functionality and executing
    regressions tests manually on every release toward usability, fast and high-quality
    feedback, and bugs that are hard to find with structured test approaches.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 测试自动化并不意味着你应该完全放弃手动测试。但手动测试的重点已经从验证功能和每个发布都进行回归测试转移到可用性、快速且高质量的反馈，以及那些通过结构化测试方法难以发现的错误。
- en: '**Exploratory testing** was introduced by Cem Kaner in 1999 (*Kaner C., Falk
    J., H. Q. Nguyen, 1999*). It is an approach to testing that focuses simultaneously
    on discovery, learning, test design, and execution. It relies on the individual
    tester to uncover defects that can''t easily be discovered in other tests.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**探索性测试**由 Cem Kaner 于 1999 年提出（*Kaner C., Falk J., H. Q. Nguyen, 1999*）。它是一种测试方法，旨在同时关注发现、学习、测试设计和执行。它依赖于测试人员个人发现那些其他测试方法难以发现的缺陷。'
- en: There are many tools available that can facilitate exploratory testing. They
    help you record your sessions, take annotated screenshots, and often allow you
    to create a test case from the steps you have performed. Some extensions integrate
    with Jira, such as Zephyr and Capture, and there are browser extensions such as
    the Test and Feedback client for Azure Test Plans. The latter is free if you use
    it in standalone mode. These tools provide the high-quality feedback of stakeholders
    to developers – not only in terms of the defects that were discovered.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以促进探索性测试。它们帮助你记录会话、拍摄带注释的截图，并且通常允许你从已经执行的步骤中创建测试用例。一些扩展与 Jira 集成，如 Zephyr
    和 Capture，还有浏览器扩展，如用于 Azure 测试计划的 Test 和 Feedback 客户端。如果以独立模式使用，后者是免费的。这些工具为开发人员提供了来自利益相关者的高质量反馈——不仅仅是关于发现的缺陷。
- en: Other ways to gather feedback include using **usability testing** techniques
    – such as **hallway testing** or **guerrilla usability** – to evaluate your solution
    by testing it on new, unbiased users. A special form of usability testing is A/B
    testing, which we'll cover in more detail in *Chapter 19*, *Experimentation and
    A/B Testing with GitHub*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 获取反馈的其他方式包括使用**可用性测试**技术——如**走廊测试**或**游击式可用性测试**——通过在新用户、没有偏见的用户身上测试，来评估你的解决方案。可用性测试的一种特殊形式是
    A/B 测试，我们将在*第19章*，*使用 GitHub 进行实验和 A/B 测试*中详细讨论。
- en: The important part here is that all these tests can be executed in production.
    You should not have any manual tests in your CI/CD pipeline. Release fast and
    allow manual testing in production using feature flags and canary releases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要部分是，所有这些测试都可以在生产环境中执行。你的 CI/CD 流水线中不应该有任何手动测试。快速发布，并使用功能标志和金丝雀发布允许在生产环境中进行手动测试。
- en: Fault injection and chaos engineering
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 故障注入与混沌工程
- en: If you want to level up testing in production, you can practice **fault injection**
    – also known as **chaos engineering**. This means that you inject faults into
    your production system to see how it behaves under pressure and if your failover
    mechanisms and circuit breakers work. Possible faults could include high CPU load,
    high memory usage, disk I/O pressure, low disk space, or a service or entire machine
    being shut down or rebooted. Other possibilities include processes being killed,
    the system's time being changed, network traffic being dropped, latency being
    injected, and DNS servers being blocked.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想提升生产环境中的测试，可以练习**故障注入**——也称为**混沌工程**。这意味着你向生产系统中注入故障，以查看它在压力下的表现，以及你的故障转移机制和断路器是否正常工作。可能的故障包括高
    CPU 占用、高内存使用、磁盘 I/O 压力、低磁盘空间，或服务或整个机器被关闭或重启。其他可能的情况包括进程被终止、系统时间被更改、网络流量丢失、延迟注入，以及
    DNS 服务器被阻塞。
- en: Practicing chaos engineering makes your system resilient. You cannot compare
    this to classical load or performance testing!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 实践混沌工程能使你的系统更具弹性。这无法与传统的负载或性能测试相比！
- en: Different tools can help you with chaos engineering. **Gremlin** ([https://www.gremlin.com/](https://www.gremlin.com/)),
    for example, is an agent-based SaaS offering that supports most cloud providers
    (Azure, AWS, and Google Cloud) and all operating systems. It can also be used
    with Kubernetes. **Chaos Mesh** ([https://chaos-mesh.org/](https://chaos-mesh.org/))
    is an open source solution that's specialized for Kubernetes. **Azure Chaos Studio**
    ([https://azure.microsoft.com/en-us/services/chaos-studio](https://azure.microsoft.com/en-us/services/chaos-studio))
    is a solution that's specialized for Azure. What tool is best for you depends
    on the platforms that you support.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的工具可以帮助你进行混沌工程。例如，**Gremlin** ([https://www.gremlin.com/](https://www.gremlin.com/))
    是一个基于代理的 SaaS 产品，支持大多数云服务提供商（如 Azure、AWS 和 Google Cloud）以及所有操作系统。它也可以与 Kubernetes
    配合使用。**Chaos Mesh** ([https://chaos-mesh.org/](https://chaos-mesh.org/)) 是一个专门为
    Kubernetes 设计的开源解决方案。**Azure Chaos Studio** ([https://azure.microsoft.com/en-us/services/chaos-studio](https://azure.microsoft.com/en-us/services/chaos-studio))
    是一个专门为 Azure 设计的解决方案。最适合你的工具取决于你支持的平台。
- en: Chaos engineering can be very effective and make your systems resilient, but
    it should be limited to canary environments that have little or no customer impact.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 混沌工程可以非常有效，并使你的系统具备韧性，但它应该仅限于对客户影响较小或没有影响的金丝雀环境。
- en: Tests and compliance
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试与合规性
- en: 'Most **compliance** standards, such as **ISO26262** for automotive or **GAMP**
    for pharma, follow the **V-Model** as a development process. The V-Model requires
    the user and system requirements to be decomposed and specifications to be created
    at different levels of detail. This is the left-hand side of the *V*. It also
    requires all the levels to be validated to ensure that the system fulfills the
    requirements and specifications. This is the right-hand side of the *V*. Both
    sides can be seen in *Figure 12.8*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数**合规性**标准，如汽车行业的**ISO26262** 或制药行业的**GAMP**，都遵循**V 模型**作为开发过程。V 模型要求对用户和系统需求进行分解，并在不同的详细层级中创建规格。这是
    *V* 的左侧。它还要求验证所有层级，以确保系统满足需求和规格。这是 *V* 的右侧。两个侧面可以在 *图 12.8* 中看到：
- en: '![Figure 12.8 – Validation in the V-Model'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.8 – V 模型中的验证'
- en: '](img/B17827_12_008.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_008.jpg)'
- en: Figure 12.8 – Validation in the V-Model
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – V 模型中的验证
- en: This model must be combined with risk analysis, which is performed at every
    level of detail. Many documents must be signed during the release phase. This
    leads to a slow waterfall process with long specification, development, and release
    phases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型必须与风险分析结合使用，风险分析在每个细节层级中执行。在发布阶段，许多文档必须签署。这导致了一个缓慢的瀑布流程，包含了较长的规格定义、开发和发布阶段。
- en: 'But the standards are based on good practices – and if your practices are better
    than the ones in the standard, you can justify that in the audits. The standards
    don''t require you to do validation manually, nor do they say anything about the
    time of the phases. The solution is to automate all the validation logic and add
    the approvals as code reviews in the pull requests when you''re modifying the
    tests (shift left). Tests that you cannot automate must be moved to production
    (shift right). This way, you can automate the entire V and run through it multiple
    times a day:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，标准是基于最佳实践的——如果你的实践优于标准中的实践，你可以在审计中为此辩护。标准并没有要求你手动进行验证，也没有涉及阶段的时间要求。解决方案是自动化所有验证逻辑，并在修改测试时将批准作为代码审查添加到拉取请求中（左移）。不能自动化的测试必须转移到生产环境中（右移）。这样，你可以自动化整个
    V 模型并多次执行：
- en: Add or modify a requirement (for example, an issue).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加或修改需求（例如，问题）。
- en: Create a pull request and link it to the issue.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建拉取请求并将其链接到问题。
- en: Modify your system design and architecture in your repository (for example,
    in markdown) or state that no modifications are needed in the pull request.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码库中修改系统设计和架构（例如，在 markdown 中），或在拉取请求中声明无需修改。
- en: Write your unit tests (this is, your software design) and the code to implement.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写你的单元测试（即软件设计）和实现代码。
- en: Write or modify your functions, system, and integration tests.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写或修改你的功能、系统和集成测试。
- en: Have all the necessary roles approve the pull requests and make sure that the
    approvals are stale if new changes are pushed.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有必要的角色都批准拉取请求，并在推送新更改时确保批准是过时的。
- en: Ship your changes to production and run your final tests there.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的更改发布到生产环境并在那里运行最终的测试。
- en: You can also manage your risks as code. This way, you can integrate them into
    your automated process. If not, you can still attach the documents to the issue.
    This way, you have the end-to-end traceability for all your changes, all your
    necessary approvals, and all the validation steps completed. And you can still
    iterate fast and release to production regularly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将风险作为代码进行管理。这样，你就可以将它们集成到自动化流程中。如果不能，你仍然可以将文档附加到问题上。这样，你就能对所有的变更、必要的审批和所有完成的验证步骤进行端到端的可追溯性管理。同时，你仍然可以快速迭代并定期发布到生产环境。
- en: Test management in GitHub
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitHub中的测试管理
- en: Unfortunately, GitHub doesn't have a great way to track your test runs and code
    coverage over time, nor can it help you detect or quarantine flaky tests. You
    can execute your tests as part of your workflow and can signal back the result
    – but for reporting, you have to rely on your test tooling.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，GitHub没有一个很好的方式来跟踪你随时间变化的测试运行和代码覆盖率，也无法帮助你检测或隔离不稳定的测试。你可以将测试作为工作流的一部分来执行，并将结果反馈给系统——但对于报告，你必须依赖你的测试工具。
- en: 'A good solution that integrates well with GitHub is **Testspace** (https://www.testspace.com/).
    It is a SaaS offering and is free for open source projects. It''s easy to set
    up – just install the extension from the marketplace (https://github.com/marketplace/testspace-com),
    select the plan you want, and grant access to your repositories. Then, add the
    following step to your workflow:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个与GitHub很好集成的优秀解决方案是**Testspace**（https://www.testspace.com/）。它是一个SaaS服务，开源项目可以免费使用。设置非常简单——只需从市场安装扩展（https://github.com/marketplace/testspace-com），选择你想要的计划，并授予对你的仓库的访问权限。然后，将以下步骤添加到你的工作流中：
- en: '[PRE0]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If your repository is private, then you must create a token in *Testspace*
    and add it as a secret to that step as well: `token: ${{ secrets.TESTSPACE_TOKEN
    }}`.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你的仓库是私有的，那么你必须在*Testspace*中创建一个令牌，并将其作为机密添加到该步骤中：`token: ${{ secrets.TESTSPACE_TOKEN
    }}`。'
- en: 'Then, you must add a step to push your test and code coverage results to *Testspace*
    after the step that executes the tests. You can use glob syntax to specify files
    in dynamic folders. Make sure that you execute the step, even if an error occurs
    (`if: ''!cancelled()''`):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，你必须添加一个步骤，在执行测试后的步骤中，将你的测试和代码覆盖率结果推送到*Testspace*。你可以使用glob语法来指定动态文件夹中的文件。确保即使发生错误，也能执行该步骤（`if:
    ''!cancelled()''`）：'
- en: '[PRE3]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Testspace* provides reliable detection for flaky tests. It has a *Build Bot*
    that sends you a notification if new results arrive. You can comment on the results
    by answering the email (*see Figure 12.9*):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*Testspace* 提供了可靠的检测来处理不稳定的测试。它有一个*构建机器人*，如果有新的结果到达，它会发送通知给你。你可以通过回复邮件来评论结果（*见图12.9*）：'
- en: '![Figure 12.9 – Notification from Testspace about your build results'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9 – 来自Testspace的构建结果通知'
- en: '](img/B17827_12_009.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_009.jpg)'
- en: Figure 12.9 – Notification from Testspace about your build results
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 – 来自Testspace的构建结果通知
- en: 'It automatically integrates as a check into your pull request (*see Figure
    12.10*):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它会自动集成作为拉取请求中的一个检查（*见图12.10*）：
- en: '![Figure 12.10 – Testspace integrates into your pull request checks'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10 – Testspace集成到你的拉取请求检查中'
- en: '](img/B17827_12_010.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_010.jpg)'
- en: Figure 12.10 – Testspace integrates into your pull request checks
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – Testspace集成到你的拉取请求检查中
- en: 'The UI of *Testpace* doesn''t look very fancy, but it has really rich reports
    and a ton of functionality (*see Figure 12.11*):'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*Testspace* 的用户界面看起来并不特别华丽，但它有非常丰富的报告和大量功能（*见图12.11*）：'
- en: '![Figure 12.11 – Rich reports of your test metrics'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11 – 你的测试指标的丰富报告'
- en: '](img/B17827_12_011.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_12_011.jpg)'
- en: Figure 12.11 – Rich reports of your test metrics
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 你的测试指标的丰富报告
- en: If you don't have a solution for test management yet, you can try *Testspace*.
    If you already have one, then it should be straightforward to integrate it into
    your workflow.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有测试管理解决方案，可以尝试*Testspace*。如果你已经有了，它应该很容易集成到你的工作流中。
- en: Case study
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: The two pilot teams at **Tailwind Gears** have achieved a much higher **delivery
    lead time** and **deployment frequency** thanks to the DevOps practices that have
    been applied. The **mean time to restore** is also much better because the release
    pipelines help ship fixes faster. However, the **change failure rate** has dropped.
    Releasing more frequently also means that more deployments fail and finding bugs
    in the code is hard. The quality signals that come from the automated test suites
    are just not reliable enough and fixing one bug often introduces another bug in
    another module. There are still many parts of the application that need manual
    testing – but with one QA engineer in the team, this was not an option. So, some
    of these parts have been replaced with UI tests, while others have just been dropped.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tailwind Gears**的两个试点团队通过应用DevOps实践，取得了显著提高的**交付前置时间**和**部署频率**。由于发布流水线有助于更快地发布修复，**恢复时间均值**也大大改善。然而，**变更失败率**下降了。更频繁的发布意味着更多的部署会失败，且在代码中找出bug变得更加困难。来自自动化测试套件的质量信号并不可靠，修复一个bug通常会引入另一个模块中的bug。应用程序中仍有许多部分需要手动测试——但由于团队中只有一名QA工程师，这已经不再是一个可行的选项。因此，这些部分中的一些已被UI测试替代，而另一些则被直接丢弃。'
- en: To evaluate the test portfolio, the teams must introduce a test taxonomy and
    include reporting in their pipelines. The QA engineers in the team are responsible
    for the taxonomy and the reports show that there are way too many functional and
    UI tests – and not enough unit tests. Many of the engineers are still not convinced
    that TDD would save them time and that it is possible to develop with TDD in certain
    cases, especially when the team is developing the embedded software. The teams
    decide to book a TDD training session together to learn about and practice TDD.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估测试组合，团队必须引入测试分类法，并在流水线中包括报告。团队中的QA工程师负责分类法，报告显示功能性和UI测试过多，而单元测试不足。许多工程师仍然不相信TDD能够节省时间，也不认为在某些情况下开发嵌入式软件时能够使用TDD。团队决定一起安排一次TDD培训课程，学习并实践TDD。
- en: After that, all the new code is written in TDD with a **code coverage** of 90%
    (at a minimum) for the new code. The teams also spend 30% of their time every
    sprint eradicating **flaky tests** and rewriting tests at a lower level.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，所有新代码都以TDD编写，并要求新代码的**代码覆盖率**至少达到90%。团队还将每个迭代中30%的时间用于消除**不稳定的测试**并重新编写更低层次的测试。
- en: To discover flaky tests, the teams run reliability runs on pipelines with green
    tests. Flaky tests have the highest priority. After that, the team picks the tests
    with the longest execution time and decides what to do for each test. Most of
    the tests get converted into unit tests, though some get converted into integration
    tests. Some of the tests can be deleted as they bring no additional value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发现不稳定的测试，团队在通过绿色测试的流水线上运行可靠性测试。不稳定的测试被优先处理。之后，团队会选择执行时间最长的测试，并决定如何处理每个测试。大多数测试被转换为单元测试，尽管有些被转换为集成测试。有些测试可以被删除，因为它们没有带来额外的价值。
- en: Structured manual tests get replaced completely by **exploratory testing**.
    If anything is found in these sessions, a unit test is created before they're
    fixed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化的手动测试完全被**探索性测试**所替代。如果在这些会话中发现任何问题，会在修复之前创建单元测试。
- en: The team that runs the web application also includes a new test category with
    tests that get executed in production. They implement **application performance
    monitoring** and collect many metrics so that they're aware of the health of the
    application in all environments. They also perform their first BCDR drills once
    per sprint to get started with **testing in production** and **chaos engineering**.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Web应用程序的团队还增加了一种新的测试类别，其中的测试将在生产环境中执行。他们实现了**应用性能监控**并收集了大量的度量，以便了解应用程序在所有环境中的健康状况。团队还在每个迭代中进行一次首次的BCDR演练，开始实施**生产环境中的测试**和**混沌工程**。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to accelerate your software delivery by shifting
    testing to the left via test automation and then to the right with testing in
    production and chaos engineering. This way, you can release at a fast pace without
    making compromises in terms of quality. Finally, you learned how to manage your
    test portfolio, eradicate flaky tests, and make your application more resilient
    by injecting faults and chaos.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学到了如何通过测试自动化将测试向左迁移并加速软件交付，随后通过生产中的测试和混沌工程向右迁移。这样，你就可以以快速的节奏发布，而不必在质量上做出妥协。最后，你学到了如何管理你的测试组合，消除不稳定测试，并通过注入故障和混沌使你的应用程序更加具有韧性。
- en: In the next chapter, you will learn how to shift left security and implement
    DevSecOps practices into your development process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何将安全性向左迁移，并将DevSecOps实践融入你的开发过程。
- en: Further reading
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following references were used in this chapter to help you learn more about
    the topics that were discussed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用了以下参考文献，以帮助你进一步了解讨论过的主题：
- en: 'Forsgren N., Humble, J., & Kim, G. (2018). *Accelerate: The Science of Lean
    Software and DevOps: Building and Scaling High Performing Technology Organizations*
    (1st ed.) [E-book]. IT Revolution Press.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Forsgren N., Humble, J., & Kim, G. (2018). *加速：精益软件和DevOps的科学：构建和扩展高效能技术组织*（第1版）[电子书]。IT革命出版社。
- en: 'Eran Kinsbruner (2018), *Continuous Testing for DevOps Professionals: A Practical
    Guide From Industry Experts* (Kindle Edition). CreateSpace Independent Publishing
    Platform.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Eran Kinsbruner (2018)，*DevOps专业人员的持续测试：来自行业专家的实用指南*（Kindle版）。CreateSpace独立出版平台。
- en: Sam Laing (2015), *The Testing Manifesto*, [https://www.growingagile.co.za/2015/04/the-testing-manifesto/](https://www.growingagile.co.za/2015/04/the-testing-manifesto/).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sam Laing (2015)，*测试宣言*，[https://www.growingagile.co.za/2015/04/the-testing-manifesto/](https://www.growingagile.co.za/2015/04/the-testing-manifesto/)。
- en: 'Wolfgang Platz, Cynthia Dunlop (2019), *Enterprise Continuous Testing: Transforming
    Testing for Agile and DevOps* (Kindle Edition), Independently published.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wolfgang Platz, Cynthia Dunlop (2019)，*企业持续测试：为敏捷和DevOps转型测试*（Kindle版），独立出版。
- en: 'Tilo Linz (2014): *Testing in Scrum* (E-book), Rocky Nook.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tilo Linz (2014)：*Scrum中的测试*（电子书），Rocky Nook。
- en: Kaner C., Falk J., H. Q. Nguyen (1999), *Testing Computer Software* (2nd Edition)
    Wiley.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kaner C., Falk J., H. Q. Nguyen (1999)，*计算机软件测试*（第2版），Wiley。
- en: Roy Osherove (2009), *The Art of Unit Testing* (1st edition), Manning.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Roy Osherove (2009)，*单元测试的艺术*（第1版），Manning。
- en: Martin Fowler (2007), *Mocks Aren't Stubs* [https://martinfowler.com/articles/mocksArentStubs.html](https://martinfowler.com/articles/mocksArentStubs.html).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Martin Fowler (2007)，*模拟对象不是存根* [https://martinfowler.com/articles/mocksArentStubs.html](https://martinfowler.com/articles/mocksArentStubs.html)。
- en: Müller, Matthias M.; Padberg, Frank (2017). *About the Return on Investment
    of Test-Driven Development* (PDF). Universität Karlsruhe, Germany.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Müller, Matthias M.; Padberg, Frank (2017). *关于测试驱动开发的投资回报率*（PDF）。卡尔斯鲁厄大学，德国。
- en: Erdogmus, Hakan; Morisio, Torchiano (2014). *On the Effectiveness of Test-first
    Approach to Programming*. Proceedings of the IEEE Transactions on Software Engineering,
    31(1). January 2005\. (NRC 47445).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Erdogmus, Hakan; Morisio, Torchiano (2014)。*测试优先方法对编程的有效性*。IEEE软件工程学报，31(1)，2005年1月。（NRC
    47445）。
- en: '*Shift left to make testing fast and reliable*: https://docs.microsoft.com/en-us/devops/develop/shift-left-make-testing-fast-reliable.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将测试向左迁移，使测试快速且可靠*：https://docs.microsoft.com/en-us/devops/develop/shift-left-make-testing-fast-reliable。'
- en: Martin Fowler (2011), *Eradicating Non-Determinism in Tests*, [https://martinfowler.com/articles/nonDeterminism.html](https://martinfowler.com/articles/nonDeterminism.html).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Martin Fowler (2011)，*消除测试中的非确定性*，[https://martinfowler.com/articles/nonDeterminism.html](https://martinfowler.com/articles/nonDeterminism.html)。
- en: Jordan Raine (2020). *Reducing flaky builds by 18x*. [https://github.blog/2020-12-16-reducing-flaky-builds-by-18x/](https://github.blog/2020-12-16-reducing-flaky-builds-by-18x/).
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jordan Raine (2020). *将不稳定的构建减少18倍*。[https://github.blog/2020-12-16-reducing-flaky-builds-by-18x/](https://github.blog/2020-12-16-reducing-flaky-builds-by-18x/)。
- en: John Micco (2016). *Flaky Tests at Google and How We Mitigate Them*. [https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html](https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: John Micco (2016). *Google中的不稳定测试及其缓解方法*。[https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html](https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html)。
- en: '*Shift right to test in production*: [https://docs.microsoft.com/en-us/devops/deliver/shift-right-test-production](https://docs.microsoft.com/en-us/devops/deliver/shift-right-test-production).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*右移测试到生产环境*：[https://docs.microsoft.com/en-us/devops/deliver/shift-right-test-production](https://docs.microsoft.com/en-us/devops/deliver/shift-right-test-production)。'
- en: Michael Nygard (2018). *Release It! Design and Deploy Production-Ready Software*
    (2nd Edition). O'Reilly.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Michael Nygard（2018）。*发布它！设计与部署生产就绪的软件*（第二版）。O'Reilly。
