- en: 'Chapter 10: Automating Workflows with GitHub Actions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章：使用 GitHub Actions 自动化工作流
- en: Have you ever been part of a project that required the completion of routine,
    monotonous tasks? Have you ever sat down to release software and read over the
    project wiki page, only to find 15 manual steps that you needed to cut, paste,
    and pray? What did it feel like when it was your turn to complete those tasks?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾参与过一个需要完成例行、单调任务的项目？你是否曾坐下来发布软件，阅读项目的 wiki 页面，却发现需要执行 15 个手动步骤，复制、粘贴并祈祷？当轮到你完成这些任务时，感觉如何？
- en: Tasks such as these are referred to as **toil** – *slow* and *difficult*. This
    kind of work reduces our teams' development velocity and, just as critically,
    grinds away the morale of the DevOps or **Site-Reliability Engineering** (**SRE**)
    team over time. Toilsome tasks are manual, and by their nature, manual tasks are
    error-prone. If we don't try to replace these tasks with appropriate automation,
    more will accumulate, worsening the situation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的任务被称为 **繁重工作** —— *缓慢* 和 *困难*。这种工作会降低我们团队的开发速度，而且更为关键的是，随着时间的推移，它会消磨 DevOps
    或 **站点可靠性工程** (**SRE**) 团队的士气。繁重任务是手动的，手动任务天生容易出错。如果我们不试图用适当的自动化来替换这些任务，更多的繁重工作将会积累，情况会变得更糟。
- en: As a DevOps engineer, you are the anti-entropy force driving automation and
    reducing toilsome work. In this chapter, we will learn how to use GitHub Actions
    to automate workflows to reduce toil and increase project velocity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名 DevOps 工程师，你是驱动自动化并减少繁重工作的反熵力量。在本章中，我们将学习如何使用 GitHub Actions 来自动化工作流，以减少繁重工作并提高项目速度。
- en: GitHub Actions provides a powerful platform for creating customizable automation
    workflows and is free for any open source project. GitHub Actions pairs a robust,
    customizable workflow engine with an equally powerful event model to trigger automation.
    The patterns and practices used in this chapter will leverage GitHub Actions but
    are transferable to many other developer workflow automation tools such as Jenkins
    and GitLab CI. The choice to use GitHub Actions is driven by the ubiquitous access
    for open source developers and the access to a wide community of contributed actions
    that amplify productivity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 提供了一个强大的平台，用于创建可定制的自动化工作流，并且对于任何开源项目都是免费的。GitHub Actions 将强大、可定制的工作流引擎与同样强大的事件模型结合，触发自动化。本章中使用的模式和实践将利用
    GitHub Actions，但也可以转移到许多其他开发者工作流自动化工具，如 Jenkins 和 GitLab CI。选择使用 GitHub Actions
    的原因是它为开源开发者提供了普遍的访问权限，并且能够接触到广泛的社区贡献的 Actions，极大提升了生产力。
- en: In this chapter, you will start off by learning the basics of GitHub Actions.
    You will use these skills to build a continuous integration workflow to validate
    a pull request. Then, you will extend the workflow to add release automation to
    publish GitHub releases. Finally, you will build your own custom GitHub Action
    using Go and publish it to GitHub Marketplace.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将从学习 GitHub Actions 的基础知识开始。你将运用这些技能构建一个持续集成工作流，用于验证拉取请求。然后，你将扩展该工作流，添加发布自动化以发布
    GitHub 版本。最后，你将使用 Go 构建自己的自定义 GitHub Action，并将其发布到 GitHub Marketplace。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the basics of GitHub Actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 GitHub Actions 的基础知识
- en: Building a continuous integration workflow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建持续集成工作流
- en: Building a release workflow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建发布工作流
- en: Creating a custom GitHub Action using Go
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 创建自定义 GitHub Action
- en: Publishing a custom Go GitHub Action
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布自定义 Go GitHub Action
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, you need to have Docker, Git, and the Go tools installed on
    your machine. The code for this chapter is located at [https://github.com/PacktPublishing/B18275-09-Automating-Workflows-with-GitHub-Actions-Code-Files](https://github.com/PacktPublishing/B18275-09-Automating-Workflows-with-GitHub-Actions-Code-Files).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你需要在计算机上安装 Docker、Git 和 Go 工具。本章的代码位于 [https://github.com/PacktPublishing/B18275-09-Automating-Workflows-with-GitHub-Actions-Code-Files](https://github.com/PacktPublishing/B18275-09-Automating-Workflows-with-GitHub-Actions-Code-Files)。
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/10](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/10)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以从 [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/10](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/10)
    下载。
- en: Let's get started building our first GitHub Action.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建我们的第一个 GitHub Action。
- en: Understanding the basics of GitHub Actions
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 GitHub Actions 的基础知识
- en: GitHub Actions are event-driven automation tasks that live within a GitHub repository.
    An event like a pull request can trigger a set of tasks to be executed. An example
    is a pull request triggering a set of tasks to clone the Git repository and execute
    `go test` to run Go tests.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 是事件驱动的自动化任务，存在于 GitHub 仓库中。像拉取请求这样的事件可以触发一组任务的执行。一个示例是拉取请求触发一组任务来克隆
    Git 仓库并执行 `go test` 来运行 Go 测试。
- en: GitHub Actions is extremely flexible, enabling developers to author a wide variety
    of automations, even some that you might not normally associate with a traditional
    continuous integration/release pipeline. Actions are also composable, enabling
    groups of tasks to be packaged together as a published action and used in workflows
    together with other actions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 极为灵活，使开发者能够编写各种自动化任务，甚至是一些你通常不会与传统的持续集成/发布管道联系在一起的自动化。Actions
    也具有可组合性，使得任务组可以作为已发布的 Action 打包在一起，并与其他 Actions 一起用于工作流。
- en: 'In this section, you will learn about the components of a GitHub Action: workflows,
    events, context and expressions, jobs, steps, and actions. After you have been
    introduced to these components, we''ll build and trigger our first GitHub Action.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解 GitHub Action 的组成部分：工作流、事件、上下文和表达式、作业、步骤以及动作。在介绍这些组件后，我们将构建并触发我们的第一个
    GitHub Action。
- en: Exploring the components of a GitHub Action
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 GitHub Action 的组成部分
- en: Understanding the components of a GitHub Action, their relationships, and how
    they interact is the key to understanding how to compose your own automation.
    Let's get started with exploring the components of an action.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 GitHub Action 的组成部分、它们之间的关系，以及它们如何交互，是理解如何编写自己的自动化的关键。让我们从探索 Action 的组成部分开始。
- en: Workflows
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作流
- en: A workflow is an automation file written in YAML that lives in a GitHub repository
    in the `./github/workflows/` folder. A workflow consists of one or more jobs and
    can be scheduled or triggered by an event. A workflow is the highest-level component
    of a GitHub Action.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流是一个以 YAML 编写的自动化文件，存放在 GitHub 仓库的 `./github/workflows/` 文件夹中。一个工作流由一个或多个作业组成，可以按计划或通过事件触发。工作流是
    GitHub Action 的最高级别组件。
- en: Workflow syntax
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作流语法
- en: Workflows require a developer to specify the events that will trigger automation
    via the `on` key and the jobs that automation will execute when it is triggered
    by the `jobs` key. Often, a name is also specified by the `name` keyword. Otherwise,
    the workflow will take the short name of the file that contains the workflow YAML.
    For example, the workflow defined in `./github/workflows/foo.yaml` will have the
    default name of `foo`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流需要开发者通过 `on` 键指定触发自动化的事件，并通过 `jobs` 键指定自动化触发后执行的作业。通常，`name` 关键字还会指定一个名称，否则，工作流将使用包含工作流
    YAML 文件的短名称。例如，在 `./github/workflows/foo.yaml` 中定义的工作流将默认名称为 `foo`。
- en: An example of a workflow structure
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作流结构的示例
- en: 'The following is an example of a named workflow with the minimum set of keys
    defined. However, this is not a valid workflow, as we have not yet defined any
    events to trigger the workflow, nor any jobs to be executed once triggered:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个命名工作流的示例，定义了最小的键集。但是，这不是一个有效的工作流，因为我们还没有定义任何触发工作流的事件，也没有定义任何在触发后执行的作业：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, let's discuss how to trigger workflows.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何触发工作流。
- en: Events
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件
- en: 'An event is a trigger that causes a workflow to start executing. Events come
    in a variety of flavors: webhook events, scheduled events, and manually dispatched
    events.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是一个触发器，它使工作流开始执行。事件有多种类型：Webhook 事件、定时事件和手动触发事件。
- en: Webhook events can originate from an activity within the repository. Examples
    of triggering activities are pushing a commit, creating a pull request, or creating
    a new issue. Events raised from repository interactions are the most common triggers
    for workflows. Webhook events can also be created through external systems and
    relayed to GitHub through the repository dispatch Webhook.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook 事件可以来自仓库中的活动。例如，触发活动包括提交推送、创建拉取请求或创建新问题。来自仓库交互的事件是工作流最常见的触发器。Webhook
    事件也可以通过外部系统创建，并通过仓库调度 Webhook 转发到 GitHub。
- en: Scheduled events are similar to cron jobs. These events trigger workflows on
    a defined schedule. Schedule events are a way to automate repetitive tasks, such
    as performing issue maintenance on older issues in GitHub or running a nightly
    reporting job.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 定时事件类似于 cron 作业。这些事件会在定义的时间表上触发工作流。定时事件是自动化重复性任务的一种方式，例如，在 GitHub 上执行旧问题的维护或运行夜间报告作业。
- en: Manual dispatch events are not triggered through repository activities but rather
    manually. For example, a project may have a Twitter account associated with it,
    and project maintainers may want to be able to send a tweet about a new feature
    but do not want to share the Twitter authentication secrets. An ad hoc event would
    enable automation to send out the tweet on behalf of the project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 手动调度事件并非通过仓库活动触发，而是手动触发。例如，一个项目可能与其Twitter账户关联，项目维护者可能希望能够发送一条关于新功能的推文，但又不希望共享Twitter的认证密钥。一个临时事件将使得自动化可以代表项目发送推文。
- en: Event syntax
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事件语法
- en: Events require a developer to specify the type of events for the `on:` key in
    the workflow. Event types generally have child key-value pairs that define their
    behavior.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 事件要求开发者为`on:`键指定事件类型。事件类型通常具有子键值对，用于定义其行为。
- en: A single event example
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单个事件示例
- en: 'A single event can be specified to trigger automation:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定一个事件来触发自动化：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A multiple events example
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多个事件示例
- en: 'Multiple events can be specified to trigger automation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定多个事件来触发自动化：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A scheduled event example
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定时事件示例
- en: 'Scheduled event schedules are specified using **Portable Operating System Interface**
    (**POSIX**) cron syntax:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 定时事件调度使用**便携式操作系统接口**（**POSIX**）的cron语法：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A manual event example
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 手动事件示例
- en: 'Manual events are triggered through user interaction and can include input
    fields:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 手动事件通过用户交互触发，并且可以包括输入字段：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Context and expressions
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文和表达式
- en: GitHub Actions exposes a rich set of context variables, expressions, functions,
    and conditionals to provide expressiveness in your workflows. This will not be
    an exhaustive study of all of these items, but we will highlight the most critical
    items.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 提供了一组丰富的上下文变量、表达式、函数和条件语句，用以增强工作流的表现力。这将不是对所有这些项的详尽研究，但我们将重点介绍最关键的内容。
- en: Context variables
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 上下文变量
- en: Context variables provide a way to access information about workflow runs, environment,
    steps, secrets, and so on. The most common context variables are `github`, `env`,
    `secrets`, and `matrix`. These variables are treated as maps and can be indexed
    using variable names and property names. For example, `env['foo']` resolves to
    the value of the `foo` environment key.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文变量提供了一种访问工作流运行、环境、步骤、密钥等信息的方式。最常见的上下文变量有`github`、`env`、`secrets`和`matrix`。这些变量被视为映射，可以通过变量名和属性名进行索引。例如，`env['foo']`解析为`foo`环境键的值。
- en: The `github` context variable provides information about the workflow run and
    contains information such as the `ref` that the workflow is executing on. This
    is useful if you would like to use that information to inject a version into an
    application at build time. You can access this information by indexing the `github`
    variable with `github['ref']` or `github.ref`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`github`上下文变量提供关于工作流运行的信息，包含如工作流正在执行的`ref`等信息。如果你希望在构建时将该信息注入到应用程序中，这非常有用。你可以通过使用`github[''ref'']`或`github.ref`来访问这些信息。'
- en: The `env` context variable contains environment variables specified for the
    workflow run. The values can be accessed by using the index syntax.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`env`上下文变量包含为工作流运行指定的环境变量。这些值可以通过索引语法进行访问。'
- en: The `secrets` context variable contains the secrets available for the workflow
    run. These values can also be accessed by the index syntax. Note that these values
    will be redacted in the logs, so the secret values will not be exposed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`secrets`上下文变量包含工作流运行中可用的密钥。这些值也可以通过索引语法进行访问。注意，这些值在日志中会被隐藏，因此密钥值不会暴露。'
- en: The `matrix` context variable contains information about the matrix parameters
    you configure for the current job. For example, if you want to run a build on
    multiple operating systems with multiple versions of Go, the matrix variable allows
    you to specify the list of each one, which can be used to execute a set of concurrent
    job executions using each combination of operating system and Go version. We will
    go into more detail about this when we talk about jobs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix`上下文变量包含你为当前任务配置的矩阵参数信息。例如，如果你希望在多个操作系统上运行构建并使用多个版本的Go，`matrix`变量允许你指定每一个操作系统和Go版本的列表，这可以用于执行一组并行任务，使用每一种操作系统和Go版本的组合。我们将在讨论任务时更详细地介绍这一点。'
- en: Expressions
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表达式
- en: 'The syntax used for an expression is `${{ expression }}`. Expressions consist
    of variables, literals, operators, and functions. Let''s examine the following
    example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的语法是`${{ expression }}`。表达式由变量、字面量、运算符和函数组成。我们来看下面的示例：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding job will only execute if the pull request is labeled with `safe
    to test`. The `if` conditional will evaluate the `github.event.pull_request.labels.*.name`
    context variable and verify that one of the labels on the pull request is named
    `safe to test`. This is useful if you want to ensure that a workflow only executes
    after a repository maintainer has had an opportunity to verify that the pull request
    is safe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前述任务仅会在拉取请求被标记为`safe to test`时执行。`if`条件将评估`github.event.pull_request.labels.*.name`上下文变量，并确认拉取请求上的标签中是否有一个名为`safe
    to test`的标签。如果你想确保工作流只在仓库维护者确认拉取请求是安全的后才执行，这非常有用。
- en: 'Expressions can also be used as input. Let''s examine the following example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式也可以用作输入。我们来看下面的示例：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The snippet of YAML shows how to set an environment variable called `GIT_SHA`
    to the value of the `github.sha` context variable. The `GIT_SHA` environment variable
    will now be available to all actions running within the job. Using context variables
    for input is useful for customizing the execution of scripts or actions executed
    in a workflow.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YAML片段展示了如何将名为`GIT_SHA`的环境变量设置为`github.sha`上下文变量的值。现在，`GIT_SHA`环境变量将对所有在任务内运行的操作可用。使用上下文变量作为输入对于定制在工作流中执行的脚本或操作非常有用。
- en: Jobs
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 任务
- en: A job is a collection of steps that run on an individual compute instance, or
    runner. You can think of a runner as a virtual machine for running your job. Jobs,
    by default, execute concurrently, so if a workflow defines multiple jobs, they
    will execute concurrently if enough runners are available. Jobs have the concept
    of dependency where a job can be dependent on another job, which will ensure the
    jobs execute sequentially rather than concurrently.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一个任务是执行一组步骤的集合，这些步骤在一个独立的计算实例或运行器上运行。你可以将运行器视为运行任务的虚拟机。任务默认是并行执行的，因此如果工作流定义了多个任务，并且有足够的运行器可用，它们将并行执行。任务有依赖关系的概念，一个任务可以依赖于另一个任务，这样可以确保任务按顺序执行，而不是并行执行。
- en: Job syntax
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 任务语法
- en: Jobs require a developer to specify an ID of the job, the type of runner the
    job will execute on using the `runs-on:` key, and a sequence of steps the job
    will execute using the `steps:` key. The `runs-on:` key is particularly interesting
    to us, as it is useful for executing a job on different **operating system** (**OS**)
    platforms such as multiple versions of Ubuntu, macOS, and Windows.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任务要求开发者指定任务的ID、任务将在其上执行的运行器类型（通过`runs-on:`键），以及任务将执行的一系列步骤（通过`steps:`键）。`runs-on:`键对我们特别重要，因为它用于在不同的**操作系统**（**OS**）平台上执行任务，例如多个版本的Ubuntu、macOS和Windows。
- en: With the `runs-on:` key, a job is able to run on a specified platform, but that
    does not allow us to make a matrix of jobs to run on multiple platforms concurrently.
    To enable a job to execute in a matrix of configurations, one must use the `strategy:`
    key and expressions. By configuring the strategy, we can build a matrix of jobs
    executing the same job configuration. You will find an example of this configuration
    in the following example.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`runs-on:`键，可以让任务在指定平台上运行，但这并不能让我们创建一个任务矩阵来在多个平台上并行执行。为了使任务在配置矩阵中执行，必须使用`strategy:`键和表达式。通过配置策略，我们可以构建一个执行相同任务配置的任务矩阵。你将在下面的示例中看到这种配置的例子。
- en: There are many other options to customize the execution of the job and the environment
    that the job executes within, but we will not dive deeply into them.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他选项可以定制任务的执行以及任务执行的环境，但我们不会深入探讨这些选项。
- en: Executing jobs on multiple platforms
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在多个平台上执行任务
- en: 'This example shows two jobs named `job_one` and `job_two`. Here, `job_one`
    is a matrix job that will run six concurrent templated jobs on the latest versions
    of Ubuntu, macOS, and Windows, which will each echo `1.17` and `1.16`. Running
    on Ubuntu 18.04, `job_two` will run concurrently with `job_one` and echo `"hello
    world!"`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了两个名为`job_one`和`job_two`的任务。在这里，`job_one`是一个矩阵任务，它将在Ubuntu、macOS和Windows的最新版本上并行运行六个模板化任务，每个任务都会回显`1.17`和`1.16`。在Ubuntu
    18.04上，`job_two`将与`job_one`并行运行，并回显`"hello world!"`：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Steps
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤
- en: Steps are tasks that run in the context of a job and execute in the context
    of the job's associated runner. Steps can consist of a shell command or an action.
    Since steps execute in the same runner, they can share data between each of the
    steps. For example, if you create a file on the filesystem of the runner in a
    previous step, subsequent steps will be able to access that file. You can think
    of a step running within its own process and that any changes to environment variables
    will not carry over to the next step.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤是在作业上下文中运行的任务，并在与该作业关联的运行器上下文中执行。步骤可以是一个 shell 命令或一个动作。由于步骤在同一个运行器中执行，它们可以共享数据。例如，如果你在前一个步骤中在运行器的文件系统上创建了一个文件，那么后续步骤将能够访问该文件。你可以将一个步骤看作是在它自己的进程中运行，且任何环境变量的更改都不会传递到下一个步骤。
- en: Steps syntax
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步骤语法
- en: Steps require a developer to specify an action with the `uses:` key or specify
    the shell commands to run with the `run:` key. Optional input allows you to customize
    the environment variables using the `env:` key and the working directory using
    the `working-directory:` key, and also to change the name that appears in the
    GitHub user interface for the step by using the `name` key. There are a wide variety
    of other options to customize the execution of steps, but we will not go into
    great depth about these.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤要求开发者使用 `uses:` 键来指定一个动作，或使用 `run:` 键来指定要运行的 shell 命令。可选的输入允许你使用 `env:` 键自定义环境变量，使用
    `working-directory:` 键自定义工作目录，也可以通过使用 `name` 键更改在 GitHub 用户界面中显示的步骤名称。还有许多其他选项可以定制步骤的执行方式，但我们不会深入讨论这些选项。
- en: Step for installing Go using an action
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用动作安装 Go 的步骤
- en: 'This example shows a step with no name that uses the v2 version of `actions/setup-go`
    to install version 1.17.0 or higher of Go. This action can be found at [https://github.com/actions/setup-go](https://github.com/actions/setup-go).
    This is a great example of a publicly available action that you can use to add
    functionality to your automation. You can find actions for nearly any task at
    [https://github.com/marketplace?type=actions](https://github.com/marketplace?type=actions).
    In a later section, we''ll discuss how to build your own action and publish it
    to the GitHub Marketplace:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了一个没有名称的步骤，使用 `actions/setup-go` 的 v2 版本来安装 Go 版本 1.17.0 或更高版本。这个动作可以在
    [https://github.com/actions/setup-go](https://github.com/actions/setup-go) 找到。这个示例很好地展示了一个公开可用的动作，你可以用它为你的自动化添加功能。你可以在
    [https://github.com/marketplace?type=actions](https://github.com/marketplace?type=actions)
    上找到几乎任何任务的动作。在后面的章节中，我们将讨论如何构建你自己的动作并将其发布到 GitHub 市场：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A step with a multiple line command
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 含有多行命令的步骤
- en: 'In this example, we''ve extended the previous one and added a `Run go mod download
    and test` step that runs the `go` tool, which was installed by `actions/setup-go@v2`.
    The run command uses `|` in the first line to indicate the start of a multiline
    string in YAML:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们扩展了前面的示例，新增了一个 `Run go mod download and test` 步骤，它运行 `go` 工具，而这个工具是通过
    `actions/setup-go@v2` 安装的。运行命令的第一行使用 `|` 来表示 YAML 中多行字符串的开始：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Actions
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动作
- en: An action is a reusable combination of a set of steps formed into a single command,
    which can also have input and output. For example, the `actions/setup-go` action
    is used to execute a series of steps to install a version of Go on a runner. The
    Go toolchain can then be used within subsequent steps within the same job.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动作是由一组步骤组合而成的可重用命令，这些步骤可以有输入和输出。例如，`actions/setup-go` 动作用于执行一系列步骤，在运行器上安装
    Go 的某个版本。然后，Go 工具链可以在同一作业中的后续步骤中使用。
- en: GitHub Actions is aptly named, as actions are the superpower of GitHub Actions.
    Actions are often published publicly and enable developers to leverage existing
    recipes to build complex automation quickly. Actions are similar to open source
    Go libraries, which enable developers to build Go applications quicker. As we
    build our own actions, you will quickly see the power of this feature.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 名字起得很恰当，因为动作是 GitHub Actions 的超级功能。动作通常是公开发布的，允许开发者利用现有的方案来快速构建复杂的自动化。动作类似于开源的
    Go 库，帮助开发者更快地构建 Go 应用。当我们构建自己的动作时，你会很快看到这个功能的强大之处。
- en: If you are interested in seeing the source code for `actions/setup-go`, visit
    [https://github.com/actions/setup-go](https://github.com/actions/setup-go). Later
    in this chapter, we will build our own Go action and publish it to the GitHub
    Marketplace.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣查看 `actions/setup-go` 的源代码，请访问 [https://github.com/actions/setup-go](https://github.com/actions/setup-go)。在本章后面，我们将构建自己的
    Go 动作并将其发布到 GitHub 市场。
- en: How to build and trigger your first GitHub Action
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何构建和触发你的第一个 GitHub Action
- en: Now that we have a general understanding of what the components of an action
    are, let's build one and explore how the components are structured and interact.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们大致了解了 Action 的组成部分，接下来让我们创建一个并探索这些组件如何构建、结构化及相互作用。
- en: Creating and cloning a GitHub repository
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建并克隆 GitHub 仓库
- en: 'If this is your first time creating and cloning a repository, you may find
    the following links useful:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次创建和克隆一个代码库，你可以参考以下链接：
- en: '[https://docs.github.com/en/get-started/quickstart/create-a-repo](https://docs.github.com/en/get-started/quickstart/create-a-repo)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.github.com/en/get-started/quickstart/create-a-repo](https://docs.github.com/en/get-started/quickstart/create-a-repo)'
- en: '[https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository-from-github/cloning-a-repository](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository-from-github/cloning-a-repository)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository-from-github/cloning-a-repository](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/cloning-a-repository-from-github/cloning-a-repository)'
- en: 'When creating the repository, I normally add `README.md`, `.gitignore`, and
    an **Massachusetts Institute of Technology** (**MIT**) license file. Once you
    have created and cloned your repository, you should have a local directory for
    your project, as shown in the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建仓库时，我通常会添加 `README.md`、`.gitignore` 和一个**麻省理工学院**（**MIT**）许可证文件。一旦你创建并克隆了仓库，你应该会有一个本地项目目录，如下所示：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating your first workflow
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建你的第一个工作流
- en: 'Remember that workflows live in the `.github/workflows` directory. The first
    step is to create that directory. The next step is to create the workflow file
    within the `.github/workflows` directory:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，工作流文件存放在 `.github/workflows` 目录中。第一步是创建该目录。下一步是在 `.github/workflows` 目录中创建工作流文件：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Open `.github/workflows/first.yaml` in your favorite editor and add the following
    workflow YAML:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `.github/workflows/first.yaml` 文件，使用你喜欢的编辑器，并添加以下工作流 YAML：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding workflow is named `first-workflow`. It will execute a single job
    called `echo` on the latest version of Ubuntu and execute a single step that will
    echo `hello world!` using the system's default shell. You can also specify the
    shell you would like with the `shell:` key.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述工作流名为 `first-workflow`。它将在最新版本的 Ubuntu 上执行一个名为 `echo` 的单一作业，并执行一个步骤，使用系统默认的
    shell 输出 `hello world!`。你还可以通过 `shell:` 键指定你想要使用的 shell。
- en: 'Save `.github/workflows/first.yaml`. Commit and push the workflow to GitHub:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 保存 `.github/workflows/first.yaml`。提交并将工作流推送到 GitHub：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Normally, you'd create a branch first and then open a pull request before committing
    and pushing directly to the main branch, but for your first workflow, this will
    be the quickest way to see your results.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会先创建一个分支，然后打开一个拉取请求（pull request），而不是直接提交和推送到主分支。但对于你的第一个工作流，这是查看结果的最快方法。
- en: 'After you push your commit, you should be able to open your GitHub repository
    in your browser and click on the **Actions** tab. You should be greeted with a
    view of your first workflow having successfully executed. It should look like
    the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当你推送完提交后，你应该能够在浏览器中打开你的 GitHub 仓库并点击**Actions**选项卡。你应该看到你的第一个工作流成功执行的视图。它应当类似如下：
- en: '![Figure 10.1 – The All workflows view'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1 – 所有工作流视图'
- en: '](img/B17626_10_001.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_001.jpg)'
- en: Figure 10.1 – The All workflows view
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 所有工作流视图
- en: Note the list of workflows on the left and that there is one workflow named
    **first-workflow**. We can see that the first run of the workflow was for our
    commit with the **my first action** message.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意左侧的工作流列表，里面有一个名为**first-workflow**的工作流。我们可以看到，该工作流的第一次运行是针对我们的提交，提交信息为**my
    first action**。
- en: 'If you click on the workflow run for **my first action**, you should see the
    following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**my first action**的工作流运行记录，你应该能看到如下内容：
- en: '![Figure 10.2 – The workflow job view'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – 工作流作业视图'
- en: '](img/B17626_10_002.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_002.jpg)'
- en: Figure 10.2 – The workflow job view
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 工作流作业视图
- en: Note the **Jobs** list on the left with the **echo** job marked with a green
    check, signifying the successful execution of the job. On the right, you can see
    the details of the execution.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意左侧的**Jobs**列表中，**echo**作业旁边有一个绿色的勾，表示该作业已成功执行。在右侧，你可以看到执行的详细信息。
- en: 'You can click on the **echo** job to see output from it and the steps that
    were executed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击**echo**作业，查看它的输出以及执行的步骤：
- en: '![Figure 10.3 – The echo job output view'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – echo 作业输出视图'
- en: '](img/B17626_10_003.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_003.jpg)'
- en: Figure 10.3 – The echo job output view
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – echo 作业输出视图
- en: Note the job setup, which provides details about the runner and the environment
    the job executed within. Also, note the `echo 'Hello World!'` single shell command
    and echoed the `"Hello World!"` string to the console log. Finally, the job completed
    successfully due to `echo step` returning a `0` error code upon completion.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意作业设置，它提供了关于执行作业的 runner 和环境的详细信息。同时，注意到 `echo 'Hello World!'` 这一单一 shell 命令，并将
    `"Hello World!"` 字符串输出到控制台日志。最后，作业成功完成，因为 `echo step` 在完成时返回了 `0` 错误码。
- en: In this section, you have learned the basics of GitHub Actions and created your
    first simple automation. You now have the tools needed to start building more
    complex automation that will eliminate the toilsome tasks we discussed earlier
    in the chapter. In the upcoming sections, you will learn how to use these skills
    to build continuous integration and release workflows and, later, your own custom
    action written in Go.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已学会了 GitHub Actions 的基础知识，并创建了你的第一个简单自动化。现在，你具备了开始构建更复杂自动化所需的工具，这些自动化将消除我们在本章早些时候讨论的繁琐任务。在接下来的章节中，你将学会如何利用这些技能构建持续集成和发布工作流，之后还将学会如何编写自己用
    Go 编写的自定义操作。
- en: Building a continuous integration workflow
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建持续集成工作流
- en: In this section, we will use GitHub Actions to execute continuous integration
    automation when a pull request is opened or when code is pushed to a repository.
    If you are unfamiliar with continuous integration, it is the practice of automating
    the integration of code changes from multiple contributors into a code repository.
    Continuous integration automation tasks include cloning the repository at a specific
    commit, linting, building, and testing code, and evaluating changes to test coverage.
    The goal of continuous integration automation is to provide a guard against code
    changes that will lower the quality of a project or violate the rules codified
    in automation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 GitHub Actions 执行持续集成自动化，当拉取请求被打开或代码被推送到仓库时。如果你不熟悉持续集成，它是指将来自多个贡献者的代码变更自动集成到代码仓库中的实践。持续集成自动化任务包括在特定提交时克隆仓库、代码检查、构建和测试代码，并评估测试覆盖率的变化。持续集成自动化的目标是防止代码变更降低项目质量或违反自动化中规定的规则。
- en: In this section, you will learn how to create a continuous integration workflow.
    In your continuous integration workflow, you will learn to execute jobs across
    multiple operating systems concurrently. You will install build tools onto the
    job executors, which you will use to build the software project. You will clone
    the source code for the project using an action. Finally, you will enforce passing
    tests and code quality by running a code linter and executing unit tests.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何创建持续集成工作流。在你的持续集成工作流中，你将学会如何在多个操作系统之间并行执行任务。你将把构建工具安装到工作执行器上，用于构建软件项目。你将使用一个操作来克隆项目的源代码。最后，你将通过运行代码检查工具和执行单元测试来确保测试通过并保持代码质量。
- en: Introducing the tweeter command-line tool
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 tweeter 命令行工具
- en: You cannot have a continuous integration workflow without a software project
    to run the workflow upon. We will be using a simple Go command-line tool called
    **tweeter**. The source code for the project can be found at [https://github.com/PacktPublishing/B18275-08-Automating-Workflows-with-GitHub-Actions-Code-Files](https://github.com/PacktPublishing/B18275-08-Automating-Workflows-with-GitHub-Actions-Code-Files).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能没有软件项目就创建持续集成工作流。我们将使用一个简单的 Go 命令行工具，名为 **tweeter**。该项目的源代码可以在 [https://github.com/PacktPublishing/B18275-08-Automating-Workflows-with-GitHub-Actions-Code-Files](https://github.com/PacktPublishing/B18275-08-Automating-Workflows-with-GitHub-Actions-Code-Files)
    找到。
- en: Tweeter is a simple Go command-line tool that will send tweets to Twitter. The
    source code consists of two packages, `main` and `tweeter`. The `tweeter` package
    contains Go tests that will be executed by our continuous integration workflow.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Tweeter 是一个简单的 Go 命令行工具，它会向 Twitter 发送推文。源代码由两个包组成，`main` 和 `tweeter`。`tweeter`
    包包含将由我们的持续集成工作流执行的 Go 测试。
- en: Cloning and testing tweeter
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 克隆并测试 tweeter
- en: 'Create a new repository from the template at [https://github.com/PacktPublishing/B18275-08-Automating-Workflows-with-GitHub-Actions-Code-Files](https://github.com/PacktPublishing/B18275-08-Automating-Workflows-with-GitHub-Actions-Code-Files)
    by clicking the `{your-account}` with your account name):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从模板创建一个新的仓库：[https://github.com/PacktPublishing/B18275-08-Automating-Workflows-with-GitHub-Actions-Code-Files](https://github.com/PacktPublishing/B18275-08-Automating-Workflows-with-GitHub-Actions-Code-Files)，点击
    `{your-account}` 并用你的账户名创建：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Executing `tweeter` with the `-h` argument will provide usage documentation:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 执行` tweeter`命令并带上`-h`参数将提供使用文档：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Twitter usage is not required
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要求使用Twitter
- en: If you are not inclined to use social media, tweeter also allows users to simulate
    sending a tweet. When `--dryRun` is specified, the message value will be output
    to `STDOUT`, rather than being sent to Twitter as a tweet.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不倾向于使用社交媒体，tweeter 也允许用户模拟发送推文。当指定`--dryRun`时，消息内容将输出到`STDOUT`，而不是作为推文发送到
    Twitter。
- en: Next, we will build a continuous integration workflow to test tweeter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建一个持续集成工作流来测试tweeter。
- en: Goals of the tweeter continuous integration workflow
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tweeter持续集成工作流的目标
- en: 'Before building a continuous integration workflow, you should consider what
    you want to accomplish with the workflow. For the tweeter workflow, our goals
    are the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建持续集成工作流之前，您应考虑希望通过工作流实现什么。对于tweeter工作流，我们的目标如下：
- en: Trigger on pushes to `main` and tags formatted as a semantic version – for example,
    `v1.2.3` must build and validate.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在推送到`main`分支和格式化为语义版本的标签（例如`v1.2.3`）时触发工作流，进行构建和验证。
- en: Pull requests against the `main` branch must build and validate.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对`main`分支的拉取请求必须进行构建和验证。
- en: Tweeter must build and validate on Ubuntu, macOS, and Windows concurrently.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tweeter必须同时在Ubuntu、macOS和Windows上进行构建和验证。
- en: Tweeter must build and validate using Go 1.16 and 1.17 concurrently.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tweeter必须同时使用Go 1.16和1.17进行构建和验证。
- en: Tweeter source code must pass a code-linting quality check.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tweeter源代码必须通过代码风格检查。
- en: Continuous integration workflow for tweeter
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tweeter的持续集成工作流
- en: 'With our goals for the tweeter continuous integration workflow specified, we
    can construct a workflow to achieve those goals. The following is a continuous
    integration workflow that achieves each goal:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们确定了tweeter持续集成工作流的目标后，我们可以构建一个工作流来实现这些目标。以下是实现每个目标的持续集成工作流：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding workflow is a lot to absorb initially. However, if we break down
    the workflow, the behavior will become clear.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上述工作流一开始可能有些复杂。不过，如果我们将工作流分解，行为会变得清晰。
- en: Triggering the workflow
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发工作流
- en: 'The first two goals for the tweeter continuous integration workflow are as
    follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: tweeter持续集成工作流的前两个目标如下：
- en: Pushes to `main` and tags matching `v[0-9]+.[0-9]+.*` must build and validate.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送到`main`分支以及与`v[0-9]+.[0-9]+.*`匹配的标签必须进行构建和验证。
- en: Pull requests against the `main` branch must build and validate.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对`main`分支的拉取请求必须进行构建和验证。
- en: 'These goals are accomplished by specifying the following event triggers:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定以下事件触发器来实现这些目标：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `push:` trigger will execute the workflow if a tag is pushed matching `v[0-9]+.[0-9]+.*`
    – for example, `v1.2.3` would match the pattern. The `push:` trigger will also
    execute the workflow if a commit is pushed to `main`. The `pull_request` trigger
    will execute the workflow on any changes to a pull request targeting the `main`
    branch.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`push:`触发器将在推送标签匹配`v[0-9]+.[0-9]+.*`时执行工作流——例如，`v1.2.3`会匹配该模式。`push:`触发器也会在向`main`推送提交时执行工作流。`pull_request`触发器将在任何针对`main`分支的拉取请求更改时执行工作流。'
- en: 'Note that using the `pull_request` trigger will allow us to update the workflow
    and see the changes to the workflow each time the changes are pushed in a pull
    request. This is the desired behavior when developing a workflow, but it does
    open automation to malicious actors. For example, a malicious actor can open a
    new pull request, mutating the workflow to exfiltrate secrets exposed in it. There
    are multiple mitigations to prevent this, which can be applied independently or
    together, depending on the security preferences of a given project:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`pull_request`触发器将允许我们更新工作流，并在每次推送拉取请求时查看工作流的变化。这是开发工作流时希望的行为，但它也可能使自动化面临恶意行为者的威胁。例如，恶意行为者可以打开新的拉取请求，篡改工作流以窃取其中暴露的机密。为了防止这种情况，有多种缓解措施可以应用，根据项目的安全需求，可以独立或一起使用这些措施：
- en: Only allow maintainers to trigger workflows.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅允许维护者触发工作流。
- en: Use the `pull_request_target` event to trigger, which will use workflows defined
    in the base of the pull request without regard to workflow changes in the pull
    request.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pull_request_target`事件来触发工作流，这将使用拉取请求基准中定义的工作流，而不管拉取请求中工作流的更改。
- en: Add a label guard for executing a workflow so that it will only execute if a
    maintainer adds the label to the pull request. For example, a pull request can
    be reviewed by a maintainer, and then if the user and code changes are safe, the
    maintainer will apply a `safe-to-test` label, allowing the job to proceed.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加标签保护，以便只有在维护者为拉取请求添加标签时，工作流才会执行。例如，拉取请求可以由维护者进行审查，如果用户和代码更改是安全的，维护者会应用`safe-to-test`标签，从而允许任务继续进行。
- en: Next, we'll extend automation to include multiple platforms and Go versions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展自动化，涵盖多个平台和Go版本。
- en: Entering the matrix
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进入矩阵
- en: 'The next two goals for the tweeter continuous integration workflow are as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Tweeter持续集成工作流的接下来的两个目标如下：
- en: Tweeter must build and validate on Ubuntu, macOS, and Windows concurrently.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tweeter必须同时在Ubuntu、macOS和Windows上进行构建和验证。
- en: Tweeter must build and validate using Go 1.16 and 1.17 concurrently.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tweeter必须同时使用Go 1.16和1.17进行构建和验证。
- en: 'These goals are accomplished by specifying the following `matrix` configuration:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这些目标是通过指定以下`matrix`配置来完成的：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `test` job specifies a matrix strategy with two dimensions, `go-version`
    and `os`. There are two Go versions and three OSs specified. This variable combinations
    will create six concurrent jobs, `[(ubuntu-latest, 1.16.x)`, `(ubuntu-latest,
    1.17.x)`, `(macos-latest, 1.16.x)`, `(macos-latest, 1.17.x)`, `(windows-latest,
    1.16.x)`, and `(windows-latest, 1.17.x)]`. The values of the matrix will be substituted
    in `runs-on:` and `go-version:` to execute a concurrent job, satisfying the goals
    of running on each combination of platform and Go version:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`任务指定了一个矩阵策略，包含两个维度，`go-version`和`os`。指定了两个Go版本和三个操作系统。这个变量组合将创建六个并行任务，`[(ubuntu-latest,
    1.16.x)`, `(ubuntu-latest, 1.17.x)`, `(macos-latest, 1.16.x)`, `(macos-latest,
    1.17.x)`, `(windows-latest, 1.16.x)`和`(windows-latest, 1.17.x)]`。矩阵的值将被替换到`runs-on:`和`go-version:`中，以执行并行任务，满足在每个平台和Go版本组合上运行的目标：'
- en: '![Figure 10.4 – A pull request showing matrix builds'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.4 – 显示矩阵构建的拉取请求'
- en: '](img/B17626_10_004.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_004.jpg)'
- en: Figure 10.4 – A pull request showing matrix builds
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 显示矩阵构建的拉取请求
- en: In the preceding figure, you can see each matrix job executing concurrently.
    Note that each job specifies the name of the job, `test`, and the matrix variables
    for the job.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，可以看到每个矩阵任务并行执行。注意，每个任务都指定了任务名称`test`和该任务的矩阵变量。
- en: Building, testing, and linting
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建、测试和lint检查
- en: 'There is an overlap of build, testing, and linting in the last three goals:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三个目标之间存在构建、测试和lint的重叠：
- en: Tweeter must build and validate on Ubuntu, macOS, and Windows concurrently.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tweeter必须同时在Ubuntu、macOS和Windows上进行构建和验证。
- en: Tweeter must build and validate using Go 1.16 and 1.17 concurrently.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tweeter必须同时使用Go 1.16和1.17进行构建和验证。
- en: The Tweeter source code must pass a code-linting quality check.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tweeter的源代码必须通过代码质量检查。
- en: 'The following steps will satisfy these requirements:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将满足这些要求：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding steps, the following occurs:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，发生了以下情况：
- en: Go is installed with the `actions/setup-go@v2` action using the matrix-specified
    Go version. This action is available to all GitHub users and is published through
    the GitHub Marketplace. There are numerous actions available in the Marketplace
    that can simplify workflow authoring.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Go通过`actions/setup-go@v2`动作安装，使用矩阵指定的Go版本。这个动作对所有GitHub用户可用，并通过GitHub Marketplace发布。Marketplace中有许多可以简化工作流编写的动作。
- en: The source code for the current `ref` is cloned with the `actions/checkout@v2`
    action in the current working directory. Note that the action is not named. For
    commonly used actions, it is idiomatic to not provide a name.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当前`ref`的源代码是通过`actions/checkout@v2`动作在当前工作目录中克隆的。注意，动作没有指定名称。对于常用的动作，通常不提供名称。
- en: Linting is run with the `golangci/golangci-lint-action@v2`, which installs and
    executes the `golangci-lint` tool on the source of the repository, satisfying
    the goal of ensuring that the code passes a lint quality check. This particular
    action includes several sub-linters that run a rigorous check of common Go performance
    and stylistic errors.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lint检查使用`golangci/golangci-lint-action@v2`执行，该动作会在代码库的源代码上安装并执行`golangci-lint`工具，满足确保代码通过lint质量检查的目标。这个特定的动作包括多个子lint工具，能够严格检查常见的Go性能和风格错误。
- en: The code is functionally validated by running an ad hoc `go test ./...` script,
    which tests the packages recursively in the repository. Note that in a previous
    step, the Go tools have been installed and are available for use in subsequent
    steps.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行一个临时的 `go test ./...` 脚本来对代码进行功能验证，该脚本递归地测试仓库中的所有包。请注意，在前面的步骤中，Go 工具已经被安装并可供后续步骤使用。
- en: With the preceding steps, we have satisfied the goals of our continuous integration
    workflow. With the preceding workflow, we executed a matrix of concurrent jobs,
    installed build tools, cloned source code, linted, and tested the change set.
    In this example, we learned to build a continuous integration workflow for a Go
    project, but any language and set of tools can be used to create a continuous
    integration workflow.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的步骤，我们已经实现了持续集成工作流的目标。通过之前的工作流，我们执行了一个并发作业矩阵，安装了构建工具，克隆了源代码，进行了代码检查和测试了变更集。在这个示例中，我们学习了如何为
    Go 项目构建一个持续集成工作流，但任何语言和工具集都可以用来创建持续集成工作流。
- en: In the next section, we will build a release workflow that will automate the
    process of building and releasing new versions of the tweeter project.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将构建一个发布工作流，自动化构建和发布 tweeter 项目的新版本过程。
- en: Building a release workflow
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建发布工作流
- en: In this section, we will take the manual, toilsome process of publishing a new
    release and transform it into GitHub workflow automation, triggered by pushing
    a tag to the repository. This automation will result in a GitHub release containing
    build notes and release artifacts for a tagged, semantic version of the tweeter
    command-line tool. Automating manual processes such as releases reduces the possibility
    of manual errors and increases the productivity of project maintainers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把发布新版本的手动繁琐过程转化为 GitHub 工作流自动化，通过将标签推送到仓库来触发。此自动化将导致一个包含构建说明和发布工件的 GitHub
    发布，适用于已标记的、语义版本的 tweeter 命令行工具。自动化手动过程，如发布，减少了手动错误的可能性，并提高了项目维护者的生产力。
- en: In this section, you will learn how to create a release automation workflow.
    You will learn how to trigger automation to run after the successful completion
    of dependent automation. You will learn how to build binaries targeting multiple
    platforms. Finally, you will automate the creation of a GitHub release, including
    automatically generated release notes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何创建发布自动化工作流。你将学习如何在成功完成依赖自动化后触发自动化运行。你将学习如何构建面向多个平台的二进制文件。最后，你将自动化创建
    GitHub 发布，包括自动生成的发布说明。
- en: GitHub releases
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub 发布
- en: GitHub releases are deployable software iterations for a repository that are
    based on Git tags. A release declares to the world that a new version of the software
    is available. A release is composed of a title, an optional description, and an
    optional set of artifacts. The title provides a name for the release. The description
    is used to provide insight into what is contained in the release – for example,
    what new features or pull requests were included in the release, and which GitHub
    contributors contributed to the release. The description is formatted in GitHub
    Markdown. Release artifacts are files associated with the release that users can
    download – for example, a command-line application might publish compiled binaries
    ready for download and use.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 发布是基于 Git 标签的仓库可部署软件迭代。发布声明向世界表明该软件的新版本已可用。一个发布包含一个标题、一个可选的描述和一组可选的工件。标题为发布提供一个名称。描述用于提供对发布内容的洞察——例如，发布中包含了哪些新功能或拉取请求，以及哪些
    GitHub 贡献者参与了发布。描述采用 GitHub Markdown 格式。发布工件是与发布相关的文件，用户可以下载——例如，一个命令行应用可能会发布已编译的二进制文件，供下载和使用。
- en: Git tags
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git 标签
- en: 'A Git tag is a named pointer to a specific reference in the Git repository
    and are often formatted as semantic versions, such as `v1.2.3`. Semantic versioning
    is a convention for naming tags that provides some insight into the significance
    of a new release. A semantic version tag is formatted as `Major.Minor.Patch`.
    The following behavior is expressed by incrementing the individual field:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标签是指向 Git 仓库中特定引用的命名指针，通常采用语义版本格式，如 `v1.2.3`。语义版本是一种为标签命名的约定，它提供了关于新版本重要性的某些信息。语义版本标签的格式为
    `Major.Minor.Patch`。通过递增各个字段来表达以下行为：
- en: '`Major`: Increment when incompatible API changes occur, such as breaking changes.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Major`：当发生不兼容的 API 更改时（例如破坏性更改），递增此字段。'
- en: '`Minor`: Increment when functionality is added in a backward-compatible manner,
    such as new features.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Minor`：在向后兼容的方式中添加功能时递增，例如新增功能。'
- en: '`Patch`: Increment when making backward-compatible bug fixes.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Patch`：在进行向后兼容的 bug 修复时递增。'
- en: Release automation for tweeter
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 推特的发布自动化
- en: In the *Continuous integration workflow for tweeter* section, we created a CI
    automation for the tweeter command-line tool. We will build upon the CI automation
    and add release automation for tweeter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *推特的持续集成工作流* 部分中，我们为推特命令行工具创建了 CI 自动化。我们将在 CI 自动化的基础上添加推特的发布自动化。
- en: Goals for automation
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化目标
- en: 'In our release automation, we are going to accomplish the following goals:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的发布自动化中，我们将完成以下目标：
- en: Trigger automation when the repository is tagged with a semantic version
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当仓库被标记为语义版本时触发自动化
- en: Run unit tests and validation prior to creating the release
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建发布之前运行单元测试和验证
- en: Inject the semantic version of the release into the tweeter application
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将发布的语义版本注入推特应用程序
- en: Build cross-platform versions of the tweeter application
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建推特应用程序的跨平台版本
- en: Generate release notes from the pull requests in the release
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从发布中的拉取请求生成发布说明
- en: Tag the contributors in the release
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发布中标记贡献者
- en: 'Create a GitHub release containing the following:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的 GitHub 发布：
- en: A title containing the semantic version of the release
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含发布语义版本的标题
- en: A description containing the generated release notes
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含生成的发布说明的描述
- en: Artifacts consisting of the cross-platform binaries
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由跨平台二进制文件组成的工件
- en: Next, we will create release automation to satisfy these requirements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建发布自动化以满足这些要求。
- en: Creating the release automation
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建发布自动化
- en: With our goals for the tweeter release automation specified, we are ready to
    extend the existing continuous integration workflow that we built in the previous
    section and add a release job to achieve those goals. The release job is longer
    than the continuous integration workflow, so we'll approach it one piece at a
    time.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在明确了推特发布自动化的目标后，我们准备好扩展在上一节中构建的现有持续集成工作流，并添加发布作业以实现这些目标。由于发布作业比持续集成工作流要长，因此我们将逐步处理每个部分。
- en: Triggering the automation
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 触发自动化
- en: 'The first goal for the tweeter release workflow is triggering the automation
    when the repository is tagged with a semantic version:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 推特发布工作流的第一个目标是当仓库被标记为语义版本时触发自动化：
- en: '[PRE20]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding snippet of YAML is unchanged from the continuous integration workflow.
    It will trigger the workflow with any tag matching the semantic version in the
    form of `v1.2.3`. However, the workflow will also trigger on pull requests and
    pushes. We want the continuous integration workflow to execute on pull requests
    and pushes, but we do not want to execute a release each time. We will need to
    restrict execution of the release job to only when executing on a `tag` push.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 YAML 片段与持续集成工作流保持不变。它将在任何与语义版本匹配的标签（如 `v1.2.3`）上触发工作流。但是，工作流也会在拉取请求和推送时触发。我们希望持续集成工作流在拉取请求和推送时执行，但我们不希望每次都执行发布。我们需要限制发布作业的执行，只在执行
    `tag` 推送时触发。
- en: Restricting release execution
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制发布执行
- en: 'The first and second goal for the tweeter release workflow is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 推特发布工作流的第一个和第二个目标如下：
- en: Triggering the automation when the repository is tagged with a semantic version
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当仓库被标记为语义版本时触发自动化
- en: Running unit tests and validation prior to creating the release
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建发布之前运行单元测试和验证
- en: 'Let''s make sure the release job only executes when the repository is tagged:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保发布作业仅在仓库被标记时执行：
- en: '[PRE21]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding job definition completes the first goal of only running the release
    when a tag starting with `v` is pushed by specifying an `if` statement to verify
    that the `github.ref` context variable starts with `refs/tags/v`. The second goal
    of ensuring the `test` job executes successfully before attempting to execute
    the `release` job is achieved by specifying `needs: test`. If `needs: test` was
    not specified on the `release` job, both jobs will execute concurrently, which
    can cause a release to be created without passing validation.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '上述作业定义完成了第一个目标，即只有在推送以 `v` 开头的标签时才执行发布，通过指定 `if` 语句验证 `github.ref` 上下文变量是否以
    `refs/tags/v` 开头。确保 `test` 作业在尝试执行 `release` 作业之前成功执行的第二个目标通过指定 `needs: test`
    达成。如果没有在 `release` 作业上指定 `needs: test`，两个作业将并行执行，这可能会导致在没有通过验证的情况下创建发布。'
- en: Workspace and environmental setup
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工作区和环境设置
- en: 'To achieve the rest of the automation goals, we will need to set up the workspace:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现其余的自动化目标，我们需要设置工作区：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding code does the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码执行以下操作：
- en: Checks out the source at the Git ref associated with the tag
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与标签相关的 Git 引用处签出源代码
- en: Creates a `RELEASE_VERSION` environment variable with the tag, such as `v1.2.3`
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含标签的 `RELEASE_VERSION` 环境变量，例如 `v1.2.3`
- en: Installs Go 1.17 tools
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Go 1.17 工具
- en: Building cross-platform binaries and version injection
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建跨平台二进制文件并进行版本注入
- en: 'The third and fourth goals of the tweeter release flow are as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Tweeter 发布流程的第三和第四个目标如下：
- en: Inject the semantic version of the release into the tweeter application.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将发布的语义版本注入到 Tweeter 应用中。
- en: Build cross-platform versions of the tweeter application.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Tweeter 应用的跨平台版本。
- en: 'Let''s get started by injecting the semantic version of the release into the
    compiled binary:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将发布的语义版本注入到编译后的二进制文件开始：
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding steps do the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤执行以下操作：
- en: Install the `gox` command-line tool for simplifying Go cross-compilation.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `gox` 命令行工具，以简化 Go 跨平台编译。
- en: 'Build cross-platform binaries for each specified platform/architecture while
    injecting the `RELEASE_VERSION` environment variable into a Go `ldflag`. The `ldflag
    -X` replaces the default value of the `Version` variable in the `github.com/devopsforgo/github-actions/pkg/tweeter`
    package with the semantic version tag of the build. The output of `gox` is structured
    by `OUTPUT_PATH_FORMAT` – for example, the output directory looks like the following:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个指定的平台/架构构建跨平台的二进制文件，同时将 `RELEASE_VERSION` 环境变量注入到 Go 的 `ldflag` 中。`ldflag
    -X` 会将 `github.com/devopsforgo/github-actions/pkg/tweeter` 包中 `Version` 变量的默认值替换为构建的语义版本标签。`gox`
    的输出按 `OUTPUT_PATH_FORMAT` 结构化——例如，输出目录看起来如下：
- en: '[PRE24]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: One of the most compelling reasons to use Golang for building applications is
    the relative ease of building cross-platform, statically linked binaries. With
    a couple of steps, we can build versions of tweeter for Linux, Windows, macOS
    targeting AMD64 and ARM64, as well as many other platforms and architectures.
    These small, statically linked binaries are simple to distribute and execute across
    platforms and architectures.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Golang 构建应用程序的一个最具吸引力的理由是相对容易构建跨平台的静态链接二进制文件。通过几个步骤，我们可以为 Linux、Windows、macOS
    构建针对 AMD64 和 ARM64 以及许多其他平台和架构的 Tweeter 版本。这些小巧的静态链接二进制文件简单易分发，并且可以在各个平台和架构上执行。
- en: With the preceding steps, the release job has compiled the semantic version
    of the release into the platform and architecture-specific, statically linked
    binaries. In the next step, we will use the semantic version to generate release
    notes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的步骤，发布作业已将发布的语义版本编译成特定平台和架构的静态链接二进制文件。在下一步中，我们将使用语义版本来生成发布说明。
- en: Generating release notes
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成发布说明
- en: 'We have the following goals associated with generating release notes:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下生成发布说明的目标：
- en: Generate release notes from the pull requests in the release.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从发布中的拉取请求生成发布说明
- en: Tag the contributors in the release.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发布中标记贡献者。
- en: 'Create a GitHub release containing the following:'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的 GitHub 发布：
- en: A description containing the generated release notes
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含生成的发布说明的描述
- en: 'Here''s some great news! With a bit of configuration and tagging, release note
    generation is automatically handled by GitHub. We''ll start by adding a new file
    to the repository, `./.github/release.yml`, with the following content:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个好消息！只需稍作配置和标签管理，发布说明的生成就能由 GitHub 自动处理。我们将从往仓库中添加一个新文件 `./.github/release.yml`
    开始，内容如下：
- en: '[PRE25]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding release configuration will tell GitHub to filter and categorize
    pull requests based on the applied labels. For example, pull requests labeled
    with `ignore-for-release` will be excluded from the release notes, but a pull
    request labeled with `enhancement` will be grouped under the `New Features` header
    in the release notes:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 上述发布配置将告诉 GitHub 基于应用的标签来筛选和分类拉取请求。例如，标有 `ignore-for-release` 标签的拉取请求将被排除在发布说明之外，但标有
    `enhancement` 标签的拉取请求将会被归类到发布说明中的 `新功能` 下面：
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding step generates release notes. The step executes an API call to
    the GitHub API to generate the release notes for the given tag. The command captures
    the JSON body of the response in a `tmp-release-notes.json` filename. Note that
    `gh` requires a GitHub token to interact with the GitHub APIs. The GitHub secret
    is passed into the `GITHUB_TOKEN` environment variable and is used by `gh` to
    authenticate.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 上一步生成了发布说明。该步骤执行一个 API 调用，向 GitHub API 请求生成给定标签的发布说明。命令将响应的 JSON 内容保存为 `tmp-release-notes.json`
    文件。请注意，`gh` 需要 GitHub 令牌才能与 GitHub API 交互。GitHub 密钥被传递到 `GITHUB_TOKEN` 环境变量中，并由
    `gh` 用于身份验证。
- en: 'The following is an example of JSON returned from the `generate-notes` API
    call:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `generate-notes` API 调用返回的 JSON 示例：
- en: '[PRE27]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will use `tmp-release-notes.json` to create the release in the next step.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一步中使用 `tmp-release-notes.json` 来创建发布。
- en: Creating the GitHub release
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 GitHub 发布
- en: 'The final goal of creating the release automation is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 创建发布自动化的最终目标如下：
- en: A title containing the semantic version of the release
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含发布语义版本的标题
- en: A description containing the generated release notes
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含生成的发布说明的描述
- en: Artifacts consisting of the cross-platform binaries
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含跨平台二进制文件的工件
- en: 'Let''s get started creating our release automation:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的发布自动化：
- en: '[PRE28]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding steps do the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤执行了以下操作：
- en: Execute `tar` and `gzip` on the binaries. With Go 1.17, tweeter bins are roughly
    6.5 MB. After `gzip`, each artifact is less than 4 MB.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `tar` 和 `gzip` 命令对二进制文件进行压缩。使用 Go 1.17，推特二进制文件大约为 6.5 MB。经过 `gzip` 压缩后，每个工件小于
    4 MB。
- en: Create a GitHub release using the `gh` command-line tool, which is available
    on all GitHub job executors. `gh` requires a GitHub token to interact with the
    GitHub APIs. The GitHub secret is passed into the `GITHUB_TOKEN` environment variable
    and is used by `gh` to authenticate. `gh release create` creates a release and
    uploads each of the files specified after the arguments. Each file uploaded becomes
    an artifact on the release. Note `#` after each artifact file path. The text after
    `#` is the name that the artifact will display, as in the GitHub UI. We also specify
    the title and the release notes using the captured `tmp-release-notes.json` and
    `jq` to parse and select the JSON content.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `gh` 命令行工具创建 GitHub 发布，该工具在所有 GitHub 作业执行器上都可用。`gh` 需要 GitHub 令牌才能与 GitHub
    API 交互。GitHub 密钥被传递到 `GITHUB_TOKEN` 环境变量中，并由 `gh` 用于身份验证。`gh release create` 会创建一个发布并上传所有在参数后指定的文件。每个上传的文件都会成为发布的一个工件。请注意每个工件文件路径后面的
    `#`。`#` 后的文本是工件在 GitHub UI 中显示的名称。我们还使用捕获到的 `tmp-release-notes.json` 和 `jq` 来解析并选择
    JSON 内容，以指定标题和发布说明。
- en: At this point, we have a created release targeting multiple platforms and architectures,
    satisfying all our goals for automation. Let's kick off a release and see the
    results.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已经创建了一个面向多个平台和架构的发布版本，满足了我们对自动化的所有目标。让我们开始发布并查看结果。
- en: Creating a release of tweeter
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建推特发布
- en: 'Now that we have built a release job that will automate the releases of tweeter,
    we can now tag the repository and release a version of the application. To start
    the release automation, we are going to create and push the `v0.0.1` tag to the
    repository by executing the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了一个发布作业来自动化推特发布，我们可以对仓库进行标签标记并发布应用程序的版本。为了启动发布自动化，我们将通过执行以下操作来创建并推送
    `v0.0.1` 标签到仓库：
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After the tag is pushed, you should be able to go to the **Actions** tab on
    your GitHub repository and see the tag workflow executing. If you navigate to
    the workflow, you should see something like the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签推送后，您应该能够进入 GitHub 仓库的 **Actions** 标签页，并看到标签工作流正在执行。如果您进入工作流页面，应该会看到如下内容：
- en: '![Figure 10.5 – The workflow job view showing dependent test and release jobs'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – 显示依赖测试和发布作业的工作流作业视图'
- en: '](img/B17626_10_005.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_005.jpg)'
- en: Figure 10.5 – The workflow job view showing dependent test and release jobs
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 显示依赖测试和发布作业的工作流作业视图
- en: 'As you can see in the preceding figure, the tests have been executed and, subsequently,
    the release job has been too. If you navigate to the **release** job, you should
    see something like the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，测试已经执行，随后发布作业也已经执行。如果您进入 **release** 作业页面，您应该会看到如下内容：
- en: '![Figure 10.6 – The release job output view'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.6 – 发布作业输出视图'
- en: '](img/B17626_10_006.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_006.jpg)'
- en: Figure 10.6 – The release job output view
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – 发布作业输出视图
- en: 'As you can see in the preceding figure, the release job has successfully executed
    each of the steps and the release was created. If you go to the landing page of
    the repository, you should see that a new release has been created. If you click
    on that release, you should see something like the following:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，发布任务已成功执行每个步骤，且发布已创建。如果你进入仓库的首页，你应该会看到一个新发布已经创建。如果你点击该发布，你应该会看到如下内容：
- en: '![Figure 10.7 – The release view, containing assets, the release note, and
    the semantic version title'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.7 – 发布视图，包含资产、发布说明和语义版本标题'
- en: '](img/B17626_10_007.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_007.jpg)'
- en: Figure 10.7 – The release view, containing assets, the release note, and the
    semantic version title
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – 发布视图，包含资产、发布说明和语义版本标题
- en: In the preceding figure, you can see that the release named `v0.0.1` has been
    autogenerated with categorized release notes that link to the pull requests, the
    contributor, and artifacts for each platform/architecture combination.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到名为`v0.0.1`的发布已经自动生成，并附带了分类的发布说明，这些说明链接到拉取请求、贡献者以及每个平台/架构组合的工件。
- en: With the preceding steps, we have satisfied the goals of our release automation
    job. We triggered the release job after the tests executed to ensure a release
    will always pass our validations before being published. We built statically linked
    binaries for each of the specified platform/architecture combinations using `gox`.
    We leveraged GitHub release notes autogeneration to create beautifully formatted
    release notes. And finally, we created a release with the generated notes and
    artifacts from the build.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的步骤，我们已经达成了发布自动化任务的目标。在测试执行后，我们触发了发布任务，以确保发布在发布之前始终通过我们的验证。我们使用`gox`为每个指定的平台/架构组合构建了静态链接的二进制文件。我们利用
    GitHub 发布说明自动生成工具创建了格式美观的发布说明。最后，我们创建了一个发布，其中包含了构建过程中生成的说明和工件。
- en: In this example, we learned to build a release automation job for a Go project,
    but any language and set of tools can be used in a similar manner to create release
    automation for any language.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们学习了如何为 Go 项目构建发布自动化任务，但任何语言和工具集都可以类似地用于为任何语言创建发布自动化。
- en: We have no more manual toil to release the tweeter project. All that needs to
    be done is to push a tag to the repository. Our use of open source actions has
    enhanced our ability to author these automations. In the next section, we will
    learn to create our own packaged action that will allow others to use an action
    we author.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要手动发布 tweeter 项目。所需的唯一操作是将标签推送到仓库。我们使用开源操作增强了创建这些自动化的能力。在下一部分，我们将学习如何创建自己的打包操作，以便其他人使用我们编写的操作。
- en: Creating a custom GitHub Action using Go
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Go 创建自定义 GitHub 操作
- en: In this section, we will extend upon our work by turning the tweeter command
    line into a GitHub Action. This will allow anyone on GitHub building automation
    to use tweeter to tweet from their own pipeline. Furthermore, we'll use our tweeter
    action to tweet when we release new versions of tweeter by extending the release
    job to use our new action.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将在之前的工作基础上扩展，将 tweeter 命令行转换为 GitHub 操作。这将允许 GitHub 上的任何人使用 tweeter 在他们自己的流水线中发布推文。此外，我们将使用我们的
    tweeter 操作在发布新版本时发推，方法是将发布任务扩展为使用我们的新操作。
- en: In this section, you will learn the basics of authoring GitHub Actions. You
    will create a custom GitHub Action using Go. You will then optimize the start
    up time of your custom action by creating a container image.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习编写 GitHub 操作的基础知识。你将使用 Go 创建一个自定义 GitHub 操作。然后，你将通过创建一个容器镜像来优化自定义操作的启动时间。
- en: Basics of custom actions
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义操作的基础
- en: Custom actions are individual tasks that wrap a collection of related tasks.
    Custom actions can be executed as individual tasks in workflows and can be shared
    with the GitHub community.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义操作是将一组相关任务封装起来的单独任务。自定义操作可以作为工作流中的独立任务执行，并且可以与 GitHub 社区共享。
- en: Types of actions
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作类型
- en: 'There are three types of actions: container, JavaScript, and composite actions.
    Container-based actions use a Dockerfile or a container image reference as the
    entry point, the starting point of execution for the action, and are useful if
    you want to author an action in anything but JavaScript or existing actions. Container-based
    actions offer flexibility in customizing the execution environment of an action,
    but it comes at the cost of start up time. If a container-based action depends
    on a large container image or a slow-building Dockerfile, then the action start
    up time will be adversely affected. JavaScript actions can run directly on the
    runner machine and are the native expression of an action. JavaScript actions
    start up quickly and can leverage the GitHub Actions Toolkit, a set of JavaScript
    packages to make creating actions easier. Composite actions are a collection of
    steps within a wrapper action. They enable an author to combine a set of disparate
    steps into a higher-order behavior.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的动作：容器动作、JavaScript 动作和复合动作。基于容器的动作使用 Dockerfile 或容器镜像引用作为入口点，即动作的执行起点，适用于你希望在
    JavaScript 或现有动作以外的其他语言中编写动作的情况。基于容器的动作提供了定制执行环境的灵活性，但代价是启动时间。如果容器动作依赖于一个大型容器镜像或一个构建缓慢的
    Dockerfile，那么动作的启动时间将受到不利影响。JavaScript 动作可以直接在运行器机器上执行，是动作的本地表现形式。JavaScript 动作启动迅速，并可以利用
    GitHub Actions 工具包，这是一个 JavaScript 包集合，使创建动作更加简单。复合动作是一个包含多个步骤的封装动作。它们使得作者能够将一组不同的步骤组合成更高阶的行为。
- en: Action metadata
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动作元数据
- en: 'To define an action, you must create an `action.yaml` file in a GitHub repository.
    If the action is to be shared publicly, the `action.yaml` file should be created
    in the root of the repository. If the action is not to be shared publicly, it
    is recommended to create the `action.yaml` file in `./.github/{name-of-action}/action.yaml`
    where `{name-of-action}` should be substituted with the name of the action. For
    example, if the tweeter action was only to be used internally, the path of the
    action metadata would be `./.github/tweeter/action.yaml`:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个动作，你必须在 GitHub 仓库中创建一个 `action.yaml` 文件。如果该动作是要公开共享的，`action.yaml` 文件应当放在仓库的根目录中。如果该动作不打算公开共享，建议将
    `action.yaml` 文件放在 `./.github/{name-of-action}/action.yaml` 路径中，其中 `{name-of-action}`
    应替换为该动作的名称。例如，如果 Tweeter 动作仅用于内部使用，则动作元数据的路径应为 `./.github/tweeter/action.yaml`：
- en: '[PRE30]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding `action.yaml` defines the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `action.yaml` 定义了以下内容：
- en: The name of the action that will be shown in the GitHub UI
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将在 GitHub 用户界面中显示的动作名称
- en: The author of the action
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作的作者
- en: The description of the action
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作的描述
- en: Branding that will be used for the action in the GitHub UI
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将在 GitHub 用户界面中用于该动作的品牌标识
- en: Input the action will accept
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入该动作将接受
- en: Output the action will return
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出该动作将返回
- en: The `runs` section, which describes how the action will be executed
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runs` 部分，描述了动作如何执行'
- en: In this example, we are using a Dockerfile, which will build a container from
    the Dockerfile and execute the container entry point with the specified arguments.
    Note how the `inputs.sample` context variable is used to map input to command-line
    arguments.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了一个 Dockerfile，它将从 Dockerfile 构建一个容器，并使用指定的参数执行容器的入口点。注意如何使用 `inputs.sample`
    上下文变量将输入映射为命令行参数。
- en: 'The preceding action can be executed with the following step:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 上述动作可以通过以下步骤执行：
- en: '[PRE31]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding sample execution does the following:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例执行的操作如下：
- en: Executes a step using the sample action with the assumption that the action
    is tagged with `v1` in the `devopsforgo/sample-action` repository, with `action.yaml`
    at the root of that repository, and specifies the required input variable `sample`.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例动作执行一个步骤，假设该动作在 `devopsforgo/sample-action` 仓库中已标记为 `v1`，且该仓库的根目录下有 `action.yaml`
    文件，并指定了所需的输入变量 `sample`。
- en: Echoes the `sampleOutput` variable.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回显 `sampleOutput` 变量。
- en: Next, we will discuss how to tag action releases.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何标记动作发布版本。
- en: Action release management
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动作发布管理
- en: In all of our examples of using actions in our workflows, the `uses:` value
    for the action has always included the version of the action. For example, in
    the preceding sample, we used `devopsforgo/sample-action@v1` to specify that we
    wanted to use the action at the Git tag of `v1`. By specifying that version, we
    are telling the workflow to use the action at the Git reference pointed to by
    that tag. By convention, the `v1` tag of an action can point to any Git reference
    that is tagged in the semantic version range of `v1.x.x`. That means that the
    `v1` tag is a floating tag and not static, and will advance as new releases in
    the `v1.x.x` range are released. Recall from the description of semantic versions
    earlier in this chapter that increments of the major version indicate breaking
    changes. The author of the action is making a promise to users that anything tagged
    with `v1` will not include breaking changes.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所有的工作流示例中，Action 的 `uses:` 值始终包含 Action 的版本。例如，在上述示例中，我们使用 `devopsforgo/sample-action@v1`
    来指定我们希望使用 `v1` 的 Git 标签版本。通过指定该版本，我们告诉工作流使用该标签指向的 Git 引用。按照约定，Action 的 `v1` 标签可以指向任何符合
    `v1.x.x` 语义版本范围的 Git 引用。这意味着 `v1` 标签是一个浮动标签而非静态标签，并且随着新的 `v1.x.x` 版本的发布而推进。回想一下本章早些时候关于语义版本的描述，主版本号的递增表示存在破坏性变更。Action
    的作者向用户承诺，任何标记为 `v1` 的版本都不会包含破坏性变更。
- en: The conventions used for versioning actions can cause friction when an action
    is included in the same repository as another versioned software project. It is
    advised to consider the implications of action versioning, and consider creating
    a repository dedicated to an action rather than creating it within a repository
    containing other versioned projects.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 用于版本控制的约定可能会在 Action 与同一仓库中的另一个版本化软件项目一起使用时造成摩擦。建议考虑 Action 版本控制的影响，并考虑为 Action
    创建一个专门的仓库，而不是将其创建在包含其他版本化项目的仓库中。
- en: Goals for the tweeter custom GitHub Action
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: tweeter 自定义 GitHub Action 的目标
- en: 'In our custom GitHub Action for tweeter, we are going to accomplish the following:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 tweeter 自定义 GitHub Action 中，我们将完成以下任务：
- en: Build a Dockerfile for building and running the tweeter command-line tool.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个用于构建和运行 tweeter 命令行工具的 Dockerfile。
- en: Create an action metadata file for the custom action.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为自定义 Action 创建一个 Action 元数据文件。
- en: Extend the continuous integration job to test the action.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展持续集成任务以测试 Action。
- en: Create an image release workflow for publishing the tweeter container image.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个图像发布工作流，用于发布 tweeter 容器镜像。
- en: Optimize the tweeter custom action by using the published container image.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用发布的容器镜像来优化 tweeter 自定义 Action。
- en: Next, we will create a custom Go action using a Dockerfile.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Dockerfile 创建一个自定义 Go Action。
- en: Creating the tweeter action
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 tweeter Action
- en: With our goals for the tweeter custom action specified, we are ready to create
    the Dockerfile required to run tweeter, define the metadata for the action to
    map input and output from the tweeter command-line tool, extend our continuous
    integration job to test the action, and finally, optimize the start time for the
    action by using a pre-built container image in the custom action. We will break
    down each step and create our custom Go action.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在明确了 tweeter 自定义 Action 的目标后，我们准备创建运行 tweeter 所需的 Dockerfile，定义 Action 的元数据，以映射来自
    tweeter 命令行工具的输入和输出，扩展我们的持续集成任务来测试 Action，最后，通过在自定义 Action 中使用预构建的容器镜像来优化 Action
    的启动时间。我们将分解每个步骤并创建我们自定义的 Go Action。
- en: Defining a Dockerfile
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个 Dockerfile
- en: The first goal for the tweeter custom GitHub Action is building a Dockerfile
    for building and running the tweeter command-line tool.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: tweeter 自定义 GitHub Action 的第一个目标是构建一个用于构建和运行 tweeter 命令行工具的 Dockerfile。
- en: 'Let''s get started by building a Dockerfile in the root of the tweeter repository
    that we will use to build a container image:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个 Dockerfile 开始，该 Dockerfile 位于 tweeter 仓库的根目录，用于构建容器镜像：
- en: '[PRE32]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding Dockerfile does the following:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 Dockerfile 的功能如下：
- en: Uses the `golang:1.17` image as an intermediate builder container, which contains
    the Go build tools needed to compile the tweeter command-line tool. Using the
    builder pattern creates an intermediate container, containing build tools and
    source code that will not be needed in the end product. It allows us a scratch
    area to build a statically linked Go application that can be added to a slimmed-down
    container at the end of the build process. This enables the final container to
    only contain the Go application and nothing more.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `golang:1.17` 镜像作为中间构建容器，包含编译 tweeter 命令行工具所需的 Go 构建工具。使用构建者模式创建一个中间容器，包含构建工具和源代码，这些在最终产品中不会被使用。它为我们提供了一个构建静态链接的
    Go 应用程序的临时区域，构建完成后可以将其添加到精简版的容器中。这样，最终的容器只会包含 Go 应用程序，而没有其他内容。
- en: The build then copies in `go.mod` and `go.sum`, and then downloads the Go dependencies
    for the tweeter application.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建过程然后复制 `go.mod` 和 `go.sum`，然后下载 tweeter 应用程序所需的 Go 依赖。
- en: The source for the tweeter application is copied into the builder container
    and then compiled as a statically linked binary.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: tweeter 应用程序的源代码被复制到构建容器中，并编译为静态链接的二进制文件。
- en: The production image is created from the `gcr.io/distroless/static:latest` base
    image, and the tweeter application is copied from the intermediate builder container.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生产镜像是从 `gcr.io/distroless/static:latest` 基础镜像创建的，tweeter 应用程序则从中间构建容器中复制过来。
- en: Finally, the default entry point is set to the tweeter binary, which will enable
    us to run the container and directly execute the tweeter application.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，默认入口点被设置为 tweeter 二进制文件，这将使我们能够运行容器并直接执行 tweeter 应用程序。
- en: 'To build and then execute the preceding Dockerfile, you can run the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建并执行上述 Dockerfile，您可以运行以下命令：
- en: '[PRE33]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding script does the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本执行以下操作：
- en: Builds the Dockerfile and tags it with the name `tweeter`
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Dockerfile 并标记为 `tweeter` 名称
- en: Runs the tagged tweeter container image, passing the tweeter application the
    `-h` argument, causing the tweeter application to print the help text
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行标记的 tweeter 容器镜像，向 tweeter 应用程序传递 `-h` 参数，导致 tweeter 应用程序打印帮助文本
- en: Now that we have a working Dockerfile, we can use that to define a custom container
    action defined in `action.yaml`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个有效的 Dockerfile，可以使用它来定义 `action.yaml` 中定义的自定义容器操作。
- en: Creating action metadata
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建操作元数据
- en: The second goal for the tweeter custom GitHub Action is creating an action metadata
    file for the custom action.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: tweeter 自定义 GitHub Action 的第二个目标是为自定义操作创建一个操作元数据文件。
- en: 'Now that we have defined the Dockerfile, we can author a Docker action with
    the following action metadata in an `action.yaml` file in the root of the repository:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 Dockerfile，可以在仓库根目录中的 `action.yaml` 文件中编写自定义操作的操作元数据：
- en: '[PRE34]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The preceding action metadata does the following:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作元数据执行以下操作：
- en: Defines the action name, author, and description metadata
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义操作名称、作者和描述元数据
- en: Defines the expected input to the action
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义操作的预期输入
- en: Defines the output variable for the action
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为操作定义输出变量
- en: Executes the Dockerfile, mapping the input of the action to the `args` of the
    tweeter application
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 Dockerfile，将操作的输入映射到 tweeter 应用程序的 `args` 中
- en: 'How the input variables map to the tweeter `args` command line is apparent
    due to the mapping of the input to the arguments, but it is not clear how the
    output variables are mapped. The output variables are mapped by specially encoding
    the variables in STDOUT in the Go application:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 输入变量如何映射到 tweeter 的 `args` 命令行是显而易见的，因为输入被映射到参数中，但输出变量如何映射则不太清楚。输出变量通过在 Go 应用程序中将变量特别编码到
    STDOUT 来映射：
- en: '[PRE35]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding function prints to STDOUT the key and the message for an output
    variable. To return the `sentMessage` output variable, the Go application calls
    `printOutput("sendMessage", message)`. The action runtime will read STDOUT, recognize
    the encoding, and then populate the context variable for `steps.{action.id}.outputs.sentMessage`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将输出变量的键和值打印到 STDOUT。为了返回 `sentMessage` 输出变量，Go 应用程序调用 `printOutput("sendMessage",
    message)`。操作运行时将读取 STDOUT，识别编码，并将其填充到 `steps.{action.id}.outputs.sentMessage`
    的上下文变量中。
- en: With our action metadata defined, we are now ready to test our action by extending
    the tweeter continuous integration workflow to execute the action in the local
    repository.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了操作元数据后，我们现在准备通过扩展 tweeter 持续集成工作流，来测试在本地仓库中执行该操作。
- en: Testing the action
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试操作
- en: The third goal of the tweeter custom GitHub Action is to extend the continuous
    integration job to test the action.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 推特自定义 GitHub Action 的第三个目标是将持续集成任务扩展为测试该动作。
- en: 'With the `action.yaml` file authored, we can add a workflow job to test the
    action:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 编写好`action.yaml`文件后，我们可以添加一个工作流任务来测试该动作：
- en: '[PRE36]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding `test-action` job does the following:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`test-action`任务执行了以下操作：
- en: Checks out the code to the local workspace
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码签出到本地工作区
- en: Executes the local action, specifying all required input and setting the `DRY_RUN`
    environment variable to `true` so that the action will not try to send the message
    to Twitter
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行本地动作，指定所有必需的输入，并将`DRY_RUN`环境变量设置为`true`，这样该动作就不会尝试发送消息到 Twitter
- en: Runs an `echo` command, fetching the echoed output from the action
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`echo`命令，获取从动作中回显的输出
- en: 'Let''s see what happens when we trigger this workflow:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看触发此工作流时会发生什么：
- en: '![Figure 10.8 – The workflow run with the new test-action job'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.8 – 具有新 test-action 任务的工作流运行情况'
- en: '](img/B17626_10_008.jpg)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_008.jpg)'
- en: Figure 10.8 – The workflow run with the new test-action job
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – 具有新 test-action 任务的工作流运行情况
- en: 'In the preceding screenshot, you can see that the `test-action` job is now
    part of the tweeter automation that will validate the action. Note the runtime
    of 54 seconds for executing the job. It seems like a long time to call a command-line
    application:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到`test-action`任务现在是推特自动化的一部分，它将验证这个动作。注意执行任务的运行时为 54 秒。调用命令行应用程序似乎花费了很长时间：
- en: '![Figure 10.9 – The test-action job output'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.9 – test-action 任务输出'
- en: '](img/B17626_10_009.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_009.jpg)'
- en: Figure 10.9 – The test-action job output
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – test-action 任务输出
- en: In the preceding screenshot, you can see that the test for the tweeter action
    took 49 seconds out of the total job runtime of 54 seconds. That is the vast majority
    of the time it took to execute the job. Most of that time was spent compiling
    tweeter and building the `docker` image prior to executing the action. In the
    next part, we'll optimize the action execution time by referencing a pre-built
    version of the tweeter container image.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，你可以看到推特操作的测试占用了 49 秒，任务的总运行时间为 54 秒。几乎所有的时间都花在了编译推特和构建`docker`镜像上，然后才执行这个动作。在接下来的部分中，我们将通过引用预构建版本的推特容器镜像来优化动作执行时间。
- en: Creating a container image release workflow
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建容器镜像发布工作流
- en: The fourth goal of the tweeter custom GitHub Action is creating an image release
    workflow for publishing the tweeter container image.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 推特自定义 GitHub Action 的第四个目标是创建一个图像发布工作流，用于发布推特容器镜像。
- en: 'As we saw in the previous section, the amount of time to build the Dockerfile
    was significant. There is little reason to do that for every execution of an action,
    which can be avoided by publishing the container image to a container registry
    and then using the registry image in place of the Dockerfile:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，构建 Dockerfile 所需的时间相当长。没有理由在每次执行操作时都这么做，这可以通过将容器镜像发布到容器注册表中，然后在
    Dockerfile 位置使用该注册表镜像来避免：
- en: '[PRE37]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding workflow definition does the following:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的工作流定义执行了以下操作：
- en: Triggers only when tags starting with `image-v` are pushed
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在推送以`image-v`开头的标签时触发
- en: Requests permissions to write to the `ghcr.io` image repository and read the
    Git repository
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求对`ghcr.io`镜像库的写权限以及对 Git 仓库的读取权限
- en: Contains a single container image build and steps to publish the image.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含单个容器镜像构建和发布镜像的步骤。
- en: Checks out the repository
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签出代码库
- en: Builds the `RELEASE_VERSION` environment variable based on the tag format
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据标签格式构建`RELEASE_VERSION`环境变量
- en: Sets up `buildx` for building the container image
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`buildx`以构建容器镜像
- en: Logs in to `ghcr.io`, the GitHub container registry
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录到 `ghcr.io`，GitHub 容器注册表
- en: Builds and pushes the container image tagged with both the release version and
    the latest version
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建并推送标记为发布版本和最新版本的容器镜像
- en: 'With the preceding workflow in place, we can tag the repository with the following
    commands and have the container image published to the GitHub container registry
    for use in the tweeter action:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述工作流后，我们可以使用以下命令标记代码库，并将容器镜像发布到 GitHub 容器注册表，以便在推特动作中使用：
- en: '[PRE38]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s see the result of our image release workflow:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的图像发布工作流的结果：
- en: '![Figure 10.10 – The workflow job view for the image-release job'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.10 – 图像发布任务的工作流视图'
- en: '](img/B17626_10_010.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_010.jpg)'
- en: Figure 10.10 – The workflow job view for the image-release job
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – 图像发布任务的工作流视图
- en: 'The preceding screenshot shows the `release image` workflow that was triggered
    by pushing the `image-v1.0.0` tag. The following screenshot details the results
    of each step of the `release image` workflow:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图展示了通过推送 `image-v1.0.0` 标签触发的 `release image` 工作流。以下截图详细说明了每个步骤的结果：
- en: '![Figure 10.11 – The image release job output'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.11 – 图像发布作业输出'
- en: '](img/B17626_10_011.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_011.jpg)'
- en: Figure 10.11 – The image release job output
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 图像发布作业输出
- en: The result of the preceding workflow is that we now have a container image pushed
    to `ghcr.io/devopsforgo/tweeter`, tagged with `v1.0.0` and `latest`. We can now
    update the action metadata to use the tagged image version.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 上述工作流的结果是，我们现在将容器镜像推送到了 `ghcr.io/devopsforgo/tweeter`，并标记为 `v1.0.0` 和 `latest`。现在，我们可以更新
    action 的元数据，使用标记的镜像版本。
- en: Optimizing the custom Go action
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化自定义 Go action
- en: The final goal of this section is optimizing the tweeter custom action by using
    the published container image.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最终目标是通过使用已发布的容器镜像来优化 tweeter 自定义 action。
- en: 'Now that we have the image published to `ghcr.io`, we can replace the Dockerfile
    with the reference to the published image:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将镜像发布到 `ghcr.io`，我们可以用已发布的镜像引用替换 Dockerfile：
- en: '[PRE39]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The preceding portion of the `action.yaml` file illustrates replacing the Dockerfile
    with the published tweeter container image. Now that the Dockerfile has been replaced,
    let''s run the workflow and see the performance optimization in action:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 上面 `action.yaml` 文件的部分展示了如何将 Dockerfile 替换为已发布的 tweeter 容器镜像。既然 Dockerfile 已被替换，让我们运行工作流，看看性能优化的实际效果：
- en: '![Figure 10.12 – The workflow view showing the speed increase of the test-action
    job'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.12 – 显示测试动作作业速度提升的工作流视图'
- en: '](img/B17626_10_012.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_012.jpg)'
- en: Figure 10.12 – The workflow view showing the speed increase of the test-action
    job
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 显示测试动作作业速度提升的工作流视图
- en: The preceding screenshot illustrates the gains from using a pre-built container
    image. Recall, when using a Dockerfile, that the workflow execution was 54 seconds.
    Now, using the tweeter container image from the registry, the workflow executes
    in 11 seconds. This is a significant optimization and should be used when possible.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的截图展示了使用预构建容器镜像带来的好处。回想一下，当使用 Dockerfile 时，工作流执行时间为 54 秒。而现在，使用来自注册表的 tweeter
    容器镜像，工作流在 11 秒内执行完毕。这是一个显著的优化，应该在可能的情况下使用。
- en: In this section, we learned to build custom actions using Go, which enables
    a DevOps engineer to build complex actions and package them in easily accessible
    units of automation. We also learned how to test and optimize these actions locally,
    ensuring that when custom actions are published, they function as intended.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了如何使用 Go 构建自定义 actions，这使得 DevOps 工程师能够构建复杂的 actions，并将它们打包成易于访问的自动化单元。我们还学习了如何在本地测试和优化这些
    actions，确保当自定义 actions 发布时，它们能够按预期工作。
- en: In the next section, we will build upon the ability to author custom actions
    and publish an action to the entire GitHub community. By publishing an action
    to the GitHub marketplace, an action can become a key tool for other DevOps engineers
    authoring automation.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将基于编写自定义 actions 的能力，发布一个 action 给整个 GitHub 社区。通过将 action 发布到 GitHub
    Marketplace，action 可以成为其他 DevOps 工程师编写自动化工具的关键工具。
- en: Publishing a custom Go GitHub Action
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布自定义 Go GitHub Action
- en: The superpower of GitHub Actions is the community and the actions that the community
    publishes to the GitHub Marketplace. Think about how much more work we would have
    had to do in the previous sections if we didn't have community actions available
    for use. Our workflows would have had to start from first principles, involving
    authoring long, tedious scripts to complete tasks that we were able to express
    in a handful of YAML instead.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 的超级力量在于社区以及社区发布到 GitHub Marketplace 的 actions。试想，如果没有社区 actions
    可用，我们在前面的章节中需要做多少额外的工作。我们的工作流将不得不从基础开始，编写冗长且繁琐的脚本来完成那些我们现在能够用少量 YAML 表达的任务。
- en: Open source software is not only about having access to free software but also
    about giving back to the community. We are going to learn how to give back to
    the GitHub Actions community through publishing an action to GitHub Marketplace.
    This will enable the entire user community of GitHub to benefit from it.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 开源软件不仅仅是拥有免费的软件，还包括回馈社区。我们将学习如何通过将 action 发布到 GitHub Marketplace 来回馈 GitHub
    Actions 社区。这将使整个 GitHub 用户社区都能受益。
- en: In this section, you will learn how to publish a custom action to the GitHub
    Marketplace. You will learn the basics of publishing actions. After covering the
    basics, you will learn how to automate versioning for a published action. You
    will learn how to use the tweeter action to tweet an announcement of new releases
    to tweeter. Finally, you will learn how to publish your action to the GitHub Marketplace
    so that it can be used by the rest of the GitHub community across the world.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何将自定义动作发布到 GitHub 市场。您将了解发布动作的基本知识。掌握基础知识后，您将学习如何自动化发布动作的版本管理。您将学习如何使用
    Twitter 动作发布新版本的公告到 Twitter。最后，您将学习如何将您的动作发布到 GitHub 市场，以便全球其他 GitHub 社区的成员可以使用。
- en: The basics of publishing actions
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布动作的基础知识
- en: Publishing an action to the GitHub Marketplace adds some requirements and best
    practices that, for a local action, as we built in the previous section, do not
    apply. For example, the readme for the repository will be the landing page for
    the action in the marketplace, so you'd want to provide a description and usage
    guidance for the repository readme.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 将动作发布到 GitHub 市场需要满足一些要求和最佳实践，这对于我们在上一节中构建的本地动作是不适用的。例如，仓库的 README 将是动作在市场中的落地页，因此您需要提供仓库
    README 的描述和使用指导。
- en: 'The following are the requirements for publishing an action to the GitHub Marketplace:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将动作发布到 GitHub 市场的要求：
- en: The action must be in a public GitHub repository.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该动作必须位于公共 GitHub 仓库中。
- en: In the root of the repository must be a single action named `action.yaml` or
    `action.yml`.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库的根目录中必须有一个名为 `action.yaml` 或 `action.yml` 的单个动作文件。
- en: The name of the action in `action.yaml` must be unique to the marketplace. The
    name may not overlap with any GitHub features or products, or any other names
    that GitHub reserves.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`action.yaml` 中的动作名称必须是 GitHub 市场中唯一的。该名称不得与任何 GitHub 特性、产品或 GitHub 保留的其他名称重叠。'
- en: A public action should follow `v1` and `v1.2.3` semantic version guidance so
    that users of the action can specify a full semantic version, or simply `v1` to
    denote the latest in the `v1` major semantic version series.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共动作应遵循 `v1` 和 `v1.2.3` 的语义版本规范，以便用户可以指定完整的语义版本，或者仅使用 `v1` 来表示 `v1` 这一大版本系列中的最新版本。
- en: Goals for publishing the tweeter custom action
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布 Twitter 自定义操作的目标
- en: 'The following are goals for publishing the tweeter custom action:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是发布 Twitter 自定义操作的目标：
- en: Set up a release-triggered workflow that will handle semantic version management.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个发布触发的工作流来处理语义版本管理。
- en: Publish the tweeter action to the GitHub Marketplace.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Twitter 动作发布到 GitHub 市场。
- en: Managing action semantic versioning
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理动作的语义版本
- en: 'The first and second goals of publishing the tweeter custom action to the marketplace
    are as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 发布 Twitter 自定义操作到市场的前两个目标如下：
- en: Set up a release-triggered workflow that will handle semantic version management.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个发布触发的工作流来处理语义版本管理。
- en: Use the action to tweet an announcement of the new release of the action.
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此操作发布新版本的动作到 Twitter。
- en: 'We are going to build a workflow to update the major version tag – for example,
    `v1` – to point to the latest release in the `v1.x.x` series of semantic versions.
    The workflow will also be responsible for creating new major version tags as new
    major semantic versions are released:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个工作流来更新大版本标签——例如，`v1`——指向 `v1.x.x` 语义版本系列中的最新发布版本。该工作流还将负责在发布新大版本时创建新的大版本标签：
- en: '[PRE40]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding workflow does the following:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 上述工作流执行以下操作：
- en: Triggers on a release being published or on a manual UI submission. This means
    that a project maintainer can trigger the workflow via the GitHub UI if ad hoc
    execution was required.
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在发布版本或手动 UI 提交时触发。这意味着项目维护者可以通过 GitHub UI 来触发工作流，如果需要临时执行的话。
- en: Declares that the workflow requires rights to write to the repository. This
    is used to write tags.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明工作流需要有对仓库的写权限。此权限用于写入标签。
- en: Declares the `TAG_NAME` environment variable, which is either the ad hoc job
    input or the tag of the release.
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明 `TAG_NAME` 环境变量，该变量可以是临时作业输入或发布的标签。
- en: The `update_tag` takes the tag in `v1.2.3` format and updates the tag's major
    semantic version tag to the latest version within that major semantic version.
    For example, if the new release tag is `v1.2.3`, then the `v1` tag will point
    to the same Git ref as `v1.2.3`.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update_tag`采用`v1.2.3`格式的标签，并将标签的主语义版本更新为该主版本中的最新版本。例如，如果新发布的标签是`v1.2.3`，那么`v1`标签将指向与`v1.2.3`相同的Git引用。'
- en: Clones the source code using `actions/checkout@v2`.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`actions/checkout@v2`克隆源代码。
- en: 'Tweets about the new release using Twitter developer credentials embedded in
    GitHub repository secrets. To set up Twitter developer credentials, see [https://developer.twitter.com/en/portal/dashboard](https://developer.twitter.com/en/portal/dashboard)
    and set up an account and application. After you gather the secrets, you can add
    them to the repository secrets under the **Settings** tab, as shown in the following
    screenshot:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用嵌入在GitHub仓库秘钥中的Twitter开发者凭证发布关于新发布的推文。要设置Twitter开发者凭证，请参见[https://developer.twitter.com/en/portal/dashboard](https://developer.twitter.com/en/portal/dashboard)并设置账户和应用程序。收集凭证后，您可以将它们添加到**设置**选项卡下的仓库秘钥中，如下截图所示：
- en: '![Figure 10.13 – Repository secrets'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.13 – 仓库秘钥'
- en: '](img/B17626_10_013.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_10_013.jpg)'
- en: Figure 10.13 – Repository secrets
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 仓库秘钥
- en: With the preceding workflow, when we apply a tag – for example, `v1.2.3` – the
    repository will also be tagged at the same Git `ref` with `v1`. After the tags
    are set, the tweeter action will execute, announcing the release to the world.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述工作流，在我们应用标签（例如`v1.2.3`）时，仓库也将以相同的Git `ref`标记为`v1`。标签设置完成后，tweeter动作将执行，向全球宣布发布。
- en: Recall from the previous section that when we tag the tweeter repository with
    a semantic version, the release workflow will trigger, causing a new release to
    be created. This workflow will then trigger the action version update release
    workflow, which will tag the action with the major version and announce through
    Twitter that the action release is available.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一节回顾，当我们使用语义版本为tweeter仓库打上标签时，将触发发布工作流程，从而创建新的发布。然后，此工作流将触发动作版本更新发布工作流，该工作流将以主版本标签动作，并通过Twitter宣布动作发布可用。
- en: All that is left to do is to release the action to the GitHub Marketplace. This
    only needs to be done the first time the action is released.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情是将动作发布到GitHub Marketplace。这只需要在首次发布动作时完成。
- en: Publishing the tweeter action to the GitHub Marketplace
  id: totrans-436
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将tweeter动作发布到GitHub Marketplace
- en: 'The final goal of publishing the tweeter custom action is to publish the tweeter
    action to the GitHub Marketplace. The first publication of your GitHub Action
    is a manual process and can be accomplished by following the guide here: [https://docs.github.com/en/actions/creating-actions/publishing-actions-in-github-marketplace](https://docs.github.com/en/actions/creating-actions/publishing-actions-in-github-marketplace).
    After taking this first set of manual steps, they will not need to be repeated
    for future releases.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 发布tweeter自定义动作的最终目标是将tweeter动作发布到GitHub Marketplace。您的GitHub动作的首次发布是一个手动过程，可以通过以下指南完成：[https://docs.github.com/en/actions/creating-actions/publishing-actions-in-github-marketplace](https://docs.github.com/en/actions/creating-actions/publishing-actions-in-github-marketplace)。完成这些首次手动步骤后，未来发布时无需重复。
- en: Summary
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: GitHub Actions is a powerful system for project maintainers to automate toilsome
    processes, enabling greater developer satisfaction and increased project velocity.
    We targeted Go in this chapter as the language of choice for GitHub Actions due
    to its type safety, low memory overhead, and speed. We believe that it is the
    best choice for writing GitHub Actions. However, many of the skills taught here
    are transferable to other languages. Each of the patterns, continuous integration,
    release pipelines, semantic versioning, and action creation can be applied to
    any project that you come into contact with.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions是项目维护者自动化繁琐流程的强大系统，提升开发者满意度和项目速度。在本章中，我们选择了Go作为GitHub Actions的首选语言，因为它具有类型安全性、低内存开销和高速度。我们认为这是编写GitHub
    Actions的最佳选择。然而，这里教授的许多技能也可迁移到其他语言。每个模式，持续集成，发布管道，语义版本控制和动作创建都可以应用于您接触的任何项目中。
- en: The key to the chapter is to understand the impact of community contributions
    in the GitHub Marketplace. By using, building, and contributing to the marketplace,
    an engineer can make their automation more composable and empower community members
    to solve more complex problems through the contributions of the community.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键是理解 GitHub Marketplace 中社区贡献的影响。通过使用、构建和贡献于 Marketplace，工程师可以使他们的自动化更加可组合，并通过社区的贡献，赋能社区成员解决更复杂的问题。
- en: We learned the basics of GitHub Actions with a focus on its features, which
    enable us to be functional quickly. With these basic skills, we were able to build
    a continuous integration automation workflow to clone, build, lint, and test the
    tweeter project. We extended the continuous integration automation to create a
    release pipeline trigger from Git tags. The release pipeline transformed manual
    tasks such as authoring release notes and made them an automated part of the release
    workflow. Finally, we created and published a custom Go GitHub Action that can
    be used by the entire community.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了 GitHub Actions 的基础知识，重点介绍了它的功能，使我们能够快速投入使用。凭借这些基本技能，我们成功构建了一个持续集成的自动化工作流，用于克隆、构建、静态检查和测试
    tweeter 项目。我们进一步扩展了持续集成自动化，创建了一个从 Git 标签触发的发布管道。发布管道将手动任务，如编写发布说明，转变为自动化的一部分。最后，我们创建并发布了一个自定义的
    Go GitHub Action，可以供整个社区使用。
- en: I hope that at the end of this chapter you feel confident in your ability to
    create automation to eliminate toilsome tasks that burdened your team's day. Remember
    that if you can automate a task that happens once a week and takes an hour, you
    are saving a full week of work from one of your team members! That is time that
    is likely better spent adding value to your business.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望在本章结束时，你能自信地掌握创建自动化的能力，从而消除那些困扰你团队日常工作的繁琐任务。记住，如果你能自动化一个每周发生一次且需要一个小时的任务，你就相当于为你的团队成员节省了一整周的工作时间！这些时间很可能能更好地用来为你的业务增值。
- en: In the next chapter, we are going to learn about ChatOps. You will learn how
    to use chat applications such as Slack to trigger automation and alerts when events
    occur, providing you and your team an interactive robotic DevOps partner.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习 ChatOps。你将学习如何使用聊天应用程序，如 Slack，当事件发生时触发自动化和警报，为你和你的团队提供一个互动的机器人 DevOps
    合作伙伴。
