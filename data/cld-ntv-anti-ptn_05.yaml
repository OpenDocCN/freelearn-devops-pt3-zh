- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Delivering Rapidly and Continuously Without Compromising Security
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速且持续地交付而不妥协安全性
- en: So far, we have looked at the organizational changes required for cloud native
    development. In this chapter, we will start to look at the cultural and development
    practices that are required for a shift to cloud native. When shifting to cloud
    native software development, we’re sold the dream of rapid delivery and secure
    systems. However, this can only be achieved in practice with corresponding organizational
    and cultural change. Let’s explore how common anti-patterns in our software delivery
    life cycle can interrupt our journey to becoming a high-performing cloud native
    organization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了云原生开发所需的组织变革。在本章中，我们将开始探讨为了向云原生转型所需的文化和开发实践。在转向云原生软件开发时，我们常常被快速交付和安全系统的梦想所吸引。然而，只有在实现了相应的组织和文化变革后，这一目标才能在实践中实现。让我们探讨在软件交付生命周期中常见的反模式是如何干扰我们成为高绩效云原生组织的道路的。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Underestimating the cultural impact
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低估文化影响
- en: Frequent change to meet business needs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 频繁变更以满足业务需求
- en: Guardrails
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防护栏
- en: Shifting left
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左移动
- en: Self-sufficient teams
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自给自足的团队
- en: Underestimating the cultural impact
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低估文化影响
- en: Delivering cloud native projects rapidly and securely is primarily a cultural
    change. The technical and business process changes required to excel at cloud
    native delivery support cultural changes. We need to align the mentality of the
    team working on the project toward shared ownership of outcomes, breaking down
    the silos that may be present in the existing delivery process. The team that
    produces a change or feature should be responsible for its delivery into the production
    environment. This shift is the most fundamental aspect of delivering rapidly.
    In this section, we will start by reviewing a typical deployment process that
    we see often in clients who are just beginning their cloud native journey.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 快速且安全地交付云原生项目主要是一种文化变革。为云原生交付所需的技术和业务流程变革，支持着文化变革。我们需要使团队的心态与结果的共同责任对齐，打破现有交付过程中可能存在的孤岛。产生变更或功能的团队应负责将其交付到生产环境中。这一转变是快速交付的最根本方面。在本节中，我们将从回顾一个常见的部署流程开始，这个流程通常出现在刚刚开始云原生之旅的客户中。
- en: The siloed model – a long road to production
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 孤岛式模型 – 通向生产的漫长道路
- en: Let’s examine a well-intentioned yet siloed delivery process that is usually
    the artifact of taking an on-premises approach to releases and applying it to
    cloud native delivery.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个良好意图却仍然是孤岛式的交付流程，通常这是将本地发布方法应用于云原生交付时产生的产物。
- en: '![Figure 5.1 – A typical siloed release process – many touchpoints with little
    end-to-end ownership](img/B22364_05_1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 一个典型的孤岛式发布流程 – 有许多接触点，但缺乏端到端的责任](img/B22364_05_1.jpg)'
- en: Figure 5.1 – A typical siloed release process – many touchpoints with little
    end-to-end ownership
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – 一个典型的孤岛式发布流程 – 有许多接触点，但缺乏端到端的责任
- en: This model works when releases are large, cumbersome processes that take significant
    effort to deploy, and the consequences of pushing a bad change are complex to
    recover from. We might use this model when deploying to a fleet of on-premises
    customer servers of varying capacity and capability. In the cloud, these constraints
    do not exist. We can make rapid changes with quick remediation if something goes
    wrong; a single, unified, homogenous production environment simplifies deployment
    and remediation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当发布过程庞大且繁琐，需要大量努力才能部署，并且推送不良变更的后果很难恢复时，这种模型是有效的。我们可能会在部署到具有不同容量和能力的本地客户服务器群时使用该模型。而在云环境中，这些限制并不存在。如果出现问题，我们可以迅速进行更改并快速修复；单一、统一、同质化的生产环境简化了部署和修复过程。
- en: Under this model, we heavily scrutinize all code before it reaches our production
    environment. However, its rigidity is also its downfall. When something inevitably
    goes wrong in one of these stages, the process, more commonly, is that the developer,
    who has already begun working on the next feature, must drop what they’re doing
    to create a fix applied at the level of review reached. It’s unlikely that this
    last-minute change will go through the review process as the process cannot afford
    to start over.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模式下，我们会对所有代码进行严格审查，确保它在进入生产环境之前无误。然而，它的僵化性也是其缺点。当其中某个阶段不可避免地出错时，通常的做法是，开发者已经开始着手下一个功能时，必须放下手头的工作，去修复已经达到审查阶段的错误。这个临时的变更很可能不会经过审查流程，因为该流程无法承受从头开始的风险。
- en: DORA – measuring the road
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DORA – 衡量道路
- en: “*If you can’t measure it, you cannot improve it*.” We understand that the siloed
    model is limiting when applied to cloud native software, but as we change our
    delivery process, how do we know that our changes are shifting our business in
    the right direction?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: “*如果你不能衡量它，你就无法改进它*。”我们理解，当应用于云原生软件时，孤立的模型是有限制的，但当我们改变交付过程时，我们如何知道我们的变更正在把业务推向正确的方向？
- en: 'Earlier, in [*Chapter 1*](B22364_01.xhtml#_idTextAnchor015), we introduced
    the DORA metrics to measure how well teams perform. If you are interested in the
    science behind these metrics, we recommend reading the DORA report or *Accelerate:
    The Science of Lean Software and DevOps: Building and Scaling High Performing
    Technology Organizations*. To recap, these metrics are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面，[*第1章*](B22364_01.xhtml#_idTextAnchor015)中，我们介绍了DORA指标来衡量团队的表现。如果你对这些指标背后的科学感兴趣，我们推荐阅读《DORA报告》或《加速：精益软件和DevOps科学：构建与扩展高效能技术组织》。回顾一下，这些指标如下：
- en: Deployment frequency
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署频率
- en: Lead time for changes
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更的前置时间
- en: Change failure rate
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变更失败率
- en: Time to restore service
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复服务的时间
- en: If these are the metrics that most accurately predict team performance, we can
    see that ownership of delivery is not optional.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些是最准确预测团队表现的指标，我们可以看到交付的责任不是可选的。
- en: Deployment frequency is suboptimal in the siloed configuration as we are tied
    to such an arduous release process. This release process also dictates our lead
    time for changes, as any changes must be aligned with the estimated schedule.
    We are also deploying much larger bundles of code at a time so that the chances
    of one of the features in the deployed bundle causing a change failure is now
    much higher, as the likelihood is now the sum of the likelihoods of each of the
    sub-components. Finally, the time to restore service is also much greater due
    to either rolling back a large change or sifting through a large release to find
    the culprit and apply a hotfix (which is also unlikely to go through the release
    process).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在孤立配置中，部署频率是次优的，因为我们被束缚在繁琐的发布过程中。这个发布过程还决定了我们变更的前置时间，因为所有变更必须与预估的时间表对齐。我们同时还在部署更大规模的代码包，这使得其中某个特性导致变更失败的几率大大增加，因为这个概率现在是每个子组件概率的总和。最后，恢复服务的时间也因为要回滚大量变更或从庞大的发布中筛选出问题并进行热修复（这也很可能不会经过发布过程）而大大增加。
- en: Leaving aside the metrics for high-performing teams, we also run into another
    issue around ownership. Who owns this change and is responsible for its success?
    The developer who wrote it? The change approval board that approved it? If it’s
    a security issue, does ownership lie with the security team? Siloing the release
    process also means siloing the ownership; without end-to-end ownership of the
    process, problems are much harder to fix.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 摒弃高效团队的指标，我们还会遇到另一个关于责任的问题。谁负责这个变更并对其成功负责？是写代码的开发者吗？是批准变更的审批委员会吗？如果是安全问题，责任是否属于安全团队？将发布过程孤立也意味着孤立了责任；没有端到端的过程责任，问题就更难解决。
- en: Empowered teams – increasing your speed
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权团队 – 提升你的速度
- en: This brings us back to the concept of empowered teams. If your team wrote it,
    you are responsible for its entire journey into production. Or, more succinctly,
    “*You build it, you run it*.” We can’t just throw all of our teams in the deep
    end and expect them to swim; they need to be supported. This is where those siloed
    teams from before come into play. They shift from being the gatekeepers of the
    journey toward the production environment to enablers of the dev team to undertake
    that journey themselves.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们带回到赋能团队的概念。如果是你的团队编写的代码，你就负责它从开发到生产的整个过程。或者更简洁地说，“*你建造它，你运行它*。”我们不能把所有团队丢到深水区，然后指望他们游得起来；他们需要得到支持。这时之前那些孤立的团队就发挥作用了。它们从生产环境之旅的守门人转变为帮助开发团队自行承担这段旅程的推动者。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Empowering and supporting teams to own their output is the core of rapid and
    secure delivery.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 赋能并支持团队拥有他们的输出是快速和安全交付的核心。
- en: Hence, to deliver rapidly without compromising security, the cultural shift
    is one of the most essential aspects, while also being an aspect that companies
    fail to target. For a team to own its output, each must have the skills and capabilities
    required to deliver a piece of work end to end, either internally through forming
    cross-functional teams or externally through an enabling team. Later in this chapter,
    we will explore ways to approach this from a shift-left and push-down approach.
    The key here is not to hand all control over to delivery teams but to ensure they
    are empowered and supported by those traditionally siloed functions to own their
    output.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了在不妥协安全性的情况下快速交付，文化转变是最重要的方面之一，同时也是公司未能着重解决的方面。为了让团队拥有自己的输出，每个团队必须具备交付工作所需的技能和能力，或者通过组建跨职能团队在内部实现，或者通过赋能团队在外部实现。本章后面我们将探讨如何通过“左移”和“下压”的方法来解决这个问题。关键在于，不能将所有控制权交给交付团队，而是要确保他们获得传统孤立职能的赋能和支持，才能真正拥有自己的输出。
- en: The easiest way to do this is to provide both the carrot and the stick to the
    development team. Enabling teams must produce platforms and artifacts the development
    team can consume to do their jobs in line with company standards. This might be
    in the form of authentication libraries, infrastructure as code patterns, common
    UI component libraries, and so on. Then, the enabling team should seek to automate
    guardrails to enable the developers to ensure that the code they are producing
    meets the same standards that had been manually enforced. This could be through
    the use of QA testing suites, **static application security testing** (**SAST**),
    and automated ticket creation systems for site reliability alarms in the observability
    platform. By enabling developers in this way, we empower them to own their output
    and shift left the responsibility of the deployment process.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是同时给开发团队提供胡萝卜和大棒。赋能团队必须提供开发团队能够使用的平台和工件，以便他们按照公司标准完成工作。这可能以身份验证库、基础设施即代码模式、通用UI组件库等形式呈现。接着，赋能团队应当努力自动化“护栏”，以帮助开发人员确保他们所编写的代码符合之前手动执行的标准。这可以通过使用QA测试套件、**静态应用安全测试**（**SAST**）和在可观察性平台中为站点可靠性警报自动创建工单系统来实现。通过这种方式赋能开发人员，我们让他们能够拥有自己的输出，并将部署过程的责任向左移。
- en: DevSecOps – the super-highway to production
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DevSecOps – 通往生产的高速公路
- en: 'Let’s now revisit our deployment model:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们回顾一下我们的部署模型：
- en: '![Figure 5.2 – Target state for ownership of deployable artifacts](img/B22364_05_2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 可部署工件所有权的目标状态](img/B22364_05_2.jpg)'
- en: Figure 5.2 – Target state for ownership of deployable artifacts
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 可部署工件所有权的目标状态
- en: 'Our other teams have remained in the organization. Instead, they are maintaining
    three sets of artifacts:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的其他团队依然留在组织中。相反，他们维护着三组工件：
- en: '**Platform tools**: The systems and artifacts that developers consume to produce
    software artifacts that align with the responsible team’s requirements, such as
    shared auth libraries, structured logging libraries, or cloud infrastructure modules.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台工具**：开发人员用于生产符合责任团队需求的软件工件的系统和工具，例如共享的身份验证库、结构化日志库或云基础设施模块。'
- en: '**Automated pipeline**: This pipeline codifies each team’s expectations instead
    of relying on a manual review. As mentioned earlier, this may include QA automated
    tests, SAST, or container scanning tools.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化流水线**：此流水线规范了每个团队的期望，而不是依赖于手动审查。如前所述，这可能包括自动化QA测试、SAST或容器扫描工具。'
- en: '**Observability platform**: This platform codifies the expectations around
    the application’s performance and alerts developers for situations outside of
    normal operating parameters while storing information about these events.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察性平台**：该平台规范了关于应用程序性能的期望，并在操作超出正常参数的情况下，提醒开发人员，同时存储关于这些事件的信息。'
- en: The key difference here is that instead of the development team interfacing
    with five different teams to push features out to production, the development
    team is empowered to own the code they produce and deploy artifacts that meet
    a baseline standard to production. They can also see how the artifacts they produce
    perform through the observability platform. Hence, we’ve shifted the culture away
    from gatekeeping to enablement. This is the crux of DevSecOps, enabling software
    teams to develop, secure, and operate the code they write.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键区别在于，开发团队不再需要与五个不同的团队对接来将特性推送到生产环境，而是有能力拥有他们所编写的代码，并将符合基准标准的工件部署到生产环境。他们还可以通过可观察性平台查看他们生产的工件的性能。因此，我们已经将文化从守门转变为赋能。这正是DevSecOps的核心，赋能软件团队开发、保障和运营他们所编写的代码。
- en: The magnitude of this change is typically underestimated in organizations undergoing
    a cloud native transformation. People can take offense to being taken off the
    critical path, considering that they relinquish some power they previously had.
    The mindset to install in these teams is that they are no longer at odds with
    the development team by stopping them from deploying to production but instead
    are stewards of their specialty for the development teams, producing artifacts
    and providing insights that help guide the development teams toward their own
    secure, high-quality, observable artifacts.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化的规模在经历云原生转型的组织中通常被低估。人们可能会对被从关键路径上移除感到反感，因为这意味着他们放弃了之前拥有的一部分权力。需要在这些团队中树立的心态是，他们不再通过阻止开发团队部署到生产环境来与开发团队对立，而是成为开发团队的专业领域的管理者，提供文档并提供洞察，帮助引导开发团队朝着自己的安全、高质量、可观察的工件前进。
- en: As a result, development teams become more cross-functional, and team members
    need to upskill in security, quality assurance, and site reliability engineering
    under the guidance of these enabling teams.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，开发团队变得更加跨职能，团队成员需要在这些支持团队的指导下，提升安全性、质量保证和站点可靠性工程的技能。
- en: 'We can now see a few distinct advantages of reducing these friction points:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看到减少这些摩擦点的几个明显优势：
- en: Deployment frequency increases as we no longer bundle on a schedule but instead
    deploy as soon as possible. This also results in a much shorter change lead time,
    as once a change is ready and passes our pipeline checks, it can easily be deployed
    to production.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署频率提高，因为我们不再按计划打包，而是尽快部署。这也导致了更短的变更交付时间，因为一旦变更准备好并通过了我们的流水线检查，它就可以轻松地部署到生产环境。
- en: We are now deploying much smaller units of code that often contain only a few
    features, which decreases the likelihood of the change failing and reduces our
    change failure rate.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在部署的是更小的代码单元，通常只包含几个特性，这减少了变更失败的可能性，并降低了变更失败率。
- en: We have a platform to observe our application, which means that a change that
    results in an outage can quickly be identified, and a fix can be pushed through
    the automated pipeline. This is a key difference as, typically, hotfixes needed
    to be applied out of band, and we could not afford to run the fix through the
    whole pipeline. Instead, the automated pipeline can still be used as the developers
    do not need to interface with other teams to deploy the rectification. Hence,
    we have shifted toward a process of **continuous improvement and continuous**
    **delivery** (**CI/CD**).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个平台来观察我们的应用程序，这意味着任何导致停机的变更都能迅速被识别，并且修复可以通过自动化流水线推送。这是一个关键的区别，因为通常情况下，热修复需要脱带应用，而我们无法将修复通过整个流水线运行。相反，自动化流水线仍然可以使用，因为开发人员无需与其他团队接触就能部署修复。因此，我们已经转向了**持续改进和持续交付**（**CI/CD**）的过程。
- en: Staying on the road
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持在正轨上
- en: Another fallacy that companies can quickly fall into is the belief that delivering
    features using DevSecOps and CI/CD principles will result in a large increase
    in development velocity, which means tighter deadlines. While it is true that
    the underlying improvements in the process will translate to the faster delivery
    of features, focusing solely on delivery timelines will ultimately undermine efficiency
    gains by the cultural shift.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个公司可能很容易陷入的谬误是，认为使用DevSecOps和CI/CD原则交付特性将导致开发速度的大幅提升，这意味着更紧迫的截止日期。虽然确实，流程中基础的改进会转化为特性的更快交付，但仅仅专注于交付时间表，最终会因为文化转变而破坏效率提升。
- en: If you are migrating from a fixed release schedule with tight deadlines and
    rigid business processes, it can be tempting to translate that directly into delivery
    schedules in the new paradigm. Instead, by decoupling feature work from the release
    process, we allow our development teams to obsess over output quality and only
    release features when ready from a multifaceted perspective. This ensures that
    we retain our increase in development velocity without compromising on code quality,
    and this leads us to a sustainable, rather than temporary, increase in development
    velocity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在从一个有固定发布时间表、严格的截止日期和僵化的业务流程中迁移过来，可能会很诱人地将这种方式直接转化为新范式中的交付时间表。相反，通过将特性工作与发布过程解耦，我们让开发团队专注于输出质量，只有在从多方面角度准备好时才发布特性。这确保了我们在不妥协代码质量的前提下保持开发速度的提升，从而带来的是可持续的，而非暂时的，开发速度提升。
- en: Conway’s law states, “*Organizations which design systems are constrained to
    produce designs which are copies of the communication structures of these organizations*.”
    When we allow our teams to be siloed, we inevitably constrain their output to
    a particular part of the development/deployment process and their responsibilities
    and produce a deployment process replicating those teams’ communication pathways.
    Therefore, the logical conclusion is that to maintain all of the cultural changes
    we have prescribed in this chapter, we must encourage our teams to become self-sufficient.
    This enables the automated, independent production of change that we desire.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 康威定律指出，“*设计系统的组织会被约束，以生产出这些组织通信结构的副本*。”当我们让团队之间形成孤岛时，我们不可避免地将他们的输出限制在开发/部署过程的某一特定部分及其职责上，并产生一个复制这些团队通信路径的部署过程。因此，合乎逻辑的结论是，为了保持我们在本章中所规定的所有文化变革，我们必须鼓励团队实现自给自足。这将使我们能够自动化并独立地进行变更生产，这是我们所期望的。
- en: Drawing a new map
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绘制一张新地图
- en: Finally, as we shift to fully cloud native, one of the hardest anti-patterns
    to break can be the coupling between services and the compute they run on. New
    services are cheap to create, maintain, and run. Hence, we can form bounded service
    contexts that encapsulate a business domain.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们完全转向云原生时，最难打破的反模式之一可能是服务与其运行的计算资源之间的耦合。新服务的创建、维护和运行成本低廉。因此，我们可以形成有限的服务上下文，封装一个业务领域。
- en: '*Domain Driven Design* is a great read in this space; it goes into this topic
    in great detail. This allows us to evolve our architecture to meet our business
    domain needs rather than apply our business needs to our architecture because
    we installed a particular number of servers. Later in this book, we will dive
    into translating your business problems into application code and introduce the
    concepts of coupling and cohesion. The key for this chapter is to break the mentality
    that your architecture must fit into a predefined configuration. Conway’s law
    also applies to your architecture, and just as we break down silos in the deployment
    process, we must also break down silos between development teams to enable us
    to build the right solution in the right place.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*领域驱动设计* 是该领域的一本好书；它深入探讨了这一主题。这使我们能够根据业务领域的需求演进我们的架构，而不是因为我们安装了特定数量的服务器就将业务需求强加给架构。稍后本书将深入探讨如何将你的业务问题转化为应用代码，并介绍耦合和内聚的概念。本章的关键是打破架构必须适应预定义配置的思维方式。康威定律同样适用于你的架构，正如我们在部署过程中打破孤岛一样，我们还必须打破开发团队之间的孤岛，以使我们能够在正确的地方构建正确的解决方案。'
- en: As we can see, the cultural shift required to create genuinely cloud native
    solutions can take some organizations by surprise, so it is crucial to consider
    its magnitude. The key shift in thinking is about empowering and enabling teams
    to be self-sufficient and own their delivery from feature inception to running
    it in production through a cultural change from a siloed ownership and delivery
    model to a lean ownership model where developers are responsible for the changes
    they make, supported through DevSecOps enablement. Empowered development will
    allow us to deliver change faster, so let’s dive into how to enable frequent atomic
    changes to meet our business goals.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，创建真正的云原生解决方案所需的文化转变可能会让一些组织感到措手不及，因此必须充分考虑其影响力。思维的核心转变在于赋能团队，使其自给自足，并拥有从功能构想到生产环境运行的交付全过程，通过从孤立所有权和交付模式转变为精益所有权模式，开发人员对自己所做的变更负责，并通过
    DevSecOps 能力得到支持。赋能开发将使我们能够更快地交付变更，因此让我们深入探讨如何实现频繁的小型变更以达成我们的业务目标。
- en: Frequent changes to meet business goals
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了实现业务目标频繁地进行变更
- en: In the previous chapter, we introduced the concept of the empowered development
    team. We worked on reducing the silos in the release process to allow ownership
    of the end-to-end release process. With this process, we can release much more
    frequently. Let’s explore the development changes that are enabling us to work
    under this new paradigm.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了“赋能开发团队”的概念。我们着重于减少发布过程中的孤岛现象，使得团队能够拥有端到端的发布过程。在这一过程中，我们能够更频繁地发布新版本。让我们深入探讨那些使我们能够在这种新范式下工作的开发变更。
- en: Pruning Git branches
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修剪 Git 分支
- en: Most deployment strategies will be multi-stage. For example, you may have environments
    called *development*, *integration testing*, and *production*. The understanding
    is that earlier environments have changes deployed first, so we can test our changes
    before being released to the production environment. Having multi-stage deployments
    is a pattern we recommend as it allows for the testing of features, either by
    the development team or through automated tests against a live environment, before
    we deploy the changes to production. With this strategy, adopting a pattern such
    as Gitflow may be tempting, where each environment is a self-contained branch.
    Let’s look at a typical Gitflow implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数部署策略都会是多阶段的。例如，您可能会有名为 *开发*、*集成测试* 和 *生产* 的环境。基本理解是，较早的环境会先部署变更，这样我们就可以在将变更发布到生产环境之前进行测试。在多阶段部署模式下，我们推荐的一个模式是先在较低环境中测试功能，由开发团队或通过自动化测试对实时环境进行验证，然后再将变更部署到生产环境。采用这种策略时，可能会倾向于使用
    Gitflow 模式，其中每个环境都是一个独立的分支。让我们来看一下典型的 Gitflow 实现。
- en: '![Figure 5.3 – Typical Gitflow branching model](img/B22364_05_3.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 典型 Gitflow 分支模型](img/B22364_05_3.jpg)'
- en: Figure 5.3 – Typical Gitflow branching model
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 典型 Gitflow 分支模型
- en: This anti-pattern produces a false sense of security as we assume the changes
    are thoroughly tested in the lower environments before we push them to higher
    environments. However, with more people working on the code base and teams applying
    hotfixes, each branch’s contents will tend to drift over time. In the preceding
    diagram, we can see that we applied a hotfix to production, and the first time
    we tested our deployed feature alongside the hotfix, it was actually in the production
    environment. This uncertainty is the risk we run when maintaining environment-specific
    code bases. It also leans toward a backslide in cultural attitudes, as the temptation
    to introduce manual checks between environment promotions can be detrimental.
    Instead, the principle of a single code base deployed multiple times limits our
    environmental drift. An excellent online resource, *The 12 Factor App*, ([12factor.net](http://12factor.net))
    adopts this as the first factor.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种反模式会产生一种错误的安全感，因为我们假设变更在推送到更高环境之前已经在较低环境中经过了充分的测试。然而，随着更多的人参与到代码库中，并且团队在应用热修复时，每个分支的内容随着时间的推移会逐渐发生偏差。在前面的图示中，我们可以看到我们对生产环境应用了热修复，而我们第一次测试我们的已部署功能时，它实际上是在生产环境中进行的。这种不确定性就是我们在维护特定环境代码库时面临的风险。它也会导致文化态度的倒退，因为在环境迁移之间引入手动检查的诱惑可能会带来不良后果。相反，采用单一代码库多次部署的原则能有效限制环境偏差。一个非常好的在线资源《12
    因素应用》（*The 12 Factor App*），([12factor.net](http://12factor.net)) 将其作为第一项原则。
- en: So, how do we operate a single code base effectively? Selecting a revision-based
    branching strategy, such as trunk-based development, is the easiest way to ensure
    that we operate from a single code base. Instead of an environment running the
    latest configuration in an environment branch, we have rules for running the last
    known correct configuration in a single branch, which we will promote to higher
    environments on an as-needed basis. Let’s take a look at the typical trunk-based
    development model.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何有效地操作单一代码库呢？选择基于修订的分支策略，比如基于主干的开发，是确保我们从单一代码库中操作的最简单方法。我们不是让某个环境在环境分支中运行最新配置，而是为运行已知的最后正确配置在单一分支中制定规则，并在需要时将其推广到更高环境。让我们来看一下典型的基于主干的开发模型。
- en: '![Figure 5.4 – Trunk-based development branching model](img/B22364_05_4.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 基于主干的开发分支模型](img/B22364_05_4.jpg)'
- en: Figure 5.4 – Trunk-based development branching model
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 基于主干的开发分支模型
- en: In this example, each environment is deployed off the main branch, with lower
    environments having the most recent changes for testing and higher environments
    trailing behind on the main branch. By continuously integrating and deploying,
    we reduce our change lead time and increase our deployment frequency.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每个环境都是从主分支部署的，较低环境会包含最新的更改以供测试，而较高环境则落后于主分支。通过持续集成和部署，我们减少了变更的交付时间，并增加了部署频率。
- en: Decoupling integration and release
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解耦集成和发布
- en: 'Now the complexity of promoting each environment is taken care of, we run into
    a problem not apparent in the branch or code base per environment system. How
    do we test or change features in one environment but stop them from blocking other
    features from deploying in higher environments? In the previous system, we could
    cherry-pick commits to promote specific features. The answer to this is twofold:
    we want an easy way for developers to test their features before merging them
    and an easy way to manage merged features in different environments.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，提升每个环境的复杂性已经得到解决，但我们遇到了一个在按环境分支或代码库系统中并不明显的问题。我们如何在一个环境中测试或更改功能，但又不让它们阻碍其他功能在更高环境中的部署呢？在之前的系统中，我们可以挑选提交来推广特定功能。解决这个问题的方法是双重的：我们需要一个简单的方式让开发人员在合并之前测试他们的功能，并且需要一个简单的方式来管理在不同环境中已合并的功能。
- en: The simplest solution to manage merged features is to decouple the expression
    of a feature in the end product from its inclusion in the code base. For example,
    a feature can be complete and merged but not present in the deployed system. To
    achieve this, we use a concept known as **feature flags**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 管理已合并功能的最简单方法是将功能在最终产品中的表现与其在代码库中的包含解耦。例如，一个功能可以已经完成并合并，但不出现在已部署的系统中。为了实现这一点，我们使用了一个被称为**功能标志**的概念。
- en: Feature flags allow us to guard specific clauses in our application. A simple
    example would be a `if` statement, and if the feature flag is off, then we wouldn’t
    show the button. When the development team works on this feature locally, they
    can turn the feature flag on for testing. The deployed environments don’t have
    the feature flag turned on, so we can merge the feature into the main code base
    without impacting the deployed application. Once the feature is complete, we can
    turn the feature on in lower environments to test the feature in an actual environment.
    By decoupling the development of a feature from its expression in the end app,
    we also decouple the release decision for a feature from being technically driven
    (i.e., the feature is present in the code base and, therefore, it will be present
    in the deployed application) to a business decision; we can add features on demand.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志允许我们在应用程序中保护特定的条款。一个简单的例子是 `if` 语句，如果功能标志关闭，那么我们就不会显示按钮。当开发团队在本地开发此功能时，可以打开功能标志进行测试。已部署的环境没有打开功能标志，因此我们可以将该功能合并到主代码库中，而不会影响已部署的应用程序。一旦功能完成，我们可以在较低环境中打开功能标志，以便在实际环境中测试该功能。通过将功能的开发与其在最终应用中的表现解耦，我们还将功能发布决策从技术驱动（即，功能已存在于代码库中，因此它将出现在已部署的应用程序中）解耦到业务决策层面；我们可以根据需求添加功能。
- en: To truly decouple the feature release decision from the technical implementation,
    it’s crucial to store feature configuration within the application environment.
    In this case, an anti-pattern would be to have files checked into version control
    called `features.prod.yml` and `features.dev.yml`, as, once again, we are creating
    checked-in concretions in our code base.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要真正将功能发布决策与技术实现解耦，将功能配置存储在应用环境中至关重要。在这种情况下，反模式是将名为`features.prod.yml`和`features.dev.yml`的文件提交到版本控制中，因为我们再次在代码库中创建了具体化的检入物。
- en: The best methodology for feature flagging is to check in a file to version control
    that defines the feature flags available and their state. In this file, we prefer
    to use something other than Booleans for feature flags as they become hard to
    extend later. Typically, we rely on enums. An example enum might consist of values
    called `Baseline`, `Configurable`, and `Off`. In this scenario, `Baseline` ensures
    a feature is on in all environments and is turned on by default when we deploy
    new environments. These flags represent mature features that are stable enough
    to be always on and are safe to use as the basis for new features. `Configurable`
    flags are features that we want to be able to change the expression of in various
    environments. These might indicate yet-to-be-released features, features that
    are undergoing testing, or features that are incomplete but in a usable state.
    These features need a way to be either on or off in deployed environments. We
    can achieve this through application configuration if the system is small or backed
    by a database table if the feature list is extensive. Finally, we have features
    configured as `Off`; these are feature flags that should not be available on any
    environments but are for features that are a work in progress and need to be able
    to be expressed locally.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 特征标志的最佳方法是向版本控制中检入一个文件，该文件定义了可用的特征标志及其状态。在此文件中，我们更喜欢使用非布尔值来表示特征标志，因为这样后续扩展起来更加困难。通常，我们依赖枚举。例如，一个枚举可以包含名为`Baseline`、`Configurable`和`Off`的值。在这种情况下，`Baseline`确保在所有环境中都启用了一个特征，并且在我们部署新环境时默认启用。这些标志代表了成熟的功能，稳定到可以始终启用，并且可以安全地用作新功能的基础。`Configurable`标志是我们希望能够在各种环境中更改其表达方式的特性。这些可能表示尚未发布的特性、正在测试的特性或尚未完成但处于可用状态的特性。这些特性需要在部署环境中可以打开或关闭的方法。如果系统规模较小，我们可以通过应用配置来实现这一点；如果功能列表很长，我们可以通过数据库表来支持。最后，我们有配置为`Off`的特性；这些是不应在任何环境中可用的特性标志，但是它们用于正在进行中的功能，并且需要能够在本地表达。
- en: To address the problem of developers needing to test locally, this is where
    the advantages of building cloud native software shine. A common anti-pattern
    we see is attempting to replicate the cloud in a local environment, and many services
    do this. However, there is no substitute for actively running your code in the
    cloud. With cloud native software, using principles such as **infrastructure as
    code** (**IaC**) and serverless/managed services, there is no reason why developers
    cannot spin up an isolated development cloud environment. This practice allows
    your developers to truly develop in the cloud. It also ensures your IaC avoids
    its anti-patterns, such as hardcoded references, as we regularly create and destroy
    new environments. The development team can now also test infrastructure changes
    independent of deployed environments. This decoupling feeds into the concept of
    empowered teams; developers can now control the code that runs, the infrastructure
    it runs on, and the services it interacts with. They also gain familiarity with
    the deployment process and get closer to the ideal of “*You build it, you run
    it*.” By allowing our developers to test in the cloud with a blast radius limited
    to the ephemeral environment they are testing in, we enable much more destructive
    types of testing. My load test on my ephemeral environment will not impact your
    testing on your ephemeral environment. By allowing this type of comprehensive
    testing in the pipeline, we reduce our change failure rate.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决开发者需要本地测试的问题，这正是构建云原生软件的优势所在。我们常见的一个反模式是试图在本地环境中复制云环境，许多服务都会这样做。然而，没有什么能替代在云中实际运行你的代码。使用云原生软件，利用**基础设施即代码**（**IaC**）和无服务器/托管服务等原则，开发者完全可以创建一个隔离的开发云环境。这个做法让开发者真正能够在云中开发。它还确保了你的IaC避免了反模式，比如硬编码引用，因为我们会定期创建和销毁新环境。开发团队现在也可以独立于已部署环境测试基础设施变更。这种解耦有助于强化“授权团队”这一概念；开发者现在可以控制运行的代码、其运行的基础设施以及它与之交互的服务。他们还熟悉部署过程，更接近“*你构建，你运维*”的理想状态。通过让开发者在云中进行测试，并将测试范围限制在他们正在测试的短暂环境中，我们可以进行更多具有破坏性的测试。我在短暂环境上的负载测试不会影响你在你自己的短暂环境中的测试。通过在管道中允许这种类型的全面测试，我们降低了变更失败率。
- en: Reversing the inevitable
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逆转不可避免的变更
- en: 'No system is perfect, and as we increase the rate at which we deploy, the likelihood
    of one of those changes going wrong is eventually a certainty. According to the
    DORA report, the change failure rate is one of the metrics we should track for
    organizational performance. Although we strive to keep this metric as low as possible
    if a failure occurs, another DORA metric, **mean time to restore** (**MTTR**),
    comes into play. Three key anti-patterns prevent you from optimizing your MTTR
    when the cause is a change failure:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 没有系统是完美的，随着我们部署频率的提高，某个变更失败的可能性最终会变得必然。根据DORA报告，变更失败率是我们应该追踪的一个组织绩效指标。尽管我们力求将这个指标保持在尽可能低的水平，但如果发生失败，另一个DORA指标——**恢复时间中位数**（**MTTR**）就会发挥作用。三个关键的反模式会阻碍我们优化MTTR，当原因是变更失败时：
- en: Mutable artifacts
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变工件
- en: Destructive changes
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 毁灭性变更
- en: No reverse definition for a change
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有变更的反向定义
- en: The first anti-pattern is using **mutable artifacts**, and all artifacts produced
    must be immutable. When your automated build pipeline produces an artifact as
    a deployment candidate, we must preserve the artifact throughout subsequent build
    pipeline runs. This immutability can be as simple as container versioning in a
    container registry or having all previous versions of an internal library available
    for installation at any point. By having immutable artifacts, it is simple to
    roll back the system to a known correct configuration. We can simply deploy an
    earlier artifact, and then we can triage the fixes in lower environments until
    we are ready to deploy to production again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个反模式是使用**可变工件**，所有产生的工件必须是不可变的。当你的自动化构建管道生成一个工件作为部署候选项时，我们必须在随后的构建管道运行中保持该工件不变。这种不可变性可以像容器注册表中的容器版本控制一样简单，或者使所有以前版本的内部库在任何时候都可供安装。通过使用不可变工件，可以轻松将系统回滚到已知的正确配置。我们只需部署早期的工件，然后在较低环境中进行修复，直到我们准备好再次部署到生产环境中。
- en: The second anti-pattern is **destructive changes**. Deployment of a new version
    of the system should allow us to roll back to previous instances of the application.
    For example, a destructive change would be dropping a database table or dropping
    a data store. When we deploy these changes, we can never roll the system back
    to the last known correct configuration because we have lost the system’s state
    in the destructive change. If a destructive change is required, it should go through
    a deprecation schedule before the final destructive change is applied to ensure
    that removing the functionality will not impact other application areas.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种反模式是**破坏性变更**。系统新版本的部署应该允许我们回滚到之前的应用程序实例。例如，破坏性变更可能是删除数据库表或删除数据存储。当我们部署这些变更时，我们永远无法将系统回滚到上一个已知的正确配置，因为在破坏性变更中我们丢失了系统的状态。如果需要进行破坏性变更，应该在最终应用破坏性变更之前经过弃用计划，以确保删除功能不会影响其他应用领域。
- en: 'The final anti-pattern is **no reverse definition for a change**. This anti-pattern
    primarily applies to stores of application state, such as databases or infrastructure
    changes. It is closely related to the second point: a change fundamentally cannot
    be reversible if it is destructive. The extension this rule applies is that any
    change to the system state, architecture, or data must be recoverable. This functionality
    exists for some tooling, such as Terraform comparing deployed infrastructure to
    a state file or a SQL Server project deployed via DACPAC. In other scenarios,
    the migration must explicitly define forward and reverse operations, such as through
    database SQL migrations using a tool such as Flyway or Entity Framework migrations.
    The common anti-pattern we see here is that the draft changes contain a detailed
    upward migration, and no one builds or tests the downward migration. This strategy
    means that significant work is often required when we need to roll back a change,
    as the reverse migration may need time to be created or may be non-functional
    if testing is not performed. This results in high-pressure, high-risk situations
    where we must craft changes while production is impacted, resulting in corners
    being cut to “just get it running again.”'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的反模式是**没有逆向定义的变更**。这个反模式主要适用于应用程序状态的存储，例如数据库或基础设施变更。它与第二点密切相关：如果变更是破坏性的，基本上就无法逆转。这个规则的扩展是，任何对系统状态、架构或数据的变更都必须是可恢复的。某些工具提供了这种功能，例如，Terraform比较已部署的基础设施与状态文件，或通过DACPAC部署的SQL
    Server项目。在其他场景中，迁移必须显式定义正向和逆向操作，例如通过使用Flyway或Entity Framework迁移的数据库SQL迁移。我们在这里看到的常见反模式是，草稿中的变更包含了详细的向上迁移，但没有人构建或测试向下迁移。这种策略意味着当我们需要回滚变更时，通常需要进行大量工作，因为逆向迁移可能需要时间来创建，或者如果没有进行测试，可能会失效。这导致了高压、高风险的情况，我们必须在生产环境受到影响时制作变更，导致“只为让它重新运行”而偷工减料。
- en: To summarize this section, complex release processes allow bad practices due
    to the high barriers between development and production. We can optimize delivery
    and increase service uptime by removing those barriers and supporting good practices.
    The key is frequent, flagged, well-tested changes that are immutable, non-destructive,
    and easily reversible when required. This allows us to develop faster, but we
    still need to ensure that our developers are doing the right thing, to do so we
    typically employ guardrails.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这一部分，复杂的发布流程由于开发与生产之间的高壁垒，允许出现不良实践。我们可以通过去除这些壁垒并支持良好实践来优化交付和提高服务的正常运行时间。关键在于频繁、标记清晰、经过充分测试的变更，这些变更是不可变的、无害的，并且在需要时易于恢复。这使得我们能够更快地开发，但我们仍然需要确保开发人员在做正确的事情，为此，我们通常会使用护栏措施。
- en: Guardrails
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 护栏措施
- en: We’ve talked about empowering developers to do more and fully own the changes
    they produce. However, developers are not the experts; we see this fundamental
    anti-pattern in adopting the shift-left mentality. We should not expect developers
    to become experts in security, **site reliability engineering** (**SRE**), DevSecOps,
    and so on. Developers will need a passing knowledge of these topics but should
    be able to deploy with certainty without being experts.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何赋予开发人员更多的权力，并让他们完全负责他们所做的变更。然而，开发人员并不是专家；我们在采纳“左移”思维时看到这种根本性的反模式。我们不应该期望开发人员成为安全性、**站点可靠性工程**（**SRE**）、DevSecOps等方面的专家。开发人员需要对这些主题有一定的了解，但应该能够有信心地进行部署，而不必成为专家。
- en: Keeping your developers on track
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持开发人员在正轨上
- en: A common anti-pattern that we see in this space is that because we are shifting
    responsibility left toward the development team, the development team needs more
    permissions in the cloud environment to do their job. The exact opposite is true.
    Developers should have a constrained set of permissions to diagnose, inspect,
    and support the cloud environment. Instead, the escalation of privilege should
    occur in the CI/CD pipelines, and this is how we enable our developers by providing
    tooling with elevated permissions. By doing this, we ensure that our developers
    can deploy independently but not outside the confines of the CI/CD environment.
    This process limits the chance of environmental drift through manual configuration,
    which preserves disaster recovery functions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个领域经常看到的一个常见反模式是，由于我们正在将责任向左移交给开发团队，开发团队在云环境中需要更多权限来完成他们的工作。事实正好相反。开发人员应该有一组受限的权限来诊断、检查和支持云环境。相反，特权的升级应该发生在CI/CD管道中，这是通过提供具有提升权限的工具来启用我们的开发人员的方式。通过这样做，我们确保开发人员可以独立部署，但不会超出CI/CD环境的限制。这个过程通过手动配置限制了环境漂移的可能性，从而保留了灾难恢复功能。
- en: The primary method of enabling developers to deploy with confidence is to provide
    guardrails in the deployment process. These guardrails define an acceptable set
    of actions a developer can take to achieve their objectives. For example, an infrastructure
    guardrail might prevent a **content delivery network** (**CDN**) from being deployed
    without a **web application firewall** (**WAF**) in front of it. A code-level
    guardrail might avoid the use of insecure hash functions. In both instances, we
    prevent changes from meeting a minimum standard when deploying them to production.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使开发人员能够放心部署的主要方法是在部署过程中提供防护栏。这些防护栏定义了开发人员可以采取的一组可接受的操作。例如，基础设施防护栏可能防止在没有**Web应用程序防火墙**（**WAF**）前端的情况下部署**内容传递网络**（**CDN**）。代码级防护栏可能避免使用不安全的哈希函数。在这两种情况下，我们防止变更在部署到生产环境时达到最低标准。
- en: We might deploy guardrails to meet regulatory compliance requirements. For example,
    a cloud-wide policy that prevents any resources from being deployed in particular
    regions to support data sovereignty requirements might be employed. This example
    would be perfect for a **service control policy** (**SCP**) from **Amazon Web
    Services** (**AWS**). These allow us to enforce boundaries of acceptable use at
    different levels of granularity, from organization-wide to individual accounts.
    For example, we lock various accounts to a specific region, and globally, we prevent
    all accounts from deploying resources in export-controlled areas.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会部署防护栏，以满足法规合规要求。例如，可以采用云范围策略，防止在特定地区部署任何资源，以支持数据主权要求。这个例子非常适合来自**亚马逊网络服务**（**AWS**）的**服务控制策略**（**SCP**）。这些策略允许我们在不同粒度的层次上强制执行可接受使用的边界，从组织范围到个人账户。例如，我们将各种账户锁定到特定地区，全局上，我们防止所有账户在出口管制区域部署资源。
- en: An anti-pattern in the security space is mistaking pentesting as a guardrail
    in the critical deployment path. Pentesting is a vital security step but should
    be outside the deployment path. Instead, it should run alongside the deployment
    process. We should automate all steps in the path to deployment. If you want to
    test the application security dynamically, consider using a **dynamic application
    security testing** (**DAST**) framework on one of the pre-prod environments as
    a pre-promotion check. The essential factor for guardrails is that developers
    should be able to access guardrail evaluations on demand.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全领域中的一个反模式是将渗透测试误认为是关键部署路径上的防护栏。渗透测试是一个重要的安全步骤，但应该在部署路径之外进行。相反，它应该与部署过程并行进行。我们应该自动化部署路径中的所有步骤。如果你想动态测试应用程序安全性，考虑在预生产环境中使用**动态应用程序安全测试**（**DAST**）框架作为预提升检查。防护栏的关键因素是开发人员应能够按需访问防护栏评估。
- en: Types of guardrail
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防护栏的类型
- en: 'We commonly see two main types of guardrails: preventative and detective.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常看到两种主要类型的防护栏：预防性和检测性。
- en: '**Preventative guardrails** are proactive guardrails that specify the outer
    bounds of what developers can do; these are punitive, preventing the pipeline
    from deploying if the guardrails are activated. This methodology is suitable for
    applying easily defined heuristics (i.e., our hashing should not be using the
    MD5 hash algorithm). The common mistake we see with preventative guardrails is
    that they typically get implemented, and then the developers are left to fend
    for themselves. If the guardrail fails, they have to go back and fix it. A better
    workflow is to have observability into guardrail activation. These metrics will
    tell you where developers have the most trouble and allow you to make developers’
    lives easier by providing training, libraries of correct implementations, or,
    even better, an enabling artifact.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**预防性防护栏**是主动的防护栏，指定了开发人员可以做的外部边界；这些防护栏是惩罚性的，若防护栏被激活，管道就会停止部署。这种方法适用于应用容易定义的启发式规则（例如，我们的哈希算法不应该使用MD5）。我们常见的错误是，预防性防护栏通常被实现后，开发人员被留给自己去应对。如果防护栏失败，他们必须返回并修复它。一个更好的工作流程是能够观察防护栏的激活情况。这些指标可以告诉你开发人员在哪些地方遇到最多的问题，从而通过提供培训、正确实现的库，或者更好的方法——一个可行的工具，来让开发人员的工作更轻松。'
- en: Next, we have **detective guardrails**. These reactive guardrails scan your
    environment for non-compliance, then either raise the issue or take corrective
    action. For example, we could enable our developers to deploy storage with public
    access through a CDN. However, if we tag particular storage containing PII (personally
    identifiable information), this tagging process might be out of band with the
    deployment of the storage itself. In this case, we could add a detective guardrail
    that checks for storage with public access, checks whether that storage account
    has the tag indicating that it contains PII, and then activates the guardrail.
    This type of control is typically the least favorable, as it requires an insecure
    configuration to be present in the environment to detect it instead of evaluating
    it proactively.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍**侦测性防护栏**。这些反应型防护栏会扫描你的环境以检查不合规的情况，然后会提出问题或采取纠正措施。例如，我们可以允许开发人员通过CDN部署具有公共访问权限的存储。然而，如果我们对包含个人身份信息（PII，Personally
    Identifiable Information）的特定存储进行标记，这一标记过程可能与存储本身的部署不一致。在这种情况下，我们可以添加一个侦测性防护栏，检查是否存在具有公共访问权限的存储，检查该存储账户是否有标记表示它包含PII，然后激活防护栏。这种控制方式通常最不理想，因为它要求环境中先存在不安全的配置，才能检测到问题，而不是主动评估问题。
- en: A typical driver of guardrails is security. Several tools exist to perform SAST
    to pick up common errors and allow the security team to define custom rules they
    want to look for. This space has excellent open source tooling (such as Semgrep)
    and many proprietary solutions. There is some upfront work to codify the anti-patterns
    you want to catch, but each codified heuristic is something that the security
    team no longer needs to review manually. Many available tools are not limited
    purely to security heuristics but can also check for anti-patterns such as deeply
    nested loops or cognitive complexity.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 防护栏的一个典型驱动因素是安全性。现在有一些工具可以执行静态应用安全测试（SAST），以发现常见错误，并允许安全团队定义他们想要查找的自定义规则。这个领域有许多优秀的开源工具（如Semgrep）以及许多专有的解决方案。虽然需要一些前期工作来编写想要捕捉的反模式，但每一条编写好的启发式规则都意味着安全团队不再需要手动审查。许多现有的工具不仅限于安全启发式，还能检查诸如深度嵌套的循环或认知复杂性等反模式。
- en: The case for guardrail observability
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '防护栏可观察性的案例  '
- en: Building guardrails is essential, but it is also important to monitor them.
    Developers use observability platforms to understand user behavior better and
    make changes to the applications they build to support it. We should do the same
    for our development team, who are effectively our users. By monitoring our guardrails,
    we can see the common friction points for our developers and proactively fix common
    issues. Let’s imagine our preventative guardrail from before requiring developers
    to deploy a WAF in front of a CDN. We might notice that our developers are hitting
    this guardrail very often, and hence, using the metrics we collect around guardrail
    activations, we build an enabling artifact. This artifact allows developers to
    avoid activating the guardrail and produce more secure artifacts without additional
    rework.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 构建护栏是至关重要的，但同样重要的是监控它们。开发人员使用可观察性平台来更好地理解用户行为，并对他们构建的应用程序进行更改以支持这些行为。我们也应该为我们的开发团队做同样的事，他们实际上是我们的用户。通过监控护栏，我们可以看到开发人员常遇到的摩擦点，并主动修复常见问题。假设我们之前的预防性护栏要求开发人员在CDN前面部署WAF。我们可能会注意到开发人员经常遇到这个护栏，因此，利用我们收集的护栏激活指标，我们构建了一个启用工件。这个工件使开发人员能够避免触发护栏，且在没有额外返工的情况下生产出更安全的工件。
- en: The key to enabling artifacts is to abstract away standard configurations using
    sensible defaults. Continuing with our WAF and CDN example, as a security team,
    we may introduce a default WAF that gets added to every CDN deployment if a developer
    forgets to specify one explicitly. If we already have a detective and preventative
    guardrail for this scenario, the enabling artifact minimizes the number of activations
    we encounter. When tracking metrics for these units, we recommend monitoring everything.
    Metrics about the enabling artifact tell you how often we activate the default
    WAF. These metrics can be helpful to track as they are a great way to measure
    enabling artifacts’ impact on the development team.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 启用工件的关键在于通过合理的默认设置来抽象化标准配置。继续以WAF和CDN为例，作为安全团队，如果开发人员忘记明确指定WAF，我们可能会引入一个默认的WAF，该WAF会被添加到每个CDN部署中。如果我们已经为这种情况设立了侦测性和预防性护栏，那么启用工件将减少我们遇到的激活次数。在跟踪这些单元的指标时，我们建议监控所有内容。关于启用工件的指标告诉我们默认WAF激活的频率。这些指标很有帮助，因为它们是衡量启用工件对开发团队影响的好方法。
- en: If enabling artifacts are the counterpart of preventative guardrails, the equivalent
    of detective guardrails is automated remediation. For our PII tagging solution,
    we could listen for the guardrail activation event and kick off a process that
    revokes public access to the bucket. This enables our system to be secure without
    outside intervention for simple use cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用工件是预防性护栏的对应物，那么侦测性护栏的等价物就是自动修复。对于我们的PII标签解决方案，我们可以监听护栏激活事件，并启动一个过程，撤销对存储桶的公共访问。这使我们的系统在不需要外部干预的情况下，在简单用例中保持安全。
- en: So, for a vulnerability or misconfiguration in our application, the preference
    is to have a sensible default added through an enabling artifact, such as a library
    or automated pipeline tool, then for cases outside of this to have them caught
    by preventative guardrails, and finally, if a misconfiguration makes it to production,
    then automated remediation or a manual process is initiated to rectify it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们应用程序中的漏洞或配置错误，首选是通过启用的工件（如库或自动化管道工具）添加一个合理的默认设置，然后对于超出此范围的情况，通过预防性护栏进行捕获，最后，如果配置错误到达生产环境，则启动自动修复或手动过程进行修正。
- en: These tools can exist in the pipeline and environment at all times. The final
    layer of security in this system should be pentesting, but it’s important to note
    that this needs to occur asynchronously with the deployment and development of
    the application. Ideally, the findings from penetration testing will feed back
    into our system of guardrails to help us develop new enabling artifacts and preventative/detective
    controls to stop the issue from resurfacing.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具可以始终存在于管道和环境中。该系统的最终安全层应该是渗透测试，但需要注意的是，这一过程必须与应用程序的部署和开发异步进行。理想情况下，渗透测试的结果将反馈到我们的护栏系统中，帮助我们开发新的启用工件和预防/侦测控制，以防止问题重新出现。
- en: Example guardrails
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例护栏
- en: In cloud environments, there are unusual ways in which systems interact, as
    not only are you able to give deployed infrastructure and services the ability
    to interact with each other but also to interact with the underlying definitions
    of those resources. Now, we will go through some common guardrails that are easily
    applicable. By no means will this be exhaustive, but it will give you a head start.
    For our example, we will use AWS.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，系统的交互方式常常不寻常，因为不仅可以让已部署的基础设施和服务相互交互，还可以让它们与这些资源的底层定义进行交互。接下来，我们将介绍一些容易应用的常见护栏。虽然这并非详尽无遗，但它会为你提供一个起步点。作为我们的示例，我们将使用AWS。
- en: 'The guardrail examples we will use are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下的护栏示例：
- en: Overprivileged IAM accounts
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限过多的IAM账户
- en: Public S3 buckets
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共S3存储桶
- en: Data sovereignty requirements
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据主权要求
- en: Publicly accessible remote administration tools
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共可访问的远程管理工具
- en: A simple place to start would be IAM permissions policies. I won’t go into detail
    about the principle of least privilege here, we’ll save that for a later chapter,
    but it’s common to see overprivileged accounts or roles defined. Typically, this
    arises because the user can’t find the correct permissions to perform the actions
    they require, so they end up assigning a long list of permissions, or wildcard
    permissions, while trying to make it work. This is actually a great candidate
    for all three methods of control discussed earlier; we can build common permissions
    policies that contain pre-approved policies for completing common tasks, for example,
    connecting our Lambda functions to a specific DynamoDB table. We can then also
    add a preventative control, such as an SCP in our account or organization to forbid
    access to particular APIs that are not in use. Finally, we can add a detective
    control that monitors all our active roles for policies that contain wildcard
    permissions, and revoke all associated grants and trust policies when one is discovered.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的起点是IAM权限策略。我在这里不打算详细讨论最小权限原则，我们会在后续章节中介绍，但通常会看到定义了过多权限的账户或角色。通常，这种情况发生是因为用户无法找到正确的权限来执行所需的操作，于是他们最终分配了一长串权限或通配符权限，试图让其工作。实际上，这对我们之前讨论的三种控制方法来说是一个很好的候选对象；我们可以构建包含预批准策略的常见权限策略，用于完成常见任务，例如将Lambda函数连接到特定的DynamoDB表。接着，我们还可以添加预防性控制，例如在账户或组织中使用SCP，禁止访问不再使用的特定API。最后，我们可以添加侦测性控制，监控我们所有的活动角色，检查是否有包含通配符权限的策略，并在发现时撤销所有相关的授权和信任策略。
- en: Another common misconfiguration that is a good candidate for guardrails is public
    access to S3 buckets. Any scenario using public access to an S3 bucket is typically
    better served through the use of a CloudFront distribution and an origin access
    identity. We can build an enabling artifact here in the form of a Terraform module
    that sets up a default configuration for a bucket and disables public access.
    We can build a preventative guardrail that checks our infrastructure plan to prevent
    this configuration. Finally, we can build a detective guardrail that scans our
    deployed infrastructure to ensure that no public buckets exist, and if they do,
    revoke public access.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的配置错误，适合用护栏来管理的是S3存储桶的公共访问。任何使用公共访问的S3存储桶场景，通常更适合通过使用CloudFront分发和源访问身份来解决。我们可以通过创建Terraform模块来构建一个启用的构件，该模块为存储桶设置默认配置并禁用公共访问。我们还可以构建一个预防性护栏，检查我们的基础设施计划，以防止出现此配置。最后，我们可以建立一个侦测性护栏，扫描已部署的基础设施，确保没有公共存储桶存在，如果存在，则撤销公共访问。
- en: 'Many businesses also have the constraint of data sovereignty requirements;
    data for entities in a region must be stored in that region. Through the deployment
    of resources into regions that meet our data sovereignty requirements, we can
    be compliant. However, we are not provably compliant, as this approach requires
    the constant enforcement of a process. Instead, we can use a preventative control:
    we can build SCPs that lock resources in an account from being deployed in any
    region apart from the ones we specify. This approach must be proactive, as it
    only applies to new calls to the AWS API.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 许多企业也面临数据主权要求的约束；某地区的实体数据必须存储在该地区。通过将资源部署到符合数据主权要求的区域，我们可以做到合规。然而，我们无法证明已合规，因为这种方法需要不断执行流程。相反，我们可以使用预防性控制：可以构建SCP（服务控制策略），将账户中的资源锁定，禁止其部署到我们未指定的区域。这种方法必须是前瞻性的，因为它仅适用于新的AWS
    API调用。
- en: The last common misconfiguration we see is directly opening remote administration
    tools to the internet. For example, your EC2 instances might expose port `22`
    to allow SSH for your developers, but now the attack surface for those instances
    just increased by every version of SSH those instances are running. This should
    be enforced at the network level, and typically, it’s good practice to have a
    detective guardrail (alongside preventative guard rails) in this instance. The
    temptation for a developer to open the SSH port in a `22` with unrestricted access
    and automatically close it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的最后一种常见配置错误是直接将远程管理工具暴露到互联网上。例如，你的 EC2 实例可能会暴露端口`22`以允许开发者通过 SSH 连接，但这就意味着这些实例的攻击面增加了，具体取决于它们运行的
    SSH 版本。这个问题应该在网络层面进行强制执行，通常，最好在这种情况下同时设置侦测性护栏（除了预防性护栏）。开发者很容易将 SSH 端口设置为`22`并开放无限制访问，然后自动关闭它。
- en: Hopefully, through reading this section, you have come to understand the types
    of guardrails that can be configured and how to enable your developers to best
    work within the boundaries you set, without impacting their development velocity.
    The importance of monitoring your organization’s guardrails has also been discussed,
    with these metrics providing us with a clear insight into both our security posture
    and developer experience. Finally, we have also looked at some common misconfigurations
    and explored how guardrails and enabling artifacts could mitigate the risk to
    the business. So, now we have the tools to enable our developers to securely and
    safely own their output, let’s look at how we can shift left the responsibility
    of producing secure artifacts onto our development teams.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 希望通过阅读本节，你已经理解了可以配置的护栏类型，以及如何让开发者在不影响其开发速度的情况下，最好地在你设置的边界内工作。我们还讨论了监控组织护栏的重要性，这些指标为我们提供了清晰的视角，既能看出我们的安全态势，也能了解开发者的体验。最后，我们还探讨了一些常见的配置错误，并分析了护栏和启用的工具如何降低对业务的风险。因此，既然我们已经拥有了使开发者能够安全且可靠地管理输出的工具，让我们来看一下如何将生产安全工件的责任左移到开发团队。
- en: Shifting left
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 左移
- en: We have touched on the requirement to shift left the responsibility of producing
    functional, secure changes to the development team. The focus so far has been
    on the externalities of the development team. This section will be about the effect
    of shifting left on the development team and the techniques we can use to meet
    the new expectations imposed upon them. We recommend reading this chapter if you
    are a developer, as you will learn some valuable tools, or as part of an external
    function, as it will allow you to support the development team better.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过将功能性和安全性的变化责任交给开发团队的需求。到目前为止，焦点主要放在了开发团队的外部因素上。本节将讨论将责任左移对开发团队的影响，以及我们可以使用哪些技术来满足对他们施加的新期望。如果你是开发者，建议阅读这一章，因为你将学习到一些有价值的工具；如果你是外部职能的一部分，这一章也能帮助你更好地支持开发团队。
- en: Development as an iterative process
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为一个迭代过程的开发
- en: A common anti-pattern involves invoking **quality assurance** (**QA**) once
    a feature is complete in the eyes of the developer rather than a process that
    takes place iteratively over the software development life cycle. We spoke earlier
    about ephemeral environments, which are helpful for a developer to develop their
    feature in isolation and provide an environment where somebody can test the feature
    in its incomplete state. Different companies have different QA functions, which
    may come from a dedicated QA role or exist as part of the product team. The key
    here is that ephemeral environments allow you to involve the QA function much
    earlier in the process.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的反模式是，在开发者认为一个功能已经完成后，再启用**质量保证**（**QA**）而不是在整个软件开发生命周期中进行迭代过程。我们之前提到过临时环境，这对于开发者在隔离的环境中开发功能并提供一个可以在功能不完整时进行测试的环境非常有帮助。不同的公司有不同的
    QA 功能，可能来自专门的 QA 角色，或者是产品团队的一部分。这里的关键是，临时环境让你可以在过程的早期就将 QA 功能引入其中。
- en: Another anti-pattern here is using long-lived feature branches with ephemeral
    environments. We develop the feature on multiple small branches, each containing
    a portion of the work required for the entire feature to operate. The ephemeral
    environment allows us an alternative deployment with enabled incomplete features.
    We establish a fast feedback cycle between developers and the QA process by getting
    QA involved from the first commit. Shifting left the QA to be parallel or integrated
    with the development allows us to mitigate the risk that a significant feature
    may fail QA once we have completed the feature, requiring significant rework to
    fix. It also brings us closer to a no-silo model by fostering collaboration between
    QA and development functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个反模式是使用长期存在的特性分支和短暂的环境。我们在多个小分支上开发特性，每个分支包含整个特性所需的一部分工作。短暂环境为我们提供了一个替代部署方式，允许未完成的特性启用。我们通过从第一次提交开始就让QA参与，建立开发者和QA流程之间的快速反馈循环。将QA并行或集成到开发中，有助于我们减轻一个重要特性在完成后可能未通过QA测试的风险，从而需要大量返工来修复。它还通过促进QA和开发功能之间的协作，使我们更接近无隔离的模型。
- en: Test first, code later
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先测试，后编码
- en: One of the anti-patterns that teams typically seem to acknowledge but fail to
    implement correctly is **test-driven development** (**TDD**) and, by extension,
    **behavior-driven development** (**BDD**). When asking development teams whether
    they use TDD or BDD, they usually answer in the affirmative, but when asked when
    they write their tests, they respond that they write the tests after the code.
    Cognitive dissonance aside, true BDD involves defining the behavior of your system
    and writing a test that can check for compliance with that behavior before actually
    implementing the system. Another fallacy that comes into play when implementing
    BDD is a waterfall-style approach to coding tests, specifying all the edge cases
    you foresee and writing too many tests upfront. A lot of system behavior and requirements
    only emerge through the actual implementation of the system, and writing too many
    tests up front just hampers this discovery process. Instead, an excellent approach
    to use in BDD is the red, green, refactor system. You define your desired behavior
    and write simple tests to ensure the system fulfills the desired behavior. These
    tests will fail (red), and we will then implement a system that passes these tests
    (green). Through the design of this system, we then refactor the implementation
    and the test suite to exhibit the desired behavior accurately and test the emergent
    behavior of the system. We must create the initial desired behavior with the product
    owner to ensure that the desired behavior test accurately reflects the behavior
    required in the end product. This process will shift left the desired behavior’s
    description to a point before we write any code.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 团队通常认可但未能正确实施的反模式之一是**测试驱动开发**（**TDD**），以及**行为驱动开发**（**BDD**）。当询问开发团队是否使用TDD或BDD时，他们通常会肯定回答，但当被问到何时编写测试时，他们会回答说是在编写代码之后才写测试。撇开认知失调不谈，真正的BDD包括在实际实现系统之前，定义系统的行为并编写可以检查该行为是否符合要求的测试。实现BDD时另一个常见的误区是采用瀑布式的编码测试方法，预先列出所有预见到的边缘情况并编写过多的测试。许多系统的行为和需求只有在实际实现系统过程中才会显现出来，而过早编写过多的测试只会妨碍这一发现过程。相反，在BDD中，一个很好的方法是使用红绿重构系统。你首先定义期望的行为，并编写简单的测试来确保系统能实现这个行为。这些测试会失败（红），然后我们会实现一个能够通过这些测试的系统（绿）。通过设计这个系统，我们再对实现和测试用例进行重构，以准确展现期望的行为，并测试系统的
    emergent 行为。我们必须与产品负责人一起创建初步的期望行为，以确保期望行为测试能够准确反映最终产品所需的行为。这个过程将会将期望行为的描述“提前”，直到我们开始编写任何代码之前。
- en: Once we create tests, they should enter the deployment pipeline’s critical path.
    This practice ensures that future changes to the system do not prevent it from
    exhibiting the desired behavior required. A common anti-pattern that teams can
    fall into in this stage is failing to trust their tests’ output fully. In an extreme
    case, this might look like accepting a certain percentage of failed tests as “par
    for the course.” This lack of confidence in the tests undermines the value of
    the entire test suite, as developers no longer have confidence that their changes
    do not cause regressions on existing behaviors.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了测试，它们应该进入部署管道的关键路径。这个实践可以确保系统的未来更改不会阻止其展现所需的行为。团队在这一阶段容易陷入的一个常见反模式是无法完全信任测试的输出。在极端情况下，这可能表现为接受一定比例的失败测试作为“正常现象”。这种对测试缺乏信心削弱了整个测试套件的价值，因为开发人员不再相信他们的更改不会导致现有行为的回归。
- en: 'The second and more common pattern is the existence of intermittent test failures.
    Intermittent failure commonly occurs when tests are not properly isolated, and
    the side effects of one test may influence the result of another test. Typically,
    in this scenario, the developers rerun the pipeline until the intermittent test
    passes. This behavior is counterproductive for two reasons: firstly, we’re increasing
    the time developers are waiting for pipeline executions to finish, and secondly,
    we have a failing test that we are ignoring. In this scenario, rather than putting
    up with the inconvenience of multiple pipeline runs, we should be adequately reestablishing
    the boundaries of our tests and creating a new test that checks for regression
    of the intermittent behavior. By vigorously enforcing these test suites, we shift
    left the responsibilities of detecting and rectifying regressions to the developer
    responsible for the regression as part of their development process rather than
    waiting for the regression to become apparent in the end product.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种更常见的模式是间歇性的测试失败。当测试未能正确隔离时，通常会发生间歇性失败，而一个测试的副作用可能会影响另一个测试的结果。在这种情况下，开发人员通常会重新运行管道，直到间歇性测试通过。这种行为是适得其反的，原因有两个：首先，我们增加了开发人员等待管道执行完成的时间；其次，我们忽略了一个失败的测试。在这种情况下，与其忍受多次管道运行的不便，不如充分地重新确定测试的边界，并创建一个新测试来检查间歇性行为的回归。通过严格执行这些测试套件，我们将检测和纠正回归的责任“左移”到负责回归的开发人员身上，让他们在开发过程中处理，而不是等到回归在最终产品中显现出来。
- en: Shared ownership of output
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出的共享责任
- en: 'Consider Fred Brooks’s famous quote: “*What one programmer can do in one month,
    two programmers can do in two months*.” While tongue-in-cheek, the sentiment holds
    when we program in isolation. The increased communication channels and distribution
    of knowledge can make the development process more demanding, which leads us to
    our third common anti-pattern, **isolated development**. We have seen software
    teams where they only interact with each other in the daily standup. This system
    falls back into our old patterns of slow feedback cycles. If I have a daily standup
    and need the output from one other developer on my team to progress my feature,
    it may be complete 5 minutes after the standup, and I would need to wait until
    the next day to hear about it. I’ve seen high-performing development teams on
    a virtual call all day, splitting off the primary call to pair and mob program
    as required. The key differentiator here is that the high-performing team sees
    their delivery as a shared output rather than an individual output. This differentiator
    also needs to be reflected in how we track productivity metrics, which should
    reflect a team’s productivity, not the individual’s. Management of the individual
    is informed by feedback from other team members, as the team is the value we want
    to optimize.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑弗雷德·布鲁克斯（Fred Brooks）的名言：“*一个程序员在一个月内能做到的事情，两个程序员可以在两个月内做到*。”虽然是半开玩笑的，但这种情绪在我们独立编程时仍然成立。增加的沟通渠道和知识分发可以使开发过程更加苛刻，这导致我们第三个常见的反模式，**孤立开发**。我们看到过软件团队，他们只在每日站会中与彼此交互。这种系统会回到我们旧的慢反馈周期的模式。如果我在每日站会后完成并需要另一名团队开发者的输出来推进我的特性，可能会在站会后5分钟完成，而我需要等到第二天才能听到相关情况。我见过高效开发团队在虚拟呼叫中整天工作，根据需要分拆出主要呼叫以进行配对编程和集体编程。关键的不同点在于，高效的团队将他们的交付视为共同的输出，而不是个人的输出。这种不同点也需要在我们如何跟踪生产力指标方面得到体现，这些指标应该反映团队的生产力，而不是个人的。个人的管理受到来自其他团队成员的反馈的指导，因为团队是我们希望优化的价值。
- en: Small and regular changes, merged back to the code base, are also crucial from
    a code review perspective. Show a developer a 12-line pull request, and they will
    have plenty of comments. Show them a 1,200-line pull request, and you’ll likely
    get zero comments. Maybe you will get a response of “*Looks good to me*.” The
    main enemy of this approach is long-running feature branches. If you’re not regularly
    merging code with the main branch, then the reviewer does not stand a chance of
    understanding the scope of the change. Development processes that support small,
    atomic changes are essential here, such as trunk-based development and feature
    flagging, as discussed earlier in this chapter. When working toward deadlines,
    there is typically a tendency to approve pull requests with more relaxed standards
    to integrate changes in time. This approach, however, is a false economy. By approving
    lax changes, such as code that does not conform to coding standards or code with
    high cognitive complexity, we are simply robbing ourselves of future velocity
    and building up technical debt. The other side of this coin is that when we rigorously
    enforce coding standards at the pull request stage, we slowly start to see an
    uplift in the team, and future pull requests from the same team member are less
    likely to have the same mistakes. The failure to enforce coding standards is the
    key to our false economy. Enforcement versus non-enforcement of the coding standards
    eventually brings you to an equivalent or increased development velocity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 小而定期的变更，合并回代码库，从代码审查的角度来看也至关重要。向开发者展示一个12行的拉取请求，他们会有很多评论。向他们展示一个1,200行的拉取请求，你可能会得到零评论。也许你会得到一个“*看起来不错*。”的回复。这种方法的主要敌人是长期运行的功能分支。如果你不定期将代码合并到主分支中，那么审阅者就无法理解变更的范围。在这里，支持小而原子化变更的开发过程至关重要，比如前面在本章讨论过的基干开发和特性标志。在努力满足截止日期时，通常会倾向于批准拉取请求，以更宽松的标准整合变更。然而，这种方法是一种虚假的经济。通过批准宽松的变更，比如不符合编码标准的代码或具有高认知复杂性的代码，我们只是在削弱未来的速度，并积累技术债务。这个问题的另一面是，当我们在拉取请求阶段严格执行编码标准时，我们慢慢开始看到团队的提升，同一个团队成员未来的拉取请求不太可能出现同样的错误。不执行编码标准是我们虚假经济的关键。执行与不执行编码标准最终会让您达到等效或增加的开发速度。
- en: Experimenting and getting feedback early
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 早期实验和及早获得反馈
- en: We have examined the feedback loops in a typical software development business
    function. However, you should also look at feedback loops that may be more specific
    to your business. An example might be that an order-matching engine from a financial
    system might require the last six months of data to be fed into the system to
    ensure it reaches the same target state as the existing engine. To shift this
    left, we might use a smaller time range with dummy data that developers can run
    locally to get instant feedback. The key to shifting left is identifying these
    feedback loops and either putting them into the hands of developers directly or
    enabling developers to interact with the business unit responsible in the early
    stages of development. This business process optimization ensures that we are
    breaking down the chance of a late part of the process coming back with significant
    changes. To facilitate this, we recommend mapping out all the parts of the deployment
    process that occur once a change leaves the hands of a developer and finding the
    areas where this process experiences the most failures (i.e., requires rework
    by the developer). These parts of the process are your best candidates for shifting
    left. It’s important to note that, once again, you need metrics on the process
    to identify these stages, so observability in your deployment process is a significant
    factor in its efficacy.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经检查了典型软件开发业务功能中的反馈循环。然而，您还应该关注可能更具体于您业务的反馈循环。一个例子可能是来自金融系统的订单匹配引擎可能需要过去六个月的数据输入系统，以确保它达到与现有引擎相同的目标状态。为了将这一过程向左转型，我们可以使用较小的时间范围和虚拟数据，让开发人员在本地运行，以便获得即时反馈。向左转型的关键是识别这些反馈循环，并将其直接交给开发人员，或者在开发的早期阶段使开发人员能够与负责业务单元互动。这个业务过程的优化确保了我们减少了流程后期出现重大更改的机会。为了促进这一点，我们建议绘制出所有部署过程中，开发人员完成更改后发生的部分，并找到这一过程中发生最多故障（即需要开发人员返工）的区域。这些过程部分是您向左转型的最佳候选。需要注意的是，您仍然需要有关流程的度量数据，以识别这些阶段，因此，部署过程的可观察性在其有效性中是一个重要因素。
- en: Shifting left also requires the development team to be the source of truth in
    tackling a feature. The development team must be allowed to experiment before
    committing to a solution. A great way to approach this is through timeboxed technical
    spikes, possibly multiple in parallel if different approaches need testing for
    their efficacy. The crucial factor here is allowing developers to experiment,
    with the culmination of their work validating an idea or assumption rather than
    introducing a change or a new feature. This process is another area where ephemeral
    environments shine. Having a consequence-free sandbox to test a proof-of-concept
    idea allows the development team to, in the words of Mark Zuckerberg, “*move fast
    and break things*.” Even though this approach does not aim to produce a tangible
    outcome, typically, these technical spikes, if successful, will form the basis
    of a new change or feature. So, even though the goal was not to create a change,
    the technical spike often does not result in lost productivity.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 向左转型还要求开发团队在解决某个功能时成为真实信息的来源。开发团队必须被允许在承诺解决方案之前进行实验。一种很好的方法是通过限定时间的技术探针（timeboxed
    technical spikes），如果需要测试不同方法的有效性，可能会同时进行多个技术探针。这里的关键因素是允许开发人员进行实验，并通过他们的工作成果来验证一个想法或假设，而不是引入更改或新特性。这一过程是短暂环境（ephemeral
    environments）发挥作用的又一个领域。拥有一个没有后果的沙盒来测试概念验证（proof-of-concept）想法，使开发团队能够以马克·扎克伯格的话说，"*快速行动并打破事物*"。尽管这种方法并不旨在产生可见的成果，但通常情况下，如果这些技术探针成功，它们将成为新更改或新特性的基础。因此，尽管目标不是创建更改，但技术探针通常并不会导致生产力的浪费。
- en: Building in security from the start
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从一开始就将安全性构建进来
- en: The final requirement of the shift-left methodology is ensuring that security
    is part of the cloud native solution from the inception of the changes. Developers
    must all be conscious of the effects of their decisions on the overall solution
    security posture. Developers do not need to be security experts. Instead, they
    must shift their thinking from “*Does it achieve the required objective?*” to
    consider the new attack surface their changes could provide. An excellent way
    to guide a development team that is newly adopting shift-left methodologies into
    their way of working is to undertake threat modeling of a change as part of the
    development process. By shifting into the mindset of an attacker, we can quickly
    identify threats and put mitigations into place to defend against them. This exercise
    is even more effective if the security team is involved in the first few attempts.
    While the team’s goal is to become self-sufficient (a topic we will touch on soon),
    using enabling teams is essential to set a consistent quality across teams.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: shift-left 方法的最终要求是确保安全性从变更开始时就融入到云原生解决方案中。开发人员必须意识到他们的决策对整体解决方案安全姿态的影响。开发人员不需要成为安全专家，而是需要将思维方式从“*它能达到预期目标吗？*”转变为考虑他们的变更可能带来的新攻击面。一个优秀的方法是将威胁建模作为开发过程的一部分，来引导刚刚采用
    shift-left 方法论的开发团队。通过转变为攻击者的思维方式，我们可以迅速识别威胁并采取缓解措施加以防御。如果安全团队参与到前几次的尝试中，这个练习将更加有效。尽管团队的目标是实现自给自足（这是我们稍后会讨论的主题），但利用支持团队来确保跨团队的一致性质量仍然至关重要。
- en: By shifting left, we have enabled our developers to produce secure, complete,
    and production-ready changes. Using appropriate tooling and business processes
    has increased the development velocity and given our developers the control and
    proper safeguards to apply themselves to finding the best solution. Now we have
    teams that are expected to own their output, we will next look at how to make
    these teams truly self-sufficient.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 shift-left 方法，我们使开发人员能够生产安全、完整且适合生产环境的变更。使用适当的工具和业务流程提高了开发速度，并赋予了开发人员控制权和适当的保障措施，使他们能够专注于寻找最佳解决方案。现在，随着团队开始负责自己的产出，接下来我们将探讨如何让这些团队真正实现自给自足。
- en: Self-sufficient teams
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自给自足的团队
- en: With all the changes we have made in culture, process, tooling, and delivery,
    we expect our teams to become self-sufficient change factories. But how can we
    adjust our team’s internal structures to ensure that the team can organize and
    support these new ways of working?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在文化、流程、工具和交付方面做出的所有变更，我们期望我们的团队成为自给自足的变更工厂。但我们如何调整团队的内部结构，以确保团队能够组织和支持这些新的工作方式呢？
- en: Trifecta leadership
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三位一体领导力
- en: Spotify popularized a model known as the *Squad Model*. While, typically, it
    also ascribes much larger structures beyond the independent squads, we will focus
    on the structure of the squad itself. There is valid criticism of the larger model.
    However, this does not take away from the validity of the atomic team structure.
    The crux of the team is that it is a unit that works on a specific product. It
    contains a trio of leaders who orient the squad’s development efforts. These leaders
    are the engineering manager, responsible for the team’s technical direction; the
    product owner, who represents the customer; and the scrum master, who organizes
    the team’s efforts. By encapsulating the responsibilities of a team within the
    team itself and allowing the team the ability to work across the entire product,
    we can now scale these squads horizontally without linearly increasing management
    overhead. We are now venturing into scalable, agile delivery, which matches well
    with the requirements for cloud native development.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Spotify 推广了一种被称为 *Squad Model*（小队模型）的模式。虽然通常它也包含独立小队之外更大规模的结构，但我们将专注于小队本身的结构。对于更大模型的批评是有其有效性的，但这并不影响原子团队结构的有效性。团队的核心在于它是一个专注于特定产品的单位。它包含三位领导者，负责指导小队的发展工作。这三位领导者分别是工程经理，负责团队的技术方向；产品负责人，代表客户；以及
    Scrum Master，组织团队的工作。通过将团队的责任封装在团队内部，并允许团队能够跨整个产品进行工作，我们可以横向扩展这些小队，而不会线性增加管理开销。现在，我们进入了可扩展的敏捷交付，这与云原生开发的要求非常契合。
- en: The key to successfully implementing this format is understanding that while
    the leadership is a trifecta, there is minimal overlap in actual responsibility.
    A common anti-pattern in this space is all developers reporting to the engineering
    manager. Developers are the implementers of change, and there is much more nuance
    to producing change in a system than technical direction. Instead, developers
    become stewards of the changes that they are making, understanding the product
    thinking behind it and the technical direction required to implement it. A great
    way to communicate this is through a concept called *commander’s intent*. This
    refers to the abstraction of leadership direction to encompass the goal, allowing
    for flexibility in our method. In its original form, the order might require us
    to move to a particular position on the battlefield, but the intent is to take
    a specific hill in concert with other units. If we focus on the *how* (moving
    to the positions), we might miss opportunities to accomplish the *what* (taking
    the hill).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 成功实施这种格式的关键是理解，虽然领导层是三位一体的，但实际责任之间的重叠很小。这个领域中一个常见的反模式是所有开发者都向工程经理汇报。开发者是变更的实施者，产生系统变更比技术方向更为复杂。相反，开发者成为他们所做变更的管理者，理解背后的产品思维以及实施所需的技术方向。传达这一点的一个很好的方式是通过一个叫做*指挥官意图*的概念。它指的是领导指令的抽象，以涵盖目标，从而使我们的方法更加灵活。在最初的形式中，命令可能要求我们前往战场上的特定位置，但意图是与其他单位一起攻占某个特定的山丘。如果我们专注于*如何*（移动到位置），我们可能会错过完成*什么*（占领山丘）的机会。
- en: Similarly, if we dictate the steps a developer must take to implement a feature,
    emergent opportunities that are only visible to the implementer might be overlooked.
    This situation is where the trifecta leadership and collaborative model of squads
    is potent. Not only can we communicate the commander’s intent of a particular
    change but developers also have local sources of authority to present these new
    opportunities for strategic direction.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果我们强制开发者按照规定的步骤实现某个功能，那么那些只有实现者才能看到的新兴机会可能会被忽视。这种情况下，三位一体的领导和协作模式（Squads）非常有效。我们不仅能传达特定变更的指挥意图，而且开发者还拥有本地的权威来源，以便展示这些新机会和战略方向。
- en: Previously, I worked in an organization that used a particular framework to
    attempt to safely scale agile development while retaining complete control over
    the product teams. This framework implementation resulted in a misalignment of
    strategic direction. In other words, the process did not empower the teams to
    be self-sufficient and capitalize on opportunities, as the requirement was to
    surface such opportunities at multiple layers before we could take action. The
    self-sufficient team is the antithesis of this paradigm. Rather than asserting
    control, we seek to empower and provide strategic direction while enabling strategic
    opportunity.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我在一个组织工作，使用一种特定的框架，试图在保持对产品团队的完全控制的同时安全地扩展敏捷开发。这个框架的实施导致了战略方向的不一致。换句话说，这个过程没有使团队具备自给自足并抓住机会的能力，因为要求在我们采取行动之前，要在多个层级上展示这些机会。自给自足的团队正是这一范式的对立面。我们不再强调控制，而是寻求授权并提供战略方向，同时促进战略机会。
- en: The topology of your teams
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 团队的拓扑结构
- en: 'In their seminal work, *Team Topologies*, Matthew Skelton and Manuel Pais identify
    four types of teams in a DevSecOps-focused organization, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的开创性著作《*团队拓扑*》中，Matthew Skelton 和 Manuel Pais 确定了在一个 DevSecOps 聚焦的组织中四种类型的团队，如下所示：
- en: Stream-aligned teams
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程对齐团队
- en: Enabling teams
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋能团队
- en: Complicated subsystem team
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂子系统团队
- en: Platform team
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平台团队
- en: The stream-aligned team is an expert in a business domain, aligning its output
    with the strategic direction of that business area. This team is your organization’s
    primary type, directly focused on changes that will solve your business’s or its
    customers’ problems. Note that the organization of these teams is by business
    domain, while Conway’s law assumes that these domains will naturally be bounded
    contexts within our architecture. We should not constrain the team to own and
    operate only a particular part of the code base.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 流程对齐团队是业务领域的专家，其输出与该业务领域的战略方向保持一致。这个团队是你组织的主要团队，直接专注于解决业务或客户问题的变化。请注意，这些团队的组织是按业务领域划分的，而康威定律假设这些领域会在我们的架构中自然形成有界上下文。我们不应将团队限制为只拥有和操作代码库中的某一部分。
- en: The enabling team supports the other team types in achieving their goals by
    providing technical guidance and enabling artifacts to the development team. For
    example, a dedicated security team might assist teams with unique security problems
    in their development process. It’s important to note that the existence of these
    teams does not absolve other teams of their responsibilities. These teams are
    enhancers, not replacements for self-sufficiency.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 启用团队通过提供技术指导和支持开发团队的工作成果，帮助其他类型的团队实现目标。例如，专门的安全团队可能协助那些在开发过程中面临独特安全问题的团队。需要注意的是，这些团队的存在并不意味着可以免除其他团队的责任。这些团队是增强者，而非取代自给自足的角色。
- en: The complicated subsystem team deals with a subsystem that takes deep technical
    or engineering capability. This type of team is generally the only time we assign
    a team to a particular part of your organization’s architecture, and typically,
    the role of this team is to abstract the complicated subsystem so that other parts
    of the business can interact with it. A typical example might be a bank that still
    has a mainframe; we manage the mainframe with a complicated subsystem team that
    provides interfaces for other teams to interact with.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂子系统团队处理的是需要深入技术或工程能力的子系统。这种类型的团队通常是唯一会被分配到组织架构中特定部分的团队，通常，这个团队的角色是将复杂的子系统抽象出来，供业务的其他部分与之交互。一个典型的例子可能是某个仍在使用大型主机的银行；我们通过复杂子系统团队来管理该主机，并为其他团队提供接口以便交互。
- en: 'The platform team is the development team for your developers; they build internal
    products for which your other teams are the consumers. The platform might consist
    of standardized build pipelines and guardrails, enabling artifacts and tooling
    such as Git, ticket management software, and so on. As we discussed before, your
    metrics and customer development teams should guide this team’s strategic direction.
    These teams have three main modes of operation:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 平台团队是开发团队为开发人员所建设的团队；他们为其他团队提供内部产品，其他团队则是这些产品的使用者。平台可能包括标准化的构建流水线和护栏、启用的工件和工具，如Git、票务管理软件等。正如我们之前讨论过的，你的度量标准和客户开发团队应该引导该团队的战略方向。该团队有三种主要的运作模式：
- en: '**Collaboration**: This involves teams working together for some time. These
    might be teams with closely related changes in progress, a stream team working
    with the platform team to develop new tooling, or a team working with a complicated
    subsystem team to evolve the service.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：这涉及到团队之间的长期合作。这些可能是进行相关变更的团队，或是流线型团队与平台团队合作开发新工具，亦或是团队与复杂子系统团队共同努力，以推动服务的演进。'
- en: '**X as a service**: This model typically refers to complicated subsystem teams
    abstracting away technically complex functionality behind a service that other
    teams can consume.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**X即服务**：这种模型通常指的是复杂的子系统团队将技术上复杂的功能抽象成服务，供其他团队使用。'
- en: '**Facilitating**: This involves teams working together to achieve a particular
    team’s goals. For example, the security enabling team might facilitate changes
    to the authorization logic required by a stream-aligned team. This mode typically
    also involves empowering the team to be self-sufficient moving forward.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进**：这涉及到团队合作以实现特定团队的目标。例如，安全启用团队可能促进对流线型团队所需的授权逻辑的变更。这种模式通常也包括赋能团队，以便在未来能够自给自足。'
- en: When identifying these modes of operation, a few anti-patterns arise. The most
    common one is assuming that too many parts of your organization are complicated
    subsystems. The critical distinction is that complicated subsystem teams focus
    on something technically complex. A complex business domain is not a complicated
    subsystem. This method of thinking returns us to the trap of aligning our teams
    with our existing architecture rather than our business domains and allowing the
    architecture to grow out of the natural bounded contexts of those emergent domains.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在识别这些运作模式时，出现了一些反模式。最常见的一个是认为组织中的许多部分都是复杂的子系统。关键的区别在于，复杂的子系统团队专注于某些技术复杂的内容。复杂的业务领域并不是一个复杂的子系统。这种思维方式将我们带回了一个陷阱：将团队与现有架构对齐，而不是与业务领域对齐，并且让架构从这些新兴领域的自然边界上下文中发展出来。
- en: When enabling teams need to facilitate the goals of stream-aligned teams, a
    common mistake they make is to assume that, as the experts in that area, they
    should just make the required changes. Fundamentally, to foster team self-sufficiency,
    the enabling team needs to mentor the stream-aligned team to improve the team’s
    capabilities.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当支持团队需要促进与流对齐团队目标的实现时，他们常犯的一个错误是，假设作为该领域的专家，他们应该直接做出所需的改变。从根本上说，为了促进团队的自给自足，支持团队需要指导流对齐团队，提高团队的能力。
- en: Finally, it can be tempting to use the X-as-a-service pattern liberally for
    things that are the entire organization’s responsibility. A key example is security.
    Security is not a system we can develop in isolation and provide to developers
    as a service. It is the responsibility of every member of every team. We can build
    our platform tooling and enabling teams to incentivize and foster good security
    practices. The purpose of the X-as-a-service mode of interaction is to remove
    technical responsibility from the service consumers, which is counterproductive
    in the case of security.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于那些整个组织负责的事务，使用X-as-a-service模式可能会很有诱惑力。一个关键的例子就是安全性。安全性不是我们可以独立开发并作为服务提供给开发者的系统。它是每个团队成员的责任。我们可以构建我们的平台工具，并使支持团队能够激励并培养良好的安全实践。X-as-a-service交互模式的目的是将技术责任从服务消费者身上移除，而在安全性的情况下，这种做法是适得其反的。
- en: Champions and the T-shaped engineer
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冠军和T型工程师
- en: As we shift from a traditional delivery model to a cloud native delivery model,
    we also broaden the horizon of services we can consume. Rather than solving business
    problems in the same ways over and over again, we have the opportunity to leverage
    cloud native services. However, as we broaden our horizons, inevitably, we must
    educate our teams on the best practices for these new types of services. In the
    traditional model, every developer could understand the architecture and code
    patterns required. It is unreasonable to expect all of our team to become experts
    overnight; however, each of our developers will need to acquire a broad knowledge
    of cloud native services to identify when certain patterns should be used. This
    broad knowledge forms the top bar of the T-shaped engineer, a wide but shallow
    knowledge that is typically acquired through self-learning. When they use certain
    patterns repeatedly, they develop a deep understanding of specific implementation
    idiosyncrasies of the services involved, developing a deep knowledge. This forms
    the column of our T-shaped engineer, a deep but tightly scoped expertise. The
    idea is that with a few T-shaped engineers on the team, we have a diversity of
    technical opinions available to guide the technical direction of the team.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们从传统交付模型转向云原生交付模型，我们也在拓宽可以使用的服务范围。我们不再一次又一次地用相同的方式解决业务问题，而是有机会利用云原生服务。然而，随着我们视野的拓宽，我们必然需要教育我们的团队关于这些新型服务的最佳实践。在传统模型中，每个开发者都能够理解所需的架构和代码模式。指望我们的团队一夜之间成为专家是不现实的；然而，我们的每个开发者都需要获得关于云原生服务的广泛知识，以便在某些模式需要使用时能够识别出来。这种广泛的知识构成了T型工程师的顶端，它是通过自学获得的广泛但浅显的知识。当他们反复使用某些模式时，他们会深入理解所涉及服务的特定实现特点，形成深厚的知识。这构成了我们T型工程师的竖直部分，它是深度但范围有限的专业知识。这个理念是，当团队中有几个T型工程师时，我们就能够获得多样的技术意见来指导团队的技术方向。
- en: For business-wide, job-zero initiatives, such as security, accessibility, or
    code quality, we recommend electing champions within the teams to provide self-sufficient
    teams with the internal capability to meet their goals. It is then the responsibility
    of the governing group behind this initiative, which may be an enabling team,
    to support these champions in developing their field. This may include supporting
    self-learning through certification pathways, funding them to attend conferences,
    and providing internal knowledge-sharing opportunities. The key here is that the
    company must invest in its people for the initiative to succeed and yield results.
    It is simply not enough to continue business as usual. In the cloud space, technology
    and practices evolve rapidly; as a company, to maximize your return on cloud investment,
    you must invest in people.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于公司范围内的零基础倡议，例如安全性、可访问性或代码质量，我们建议在团队内选举出冠军人物，以便为自给自足的团队提供满足目标的内部能力。然后，由支持这一倡议的管理团队（可能是支持团队）负责支持这些冠军人物在各自领域的发展。这可能包括通过认证路径支持自学，资助他们参加会议，以及提供内部知识共享机会。关键在于，公司必须投资于其员工，才能使倡议成功并取得成果。仅仅按部就班地继续开展业务是远远不够的。在云技术领域，技术和实践发展迅速；作为一家公司，为了最大化云投资的回报，必须对员工进行投资。
- en: Building cloud native capability within teams takes time; it is important to
    recognize the need to provide teams with all the tools and opportunities to become
    self-sufficient. To achieve this, we explored using a trifecta leadership of the
    product owner, engineering manager, and scrum master. We also looked at ways for
    teams to organize their interactions with each other. Finally, we looked at how
    we can grow initiatives in the organization and provide diverse opinions by encouraging
    T-shaped engineers and champion programs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队中构建云原生能力需要时间；认识到需要为团队提供所有工具和机会，以使其具备自给自足的能力至关重要。为此，我们探讨了产品负责人、工程经理和敏捷教练的三重领导模式。同时，我们也研究了团队如何组织相互之间的互动。最后，我们考虑了如何在组织内推动倡议并通过鼓励T型工程师和冠军计划提供多样化的意见。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Through ownership of output and team empowerment, we have transformed our development
    teams into genuinely self-sufficient powerhouses. We have tempered their output
    with automated processes and guardrails to ensure that they are working within
    the constraints required by our business. We have also looked at mitigating the
    impact any one negative change can have on the overall system. These atomic changes
    will form the basis of our new development model going forward. Next up, we will
    be looking deeper into maintaining security and compliance in cloud native environments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对成果的 ownership（所有权）和团队赋能，我们已将开发团队转变为真正自给自足的强大力量。我们通过自动化流程和保护措施来调节他们的产出，确保他们在我们业务所需的约束条件下工作。我们还考虑了如何减少任何一个负面变化对整个系统的影响。这些原子化的变化将成为我们未来发展模型的基础。接下来，我们将深入研究如何在云原生环境中保持安全性和合规性。
