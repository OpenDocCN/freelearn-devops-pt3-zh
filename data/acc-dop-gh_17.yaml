- en: '*Chapter 14*: Securing Your Code'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：保障你的代码安全'
- en: 'In 2016, a dispute about the name *Kik* between the messenger service Kik ([https://www.kik.com/](https://www.kik.com/))
    and open source contributor *Azer Koçulu*, who maintained a project with the same
    name, led to a complete outage of the internet. At least everybody noticed that
    day that something was wrong. What happened? Because of the dispute and npm siding
    with the messenger service, Azer retracted all his packages from the npm registry.
    Among the packages was a package called `left-pad`. Its purpose was to add characters
    to the beginning of a string of text. `left-pad` was a simple module with only
    11 lines of code:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年，消息服务Kik（[https://www.kik.com/](https://www.kik.com/)）与开源贡献者*Azer Koçulu*之间关于*Kik*名称的争执，导致了整个互联网的完全宕机。至少那天每个人都注意到出了问题。发生了什么？由于争执以及npm支持消息服务Kik，Azer将自己所有的包从npm注册表中撤回。撤回的包中包括一个名为`left-pad`的包。这个包的功能是向文本字符串的开头添加字符。`left-pad`是一个只有11行代码的简单模块：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a simple, single-purpose function that every developer should be able
    to write on their own. And yet the package made it into globally used frameworks
    such as *React*. React didn't require these 11 lines of code directly, of course.
    But it depended on packages that depend on other packages – and one package in
    this tree depended on `left-pad`. And that package missing basically broke the
    internet (see *Keith Collins 2016* and *Tyler Eon 2016*).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的单一功能，每个开发者都应该能够自己编写。然而，这个包却被纳入了全球使用的框架，比如*React*。当然，React本身并不直接需要这11行代码，但它依赖的包又依赖于其他包——而这个依赖树中的某个包就依赖于`left-pad`。这个包的缺失几乎让整个互联网崩溃（参见*Keith
    Collins 2016*和*Tyler Eon 2016*）。
- en: Software today depends on a lot of different software – tools, packages, frameworks,
    compilers, and languages – and each of these has its own dependency tree. It's
    important to ensure security and license compliance not just for your code but
    for your entire software supply chain.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，软件依赖于许多不同的软件——工具、包、框架、编译器和语言——每一个都有自己的依赖树。确保不仅是你自己的代码，整个软件供应链的安全性和许可证合规性都非常重要。
- en: In this chapter, you'll learn how GitHub Actions and Advanced Security can help
    you to eliminate bugs and security issues in your code and successfully manage
    your software supply chain.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你将学习如何通过GitHub Actions和高级安全功能，帮助你消除代码中的错误和安全问题，并成功管理你的软件供应链。
- en: 'The key topics in this chapter are as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键内容如下：
- en: Dependency management and Dependabot
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖管理与Dependabot
- en: Secret scanning
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密扫描
- en: Code scanning
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码扫描
- en: Writing your own CodeQL queries
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写你自己的CodeQL查询
- en: GitHub Advanced Security
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: GitHub高级安全
- en: Many features discussed in this chapter are only available for GitHub Enterprise
    if you acquire the **Advanced Security License**. Some of them are free for open
    source – but if some are not available in your organization, then you probably
    have not acquired the corresponding license.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本章讨论的许多功能仅在你获得**高级安全许可证**后，才能在GitHub Enterprise中使用。其中一些功能对开源项目免费提供——但如果你的组织无法使用某些功能，可能是因为你没有获得相应的许可证。
- en: Dependency management and Dependabot
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理与Dependabot
- en: To manage your dependencies, you can use **Software Composition Analysis** (**SCA**)
    tools. GitHub offers **Dependency graphs**, **Dependabot alerts**, and **Dependabot
    security updates** to manage your software dependencies.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理你的依赖关系，你可以使用**软件组成分析**（**SCA**）工具。GitHub提供了**依赖图**、**Dependabot警报**和**Dependabot安全更新**来管理你的软件依赖关系。
- en: '**Dependency graph** helps you to understand your dependency tree. **Dependabot
    alerts** check your dependencies for known vulnerabilities and alert you in case
    Dependabot finds any. If you enable **Dependabot security updates**, Dependabot
    will automatically create pull requests that update your dependencies if the author
    of the dependent package releases a fix for a vulnerability.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖图**帮助你了解你的依赖树。**Dependabot警报**检查你的依赖项是否存在已知漏洞，如果Dependabot发现任何问题，它会发出警报。如果你启用**Dependabot安全更新**，Dependabot将在依赖包的作者发布漏洞修复后自动创建拉取请求来更新你的依赖项。'
- en: 'The dependency graph is enabled by default for public repositories but not
    for private ones. Dependabot alerts and updates must be enabled for all repositories.
    You can do this under **Settings** | **Security & Analysis** (see *Figure 14.1*):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖图默认对公共仓库启用，但私有仓库则没有启用。Dependabot的警报和更新必须在所有仓库中启用。你可以在**设置** | **安全性与分析**中完成此操作（见*图14.1*）：
- en: '![Figure 14.1 – Enable the dependency graph and Dependabot'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.1 – 启用依赖图和Dependabot](图14.1)'
- en: '](img/B17827_14_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_001.jpg)'
- en: Figure 14.1 – Enable the dependency graph and Dependabot
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.1 – 启用依赖图和 Dependabot
- en: On the organizational level, you can enable these options for all repositories
    and make them the default for new repositories.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织级别，你可以为所有仓库启用这些选项，并将其设为新仓库的默认设置。
- en: Exploring your dependencies
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索你的依赖关系
- en: 'If you enable the dependency graph, it will start looking for dependencies.
    The following package ecosystems are supported (see *Table 14.1*):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了依赖图，它将开始寻找依赖关系。以下包生态系统是受支持的（参见*表 14.1*）：
- en: '![Table 14.1 – Supported formats for the dependency graph and Dependabot'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 14.1 – 依赖图和 Dependabot 支持的格式'
- en: '](img/B17827_table_14.1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_table_14.1.jpg)'
- en: Table 14.1 – Supported formats for the dependency graph and Dependabot
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.1 – 依赖图和 Dependabot 支持的格式
- en: 'To explore your dependencies, you can navigate to **Insights** | **Dependency
    graph**. On the **Dependencies** tab, you can find all the dependencies for the
    manifest files that were found in your repository. You can open the dependencies
    for each dependency and navigate the tree. If the dependency has a known vulnerability,
    you can see it on the right side. The vulnerability has an assigned severity and
    a **Common Vulnerabilities and Exposures** (**CVE**) identifier. With this identifier,
    you can look up the details for the vulnerability in the **National Vulnerability
    Database** ([nvd.nist.gov](http://nvd.nist.gov)). Click on the link, and it will
    direct you to the entry in the database ([https://nvd.nist.gov/vuln/detail/CVE-2021-3749](https://nvd.nist.gov/vuln/detail/CVE-2021-3749))
    or to the **GitHub Advisory Database** ([https://github.com/advisories](https://github.com/advisories)).
    If there is a fix for the vulnerability, the dependency graph suggests the version
    you should upgrade the dependency to (see *Figure 14.2*):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索你的依赖关系，你可以导航到**洞察** | **依赖图**。在**依赖项**标签下，你可以找到仓库中所有的清单文件依赖关系。你可以打开每个依赖项，并浏览树状结构。如果某个依赖项存在已知漏洞，你可以在右侧看到它。漏洞会标明严重性，并且有一个**常见漏洞和暴露**（**CVE**）标识符。通过该标识符，你可以在**国家漏洞数据库**（[nvd.nist.gov](http://nvd.nist.gov)）中查找漏洞详情。点击链接，它会将你引导到数据库中的条目（[https://nvd.nist.gov/vuln/detail/CVE-2021-3749](https://nvd.nist.gov/vuln/detail/CVE-2021-3749)）或**GitHub
    安全顾问数据库**（[https://github.com/advisories](https://github.com/advisories)）。如果有修复该漏洞的版本，依赖图会建议你升级到该版本（参见*图
    14.2*）：
- en: '`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`'
- en: '![Figure 14.2 – Exploring your dependencies with the dependency graph'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.2 – 使用依赖图探索你的依赖关系'
- en: '](img/B17827_14_002.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_002.jpg)'
- en: Figure 14.2 – Exploring your dependencies with the dependency graph
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 – 使用依赖图探索你的依赖关系
- en: 'On the *organization level*, under **Insights** | **Dependencies**, you can
    find all dependencies from all repositories that have turned on the dependency
    graph. In addition to the repository insights, you can find all the used licenses
    here. This can help you to check the license compliance of your products (see
    *Figure 14.3*):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在*组织级别*，在**洞察** | **依赖项**下，你可以找到所有启用了依赖图的仓库中的依赖项。除了仓库的洞察外，你还可以在此处找到所有使用的许可证。这可以帮助你检查产品的许可证合规性（参见*图
    14.3*）：
- en: '![Figure 14.3 – Dependency insights on the organization level'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.3 – 组织级别的依赖关系洞察'
- en: '](img/B17827_14_003.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_003.jpg)'
- en: Figure 14.3 – Dependency insights on the organization level
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3 – 组织级别的依赖关系洞察
- en: If you want to leverage GitHub to inform others that depend on your packages,
    you can draft a new **security advisory** under **Security** | **Security Advisories**
    | **New draft security advisory**. The security advisor contains a title, description,
    the ecosystem, the package name, the affected versions (that is, < 1.2.3), the
    patched versions (1.2.3), and the severity. You can optionally add multiple **Common
    Weakness Enumerators** (**CWEs**) (see [https://cwe.mitre.org/](https://cwe.mitre.org/)).
    If you already have a CVE ID, you can add it here; if not, you can select to add
    it later.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想利用 GitHub 通知其他依赖你的包的人，你可以在**安全** | **安全顾问** | **新草稿安全顾问**下起草一个新的**安全顾问**。安全顾问包含标题、描述、生态系统、包名称、受影响版本（例如，<
    1.2.3）、修复版本（1.2.3）和严重性。你可以选择性地添加多个**常见弱点枚举**（**CWE**）（参见[https://cwe.mitre.org/](https://cwe.mitre.org/)）。如果你已有
    CVE ID，可以在此添加；如果没有，你可以选择稍后添加。
- en: The draft is only visible to repository owners until it is published. Once published,
    security advisories on public repositories are visible to everyone and are added
    to the **GitHub Advisory Database** ([https://github.com/advisories](https://github.com/advisories)).
    For private repositories, they are only visible to everyone that has access to
    the repository, and they do not get added to the advisory database until you request
    an official CVE identifier.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 草稿在发布之前只对仓库所有者可见。发布后，公共仓库中的安全公告对所有人可见，并会添加到**GitHub Advisory Database**（[https://github.com/advisories](https://github.com/advisories)）。对于私人仓库，只有有权访问仓库的人员可以看到这些公告，且在请求官方CVE标识符之前，它们不会被添加到公告数据库中。
- en: Dependabot
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dependabot
- en: '**Dependabot** is a bot in GitHub that can check your dependencies for known
    vulnerabilities. It can also automatically create pull requests to keep your dependencies
    up to date.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dependabot**是GitHub中的一个机器人，能够检查你的依赖项是否存在已知漏洞。它还可以自动创建拉取请求，以保持你的依赖项最新。'
- en: Dependabot supports npm, GitHub Actions, Docker, git submodules, .NET (NuGet),
    pip, Terraform, Bundler, Maven, and many other ecosystems. For a complete list,
    see [https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-dependabot-version-updates#supported-repositories-and-ecosystems](https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-dependabot-version-updates#supported-repositories-and-ecosystems).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Dependabot 支持 npm、GitHub Actions、Docker、git 子模块、.NET（NuGet）、pip、Terraform、Bundler、Maven
    等多个生态系统。完整的支持列表，请参见 [https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-dependabot-version-updates#supported-repositories-and-ecosystems](https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-dependabot-version-updates#supported-repositories-and-ecosystems)。
- en: 'To enable Dependabot, create a `dependabot.yml` file in the `.github` directory.
    You select the package ecosystem and the directory that contains the package file
    (that is, the `package.json` file). You have to specify whether Dependabot should
    check for updates `daily`, `weekly`, or `monthly`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用Dependabot，在`.github`目录中创建一个`dependabot.yml`文件。你需要选择包生态系统和包含包文件（即`package.json`文件）的目录。你必须指定Dependabot是每天、每周还是每月检查更新：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can authenticate to private registries using **Dependabot secrets**. Add
    a new secret under **Settings** | **Secrets** | **Dependabot** (see Figure 14.4**)**:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用**Dependabot secrets**对私有注册表进行身份验证。在**Settings** | **Secrets** | **Dependabot**下添加一个新的秘密（见图14.4**）**：
- en: '![Figure 14.4 – Adding a Dependabot secret'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.4 – 添加Dependabot秘密'
- en: '](img/B17827_14_004.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_004.jpg)'
- en: Figure 14.4 – Adding a Dependabot secret
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 – 添加Dependabot秘密
- en: 'Then, add the registry to the `dependabot.yml` file and access the secret from
    the `secret` context:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将注册表添加到`dependabot.yml`文件中，并从`secret`上下文中访问该秘密：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There are many more options to configure Dependabot – you can allow or deny
    certain packages, apply metadata to pull requests (such as labels, milestones,
    and reviewers), customize the commit message, or you can change the merge strategy.
    For a complete list of options, see [https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates](https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他选项可以配置Dependabot——你可以允许或拒绝某些包，向拉取请求添加元数据（如标签、里程碑和审阅者），自定义提交信息，或者更改合并策略。有关完整选项列表，请参见
    [https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates](https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates)。
- en: 'You can check the status of Dependabot updates under **Insights** | **Dependency
    graph** | **Dependabot**. Each update entry has a row with a status and warning
    icons if something is wrong. Click the status to see the complete log (see *Figure
    14.5*):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**Insights** | **Dependency graph** | **Dependabot**下查看Dependabot更新的状态。如果有问题，每个更新条目会显示一个状态和警告图标。点击状态查看完整日志（见*图14.5*）：
- en: '![Figure 14.5 – Viewing Dependabot status and log files'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.5 – 查看Dependabot状态和日志文件'
- en: '](img/B17827_14_005.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_005.jpg)'
- en: Figure 14.5 – Viewing Dependabot status and log files
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 查看Dependabot状态和日志文件
- en: 'You can find all the Dependabot alerts under **Security** | **Dependabot alerts**.
    You can click on each item to see details. If Dependabot has already created a
    pull request to fix the vulnerability, you can see a link with a fly-out menu
    in the list (see *Figure 14.6*):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 **安全** | **Dependabot 警报** 中找到所有的 Dependabot 警报。你可以点击每个项目查看详细信息。如果 Dependabot
    已经创建了拉取请求来修复该漏洞，你可以在列表中看到一个带有弹出菜单的链接（参见*图 14.6*）：
- en: '![Figure 14.6 – Viewing Dependabot alerts'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.6 – 查看 Dependabot 警报'
- en: '](img/B17827_14_006.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_006.jpg)'
- en: Figure 14.6 – Viewing Dependabot alerts
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.6 – 查看 Dependabot 警报
- en: 'Note that only the security alerts are in this list – not all the pull requests
    that get created to update your dependencies. There are also a lot of security
    alerts here that don''t have a fix yet. Sometimes, the only fix is a downgrade,
    and if one of your dependents states a minimum higher version, there is no automated
    fix (see *Figure 14.7*):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个列表中仅包含安全警报 —— 并不是所有创建的拉取请求都用于更新你的依赖项。这里也有很多尚未修复的安全警报。有时，唯一的修复方法是降级，如果你的某个依赖声明了更高的最低版本，那么就没有自动修复（参见*图
    14.7*）：
- en: '![Figure 14.7 – Details of a vulnerability that has no fix'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.7 – 没有修复的漏洞详情'
- en: '](img/B17827_14_007.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_007.jpg)'
- en: Figure 14.7 – Details of a vulnerability that has no fix
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.7 – 没有修复的漏洞详情
- en: 'If you have a closer look at the pull requests of Dependabot, you''ll notice
    a lot of additional information. Of course, the changes themselves are only updated
    version numbers in a manifest file. But in the description, it adds the release
    notes from the package – if there are any – and a complete list of the commits
    that are in the new release. Dependabot also adds a compatibility score that indicates
    how likely it is that this update will be compatible with your code (see *Figure
    14.8*):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看 Dependabot 的拉取请求，你会注意到许多附加信息。当然，变更本身只是清单文件中的版本号更新。但在描述中，它会添加包的发布说明 ——
    如果有的话 —— 以及新版本中的所有提交的完整列表。Dependabot 还会添加一个兼容性评分，表示该更新与您的代码兼容的可能性有多大（参见*图 14.8*）：
- en: '![Figure 14.8 – Details of a Dependabot pull request'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.8 – Dependabot 拉取请求详情'
- en: '](img/B17827_14_008.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_008.jpg)'
- en: Figure 14.8 – Details of a Dependabot pull request
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.8 – Dependabot 拉取请求详情
- en: 'In the description, you will also find a list of commands that you can send
    to the bot by commenting on the pull request. You can use any of the following
    commands:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述中，你还会找到一份可以通过评论拉取请求发送给机器人的命令列表。你可以使用以下任何一个命令：
- en: '`@dependabot cancel merge`: Cancels a previously requested merge.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@dependabot cancel merge`：取消先前请求的合并。'
- en: '`@dependabot close`: Closes the pull request and prevents Dependabot from recreating
    it. You can achieve the same result by closing the pull request manually.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@dependabot close`：关闭拉取请求，并阻止 Dependabot 重新创建它。你也可以通过手动关闭拉取请求来实现相同的结果。'
- en: '`@dependabot ignore this dependency`: Closes the pull request and prevents
    Dependabot from creating any more pull requests for this dependency (unless you
    reopen the pull request or upgrade to the suggested version of the dependency
    yourself).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@dependabot ignore this dependency`：关闭拉取请求，并阻止 Dependabot 为此依赖创建更多拉取请求（除非你重新打开拉取请求或自行升级到该依赖的建议版本）。'
- en: '`@dependabot ignore this major version`: Closes the pull request and prevents
    Dependabot from creating any more pull requests for this major version (unless
    you reopen the pull request or upgrade to this major version yourself).'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@dependabot ignore this major version`：关闭拉取请求，并阻止 Dependabot 为此主版本创建更多拉取请求（除非你重新打开拉取请求或自行升级到该主版本）。'
- en: '`@dependabot ignore this minor version`: Closes the pull request and prevents
    Dependabot from creating any more pull requests for this minor version (unless
    you reopen the pull request or upgrade to this minor version yourself).'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@dependabot ignore this minor version`：关闭拉取请求，并阻止 Dependabot 为此次要版本创建更多拉取请求（除非你重新打开拉取请求或自行升级到该次要版本）。'
- en: '`@dependabot merge`: Merges the pull request once your CI tests have passed.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@dependabot merge`：在你的 CI 测试通过后，合并拉取请求。'
- en: '`@dependabot rebase`: Rebases the pull request.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@dependabot rebase`：为拉取请求执行变基操作。'
- en: '`@dependabot recreate`: Recreates the pull request, overwriting any edits that
    have been made to the pull request.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@dependabot recreate`：重新创建拉取请求，覆盖对拉取请求所做的任何编辑。'
- en: '`@dependabot reopen`: Reopens the pull request if the pull request is closed.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@dependabot reopen`：如果拉取请求已关闭，则重新打开该拉取请求。'
- en: '`@dependabot squash and merge`: Squashes and merges the pull request once your
    CI tests have passed.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@dependabot squash and merge`：在你的CI测试通过后，会压缩并合并拉取请求。'
- en: Just comment on one of the commands in the pull request, and Dependabot will
    do the rest for you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在拉取请求中的某个命令上评论，Dependabot会为你处理剩下的工作。
- en: Automate Dependabot updates with GitHub Actions
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用GitHub Actions自动化Dependabot更新
- en: You can use GitHub Actions to add even more automation to Dependabot updates,
    but there are some things you have to be aware of. If Dependabot triggers a workflow,
    the GitHub actor is Dependabot (`github.actor == "Dependabot[bot]"`). This means
    that `GITHUB_TOKEN` has only read-only permissions by default, and you must grant
    write permissions if necessary. The secrets that are populated in the secret context
    are the Dependabot secrets! GitHub Actions secrets are not available to the workflow.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用GitHub Actions为Dependabot更新添加更多自动化，但需要注意一些事项。如果Dependabot触发了一个工作流，则GitHub演员是Dependabot（`github.actor
    == "Dependabot[bot]"`）。这意味着`GITHUB_TOKEN`默认只有只读权限，若有需要，你必须授予写权限。填充在秘密上下文中的密钥是Dependabot的密钥！GitHub
    Actions的密钥不能用于工作流。
- en: 'The following is an example of a workflow that only gets triggered by Dependabot
    pull requests and gets granted write permissions to pull requests, issues, and
    projects:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个仅在Dependabot拉取请求触发时才会启动的工作流示例，并且该工作流会被授予对拉取请求、问题和项目的写权限：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can use the `Dependabot/fetch-metadata` action to extract information about
    the dependencies being updated. Here is an example that uses the information to
    apply a label to the pull request:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`Dependabot/fetch-metadata`动作来提取关于更新依赖的信息。以下是一个示例，使用这些信息为拉取请求应用标签：
- en: '[PRE40]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Using the GitHub CLI, it''s really easy to add automation. You can, for example,
    auto-approve and auto-merge all new patches:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitHub CLI，添加自动化非常容易。例如，你可以自动批准并自动合并所有新的修复补丁：
- en: '[PRE51]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The combination of GitHub Actions and Dependabot is very powerful and can remove
    nearly all manual tasks to keep your software up to date. In combination with
    a good CI build and a test suite you trust, you can basically auto-merge all the
    Dependabot pull requests that pass the tests.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions与Dependabot的结合非常强大，可以消除几乎所有手动任务，以保持你的软件最新。结合一个可靠的CI构建和测试套件，你基本可以自动合并所有通过测试的Dependabot拉取请求。
- en: Use Dependabot to keep your GitHub actions up to date
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Dependabot保持你的GitHub Actions最新
- en: 'GitHub actions are also dependencies you must manage. Each action is pinned
    to a version (the part behind `@`, such as `uses: Dependabot/fetch-metadata@v1.1.1`).
    The version can also be a branch name – but this would result in flaky workflows,
    as your actions would change without you knowing. It''s better to pin the versions
    to a tag or an individual commit SHA. You can let Dependabot check for updates
    and create pull requests for you as with any other ecosystem. Add the following
    section to your `Dependabot.yml` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitHub Actions也是你必须管理的依赖项。每个动作都固定在某个版本（`@`后面的部分，例如`uses: Dependabot/fetch-metadata@v1.1.1`）。版本也可以是分支名，但这样会导致工作流不稳定，因为你的动作会在你不知情的情况下发生变化。最好将版本固定为标签或单独的提交SHA。你可以让Dependabot检查更新并为你创建拉取请求，就像其他任何生态系统一样。将以下部分添加到你的`Dependabot.yml`文件中：'
- en: '[PRE59]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Dependabot will create pull requests if new versions of your actions are available.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有新的版本可用，Dependabot将创建拉取请求。
- en: Secret scanning
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密扫描
- en: One of the most common attack vectors is secrets in plain text files. Secrets
    should never be stored unencrypted and unprotected. GitHub helps you with this
    by constantly scanning all your public repositories for secrets. You can also
    enable this for private repositories that belong to an organization where **GitHub
    Advanced Security** is enabled.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的攻击路径之一是纯文本文件中的密钥。密钥绝不应以未加密和未保护的方式存储。GitHub通过不断扫描你的所有公共仓库中的密钥来帮助你解决这个问题。你还可以为启用了**GitHub高级安全**的组织中的私有仓库启用此功能。
- en: Currently, there are nearly 100 secrets in public and 145 in private repositories
    that get detected – Adobe, Alibaba, Amazon, Atlassian, Azure, and so on. For a
    complete list, see [https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning](https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，在公共和私有仓库中，约有100个公开的密钥和145个私有密钥被检测到——包括Adobe、阿里巴巴、亚马逊、Atlassian、Azure等。完整的列表请参见[https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning](https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning)。
- en: As a service provider, you can sign up for the **secret scanning partner program**
    (see [https://docs.github.com/en/developers/overview/secret-scanning-partner-program](https://docs.github.com/en/developers/overview/secret-scanning-partner-program)).
    Your secrets get detected by a regular expression and are then sent to an endpoint,
    where you can verify whether the secret is real or whether it is a false positive.
    It is the decision of the partner to revoke the secret or just inform the customer
    that the secret is compromised.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 作为服务提供商，您可以加入 **秘密扫描合作伙伴计划** （参见 [https://docs.github.com/en/developers/overview/secret-scanning-partner-program](https://docs.github.com/en/developers/overview/secret-scanning-partner-program)）。您的秘密将通过正则表达式检测，然后发送到一个端点，在那里您可以验证秘密是真实的还是误报。合作伙伴决定是撤销秘密还是仅通知客户秘密已泄露。
- en: 'You can enable secret scanning for private repositories in **Settings** | **Security
    & analysis** | **GitHub Advanced Security**. Here, you can also define custom
    patterns by clicking **New pattern** (see *Figure 14.9*):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 **设置** | **安全与分析** | **GitHub 高级安全** 中为私有存储库启用秘密扫描。在这里，您还可以通过点击 **新模式**
    定义自定义模式（参见 *图 14.9*）：
- en: '![Figure 14.9 – Enabling secret scanning and adding custom patterns'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.9 – 启用秘密扫描并添加自定义模式'
- en: '](img/B17827_14_009.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_009.jpg)'
- en: Figure 14.9 – Enabling secret scanning and adding custom patterns
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.9 – 启用秘密扫描并添加自定义模式
- en: 'A custom pattern is a regular expression that matches the secrets you want
    to detect. You have to provide some test strings to see whether your pattern works.
    GitHub marks the secrets found in the test strings yellow (see *Figure 14.10*):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义模式是匹配您想要检测的秘密的正则表达式。您必须提供一些测试字符串以查看您的模式是否有效。GitHub 标记在测试字符串中找到的秘密为黄色（参见 *图
    14.10*）：
- en: '![Figure 14.10 – Adding a custom secret pattern'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.10 – 添加自定义秘密模式'
- en: '](img/B17827_14_010.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_010.jpg)'
- en: Figure 14.10 – Adding a custom secret pattern
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.10 – 添加自定义秘密模式
- en: 'You can also customize the patterns before and after the secret, and you can
    add patterns that must match or must not patch – for example, you can enforce
    with the additional pattern (`[A-Z]`) that the string must at least contain one
    uppercase letter (see *Figure 14.11*):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在秘密之前和之后自定义模式，并且可以添加必须匹配或不匹配的模式 – 例如，您可以使用额外模式 (`[A-Z]`) 强制字符串至少包含一个大写字母（参见
    *图 14.11*）：
- en: '![Figure 14.11 – Advanced options for custom patterns'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.11 – 自定义模式的高级选项'
- en: '](img/B17827_14_011.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_011.jpg)'
- en: Figure 14.11 – Advanced options for custom patterns
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.11 – 自定义模式的高级选项
- en: Custom patterns can also be defined on the organization and enterprise level,
    and GitHub will scan all repositories in the enterprise or organization with GitHub
    Advanced Security enabled.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义模式也可以在组织和企业级别定义，GitHub 将扫描启用了 GitHub 高级安全的企业或组织中的所有存储库。
- en: When a new secret is detected, GitHub notifies all users with access to security
    alerts for the repository according to their notification preferences. You will
    receive alerts if you are watching the repository, have enabled notifications
    for security alerts or all activity on the repository, are the author of the commit
    that contains the secret, and are not ignoring the repository.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当检测到新的秘密时，GitHub 根据用户的通知偏好通知所有具有存储库安全警报访问权限的用户。如果您正在关注存储库，已启用安全警报或存储库上的所有活动的通知，并且是包含秘密的提交的作者，则会收到警报，并且不会忽略存储库。
- en: 'You can manage the alerts under **Security** | **Secret scanning alerts** (see
    *Figure 14.12*):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 **安全** | **秘密扫描警报** 下管理警报（参见 *图 14.12*）：
- en: '![Figure 14.12 – Managing secret scanning alerts'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.12 – 管理秘密扫描警报'
- en: '](img/B17827_14_012.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_012.jpg)'
- en: Figure 14.12 – Managing secret scanning alerts
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.12 – 管理秘密扫描警报
- en: You should consider a secret that has been committed to GitHub compromised –
    even if it has only been to a private repository. Rotate and revoke the secret.
    Some service providers will revoke it for you.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 GitHub 上提交了一个秘密，即使它只提交到了私有存储库，也应该认为该秘密已经泄露。请更换并撤销秘密。一些服务提供商会为您撤销它。
- en: 'You can close an alert with the `Revoked`, `False positive`, `Used in tests`,
    or `Won''t fix` status (see *Figure 14.13*):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `Revoked`、`False positive`、`Used in tests` 或 `Won't fix` 状态关闭警报（参见 *图
    14.13*）：
- en: '![Figure 14.13 – Managing the status for a secret scanning alert'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.13 – 管理秘密扫描警报的状态'
- en: '](img/B17827_14_013.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_013.jpg)'
- en: Figure 14.13 – Managing the status for a secret scanning alert
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.13 – 管理秘密扫描警报的状态
- en: 'You can also exclude paths in your source code from secret scanning by adding
    a `secret_scanning.yml` file to the `.github` folder. The file supports multiple
    path patterns with wildcard support:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过向`.github`文件夹添加`secret_scanning.yml`文件，排除源代码中的路径进行秘密扫描。该文件支持使用通配符的多个路径模式：
- en: '[PRE65]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: But be careful! This should not be used to store real secrets in source files,
    even for testing – store secrets as GitHub encrypted secrets or in a secure vault.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心！这不应当用于在源文件中存储真实的秘密，即使是为了测试——应该将秘密存储为GitHub加密的秘密，或存储在安全的保险库中。
- en: Secret scanning is easy – you basically just have to turn it on. But the value
    of security should not be underestimated.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密扫描很简单——你基本上只需要启用它。但安全的重要性不容低估。
- en: Code scanning
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码扫描
- en: To find vulnerabilities in your own code, you can use **Static** **Application
    Security Testing** (**SAST**). SAST is considered white-box testing, as it has
    full access to the source code. It is not a pure static code analysis, as that
    normally includes building software. But unlike **Dynamic Application Security
    Testing** (**DAST**) – we will learn more about that in [*Chapter 15*](B17827_15_Epub.xhtml#_idTextAnchor313),
    *Securing Your Deployments* – it is not executed at runtime but at compile time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要在自己的代码中查找漏洞，可以使用**静态应用程序安全测试**（**SAST**）。SAST 被认为是白盒测试，因为它可以完全访问源代码。它不仅仅是静态代码分析，通常静态分析包括构建软件。但与**动态应用程序安全测试**（**DAST**）不同——我们将在[*第15章*](B17827_15_Epub.xhtml#_idTextAnchor313)《保护你的部署》中学习更多——它不是在运行时执行，而是在编译时执行。
- en: Code scanning in GitHub
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub中的代码扫描
- en: In GitHub, SAST is called **code scanning**, and it is available for all public
    repositories and for private repositories that have GitHub Advanced Security enabled.
    You can use code scanning with all tools that support the **Static Analysis Results
    Interchange Format** (**SARIF**). SARIF is an **OASIS Standard** based upon JSON
    that defines the output format for static analysis tools. GitHub code scanning
    currently supports **SARIF 2.1.0**, which is the newest version of the standard
    (see https://docs.github.com/en/code-security/code-scanning/integrating-with-code-scanning/sarif-support-for-code-scanning).
    So, any tool that supports SARIF 2.1.0 can integrate into code scanning.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub中，SAST被称为**代码扫描**，并且对所有公共仓库以及启用了GitHub高级安全的私有仓库都可用。你可以使用支持**静态分析结果交换格式**（**SARIF**）的所有工具进行代码扫描。SARIF是基于JSON的**OASIS标准**，定义了静态分析工具的输出格式。GitHub代码扫描目前支持**SARIF
    2.1.0**，这是该标准的最新版本（见 https://docs.github.com/en/code-security/code-scanning/integrating-with-code-scanning/sarif-support-for-code-scanning）。因此，任何支持SARIF
    2.1.0的工具都可以集成到代码扫描中。
- en: Running your code scans
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行代码扫描
- en: 'Code scanning uses GitHub Actions to execute the analysis. Most code scanning
    tools automatically upload the results to GitHub – but if your code scanning tool
    does not, you can upload any SARIF file using the following action:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 代码扫描使用GitHub Actions执行分析。大多数代码扫描工具会自动将结果上传到GitHub——但如果你的代码扫描工具不这样做，你可以使用以下操作上传任何SARIF文件：
- en: '[PRE67]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The action accepts individual `.sarif` (or `.sarif.json`) files or a folder
    with multiple files. This is useful if your scanning tool does not support SARIF,
    but the results can be converted. An example would be `ESLint`. You can use `@microsoft/eslint-formatter-sarif`
    to convert the output to SARIF and upload the results:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作接受单个`.sarif`（或`.sarif.json`）文件，或者包含多个文件的文件夹。如果你的扫描工具不支持SARIF，但结果可以转换，这很有用。例如，`ESLint`。你可以使用`@microsoft/eslint-formatter-sarif`将输出转换为SARIF并上传结果：
- en: '[PRE71]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: However, most code scanning tools integrate natively into GitHub.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数代码扫描工具已原生集成到GitHub中。
- en: Getting started
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入门
- en: 'To get started with code scanning, go to `/security/code-scanning/setup`, which
    shows you a list of code scanning options. On top, you can see the native GitHub
    code scanning tool – **CodeQL Analysis**. But GitHub analyses your repository
    and also shows you all the other tools it can find in the marketplace that fit
    the languages that were detected in your repository – **42Crunch**, **Anchore**,
    **CxSAST**, **Veracode**, and many more. In this book, we''ll focus on **CodeQL**
    – but the integration of the other tools works the same way. If you click **Set
    up this workflow**, GitHub will create a workflow for you (see *Figure 14.14*):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用代码扫描，请转到`/security/code-scanning/setup`，这里会显示代码扫描选项的列表。顶部是 GitHub 原生的代码扫描工具——**CodeQL
    分析**。但 GitHub 还会分析你的仓库，展示它可以在市场中找到的其他工具，这些工具适用于在你的仓库中检测到的语言——**42Crunch**、**Anchore**、**CxSAST**、**Veracode**
    等等。在本书中，我们将重点介绍**CodeQL**——但其他工具的集成方式相同。如果你点击**设置此工作流**，GitHub 将为你创建一个工作流（见*图
    14.14*）：
- en: '![Figure 14.14 – Setting up code scanning'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.14 – 设置代码扫描'
- en: '](img/B17827_14_014.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_014.jpg)'
- en: Figure 14.14 – Setting up code scanning
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.14 – 设置代码扫描
- en: 'If you have already set up code scanning, you can add additional tools from
    the results page by clicking **Add more scanning tools** (see *Figure 14.15*):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经设置了代码扫描，你可以通过点击**添加更多扫描工具**来从结果页面添加额外的工具（见*图 14.15*）：
- en: '![Figure 14.15 – Code scanning alerts in a repository'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.15 – 仓库中的代码扫描警报'
- en: '](img/B17827_14_015.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_015.jpg)'
- en: Figure 14.15 – Code scanning alerts in a repository
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.15 – 仓库中的代码扫描警报
- en: 'The workflow template has a trigger for `push`, `pull_request`, and `schedule`.
    The schedule might surprise you, but it has a simple explanation – there might
    be new rules that detect vulnerabilities in your codebase that have not been recognized
    before. So, it is a good idea to run the build also on a scheduled basis. The
    trigger runs once per week on a random day and to a random time. Of course, GitHub
    does not want all code scans to run at the same time. Adjust the schedule to your
    needs:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流模板包含`push`、`pull_request`和`schedule`的触发器。可能会对`schedule`感到意外，但它有一个简单的解释——可能有新的规则检测到代码库中之前未曾识别的漏洞。因此，定期运行构建是一个不错的选择。触发器每周在随机的一天和时间运行一次。当然，GitHub不希望所有代码扫描在同一时间运行。根据需要调整时间表：
- en: '[PRE85]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The workflow needs write permissions for security events:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流需要对安全事件具有写权限：
- en: '[PRE92]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'CodeQL supports C++ (`cpp`), C# (`csharp`), Go, Java, JavaScript, Python, and
    Ruby. GitHub tries to detect the languages used in your repository and sets up
    the matrix so that each language gets built independently. Add additional languages
    if necessary:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: CodeQL 支持 C++（`cpp`）、C#（`csharp`）、Go、Java、JavaScript、Python 和 Ruby。GitHub 会尝试检测你仓库中使用的语言，并设置矩阵，使每种语言独立构建。如有必要，可以添加额外的语言：
- en: '[PRE100]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The analysis itself is quite simple – check out the repository, initialize
    the analysis for the given language, run `autobuild`, and perform the analysis:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 分析本身相当简单——检查仓库，初始化给定语言的分析，运行`autobuild`，并执行分析：
- en: '[PRE104]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The `autobuild` step tries to build your source code. If it fails, you have
    to change the workflow and build the code yourself. Sometimes, it is enough to
    set up the right version in the environment – for example, the version of Node.js
    or .NET:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`autobuild`步骤尝试构建你的源代码。如果失败，你需要更改工作流并手动构建代码。有时，仅仅在环境中设置正确的版本就足够了——例如，Node.js
    或 .NET 的版本：'
- en: '[PRE115]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Code scanning alerts
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码扫描警报
- en: 'You can manage your code scanning alerts in each repository under **Settings**
    | **Security & analysis** | **Code scanning** – as you saw in *Figure 14.15*.
    On the organization level, you get an overview of all repositories, and you can
    jump to the individual results page (see *Figure 14.16*):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在每个仓库的**设置** | **安全与分析** | **代码扫描**下管理代码扫描警报——正如你在*图 14.15*中看到的。在组织级别，你可以看到所有仓库的概览，并跳转到各个结果页面（见*图
    14.16*）：
- en: '![Figure 14.16 – The security overview for an organization'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.16 – 组织的安全概述'
- en: '](img/B17827_14_016.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_016.jpg)'
- en: Figure 14.16 – The security overview for an organization
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.16 – 组织的安全概述
- en: You can filter, sort, and search alerts the same way you can with issues.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理问题一样过滤、排序和搜索警报。
- en: Severity
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严重性
- en: Every code scanning alert has a severity assigned. The severity is calculated
    using the **Common Vulnerability Scoring System** (**CVSS**). The CVSS is an open
    framework for communicating the characteristics and severity of software vulnerabilities
    (see *GitHub Blog 2021* for more information).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每个代码扫描警报都有一个分配的严重性。严重性是使用**常见漏洞评分系统**（**CVSS**）计算的。CVSS 是一个用于沟通软件漏洞特征和严重性的开源框架（有关更多信息，请参见*GitHub
    博客 2021*）。
- en: The severity helps you to triage your alerts.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 严重性有助于你筛查警报。
- en: Tracking alerts in issues
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在问题中追踪警报
- en: 'The best way to track a code scanning alert is in an issue. You can create
    one by clicking **Create issue** inside the alert (see *Figure 14.17*):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪代码扫描警报的最佳方式是在问题中。你可以通过点击警报中的**创建问题**来创建一个问题（参见*图 14.17*）：
- en: '![Figure 14.17 – Creating an issue from a code scanning alert'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.17 – 从代码扫描警报创建问题'
- en: '](img/B17827_14_017.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_017.jpg)'
- en: Figure 14.17 – Creating an issue from a code scanning alert
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.17 – 从代码扫描警报创建问题
- en: 'But it is just opening a new issue and adding the link to the alert into a
    Markdown task list (see *Figure 14.18*):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是打开一个新问题，并将警报的链接添加到 Markdown 任务列表中（参见*图 14.18*）：
- en: '![Figure 14.18 – Linking an issue to a code scanning alert'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.18 – 将问题与代码扫描警报关联'
- en: '](img/B17827_14_018.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_018.jpg)'
- en: Figure 14.18 – Linking an issue to a code scanning alert
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.18 – 将问题与代码扫描警报关联
- en: The alert will have an indicator that it is being tracked in an issue – like
    nested issues do (see *Figure 14.19* in the next).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 警报会有一个指示器，表明它正被追踪在一个问题中——就像嵌套问题那样（参见下面的*图 14.19*）。
- en: Data-flow analysis
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据流分析
- en: 'In the area under the code, you can see the details of the alert in your code.
    CodeQL supports **data-flow analysis** and can detect issues that arise from the
    flow of data through your application. Click on **Show paths** to see how the
    data flows through your application (see *Figure 14.19*):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码下方区域，你可以看到代码中的警报详细信息。CodeQL 支持**数据流分析**，可以检测由数据流通过应用程序时产生的问题。点击**显示路径**以查看数据如何在应用程序中流动（参见*图
    14.19*）：
- en: '![Figure 14.19 – Details of the code scanning alert'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.19 – 代码扫描警报的详细信息'
- en: '](img/B17827_14_019.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_019.jpg)'
- en: Figure 14.19 – Details of the code scanning alert
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.19 – 代码扫描警报的详细信息
- en: 'You can follow the data through your entire application. In the example here,
    you can see 12 steps where the data is assigned and passed along until it is logged
    (see *Figure 14.20*):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以跟踪整个应用程序中的数据流。在此示例中，你可以看到 12 个步骤，其中数据被分配并传递，直到被记录（参见*图 14.20*）：
- en: '![Figure 14.20 – An example data flow'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.20 – 示例数据流'
- en: '](img/B17827_14_020.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_020.jpg)'
- en: Figure 14.20 – An example data flow
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.20 – 示例数据流
- en: This is the real power of CodeQL. It is not just a semantic analysis of your
    source code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 CodeQL 的真正力量。它不仅仅是对源代码的语义分析。
- en: CodeQL queries
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CodeQL 查询
- en: 'In the code scanning alert, you can find a reference to the query that detected
    the issue. Click on **View source** to see the query on GitHub (see *Figure 14.21*):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码扫描警报中，你可以找到触发问题的查询引用。点击**查看源代码**以在 GitHub 上查看该查询（参见*图 14.21*）：
- en: '![Figure 14.21 – The CodeQL queries are open source'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.21 – CodeQL 查询是开源的'
- en: '](img/B17827_14_021.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_021.jpg)'
- en: Figure 14.21 – The CodeQL queries are open source
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.21 – CodeQL 查询是开源的
- en: The queries are open source, and you'll find them under [https://github.com/github/codeql](https://github.com/github/codeql).
    Every language has a folder here, and inside the CodeQL folder, you'll find the
    queries under `ql/src`. The queries have the `.ql` file extension.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这些查询是开源的，你可以在[https://github.com/github/codeql](https://github.com/github/codeql)找到它们。每种语言都有一个文件夹，在
    CodeQL 文件夹中，你可以在 `ql/src` 下找到查询。查询的文件扩展名为 `.ql`。
- en: Timeline
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间线
- en: 'The code scanning alert also contains a concrete timeline with git blame information
    – when and in what commit was the issue first detected? When and where was it
    fixed? Did it reappear? This can help you to triage the alerts (see *Figure 14.22*):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 代码扫描警报还包含一个具体的时间线和 git blame 信息——问题首次被检测到的时间和提交？何时以及在哪里被修复？是否重新出现？这些信息有助于你进行警报筛查（参见*图
    14.22*）：
- en: '![Figure 14.22 – A timeline of a code scanning alert'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.22 – 代码扫描警报的时间线'
- en: '](img/B17827_14_022.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_022.jpg)'
- en: Figure 14.22 – A timeline of a code scanning alert
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.22 – 代码扫描警报的时间线
- en: Pull request integration
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拉取请求集成
- en: 'Code scanning integrates well with pull requests. Code scanning results are
    integrated into the pull request checks, and the details page shows you the overview
    of the results (see *Figure 14.23*):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 代码扫描与拉取请求集成良好。代码扫描结果集成到拉取请求检查中，详情页面显示结果概览（见*图 14.23*）：
- en: '![Figure 14.23 – Code scanning results in a pull request'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.23 – 拉取请求中的代码扫描结果'
- en: '](img/B17827_14_023.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_023.jpg)'
- en: Figure 14.23 – Code scanning results in a pull request
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.23 – 拉取请求中的代码扫描结果
- en: 'Code scanning also adds comments for the alerts in the code, and you can directly
    triage the findings there, changing the status to **False positive**, **Used in
    tests**, or **Won''t fix** (see *Figure 14.24*):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 代码扫描还会在代码中为警报添加评论，你可以直接在此对结果进行分级，修改状态为**误报**、**已用于测试**或**不修复**（见*图 14.24*）：
- en: '![Figure 14.24 – Code scanning comment in the source of a pull request'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.24 – 拉取请求源中的代码扫描评论'
- en: '](img/B17827_14_024.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_024.jpg)'
- en: Figure 14.24 – Code scanning comment in the source of a pull request
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.24 – 拉取请求源中的代码扫描评论
- en: 'You can define which alert severity should cause the pull request to fail for
    security issues and other findings under **Settings** | **Security & analysis**
    | **Code scanning** (see *Figure 14.25*):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**设置** | **安全性与分析** | **代码扫描**下定义哪些警报严重性会导致拉取请求因安全问题和其他发现而失败（见*图 14.25*）：
- en: '![Figure 14.25 – Configure which level of severity causes pull requests to
    fail'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.25 – 配置导致拉取请求失败的严重性级别'
- en: '](img/B17827_14_025.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_025.jpg)'
- en: Figure 14.25 – Configure which level of severity causes pull requests to fail
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.25 – 配置导致拉取请求失败的严重性级别
- en: The pull request integration helps you to keep your main branch clean and detect
    issues before merging and making the code analysis part of the review process.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求集成帮助你保持主分支的清洁，并在合并之前检测问题，使代码分析成为审核过程的一部分。
- en: Code scanning configuration
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码扫描配置
- en: 'There are many options to configure code scanning. The `init` CodeQL action
    in your workflow has a parameter called `queries`. You can use it to pick one
    of the default query suits:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多选项可以配置代码扫描。工作流中的`init` CodeQL 操作有一个名为`queries`的参数。你可以使用它选择默认查询集之一：
- en: '`security-extended`: More queries of lower severity than the default'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security-extended`：比默认查询更低严重性的更多查询'
- en: '`security-and-quality`: Queries from `security-extended`, plus maintainability
    and reliability queries'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`security-and-quality`：来自`security-extended`的查询，以及可维护性和可靠性查询'
- en: '[PRE119]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'You can also use the `queries` parameter to add custom queries. The parameter
    accepts local paths or references to other repositories, including a git reference
    (`branch`, `tag`, or `SHA`). Add a plus sign to add the queries on top of the
    default:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`queries`参数添加自定义查询。该参数接受本地路径或对其他仓库的引用，包括 Git 引用（`branch`、`tag` 或 `SHA`）。添加加号以将查询添加到默认查询之上：
- en: '[PRE124]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '`packs` parameter:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`packs` 参数：'
- en: '[PRE126]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Important Note
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**CodeQL packs** are still in beta at the time of writing. See [https://codeql.github.com/docs/codeql-cli/about-codeql-packs/](https://codeql.github.com/docs/codeql-cli/about-codeql-packs/)
    for more information about packs.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '**CodeQL 包**在写作时仍处于测试阶段。有关包的更多信息，请参见[https://codeql.github.com/docs/codeql-cli/about-codeql-packs/](https://codeql.github.com/docs/codeql-cli/about-codeql-packs/)。'
- en: 'You can also use a configuration file – for example, `./.github/codeql/codeql-config.yml`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用配置文件，例如`./.github/codeql/codeql-config.yml`：
- en: '[PRE128]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'If any of the preceding is located in another private repository, then you
    can add an access token that is used to load queries, packs, or the config file:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述内容位于另一个私有仓库中，则可以添加一个访问令牌，用于加载查询、包或配置文件：
- en: '[PRE131]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'In the config file, you normally disable the default queries and specify your
    own. You can also exclude specific paths. Here is an example – `codeql-config.yml`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中，你通常会禁用默认查询并指定自己的查询。你还可以排除特定路径。以下是一个示例 – `codeql-config.yml`：
- en: '[PRE132]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Your custom query suit (`custom-javascript.qls`) can then import other query
    suites (`javascript-security-extended.qls`) from *CodeQL packs* ( `codeql-javascript`)
    and exclude specific rules:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你的自定义查询集（`custom-javascript.qls`）可以导入其他查询集（`javascript-security-extended.qls`），并从*CodeQL
    包*（`codeql-javascript`）中排除特定规则：
- en: '[PRE139]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'You can also add individual queries (`- query : <path to query>`), multiple
    queries (`-queries: <path to folder>`), or packs (`- qlpack: <name of pack>`).'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '你还可以添加单个查询（`- query : <查询路径>`）、多个查询（`-queries: <文件夹路径>`）或查询包（`- qlpack: <包名称>`）。'
- en: CodeQL is very powerful, and you have many options to finetune the configuration.
    See [https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning)
    for more details.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: CodeQL 非常强大，你有很多选项可以精细调整配置。详情请参见 [https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning)。
- en: Writing your own CodeQL queries
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写你自己的 CodeQL 查询
- en: CodeQL comes with a lot of out-of-the-box queries – especially if you use the
    `security-and-quality` suite. But the full power of CodeQL comes if you start
    to write your own queries. Of course, this is not trivial. CodeQL is a complex
    query language, and if you look at some of the queries at [https://github.com/github/codeql](https://github.com/github/codeql),
    you'll see that they can get quite complex. But if you know your coding language,
    it should be quite easy to create some simple queries.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: CodeQL 附带了许多开箱即用的查询，尤其是如果你使用 `security-and-quality` 套件。但 CodeQL 的完整功能会在你开始编写自己的查询时展现。当然，这并不简单。CodeQL
    是一种复杂的查询语言，如果你查看 [https://github.com/github/codeql](https://github.com/github/codeql)
    上的一些查询，你会发现它们可能相当复杂。但如果你熟悉你的编程语言，编写一些简单的查询应该相当容易。
- en: To write CodeQL queries, you need **Visual Studio Code** (**VS Code**) and the
    **GitHub CodeQL extension** ([https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql)).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写 CodeQL 查询，你需要 **Visual Studio Code**（**VS Code**）和 **GitHub CodeQL 扩展**（[https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql)）。
- en: 'If you have both installed, clone the starter workspace:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了两者，克隆起始工作区：
- en: '[PRE145]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Note the `--recursive` parameter! If you forget it, you have to load the submodules
    manually:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `--recursive` 参数！如果你忘记它，你将不得不手动加载子模块：
- en: '[PRE146]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: In VSCode, select `vscode-codeql-starter.code-workspace` file from the starter
    workspace.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VSCode 中，从起始工作区选择 `vscode-codeql-starter.code-workspace` 文件。
- en: 'To create a database from your source code, you need the **CodeQL CLI**. On
    a Mac, you can install it using Homebrew:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要从你的源代码创建数据库，你需要 **CodeQL CLI**。在 Mac 上，你可以通过 Homebrew 安装它：
- en: '[PRE147]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'For other platforms, you can download the binaries here: [https://github.com/github/codeql-cli-binaries/releases/latest.](https://github.com/github/codeql-cli-binaries/releases/latest)'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他平台，你可以在此处下载二进制文件：[https://github.com/github/codeql-cli-binaries/releases/latest.](https://github.com/github/codeql-cli-binaries/releases/latest)
- en: Extract them to a folder and add them to the `$PATH` variable (`%PATH%` on windows).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们提取到一个文件夹中，并将其添加到 `$PATH` 变量中（在 Windows 上为 `%PATH%`）。
- en: 'Now, go into the folder where you want to store the database and run the following
    command:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入你想存储数据库的文件夹并运行以下命令：
- en: '[PRE148]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This will create a database for the language in your repository. Repeat the
    step for all the languages in your repository.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为你的仓库中的语言创建一个数据库。对仓库中的所有语言重复此步骤。
- en: 'Now, open the QL extension in VSCode and click **Databases** | **From a folder**.
    Select the database that you''ve created in the previous step. You can attach
    multiple databases and switch between them (see *Figure 14.26*):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 VSCode 中打开 QL 扩展并点击 **数据库** | **从文件夹中导入**。选择你在上一步骤中创建的数据库。你可以附加多个数据库并在它们之间切换（见
    *图 14.26*）：
- en: '![Figure 14.26 – Attaching databases to the VSCode CodeQL extension'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.26 – 将数据库附加到 VSCode CodeQL 扩展'
- en: '](img/B17827_14_026.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_026.jpg)'
- en: Figure 14.26 – Attaching databases to the VSCode CodeQL extension
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.26 – 将数据库附加到 VSCode CodeQL 扩展
- en: 'You can find sample queries for all supported languages in the starter workspace
    (`codeql-custom-queries-<language>/example.ql`). The queries have a comment header
    with metadata:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在起始工作区中找到所有支持语言的示例查询（`codeql-custom-queries-<language>/example.ql`）。查询文件中有一个带有元数据的注释头：
- en: '[PRE149]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Then, they import the necessary modules. They are normally named after the
    language (`javascript`, `csharp`, `java`, and so on), but they could also be something
    like `DataFlow::PathGraph`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它们导入必要的模块。这些模块通常以语言命名（`javascript`、`csharp`、`java` 等），但也可能是类似 `DataFlow::PathGraph`
    这样的名称：
- en: '[PRE155]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'The query itself has a variable declaration, an optional `where` block to limit
    the results, and the `select` statement:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 查询本身有一个变量声明，一个可选的 `where` 块来限制结果，以及 `select` 语句：
- en: '[PRE156]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Look at the CodeQL samples on GitHub to get an idea of how to start. The better
    you know a language, the easier it is to write the queries. The following query
    would search for empty catch blocks in C#:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 GitHub 上的 CodeQL 示例，了解如何开始。你对某种语言了解得越深，写查询就越容易。以下查询会搜索 C# 中的空 catch 块：
- en: '[PRE160]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'You have full IntelliSense support in VSCode (see *Figure 14.27*), which helps
    a lot when writing the queries:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VSCode 中，你拥有完整的 IntelliSense 支持（见 *图 14.27*），这在编写查询时非常有帮助：
- en: '![Figure 14.27 – IntelliSense in VSCode'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.27 – VSCode 中的 IntelliSense'
- en: '](img/B17827_14_027.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_027.jpg)'
- en: Figure 14.27 – IntelliSense in VSCode
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.27 – VSCode 中的 IntelliSense
- en: 'If you run a query from the context menu (**CodeQL: Run query**), it will display
    the results in the results window (see *Figure 14.28*):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你从上下文菜单中运行查询（**CodeQL: 运行查询**），它将在结果窗口中显示结果（见 *图 14.28*）：'
- en: '![Figure 14.28 – CodeQL query results'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 14.28 – CodeQL 查询结果'
- en: '](img/B17827_14_028.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_14_028.jpg)'
- en: Figure 14.28 – CodeQL query results
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.28 – CodeQL 查询结果
- en: Every element in the `select` clause has a column. You can click on code elements
    and VSCode will open the corresponding source file at the exact location.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 子句中的每个元素都有一个列。你可以点击代码元素，VSCode 会在准确的位置打开相应的源文件。'
- en: You could easily fill an entire book just about CodeQL. This is just a very
    brief introduction, but I see a lot of value in being able to extend code scanning
    with your own rules.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 你完全可以写一本关于 CodeQL 的书。这只是一个非常简短的介绍，但我认为能够使用你自己的规则扩展代码扫描是非常有价值的。
- en: See the CodeQL documentation and language reference for further information.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 CodeQL 文档和语言参考，获取更多信息。
- en: Summary
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you''ve learned how to secure your code and control your dependencies:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学会了如何保护你的代码并控制你的依赖关系：
- en: You've learned about SCA, and you know how to use dependency graphs, Dependabot
    alerts, and Dependabot security updates to manage your software dependencies.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经了解了 SCA，并且知道如何使用依赖关系图、Dependabot 警报和 Dependabot 安全更新来管理你的软件依赖。
- en: You've learned about secret scanning, which prevents secrets from being leaked
    in your source code.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经了解了秘密扫描，它可以防止秘密信息在源代码中泄露。
- en: You've learned about SAST, and you know how to use code scanning with CodeQL
    or other tools that support SARIF to find problems already during development.
    You can now write your own queries to enforce quality and coding standards.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你已经学会了 SAST，并且知道如何使用 CodeQL 或其他支持 SARIF 的工具进行代码扫描，在开发过程中就发现问题。现在你可以编写自己的查询，以执行质量和编码标准。
- en: In the next chapter, we'll have a look into how we can secure our release pipeline
    and our deployments.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将看看如何保护我们的发布管道和部署。
- en: Further reading
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'These are the references from this chapter that you can also use to get more
    information on the topics:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章中的一些参考资料，你也可以用来进一步了解这些主题：
- en: '*How one programmer broke the internet by deleting a tiny piece of code*, *Keith
    Collins* (2016): [https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/](https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/)'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如何一个程序员通过删除一小段代码打破了互联网*，*Keith Collins*（2016）：[https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/](https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/)'
- en: '*Kik, Left-Pad, and NPM – Oh My!*, *Tyler Eon* (2016): [https://medium.com/@kolorahl/kik-left-pad-and-npm-oh-my-e6f216a22766](https://medium.com/@kolorahl/kik-left-pad-and-npm-oh-my-e6f216a22766)'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Kik, Left-Pad, 和 NPM – 哦，天哪！*，*Tyler Eon*（2016）：[https://medium.com/@kolorahl/kik-left-pad-and-npm-oh-my-e6f216a22766](https://medium.com/@kolorahl/kik-left-pad-and-npm-oh-my-e6f216a22766)'
- en: '*Secure at every step: What is software supply chain security and why does
    it matter?*, *Maya Kaczorowski* (2020): [https://github.blog/2020-09-02-secure-your-software-supply-chain-and-protect-against-supply-chain-threats-github-blog/](https://github.blog/2020-09-02-secure-your-software-supply-chain-and-protect-against-supply-chain-threats-github-blog/'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每一步都要安全：什么是软件供应链安全，为什么它很重要？*，*Maya Kaczorowski*（2020）：[https://github.blog/2020-09-02-secure-your-software-supply-chain-and-protect-against-supply-chain-threats-github-blog/](https://github.blog/2020-09-02-secure-your-software-supply-chain-and-protect-against-supply-chain-threats-github-blog/)'
- en: )
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*About the dependency graph*: [https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于依赖关系图*：[https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph)'
- en: )
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*About Dependabot version updates*: [https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-Dependabot-version-updates](https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-Dependabot-version-updates'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于 Dependabot 版本更新*：[https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-Dependabot-version-updates](https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-Dependabot-version-updates)'
- en: )
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*About secret scanning*: [https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning](https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning
    )'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于密钥扫描*：[https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning](https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning)'
- en: '*About GitHub Advanced Security*: [https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security](https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于 GitHub 高级安全性*：[https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security](https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security)'
- en: )
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*About code scanning*: [https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*关于代码扫描*：[https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning)'
- en: '*CodeQL code scanning: new severity levels for security alerts*, GitHub Blog
    (2021): [https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/](https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CodeQL 代码扫描：安全警报的新严重性级别*，GitHub 博客（2021）：[https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/](https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/)'
- en: )
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '*Common Vulnerability Scoring System (CVSS)*: [https://www.first.org/cvss/v3.1/specification-document](https://www.first.org/cvss/v3.1/specification-document)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通用漏洞评分系统（CVSS）*：[https://www.first.org/cvss/v3.1/specification-document](https://www.first.org/cvss/v3.1/specification-document)'
- en: '*CodeQL documentation*: https://codeql.github.com/docs/'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CodeQL 文档*：https://codeql.github.com/docs/'
- en: '*QL language reference*: [https://codeql.github.com/docs/ql-language-reference](https://codeql.github.com/docs/ql-language-reference)'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*QL 语言参考*：[https://codeql.github.com/docs/ql-language-reference](https://codeql.github.com/docs/ql-language-reference)'
