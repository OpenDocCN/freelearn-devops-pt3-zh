- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Securing and Testing Your CI/CD Pipeline
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护和测试您的 CI/CD 管道
- en: In the previous chapters, we looked at **Continuous Integration** (**CI**) and
    **Continuous Deployment/Delivery** (**CD**) with GitOps as the central concept.
    Both concepts and the tooling surrounding them help us deliver better software
    faster. However, one of the most critical aspects of technology is security and
    quality assurance. Though security was not considered in DevOps’ initial days,
    with the advent of **DevSecOps**, modern DevOps now places a great emphasis on
    it. In this chapter, we’ll try to understand the concepts surrounding container
    applications’ security and testing and how to apply them within CI and CD.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们探讨了**持续集成** (**CI**) 和**持续部署/交付** (**CD**) ，并将 GitOps 作为核心概念。这两个概念及其相关工具帮助我们更快速地交付更好的软件。然而，技术的一个关键方面是安全性和质量保障。虽然在
    DevOps 的早期并没有考虑到安全性，但随着 **DevSecOps** 的出现，现代 DevOps 现在非常重视安全性。在本章中，我们将尝试理解容器应用程序安全性和测试的相关概念，以及如何在
    CI 和 CD 中应用这些概念。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Securing and testing CI/CD pipelines
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性和测试 CI/CD 管道
- en: Revisiting the Blog Application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾博客应用程序
- en: Container vulnerability scanning
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器漏洞扫描
- en: Managing secrets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理机密
- en: Binary authorization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制授权
- en: Release gating with pull requests and deploying our application in production
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用拉取请求进行发布门控，并将我们的应用部署到生产环境
- en: Security and testing best practices for modern DevOps pipelines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代 DevOps 管道的安全性和测试最佳实践
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we will spin up a cloud-based Kubernetes cluster, **Google
    Kubernetes Engine** (**GKE**), for the exercises. Currently, **Google Cloud Platform**
    (**GCP**) provides a free $300 trial for 90 days, so you can go ahead and sign
    up for one at [https://console.cloud.google.com/](https://console.cloud.google.com/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将启动一个基于云的 Kubernetes 集群，**Google Kubernetes Engine** (**GKE**)，用于练习。目前，**Google
    Cloud Platform** (**GCP**) 提供一个免费的 $300 试用，持续 90 天，因此你可以前往[https://console.cloud.google.com/](https://console.cloud.google.com/)注册。
- en: 'You will also need to clone the following GitHub repository for some of the
    exercises:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要克隆以下 GitHub 仓库，以便进行一些练习：
- en: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)。'
- en: 'You can use the Cloud Shell offering available on GCP to follow this chapter.
    Go to Cloud Shell and start a new session. Run the following commands to clone
    the repository into your home directory to access the required resources:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 GCP 上提供的 Cloud Shell 服务来跟随本章内容。进入 Cloud Shell 并启动一个新会话。运行以下命令将仓库克隆到你的主目录，以便访问所需资源：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also need to set the project ID and enable a few GCP APIs that we will use
    in this chapter. To do so, run the following commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置项目 ID，并启用一些我们将在本章中使用的 GCP API。为此，请运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, in the next section, let’s look at how to secure and test CI/CD pipelines.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何保护和测试 CI/CD 管道。
- en: Securing and testing CI/CD pipelines
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性和测试 CI/CD 管道
- en: With continuous cyber threats and the ongoing war between cybersecurity experts
    and cybercriminals, security has always been the top priority for most organizations,
    and it also forms a significant part of a mature organization’s investment.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着持续的网络威胁和网络安全专家与网络犯罪分子之间的持续斗争，安全性一直是大多数组织的首要任务，并且它也构成了成熟组织投资的一个重要部分。
- en: However, security comes with its costs. Most organizations have cybersecurity
    teams that audit their code regularly and give feedback. However, that process
    is generally slow and happens when most of the code is already developed and difficult
    to modify.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，安全性伴随着成本。大多数组织都有网络安全团队定期审核他们的代码并提供反馈。然而，这一过程通常较慢，并且发生在大部分代码已经开发完成且难以修改时。
- en: Similarly, while most organizations significantly emphasize automated testing,
    many still heavily depend on manual testing. Manual testing is not only labor-intensive
    but also lacks repeatability. DevOps places great importance on automating tests
    to ensure that they can be repeated with every release, enabling the detection
    of existing issues and thorough testing of new features. Additionally, automation
    is essential for efficiently conducting regression testing on bug fixes, as manual
    testing in such cases is inefficient.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，虽然大多数组织都强调自动化测试，但许多仍然严重依赖手动测试。手动测试不仅劳动密集，而且缺乏可重复性。DevOps 非常重视自动化测试，以确保每次发布时都能重复执行，能够发现现有问题并彻底测试新功能。此外，自动化对于高效地进行回归测试至关重要，因为在这种情况下，手动测试效率低下。
- en: Therefore, embedding security and testing at the early stages of development
    is an essential goal for modern DevOps. Embedding security with DevOps has led
    to the concept of DevSecOps, where developers, cybersecurity experts, and operations
    teams work together to create better and more secure software faster.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在开发初期嵌入安全性和测试是现代 DevOps 的一个关键目标。将安全性与 DevOps 相结合催生了 DevSecOps 的概念，在这个概念中，开发人员、网络安全专家和运维团队协同工作，更快地创建更好、更安全的软件。
- en: Securing and testing your software using CI/CD pipelines offers various significant
    business advantages. Firstly, it ensures security by protecting sensitive data,
    preventing vulnerabilities, and ensuring compliance. Secondly, it improves quality
    and reliability through early issue detection, consistency, and higher product
    quality. This leads to cost reduction by reducing rework, speeding up time to
    market, and optimizing resource usage. Additionally, it mitigates risks by increasing
    resilience and enabling stress testing. Moreover, it ensures business continuity
    through disaster recovery and efficient rollback procedures. Furthermore, it provides
    a competitive advantage by fostering faster innovation and market responsiveness.
    Finally, it enhances reputation and customer trust by building confidence in your
    products and services and safeguarding your brand’s reputation. In essence, securing
    and testing CI/CD pipelines is both a technical necessity and a strategic business
    imperative that enhances security, quality, and reliability while reducing costs
    and risks, ultimately leading to improved customer satisfaction, business continuity,
    and a competitive edge in the market.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CI/CD 流水线进行软件安全和测试可以带来许多显著的商业优势。首先，它通过保护敏感数据、防止漏洞并确保合规性来确保安全性。其次，它通过早期发现问题、一致性和更高的产品质量来提升质量和可靠性。这将通过减少返工、加速上市时间和优化资源使用来降低成本。此外，它通过增强韧性和进行压力测试来降低风险。更重要的是，它通过灾难恢复和高效的回滚程序来确保业务连续性。此外，它通过促进更快的创新和市场响应来提供竞争优势。最后，通过增强客户对产品和服务的信任以及保护品牌声誉，它提高了声誉和客户信任。总之，保护和测试
    CI/CD 流水线不仅是技术上的必要性，也是战略性的商业迫切需求，它提升了安全性、质量和可靠性，同时降低了成本和风险，最终提高了客户满意度、业务连续性和市场中的竞争力。
- en: There are many ways of embedding security within the software supply chain.
    Some of these might include static code analysis, security testing, and applying
    organization-specific security policies within the process, but the idea of security
    is not to slow down development. Instead of human input, we can always use tools
    that can significantly improve the security posture of the software we develop.
    Similarly, testing need not be manual and slow and, instead, should use automation
    to plug in seamlessly with the CI/CD process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件供应链中嵌入安全性的方式有很多种。某些方法可能包括静态代码分析、安全性测试，以及在过程中应用组织特定的安全策略，但安全的目的是不让开发速度变慢。我们可以用工具来代替人工输入，这些工具能够显著改善我们开发软件的安全性。类似地，测试不必是手动和缓慢的，相反，应该使用自动化来与
    CI/CD 流水线无缝对接。
- en: '**CI/CD pipelines** are one of the essential features of modern DevOps, and
    they orchestrate all processes and combine all tools to deliver better software
    faster, but how would you secure them? You may want to ask the following questions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**CI/CD 流水线**是现代 DevOps 的核心特性之一，它协调所有流程并结合所有工具以更快交付更好的软件，但你如何确保它们的安全性呢？你可能想问以下问题：'
- en: How do I scan a container image for vulnerabilities?
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何扫描容器镜像以查找漏洞？
- en: How do I store and manage sensitive information and secrets securely?
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何安全地存储和管理敏感信息和机密？
- en: How do I ensure that my application is tested before deployment to production?
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保在部署到生产环境之前测试我的应用程序？
- en: How do I ensure that only tested and approved container images are deployed
    in production?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确保只有经过测试和批准的容器映像才能部署到生产环境？
- en: 'Throughout this chapter, we will try to answer these using best practices and
    tooling. For reference, look at the following workflow diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试使用最佳实践和工具来回答这些问题。作为参考，请查看以下工作流程图：
- en: '![Figure 13.1 – Secure CI/CD workflow](img/B19877_13_1.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1 – 安全的 CI/CD 工作流程](img/B19877_13_1.jpg)'
- en: Figure 13.1 – Secure CI/CD workflow
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 – 安全的 CI/CD 工作流程
- en: 'As depicted in the previous figure, we need to modify the CI pipeline to include
    an additional step for vulnerability scanning. We also require two CD pipelines,
    one for the Dev environment and another for Prod. To enhance reusability, we’ll
    restructure our GitHub Actions workflow. We’ll divide the workflows into parent
    and child workflows. Let’s begin by examining the CD workflow for the Dev environment
    to get an overview:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们需要修改 CI 管道以包括额外的漏洞扫描步骤。我们还需要两个 CD 管道，一个用于开发环境，另一个用于生产环境。为增强可重用性，我们将重新构造
    GitHub Actions 工作流程。我们将工作流划分为父工作流和子工作流。让我们从检查用于开发环境的 CD 工作流开始，以获取概述：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The workflow begins with a `name`, followed by a declaration of `on push branches
    dev`. This configuration ensures that the workflow triggers with every push to
    the `dev` branch. We define multiple jobs in sequence, each depending on the previous
    one using the `needs` attribute. Each job invokes a child workflow specified by
    the `uses` attribute, and it provides GitHub secrets to these child workflows
    by setting `inherit` for the `secrets` attribute.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流程从 `name` 开始，然后声明 `on push branches dev`。此配置确保工作流在每次推送到 `dev` 分支时触发。我们按顺序定义多个作业，每个作业都使用
    `needs` 属性依赖于前一个作业。每个作业通过设置 `uses` 属性调用子工作流，并通过为 `secrets` 属性设置 `inherit` 来向这些子工作流提供
    GitHub 秘密。
- en: 'The workflow accomplishes the following tasks:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该工作流程完成以下任务：
- en: Sets up the Dev Kubernetes cluster, configures Argo CD and supporting tools
    to establish the environment, and deploys the sample Blog App.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置开发 Kubernetes 集群，配置 Argo CD 和支持工具以建立环境，并部署示例博客应用程序。
- en: Executes integration tests on the deployed Blog App.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署的博客应用上执行集成测试。
- en: If the tests pass, it utilizes binary authorization (more details to follow)
    to attest images, ensuring that only tested artifacts are allowed for deployment
    to production.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试通过，它会利用二进制授权（详细信息将在后续提供）来证明图像，确保只有经过测试的构件允许部署到生产环境。
- en: Initiates a pull request for deployment to the Prod environment.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为部署到生产环境启动拉取请求。
- en: 'In a similar manner, we have the following Prod CD Workflow file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们有以下生产 CD 工作流文件：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This workflow is similar to the Dev workflow but does not include the `binary-auth`
    and `raise-pull-request` steps, as they are unnecessary at this stage. To understand
    it better, let’s begin by examining the Dev workflow. The initial step of the
    Dev workflow involves creating the environment and deploying the application.
    However, before we proceed, let’s revisit the Blog App in the next section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此工作流类似于开发工作流，但不包括 `binary-auth` 和 `raise-pull-request` 步骤，因为在这个阶段它们是不必要的。为了更好地理解它，让我们从检查开发工作流开始。开发工作流的初始步骤涉及创建环境并部署应用程序。但在继续之前，让我们在下一节重新审视博客应用程序。
- en: Revisiting the Blog Application
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视博客应用程序
- en: 'As we already discussed the Blog App in the last chapter, let’s look at the
    services and their interactions again in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章节中已经讨论的博客应用程序，让我们再次查看服务及其交互如下图所示：
- en: '![Figure 13.2 – The Blog App services and interactions](img/B19877_13_2.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 博客应用服务和交互](img/B19877_13_2.jpg)'
- en: Figure 13.2 – The Blog App services and interactions
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 博客应用服务和交互
- en: We’ve already created CI and CD pipelines for building, testing, and pushing
    our Blog Application microservices containers using GitHub Actions and deploying
    them using Argo CD in a GKE cluster.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 GitHub Actions 创建了 CI 和 CD 管道，用于构建、测试和推送我们的博客应用程序微服务容器，并在 GKE 集群中使用 Argo
    CD 部署它们。
- en: 'If you remember, we created the following resources for the application to
    run seamlessly:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们为应用程序创建了以下资源，以使其无缝运行：
- en: '**MongoDB** – We deployed an auth-enabled MongoDB database with root credentials.
    The credentials were injected via environment variables sourced from a Kubernetes
    **Secret** resource. To persist our database data, we created a **PersistentVolume**
    mounted to the container, which we provisioned dynamically using a **PersistentVolumeClaim**.
    As the container is stateful, we used a **StatefulSet** to manage it and, therefore,
    a headless Service to expose the database.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB** – 我们部署了一个启用了身份验证的MongoDB数据库，并设置了root凭证。凭证通过来自Kubernetes **Secret**资源的环境变量注入。为了持久化数据库数据，我们创建了一个挂载到容器的**PersistentVolume**，并使用**PersistentVolumeClaim**动态提供它。由于容器是有状态的，我们使用了**StatefulSet**来管理它，因此需要一个无头的Service来暴露数据库。'
- en: '**Posts, reviews, ratings, and users** – The posts, reviews, ratings, and users
    microservices interacted with MongoDB through the root credentials injected via
    environment variables sourced from the same **Secret** resource as MongoDB. We
    deployed them using their respective **Deployment** resources and exposed all
    of them via individual **ClusterIP** Services.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帖子、评论、评分和用户** – 帖子、评论、评分和用户微服务通过来自同一**Secret**资源的环境变量注入的root凭证与MongoDB进行交互。我们使用各自的**Deployment**资源部署了这些服务，并通过各自的**ClusterIP**服务暴露它们。'
- en: '**Frontend** – The frontend microservice does not need to interact with MongoDB,
    so there was no interaction with the **Secret** resource. We deployed this service
    as well using a **Deployment** resource. As we wanted to expose the service on
    the internet, we created a **LoadBalancer** Service for it.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Frontend** – 前端微服务不需要与MongoDB交互，因此不与**Secret**资源发生交互。我们同样使用**Deployment**资源部署了该服务。由于我们希望将该服务暴露到互联网，我们为它创建了一个**LoadBalancer**
    Service。'
- en: 'We can summarize them in the following diagram:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下图表来总结它们：
- en: '![Figure 13.3 – The Blog App – Kubernetes resources and interactions](img/B19877_13_3.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – 博客应用程序 – Kubernetes资源与交互](img/B19877_13_3.jpg)'
- en: Figure 13.3 – The Blog App – Kubernetes resources and interactions
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – 博客应用程序 – Kubernetes资源与交互
- en: In subsequent sections, we will cover all aspects of implementing this workflow,
    starting with vulnerability scanning.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的章节中，我们将涵盖实施此工作流程的所有方面，从漏洞扫描开始。
- en: Container vulnerability scanning
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器漏洞扫描
- en: Perfect software is costly to write and maintain, and every time someone makes
    changes to running software, the chances of breaking something are high. Apart
    from other bugs, changes also add a lot of software vulnerabilities. You cannot
    avoid these as software developers. Cybersecurity experts and cybercriminals are
    at constant war with each other, evolving with time. Every day, a new set of vulnerabilities
    are found and reported.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 完美的软件开发和维护成本高昂，每当有人对正在运行的软件进行更改时，破坏某些功能的可能性就很高。除了其他错误之外，更改还会引入大量软件漏洞。作为软件开发人员，您无法避免这些问题。网络安全专家和网络犯罪分子之间的斗争是持续进行的，并随着时间不断发展。每天都会发现并报告一组新的漏洞。
- en: In containers, vulnerabilities can exist on multiple fronts and may be completely
    unrelated to what you’re responsible for. Well, developers write code, and excellent
    ones do it securely. Still, you never know whether a base image may contain vulnerabilities
    your developers might completely overlook. In modern DevOps, vulnerabilities are
    expected, and the idea is to mitigate them as much as possible. We should reduce
    vulnerabilities, but doing so manually is time-consuming, leading to toil.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中，漏洞可能在多个方面存在，且可能与您负责的部分完全无关。好吧，开发人员编写代码，优秀的开发人员会确保代码的安全性。但您永远不知道基础镜像中是否存在开发人员可能完全忽视的漏洞。在现代的DevOps中，漏洞是不可避免的，关键是尽可能地减少它们。我们应该减少漏洞，但手动处理漏洞是耗时的，容易导致繁琐的工作。
- en: Several tools are available on the market that provide container vulnerability
    scanning. Some of them are open source tools such as **Anchore**, **Clair**, **Dagda**,
    **OpenSCAP**, Sysdig’s **Falco**, or **Software-as-a-Service** (**SaaS**) services
    available with **Google Container Registry** (**GCR**), **Amazon Elastic Container
    Registry** (**ECR**), and **Azure Defender**. For this chapter, we’ll discuss
    **Anchore Grype**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有多个工具可以提供容器漏洞扫描服务。其中一些是开源工具，如**Anchore**、**Clair**、**Dagda**、**OpenSCAP**、Sysdig的**Falco**，或者是可通过**Google
    Container Registry**（**GCR**）、**Amazon Elastic Container Registry**（**ECR**）和**Azure
    Defender**提供的**SaaS**服务。对于本章内容，我们将讨论**Anchore Grype**。
- en: Anchore Grype ([https://github.com/anchore/grype](https://github.com/anchore/grype))
    is a container vulnerability scanner that scans your images for known vulnerabilities
    and reports their severity. Based on that, you can take appropriate actions to
    prevent vulnerabilities by including a different base image or modifying the layers
    to remove vulnerable components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Anchore Grype ([https://github.com/anchore/grype](https://github.com/anchore/grype))
    是一个容器漏洞扫描器，它会扫描你的镜像中的已知漏洞并报告其严重性。根据这些信息，你可以采取适当的措施，通过更换基础镜像或修改层来删除易受攻击的组件，从而防止漏洞的发生。
- en: Anchore Grype is a simple **Command-Line Interface** (**CLI**)-based tool that
    you can install as a binary and run anywhere—within your local system or your
    CI/CD pipelines. You can also configure it to fail your pipeline if the vulnerability
    level increases above a particular threshold, thereby embedding security within
    your automation—all this happening without troubling your development or security
    team.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Anchore Grype 是一个简单的**命令行界面**（**CLI**）工具，可以作为二进制文件安装并在任何地方运行——无论是在本地系统还是 CI/CD
    流水线中。你还可以配置它，如果漏洞级别超过特定阈值，自动使流水线失败，从而将安全性嵌入到你的自动化中——所有这些都不会给开发或安全团队带来麻烦。
- en: Now, let’s go ahead and see Anchore Grype in action.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看看 Anchore Grype 的实际操作情况。
- en: Installing Anchore Grype
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Anchore Grype
- en: As we want to implement vulnerability scanning within our CI pipelines, let’s
    modify the `mdo-posts` repository we created in [*Chapter 11*](B19877_11.xhtml#_idTextAnchor1412).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在 CI 流水线中实施漏洞扫描，让我们修改我们在[*第 11 章*](B19877_11.xhtml#_idTextAnchor1412)中创建的
    `mdo-posts` 仓库。
- en: 'Let’s clone the repository first using the following command and `cd` into
    the `workflows` directory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用以下命令克隆仓库，并 `cd` 进入 `workflows` 目录：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Anchore Grype offers an installation script within its GitHub repository that
    you can download and run, and it should set it up for you. We’ll modify the `build.yaml`
    file to include the following step before the `Login to Docker Hub` step so that
    we can install Grype within our CI workflow:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Anchore Grype 在其 GitHub 仓库中提供了一个安装脚本，你可以下载并运行，它应该会为你设置好。我们将修改 `build.yaml` 文件，在
    `登录到 Docker Hub` 步骤之前添加以下步骤，以便在 CI 工作流中安装 Grype：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Next, we need to use Grype to scan our images for vulnerabilities.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用 Grype 扫描我们的镜像以检查漏洞。
- en: Scanning images
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描镜像
- en: 'To run container vulnerability scanning, we can use the following command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器漏洞扫描，我们可以使用以下命令：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will report a list of vulnerabilities with severities—`Negligible`, `Low`,
    `Medium`, `High`, `Critical`, or `Unknown`—within the image. We can also set a
    threshold within Grype to fail when any vulnerabilities are equal to or worse
    than it. For example, if we don’t want to allow any `Critical` vulnerabilities
    in the container, we can use the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将报告镜像中漏洞的列表，并按严重性划分—`Negligible`（轻微）、`Low`（低）、`Medium`（中等）、`High`（高）、`Critical`（严重）或`Unknown`（未知）。我们还可以在
    Grype 中设置阈值，当任何漏洞的级别等于或高于该阈值时使其失败。例如，如果我们不希望容器中出现任何`Critical`（严重）漏洞，我们可以使用以下命令：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To do so, we will add the following step within the `build.yaml` file after
    the `Build the Docker` `image` step:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将在 `build.yaml` 文件中，在 `构建 Docker` `镜像` 步骤后添加以下步骤：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As we’ve made all the changes, let’s push the modified CI pipeline using the
    following commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经做出了所有更改，让我们使用以下命令推送修改后的 CI 流水线：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As soon as we push the image, we will see the following in the GitHub Actions
    tab:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推送镜像，我们将在 GitHub Actions 标签页中看到以下内容：
- en: '![Figure 13.4 – Vulnerability scan failure](img/B19877_13_4.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.4 – 漏洞扫描失败](img/B19877_13_4.jpg)'
- en: Figure 13.4 – Vulnerability scan failure
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 – 漏洞扫描失败
- en: As we can see, Grype has reported several vulnerabilities with one being `Critical`.
    It has also failed the CI pipeline. That is automated vulnerability scanning in
    action. This will discover vulnerabilities and only allow builds to end up in
    your container registry if they meet minimum security standards.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Grype 已报告了多个漏洞，其中一个为 `Critical`（严重）。它还导致了 CI 流水线失败。这就是自动化漏洞扫描的实际应用。它会发现漏洞，并且只有当构建满足最低安全标准时，才会将其发布到你的容器注册表中。
- en: 'We need to fix the issue here, so let’s look at a more recent image and see
    whether it can fix the problem. Therefore, instead of using `python:3.7-alpine`,
    we will use `python:alpine3.18`. Let’s do that and push our code to GitHub using
    the following commands:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修复这里的问题，因此让我们查看一个更新的镜像，看看它是否能解决这个问题。因此，除了使用`python:3.7-alpine`，我们将使用`python:alpine3.18`。让我们这样做，并使用以下命令将代码推送到
    GitHub：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s revisit GitHub Actions and see what we get in the `build` output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新查看 GitHub Actions，看看在`build`输出中得到什么：
- en: '![Figure 13.5 – Vulnerability scan success](img/B19877_13_5.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 漏洞扫描成功](img/B19877_13_5.jpg)'
- en: Figure 13.5 – Vulnerability scan success
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 漏洞扫描成功
- en: The vulnerability scan did not stop our CI build this time, as no `Critical`
    vulnerabilities were found.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这次漏洞扫描没有阻止我们的 CI 构建，因为没有发现`Critical`漏洞。
- en: Tip
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Continually update the base image with time, as newer ones contain fewer vulnerabilities
    and fix older ones.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，不断更新基础镜像，因为更新后的镜像包含更少的漏洞，并修复了旧版中的漏洞。
- en: Now that we’ve secured the image for vulnerabilities, our CI pipeline is complete.
    You can replicate this process for other microservices as needed. Let’s proceed
    to discuss CD pipelines.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确保镜像没有漏洞，我们的 CI 管道已经完成。您可以根据需要为其他微服务复制此过程。让我们继续讨论 CD 管道。
- en: If you remember, in the last chapter, following the GitOps model, we stored
    the manifests of all resources on Git. However, due to security concerns with
    Kubernetes Secrets, we used **SealedSecrets** to manage them securely.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得，在上一章中，我们按照 GitOps 模式将所有资源的清单存储在 Git 上。然而，由于 Kubernetes Secrets 存在安全隐患，我们使用了**SealedSecrets**来安全地管理它们。
- en: 'However, this may not be the ideal solution for all teams due to the following
    inherent issues:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于以下固有问题，这可能并不是所有团队的理想解决方案：
- en: SealedSecrets are reliant on the controller that encrypts them. If we lose this
    controller, we also lose the ability to recreate the secret, essentially losing
    the Secret forever.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SealedSecrets 依赖于加密它们的控制器。如果我们丢失了这个控制器，我们也失去了重新创建机密的能力，从而实质上丧失了该机密。
- en: Access to the Secret is limited to logging in to the cluster and using `kubectl`,
    which doesn’t provide non-admins with the ability to manage secrets. While this
    approach might suit some teams, it may not suit others.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问机密仅限于登录集群并使用`kubectl`，这种方式不会为非管理员提供管理机密的能力。虽然这种方法可能适合某些团队，但可能不适合其他团队。
- en: Therefore, we will explore managing secrets using a Secrets management tool
    to establish a standardized method for centrally managing secrets with more granular
    control over access. Let’s delve into this topic in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将探索使用密钥管理工具来管理密钥，以建立一种标准化的方法，集中管理密钥，并对访问权限进行更精细的控制。让我们在下一节深入探讨这个话题。
- en: Managing secrets
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理机密
- en: Software always requires access to sensitive information such as user data,
    credentials, **Open Authorization** (**OAuth**) tokens, passwords, and other information
    known as secrets. Developing and managing software while keeping all these aspects
    secure has always been a concern. The CI/CD pipelines might deal with them as
    they build and deliver working software by combining code and other dependencies
    from various sources that may include sensitive information. Keeping these bits
    secure is of utmost importance; therefore, the need arises to use modern DevOps
    tools and techniques to embed security within the CI/CD pipelines themselves.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 软件始终需要访问敏感信息，如用户数据、凭证、**开放授权**（**OAuth**）令牌、密码以及其他被称为机密的信息。在开发和管理软件时，确保这些方面的安全性一直是一个关注点。CI/CD
    管道可能会处理这些信息，因为它们通过结合代码和来自多个源的其他依赖项来构建并交付工作软件，其中可能包括敏感信息。保持这些信息的安全性至关重要；因此，需要使用现代的
    DevOps 工具和技术，将安全性嵌入到 CI/CD 管道中。
- en: 'Most application code requires access to sensitive information. These are called
    **secrets** in the DevOps world. A secret is any data that helps someone prove
    their identity, authenticate, and authorize privileged accounts, applications,
    and services. Some of the potential candidates that constitute secrets are listed
    here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序代码都需要访问敏感信息。这些信息在 DevOps 领域被称为**机密**。机密是任何有助于某人证明其身份、进行身份验证以及授权特权账户、应用程序和服务的数据。以下是一些可能构成机密的候选项：
- en: Passwords
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: API tokens, GitHub tokens, and any other application key
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 令牌、GitHub 令牌以及其他任何应用程序密钥
- en: '**Secure Shell** (**SSH**) keys'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全外壳**（**SSH**）密钥'
- en: '**Transport Layer Security** (**TLS**), **Secure Sockets Layer** (**SSL**),
    and **Pretty Good Privacy** (**PGP**) private keys'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层安全性**（**TLS**）、**安全套接字层**（**SSL**）和**相当好的隐私**（**PGP**）私钥'
- en: One-time passwords
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次性密码
- en: A good example could be a container requiring access to an API key to authenticate
    with a third-party API or a username and password to authenticate with a backend
    database. Developers need to understand where and how to store secrets so that
    they are not exposed inadvertently to people who are not supposed to view them.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的例子是，容器需要访问 API 密钥以进行第三方 API 身份验证，或者需要用户名和密码来进行后端数据库的身份验证。开发人员需要理解在哪里以及如何存储机密，以确保它们不会无意中暴露给不应查看它们的人。
- en: When we run a CI/CD pipeline, it becomes imperative to understand how we place
    those secrets as, in CI/CD pipelines, we build everything from the source. “*Do
    not store secrets with code*” is a prominent piece of advice we’ve all heard.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 CI/CD 管道时，必须理解如何处理这些机密，因为在 CI/CD 管道中，我们从源代码开始构建一切。“*不要将机密与代码一起存储*”是我们都听过的重要建议。
- en: Tip
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Never store hardcoded secrets within CI/CD pipelines or store secrets in a source
    code repository such as Git.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将硬编码的机密存储在 CI/CD 管道中，或将机密存储在源代码仓库中，如 Git。
- en: How can we access secrets without including them in our code to run a fully
    automated GitOps-based CI/CD pipeline? Well, that’s something we need to figure
    out.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在不将机密包含在代码中的情况下访问它们，从而运行完全自动化的 GitOps 基于的 CI/CD 管道呢？好吧，这就是我们需要弄清楚的事情。
- en: Tip
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When using containers, the thing to avoid is baking the secrets within an image.
    While this is a prominent piece of advice, many developers do this inadvertently,
    leading to many security holes. It is very insecure, and you should avoid doing
    it at all costs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器时，应该避免将机密嵌入到镜像中。虽然这是一个广为人知的建议，但许多开发人员无意中这么做，导致许多安全漏洞。这是非常不安全的，你应该避免这样做。
- en: You can overcome this problem by using some form of **secrets management solution**.
    A secrets management solution or a **key management solution** helps store and
    manage your secrets and secure them with encryption at rest and in transit. There
    are secrets management tools within cloud providers, such as **Secret Manager**
    in GCP and **Amazon Web Services** (**AWS**), or you can use a third-party tool,
    such as **HashiCorp Vault**, if you want to go cloud agnostic. All these solutions
    provide APIs to create and query secrets at runtime, and they secure the API via
    HTTPS to allow encryption in transit. That way, you don’t need to store your secrets
    with code or bake it within an image.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用某种形式的**秘密管理解决方案**来克服这个问题。秘密管理解决方案或**密钥管理解决方案**帮助存储和管理机密，并通过静态和传输加密保护它们。云服务提供商内部有秘密管理工具，如
    GCP 中的**秘密管理器**和**亚马逊 Web 服务**（**AWS**），或者如果你希望使用与云无关的工具，可以使用第三方工具，如**HashiCorp
    Vault**。所有这些解决方案都提供 API 用于在运行时创建和查询机密，并通过 HTTPS 安全 API 以允许加密传输。这样，你就不需要将机密与代码一起存储或嵌入镜像中。
- en: In this discussion, we’ll use the **Secret Manager** solution offered by GCP
    to store secrets, and we will access them while running the CI/CD pipeline. Secret
    Manager is Google Cloud’s secrets management system, which helps you store and
    manage secrets centrally. It is incredibly secure and uses **Hardware Security
    Modules** (**HSMs**) to harden your secrets further.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本讨论中，我们将使用 GCP 提供的**秘密管理器**解决方案来存储机密，并在运行 CI/CD 管道时访问它们。秘密管理器是 Google Cloud
    的秘密管理系统，它帮助你集中存储和管理机密。它非常安全，使用**硬件安全模块**（**HSMs**）进一步加固你的机密。
- en: In this chapter, we will look at improving the CI/CD pipeline of our Blog Application,
    which we discussed in the last chapter, and will use the same sample application.
    Therefore, let’s go ahead and create the `mongodb-creds` Secret in Google Cloud
    Secret Manager.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将着眼于改进上章讨论的博客应用程序的 CI/CD 管道，并将使用相同的示例应用程序。因此，接下来我们将创建 Google Cloud Secret
    Manager 中的 `mongodb-creds` 机密。
- en: Creating a Secret in Google Cloud Secret Manager
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Google Cloud Secret Manager 中创建一个机密
- en: 'Let’s create a secret called `external-secrets`, where we will pass the MongoDB
    credentials in JSON format. To do so, run the following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `external-secrets` 的机密，在其中我们将以 JSON 格式传递 MongoDB 凭据。为此，请运行以下命令：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding command, we echo a JSON containing `MONGO_INITDB_ROOT_USERNAME`
    and `PASSWORD` directly into the `gcloud secrets create` command. We have specified
    a particular location to avoid replicating it in other regions as a cost-saving
    measure. However, it’s highly recommended to replicate secrets to prevent potential
    loss in case of a zonal outage. The JSON is stored as a new version of our secret.
    Secret Manager utilizes versioning for secrets, so any new value assigned to the
    secret (`external-secrets`) is versioned and stored within Secret Manager. You
    can reference a specific version either by its version number or by using the
    `latest` keyword to access the most recent version.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们将包含 `MONGO_INITDB_ROOT_USERNAME` 和 `PASSWORD` 的 JSON 直接传递给 `gcloud
    secrets create` 命令。我们指定了一个特定的位置，以避免在其他区域重复它，从而节省成本。然而，强烈建议复制密钥，以防在区域性故障时发生潜在的丢失。该
    JSON 被存储为密钥的新版本。Secret Manager 使用版本控制来管理密钥，因此分配给密钥（`external-secrets`）的任何新值都会被版本化并存储在
    Secret Manager 中。你可以通过版本号或使用 `latest` 关键字来引用特定版本，以访问最新的版本。
- en: As seen in the output, we’ve created the first version of our secret (`version
    1`). Typically, this is done during development and should remain outside the
    CI/CD process. Instead of storing the Secret resource manifest in your source
    code repository, you can keep it in Secret Manager.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，我们已经创建了密钥的第一个版本（`版本 1`）。通常，这是在开发阶段完成的，应该保持在 CI/CD 流程之外。你可以将 Secret
    资源清单保存在 Secret Manager 中，而不是存储在源代码库中。
- en: Now that we’ve created the secret, we must access it within our application.
    To achieve this, we require a tool to access the secret stored in Secret Manager
    from the Kubernetes cluster. For this purpose, we will use **External** **Secrets
    Operator**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了密钥，我们必须在应用程序中访问它。为此，我们需要一个工具来访问 Kubernetes 集群中的 Secret Manager 中存储的密钥。为此，我们将使用**External**
    **Secrets Operator**。
- en: Accessing external secrets using External Secrets Operator
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 External Secrets Operator 访问外部密钥
- en: External Secrets Operator ([https://external-secrets.io/latest/](https://external-secrets.io/latest/))
    is a Kubernetes operator used in Kubernetes clusters to manage external secrets
    securely. It is designed to automate the retrieval and management of secrets stored
    in external secret stores such as AWS Secret Manager, GCP Secret Manager, Hashicorp
    Vault, and so on, and inject them into Kubernetes pods as Kubernetes Secrets.
    Operators are a way to extend Kubernetes functionality and automate tasks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: External Secrets Operator ([https://external-secrets.io/latest/](https://external-secrets.io/latest/))
    是一个 Kubernetes 操作器，用于在 Kubernetes 集群中安全地管理外部密钥。它旨在自动检索和管理存储在外部密钥存储系统中的密钥，如 AWS
    Secret Manager、GCP Secret Manager、Hashicorp Vault 等，并将它们作为 Kubernetes Secrets
    注入到 Kubernetes pod 中。操作器是一种扩展 Kubernetes 功能并自动化任务的方式。
- en: How it works
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'External Secrets Operator serves as a bridge between the Kubernetes cluster
    and external secret management systems. We define an `ExternalSecret` custom resource
    within the Kubernetes cluster, which the operator monitors. When an `ExternalSecret`
    resource is created or updated, the operator interacts with the external secret
    store specified in the `ClusterSecretStore` CRD to retrieve the secret data. It
    then creates or updates the corresponding Kubernetes Secrets. This process is
    illustrated in the following diagram:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: External Secrets Operator 作为 Kubernetes 集群与外部密钥管理系统之间的桥梁。我们在 Kubernetes 集群中定义一个
    `ExternalSecret` 自定义资源，操作器会监视它。当创建或更新 `ExternalSecret` 资源时，操作器与 `ClusterSecretStore`
    CRD 中指定的外部密钥存储交互，以检索密钥数据。然后，它创建或更新相应的 Kubernetes Secrets。该过程在下面的图示中展示：
- en: '![Figure 13.6 – External Secret Operator](img/B19877_13_6.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.6 – 外部密钥操作器](img/B19877_13_6.jpg)'
- en: Figure 13.6 – External Secret Operator
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 – 外部密钥操作器
- en: 'Now, this process has a lot of benefits, some of which are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个过程有很多好处，其中一些如下：
- en: '**Enhanced Security**: Secrets remain in a dedicated, secure secret store'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强安全性**：密钥保存在专用的安全密钥存储中'
- en: '**Automation**: Automates the retrieval and rotation of secrets'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：自动化密钥的检索和轮换'
- en: '**Simplified Deployment**: Eases the management of secrets within Kubernetes
    applications'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化部署**：简化了 Kubernetes 应用程序中密钥的管理'
- en: '**Compatibility**: Works with various external secret stores, making it versatile'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性**：支持多种外部密钥存储，使其具有多功能性'
- en: Now, let’s go ahead and install External Secrets Operator on our Kubernetes
    cluster.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续在 Kubernetes 集群中安装 External Secrets Operator。
- en: Installing External Secrets Operator
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 External Secrets Operator
- en: 'External Secrets Operator is available as a `manifests/argocd/external-secrets.yaml`
    manifest file:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 外部密钥操作符可通过 `manifests/argocd/external-secrets.yaml` 清单文件获取：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The application manifest creates an `external-secrets` application on the `argocd`
    namespace within the `default` project. It downloads the `0.9.4` revision from
    the `external-secrets` Helm chart repository and deploys the chart on the Kubernetes
    cluster on the `external-secrets` namespace.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 应用清单在 `default` 项目中的 `argocd` 命名空间下创建了一个 `external-secrets` 应用。它从 `external-secrets`
    Helm 图表仓库下载 `0.9.4` 版本，并将图表部署到 Kubernetes 集群中的 `external-secrets` 命名空间。
- en: 'To install this application, we need to apply this manifest using Terraform.
    Therefore, to do so, we make the following entry in the `app.tf` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装此应用，我们需要使用 Terraform 应用此清单。因此，我们在 `app.tf` 文件中做出如下输入：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To deploy this, we must check these files into source control. Let’s clone the
    `mdo-environments` repository that we created in the last chapters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了部署这一应用，我们必须将这些文件提交到源代码管理。让我们克隆上一章节中创建的 `mdo-environments` 仓库。
- en: If you haven’t followed the last chapters, you can do the following to set a
    baseline. Feel free to skip the next section if you’ve already set up your environment
    in [*Chapter 12*](B19877_12.xhtml#_idTextAnchor1554)*, Continuous Deployment/Delivery
    with* *Argo CD*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有按照上一章节的步骤操作，可以通过以下方法设置一个基础环境。如果你已经在[*第12章*](B19877_12.xhtml#_idTextAnchor1554)中完成了环境设置，可以跳过下一节，继续进行*持续部署/交付与*
    **Argo CD**。
- en: Setting up the baseline
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基础环境
- en: 'To ensure continuity with the last chapters, let’s start by creating a service
    account for Terraform to interact with our GCP project using the following commands:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保与上一章节的连续性，让我们首先创建一个服务帐户，以便 Terraform 可以与我们的 GCP 项目交互，使用以下命令：
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You will see a file called `key-file` created within your working directory.
    Now, create a new repository called `mdo-environments` with a `README.md` file
    on GitHub, rename the `main` branch to `prod`, and create a new branch called
    `dev` using GitHub. Navigate to `https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions/new`
    and create a secret named `GCP_CREDENTIALS`. For the value, print the `key-file`
    file, copy its contents, and paste it into the **values** field of the GitHub
    secret.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在工作目录中看到一个名为 `key-file` 的文件。现在，在 GitHub 上创建一个名为 `mdo-environments` 的新仓库，并添加一个
    `README.md` 文件，重命名 `main` 分支为 `prod`，并使用 GitHub 创建一个名为 `dev` 的新分支。然后访问 `https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions/new`，创建一个名为
    `GCP_CREDENTIALS` 的密钥。在值字段中，打印出 `key-file` 文件的内容，复制并粘贴到 GitHub 密钥的 **values**
    字段中。
- en: Next, create another secret, `PROJECT_ID`, and specify your GCP project ID within
    the **values** field.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个密钥 `PROJECT_ID`，并在 **values** 字段中指定你的 GCP 项目 ID。
- en: 'Next, we need to create a GCS bucket for Terraform to use as a remote backend.
    To do this, run the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为 Terraform 创建一个 GCS 存储桶，作为远程后端使用。为此，运行以下命令：
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, now that all the prerequisites are met, we can clone our repository and
    copy the baseline code. Run the following commands to do this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有前提条件都已满足，我们可以克隆我们的仓库并复制基础代码。运行以下命令来完成此操作：
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As we’re now on the baseline, let’s proceed further to install external secrets
    with Terraform.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经设置了基础环境，接下来让我们继续使用 Terraform 安装外部密钥。
- en: Installing external secrets with Terraform
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Terraform 安装外部密钥
- en: 'Let’s configure our local repository to install the external secrets manifest.
    To do so, copy the application manifest and `app.tf` file using the following
    commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置本地仓库来安装外部密钥清单。为此，使用以下命令复制应用清单和 `app.tf` 文件：
- en: '[PRE17]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now that we’re all set up and ready, let’s go ahead and commit and push our
    code using the following commands:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 既然一切准备就绪，让我们使用以下命令提交并推送我们的代码：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As soon as we push the code, we’ll see that the GitHub Actions workflow has
    been triggered. To access the workflow, go to `https://github.com/<your_github_user>/mdo-environments/actions`.
    Soon, the workflow will apply the configuration, create the Kubernetes cluster,
    and deploy Argo CD, the Sealed Secrets controller, and External Secrets Operator.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推送代码，就会看到 GitHub Actions 工作流被触发。要访问该工作流，请访问 `https://github.com/<your_github_user>/mdo-environments/actions`。不久后，工作流会应用配置，创建
    Kubernetes 集群，并部署 Argo CD、Sealed Secrets 控制器和 External Secrets Operator。
- en: Once the workflow is successful, we can do the following to access the Argo
    Web UI.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工作流成功执行，我们可以按照以下步骤访问 Argo Web UI。
- en: 'We must first authenticate with the GKE cluster. To do so, run the following
    command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要对 GKE 集群进行身份验证。为此，运行以下命令：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To utilize the Argo CD Web UI, you will require the external IP address of
    the `argo-server` service. To get that, run the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Argo CD Web UI，您需要`argo-server`服务的外部IP地址。要获取该地址，请运行以下命令：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: So, now we know that Argo CD is accessible on `https://34.122.51.25/`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们知道可以通过`https://34.122.51.25/`访问Argo CD。
- en: 'Next, we will run the following commands to reset the admin password:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行以下命令来重置管理员密码：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, allow two minutes for the new credentials to be generated. After that,
    execute the following command to retrieve the password:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，允许两分钟来生成新的凭证。然后，执行以下命令来获取密码：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we now have the credentials, log in, and you will see the following page:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了凭证，登录后将看到以下页面：
- en: '![Figure 13.7 – Argo CD Web UI – home page](img/B19877_13_7.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图13.7 – Argo CD Web UI – 主页](img/B19877_13_7.jpg)'
- en: Figure 13.7 – Argo CD Web UI – home page
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.7 – Argo CD Web UI – 主页
- en: As we can see, there are three applications – `SealedSecret` manifest that we
    created in the last chapter, as it was generated by a different Sealed Secrets
    controller.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有三个应用程序——`SealedSecret`清单，它是我们在上一章中创建的，因为它是由不同的Sealed Secrets控制器生成的。
- en: 'We don’t need the Sealed Secrets operator; we will use Google Cloud Secret
    Manager instead. So, let’s remove it from our cluster using the following commands:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要Sealed Secrets操作员，我们将改用Google Cloud Secret Manager。所以，让我们使用以下命令从集群中移除它：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’ve removed the Sealed Secrets operator, and the Argo CD Web UI should reflect
    that shortly. However, the Blog Application will remain degraded as the `mongodb-creds`
    Secret is still missing. In the next section, we will use External Secrets Operator
    to generate the `mongodb-creds` Secret.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已移除Sealed Secrets操作员，Argo CD Web UI应该很快反映出这一变化。然而，博客应用程序将保持降级状态，因为`mongodb-creds`
    Secret仍然缺失。在接下来的部分中，我们将使用External Secrets Operator生成`mongodb-creds` Secret。
- en: Generating the MongoDB Kubernetes Secret using External Secrets Operator
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用External Secrets Operator生成MongoDB Kubernetes Secret
- en: 'To generate the `mongodb-creds` secret, we would need to create the following
    resources:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成`mongodb-creds` Secret，我们需要创建以下资源：
- en: A `Secret` resource – This is a standard Kubernetes Secret resource containing
    the service account credentials for Kubernetes to connect with GCP Secret Manager.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Secret`资源——这是一个标准的Kubernetes Secret资源，包含服务账户凭证，以便Kubernetes与GCP Secret Manager连接。
- en: A `ClusterSecretStore` resource – This resource contains configuration for connecting
    with the secret store (GCP Secret Manager in this case) and uses the `Secret`
    resource for the service account credentials.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ClusterSecretStore`资源——该资源包含与密钥存储（在此情况下为GCP Secret Manager）连接的配置，并使用`Secret`资源提供服务账户凭证。
- en: An `ExternalSecret` resource – This resource contains configuration to generate
    the required Kubernetes Secret (`mongodb-creds`) out of the extracted Secret from
    the secret store.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ExternalSecret`资源——该资源包含配置，用于从密钥存储中提取的Secret生成所需的Kubernetes Secret（`mongodb-creds`）。
- en: 'So, let’s go ahead and define the `Secret` resource first:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，首先让我们定义`Secret`资源：
- en: 'To create the `Secret` resource, we first need to create a GCP service account
    to interact with Secret Manager using the following commands:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建`Secret`资源，我们首先需要创建一个GCP服务账户，以便与Secret Manager交互，使用以下命令：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we’re following the principle of least privilege, we will add the following
    role-binding to provide access only to the `external-secrets` secret, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们遵循最小权限原则，我们将添加以下角色绑定，仅提供对`external-secrets` Secret的访问，如下所示：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, let’s generate the service account key file using the following command:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令生成服务账户密钥文件：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, copy the contents of the `key.json` file into a new GitHub Actions secret
    called `GCP_SM_CREDENTIALS`. We will use GitHub Actions to set this value during
    runtime dynamically; therefore, the following secret manifest will contain a placeholder:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`key.json`文件的内容复制到一个新的GitHub Actions密钥中，命名为`GCP_SM_CREDENTIALS`。我们将在运行时使用GitHub
    Actions动态设置此值；因此，以下密钥清单将包含一个占位符：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s look at the `ClusterSecretStore` resource next:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下`ClusterSecretStore`资源：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The manifest defines the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 清单定义了以下内容：
- en: A `ClusterSecretStore` resource called `gcp-backend`
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`gcp-backend`的`ClusterSecretStore`资源
- en: A provider configuration of the `gcpsm` type using auth information in the `gcpsm-secret`
    secret we defined before
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`gcpsm`类型的提供程序配置，利用我们之前定义的`gcpsm-secret`密钥中的身份验证信息
- en: 'Now, let’s look at the `ExternalSecret` resource manifest:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下`ExternalSecret`资源的清单：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The manifest defines an `ExternalSecret` resource with the following specs:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 清单定义了一个具有以下规格的 `ExternalSecret` 资源：
- en: It is named `mongodb-creds` in the `blog-app` namespace.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在 `blog-app` 命名空间中名为 `mongodb-creds`。
- en: It refers to the `gcp-backend` `ClusterSecretStore` that we defined.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它引用了我们定义的 `gcp-backend` `ClusterSecretStore`。
- en: It maps `MONGO_INITDB_ROOT_USERNAME` from the `external-secrets` Secret Manager
    secret to the `MONGO_INITDB_ROOT_USERNAME` key of the `mongodb-creds` Kubernetes
    secret. It does the same for `MONGO_INITDB_ROOT_PASSWORD`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 `MONGO_INITDB_ROOT_USERNAME` 从 `external-secrets` Secret Manager 密钥映射到 `mongodb-creds`
    Kubernetes 密钥的 `MONGO_INITDB_ROOT_USERNAME` 键。它对 `MONGO_INITDB_ROOT_PASSWORD`
    执行相同操作。
- en: 'Now, let’s deploy these resources by using the following commands:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令部署这些资源：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should trigger a GitHub Actions workflow again, and soon, we should see
    `ClusterSecretStore` and `ExternalSecret` created. To check that, run the following
    commands:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该再次触发 GitHub Actions 流程，很快我们应该会看到创建了 `ClusterSecretStore` 和 `ExternalSecret`。要检查这一点，请运行以下命令：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The same should be reflected in the `blog-app` application on Argo CD, and
    the application should come up clean, as shown in the following screenshot:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该反映在 Argo CD 中的 `blog-app` 应用中，且应用应正常启动，如以下截图所示：
- en: '![Figure 13.8 – blog-app showing as Healthy](img/B19877_13_8.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.8 – 显示为健康状态的博客应用](img/B19877_13_8.jpg)'
- en: Figure 13.8 – blog-app showing as Healthy
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.8 – 显示为健康状态的博客应用
- en: 'You can then access the application by getting the frontend service external
    IP using the following command:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过以下命令获取前端服务的外部 IP，从而访问应用：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can access the application by visiting `http://<EXTERNAL_IP>` from a browser:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过浏览器访问 `http://<EXTERNAL_IP>` 来访问应用：
- en: '![Figure 13.9 – Blog App home page](img/B19877_13_9.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.9 – 博客应用主页](img/B19877_13_9.jpg)'
- en: Figure 13.9 – Blog App home page
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.9 – 博客应用主页
- en: 'And as we can see, we can access the Blog App successfully. That is proper
    secret management, as we did not store the secret in the source code repository
    (Git). We did not view or log the secret while applying it, meaning there is no
    trace of this secret anywhere in the logs, and only the application or people
    who have access to the namespace where this application is running can access
    it. Now, let’s look at another crucial aspect: testing your application.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们可以成功访问博客应用。这是正确的密钥管理，因为我们没有将密钥存储在源代码仓库（Git）中。我们在应用密钥时没有查看或记录密钥，这意味着日志中没有任何密钥的痕迹，只有具有访问该应用运行命名空间权限的应用或人员才能访问它。现在，让我们看看另一个关键方面：测试你的应用。
- en: Testing your application within the CD pipeline
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CD 流程中测试你的应用
- en: 'Until now, we’ve deployed our application on a Kubernetes cluster and manually
    verified that it is running. We have two options moving forward: either proceed
    with manual testing or create automated tests, also known as a **test suite**.
    While manual testing is the traditional approach, DevOps heavily emphasizes automating
    tests to integrate them into your CD pipeline. This way, we can eliminate many
    repetitive tasks, often called **toil**.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们已在 Kubernetes 集群中部署了应用并手动验证它正在运行。接下来我们有两个选项：继续进行手动测试或创建自动化测试，也就是**测试套件**。虽然手动测试是传统方法，但
    DevOps 强烈强调自动化测试，并将其集成到 CD 流程中。这样，我们可以消除许多重复性任务，通常被称为**苦力活**。
- en: We’ve developed a Python-based integration test suite for our application, covering
    various scenarios. One significant advantage of this test suite is that it treats
    the application as a black box. It remains unaware of how the application is implemented,
    focusing solely on simulating end user interactions. This approach provides valuable
    insights into the application’s functional aspects.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为应用开发了一个基于 Python 的集成测试套件，涵盖了各种场景。这个测试套件的一个重要优点是，它将应用视为一个黑箱。它不了解应用是如何实现的，而专注于模拟最终用户交互。这种方法提供了关于应用功能方面的宝贵见解。
- en: Furthermore, since this is an integration test, it assesses the entire application
    as a cohesive unit, in contrast to the unit tests we ran in our CI pipeline, where
    we tested each microservice in isolation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这是集成测试，它评估的是整个应用作为一个整体单元，而与我们在 CI 流程中进行的单元测试不同，后者是在隔离的情况下测试每个微服务。
- en: Without further delay, let’s integrate the integration test into our CD pipeline.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们将集成测试集成到我们的 CD 管道中。
- en: CD workflow changes
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CD 流程更改
- en: 'Till now, we have the following within our CD workflow:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在 CD 流程中有以下内容：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Both the Dev and Prod CD workflows contain the following jobs:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和生产 CD 流程都包含以下任务：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we can see, they are both calling the `create-cluster.yml` workflow, which
    creates our environment and deploys our application. We need to run integration
    tests both within the Dev and Prod environments; therefore, we need to change
    both workflows to include the `Run Integration Tests` step as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它们都调用了 `create-cluster.yml` 工作流，该工作流创建我们的环境并部署我们的应用程序。我们需要在 Dev 和 Prod
    环境中运行集成测试，因此我们需要将两个工作流更改为包括**运行集成测试**步骤，如下所示：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we can see, the step calls the `run-tests.yml` workflow. That is the workflow
    that will be doing the integration tests. Let’s look at the workflow to understand
    it better:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，该步骤调用了 `run-tests.yml` 工作流。那就是执行集成测试的工作流。让我们看看工作流，以便更好地理解：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The workflow performs the following tasks:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 该工作流执行以下任务：
- en: It is triggered exclusively through a `workflow` call.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它仅通过 `workflow` 调用触发。
- en: It has the `./tests` working directory.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它具有 `./tests` 工作目录。
- en: It checks out the committed code.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它检出已提交的代码。
- en: It installs the `gcloud` CLI and authenticates with Google Cloud using the `GCP_CREDENTIALS`
    service account credentials.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它安装 `gcloud` CLI 并使用 `GCP_CREDENTIALS` 服务账户凭据进行 Google Cloud 身份验证。
- en: It connects `kubectl` to the Kubernetes cluster to retrieve the application
    URL.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将 `kubectl` 连接到 Kubernetes 集群，以检索应用程序的 URL。
- en: Using the application URL, it executes the integration test.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用应用程序的 URL，它执行集成测试。
- en: 'Now, let’s proceed to update the workflow and add tests using the following
    commands:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续更新工作流，并使用以下命令添加测试：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This should trigger the Dev CD GitHub Actions workflow again. You should see
    something like the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该再次触发 Dev CD GitHub Actions 工作流。您应该看到如下内容：
- en: '![Figure 13.10 – Added tests workflow run](img/B19877_13_10.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.10 – 添加测试工作流运行](img/B19877_13_10.jpg)'
- en: Figure 13.10 – Added tests workflow run
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10 – 添加测试工作流运行
- en: 'As we can see, there are two steps in our workflow, and both are now successful.
    To explore what was tested, you can click on the **Run Integration Tests** step,
    and it should show you the following output:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，工作流中有两个步骤，且两者现在都已成功。要查看测试的内容，您可以点击**运行集成测试**步骤，它应该显示以下输出：
- en: '![Figure 13.11 – The Run Integration Tests workflow step](img/B19877_13_11.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11 – 运行集成测试工作流步骤](img/B19877_13_11.jpg)'
- en: Figure 13.11 – The Run Integration Tests workflow step
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 – 运行集成测试工作流步骤
- en: As we can see, the **Run Integration Tests** step reports that all tests have
    passed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，**运行集成测试**步骤报告所有测试已通过。
- en: While images are being built, deployed, and tested using your CI/CD toolchain,
    there is nothing in between to prevent someone from deploying an image in your
    Kubernetes cluster. You might be scanning all your images for vulnerabilities
    and mitigating them, but somewhere, someone might bypass all controls and deploy
    containers directly to your cluster. So, how can you prevent such a situation?
    The answer to that question is through binary authorization. Let’s explore this
    in the next section.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当镜像在 CI/CD 工具链中构建、部署和测试时，工作流之间没有任何东西可以防止某人将镜像直接部署到 Kubernetes 集群中。您可能正在扫描所有镜像以寻找漏洞并加以修复，但某处可能有人绕过所有控制，直接将容器部署到集群中。那么，如何防止这种情况发生呢？答案就是通过二进制授权。我们将在下一节中探讨这一点。
- en: Binary authorization
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 二进制授权
- en: '**Binary authorization** is a deploy-time security mechanism that ensures that
    only trusted binary files are deployed within your environments. In the context
    of containers and Kubernetes, binary authorization uses signature validation and
    ensures that only container images signed by a trusted authority are deployed
    within your Kubernetes cluster.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**二进制授权**是一种部署时的安全机制，确保仅信任的二进制文件被部署到您的环境中。在容器和 Kubernetes 的背景下，二进制授权使用签名验证，确保只有由受信任的授权机构签名的容器镜像才会在
    Kubernetes 集群中部署。'
- en: Using binary authorization gives you tighter control over what is deployed in
    your cluster. It ensures that only tested containers and those approved and verified
    by a particular authority (such as security tooling or personnel) are present
    in your cluster.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二进制授权可以更严格地控制在集群中部署的内容。它确保只有经过测试并且由特定授权机构（如安全工具或人员）批准和验证的容器才会出现在集群中。
- en: Binary authorization works by enforcing rules within your cluster via an admission
    controller. This means you can create rulesets only to allow images signed by
    an attestation authority to be deployed in your cluster. Your **quality assurance**
    (**QA**) team can be a good attestor in a practical scenario. You can also embed
    the attestation within your CI/CD pipelines. The attestation means your images
    have been tested and scanned for vulnerabilities and have passed a minimum standard
    to be ready to be deployed to the cluster.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制授权通过在集群内强制执行规则来工作，这意味着你可以创建规则集，仅允许由认证机构签名的镜像在集群中部署。在实际场景中，你的 **质量保证**（**QA**）团队可以成为一个很好的审核员。你也可以将认证嵌入到
    CI/CD 流水线中。认证意味着你的镜像已经过测试并扫描了漏洞，并且已经通过了最低标准，准备部署到集群中。
- en: 'GCP provides binary authorization embedded within GKE, based on the open source
    project **Kritis** ([https://github.com/grafeas/kritis](https://github.com/grafeas/kritis)).
    It uses a **public key infrastructure** (**PKI**) to attest and verify images—so
    your images are signed by an attestor authority using the private key, and Kubernetes
    verifies the images by using the public key. The following diagram explains this
    beautifully:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: GCP 提供了嵌入在 GKE 中的二进制授权，基于开源项目 **Kritis** ([https://github.com/grafeas/kritis](https://github.com/grafeas/kritis))。它使用
    **公钥基础设施**（**PKI**）来认证和验证镜像——因此你的镜像是由审核员使用私钥签名的，Kubernetes 使用公钥来验证镜像。以下图表生动地解释了这一过程：
- en: '![Figure 13.12 – Binary authorization process](img/B19877_13_12.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.12 – 二进制授权过程](img/B19877_13_12.jpg)'
- en: Figure 13.12 – Binary authorization process
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.12 – 二进制授权过程
- en: In the hands-on exercise, we will set up binary authorization and a PKI using
    Google Cloud KMS. Next, we will create a QA attestor and an attestation policy
    for all binary auth-enabled GKE clusters, ensuring that only attested images can
    be deployed. Since our application is now tested, the next step is to attest the
    tested images. So, let’s proceed to set up binary authorization within our Dev
    CD workflow in the next section.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际操作中，我们将使用 Google Cloud KMS 设置二进制授权和 PKI。接下来，我们将为所有启用二进制授权的 GKE 集群创建一个 QA
    审核员和认证策略，确保只有经过认证的镜像可以被部署。由于我们的应用程序现在已经通过测试，下一步是对经过测试的镜像进行认证。因此，让我们继续在下一部分中设置
    Dev CD 工作流中的二进制授权。
- en: Setting up binary authorization
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置二进制授权
- en: 'As we’re using GitOps right from the beginning, we will use Terraform to set
    up binary authorization for us. We’ll start by setting up some GitHub Actions
    secrets. Go to `https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions`
    and create the following secrets:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们从一开始就使用 GitOps，因此我们将使用 Terraform 来为我们设置二进制授权。我们将从设置一些 GitHub Actions 密码开始。请访问
    `https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions`
    并创建以下密码：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We’ll then create a `binaryauth.tf` file with the following resources.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个 `binaryauth.tf` 文件，其中包含以下资源。
- en: 'We’ll begin by creating a Google KMS key ring. Since binary authorization utilizes
    PKI for creating and verifying attestations, this key ring will enable our attestor
    to digitally sign attestations for images. Please note the `count` attribute defined
    in the following code. This ensures that it is created exclusively in the `dev`
    environment, where we intend to use the attestor for attesting images after testing
    our app:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个 Google KMS 密钥环。由于二进制授权利用 PKI 来创建和验证认证，因此这个密钥环将使我们的审核员能够为镜像的认证进行数字签名。请注意以下代码中定义的
    `count` 属性。它确保仅在我们打算使用审核员来认证镜像的 `dev` 环境中创建：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will then use a Google-provided `binary-authorization` Terraform module
    to create our `quality-assurance` attestor. That attestor uses the Google KMS
    key ring we created before:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将使用 Google 提供的 `binary-authorization` Terraform 模块来创建我们的 `quality-assurance`
    审核员。该审核员使用我们之前创建的 Google KMS 密钥环：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, we will create a binary authorization policy that specifies the cluster’s
    behavior when deploying a container. In this scenario, our objective is to deploy
    only attested images. However, we will make a few exceptions, allowing Google-provided
    system images, Argo CD, and External Secrets Operator images. We will set the
    `global_policy_evaluation_mode` attribute to `ENABLE` to avoid enforcing the policy
    on system images managed by Google.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个二进制授权策略，指定在部署容器时集群的行为。在此场景中，我们的目标是仅部署经过认证的镜像。然而，我们将做一些例外，允许使用 Google
    提供的系统镜像、Argo CD 和 External Secrets Operator 镜像。我们将把 `global_policy_evaluation_mode`
    属性设置为 `ENABLE`，以避免强制执行 Google 管理的系统镜像上的策略。
- en: The `admission_whitelist_patterns` section defines container image patterns
    permitted to be deployed without attestations. This includes patterns for Google-managed
    system images, the Argo CD registry, the External Secrets registry, and the Redis
    container used by Argo CD.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`admission_whitelist_patterns`部分定义了允许在没有验证的情况下部署的容器镜像模式。这包括适用于 Google 管理的系统镜像、Argo
    CD 注册表、外部 Secrets 注册表以及 Argo CD 使用的 Redis 容器的模式。'
- en: 'The `defaultAdmissionRule` section mandates attestation using the attestor
    we created. Therefore, any other images would require attestation to run on the
    cluster:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultAdmissionRule`部分要求使用我们创建的验证器进行验证。因此，任何其他镜像都需要验证才能在集群中运行：'
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To enforce the binary authorization policy within a cluster, we must also enable
    binary authorization. To do so, we add the following block within the `cluster.tf`
    file:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在集群中强制执行二进制授权策略，我们还必须启用二进制授权。为此，我们需要在`cluster.tf`文件中添加以下内容：
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This dynamic block is created exclusively when the branch name is `prod`. The
    reason for this approach is our intention to deploy our code to the Dev environment
    without image attestation, conduct testing, and then attest the images if the
    tests succeed. Therefore, only the Prod cluster should disallow unattested images.
    To achieve this, we will include the following steps in the Dev CD workflow:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动态块仅在分支名称为`prod`时创建。采用这种方法的原因是我们打算将代码部署到开发环境，而无需验证镜像，进行测试，成功后再验证镜像。因此，只有生产集群应该禁止未验证的镜像。为此，我们将在开发
    CD 工作流中包含以下步骤：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As you can see, this calls the `attest-images.yml` workflow. Let’s look at
    that now:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这会调用`attest-images.yml`工作流。让我们现在来看一下：
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The YAML file performs several tasks, including the installation of `gcloud`
    and authentication with GCP. It also installs the `gcloud beta` CLI and, importantly,
    attests images.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 该 YAML 文件执行多个任务，包括安装`gcloud`并与 GCP 进行身份验证。它还安装了`gcloud beta` CLI，最重要的是，它验证了镜像。
- en: To attest images, it searches the `blog-app.yaml` manifest for all images. For
    each image, it checks whether the image is in the `sha256` digest format. If yes,
    it proceeds to attest the image.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证镜像，它会在`blog-app.yaml`清单中搜索所有镜像。对于每个镜像，它检查该镜像是否采用`sha256`摘要格式。如果是，它将继续验证该镜像。
- en: It’s worth noting that the workflow verifies that images are specified using
    a `sha256` digest format rather than a tag in the image definition. This choice
    is crucial when working with binary authorization. Why? Because binary authorization
    requires deploying images with their `sha256` digest instead of a tag. This precaution
    is essential because, with tags, anyone can associate a different image with the
    same tag as the attested image and push it to the container registry. In contrast,
    a digest is a hash generated from a Docker image. Therefore, as long as the image’s
    content remains unchanged, the digest remains the same. This prevents any attempts
    to bypass binary authorization controls.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，工作流验证镜像时，使用的是`sha256`摘要格式，而不是镜像定义中的标签。这个选择在使用二进制授权时至关重要。为什么？因为二进制授权要求使用`sha256`摘要而不是标签来部署镜像。这个预防措施非常必要，因为使用标签时，任何人都可以将一个不同的镜像与已验证镜像的标签关联，并将其推送到容器注册表。而摘要是由
    Docker 镜像生成的哈希值。因此，只要镜像内容保持不变，摘要就保持相同。这可以防止任何绕过二进制授权控制的尝试。
- en: 'The format for specifying images in this manner is as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式指定镜像的格式如下：
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Therefore, before pushing the changes to the remote repository, let’s replace
    the image tags with `sha256` digests. Use the following commands to do so:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在将更改推送到远程仓库之前，我们需要将镜像标签替换为`sha256`摘要。使用以下命令进行操作：
- en: '[PRE46]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To verify whether the changes were successful, run the following command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证更改是否成功，请运行以下命令：
- en: '[PRE47]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we can see, the images have been updated. Now, let’s proceed to push the
    changes to the remote repository using the following commands:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，镜像已经更新。现在，让我们使用以下命令将更改推送到远程仓库：
- en: '[PRE48]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, let’s review the Dev CD workflow on GitHub Actions, where we should observe
    the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下 GitHub Actions 上的开发 CD 工作流，我们应该观察以下内容：
- en: '![Figure 13.13 – Dev CD workflow – Attest Images](img/B19877_13_13.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.13 – 开发 CD 工作流 – 验证镜像](img/B19877_13_13.jpg)'
- en: Figure 13.13 – Dev CD workflow – Attest Images
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.13 – 开发 CD 工作流 – 验证镜像
- en: 'As is evident, the workflow has successfully configured binary authorization
    and attested our images. To verify, execute the following command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所见，工作流已成功配置二进制授权并验证了我们的镜像。为了验证，请执行以下命令：
- en: '[PRE49]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As we can see, the attestations have been successfully created. Having deployed
    our application in the Dev environment, tested it, and attested all the images
    within, we can now proceed with deploying the code to the Prod environment. This
    involves merging our code with the `prod` branch, and we will implement pull request
    gating for this purpose.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，证明已经成功创建。在将应用程序部署到开发环境并进行测试后，所有镜像均已验证，我们现在可以继续将代码部署到生产环境。这涉及到将代码与`prod`分支合并，我们将为此实施拉取请求门控。
- en: Release gating with pull requests and deployment to production
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过拉取请求进行发布门控并部署到生产环境
- en: The process of pull request gating is straightforward. At the end of the Dev
    CD workflow, we’ll introduce a step to initiate a pull request to merge `dev`
    into the `prod` branch. Human approval is required to proceed with merging the
    pull request. This step highlights how various organizations may adopt different
    methods to verify and promote tested code. Some may opt for automated merging,
    while others may prioritize human-triggered actions. Once the code is successfully
    merged into the `prod` branch, it triggers the Prod CD workflow. This workflow
    creates the Prod environment and deploys our application. It also executes the
    same integration test we ran in the Dev environment to ensure the deployed application
    in Prod remains intact.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取请求门控的过程很简单。在开发 CD 工作流的末尾，我们将添加一个步骤来发起一个拉取请求，将`dev`分支合并到`prod`分支。此步骤需要人工审批才能继续合并拉取请求。这一步展示了不同组织可能采用不同方式来验证和推广经过测试的代码。一些可能选择自动合并，而其他可能优先考虑人工触发的操作。代码成功合并到`prod`分支后，会触发生产
    CD 工作流。该工作流会创建生产环境并部署我们的应用程序，还会执行与在开发环境中运行的相同的集成测试，以确保生产环境中部署的应用程序保持完好。
- en: 'Here’s the step we’ll add to the Dev CD workflow:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将添加到开发 CD 工作流中的步骤：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As we can see, this step invokes the `raise-pr.yml` file. Let’s look at that:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这一步骤调用了`raise-pr.yml`文件。我们来看一下这个文件：
- en: '[PRE51]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This workflow does the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此工作流执行以下操作：
- en: Checks out the code from the repository
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从仓库中检出代码
- en: Raises a pull request to merge with the `prod` branch using the `GH_TOKEN` secret
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交一个拉取请求以使用`GH_TOKEN`密钥与`prod`分支合并
- en: 'To enable the workflow’s functionality, we need to define a GitHub token. This
    token allows the workflow to act on behalf of the current user when creating the
    pull request. Here are the steps:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用工作流的功能，我们需要定义一个GitHub令牌。这个令牌允许工作流代表当前用户创建拉取请求。以下是步骤：
- en: Go to [https://github.com/settings/personal-access-tokens/new](https://github.com/settings/personal-access-tokens/new).
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://github.com/settings/personal-access-tokens/new](https://github.com/settings/personal-access-tokens/new)。
- en: Create a new token with `mdo-environments` repository, granting it the `read-write`
    pull request permission. This approach aligns with the principle of least privilege,
    offering more granular control.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`mdo-environments`仓库中创建一个新的令牌，并授予它`读写`拉取请求权限。这种方法符合最小权限原则，提供了更细粒度的控制。
- en: Once the token is created, copy it.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建令牌后，复制它。
- en: Now, create a GitHub Actions secret named `GH_TOKEN` and paste the copied token
    as the value. You can do this by visiting `https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`GH_TOKEN`的GitHub Actions密钥，并将复制的令牌粘贴为其值。你可以通过访问`https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions`来完成此操作。
- en: 'Next, let’s proceed to copy the workflow files using the following commands:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们继续使用以下命令复制工作流文件：
- en: '[PRE52]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We’re ready to push this code to GitHub. Run the following commands to commit
    and push the changes to your GitHub repository:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备将这段代码推送到GitHub了。运行以下命令以提交并推送更改到你的GitHub仓库：
- en: '[PRE53]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This should trigger a GitHub Actions workflow in your GitHub repository, and
    you should observe something similar to the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会触发GitHub Actions工作流在你的GitHub仓库中运行，你应该会看到类似如下内容：
- en: '![Figure 13.14 – Raising a pull request](img/B19877_13_14.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.14 – 提交拉取请求](img/B19877_13_14.jpg)'
- en: Figure 13.14 – Raising a pull request
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.14 – 提交拉取请求
- en: GitHub has generated a pull request to merge the code into the `prod` branch,
    and the Dev CD workflow is running as anticipated. We can now review the pull
    request and merge the code into the `prod` branch.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub已经生成了一个拉取请求，将代码合并到`prod`分支，且开发 CD 工作流正按预期运行。现在我们可以审查拉取请求并将代码合并到`prod`分支。
- en: Merging code and deploying to prod
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并代码并部署到生产环境
- en: As demonstrated in the previous section, the Dev CD workflow created our environment,
    deployed the application, tested it, and attested application images. It then
    automatically initiated a pull request to merge the code into the `prod` branch.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所示，Dev CD 工作流创建了我们的环境，部署了应用程序，进行了测试，并验证了应用程序镜像。然后，它自动发起了一个拉取请求，将代码合并到`prod`分支。
- en: We’ve entered the `prod` branch.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已进入`prod`分支。
- en: 'Since we know the pull request has been created, let’s proceed to inspect and
    approve it. To do so, go to `https://github.com/<your_github_user>/mdo-environments/pulls`,
    where you will find the pull request. Click on the pull request, and you will
    encounter the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道拉取请求已经创建，让我们继续检查并批准它。为此，访问`https://github.com/<your_github_user>/mdo-environments/pulls`，你会找到该拉取请求。点击该拉取请求，你会看到以下内容：
- en: '![Figure 13.15 – Pull request](img/B19877_13_15.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.15 – 拉取请求](img/B19877_13_15.jpg)'
- en: Figure 13.15 – Pull request
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.15 – 拉取请求
- en: We see that the pull request is ready to merge. Click on `prod` branch.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到拉取请求已经准备好合并。点击`prod`分支。
- en: 'If you go to `https://github.com/<your_user>/mdo-environments/actions`, you’ll
    find that the Prod CD workflow has been triggered. When you click on the workflow,
    you will see a workflow run like the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问`https://github.com/<your_user>/mdo-environments/actions`，你会发现 Prod CD
    工作流已经触发。当你点击工作流时，你会看到类似以下的工作流运行：
- en: '![Figure 13.16 – Prod CD workflow](img/B19877_13_16.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.16 – Prod CD 工作流](img/B19877_13_16.jpg)'
- en: Figure 13.16 – Prod CD workflow
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.16 – Prod CD 工作流
- en: When we merged the pull request, it automatically triggered the Prod CD workflow
    as it would react to any new changes in the `prod` branch. The workflow did its
    job by building the Prod environment, deploying our application, and testing it.
    Note that binary authorization is enabled for this cluster.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们合并了拉取请求时，它会自动触发 Prod CD 工作流，因为它会响应`prod`分支中的任何新变化。工作流完成了它的任务，构建了生产环境，部署了我们的应用程序，并对其进行了测试。请注意，这个集群启用了二进制授权。
- en: To confirm that binary authorization is functioning correctly, let’s perform
    some checks to ensure unattested images cannot be deployed.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认二进制授权是否正常工作，让我们进行一些检查，确保无法部署未经验证的镜像。
- en: 'First, let’s establish a connection to the `prod` cluster using the following
    command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令与`prod`集群建立连接：
- en: '[PRE54]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s attempt to deploy a pod to your cluster using an `nginx` image. Please
    use the following command:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用`nginx`镜像将一个 pod 部署到集群中。请使用以下命令：
- en: '[PRE55]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now, as expected, the deployment failed, but there’s something else to note
    if you examine the reason. The failure happened because we specified a tag instead
    of a `sha256` digest. Let’s attempt to deploy the image again, but this time,
    with a digest.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如预期的那样，部署失败了，但如果你检查失败的原因，还有一些需要注意的地方。失败发生是因为我们指定了一个标签，而不是`sha256`摘要。让我们再次尝试部署镜像，但这次使用摘要。
- en: 'To do so, let’s retrieve the image digest and set it as a variable called `DIGEST`
    using the following command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们通过以下命令获取镜像摘要并将其设置为名为`DIGEST`的变量：
- en: '[PRE56]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let’s redeploy the image using the digest with the following command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用摘要重新部署镜像，使用以下命令：
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This time, the deployment was denied for a valid reason, confirming that binary
    authorization functions correctly. This ensures the security of your Kubernetes
    cluster, preventing the deployment of unattested images and giving you complete
    control over your environment. With this in place, any issues that arise won’t
    stem from deploying untested or vulnerable images.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，部署因正当理由被拒绝，确认了二进制授权功能正常。这确保了 Kubernetes 集群的安全，防止了未经验证的镜像被部署，并让你对环境拥有完全控制权。有了这个措施，任何问题都不会源自部署未经测试或存在漏洞的镜像。
- en: We’ve covered a lot of ground in integrating security and QA into our CI/CD
    pipelines. Now, let’s explore some best practices for securing modern DevOps pipelines.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了将安全性和质量保障集成到 CI/CD 流水线中的许多内容。现在，让我们探讨一些保护现代 DevOps 流水线的最佳实践。
- en: Security and testing best practices for modern DevOps pipelines
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代 DevOps 流水线的安全性和测试最佳实践
- en: Tooling is not the only thing that will help you in your DevSecOps journey.
    Here are some helpful tips that can help you address security risks and have a
    more secure culture within your organization.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 工具并不是唯一能帮助你在 DevSecOps 旅程中取得进展的东西。这里有一些有用的建议，帮助你解决安全风险，并在你的组织内建立更安全的文化。
- en: Adopt a DevSecOps culture
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 采纳 DevSecOps 文化
- en: Adopting a DevSecOps approach is critical in implementing modern DevOps. Therefore,
    it is vital to embed security within an organization’s culture. You can achieve
    that by implementing effective communication and collaboration between the *development*,
    *operations*, and *security* teams. While most organizations have a security policy,
    it mustn’t be followed just to comply with rules and regulations. Instead, employees
    should cross-skill and upskill themselves to adopt a DevSecOps approach and embed
    security early on during development. Security teams need to learn how to write
    code and work with APIs, while developers need to understand security and use
    automation to achieve this.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 采用DevSecOps方法在实施现代DevOps中至关重要。因此，必须将安全性融入组织的文化中。你可以通过实现开发、运维和安全团队之间的有效沟通与协作来实现这一点。虽然大多数组织都有安全政策，但这些政策不能仅仅为了遵守规则和法规而执行。相反，员工应该进行跨技能培训和提升技能，以便采纳DevSecOps方法，并在开发初期就将安全性嵌入其中。安全团队需要学习如何编写代码并与API协作，而开发人员则需要理解安全性并利用自动化来实现这一点。
- en: Establish access control
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立访问控制
- en: You have heard about the **Principle of Least Privilege** (**PoLP**) several
    times in this book. Well, that is what you need to implement for a better security
    posture, which means you should make all attempts to grant only the required privileges
    to people to do their job, and nothing more. Reduce the just-in-case syndrome
    by making the process of giving access easier so that people don’t feel hindered,
    and as a result, they do not seek more privileges than they require.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书中已经多次听说过**最小权限原则**（**PoLP**）。这正是你需要实施的措施，以提高安全性，这意味着你应该尽量只为人们完成工作所需的权限，而不授予其他不必要的权限。通过简化授予访问权限的过程，减少“以防万一”心态，让人们不会感到受到阻碍，进而避免他们寻求超出需求的权限。
- en: Implement shift left
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施左移策略
- en: Shifting left means embedding security into software at the earlier stages of
    software development. This means security experts need to work closely with developers
    to enable them to build secure software right from the start. The security function
    should not be review-only but should actively work with developers and architects
    to develop a security-hardened design and code.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 左移意味着在软件开发的早期阶段就将安全性嵌入软件中。这意味着安全专家需要与开发人员密切合作，使他们从一开始就能构建安全的软件。安全功能不仅仅是审查功能，还应与开发人员和架构师积极合作，开发安全强化的设计和代码。
- en: Manage security risks consistently
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致地管理安全风险
- en: You should accept risks, which are inevitable, and should have a **Standard
    Operating Procedure** (**SOP**) should an attack occur. You should have straightforward
    and easy-to-understand policies and practices from a security standpoint in all
    aspects of software development and infrastructure management, such as **configuration
    management**, **access controls**, **vulnerability testing**, **code review**,
    and **firewalls**.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该接受不可避免的风险，并在发生攻击时拥有**标准操作程序**（**SOP**）。你应该在软件开发和基础设施管理的各个方面（如**配置管理**、**访问控制**、**漏洞测试**、**代码审查**和**防火墙**）制定简明易懂的政策和实践，以确保从安全角度出发做好准备。
- en: Implement vulnerability scanning
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施漏洞扫描
- en: Open source software today is snowballing, and most software implementations
    rely on ready-made open source frameworks, software libraries, and third-party
    software that don’t come with a guarantee or liability of any kind. While the
    open source ecosystem is building the technological world like never before, it
    does have its own share of vulnerabilities, which you don’t want to insert within
    your software through no fault of your own. Vulnerability scanning is crucial,
    as scans can discover any third-party dependency with vulnerabilities and alert
    you at the initial stage.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，开源软件正在快速增长，许多软件实现依赖于现成的开源框架、软件库和第三方软件，而这些软件并不提供任何保证或责任。虽然开源生态系统正在以前所未有的方式构建技术世界，但它也有自己的漏洞问题，你不希望在自己的软件中引入这些漏洞。漏洞扫描至关重要，因为扫描可以发现任何带有漏洞的第三方依赖，并在初期阶段提醒你。
- en: Automate security
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化安全
- en: Security should not hinder the speed of your DevOps teams; therefore, to keep
    up with the fast pace of DevOps, you should look at embedding security within
    your CI/CD processes. You can do code analysis, vulnerability scanning, configuration
    management, and infrastructure scanning with policy as code and binary authorization
    to allow only tested and secure software to be deployed. Automation helps identify
    potential vulnerabilities early on in the software development life cycle, thereby
    bringing down the cost of software development and rework.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性不应妨碍DevOps团队的速度；因此，为了跟上DevOps的快速节奏，你应该考虑将安全性嵌入到你的CI/CD流程中。你可以通过代码分析、漏洞扫描、配置管理和基础设施扫描，并使用策略即代码和二进制授权来确保只有经过测试并且安全的软件才能部署。自动化有助于在软件开发生命周期的早期发现潜在漏洞，从而降低软件开发和返工的成本。
- en: Similarly, QA is the backbone of software delivery, and modern DevSecOps heavily
    emphasizes automating it. Here are some tips you can follow to implement a modern
    testing approach.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，QA是软件交付的核心，而现代DevSecOps则高度重视自动化测试。以下是一些你可以遵循的建议，以实现现代化的测试方法。
- en: Test automation within your CI/CD pipelines
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在CI/CD管道中进行自动化测试
- en: Automating testing across the board is key. This means encompassing a wide spectrum,
    from unit and integration testing to functional, security, and performance testing.
    The goal is to seamlessly embed these tests within your CI/CD pipeline, ensuring
    a constant stream of validation. In this journey, creating isolated and reproducible
    test environments becomes crucial to thwart any interference among tests. Here,
    methods such as containerization and virtualization are valuable tools for environment
    isolation.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试是关键。这意味着要涵盖广泛的领域，从单元测试、集成测试到功能测试、安全测试和性能测试。目标是将这些测试无缝地嵌入到你的CI/CD管道中，确保持续不断的验证。在这个过程中，创建隔离且可重现的测试环境至关重要，以避免测试之间的相互干扰。在这方面，容器化和虚拟化等方法是环境隔离的宝贵工具。
- en: Manage your test data effectively
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效管理你的测试数据
- en: Test data management is another pivotal aspect. It’s imperative to handle your
    test data effectively, not only ensuring its consistency but also safeguarding
    data privacy. Leveraging data generation tools can be a game-changer in this regard,
    allowing you to create relevant datasets for your testing needs. Moreover, when
    dealing with sensitive information, the consideration of data anonymization is
    prudent. This ensures that you maintain the highest standards of data protection
    while still benefiting from comprehensive testing procedures.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据管理是另一个关键环节。有效处理测试数据至关重要，不仅要确保其一致性，还要保护数据隐私。在这方面，利用数据生成工具可以大大改变游戏规则，帮助你创建适合测试需求的数据集。此外，在处理敏感信息时，考虑数据匿名化是明智的做法。这能确保你在保持最高数据保护标准的同时，依然能够进行全面的测试。
- en: Test all aspects of your application
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试应用的各个方面
- en: CI is all about keeping the development process flowing smoothly. This involves
    frequently merging code and running tests automatically, ensuring the code base
    remains stable. When tests fail, immediate attention is crucial to rectify the
    issues promptly.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: CI的关键是保持开发过程的顺畅进行。这包括频繁地合并代码并自动运行测试，确保代码库保持稳定。当测试失败时，立即关注并迅速解决问题至关重要。
- en: End-to-end testing is your compass to ensure the entire application workflow
    functions as expected. Automation frameworks play a pivotal role in replicating
    real user interactions, making it possible to assess your application thoroughly.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试是确保整个应用工作流按预期运行的指南针。自动化框架在复制真实用户交互方面发挥着重要作用，使你能够全面评估应用的表现。
- en: Load testing is an essential part of the process, as it evaluates how your application
    performs under varying loads, providing insights into its robustness and capacity.
    Additionally, scalability testing ensures that the system is well-equipped to
    handle growth, an important factor for the long-term health of your application.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试是流程中不可或缺的一部分，它评估应用在不同负载下的表现，提供关于应用的健壮性和容量的洞察。此外，可扩展性测试确保系统能够应对增长的需求，这是保证应用长期健康发展的重要因素。
- en: Implement chaos engineering
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施混沌工程
- en: Incorporating chaos engineering practices is a proactive strategy to uncover
    and address potential system weaknesses. By conducting controlled experiments,
    you can gauge the resilience of your system and better prepare it for unexpected
    challenges. These experiments involve intentionally introducing chaos into your
    environment to observe how your system responds. This not only helps you identify
    weaknesses but also provides valuable insights into how to make your system more
    robust and reliable.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 纳入混沌工程实践是一种积极主动的策略，用于发现和解决潜在的系统弱点。通过进行受控实验，你可以评估系统的弹性，更好地为意外的挑战做好准备。这些实验通过故意在环境中引入混沌，观察系统的反应。这不仅帮助你识别弱点，还提供了关于如何增强系统的健壮性和可靠性的宝贵见解。
- en: Monitor and observe your application when it is being tested
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试时监控和观察应用程序
- en: Setting up robust monitoring and observability tools is crucial for gaining
    deep insights into your system’s performance and behavior. These tools allow you
    to collect essential metrics, logs, and traces, providing a comprehensive view
    of your application’s health and performance.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 设置强大的监控和可观察性工具对于深入了解系统的性能和行为至关重要。这些工具允许你收集关键的指标、日志和追踪信息，从而提供应用程序健康状况和性能的全面视图。
- en: Effective testing in production
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在生产环境中进行有效测试
- en: Implementing feature flags and canary releases is a prudent strategy for testing
    new functionality in a real production environment while minimizing risks. Feature
    flags allow you to enable or disable certain features at runtime, giving you control
    over their activation. Canary releases involve rolling out new features to a small
    subset of users, allowing you to monitor their impact before a full-scale release.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 实施特性标志和金丝雀发布是测试新功能在真实生产环境中表现的明智策略，同时可以最小化风险。特性标志允许你在运行时启用或禁用某些功能，从而对它们的激活进行控制。金丝雀发布则涉及将新功能推出给少量用户，允许你在全面发布之前监控其影响。
- en: By utilizing feature flags, you can introduce new features to a limited audience
    without affecting the entire user base. This controlled approach lets you observe
    user interactions, collect feedback, and assess the feature’s performance in a
    real-world scenario. Simultaneously, canary releases enable you to deploy these
    features to a small, representative group of users, allowing you to monitor their
    behavior, collect performance metrics, and identify potential issues.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用特性标志，你可以将新功能推出给有限的用户群体，而不会影响整个用户基础。这种受控的方式使你能够观察用户互动、收集反馈并评估功能在实际场景中的表现。同时，金丝雀发布允许你将这些功能部署给一小部分代表性用户，从而监控他们的行为、收集性能数据并识别潜在问题。
- en: Crucially, continuous monitoring is essential during this process. By closely
    observing the impact of the new functionality, you can quickly detect any issues
    that may arise. If problems occur, you have the flexibility to roll back the changes
    by simply turning off the feature flags or reverting to the previous version.
    This iterative and cautious approach minimizes the impact of potential problems,
    ensuring a smoother user experience and maintaining the stability of your production
    environment.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 至关重要的是，在此过程中持续监控是必不可少的。通过密切观察新功能的影响，你可以迅速发现可能出现的问题。如果发生问题，你可以通过简单地关闭特性标志或恢复到先前版本来灵活地回滚更改。这种迭代和谨慎的方法最大程度地减少了潜在问题的影响，确保了更加顺畅的用户体验，并维持生产环境的稳定性。
- en: Documentation and knowledge sharing
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档和知识共享
- en: Documenting testing procedures, test cases, and best practices is essential
    for ensuring consistency and reliability within the development and testing processes.
    Comprehensive documentation serves as a reference for team members, providing
    clear guidelines on how to conduct tests, the expected outcomes, and the best
    practices to follow. This documentation acts as a valuable resource for both new
    and existing team members, fostering a shared understanding of the testing procedures.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 记录测试程序、测试用例和最佳实践对于确保开发和测试过程中的一致性和可靠性至关重要。全面的文档为团队成员提供了清晰的指导，说明如何进行测试、预期的结果以及应遵循的最佳实践。这些文档是新老团队成员宝贵的资源，促进了对测试程序的共同理解。
- en: Encouraging knowledge sharing among team members further enhances the collective
    expertise of the team. By promoting open communication and sharing experiences,
    team members can learn from one another, gain insights into different testing
    scenarios, and discover innovative solutions to common challenges. This collaborative
    environment promotes continuous learning and ensures that the team stays updated
    on the latest developments and techniques in the field of software testing.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励团队成员之间的知识共享进一步增强了团队的集体专业知识。通过促进开放的沟通和分享经验，团队成员可以互相学习，获得不同测试场景的见解，并发现应对常见挑战的创新解决方案。这种协作的环境促进了持续学习，并确保团队保持对软件测试领域最新发展和技术的了解。
- en: By adhering to these best practices, teams can enhance the security and reliability
    of their CI/CD pipelines. Properly documented procedures and test cases enable
    consistent testing, reducing the likelihood of introducing errors into the code
    base. Knowledge sharing ensures that the team benefits from the collective wisdom
    and experiences of its members, leading to more informed decision-making and efficient
    problem-solving.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践，团队可以增强 CI/CD 管道的安全性和可靠性。适当的文档化流程和测试用例使得测试保持一致，从而减少将错误引入代码库的可能性。知识共享确保团队能够从成员的集体智慧和经验中受益，进而做出更明智的决策并高效解决问题。
- en: In addition, managing security risks effectively becomes possible through well-documented
    testing procedures and disseminating best practices. Teams can identify potential
    security vulnerabilities early in the development process, enabling them to address
    these issues before they escalate into significant threats. Regular knowledge-sharing
    sessions can also include discussions about security best practices, ensuring
    that team members are aware of the latest security threats and countermeasures.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过良好的文档化测试流程和传播最佳实践，能够有效管理安全风险。团队可以在开发过程中及早发现潜在的安全漏洞，从而在这些问题升级为重大威胁之前予以解决。定期的知识共享会议也可以包括关于安全最佳实践的讨论，确保团队成员了解最新的安全威胁和应对措施。
- en: Ultimately, these best practices contribute to a robust testing and development
    culture. They empower teams to deliver software faster and with confidence, knowing
    that their CI/CD pipelines are secure, reliable, and capable of handling the challenges
    of modern software development.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这些最佳实践有助于建立一个强大的测试和开发文化。它们使团队能够更快、更自信地交付软件，因为他们知道 CI/CD 管道是安全、可靠的，并且能够应对现代软件开发的挑战。
- en: Summary
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has covered CI/CD pipeline security and testing, and we have understood
    various tools, techniques, and best practices surrounding it. We looked at a secure
    CI/CD workflow for reference. We then understood, using hands-on exercises, the
    aspects that made it secure, such as secret management, container vulnerability
    scanning, and binary authorization.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经涵盖了 CI/CD 管道的安全性和测试，我们了解了围绕它的各种工具、技术和最佳实践。我们参考了一个安全的 CI/CD 工作流。然后，我们通过实际操作，理解了让它保持安全的各个方面，比如密钥管理、容器漏洞扫描和二进制授权。
- en: Using the skills learned in this chapter, you can now appropriately secure your
    CI/CD pipelines and make your application more secure.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 运用本章学到的技能，你现在可以适当地保护你的 CI/CD 管道，并使你的应用程序更安全。
- en: In the next chapter, we will explore the operational elements along with key
    performance indicators for running our application in production.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探索运行应用程序在生产环境中的操作元素以及关键性能指标。
- en: Questions
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of these is the recommended place for storing secrets?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是存储密钥的推荐位置？
- en: A. Private Git repository
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 私有 Git 仓库
- en: B. Public Git repository
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 公共 Git 仓库
- en: C. Docker image
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Docker 镜像
- en: D. Secret management system
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 密钥管理系统
- en: Which one of the following is an open source secret management system?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项是开源的密钥管理系统？
- en: A. Secret Manager
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 密钥管理器
- en: B. HashiCorp Vault
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. HashiCorp Vault
- en: C. Anchore Grype
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Anchore Grype
- en: Is it a good practice to download a secret within your CD pipeline’s filesystem?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 CD 管道的文件系统中下载一个密钥是一个好习惯吗？
- en: Which base image is generally considered more secure and consists of the fewest
    vulnerabilities?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种基础镜像通常被认为更安全，并且包含最少的漏洞？
- en: A. Alpine
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. Alpine
- en: B. Slim
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. Slim
- en: C. Buster
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Buster
- en: D. Default
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 默认
- en: Which of the following answers are true about binary authorization? (Choose
    two)
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项关于二进制授权的说法是正确的？（选择两项）
- en: A. It scans your images for vulnerabilities.
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 它会扫描你的镜像以检测漏洞。
- en: B. It allows only attested images to be deployed.
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 它仅允许部署经过验证的镜像。
- en: C. It prevents people from bypassing your CI/CD pipeline.
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 它防止人们绕过你的 CI/CD 管道。
- en: Answers
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: D
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D
- en: B
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: 'No'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: A
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
- en: B and C
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B 和 C
- en: Part 5:Operating Applications in Production
  id: totrans-401
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五部分：在生产环境中操作应用
- en: This part provides a comprehensive guide to managing containers in production.
    We will start by covering key performance indicators and reliability principles
    and then explore Istio for advanced security, traffic management, and observability.
    This section will equip you with crucial skills to optimize container-based applications
    in production.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分提供了在生产环境中管理容器的全面指南。我们将首先介绍关键性能指标和可靠性原则，然后探索 Istio 以实现高级安全性、流量管理和可观察性。本节将帮助你掌握优化生产环境中基于容器的应用所需的关键技能。
- en: 'This part has the following chapters:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 14*](B19877_14.xhtml#_idTextAnchor1812), *Understanding Key Performance
    Indicators (KPIs) for Your Production Service*'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19877_14.xhtml#_idTextAnchor1812)，*理解生产服务的关键绩效指标（KPI）*'
- en: '[*Chapter 15*](B19877_15.xhtml#_idTextAnchor1834), *Operating Containers in
    Production with Istio*'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19877_15.xhtml#_idTextAnchor1834)，*使用 Istio 操作生产环境中的容器*'
