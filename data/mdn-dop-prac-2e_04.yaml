- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Creating and Managing Container Images
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和管理容器镜像
- en: In the previous chapter, we covered containerization with Docker, where we installed
    Docker and ran our first container. We covered some core fundamentals, including
    Docker volumes, mounts, storage drivers, and logging drivers. We also covered
    Docker Compose as a declarative method of managing containers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讲解了如何使用 Docker 进行容器化，安装了 Docker 并运行了我们的第一个容器。我们涵盖了一些核心基础知识，包括 Docker
    卷、挂载、存储驱动程序和日志驱动程序。我们还介绍了 Docker Compose 作为一种声明性管理容器的方法。
- en: 'Now, we will discuss the core building blocks of containers: container images.
    Container images also fulfill a core principle of modern DevOps practices: config
    as code. Therefore, understanding container images, how they work, and how to
    build an image effectively is very important for a modern DevOps engineer.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论容器的核心构建模块：容器镜像。容器镜像还实现了现代 DevOps 实践的一个核心原则：配置即代码（config as code）。因此，理解容器镜像、它们是如何工作的以及如何有效地构建镜像，对于现代
    DevOps 工程师来说非常重要。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Docker architecture
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 架构
- en: Understanding Docker images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Docker 镜像
- en: Understanding Dockerfiles, components, and directives
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Dockerfiles、组件和指令
- en: Building and managing Docker images
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和管理 Docker 镜像
- en: Flattening Docker images
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扁平化 Docker 镜像
- en: Optimizing containers with distroless images
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无发行版镜像优化容器
- en: Understanding Docker registries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Docker 仓库
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we assume that you have Docker installed on a Linux machine
    running Ubuntu 18.04 Bionic LTS or later with sudo access. You can read [*Chapter
    3*](B19877_03.xhtml#_idTextAnchor220), *Containerization with Docker*, for more
    details on how to do that.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们假设你已经在一台运行 Ubuntu 18.04 Bionic LTS 或更高版本的 Linux 机器上安装了 Docker，并且具有 sudo
    权限。你可以阅读 [*第 3 章*](B19877_03.xhtml#_idTextAnchor220)，*使用 Docker 进行容器化*，了解更多关于如何实现这一点的细节。
- en: You will also need to clone a GitHub repository for some of the exercises in
    this chapter, which you can find at [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e).
    Also, you need a Docker Hub account for most of the activities. To create one,
    go to [https://hub.docker.com/](https://hub.docker.com/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要克隆一个 GitHub 仓库，用于本章的一些练习，仓库地址是 [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)。此外，大多数活动需要你有一个
    Docker Hub 账户。要创建一个，请访问 [https://hub.docker.com/](https://hub.docker.com/)。
- en: Docker architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 架构
- en: 'Imagine you’re a passionate chef dedicated to creating mouthwatering dishes
    that satisfy hungry customers. In your kitchen, which is a magical place called
    Docker, you have special powers to plan, make, and showcase your culinary creations.
    Let’s break down the key parts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一位充满热情的厨师，致力于创造令人垂涎的菜肴，以满足饥饿的顾客。在你的厨房里，这个神奇的地方叫做Docker，你拥有特殊的能力来规划、制作并展示你的烹饪创作。让我们来拆解其中的关键部分：
- en: '**Ingredients (Application Code and Dependencies)**: Imagine your kitchen has
    shelves filled with ingredients such as flour, eggs, and spices. These ingredients
    come together in a specific way to make a dish. Similarly, your application code
    and dependencies work together to build your application.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**食材（应用代码和依赖项）**：想象你的厨房里有一排架子，上面摆满了食材，比如面粉、鸡蛋和香料。这些食材以特定的方式结合在一起，做成一道菜。同样，你的应用代码和依赖项也需要协同工作，才能构建出你的应用程序。'
- en: '**Recipe (Image)**: Each recipe is like a plan for a particular dish. Imagine
    having a recipe for chocolate cake or pasta carbonara. These recipes are like
    the building blocks for your creations. In the same way, a Docker image is a plan
    for making your Docker container.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**食谱（镜像）**：每个食谱就像是某道菜的计划。想象一下你有一个巧克力蛋糕或卡邦尼意面的食谱。这些食谱就像是你创作的构建模块。同样，Docker 镜像就是制作
    Docker 容器的计划。'
- en: '**Recipe Cards (Dockerfile)**: Your cooking journey involves using special
    recipe cards called Dockerfiles. These cards show you the important steps and
    ingredients (commands) to follow. For example, a Dockerfile for a chocolate cake
    might have steps such as “Mix the flour and sugar” or “Add eggs and cocoa powder.”
    These Dockerfiles guide your helpers (Docker) in making the dish (container).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**食谱卡（Dockerfile）**：你的烹饪旅程中涉及使用特别的食谱卡，这些卡片被称为 Dockerfiles。这些卡片展示了你需要遵循的重要步骤和食材（命令）。例如，一个巧克力蛋糕的
    Dockerfile 可能包括“混合面粉和糖”或“加入鸡蛋和可可粉”这样的步骤。这些 Dockerfiles 引导你的助手（Docker）制作这道菜（容器）。'
- en: '**Cooked Dish (Container)**: When someone wants a dish, you use the recipe
    (image) to make it. Then, you have a fresh, hot dish ready to serve. These dishes
    are separate, but they can be made again and again (thanks to the recipe), just
    like a container.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**做好的菜肴（容器）**：当有人想要一份菜肴时，你用食谱（镜像）来做它。然后，你就有了一道新鲜热乎的菜肴，准备好上桌。这些菜肴是独立的，但它们可以一次又一次地被做出来（多亏了食谱），就像容器一样。'
- en: '**Kitchen Staff (Docker Engine)**: In your bustling kitchen, your helpers (Docker
    Engine) play a big role. They do the hard work, from getting ingredients to following
    the recipe and serving the dish. You give them instructions (Docker commands),
    and they make it happen. They even clean up after making each dish.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**厨房助手（Docker Engine）**：在你忙碌的厨房里，你的助手（Docker Engine）发挥着重要作用。他们做了繁重的工作，从获取食材到按照食谱做菜并上菜。你给他们指令（Docker
    命令），他们就会把事情做成。他们甚至会在做完每道菜后帮你清理。'
- en: '**Special Set Menu (Docker Compose)**: Sometimes, you want to serve a special
    meal with multiple dishes that go well together. Think of a meal with an appetizer,
    a main course, and a dessert. Using Docker Compose is like creating a special
    menu for that occasion. It lists recipes (images) for each part of the meal and
    how they should be served. You can even customize it to create a whole meal experience
    with just one command.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**特制套餐菜单（Docker Compose）**：有时，你想提供一道包含多种菜肴的特别套餐，它们相互搭配非常好。想象一下，一顿包含前菜、主菜和甜点的餐食。使用
    Docker Compose 就像为这个场合制作一个特别的菜单。它列出了每道菜的食谱（镜像）以及它们应该如何搭配。你甚至可以自定义它，只用一个命令就能创造出一整顿饭的体验。'
- en: '**Storage Area (Volumes)**: In your kitchen, you need a place to keep ingredients
    and dishes. Think of Docker volumes as special storage areas where you can keep
    important things, such as data and files, that multiple dishes (containers) can
    use.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**存储区域（Volumes）**：在厨房里，你需要一个地方来存放食材和餐具。把 Docker 卷想象成特殊的存储区域，你可以在这里保存重要的东西，如数据和文件，多个菜肴（容器）都可以使用这些存储。'
- en: '**Communication Channels (Networks)**: Your kitchen is a busy place with lots
    of talking and interacting. In Docker, networks are like special communication
    paths that help different parts of your kitchen (containers) talk to each other.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**通信通道（Networks）**：你的厨房是个热闹的地方，充满了交谈和互动。在 Docker 中，网络就像是特殊的通信路径，帮助你厨房中的不同部分（容器）相互交流。'
- en: So, Docker is like your magical kitchen where you make dishes (containers) using
    plans (Dockerfiles) and ingredients (images) with the assistance of your kitchen
    helpers (Docker Engine). You can even serve entire meals (Docker Compose) and
    use special storage areas (volumes) and communication paths (networks) to make
    your dishes even more amazing. Just like a chef gets better with practice, exploring
    Docker will help you become a master of DevOps in no time! Now, let’s dive deeper
    into Docker architecture to understand its nuances!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，Docker 就像你的神奇厨房，你可以使用计划（Dockerfiles）和食材（镜像），在厨房助手（Docker Engine）的帮助下制作菜肴（容器）。你甚至可以提供整套套餐（Docker
    Compose），并使用特殊的存储区域（Volumes）和通信通道（Networks）来使你的菜肴更加美味。就像大厨通过练习不断进步一样，探索 Docker
    将帮助你迅速成为 DevOps 的高手！现在，让我们深入了解 Docker 架构，理解其中的细节！
- en: As we already know, Docker uses the *build once, run anywhere* concept. Docker
    packages applications into images. Docker images form the blueprint of containers,
    so a container is an instance of an image.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，Docker 使用 *一次构建，到处运行* 的概念。Docker 将应用打包成镜像，Docker 镜像形成容器的蓝图，因此容器就是镜像的一个实例。
- en: A container image packages applications and their dependencies, so they are
    a single immutable unit you can run on any machine that runs Docker. You can also
    visualize them as a snapshot of the container.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像打包了应用程序及其依赖项，因此它们是一个可以在任何运行 Docker 的机器上运行的单一不可变单元。你也可以将它们视为容器的快照。
- en: We can build and store Docker images in a Docker registry, such as **Docker
    Hub**, and then download and use those images in the system where we want to deploy
    them. Images comprise several layers, which helps break images into multiple parts.
    The layers tend to be reusable stages that other images can build upon. This also
    means we don’t have to transmit the entire image over a network when changing
    images. We only transmit the delta, which saves a lot of network I/O. We will
    talk about the layered filesystem in detail later in this chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Docker 注册中心中构建和存储 Docker 镜像，例如 **Docker Hub**，然后将这些镜像下载到我们希望部署它们的系统中。镜像由多个层组成，这有助于将镜像拆分成多个部分。层通常是可重用的阶段，其他镜像可以在此基础上构建。这也意味着我们在更改镜像时不必传输整个镜像，而只需传输差异部分，这大大节省了网络
    I/O。我们将在本章稍后详细讨论分层文件系统。
- en: 'The following diagram shows the components Docker uses to orchestrate the following
    activities:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了 Docker 用于协调以下活动的组件：
- en: '![Figure 4.1 – Docker architecture](img/B19877_Figure_4.01.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – Docker 架构](img/B19877_Figure_4.01.jpg)'
- en: Figure 4.1 – Docker architecture
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – Docker 架构
- en: 'The components are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 组件包括：
- en: '**Docker daemon**: This process runs on the servers that we want to run our
    containers on. They deploy and run containers on the Docker server.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 守护进程**：该进程运行在我们希望运行容器的服务器上。它们在 Docker 服务器上部署和运行容器。'
- en: '**Docker registries**: These store and distribute Docker images.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 仓库**：这些用于存储和分发 Docker 镜像。'
- en: '`docker` commands to the Docker daemon.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 Docker 守护进程发送 `docker` 命令。
- en: Now that we understand Docker architecture’s key components and how Docker images
    play an essential role, let’s understand Docker images and their components, directives,
    and registries in detail.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了 Docker 架构的关键组件，以及 Docker 镜像在其中的重要作用，让我们更详细地理解 Docker 镜像及其组件、指令和仓库。
- en: Understanding Docker images
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Docker 镜像
- en: Docker images form the blueprint of Docker containers. Just like you need a
    blueprint for a shipping container to determine its size and what goods it will
    contain, a Docker image specifies what packages, source code, dependencies, and
    libraries it needs to use. It also determines what it needs to do for the source
    code to run effectively.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像构成了 Docker 容器的蓝图。就像你需要为运输集装箱设计一个蓝图来确定其大小以及它将包含哪些货物一样，Docker 镜像指定了需要使用的包、源代码、依赖项和库。它还决定了源代码如何运行才能有效。
- en: Technically, it consists of a series of steps you would perform on a base OS
    image to get your application up and running. This may include installing packages
    and dependencies, copying the source code to the correct folder, building your
    code to generate a binary, and so on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，它由一系列步骤构成，这些步骤是在基础操作系统镜像上执行的，以便让你的应用程序正常运行。这可能包括安装软件包和依赖项、将源代码复制到正确的文件夹、构建代码生成二进制文件等等。
- en: You can store Docker images in a container registry, a centralized location
    from where your Docker machines can pull images to create containers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 Docker 镜像存储在容器仓库中，这是一个集中存储位置，Docker 主机可以从这里拉取镜像来创建容器。
- en: Docker images use a layered filesystem. Instead of a huge monolithic block on
    the filesystem that comprises the template to run containers, we have many layers,
    one on top of the other. But what does this mean? What problem does this solve?
    Let’s have a look in the next section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像使用分层文件系统。我们不再使用一个庞大的、单一的文件系统块作为运行容器的模板，而是有许多层，叠加在一起。那么这意味着什么？解决了什么问题？让我们在下一部分中看看。
- en: The layered filesystem
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层文件系统
- en: Layers in Docker are intermediate Docker images. The idea is that every Dockerfile
    statement we execute on top of a layer changes something within the layer and
    builds a new one. The subsequent statement modifies the current one to generate
    the next one. The final layer executes the Docker `CMD` or `ENTRYPOINT` command,
    and the resulting image comprises several layers arranged one on top of the other.
    Let’s understand this by looking at a simple example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 中的层是中间的 Docker 镜像。其理念是我们对每个 Dockerfile 语句执行时，都会在上一层之上进行更改并构建一个新层。随后的语句会修改当前层，生成下一个层。最终的层会执行
    Docker 的 `CMD` 或 `ENTRYPOINT` 命令，结果镜像由多个层组成，一个层叠在另一个层之上。让我们通过一个简单的例子来理解这一点。
- en: 'If we pull the *Flask application* we built in the previous chapter, we will
    see the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们拉取上章构建的 *Flask 应用程序*，我们将看到以下内容：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, many `Pull complete` statements are beside random IDs. These
    are called **layers**. The current layer contains just the differences between
    the previous and current filesystem. A container image comprises several layers.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，许多 `Pull complete` 语句旁边都有随机 ID。这些被称为 **层**。当前层仅包含与上一层和当前层文件系统之间的差异。一个容器镜像由多个层组成。
- en: Containers contain an additional writable filesystem on top of the image layers.
    This is the layer where your containers modify the filesystem to provide the expected
    functionality.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在镜像层之上包含一个额外的可写文件系统。这是容器修改文件系统以提供预期功能的层。
- en: There are several advantages of using layers instead of merely copying the entire
    filesystem of the container. Since image layers are read-only, multiple containers
    created from an image share the same layered filesystem, decreasing the overall
    disk and network footprint. Layers also allow you to share filesystems between
    images. For example, if two images come from a single base image, both images
    share the same base layer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用层次结构而不是简单地复制整个容器文件系统有几个优点。由于镜像层是只读的，从一个镜像创建的多个容器共享相同的层次文件系统，从而减少了总体磁盘和网络占用。层次结构还允许你在镜像之间共享文件系统。例如，如果两个镜像来自同一个基础镜像，它们就共享相同的基础层。
- en: 'The following diagram shows a Python application that runs on an Ubuntu OS.
    At a high level, you will see a base layer (Ubuntu OS) and Python installed on
    top of it. On top of Python, we’ve installed the Python app. All these components
    form the image. When we create a container out of the image and run it, we get
    the writable filesystem on top as the final layer:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了一个在 Ubuntu 操作系统上运行的 Python 应用程序。从高层次来看，你会看到一个基础层（Ubuntu 操作系统）和安装在其上的 Python。在
    Python 上面，我们安装了 Python 应用程序。所有这些组件共同构成了镜像。当我们从镜像创建容器并运行它时，我们得到的是位于最上层的可写文件系统：
- en: '![Figure 4.2 – Container layers](img/B19877_Figure_4.02.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 容器层](img/B19877_Figure_4.02.jpg)'
- en: Figure 4.2 – Container layers
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 容器层
- en: So, you can create multiple Python app images from the same base image and customize
    them according to your needs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你可以从相同的基础镜像创建多个 Python 应用镜像，并根据需要进行定制。
- en: The writable filesystem is unique for every container you spin from container
    images, even if you create containers from the same image.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 每个从容器镜像创建的容器都有独特的可写文件系统，即使你从相同的镜像创建容器也是如此。
- en: Image history
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像历史
- en: To understand images and their layers, you can always inspect the image history.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解镜像及其层次结构，你可以随时查看镜像历史。
- en: 'Let’s inspect the history of the last Docker image by running the following
    command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令检查最后一个 Docker 镜像的历史：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, there are several layers, and every layer has associated commands.
    You can also see when the layers were created and the size of the disk space occupied
    by each. Some layers do not occupy any disk space, as they haven’t added anything
    new to the filesystem, such as `CMD` and `EXPOSE` directives. These perform some
    functions, but they do not write anything to the filesystem. While commands such
    as `apk add` write to the filesystem, you can see them taking up disk space.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，存在多个层次，每个层次都有相应的命令。你还可以看到这些层次何时创建以及每层占用的磁盘空间大小。有些层并不占用磁盘空间，因为它们没有对文件系统做任何更改，比如
    `CMD` 和 `EXPOSE` 指令。它们执行某些功能，但不会向文件系统写入任何内容。而像 `apk add` 这样的命令会写入文件系统，你可以看到它们占用了磁盘空间。
- en: Every layer modifies the old layer in some way, so every layer is just a delta
    of the filesystem configuration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 每一层都会以某种方式修改旧的层，因此每一层只是文件系统配置的增量。
- en: In the next section, we will deep dive into Dockerfiles and find out how we
    can build Docker images and see what the layered architecture looks like.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入研究 Dockerfile，了解如何构建 Docker 镜像并查看其层次结构是怎样的。
- en: Understanding Dockerfiles, components, and directives
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Dockerfile、组件和指令
- en: A Dockerfile is a simple file that constitutes a series of steps to build a
    Docker image. Each step is known as a **directive**. There are different kinds
    of directives. Let’s look at a simple example to understand how this works.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 是一个简单的文件，它包含了一系列构建 Docker 镜像的步骤。每个步骤称为 **指令**。有不同类型的指令。让我们通过一个简单的例子来理解它是如何工作的。
- en: We will create a simple NGINX container by building the image from scratch rather
    than using the one available on Docker Hub. NGINX is very popular web server software
    that you can use for a variety of applications; for example, it can serve as a
    load balancer or a reverse proxy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从零开始构建一个简单的 NGINX 容器，而不是使用 Docker Hub 上现成的镜像。NGINX 是一种非常流行的 Web 服务器软件，适用于各种应用场景；例如，它可以作为负载均衡器或反向代理服务器。
- en: 'Start by creating a Dockerfile:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从创建一个 Dockerfile 开始：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let’s look at each line and directive one by one to understand how this Dockerfile
    works:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行分析每个指令，理解这个 Dockerfile 是如何工作的：
- en: The `FROM` directive specifies what the base image for this container should
    be. This means we are using another image as the base and will be building layers
    on top of it. We use the `ubuntu:bionic` package as the base image for this build
    since we want to run NGINX on Ubuntu.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`指令指定了此容器的基础镜像。这意味着我们使用另一个镜像作为基础，并将在其上构建层。我们使用`ubuntu:bionic`包作为此次构建的基础镜像，因为我们想在Ubuntu上运行NGINX。'
- en: The `RUN` directives specify the commands we need to run on a particular layer.
    You can run more than one command by separating them with `&&`. We want to run
    multiple commands in a single line if we’re going to club dependent commands in
    a single layer. Every layer should meet a particular objective. In the preceding
    example, the first `RUN` directive is used to install `curl`, while the next `RUN`
    directive is used to install `nginx`.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`指令指定了在特定层上需要执行的命令。你可以通过`&&`分隔多个命令。如果我们想将依赖命令放入同一层中，可以在一行中运行多个命令。每个层应达到特定的目标。在前面的例子中，第一个`RUN`指令用于安装`curl`，而下一个`RUN`指令用于安装`nginx`。'
- en: You might be wondering why we have `apt update` before every installation. This
    is required, as Docker builds images using layers. So, one layer should not have
    implicit dependencies on the previous one. In this example, if we omit `apt update`
    while installing `nginx`, and if we want to update the `nginx` version without
    changing anything in the directive containing `apt update` (that is, the line
    that installs `curl`), when we run the build, `apt update` will not run again,
    so your `nginx` installation might fail.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么每次安装之前都要运行`apt update`。这是必需的，因为Docker构建镜像是通过层来实现的。因此，一个层不应该隐性依赖于前一个层。在这个例子中，如果在安装`nginx`时省略了`apt
    update`，并且我们想在不更改包含`apt update`指令（即安装`curl`的那一行）的情况下更新`nginx`版本，那么当我们运行构建时，`apt
    update`不会再运行，导致你的`nginx`安装可能会失败。
- en: The `CMD` directive specifies a list of commands that we need to run when the
    built image runs as a container. This is the default command that will be executed,
    and its output will end up in the container logs. Your container can contain one
    or more `CMD` directives. For a long-running process such as NGINX, the last `CMD`
    should contain something that will not pass control back to the shell and continue
    to run for the container’s lifetime. In this case, we run `nginx -g daemon off;`,
    which is a standard way of running NGINX in the foreground.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`指令指定了当构建的镜像作为容器运行时需要执行的一组命令。这是默认执行的命令，它的输出将记录在容器日志中。你的容器可以包含一个或多个`CMD`指令。对于像NGINX这样的长时间运行的进程，最后一个`CMD`应该包含一些不会将控制权交还给shell并且能够持续运行至容器生命周期结束的命令。在这种情况下，我们运行`nginx
    -g daemon off;`，这是一种标准的方式来在前台运行NGINX。'
- en: Some directives can easily be confused with each other, such as `ENTRYPOINT`
    and `CMD` or `CMD` and `RUN`. These also test how solid your Docker fundamentals
    are, so let’s look at both.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一些指令很容易混淆，比如`ENTRYPOINT`和`CMD`，或者`CMD`和`RUN`。这些也能考察你对Docker基础的掌握程度，所以我们来看看这两者的区别。
- en: Can we use ENTRYPOINT instead of CMD?
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以用`ENTRYPOINT`替代`CMD`吗？
- en: Instead of `CMD`, you can use `ENTRYPOINT`. While they serve a similar purpose,
    they are two very different directives. Every Docker container has a default `ENTRYPOINT`
    – `/bin/sh -c`. Anything you add to `CMD` is appended post-`ENTRYPOINT` and executed;
    for example, `CMD ["nginx", "-g", "daemon off;"]` will be generated as `/bin/sh
    -c nginx -g daemon off;`. If you use a custom `ENTRYPOINT` instead, the commands
    you use while launching the container will be appended after it. So, if you define
    `ENTRYPOINT ["nginx", "-g"]` and use `docker run nginx daemon off;`, you will
    get a similar result.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用`ENTRYPOINT`替代`CMD`。虽然它们服务的目的是类似的，但它们是两个完全不同的指令。每个Docker容器都有一个默认的`ENTRYPOINT`——`/bin/sh
    -c`。你在`CMD`中添加的内容会被追加到`ENTRYPOINT`之后并执行；例如，`CMD ["nginx", "-g", "daemon off;"]`将被生成为`/bin/sh
    -c nginx -g daemon off;`。如果你使用自定义的`ENTRYPOINT`，那么在启动容器时使用的命令将被追加到它之后。因此，如果你定义了`ENTRYPOINT
    ["nginx", "-g"]`，并使用`docker run nginx daemon off;`，你将得到类似的结果。
- en: To get a similar result without adding any `CMD` arguments while launching the
    container, you can also use `ENTRYPOINT ["nginx", "-g", "``daemon off;"]`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在启动容器时不添加任何`CMD`参数，您也可以使用`ENTRYPOINT ["nginx", "-g", "daemon off;"]`来获得类似的效果。
- en: Tip
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Use `ENTRYPOINT` unless there is a need for a specific `CMD` requirement. Using
    `ENTRYPOINT` ensures that users cannot change the default behavior of your container,
    so it’s a more secure alternative.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特定的`CMD`需求，否则应该使用`ENTRYPOINT`。使用`ENTRYPOINT`可以确保用户无法更改容器的默认行为，因此它是一种更安全的替代方案。
- en: Now, let’s look at `RUN` versus `CMD`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下 `RUN` 与 `CMD` 的区别。
- en: Are RUN and CMD the same?
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`RUN` 和 `CMD` 是一样的吗？'
- en: No, `RUN` and `CMD` are different and serve different purposes. While `RUN`
    is used to build the container and only modifies the filesystem while building
    it, `CMD` commands are only executed on the writable container layer after the
    container is running.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 不，`RUN` 和 `CMD` 是不同的，它们有不同的用途。`RUN` 用于构建容器，仅在构建过程中修改文件系统，而 `CMD` 指令仅在容器运行后在可写容器层中执行。
- en: While there can be several `RUN` statements in a Dockerfile, each modifying
    the existing layer and generating the next, if a Dockerfile contains more than
    one `CMD` command, all but the last one are ignored.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个 Dockerfile 中可以有多个 `RUN` 语句，每个语句修改现有层并生成下一层，但如果 Dockerfile 中包含多个 `CMD` 指令，除了最后一个，其他都会被忽略。
- en: The `RUN` directives are used to execute statements within the container filesystem
    to build and customize the container image, thus modifying the image layers. The
    idea of using a `CMD` command is to provide the default command(s) with the container
    image that will be executed at runtime. This only changes the writeable container
    filesystem. You can also override the commands by passing a custom command in
    the `docker` `run` statement.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN` 指令用于在容器文件系统内执行语句来构建和定制容器镜像，从而修改镜像层。使用 `CMD` 指令的目的是为容器镜像提供默认的命令，这些命令将在运行时执行。这只会改变可写的容器文件系统。你还可以通过在
    `docker` `run` 语句中传递自定义命令来覆盖这些命令。'
- en: Now, let’s go ahead and build our first container image.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始构建我们的第一个容器镜像。
- en: Building our first container
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建我们的第一个容器
- en: 'Building a container image is very simple. It is actually a one-line command:
    `docker build -t <image-name>:version <build_context>`. While we will discuss
    building container images in detail in the *Building and managing container images*
    section, let’s first build the Dockerfile:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器镜像非常简单。实际上，它是一个一行命令：`docker build -t <image-name>:version <build_context>`。虽然我们将在
    *构建和管理容器镜像* 部分详细讨论构建容器镜像，但首先让我们构建 Dockerfile：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You might have noticed that the name of the container had a prefix in front
    of it. That is your Docker Hub account name. The name of the image has a structure
    of `<registry-url>/<account-name>/<container-image-name>:<version>`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，容器的名字前面有一个前缀。那是你的 Docker Hub 账户名。镜像的名字结构是 `<registry-url>/<account-name>/<container-image-name>:<version>`。
- en: 'Here, we have the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '`registry-url`: The URL to the Docker registry – defaults to `docker.io`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registry-url`：Docker 注册表的 URL，默认为 `docker.io`'
- en: '`account-name`: The user or account that owns the image'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`account-name`：拥有该镜像的用户或账户'
- en: '`container-image-name`: The container image’s name'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container-image-name`：容器镜像的名称'
- en: '`version`: The image version'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：镜像版本'
- en: 'Now, let’s create a container out of the image using the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令从镜像创建一个容器：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we can see that the container is up and running.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到容器已经启动并运行。
- en: 'If we run `curl localhost`, we get the default `nginx` `html` response:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行 `curl localhost`，我们会得到默认的 `nginx` `html` 响应：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That’s great! We have built our first image using a Dockerfile.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们已经使用 Dockerfile 构建了我们的第一个镜像。
- en: 'What if we wanted to customize the image according to our requirements? Practically
    speaking, no one would want an NGINX container just responding with the default
    `Welcome to nginx!` message, so let’s create an index page and use that instead:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想根据需求自定义镜像怎么办？实际上，没有人会想要一个仅响应默认 `Welcome to nginx!` 消息的 NGINX 容器，因此让我们创建一个索引页面并使用它代替：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This one outputs a custom message instead of the default NGINX HTML page.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出一个自定义消息，而不是默认的 NGINX HTML 页面。
- en: We all know that the default NGINX directory containing the `index.html` file
    is `/var/www/html`. If we can copy the `index.html` file into this directory,
    it should sort out our problem.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道，默认的 NGINX 目录包含 `index.html` 文件，路径是 `/var/www/html`。如果我们可以将 `index.html`
    文件复制到该目录中，应该就能解决我们的问题。
- en: 'So, modify the Dockerfile so that it includes the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，修改 Dockerfile，使其包含以下内容：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we’ve added two directives to the file: `WORKDIR` and `ADD`. Let’s understand
    what each one does:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向文件中添加了两个指令：`WORKDIR` 和 `ADD`。让我们理解每个指令的作用：
- en: '`WORKDIR`: This defines the current working directory, which is `/var/www/html`
    in this case. The last `WORKDIR` in the Dockerfile also specifies the working
    directory when the container is executed. So, if you `exec` into a running container,
    you will land in the last defined `WORKDIR`. `WORKDIR` can be absolute as well
    as relative to the current working directory.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR`：此指令定义当前工作目录，在本例中为`/var/www/html`。Dockerfile中的最后一个`WORKDIR`指令也指定了容器执行时的工作目录。因此，如果你`exec`进入一个运行中的容器，你将进入最后定义的`WORKDIR`。`WORKDIR`可以是绝对路径，也可以是相对于当前工作目录的相对路径。'
- en: '`ADD`: This adds a local file to the container filesystem – the working directory,
    in this case. You can also use a `COPY` directive here instead of `ADD`, though
    `ADD` offers some more features, such as downloading files from a URL and using
    an archive such as a TAR or ZIP package.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`：此指令将本地文件添加到容器文件系统——在此案例中是工作目录。你也可以使用`COPY`指令代替`ADD`，虽然`ADD`提供了一些额外的功能，比如从URL下载文件，或使用TAR或ZIP等存档包。'
- en: 'When we build this file, we expect the `index.html` file to be copied to the
    `/var/www/html` directory within the container filesystem. Let’s have a look:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建此文件时，我们期望`index.html`文件被复制到容器文件系统中的`/var/www/html`目录。让我们来看一下：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This time, the build was much faster! When we executed the Docker build, it
    used a lot of layers from the cache. That is one of the advantages of layered
    architecture; you only build the changing part and use the existing one the way
    it is.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，构建速度更快了！当我们执行Docker构建时，它使用了大量来自缓存的层。这就是分层架构的优势之一；你只需要构建变化的部分，其他部分则可以直接使用现有的。
- en: Tip
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always add source code after installing packages and dependencies. The source
    code changes frequently and the packages more or less remain the same. This will
    result in faster builds and save a lot of CI/CD time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完包和依赖后，始终添加源代码。源代码经常变动，而包的内容大致保持不变。这将加快构建速度，并节省大量CI/CD时间。
- en: 'Let’s rerun the container and see what we get. Note that you need to remove
    the old container before doing so:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新运行容器，看看会得到什么。请注意，重新运行前需要先删除旧的容器：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, we can’t see the container anymore. Now, let’s rerun the container
    using the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们无法再看到容器了。现在，让我们使用以下命令重新运行容器：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we can see that the container is up and running. Let’s use `curl localhost`
    to see what we get:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到容器正在运行。让我们使用`curl localhost`看看会得到什么结果：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we get a custom message instead of the default NGINX HTML response!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到的是一个自定义消息，而不是默认的NGINX HTML响应！
- en: This looks good enough for now, but I will discuss a few more directives to
    make this image more reliable. First, we haven’t explicitly documented what port
    this container should expose. This works perfectly fine, as we know that NGINX
    runs on port `80`, but what if someone wants to use your image and doesn’t know
    the port? In that scenario, it is best practice to define the port explicitly.
    We will use the `EXPOSE` directive for that.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这看起来已经足够好了，但我将讨论更多的指令，以使这个镜像更加可靠。首先，我们没有明确记录此容器应暴露的端口。虽然这样做也能正常工作，因为我们知道NGINX运行在`80`端口，但如果有人想使用你的镜像却不知道端口怎么办呢？在这种情况下，最好显式地定义端口。我们将使用`EXPOSE`指令来实现这一点。
- en: Tip
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always use the `EXPOSE` directive to give more clarity and meaning to your image.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用`EXPOSE`指令为你的镜像提供更多的清晰度和意义。
- en: We also need to define the action to the container process if someone sends
    a `docker stop` command. While most processes take the hint and kill the process,
    it makes sense to explicitly specify what `STOPSIGNAL` the container should send
    on a `docker stop` command. We will use the `STOPSIGNAL` directive for that.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要定义如果有人发送`docker stop`命令时，容器进程应该采取的动作。虽然大多数进程会接受这个信号并杀死进程，但明确指定容器在接收到`docker
    stop`命令时应该发送什么`STOPSIGNAL`是有意义的。我们将使用`STOPSIGNAL`指令来实现这一点。
- en: Now, while Docker monitors the container process and keeps it running unless
    it receives a `SIGTERM` or a stop, what would happen if your container process
    hangs for some reason? While your application is in a hung state, Docker still
    thinks it is running as your process is still running. Therefore, monitoring the
    application through an explicit health check would make sense. We will use the
    `HEALTHCHECK` directive for this.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然Docker监控容器进程并保持其运行，除非接收到`SIGTERM`信号或停止命令，但如果你的容器进程因为某些原因挂起会发生什么呢？当你的应用程序处于挂起状态时，Docker仍然认为它在运行，因为你的进程依然在运行。因此，通过显式的健康检查来监控应用程序是有意义的。我们将使用`HEALTHCHECK`指令来实现这一点。
- en: 'Let’s combine all these aspects and see what we get in the Dockerfile:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些方面结合起来，看看在Dockerfile中会得到什么结果：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While `EXPOSE` and `STOPSIGNAL` are self-explanatory, let’s look at the `HEALTHCHECK`
    directive. The `HEALTHCHECK` directive runs a command (hence `CMD`) called `curl
    -f localhost`. So, this container will report itself as healthy until the result
    of the `curl` command is a success.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`EXPOSE`和`STOPSIGNAL`不言自明，但我们来看看`HEALTHCHECK`指令。`HEALTHCHECK`指令会运行一个名为`curl
    -f localhost`的命令（因此是`CMD`）。所以，在`curl`命令执行成功之前，这个容器会报告为健康状态。
- en: 'The `HEALTHCHECK` directive also contains the following optional fields:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK`指令还包含以下可选字段：'
- en: '`--interval (default: 30s)`: The interval between two subsequent health checks.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--interval (默认值: 30s)`：两次健康检查之间的间隔时间。'
- en: '`--timeout (default: 30s)`: The health check probe timeout. If the health check
    times out, it implies a health check failure.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--timeout (默认值: 30s)`：健康检查探针超时。如果健康检查超时，则表示健康检查失败。'
- en: '`--start-period (default: 0s)`: The time lag between starting the container
    and the first health check. This allows you to ensure your container is up before
    a health check.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--start-period (默认值: 0s)`：启动容器和第一次健康检查之间的时间间隔。这样可以确保容器在进行健康检查之前已启动。'
- en: '`--retries (default: 3)`: The number of times the probe will retry before declaring
    an unhealthy status.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--retries (默认值: 3)`：探针在宣布容器不健康之前会重试的次数。'
- en: 'Now, let’s build this container:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建这个容器：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It’s time to run it and see for ourselves:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行它，看看结果如何：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we have successfully launched the container, let’s try `ps` and see
    what we get:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功启动了容器，接下来让我们尝试`ps`命令，看看会得到什么结果：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we can see, the container shows `health: starting`, which means the health
    check hasn’t been started yet, and we are waiting for the start time to expire.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们所看到的，容器显示`health: starting`，这意味着健康检查尚未开始，我们正在等待启动时间到期。'
- en: 'Let’s wait a while and then try `docker` `ps` again:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们等一会儿，然后再试一次`docker` `ps`：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, it reports the container as healthy. So, our container is now more
    reliable, as anyone monitoring it will know what part of the application is healthy
    and what part is not.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，它报告容器为健康状态。因此，我们的容器现在更可靠了，因为任何监控它的人都会知道应用程序的哪一部分是健康的，哪一部分不是。
- en: This health check only reports on the container’s health status. It takes no
    action beyond that. You are responsible for periodically monitoring the containers
    and writing a script to action unhealthy containers.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个健康检查只报告容器的健康状态，不会执行其他操作。你需要定期监控容器，并编写脚本来处理不健康的容器。
- en: One way to manage this would be to create a script that checks for unhealthy
    containers and restarts them. You can schedule such a script in your crontab.
    You can also create a long-running `systemd` script that continuously polls the
    container processes and checks for the health status.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 管理这种情况的一种方法是创建一个脚本，用于检查不健康的容器并重新启动它们。你可以在crontab中安排这个脚本。你也可以创建一个长时间运行的`systemd`脚本，不断轮询容器进程并检查健康状态。
- en: Tip
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: While using `HEALTHCHECK` is a great option, you should avoid using it to run
    your containers on Kubernetes or a similar container orchestrator. You should
    make use of liveness and readiness probes instead. Similarly, you can define health
    checks on Docker Compose if you are using it, so use that instead of baking the
    health check into the container image.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用`HEALTHCHECK`是一个不错的选择，但你应该避免在Kubernetes或类似的容器编排工具中运行容器时使用它。你应该改为使用存活探针和就绪探针。类似地，如果你使用Docker
    Compose，也可以在其中定义健康检查，因此应使用它，而不是将健康检查嵌入容器镜像。
- en: Now, let’s go ahead and learn how to build and manage Docker images.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续学习如何构建和管理Docker镜像。
- en: Building and managing Docker images
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和管理Docker镜像
- en: 'We built some Docker images in the previous section, so by now, you should
    know how to write Dockerfiles and create Docker images from them. We’ve also covered
    a few best practices regarding it, which, in summary, are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们构建了一些Docker镜像，到目前为止，你应该知道如何编写Dockerfile并从中创建Docker镜像。我们还讨论了一些最佳实践，简而言之，内容如下：
- en: Always add the layers that do not change frequently first, followed by the layers
    that may change often. For example, install your packages and dependencies first
    and copy the source code later. Docker builds the Dockerfile from the part you
    change until the end, so if you change a line that comes later, Docker takes all
    the existing layers from the cache. Adding more frequently changing parts later
    in the build helps reduce the build time and will result in a faster CI/CD experience.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是先添加那些不常更改的层，再添加可能频繁更改的层。例如，先安装你的包和依赖，再复制源代码。Docker 会从你更改的部分开始构建 Dockerfile，直到结束，因此，如果你修改了后面的某一行，Docker
    会从缓存中获取所有已有的层。将更常变动的部分放在构建的后面，有助于减少构建时间，从而实现更快的 CI/CD 体验。
- en: Combine multiple commands to create as few layers as possible. Avoid multiple
    consecutive `RUN` directives. Instead, combine them into a single RUN directive
    using the `&&` clauses. This will help reduce the overall container footprint.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将多个命令合并为尽可能少的层。避免使用多个连续的 `RUN` 指令。相反，使用 `&&` 子句将它们合并成一个 `RUN` 指令。这将有助于减少容器的总体体积。
- en: Only add the required files within your container. Your container does not need
    the heavyweight package managers and the Go toolkit while running your containers
    if you have already compiled the code into a binary. We will discuss how to do
    this in detail in the following sections.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅将必需的文件添加到容器中。如果你已经将代码编译成二进制文件，那么在运行容器时，容器不需要沉重的包管理器和 Go 工具包。我们将在接下来的章节中详细讨论如何做到这一点。
- en: Docker images are traditionally built using a sequence of steps specified in
    the Dockerfile. But as we already know, Docker is DevOps-compliant and uses config
    management practices from the beginning. Most people build their code within the
    Dockerfile. Therefore, we will also need the programming language library in the
    build context. With a simple sequential Dockerfile, these programming language
    tools and libraries end up within the container image. These are known as single-stage
    builds, which we will cover next.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像传统上是通过在 Dockerfile 中指定一系列步骤来构建的。但正如我们所知道的，Docker 是符合 DevOps 的，并从一开始就使用配置管理实践。大多数人会在
    Dockerfile 中构建他们的代码。因此，我们也需要在构建上下文中包含编程语言库。通过一个简单的顺序 Dockerfile，这些编程语言工具和库最终会出现在容器镜像中。这些被称为单阶段构建，接下来我们将讨论这一点。
- en: Single-stage builds
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单阶段构建
- en: Let’s containerize a simple Go application that prints `Hello, World!` on the
    screen. While I am using **Golang** in this application, this concept is applicable
    universally, irrespective of the programming language.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一个简单的 Go 应用程序容器化，该程序在屏幕上打印 `Hello, World!`。虽然在这个应用程序中我使用的是 **Golang**，但这个概念是普遍适用的，无论使用什么编程语言。
- en: The respective files for this example are present in the `ch4/go-hello-world/single-stage`
    directory within this book’s GitHub repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的相关文件位于本书 GitHub 仓库中的 `ch4/go-hello-world/single-stage` 目录下。
- en: 'Let’s look at the Go application file, `app.go`, first:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下 Go 应用程序文件 `app.go`：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The Dockerfile appears as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 如下所示：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is standard stuff. We take the `golang:1.20.5` base image, declare a `WORKDIR`
    `/tmp`, copy `app.go` from the host filesystem to the container, and build the
    Go application to generate a binary. Finally, we use the `CMD` directive with
    the generated binary to be executed when we run the container.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是标准做法。我们使用 `golang:1.20.5` 基础镜像，声明一个 `WORKDIR` 为 `/tmp`，从主机文件系统将 `app.go` 复制到容器中，然后构建
    Go 应用程序以生成一个二进制文件。最后，我们使用 `CMD` 指令来执行生成的二进制文件，当我们运行容器时，该文件将被执行。
- en: 'Let’s build the Dockerfile:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建 Dockerfile：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let’s run the Docker image and see what we get:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行 Docker 镜像，看看我们能得到什么：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We get the expected response back. Now, let’s run the following command to
    list the image:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了预期的响应。现在，让我们运行以下命令来列出镜像：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This image is huge! It takes 803 MB to print `Hello, World!` on the screen.
    This is not the most efficient way of building Docker images.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个镜像好大啊！打印 `Hello, World!` 需要 803 MB。这不是构建 Docker 镜像的最有效方式。
- en: Before we look at the solution, let’s understand why the image is so bloated
    in the first place. We use the Golang base image, which contains the entire Go
    toolkit and generates a simple binary. We do not need the complete Go toolkit
    for this application to run; it can efficiently run in an Alpine Linux image.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看解决方案之前，先来了解一下为什么镜像一开始会这么臃肿。我们使用的是 Golang 基础镜像，它包含了完整的 Go 工具包，并生成一个简单的二进制文件。对于这个应用程序的运行，我们并不需要完整的
    Go 工具包；它可以在 Alpine Linux 镜像中高效运行。
- en: Docker solves this problem by providing multi-stage builds. You can split your
    build into stages where you can build your code in one stage and then, in the
    second stage, export the built code to another context that begins with a different
    base image that is much lighter and only contains those files and components that
    we need to run the code. We’ll have a look at this in the next section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 通过提供多阶段构建来解决这个问题。你可以将构建过程拆分成多个阶段，在其中一个阶段构建你的代码，然后在第二个阶段将构建好的代码导出到另一个上下文，该上下文从一个更轻的基础镜像开始，只包含运行代码所需的文件和组件。我们将在下一节中详细讨论这个过程。
- en: Multi-stage builds
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多阶段构建
- en: Let’s modify the Dockerfile according to the multi-stage build process and see
    what we get.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照多阶段构建过程修改 Dockerfile，看看结果如何。
- en: The respective files for this example are present in the `ch4/go-hello-world/multi-stage`
    directory within this book’s GitHub repository.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的相关文件位于本书 GitHub 仓库中的 `ch4/go-hello-world/multi-stage` 目录下。
- en: 'The following is the Dockerfile:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 Dockerfile：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The Dockerfile contains two `FROM` directives: `FROM golang:1.20.5 AS build`
    and `FROM alpine:3.18.0`. The first `FROM` directive also includes an `AS` directive
    that declares the stage and names it `build`. Anything we do after this `FROM`
    directive can be accessed using the `build` term until we encounter another `FROM`
    directive, which would form the second stage. Since the second stage is the one
    we want to run our image from, we are not using an `AS` directive.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 包含两个 `FROM` 指令：`FROM golang:1.20.5 AS build` 和 `FROM alpine:3.18.0`。第一个
    `FROM` 指令还包括一个 `AS` 指令，用于声明阶段并将其命名为 `build`。在此 `FROM` 指令之后所做的任何操作都可以通过 `build`
    来访问，直到我们遇到另一个 `FROM` 指令，这将形成第二个阶段。由于第二个阶段是我们要运行镜像的地方，所以我们没有使用 `AS` 指令。
- en: In the first stage, we build our Golang code to generate the binary using the
    `golang` base image.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段，我们使用 `golang` 基础镜像构建我们的 Golang 代码，生成二进制文件。
- en: In the second stage, we use the Alpine base image and copy the `/tmp/app` file
    from the build stage into our current stage. This is the only file we need to
    run in the container. The rest were only required to build and bloat our container
    during runtime.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二阶段，我们使用 Alpine 基础镜像，并将构建阶段中的 `/tmp/app` 文件复制到当前阶段。这是我们在容器中运行所需的唯一文件。其他文件仅在构建过程中需要，用于在运行时膨胀我们的容器。
- en: 'Let’s build the image and see what we get:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建镜像，看看得到什么：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, let’s run the container:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行容器：
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We get the same output, but this time with a minimal footprint. Let’s look
    at the image to confirm this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了相同的输出，但这次占用的空间更小。让我们查看镜像以确认这一点：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This one occupies just 9.17 MB instead of the huge 803 MB. This is a massive
    improvement! We have reduced the image size by almost 100 times.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个镜像仅占用 9.17 MB，而不是庞大的 803 MB。这是一个巨大的改进！我们已经将镜像大小减少了近 100 倍。
- en: That is how we increase efficiency within our container image. Building efficient
    images is the key to running production-ready containers, and most professional
    images you find on Docker Hub use multi-stage builds to create efficient images.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在容器镜像中提高效率的方法。构建高效的镜像是运行生产就绪容器的关键，Docker Hub 上的大多数专业镜像都使用多阶段构建来创建高效的镜像。
- en: Tip
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Use multi-stage builds where possible to include minimal content within your
    image. Consider using an Alpine base image if possible.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使用多阶段构建，以在镜像中包含最小的内容。如果可能，考虑使用 Alpine 基础镜像。
- en: In the next section, we will look at managing images within Docker, some best
    practices, and some of the most frequently used commands.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何管理 Docker 镜像，最佳实践以及一些最常用的命令。
- en: Managing Docker images
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理 Docker 镜像
- en: In modern DevOps practices, Docker images are primarily built either on a developer
    machine or a CI/CD pipeline. The images are stored in a container registry and
    then deployed to multiple staging environments and production machines. They might
    run Docker or a container orchestrator, such as Kubernetes, on top of them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 DevOps 实践中，Docker 镜像通常是在开发者机器或 CI/CD 管道上构建的。这些镜像存储在容器注册中心，然后部署到多个预生产环境和生产机器上。这些机器可能运行
    Docker 或一个容器编排工具，例如 Kubernetes。
- en: To efficiently use images, we must understand how to tag them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效使用镜像，我们必须理解如何标记它们。
- en: Primarily, Docker pulls the image once when you do a Docker run. This means
    that once an image with a particular version is on the machine, Docker will not
    attempt to pull it on every run unless you explicitly pull it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 主要情况下，Docker 会在你执行 Docker run 时拉取镜像一次。这意味着，一旦某个版本的镜像已经存在于机器上，Docker 就不会在每次运行时都重新拉取它，除非你显式地执行拉取操作。
- en: 'To pull the image explicitly, you can use the `docker` `pull` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要显式拉取镜像，你可以使用 `docker` `pull` 命令：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, if we attempt to launch a container using this image, it will instantly
    launch the container without pulling the image:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试使用这个镜像启动容器，它将立即启动容器，而不拉取镜像：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, using the latest tag on an image is a bad idea, and the best practice is
    to use semantic versions as your tag. There are two primary reasons for this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在镜像上使用最新标签是一个坏主意，最佳实践是使用语义版本作为标签。主要有两个原因：
- en: If you build the latest image every time, orchestrators such as Docker Compose
    and Kubernetes will assume the image is already on your machine and will not pull
    your image by default. Using an image pull policy such as `Always` on Kubernetes
    or a script to pull the image is a waste of network bandwidth. It is also important
    to note that Docker Hub limits the number of pulls you can make on open source
    images, so you must limit your pulls to only when necessary.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果每次都构建最新镜像，像 Docker Compose 和 Kubernetes 这样的编排工具会认为镜像已经在你的机器上，并默认不拉取镜像。在 Kubernetes
    上使用像 `Always` 这样的镜像拉取策略，或者用脚本拉取镜像，会浪费网络带宽。还需要注意的是，Docker Hub 限制了你对开源镜像的拉取次数，因此你必须将拉取限制为必要时才进行。
- en: Docker tags allow you to roll out or roll back your container deployment quickly.
    If you always use the latest tag, the new build overrides the old one, so there
    is no way you can roll back a faulty container to the last known good version.
    Using versioned images in production is also a good idea to ensure your container’s
    stability. If, for some reason, you lose the local image and decide to rerun your
    container, you may not get the same version of the software you were already running,
    as the latest tag changes frequently. So, it’s best to use a particular container
    version in production for stability.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 标签允许你快速推出或回滚容器部署。如果你总是使用最新标签，新的构建将覆盖旧的构建，因此你无法将故障容器回滚到最后一个已知的良好版本。在生产环境中使用版本化的镜像也是一个好主意，以确保容器的稳定性。如果由于某些原因，你丢失了本地镜像并决定重新运行容器，可能无法获得与你之前运行的相同版本的软件，因为最新标签经常变化。因此，最好在生产环境中使用特定的容器版本以确保稳定性。
- en: Images comprise multiple layers, and most of the time, there is a relationship
    between various versions of containers that run on your server. With time, new
    versions of images roll out in your production environment, so removing the old
    images by doing some housekeeping is best. This will reclaim some valuable space
    the container images occupy, resulting in a cleaner filesystem.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像由多个层组成，通常，容器的不同版本在你的服务器上是有关系的。随着时间的推移，新的镜像版本会在你的生产环境中推出，因此通过进行一些清理来移除旧镜像是最好的做法。这将回收容器镜像占用的一些宝贵空间，从而使文件系统更加干净。
- en: 'To remove a particular image, you can use the `docker` `rmi` command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除特定镜像，你可以使用 `docker` `rmi` 命令：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Oh! We get an error, but why? It’s because we have a container running and using
    this image.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！我们遇到错误了，为什么呢？因为我们有一个正在运行并使用该镜像的容器。
- en: Tip
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You cannot remove images currently used by a running container.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能移除当前正在使用的镜像。
- en: 'First, you will have to stop and remove the container. Then, you can remove
    the image using the preceding command. If you want to do everything at once, you
    can force removal by using the `-f` flag, which will stop the container, remove
    it, and then remove the image. So, unless you know what you are doing, do not
    use the `-``f` flag:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要停止并移除容器。然后，你可以使用前面的命令移除镜像。如果你想一气呵成，可以通过使用 `-f` 标志强制移除，这将停止容器，移除容器，并移除镜像。所以，除非你知道自己在做什么，否则不要使用
    `-f` 标志：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We built our container many times, but what should we do if we need to push
    it to Docker Hub or other registries? But before we do that, we will have to authenticate
    it with Docker Hub using the following command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了容器多次，但如果我们需要将其推送到 Docker Hub 或其他注册中心该怎么办？但在此之前，我们需要通过以下命令对其进行 Docker
    Hub 身份验证：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, you can push the image to Docker Hub using the following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用以下命令将镜像推送到 Docker Hub：
- en: '[PRE31]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This has pushed four layers and mounted the rest from Ubuntu. We used Ubuntu
    as the base image, which is already available on Docker Hub.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经推送了四层，并将其余部分从 Ubuntu 挂载。我们使用了 Ubuntu 作为基础镜像，该镜像已经存在于 Docker Hub 上。
- en: 'If you have multiple tags for the image and you want to push all of them, then
    you can use the `-a` or `--all-tags` option in the `push` command. This will push
    all the tags for that particular image:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多个镜像标签，并且希望推送所有标签，那么可以在`push`命令中使用`-a`或`--all-tags`选项。这样会将该镜像的所有标签一起推送：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When your build fails for some reason and you make changes to your Dockerfile,
    it’s possible that the old images’ layers will remain dangling. Therefore, it
    is best practice to prune the dangling images at regular intervals. You can use
    `docker images prune` for this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建因为某种原因失败并且你修改了 Dockerfile 时，旧镜像的层可能会保持悬空。因此，定期清理悬空镜像是最佳实践。你可以使用`docker images
    prune`来完成这一操作：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the next section, we’ll look at another way to improve Docker image efficiency:
    flattening Docker images.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨提高 Docker 镜像效率的另一种方法：扁平化 Docker 镜像。
- en: Flattening Docker images
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扁平化 Docker 镜像
- en: Docker inherently uses a layered filesystem, and we have already discussed why
    it is necessary and how it is beneficial in depth. However, in some particular
    use cases, Docker practitioners have observed that a Docker image with fewer layers
    performs better. You can reduce layers in an image by flattening it. However,
    it is still not a best practice, and you need to do this only if you see a performance
    improvement, as this would result in a filesystem overhead.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 本身使用分层文件系统，我们已经深入讨论过它为什么必要以及如何带来好处。然而，在某些特定的使用场景下，Docker 实践者观察到，拥有更少层的
    Docker 镜像表现更好。你可以通过扁平化镜像来减少镜像中的层。然而，这仍然不是最佳实践，只有在你看到性能提升的情况下才应这么做，因为这会导致文件系统开销。
- en: 'To flatten a Docker image, follow these steps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 扁平化 Docker 镜像的步骤如下：
- en: Run a Docker container with the usual image.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用常规镜像运行一个 Docker 容器。
- en: Do a `docker export` of the running container to a `.``tar` file.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对正在运行的容器进行`docker export`操作，将其导出为`.tar`文件。
- en: Do a `docker import` of the `.tar` file into another image.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`.tar`文件进行`docker import`操作，将其导入到另一个镜像中。
- en: Let’s use the `nginx-hello-world` image to flatten it and export it to another
    image; that is, `<your_dockerhub_user>/nginx-hello-world:flat`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`nginx-hello-world`镜像进行扁平化并导出到另一个镜像中；也就是说，`<your_dockerhub_user>/nginx-hello-world:flat`。
- en: 'Before we move on, let’s get the history of the latest image:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们查看最新镜像的历史记录：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let’s run a Docker image with the latest image:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行一个最新的 Docker 镜像：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, let’s take an export out of the running container:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们从正在运行的容器中导出：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Import `nginx-hello-world-flat.tar` to a new image; that is, `<your_dockerhub_user>/nginx-hello-world:flat`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将`nginx-hello-world-flat.tar`导入为一个新镜像；也就是说，`<your_dockerhub_user>/nginx-hello-world:flat`：
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let’s list the images and see what we get:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们列出镜像并看看得到的结果：
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here, we can see that the flat image is present and that it occupies less space
    than the latest image. If we view its history, we should see just a single layer:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到扁平化后的镜像，并且它占用的空间比最新镜像少。如果查看它的历史记录，我们应该只看到一个层：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It has flattened the image. But is it a best practice to flatten Docker images?
    Well, it depends. Let’s understand when and how to flatten Docker images and what
    you should consider:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 它已经将镜像进行了扁平化。但将 Docker 镜像扁平化是最佳实践吗？嗯，这取决于情况。让我们来了解一下什么时候以及如何扁平化 Docker 镜像，以及你需要考虑哪些因素：
- en: Are several applications using a similar base image? If that is the case, then
    flattening images will only increase the disk footprint, as you won’t be able
    to take advantage of a layered filesystem.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有多个应用程序使用相似的基础镜像？如果是这样，扁平化镜像只会增加磁盘占用，因为你无法利用分层文件系统的优势。
- en: Consider alternatives to flattening images using a small base image, such as
    Alpine.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑使用小型基础镜像（如 Alpine）作为扁平化镜像的替代方案。
- en: Multi-stage builds are helpful for most complied languages and can reduce your
    image’s size considerably.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多阶段构建对于大多数编译语言非常有用，并且可以显著减少镜像大小。
- en: You can also slim down images by using as few layers as possible by combining
    multiple steps into a single `RUN` directive.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还可以通过将多个步骤合并为单个`RUN`指令，使用尽可能少的层来缩小镜像大小。
- en: Consider whether the benefits of flattening the image outweigh the disadvantages,
    whether you'll get considerable performance improvements, and whether performance
    is critical for your application needs.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑一下扁平化镜像的好处是否超过其缺点，是否会带来显著的性能提升，以及性能是否对你的应用程序需求至关重要。
- en: These considerations will help you understand your container image footprint
    and help you manage container images. Remember that although reducing the image’s
    size is ideal, flattening it should be a last resort.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这些考虑因素将帮助你理解容器镜像的占用空间，并帮助你管理容器镜像。记住，尽管减少镜像的大小是理想的，但将其压缩应作为最后的手段。
- en: So far, all the images we’ve used have been derived from a Linux distribution
    and always used a distro as their base image. You can also run a container without
    using a Linux distro as the base image to make it more secure. We’ll have a look
    at how in the next section.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的所有镜像都是从 Linux 发行版派生的，且总是使用某个发行版作为其基础镜像。你也可以在不使用 Linux 发行版作为基础镜像的情况下运行容器，以提高安全性。我们将在下一部分中探讨如何做到这一点。
- en: Optimizing containers with distroless images
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用无发行版镜像优化容器
- en: Distroless containers are one of the latest trends in the container world. They
    are promising because they consider all the aspects of optimizing containers for
    the Enterprise environment. You should consider three important things while optimizing
    containers – performance, security, and cost.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 无发行版容器是容器世界中的最新趋势之一。它们很有前景，因为它们考虑了为企业环境优化容器的各个方面。在优化容器时，你应该考虑三个重要因素——性能、安全性和成本。
- en: Performance
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能
- en: You don’t make containers out of thin air. You must download images from your
    container registry and then run the container out of the image. Each step uses
    network and disk I/O. The bigger the image, the more resources it consumes and
    the less performance you get from it. Therefore, a smaller Docker image naturally
    performs better.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能凭空创建容器。你必须从容器注册表中下载镜像，然后从镜像中运行容器。每个步骤都涉及网络和磁盘 I/O。镜像越大，消耗的资源就越多，性能就越差。因此，更小的
    Docker 镜像自然表现更好。
- en: Security
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is one of the most important aspects of the current IT landscape. Companies
    usually focus on this aspect and invest a lot of money and time. Since containers
    are a relatively new technology, they are vulnerable to hacking, so appropriately
    securing your containers is important. Standard Linux distributions have a lot
    of stuff that can allow hackers to access more than they could have if you secured
    your container properly. Therefore, you must ensure you only have what you need
    within the container.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是当前 IT 环境中最重要的方面之一。公司通常会专注于这一点，并投入大量的时间和资金。由于容器是一项相对较新的技术，它们容易受到黑客攻击，因此，适当保护你的容器至关重要。标准的
    Linux 发行版包含了许多可以让黑客访问更多内容的组件，而如果你正确保护容器，它们本来是无法做到的。因此，你必须确保容器内只有必要的内容。
- en: Cost
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成本
- en: A smaller image also results in a lower cost. The lower your container footprint,
    the more containers you can pack within a machine, so there are fewer machines
    you would need to run your applications. This means you save a lot of money that
    would accumulate over time.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 更小的镜像也意味着更低的成本。容器的占用空间越小，你就可以在一台机器中容纳更多的容器，从而减少运行应用程序所需的机器数量。这意味着你可以节省大量随着时间积累的费用。
- en: As a modern DevOps engineer, you must ensure your images are optimized for all
    these aspects. Distroless images help take care of all of them. Therefore, let’s
    understand what distroless images are and how to use them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名现代 DevOps 工程师，你必须确保你的镜像在所有这些方面都得到了优化。无发行版镜像有助于解决这些问题。因此，让我们了解一下什么是无发行版镜像以及如何使用它们。
- en: Distroless images are the most minimal images and only contain your application,
    dependencies, and the necessary files for your container process to run. Most
    of the time, you do not need package managers such as `apt` or a shell such as
    `bash`. Not having a shell has its advantages. For one, it will help you avoid
    any outside party gaining access to your container while it is running. Your container
    has a small attack surface and won’t have many security vulnerabilities.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 无发行版镜像是最简化的镜像，仅包含你的应用程序、依赖项以及容器进程运行所需的文件。大多数情况下，你不需要像 `apt` 这样的包管理器或像 `bash`
    这样的 shell。没有 shell 有其优势。例如，它能帮助你避免任何外部方在容器运行时获得访问权限。你的容器拥有较小的攻击面，因此不会有太多安全漏洞。
- en: Google provides distroless images in their official GCR registry, available
    on their GitHub page at [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless).
    Let’s get hands-on and see what we can do with them.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Google 在其官方 GCR 注册表中提供了无发行版镜像，这些镜像可以在他们的 GitHub 页面找到，链接为 [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless)。让我们动手操作，看看我们能用它们做些什么。
- en: The required resources for this exercise are in `ch4/go-hello-world/distroless`
    in this book’s GitHub repository.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习所需的资源在本书的 GitHub 仓库中的 `ch4/go-hello-world/distroless` 文件夹内。
- en: 'Let’s start by creating a Dockerfile:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个 Dockerfile：
- en: '[PRE40]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This Dockerfile is similar to the multi-stage build Dockerfile for the `go-hello-world`
    container, but instead of using `alpine`, it uses `gcr.io/distroless/base` as
    the base image. This image contains a minimalistic Linux glibc-enabled system
    and lacks a package manager or a shell. You can use it to run binaries compiled
    in a language such as Go, Rust, or D.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Dockerfile 类似于 `go-hello-world` 容器的多阶段构建 Dockerfile，但它使用 `gcr.io/distroless/base`
    作为基础镜像，而不是 `alpine`。这个镜像包含一个最简化的 Linux glibc 系统，不带包管理器或 shell。你可以用它来运行用 Go、Rust
    或 D 等语言编译的二进制文件。
- en: 'So, let’s build this first using the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，先使用以下命令构建它：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let’s run this image and see what we get:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行这个镜像，看看结果：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It works! Let’s look at the size of the image:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效！让我们来看一下图像的大小：
- en: '[PRE43]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It’s just 22.3 MB. Yes, it’s a bit more than the Alpine image, but it does not
    contain a shell, so it is more secure from that point of view. Also, there are
    distroless images available for interpreted programming languages, such as Python
    and Java, that you can use instead of the bloated image containing the toolkits
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 它只有 22.3 MB。是的，比 Alpine 镜像稍大，但它不包含 shell，因此从这个角度看，它更安全。此外，还有适用于解释型编程语言（如 Python
    和 Java）的 distroless 镜像，你可以使用这些代替包含工具包的庞大镜像。
- en: Docker images are stored in Docker registries, and we have all been using Docker
    Hub for a while. In the next section, we’ll understand what they are and what
    our options are for storing our images.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像存储在 Docker 注册表中，我们已经使用 Docker Hub 一段时间了。在接下来的章节中，我们将了解它们是什么，以及我们存储镜像的选项。
- en: Understanding Docker registries
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Docker 注册表
- en: A **Docker registry** is a stateless, highly scalable server-side application
    that stores and lets you distribute Docker images. The registry is open source
    under the permissive **Apache license**. It is a storage and distribution system
    where all your Docker servers can connect and upload and download images as and
    when needed. It acts as a distribution site for your images.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 注册表** 是一个无状态、高度可扩展的服务器端应用程序，用于存储和分发 Docker 镜像。该注册表在宽松的 **Apache 许可证**
    下开源。它是一个存储和分发系统，所有 Docker 服务器都可以连接到它，并根据需要上传和下载镜像。它充当你的镜像分发站点。'
- en: A Docker registry contains several Docker repositories. A Docker repository
    holds several versions of a specific image. For example, all the versions of the
    `nginx` image are stored within a single repository within Docker Hub called `nginx`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Docker 注册表包含多个 Docker 仓库。一个 Docker 仓库保存特定镜像的多个版本。例如，所有版本的 `nginx` 镜像都存储在
    Docker Hub 中名为 `nginx` 的单一仓库内。
- en: By default, Docker interacts with its public Docker registry instance, called
    Docker Hub, which helps you distribute your images to the broader open source
    community.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 与其公共 Docker 注册表实例 Docker Hub 交互，Docker Hub 帮助你将镜像分发到更广泛的开源社区。
- en: Not all images can be public and open source, and many proprietary activities
    are ongoing. Docker allows you to use a private Docker registry for a scenario
    you can host within your infrastructure called **Docker Trusted Registry**. Several
    online options are available, including using a SaaS service, such as GCR, or
    creating private repositories at Docker Hub.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有镜像都可以公开和开源，许多专有活动仍在进行中。Docker 允许你使用私有 Docker 注册表，这是一种可以在你自己的基础设施内托管的场景，称为
    **Docker Trusted Registry**。有多个在线选项可用，包括使用 SaaS 服务，如 GCR，或在 Docker Hub 上创建私有仓库。
- en: While the SaaS option is readily available and intuitive, let’s consider hosting
    our private Docker registry.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SaaS 选项易于使用且直观，但让我们考虑托管我们自己的私有 Docker 注册表。
- en: Hosting your private Docker registry
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 托管你的私有 Docker 注册表
- en: 'Docker provides an image that you can run on any server that has Docker installed.
    Once the container is up and running, you can use that as the Docker registry.
    Let’s have a look:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了一个镜像，你可以在任何安装了 Docker 的服务器上运行。一旦容器启动并运行，你可以将其用作 Docker 注册表。我们来看一下：
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since we know that the registry is running on localhost and listening on port
    `80`, let’s try to push an image to this registry. First, let’s tag the image
    to specify `localhost` as the registry. We will add a registry location at the
    beginning of the Docker tag so that Docker knows where to push the image. We already
    know that the structure of a Docker tag is `<registry_url>/<user>/<image_name>:<image_version>`.
    We will use the `docker tag` command to give another name to an existing image,
    as shown in the following command:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道注册表运行在本地主机上并监听端口`80`，我们现在尝试将镜像推送到这个注册表。首先，让我们标记镜像，指定`localhost`作为注册表。我们将在Docker标签前加上注册表位置，以便Docker知道将镜像推送到哪里。我们已经知道Docker标签的结构是`<registry_url>/<user>/<image_name>:<image_version>`。我们将使用`docker
    tag`命令给现有镜像另起一个名字，如下所示：
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we can go ahead and push the image to the local Docker registry:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续将镜像推送到本地Docker注册表：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: And that’s it! It is as simple as that!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！简单至极！
- en: There are other considerations as well since this is too simplistic. You will
    also have to mount volumes; otherwise, you will lose all the images when you restart
    the registry container. Also, there is no authentication in place, so anyone accessing
    this server can push or pull images, but we don’t desire this. Also, communication
    is insecure, and we want to encrypt the images during transit.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他考虑因素，因为这太过简化了。你还需要挂载卷；否则，在重启注册表容器时，你将丢失所有镜像。另外，目前没有身份验证机制，因此任何访问该服务器的人都可以推送或拉取镜像，但我们并不希望如此。此外，通信是不安全的，我们希望在传输过程中对镜像进行加密。
- en: 'First, let’s create the local directories that we will mount to the containers:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建将要挂载到容器中的本地目录：
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let’s generate an `htpasswd` file for adding authentication to the registry.
    For this, we will run the `htpasswd` command from within a new Docker registry
    container to create a file on our local directory:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们生成一个`htpasswd`文件，为注册表添加身份验证。为此，我们将在新的Docker注册表容器内运行`htpasswd`命令，创建一个文件到我们的本地目录：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The next step is to generate some self-signed certificates for enabling TLS
    on the repository. Add your server name or IP when asked for a **Fully Qualified
    Domain Name** (**FQDN**). You can leave the other fields blank or add appropriate
    values for them:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是生成一些自签名证书，以启用仓库的TLS。输入服务器名称或IP地址时，输入**完全限定域名** (**FQDN**)。你可以将其他字段留空，或者为它们添加合适的值：
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Before we proceed further, let’s remove the existing registry:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，先删除现有的注册表：
- en: '[PRE50]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we are ready to launch our container with the required configuration:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好启动我们的容器，并配置所需的设置：
- en: '[PRE51]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The container is now up and running. Let’s use `https` this time, but before
    that, let’s `docker login` to the registry. Add the username and password you
    set while creating the `htpasswd` file (in this case, `user` and `pass`):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 容器现在已启动并运行。我们这次使用`https`，但在此之前，我们需要进行`docker login`到注册表。输入你在创建`htpasswd`文件时设置的用户名和密码（此例中为`user`和`pass`）：
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Since the login succeeded, we can go ahead and push our image to the registry:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 由于登录成功，我们可以继续将镜像推送到注册表：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This time, it works the way we want it to.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，它按我们希望的方式工作。
- en: Other public registries
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他公共注册表
- en: Apart from running your registry in a dedicated Docker server, other cloud and
    on-premises options exist.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在专用的Docker服务器上运行注册表外，其他云和本地部署选项也存在。
- en: 'Most public cloud providers offer paid online registries and container-hosting
    solutions that you can easily use while running in the cloud. Some of them are
    as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数公共云服务提供商都提供付费的在线注册表和容器托管解决方案，你可以在云端运行时轻松使用它们。以下是一些例子：
- en: '**Amazon Elastic Container Registry** (**ECR**): This is a popular AWS offering
    you can use if your infrastructure runs on AWS. It is a highly available, highly
    performant, fully managed solution. It can host public and private registries,
    and you only pay for the storage you consume and the amount of data transferred
    to the internet. The best part is that it integrates with AWS IAM.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon Elastic Container Registry** (**ECR**)：这是一个流行的AWS服务，如果你的基础设施运行在AWS上，你可以使用它。它是一个高可用、高性能、完全托管的解决方案。它可以托管公共和私有注册表，你只需为所使用的存储和传输到互联网的数据量付费。最棒的是，它可以与AWS
    IAM集成。'
- en: '**Google Container Registry** (**GCR**): Backed by **Google Cloud Storage**
    (**GCS**), GCR is one of the best choices if you run your infrastructure on GCP.
    It hosts both public and private repositories, and you only pay for the storage
    on GCS.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Google容器注册表**（**GCR**）：由**Google Cloud Storage**（**GCS**）提供支持，如果你的基础设施运行在GCP上，GCR是最好的选择之一。它支持公共和私有仓库，你只需要为GCS上的存储付费。'
- en: '**Azure Container Registry** (**ACR**): This fully managed, geo-replicated
    container registry only supports a private registry. It is a good option if you
    are running your infrastructure on Azure. Besides storing container images, it
    also stores Helm charts and other artifacts that help you manage your containers.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure容器注册表**（**ACR**）：这是一个完全托管的、地理复制的容器注册表，仅支持私有注册表。如果你在Azure上运行基础设施，它是一个不错的选择。除了存储容器镜像外，它还存储Helm
    charts和其他有助于管理容器的工件。'
- en: '**Oracle Cloud Infrastructure Registry**: Oracle Cloud Infrastructure Registry
    is a highly available Oracle-managed container registry. It can host both public
    and private repositories.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Oracle Cloud基础设施注册表**：Oracle Cloud基础设施注册表是一个高度可用的Oracle托管容器注册表。它可以托管公共和私有仓库。'
- en: '**CoreOS Quay**: This supports OAuth and LDAP authentication. It offers both
    (paid) private and (free) public repositories, automatic security scanning, and
    automated image builds via integration with GitLab, GitHub, and Bitbucket.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CoreOS Quay**：此服务支持OAuth和LDAP身份验证。它提供（付费）私有仓库和（免费）公共仓库，自动安全扫描，并通过与GitLab、GitHub和Bitbucket的集成进行自动镜像构建。'
- en: If you don’t want to go with managed options in the cloud or run on-premises,
    you can also use distribution management software such as *Sonatype Nexus* or
    *JFrog Artifactory*. Both tools support Docker registries out of the box. You
    can create a Docker registry there using fancy UIs, and then use `docker login`
    to connect to the registry.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想选择云中的托管选项或不希望在本地运行，你还可以使用分发管理软件，如*Sonatype Nexus*或*JFrog Artifactory*。这两款工具都开箱即用地支持Docker注册表。你可以通过它们的华丽界面创建Docker注册表，然后使用`docker
    login`连接到注册表。
- en: Summary
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered a lot of ground. At this point, you should
    understand Docker from a hands-on perspective. We started with Docker images,
    how to use a Dockerfile to build Docker images, the components and directives
    of the Dockerfile, and how to create efficient images by following some best practices.
    We also discussed flattening Docker images and improving container security using
    distroless images. Finally, we discussed Docker registries, how to run a private
    Docker registry on a Docker server, and how to use other turnkey solutions, such
    as Sonatype Nexus and JFrog Artifactory.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们已经覆盖了很多内容。此时，你应该能够从实际操作的角度理解Docker。我们从Docker镜像开始，讲解了如何使用Dockerfile构建Docker镜像、Dockerfile的组件和指令，以及如何通过遵循一些最佳实践来创建高效的镜像。我们还讨论了如何通过使用无发行版镜像来简化Docker镜像并提高容器安全性。最后，我们讨论了Docker注册表、如何在Docker服务器上运行私有Docker注册表，以及如何使用其他即插即用的解决方案，如Sonatype
    Nexus和JFrog Artifactory。
- en: 'Here is a quick summary of some best practices for managing Docker containers
    effectively and efficiently:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些管理Docker容器的最佳实践的快速总结：
- en: '**Use Official Images**: Whenever possible, start with official Docker images
    from reputable sources such as Docker Hub. These images are well-maintained, regularly
    updated, and often come with better security practices.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用官方镜像**：尽可能使用来自可信来源（如Docker Hub）的官方Docker镜像。这些镜像得到了良好的维护，定期更新，通常遵循更好的安全实践。'
- en: '**Minimize Containers**: Follow the “one service per container” principle.
    Each container should have a single responsibility, which helps with maintainability
    and scaling.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小化容器**：遵循“每个容器一个服务”的原则。每个容器应该承担单一责任，这有助于维护性和可扩展性。'
- en: '**Optimize Container Sizes**: Keep containers as lightweight as possible. Use
    Alpine Linux or other minimal base images and remove unnecessary files and dependencies.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化容器大小**：尽可能保持容器轻量化。使用Alpine Linux或其他最小化的基础镜像，并删除不必要的文件和依赖。'
- en: '**Use Environment Variables**: Store configuration and sensitive data in environment
    variables rather than hardcoding it into the container. This enhances portability
    and security.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用环境变量**：将配置和敏感数据存储在环境变量中，而不是硬编码到容器中。这可以提高可移植性和安全性。'
- en: '**Persistent Data**: Store application data outside containers using Docker
    volumes or bind mounts. This ensures that data persists even if containers are
    replaced or stopped.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化数据**：使用Docker卷或绑定挂载将应用数据存储在容器外部。这样可以确保即使容器被替换或停止，数据仍然能够持久存在。'
- en: '**Container Naming**: Give containers meaningful and unique names. This helps
    with easy identification and troubleshooting.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器命名**：为容器赋予有意义且唯一的名称。这有助于便于识别和故障排除。'
- en: '**Resource Limits**: Set resource limits (CPU and memory) for containers to
    prevent one misbehaving container from affecting others on the same host.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源限制**：为容器设置资源限制（CPU 和内存），以防一个不正常的容器影响同一主机上的其他容器。'
- en: '**Container Restart Policies**: Define restart policies to determine how containers
    should behave when they exit or crash. Choose the appropriate policy based on
    your application’s requirements.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器重启策略**：定义重启策略，以决定容器在退出或崩溃时的行为。根据应用程序的需求选择适当的策略。'
- en: '**Docker Compose**: Use Docker Compose to define and manage multi-container
    applications. It simplifies the deployment and orchestration of complex setups.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Compose**：使用 Docker Compose 来定义和管理多容器应用程序。它简化了复杂设置的部署和协调。'
- en: '**Network Isolation**: Use Docker networks to isolate containers and control
    communication between them. This enhances security and manageability.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络隔离**：使用 Docker 网络来隔离容器并控制它们之间的通信。这增强了安全性和可管理性。'
- en: '**Health Checks**: Implement health checks in your containers to ensure they
    run as expected. This helps with automated monitoring and recovery.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康检查**：在容器中实现健康检查，确保它们按预期运行。这有助于自动化监控和恢复。'
- en: '`stdout`) and standard error (`stderr`) streams. This makes it easier to collect
    and analyze logs using Docker’s logging mechanisms.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdout`）和标准错误（`stderr`）流。这使得使用 Docker 的日志机制收集和分析日志变得更容易。'
- en: '**Security Best Practices**: Keep containers up to date with security patches,
    avoid running containers as the root, and follow security best practices to avoid
    vulnerabilities.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全最佳实践**：保持容器的安全补丁更新，避免以 root 身份运行容器，并遵循安全最佳实践以避免漏洞。'
- en: '**Version Control Dockerfiles**: Store Dockerfiles in version control systems
    (e.g., Git) and regularly review and update them.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制 Dockerfile**：将 Dockerfile 存储在版本控制系统中（例如 Git），并定期审查和更新它们。'
- en: '**Container Cleanup**: Regularly remove unused containers, images, and volumes
    to free up disk space. Consider using tools such as Docker’s built-in prune commands.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器清理**：定期移除未使用的容器、镜像和卷，以释放磁盘空间。考虑使用 Docker 内置的清理命令等工具。'
- en: '**Orchestration Tools**: Explore container orchestration tools such as Kubernetes
    or Docker Swarm for managing larger and more complex container deployments.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编排工具**：探索如 Kubernetes 或 Docker Swarm 等容器编排工具，以管理更大且更复杂的容器部署。'
- en: '**Documentation**: Maintain clear and up-to-date documentation for your containers
    and images, including how to run them, their required environment variables, and
    any other configuration details.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：维护清晰且最新的容器和镜像文档，包括如何运行它们、所需的环境变量以及其他任何配置细节。'
- en: '**Backup and Restore**: Establish backup and restore processes for container
    data and configuration to recover them quickly in case of failures.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份与恢复**：建立容器数据和配置的备份与恢复流程，以便在故障发生时迅速恢复。'
- en: '**Monitoring and Scaling**: Implement monitoring and alerting for your containers
    to ensure they run smoothly. Use scaling mechanisms to handle the increased load.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控与扩展**：为容器实现监控和告警，确保它们平稳运行。使用扩展机制来应对增加的负载。'
- en: By following these best practices, you can ensure that your Docker container
    environment is well-organized, secure, maintainable, and scalable.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些最佳实践，您可以确保 Docker 容器环境是有序、安全、可维护和可扩展的。
- en: In the next chapter, we will delve into container orchestration using Kubernetes.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将深入探讨使用 Kubernetes 进行容器编排。
- en: Questions
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Docker images use a layered model. (True/False)
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 镜像使用分层模型。（对/错）
- en: You can delete an image from a server if a container using that image is already
    running. (True/False)
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个容器正在使用某个镜像运行，您仍然可以从服务器上删除该镜像。（对/错）
- en: How do you remove a running container from a server? (Choose two)
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何从服务器中移除一个正在运行的容器？（选择两项）
- en: A. `docker` `rm <container_id>`
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. `docker` `rm <container_id>`
- en: B. `docker rm -``f <container_id>`
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. `docker rm -``f <container_id>`
- en: C. `docker stop <container_id> && docker` `rm <container_id>`
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. `docker stop <container_id> && docker` `rm <container_id>`
- en: D. `docker stop -``f <container_id>`
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. `docker stop -``f <container_id>`
- en: Which of the following options are container build best practices? (Choose four)
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个选项是容器构建的最佳实践？（选择四项）
- en: A. Always add layers that don’t frequently change at the beginning of the Dockerfile.
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 总是将不常更改的层添加到 Dockerfile 的开始部分。
- en: B. Combine multiple steps into a single directive to reduce layers.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 将多个步骤合并为单一指令，以减少层级。
- en: C. Only use the required files in the container to keep it lightweight and reduce
    the attack surface.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 只在容器中使用必要的文件，以保持容器轻量并减少攻击面。
- en: D. Use semantic versioning in your Docker tags and avoid the latest version.
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 在 Docker 标签中使用语义版本控制，避免使用最新版本。
- en: E. Include package managers and a shell within the container, as this helps
    with troubleshooting a running container.
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: E. 在容器中包含包管理器和 shell，这有助于调试正在运行的容器。
- en: F. Only use an `apt update` at the start of your Dockerfile.
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: F. 仅在 Dockerfile 的开头使用 `apt update`。
- en: You should always flatten Docker images to a single layer. (True/False)
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应始终将 Docker 镜像压缩成单层。（对/错）
- en: A distroless container contains a shell. (True/False)
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不带发行版的容器包含一个 shell。（对/错）
- en: What are some of the ways to improve container efficiency? (Choose four)
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改善容器效率的方法有哪些？（选择四项）
- en: A. Try to use a smaller base image if possible, such as Alpine.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 尽可能使用较小的基础镜像，例如 Alpine。
- en: B. Only use multi-stage builds to add the required libraries and dependencies
    to the container and omit heavyweight toolkits that are not necessary.
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 仅使用多阶段构建将所需的库和依赖项添加到容器中，省略不必要的重型工具包。
- en: C. Use distroless base images where possible.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 尽可能使用不带发行版的基础镜像。
- en: D. Flatten Docker images.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 简化 Docker 镜像。
- en: E. Use single-stage builds to include package managers and a shell, as this
    will help in troubleshooting in production.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: E. 使用单阶段构建来包含包管理器和 shell，因为这有助于生产环境中的故障排除。
- en: It is a best practice to prune Docker images from time to time. (True/False)
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定期修剪 Docker 镜像是一种最佳实践。（对/错）
- en: Health checks should always be baked into your Docker image. (True/False)
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 健康检查应始终包含在 Docker 镜像中。（对/错）
- en: Answers
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'True'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对
- en: False – you cannot delete an image that is being used by a running container.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误 – 不能删除正在被运行容器使用的镜像。
- en: B, C
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B, C
- en: A, B, C, D
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B, C, D
- en: False – only flatten Docker images if you'll benefit from better performance.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误 – 只有在提高性能的情况下，才应简化 Docker 镜像。
- en: False – distroless containers do not contain a shell.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误 – 不带发行版的容器不包含 shell。
- en: A, B, C, D
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B, C, D
- en: 'True'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对
- en: False – if you’re using Kubernetes or Docker Compose, use the liveness probes
    or define health checks with a YAML file instead.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误 – 如果使用 Kubernetes 或 Docker Compose，请使用存活探针或通过 YAML 文件定义健康检查。
- en: Part 2:Container Orchestration and Serverless
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：容器编排与无服务器架构
- en: This part will build upon *Part 1* and introduce you to managing containers
    with container orchestration and serverless technologies. In this part, you will
    learn how to manage containers both on-premises and in the cloud using cutting-edge
    tools and technologies.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分将基于*第一部分*，并向您介绍使用容器编排和无服务器技术管理容器。在本部分中，您将学习如何使用先进的工具和技术在本地和云端管理容器。
- en: 'This part has the following chapters:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 5*](B19877_05.xhtml#_idTextAnchor536), *Container Orchestration with
    Kubernetes*'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B19877_05.xhtml#_idTextAnchor536)，*使用 Kubernetes 进行容器编排*'
- en: '[*Chapter 6*](B19877_06.xhtml#_idTextAnchor668), *Managing Advanced Kubernetes
    Resources*'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B19877_06.xhtml#_idTextAnchor668)，*管理高级 Kubernetes 资源*'
- en: '[*Chapter 7*](B19877_07.xhtml#_idTextAnchor866), *Containers as a Service (CaaS)
    and Serverless*'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B19877_07.xhtml#_idTextAnchor866)，*容器即服务（CaaS）与无服务器架构*'
