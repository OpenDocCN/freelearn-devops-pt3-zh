- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Everything Starts with Source Control
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切从源代码控制开始
- en: Source control is one of the most basic tools that is used in software development.
    Therefore, it is probably safe to assume that you have worked with source control
    before. For that reason, this chapter will contain only a brief introduction to
    source control and quickly move on to more advanced topics to help you to set
    up your source control to support DevOps practices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码控制是软件开发中最基本的工具之一。因此，可以合理假设你之前已经使用过源代码控制。鉴于此，本章将仅简要介绍源代码控制，并迅速进入更高级的话题，以帮助你设置源代码控制并支持
    DevOps 实践。
- en: Multiple DevOps practices rely on source control, so setting up your repositories
    to continuously deliver value to your users is a great way to get started and
    a prerequisite for many of the subjects in the following chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 多种 DevOps 实践依赖于源代码控制，因此，设置你的代码库以持续为用户提供价值是一个很好的起点，并且是后续章节中许多主题的前提条件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The types of source control in Azure DevOps source control systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure DevOps 源代码控制系统中的源代码控制类型
- en: Selecting a branching and merging strategy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择分支和合并策略
- en: Securing source control using branch policies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分支策略保护源代码控制
- en: Other tools that are available for source control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于源代码控制的其他工具
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To practice the subjects covered in this chapter, you may need an Azure DevOps
    organization. Also, ensure that Git tools are installed on your local machine.
    You can download Git tools from here: [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实践本章所涉及的主题，你可能需要一个 Azure DevOps 组织。此外，请确保在本地计算机上安装了 Git 工具。你可以从这里下载 Git 工具：[https://git-scm.com/downloads](https://git-scm.com/downloads)。
- en: Types of source control in Azure DevOps
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure DevOps 中的源代码控制类型
- en: 'While there are many different source control systems in existence, they can
    be classified into two categories, centralized and decentralized, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在许多不同的源代码控制系统，但它们可以分为两类：集中式和去中心化，如下所示：
- en: In a **centralized source control** system, only the server has the full history
    and the full set of branches that make up the repository.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**集中式源代码控制**系统中，只有服务器拥有完整的历史记录和构成代码库的所有分支。
- en: In a **decentralized source control** system, everyone working with the repository
    has a full copy of the repository, all of the branches, and its history.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**去中心化源代码控制**系统中，每个与代码库协作的人都拥有代码库的完整副本，包括所有分支及其历史记录。
- en: Azure Repos, part of Azure DevOps services, offers both types of source control
    through **Team Foundation Version Control** (**TFVC**) and Git. The next two sections
    discuss both types of source control in more detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Repos，作为 Azure DevOps 服务的一部分，通过**团队基础版本控制**（**TFVC**）和 Git 提供两种类型的源代码控制。接下来的两节将更详细地讨论这两种源代码控制。
- en: Centralized source control
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集中式源代码控制
- en: In a centralized source control system, the server is the only location where
    the full repository, including all of the history, is stored. When you create
    a local version of the content, you only receive the latest version of the code.
    Receiving this latest version is called **checking out** the repository. In addition
    to this latest version, your own computer only has the changes you make locally.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在集中式源代码控制系统中，服务器是唯一存储完整代码库（包括所有历史记录）的地方。当你创建内容的本地版本时，你只会获得代码的最新版本。获取这个最新版本的过程称为**检出**代码库。除了这个最新版本，你的计算机上只有你本地所做的更改。
- en: Not checking out the full history obviously saves space on your local computer.
    However, disk space is hardly ever an issue nowadays. The downside of this is
    that you need to be continuously connected to the server to perform operations
    such as viewing the history of a file, recent commits of others, or which line
    in a file was last changed by who.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不检出完整历史记录显然节省了你本地计算机的空间。然而，如今磁盘空间几乎从来不是问题。这样做的缺点是，你需要持续连接到服务器，才能执行诸如查看文件历史记录、其他人最近提交的内容，或是某个文件中的某一行最后由谁修改等操作。
- en: An advantage of centralized source control systems is that they often offer
    options for fine-grained control over who can access which branches, directories,
    and even files.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式源代码控制系统的一个优点是，它们通常提供对谁可以访问哪些分支、目录，甚至文件的精细控制选项。
- en: Decentralized source control
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 去中心化源代码控制
- en: With a decentralized source control system, all files, history, and branches
    are also stored on a server. The difference with centralized source control comes
    when you **clone** the repository to have a local copy on your own computer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用去中心化源代码管理系统时，所有文件、历史记录和分支也会存储在服务器上。与集中式源代码管理的不同之处在于，当你**克隆**仓库时，能够在本地计算机上拥有一份副本。
- en: Since you have a full clone of the repository, you can now view the history
    of a file and other branches without connecting to the server again. This obviously
    lessens the load on the server and allows you to continue working even when disconnected,
    which are two advantages of decentralized source control.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你拥有仓库的完整克隆，现在可以在不需要再次连接到服务器的情况下查看文件的历史记录和其他分支。这显然减轻了服务器的负担，并允许你在断开连接时继续工作，这是去中心化源代码管理的两个优势。
- en: The downside is that decentralized source control can be harder to learn than
    centralized source control. Overall, the learning curve of decentralized source
    control systems is steeper. Also, access control on the level of individual directories
    and files is often more limited.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点是，去中心化的源代码管理可能比集中式源代码管理更难学习。总体来说，去中心化源代码管理系统的学习曲线更陡峭。此外，基于单独目录和文件的访问控制通常也更为有限。
- en: No matter which type of source control you are using, you must put a branching
    and merging strategy in place to allow developers to work on different features
    in parallel, while always keeping your `master` branch in a shippable state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用哪种类型的源代码管理，都必须制定分支和合并策略，以便让开发人员能够并行工作在不同的功能上，同时始终保持 `master` 分支处于可交付的状态。
- en: 'In a recent update to Azure DevOps, the default branch that gets created at
    the time of the repository creation is now named `main`. Azure DevOps also offers
    you the ability to rename your default branch to something else. Refer here for
    more information: [https://docs.microsoft.com/en-us/azure/devops/repos/git/change-default-branch](https://docs.microsoft.com/en-us/azure/devops/repos/git/change-default-branch).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 的一次更新中，仓库创建时默认创建的分支现在被命名为 `main`。Azure DevOps 还提供了将默认分支重命名为其他名称的功能。有关更多信息，请参考：[https://docs.microsoft.com/en-us/azure/devops/repos/git/change-default-branch](https://docs.microsoft.com/en-us/azure/devops/repos/git/change-default-branch)。
- en: In the next section, we will look at the different source control systems that
    have been most commonly used within the developer community.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将了解开发者社区中最常用的不同源代码管理系统。
- en: Source control systems
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 源代码管理系统
- en: 'There are many source control systems in use, but in this chapter, we will
    only be looking at the three currently most used. They are the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有许多源代码管理系统被使用，但在本章中，我们将只关注当前最常用的三种，它们如下：
- en: TFVC
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TFVC
- en: Git
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Subversion
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion
- en: Within Azure DevOps, only TVFC and Git are available. Subversion is a centralized
    source control system that is created by the Apache Foundation. In the upcoming
    subsections, we’ll take a look at TFVC and Git in more detail and learn how to
    migrate sources between them. Subversion is discussed at the end of this chapter
    in the *Other tools for source control* section.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中，只有 TFVC 和 Git 可用。Subversion 是由 Apache 基金会创建的集中式源代码管理系统。在接下来的小节中，我们将更详细地了解
    TFVC 和 Git，并学习如何在它们之间迁移源代码。Subversion 将在本章最后的 *其他源代码管理工具* 部分进行讨论。
- en: TFVC
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TFVC
- en: '**TFVC** is a centralized source control system that was introduced by Microsoft
    in 2013, as part of **Team Foundation Server** (**TFS**), the product that has
    evolved to become Azure DevOps. TFVC is still supported in Azure DevOps but is
    not recommended for new projects. If you are not already working with TFVC, there
    is no value in learning it as Microsoft will most likely not release new features
    for it, but it isn’t necessary to move away from it without other drivers.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**TFVC** 是由微软在 2013 年推出的集中式源代码管理系统，作为 **Team Foundation Server** (**TFS**)
    的一部分，该产品已经发展成了现在的 Azure DevOps。TFVC 在 Azure DevOps 中仍然受到支持，但不建议用于新项目。如果你还没有使用
    TFVC，那么学习它没有什么价值，因为微软很可能不会再为它发布新功能，但也不必因为没有其他原因就停止使用它。'
- en: In Azure DevOps, there is a maximum of one TFVC repository per team project.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中，每个团队项目最多只能有一个 TFVC 仓库。
- en: Git
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git
- en: Next to TFVC, Azure DevOps also supports hosting Git repositories. Git is a
    form of decentralized source control that is the standard now among the developer
    community. Git is not specific to Azure DevOps but is a general protocol that
    is used by many platforms that provide source control hosting as a service. Well-known
    examples next to Azure DevOps are GitHub and GitLab.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了TFVC，Azure DevOps还支持托管Git代码库。Git是一种去中心化的源代码控制方式，目前在开发者社区中是标准做法。Git并非Azure
    DevOps特有，它是一种通用协议，许多提供源代码托管服务的平台都使用这个协议。Azure DevOps之外的著名例子有GitHub和GitLab。
- en: 'To work with a Git repository, you must first clone it:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要与Git代码库一起工作，您必须首先克隆它：
- en: Open *Command Prompt* and navigate to the directory where you want to store
    the repository.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开*命令提示符*并导航到您希望存储代码库的目录。
- en: 'Execute the following command and replace the example URL with the URL to your
    Git repository. The example URL shows how the location of a Git repository in
    Azure DevOps is built up:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令并将示例URL替换为您的Git代码库的URL。示例URL展示了Azure DevOps中Git代码库位置的构建方式：
- en: '[PRE0]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, you can start working on the changes you want to make. In this example,
    a new file, `NewFile.txt`, was added.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以开始处理您想要做的更改。在本示例中，添加了一个新文件`NewFile.txt`。
- en: 'Next, this file must be staged for commit. Staging files is done to differentiate
    between files you want to commit and changes you want to keep for your own:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，必须暂存此文件以便提交。暂存文件是为了区分您想提交的文件和您希望保留的更改：
- en: '[PRE1]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After staging all of the changes you want to group into a single commit, creating
    the actual `commit` is done by calling the `commit` command and specifying a description
    of the changes:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将所有希望归为一个提交的更改暂存后，创建实际的`commit`可以通过调用`commit`命令并指定更改描述来完成：
- en: '[PRE2]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, you can push your changes back to the central repository (also termed
    as the remote), by executing the following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以通过执行以下命令将您的更改推送回中央代码库（也称为远程库）：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To make more changes, you can stage and commit changes as often as required.
    You can push the commits one at a time, or you can push multiple commits at once.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行更多更改，您可以根据需要随时暂存和提交更改。您可以一次提交一个提交，也可以一次推送多个提交。
- en: You can also work with Git through the **Visual Studio** (**VS**) or VS Code
    interfaces. Here, you execute precisely the same steps, but instead of your familiar
    command-line interface, you can use a visual interface.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过**Visual Studio**（**VS**）或VS Code接口来使用Git。在这里，您执行完全相同的步骤，但可以使用图形界面代替熟悉的命令行界面。
- en: Large File Storage
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大文件存储
- en: Git is designed and optimized for working with plain text files and tracking
    changes from version to version. However, you might want to store other things
    than just text files in source control. Examples are images or binary files that
    should be included with your application at runtime. While these are valid use
    cases, out of the box, they do not work very well with Git. To fix this, **Large
    File Storage** (**LFS**) was introduced.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Git被设计和优化用于处理纯文本文件，并跟踪从版本到版本的变化。然而，您可能希望在源代码管理中存储除了文本文件以外的其他内容。比如，图像或二进制文件，这些文件应该在应用程序运行时与应用一起使用。虽然这些是有效的使用场景，但开箱即用时，它们与Git的兼容性并不好。为了解决这个问题，引入了**大文件存储**（**LFS**）。
- en: Instead of storing the binary file itself, Git LFS allows you to store a small,
    text file that acts as a pointer to the binary file. The text file contains a
    hash of the binary file so that the client can download the file when cloning
    or fetching changes. Subsequently when you update the binary file, the hash within
    the text file is also updated.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Git LFS并不直接存储二进制文件本身，而是允许您存储一个小的文本文件，这个文本文件充当二进制文件的指针。该文本文件包含二进制文件的哈希值，以便客户端在克隆或获取更改时下载文件。之后，当您更新二进制文件时，文本文件中的哈希值也会更新。
- en: 'To work with Git LFS, you must install the LFS client next to the Git client.
    This is a separate client that every user of the repository must download. Without
    this client, other users will only see the pointer files instead of the actual
    binary files. After installing the client, you must prepare the repository for
    the use of LFS. The following example commands enable the use of LFS for MP4 files:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Git LFS，您必须在Git客户端之外安装LFS客户端。这是一个独立的客户端，代码库的每个用户都必须下载。没有这个客户端，其他用户只能看到指针文件，而无法看到实际的二进制文件。安装客户端后，您必须为代码库准备LFS的使用。以下示例命令启用了对MP4文件的LFS支持：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From here onward, you can work with MP4 files just like any file, and behind
    the scenes, they will be stored separately from your text file changes.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，您可以像处理任何文件一样处理MP4文件，在幕后，它们将与您的文本文件更改分开存储。
- en: Migrating between control systems
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制系统之间迁移
- en: One of the steps on the DevOps journey is the consolidation of tools. This means
    that, at some point, you might be asked to migrate sources from one source control
    system to another, and companies might decide to move all of their sources from
    GitLab or Subversion to Azure Repos. There are multiple options available to you
    to do migrations like these.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps旅程中的一步是工具的整合。这意味着在某个时刻，您可能会被要求将源代码从一个源代码控制系统迁移到另一个，并且公司可能决定将所有源代码从GitLab或Subversion迁移到Azure
    Repos。您可以选择多种选项来执行此类迁移。
- en: The most likely event is that you will receive requests to move sources to one
    or more Azure Git repositories. Possible sources are other Git repositories, TFVC,
    or Subversion. There are tools and approaches available to do such a migration
    while retaining the history of changes in the original repository.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最可能的情况是您将收到将源移动到一个或多个Azure Git存储库的请求。可能的来源包括其他Git存储库、TFVC或Subversion。有工具和方法可用于在保留原始存储库中变更历史的同时执行此类迁移。
- en: If there is no procedure available or you must import sources from another system,
    you can also fall back on creating a new, empty repository and initialize that
    with an existing code base. The disadvantage of this is that all history will
    be lost.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有可用的程序或者必须从另一个系统导入源代码，您还可以回退到创建一个新的空存储库，并使用现有代码库进行初始化。这种方法的缺点是所有历史记录将丢失。
- en: Migrating existing Git repositories
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迁移现有Git存储库
- en: 'When it comes to migrating sources, moving to another location for hosting
    Git repositories is straightforward compared to other migrations. Let’s learn
    how to do this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移源方面，与其他迁移相比，将Git存储库迁移到另一个托管位置非常简单。让我们学习如何做到这一点：
- en: 'First, clone the existing repository to your local computer:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将现有存储库克隆到您的本地计算机：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add another remote server that refers to the new, empty repository that you
    want to move the sources to:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个引用新的空存储库的远程服务器，您希望将源移动到该存储库：
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, push the changes to this new repository. You must do this separately
    for every branch you want to move next to the master:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将更改推送到这个新存储库。您必须对每个要移动到主干旁边的分支单独执行此操作：
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Meanwhile, other developers might have continued to work with the existing repository.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，其他开发人员可能会继续使用现有的存储库。
- en: 'To include those in the new repository as well, you must fetch them to your
    local computer from the original repository and then push them to the new repository.
    Again, repeat this for every branch:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将这些包含在新存储库中，您必须从原始存储库将它们获取到您的本地计算机，然后将它们推送到新存储库。再次为每个分支重复此操作：
- en: '[PRE8]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instruct all developers to start using the new remote repository. Subsequently,
    plan to decommission the original.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指示所有开发人员开始使用新的远程存储库。随后，计划废弃原始存储库。
- en: After a successful migration, it is often best to remove the old repository.
    This prevents anyone from continuing to work there accidentally.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功迁移后，最好删除旧存储库。这样可以防止任何人意外继续在那里工作。
- en: The preceding steps will work for any Git-to-Git migration.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前述步骤对任何Git到Git的迁移都适用。
- en: 'Now, if you specifically want to migrate to an Azure Git repository, you can
    also use the `Import` functionality that is included with Azure DevOps. To do
    this, follow these steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您特别想迁移到Azure Git存储库，您还可以使用Azure DevOps提供的`导入`功能。要执行此操作，请按照以下步骤操作：
- en: Navigate to **Repos** and, optionally, create a new Git repository.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**存储库**，并可选择创建一个新的Git存储库。
- en: Choose to import an existing repository.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择导入现有存储库。
- en: Provide the requested information.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供所请求的信息。
- en: Click on **Import** to start importing the repository.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**导入**以开始导入存储库。
- en: 'The following screenshot illustrates these steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了这些步骤：
- en: '![Figure 4.1 – Importing a repository ](img/B18655_04_01.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 导入存储库 ](img/B18655_04_01.jpg)'
- en: Figure 4.1 – Importing a repository
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 导入存储库
- en: The disadvantage of this approach is that you cannot keep pushing changes from
    the source repository to the new repository. This means that all other developers
    on your team must make sure that they move their changes over on their own or
    do not have any pending work while you migrate the repository.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是您不能继续将更改从源仓库推送到新仓库。这意味着您团队中的所有其他开发人员必须确保他们自己将更改迁移过来，或者在您迁移仓库时没有任何待处理工作。
- en: Migrating from TFVC to an Azure Git repository
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 TFVC 迁移到 Azure Git 仓库
- en: To migrate from TFVC to Git, you can use the same import repository as for moving
    from any Git repository to an Azure repository. This wizard can move the history
    of changes for the last 180 days when doing the import. If this is not enough
    and you are required to move more than 180 days’ worth of history to the new repository,
    there are other approaches you can use but they are more involved. Links to more
    detailed advice are included at the end of this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 TFVC 迁移到 Git，您可以使用与将任何 Git 仓库迁移到 Azure 仓库相同的导入仓库。此向导可以在进行导入时迁移过去180天的变更历史。如果这不够，您需要将超过180天的历史迁移到新仓库，您可以使用其他方法，但这些方法更加复杂。更多详细建议的链接已包含在本章末尾。
- en: Migrating from Subversion to an Azure Git repository
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Subversion 迁移到 Azure Git 仓库
- en: A final type of request that you might receive is that of migrating from a Subversion
    repository to a Git repository. For this, there is no out-of-the-box solution
    from Microsoft available. However, Atlassian has created a tool that can be used
    to migrate a Subversion repository to a local Git repository while maintaining
    the changes history.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能收到的最后一种请求是将 Subversion 仓库迁移到 Git 仓库。对此，微软没有提供现成的解决方案。但是，Atlassian 创建了一个工具，可以在保持变更历史的同时，将
    Subversion 仓库迁移到本地 Git 仓库。
- en: After running this tool, the only thing left to do is to add a remote repository
    to a new empty, hosted repository and push all of the branches. These are the
    same as the steps for migrating from Git to Git, starting at the step that adds
    a new remote repository.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此工具后，剩下要做的就是向新的空托管仓库添加远程仓库，并推送所有分支。这些步骤与从 Git 迁移到 Git 的步骤相同，从添加新远程仓库的步骤开始。
- en: Migrating without retaining history
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不保留历史记录的迁移
- en: If you are asked to do a migration without retaining history, you can just create
    a new, empty repository out of sources folder on your local computer and push
    existing changes there.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您被要求进行不保留历史记录的迁移，您可以直接从本地计算机上的源文件夹创建一个新的空仓库，并将现有更改推送到该仓库。
- en: 'Execute the following commands from the directory that contains the files that
    should go into the `master` branch:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从包含应进入 `master` 分支的文件的目录执行以下命令：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These commands initialize a new repository, create the first commit out of all
    of the files already in the directory, add a reference to the target server location,
    and push the newly created repository there.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令初始化一个新的仓库，创建所有目录中文件的第一个提交，添加对目标服务器位置的引用，并将新创建的仓库推送到该位置。
- en: 'If you want to retain multiple branches, you must repeat the following steps
    for every other branch:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想保留多个分支，必须为每个其他分支重复以下步骤：
- en: 'First, go to the right directory for that branch:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，进入该分支的正确目录：
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, copy the files that need to go into this branch into your working directory.
    Then, continue with the following commands:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将需要进入该分支的文件复制到您的工作目录中。然后，继续执行以下命令：
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This completes the migration, and the latest version of the sources you had
    on your local computer is now available in Git. Other members of your team can
    now clone the repository and work with it. Next, we’ll go on to learn about branching
    and merging.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了迁移，您本地计算机上的源文件的最新版本现在可以在 Git 中使用。您的团队其他成员现在可以克隆该仓库并与其合作。接下来，我们将继续学习关于分支和合并的内容。
- en: Selecting a branching and merging strategy
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择分支和合并策略
- en: Source control allows you to keep a history of all of the changes you have made
    to your files, and also allows working separately from your team members for a
    while if you so desire. We call this **branching**. When you are branching in
    source control, you **fork** the line of changes currently registered. We call
    such a fork a **branch**. A branch allows you to temporarily isolate some work
    from the rest. At any point, if you want to integrate the changes from a branch
    with the changes on the other fork, you can **merge** these changes back. Branches
    are often used for working on not-yet-complete features, proofs of concept, or
    hotfixes. Using branches allows you to later decide which changes to include in
    the next version and which not to.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理允许你保留所有文件更改的历史记录，还允许你与团队成员暂时分开工作（如果你愿意的话）。我们称之为**分支**。当你在源代码管理中进行分支时，你**分叉**了当前注册的更改路径。我们称这样的分叉为**分支**。分支使你可以暂时将某些工作与其他工作隔离开来。在任何时候，如果你想将一个分支的更改与另一个分支的更改合并，你可以**合并**这些更改。分支通常用于开发尚未完成的特性、概念验证或热修复。使用分支允许你稍后决定哪些更改应包含在下一个版本中，哪些不包含。
- en: Branching strategies
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支策略
- en: 'There are many branching strategies available, but the three most used nowadays
    are the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有许多分支策略可供选择，但如今最常用的三种策略如下：
- en: GitHub Flow
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 流程
- en: GitFlow
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitFlow
- en: Release Flow
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布流程
- en: The following subsections will discuss these in greater detail.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将更详细地讨论这些内容。
- en: Tip
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As an alternative to branching, trunk-based development is becoming more popular
    nowadays. To learn more about this, visit [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 作为分支的替代方法，基于主干的开发如今变得越来越流行。欲了解更多信息，请访问 [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/)。
- en: GitHub Flow
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitHub 流程
- en: GitHub Flow is a simple, yet often sufficient, branching strategy. In GitHub
    Flow, there is one `master` branch.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 流程是一种简单但通常足够的分支策略。在 GitHub 流程中，只有一个 `master` 分支。
- en: 'If you want to start work on a new feature or bugfix, you need to create a
    new topic branch on the `master` branch where you commit your work. Only when
    you are completely done with that work should you merge this branch back to the
    `master` branch. An example commit flow might look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想开始开发一个新特性或修复 bug，你需要在 `master` 分支上创建一个新的主题分支，并在该分支上提交你的工作。只有在你完全完成工作后，才应将该分支合并回
    `master` 分支。一个示例提交流程可能如下所示：
- en: '![Figure 4.2 – GitHub Flow ](img/B18655_04_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – GitHub 流程](img/B18655_04_02.jpg)'
- en: Figure 4.2 – GitHub Flow
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – GitHub 流程
- en: As this is the branching scheme with the least branches involved, this is probably
    a good strategy to start with.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是涉及最少分支的分支方案，它可能是一个很好的起始策略。
- en: 'Refer here for more information: [https://www.geeksforgeeks.org/git-flow-vs-github-flow/](https://www.geeksforgeeks.org/git-flow-vs-github-flow/).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多信息，请参见：[https://www.geeksforgeeks.org/git-flow-vs-github-flow/](https://www.geeksforgeeks.org/git-flow-vs-github-flow/)。
- en: GitFlow
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitFlow
- en: GitFlow is another well-known, elaborate branching scheme, and can deal with
    almost any situation that might arise when working with software. GitFlow describes
    creating a `develop` branch of the `master` branch whenever you start work on
    a new version. `develop` is the integration branch where you combine new features
    and do integration testing. It should only contain work that you believe is ready
    to be released.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: GitFlow 是另一种著名的、复杂的分支方案，几乎可以处理在软件开发过程中可能出现的任何情况。GitFlow 描述了每当你开始开发新版本时，如何从 `master`
    分支创建一个 `develop` 分支。`develop` 是集成分支，用于合并新特性并进行集成测试。它应该只包含你认为已准备好发布的工作。
- en: From `develop`, you can create one or more `feature` branches where you start
    working on new features. Only when a feature is done should you merge that branch
    back to the `develop` branch.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `develop` 分支，你可以创建一个或多个 `feature` 分支，开始开发新特性。只有当特性完成后，才应将该分支合并回 `develop`
    分支。
- en: 'When you want to release a new version of your application, you create a `release`
    branch of the `develop` branch. You can perform final testing on the code on this
    branch, and perform one or more bug fixes if needed. When you are satisfied with
    the quality of the code, you can merge this branch with `master` and tag the version.
    You can also merge these bug fixes back to `develop`, so they will also be incorporated
    in new developments. This flow is visible in the following diagram:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想发布应用程序的新版本时，你会创建一个`release`分支，基于`develop`分支。你可以在此分支上进行最终测试，并根据需要进行一个或多个bug修复。当你对代码的质量满意时，你可以将此分支合并到`master`并标记版本。你还可以将这些bug修复合并回`develop`，以便它们也能被纳入新的开发中。这个流程可以在下图中看到：
- en: '![Figure 4.3 – GitFlow branching model ](img/B18655_04_03.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – GitFlow分支模型 ](img/B18655_04_03.jpg)'
- en: Figure 4.3 – GitFlow branching model
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – GitFlow分支模型
- en: If there is ever a critical bug that you need to ship as fast as possible, or
    you want to do a hotfix, this is also possible using the GitFlow-based branching
    strategy. In that case, you can create a new branch of `master` on which you can
    fix the bug. After testing, you can merge this branch to both `master` and `develop`—just
    as you would with a `release` branch.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个紧急的bug需要尽快修复，或者你想做一个热修复，也可以使用基于GitFlow的分支策略。在这种情况下，你可以创建一个`master`分支的新分支，在这个分支上修复bug。测试完成后，你可以将该分支合并到`master`和`develop`中——就像处理`release`分支一样。
- en: Release Flow
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布流程
- en: '`master` branch.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`master` 分支。'
- en: 'The difference is that it is not the code that is on the `master` branch that
    is deployed to production. Instead, whenever a new version of the product needs
    to be released, a new branch is created of `master` with the name `release-{version}`.
    The code from this branch is then deployed to production. Once a new `release`
    branch is deployed, the previous one can be disregarded. This results in the following
    flow:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于，部署到生产环境的不是位于`master`分支上的代码。而是每当需要发布新版本时，会从`master`创建一个名为`release-{version}`的新分支。该分支中的代码随后被部署到生产环境。一旦新的`release`分支被部署，之前的分支就可以被忽略。这导致了以下流程：
- en: '![Figure 4.4 – Release flow branching model ](img/B18655_04_04.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 发布流程分支模型 ](img/B18655_04_04.jpg)'
- en: Figure 4.4 – Release flow branching model
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 发布流程分支模型
- en: The advantage of this model is that it allows for taking a snapshot of the current
    state of the `master` branch and taking that to production. If there is ever a
    bug in production that needs to be fixed ahead of a new complete release, then
    the necessary commits can be merged from the `master` branch to the current `release`
    branch.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型的优点在于，它允许获取`master`分支当前状态的快照并将其推向生产环境。如果生产环境中出现了一个bug，需要在新的完整发布之前修复，那么必要的提交可以从`master`分支合并到当前的`release`分支中。
- en: Trunk-based development
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: In many companies, branching and merging are done to retain flexibility when
    releasing a new version of the software, and being able to cherry pick changes
    for a particular version only at the last moment. This flexibility comes at the
    cost of having to merge or integrate your changes at some point.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多公司中，分支和合并操作用于保持发布新版本软件时的灵活性，并且能够在最后一刻为特定版本选择性地挑选更改。这种灵活性以某些时候需要合并或整合你的更改为代价。
- en: This cost is not only the time it takes but also the risks that a merge operation
    introduces. Merging the changes from two different branches that contain perfectly
    working software might still produce non-working code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这种成本不仅仅是所需的时间，还有合并操作引入的风险。合并来自两个不同分支的变化，即使它们包含完美运行的软件，也可能仍然产生无法工作的代码。
- en: For this reason, you might consider switching to `master` branch) and only creates
    a short-lived branch for preparing one single change, which is then merged into
    the `master` branch.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能考虑切换到`master`分支，仅为准备单一更改创建一个短期存在的分支，然后将其合并到`master`分支。
- en: Benefits of Trunk-Based Development
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的开发的好处
- en: Trunk-based development facilitates increased agility for the development teams
    when releasing features to production. The features teams will develop features
    using temporary and short-lived `features` branches. The changes will be unit
    tested and verified in the development environment, and then subsequently pushed
    to the `master` branch using the Git `PULL` request feature. This is explained
    in the subsequent sections.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 主干开发有助于提高开发团队在发布功能到生产环境时的敏捷性。功能团队将使用临时且短生命周期的`features`分支来开发功能。更改将在开发环境中进行单元测试和验证，随后通过Git的`PULL`请求功能推送到`master`分支。这将在后续章节中进行详细说明。
- en: 'You can read more about trunk-based development here: [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里阅读更多关于主干开发的信息：[https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/)。
- en: When you adopt this, you will need another way to determine which changes will
    and won’t yet be available to your users when releasing a new version of your
    software. You can do this by using **branching by abstraction**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 采用此方法时，你需要另一种方式来确定发布新版本软件时哪些更改对用户可用，哪些不可用。你可以通过使用**抽象分支**来实现这一点。
- en: Branching by abstraction
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 抽象分支
- en: 'When branching by abstraction, you do not keep two versions of your code side
    by side using branches, but you keep them side by side in your code base instead.
    For example, when you want to change the implementation of a class called `FoodClassifier`,
    which implements the `IFoodClassifier` interface, you go through the following
    steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行抽象分支时，你不会通过分支并排存放代码的两个版本，而是将它们并排保存在代码库中。例如，当你想要更改名为`FoodClassifier`的类的实现，而该类实现了`IFoodClassifier`接口时，你需要执行以下步骤：
- en: Refactor the name of the `FoodClassifier` class to `FoodClassifierToBeRemoved`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`FoodClassifier`类的名称重构为`FoodClassifierToBeRemoved`。
- en: Create a copy of the complete `FoodClassifierToBeRemoved` class.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个完整的`FoodClassifierToBeRemoved`类的副本。
- en: Change the name of this copy back to `FoodClassifier`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个副本的名称改回`FoodClassifier`。
- en: 'At this point, your changes should look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你的更改应该是这样的：
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note that at runtime, your application will behave just as it did before.
    You have just added a new, yet unused, class with a behavior change. It is safe
    to commit these changes and even ship the new binaries to a user. Now you can
    start changing the implementation of the new `FoodClassifier` class, test it,
    and establish trust in its implementation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在运行时，你的应用程序行为与之前完全相同。你只是添加了一个新的、尚未使用的类，并且它具有行为变更。现在提交这些更改并将新二进制文件交付给用户是安全的。接下来，你可以开始修改新`FoodClassifier`类的实现，进行测试，并建立对其实现的信任。
- en: Meanwhile, you can keep committing and pushing your changes, even to customers.
    Switching to the new implementation can be done using your dependency injection
    configuration, a Boolean flag, or environment variables. Just choose what makes
    sense in your scenario.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，你可以继续提交并推送你的更改，甚至是推送到客户那里。切换到新实现可以通过依赖注入配置、布尔标志或环境变量来完成。只需根据你的场景选择合适的方式。
- en: Only when you are fully satisfied that the new implementation is working do
    you remove the `FoodClassifierToBeRemoved` class and update any references back
    to `FoodClassifier`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当你完全确认新实现正常工作时，才会移除`FoodClassifierToBeRemoved`类，并将任何引用更新回`FoodClassifier`。
- en: We will expand on branching by abstraction in [*Chapter 6*](B18655_06.xhtml#_idTextAnchor330),
    *Implementing Continuous Deployment and Release Management*, when discussing feature
    toggles. While being a recommended way forward to further accelerate your delivery,
    branching by abstraction is a double-edged sword. If you do not have a process
    to keep the number of side-by-side implementations under control and clean them
    up after switching implementations, the quality of your code base might decline.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第六章*](B18655_06.xhtml#_idTextAnchor330)《实现持续部署和发布管理》中，讨论特性开关时详细介绍抽象分支。虽然抽象分支是加速交付的推荐方法，但它也是一把双刃剑。如果没有有效的流程来控制并清理并行实现的数量，且在切换实现后进行清理，代码库的质量可能会下降。
- en: Merging strategies
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并策略
- en: Depending on the source control system you are working with, there might be
    multiple ways you can merge your changes from one branch to another.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的源代码管理系统，可能有多种方式将你的更改从一个分支合并到另一个分支。
- en: TFVC
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TFVC
- en: When you are working with TFVC, you can prepare a merge locally by choosing
    both a source and target branch and then picking the list of changes you want
    to merge. TFVC will then execute the merge and will show you the changes that
    are the consequence of this merge as *local* changes. You can review, correct,
    or change these changes, and resolve any conflicts. After this, you can commit
    the changes just as you would any regular change.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 TFVC 时，你可以通过选择源分支和目标分支，并选择你想要合并的更改列表来准备本地合并。TFVC 将执行合并并将合并的结果显示为*本地*更改。你可以审查、更正或更改这些更改，并解决任何冲突。之后，你可以像处理常规更改一样提交这些更改。
- en: Git
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git
- en: A merge using Git can be performed by switching to the target branch and then
    merging all of the changes from the source branch. If there are conflicting changes
    between the branches, you must resolve those just as you would when fetching new
    changes from the server. After merging the changes from the source branch and
    resolving any changes, you can commit the changes. This will result in a merge
    commit, which you push to the remote just as any other change.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Git 进行合并时，可以切换到目标分支，然后合并源分支的所有更改。如果分支之间有冲突的更改，你必须像从服务器获取新更改时一样解决这些冲突。合并源分支的更改并解决冲突后，你可以提交这些更改。这将产生一个合并提交，你可以像其他更改一样将其推送到远程仓库。
- en: 'The merge commit can be done using the visual interface of Visual Studio or
    VS Code, or by using the following sequence of commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 合并提交可以通过 Visual Studio 或 VS Code 的可视化界面来完成，也可以使用以下命令序列：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'During the merge process, if there are any conflicts, you have to resolve these
    at this point. Otherwise, you cannot continue:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并过程中，如果有任何冲突，你必须在此时解决这些冲突，否则无法继续：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you will read in the *Securing repositories* section, it is possible to protect
    some branches by disallowing merging this way. When it comes to merging changes
    to `master`, you might want to use another mechanism, namely, pull requests. Using
    a pull request, you can open a request for someone else to pull changes from your
    local branch to the target branch. This way, another team member can first review
    your changes and then merge them when they meet all agreed standards. Others can
    comment on your changes or request updates before they perform the merge. This
    is the most common way of enforcing the *four-eyes principle* for source code
    when working with Git. The *four-eyes principle* says that every change or action
    should be viewed by at least two people.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在*保护仓库*部分中看到的那样，可以通过禁止这种方式的合并来保护某些分支。当涉及到合并更改到`master`分支时，你可能希望使用另一种机制，即拉取请求。通过拉取请求，你可以请求其他人从你的本地分支拉取更改到目标分支。这样，其他团队成员可以首先审查你的更改，并在满足所有约定标准时进行合并。其他人可以对你的更改进行评论或请求更新，然后再进行合并。这是强制执行*四眼原则*的最常见方式，适用于
    Git 的源代码管理。*四眼原则*规定，每个更改或操作都应该至少由两个人审查。
- en: When you are approving a pull request, there are different strategies you can
    use for generating the merge commit. The most commonly used are a merge commit,
    squash commit, or rebase.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你批准拉取请求时，你可以使用不同的策略来生成合并提交。最常用的策略有合并提交、压缩提交或变基提交。
- en: Merge commit
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并提交
- en: A regular **merge commit** is a type of commit that maintains visibility of
    all previous commits. It has a reference to two parents, showing both origins
    of the change, namely the source and target branch. This is the same type of merge
    as you can perform manually using a Git merge. The advantage of this type of commit
    is that it clearly shows where the new state of the target branch comes from.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的**合并提交**是一种保留所有先前提交可见性的提交类型。它引用了两个父提交，展示了更改的两个来源，即源分支和目标分支。这与你可以手动使用 Git
    合并执行的合并类型相同。此类型的提交的优点是，它清晰地显示了目标分支的新状态来自哪里。
- en: Squash commit
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩提交
- en: When performing a so-called **squash commit**, you are combining all of the
    individual commits from the source branch in one new commit. This is useful when
    all of the commits on the source branch relate to one feature and you want to
    keep a clear, concise change history on the target branch. This approach makes
    most sense when there are commits with bug fixes or clean-up operations on the
    source branch. The disadvantage is that you might lose the rationale for some
    incremental changes that were made on the source branch.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行所谓的**压缩提交**时，你将源分支中的所有单独提交合并为一个新的提交。这对于源分支上的所有提交都与一个功能相关，并且你希望在目标分支上保持清晰、简洁的更改历史时非常有用。当源分支上有修复bug或清理操作的提交时，这种方法最为合适。缺点是，你可能会失去一些源分支上增量更改的理由。
- en: Rebase
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变基
- en: '`master` branch are put aside for a bit. Meanwhile, all of the commits for
    which the `master` branch is ahead of your local branch are now merged into your
    local branch. Finally, all of your own commits that were set aside are now reapplied.
    The following diagram shows a branch before and after a rebase commit:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`master` 分支暂时被搁置。与此同时，`master` 分支超前于本地分支的所有提交现在会合并到本地分支。最后，所有被搁置的你自己的提交将被重新应用。以下图示展示了变基提交前后的分支状态：'
- en: '![Figure 4.5 – Rebasing ](img/B18655_04_05.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5 – 变基](img/B18655_04_05.jpg)'
- en: Figure 4.5 – Rebasing
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 – 变基
- en: After rebasing the source branch, it is now merged into `master`. The advantage
    of this kind of merge is that you retain all individual changes in one single
    commit history.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在变基源分支后，它现在被合并到`master`分支中。这种合并的优点是，你可以在一个提交历史中保留所有单独的更改。
- en: Managing repositories
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理仓库
- en: When working in Azure Repos, every team project can have a maximum of one TFVC
    repository. However, when working with Git, you can have multiple repositories
    in the same team project. A discussion that is gaining more attention lately is
    that of having a single repository for all applications or a repository per application.
    Other topics that are important when managing repositories are creating and removing
    repositories, securing them, and setting policies on them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Azure Repos时，每个团队项目最多只能有一个TFVC仓库。然而，在使用Git时，你可以在同一个团队项目中拥有多个仓库。最近越来越受到关注的讨论是，是否应该为所有应用程序使用单一仓库，还是每个应用程序使用一个仓库。管理仓库时，其他重要的话题包括创建和删除仓库、确保仓库安全以及为仓库设置策略。
- en: Monorepo or multi-repo
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单仓库或多仓库
- en: You use a **monolithic repository** (**monorepo**) when you store all of the
    code from all of your projects and applications in one single source control repository.
    Contrary to this, you might use multiple repositories where every application,
    library, or project is stored in its own repository. Both approaches have their
    own pros and cons, and both approaches are used by companies from small to large.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用**单体仓库**（**monorepo**）时，将所有项目和应用程序的代码存储在一个源代码控制仓库中。与此相对，你可能会使用多个仓库，其中每个应用程序、库或项目存储在自己的仓库中。这两种方法各有优缺点，且大小公司都会使用这两种方法。
- en: 'Possible advantages of a monorepo can include the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 单仓库的可能优势包括以下几点：
- en: 'Easier reuse of existing code: If all of the code is in a single repository,
    it is accessible and visible to everyone. This means that the chances of reuse
    are increased.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更容易重用现有代码：如果所有代码都在一个仓库中，那么每个人都可以访问和查看它。这意味着重用的机会增加。
- en: Having all applications in one repository also means that any change affecting
    more than one application can be made in a single commit in a single repository.
    A typical example is an API change.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有应用程序放在一个仓库中也意味着，任何影响多个应用程序的更改都可以在一个提交中进行，这样可以在一个仓库里完成。一个典型的例子是API更改。
- en: With all of the code being accessible to and maintained by everyone, there is
    less chance that a developer or team claims a specific repository as its own.
    This encourages learning from each other.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于所有代码都可以由每个人访问和维护，因此开发人员或团队声称某个特定仓库是自己的可能性较小。这鼓励大家互相学习。
- en: 'Disadvantages of mono repositories include the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 单仓库的缺点包括以下几点：
- en: A monorepo can become very, very large, even up to the point that developers
    checkout or clone only part of the monorepo. This effectively defeats most of
    the advantages of a monorepo.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单仓库可能会变得非常非常大，甚至到达开发人员只检出或克隆单个部分的程度。这实际上会消除单仓库的大部分优势。
- en: Having one repository with all of the code encourages tight coupling between
    components or applications. If you have multiple repositories, you could update
    an API and release it under a new version and upgrade clients one by one. In a
    monorepo, you might be tempted to upgrade the API and change all of the consumers
    in one commit, with all of the risks attached.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有代码集中在一个仓库中会促使组件或应用之间的紧耦合。如果你有多个仓库，可以更新 API 并以新版本发布，逐个升级客户端。在单一仓库中，你可能会被诱惑在一次提交中升级
    API 并更改所有消费者，带来所有相关的风险。
- en: Which approach works best for you is influenced not only by the advantages and
    disadvantages discussed but also by the background and makeup of your team and
    organization. If you have a single team doing all the development for internal
    applications, a monorepo might make more sense. If you have multiple teams working
    on different applications for different clients, multiple repositories make more
    sense.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种方法最适合你，受到的不仅是已讨论的优缺点的影响，还受到你团队和组织的背景及构成的影响。如果你有一个团队负责内部应用的所有开发，单一仓库可能更有意义。如果你有多个团队为不同客户开发不同的应用，多个仓库更合适。
- en: Creating and removing repositories
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和删除仓库
- en: 'In Azure DevOps, you can have multiple Git repositories per team project. Try
    doing the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure DevOps 中，每个团队项目可以有多个 Git 仓库。试着执行以下操作：
- en: 'First, visit the **Manage repositories** interface. The following screenshot
    shows how to access this interface:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，访问**管理仓库**界面。以下截图展示了如何访问此界面：
- en: '![Figure 4.6 – Managing repositories ](img/B18655_04_06.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 管理仓库](img/B18655_04_06.jpg)'
- en: Figure 4.6 – Managing repositories
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 管理仓库
- en: After opening this interface, a new interface (as shown in the following screenshot)
    opens up. Here, you can add new repositories by clicking on the **Add...** button
    with a plus sign ( refer to the vertical section next to the left navigation menu)
    and filling out a repository name.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开此界面后，新的界面（如下图所示）会弹出。在这里，你可以通过点击带有加号的**添加...**按钮（请参阅左侧导航菜单旁边的垂直部分）来添加新仓库，并填写仓库名称。
- en: 'Repositories can also be removed by clicking on their name and then **Delete
    repository** (marked with **2**; refer to the context menu shown for the repository
    name):'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也可以通过点击仓库名称，然后选择**删除仓库**（标记为**2**；请参阅仓库名称的上下文菜单）来删除仓库：
- en: '![Figure 4.7 – Deleting a repository ](img/B18655_04_07.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 删除仓库](img/B18655_04_07.jpg)'
- en: Figure 4.7 – Deleting a repository
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 删除仓库
- en: Removing repositories is not something that is often done. It might make more
    sense to make a no-longer-used repository read-only or remove all authorizations
    on it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 删除仓库并不是常做的事。将不再使用的仓库设置为只读或移除其所有授权，可能更有意义。
- en: Now, let’s learn how to secure the repositories that we create.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何保护我们创建的仓库。
- en: Securing repositories
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护仓库
- en: While the security options with distributed source control are often not as
    broad as with centralized source control, Azure Repos offers some means to set
    authorizations on a repository or a server-side branch. In the last figure of
    the previous section, you can also see how you can select a group or user in the
    middle column and then update the authorizations on the repository. By default,
    all authorizations are inherited from project defaults.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然分布式源代码管理的安全选项通常没有集中式源代码管理那么广泛，但 Azure Repos 提供了一些设置仓库或服务器端分支授权的方式。在上一节的最后一张图中，你还可以看到如何在中间列中选择一个组或用户，然后更新仓库的授权。默认情况下，所有授权都是从项目默认设置继承的。
- en: Tip
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It is recommended to only change authorizations as little as possible and if
    you do, it is often best to work via groups and allow authorizations.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 建议尽量减少更改授权的次数，如果确实需要更改，最好通过组进行操作并授权。
- en: You can also change the authorizations for a specific branch by opening the
    repository branches in the drop-down menu on the left and clicking on the branch
    you want to override the authorizations for. In the preceding screenshot, this
    is marked with `HenryBreen.RazorAnalysers` repository.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在左侧下拉菜单中打开仓库分支，点击你希望覆盖授权的分支来更改特定分支的授权。在之前的截图中，这是标记为`HenryBreen.RazorAnalysers`的仓库。
- en: Branch policies
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支策略
- en: 'Finally, it is possible to enforce one or more policies on pull requests to
    a specific branch. The interface for branch policies is shown in the following
    screenshot and can be accessed by choosing the **Branch policies** option while
    managing the authorizations on a repository branch:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以强制对特定分支的拉取请求应用一项或多项策略。分支策略的界面如下所示，可以通过在管理仓库分支的授权时选择**分支策略**选项来访问：
- en: '![Figure 4.8 – Branch policies ](img/B18655_04_08.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 分支策略](img/B18655_04_08.jpg)'
- en: Figure 4.8 – Branch policies
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 分支策略
- en: The first four checkboxes are related to default policies that can be enabled
    (or not) on your preference. By default, they are all disabled.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 前四个复选框与可以启用（或不启用）的默认策略相关。默认情况下，它们都处于禁用状态。
- en: '**Build validation** can be used to disallow the merge of any pull request
    if one or more of the select builds have not been completed successfully. How
    to set up such a build is something you will learn in the next chapter.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建验证**可以用于禁止合并任何拉取请求，如果选择的一个或多个构建未成功完成。如何设置这样的构建是你将在下一章中学习的内容。'
- en: Next to builds, you can also call external services to inspect the pull request
    and to allow or disallow it. An often used integration here is with a code quality
    tool. You might also call your own APIs here to enforce team agreements on things
    such as pull request titles, relation to work items, or more complex constraints.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了构建外，你还可以调用外部服务来检查拉取请求，并允许或拒绝它。这里经常使用的集成是与代码质量工具的集成。你也可以在这里调用自己的 API，以强制执行团队在诸如拉取请求标题、与工作项的关联或更复杂的约束等方面的约定。
- en: Finally, you can enforce that a specific user or group has to be included in
    the review of a pull request. This might be needed to enforce a specific level
    of quality, but it can also be a limiting factor in your development speed and
    flow.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以强制要求特定的用户或小组必须参与拉取请求的审查。这可能是为了确保特定的质量水平，但也可能成为限制你开发速度和流程的因素。
- en: Other tools for source control
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他源代码管理工具
- en: 'Next to the source control systems available in Azure Repos, there are also
    some other well-known systems that you should know about:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Azure Repos 中可用的源代码管理系统外，还有一些其他著名的系统，你应该了解它们：
- en: GitHub
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: GitLab
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab
- en: Subversion
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion
- en: We’ll go over each of these in the upcoming subsections.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的子章节中逐一讲解这些内容。
- en: GitHub
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub
- en: '**GitHub** is a hosted source control provider that delivers hosted Git repositories.
    GitHub allows anyone to create as many publicly visible repositories as they want.
    When you create private repositories that require three or more contributors,
    you must switch to a paid subscription.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitHub** 是一个托管的源代码管理提供商，提供托管的 Git 仓库。GitHub 允许任何人创建任意数量的公开可见仓库。当你创建需要三名或更多贡献者的私有仓库时，必须切换到付费订阅。'
- en: This model allows unlimited free usage of the platform if developing in public,
    which has made GitHub by far the largest host of open source software in the world.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是在公共开发中使用，该模型允许平台的无限制免费使用，这使得 GitHub 成为全球最大的开源软件托管平台。
- en: GitHub was acquired by Microsoft in 2018 and since then, Microsoft and GitHub
    have worked together to create a great integration experience between GitHub repositories
    and Azure DevOps, specifically with Azure Boards and Azure Pipelines. In addition
    to this, Microsoft has stated that GitHub and Azure Repos will continue to exist
    next to each other and that there are currently no plans to terminate one of the
    products in favor of the other.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 于 2018 年被微软收购，从那时起，微软和 GitHub 一起合作，创建了 GitHub 仓库与 Azure DevOps 之间的良好集成体验，特别是在
    Azure Boards 和 Azure Pipelines 上。除此之外，微软表示 GitHub 和 Azure Repos 将继续并存，目前没有计划为了一个产品而终止另一个产品。
- en: There is also an enterprise offering by GitHub called GitHub Enterprise, which
    comes with two deployment options, namely cloud-hosted and self-hosted (or on-premises).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 还提供了一个企业版，称为 GitHub Enterprise，提供两种部署选项，即云托管和自托管（或本地部署）。
- en: 'You can read more about the various GitHub products and pricing plans here:
    [https://docs.github.com/en/get-started/learning-about-github/githubs-products](https://docs.github.com/en/get-started/learning-about-github/githubs-products).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里阅读更多关于各种 GitHub 产品和定价计划的内容：[https://docs.github.com/en/get-started/learning-about-github/githubs-products](https://docs.github.com/en/get-started/learning-about-github/githubs-products)。
- en: 'The public roadmap for GitHub can be viewed here: [https://github.com/orgs/github/projects/4247/views/1](https://github.com/orgs/github/projects/4247/views/1).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 的公共路线图可以在这里查看：[https://github.com/orgs/github/projects/4247/views/1](https://github.com/orgs/github/projects/4247/views/1)。
- en: GitLab
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab
- en: GitLab is another platform that delivers hosted Git repositories. Just like
    Azure DevOps, source control hosting is one of the services it provides.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 是另一个提供托管 Git 仓库的平台。像 Azure DevOps 一样，源代码控制托管是它提供的服务之一。
- en: Subversion
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Subversion
- en: An older source control system is Subversion. Subversion was developed and first
    used in 2004 and is maintained by the Apache Software Foundation. Subversion is
    a centralized source control system that supports all the features that you would
    expect of such a system.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion 是一种较早的源代码控制系统。Subversion 开发并首次使用于 2004 年，由 Apache 软件基金会维护。Subversion
    是一种集中式源代码控制系统，支持你期望的所有功能。
- en: There are many false arguments as to why Subversion would be inferior to Git;
    however, most of them are not true for more recent versions of Subversion. The
    reality is that Subversion is a widely used type of source control system that
    performs well, especially for very large repositories, or repositories that have
    very specific authorization needs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为什么 Subversion 比 Git 更差的论点有很多是错误的；然而，大多数论点对新版 Subversion 并不适用。事实上，Subversion
    是一种广泛使用的源代码控制系统，特别适用于非常大的仓库或具有特定授权需求的仓库。
- en: While Azure DevOps cannot host Subversion repositories, it can connect to and
    work with sources that are stored in Subversion.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Azure DevOps 无法托管 Subversion 仓库，但它可以连接并与存储在 Subversion 中的源代码进行协作。
- en: Summary
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you have learned about source control. You saw that there
    are two types of source control: centralized and decentralized, both supported
    by Azure DevOps. TFVC is no longer recommended for new projects. You should use
    Git whenever starting a new project.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经了解了源代码控制。你了解到源代码控制有两种类型：集中式和分散式，Azure DevOps 都支持这两种类型。TFVC 不再推荐用于新项目。你应该在开始新项目时使用
    Git。
- en: When using Git, you can have more than one repository in your team project.
    For each repository, you can assign policies to lock down specific branches and
    enforce the four-eyes principle. You have also learned about access control, and
    how to provide users access to one or more repositories. Finally, you have learned
    about alternative tools, and how to migrate sources from one tool to the other.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Git 时，你可以在团队项目中拥有多个仓库。对于每个仓库，你可以分配策略来锁定特定分支，并强制执行四眼原则。你还学习了访问控制，如何为用户提供对一个或多个仓库的访问权限。最后，你了解了替代工具，并学会了如何将源代码从一种工具迁移到另一种工具。
- en: You can use what you have learned to make decisions on which type of source
    control system to use in your products. You can now professionally organize the
    repository or repositories you work in. You are now able to work with different
    branching strategies and use policies for enforcing security or quality requirements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用所学知识来决定在你的产品中使用哪种类型的源代码控制系统。你现在可以专业地组织你所工作的一个或多个仓库。你现在能够使用不同的分支策略，并使用策略来强制执行安全性或质量要求。
- en: The next chapter will take what you have learned about source control and use
    that to set up continuous integration.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将基于你学到的源代码控制知识，使用这些知识来设置持续集成。
- en: Questions
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结之前，这里有一份问题列表，供你测试自己对本章内容的掌握情况。你可以在*附录*的*评估*部分找到答案：
- en: What are the differences between centralized and decentralized source control,
    and which works best in what situation?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 集中式和分散式源代码控制有什么区别，在哪些情况下哪种方式更合适？
- en: True or false? Git is an example of decentralized source control.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断题：Git 是分散式源代码控制的一个例子，正确还是错误？
- en: Which of the following is not a common branching strategy?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪一项不是常见的分支策略？
- en: Release Flow
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发布流程
- en: Rebasing
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变基
- en: GitFlow
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitFlow
- en: GitHub Flow
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitHub Flow
- en: Many companies want a code review to be performed before code is merged into
    the `master` branch. What construct is used to do so when working with Git, and
    how can this be enforced in Azure DevOps?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 许多公司希望在代码合并到`master`分支之前进行代码审查。使用 Git 时，应该使用什么方法来完成此操作？如何在 Azure DevOps 中强制执行这一流程？
- en: Which of the following are not valid merge strategies?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些不是有效的合并策略？
- en: Rebasing
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变基
- en: Trunk-based development
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: Merge commit
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 合并提交
- en: Squash commit
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压缩提交
- en: Exercises
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Prerequisite reading: [https://docs.microsoft.com/en-us/azure/devops/boards/best-practices-agile-project-management.](https://docs.microsoft.com/en-us/azure/devops/boards/best-practices-agile-project-management%20)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前提阅读：[https://docs.microsoft.com/zh-cn/azure/devops/boards/best-practices-agile-project-management](https://docs.microsoft.com/en-us/azure/devops/boards/best-practices-agile-project-management%20)
- en: 'Create your first team project, and name it `PacktBookLibrary`. Apply other
    settings as per the following screenshot:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个团队项目，并将其命名为`PacktBookLibrary`。按以下截图设置其他配置：
- en: '![Figure 4.9 – Create a new team project ](img/B18655_04_09.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 创建一个新的团队项目](img/B18655_04_09.jpg)'
- en: Figure 4.9 – Create a new team project
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 创建一个新的团队项目
- en: 'Once the `PacktBookLibrary` team project has been created, using the left navigation,
    go to `Product-Backlog` within `Product-Backlog` query in a hierarchical manner:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦`PacktBookLibrary`团队项目创建完成，使用左侧导航，按照层次结构进入`Product-Backlog`，在`Product-Backlog`查询中：
- en: '![Figure 4.10 – Query editor ](img/B18655_04_10.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – 查询编辑器](img/B18655_04_10.jpg)'
- en: Figure 4.10 – Query editor
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – 查询编辑器
- en: Using the **Column options** section within the **Editor** view, choose columns
    (Stack Rank, .. ) and **Sorting** on **Stack Rank**:![Figure 4.11 – Add columns
    and apply sorting ](img/B18655_04_11.jpg)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**编辑器**视图中的**列选项**部分，选择列（堆栈排名等）并在**堆栈排名**上进行**排序**：![图 4.11 – 添加列并应用排序](img/B18655_04_11.jpg)
- en: Figure 4.11 – Add columns and apply sorting
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 添加列并应用排序
- en: 'Add an initial Product Backlog (Epics and Features) as shown in the following
    screenshot:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个初始的产品待办事项（史诗和特性），如以下截图所示：
- en: '![Figure 4.12 – DevOps feature list ](img/B18655_04_12.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – DevOps 特性列表](img/B18655_04_12.jpg)'
- en: Figure 4.12 – DevOps feature list
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – DevOps 特性列表
- en: The goal here is to track the implementation of the important DevOps practices
    through the same product backlog so that those are included during the work planning
    and prioritization process. Eventually, it is the same set of team members who
    will work on implementing these practices as well.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标是通过相同的产品待办事项跟踪重要的DevOps实践的实施，以便在工作规划和优先级设置过程中将其纳入其中。最终，实施这些实践的将是同一组团队成员。
- en: 'You can either configure a new Git repository to start adding your code or
    import code from an existing Git repository. The starter code for the `PacktBookLibrary`
    solution is available here: https://github.com/PacktPublishing/Exam-Guide-AZ-400-Designing-and-Implementing-Microsoft-DevOps-Solutions.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以配置一个新的 Git 仓库开始添加代码，或者从现有 Git 仓库导入代码。`PacktBookLibrary`解决方案的起始代码可以在这里找到：https://github.com/PacktPublishing/Exam-Guide-AZ-400-Designing-and-Implementing-Microsoft-DevOps-Solutions。
- en: 'The dialog in the following screenshot is shown when you import an existing
    repository:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入现有仓库时，以下截图中的对话框会显示出来：
- en: '![Figure 4.13 – Import a Git repository ](img/B18655_04_13.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 导入 Git 仓库](img/B18655_04_13.jpg)'
- en: Figure 4.13 – Import a Git repository
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 导入 Git 仓库
- en: Once the code has been imported, you should be able to view the code files within
    the repository.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦代码被导入，你应该能够在仓库中查看到代码文件。
- en: 'Configure branch policies for the `main` branch in the repository within the
    following settings:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在以下设置中，为仓库中的`main`分支配置分支策略：
- en: Turn on (use the toggle button) **Require minimum number of reviewers**. Set
    the minimum reviewer count as **1**.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开（使用切换按钮）**要求最低数量的审阅者**。将最低审阅者数量设置为**1**。
- en: Turn on (use the toggle button) **Check for linked work items** to **Required**.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开（使用切换按钮）**检查关联工作项**，设置为**必需**。
- en: Turn on **Limit merge types**. Select **Squash merge** as the only option from
    the allowed merge types list.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开**限制合并类型**。从允许的合并类型列表中选择**Squash 合并**作为唯一选项。
- en: Clone the `PacktBookLibrary` repository (the `main` branch) to a local folder
    within your workstation.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`PacktBookLibrary`仓库（`main`分支）克隆到你工作站中的本地文件夹。
- en: Check out the source code by creating a branch off `main`, and then start using
    it for making commits. Periodically plan to raise a `PULL` request to merge your
    changes with the `main` branch.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过从`main`分支创建一个分支来检出源代码，然后开始使用它进行提交。定期计划发起`PULL`请求，以将更改合并到`main`分支中。
- en: After completing the steps mentioned in the exercise list, your source control
    repository will be set up. We will build upon this foundation in the next chapters
    through exercises.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 完成练习列表中的步骤后，你的源代码控制仓库将被设置好。我们将在接下来的章节中通过练习在此基础上进行拓展。
- en: Further reading
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More information about working with Git can be found at [https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/](https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Git的更多使用信息可以在[https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/](https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/)找到。
- en: The original Microsoft advice on TFVC versus Git can be found at [https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devopsviewFallbackFrom=vsts](https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devopsviewFallbackFrom=vsts).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于TFVC与Git的原始Microsoft建议可以在[https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devopsviewFallbackFrom=vsts](https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devopsviewFallbackFrom=vsts)找到。
- en: More information about Git LFS can be found at [https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops).
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Git LFS的更多信息可以在[https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops)找到。
- en: Instructions for downloading Git LFS can be found at [https://git-lfs.github.com/](https://git-lfs.github.com/).
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载Git LFS的说明可以在[https://git-lfs.github.com/](https://git-lfs.github.com/)找到。
- en: More information about migrating to Git can be found at [https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops).
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于迁移到Git的更多信息可以在[https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops)找到。
- en: An Atlassian tool for converting an SVN repository to a local Git repository
    can be found at [https://www.atlassian.com/git/tutorials/migrating-convert](https://www.atlassian.com/git/tutorials/migrating-convert).
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于将SVN仓库转换为本地Git仓库的Atlassian工具可以在[https://www.atlassian.com/git/tutorials/migrating-convert](https://www.atlassian.com/git/tutorials/migrating-convert)找到。
- en: More information about GitFlow can be found at [https://datasift.github.io/gitflow/IntroducingGitFlow.xhtml](https://datasift.github.io/gitflow/IntroducingGitFlow.xhtml).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于GitFlow的更多信息可以在[https://datasift.github.io/gitflow/IntroducingGitFlow.xhtml](https://datasift.github.io/gitflow/IntroducingGitFlow.xhtml)找到。
- en: More information about GitHub Flow can be found at [https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/).
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于GitHub Flow的更多信息可以在[https://guides.github.com/introduction/flow/](https://guides.github.com/introduction/flow/)找到。
- en: Release Flow is described in more detail at [https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow](https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow).
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Release Flow的详细描述可以在[https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow](https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow)找到。
- en: Trunk-based development is discussed at [https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/).
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Trunk-based开发的讨论可以在[https://trunkbaseddevelopment.com/](https://trunkbaseddevelopment.com/)找到。
- en: More information about GitLab can be found at [https://about.gitlab.com/](https://about.gitlab.com/).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于GitLab的更多信息可以在[https://about.gitlab.com/](https://about.gitlab.com/)找到。
- en: More information about Subversion can be found at [https://subversion.apache.org/docs/](https://subversion.apache.org/docs/).
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Subversion的更多信息可以在[https://subversion.apache.org/docs/](https://subversion.apache.org/docs/)找到。
