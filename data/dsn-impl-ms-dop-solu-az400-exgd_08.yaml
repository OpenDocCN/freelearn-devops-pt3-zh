- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Implement Infrastructure and Configuration as Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基础设施和配置作为代码
- en: In the previous chapter, the focus was on storing and building application code
    and releasing the created binaries. You learned how to create a pipeline, from
    source control to a target environment, for the automated, repeatable deployment
    of your applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，重点是存储和构建应用程序代码并发布生成的二进制文件。你学习了如何创建一个管道，从源代码控制到目标环境，用于自动化、可重复的应用程序部署。
- en: In this chapter, you will learn how to apply the same principles to the infrastructure
    that your application runs on and the runtime configuration of your application.
    Doing so will help you to further increase the speed at which changes can be delivered
    to production, increasing the flow of value to your end users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何将相同的原则应用于你的应用程序所运行的基础设施和应用程序的运行时配置。这样做将帮助你进一步提高将更改交付到生产环境的速度，增加价值流向最终用户。
- en: This chapter will start off by explaining the value of having everything, infrastructure
    and configuration included, as code. After that, it continues by explaining **Azure
    Resource Manager** (**ARM**) templates. The syntax will be explained, as well
    as how to deploy ARM templates. Then, it proceeds to explain the Azure Automation
    offering, available in the Azure cloud. Azure Automation can be used to run scripts
    on a schedule or load and apply PowerShell DSC modules. Next up is managing application
    settings for PaaS offerings, such as Azure App Service. Finally, it concludes
    by discussing several other tools that have similar capabilities.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将首先解释将一切（包括基础设施和配置）作为代码的价值。之后，将继续解释**Azure 资源管理器**（**ARM**）模板。将解释其语法，以及如何部署
    ARM 模板。接下来，介绍 Azure Automation 服务，它可在 Azure 云中使用。Azure Automation 可以用于按计划运行脚本或加载并应用
    PowerShell DSC 模块。接下来是管理 PaaS 产品（如 Azure 应用服务）的应用程序设置。最后，讨论其他具有类似功能的工具。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Having everything as code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一切作为代码
- en: Working with ARM templates
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ARM 模板
- en: Deploying ARM templates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署 ARM 模板
- en: Reverse engineering a template
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向工程一个模板
- en: Using Azure Automation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure Automation
- en: Managing application settings
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理应用程序设置
- en: Other tools
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他工具
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To experiment with one or more of the technologies described in this chapter,
    one or more of the following may be required:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验本章中描述的一个或多个技术，可能需要以下一项或多项：
- en: An Azure subscription, for executing ARM templates and running Azure Automation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Azure 订阅，用于执行 ARM 模板和运行 Azure Automation
- en: PowerShell with the Azure PowerShell modules, for executing ARM templates, available
    from [https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-7.3.0](https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-7.3.0)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure PowerShell 模块的 PowerShell，用于执行 ARM 模板，模块可从[https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-7.3.0](https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-7.3.0)获取
- en: The Azure CLI, for executing ARM templates, available from https://docs.microsoft.com/en-us/cli/azure/
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure CLI 执行 ARM 模板，可从 https://docs.microsoft.com/en-us/cli/azure/ 获取
- en: Having everything as code
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切作为代码
- en: If you have been responsible for creating and maintaining application infrastructure
    and configuration in the past, you have most likely experienced what is called
    **configuration drift**. Configuration drift is the name for the phenomenon where
    the configuration between servers in acceptance and the production environment
    differs. Or, even worse, when having multiple servers in the production environment,
    it might be the case that the configuration of these is not always the same.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾负责创建和维护应用程序的基础设施和配置，你很可能经历过所谓的**配置漂移**。配置漂移是指接收环境与生产环境中的服务器配置不同的现象。更糟糕的是，当生产环境中有多台服务器时，它们的配置可能并不总是相同。
- en: The most common cause of configuration drift is manual change. When making changes
    manually, maybe under the pressure of a production issue, there is always the
    risk that you apply different settings to different servers or hosts. If you ever
    need to scale out and add another server to your production environment, the chance
    of that server taking on the same configuration as all already-existing servers
    is very slim.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 配置漂移的最常见原因是手动更改。当手动更改时，可能在生产问题的压力下，始终存在将不同的设置应用于不同服务器或主机的风险。如果你需要扩展并添加另一个服务器到生产环境中，那么这个服务器与所有已有服务器具有相同配置的可能性非常小。
- en: Tip
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Declarative (functional) and imperative (procedural) are two of the main approaches
    adopted to implement **Infrastructure as Code** (**IaC**) and **Configuration
    as Code** (**CaC**).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式（函数式）和命令式（过程式）是实现**基础设施即代码**（**IaC**）和**配置即代码**（**CaC**）的两种主要方法。
- en: With IaC and CaC, you no longer make changes to application configuration and
    infrastructure manually, but through automation. The first step to do this is
    specifying the desired state of configuration and infrastructure. The desired
    state is then fed into configuration management tooling that enforces this configuration
    on your infrastructure. Specifying only the desired state is called a *declarative*
    approach, which differs from an *imperative* approach, where you specify all of
    the steps that need to be taken.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IaC 和 CaC，你不再手动更改应用程序配置和基础设施，而是通过自动化来进行。实现这一点的第一步是指定所需的配置和基础设施状态。然后，将所需状态输入到配置管理工具中，强制执行此配置到你的基础设施上。仅指定所需状态被称为*声明式*方法，它不同于*命令式*方法，在命令式方法中，你需要指定所有需要采取的步骤。
- en: Some of these tools are often also capable of checking the current state of
    your infrastructure and configuration at regular intervals and reapplying your
    desired state if any deviation is detected. This is possible due to the declarative
    approach. This makes applying configuration an idempotent operation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些工具通常也能够定期检查你基础设施和配置的当前状态，并在检测到任何偏差时重新应用你所需的状态。这是由于声明式方法的缘故。这使得应用配置成为一个幂等操作。
- en: Tip
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: An operation is idempotent if it can be repeated one or more times, while the
    outcome remains the same.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个操作是幂等的，如果它可以重复执行一次或多次，而结果保持不变。
- en: When adopting IaC and CaC, you can even go so far as to recreate the complete
    infrastructure before deploying an application, deploy the application on that
    new infrastructure, and then disregard the old infrastructure after switching
    to the new deployment. This is an extreme form of immutable servers. The added
    benefit of this approach is that you are now guaranteed that there will be no
    traces from any configuration or binaries from the previous deployment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在采用 IaC 和 CaC 时，你甚至可以重建完整的基础设施，然后再部署应用程序，将应用程序部署到新的基础设施上，切换到新的部署后再丢弃旧的基础设施。这是一种极端的不可变服务器形式。这种方法的额外好处是，你现在可以确保不会留下任何来自之前部署的配置或二进制文件的痕迹。
- en: In the following sections, you will learn about different IaC technologies and
    how to use them. It is important to understand that they are complementary and
    are often used together. For example, ARM templates can be used to create virtual
    machines in Azure and, once that is done, PowerShell DSC or Ansible can be used
    to configure those virtual machines.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将了解不同的基础设施即代码（IaC）技术以及如何使用它们。理解它们是互补的，并且常常一起使用非常重要。例如，ARM 模板可用于在 Azure
    中创建虚拟机，一旦完成，PowerShell DSC 或 Ansible 可用于配置这些虚拟机。
- en: Working with ARM templates
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ARM 模板
- en: 'When working on the Azure platform, infrastructure is described using ARM templates.
    ARM templates are written in JSON, and a skeleton template looks as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 平台上工作时，基础设施是通过 ARM 模板来描述的。ARM 模板是用 JSON 编写的，一个骨架模板如下所示：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The template itself is, at the highest level, a JSON object. There is a mandatory
    property, `$schema`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 模板本身在最高层次上是一个 JSON 对象。它有一个必填属性，`$schema`。
- en: '`$schema` is a required element and the value version number depends on the
    scope of the deployment and the JSON editor. The `contentVersion` property is
    also required and can be specified to version the contents. This version can be
    used by the author to version the template if necessary.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`$schema` 是一个必需元素，值的版本号取决于部署的范围和 JSON 编辑器。`contentVersion` 属性也是必需的，可以指定以对内容进行版本控制。这个版本号可由作者在必要时对模板进行版本控制。'
- en: The rest of this chapter will discuss the different parts that make up ARM templates
    in more detail. You will find a link to the online documentation at the end of
    this chapter. A link to a formal, detailed breakdown of the structure and syntax
    of ARM templates is also provided at the end of this chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将更详细地讨论构成 ARM 模板的不同部分。在本章的末尾，你会找到指向在线文档的链接。也会提供一个正式、详细的 ARM 模板结构和语法解析链接。
- en: Parameters
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数
- en: The parameters section is usually near the top of the template. Before beginning
    deployment activities, ARM will resolve the parameter values. The resolved value
    is referenced whenever the parameter is found in the template by ARM.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 参数部分通常位于模板的顶部。在开始部署活动之前，ARM 将解析参数值。每当在模板中找到该参数时，ARM 会引用解析后的值。
- en: 'This section takes the form of a JSON object, which can be empty but cannot
    be left out. The use of this section is to declare one or more parameters that
    can be specified by the caller of the ARM template before deploying it. A common
    reason for using the parameters section is to use the same template for both the
    test and production environments but vary the names of resources between the two.
    An example parameters section might look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的形式是一个 JSON 对象，可以为空，但不能省略。此部分的作用是声明一个或多个在部署 ARM 模板之前由调用者指定的参数。使用参数部分的常见原因是将同一个模板用于测试和生产环境，但在两者之间变化资源的名称。一个参数部分的示例可能如下所示：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For every parameter, a new key is specified with the parameter’s name. The value
    is an object. This object has one mandatory key, `type`. The allowed values for
    `type` are `string`, `int`, `bool`, `object`, `array`, `secureString`, and `secureObject`.
    The `secureString` and `secureObject` variations can be used to make sure that
    the runtime values of these parameters are scrubbed from any log and output. They
    are intended to hold passwords, keys, or other secrets.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个参数，都会指定一个新的键作为参数的名称。值是一个对象。这个对象有一个必填键 `type`。`type` 的允许值有 `string`、`int`、`bool`、`object`、`array`、`secureString`
    和 `secureObject`。`secureString` 和 `secureObject` 类型可以用来确保这些参数的运行时值不会出现在任何日志和输出中。它们用于存储密码、密钥或其他机密信息。
- en: The `metadata` object, with the `description` key, is optional and can be used
    to add a description to the parameter for future reference.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata` 对象，包含 `description` 键，是可选的，可以用来为参数添加描述，以供将来参考。'
- en: 'Other properties that can be specified on a parameter object are the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在参数对象上指定的其他属性如下：
- en: '`minValue` and `maxValue` for specifying bounds on an integer value'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minValue` 和 `maxValue` 用于指定整数值的范围。'
- en: '`minLength` and `maxLength` for specifying bounds on the length of a string
    value'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minLength` 和 `maxLength` 用于指定字符串值的长度范围。'
- en: '`defaultValue` for specifying a default value that will be used if no value
    is specified when applying the template'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultValue` 用于指定默认值，如果在应用模板时未指定值，则使用此默认值。'
- en: '`allowedValues` for specifying an array of allowed values, limiting valid inputs'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowedValues` 用于指定一个允许值的数组，从而限制有效的输入。'
- en: Next, let’s understand what parameter files are.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解什么是参数文件。
- en: Parameter files
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数文件
- en: 'You can make use of a JSON file that contains the parameter values instead
    of specifying them as inline values in your script. In this section, we will discuss
    how to use parameter files to use with the templates. Often, a single template
    is accompanied by more than one parameter file, for example, one for test and
    one for production. The JSON for a parameter file appears as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用包含参数值的 JSON 文件，而不是在脚本中将它们作为内联值指定。在本节中，我们将讨论如何使用参数文件来配合模板使用。通常，一个模板会配有多个参数文件，例如，一个用于测试，一个用于生产。参数文件的
    JSON 可能如下所示：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just like an ARM template, every parameter file is a JSON object with mandatory
    `$schema` and `contentVersion` properties. The third property parameter is used
    to specify one or more parameter values. For each parameter, specify its name
    as the key and an object as the value. This object can hold the `value` key for
    providing the actual value of the parameter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ARM 模板类似，每个参数文件都是一个包含必填 `$schema` 和 `contentVersion` 属性的 JSON 对象。第三个属性参数用于指定一个或多个参数值。对于每个参数，指定其名称作为键，值为一个对象。该对象可以包含
    `value` 键，用于提供参数的实际值。
- en: While very valuable for specifying names for resources, scaling options, and
    other things that have to vary between environments, this solution is not useful
    for secrets.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对于指定资源名称、扩展选项以及在不同环境之间必须变化的其他内容非常有用，但此解决方案对机密无用。
- en: 'The following diagram shows how the parameter file references the secret and
    passes that value to the template:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了参数文件如何引用密钥并将该值传递给模板：
- en: '![Figure 8.1 – Using secrets in an Azure template ](img/B18655_08_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 在 Azure 模板中使用密钥](img/B18655_08_01.jpg)'
- en: Figure 8.1 – Using secrets in an Azure template
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 在 Azure 模板中使用密钥
- en: 'Keys, passwords, and other secrets should not be stored as plaintext in source
    control in a parameter file. For secrets, another notation is available:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥、密码和其他机密不应作为明文存储在源控制的参数文件中。对于机密，提供了另一种表示法：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this notation, instead of specifying the value directly, there is a pointer
    to a location in an Azure key vault where the correct value is stored. When deploying
    the template, this secret is (within Azure!) taken from the key vault and used
    in deployment. This is allowed only if the user or service starting the deployment
    has either an owner or contributor role in relation to the key vault, and the
    key vault is enabled for template deployment.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种表示法时，代替直接指定值，会指向 Azure 密钥保管库中存储正确值的位置。在部署模板时，该密钥（在 Azure 内！）将从密钥保管库中提取并用于部署。仅当启动部署的用户或服务在密钥保管库中具有所有者或贡献者角色，并且该密钥保管库已启用模板部署时，才允许这样做。
- en: Important Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Strictly speaking, any role that includes the `Microsoft.KeyVault/vaults/deploy/action`
    permission will work. By default, these are the owner and contributor roles, but
    you can create custom roles that include this action as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，任何包含 `Microsoft.KeyVault/vaults/deploy/action` 权限的角色都能正常工作。默认情况下，这些角色是所有者和贡献者角色，但你也可以创建自定义角色，其中包含此操作。
- en: Variables
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'The variables section is used to specify one or more values that will be used
    throughout the template. A common approach is building the names of all resources
    in the variables section, based on a single parameter called `environmentName`.
    This ensures that resources will have the same name between environments. Variables
    are also used to specify values that cannot be specified from outside the template
    but should be recognized as configurable. An example might look like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 变量部分用于指定一个或多个将在整个模板中使用的值。一种常见方法是在变量部分根据一个名为 `environmentName` 的参数构建所有资源的名称。这样可以确保资源在不同环境中具有相同的名称。变量还用于指定那些无法从模板外部指定但应被视为可配置的值。例如，可能如下所示：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Please note that the example for `appServiceName` contains functions, which
    are discussed in the next section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`appServiceName` 示例中包含了函数，接下来会在下一节中讨论。
- en: Functions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'Functions are used to allow the dynamic evaluation of properties in ARM templates.
    Calling functions uses a notation very similar to that of many programming languages:
    `functionName(arg1, arg2, …)`. Functions can return either a value, such as `string`
    or `int,` or an object or array.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 函数用于在 ARM 模板中动态评估属性。调用函数使用的语法与许多编程语言非常相似：`functionName(arg1, arg2, …)`。函数可以返回一个值，例如
    `string` 或 `int`，也可以返回一个对象或数组。
- en: 'When an object is returned, any property can be accessed using the `.propertyName`
    notation. Accessing elements in an array can be done using `[index]`. To indicate
    which parts of a string should be evaluated as a function, they must be enclosed
    in brackets:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回一个对象时，可以使用 `.propertyName` 语法访问任何属性。访问数组中的元素可以使用 `[index]`。要指示字符串的哪些部分应作为函数进行评估，它们必须包含在括号中：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding section shows two examples of functions. In the first, the `concat`
    function is called to concatenate two string values. One is hardcoded and the
    other one is the result of a second function call to retrieve the value of a template
    parameter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节展示了两个函数的示例。在第一个示例中，调用了 `concat` 函数来连接两个字符串值，一个是硬编码的，另一个是第二个函数调用的结果，用于获取模板参数的值。
- en: There are a fair number of functions available. They can be used for string
    manipulation, retrieving details about the current subscription, resource group,
    or **Azure Active Directory** (**AAD**) tenant, or getting resource details.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的函数。这些函数可以用于字符串操作、获取当前订阅、资源组或**Azure Active Directory**（**AAD**）租户的详细信息，或者获取资源详细信息。
- en: Functions can also be used to retrieve account keys or other secrets. This is
    often done to automatically insert keys directly from the service that exposes
    the key to the application settings or a key vault. This eliminates the need for
    the manual transfer of secrets. Variables and functions can help make your templates
    easier to maintain.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以用于检索帐户密钥或其他秘密。这通常用于自动将密钥直接从服务插入到应用设置或密钥保管库中。这样可以消除手动传输密钥的需求。变量和函数可以帮助简化模板的维护。
- en: You can also add your own functions to your template. These functions can be
    used in your template. User-defined functions exist independently of regular template
    functions. In most cases, you define complex expressions that you don’t want to
    repeat throughout your template.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以向模板中添加自己的函数。这些函数可以在模板中使用。用户定义的函数独立于常规模板函数。在大多数情况下，你定义了复杂的表达式，不希望在整个模板中重复这些表达式。
- en: Comments and metadata
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释和元数据
- en: An ARM template can contain sections that aren’t related to the JSON language
    itself. You have a few options to add comments and metadata.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 ARM 模板可以包含与 JSON 语言本身无关的部分。你有几种方法可以添加注释和元数据。
- en: Comments
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: 'To comment the rest of a line, `//` is used, or to comment a block, the `/*
    */` notation is used. This makes the following snippets both valid as part of
    an ARM template:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要注释一行的其余部分，可以使用 `//`，或者要注释一个块，则使用 `/* */` 注释方式。这样，以下代码片段在 ARM 模板中都是有效的：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another deviation from JSON is that ARM templates allow for a multiline string.
    You can break a string into multiple lines. See the `location` property in the
    preceding example.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与 JSON 不同的地方是，ARM 模板允许使用多行字符串。你可以将字符串分成多行。请参见前面示例中的 `location` 属性。
- en: In the preceding example, you will notice the use of comments and metadata in
    your templates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你会注意到在模板中使用了注释和元数据。
- en: Important Note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: To deploy templates with multiline strings and comments, use Azure PowerShell
    or the Azure CLI. For the CLI, use version 2.3.0 or later, and specify the `--handle-extended-json-format` switch.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署包含多行字符串和注释的模板，可以使用 Azure PowerShell 或 Azure CLI。对于 CLI，请使用版本 2.3.0 或更高版本，并指定
    `--handle-extended-json-format` 开关。
- en: metadata
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据
- en: Text you add to a metadata description is automatically used as a tip for that
    parameter. ARM will ignore the `metadata` object, and this can be added anywhere
    in the template.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你添加到元数据描述中的文本会自动用作该参数的提示。ARM 会忽略 `metadata` 对象，并且可以在模板中的任何位置添加它。
- en: Resources
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: 'Resources are the main part of the template, where all of the resources to
    be created are specified. This section is the only one that is not an object,
    but an array. Within that array, one or more objects of the following form are
    specified:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 资源是模板的主要部分，在这里会指定要创建的所有资源。这个部分是唯一一个不是对象，而是数组的部分。在这个数组中，会指定一个或多个如下形式的对象：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each resource is specified in the form of an object. The first four properties
    are mandatory for every type of resource:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源都是以对象的形式指定的。前四个属性是每种类型资源的必填项：
- en: The type of the resource to be created or updated needs to be specified. This
    takes the form of the name of `resourceprovider` followed by a slash and the name
    of a resource type that belongs to that `resourceprovider`.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要指定要创建或更新的资源类型。这采用 `resourceprovider` 的名称，后跟一个斜杠和该 `resourceprovider` 下的资源类型名称。
- en: 'The version of the REST API to use for this resource: A list of supported API
    versions can be retrieved from [https://docs.microsoft.com/en-us/azure/templates/microsoft.resources/allversions](https://docs.microsoft.com/en-us/azure/templates/microsoft.resources/allversions).'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用此资源的 REST API 版本：可以从 [https://docs.microsoft.com/en-us/azure/templates/microsoft.resources/allversions](https://docs.microsoft.com/en-us/azure/templates/microsoft.resources/allversions)
    获取支持的 API 版本列表。
- en: 'The name for the resource: Every resource type has its own rules for determining
    what a valid name is. These can also available in the reference link shared in
    preceding point.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的名称：每种资源类型都有其自己的规则来确定有效名称。这些规则也可以在前述参考链接中获取。
- en: Many resources will need to have a location. If the resources require a location,
    you must specify one for each resource. The location does not have to be the same
    as the location of the resource group. The location must be a valid Azure region.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多资源需要指定位置。如果资源需要位置，则必须为每个资源指定一个位置。该位置不需要与资源组的位置信息相同。该位置必须是有效的 Azure 区域。
- en: All other properties on the object vary from resource type to resource type
    and are all specified in the resource.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对象上的所有其他属性因资源类型而异，且都在资源中指定。
- en: Dependent resources
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖资源
- en: A special type of resource is the dependent resource. For example, SQL databases
    are hosted on SQL Server and Service Bus topics are located within a Service Bus
    namespace.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊类型的资源是依赖资源。例如，SQL 数据库托管在 SQL Server 上，服务总线主题位于服务总线命名空间内。
- en: 'For a nested resource type, the type and name reflect this nesting. The following
    example shows the explicit dependency of Service Bus topics on a Service Bus namespace:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌套资源类型，类型和名称反映了这种嵌套关系。以下示例展示了服务总线主题对服务总线命名空间的显式依赖：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next to nesting the type and the name, the extra property, `dependsOn`, is also
    mandatory to specify that this nested resource can only be created after the containing
    resource exists. A `location` property is not necessary since this will be inherited
    from the containing resource.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了嵌套类型和名称外，还需要额外的属性`dependsOn`，以指定该嵌套资源只能在包含资源存在之后创建。由于此属性会从包含资源继承，因此不需要`location`属性。
- en: 'The following sample depicts a logical dependency between Azure SQL Server
    and Azure SQL Database. When the `dependson` property is utilized, an explicit
    deployment dependency between a child resource and the parent resource is established
    automatically. The child resource will be deployed after the parent resource.
    Here, you will notice the use of the built-in important `resourceID` function.
    The `resourceID` function returns the unique identifier of a resource:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 Azure SQL Server 与 Azure SQL Database 之间的逻辑依赖关系。当使用`dependsOn`属性时，子资源与父资源之间的显式部署依赖关系会自动建立。子资源会在父资源之后部署。在这里，你会注意到使用了内置的重要`resourceID`函数。`resourceID`函数返回资源的唯一标识符：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Important Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: A **circular dependency** is a problem with dependency order, resulting in the
    deployment running in a loop, unable to continue and complete the deployment.
    ARM identifies circular dependencies during template validation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环依赖**是一个依赖顺序问题，导致部署在循环中运行，无法继续并完成部署。ARM 在模板验证过程中会识别出循环依赖。'
- en: Nested templates
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套模板
- en: 'A second special type of resource is template deployment. This way, one template
    can trigger the deployment of another. An example of defining a template deployment
    as a resource in a template looks as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种特殊类型的资源是模板部署。通过这种方式，一个模板可以触发另一个模板的部署。以下是将模板部署定义为模板中的资源的示例：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The locations of the template and parameter file can be specified using both
    HTTP and HTTPS, that is, with a valid **Uniform Resource Identifier** (**URI**),
    but have to be publicly accessible locations. Although the template URI needs
    to be accessed externally, we would like to enable security and restrict access
    for these templates. To gain access during deployment, append an SAS token to
    the template file URI As an alternative, a single property template can be specified.
    This should then contain a whole template as a JSON object. However, you can’t
    use both inline parameters and a link to a parameter file.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 模板和参数文件的位置可以使用 HTTP 和 HTTPS 来指定，即使用有效的**统一资源标识符**（**URI**），但必须是公开可访问的位置。尽管模板
    URI 需要外部访问，但我们希望为这些模板启用安全性并限制访问。为了在部署期间获得访问权限，可以将 SAS 令牌附加到模板文件的 URI。作为替代方案，可以指定一个单独的属性模板，模板内容应为整个模板的
    JSON 对象。然而，不能同时使用内联参数和链接到参数文件。
- en: Outputs
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出
- en: The next section of a template is the outputs section. Here are the keys returned
    to the caller of the template. The caller can use these values to start another
    task or script and use one or more of the values created or used by the template.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的下一个部分是输出部分。这里是返回给模板调用者的键。调用者可以使用这些值来启动另一个任务或脚本，并使用模板创建或使用的一个或多个值。
- en: 'The main use for this is to prevent hardcoding names and other dynamic values,
    especially IPs, in downstream automation. The outputs section is a JSON object
    of the following format:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的主要目的是避免在下游自动化中硬编码名称和其他动态值，尤其是 IP 地址。输出部分是以下格式的 JSON 对象：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When specifying outputs, the same types can be used as for parameters. Of course,
    it does not make much sense hardcoding the values, so functions are used to retrieve
    values from parameters, variables, or even created resources.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定输出时，可以使用与参数相同的类型。当然，硬编码这些值没有太大意义，因此通常使用函数从参数、变量或甚至创建的资源中获取值。
- en: 'To continue with the previous example in the *Dependent resources* section
    for creating a SQL server, a sample of the output would be as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一节中关于创建 SQL 服务器的*Dependent resources*部分的示例，输出样本如下：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output would be as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Well, so far, we have learned about the different parts that make up an ARM
    template, which you should be able to write on your own. Now it’s time to learn
    how we can deploy them with the help of various tools.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了组成 ARM 模板的不同部分，您应该能够自己编写它们。现在是时候学习如何通过各种工具来部署它们了。
- en: Deploying ARM templates
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 ARM 模板
- en: Once an ARM template and its accompanying parameter files are written, they
    can be applied to an Azure environment. There are PowerShell cmdlet and Azure
    CLI commands available for applying an ARM template from a scripting environment.
    When ARM templates are used for the infrastructure of an application, Azure Pipelines
    can be used for deploying not only code but also ARM templates. Other alternatives
    for deploying templates in Azure include the Azure portal, Azure CLI, REST API,
    and Azure Cloud Shell or ARM template specs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编写了 ARM 模板及其相应的参数文件，它们可以应用于 Azure 环境。有 PowerShell cmdlet 和 Azure CLI 命令可用于从脚本环境应用
    ARM 模板。当 ARM 模板用于应用程序的基础设施时，Azure Pipelines 可用于部署不仅仅是代码，还有 ARM 模板。在 Azure 中部署模板的其他替代方法包括
    Azure 门户、Azure CLI、REST API、Azure Cloud Shell 或 ARM 模板规格。
- en: Whatever deployment method is used (REST API, Azure CLI, or ARM templates),
    it will all have a *deployment mode*. This can be either *Incremental* or *Complete*.
    In Incremental mode, all resources specified in the template will be created in
    Azure or their properties will be updated if the resource already exists. In Complete
    deployment mode, any resources that are not defined in the ARM template will be
    deleted. This mode does not redeploy all resources; instead, it verifies that
    the resources stated in the template have been created and removes those that
    have not been defined and already exist in Azure.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种部署方法（REST API、Azure CLI 或 ARM 模板），都将有一个*deployment mode*。这可以是*Incremental*或*Complete*。在增量模式下，将在
    Azure 中创建模板中指定的所有资源，或者如果资源已存在，则将更新其属性。在完全部署模式下，将删除在 ARM 模板中未定义的任何资源。此模式不会重新部署所有资源；相反，它验证了模板中声明的资源是否已创建，并删除那些未在模板中定义但已存在于
    Azure 中的资源。
- en: The default deployment mode is Incremental.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 默认部署模式为增量。
- en: In the next sections, several tools for executing deployments are discussed,
    starting with PowerShell.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，讨论了几个执行部署的工具，首先是 PowerShell。
- en: PowerShell
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell
- en: 'For the local development and testing of ARM templates on a local machine,
    PowerShell has a quick command to apply an ARM template to a resource group:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用于在本地开发和测试 ARM 模板的 PowerShell 快速命令可应用 ARM 模板到资源组：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding command will pick up the specified template and parameter file
    and apply it to the specified resource group. This command assumes that the current
    session has already been logged in to Azure.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将获取指定的模板和参数文件，并将其应用于指定的资源组。此命令假定当前会话已登录到 Azure。
- en: 'There are a few variations of the command available:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可用几种命令的变体：
- en: A parameter called `-Mode` with a `Complete` or `Incremental` value is available.
    This can be used to specify `deploymentmode`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数 `-Mode` 包含 `Complete` 或 `Incremental` 值可用。这可用于指定 `deploymentmode`。
- en: If no parameter file is specified and the template requires parameters, the
    cmdlet will prompt for these values on the command line.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果未指定参数文件且模板需要参数，则命令行工具将提示输入这些值。
- en: As an alternative, the `-TemplateUri` and `-TemplateParametersUri` options can
    be used to specify the location of the template and parameters to be retrieved
    from another location.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为替代方案，可以使用 `-TemplateUri` 和 `-TemplateParametersUri` 选项指定模板和参数的位置，以从其他位置检索。
- en: The next tool that we’ll look into is the Azure CLI.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将了解 Azure CLI。
- en: The Azure CLI
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure CLI
- en: 'The Azure CLI is another way of deploying ARM templates from the command line.
    The benefit of the CLI is that it is completely cross-platform and runs on Windows,
    macOS, and Linux. The Azure CLI command for deploying an ARM template is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Azure CLI 是从命令行部署 ARM 模板的另一种方式。CLI 的好处是完全跨平台，并可在 Windows、macOS 和 Linux 上运行。部署
    ARM 模板的 Azure CLI 命令如下：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All other options that are available in PowerShell are also available in the
    CLI.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 中提供的所有其他选项在 CLI 中也同样可用。
- en: Azure Pipelines
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Pipelines
- en: 'A third mechanism for deploying ARM templates is from an Azure pipeline. This
    is particularly useful for deploying the infrastructure and configuration of an
    application, together with the binaries. To deploy an ARM template deployment
    from a pipeline, at least one service connection of the ARM template needs to
    be configured. After doing this, a pipeline can be configured, as shown in the
    following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 ARM 模板的第三种机制是通过 Azure 管道进行。这对于同时部署应用程序的基础设施、配置以及二进制文件非常有用。要通过管道部署 ARM 模板，至少需要配置一个
    ARM 模板的服务连接。完成此配置后，可以配置管道，如下图所示：
- en: '![Figure 8.2 – Azure Pipelines ARM template deployment ](img/B18655_08_02.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – Azure 管道 ARM 模板部署](img/B18655_08_02.jpg)'
- en: Figure 8.2 – Azure Pipelines ARM template deployment
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Azure 管道 ARM 模板部署
- en: In this example, there are two deployments of an ARM template, surrounding the
    deployment of the application code. The first deployment is of the Incremental
    mode, while the second deployment is of the Complete mode.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，有两个 ARM 模板的部署，围绕应用程序代码的部署。第一次部署是增量模式，第二次部署是完整模式。
- en: Tip
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The ARM template test toolkit is available at [https://github.com/Azure/arm-ttk](https://github.com/Azure/arm-ttk)
    for you to make ARM templates compliant with standard practices.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 模板测试工具包可通过[https://github.com/Azure/arm-ttk](https://github.com/Azure/arm-ttk)访问，帮助你使
    ARM 模板符合标准实践。
- en: Using this approach, the first deployment will create all new infrastructure
    needed by the new version of the application. This deployment is done in Incremental
    mode, so infrastructure that is no longer present in the template but still in
    use by the currently deployed version of the application will not yet be removed.
    The second deployment will take care of removing these elements after the new
    version of the code is deployed.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，第一次部署将创建新版本应用所需的所有新基础设施。该部署是增量模式，因此模板中不再存在但当前部署的应用版本仍在使用的基础设施将不会被移除。第二次部署将在新版本代码部署后处理移除这些元素。
- en: ARM REST API
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ARM REST API
- en: 'ARM provides REST API operational groups to deploy and manage infrastructure
    to Azure. In order to get a list of resources in a subscription, run the following
    command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ARM 提供了 REST API 操作组，用于部署和管理 Azure 的基础设施。要获取订阅中的资源列表，请运行以下命令：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can use ARMClient, a simple command-line tool, to send HTTP requests to
    the new ARM REST API:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 ARMClient，这是一个简单的命令行工具，用于向新的 ARM REST API 发送 HTTP 请求：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding command gets a list of resources in the subscription. Please note
    that ARM client is not an official Microsoft tool. It is an OSS project that is
    maintained on GitHub.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令获取订阅中的资源列表。请注意，ARM 客户端不是微软的官方工具，而是一个开源项目，由 GitHub 上的社区维护。
- en: 'Also, you can use the `az rest` command to run these commands. Take the following
    example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以使用`az rest`命令来运行这些命令。以下是一个示例：
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Azure Cloud Shell
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Cloud Shell
- en: Azure Cloud Shell provides a Bash and PowerShell experience to manage and deploy
    Azure resources from within the browser itself. Azure Cloud Shell is hosted in
    Azure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cloud Shell 提供了一个 Bash 和 PowerShell 环境，允许从浏览器内管理和部署 Azure 资源。Azure Cloud
    Shell 托管在 Azure 中。
- en: '![Figure 8.3 – Azure Cloud Shell ](img/B18655_08_03.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – Azure Cloud Shell](img/B18655_08_03.jpg)'
- en: Figure 8.3 – Azure Cloud Shell
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – Azure Cloud Shell
- en: 'The Azure Cloud Shell command for deploying an ARM template in a resource group
    is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 ARM 模板到资源组的 Azure Cloud Shell 命令如下：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: All other options that are available in the Azure CLI are also available in
    Azure Cloud Shell.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Azure CLI 中的所有其他选项也可以在 Azure Cloud Shell 中使用。
- en: Reverse engineering a template
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逆向工程模板
- en: 'Writing an ARM template from scratch can be a tedious and time-consuming task.
    Luckily, there are two approaches available to generate an ARM template from existing
    infrastructure:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从头编写一个 ARM 模板可能是一项繁琐且耗时的任务。幸运的是，现有基础设施中有两种方法可以生成 ARM 模板：
- en: Using **Export template**
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**导出模板**
- en: Using **Resource Explorer**
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**资源浏览器**
- en: Let’s discuss both of these in the upcoming subsections.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的子章节中讨论这两种方法。
- en: Using Export template
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用导出模板
- en: 'The first approach is using the **Export template** option, which can be found
    on every resource and resource group in the Azure portal. This will generate an
    ARM template of the current state of the resource (group), as shown in the following
    screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是使用**导出模板**选项，该选项可以在 Azure 门户的每个资源和资源组中找到。这样会生成当前资源（组）状态的 ARM 模板，如下图所示：
- en: '![Figure 8.4 – Exporting an ARM template  ](img/B18655_08_04.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 导出 ARM 模板](img/B18655_08_04.jpg)'
- en: Figure 8.4 – Exporting an ARM template
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 导出 ARM 模板
- en: Please note that not every service currently supports reverse engineering an
    ARM template using this approach. For any service not supported, there will be
    a warning at the top of the screen. To work around this limitation for retrieving
    the JSON template for an individual resource, there is another approach, which
    is our next topic of discussion. The E`xport template` process will create a reusable
    ARM template. However, most exported templates require some modifications before
    they can be used to deploy Azure resources.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有服务目前都支持使用这种方法反向工程 ARM 模板。对于任何不受支持的服务，屏幕顶部将会显示一个警告。为了绕过这个限制并获取单个资源的 JSON
    模板，还有另一种方法，这是我们接下来要讨论的话题。`导出模板`过程将创建一个可重复使用的 ARM 模板。然而，大多数导出的模板在使用之前需要进行一些修改才能部署
    Azure 资源。
- en: Using Resource Explorer
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用资源浏览器
- en: 'To retrieve the JSON template for an individual resource, we can use **Resource
    Explorer**. Resource Explorer is shown here and can be found in the Azure portal
    by using the menu (**1**):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取单个资源的 JSON 模板，我们可以使用 **资源浏览器**。此处显示了资源浏览器，并可以通过菜单（**1**）在 Azure 门户中找到：
- en: '![Figure 8.5 – Azure Resource Explorer  ](img/B18655_08_05.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – Azure 资源浏览器](img/B18655_08_05.jpg)'
- en: Figure 8.5 – Azure Resource Explorer
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – Azure 资源浏览器
- en: After opening Resource Explorer, two new panes open up. The left pane can be
    used to navigate through subscriptions and drill down into the resource groups,
    down to the individual resources. For every element that is selected, the corresponding
    JSON will be displayed on the right. In the preceding example, the JSON for a
    hard disk is shown. This JSON is the same as the JSON that can be used in the
    resources array of an ARM template, except the ID element. Note that due to the
    different API versions used, the JSON output and the relevant template resource
    may vary.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 打开资源浏览器后，会打开两个新的面板。左侧面板可以用来浏览订阅并深入到资源组，直到单个资源。每选择一个元素，右侧将显示相应的 JSON。在前面的示例中，显示了硬盘的
    JSON。这个 JSON 与可以在 ARM 模板的资源数组中使用的 JSON 相同，唯一不同的是 ID 元素。请注意，由于使用了不同的 API 版本，JSON
    输出和相关模板资源可能会有所不同。
- en: Subscription-level templates
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅级别模板
- en: 'The discussion of ARM templates up to this point has all been about ARM templates
    for a resource group deployment. A template describes one or more resources that
    are deployed to a resource group. Additionally, there are also subscription-level
    templates. An example ARM template for a resource group is as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，关于 ARM 模板的讨论都是关于资源组部署的 ARM 模板。模板描述了一个或多个部署到资源组的资源。此外，还有订阅级别的模板。以下是一个资源组的示例
    ARM 模板：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The format for a subscription template is completely the same as that for a
    resource group. The differences are `$schema`, which points to another schema
    location, and the types of resources that are supported. Subscription templates
    do not support the creation of resources directly and support only the creation
    of resource groups, the initiation of template deployments, creating and assigning
    Azure policies, and the creation of role assignments.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅模板的格式与资源组模板完全相同。不同之处在于 `$schema`，它指向另一个架构位置，以及支持的资源类型。订阅模板不支持直接创建资源，只支持创建资源组、启动模板部署、创建和分配
    Azure 策略以及创建角色分配。
- en: Azure Blueprints
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 蓝图
- en: 'Next to subscription-level templates, there is also another offering available:
    Azure Blueprints. Blueprints can be used to describe the desired state of an Azure
    subscription and apply that to an existing subscription.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 除了订阅级别模板外，还有另一种可用的服务：Azure 蓝图。蓝图可以用来描述 Azure 订阅的期望状态，并将其应用到现有订阅上。
- en: 'All of the things that can be done using a blueprint can nowadays also be done
    using an ARM template. However, the other way around is not true. Azure Blueprints
    only supports the following constructs, which are called artifacts:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用蓝图可以做的所有事情也可以通过 ARM 模板来完成。然而，反之则不成立。Azure 蓝图仅支持以下构造，称为工件：
- en: Policy assignments
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略分配
- en: Role (RBAC) assignments
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色（RBAC）分配
- en: Resource group creation
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源组创建
- en: Nested ARM templates at the subscription or resource group level
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅或资源组级别的嵌套 ARM 模板
- en: These are all of the elements that are needed to build the default layout, or
    a blueprint, for Azure subscriptions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是构建默认布局或 Azure 订阅蓝图所需的所有元素。
- en: 'There are a number of key differences between blueprints and ARM templates:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图和 ARM 模板之间有许多关键差异：
- en: A blueprint is a resource you can create and navigate to in the portal. The
    authoring experience is also in the portal, not in text files on a local computer.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝图是你可以在门户中创建并导航的资源。编写体验也在门户中，而不是本地计算机上的文本文件。
- en: The relationship between a subscription and the blueprint that was used to create
    it remains, also after the deployment completes.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅与用于创建它的蓝图之间的关系在部署完成后依然存在。
- en: With the assignment of a blueprint to a subscription, it is possible to mark
    the assignment as locked. If this is done, all of the resources deployed through
    the blueprint cannot be deleted or edited as long as the blueprint is applied—not
    even by the owners of the subscription that it is assigned to.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将蓝图分配给订阅，可以将分配标记为锁定。如果这样做，则通过蓝图部署的所有资源在蓝图应用期间无法被删除或编辑——即使是被分配的订阅的所有者也无法进行操作。
- en: There are many built-in blueprints available that can be used to implement controls
    from well-known standards such as ISO, NIST, or HIPAA.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多内置蓝图可以用来实施来自知名标准（如 ISO、NIST 或 HIPAA）的控制。
- en: Azure Blueprints is still in preview at the time of writing. While using Blueprints,
    you can install RBAC roles, ARM templates, and Azure policies all at once and
    assign them to a certain scope. Removing the assignment does not delete or remove
    the resources, thus this soon becomes tedious, and Azure DevOps has no tasks or
    automation to manage blueprints at scale.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 蓝图在写作时仍处于预览阶段。在使用蓝图时，你可以一次性安装 RBAC 角色、ARM 模板和 Azure 策略，并将它们分配到某个范围。删除分配不会删除或移除资源，因此这很快会变得繁琐，并且
    Azure DevOps 没有任务或自动化来大规模管理蓝图。
- en: Bicep
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Bicep
- en: Bicep is a **Domain-Specific Language** (**DSL**) that allows the declarative
    deployment of Azure resources. Everything you can do with an ARM template can
    be accomplished with Bicep as well.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Bicep 是一种**领域专用语言**（**DSL**），允许声明性地部署 Azure 资源。你可以使用 ARM 模板完成的一切，也可以通过 Bicep
    来实现。
- en: Bicep provides all resource types and API versions. Bicep provides a better
    authoring experience as it supports type safety and a simple declarative syntax.
    Bicep files are idempotent, and one file will represent the desired state. You
    can then use that file to repeatedly deploy your infrastructure in a consistent
    manner.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Bicep 提供了所有资源类型和 API 版本。Bicep 提供了更好的编写体验，因为它支持类型安全并且具有简洁的声明性语法。Bicep 文件是幂等的，一个文件将代表所需的状态。然后，你可以使用该文件以一致的方式反复部署基础设施。
- en: Bicep is a transparent abstraction over ARM template JSON and supports JSON
    template capabilities. The Bicep CLI converts a Bicep file into ARM template JSON.
    You can use the Bicep Playground ([https://aka.ms/bicepdemo](https://aka.ms/bicepdemo)) to
    view Bicep and equivalent JSON side by side.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Bicep 是对 ARM 模板 JSON 的透明抽象，并支持 JSON 模板功能。Bicep CLI 将 Bicep 文件转换为 ARM 模板 JSON。你可以使用
    Bicep Playground ([https://aka.ms/bicepdemo](https://aka.ms/bicepdemo)) 来并排查看
    Bicep 和等效的 JSON。
- en: 'To decompile ARM template JSON to Bicep in the Azure CLI, use the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Azure CLI 中将 ARM 模板 JSON 反编译为 Bicep，请使用以下命令：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The command creates a file named `deployment.bicep`. Decompiling an ARM template
    helps you get started with Bicep development.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令会创建一个名为 `deployment.bicep` 的文件。反编译 ARM 模板可以帮助你开始 Bicep 开发。
- en: Using Azure Automation
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure 自动化
- en: Azure Automation is a service in Azure that is designed to help users to create,
    manage, deploy, and maintain their Azure resources. Azure Automation contains
    several concepts that remove some of the complexities and low-level details from
    these actions. Azure Automation allows for the formulation of workflows in the
    form of runbooks. These runbooks can be executed against Azure resources on behalf
    of the user.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 自动化是 Azure 中的一项服务，旨在帮助用户创建、管理、部署和维护其 Azure 资源。Azure 自动化包含几个概念，可以去除这些操作中的一些复杂性和底层细节。Azure
    自动化允许以 Runbook 形式制定工作流。这些 Runbook 可以代表用户对 Azure 资源进行执行。
- en: Automation account resources
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化帐户资源
- en: Within an Azure Automation account, there are several resources that make this
    more than just a scripting engine. These resources are shared on the level of
    the Automation account and can hence be reused within multiple runbooks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个 Azure 自动化帐户中，有几个资源使其不仅仅是一个脚本引擎。这些资源在自动化帐户级别共享，因此可以在多个 runbook 中重用。
- en: Run As account
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Run As 帐户
- en: The first of these constructs is the *Run As* account. This account is a service
    principal that will be created in the AAD that the Azure subscription containing
    the Automation account is linked to. The credentials to authenticate as this service
    principal are securely stored within the Automation account. These credentials
    are non-retrievable directly from an Automation account. The service principal
    is also added as a contributor to the Azure subscription. As a result, runbooks
    can now be set up to execute using this account. Run As accounts can be automatically
    created when creating the Automation account.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构造中的第一个是 *Run As* 帐户。该帐户是一个服务主体，它将在与自动化帐户关联的 Azure 订阅所连接的 AAD 中创建。用于验证该服务主体的凭据将安全地存储在自动化帐户中。这些凭据无法直接从自动化帐户中检索。服务主体也会被添加为
    Azure 订阅的贡献者。因此，现在可以设置 runbook 使用该帐户执行。创建自动化帐户时，可以自动创建 Run As 帐户。
- en: Run As account functionality is still available for current and new Automation
    accounts. However, the Run As account has been replaced with managed identities.
    Managed identities are the recommended way to authenticate in your runbooks and
    the default authentication method for your Automation account. Because no credentials
    are saved, a managed identity is more secure and easier to use. If you use Run
    As in your runbook code, you should change it to use managed identities instead.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Run As 帐户功能仍然适用于当前和新的自动化帐户。然而，Run As 帐户已被托管身份所取代。托管身份是验证 runbook 中身份的推荐方式，也是自动化帐户的默认验证方法。由于不保存凭据，托管身份更加安全且更易于使用。如果你在
    runbook 代码中使用了 Run As，应该将其改为使用托管身份。
- en: Schedules
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调度
- en: 'A common way of automating workflows is scheduling them to run on a specific
    date and time or at a fixed interval. Instead of specifying a schedule for every
    workflow, shared schedules can be created and reused in runbooks. To create a
    new schedule, first, open the list of all schedules. After that, a new schedule
    can be added, as shown in the following screenshot:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化工作流的常见方式是将其安排在特定的日期和时间运行，或者在固定的时间间隔内运行。为了避免为每个工作流都指定一个调度，可以创建共享的调度并在 runbook
    中重用。要创建新的调度，首先打开所有调度的列表。之后，可以添加一个新的调度，如下图所示：
- en: '![Figure 8.6 – Azure Automation workflow schedules ](img/B18655_08_06.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – Azure 自动化工作流调度](img/B18655_08_06.jpg)'
- en: Figure 8.6 – Azure Automation workflow schedules
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – Azure 自动化工作流调度
- en: A schedule has a name and a description. These values are for the users interacting
    with the schedule only. Next, a starting date and time can be configured, along
    with an optional recurrence interval, and, if a recurrence interval is specified,
    an expiration date and time.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一个调度有一个名称和描述。这些值仅供与调度交互的用户使用。接下来，可以配置一个开始日期和时间，以及一个可选的重复间隔，如果指定了重复间隔，还需要配置一个过期日期和时间。
- en: Once the schedule is created, it can be used for a runbook.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了调度，它就可以用于一个 runbook。
- en: Modules
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块
- en: The runbooks that are used in Azure Automation are written in PowerShell or
    Python. PowerShell has a very rich ecosystem of modules with predefined functionalities
    that can be used. To use PowerShell modules from an Automation account, only modules
    that have been uploaded to the modules section can be used. One major benefit
    of this is that it is possible to fix the version of a module to use. This guarantees
    that scripts will keep working and not break in case of updates to dependencies.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure 自动化中使用的 runbook 是用 PowerShell 或 Python 编写的。PowerShell 拥有一个非常丰富的模块生态系统，提供了许多预定义的功能，可以直接使用。要从自动化帐户中使用
    PowerShell 模块，只有那些已上传到模块部分的模块可以使用。这样做的一个主要好处是可以固定使用某个版本的模块。这可以确保脚本在依赖项更新时仍然能够正常工作，而不会中断。
- en: The PowerShell modules for interacting with Azure are by default installed into
    every Automation account. Furthermore, more modules can be added, and existing
    modules can be upgraded or removed by administrators.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 用于与 Azure 交互的 PowerShell 模块默认会安装到每个自动化帐户中。此外，管理员还可以添加更多模块，升级现有模块或移除模块。
- en: Variables
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: 'Within runbooks, a lot of variables might come into play: the names of resource
    groups, virtual machines, startup or shutdown times, and so on. Hardcoding these
    values inside a script is not good practice but storing them together with a runbook
    also has downsides. For example, in the case that there are three runbooks for
    the same virtual machine, this would mean that a number of variable values (for
    example, resource group name and virtual machine name) would be repeated at least
    three times. To prevent this, it is possible to store variable values at the Automation
    account level, from where they can be reused throughout every runbook that is
    executed in that account.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行手册中，可能涉及到许多变量：资源组名称、虚拟机名称、启动或关闭时间等。将这些值硬编码到脚本中并不是一个好习惯，而将它们与运行手册一起存储也有缺点。例如，如果有三个运行手册用于同一虚拟机，这意味着一些变量值（例如资源组名称和虚拟机名称）至少会重复三次。为了避免这种情况，可以将变量值存储在自动化帐户级别，从而可以在该帐户中执行的每个运行手册中重复使用。
- en: 'Once a variable is set, it can be accessed from a runbook using the following
    command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了变量，可以使用以下命令从运行手册中访问该变量：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In addition to reading and using variables inside a runbook, they can also
    be updated from within a runbook:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在运行手册内读取和使用变量外，还可以从运行手册中更新变量：
- en: '[PRE23]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: While a very powerful feature, updating variables from within runbooks can have
    unexpected consequences. If a variable value that is used in multiple runbooks
    gets updated by one of them, this might break the other runbooks. Keeping track
    of which variables are read-only and which are written to as well is important.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从运行手册中更新变量是一个非常强大的功能，但它可能带来意想不到的后果。如果在多个运行手册中使用的某个变量值被其中一个运行手册更新了，可能会导致其他运行手册出现问题。因此，跟踪哪些变量是只读的，哪些是可写的也非常重要。
- en: Credentials
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 凭据
- en: 'A special type of variable is the credential. Credentials contain not one but
    two values: a username and a password. Credentials are treated as secrets everywhere
    they are used. This means that they will not appear in logs and that they have
    to be retrieved using a specific PowerShell syntax:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊类型的变量是凭据。凭据包含的不仅仅是一个值，而是两个值：用户名和密码。凭据在使用的地方会被视为机密。这意味着它们不会出现在日志中，必须使用特定的PowerShell语法来检索：
- en: '[PRE24]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After executing this command, the `myCredential` object can be used to retrieve
    both the username and password.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，`myCredential`对象可以用来获取用户名和密码。
- en: Connections
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接
- en: It is a very common scenario to have to connect to one or more external services
    from within a runbook. A common example is the ARM template that is used to manage
    all resources within Azure. To avoid having to store a series of variables and
    build the corresponding connection in a runbook, Automation accounts allow for
    the creation beforehand of one or more connections.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行手册中连接一个或多个外部服务是非常常见的场景。一个常见的例子是用于管理Azure中所有资源的ARM模板。为了避免在运行手册中存储一系列变量并建立相应的连接，自动化帐户允许事先创建一个或多个连接。
- en: Tip
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In most scenarios, it is not necessary to create connections manually as they
    are provided along with a Run As account.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，不需要手动创建连接，因为它们会随**Run As**帐户一起提供。
- en: Once all of the shared resources are in place, it is time to start writing one
    or more runbooks, which is our next topic of discussion.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有共享资源就绪，就可以开始编写一个或多个运行手册，这是我们接下来要讨论的话题。
- en: Runbooks
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行手册
- en: 'Azure Automation supports a number of types of runbooks: PowerShell, Python
    2, and graphical. The first two allow for writing scripts in the specified language.
    Graphical runbooks allow for composing a runbook from all uploaded PowerShell
    modules, assets, and existing runbooks using drag and drop.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Azure自动化支持多种类型的运行手册：PowerShell、Python 2和图形化运行手册。前两者允许用指定语言编写脚本。图形化运行手册允许通过拖放方式从所有上传的PowerShell模块、资产和现有运行手册中组成一个运行手册。
- en: In addition to these three basic types of runbooks, there are PowerShell workflow
    and graphical workflow types available. The difference between a regular runbook
    and a workflow runbook is that workflow runbooks also support parallelism. Another
    benefit of PowerShell workflow is that it supports the use of checkpoints, which
    allow a script to be resumed if it encounters an exception mid-execution.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三种基本类型的运行手册外，还有PowerShell工作流和图形工作流类型可供选择。常规运行手册与工作流运行手册的区别在于，工作流运行手册还支持并行处理。PowerShell工作流的另一个好处是它支持使用检查点，这样如果脚本在执行过程中遇到异常，它可以从检查点恢复继续执行。
- en: Runbook execution
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行手册执行
- en: 'Once the runbook is written, there are a number of ways to execute it:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦写好了运行手册，就有多种方式可以执行它：
- en: '**Manually**: Any runbook can be run at any time by opening it in the Azure
    portal and pressing **Start**. Of course, these operations are also available
    using PowerShell or the Azure CLI.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动**：任何运行手册都可以随时通过在 Azure 门户中打开并按下**开始**按钮来运行。当然，这些操作也可以通过 PowerShell 或 Azure
    CLI 执行。'
- en: '**By attaching a webhook**: Once a runbook is published, one or more webhooks
    can be generated for executing the runbook. Each webhook can be enabled or disabled
    or given an expiration date. These tools allow a new webhook to be generated for
    every user of the runbook and fine-grained control to be initiated if ever, in
    the future, access should not be accorded to a particular user.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过附加 webhook**：一旦发布了运行手册，可以生成一个或多个 webhook 用于执行该运行手册。每个 webhook 都可以启用或禁用，并可以设置过期日期。这些工具允许为每个运行手册的用户生成一个新的
    webhook，并在将来需要撤销某个用户的访问时，进行细粒度的控制。'
- en: '**On a schedule**: Published runbooks can be attached to one or more of the
    shared schedules. Being able to attach to multiple schedules means that it is
    easy to precreate a series of schedules for typical reoccurrences, such as hourly,
    daily, or every Monday, and reuse and combine these for the appropriate runbooks.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按计划**：已发布的运行手册可以附加到一个或多个共享的计划中。能够附加到多个计划意味着，可以轻松预先创建一系列典型的重复计划，例如每小时、每天或每周一，并将这些计划重复使用和组合到适当的运行手册中。'
- en: When executing the runbook from a webhook or on a schedule, the option to run
    it manually will stay available.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过 webhook 或按计划执行运行手册时，手动执行的选项仍然可用。
- en: Jobs
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作业
- en: Every time a runbook is executed, a new entry is created in the **Jobs** log.
    This log will show an entry for every time the runbook has run, no matter how
    the execution was initiated. Every entry will contain the date and time the run
    was started, whether there were errors, and a full execution log.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行运行手册时，都会在**作业**日志中创建一个新条目。该日志会记录每次运行手册时的条目，无论执行是如何发起的。每个条目都会包含运行开始的日期和时间、是否有错误，以及完整的执行日志。
- en: Runbooks gallery
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行手册画廊
- en: Runbooks are a great way of automating common tasks. Of course, there are tasks
    that are only for specific customers, but there are also many tasks that are applicable
    to all Azure customers. Examples include the automated startup of a virtual machine
    every Monday at 8 A.M. or scaling up a database every morning and back down every
    evening.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 运行手册是自动化常见任务的绝佳方式。当然，也有一些任务仅适用于特定客户，但也有许多任务适用于所有 Azure 客户。举例来说，自动化启动虚拟机，每周一上午
    8 点，或者每天早晨扩展数据库并在晚上缩减。
- en: For these common scenarios, there is the runbooks gallery, which is enabled
    within every Automation account. In this gallery, hundreds of premade runbooks
    can be browsed and searched. Once an appropriate runbook has been found, it can
    be imported directly into the account as a runbook.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些常见场景，每个自动化帐户中都启用了运行手册画廊。在该画廊中，可以浏览和搜索数百个预先制作的运行手册。找到合适的运行手册后，可以直接将其导入帐户作为运行手册。
- en: Besides executing scripts at set intervals or upon the invocation of a webhook,
    Azure Automation can also be used as a PowerShell DSC pull server. Let’s discuss
    this next.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 除了按设定的时间间隔或在调用 webhook 时执行脚本，Azure Automation 还可以作为 PowerShell DSC 拉取服务器使用。接下来我们将讨论这个功能。
- en: Before you run a new runbook that you’ve created or imported, you must first
    publish it. Each Azure Automation runbook has a Draft and a Published edition.
    Only the Published version can be run, and the Draft version can be modified.
    Any modifications to the Draft version have no effect on the Published version.
    When the Draft version is ready, you publish it, replacing the existing Published
    version with the Draft version.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行新创建或导入的运行手册之前，必须先发布它。每个 Azure Automation 运行手册都有草稿版和已发布版。只有已发布版可以运行，而草稿版可以进行修改。对草稿版的任何修改不会影响已发布版。当草稿版准备好后，可以将其发布，替换现有的已发布版。
- en: PowerShell DSC
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PowerShell DSC
- en: PowerShell DSC is a notion for specifying the configuration of servers. This
    configuration is stored on a pull server, where it can be accessed by one or more
    virtual machines. These virtual machines are configured to check this server at
    a specified interval for the latest DSC configuration and update themselves to
    comply with this configuration.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell DSC 是一种用于指定服务器配置的概念。该配置存储在拉取服务器上，虚拟机可以访问该服务器。虚拟机被配置为在指定的时间间隔检查该服务器，获取最新的
    DSC 配置，并更新自己以遵循该配置。
- en: 'PowerShell DSC is an extension to the PowerShell language specification that
    is used for writing desired state configurations. A configuration enables the
    desired state of one or more nodes to be specified. A node specifies which server,
    or set of servers, is to be configured. The configuration for a node is written
    in the form of one or more resources. An example configuration is as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell DSC 是 PowerShell 语言规范的扩展，用于编写期望的状态配置。配置使得可以指定一个或多个节点的期望状态。节点指定了要配置的服务器或服务器集合。节点的配置是通过一个或多个资源来编写的。以下是一个示例配置：
- en: '[PRE25]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, the configuration for a server farm with a single type of server
    is described. This server contains two resources. The first one, of the `WindowsFeature`
    type, with the name `IIS` is installed together with all of its subfeatures. The
    second resource, of the `File` type, ensures that a directory, `c:\logs`, exists.
    The resource types of `IIS` and `File` and many more are built into the PowerShell
    DSC specification. A full reference of all resources is available online and a
    link is included at the end of this chapter.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，描述了一个仅包含单一类型服务器的服务器集群配置。该服务器包含两个资源。第一个资源是 `WindowsFeature` 类型，名为 `IIS`，它与所有子功能一起安装。第二个资源是
    `File` 类型，用于确保目录 `c:\logs` 存在。`IIS` 和 `File` 等资源类型内建于 PowerShell DSC 规范中。所有资源的完整参考可在线查阅，并且本章末尾附有链接。
- en: Compiling and applying PowerShell DSC
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译并应用 PowerShell DSC
- en: PowerShell DSC files are saved in plaintext, often in a `.ps1` file. These files
    can be compiled into **Managed Object Format** (**MOF**) files. These MOF files
    can then be pushed to one or more servers to update the state of the server to
    the state described in the MOF file. This is called **push mode**.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell DSC 文件以纯文本格式保存，通常为 `.ps1` 文件。这些文件可以编译成 **管理对象格式**（**MOF**）文件。然后，这些
    MOF 文件可以被推送到一个或多个服务器，以将服务器的状态更新为 MOF 文件中描述的状态。这称为 **推送模式**。
- en: Besides push mode, there is another mode for deploying MOF files. This is called
    **pull mode**. In pull mode, MOF files are not directly pushed to individual servers
    but stored on a central server, which is called the **pull server**. This way,
    the pull server has a complete record of all configurations and node definitions
    within those configurations.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 除了推送模式，还有一种部署 MOF 文件的模式，称为 **拉取模式**。在拉取模式下，MOF 文件不会直接推送到单个服务器，而是存储在一个中央服务器上，该服务器称为
    **拉取服务器**。这样，拉取服务器就有了所有配置和节点定义的完整记录。
- en: Once the pull server is up and running, individual servers are configured to
    fetch their DSC configuration at a fixed interval and apply that configuration.
    Applying a configuration means that, for every defined resource, the described
    state will be enacted. This can be done by doing nothing if the actual state already
    matches the desired state, or by running commands to achieve the desired state.
    In this process, all previous changes—even by administrators—will be reverted
    if necessary.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦拉取服务器启动并运行，单个服务器将被配置为在固定间隔时间内获取其 DSC 配置并应用该配置。应用配置意味着，对于每个定义的资源，将执行描述的状态。如果实际状态已经与期望状态匹配，则可以什么都不做；如果不匹配，则通过执行命令以达到期望状态。在此过程中，所有之前的更改——即使是管理员的更改——如果有需要，都会被撤销。
- en: Using PowerShell DSC with Azure Automation
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Azure Automation 中使用 PowerShell DSC
- en: Azure Automation has built-in capabilities for PowerShell DSC and can fulfill
    the role of pull server for one or more virtual machines.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Automation 具有内建的 PowerShell DSC 功能，可以充当一个或多个虚拟机的拉取服务器。
- en: 'To start using the built-in pull server capabilities, upload one or more configuration
    files to the Automation account. This is done from the **State configuration**
    view that is shown in the following screenshot. Now, complete the following steps:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用内建的拉取服务器功能，请将一个或多个配置文件上传到 Automation 账户。这可以从下图所示的 **状态配置** 视图中完成。现在，按照以下步骤操作：
- en: Open by clicking the menu option on the left.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧的菜单选项打开。
- en: Select **Configurations** in the tab bar at the top.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部的标签栏中选择 **配置**。
- en: '![Figure 8.7 – Azure Automation state configuration ](img/B18655_08_07.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – Azure Automation 状态配置](img/B18655_08_07.jpg)'
- en: Figure 8.7 – Azure Automation state configuration
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – Azure Automation 状态配置
- en: Once the overview of all configurations is opened, new configurations can be
    added using the `topHere`, a local `ps1` file can be selected, and that will be
    added to the list. Any valid configuration in the list can be clicked on and compiled
    in place.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦打开所有配置的概览，可以使用 `topHere` 添加新配置，可以选择本地 `ps1` 文件，并将其添加到列表中。列表中的任何有效配置都可以点击并在当前位置进行编译。
- en: Now, the configuration will also be shown in the tab with compiled configurations
    and can be applied to one or more virtual machines.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，配置也会显示在已编译配置的标签页中，并可以应用于一个或多个虚拟机。
- en: Once a compiled configuration is available, the **Nodes** tab can be used for
    adding one or more virtual machines from the subscription to a configuration node.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦有了已编译的配置，可以使用**节点**标签将一个或多个虚拟机从订阅中添加到配置节点。
- en: 'Clicking the **Add** button while this tab is shown opens the view shown here:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此标签页显示时点击**添加**按钮，打开此处显示的视图：
- en: '![Figure 8.8 – Azure Automation – adding a new virtual machine ](img/B18655_08_08.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – Azure 自动化 – 添加新虚拟机](img/B18655_08_08.jpg)'
- en: Figure 8.8 – Azure Automation – adding a new virtual machine
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – Azure 自动化 – 添加新虚拟机
- en: In this view, a virtual machine can be selected to which the selected configuration
    should be applied.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此视图中，可以选择一个虚拟机，选定的配置将应用于该虚拟机。
- en: The local configuration manager on that machine will be configured to refresh
    the configuration at fixed intervals.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该机器上的本地配置管理器将被配置为在固定时间间隔内刷新配置。
- en: Whenever the configuration is refreshed, it will be reapplied to the server.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当配置刷新时，它将重新应用于服务器。
- en: Azure Automation enables users to manage virtual machines, for example, to apply
    application configuration. When working with PaaS offerings, this cannot be done
    using techniques such as PowerShell DSC; other techniques have to be used to manage
    application settings. These will be discussed in the next section.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 自动化使用户能够管理虚拟机，例如应用程序配置。在使用 PaaS 产品时，无法使用 PowerShell DSC 等技术来完成此任务；必须使用其他技术来管理应用设置。下一节将讨论这些技术。
- en: Managing application settings
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理应用设置
- en: 'Another part of the infrastructure of an application is the application configuration.
    In this section, a number of approaches for storing and loading the application
    configuration for an Azure App Service are discussed. They include the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的另一个基础设施部分是应用配置。在本节中，讨论了存储和加载 Azure 应用服务应用配置的多种方法。包括以下内容：
- en: Storing the configuration in the app settings
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将配置存储在应用设置中
- en: Using a combination of a managed identity and key vault
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用托管身份和密钥保管库的组合
- en: Using the Azure App Configuration service
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure 应用配置服务
- en: The disadvantage of the first approach is that the app settings can be read
    by any user who has administrative (read) access to the app service that is configured.
    The next two approaches do not have this disadvantage.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法的缺点是，任何具有应用服务管理（读取）权限的用户都可以读取应用设置。接下来的两种方法没有这个缺点。
- en: Azure App Service settings from an ARM template
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ARM 模板中的 Azure 应用服务设置
- en: 'The first way to configure application settings as code is by specifying app
    settings as a resource in an ARM template. This should be specified as a nested
    resource. This can be done as shown in the following screenshot:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应用设置为代码的第一种方式是通过在 ARM 模板中将应用设置指定为资源。这应该作为嵌套资源来指定。如下截图所示：
- en: '[PRE26]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The use of the `listKeys` function is especially useful in these scenarios.
    It allows for the direct copying of secrets from supported services to the application
    settings without ever storing them in an intermediate solution. For secrets that
    do not come from Azure sources, template parameters should be used.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些场景中，使用 `listKeys` 函数尤其有用。它允许将支持服务的密钥直接复制到应用设置中，而无需将其存储在中间解决方案中。对于不来自 Azure
    源的密钥，应使用模板参数。
- en: The configuration specified in the ARM template corresponds to the configuration
    of an app service that can be found in the portal. These settings are used to
    override corresponding entries in the `appsettings.json` or `appsettings.config`
    files. Updating this configuration automatically reloads the application as well.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ARM 模板中指定的配置对应于在门户中可以找到的应用服务的配置。这些设置用于覆盖 `appsettings.json` 或 `appsettings.config`
    文件中的相应条目。更新此配置也会自动重新加载应用程序。
- en: The downside of this approach is that secrets that are stored this way are readable
    through the Azure portal. Any user with read access to the app service can retrieve
    all secrets stored this way.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，以这种方式存储的机密可以通过 Azure 门户查看。任何具有应用服务读取权限的用户都可以检索以这种方式存储的所有机密。
- en: Loading settings at runtime from a key vault
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从密钥库在运行时加载设置
- en: The next possible location for storing app service settings is in an Azure key
    vault, where the application loads them at runtime. To make this possible, the
    following has to be in place.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 存储应用服务设置的下一个可能位置是在 Azure 密钥库中，应用程序在运行时加载它们。为了实现这一点，必须具备以下条件。
- en: To be able to authorize an application with access to a key vault, the application
    first has to be able to authenticate itself against AAD. Of course, this can be
    done by registering a service principal manually, but this would return a username
    and password that have to be stored somewhere. Usernames and passwords are secrets
    but cannot be stored in the key vault since they are needed for accessing it.
    This problem of how to keep the key to the vault safe can be solved by using an
    Azure capability called a **managed identity**.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够授权应用程序访问密钥库，应用程序首先必须能够在 AAD 中进行身份验证。当然，可以手动注册一个服务主体，但这将返回一个必须存储在某处的用户名和密码。用户名和密码是机密，但不能存储在密钥库中，因为它们需要用于访问密钥库。如何保持密钥的安全问题可以通过使用
    Azure 提供的一项功能 **托管身份** 来解决。
- en: Important Note
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The problem of securely storing secrets but getting another secret in return
    for accessing them is often referred to as the problem of *turtles all the way
    down*. This refers to an old anecdote to which a link is included at the end of
    this chapter.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 安全存储机密并通过访问它们获取另一个机密的问题通常被称为 *一切都是乌龟背上的问题*。这指的是一个古老的轶事，章节末尾提供了一个链接。
- en: With an Azure managed identity enabled on an app service, Azure automatically
    generates a service principal with a non-retrievable username and password. Only
    at runtime, using specific code, can an application authenticate itself as this
    principal. Azure will ensure that this will only work for code that is running
    with the app service that the managed identity belongs to.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Azure 托管身份的应用服务，Azure 会自动生成一个服务主体，并为其提供不可检索的用户名和密码。只有在运行时，通过特定的代码，应用程序才能将自己认证为该服务主体。Azure
    会确保这一过程仅适用于运行在该托管身份所属应用服务中的代码。
- en: 'Now that an application can have its own identity, that identity has to be
    granted access to the key vault. This can be done in the key vault description
    in an ARM template, using the following syntax for reference:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序可以拥有自己的身份，该身份必须被授予访问密钥库的权限。这可以在 ARM 模板中的密钥库描述中完成，参考以下语法：
- en: '[PRE27]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this example, the `reference()` function is used to retrieve the information
    of the managed identity and uses this to create an access policy on the key vault.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用 `reference()` 函数来检索托管身份的信息，并利用它在密钥库上创建访问策略。
- en: 'Finally, with the key vault and access to it set up, the application has to
    retrieve the contents at startup time. To do this, config builders can be used.
    They are introduced with .NET Core 2.0 (and .NET Framework 4.7.1) and are used
    in the `StartUp` class, as shown in the following code snippet:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在设置好密钥库并获得访问权限后，应用程序必须在启动时检索内容。为此，可以使用配置构建器。它们从 .NET Core 2.0（以及 .NET Framework
    4.7.1）开始引入，并在 `StartUp` 类中使用，以下代码片段展示了这一点：
- en: '[PRE28]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: All types in this code example are available in the NuGet `Microsoft.Configuration.ConfigurationBuilders.Azure`
    package.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码示例中的所有类型都可以在 NuGet `Microsoft.Configuration.ConfigurationBuilders.Azure`
    包中找到。
- en: Azure App Configuration
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure 应用配置
- en: Another location for storing the configuration of applications is Azure App
    Configuration. This is a new service, and at the time of writing, it is still
    in preview. App Configuration allows for the creation of a central register of
    key-value pairs that can be used as configuration by such a register, but also
    multiple applications.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个存储应用程序配置的位置是 Azure 应用配置。这是一个新服务，写作时仍处于预览阶段。应用配置允许创建一个包含键值对的中央注册表，可以由该注册表及多个应用程序作为配置使用。
- en: 'App Configuration is another type of resource that can be created from the
    portal. The main component is a **Configuration explorer,** as shown in the following
    screenshot:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 应用配置是另一种可以从门户创建的资源类型。其主要组件是 **配置资源管理器（Configuration Explorer）**，如以下截图所示：
- en: '![Figure 8.9 – Azure App Configuration ](img/B18655_08_09.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – Azure 应用配置](img/B18655_08_09.jpg)'
- en: Figure 8.9 – Azure App Configuration
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – Azure应用配置
- en: In addition to the Configuration explorer, there is a keys section for retrieving
    access keys that applications can use to read the configuration. There are also
    options to view recent changes to the configuration and restore earlier versions
    and for importing or exporting all configuration settings.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 除了配置浏览器外，还有一个用于获取访问密钥的“密钥”部分，应用程序可以使用这些密钥读取配置。还可以查看配置的最近更改，恢复早期版本，并进行配置设置的导入或导出。
- en: 'After the App Configuration resource has been created and configuration keys
    added, they can be retrieved from within an application by using an extension
    method of the **IConfiguration** framework type:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了应用配置资源并添加了配置密钥后，可以通过使用**IConfiguration**框架类型的扩展方法从应用程序中检索这些密钥：
- en: '[PRE29]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The loader for settings from an app configuration is part of the NuGet `Microsoft.Azure.AppConfiguration.AspNetCore`
    package.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序配置加载设置的加载器是NuGet `Microsoft.Azure.AppConfiguration.AspNetCore`包的一部分。
- en: 'Compared to storing settings in Azure Key Vault, App Configuration has two
    downsides:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 与将设置存储在Azure Key Vault中相比，应用配置有两个缺点：
- en: First, the application needs to be configured with a connection string to the
    Azure App Configuration, storing at least one new secret in the app settings.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，应用程序需要配置一个连接字符串，连接到Azure应用配置，并在应用程序设置中存储至少一个新的密钥。
- en: Second App Configuration does not have access control options that are as rigid
    as Key Vault. For this reason, it might make sense to distribute configuration
    over both App Configuration and Key Vault, depending on the type of configuration
    value.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，应用配置不像Key Vault那样具有严格的访问控制选项。因此，根据配置值的类型，可能需要在应用配置和Key Vault之间分配配置。
- en: This concludes our discussion of Azure and Azure DevOps capabilities for IaC.
    The next section will discuss a series of other tools available that offer similar
    capabilities.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们关于Azure和Azure DevOps在基础设施即代码（IaC）方面功能的讨论。接下来的部分将讨论一系列其他工具，这些工具提供类似的功能。
- en: Other tools
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他工具
- en: There are many other tools available for managing infrastructure and configuration
    through code. Next to the native Azure and Windows options discussed in the previous
    sections, there are many alternatives widely in use and some of them are listed
    in this section. It is important to know which tool can be used for which scenarios
    and how to integrate with them.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他工具可以通过代码管理基础设施和配置。除了前面讨论的原生Azure和Windows选项外，还有许多广泛使用的替代工具，其中一些在本节中列出。了解哪些工具可以用于哪些场景以及如何与它们集成是很重要的。
- en: CloudFormation
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CloudFormation
- en: 'CloudFormation is the IaC language for the AWS cloud. CloudFormation templates
    can be written in either JSON or YAML format. One example of creating an AWS S3
    storage bucket that is publicly readable would look like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation是AWS云的基础设施即代码（IaC）语言。CloudFormation模板可以使用JSON或YAML格式编写。以下是创建一个公共可读的AWS
    S3存储桶的示例：
- en: '[PRE30]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There is an extension available that allows the execution of CloudFormation
    templates on AWS from Azure DevOps. This extension provides tasks for creating,
    updating, or deleting AWS stacks. A stack has a function that is comparable to
    a resource group in Azure and the tasks are comparable to the tasks for applying
    an ARM template.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个扩展可用，允许从Azure DevOps在AWS上执行CloudFormation模板。此扩展提供了创建、更新或删除AWS堆栈的任务。堆栈的功能类似于Azure中的资源组，任务也类似于应用ARM模板的任务。
- en: Chef
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chef
- en: Chef is a tool for CaC, with support for describing and enforcing the configuration
    of servers. Chef uses a centralized server, the **Chef server**, where all configuration
    for all servers is saved. Here, the correct desired state for every server is
    determined, which is then pulled by the **Chef client**, an agent that runs on
    the *node* that is being managed.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Chef是一个用于配置即代码（CaC）的工具，支持描述和强制执行服务器的配置。Chef使用一个集中的服务器，**Chef服务器**，所有服务器的配置都保存在这里。在这里，确定每个服务器的正确期望状态，然后由**Chef客户端**，一个运行在被管理的*节点*上的代理，拉取这些配置。
- en: Defining the desired state for a server is done using a number of constructs.
    The lowest level is the recipe. A recipe contains one or more resources, which
    are built-in capabilities that can be used. An example resource is `execute`,
    which runs a Bash command. Another example resource is `apt_update`, which provides
    the means to interact with the `apt` package manager. One or more recipes are
    combined in cookbooks, which describe a capability that can be assigned to a node.
    The assignment of one or more cookbooks to a node is done using the run list.
    The run list contains all cookbooks that have to be applied to a node.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 定义服务器的期望状态是通过一系列构建块来完成的。最低级别的是食谱（recipe）。食谱包含一个或多个资源，这些资源是可以使用的内置功能。例如，`execute`
    是一个资源，用于运行 Bash 命令。另一个示例资源是 `apt_update`，它提供与 `apt` 包管理器交互的手段。一个或多个食谱可以组合成烹饪书（cookbook），它描述了可以分配给节点的能力。一个或多个烹饪书的分配是通过运行列表（run
    list）完成的。运行列表包含必须应用到节点上的所有烹饪书。
- en: Interaction with the Chef server is done using a command-line tool called `knife`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Chef 服务器的交互是通过名为 `knife` 的命令行工具完成的。
- en: While the terminology is completely different, there are many conceptual parallels
    between PowerShell DSC and Chef.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管术语完全不同，但 PowerShell DSC 和 Chef 在概念上有许多相似之处。
- en: Puppet
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Puppet
- en: Puppet is a deployment and configuration management tool that operates using
    a server-client model. There is a centralized server called the **Puppet master**
    that is responsible for taking in all of the desired state descriptions and compiling
    them to an internal catalog that holds the desired state for every managed server.
    All servers that are managed by Puppet need to have the Puppet agent installed
    on the local server. The agent connects to the server to pull the state for the
    server it manages, and applies that locally. A managed server is called a **node**.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 是一种部署和配置管理工具，采用服务器-客户端模型。它有一个集中式的服务器，称为 **Puppet master**，负责接收所有期望状态描述并将它们编译成一个内部目录，目录中保存着每个被管理服务器的期望状态。所有被
    Puppet 管理的服务器都需要在本地服务器上安装 Puppet 代理。代理连接到服务器，拉取它所管理服务器的状态，并在本地应用该状态。被管理的服务器称为
    **节点**。
- en: The base building block used by Puppet is called a **resource**. A resource
    is defined by specifying a resource type and a series of attributes. There are
    many resource types available, for example, for managing users and installed applications.
    Resources are grouped into one or more *classes*. These classes are, in turn,
    assigned to one or more nodes.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 使用的基本构建块叫做 **资源**（resource）。资源通过指定资源类型和一系列属性来定义。有很多类型的资源可供使用，例如用于管理用户和已安装的应用程序。资源被分组到一个或多个
    *类*（class）中，这些类进一步被分配到一个或多个节点上。
- en: Puppet can be installed on any Linux or Windows virtual machine in Azure. There
    is also a prebuilt image with Puppet Enterprise available in the Azure Marketplace.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 可以安装在 Azure 中的任何 Linux 或 Windows 虚拟机上。Azure Marketplace 中也有一个包含 Puppet
    Enterprise 的预构建镜像。
- en: Puppet is comparable to Chef and PowerShell DSC. All three have a comparable
    model for describing the desired state and they all serve the same purpose.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 可与 Chef 和 PowerShell DSC 相媲美。三者在描述期望状态方面有相似的模型，并且都具有相同的目的。
- en: Ansible
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible
- en: Ansible is yet another configuration management tool that is mostly used on
    Linux but also has support for Windows. One aspect that differentiates Ansible
    from other tools is that it does not have a centralized server that hosts all
    of the desired states, nor does it work with agents. All commands executed by
    Ansible are executed using SSH or other relevant protocols—HTTP(S), WinRM, and
    so on.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是另一种配置管理工具，主要用于 Linux，但也支持 Windows。Ansible 与其他工具的不同之处在于，它没有一个集中式服务器来托管所有的期望状态，也不使用代理。所有由
    Ansible 执行的命令都是通过 SSH 或其他相关协议（如 HTTP(S)、WinRM 等）执行的。
- en: Any server can initiate the deployment of a *playbook* against one or more *items*
    in an *inventory*. An Ansible inventory contains all of the servers that can be
    managed by Ansible. They can be grouped into one or more groups, which can be
    nested into other groups as well. Each individual server and every group is an
    inventory item. In Ansible, the desired state is written in playbooks. A playbook
    is a series of tasks or roles that need to be run on the target server. A role
    is a group of tasks. Roles are intended to be reused in more than one playbook
    and should, therefore, be general enough to be usable in multiple situations.
    Roles should also be idempotent. This means that the tasks in the role should
    ensure that the outcome of running the playbook is the same, no matter the number
    of times it is run.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 任何服务器都可以启动一个 *playbook*，对一个或多个 *items* 在 *inventory* 中进行操作。Ansible 清单包含所有可以由
    Ansible 管理的服务器。这些服务器可以分组为一个或多个组，并且可以嵌套在其他组中。每个单独的服务器和每个组都是一个清单项。在 Ansible 中，期望的状态是写在
    playbooks 中的。Playbook 是一系列需要在目标服务器上运行的任务或角色。角色是一组任务。角色旨在在多个 playbook 中重用，因此应足够通用，以便在多种情况下使用。角色还应该是幂等的。这意味着角色中的任务应确保无论运行
    playbook 的次数多少，结果都是相同的。
- en: Ansible scripts can be executed using command-line tools or an Azure DevOps
    extension that wraps this tool. There are also other management systems available,
    such as Ansible Tower, which provides a graphical user interface on top of the
    capabilities of the Ansible command-line tools.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 脚本可以使用命令行工具或封装此工具的 Azure DevOps 扩展进行执行。还有其他管理系统可用，例如 Ansible Tower，它在
    Ansible 命令行工具的功能之上提供了图形用户界面。
- en: Terraform
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform
- en: '**Terraform** is a multicloud infrastructure management solution. It is comparable
    to ARM templates or Bicep, the difference being that it also supports Amazon Web
    Services, Google Cloud Platform, and other supported cloud services. Terraform
    uses a custom file format for specifying one or more resources to be created using
    one or more providers. The resources correspond to the cloud resources, and the
    providers are responsible for knowing how to interact with the APIs of the different
    vendors.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '**Terraform** 是一种多云基础设施管理解决方案。它可以与 ARM 模板或 Bicep 相媲美，不同之处在于它还支持 Amazon Web
    Services、Google Cloud Platform 和其他支持的云服务。Terraform 使用一种自定义文件格式来指定一个或多个资源，这些资源通过一个或多个提供者进行创建。资源对应于云资源，而提供者负责了解如何与不同厂商的
    API 进行交互。'
- en: Optionally, you can use a JSON format instead of the Terraform proprietary format
    called **HashiCorp Configuration Language** (**HCL**). Terraform also supports
    the use of modules for creating packages that are reusable components.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以选择使用 JSON 格式，而不是 Terraform 专有的 **HashiCorp 配置语言**（**HCL**）。Terraform 还支持使用模块来创建可重用的组件包。
- en: Terraform configuration files are executed using CLIs.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 配置文件通过 CLI 执行。
- en: You can refer to the Terraform fundamentals ([https://learn.hashicorp.com/collections/terraform/cli](https://learn.hashicorp.com/collections/terraform/cli))
    to learn about these core components.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考 Terraform 基础知识 ([https://learn.hashicorp.com/collections/terraform/cli](https://learn.hashicorp.com/collections/terraform/cli))
    来了解这些核心组件。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the concepts of IaC and CaC, their value,
    and how to use them in practice. To implement these, you learned about ARM templates,
    the IaC mechanism for Azure. You also learned about PowerShell DSC to manage the
    configuration of virtual machines and about different techniques for managing
    the configuration of your applications. Finally, you learned about several other
    tools available on the market. You learned which tool can be used in which situation
    and whether these tools can integrate with Azure DevOps.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了 IaC 和 CaC 的概念、它们的价值以及如何在实践中使用它们。为了实现这些，你了解了 Azure 的 IaC 机制 —— ARM
    模板。你还学习了如何使用 PowerShell DSC 来管理虚拟机的配置，以及如何使用不同的技术来管理应用程序的配置。最后，你了解了市场上其他可用的工具。你学会了在什么情况下使用哪种工具，以及这些工具是否可以与
    Azure DevOps 集成。
- en: With this knowledge, you are now able to start describing the infrastructure
    and configuration of your application(s) in source control using one or more of
    the tools you have read about. You are also capable of setting up the means to
    deliver the infrastructure using automation, either from a release pipeline or
    using dedicated infrastructure management tools. But no matter which solution
    you choose, you now have the capabilities to incorporate infrastructure into your
    DevOps processes.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，你现在可以开始使用你读到的一个或多个工具，在源控制中描述你的应用程序的基础设施和配置。你也可以设置交付基础设施的方式，使用自动化，既可以通过发布管道，也可以使用专用的基础设施管理工具。无论你选择哪种解决方案，你现在都具备了将基础设施融入
    DevOps 流程的能力。
- en: In the next chapter, you will learn about another challenge you might encounter
    when implementing DevOps practices, related to databases. When increasing the
    speed at which features flow to production, you may also have to change the way
    you manage your database schema and how you apply changes. The next chapter will
    discuss this subject.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习到实施 DevOps 实践时可能遇到的另一个挑战，涉及数据库。当提高功能流向生产的速度时，你可能还需要改变管理数据库架构和应用更改的方式。下一章将讨论这个话题。
- en: Activity
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动
- en: Create And Deploy Empty ARM template using Azure CLI
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure CLI 创建并部署空的 ARM 模板
- en: Add a resource to create Storage account in your ARM template
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的 ARM 模板中添加资源以创建存储帐户
- en: Questions
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们总结时，这里列出了一些问题，供你测试关于本章内容的知识。你可以在附录的*评估*部分找到答案：
- en: 'True or False: ARM templates in Incremental deployment mode can be used for
    creating, updating, and deleting Azure resources.'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确还是错误：增量部署模式下的 ARM 模板可用于创建、更新和删除 Azure 资源。
- en: Which of the following is not an Azure Automation account resource?
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项不是 Azure 自动化帐户资源？
- en: Modules
  id: totrans-343
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块
- en: Containers
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器
- en: Managed identities
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 托管标识
- en: Variables
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量
- en: 'True or False: One disadvantage of IaC is that you have to put sensitive information
    in source control as ARM template parameter files.'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确还是错误：IaC 的一个缺点是你必须将敏感信息作为 ARM 模板参数文件放入源控制中。
- en: 'True or False: Azure Automation accounts allow for the execution of PowerShell
    runbooks at a predefined schedule.'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确还是错误：Azure 自动化帐户允许按预定义的时间表执行 PowerShell 运行簿。
- en: What are some of the benefits of using IaC?
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 IaC 的一些好处是什么？
- en: Further reading
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: A formal breakdown of the ARM template structure and syntax can be found at
    [https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-expressions](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-expressions).
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 ARM 模板结构和语法的正式分解，请参见[https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-expressions](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-expressions)。
- en: The complete ARM template documentation can be found at [https://docs.microsoft.com/en-us/azure/templates/](https://docs.microsoft.com/en-us/azure/templates/).
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的 ARM 模板文档可以在[https://docs.microsoft.com/en-us/azure/templates/](https://docs.microsoft.com/en-us/azure/templates/)找到。
- en: An overview of all functions that can be used in ARM templates can be found
    at [https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions).
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关可以在 ARM 模板中使用的所有函数的概述，请参见[https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions)。
- en: More information about Azure Blueprints can be found at [https://docs.microsoft.com/en-us/azure/governance/blueprints/overview](https://docs.microsoft.com/en-us/azure/governance/blueprints/overview).
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Azure 蓝图的更多信息，请参见[https://docs.microsoft.com/en-us/azure/governance/blueprints/overview](https://docs.microsoft.com/en-us/azure/governance/blueprints/overview)。
- en: Details about the `WhatIf` command for ARM templates can be found at [https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deploy-what-if](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deploy-what-if).
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 ARM 模板的 `WhatIf` 命令的详细信息，请参见[https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deploy-what-if](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deploy-what-if)。
- en: Documentation for all PowerShell DSC built-in resources, can be found at [https://docs.microsoft.com/en-us/powershell/dsc/overview/decisionmaker?view=dsc-1.1](https://docs.microsoft.com/en-us/powershell/dsc/overview/decisionmaker?view=dsc-1.1).
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 PowerShell DSC 内置资源的文档可以在[https://docs.microsoft.com/en-us/powershell/dsc/overview/decisionmaker?view=dsc-1.1](https://docs.microsoft.com/en-us/powershell/dsc/overview/decisionmaker?view=dsc-1.1)找到。
- en: More information about CloudFormation can be found at [https://aws.amazon.com/cloudformation/](https://aws.amazon.com/cloudformation/).
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 CloudFormation 的更多信息可以在[https://aws.amazon.com/cloudformation/](https://aws.amazon.com/cloudformation/)找到。
- en: More information about Chef can be found at [https://www.chef.io/](https://www.chef.io/).
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Chef 的更多信息可以在[https://www.chef.io/](https://www.chef.io/)找到。
- en: More information about Puppet can be found at [https://puppet.com/](https://puppet.com/).
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Puppet 的更多信息可以在[https://puppet.com/](https://puppet.com/)找到。
- en: More information about Ansible can be found at [https://www.ansible.com/](https://www.ansible.com/).
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Ansible 的更多信息可以在[https://www.ansible.com/](https://www.ansible.com/)找到。
- en: More information about Terraform can be found at `https://www.terraform.io/`.
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Terraform 的更多信息可以在`https://www.terraform.io/`找到。
- en: More information about Azure resource manager commands [https://docs.microsoft.com/en-us/cli/azure/deployment/group?view=azure-cli-latest#az-deployment-group-create](https://docs.microsoft.com/en-us/cli/azure/deployment/group?view=azure-cli-latest#az-deployment-group-create)
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Azure 资源管理器命令的更多信息，请访问[https://docs.microsoft.com/en-us/cli/azure/deployment/group?view=azure-cli-latest#az-deployment-group-create](https://docs.microsoft.com/en-us/cli/azure/deployment/group?view=azure-cli-latest#az-deployment-group-create)
- en: 'Bicep overview:'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bicep 概述：
- en: '[https://github.com/Azure/bicep](https://github.com/Azure/bicep)'
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Azure/bicep](https://github.com/Azure/bicep)'
- en: '[https://docs.microsoft.com/en-us/azure/azure-resource-manager/bicep/learn-bicep](https://docs.microsoft.com/en-us/azure/azure-resource-manager/bicep/learn-bicep)'
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/azure-resource-manager/bicep/learn-bicep](https://docs.microsoft.com/en-us/azure/azure-resource-manager/bicep/learn-bicep)'
- en: 'Learning path to explore the *Infrastructure as Code*: [https://docs.microsoft.com/en-us/learn/paths/az-400-manage-infrastructure-as-code-using-azure/](https://docs.microsoft.com/en-us/learn/paths/az-400-manage-infrastructure-as-code-using-azure/).'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索*基础设施即代码*的学习路径：[https://docs.microsoft.com/en-us/learn/paths/az-400-manage-infrastructure-as-code-using-azure/](https://docs.microsoft.com/en-us/learn/paths/az-400-manage-infrastructure-as-code-using-azure/)。
- en: There are many online references to the story of *turtles all the way down*,
    but an early reference can be found digitized at [https://dspace.mit.edu/handle/1721.1/15166](https://dspace.mit.edu/handle/1721.1/15166).
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于*乌龟背上的故事*有很多在线参考资料，但早期的一个参考可以在[https://dspace.mit.edu/handle/1721.1/15166](https://dspace.mit.edu/handle/1721.1/15166)找到数字化版本。
