- en: 'Chapter 2: Go Language Essentials'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：Go 语言基础
- en: In the previous chapter, we covered the basics of the Go language. While some
    of the syntax is new in relation to other languages, most of the concepts in that
    chapter are familiar to programmers coming from other languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章，我们介绍了 Go 语言的基础知识。虽然与其他语言相比，某些语法是新的，但大多数概念对于来自其他语言的程序员来说是熟悉的。
- en: This isn't to say that the way Go uses those concepts doesn't lead to code that
    is easier to read and reason about—it's just that most of it doesn't stand out
    from other languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说 Go 使用这些概念的方式不导致更容易阅读和推理的代码——只是大多数内容与其他语言并无显著不同。
- en: In this chapter, we will be discussing the essential parts of Go that make it
    stand out from other languages, from Go's more pragmatic error handling to its
    core concurrency concept, the goroutine, and the newest feature of the Go language,
    generics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论使 Go 与其他语言不同的关键部分，从 Go 更具实用性的错误处理，到其核心并发概念 goroutine，再到 Go 语言的最新特性：泛型。
- en: 'Here are the main topics that will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将要讨论的主要主题：
- en: Handling errors in Go
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中处理错误
- en: Utilizing Go constants
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Go 常量
- en: Using `defer`, `panic`, and `recover`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `defer`、`panic` 和 `recover`
- en: Utilizing goroutines for concurrency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 goroutine 实现并发
- en: Understanding Go's `Context` type
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Go 的 `Context` 类型
- en: Utilizing Go's testing framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Go 的测试框架
- en: Generics—the new kid on the block
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型——新兴的技术
- en: Now, let's get the essentials down and get you on your way!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们整理一下基本要点，帮助你顺利开始！
- en: Handling errors in Go
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Go 中处理错误
- en: Many of you will come from languages that handle *errors* using *exceptions*.
    Go took a different approach, treating errors like our other data types. This
    prevents common problems that exception-based models have, such as exceptions
    escaping up the stack.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者来自于使用 *异常* 处理 *错误* 的语言。Go 采用了不同的方法，将错误视为与其他数据类型一样的对象。这避免了基于异常的模型常见问题，例如异常从栈中逃逸的问题。
- en: 'Go has a built-in error type called `error`. `error` is based on the `interface`
    type, with the following definition:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言有一个内建的错误类型，叫做 `error`。`error` 基于 `interface` 类型，具有以下定义：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, let's look at how we can create an error.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看如何创建一个错误。
- en: Creating an error
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个错误
- en: 'The most common way to create errors is using either the `errors` package''s
    `New()` method or the `fmt` package''s `Errorf()` method. Use `errors.New()` when
    you don''t need to do variable substitution and `fmt.Errorf()` when you do. You
    can see both methods in the following code snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建错误的最常见方法是使用 `errors` 包的 `New()` 方法或 `fmt` 包的 `Errorf()` 方法。当你不需要变量替换时，使用 `errors.New()`，当你需要变量替换时，使用
    `fmt.Errorf()`。你可以在以下代码片段中看到这两种方法：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In both the preceding examples, `err` will be of type `error`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`err` 将是 `error` 类型。
- en: Using an error
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用错误
- en: The most common way to use an error is as the last return value on a function
    or method call. The caller can then test if the returned error is `nil`, indicating
    there is no error.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用错误的最常见方式是将其作为函数或方法调用的最后一个返回值。调用者可以测试返回的错误是否为 `nil`，如果是，表示没有错误。
- en: 'Let''s say we want a function that divides a number, and we want to detect
    if the divisor is zero. In that case, we want to return an error because a computer
    cannot divide a number by zero. This is how it might look:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要编写一个除法函数，并且希望检测除数是否为零。如果是这样，我们希望返回一个错误，因为计算机无法将一个数除以零。代码可能如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding example uses Go''s multiple return ability to return two values:
    **the result** and **the error**.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例使用了 Go 语言的多值返回能力，返回了两个值：**结果** 和 **错误**。
- en: In our `main` package, we can now divide our numbers and check the returned
    `error` type to see if it is not `nil`. If it is, we know we had an error and
    should ignore the return value. If not, we know the operation completed successfully.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `main` 包中，现在可以进行除法运算并检查返回的 `error` 类型，看看它是否为 `nil`。如果是，我们知道发生了错误，应该忽略返回值。如果不是，我们知道操作已成功完成。
- en: Creating named errors
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建命名错误
- en: 'Sometimes, you want to create errors that indicate a specific type of error—say,
    a network error versus an incorrect argument. This can be done by creating specific
    types of errors using the `var` keyword and `errors.New()` or `fmt.Errorf()`,
    as illustrated in the following code snippet:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能希望创建表示特定类型错误的错误——比如网络错误与参数错误。这可以通过使用 `var` 关键字和 `errors.New()` 或 `fmt.Errorf()`
    来创建特定类型的错误，以下是示例代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can use the `errors` package''s `Is()` function to detect the error type
    and retry on `ErrNetwork` and not on other errors, as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`errors`包的`Is()`函数来检测错误类型，并在`ErrNetwork`上重试，而不在其他错误上重试，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`someFunc()` is not defined here. You can view a full example here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`someFunc()`在此未定义。你可以在此查看完整示例：'
- en: '[https://play.golang.org/p/iPwwwmIBcAG](https://play.golang.org/p/iPwwwmIBcAG)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://play.golang.org/p/iPwwwmIBcAG](https://play.golang.org/p/iPwwwmIBcAG)'
- en: Custom errors
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义错误
- en: 'Because the `error` type is simply an interface, you can implement your own
    custom errors. Here is a more in-depth network error that we could use:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`error`类型本质上是一个接口，你可以实现自定义错误。以下是我们可以使用的更深入的网络错误：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can now return a custom network error for something such as an authentication
    failure, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以返回一个自定义的网络错误，例如身份验证失败，如下所示：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we receive an error from a call, we can detect if it was a network error
    using the `errors.As()` function, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到一个错误时，我们可以使用`errors.As()`函数检测它是否是网络错误，如下所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also view this here: [https://play.golang.org/p/gZ5AK8-o4zA](https://play.golang.org/p/gZ5AK8-o4zA).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在这里查看：[https://play.golang.org/p/gZ5AK8-o4zA](https://play.golang.org/p/gZ5AK8-o4zA)。
- en: The preceding code detects if the network error is unrecoverable, such as an
    authentication failure. Any other network error is recoverable. If it is not a
    network error, it is unrecoverable.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码检测网络错误是否不可恢复，例如身份验证失败。任何其他网络错误都是可恢复的。如果不是网络错误，则是不可恢复的。
- en: Wrapping errors
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误包装
- en: Many times, there is an error chain where we want to `net/http` package. In
    that case, you might want to put information about which REST call you were making
    with the underlying error.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，会有一个错误链，我们希望使用`net/http`包。在这种情况下，你可能希望将你进行的 REST 调用的相关信息与底层错误一起记录。
- en: We can **wrap errors** so that not only can we include more specific information,
    but we can also keep the underlying error for extraction later.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以**包装错误**，这样不仅能包含更具体的信息，还能保留底层的错误，以便以后提取。
- en: 'We do this using `fmt.Errorf()` with `%w` for variable substitution of our
    error type. Let''s say we want to call `someFunc()` from another function called
    `restCall()` and add more information, as illustrated in the following code snippet:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`fmt.Errorf()`并使用`%w`来进行变量替换，传入我们的错误类型。假设我们想要从另一个函数`restCall()`调用`someFunc()`并添加更多信息，代码示例如下：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Someone using `restCall()` can detect and extract an `ErrNetwork` using `errors.As()`,
    just as we did before. The following code snippet provides an illustration of
    this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`restCall()`的人可以通过`errors.As()`检测并提取`ErrNetwork`，就像我们之前做的那样。以下代码片段提供了这个示例：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code extracts the `ErrNetwork` from the wrapped `error` it was
    contained in. This will work no matter how many layers of wrapping the error was
    contained in.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码从被包装的`error`中提取`ErrNetwork`。无论错误被包装了多少层，这都能正常工作。
- en: In this section, you have learned how Go handles errors and about Go's `error`
    type and how to create basic errors, how to create custom errors, how to detect
    specific error types, and how to wrap/unwrap errors. As good `error` handling
    is the basis of reliable software, this knowledge will be useful in every Go program
    you write.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了 Go 如何处理错误，Go 的`error`类型，以及如何创建基本错误、如何创建自定义错误、如何检测特定错误类型以及如何包装/解包错误。因为良好的`error`处理是可靠软件的基础，所以这些知识对你编写的每一个
    Go 程序都将非常有用。
- en: Utilizing Go constants
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 Go 常量
- en: '**Constants** provide values that are set at compile time and cannot change.
    This is in contrast to variables, which store values that can be set at runtime
    and can be altered. This provides types that cannot accidentally be changed by
    a user and are allocated for use in the software on startup, providing some speed
    advantages and safety over variable declarations.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**常量**提供的是编译时设定的值，且无法更改。与此相对的是变量，它存储可以在运行时设置并且可以改变的值。常量提供的是不能被用户意外修改的类型，并且在软件启动时就分配使用，提供了一些速度优势和比变量声明更安全的特性。'
- en: 'Constants can be used to store the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 常量可以用来存储以下内容：
- en: Booleans
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔类型
- en: Runes
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符
- en: Integer types (`int`, `int8`, `uint16`, and so on)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数类型（`int`、`int8`、`uint16` 等）
- en: Floating-point types (`float32`/`float64`)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮动类型（`float32`/`float64`）
- en: Complex data types
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂数据类型
- en: Strings
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: In this section, we will discuss how to **declare constants** and common use
    in your code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何**声明常量**以及在代码中的常见用法。
- en: Declaring a constant
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明常量
- en: 'Constants are declared using the `const` keyword, as illustrated in the following
    code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是使用`const`关键字声明的，如下代码片段所示：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Constants are different from variable types in that they come in two flavors,
    as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 常量与变量类型不同，它们有两种形式，如下所示：
- en: '**Untyped constants**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未类型化常量**'
- en: '**Typed constants**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型化常量**'
- en: This is going to seem a little weird because constants store a typed value.
    But if you don't declare the exact type (as in the third example, `num64`, where
    we declared it to be an `int64` type), the constant can be used for any type that
    has the same base type or family of types (such as integers). This is called an
    **untyped constant**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点奇怪，因为常量存储的是一个类型化的值。但如果你没有声明确切的类型（如第三个示例中的`num64`，我们声明它为`int64`类型），则常量可以用于任何具有相同基础类型或类型家族的类型（例如整数）。这被称为**未类型化常量**。
- en: 'For example, `num` can be used to set the value of an `int8`, `int16`, `int32`,
    `int64`, `uint8`, `uint16`, `uint32`, or `uint64` type. So, the following will
    work:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`num`可以用来设置`int8`、`int16`、`int32`、`int64`、`uint8`、`uint16`、`uint32`或`uint64`类型的值。所以，以下代码是有效的：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While we didn't discuss it earlier, that is what happens when we wrote code
    such as `add (3,` `3)`—`3` is actually an untyped constant. If the signature of
    `add` changed to `add(x,` `y` `int64)`, `add(3,` `3)` works because of this property
    of an untyped constant.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们之前没有讨论过，但这就是我们写出像`add(3,` `3)`这样的代码时发生的情况——`3`实际上是一个未类型化的常量。如果`add`的签名改为`add(x,`
    `y` `int64)`，`add(3,` `3)`仍然能工作，因为未类型化常量的这一特性。
- en: 'This extends to any type based on that basic type. Have a look at the following
    example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于任何基于该基本类型的类型。请看下面的示例：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From the preceding code, you will receive the following output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码，你将会得到以下输出：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is because `varHelloWorld` is a `string` type and not a `specialStr` type.
    But the unique properties of an untyped constant allow for `constHelloWorld` to
    satisfy any type based on `string`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`varHelloWorld`是一个`string`类型，而不是`specialStr`类型。但未类型化常量的独特特性允许`constHelloWorld`满足任何基于`string`的类型。
- en: Enumeration via constants
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过常量进行枚举
- en: Many languages provide an **enumerated type** that gives a readable name to
    some value that cannot be changed. This is most commonly done for integer constants,
    though you can do this for any type of constant.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言提供了**枚举类型**，为一些不可更改的值提供可读的名称。这通常用于整数常量，但你可以对任何类型的常量进行此操作。
- en: 'For integer constants specifically, there is a special `iota` keyword that
    can be used to generate constants. It increments the value by `1` for each constant
    defined in the grouping, as illustrated in the following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数常量，特别是有一个特殊的`iota`关键字，可以用来生成常量。它会为每个在分组中定义的常量递增`1`，如下代码片段所示：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This can also be shortened to have only the first value use `iota`, and the
    following values would also automatically be set. The value can also be set to
    a formula in which `iota` uses a multiplier or other mathematical operation. Here
    is an example of both those concepts:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以简化为只让第一个值使用`iota`，后续的值也会自动设置。该值也可以设置为一个公式，其中`iota`使用乘法器或其他数学运算。下面是这两个概念的示例：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Enumeration with `iota` is great, as long as the values will never be stored
    on disk or sent to another process that is local or remote. The value of constants
    is controlled by the order of the constants in the code. Here, look what happens
    if we insert `c` into our first example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`iota`进行枚举很棒，只要这些值永远不会被存储在磁盘上或传送到本地或远程的其他进程。如果常量的值是由代码中常量的顺序控制的，那么看一下如果我们在第一个示例中插入`c`会发生什么：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice that `d` now has the value of `3`? This would cause serious errors if
    the code needed to read back values that were written to disk and needed to be
    read back in. In cases where these values could be used by another process, it
    is best practice to statically define enumeration values.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`d`现在的值是`3`了吗？如果代码需要读取已经写入磁盘并需要重新读取的值，这会导致严重的错误。在这些值可能被其他进程使用的情况下，最佳实践是静态定义枚举值。
- en: Enumerators in Go can be hard to interpret when printed. Maybe you are using
    them for error codes and would prefer to have the constant's name printed when
    printing the *value* to logs or **standard output** (**stdout**). Let's have a
    look at how we can get better output.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，枚举值打印出来时可能难以解释。也许你在使用它们作为错误码，并希望在打印*值*到日志或**标准输出**（**stdout**）时打印常量的名称。让我们看看如何能得到更好的输出。
- en: Printing enumerators
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印枚举值
- en: Enumerators are much easier to use when displaying a value as the enumerated
    name instead of the value. This can be done easily when the constant is a string
    such as `const toyota = "toyota"`, but for other more efficient enumerator types
    such as integers, printing the value simply outputs a number.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当以枚举名称而不是值来显示一个值时，枚举器的使用会更加简便。当常量是字符串时，如`const toyota = "toyota"`，这可以轻松实现，但对于其他更高效的枚举器类型，如整数，打印该值将仅输出一个数字。
- en: 'Go has the concept of code generation built into the tooling. This is a more
    far-reaching subject than we will cover here (read about it here: [https://blog.golang.org/generate](https://blog.golang.org/generate)).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Go 具有内置的代码生成工具。这是一个比我们在这里讨论的内容更广泛的主题（可以在此阅读：[https://blog.golang.org/generate](https://blog.golang.org/generate)）。
- en: 'However, we will borrow from the linked document to show how this can be used
    to set up an enumerator to a string value for printing automatically, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将借用链接文档中的内容，展示如何利用它来设置枚举器为字符串值，以便自动打印，方法如下：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This requires the Go `stringer` binary to be installed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要安装 Go 的 `stringer` 二进制文件。
- en: '`//go:generate stringer -type=Pill` is a special syntax that indicates that
    when the `go generate` command is run for this package, it should call the `stringer`
    tool and pass it the `-type=Pill` flag, which indicates to read our package code
    and generate a method that reverses the constants based on type `Pill` to a string.
    This will be placed in a file called `pill_string.go`.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`//go:generate stringer -type=Pill` 是一种特殊的语法，表示当运行 `go generate` 命令时，它应调用 `stringer`
    工具并传递 `-type=Pill` 标志，这表示读取我们的包代码并生成一个方法，该方法基于类型 `Pill` 将常量反转为字符串。这将被放置在名为 `pill_string.go`
    的文件中。'
- en: Before running the command, `fmt.Println(Aspirin)` would print `1`; after, it
    would print `Aspirin`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行命令之前，`fmt.Println(Aspirin)` 会打印 `1`；之后，它会打印 `Aspirin`。
- en: In this section, you have learned how constants can provide non-changeable values
    for use in your code, how you can create enumerators with them, and finally, how
    you can generate textual printed output for enumerators for better logging. In
    the next section, we will explore how to use `defer`, `panic`, and `recover` methods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经学习了常量如何提供不可变的值以供在代码中使用，如何使用它们创建枚举器，以及如何为枚举器生成文本输出以便更好地记录日志。在下一节中，我们将探讨如何使用
    `defer`、`panic` 和 `recover` 方法。
- en: Using defer, panic, and recover
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 defer、panic 和 recover
- en: Modern programming languages have a need to provide some method of running routines
    when a section of code ends. This is useful when you need to guarantee a file
    closure or unlock a mutex. In addition, there are times when a program needs to
    stop execution and exit. This can be caused by loss of access to a critical resource,
    a security issue, or another need.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编程语言需要提供某种方法，在一段代码执行完毕时运行某些操作。这在需要保证文件关闭或解锁互斥锁时非常有用。此外，有时程序需要停止执行并退出。这可能是由于无法访问关键资源、安全问题或其他需求导致的。
- en: We also require the ability to recover from a premature program exit caused
    by a package that contains code we do not control. This section will cover each
    of the abilities in Go and their interrelations.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够从程序提前退出的情况中恢复，这种情况通常由我们无法控制的代码包引起。本节将涵盖 Go 中每种能力及其相互关系。
- en: defer
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: defer
- en: The `defer` keyword allows you to execute a function when the function that
    contains `defer` exits. If there are multiple `defer` statements, they execute
    last to first.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer` 关键字允许你在包含 `defer` 的函数退出时执行一个函数。如果有多个 `defer` 语句，它们将按从后到前的顺序执行。'
- en: 'This can be useful for debugging, unlocking mutexes, decrementing counters,
    and so on. Here''s an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于调试、解锁互斥锁、递减计数器等非常有用。以下是一个示例：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This outputs the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also see it at the following link:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过以下链接查看：
- en: '[https://play.golang.org/p/DaoP9M79E_J](https://play.golang.org/p/DaoP9M79E_J)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://play.golang.org/p/DaoP9M79E_J](https://play.golang.org/p/DaoP9M79E_J)'
- en: If you run this example, you will notice that our `defer` statements execute
    after the rest of `printStuff()` has run. We use a deferred anonymous function
    to set our named return `value` before exiting. You will see `defer` used frequently
    in future chapters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个示例，你会注意到我们的 `defer` 语句在 `printStuff()` 的其余部分执行完后才执行。我们使用一个延迟的匿名函数来设置我们命名的返回值
    `value`，然后退出。你将在后续章节中看到 `defer` 被频繁使用。
- en: panic
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: panic
- en: The `panic` keyword is used to cause the execution of the program to stop and
    exit while displaying some text and a stack trace.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`panic` 关键字用于停止程序的执行并退出，同时显示一些文本和堆栈跟踪。'
- en: 'Using `panic` is as simple as calling the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `panic` 只需调用以下内容：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`panic` is intended to be used when a program cannot or should not continue
    to execute. This might be because there is a security issue, or on startup, you
    cannot connect to a required data source.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`panic` 用于程序无法或不应该继续执行时。这可能是因为存在安全问题，或者在启动时无法连接到所需的数据源。'
- en: In most circumstances, a user should return an `error` and not `panic`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，用户应返回 `error` 而不是 `panic`。
- en: As a general rule, only use `panic` in the `main` package.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，只有在 `main` 包中使用 `panic`。
- en: recover
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 恢复
- en: There are rare circumstances in which a program might panic due to an unforeseen
    bug or a package that unnecessarily panics. After more than 10 years of programming
    in Go, I can count on my fingers the number of times I have needed to recover
    from a panic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些罕见的情况下，程序可能因为不可预见的 bug 或某个包不必要的 panic 而崩溃。在超过 10 年的 Go 编程经验中，我可以数出我需要从 panic
    中恢复的次数。
- en: '`recover` to prevent a server crash when an RPC call panics and then signals
    the caller of the issue.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `recover` 来防止在 RPC 调用发生 panic 时导致服务器崩溃，并通知调用者问题。
- en: 'If, like the RPC framework, you need to catch a panic that is occurring or
    protect against potential panics, you can use the `recover` keyword with the `defer`
    keyword. Here is an example of this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像 RPC 框架一样，你需要捕获正在发生的 panic 或防止潜在的 panic，可以结合 `defer` 关键字使用 `recover` 关键字。以下是一个示例：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can also see this here: [https://play.golang.org/p/J8RfjOe1dMh](https://play.golang.org/p/J8RfjOe1dMh).'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在这里查看：[https://play.golang.org/p/J8RfjOe1dMh](https://play.golang.org/p/J8RfjOe1dMh)。
- en: This has similarities to other languages' exception types, but you should not
    confuse the two. Go does not intend for you to use `panic`/`defer`/`recover` in
    that way—it will simply cause you problems in the future.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他语言的异常类型有相似之处，但你不应混淆这两者。Go 并不打算让你以这种方式使用 `panic`/`defer`/`recover`——这样做将会在未来给你带来问题。
- en: 'Now that you have completed this section, you have learned how to defer the
    execution of a function, cause a panic within the `main` package, how to recover
    from a misbehaving package, and when these should be used. Let''s hop onto the
    next topic relevant to this chapter: *goroutines*.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经完成了这一部分，你学习了如何延迟执行函数，如何在 `main` 包中引发 panic，如何从不正常的包中恢复，以及何时应该使用这些功能。让我们进入本章相关的下一个话题：*goroutines*。
- en: Utilizing goroutines for concurrency
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 goroutines 进行并发
- en: In the modern era of computers, **concurrency** is the name of the game. In
    the years before 2005 or so, computers used Moore's law to double the speed of
    a single **central processing unit** (**CPU**) every 18 months. Multiple CPU consumer
    systems were rare and there was one core per CPU in the system. Software that
    utilized multiple cores efficiently was rare.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算机时代，**并发** 是关键。在 2005 年之前的几年，计算机使用摩尔定律每 18 个月就将单个 **中央处理单元**（**CPU**）的速度加倍。多
    CPU 消费者系统很少见，系统中每个 CPU 只有一个核心。高效利用多核的软体系统稀少。
- en: Over time, it became more expensive to increase single-core speed and multi-core
    CPUs have become the norm. Each core on a CPU supports a number of hardware threads
    and **operating systems** (**OSs**) provide OS threads that are mapped to hardware
    threads that are then shared between processes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，增加单核处理器的速度变得更加昂贵，多核 CPU 已成为常态。每个 CPU 核心支持多个硬件线程，**操作系统**（**OS**）提供的
    OS 线程映射到硬件线程，然后在进程之间共享。
- en: Languages can utilize these OS threads to run functions in their language *concurrently*
    instead of *serially* as we have been doing in all of our code so far.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言可以利用这些操作系统线程以 *并发* 的方式运行函数，而不是像我们在代码中一直做的那样 *串行* 执行。
- en: Starting an OS thread is an expensive operation and to fully utilize the thread's
    time requires paying a lot of attention to what you are doing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 启动操作系统线程是一个昂贵的操作，要充分利用线程的时间，需要特别关注你正在做的事情。
- en: Go takes this to another level than most languages with **goroutines**. Go has
    built a runtime scheduler that maps these goroutines onto OS threads and switches
    which routine is running on which thread to optimize CPU utilization.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Go 在这一点上超越了大多数语言，使用 **goroutines**。Go 构建了一个运行时调度器，将这些 goroutines 映射到操作系统线程，并切换哪个
    goroutine 在哪个线程上运行，以优化 CPU 的使用。
- en: This produces concurrency that is easy and cheap to use, requiring less mental
    burden on the developer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了易于使用且成本低廉的并发，减少了开发人员的心理负担。
- en: Starting a goroutine
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动一个 goroutine
- en: 'Go gets its name from the `go` keyword that is used to spawn a goroutine. By
    applying `go` before a function call, you can cause that function to execute concurrently
    with the rest of the code. Here is an example that causes 10 goroutines to be
    created, with each printing out a number:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Go得名于`go`关键字，它用于启动一个goroutine。通过在函数调用前加上`go`，您可以使该函数与其余代码并发执行。以下是一个示例，它创建了10个goroutine，每个打印一个数字：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output will look similar to, but not necessarily in the same order as,
    what is shown next. `...` indicates more numbers follow, but have been omitted
    for brevity:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于但不一定与下面显示的顺序相同。`...`表示后面还有更多数字，但为简洁起见已省略。
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can see the preceding example here:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到前面的例子：
- en: '[https://play.golang.org/p/RBD3yuBA3Gd](https://play.golang.org/p/RBD3yuBA3Gd)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://play.golang.org/p/RBD3yuBA3Gd](https://play.golang.org/p/RBD3yuBA3Gd)'
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will also notice that this panics with an error after running. This is because
    the program will have no running goroutines, which means the program is effectively
    dead. It is killed by Go's deadlock detector. We will handle this more gracefully
    in the next chapter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行后，您还会注意到此处出现错误。这是因为程序没有运行的goroutines，这意味着程序实际上已经死了。它被Go的死锁检测器杀死。我们将在下一章更加优雅地处理这个问题。
- en: Running this will print out the numbers in random order. Why random? Once you
    are running concurrently, you cannot be sure when a scheduled function will execute.
    At any given moment, there will be between 0 and 10 goroutines executing `fmt.Println(x)`,
    and another one executing `fmt.Println("hello")`. That's right—the `main()` function
    is its own goroutine.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将以随机顺序打印出数字。为什么是随机的呢？因为一旦并发运行，您不能确定何时调度函数将执行。在任何给定时刻，将会有0到10个goroutines执行`fmt.Println(x)`，还有另一个执行`fmt.Println("hello")`。没错，`main()`函数本身就是一个goroutine。
- en: Once the `for` loop ends, `fmt.Println("hello")` will execute. `hello` might
    be printed out before any of the numbers, somewhere in the middle, or after all
    the numbers. This is because they are all executing at the same time like horses
    on a racetrack. We know all the horses will reach the end, but we don't know which
    one will be first.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`for`循环结束，`fmt.Println("hello")`将会执行。`hello`可能会在任何数字之前、中间某处或者所有数字之后打印出来。这是因为它们都像赛马一样同时执行。我们知道所有赛马最终都会到达终点，但我们不知道哪匹会第一个到达。
- en: Synchronization
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步
- en: 'When doing **concurrent programming**, there is a simple rule: *You can read
    a variable concurrently without synchronization, but a single writer requires
    synchronization.*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行**并发编程**时，有一个简单的规则：*您可以同时读取一个变量而无需同步，但单个写入者需要同步。*
- en: 'These are the most common methods of synchronization in Go:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Go中最常见的同步方法：
- en: The `channel` data type to exchange data between goroutines
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在goroutines之间交换数据的`channel`数据类型
- en: '`Mutex` and `RWMutex` from the `sync` package to lock data access'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`sync`包的`Mutex`和`RWMutex`用于锁定数据访问
- en: '`WaitGroup` from the `sync` package to track access'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于跟踪访问的`sync`包中的`WaitGroup`
- en: These can be used to prevent multiple goroutines from reading and writing to
    variables at the same time. It is undefined what happens if you try to read and
    write to the same variable from multiple goroutines simultaneously (in other words,
    *that is a bad idea*).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以用来防止多个goroutines同时读写变量。如果尝试从多个goroutines同时读写同一变量，则结果是未定义的（换句话说，*这是个坏主意*）。
- en: 'Reading and writing to the same variable concurrently is called a **data race**.
    Go has a data race detector not covered in this book to uncover these types of
    problems. You can read about it here: [https://golang.org/doc/articles/race_detector](https://golang.org/doc/articles/race_detector).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 同时读写同一变量被称为**数据竞争**。Go有一个数据竞争检测器，本书未涵盖这些问题，可以在这里阅读更多信息：[https://golang.org/doc/articles/race_detector](https://golang.org/doc/articles/race_detector)。
- en: WaitGroups
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WaitGroups
- en: A `WaitGroup` is a synchronization counter that only has positive values starting
    at 0\. It is most often used to indicate when some set of tasks is finished before
    executing code that relies on those tasks.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitGroup`是一个同步计数器，其值从0开始，只有正值。它通常用于指示某些任务完成后再执行依赖于这些任务的代码。'
- en: 'A `WaitGroup` has a few methods, as outlined here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitGroup`有几个方法，如下所述：'
- en: '`.Add(int)`: Used to add some number to the `WaitGroup`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Add(int)`: 用于向`WaitGroup`添加某个数字'
- en: '`.Done()`: Subtract 1 from the `WaitGroup`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Done()`: 从`WaitGroup`减去1'
- en: '`.Wait()`: Block until `WaitGroup` is 0'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.Wait()`: 阻塞，直到`WaitGroup`为0'
- en: In our previous section on goroutines, we had an example that *panicked* after
    running. This was due to having all goroutines stopped. We used a `select` statement
    (covered in this chapter) to block forever to prevent the program from exiting
    before the goroutines could run, but we can use a `WaitGroup` to wait for our
    goroutines to end and exit gracefully.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前关于goroutine的部分，我们有一个示例在运行后*发生了panic*。这是因为所有的goroutine都停止了。我们使用了`select`语句（本章会介绍）来阻塞直到永远，防止程序在goroutine运行之前退出，但我们可以使用`WaitGroup`来等待goroutine结束并优雅地退出。
- en: 'Let''s do it again, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再做一遍，如下所示：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can also see this here: [https://play.golang.org/p/cwA3kC-d3F6](https://play.golang.org/p/cwA3kC-d3F6).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在这里看到这个示例：[https://play.golang.org/p/cwA3kC-d3F6](https://play.golang.org/p/cwA3kC-d3F6)。
- en: This example uses a `WaitGroup` to track the number of goroutines that are outstanding.
    We add 1 to `wg` before we launch our goroutine (*do not add it inside the goroutine*).
    When the goroutine exits, the `defer` statement is called, which subtracts 1 from
    the counter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例使用`WaitGroup`来跟踪尚未完成的goroutine数量。我们在启动goroutine之前将`wg`加1（*不要在goroutine内部加*）。当goroutine退出时，会调用`defer`语句，从计数器中减去1。
- en: Important Note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A `WaitGroup` can only have positive values. If you call `.Done()` when the
    `WaitGroup` is at 0, it will cause a panic. Because of the way they are used,
    the creators knew that any attempt to reach a negative value would be a critical
    bug that needs to be caught early.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`WaitGroup`只能有正值。如果在`WaitGroup`为0时调用`.Done()`，将会引发panic。由于它们的使用方式，创建者知道任何试图使其达到负值的操作都会是一个需要尽早捕获的严重bug。'
- en: '`wg.Wait()` waits for all the goroutines to finish, and calling `defer wg.Done()`causes
    our counter to decrement until it reaches 0\. At that point, `Wait()` stops blocking
    and the program exits the `main()` function.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`wg.Wait()`等待所有的goroutine完成，调用`defer wg.Done()`会使我们的计数器递减直到为0。此时，`Wait()`停止阻塞，程序退出`main()`函数。'
- en: Important Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If passing a `WaitGroup` in a function or method call, you need to use a `wg
    := &sync.WaitGroup{}` pointer. Otherwise, each function is operating on a copy,
    not the same value. If used in a struct, either the struct or the field holding
    the `WaitGroup` must be a pointer.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在函数或方法调用中传递`WaitGroup`，你需要使用`wg := &sync.WaitGroup{}`指针。否则，每个函数操作的是副本，而不是相同的值。如果`WaitGroup`在结构体中使用，则结构体或持有`WaitGroup`的字段必须是指针类型。
- en: Channels
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道
- en: '**Channels** provide a synchronization primitive in which data is inserted
    into a channel by a goroutine and removed by another goroutine. A channel can
    be buffered, meaning it can hold a certain amount of data before blocking, or
    unbuffered, where a sender and receiver must both be present for the data to transfer
    between goroutines.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**通道**提供了一种同步原语，其中数据由一个goroutine插入到通道中，并由另一个goroutine移除。通道可以是有缓冲区的，这意味着它可以在阻塞之前容纳一定量的数据；也可以是无缓冲区的，在这种情况下，发送方和接收方必须同时存在，数据才能在goroutine之间传递。'
- en: 'A common analogy for a channel is a pipe in which water flows. Water is inserted
    into a pipe and flows out the far side. The amount of water that can be held in
    the pipe is the buffer. Here, you can see a representation of goroutine communication
    using a channel:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的常见类比是水流通过的管道。水被注入管道，然后从另一端流出。管道可以容纳的水量就是缓冲区的大小。在这里，你可以看到使用通道进行goroutine通信的示意图：
- en: '![Figure 2.1 – Goroutine communication using a channel'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.1 – 使用通道进行goroutine通信'
- en: '](img/B17626_02_001.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_02_001.jpg)'
- en: Figure 2.1 – Goroutine communication using a channel
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 使用通道进行goroutine通信
- en: Channels are used to pass data from one goroutine to another, where the goroutine
    that passed the data stops using it. This allows you to pass *control* from one
    goroutine to another, giving access to a single goroutine at a time. This provides
    synchronization.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通道用于将数据从一个goroutine传递到另一个goroutine，其中传递数据的goroutine停止使用该数据。这允许你将*控制*从一个goroutine传递到另一个goroutine，每次只允许一个goroutine访问。这提供了同步机制。
- en: 'Channels are typed, so only data of that type can go into the channel. Because
    channels are a pointer-scoped type such as `map` and `slice`, we use `make()`
    to create them, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是有类型的，因此只能将该类型的数据发送到通道中。由于通道是类似于`map`和`slice`的指针作用域类型，因此我们使用`make()`来创建它们，如下所示：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding statement creates a channel called `ch` that holds a `string`
    type with a buffer of 1\. Leaving "`,` `1`" off will make it an unbuffered channel.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语句创建了一个名为`ch`的通道，该通道持有`string`类型的数据，且具有大小为1的缓冲区。如果省略"`,` `1`"，则会创建一个无缓冲区的通道。
- en: Sending/receiving
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送/接收
- en: 'Sending to a channel is done with the `<-` syntax. To send a `string` type
    to the preceding channel, we could do the following: `ch <- "word"`. This attempts
    to put the "`word"` string into the `ch` channel. If the channel has an available
    buffer, we continue execution in this goroutine. If the buffer is full, this blocks
    until either buffer becomes available or—in the case of unbuffered channels—a
    goroutine tries to pull from the channel.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<-` 语法发送到通道。要将 `string` 类型发送到前述通道，我们可以这样做：`ch <- "word"`。这试图将 "`word`" 字符串放入
    `ch` 通道中。如果通道有可用缓冲区，我们继续在此 goroutine 中执行。如果缓冲区已满，则阻塞，直到缓冲区变得可用或在无缓冲通道的情况下，goroutine
    尝试从通道中取出。
- en: 'Receiving is similar using the same syntax but on the opposite side of the
    channel. The goroutine trying to pull from the channel would do this: `str :=
    <-ch`. This assigns the next value on the channel to the `str` variable.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接收类似于在通道的对面使用相同的语法。试图从通道中拉取值的 goroutine 将执行此操作：`str := <-ch`。这将通道上的下一个值分配给 `str`
    变量。
- en: 'More commonly when receiving variables, the `for range` syntax is used. This
    allows us to pull all values out of a channel. An example using our preceding
    channel might look like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的情况是在接收变量时使用 `for range` 语法。这使我们可以从通道中取出所有值。使用我们前述的通道的示例可能如下所示：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Channels can be closed so that no more data will be sent to them. This is done
    with the `close` keyword. To close the preceding channel, we could do `close(ch)`.
    This should *always* be done by the sender. Closing a channel will cause a `for
    range` loop to exit once all values on the channel have been removed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通道可以关闭，这样将不会再向其发送数据。这是使用 `close` 关键字完成的。要关闭前述通道，我们可以执行 `close(ch)`。这应该 *始终*
    由发送方执行。关闭通道将导致 `for range` 循环在通道上的所有值都被移除后退出。
- en: 'Let''s use a channel to send words from one goroutine to another, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用通道从一个 goroutine 发送单词到另一个 goroutine，如下所示：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can also see the preceding example here:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在此处看到前述示例：
- en: '[https://go.dev/play/p/9km80Jz6f26](https://go.dev/play/p/9km80Jz6f26)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://go.dev/play/p/9km80Jz6f26](https://go.dev/play/p/9km80Jz6f26)'
- en: Important Note
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: After a channel is closed, sending a value on a channel will cause a panic.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在通道关闭后，向通道发送值将导致 panic。
- en: Receiving from a closed channel will return the zero value of the type the channel
    holds.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从关闭的通道接收将返回通道持有类型的零值。
- en: A channel can be `nil`. Sending or receiving from a `nil` channel can block
    forever. It is a common bug for developers to forget to initialize channels in
    a struct.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通道可以是 `nil`。从 `nil` 通道发送或接收可能会永久阻塞。开发人员常常忘记在结构体中初始化通道，这是一个常见的 bug。
- en: select statements
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: select 语句
- en: A `select` statement is similar to a `switch` statement but is geared toward
    listening to multiple channels. This allows us to receive and act on multiple
    inputs at the same time.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 语句类似于 `switch` 语句，但专注于监听多个通道。这使我们能够同时接收和处理多个输入。'
- en: 'The following example will listen to several channels and execute a `case`
    statement whenever it receives a value on one of them. In the example cases, we
    spin off a goroutine to do something with the value so that we can continue the
    execution of our loop for the next value. If no value is present on the channel,
    this blocks until one is. If values are on more than one channel, `select` uses
    a pseudo-random method to select which case to execute:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例将监听几个通道，并在收到其中一个通道的值时执行 `case` 语句。在示例 case 中，我们启动一个 goroutine 来处理值，以便我们可以继续执行我们的循环以获取下一个值。如果通道上没有值，则会阻塞直到有值。如果多个通道上有值，则
    `select` 使用伪随机方法选择要执行的 case：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With a `select` statement, we sometimes only want to check if a value is on
    a channel, but if it is not, then we want to move on. In those cases, we can use
    a `default` statement. `default` executes if no other case statement can execute
    (versus the previous behavior of waiting for channel data indefinitely). You can
    see an example of this in the following code snippet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `select` 语句时，有时我们只想检查通道上是否有值，如果没有，我们希望继续执行。在这些情况下，我们可以使用 `default` 语句。如果没有其他
    case 语句可以执行（与以前等待通道数据无限期的行为相反），则 `default` 会执行。您可以在以下代码片段中看到此示例：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`select` has one more use we saw before but it wasn''t explained. `select{}`
    has no case statements and no default statement; therefore, it blocks forever.
    This is often used by servers that want to run forever to prevent the `main()`
    function from exiting, which stops the execution of the program.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`select` 还有一个我们之前见过但没有解释的用法。`select{}` 没有 `case` 语句和 `default` 语句，因此它会永远阻塞。这通常用于希望永远运行的服务器，防止
    `main()` 函数退出，从而停止程序的执行。'
- en: Channels as an event signal
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道作为事件信号
- en: One common use of channels is to use them to send a signal to another goroutine.
    Often, this is an indication to exit a loop or some other execution.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通道的一个常见用法是用于向另一个 goroutine 发送信号。通常，这是指示退出循环或其他某些执行的信号。
- en: 'In the `select` example from before where we used the `for` loop, the loop
    will continue forever, but we can use a channel to signal that we want to exit,
    as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 `select` 示例中，我们使用了 `for` 循环，循环将永远继续下去，但我们可以使用通道来发出退出信号，如下所示：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`printWords()` reads input off of three channels. If the input is on `in1`
    or `in2`, it prints the channel name and what string was sent on the channel.
    If it is the `exit` channel, it prints that it is exiting and returns. When returning,
    `wg` will have `.Done()` called on it, which will decrement the it by 1:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`printWords()` 从三个通道读取输入。如果输入来自 `in1` 或 `in2`，它会打印通道名称和发送的字符串。如果是 `exit` 通道，它会打印退出信息并返回。当返回时，`wg`
    将调用 `.Done()`，使其值减 1：'
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here we create all the channels required for `printWords()` and spin `printWords`
    off in a goroutine. We then send input on our input channels and once that is
    completed, we close the `exit` channel to signal there is no further input to
    `printWords`. The `wg.Wait()` call prevents `main()` from exiting until `printWords`
    has exited.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了 `printWords()` 所需的所有通道，并将 `printWords` 放入 goroutine 中执行。然后，我们通过输入通道发送输入，一旦输入完成，我们关闭
    `exit` 通道以表明没有更多输入需要传递给 `printWords`。`wg.Wait()` 调用会阻止 `main()` 在 `printWords`
    退出之前退出。
- en: 'The output looks like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also see the preceding example at the following link:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过以下链接查看前面的示例：
- en: '[https://play.golang.org/p/go7Klf5JNQn](https://play.golang.org/p/go7Klf5JNQn)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://play.golang.org/p/go7Klf5JNQn](https://play.golang.org/p/go7Klf5JNQn)'
- en: '`exit` is used in this example to signal to `printWords()` that we want to
    exit the `for` loop. This is made possible because receiving on a closed channel
    returns the zero value of the type that the channel holds. We use a blank `struct{}`
    instance because it doesn''t cost memory. We do not store the returned value in
    a variable because it is the signal that the channel closed that is important.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`exit` 用于向 `printWords()` 发送信号，告诉它我们希望退出 `for` 循环。这得以实现是因为在关闭的通道上接收会返回该通道持有类型的零值。我们使用一个空的
    `struct{}` 实例，因为它不占用内存。我们不将返回值存储在变量中，因为重要的是通道关闭时的信号。
- en: Mutexes
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mutexes
- en: A `sync` package called `Mutex`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `Mutex` 的 `sync` 包。
- en: This is used to protect a variable or set of variables from being accessed by
    multiple goroutines. Remember—if one goroutine tries to write to a value at the
    same time another wants to read or write to that value, the variable must be protected
    by a synchronization primitive.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于保护一个变量或一组变量，防止它们被多个 goroutine 同时访问。记住——如果一个 goroutine 尝试在另一个 goroutine 正在读取或写入同一个值时进行写入，变量必须通过同步原语来保护。
- en: 'In the following example, we will spin off 10 goroutines to add a number to
    a `sum` value. The `sum` value must be protected as we are reading and writing
    from multiple goroutines:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将启动 10 个 goroutine 来向 `sum` 值添加数字。由于我们在多个 goroutine 中进行读写操作，必须保护 `sum`
    值：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can also see this example at the following link:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过以下链接查看此示例：
- en: '[https://play.golang.org/p/mXUk8PCzBI7](https://play.golang.org/p/mXUk8PCzBI7)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://play.golang.org/p/mXUk8PCzBI7](https://play.golang.org/p/mXUk8PCzBI7)'
- en: This code uses a Mutex named `mu` that is part of the `sum` struct to control
    access to the `get()` and `add()` methods. As each is locked, only one of those
    may execute at a time. We use the `defer` statement to unlock the Mutex when the
    function exits. This protects us from forgetting to unlock the Mutex when a function
    gets long.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了一个名为 `mu` 的 Mutex，它是 `sum` 结构体的一部分，用于控制对 `get()` 和 `add()` 方法的访问。由于每次加锁，因此只有一个方法可以同时执行。我们使用
    `defer` 语句在函数退出时解锁 Mutex。这可以防止在函数变长时忘记解锁 Mutex。
- en: RWMutex
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RWMutex
- en: Along with `sync.Mutex` is `sync.RWMutex`. This distinguishes itself by providing
    a read and write lock. Any number of `mu.RLock()` read locks may be held at a
    time, but a single `mu.Lock()` write lock waits for all existing read locks to
    complete (new `Rlock()` attempts block) and then provides the writer with exclusive
    access.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `sync.Mutex` 一起使用的是 `sync.RWMutex`。它通过提供读写锁来区分自己。可以同时持有任意数量的 `mu.RLock()`
    读锁，但只有一个 `mu.Lock()` 写锁，且必须等待所有现有的读锁完成（新的 `Rlock()` 尝试会被阻塞），然后为写入者提供独占访问权限。
- en: This proves to be faster when there are lots of concurrent readers and writing
    happens infrequently. However, the standard `Mutex` is faster in the generalized
    case because its implementation is less complicated.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当并发读取量较大且写入操作不频繁时，这种方式证明更为高效。然而，标准的 `Mutex` 在通用情况下更为高效，因为它的实现更加简单。
- en: In this section, you have gained basic skills in using goroutines for concurrent
    operations, learned what synchronization is and when you must use it, and learned
    about Go's various methods for synchronization and signaling. Let's dive into
    understanding another type, known as `context`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经掌握了使用 goroutine 进行并发操作的基本技能，了解了什么是同步以及何时需要使用同步，还了解了 Go 的各种同步和信号传递方法。让我们深入理解另一种类型，称为
    `context`。
- en: Understanding Go's Context type
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Go 的 `Context` 类型
- en: 'Go provides a package called `context` that is useful for two purposes, as
    outlined here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一个名为 `context` 的包，具有以下两个主要用途：
- en: Canceling a chain of function calls after some event (such as a timeout)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些事件（例如超时）发生后取消一连串的函数调用
- en: Passing information through a chain of function calls (such as user information)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一系列函数调用中传递信息（例如用户信息）
- en: 'A `Context` object is usually created in either `main()` or at the point of
    ingestion of some request (such as an RPC or `Context` object is created from
    our background `Context` object, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context` 对象通常在 `main()` 函数中创建，或者在某些请求（如 RPC）被处理时创建（例如从我们的后台 `Context` 对象中创建
    `Context` 对象，如下所示）。'
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `context` package and the `Context` type is an advanced subject, but I want
    to introduce it here as you will see it used throughout the Go ecosystem.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`context` 包和 `Context` 类型是一个高级主题，但我想在这里介绍它，因为你会在 Go 生态系统中看到它的使用。'
- en: Using a Context to signal a timeout
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `Context` 信号来表示超时
- en: '`Context` is often used to communicate a timer state or to terminate a wait
    condition—for example, when your program is waiting for a network response.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context` 通常用于传递计时器状态或终止等待条件——例如，当程序等待网络响应时。'
- en: 'Let''s say we want to call a function to get some data, but we don''t want
    to wait longer than 5 seconds for the call to complete. We can signal this via
    a `Context`, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要调用一个函数来获取一些数据，但我们不希望等待超过 5 秒钟才能完成调用。我们可以通过 `Context` 来传达这一信号，如下所示：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`context.WithTimeout()` creates a new `Context` that will automatically be
    canceled after 5 seconds and a function that will cancel the `Context` (`context.CancelFunc`)
    when called.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`context.WithTimeout()` 创建一个新的 `Context`，它将在 5 秒后自动取消，并且创建一个可以取消该 `Context`
    的函数（`context.CancelFunc`）。'
- en: Every `Context` is said to be derived from another `Context`. Here, we derive
    our `ctx` object from `context.Background()`. `context.Background()` is our parent
    `Context`. New `context` objects can be derived from `ctx` forming a chain, and
    those new `Context` objects can have different timeouts.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Context` 都是从另一个 `Context` 派生出来的。在这里，我们从 `context.Background()` 派生我们的 `ctx`
    对象。`context.Background()` 是我们的父 `Context`。新的 `context` 对象可以从 `ctx` 派生，形成一个链条，这些新的
    `Context` 对象可以有不同的超时时间。
- en: Canceling a `Context` either directly via `cancel()` or with a timeout or deadline
    causes that `Context` and its children to also be canceled.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 直接通过 `cancel()` 或通过超时或截止日期取消 `Context` 会导致该 `Context` 及其子 `Context` 被一起取消。
- en: 'The preceding code does the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码执行了以下操作：
- en: Creates a `Context` that is canceled after 5 seconds.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个在 5 秒后取消的 `Context`。
- en: Calls `GatherData()` and passes the `Context`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `GatherData()` 并传递 `Context`。
- en: Once the call is complete, we cancel the `Context` if not already canceled.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦调用完成，如果 `Context` 还没有被取消，我们就会取消它。
- en: Now, we need to set up `GatherData()` to honor our `Context` cancellation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要设置 `GatherData()` 以响应我们的 `Context` 取消请求。
- en: Honoring a context when receiving
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在接收时遵守上下文
- en: 'If we are executing the `GatherData()` function, we need to honor this context.
    There are a few ways to do that with a basic call to `ctx.Err()`, as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在执行 `GatherData()` 函数，我们需要遵守这个上下文。可以通过几种方式来做到这一点，最基本的是调用 `ctx.Err()`，如下所示：
- en: '[PRE36]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`GatherData()` looks at `ctx.Err()` and checks the value to see if it returns
    an error. If so, we know the `Context` has been canceled and simply return.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`GatherData()`检查`ctx.Err()`的值，看是否返回错误。如果是的话，我们知道`Context`已经被取消，直接返回即可。'
- en: In this example, we derive two new `Context` objects that share the parent of
    `ctx`. If `ctx` is canceled, `localCtx` and `remoteCtx` are canceled. Canceling
    `localCtx` or `remoteCtx` has no effect on `ctx`. In most circumstances, passing
    `ctx` instead of deriving new `Context` objects is done, but we wanted to show
    how you derive new `Context` objects.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们派生了两个新的`Context`对象，它们共享`ctx`的父级。如果`ctx`被取消，`localCtx`和`remoteCtx`也会被取消。取消`localCtx`或`remoteCtx`不会影响`ctx`。在大多数情况下，传递`ctx`而不是派生新的`Context`对象是常见做法，但我们希望展示如何派生新的`Context`对象。
- en: '`Context` also supports a `.Done()` method in case you need to check for cancellation
    inside a `select` statement. `.Done()` returns a channel that, if closed, indicates
    cancellation. Using it is simple, as we can see here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`还支持`.Done()`方法，如果你需要在`select`语句中检查取消状态，可以使用`.Done()`。`.Done()`返回一个通道，如果该通道关闭，则表示已取消。使用它非常简单，如下所示：'
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that we have shown you how you should add `Context` to your functions, let's
    talk about how this works in the standard library and why it is not the same as
    the examples we have shown.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经展示了如何将`Context`添加到你的函数中，让我们来谈谈它是如何在标准库中工作的，以及为什么它与我们展示的例子不同。
- en: Context in the standard library
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准库中的`Context`
- en: The `context` package was added in **Go 1.7**, well after the introduction of
    Go's standard library. Unfortunately, this meant that it had to be hacked into
    the standard library packages in order to avoid breaking Go's version 1.0-compatibility
    promise.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`包是在**Go 1.7**中新增的，远晚于Go标准库的引入。不幸的是，这意味着它不得不被“黑客”加入标准库包中，以避免破坏Go 1.0的兼容性承诺。'
- en: This is the one thing added to Go that has added some real ugliness. Previously,
    we showed you how when using `Context` it should be the first argument of a function
    called `ctx`. However, the standard library cannot do this.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Go语言中新增的一个特性，但它也带来了一些丑陋的部分。之前我们向你展示了如何使用`Context`，它应该作为函数的第一个参数`ctx`传入。然而，标准库并未按此方式实现。
- en: 'A common pattern you will see when using `Context` in the standard library
    will be to add it via a method. Here is an example of using `Context` for `http.Client`
    to fetch `www.golang.org` and print it to the screen:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准库中使用`Context`时，你会看到一个常见的模式，那就是通过方法将其添加进来。这里有一个例子，展示了如何使用`Context`与`http.Client`来获取`www.golang.org`并打印到屏幕上：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In this code we do the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们做了以下操作：
- en: Create an `HTTP` client
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`HTTP`客户端
- en: Create a `*http.Request (req)` to get the page at [www.golang.org](http://www.golang.org)
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`*http.Request (req)`以获取[www.golang.org](http://www.golang.org)页面。
- en: Create `Context` (`ctx`) and `CancelFunc` (cancel) where the `Context` is cancelled
    after 3 seconds
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`Context`（`ctx`）和`CancelFunc`（`cancel`），其中`Context`会在3秒后被取消。
- en: Attach `ctx` to `req` to prevent `*http.Request` from taking longer than 3 seconds
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`ctx`附加到`req`，以防止`*http.Request`超时超过3秒。
- en: Uses `cancel()` to cancel the Context's internal goroutine that is tracking
    the timeout once the `client.Do()` call has completed
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`cancel()`来取消`Context`的内部goroutine，该goroutine在`client.Do()`调用完成后追踪超时。
- en: So far, we have talked about how to use C`ontext` for cancellation. Now let's
    talk about another use of `Context`—passing values through a call chain.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何使用`Context`进行取消操作。现在让我们谈谈`Context`的另一个用途——在调用链中传递值。
- en: Context to pass values
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用`Context`传递值
- en: A Context's other main use is to pass a value through a `Context` to pass values
    that are useful on a per-call basis, not as generalized storage.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`的另一个主要用途是传递值，目的是传递那些在每次调用时都有用的值，而非作为通用存储。'
- en: 'These are the two best uses for passing values on a `Context`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况是传递值给`Context`的最佳用途：
- en: Security information about a user making a call.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户发起调用时的安全信息。
- en: Telemetry information such as the data types used with *OpenTelemetry*.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如*OpenTelemetry*中使用的数据类型等遥测信息。
- en: In the case of security information, you are informing the system who the user
    is, probably with **OpenID Connect** (**OIDC**) information. This allows the call
    stack to make authorization checks.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在安全信息的情况下，你正在通知系统用户是谁，可能是通过**OpenID Connect**（**OIDC**）信息。这使得调用栈能够进行授权检查。
- en: For telemetry, this allows a service to record information related to this specific
    call to track function execution times, database latency, input, and errors. This
    can be dialed up or down to debug service issues. We discuss telemetry in future
    chapters.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于遥测，这允许服务记录与特定调用相关的信息，用于跟踪函数执行时间、数据库延迟、输入和错误。这可以调节用于调试服务问题。我们将在后续章节讨论遥测。
- en: 'Passing a value to a `Context` requires a little care. Values stored in a context
    are key-value pairs, and to prevent overwriting of keys between multiple packages,
    we need to create our own custom key type that can only be implemented by our
    package. In this way, keys from different packages will have different types.
    The code to achieve this is shown in the following snippet:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `Context` 传递一个值需要小心。存储在 `Context` 中的值是键值对，为了防止多个包之间的键被覆盖，我们需要创建自己的自定义键类型，该类型只能由我们的包实现。通过这种方式，不同包的键将具有不同的类型。实现此功能的代码如下所示：
- en: '[PRE39]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This code does the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: Defines a type called `key` that is private, which prevents other packages from
    implementing it
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个名为 `key` 的私有类型，防止其他包实现它
- en: Defines a `claimsKey` constant of type `key`. This is used as the key for a
    value that holds an OIDC `IDToken` claim
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个类型为 `key` 的 `claimsKey` 常量。它作为存储 OIDC `IDToken` 声明的值的键
- en: '`NewContext()` provides a function that attaches a `Claim` to our `Context`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewContext()` 提供一个函数，将 `Claim` 附加到我们的 `Context` 上'
- en: '`ClaimsFromContext()` provides a function that extracts `Claims` from a `Context`
    and indicates if `Claims` were found'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClaimsFromContext()` 提供一个函数，从 `Context` 中提取 `Claims` 并指示是否找到了 `Claims`'
- en: The preceding code might exist in a security package for `Claims` would represent
    user data we have validated. `NewContext()` would allow us to add this information
    to a context in some middleware, and `ClaimsFromContext()` would allow us to extract
    it anywhere in the call chain that was required.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码可能存在于一个安全包中，因为 `Claims` 代表我们已验证的用户数据。`NewContext()` 允许我们在某些中间件中将此信息添加到上下文中，而
    `ClaimsFromContext()` 允许我们在调用链中需要的地方提取该信息。
- en: Best practices
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最佳实践
- en: I recommend that all public functions and methods have an initial argument of
    `ctx context.Context`. This allows you to add future-proofing to your public functions/methods/interfaces
    if you need to add capabilities that `Context` provides at a later date, even
    if you aren't using it now.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议所有公共函数和方法都应有一个初始参数 `ctx context.Context`。这样可以让你为公共函数/方法/接口添加未来兼容性，如果将来需要添加
    `Context` 提供的功能，即使现在没有使用它，也能轻松做到。
- en: Important Note
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Future-proofing methods/functions/interfaces is a practice of adding arguments
    and return values that are not used at the moment in order to prevent breaking
    them (and users) at some future date—for example, adding a returned `error` for
    a constructor that cannot currently return an error, but might in the future.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 未来兼容方法/函数/接口是指添加当前未使用的参数和返回值，以防止将来某个时间点破坏它们（和用户）——例如，为一个当前无法返回错误的构造函数添加一个返回的
    `error`，但将来可能会返回。
- en: Maybe you won't need to handle cancellations (execution is too fast or can't
    be canceled), but something such as adding telemetry might come in handy later.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你不需要处理取消（执行过快或无法取消），但添加遥测功能可能在以后会派上用场。
- en: In this section, you learned about Go's `Context` object and how it is used
    to signal cancellation and to pass values through the call stack. You will see
    this used in many of the third-party packages you will use in your code. The final
    topic of this chapter will be about *Go's testing package*. Let's dive right into
    it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你了解了 Go 的 `Context` 对象及其如何用于发出取消信号并通过调用堆栈传递值。你将会在许多第三方包中看到它的使用。该章节的最后一部分将讨论
    *Go 的测试包*。让我们立即深入探讨。
- en: Utilizing Go's testing framework
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Go 的测试框架
- en: '**Testing** is one of the most important and least loved parts of any language.
    Testing provides a developer with the knowledge that something works as expected.
    I cannot count the times that writing unit tests has proven that a function or
    method did not work the way I expected. This saved countless hours of debugging.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试** 是任何编程语言中最重要且最不受欢迎的部分之一。测试能让开发者知道某些功能是否按预期工作。我无法计数多少次编写单元测试证明某个函数或方法没有按预期工作。这为我节省了无数的调试时间。'
- en: 'To this end, tests need to have the following attributes:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，测试需要具备以下特性：
- en: Easy to write
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于编写
- en: Fast to execute
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行速度快
- en: Simple to refactor
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单重构
- en: Effortless to understand
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易理解
- en: 'To satisfy these needs, Go tackles tests by doing the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这些需求，Go 通过以下方式处理测试：
- en: Breaking tests into their own files
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试拆分到独立的文件中
- en: Providing a simple `testing` package
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个简单的 `testing` 包
- en: Using a testing methodology called **table-driven tests** (**TDTs**)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一种名为 **表驱动测试**（**TDTs**）的测试方法论
- en: In this section, we will cover how to write basic tests, Go's standard TDT methodology,
    creating fakes with interfaces, and—finally—some third-party packages that I used
    and others that are popular, but I don't necessarily recommend.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍如何编写基本测试、Go 的标准 TDT 方法论、通过接口创建虚拟对象，以及—最后—我使用过的一些第三方包和一些流行但不一定推荐的包。
- en: Creating a basic test file
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基本的测试文件
- en: Go tests are contained in package files with a `_test.go` suffix. These files
    have the same package name, and you can include as many test files as needed.
    The usual rule is to write a test file per package file you want to test so that
    there is a 1:1 association for clarity.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Go 测试包含在以 `_test.go` 结尾的包文件中。这些文件具有相同的包名，你可以根据需要包含任意数量的测试文件。通常的规则是，每个你想要测试的包文件写一个测试文件，以确保一一对应，便于清晰。
- en: 'Each test in a test file is a function whose name is prefixed with `Test` and
    has a single argument, `t *testing.T`, with no returns. This is how it looks:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试在测试文件中都是一个函数，函数名以 `Test` 为前缀，并且有一个参数 `t *testing.T`，没有返回值。代码如下所示：
- en: '[PRE40]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`t` is passed by the `go test` command and provides the necessary utilities
    for our tests. The primary methods used are listed here:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`t` 是由 `go test` 命令传递的，提供了执行测试所需的工具。常用的方法列举如下：'
- en: '`t.Error()`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Error()`'
- en: '`t.Errorf()`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Errorf()`'
- en: '`t.Fatalf()`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Fatalf()`'
- en: '`t.Log()`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Log()`'
- en: '`t.Logf()`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t.Logf()`'
- en: When a test is executed, if the test ends without `panic`/`Error`/`Errorf`/`Fatal`/`Fatalf`
    called, the test is considered passed. If any of these are called, then the test
    fails. With `Error`/`Errorf`, the test continues executing and accumulates these
    error messages for the test. With `Fatal`/`Fatalf`, the test fails immediately.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试执行时，如果没有调用 `panic`/`Error`/`Errorf`/`Fatal`/`Fatalf`，测试会被视为通过。如果调用了其中任何一个，测试就会失败。使用
    `Error`/`Errorf`，测试会继续执行并积累这些错误信息。使用 `Fatal`/`Fatalf`，测试会立即失败。
- en: '`Log()`/`Logf()` calls are informative and are only displayed on failure or
    when other flags are passed for a test.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Log()`/`Logf()` 调用是信息性的，只有在测试失败时或传递了其他标志时才会显示。'
- en: Creating a simple test
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的测试
- en: 'Borrowing from `golang.org` tutorials ([https://golang.org/doc/tutorial/add-a-test](https://golang.org/doc/tutorial/add-a-test)),
    let''s create a simple test for a function called `Greeter()` that takes a name
    as an argument and returns `"Hello [name]"`. The code is illustrated in the following
    snippet:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 借鉴 `golang.org` 的教程 ([https://golang.org/doc/tutorial/add-a-test](https://golang.org/doc/tutorial/add-a-test))，让我们为一个名为
    `Greeter()` 的函数创建一个简单的测试，该函数接受一个名字作为参数并返回 `"Hello [name]"`。代码如下所示：
- en: '[PRE41]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can also see this example here: [https://play.golang.org/p/vjAhW0hfwHq](https://play.golang.org/p/vjAhW0hfwHq).'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在这里看到这个例子：[https://play.golang.org/p/vjAhW0hfwHq](https://play.golang.org/p/vjAhW0hfwHq)。
- en: 'To run the test, we need to simply run `go test` inside the package directory.
    If the test is successful, we should see the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，我们只需在包目录中运行 `go test`。如果测试成功，我们应该看到以下内容：
- en: '[PRE42]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To show what a failure looks like, I changed `want` to be `Hello Sarah` while
    leaving the name `Bob`, as illustrated here:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示失败的情况，我将 `want` 改成了 `Hello Sarah`，同时保留了名字 `Bob`，如下所示：
- en: '[PRE43]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'It is important to include enough information to debug your test. I like to
    include the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 包含足够的信息来调试测试非常重要。我喜欢包括以下内容：
- en: The name of the test
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的名称
- en: If table-driven, the description of the table row executed
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是表驱动的，执行的表格行的描述
- en: What I received (called `got`)
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我得到的结果（称为 `got`）
- en: What I wanted (called `want`)
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我期望的结果（称为 `want`）
- en: Now, let's talk about Go's preferred style of testing—TDTs.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来谈谈 Go 的测试首选风格——TDTs。
- en: Table Driven Tests (TDT)
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表驱动测试（TDT）
- en: 'For very simple tests, the preceding methodology works fine, but often, you
    need to test a function for multiple types of success and failure, such as in
    the following scenarios:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常简单的测试，上述方法可以正常工作，但通常，你需要测试一个函数的多种成功和失败类型，例如以下场景：
- en: What if they send a bad argument?
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们传递了一个错误的参数怎么办？
- en: What if the network has a problem and returns an error?
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网络出现问题并返回错误怎么办？
- en: What if the data isn't on disk?
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据不在磁盘上怎么办？
- en: Writing a test per condition creates a lot of churns in a test file that is
    harder to read and understand. TDTs to the rescue! A TDT uses the non-named struct
    concept we talked about in [*Chapter 1*](B17626_01.xhtml#_idTextAnchor013), *Go
    Language Basics*. This is the one place where it is common to see them.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个条件编写一个测试会导致测试文件中出现大量变动，变得难以阅读和理解。TDT来救场！TDT使用了我们在[*第1章*](B17626_01.xhtml#_idTextAnchor013)《Go语言基础》中讨论过的非命名结构体概念。这是唯一一个常见使用它的地方。
- en: The concept is to create a list of structs where each struct entry represents
    a set of test conditions and results that we want to see. We execute each struct
    entry one at a time to test the function.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念是创建一个结构体列表，其中每个结构体条目表示我们希望看到的测试条件和结果。我们一次执行一个结构体条目来测试函数。
- en: 'Let''s convert our preceding test to a TDT. In this case, there are only two
    expected ways for our `Greet()` function to react, as outlined here:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将之前的测试转换为TDT。在这种情况下，我们的`Greet()`函数的反应只有两种预期方式，如下所示：
- en: We pass an empty string for `name`, which results in an error
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为`name`传递一个空字符串，导致出现错误。
- en: Anything else results in `"Hello"` and the name
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他任何情况都将返回`"Hello"`和名字。
- en: 'Let''s write a TDT that handles both these cases, as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个处理这两种情况的TDT，如下所示：
- en: '[PRE44]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This example can also be found at the following link: [https://play.golang.org/p/vYWW-GiyT-M](https://play.golang.org/p/vYWW-GiyT-M).'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例也可以在以下链接找到：[https://play.golang.org/p/vYWW-GiyT-M](https://play.golang.org/p/vYWW-GiyT-M)。
- en: As you can see, TDT tests are longer but have clearly defined test parameters
    and clear error output.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，TDT测试比较长，但具有明确的测试参数和清晰的错误输出。
- en: Unlike the previous example, this tests that our error condition occurs when
    `name == ""`. Using a TDT is overkill for something so simple but becomes a powerful
    tool in the toolbox when writing tests against more complicated functions in Go.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例不同，这个测试验证了当`name == ""`时，我们的错误条件会发生。对于这么简单的情况，使用TDT有些过度，但在编写针对Go中更复杂函数的测试时，它会成为工具箱中强大的工具。
- en: Creating fakes with interfaces
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用接口创建假对象
- en: Tests should generally be hermetic, meaning that tests should not use resources
    that are not located locally on a machine.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常应该是封闭的，也就是说，测试不应该使用位于机器上本地以外的资源。
- en: If we are testing a client to a REST service, it should not actually call out
    to the REST service. There are integration tests that should test the basic connectivity
    to a test version of a service, but those should be small and rare tests that
    we are not going to cover here.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在测试一个客户端与REST服务的连接，它不应该实际调用REST服务。应该有集成测试来测试与服务的基本连接性，但这些测试应该是小型且少见的，我们在这里不会讨论这些。
- en: To test the behaviors of remote resources, we create what are called **fakes**
    using interfaces. Let's write a client that talks to a service via a network client
    to get a user record. We don't want to test the logic of the server (the kind
    of logic we tested previously), but instead, want to test what happens if the
    REST client has an error or we get back the wrong record from the service.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试远程资源的行为，我们使用接口创建所谓的**假对象**。让我们编写一个客户端，通过网络客户端与服务交互，获取用户记录。我们不想测试服务器的逻辑（我们之前测试过的那种逻辑），而是想测试如果REST客户端出现错误或从服务端获取到错误记录时会发生什么。
- en: 'First, let''s say we use a `Fetch` client in a `client` package that looks
    like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设我们在一个名为`client`的包中使用一个`Fetch`客户端，如下所示：
- en: '[PRE45]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We use `Fetch` in a function called `Greeter()` to get information we might
    use to change our responses to the person, as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名为`Greeter()`的函数中使用`Fetch`来获取我们可能会用来更改对某人的响应的信息，如下所示：
- en: '[PRE46]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is hard to test hermetically because `Fetch` is a concrete type that talks
    to a service. However, we can change this to an interface that `Fetch` implements
    and then use a fake. Firstly, let''s add the interface and change the `Greeter`
    argument, as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Fetch`是一个与服务通信的具体类型，这很难进行封闭式测试。然而，我们可以将其改为`Fetch`实现的接口，然后使用假对象。首先，让我们添加接口并更改`Greeter`的参数，如下所示：
- en: '[PRE47]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we can pass a `*client.Fetch` instance or we can pass anything else that
    implements `recorder`. Let''s create a fake that implements `recorder` that we
    can cause to return results useful for testing, as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以传递一个`*client.Fetch`实例，或者传递任何其他实现了`recorder`的东西。让我们创建一个实现了`recorder`的假对象，能够返回对测试有用的结果，如下所示：
- en: '[PRE48]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, let''s integrate this into a TDT, like this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将其集成到TDT中，像这样：
- en: '[PRE49]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This example can be found here: [https://play.golang.org/p/fjj2WrbGlKY](https://play.golang.org/p/fjj2WrbGlKY).'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例可以在这里找到：[https://play.golang.org/p/fjj2WrbGlKY](https://play.golang.org/p/fjj2WrbGlKY)。
- en: We now are simply faking the response that would come from our real client,
    `Fetch`. In code using `Greeter()`, they can simply pass the real client and in
    our tests, we pass our `fakeRecorder` instance. This allows us to control our
    environment to test that our function handles each type of response in the way
    we expect. This test is missing a test that checks the result when a `Record`
    instance is returned where the `Age` value is set to `< 18`. We leave this as
    an exercise for you.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只是模拟从真实客户端`Fetch`获取的响应。在使用`Greeter()`的代码中，他们可以简单地传入真实客户端，而在我们的测试中，我们传入`fakeRecorder`实例。这让我们能够控制测试环境，确保我们的函数以预期的方式处理每种类型的响应。这个测试缺少一个检查当返回`Record`实例且`Age`值设置为`<
    18`时的结果。我们将这个作为练习留给你。
- en: Third-party testing packages
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方测试包
- en: 'When I''m writing tests, there is really only one tool I reach for: [https://pkg.go.dev/github.com/kylelemons/godebug/pretty?utm_source=godoc](https://pkg.go.dev/github.com/kylelemons/godebug/pretty?utm_source=godoc).'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当我写测试时，几乎只有一个工具是我常用的：[https://pkg.go.dev/github.com/kylelemons/godebug/pretty?utm_source=godoc](https://pkg.go.dev/github.com/kylelemons/godebug/pretty?utm_source=godoc)。
- en: '`pretty` allows me to easily test if two complicated structs/maps/slices are
    equivalent. Using it in a test is simple, as illustrated here:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`pretty`允许我轻松地测试两个复杂的结构体/映射/切片是否等价。像这样在测试中使用它非常简单：'
- en: '[PRE50]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This outputs a readable format showing what is missing (prepended with `-`)
    and what was received (prepended with `+`). For more control over what is compared,
    the package offers a `Config` type that can be customized.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出以可读的格式显示了缺失的部分（前面加上`-`）和接收到的部分（前面加上`+`）。为了更好地控制比较的内容，包提供了一个可以自定义的`Config`类型。
- en: This code doesn't get updated often because it just works, but Kyle does answer
    bug requests, so the project is still alive.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更新不频繁，因为它已经能正常工作，但Kyle会回应bug请求，因此项目仍然在持续维护。
- en: Many in the Go community use the `github.com/stretchr/testify` set of packages,
    specifically the `assert` and `mock` packages.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Go社区的人使用`github.com/stretchr/testify`这个包集，特别是`assert`和`mock`包。
- en: 'I list them here because they are popular in the Go community; however, I would
    give the following warnings:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里列出它们是因为它们在Go社区中很受欢迎；然而，我会给出以下几点警告：
- en: Using asserts in Go for many years was considered bad practice
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多年来，Go中使用断言被认为是不好的实践。
- en: Mocking frameworks in Go often have terrible corner cases
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go中的模拟框架通常有一些非常棘手的边缘情况。
- en: The original authors of Go thought that using asserts was a bad practice for
    the language and unneeded. The current Go team has relaxed this stance. Mocking
    frameworks in Go tend to rely heavily on `interface{}` and have some sharp corner
    cases. I find using mocks results in testing behavior that is not important (call
    order or which calls were executed) versus testing that a given input causes an
    expected output. This is less burdensome and fragile to code changes.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Go的最初作者认为，使用断言对于该语言来说是一种不好的实践且没有必要。当前的Go团队已经放宽了这一立场。Go中的模拟框架通常大量依赖`interface{}`，并且存在一些尖锐的边缘情况。我发现使用模拟对象会导致测试出一些不重要的行为（例如调用顺序或哪些调用被执行了），而不是测试给定输入是否导致预期输出。这对于代码的更改来说，负担较小且不易出错。
- en: The original mocking framework ([https://github.com/golang/mock](https://github.com/golang/mock))
    was considered unsafe at Google and its use was restricted.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的模拟框架（[https://github.com/golang/mock](https://github.com/golang/mock)）在Google被认为是不安全的，因此其使用受到了限制。
- en: To sum this section up, we have learned about Go's `testing` package, how to
    use that package to write tests, the TDT methodology, and my (*John Doak's*) thoughts
    on third-party testing packages.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这一部分，我们了解了Go的`testing`包，如何使用该包编写测试，TDT方法论，以及我（*John Doak*）对第三方测试包的看法。
- en: Now that you have an understanding of how to do testing, we are going to look
    at a major addition to Go that was added in version 1.18—generics.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然你已经了解了如何进行测试，我们将着眼于Go 1.18版本中新增的一个重要特性——泛型。
- en: Generics – the new kid on the block
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型——新晋的“新秀”
- en: Generics are a new feature in Go 1.18 that looks to have vast ramifications
    for Go's future. Generics provide a way to represent multiple types with a new
    feature called a `type` parameter to allow functions to operate on multiple types.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是Go 1.18中的一项新特性，它对Go的未来可能产生深远影响。泛型提供了一种新的方式，通过引入一个名为`type`的参数，来表示多种类型，从而使得函数可以处理多种类型的数据。
- en: This differs from the standard `interface{}` where these types of operations
    always happen at runtime and where you must convert `interface{}` to the concrete
    type to do work.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这与标准的`interface{}`不同，后者的操作总是在运行时进行，你必须将`interface{}`转换为具体类型才能进行操作。
- en: Generics are a new feature, so we are only going to give a very general overview.
    The Go community and Go authors at this time do not have a set of best practices
    that have been rigorously tested. This comes with experience in using a feature,
    and we are only at the early stages of generics at this time, with more features
    around generics coming in the future.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一个新特性，因此我们只能给出一个非常概括的概述。目前，Go社区和Go的开发者们还没有一套经过严格测试的最佳实践。这需要在使用特性时积累经验，而目前我们处于泛型的初期阶段，未来会有更多关于泛型的功能发布。
- en: Type parameters
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型参数
- en: Type parameters can be added to functions or `struct` types to support a generic
    type. However, a key gotcha is that they cannot be used on methods! This is the
    most requested feature; however, it poses certain challenges to the language that
    the language authors are not sure how to deal with (or if they can be dealt with).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数可以添加到函数或`struct`类型中，以支持泛型类型。然而，一个关键的陷阱是它们不能用于方法！这是最被请求的特性；然而，它给语言带来了一些挑战，语言的开发者们目前还不确定如何处理这些问题（或者是否能够处理）。
- en: 'Type parameters are defined after the function name within brackets. Let''s
    look at a basic one here:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数在函数名后面用括号定义。我们来看一个基本的例子：
- en: '[PRE51]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This creates a function that can sort any of our signed integer types. `I` is
    the type parameter and it is limited to the types listed in the bracket. The `|`
    pipe character acts as an `or` statement saying `I` can be an `int8` or an `int16`
    type, and so on.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就创建了一个可以排序任何有符号整数类型的函数。`I`是类型参数，并且它被限制为括号中列出的类型。`|`管道符号充当`or`语句，表示`I`可以是`int8`或`int16`类型，依此类推。
- en: Once `I` is defined, we can use it as a type in our arguments. Our function
    will operate on a slice type of `I`. It should be noted that all values in `I`
    must be the same type; it cannot be a mix of say `int8` and `int64` values.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`I`被定义，我们就可以在函数参数中将其用作类型。我们的函数将基于`I`的切片类型进行操作。需要注意的是，`I`中的所有值必须是相同的类型；不能是`int8`和`int64`类型的混合。
- en: 'Let''s look at how that might work with a simple bubble-sort implementation,
    as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何用一个简单的冒泡排序实现来演示这个过程，如下所示：
- en: '[PRE52]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can see this example here: [https://go.dev/play/p/jly7i9hz0YT](https://go.dev/play/p/jly7i9hz0YT).'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到这个例子：[https://go.dev/play/p/jly7i9hz0YT](https://go.dev/play/p/jly7i9hz0YT)。
- en: 'We now have a function that can be used to sort any type of signed integer.
    If we were to do this without generics, it would require an argument of `interface{}`
    that would need to be type switched on the slice type. Then, we would need to
    write functions to handle each type. You can see an example of what that would
    look like here: [https://go.dev/play/p/lqVUk9GQFPX](https://go.dev/play/p/lqVUk9GQFPX).'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以用来排序任何有符号整数类型的函数。如果我们没有泛型，这个函数需要一个`interface{}`类型的参数，并且需要根据切片类型进行类型转换。然后，我们还需要为每种类型编写相应的处理函数。你可以在这里看到一个例子：[https://go.dev/play/p/lqVUk9GQFPX](https://go.dev/play/p/lqVUk9GQFPX)。
- en: 'The other option would be to use runtime reflection using the `reflect` package,
    which is slow and unwieldy. `reflect` is an advanced package that has lots of
    gotchas and should be avoided unless absolutely necessary. Here is an example
    of this method: [https://go.dev/play/p/3euBYL9dcsU](https://go.dev/play/p/3euBYL9dcsU).'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种选择是使用`reflect`包中的运行时反射，这种方式较慢且笨重。`reflect`是一个高级包，包含许多潜在的陷阱，除非绝对必要，否则应该避免使用。这里是这种方法的一个例子：[https://go.dev/play/p/3euBYL9dcsU](https://go.dev/play/p/3euBYL9dcsU)。
- en: As you can see, the generic version is much simpler to implement and can significantly
    reduce your code base.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，泛型版本的实现要简单得多，并且可以显著减少代码量。
- en: Let's have a look at how we could make this slightly easier to read using type
    constraints.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何通过使用类型约束使代码更易读。
- en: Using type constraints
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型约束
- en: In our last example, `int8 |int16 |int32 |int64` was our type constraint. It
    limited the types that we could use for our `I` value type parameter, but typing
    that all the time is burdensome, so we can also define named type constraints.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上一个例子中，`int8 |int16 |int32 |int64`是我们的类型约束。它限制了我们可以用于`I`值类型参数的类型，但每次都打出这些类型会显得繁琐，因此我们也可以定义命名的类型约束。
- en: 'This is where the addition of generics is likely to create some confusion.
    Type constraints are made using the `interface` type. Here''s an example of a
    type constraint containing what we had previously:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这是引入泛型可能会引起混淆的地方。类型约束是使用`interface`类型来定义的。以下是一个包含我们之前内容的类型约束的例子：
- en: '[PRE53]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can now use that in our previous code, as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在之前的代码中使用它，如下所示：
- en: '[PRE54]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This reduces the amount of boilerplate we need. It is important to note that
    `SignedInt` is a type constraint and not a type. `I` is a defined type parameter
    that acts as a type. I''ve often found myself writing code like this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这减少了我们需要写的样板代码量。重要的是要注意，`SignedInt`是类型约束，而不是类型。`I`是一个已定义的类型参数，充当类型。我经常发现自己写这样的代码：
- en: '[PRE55]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However, that syntax is incorrect. `SignedInt` here is simply the definition
    of a constraint, not a type to be used. `I` is the type to be used in the generic
    function.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，那个语法是不正确的。这里的`SignedInt`仅仅是约束的定义，而不是一个可以使用的类型。`I`才是泛型函数中使用的类型。
- en: 'Another gotcha is that `SignedInt` can only be used on the exact basic types
    defined here. You might create your own type, like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个陷阱是`SignedInt`只能用于这里定义的确切基本类型。你可能会创建自己的类型，像这样：
- en: '[PRE56]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you do so, you cannot use this as a `SignedInt` type constraint. But not
    to worry—if we want this to work on any type based on signed integers, we can
    change this to the following:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这样做，你不能将其作为`SignedInt`类型约束使用。但不用担心——如果我们希望它能够处理基于带符号整数的任何类型，我们可以将其改为以下内容：
- en: '[PRE57]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`~` signals that we want to allow any type based on this type.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`~`表示我们希望允许基于此类型的任何类型。'
- en: Now, let's look at how we can write our sort function to handle more than just
    signed integers.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何编写我们的排序函数，以处理不仅仅是带符号整数的情况。
- en: We could do better with constraints
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以通过约束做得更好
- en: What we are doing here can be applied to more than just signed integers. We
    could make changes to which types we support, and our function would work exactly
    the same on a larger set of slice types.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的可以应用于不仅仅是带符号整数。我们可以更改支持的类型，而我们的函数在更大的切片类型集合上仍然可以正常工作。
- en: The only thing that a type must have for our function to work is that the type
    must be able to use `>` on two variables that share the same type. That is what
    allows the `if slice[i] > slice[i+1]` statement to work.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数能工作的唯一条件是类型必须能够对共享相同类型的两个变量使用`>`操作。这就是`if slice[i] > slice[i+1]`语句能够工作的原因。
- en: 'The current Go version, as of this writing, does not define a few basic type
    constraints that are planned for a future release. This future package, which
    will likely be called `constraints`, is being developed here: [https://pkg.go.dev/golang.org/x/exp/constraints](https://pkg.go.dev/golang.org/x/exp/constraints).'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本文写作时，当前的Go版本没有定义一些计划在未来版本中发布的基本类型约束。这个未来的包，可能会叫做`constraints`，正在这里开发：[https://pkg.go.dev/golang.org/x/exp/constraints](https://pkg.go.dev/golang.org/x/exp/constraints)。
- en: 'It includes a type constraint that looks like this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括一个像这样的类型约束：
- en: '[PRE58]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We will borrow that here and change our function signature, as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里借用它并更改我们的函数签名，如下所示：
- en: '[PRE59]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now, our function can sort any type of slice that can be compared using `>
    <`. See it at work here: [https://go.dev/play/p/PwrXXLk5rOT](https://go.dev/play/p/PwrXXLk5rOT).'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的函数可以排序任何可以使用`>`和`<`进行比较的切片类型。可以在这里看到它的工作效果：[https://go.dev/play/p/PwrXXLk5rOT](https://go.dev/play/p/PwrXXLk5rOT)。
- en: Current built-in constraints
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当前的内建约束
- en: 'Go has two constraints that are currently built in, as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Go当前有两个内建的约束，如下所示：
- en: '`comparable`'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comparable`'
- en: '`any`'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`any`'
- en: '`comparable` contains all types that support `==` or `!=` operators. This is
    particularly useful when writing generics that use `map` types. The key to a `map`
    type is always the `comparable` type.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`comparable`包含所有支持`==`或`!=`操作符的类型。这在编写使用`map`类型的泛型时特别有用。`map`类型的关键总是`comparable`类型。'
- en: '`any` is an alias for `interface{}`. The Go team has changed all references
    to `interface{}` in the Go standard library to `any`. You may use them interchangeably,
    and `any` as a type constraint allows any type.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`any`是`interface{}`的别名。Go团队已经将Go标准库中所有的`interface{}`引用更改为`any`。你可以交替使用它们，并且`any`作为类型约束允许任何类型。'
- en: 'Here is an example of a function that extracts all keys from a `map` type using
    these constraints:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用这些约束从`map`类型中提取所有键的函数示例：
- en: '[PRE60]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Here it is running in the playground, so give it a try: [https://go.dev/play/p/h8aKwoTaOLj](https://go.dev/play/p/h8aKwoTaOLj).'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这里它在playground中运行，试试看吧：[https://go.dev/play/p/h8aKwoTaOLj](https://go.dev/play/p/h8aKwoTaOLj)。
- en: Let's look at what happens if we do type constraining and we constrain a type
    such as a standard interface by requiring a method.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们进行类型约束，并且通过要求方法来约束一个类型（如标准接口）会发生什么。
- en: Type constraints with methods
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带方法的类型约束
- en: 'A type constraint can act like a standard interface in that it can require
    methods to be attached to the type. Here is an example:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 类型约束可以像标准接口一样起作用，它可以要求方法附加到类型上。以下是一个例子：
- en: '[PRE61]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This type constraint can only be satisfied by a type based on `string` and that
    has the `Print()` method defined.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型约束只能由基于`string`的类型满足，并且该类型必须定义了`Print()`方法。
- en: A key requirement here is that we use `~string` and not `string`. A standard
    `string` type can never have the `Print()` method, and therefore this type constraint
    could never be satisfied.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个关键要求是我们使用`~string`而不是`string`。标准的`string`类型永远无法拥有`Print()`方法，因此这个类型约束永远无法满足。
- en: 'Here is a simple use of this constraint:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的约束使用示例：
- en: '[PRE62]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, let's take a look at why you might want to add type parameters to struct
    types.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看为什么你可能想要向结构体类型添加类型参数。
- en: Adding type parameters to struct types
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向结构体类型添加类型参数
- en: 'Earlier, we wrote a generic function for sorting slices called `SortSlice()`,
    but that has some limitations in that it can only handle slices that are based
    on types that meet the constraints in `constraints.Ordered`. Oftentimes, we might
    want to handle slices that might contain types based on `struct`—say, for example,
    this type:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们编写了一个名为`SortSlice()`的通用函数来排序切片，但它有一些局限性，因为它只能处理符合`constraints.Ordered`约束的类型的切片。通常，我们可能需要处理包含基于`struct`的类型的切片——例如，像下面这样一个类型：
- en: '[PRE63]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Our `SortSlice()` function could not handle a `[]Record`, so we need to do something
    different to handle these types of cases.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SortSlice()`函数无法处理`[]Record`，因此我们需要做一些不同的处理来应对这种类型的情况。
- en: For this example, we want to use Go's built-in `sort.Sort()` function. This
    is a highly optimized sort that uses multiple sorting algorithms, depending on
    slice size.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们想使用Go内置的`sort.Sort()`函数。这是一个经过高度优化的排序算法，它根据切片的大小使用多种排序算法。
- en: 'To use it, you need a type that implements the `sort.Interface` type. That
    `interface` type is defined as follows:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，你需要一个实现了`sort.Interface`类型的类型。该`interface`类型定义如下：
- en: '[PRE64]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Before Go generics, you would have needed to implement an adapter type to implement
    these for every type you wanted to sort. For example, here is an adapter to sort
    `[]int`:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go泛型之前，你需要为每个你想排序的类型实现一个适配器类型。例如，下面是一个用来排序`[]int`的适配器：
- en: '[PRE65]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'And you could use it like so:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样使用它：
- en: '[PRE66]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can see that running here: [https://go.dev/play/p/Yl6Al9ylEhd](https://go.dev/play/p/Yl6Al9ylEhd).'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到它的运行：[https://go.dev/play/p/Yl6Al9ylEhd](https://go.dev/play/p/Yl6Al9ylEhd)。
- en: You would then need to do this for every other signed type or other types you
    wanted to sort. Imagine doing this for all `int8`, `int16`, `int32`, and `int64`
    signed integer types. You would also need to do that for every other type you
    want to sort.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要对每一个其他的有符号类型或你想排序的其他类型做类似的操作。想象一下，如果要为所有的`int8`、`int16`、`int32`和`int64`有符号整型做这些操作，你会怎么做？你还需要为所有你想排序的其他类型做同样的事情。
- en: So, what we want to do is use generics to give us a single adapter type that
    can be used for a slice with any element type.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们想做的是使用泛型来给我们一个单一的适配器类型，这样我们就可以对任何元素类型的切片进行排序。
- en: 'Let''s use a `type` parameter on a struct to allow us to create a generic adapter
    so that we can adapt any slice to the `sort.Interface` type, as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在结构体上使用`type`参数，以便创建一个通用适配器，这样我们就可以将任何切片适配到`sort.Interface`类型，如下所示：
- en: '[PRE67]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This is very similar to `intAdapter` from before, with two distinctions, as
    follows:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的`intAdapter`非常相似，主要有两个区别，具体如下：
- en: The slice elements are a `T` type parameter that can be any value
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片元素是一个`T`类型参数，它可以是任何值。
- en: We added a `less` field, which is a function that does the comparison when `Less()`
    is called
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了一个`less`字段，它是一个函数，当调用`Less()`时执行比较操作。
- en: 'Let''s create a function that can implement `func(T, T) bool` for our `Record`
    type. This compares the full name with the last name being considered first. The
    code is illustrated in the following snippet:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个能够实现`func(T, T) bool`的函数，适用于我们的`Record`类型。这个函数会首先比较姓氏，然后再比较全名。代码如下所示：
- en: '[PRE68]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, we can use `sortableSlice` to write a generic sort function that uses
    the existing `sort.Sort()` function to sort any slice that we can do comparisons
    on. Here''s the code we need to execute:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`sortableSlice`来编写一个通用排序函数，利用现有的`sort.Sort()`函数对我们可以进行比较的任何切片进行排序。以下是我们需要执行的代码：
- en: '[PRE69]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here is this in action: [https://go.dev/play/p/6Gd7DLgVQ_y](https://go.dev/play/p/6Gd7DLgVQ_y).'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的实际应用：[https://go.dev/play/p/6Gd7DLgVQ_y](https://go.dev/play/p/6Gd7DLgVQ_y)。
- en: 'You will notice that when we create our `sortableSlice` instance, we have `[T]`
    in the syntax. This is used to tell Go what type `T` will be, which in this case
    is the generic `T` type passed in `SortSlice`. If you try to remove `[T]`, you
    will get the following message:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，当我们创建 `sortableSlice` 实例时，我们在语法中使用了 `[T]`。这用于告诉 Go `T` 将是什么类型，在本例中就是传递给
    `SortSlice` 的泛型 `T` 类型。如果你尝试删除 `[T]`，你会收到以下信息：
- en: '[PRE70]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We will talk about this in our next section.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中讨论这个问题。
- en: Of course, if you want to do a generic sort without using the `sort.Sort()`
    function,
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你想在不使用 `sort.Sort()` 函数的情况下进行泛型排序，
- en: 'this can be done with less complication. Here is a generic version of the quicksort
    algorithm that uses generics: [https://go.dev/play/p/gvPl9jHtAS4](https://go.dev/play/p/gvPl9jHtAS4).'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以更少的复杂性。这里是一个使用泛型的快速排序算法的泛型版本：[https://go.dev/play/p/gvPl9jHtAS4](https://go.dev/play/p/gvPl9jHtAS4)。
- en: Now, we will look at calling a generic function when Go cannot infer a type
    for the generic function to use.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论在 Go 无法推断出泛型函数所使用的类型时，如何调用泛型函数。
- en: Specifying the type when calling a generic function
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用泛型函数时指定类型
- en: So far, all the generic cases up until the `sortableSlice` function have allowed
    the Go compiler to infer which type would be used and therefore how to deal with
    invoking the function.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有泛型案例直到 `sortableSlice` 函数都允许 Go 编译器推断出将使用的类型，因此也知道如何处理调用该函数。
- en: But Go cannot always infer which type it needs to use. We can see in our last
    section where we told `sortableSlice` it would be using the `T` generic type we
    defined.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 Go 并不总是能够推断出它需要使用哪种类型。我们可以在上一节中看到，我们告诉 `sortableSlice` 使用我们定义的 `T` 泛型类型。
- en: 'Let''s create a function that can be used with `SortSlice()` to do our less
    comparison whenever the types are of type `constraints.Ordered`. The code is illustrated
    in the following snippet:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可以与 `SortSlice()` 一起使用的函数，用于在类型为 `constraints.Ordered` 时进行小于比较。代码如下所示：
- en: '[PRE71]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With this, we can call `SortSlice()` and pass in any slice of types contained
    in `constraints.Ordered` and our new `orderedCmp` generic function to sort a slice.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以调用 `SortSlice()`，并传入任何包含在 `constraints.Ordered` 中的类型切片，以及我们的新 `orderedCmp`
    泛型函数来排序切片。
- en: 'Let''s give it a try, as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看，具体如下：
- en: '[PRE72]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Uh oh—Go can''t seem to get that to work, as we receive the following message:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀—Go 似乎无法做到这一点，因为我们收到了以下信息：
- en: '[PRE73]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is because we are passing the function and not invoking the function. Go's
    inference only currently happens by looking at the call types it receives. It
    doesn't infer inside `SortSlice()` where `orderedCmp()` will be called and passed
    a `string` type. So, to use it, we need to tell it which type it will be working
    on when it is called.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们传递的是函数，而不是调用该函数。Go 的推断只会在查看接收到的调用类型时进行。目前它不会在 `SortSlice()` 内部推断 `orderedCmp()`
    被调用并传递 `string` 类型。所以，要使用它，我们需要告诉它在调用时将使用哪种类型。
- en: In contrast, `SortSlice()` doesn't require this because it is being invoked
    directly and can infer that `T` will be a `string` type from looking at the passed
    argument, `strings`.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`SortSlice()` 不需要这样做，因为它是直接调用的，并且可以从查看传入的参数 `strings` 推断出 `T` 将是 `string`
    类型。
- en: 'By using `[string]`, we can give `orderedCmp` a little more information for
    this to work, as follows:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `[string]`，我们可以为 `orderedCmp` 提供更多信息，从而使其工作，具体如下：
- en: '[PRE74]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now that it knows that we will be comparing `string` types, it is ready to
    rock and roll, as you can see here: [https://go.dev/play/p/kd6sylV17Jz](https://go.dev/play/p/kd6sylV17Jz).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它知道我们将比较 `string` 类型，它已经准备好工作了，正如你在这里看到的：[https://go.dev/play/p/kd6sylV17Jz](https://go.dev/play/p/kd6sylV17Jz)。
- en: 'If we wanted to be very verbose, we could do the following:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想非常详细地写出来，我们可以做如下操作：
- en: '[PRE75]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Now, let's take a look at some common gotchas you might run into when trying
    to use generics.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看一些你在尝试使用泛型时可能会遇到的常见陷阱。
- en: Gotchas to watch for
  id: totrans-472
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要注意的陷阱
- en: When you are playing with generics, there are a lot of gotchas where the error
    messages are not yet clear. So, let's talk about some of them so that you can
    avoid the mistakes that I've made.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在玩泛型时，有很多陷阱，其中错误信息并不总是很清楚。所以，让我们谈谈其中的一些，以便你能够避免我曾经犯过的错误。
- en: 'First up, impossible type constraints. See if you can spot the problem in the
    following code:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是不可行的类型约束。看看你能否在以下代码中找到问题：
- en: '[PRE76]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you were to run this, you would get the following:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个，你会得到以下结果：
- en: '[PRE77]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This is because `Values` is incorrectly defined. I forgot to put `|` after
    `int64`. Without that, the constraint says the value must be `int8` or `int16`
    or `int32` or `int64` `string` or `[]byte` type. That is an impossible type, which
    means nothing can implement it. You can see this here: [https://go.dev/play/p/Nxsz4HKxdc4](https://go.dev/play/p/Nxsz4HKxdc4).'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `Values` 被错误地定义了。我忘记在 `int64` 后加上 `|`。没有这个，约束条件就会说值必须是 `int8`、`int16`、`int32`、`int64`、`string`
    或 `[]byte` 类型。这是一个不可能的类型，也就是说没有东西能实现它。你可以在这里看到这个问题：[https://go.dev/play/p/Nxsz4HKxdc4](https://go.dev/play/p/Nxsz4HKxdc4)。
- en: 'The next gotcha is instantiation when returning `struct` types that implement
    type parameters. Here''s an example of this:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个难点是返回实现类型参数的 `struct` 类型时的实例化问题。以下是一个示例：
- en: '[PRE78]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'An attempt to compile this code will give you the following message:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试编译此代码时，将显示以下消息：
- en: '[PRE79]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'It was not clear to me what the problem was here for a while. It turns out
    that I needed to add the `type` parameter on the return value as well. Here is
    the change:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间内我没有弄清楚问题出在哪里。结果发现，我还需要在返回值上添加 `type` 参数。下面是修改后的版本：
- en: '[PRE80]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: With this change, everything works fine. Try the broken version ([https://go.dev/play/p/EGTr2zd7qZW](https://go.dev/play/p/EGTr2zd7qZW))
    and fix it with the aforementioned change to familiarize yourself.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个修改，一切正常。尝试这个坏掉的版本（[https://go.dev/play/p/EGTr2zd7qZW](https://go.dev/play/p/EGTr2zd7qZW)）并通过前面提到的修改修复它，以便熟悉操作。
- en: I expect that we will see better error messages and better detection in our
    development tools in the near future.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我预期在不久的将来，我们的开发工具会提供更好的错误信息和更好的检测功能。
- en: Now that we have covered the basics of generics, let's talk about when you should
    consider using generics.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了泛型的基础知识，接下来讨论一下你应该在什么情况下考虑使用泛型。
- en: When to use generics
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用泛型
- en: 'The only guideline at this time is taken from the creator of Go''s generics
    feature, Ian Taylor, as presented here:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 目前唯一的指导原则来自 Go 泛型功能的创造者 Ian Taylor，如下所示：
- en: '"*If you find yourself writing the exact same code multiple times where the
    only difference between the copies is that the code uses different types, consider
    whether you can use a type parameter.*"'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '"*如果你发现自己在多次编写相同代码，唯一的区别只是代码使用了不同的类型，考虑一下是否可以使用类型参数。*"'
- en: 'I have found this translates to the following:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现这转化为以下内容：
- en: '*If your function needs a switch statement on the generic type, you should
    probably be using standard interfaces instead of generics.*'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的函数需要对泛型类型进行 `switch` 语句，可能应该使用标准接口而不是泛型。*'
- en: To close out on generics, I would leave you with the thought that this is a
    new language feature, and the jury is still out on the best ways for this to be
    used. The best advice I can give is to be reserved in your use of this feature.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结泛型时，我想给你留下一点思考：这是一项新的语言特性，关于它的最佳使用方式还没有定论。我能给出的最佳建议是，在使用这一特性时要保持谨慎。
- en: Summary
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned the essential parts of the **Go** language.
    This has included handling errors, using Go concurrency, taking advantage of Go's
    testing framework, and an introduction to Go's newest feature, generics. The skills
    acquired in this chapter are essential for all future chapters.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你已经学习了 **Go** 语言的核心部分。内容包括错误处理、使用 Go 并发、利用 Go 的测试框架，以及 Go 最新特性泛型的介绍。通过本章学到的技能，对未来的章节至关重要。
- en: You should now possess the ability to read Go code contained in the rest of
    the book. In addition, this chapter has given you the necessary skills to write
    your own Go code. We will use these skills to manipulate files in the filesystem,
    execute commands on remote machines, and build RPC services that can do a myriad
    of tasks. You will build chatbots in order to do **chat-based operations** (**ChatOps**)
    and write software to extend Kubernetes. The learnings here are truly foundational.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该具备了阅读本书剩余部分中的 Go 代码的能力。此外，本章还给你提供了编写 Go 代码所需的必要技能。我们将利用这些技能操作文件系统中的文件、在远程机器上执行命令，以及构建可以执行各种任务的
    RPC 服务。你还将构建聊天机器人以进行 **基于聊天的操作**（**ChatOps**），并编写软件来扩展 Kubernetes。这些学到的东西是真正的基础。
- en: Next, we will look at how to setup your Go environment to compile code locally
    on your machine. Let’s get started!
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍如何设置你的 Go 环境，以便在本地机器上编译代码。让我们开始吧！
