- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: CI/CD with Terraform, GitHub, and Atlantis
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform、GitHub 和 Atlantis 实现 CI/CD
- en: In this chapter, we are going to build on the previous chapters in this book
    by introducing pipelines for **continuous integration** (**CI**) and **continuous
    deployment** (**CD**). There are many CI and CD tools available for you, both
    open source and closed source, as well as self-hosted and **Software-as-a-Service**
    (**SaaS**). We are going to demonstrate an example pipeline, starting from committing
    source to the repository where we store **Terraform** code to applying changes
    in your infrastructure. We will do this automatically but with reviews from your
    team.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将在前几章的基础上，介绍**持续集成**（**CI**）和**持续部署**（**CD**）的管道。市场上有许多可用的 CI 和 CD 工具，包括开源和闭源工具、自托管和
    **软件即服务**（**SaaS**）工具。我们将演示一个示例管道，从将源代码提交到存储 **Terraform** 代码的仓库，到在基础设施中应用更改。我们将自动完成这一过程，但会经过团队的审查。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将覆盖以下主题：
- en: What is CI/CD?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 CI/CD？
- en: Continuously integrating and deploying your infrastructure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续集成和部署你的基础设施
- en: CI/CD with Atlantis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Atlantis 实现 CI/CD
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要以下内容：
- en: A Linux box
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Linux 服务器
- en: A free account on GitHub or similar platform (GitLab or Bitbucket)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 或类似平台（GitLab 或 Bitbucket）上的免费账户
- en: The latest version of Terraform
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最新版本的 Terraform
- en: The **AWS CLI**
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CLI**'
- en: Git
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: What is CI/CD?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 CI/CD？
- en: CI/CD is a set of practices, tools, and processes that allow software development
    teams to automate the building, testing, and deployment of their applications,
    enabling them to release software more frequently and with greater confidence
    in its quality.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 是一套实践、工具和流程，帮助软件开发团队自动化构建、测试和部署应用程序，从而更频繁地发布软件，并且更有信心其质量。
- en: '**Continuous integration** (**CI**) is a practice where developers regularly
    integrate their code changes into a repository, and each integration triggers
    an automated build and test process. This helps catch errors early and ensures
    that the application can be built and tested reliably.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）是一种实践，开发人员定期将代码更改集成到代码仓库中，每次集成都触发自动构建和测试过程。这有助于尽早发现错误，并确保应用程序可以可靠地构建和测试。'
- en: For example, using **Docker**, a developer can set up a **CI pipeline** that
    automatically builds and tests their application whenever changes are pushed to
    the code repository. The pipeline can include steps to build a Docker image, run
    automated tests, and publish the image to a Docker registry.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用 **Docker**，开发人员可以设置一个 **CI 管道**，该管道在每次将更改推送到代码仓库时自动构建和测试应用程序。管道可以包括构建
    Docker 镜像、运行自动化测试以及将镜像发布到 Docker 仓库的步骤。
- en: Continuous delivery is the practice of getting software to be available for
    deployment after the successful integration process. For example, with a Docker
    image, delivery would be pushing the image to the Docker registry from where it
    could be picked up by the deployment pipeline.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付是指在成功集成过程后，使软件可以随时进行部署的实践。例如，使用 Docker 镜像，交付过程是将镜像推送到 Docker 仓库，之后可以由部署管道提取。
- en: Finally, **continuous deployment** (**CD**) is the practice of automatically
    deploying continuous delivery process code artifacts (Docker images, Java JAR
    files, ZIP archives, and so on) to production as soon as they are tested and validated.
    This eliminates the need for manual intervention in the deployment process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**持续部署**（**CD**）是将经过测试和验证的持续交付过程代码工件（如 Docker 镜像、Java JAR 文件、ZIP 压缩包等）自动部署到生产环境中的实践。这样消除了部署过程中的人工干预需求。
- en: 'Let’s look at some common deployment strategies:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下几种常见的部署策略：
- en: '**Rolling deployment**: This strategy involves deploying changes to a subset
    of servers at a time, gradually rolling out the changes to the entire infrastructure.
    This allows teams to monitor the changes and quickly roll back if any issues arise.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动部署**：这种策略涉及一次只将更改部署到一部分服务器，逐步将更改推广到整个基础设施。这使得团队能够监控更改，并在出现问题时迅速回滚。'
- en: '**Blue-green deployment**: In this strategy, two identical production environments
    are set up, one active (blue) and the other inactive (green). Code changes are
    deployed to the inactive environment and tested before switching the traffic to
    the new environment. This allows for zero downtime deployment.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝绿部署**：在这种策略中，设置两个相同的生产环境，一个处于激活状态（蓝色），另一个处于非激活状态（绿色）。代码变更被部署到非激活环境，并在切换流量到新环境之前进行测试。这种方式可以实现零停机部署。'
- en: '**Canary deployment**: This strategy involves deploying changes to a small
    subset of users while keeping the majority of the users on the current version.
    This allows teams to monitor the changes and gather feedback before rolling out
    the changes to the entire user base.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**金丝雀部署**：这种策略涉及将变更部署到一小部分用户，并保持大多数用户使用当前版本。这样，团队可以监控这些变更并收集反馈，在将这些变更推广到所有用户之前，进行充分测试。'
- en: '**Feature toggles/feature switches**: With this strategy, changes are deployed
    to production but hidden behind a feature toggle. This toggle is then gradually
    turned on for select users or environments, allowing teams to control the rollout
    of new features and gather feedback before making them available to everyone.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能开关/特性开关**：通过这种策略，变更被部署到生产环境，但会被隐藏在功能开关后面。这个开关随后会逐步对特定用户或环境启用，允许团队在将新功能提供给所有人之前，控制功能的发布并收集反馈。'
- en: All of these strategies can be automated using **CD tools**, such as **Jenkins**,
    **CircleCI**, **GitHub** and **GitLab Actions**, **Travis CI**, and many others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些策略都可以通过 **CD 工具** 来实现自动化，如 **Jenkins**、**CircleCI**、**GitHub** 和 **GitLab
    Actions**、**Travis CI** 等众多工具。
- en: While we’re talking about the deployment of applications, we need to at least
    mention **GitOps**. GitOps is a new approach to infrastructure and application
    deployment that uses **Git** as the single source of truth for declarative infrastructure
    and application specifications. The idea is to define the desired state of the
    infrastructure and applications in Git repositories and use a GitOps tool to automatically
    apply those changes to the target environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论应用程序的部署时，我们至少需要提到 **GitOps**。GitOps 是一种新的基础设施和应用程序部署方法，它使用 **Git** 作为声明性基础设施和应用程序规格的唯一真理来源。其核心思想是在
    Git 仓库中定义基础设施和应用程序的期望状态，并使用 GitOps 工具自动将这些变更应用到目标环境。
- en: In GitOps, every change to the infrastructure or application is made via a Git
    commit, which triggers a pipeline that applies the changes to the target environment.
    This provides a complete audit trail of all changes and ensures that the infrastructure
    is always in the desired state.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitOps 中，对基础设施或应用程序的每一次更改都是通过 Git 提交来完成的，这会触发一个流水线，将这些更改应用到目标环境。这提供了完整的变更审计跟踪，并确保基础设施始终处于期望的状态。
- en: 'Some of the tools that help with enabling GitOps include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有助于启用 GitOps 的工具包括以下几种：
- en: '**FluxCD**: This is a popular GitOps tool that can automate the deployment
    and scaling of applications and infrastructure, using Git as the single source
    of truth. It integrates with **Kubernetes**, **Helm**, and other tools to provide
    a complete GitOps workflow.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FluxCD**：这是一个流行的 GitOps 工具，可以通过 Git 作为唯一的真理来源，自动化应用程序和基础设施的部署和扩展。它与 **Kubernetes**、**Helm**
    和其他工具集成，提供完整的 GitOps 工作流。'
- en: '**ArgoCD**: This is another popular GitOps tool that can deploy and manage
    applications and infrastructure, using Git as the source of truth. It provides
    a web-based UI and **CLI** to manage the GitOps pipeline and integrates with Kubernetes,
    Helm, and other tools.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ArgoCD**：这是另一款流行的 GitOps 工具，使用 Git 作为真理来源来部署和管理应用程序和基础设施。它提供基于网页的 UI 和 **CLI**
    来管理 GitOps 流水线，并与 Kubernetes、Helm 以及其他工具集成。'
- en: '**Jenkins X**: This is a CI/CD platform that includes GitOps workflows for
    building, testing, and deploying applications to Kubernetes clusters. It uses
    GitOps to manage the entire pipeline, from source code to production deployment.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins X**：这是一个包含 GitOps 工作流的 CI/CD 平台，用于构建、测试和将应用程序部署到 Kubernetes 集群。它利用
    GitOps 来管理整个流水线，从源代码到生产环境的部署。'
- en: Now that we know what CI/CD is, we can look into various tools that could be
    used to build such pipelines. In the next section, we will provide you with some
    examples of a pipeline for cloning the latest version of your repository, building
    a Docker image, and running some tests.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了 CI/CD 的概念，接下来我们可以探索一些工具，这些工具可以用来构建这样的流水线。在下一节中，我们将为您提供一些流水线示例，包含克隆最新版本的代码库、构建
    Docker 镜像以及运行一些测试。
- en: An example of CI/CD pipelines
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD 流水线示例
- en: Let’s look at a few examples of automation pipelines that will apply our Terraform
    changes to the different CD tools out there.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些自动化流水线的示例，这些流水线将我们的Terraform更改应用到不同的CD工具中。
- en: Jenkins
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jenkins
- en: 'Jenkins is the most popular open source CI/CD tools out there. It transformed
    from the clicked-through configuration to the `apply` if the user approves the
    change:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins是最流行的开源CI/CD工具之一。它从点击式配置转变为在用户批准更改后运行`apply`：
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code opens a new pipeline definition. It’s defined to run in any
    available Jenkins agent. Next, we’re setting up environment variables to be used
    within this pipeline. The environment variables text is being retrieved from the
    `aws-key-id` and `aws-secret-key` Jenkins credentials. These need to be defined
    before we can run this pipeline.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码开启了一个新的流水线定义。它被设置为在任何可用的Jenkins代理上运行。接下来，我们设置了将在该流水线中使用的环境变量。这些环境变量的文本是从`aws-key-id`和`aws-secret-key`
    Jenkins凭证中提取的。在运行该流水线之前，这些凭证需要被定义。
- en: 'Next, we’ll define that each step pipeline will run inside the `stages` block:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在`stages`块中定义每个步骤的流水线：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'First, we’ll clone our Git repository; the step that does this is `checkout
    scm`. The URL will be configured in the Jenkins UI directly:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将克隆我们的Git仓库；执行此操作的步骤是`checkout scm`。URL将在Jenkins UI中直接配置：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we’ll run `terraform init` to initialize the Terraform environment. Here,
    we’re running the plan and saving the output to the `terraform.tfplan` file, which
    we will run `apply` with in the final step:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行`terraform init`来初始化Terraform环境。在这里，我们运行计划并将输出保存到`terraform.tfplan`文件中，最后一步将使用此文件运行`apply`：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This step defines user input. We’ll need to confirm this by running `apply`
    after we review the plan’s output. We’re defining the default as `false`. The
    pipeline will wait for your input on this step:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤定义了用户输入。我们需要在审查计划的输出后通过运行`apply`来确认这一点。我们将默认值定义为`false`。流水线将在此步骤等待您的输入：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, if you’ve confirmed that the pipeline will run `apply` without asking
    for further user input (`-input=false option`) and if `apply` ran without any
    errors, it will remove the `terraform.tfplan` file that was created in the plan
    step.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您已确认流水线将运行`apply`而无需进一步的用户输入（`-input=false`选项），并且`apply`运行没有任何错误，它将删除在计划步骤中创建的`terraform.tfplan`文件。
- en: GitHub Actions basics
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitHub Actions基础
- en: 'It’s possible to create a similar pipeline with `workflow_dispatch` option,
    but it will ask the user for input before the Action runs (see the official documentation
    for a reference: [https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/](https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/)).
    So, instead, let’s create an action that will run `plan` and `apply`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能创建一个类似的流水线，使用`workflow_dispatch`选项，但它会在Action运行之前要求用户输入（请参阅官方文档作为参考：[https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/](https://github.blog/changelog/2021-11-10-github-actions-input-types-for-manual-workflows/)）。因此，我们改为创建一个将运行`plan`和`apply`的Action：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code defines that the GitHub Action will only be triggered on
    changes to the main branch:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了GitHub Action将仅在更改主分支时触发：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we’re defining environment variables similarly to the Jenkins pipeline.
    AWS access and secret keys are coming from secrets stored in GitHub that we will
    need to add beforehand. This won’t be required if our GitHub runner is running
    inside the AWS environment or we are using GitHub OpenID Connect. You can read
    about the latter by checking out the GitHub documentation: [https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以类似于Jenkins流水线的方式定义了环境变量。AWS的访问密钥和密钥从存储在GitHub中的秘密中提取，这些秘密需要我们事先添加。如果我们的GitHub运行器在AWS环境中运行或我们使用GitHub
    OpenID Connect，则无需此操作。您可以通过查看GitHub文档了解后者：[https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services](https://docs.github.com/en/actions/deployment/security-hardening-your-deployments/configuring-openid-connect-in-amazon-web-services)。
- en: 'Next, we can define the GitHub Action steps within the `jobs` block:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在`jobs`块中定义GitHub Action的步骤：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we’re defining a job named `terraform_apply` that will run on the latest
    version of the Ubuntu runner that’s available in Github Actions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`terraform_apply`的作业，它将在GitHub Actions中可用的最新版本的Ubuntu运行器上运行：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This step checks out the code. We’re using a predefined Action available in
    GitHub instead of creating a script that will run the Git command line. The exact
    code it will run is available at [https://github.com/actions/checkout](https://github.com/actions/checkout):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该步骤检出代码。我们使用 GitHub 中可用的预定义 Action，而不是创建一个运行 Git 命令行的脚本。它将执行的确切代码可在[https://github.com/actions/checkout](https://github.com/actions/checkout)找到：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Setup Terraform` step will download Terraform for us. By default, it’ll
    download the latest available version of Terraform, but we can pin an exact version
    if we need to. The code for the step is available at [https://github.com/hashicorp/setup-terraform](https://github.com/hashicorp/setup-terraform):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Setup Terraform`步骤将为我们下载 Terraform。默认情况下，它将下载最新的可用版本，但如果需要，我们可以固定某个特定版本。该步骤的代码可在[https://github.com/hashicorp/setup-terraform](https://github.com/hashicorp/setup-terraform)找到：'
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `Terraform Plan` step, we’re initializing Terraform and running the
    plan in the same way we did for the Jenkins pipeline:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Terraform Plan`步骤中，我们初始化 Terraform 并以与 Jenkins 管道相同的方式运行计划：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, the `Terraform Apply` step is applying infrastructure changes from
    the previously saved Terraform plan file, `terraform.tfplan`, and removing the
    plan file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Terraform Apply`步骤将从之前保存的 Terraform 计划文件`terraform.tfplan`中应用基础设施变更，并删除计划文件。
- en: 'If you want to create a more robust piece of code that will work in every CI/CD
    tool out there, it’s possible to create a **Bash script** to do the heavy lifting.
    With Bash scripting, it’s also much easier to embed some testing before even running
    the plan. Here’s a sample Bash script that will run the Terraform plan and apply
    it for you:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望创建一段可以在任何 CI/CD 工具中工作的更强大的代码，可以创建一个**Bash 脚本**来完成繁重的工作。使用 Bash 脚本，您还可以在运行计划之前嵌入一些测试。以下是一个示例
    Bash 脚本，它将为您运行 Terraform 计划并应用它：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we’re setting Bash as a default shell for running this script. In the
    next few lines, we’re modifying the default settings for the script so that it
    stops executing when it encounters any unbound variables or errors:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将 Bash 设置为运行此脚本的默认 shell。在接下来的几行中，我们将修改脚本的默认设置，使其在遇到任何未绑定的变量或错误时停止执行：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code block checks whether Terraform is available in the system and saves
    the full path to it inside the `TERRAFORM_BIN` variable, which we will be using
    later:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块检查系统中是否可用 Terraform，并将其完整路径保存到`TERRAFORM_BIN`变量中，我们稍后将使用它：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Initialize the Terraform environment before running the plan:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行计划之前，初始化 Terraform 环境：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run `plan` and save it to a file for later use:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`plan`并将其保存到文件中以供后续使用：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code block executes `Terraform apply` and checks the return code
    of the command. It also displays appropriate information.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块执行`Terraform apply`并检查命令的返回代码。它还会显示相应的信息。
- en: Other major CI/CD solutions use a very similar approach. The biggest difference
    is between Jenkins, corporate tools, and open source solutions where **YAML**
    configuration is the most common. In the next section, we will dig a bit deeper
    into each stage of the pipeline, focusing on the integration testing for Terraform
    and deploying changes to the infrastructure.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其他主要的 CI/CD 解决方案使用类似的方法。最大的区别在于 Jenkins、企业工具和开源解决方案之间，其中**YAML**配置最为常见。在下一节中，我们将更深入地探讨管道的每个阶段，重点关注
    Terraform 的集成测试以及基础设施变更的部署。
- en: Continuously integrating and deploying your infrastructure
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和部署您的基础设施
- en: Testing application code is now a de facto standard, especially since the adoption
    of **test-driven development** (**TDD**). TDD is a software development process
    in which developers write automated tests before writing code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用程序代码现在已经成为事实上的标准，特别是在**测试驱动开发**（**TDD**）被采纳之后。TDD 是一种软件开发过程，在这个过程中，开发人员在编写代码之前先编写自动化测试。
- en: These tests are designed to fail initially, and developers then write code to
    make them pass. The code is continuously refactored to ensure it is efficient
    and maintainable while passing all tests. This approach helps reduce the number
    of bugs and increase the reliability of the software.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试最初是故意失败的，开发人员随后编写代码使其通过。代码会不断重构，以确保高效、可维护，并且能够通过所有测试。这种方法有助于减少漏洞并提高软件的可靠性。
- en: Testing infrastructure is not as easy as that as it’s hard to check whether
    Amazon **Elastic Compute Cloud** (**EC2**) will be successfully started without
    actually starting the instance. It’s possible to mock **API** calls to AWS, but
    it won’t guarantee that the actual API will return the same results as your testing
    code. With AWS, it would also mean that testing will be slow (we will need to
    wait for this EC2 instance to come up) and probably generate additional cloud
    costs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 测试基础设施并不像看起来那么简单，因为很难在不实际启动实例的情况下检查 Amazon **弹性计算云**（**EC2**）是否会成功启动。虽然可以模拟对
    AWS 的 **API** 调用，但这并不能保证实际的 API 会返回与测试代码相同的结果。使用 AWS 时，这也意味着测试会很慢（我们需要等待该 EC2
    实例启动），并且可能会产生额外的云端费用。
- en: There are multiple infrastructure testing tools, both integrated with Terraform
    and third-party software (which is also an open source software).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个基础设施测试工具，既有与 Terraform 集成的，也有第三方软件（这也是开源软件）。
- en: Integration testing
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: There are multiple basic tests we could run in our CI pipeline. We can detect
    drift between our actual code and what’s running in the cloud, we can lint our
    code according to the recommended format, and we can test whether the code is
    to the letter of our compliance policies. We can also estimate AWS costs from
    the Terraform code. Harder and more time-consuming processes include unit testing
    and end-to-end testing of our code. Let’s take a look at the available tools we
    could use in our pipeline.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 CI 流水线中可以运行多种基本测试。我们可以检测实际代码与云端运行代码之间的偏差，我们可以根据推荐的格式对代码进行 lint 检查，还可以测试代码是否符合我们的合规政策。我们还可以从
    Terraform 代码中估算 AWS 成本。更复杂且耗时的过程包括单元测试和代码的端到端测试。让我们来看一下在流水线中可以使用的可用工具。
- en: Most basic tests we could be running from the start involve simply running `terraform
    validate` and `terraform fmt`. The former will check whether the syntax of the
    Terraform code is valid (meaning there are no typos in resources and/or variables,
    all required variables are present, and so on). The `fmt` check will update the
    formatting of the code according to the Terraform standards, which means that
    all excessive white spaces will be removed, or some white spaces may be added
    to align the `=` sign for readability. This may be sufficient for simpler infrastructure
    and we recommend adding those tests from the start as it’s pretty straightforward
    to do. You can reuse parts of the code we provided earlier to bootstrap the process
    for your existing code.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一开始运行的大多数基本测试仅涉及运行 `terraform validate` 和 `terraform fmt`。前者将检查 Terraform
    代码的语法是否有效（意味着资源和/或变量没有拼写错误、所有必需的变量都存在等）。`fmt` 检查将根据 Terraform 标准更新代码的格式，这意味着所有多余的空格将被删除，或者某些空格可能会被添加以对齐
    `=` 符号以增强可读性。这对于更简单的基础设施来说可能已经足够，我们建议从一开始就添加这些测试，因为这样做非常简单。你可以重用我们之前提供的代码片段来启动你现有代码的过程。
- en: Infrastructure costs
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础设施成本
- en: Infrastructure costs are not a functional, static, or unit test you could be
    running in your testing pipeline. Although it’s very useful to monitor that aspect
    of your infrastructure, your manager will also be happy to know when the AWS budget
    is checking out with predictions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施成本不是你可以在测试流水线中运行的功能性、静态或单元测试。虽然监控这一方面对你的基础设施非常有用，但你的经理也会很高兴知道 AWS 预算是否符合预测。
- en: '**Infracost.io** is a cloud cost estimation tool that allows you to monitor
    and manage infrastructure costs by providing real-time cost analysis for cloud
    resources. With Infracost.io, you can estimate the cost of infrastructure changes
    and avoid any unexpected costs by providing cost feedback at every stage of the
    development cycle.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Infracost.io** 是一个云成本估算工具，允许你通过提供实时的云资源成本分析来监控和管理基础设施成本。使用 Infracost.io，你可以估算基础设施变更的成本，并在开发周期的每个阶段提供成本反馈，避免任何意外的费用。'
- en: Integrating Infracost.io into GitHub Actions is a straightforward process that
    involves creating an Infracost.io account and generating an API key that will
    allow you to access the cost estimation data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Infracost.io 集成到 GitHub Actions 中是一个简单的过程，包括创建一个 Infracost.io 账户并生成一个 API
    密钥，允许你访问成本估算数据。
- en: Next, you need to install the Infracost.io CLI on your local machine. The CLI
    is a command-line tool that allows you to calculate and compare infrastructure
    costs.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在本地机器上安装 Infracost.io 的命令行工具（CLI）。CLI 是一个命令行工具，允许你计算和比较基础设施成本。
- en: After installing the CLI, you can add an Infracost.io action to your GitHub
    workflow by creating a new action file – for example, `.github/workflows/infracost.yml`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 CLI 后，您可以通过创建一个新的操作文件（例如 `.github/workflows/infracost.yml`）来将 Infracost.io
    操作添加到您的 GitHub 工作流中。
- en: 'In the Infracost.io action file, you need to specify the Infracost.io API key
    and the path to your Terraform configuration files:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Infracost.io 的操作文件中，您需要指定 Infracost.io API 密钥以及 Terraform 配置文件的路径：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, commit and push the changes to your GitHub repository. Whenever a new
    Terraform configuration file is pushed to the repository, the Infracost.io action
    will automatically calculate the cost estimation and provide feedback on the GitHub
    Actions page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将更改提交并推送到您的 GitHub 仓库。每当新的 Terraform 配置文件被推送到仓库时，Infracost.io 操作会自动计算成本估算，并在
    GitHub Actions 页面上提供反馈。
- en: Infracost is free for open source projects, but it’s also possible to create
    your own service for monitoring cloud costs. A GitHub repository for Infracost
    can be found at [https://github.com/infracost/infracost.](https://github.com/infracost/infracost.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开源项目，Infracost 是免费的，但您也可以创建自己的服务来监控云成本。Infracost 的 GitHub 仓库可以在[https://github.com/infracost/infracost](https://github.com/infracost/infracost)找到。
- en: By integrating it into your CI pipeline, you can proactively monitor and manage
    your infrastructure costs and make informed decisions on infrastructure changes
    before deploying it to your cloud account.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将其集成到您的 CI 流水线中，您可以主动监控和管理基础设施成本，并在将其部署到云账户之前，基于这些信息做出有关基础设施更改的明智决策。
- en: Drift testing
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 漂移测试
- en: One of the challenges of managing infrastructure with Terraform is ensuring
    that the actual state of the infrastructure matches the desired state defined
    in the Terraform configuration files. This is where the concept of *drift* comes
    in.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 管理基础设施的一个挑战是确保基础设施的实际状态与 Terraform 配置文件中定义的期望状态相匹配。这就是 *漂移* 概念的由来。
- en: '**Drift** occurs when there is a difference between the desired state of the
    infrastructure and its actual state. For example, if a resource that was created
    using Terraform is manually modified outside of Terraform, the actual state of
    the infrastructure will differ from the desired state defined in Terraform configuration
    files. This can cause inconsistencies in the infrastructure and may lead to operational
    issues.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**漂移**发生在基础设施的期望状态与实际状态之间存在差异时。例如，如果使用 Terraform 创建的资源被手动修改而不通过 Terraform，基础设施的实际状态将与
    Terraform 配置文件中定义的期望状态不同。这可能导致基础设施的不一致，并可能引发操作问题。'
- en: To detect drift in the infrastructure, Terraform provides a command called `terraform
    plan`. When this command is run, Terraform compares the desired state defined
    in the Terraform configuration files with the actual state of the infrastructure
    and generates a plan of the changes that need to be made to bring the infrastructure
    back into the desired state. If there are any differences between the desired
    and actual states, Terraform will show them in the plan output.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测基础设施中的漂移，Terraform 提供了一个名为 `terraform plan` 的命令。当运行此命令时，Terraform 会将配置文件中定义的期望状态与基础设施的实际状态进行比较，并生成一份计划，列出将基础设施恢复到期望状态所需的更改。如果期望状态和实际状态之间存在任何差异，Terraform
    会在计划输出中显示它们。
- en: It’s also possible to use third-party tools that will extend this feature of
    Terraform. One of these tools is `Driftctl`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用第三方工具扩展 Terraform 的这一功能。其中一个工具就是 `Driftctl`。
- en: '`Driftctl` is an open source tool that helps detect drift in cloud infrastructure
    managed by Terraform. It scans the actual state of the infrastructure resources
    and compares them against the desired state defined in Terraform configuration
    files to identify any discrepancies or differences. `Driftctl` supports a wide
    range of cloud providers, including AWS, **Google Cloud**, **Microsoft Azure**,
    and Kubernetes.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`Driftctl` 是一个开源工具，帮助检测由 Terraform 管理的云基础设施中的漂移。它扫描基础设施资源的实际状态，并将其与 Terraform
    配置文件中定义的期望状态进行比较，以识别任何差异或不一致。`Driftctl` 支持广泛的云服务提供商，包括 AWS、**Google Cloud**、**Microsoft
    Azure** 和 Kubernetes。'
- en: '`Driftctl` can be used in various ways to detect drift in infrastructure. It
    can be integrated with a CI/CD pipeline to automatically detect drift and trigger
    corrective actions. It can also be run manually to check for drift on demand.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Driftctl` 可以以多种方式使用来检测基础设施中的漂移。它可以与 CI/CD 流水线集成，自动检测漂移并触发修正措施。也可以手动运行以按需检查漂移。'
- en: 'Here’s an example GitHub pipeline that utilizes `Driftctl` to detect infrastructure
    drift:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`Driftctl`工具来检测基础设施漂移的 GitHub pipeline 示例：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code indicates that this pipeline will run only on the `main`
    branch.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码表明，此 pipeline 将仅在`main`分支上运行。
- en: 'Here, we’re defining a job called `detect-drift` that will run on the latest
    Ubuntu Linux runner available:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`detect-drift`的作业，它将在最新的 Ubuntu Linux runner 上运行：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we’re starting to define what we’re going to do in each step of the pipeline
    – first, we will use a predefined action that will run `git clone` on the runner:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始定义 pipeline 中每个步骤要做的事情——首先，我们将使用一个预定义的动作，在 runner 上运行`git clone`：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step we’re defining is a shell script that will install, unzip, and
    download Terraform from the public repository published by HashiCorp:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤是定义一个 shell 脚本，用于从 HashiCorp 发布的公共仓库安装、解压并下载 Terraform：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this step, we will install the `Driftctl` tool by downloading an archive
    from the public release on GitHub. We will extract it and move the binary to the
    `/``usr/local/bin` directory:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们将通过从 GitHub 上的公共发布下载归档来安装`Driftctl`工具。我们将提取文件并将二进制文件移动到`/usr/local/bin`目录中：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The preceding steps simply involve running `terraform init` and `terraform
    validate` to verify whether we can access the Terraform backend and whether the
    code we intend to check in the next few steps is valid from a syntax perspective:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 上述步骤仅涉及运行`terraform init`和`terraform validate`，以验证我们是否可以访问 Terraform 后端，以及我们打算在接下来的几步中检查的代码是否在语法上有效：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The final two steps are running the `Driftctl` tool and saving their findings
    inside the `driftctl.json` file, which is uploaded to GitHub artifacts with the
    name `drift-report`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两步是运行`Driftctl`工具，并将其发现结果保存在`driftctl.json`文件中，该文件将作为`drift-report`上传到 GitHub
    工件中。
- en: 'To summarize, this pipeline runs on the `main` branch and performs the following
    steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，这个 pipeline 在`main`分支上运行，并执行以下步骤：
- en: Checks out the code from the GitHub repository.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 仓库检出代码。
- en: Installs `terraform` and `driftctl`.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装`terraform`和`driftctl`。
- en: Initializes Terraform and validates the Terraform configuration files.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化 Terraform 并验证 Terraform 配置文件。
- en: Uses `driftctl` to scan the actual state of the infrastructure resources and
    compares them against the desired state defined in the Terraform configuration
    files to detect any drift. The output of this scan is saved to a JSON file called
    `drift.json`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`driftctl`扫描基础设施资源的实际状态，并将其与 Terraform 配置文件中定义的期望状态进行比较，以检测任何漂移。此扫描的输出将保存到名为`drift.json`的
    JSON 文件中。
- en: Uploads the `drift.json` file as an artifact to GitHub, making it available
    for further analysis.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`drift.json`文件作为工件上传到 GitHub，供后续分析使用。
- en: Additionally, this pipeline can be customized to meet specific requirements,
    such as integrating with a CI/CD pipeline or running on a schedule to regularly
    check for drift in the infrastructure.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个 pipeline 还可以根据特定需求进行自定义，例如集成到 CI/CD pipeline 中或按计划定期检查基础设施中的漂移。
- en: The need for installing `driftctl` and `terraform` on every pipeline run is
    not desired, so we recommend that you prepare your own Docker image with preinstalled
    proper versions of those tools and use that instead. It will also increase your
    security along the way.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 每次 pipeline 运行时都需要安装`driftctl`和`terraform`并不是我们期望的做法，因此我们建议您准备一个包含这些工具预安装的 Docker
    镜像，并使用该镜像。这还将提升您的安全性。
- en: 'You can find more information about the project on the website: [https://driftctl.com/](https://driftctl.com/).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在网站[https://driftctl.com/](https://driftctl.com/)上找到有关该项目的更多信息。
- en: Security testing
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全测试
- en: Testing infrastructure security is an essential aspect of maintaining secure
    and stable systems. As modern infrastructure is often defined and managed as code,
    it is necessary to test it just like any other code. **Infrastructure as Code**
    (**IaC**) testing helps identify security vulnerabilities, configuration issues,
    and other flaws that may lead to system compromise.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 测试基础设施的安全性是维护安全稳定系统的一个重要方面。由于现代基础设施通常作为代码进行定义和管理，因此有必要像测试其他代码一样对其进行测试。**基础设施即代码**（**IaC**）测试有助于发现安全漏洞、配置问题以及可能导致系统被攻破的其他缺陷。
- en: There are several automated tools available that can aid in infrastructure security
    testing. These tools can help identify potential security issues, such as misconfigured
    security groups, unused security rules, and unsecured sensitive data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种自动化工具可以帮助进行基础设施安全测试。这些工具可以帮助识别潜在的安全问题，例如配置错误的安全组、未使用的安全规则和不安全的敏感数据。
- en: 'There are several tools we can use to test security as a separate process from
    the CI pipeline:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用几个工具来作为 CI 管道外的单独过程进行安全性测试：
- en: '**Prowler**: This is an open source tool that scans AWS infrastructure for
    security vulnerabilities. It can check for issues such as AWS **Identity and Access
    Management** (**IAM**) misconfigurations, open security groups, and **S3 bucket**
    permission issues.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prowler**：这是一个开源工具，用于扫描 AWS 基础设施中的安全漏洞。它可以检查诸如 AWS **身份与访问管理**（**IAM**）配置错误、开放的安全组和**S3
    存储桶**权限问题等。'
- en: '**CloudFormation Guard**: This is a tool that validates **AWS CloudFormation**
    templates against a set of predefined security rules. It can help identify issues
    such as open security groups, unused IAM policies, and non-encrypted S3 buckets.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloudFormation Guard**：这是一个工具，用于根据一组预定义的安全规则验证**AWS CloudFormation**模板。它可以帮助识别诸如开放安全组、未使用的
    IAM 策略和未加密的 S3 存储桶等问题。'
- en: '**OpenSCAP**: This is a tool that provides automated security compliance testing
    for Linux-based infrastructure. It can scan the system for compliance with various
    security standards, such as the **Payment Card Industry Data Security Standard**
    (**PCI DSS**) or **National Institute of Standards and Technology Special Publication
    800-53** (**NIST** **SP 800-53**).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenSCAP**：这是一个为基于 Linux 的基础设施提供自动化安全合规性测试的工具。它可以扫描系统是否符合各种安全标准，如**支付卡行业数据安全标准**（**PCI
    DSS**）或**国家标准与技术研究院特别出版物 800-53**（**NIST** **SP 800-53**）。'
- en: '**InSpec**: This is another open source testing framework that can be used
    for testing infrastructure compliance and security. It has built-in support for
    various platforms and can be used to test against different security standards,
    such as the **Health Insurance Portability and Accountability Act** (**HIPAA**)
    and **Center for Internet** **Security** (**CIS**).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**InSpec**：这是另一个开源测试框架，可用于测试基础设施的合规性和安全性。它内置支持多种平台，并可以用于针对不同的安全标准进行测试，例如**健康保险流通与责任法案**（**HIPAA**）和**互联网安全中心**（**CIS**）。'
- en: 'Here, we’re focusing on integrating some security testing within the CI. The
    tools we could integrate here are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重点关注在持续集成（CI）中集成一些安全测试。我们可以在此处集成的工具如下：
- en: '**tfsec** is an open source static analysis tool for Terraform code. It scans
    Terraform configurations to detect potential security issues and provides suggestions
    for remediation. It has built-in support for various cloud providers and can help
    identify issues such as weak authentication, insecure network configurations,
    and unencrypted data storage. Its GitHub repository can be found at [https://github.com/aquasecurity/tfsec](https://github.com/aquasecurity/tfsec).'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tfsec** 是一个开源的 Terraform 代码静态分析工具。它扫描 Terraform 配置，以检测潜在的安全问题，并提供修复建议。它内置支持多种云服务提供商，可以帮助识别诸如弱身份验证、不安全的网络配置和未加密的数据存储等问题。其
    GitHub 仓库可以在 [https://github.com/aquasecurity/tfsec](https://github.com/aquasecurity/tfsec)
    找到。'
- en: '**Terrascan** is an open source tool for static code analysis of IaC files.
    It supports various IaC file formats, including Terraform, Kubernetes YAML, and
    Helm charts, and scans them for security vulnerabilities, compliance violations,
    and other issues. Terrascan can be integrated into a CI/CD pipeline and helps
    ensure that infrastructure deployments are secure and compliant with industry
    standards. Its GitHub repository can be found at [https://github.com/tenable/terrascan](https://github.com/tenable/terrascan).'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Terrascan** 是一个用于基础设施即代码（IaC）文件的静态代码分析开源工具。它支持多种 IaC 文件格式，包括 Terraform、Kubernetes
    YAML 和 Helm 图表，并扫描这些文件中的安全漏洞、合规性违规和其他问题。Terrascan 可以集成到 CI/CD 管道中，并帮助确保基础设施部署是安全的，并符合行业标准。其
    GitHub 仓库可以在 [https://github.com/tenable/terrascan](https://github.com/tenable/terrascan)
    找到。'
- en: '**CloudQuery** is an open source tool that enables users to test security policies
    and compliance across different cloud platforms, including AWS, **Google Cloud
    Platform** (**GCP**), and Microsoft Azure. It provides a unified query language
    and interface to access cloud resources, allowing users to analyze configurations
    and detect potential security vulnerabilities. CloudQuery integrates with various
    CI/CD pipelines, making it easy to automate testing for security policies and
    compliance. Users can also customize queries and rules based on their specific
    needs and standards. You can read more about this topic in their blog post: [https://www.cloudquery.io/how-to-guides/open-source-cspm](https://www.cloudquery.io/how-to-guides/open-source-cspm).'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloudQuery** 是一个开源工具，使用户能够在不同的云平台上测试安全策略和合规性，包括 AWS、**Google Cloud Platform**（**GCP**）和
    Microsoft Azure。它提供了统一的查询语言和接口来访问云资源，允许用户分析配置并检测潜在的安全漏洞。CloudQuery 集成了各种 CI/CD
    流水线，使自动化安全策略和合规性测试变得更加容易。用户还可以根据他们的特定需求和标准自定义查询和规则。你可以在他们的博客文章中阅读更多相关内容：[https://www.cloudquery.io/how-to-guides/open-source-cspm](https://www.cloudquery.io/how-to-guides/open-source-cspm)。'
- en: 'Let’s look at the example GitHub pipeline that’s integrating the `terrascan`
    tool:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下这个示例 GitHub 流水线，它集成了 `terrascan` 工具：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this workflow, the `on: [push]` line specifies that the workflow should
    be triggered whenever changes are pushed to the repository.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个工作流中，`on: [push]` 行指定每当有更改推送到仓库时，工作流应该被触发。'
- en: The `jobs` section contains a single job called `scan`. The `runs-on` key specifies
    that the job should run on an Ubuntu machine.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`jobs` 部分包含一个名为 `scan` 的单个作业。`runs-on` 键指定该作业应在 Ubuntu 机器上运行。'
- en: 'The `steps` section contains three steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`steps` 部分包含三个步骤：'
- en: It checks out the code from the repository using the `actions/checkout` action.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `actions/checkout` 操作从仓库中检出代码。
- en: It downloads and installs Terrascan on the machine using the `wget` and `unzip`
    commands. Note that this step assumes that you’re running the workflow on a Linux
    machine.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 `wget` 和 `unzip` 命令在机器上下载并安装 Terrascan。请注意，这一步假设你在 Linux 机器上运行工作流。
- en: It runs Terrascan to scan the infrastructure code. You’ll need to replace `./path/to/infrastructure/code`
    with the actual path to your infrastructure code.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它运行 Terrascan 来扫描基础设施代码。你需要将 `./path/to/infrastructure/code` 替换为你实际的基础设施代码路径。
- en: Once you’ve created this workflow and pushed it to your GitHub repository, GitHub
    Actions will automatically run the workflow whenever changes are pushed to the
    repository. You can view the results of the Terrascan scan in the workflow logs.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了这个工作流并将其推送到你的 GitHub 仓库，GitHub Actions 会在每次有更改推送到仓库时自动运行该工作流。你可以在工作流日志中查看
    Terrascan 扫描的结果。
- en: 'Let’s move on to **infrastructure unit testing**. There are generally two options
    at the moment: **Terratest** when testing **HCL** code directly or **CDKTF**/**Pulumi**
    if you want to use more advanced programming languages to maintain your IaC.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论 **基础设施单元测试**。目前通常有两种选择：直接测试 **HCL** 代码时使用 **Terratest**，或者如果你想使用更先进的编程语言来维护你的基础设施即代码（IaC），可以选择
    **CDKTF**/**Pulumi**。
- en: Testing with Terratest
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Terratest 进行测试
- en: Terratest is an open source testing framework for infrastructure code, including
    HCL code for Terraform. It was first released in 2017 by **Gruntwork**, a company
    that specializes in infrastructure automation and offers a set of pre-built infrastructure
    modules called the Gruntwork IaC Library.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Terratest 是一个开源测试框架，用于基础设施代码的测试，包括 Terraform 的 HCL 代码。它于 2017 年由专注于基础设施自动化的公司
    **Gruntwork** 发布，该公司还提供一套预构建的基础设施模块，称为 Gruntwork IaC 库。
- en: Terratest is designed to simplify testing infrastructure code by providing a
    suite of helper functions and libraries that allow users to write automated tests
    written in **Go**, a popular programming language for infrastructure automation.
    Terratest can be used to test not only Terraform code but also infrastructure
    built with other tools such as **Ansible**, **Packer**, and **Docker**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Terratest 旨在通过提供一套辅助函数和库来简化基础设施代码的测试，使用户能够编写使用 **Go**（一种流行的基础设施自动化编程语言）编写的自动化测试。Terratest
    不仅可以用于测试 Terraform 代码，还可以用于测试使用其他工具构建的基础设施，如 **Ansible**、**Packer** 和 **Docker**。
- en: One of the key benefits of Terratest is that it allows developers to test their
    infrastructure code in a production-like environment, without the need for a dedicated
    test environment. This can be achieved by using tools such as Docker and Terraform
    to spin up temporary infrastructure resources for testing purposes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Terratest 的一个关键优势是，它允许开发人员在类似生产环境的环境中测试他们的基础设施代码，而无需专门的测试环境。这可以通过使用 Docker 和
    Terraform 等工具来创建临时基础设施资源进行测试。
- en: Terratest also provides a range of test types, including **unit tests**, **integration
    tests**, and **end-to-end tests**, allowing users to test their infrastructure
    code at different levels of abstraction. This helps ensure that code changes are
    thoroughly tested before they are deployed to production, reducing the risk of
    downtime or other issues.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Terratest 还提供了一系列测试类型，包括 **单元测试**、**集成测试** 和 **端到端测试**，允许用户在不同的抽象层次测试他们的基础设施代码。这有助于确保在将代码部署到生产环境之前，进行充分的测试，减少停机或其他问题的风险。
- en: 'An example of testing an `aws_instance` resource we created in a module in
    the previous chapter would look like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们在上一章中创建的 `aws_instance` 资源的示例如下所示：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we first define a test function called `TestAwsInstance` using
    the standard `terraformOptions` object that specifies the directory of our Terraform
    module.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们首先定义一个名为 `TestAwsInstance` 的测试函数，使用标准的 `terraformOptions` 对象，该对象指定我们的
    Terraform 模块的目录。
- en: Then, we use the `terraform.InitAndApply` function to initialize and apply the
    Terraform configuration, creating the **AWS EC2** instance resource.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用 `terraform.InitAndApply` 函数来初始化和应用 Terraform 配置，创建 **AWS EC2** 实例资源。
- en: Next, we use the `aws.GetEc2Instance` function from the **Terratest AWS module**
    to retrieve information about the instance that was created, using its ID as input.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 **Terratest AWS 模块** 中的 `aws.GetEc2Instance` 函数，通过实例 ID 获取有关已创建实例的信息。
- en: Finally, we use the `assert` library from the `testify` package to write assertions
    that validate the properties of the instance, such as its instance type and tags.
    If any of the assertions fail, the test will fail.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `testify` 包中的 `assert` 库编写断言，验证实例的属性，例如其实例类型和标签。如果任何断言失败，测试将失败。
- en: To run this example, you will need to ensure that you have installed the Terratest
    and AWS Go modules, and have valid AWS credentials set up in your environment.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，您需要确保已安装 Terratest 和 AWS Go 模块，并在您的环境中设置了有效的 AWS 凭据。
- en: Unit testing with CDKTF
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CDKTF 进行单元测试
- en: AWS **Cloud Development Kit for Terraform** (**CDKTF**) is an open source framework
    for Terraform that allows developers to define the infrastructure and services
    inside any cloud solution Terraform supports using programming languages such
    as **TypeScript**, **Python**, and **C#**. It enables the creation of IaC using
    high-level object-oriented abstractions, reducing the complexity of writing and
    maintaining infrastructure code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**AWS Cloud Development Kit for Terraform** (**CDKTF**) 是一个开源框架，允许开发人员使用编程语言（如**TypeScript**、**Python**
    和 **C#**）在 Terraform 支持的任何云解决方案中定义基础设施和服务。它通过使用高级面向对象抽象来实现基础设施即代码（IaC）的创建，减少了编写和维护基础设施代码的复杂性。'
- en: 'CDKTF was initially released in March 2020, and it is a collaboration between
    AWS and HashiCorp, the company behind Terraform. CDKTF leverages the best of both
    worlds: the familiarity and expressiveness of modern programming languages, and
    the declarative, multi-cloud capabilities of Terraform.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: CDKTF 最初于 2020 年 3 月发布，是 AWS 和 Terraform 背后的公司 HashiCorp 之间的合作。CDKTF 融合了两者的优势：现代编程语言的熟悉性和表现力，以及
    Terraform 的声明式、多云能力。
- en: TypeScript is the most popular language used with CDKTF, and it provides a type-safe
    development experience with features such as static type-checking, code completion,
    and refactoring.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 是与 CDKTF 一起使用的最流行的语言，它提供了一个类型安全的开发体验，具有静态类型检查、代码补全和重构等功能。
- en: 'As an example, let’s reuse the Terraform code from [*Chapter 12*](B18197_12.xhtml#_idTextAnchor365):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，让我们重用 [*第 12 章*](B18197_12.xhtml#_idTextAnchor365) 中的 Terraform 代码：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The equivalent code in CDKTF in Python would look like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，CDKTF 的等效代码如下所示：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we’re importing all required modules. The first line of the script says
    that the default interpreter for it should be a Python interpreter that’s available
    in the system:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们导入了所有必需的模块。脚本的第一行表示该脚本的默认解释器应该是系统中可用的 Python 解释器：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding line, we’re configuring a default provider to use the `eu-central-1`
    region. Let’s see what’s next:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码行中，我们正在配置一个默认提供程序来使用 `eu-central-1` 区域。接下来让我们看看：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following is an example unit test for the preceding code that uses the
    `unittest` Python module and the usual syntax for TDD in Python:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `unittest` Python 模块并遵循 Python 中 TDD 通常语法的单元测试示例：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As stated previously, unfortunately, the instance must be running in AWS for
    us to test whether we have the desired tags and other properties available through
    the CDKTF. The instance is being created by the `setUp()` function and terminated
    with the `tearDown()` function. Here, we’re using a small instance that is **Free
    Tier eligible**, but with bigger instances, it will generate some costs.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，不幸的是，实例必须在 AWS 中运行，才能测试我们是否拥有通过 CDKTF 获取的期望标签和其他属性。该实例由 `setUp()` 函数创建，并通过
    `tearDown()` 函数终止。在这里，我们使用的是一个 **免费套餐适用** 的小型实例，但对于更大的实例，会产生一定的费用。
- en: Experimental Terraform testing module
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实验性 Terraform 测试模块
- en: The final but very interesting option is using the testing Terraform module.
    This module allows you to write Terraform (HCL) code tests, also in the same language.
    This will potentially make it much easier to write tests as the current options
    we’ve already gone through cover writing tests in Golang or by using CTKTF.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但非常有趣的选择是使用测试 Terraform 模块。这个模块允许你编写 Terraform（HCL）代码测试，也是在相同的语言中进行测试。这将可能大大简化测试编写，因为我们之前介绍的现有选项需要使用
    Golang 或 CTKTF 来编写测试。
- en: At the time of writing, the module is considered highly experimental, but it’s
    worth keeping an eye on how it will develop in the future.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，该模块被认为是高度实验性的，但值得关注它未来的发展。
- en: The module’s website can be found at [https://developer.hashicorp.com/terraform/language/modules/testing-experiment](https://developer.hashicorp.com/terraform/language/modules/testing-experiment).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的网站可以在 [https://developer.hashicorp.com/terraform/language/modules/testing-experiment](https://developer.hashicorp.com/terraform/language/modules/testing-experiment)
    找到。
- en: Other integration tools worth mentioning
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他值得一提的集成工具
- en: 'There is a galaxy of other testing tools out there, and more are being developed
    as you read this. The following is a short list of tools worth mentioning that
    we didn’t have enough space to describe properly:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 市面上有许多其他测试工具，随着你阅读本文，更多工具还在开发中。以下是一些值得一提的工具清单，由于篇幅限制，无法对其进行详细描述：
- en: '**Checkov** (https://www.checkov.io/): This is an open source IaC static analysis
    tool that helps developers and **DevOps** teams identify and fix security and
    compliance issues early in the development life cycle.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Checkov** (https://www.checkov.io/)：这是一个开源的 IaC 静态分析工具，帮助开发人员和 **DevOps**
    团队在开发生命周期早期识别并修复安全和合规性问题。'
- en: '**Super-linter** (https://github.com/github/super-linter): This is an open
    source code linting tool that can automatically detect and flag issues in various
    programming languages and help maintain consistent code quality.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Super-linter** (https://github.com/github/super-linter)：这是一个开源的代码检查工具，能够自动检测和标记各种编程语言中的问题，帮助维护一致的代码质量。'
- en: '**Trivy** (https://github.com/aquasecurity/trivy): This is a vulnerability
    scanner for container images that helps developers and DevOps teams identify and
    fix vulnerabilities in their containerized applications.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Trivy** (https://github.com/aquasecurity/trivy)：这是一个容器镜像漏洞扫描工具，帮助开发人员和 DevOps
    团队识别并修复其容器化应用中的漏洞。'
- en: '**Kitchen-Terraform** (https://github.com/newcontext-oss/kitchen-terraform):
    This tool is part of the Test Kitchen plugin collection and allows systems to
    utilize **Test Kitchen** to apply and validate Terraform configurations with **InSpec**
    controls.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kitchen-Terraform** (https://github.com/newcontext-oss/kitchen-terraform)：此工具是
    Test Kitchen 插件集合的一部分，允许系统利用 **Test Kitchen** 来应用和验证 Terraform 配置，并使用 **InSpec**
    控制。'
- en: '**RSpec-Terraform** (https://github.com/bsnape/rspec-terraform): This tool
    provides RSpec tests for Terraform modules. RSpec is a **behavior-driven development**
    (**BDD**) testing framework for **Ruby** that allows developers to write expressive
    and readable tests in a **domain-specific** **language** (**DSL**).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RSpec-Terraform** (https://github.com/bsnape/rspec-terraform)：此工具为 Terraform
    模块提供 RSpec 测试。RSpec 是一个 **行为驱动开发**（**BDD**）测试框架，专为 **Ruby** 设计，使开发人员能够用 **领域特定语言**（**DSL**）编写富有表现力且易读的测试。'
- en: '**Terraform-Compliance** (https://github.com/terraform-compliance/cli): This
    is a BDD testing tool designed for Terraform files.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Terraform-Compliance** (https://github.com/terraform-compliance/cli)：这是一个专为
    Terraform 文件设计的 BDD 测试工具。'
- en: '**Clarity** (https://github.com/xchapter7x/clarity): This is a declarative
    Terraform test framework that specializes in unit testing.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clarity** (https://github.com/xchapter7x/clarity)：这是一个声明式的Terraform测试框架，专门用于单元测试。'
- en: In conclusion, we have a lot of testing options available. This could be overwhelming
    for some. Testing the Terraform code is still in development, similar to the other
    IaC solutions we’ve mentioned. When implementing CI pipelines, it’s best to focus
    on the low-hanging fruits at the beginning (format checking, running `terraform
    plan`, and so on) and add more testing during development. We realize it’s a hard
    thing to accomplish, but we believe that investing in this will enable us to make
    infrastructure changes with more confidence and protect us from unintentional
    outages.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们有很多可用的测试选项。对于一些人来说，这可能会感到不知所措。Terraform代码的测试仍在开发中，类似于我们提到的其他IaC解决方案。在实现CI流水线时，最好一开始专注于简单的任务（格式检查、运行`terraform
    plan`等），然后在开发过程中逐步增加更多测试。我们意识到这是一个艰巨的任务，但我们相信，投资这些工作将帮助我们以更高的信心进行基础设施更改，并避免无意的停机。
- en: In the next section, we will focus on various CD solutions, both SaaS and self-hosted.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将重点介绍各种CD解决方案，包括SaaS和自托管版本。
- en: Deployment
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: '`terraform apply`. This can be done automatically with a simple Bash script,
    but the hard part is to integrate this into the CD tool to ensure we won’t remove
    any data by mistake with confidence. Assuming we have done a great job with our
    integration testing and we’re confident enough to do it without any further user
    interaction, we can enable it to run automatically.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform apply`。这可以通过一个简单的Bash脚本自动完成，但难点在于如何将其集成到CD工具中，以确保我们不会无意中删除数据，并且可以有信心地执行。假设我们已经完成了出色的集成测试，并且有足够的信心在没有进一步用户交互的情况下执行它，我们可以启用自动运行。'
- en: Previously, we’ve shown examples of using Jenkins, GitHub Actions, and even
    a Bash script that we could embed into the process to automate it. We can successfully
    use these solutions to deploy our changes to the infrastructure; however, there
    are already dedicated solutions for that. Let’s take a look at the most popular
    ones, starting with SaaS offerings from the company behind Terraform – HashiCorp.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们展示了使用Jenkins、GitHub Actions，甚至一个可以嵌入到流程中的Bash脚本来自动化这一过程的示例。我们可以成功地使用这些解决方案将更改部署到基础设施中；然而，已经有专门的解决方案来完成这项工作。让我们从Terraform背后的公司——HashiCorp的SaaS产品开始，来看看最流行的几种。
- en: HashiCorp Cloud and Terraform Cloud
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HashiCorp Cloud与Terraform Cloud
- en: HashiCorp is a software company that provides various tools for infrastructure
    automation and management. Two of the most popular products offered by HashiCorp
    are **HashiCorp Cloud** and **Terraform Cloud**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp是一家提供各种基础设施自动化和管理工具的软件公司。HashiCorp提供的两个最受欢迎的产品是**HashiCorp Cloud**和**Terraform
    Cloud**。
- en: HashiCorp Cloud is a cloud-based service that provides a suite of tools for
    infrastructure automation and management. It includes HashiCorp’s popular tools
    such as Terraform, **Vault**, **Consul**, and **Nomad**. With HashiCorp Cloud,
    users can create and manage their infrastructure using the same tools that they
    use locally.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp Cloud是一个基于云的服务，提供一套用于基础设施自动化和管理的工具。它包括HashiCorp的流行工具，如Terraform、**Vault**、**Consul**和**Nomad**。使用HashiCorp
    Cloud，用户可以使用与本地相同的工具来创建和管理他们的基础设施。
- en: On the other hand, Terraform Cloud is a specific offering from HashiCorp that
    focuses solely on the IaC tool Terraform. Terraform Cloud provides a central place
    for teams to collaborate on infrastructure code, store configuration state, and
    automate infrastructure workflows. It offers several features, such as workspace
    management, version control, and collaboration tools, that make it easier for
    teams to work together on large-scale infrastructure projects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Terraform Cloud是HashiCorp专门推出的一款产品，专注于IaC工具Terraform。Terraform Cloud为团队提供了一个集中的地方，协作管理基础设施代码、存储配置状态以及自动化基础设施工作流。它提供了多个功能，如工作区管理、版本控制和协作工具，使团队更容易在大规模基础设施项目中协作。
- en: One of the key differences between HashiCorp Cloud and Terraform Cloud is that
    the former offers a suite of tools for infrastructure automation and management,
    while the latter is specifically focused on Terraform.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp Cloud与Terraform Cloud之间的主要区别在于，前者提供一整套用于基础设施自动化和管理的工具，而后者则专注于Terraform。
- en: Scalr
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Scalr
- en: '**Scalr** is a cloud management platform that provides enterprise-level solutions
    for cloud infrastructure automation and management. It was founded in 2007 by
    Sebastian Stadil to simplify the process of managing multiple cloud environments.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**Scalr** 是一个云管理平台，为云基础架构的自动化和管理提供企业级解决方案。它由Sebastian Stadil于2007年创立，旨在简化管理多个云环境的流程。'
- en: 'Scalr is a multi-cloud management platform. It comes in two flavors: commercial,
    which is hosted by the parent company as a SaaS solution, and open source, which
    you can deploy yourself. It can run your Terraform code, but it has more features,
    such as cost analysis, which will present the estimated bill from the cloud provider
    for the infrastructure you are deploying. It comes with a web UI, abstracting
    a lot of work that needs to be done when working with IaC. As we mentioned previously,
    it is a multi-cloud solution and it comes with a centralized **single sign-on**
    (**SSO**) that lets you view and manage all your cloud environments from one place.
    It comes with roles, a modules registry, and so on. It is a good solution if you
    are looking for more than just a centralized IaC tool.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Scalr是一个多云管理平台。它有两种版本：商业版作为SaaS解决方案由母公司托管，开源版则可由您自行部署。它可以运行您的Terraform代码，但它还具有更多功能，例如成本分析，用于展示您正在部署的基础设施的云提供商的预估账单。它配备了Web
    UI，抽象了在处理IaC时需要完成的大部分工作。正如我们之前提到的，它是一个多云解决方案，并且配备了集中式的**单点登录**（**SSO**），可让您从一个地方查看和管理所有的云环境。它提供角色、模块注册表等功能。如果您需要的不仅仅是一个集中化的IaC工具，那么它是一个很好的选择。
- en: Spacelift
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spacelift
- en: '**Spacelift** is a cloud-native IaC platform that helps development teams automate
    and manage their infrastructure with Terraform, Pulimi, or **CloudFormation**.
    It also supports automation of Kubernetes using **kubectl** and **Ansible CaaC**.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**Spacelift** 是一个云原生的IaC平台，帮助开发团队通过Terraform、Pulumi或**CloudFormation**自动化和管理其基础架构。它还支持使用**kubectl**和**Ansible
    CaaC**自动化Kubernetes。'
- en: The platform offers a range of features, such as version control, automated
    testing, and continuous delivery, allowing teams to accelerate their infrastructure
    deployment cycles and reduce the risk of errors. Spacelift also provides real-time
    monitoring and alerts, making it easy to identify and resolve issues before they
    cause downtime or affect user experience.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该平台提供多种功能，如版本控制、自动化测试和持续交付，使团队能加快基础设施部署周期并降低错误风险。Spacelift还提供实时监控和警报，帮助轻松识别和解决可能导致停机或影响用户体验的问题。
- en: Spacelift was founded in 2020 by a team of experienced DevOps and infrastructure
    engineers who recognized the need for a better way to manage IaC. The company
    has since grown rapidly, attracting customers from a wide range of industries,
    including healthcare, finance, and e-commerce.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Spacelift由一支经验丰富的DevOps和基础架构工程师团队于2020年创立，他们意识到需要更好的方式来管理IaC。公司自那时以来迅速发展，吸引了来自医疗保健、金融和电子商务等各行业的客户。
- en: The official website can be found at https://spacelift.com.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 官方网站位于 https://spacelift.com。
- en: Env0
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Env0
- en: '**Env0** is a SaaS platform that enables teams to automate their infrastructure
    and application delivery workflows with Terraform. It was founded in 2018 by a
    team of experienced DevOps engineers who recognized the need for a streamlined
    and easy-to-use solution for managing IaC.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**Env0** 是一个SaaS平台，使团队能够通过Terraform自动化其基础架构和应用程序交付工作流程。它由一支经验丰富的DevOps工程师团队于2018年创立，他们意识到需要一个简化且易于使用的解决方案来管理IaC。'
- en: Env0 offers a variety of features and integrations to help teams manage their
    Terraform environments, including automated environment provisioning, integration
    with popular CI/CD tools such as Jenkins and **CircleCI**, and support for multiple
    cloud providers, including AWS, Azure, and Google Cloud.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Env0提供各种功能和集成，帮助团队管理其Terraform环境，包括自动环境配置、与流行的CI/CD工具（如Jenkins和**CircleCI**）集成，以及支持AWS、Azure和Google
    Cloud等多个云提供商。
- en: As a private company, Env0 does not publicly disclose its financial information.
    However, they have received significant funding from venture capital firms, including
    a $3.5 million seed round in 2020 led by Boldstart Ventures and Grove Ventures.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一家私人公司，Env0不公开其财务信息。然而，他们从风险投资公司获得了重要资金支持，包括2020年由Boldstart Ventures和Grove
    Ventures领投的350万美元种子轮融资。
- en: Env0 has quickly established itself as a leading SaaS provider for managing
    Terraform environments and streamlining DevOps workflows and looks like a very
    interesting option to us in your environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Env0迅速确立了自己作为管理Terraform环境和简化DevOps工作流的领先SaaS提供商，看起来在你的环境中是一个非常有趣的选择。
- en: The official website can be found at [https://www.env0.com/](https://www.env0.com/).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 官方网站可以在[https://www.env0.com/](https://www.env0.com/)找到。
- en: Atlantis
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Atlantis
- en: '**Atlantis** is an open source project that aims to simplify the management
    of Terraform infrastructure code by providing a streamlined workflow for creating,
    reviewing, and merging pull requests. The first release of Atlantis was made in
    2018 and it has since gained popularity among developers and DevOps teams who
    use Terraform as their IaC tool.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**Atlantis**是一个开源项目，旨在通过提供简化的工作流来管理Terraform基础设施代码，帮助创建、审查和合并拉取请求。Atlantis的首次发布是在2018年，随后在使用Terraform作为IaC工具的开发者和DevOps团队中获得了广泛的关注。'
- en: Atlantis works by integrating with your existing version control system, such
    as GitHub or GitLab, and continuously monitors for pull requests that contain
    Terraform code changes. When a new pull request is opened, Atlantis automatically
    creates a new environment for the changes and posts a comment in the pull request
    with a link to the environment. This allows reviewers to quickly and easily see
    the changes in a live environment and provide feedback. Once the changes have
    been reviewed and approved, Atlantis can automatically merge the pull request
    and apply the changes to the target infrastructure.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Atlantis通过与现有的版本控制系统（如GitHub或GitLab）集成来工作，持续监控包含Terraform代码更改的拉取请求。当新的拉取请求被打开时，Atlantis会自动为这些更改创建一个新的环境，并在拉取请求中发布一个链接，指向该环境。这样，审阅者可以快速且轻松地在实时环境中查看更改并提供反馈。一旦更改被审阅并批准，Atlantis可以自动合并拉取请求并将更改应用到目标基础设施中。
- en: This open source tool is the one we will dive deeper into. Since its source
    code is available for free, you will be able to download it yourself and deploy
    it on your local environment or inside the public cloud. Let’s deploy Atlantis
    in AWS and configure a simple infrastructure to be managed by it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个开源工具是我们将深入研究的对象。由于其源代码是免费的，你可以自己下载并将其部署到本地环境或公有云中。让我们在AWS中部署Atlantis，并配置一个简单的基础设施来进行管理。
- en: CI/CD with Atlantis
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Atlantis进行CI/CD
- en: Armed with the knowledge about tooling and principles around CI/CD (both delivery
    and deployment), we will create a CI/CD pipeline with the use of Git and the open
    source tool Atlantis. We will automatically test and deploy changes to our AWS
    infrastructure with it and do basic testing along the way.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握CI/CD（包括交付和部署）工具和原则的相关知识后，我们将使用Git和开源工具Atlantis创建一个CI/CD管道。我们将利用它自动测试并部署对AWS基础设施的更改，并在此过程中进行基本测试。
- en: Deploying Atlantis to AWS
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Atlantis部署到AWS
- en: 'We will use the Terraform module created by Anton Bobenko from the `terraform-aws-modules`
    project on GitHub. Here is the Terraform Registry link to the module: [https://registry.terraform.io/modules/terraform-aws-modules/atlantis/aws/latest](https://registry.terraform.io/modules/terraform-aws-modules/atlantis/aws/latest).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Anton Bobenko在GitHub上的`terraform-aws-modules`项目中创建的Terraform模块。以下是该模块的Terraform注册表链接：[https://registry.terraform.io/modules/terraform-aws-modules/atlantis/aws/latest](https://registry.terraform.io/modules/terraform-aws-modules/atlantis/aws/latest)。
- en: You can use this module in two ways. First, which is natural, is using it in
    your existing Terraform code to deploy it in AWS. The second, which we will use
    for this demonstration, is using the module as a standalone project. The module
    will also create a new **Virtual Private Cloud** (**VPC**) for you in the **eu-west**
    AWS zone and Atlantis will be running inside the AWS ECS service. This will generate
    some infrastructure costs.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式使用这个模块。第一种方式是最常见的，将其用于你现有的Terraform代码中，将其部署到AWS。第二种方式是我们在这个演示中将要使用的，即将这个模块作为独立项目来使用。该模块还会在**eu-west**
    AWS区域为你创建一个新的**虚拟私有云**（**VPC**），Atlantis将在AWS ECS服务中运行。这将产生一些基础设施费用。
- en: 'To do so, we need to clone the GitHub repository:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要克隆GitHub仓库：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we will have to create a Terraform variables file. We have some boilerplate
    in the repository in the `terraform.tfvars.sample` file. Let’s copy it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个Terraform变量文件。我们在`terraform.tfvars.sample`文件中有一些模板代码。让我们复制它：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Before proceeding, make sure you’ve created a GitHub repository that will hold
    all your Terraform code. We will be creating a Webhook for this repository when
    Atlantis is deployed, but you will need to add it to the `terraform.tfvars` file
    before applying it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，确保你已经创建了一个GitHub仓库来存放所有的Terraform代码。我们将在部署Atlantis时为这个仓库创建一个Webhook，但你需要在应用之前将它添加到`terraform.tfvars`文件中。
- en: 'Let’s take a look at the variables in the `terraform.tfvars` file we will be
    able to change:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下在`terraform.tfvars`文件中可以更改的变量：
- en: '[PRE33]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`atlantis_repo_allowlist` is the first one you would need to update to match
    the repositories you’d like Atlantis to be able to use. Make sure it’s pointing
    to your repository. `route53_zone_name` should be changed as well to something
    similar, such as `automation.yourorganisation.tld`. Note that it needs to be a
    public domain – GitHub will use it to send webhooks over to Atlantis to trigger
    builds. You will need to create the **Route53** hosted DNS zone in your Terraform
    code or use the web console.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`atlantis_repo_allowlist`是你需要更新的第一个变量，它指定了Atlantis能够使用的仓库。确保它指向你的仓库。`route53_zone_name`也应更改为类似的内容，如`automation.yourorganisation.tld`。请注意，它需要是一个公共域名—GitHub将使用它来发送Webhook到Atlantis以触发构建。你需要在Terraform代码中创建**Route53**托管DNS区域，或者使用Web控制台。'
- en: 'Two more variables you will need to update are `atlantis_github_user` and `atlantis_github_user_token`.
    The first one is self-explanatory, but for the second, you will need to visit
    the GitHub website and generate your **personal access token** (**PAT**). This
    will allow Atlantis to access the repository you want to use. To do that, you
    will need to follow the guidelines on the GitHub documentation pages: [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要更新另外两个变量，分别是`atlantis_github_user`和`atlantis_github_user_token`。第一个变量不言而喻，第二个变量，你需要访问GitHub网站并生成你的**个人访问令牌**（**PAT**）。这将允许Atlantis访问你想使用的仓库。为此，你需要按照GitHub文档页面上的指南操作：[https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token)。
- en: 'After updating the `terraform.tfvars` file, we’re ready to run `terraform init`
    and `terraform plan`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`terraform.tfvars`文件后，我们准备运行`terraform init`和`terraform plan`：
- en: '[PRE34]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Terraform has created a lock file called `.terraform.lock.hcl` to record the
    provider selections it made. Include this file in your version control repository
    so that Terraform will make the same selections by default when you run `terraform
    init` in the future.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform已经创建了一个名为`.terraform.lock.hcl`的锁文件，用于记录它所做的提供者选择。将此文件包含在你的版本控制仓库中，这样下次运行`terraform
    init`时，Terraform会默认做出相同的选择。
- en: 'Now, we can run the following `terraform` `plan` command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行以下的`terraform` `plan`命令：
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you see a similar output, you can apply it. The module will also return a
    lot of information about the created resources. It’s worth paying attention to
    them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到类似的输出，你可以应用它。该模块还会返回关于已创建资源的大量信息，值得关注。
- en: 'After running `terraform apply` (it will take a couple of minutes), you will
    see an output similar to the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`terraform apply`之后（这会花费几分钟），你将看到类似下面的输出：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If you’ve done everything correctly, you should be able to access the Atlantis
    website under the [atlantis.automation.yourorganisation.tld](http://atlantis.automation.yourorganisation.tld)
    domain we created previously. The module added all the necessary records to the
    Route53 zone for us.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一切操作正确，你应该能够访问我们之前创建的[atlantis.automation.yourorganisation.tld](http://atlantis.automation.yourorganisation.tld)域名下的Atlantis网站。该模块已将所有必要的记录添加到Route53区域。
- en: 'If everything has gone well up to this point, when you visit [https://atlantis.automation.yourorganisation.tld](https://atlantis.automation.yourorganisation.tld),
    you will see the following Atlantis panel:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止一切顺利，当你访问[https://atlantis.automation.yourorganisation.tld](https://atlantis.automation.yourorganisation.tld)时，你将看到以下Atlantis面板：
- en: '![Figure 13.1 – Atlantis website after successfully deploying it using the
    Terraform module](img/B18197_13_01.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 使用Terraform模块成功部署后的Atlantis网站](img/B18197_13_01.jpg)'
- en: Figure 13.1 – Atlantis website after successfully deploying it using the Terraform
    module
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 使用Terraform模块成功部署后的Atlantis网站
- en: 'The `webhook_secret` output that’s marked as sensitive in the preceding output
    will be used to set up a webhook on the GitHub repository side. To view it, you
    will need to run the following command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述输出中标记为敏感的`webhook_secret`输出将用于在GitHub仓库端设置Webhook。要查看它，你需要运行以下命令：
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We can also automate it with Terraform by using the module available in the
    same repository as the Atlantis one.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过Terraform自动化这一过程，使用与Atlantis同一仓库中提供的模块。
- en: 'Here’s the full URL to the module: [https://github.com/terraform-aws-modules/terraform-aws-atlantis/tree/master/examples/github-repository-webhook](https://github.com/terraform-aws-modules/terraform-aws-atlantis/tree/master/examples/github-repository-webhook).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模块的完整URL：[https://github.com/terraform-aws-modules/terraform-aws-atlantis/tree/master/examples/github-repository-webhook](https://github.com/terraform-aws-modules/terraform-aws-atlantis/tree/master/examples/github-repository-webhook)。
- en: 'Alternatively, you can create a webhook manually for testing by going to the
    GitHub website and following the documentation: [https://docs.github.com/en/webhooks-and-events/webhooks/creating-webhooks](https://docs.github.com/en/webhooks-and-events/webhooks/creating-webhooks).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过访问GitHub网站并按照文档创建Webhook来手动进行测试：[https://docs.github.com/en/webhooks-and-events/webhooks/creating-webhooks](https://docs.github.com/en/webhooks-and-events/webhooks/creating-webhooks)。
- en: Remember to use the secret generated automatically by Terraform in the output
    variable – that is, `webhook_secret`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 记得使用Terraform自动生成的机密，该机密位于输出变量中——即`webhook_secret`。
- en: 'Creating webhook documentation is also well described in the Atlantis documentation:
    [https://www.runatlantis.io/docs/configuring-webhooks.xhtml#github-github-enterprise](https://www.runatlantis.io/docs/configuring-webhooks.xhtml#github-github-enterprise).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Webhook的文档在Atlantis文档中也有很好的描述：[https://www.runatlantis.io/docs/configuring-webhooks.xhtml#github-github-enterprise](https://www.runatlantis.io/docs/configuring-webhooks.xhtml#github-github-enterprise)。
- en: 'You may encounter that Atlantis won’t come up as expected and you will see
    an `HTTP 500 error` issue when accessing the web panel. To track down any issues
    with this service, such as Atlantis is still unavailable or responding with errors
    to the GitHub webhook, you can go to the AWS console and find the ECS service.
    From there, you should see a cluster named **atlantis**. If you click on it, you’ll
    see the configuration and status of the cluster, as shown in the following figure:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到Atlantis没有按预期启动，并且在访问网页面板时看到`HTTP 500 error`错误。为了排查与该服务相关的问题，例如Atlantis仍然不可用或对GitHub
    webhook响应错误，你可以进入AWS控制台，找到ECS服务。在这里，你应该能看到一个名为**atlantis**的集群。如果点击它，你将看到集群的配置和状态，如下图所示：
- en: '![Figure 13.2 – Amazon Elastic Container Service (ECS) Atlantis cluster information](img/B18197_13_02.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图13.2 – Amazon Elastic Container Service (ECS) Atlantis集群信息](img/B18197_13_02.jpg)'
- en: Figure 13.2 – Amazon Elastic Container Service (ECS) Atlantis cluster information
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.2 – Amazon Elastic Container Service (ECS) Atlantis集群信息
- en: 'If you go to the **Tasks** tab (visible in the preceding screenshot) and click
    on the task ID (for example, **8ecf5f9ced3246e5b2bf16d7485e981c**), you will see
    the following information:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进入**任务**标签页（如前述截图所示），并点击任务ID（例如，**8ecf5f9ced3246e5b2bf16d7485e981c**），你将看到以下信息：
- en: '![Figure 13.3 – Details of the task inside the Atlantis ECS cluster](img/B18197_13_03.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图13.3 – Atlantis ECS集群内任务的详细信息](img/B18197_13_03.jpg)'
- en: Figure 13.3 – Details of the task inside the Atlantis ECS cluster
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.3 – Atlantis ECS集群内任务的详细信息
- en: The **Logs** tab will show you all recent events.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志**标签页将显示所有最近的事件。'
- en: 'You can view more detailed log information in the **CloudWatch** service when
    you go to the **Logs** | **Log groups** section and find the **atlantis** log
    group. Inside, you will be able to see log streams containing all the logs from
    your task. If you already have multiple streams, it’s possible to quickly track
    down the correct stream by its **Task ID**:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**CloudWatch**服务中查看更详细的日志信息，进入**日志** | **日志组**部分并找到**atlantis**日志组。在这里，你可以看到包含任务所有日志的日志流。如果已经有多个日志流，你可以通过**任务ID**快速跟踪正确的日志流：
- en: '![Figure 13.4 – CloudWatch log streams containing logs from ECS tasks running
    Atlantis](img/B18197_13_04.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 包含运行Atlantis的ECS任务日志流的CloudWatch日志](img/B18197_13_04.jpg)'
- en: Figure 13.4 – CloudWatch log streams containing logs from ECS tasks running
    Atlantis
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 包含运行Atlantis的ECS任务日志流的CloudWatch日志
- en: If everything has worked fine so far, we’re ready to test whether Atlantis can
    run `terraform plan` and `terraform apply`. Let’s get back to our code.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果到目前为止一切正常，我们准备测试Atlantis是否能运行`terraform plan`和`terraform apply`。让我们回到代码中。
- en: Running Terraform using Atlantis
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Atlantis 运行 Terraform
- en: 'To execute `terraform plan`, we will have to create a new `main.tf` file will
    look like this:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行 `terraform plan`，我们需要创建一个新的 `main.tf` 文件，内容如下：
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code configures the AWS provider to use the region specified inside
    the `region` variable.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码配置了 AWS 提供程序，以使用 `region` 变量中指定的区域。
- en: This Terraform code block configures a required Terraform version and where
    the Terraform state file is located. In this example, we’re using local storage,
    but in a production environment, we should use a remote state location.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Terraform 代码块配置了所需的 Terraform 版本以及 Terraform 状态文件的位置。在这个示例中，我们使用的是本地存储，但在生产环境中，我们应该使用远程状态位置。
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding block defines an S3 bucket where we intend to store a Terraform
    state. It is a private S3 bucket with enabled versioning. This is the recommended
    setup for storing state files.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块定义了一个 S3 桶，用于存储 Terraform 状态。它是一个启用了版本控制的私有 S3 桶。这是存储状态文件的推荐设置。
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The preceding code also configures **server-side encryption** (**SSE**) for
    the S3 bucket.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码还为 S3 桶配置了**服务器端加密**（**SSE**）。
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding code block defines a DynamoDB table that’s used for Terraform
    state locking. The `variables.tf` file will only contain one variable:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块定义了一个 DynamoDB 表，用于 Terraform 状态锁定。`variables.tf` 文件将只包含一个变量：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After adding these files to Git and committing the changes and creating a new
    pull request on GitHub, you will be able to ask Atlantis to run a plan and apply
    for you. If you run a plan, Atlantis will lock the module you’ve modified and
    no one else will be able to apply any changes to it unless you unlock or apply
    your changes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在将这些文件添加到 Git 并提交更改后，创建一个新的 GitHub 拉取请求，你将能够请求 Atlantis 为你运行计划并应用更改。如果你运行计划，Atlantis
    将锁定你修改的模块，其他人将无法对其应用任何更改，除非你解锁或应用自己的更改。
- en: 'To trigger a plan for your new pull request, just add a comment to your pull
    request stating `atlantis plan`. After a while, depending on how big the module
    is, you will get a plan output similar to what’s shown in the following screenshot:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要为你的新拉取请求触发计划，只需在拉取请求中添加评论，内容为 `atlantis plan`。稍后，根据模块的大小，你将得到类似下面屏幕截图中的计划输出：
- en: '![Figure 13.5 – Interaction with Atlantis on GitHub](img/B18197_13_05.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.5 – 在 GitHub 上与 Atlantis 的交互](img/B18197_13_05.jpg)'
- en: Figure 13.5 – Interaction with Atlantis on GitHub
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 – 在 GitHub 上与 Atlantis 的交互
- en: At the time of writing, Atlantis doesn’t support automatically applying the
    changes. However, it’s possible to automate at the CI level. For example, when
    using GitHub, you could create a GitHub Action that would, after a successful
    test, add the `atlantis apply` comment, which would trigger Atlantis to apply
    changes and report back with the status.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Atlantis 不支持自动应用更改。然而，可以在 CI 级别实现自动化。例如，使用 GitHub 时，可以创建一个 GitHub Action，在测试成功后，添加
    `atlantis apply` 评论，触发 Atlantis 应用更改并返回状态。
- en: At this point, we can give developers the power to modify our infrastructure
    without directly allowing them to run Terraform on their local machines. At the
    same time, we’re removing the possibility of applying changes by many users at
    the same time, which, without a distributed locking mechanism, can be very destructive.
    Furthermore, working with Terraform will be easier as no one will have to install
    it on local machines, no one will have to have direct access to our AWS account,
    and we will gain more visibility of changes to our infrastructure.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 到这时，我们可以赋予开发人员修改基础设施的权限，而不需要直接允许他们在本地机器上运行 Terraform。同时，我们也消除了多个用户同时应用更改的可能性，未使用分布式锁机制时，这种做法可能会非常破坏性。此外，使用
    Terraform 将变得更加简单，因为不需要在本地机器上安装它，也不需要直接访问我们的 AWS 账户，我们将获得对基础设施更改的更多可视性。
- en: Building CI/CD with Terraform still has a long way to go. IaC is still behind
    testing features available in other programming languages, but many developers
    are working on it. We’re looking forward to making testing infrastructure easier
    for everybody.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 构建 CI/CD 仍然任重道远。基础设施即代码（IaC）在测试功能方面仍然落后于其他编程语言，但许多开发人员正在为此努力。我们期待着让每个人都能更轻松地测试基础设施。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the benefits of using Terraform for IaC and discussed
    the importance of incorporating CI/CD processes in Terraform workflows. We covered
    testing infrastructure and various tools for automating deployment.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们探讨了使用 Terraform 进行基础设施即代码（IaC）的好处，并讨论了在 Terraform 工作流中纳入 CI/CD 流程的重要性。我们涵盖了基础设施测试以及各种自动化部署的工具。
- en: In the final section, we explained how to deploy Atlantis, an open source tool
    for automated Terraform pull request previews, to AWS and configure GitHub to
    trigger `terraform plan` and `terraform apply`. With Atlantis, Terraform users
    can collaborate on infrastructure changes through GitHub pull requests, allowing
    for infrastructure changes to be reviewed and approved before they are applied
    to production. By incorporating Atlantis into your Terraform workflow, you can
    improve collaboration, reduce errors, and achieve faster and more secure infrastructure
    changes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们解释了如何将Atlantis（一个用于自动化Terraform拉取请求预览的开源工具）部署到AWS，并配置GitHub以触发`terraform
    plan`和`terraform apply`。通过Atlantis，Terraform用户可以通过GitHub拉取请求协作进行基础设施变更，使得在将变更应用到生产环境之前可以进行审核和批准。通过将Atlantis融入Terraform工作流，你可以改善协作，减少错误，并实现更快速、更安全的基础设施变更。
- en: In the final chapter, we will slow down a little and talk about DevOps misconceptions
    and antipatterns, and how to avoid them.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们将放慢节奏，讨论DevOps的误解和反模式，以及如何避免它们。
- en: Exercises
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try out the following exercises to test your knowledge of this chapter:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习来测试你对本章内容的理解：
- en: Try to deploy Atlantis locally by following the documentation found at [https://www.runatlantis.io/guide/testing-locally.xhtml](https://www.runatlantis.io/guide/testing-locally.xhtml).
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过遵循[https://www.runatlantis.io/guide/testing-locally.xhtml](https://www.runatlantis.io/guide/testing-locally.xhtml)上的文档来本地部署Atlantis。
- en: 'Create a repository and configure the webhook and PAT for yourself. Run a plan
    for your new repository (hint: instead of AWS resources, you can use a **null
    resource** for testing).'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个仓库并为自己配置Webhook和PAT。为你的新仓库运行计划（提示：你可以使用**null资源**进行测试，而不是AWS资源）。
- en: Create an account on one of the CD solution websites and try to run a plan using
    this SaaS. There’s usually a free plan for public repositories.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中一个CD解决方案网站上创建一个帐户，尝试使用该SaaS运行计划。通常，公共仓库有免费的计划。
