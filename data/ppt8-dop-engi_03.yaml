- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Puppet Classes, Resource Types, and Providers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 类、资源类型和提供者
- en: This chapter will cover how classes and defined types provide structure and
    a way to group resources, allowing code to be modular and reusable. You will learn
    about the components that make up resources; types, providers, and the attributes
    applied to them. You will be shown how to use Puppet commands to understand the
    current state of the system and by looking at three of the most common resource
    types – packages, files, and services. You will see how to find out the attributes
    that are available to a resource and how to declare a state.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论类和定义类型如何提供结构，并为资源分组提供一种方式，使代码具备模块化和可重用性。你将学习资源的组成部分；类型、提供者以及应用于它们的属性。你将看到如何使用
    Puppet 命令了解系统的当前状态，并通过查看三种最常见的资源类型——包、文件和服务，了解如何查找资源可用的属性以及如何声明状态。
- en: Using these three resource types, you will see how a simple installation of
    a package, configuration file, and service can be quickly used to start up an
    application with Puppet code, such as Apache or Grafana. The other core resource
    types will then be discussed, highlighting the best practices and approaches.
    A number of metaparameters (attributes that can be applied to any resource) will
    be discussed, along with some advanced patterns for resource declaration.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三种资源类型，你将看到如何通过 Puppet 代码快速启动一个应用程序，如 Apache 或 Grafana，这包括简单的包安装、配置文件和服务。接下来将讨论其他核心资源类型，并强调最佳实践和方法。还会讨论一些元参数（可以应用于任何资源的属性），以及资源声明的一些高级模式。
- en: You will then come across some anti-patterns, which, although still documented
    Puppet language features, are not recommended for use. This will help you understand
    any legacy code you may encounter and consider where code needs to be refactored.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将遇到一些反模式，虽然这些仍然是已记录的 Puppet 语言特性，但不推荐使用。了解这些有助于你理解可能遇到的遗留代码，并考虑需要重构的代码部分。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要内容：
- en: Classes and defined types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和定义类型
- en: Resources, types, and providers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源、类型和提供者
- en: Core resource types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心资源类型
- en: Metaparameters and advanced features
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元参数和高级功能
- en: Anti-patterns
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反模式
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Provision a standard sized Puppet server with a Windows client and a Linux
    client by downloading the `params.json` file from [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch03](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch03)
    using the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过下载 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch03](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch03)
    中的 `params.json` 文件，使用以下命令来配置一个标准大小的 Puppet 服务器，配有 Windows 客户端和 Linux 客户端：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Classes and defined types
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和定义类型
- en: 'As discussed in [*Chapter 1*](B18492_01.xhtml#_idTextAnchor018), Puppet code
    is stored in manifest files ending with `.pp` . It is possible to just write resources
    into a single manifest file and then, using the `apply` command, `puppet apply
    example.pp`, enforce the code locally. It can also be done without the manifest
    file using the `execute` flag with the Puppet code in the field of the command,
    such as `puppet apply -e ''Package { ''``vscode'': }''`.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '如在[*第1章*](B18492_01.xhtml#_idTextAnchor018)中讨论的那样，Puppet 代码存储在以 `.pp` 结尾的清单文件中。可以将资源写入一个单独的清单文件，然后使用
    `apply` 命令 `puppet apply example.pp` 在本地强制执行代码。也可以不使用清单文件，直接在命令行中使用 `execute`
    标志执行 Puppet 代码，例如 `puppet apply -e ''Package { ''``vscode'': }''`。'
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`puppet apply` can also be run against a directory of manifests and it will
    parse every file in order, descending a directory structure. In [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272),
    node definitions will allow us to utilize this.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`puppet apply` 也可以针对一个清单目录运行，它会按照顺序解析每个文件，并遍历目录结构。在[*第11章*](B18492_11.xhtml#_idTextAnchor272)中，节点定义将帮助我们利用这一点。'
- en: 'While both of these approaches are useful for testing and learning purposes,
    they have a clear limitation in terms of lacking any structure, which will result
    in both having to run a lot of large static commands or files and having no way
    to pass data. **Classes** are named sections of code that provide this structure,
    offering a way of grouping resources together and assigning data, which we can
    apply to servers. A class definition goes into a manifest file and within the
    class definition, we put our resource definitions. The syntax is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两种方法对于测试和学习很有用，但它们在缺乏任何结构方面有明显的局限性，这将导致必须运行许多大型静态命令或文件，并且无法传递数据。**类**是命名的代码块，它们提供了这种结构，提供了一种将资源分组并分配数据的方式，我们可以将其应用到服务器上。类定义放入清单文件中，在类定义内部，我们放置我们的资源定义。语法如下：
- en: The `class` keyword.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class` 关键字。'
- en: The name of the class.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的名称。
- en: Optional parameters within `( )`.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`( )` 中的可选参数。'
- en: 'Puppet code with `{}`:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有 `{}` 的 Puppet 代码：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`class` parameters allow classes to be supplied with external data. For example,
    a class might have a resource that installs a package, and a parameter can be
    used to specify the version of that package to be installed.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`class` 参数允许为类提供外部数据。例如，一个类可能有一个安装包的资源，参数可以用来指定要安装的包的版本。'
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An optional `inherit` keyword can be added to a class to allow class inheritance,
    whereby you can create a general base class and then extend it in an inheriting
    class or classes. This pattern is no longer used and is no longer discussed in
    the Puppet documentation as of Puppet 6, beyond saying it exists as a keyword.
    There are better ways to achieve this behavior using data, which we will cover
    in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以向类中添加一个可选的 `inherit` 关键字，以允许类继承，通过这种方式，您可以创建一个通用的基类，然后在继承的类中扩展它。从 Puppet 6
    开始，这种模式不再使用，并且在 Puppet 文档中也不再讨论，除了提到它作为一个关键字存在。通过数据，有更好的方法来实现这种行为，我们将在 [*第 9 章*](B18492_09.xhtml#_idTextAnchor233)
    中介绍。
- en: A common early source of confusion with classes is that this structure only
    defines a class; it does not declare it to be included in the catalog compiled
    from the Puppet code. This contrasts with the resource statement in manifests,
    which by being written and then applied are added to the catalog.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 早期对于类的常见困惑是，这个结构仅定义了一个类；它并没有声明该类会被包含在从 Puppet 代码编译的目录中。这与清单中的资源声明不同，后者通过编写并应用后，会被添加到目录中。
- en: This means running `puppet apply` on a manifest containing a class will do nothing.
    To add the classes to a catalog, we must declare the class using the `include`
    function, make a class resource declaration, or we must use an **External Node
    Classifier** (**ENC**). ENCs will be covered in [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272),
    but for now, they can be understood as Puppet server scripts that identify the
    classes to be included in a node.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在包含类的清单上运行 `puppet apply` 什么也不会做。要将类添加到目录中，我们必须使用 `include` 函数声明该类，进行类资源声明，或者我们必须使用**外部节点分类器**（**ENC**）。ENC
    将在 [*第 11 章*](B18492_11.xhtml#_idTextAnchor272) 中介绍，但现在可以理解为 Puppet 服务器脚本，用于标识要包含在节点中的类。
- en: Including a class
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含一个类
- en: The `include` function is the simplest way to add classes via the declaration
    in the code block of a class in a manifest file of `include class_name`. It can
    be used multiple times across multiple classes and will result in only one entry.
    To declare a class with `puppet apply` directly, we can instead run `puppet apply
    –e "include class_name"`, which will test a manifest file with a class. Following
    the module structure, this would apply the manifest from the `class_name/manifest/init.pp`
    path.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`include` 函数是通过在清单文件的类代码块中声明 `include class_name` 来添加类的最简单方法。它可以在多个类中多次使用，并且只会产生一个条目。要直接通过
    `puppet apply` 声明一个类，我们可以运行 `puppet apply –e "include class_name"`，这将测试一个带有类的清单文件。遵循模块结构，这将应用来自
    `class_name/manifest/init.pp` 路径的清单。'
- en: The class resource declaration
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类资源声明
- en: 'In the next section, resource declaration will be covered in more detail, but
    declaring a class such as a resource allows us to pass in the attributes we have
    defined or looked up. It looks like this, but can only be used once in a catalog:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，将更详细地介绍资源声明，但声明像资源一样的类使我们能够传递我们定义或查找的属性。它看起来是这样的，但只能在一个目录中使用一次：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Defined types
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义类型
- en: A defined type is a block of Puppet code, which, in contrast to a class, can
    be declared multiple times in a catalog by passing in parameters and a unique
    name. Like a class, it is by best practice defined in a manifest file by itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类型是一个Puppet代码块，与类不同，它可以在清单中多次声明，通过传递参数和唯一名称。像类一样，最佳实践是将其定义在单独的清单文件中。
- en: 'The syntax is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 语法如下：
- en: Starts with a `define` keyword
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `define` 关键字开头
- en: The type name
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型名称
- en: Open brackets (`(`)
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开括号（`(`）
- en: List of parameters
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数列表
- en: Open braces (`{`)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开括号（`{`）
- en: The resource body
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源体
- en: Close braces (`}`)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭括号（`}`）
- en: 'In addition to the parameter list defined, the `$title` and `$name` variables
    are available to be used within the definition. This ensures the resources we
    declare are unique. A very simple example could take a name and a group and ensure
    a user and a group are created and a file is placed in the `user` home directory
    owned by the user and group we have created:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义的参数列表外，`$title` 和 `$name` 变量也可以在定义中使用。这确保了我们声明的资源是唯一的。一个非常简单的示例可能是通过名称和组来确保创建一个用户和一个组，并将文件放置在我们创建的用户和组拥有的`user`主目录中：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Defined types are the same as classes; applying the manifest file will not
    produce anything. A defined type resource declaration must be made in a class,
    which can then be included:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类型与类相同；应用清单文件不会产生任何效果。定义类型的资源声明必须在类中进行，然后可以包含在类中：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This example has its dangers since if the second declaration for `user2` also
    used a group of `group1`, this would result in a duplicated resource declaration.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例有一定的危险性，因为如果第二个 `user2` 的声明也使用了 `group1` 组，这将导致资源声明重复。
- en: Namespaces
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'Namespaces are segments that identify the directory and file structure for
    classes in manifest files. These namespaces are separated with two colons (`::`),
    so, for example, the following directories would translate as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间是标识清单文件中类的目录和文件结构的片段。这些命名空间由两个冒号（`::`）分隔，例如，以下目录将转换如下：
- en: '| **File** **path name** | **Namespace** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| **文件** **路径名称** | **命名空间** |'
- en: '| /manifests/base.pp | base |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| /manifests/base.pp | base |'
- en: '| /manifests/windows/grafana.pp | windows::grafana |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| /manifests/windows/grafana.pp | windows::grafana |'
- en: '| /manifests/linux/apache.pp | linux::apache |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| /manifests/linux/apache.pp | linux::apache |'
- en: '| /manifests/linux/ubuntu/landscape.pp | linux::ubuntu::landscape |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| /manifests/linux/ubuntu/landscape.pp | linux::ubuntu::landscape |'
- en: Table 3.1 – Namespace directory translation
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – 命名空间目录转换
- en: If we wanted only to apply the `windows::grafana` class, we could therefore
    run `puppet apply –e "include windows::grafana"` from within the `manifest` directory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想应用 `windows::grafana` 类，我们可以在 `manifest` 目录中运行 `puppet apply –e "include
    windows::grafana"`。
- en: There is no limit to the depth a namespace can have, but the best practice would
    be to stick to a couple of levels.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的深度没有限制，但最佳实践是保持在几级以内。
- en: In [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212), we will see modules that
    have namespaces where the module name is the root level for all classes except
    one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中，我们将看到具有命名空间的模块，其中模块名称是所有类的根级别，只有一个类除外。
- en: Resources, types, and providers
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源、类型和提供者
- en: Resources are the fundamental basic unit of the Puppet language; every stateful
    item we wish to describe is a resource. Resources must be unique in terms of what
    they manage since Puppet has no way of managing or prioritizing conflict between
    resources. It will simply call out that a clash exists and fail to compile a catalog.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 资源是Puppet语言的基本单位；我们希望描述的每个有状态项都是一个资源。资源在它们管理的内容上必须是唯一的，因为Puppet无法管理或优先处理资源之间的冲突。它只是会报告冲突存在，并且无法编译清单。
- en: 'Each resource will have a type, which is a description of what we are configuring,
    such as a file or a registry setting; parameters, which are variables containing
    the settings we can customize for the resource; and a provider, which is the underlying
    implementation allowing Puppet to be OS independent. This provider is often a
    default based on the OS but can be added as an attribute if required. So, a resource
    declaration has the following syntax:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源都会有一个类型，这是我们正在配置的描述，比如文件或注册表设置；参数，是包含我们可以自定义的设置的变量；以及提供者，是允许Puppet实现操作系统独立性的底层实现。这个提供者通常是基于操作系统的默认值，但如果需要，可以作为属性添加。因此，资源声明具有以下语法：
- en: Opens with the type name, such as `file`, with no quotes and in lowercase
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以类型名称开头，例如 `file`，不带引号且小写
- en: A curly brace (`{`)
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大括号（`{`）
- en: The title of the resource in quotes
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源标题应加引号
- en: A colon (`:`)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冒号（`:`）
- en: A list of attribute names and the value of that named attribute with `=>` between,
    ending with a comma (`,`)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性名称的列表以及该名称属性的值，二者之间用`=>`连接，最后以逗号（`,`）结尾
- en: A closing curly brace (`}`)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个闭合的大括号（`}`）
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Everything between the two curly braces is known as the **resource body**. It
    is possible to have multiple bodies in a single resource declaration, essentially
    declaring multiple resources of the same type, but for clarity, I would generally
    advise against this.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号之间的所有内容被称为**资源体**。在一个资源声明中可以有多个资源体，实际上是声明多个相同类型的资源，但为了清晰起见，我通常建议不要这样做。
- en: 'As pseudocode, this syntax looks like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 作为伪代码，语法看起来如下所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here’s a real example of ensuring a package named `vscode` is at the latest
    version on the system:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个实际示例，确保系统上的`vscode`包是最新版本：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What was given in the syntax list for both the resource and class declarations/definitions
    was the minimum required, while the code examples were spaced and broken over
    several lines for stylistic reasons and following best practices. It is possible
    to write declarations and definitions as a single line but Puppet has developed
    a style guide – [https://www.puppet.com/docs/puppet/8/style_guide.html](https://www.puppet.com/docs/puppet/8/style_guide.html)
    – that we will use throughout this book, along with other opinionated best practices
    to create readable, maintainable, and simple code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 语法列表中给出的资源和类声明/定义是最小要求，而代码示例则根据风格和最佳实践的考虑，进行了换行和空格的处理。虽然可以将声明和定义写成单行，但Puppet开发了一个风格指南——[https://www.puppet.com/docs/puppet/8/style_guide.html](https://www.puppet.com/docs/puppet/8/style_guide.html)，我们将在本书中遵循该指南，并结合其他一些具有明确意见的最佳实践，编写可读、可维护且简洁的代码。
- en: 'Here are some examples of the style guide being applied in the code examples:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些在代码示例中应用风格指南的例子：
- en: Use a two-space indent
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个空格缩进
- en: No trailing whitespace
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要有尾随空格
- en: Attribute names should align
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性名称应对齐
- en: Attribute `=>` symbols should align
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性`=>`符号应对齐
- en: Attribute values should align
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性值应对齐
- en: Include trailing commas after all attributes
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有属性后包含尾随逗号
- en: Although there are no limits or syntactical meanings for whitespace, the Puppet
    language style guide’s recommendations aim to make the code more readable and
    consistent. The style guide states all attributes should have trailing commas;
    this ensures adding a new attribute will only show a single change in a Git diff,
    but you may find some code follows a pattern of having no comma on the last attribute,
    which would make it clear it was the last element. This will pass linting checks
    but may cause issues for not meeting Puppet style guides if you wish to get code
    approved by Puppet for module use.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然空白符号没有限制或语法意义，但Puppet语言风格指南的建议旨在使代码更具可读性和一致性。风格指南指出，所有属性应有尾随逗号；这可以确保添加新属性时只会在
    Git diff 中显示一个更改，但你可能会发现某些代码遵循没有尾随逗号的模式，以便清楚地表示这是最后一个元素。这样做会通过 lint 检查，但如果希望代码获得Puppet模块使用批准，则可能会因不符合Puppet风格指南而遇到问题。
- en: 'As there are a number of syntactic and stylistic rules, the best way to learn
    is to use style guide linting, made available via the Ruby gem, `puppet-lint`,
    with syntax validation made available via the `puppet parser validate` command.
    The Puppet extension on Visual Studio Code has these commands integrated into
    its checks, so it highlights syntax and lint issues as you edit. In the screenshot
    in *Figure 3**.1*, the warning output of the lab is visible with some stylistic
    and syntactical errors:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在许多语法和风格规则，学习的最佳方式是使用风格指南 lint 检查，通过 Ruby gem `puppet-lint` 提供，语法验证通过 `puppet
    parser validate` 命令提供。Visual Studio Code 上的 Puppet 扩展集成了这些命令，因此在编辑时会突出显示语法和 lint
    问题。在*图 3.1*的截图中，可以看到实验室的警告输出，其中包含一些风格和语法错误：
- en: '![Figure 3.1 – Visual Studio Code showing syntax and lint issues](img/Figure_03.01.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – Visual Studio Code 显示语法和 lint 问题](img/Figure_03.01.jpg)'
- en: Figure 3.1 – Visual Studio Code showing syntax and lint issues
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – Visual Studio Code 显示语法和 lint 问题
- en: Similar effects can be achieved in `vim` using [https://github.com/rodjek/vim-puppet](https://github.com/rodjek/vim-puppet).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[https://github.com/rodjek/vim-puppet](https://github.com/rodjek/vim-puppet)可以在`vim`中实现类似效果。
- en: Important note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Throughout this book, advice will be given on best practices and approaches
    to coding, with a lot of this advice taken from sources such as the Puppet style
    guide. One of the best things an organization can do to develop clear and consistent
    Puppet code is to write its own best practices and style guidelines, building
    on top of the foundation provided by the Puppet style guide and ensuring it is
    followed when reviewing code. This can equally disagree with points raised in
    the style guide or this book, as long as it is best for your organization and
    developers and it is agreed to.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中将提供有关最佳实践和编码方法的建议，很多建议来自于 Puppet 风格指南等来源。一个组织在开发清晰一致的 Puppet 代码时可以做的最好的一件事，就是编写自己的最佳实践和风格指南，基于
    Puppet 风格指南提供的基础，确保在代码审查时遵循该指南。这也可以与风格指南或本书中的某些观点不一致，只要这对你的组织和开发人员最有利并达成共识。
- en: Resources of each type must be uniquely `ntp`, but not two service type resources
    both titled `ntp`. There are no other limitations on how they are named in terms
    of characters or spacing, but for performance purposes, titles should be kept
    short and never be longer than 140 characters. This **title** is what identifies
    the resource to Puppet itself when it generates a catalog.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的资源必须唯一，`ntp` 资源不可重复命名为两个服务类型资源名为 `ntp`。在命名时，在字符或空格方面没有其他限制，但出于性能考虑，标题应该保持简短，并且永远不超过
    140 个字符。这个 **标题** 是 Puppet 在生成目录时识别资源的依据。
- en: The `namevar` attribute (also known as the `namevar` by default is the same
    as the title unless attributes are assigned. In some cases, types will use multiple
    attributes to define `namevar`, such as a package using the command and name together.
    This is used in cases where multiple copies of the same configuration can be installed
    via different mechanisms, such as installing a package of the same name as a Ruby
    gem and as a **Red Hat Package** **Manager** (**RPM**).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`namevar` 属性（也被称为 `namevar`，默认情况下与标题相同，除非分配了其他属性）。在某些情况下，类型将使用多个属性来定义 `namevar`，例如一个包同时使用命令和名称。这在通过不同机制安装相同配置的多个副本时使用，比如安装与
    Ruby gem 同名的包，以及作为 **Red Hat 包管理器** (**RPM**) 安装的包。'
- en: 'Installing the Apache package can demonstrate the difference between `namevar`
    and `apache_package` name variable is set based on the operating system. For Fedora,
    the package name will be `httpd`, while for all other operating systems, it will
    be `apache2`. This means our title for this package resource is `apache`, and
    when referring to this resource in Puppet code, we can always refer to it as the
    `apache` resource package, while the target system will refer to it by the appropriate
    package name, ensuring it is a uniquely managed installation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Apache 包可以演示 `namevar` 与 `apache_package` 名称变量的区别，名称变量基于操作系统设置。对于 Fedora，包名将是
    `httpd`，而对于其他所有操作系统，包名将是 `apache2`。这意味着我们这个包资源的标题是 `apache`，在 Puppet 代码中引用该资源时，我们可以始终将其称为
    `apache` 资源包，而目标系统将通过适当的包名来引用它，确保它是一个唯一管理的安装：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Let us now move on to some practical examples.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续一些实际的例子。
- en: Lab
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验
- en: To practice what has been learned so far, look at the file at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/lint_and_validate.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/lint_and_validate.pp)
    and try to correct the errors highlighted in VS Code. Alternatively, use the `puppet-lint
    -f` (`-f` automatically fixes issues where possible) and `puppet parser validate`
    commands from the VS Code integrated terminal or a separate terminal session.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实践目前所学的内容，请查看 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/lint_and_validate.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/lint_and_validate.pp)
    文件，并尝试在 VS Code 中修正高亮显示的错误。或者，使用 `puppet-lint -f`（`-f` 会自动修复可能的问题）和 `puppet parser
    validate` 命令，这些命令可以在 VS Code 集成终端或单独的终端会话中执行。
- en: '[https://validate.puppet.com/](https://validate.puppet.com/) can also be used
    to do validation checks online.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://validate.puppet.com/](https://validate.puppet.com/) 也可以用来进行在线验证检查。'
- en: Examining the current system state
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查当前系统状态
- en: 'This chapter so far has discussed how resources should be structured and styled
    and, with all these rules, it can be intimidating when starting to write your
    own resources. The `puppet resource` command allows us to produce Puppet code
    from the state of a current machine; this command is supplied parameters of a
    type and a `namevar` variable. To give an example, looking at the directory on
    which a Windows desktop puppet has been installed would produce something like
    the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章讨论了资源的结构和样式，以及在所有这些规则的影响下，开始编写自己的资源可能会让人感到有些不知所措。`puppet resource` 命令允许我们从当前机器的状态生成
    Puppet 代码；该命令接受类型和 `namevar` 变量的参数。例如，查看已安装 Puppet 的 Windows 桌面上的目录会生成类似以下内容的输出：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: From this example, it should be noted that certain attributes are returned only
    for the information we refer to as properties and cannot be managed by Puppet,
    such as `mtime` and `ctime`. Other attributes such as `provider` do not need to
    be declared, as `windows` would be the presumed provider on a Windows machine.
    Apart from this, with minor adjustments, this output can just be directly put
    into Puppet manifests and run. (Later in this chapter, we will show you how to
    review type attributes.)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以注意到，某些属性仅在我们称之为属性的信息中返回，且不能由 Puppet 管理，如 `mtime` 和 `ctime`。其他属性，例如 `provider`，无需声明，因为在
    Windows 机器上，`windows` 会被假定为提供者。除此之外，经过一些小的调整，这个输出可以直接放入 Puppet 清单并运行。（本章后续内容中，我们将展示如何查看类型属性。）
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Visual Studio Code allows you to run Puppet commands via the command palette
    (*Ctrl* + *Shift* + *P*, or for Mac, *Command* + *Shift* + *P*). Type `puppet
    resource`, then the resource type, and optionally name `var`. It will then paste
    the output into your open file.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 允许你通过命令面板运行 Puppet 命令（*Ctrl* + *Shift* + *P*，Mac 上为 *Command*
    + *Shift* + *P*）。输入 `puppet resource`，然后输入资源类型，最后可选地输入 `var` 名称。随后，它会将输出粘贴到你打开的文件中。
- en: In the previous example, we ran `puppet resource` against a single `namevar`
    attribute. For certain types, you can discover what the state of every resource
    of that type would be on a machine, such as running `puppet resource package`
    for packages. This clearly will not work for the likes of files, as recursively
    going through every file on a host would produce too much information, but you
    can quickly produce information on your host’s setup.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的例子中，我们对单个 `namevar` 属性运行了 `puppet resource`。对于某些类型，你可以发现该类型在机器上每个资源的状态，比如运行
    `puppet resource package` 查看软件包的状态。这显然无法用于文件类型，因为递归遍历主机上的每个文件会生成过多的信息，但你可以快速生成主机设置的信息。
- en: In VSCode, try opening a new file, running the command palette with `puppet
    resource`, and just entering `package`. This will list all the packages recognized
    by Puppet and available Puppet providers. An example of this output is available
    at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/puppet_resource_package.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/puppet_resource_package.pp).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VSCode 中，尝试打开一个新文件，使用 `puppet resource` 运行命令面板，输入 `package`。这将列出 Puppet 识别的所有包和可用的
    Puppet 提供者。该输出的示例如可通过 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/puppet_resource_package.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/puppet_resource_package.pp)
    查看。
- en: Introducing types with the package, file, and service pattern
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入使用包、文件和服务模式的类型
- en: Having discussed the structure and style of declaring resources, the next step
    is to introduce the core types available to Puppet and how you can discover the
    attributes and features of a type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了声明资源的结构和样式之后，下一步是介绍 Puppet 可用的核心类型，以及如何发现类型的属性和功能。
- en: The core types are documented online at [https://www.puppet.com/docs/puppet/8/type.html#puppet-core-types](https://www.puppet.com/docs/puppet/8/type.html#puppet-core-types)
    and can be viewed on the command line with the `puppet describe` Puppet command.
    Using `puppet describe --list` will list all the types available in your environment;
    you can then review a type by passing the type name, for example, `puppet describe
    package`. This documentation is also visible in VS Code when you hover the mouse
    pointer over the types and attribute names in a resource declaration.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 核心类型的文档在线提供，地址为 [https://www.puppet.com/docs/puppet/8/type.html#puppet-core-types](https://www.puppet.com/docs/puppet/8/type.html#puppet-core-types)，并可以通过
    `puppet describe` Puppet 命令在命令行中查看。使用 `puppet describe --list` 会列出你环境中所有可用的类型；然后你可以通过传递类型名称来查看某一类型，例如
    `puppet describe package`。当你将鼠标悬停在资源声明中的类型和属性名称上时，这些文档在 VS Code 中也可以看到。
- en: Starting with the combination of package, file, and service types, you will
    be able to install, configure, and start an application.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从软件包、文件和服务类型的组合开始，你将能够安装、配置并启动应用程序。
- en: The package type
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件包类型
- en: Running `puppet describe package` or viewing the web contents at [https://www.puppet.com/docs/puppet/8/types/package.html](https://www.puppet.com/docs/puppet/8/types/package.html),
    we can view the description of what the type is for and a list of attributes and
    available providers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`puppet describe package`或访问[https://www.puppet.com/docs/puppet/8/types/package.html](https://www.puppet.com/docs/puppet/8/types/package.html)，我们可以查看该类型的描述及其属性列表和可用的提供者。
- en: 'A package used at its simplest level can just be declared as a package resource
    with a title:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包在最简单的层面上可以仅作为一个具有标题的软件包资源声明：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This sets several attributes to defaults, resulting in using the default provider
    for the underlying operating system, such as `yum` for Red Hat or, for Windows,
    the Windows provider, which handles `.exe` and `.msi` files. It will also install
    at the latest package version available but, when enforced, will only ensure the
    package is installed and not maintain it at the latest version.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将多个属性设置为默认值，从而使用底层操作系统的默认提供者，例如Red Hat的`yum`，或Windows的Windows提供者，它处理`.exe`和`.msi`文件。它还将安装最新的可用软件包版本，但在强制执行时，只会确保软件包已安装，而不会维持在最新版本。
- en: This versioning behavior is controlled by the `ensure` parameter and the example
    defaulted to a value of `present`, which can also be declared as `installed`.
    The `latest` value, just as it sounds, ensures the package is at the latest version
    available to the provider. For more flexible versioning, it is possible to set
    a value as a string version, such as `1.2.3`, and, depending on the support of
    the provider, to use ranges, such as `> 1.0.0 < 2.0.0`. Using the value of `absent`
    is an important part of Puppet, where resources don’t just ensure what is present
    in the server state but also what should not be there.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本控制行为由`ensure`参数控制，示例默认值为`present`，也可以声明为`installed`。`latest`值，顾名思义，确保软件包处于提供者可用的最新版本。对于更灵活的版本控制，可以将值设置为字符串版本，如`1.2.3`，并且根据提供者的支持，可以使用版本范围，如`>
    1.0.0 < 2.0.0`。使用`absent`值是Puppet的重要部分，在这里，资源不仅确保服务器状态中存在的内容，还包括不应存在的内容。
- en: Related to using the `absent` value for `ensure` is the `purged` value, which
    is a provider-dependent option. If set to `true`, it removes configuration files
    on the removal of packages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与在`ensure`中使用`absent`值相关的是`purged`值，这是一个依赖于提供者的选项。如果设置为`true`，则在删除软件包时会移除配置文件。
- en: The `providers` attribute is often left as the default, but if it is required
    to be installed via another package management system such as `pip` or `rubygems`,
    can be assigned an appropriate provider’s name as its value.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`providers`属性通常保留默认设置，但如果需要通过其他软件包管理系统（如`pip`或`rubygems`）安装，可以将其值设置为适当的提供者名称。'
- en: 'To see what providers can be used, the `-p` flag can be used on the `describe`
    command: `puppet describe` `package -p`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的提供者，可以在`describe`命令中使用`-p`标志：`puppet describe package -p`。
- en: Taking the example of Windows, it is important to note that it tells us the
    Windows provider is the default provider and it lists the supported features,
    which are attributes that will work with this provider. This difference in attributes
    reflects the different underlying commands used by the provider.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以Windows为例，需要注意的是，它告诉我们Windows提供者是默认提供者，并列出了支持的特性，这些特性是与此提供者兼容的属性。这些属性的差异反映了该提供者使用的不同底层命令。
- en: The `source` attribute is a URL to the package file; this allows for remote
    calls to web sources such as JFrog Artifactory or locally downloaded files and
    is a required parameter for certain providers, such as Windows, which requires
    a location of the `.bin` or `.``exe` file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`属性是指向软件包文件的URL；这允许通过远程调用Web源（如JFrog Artifactory）或本地下载的文件，并且是某些提供者的必需参数，例如Windows，它需要`.bin`或`.exe`文件的位置。'
- en: The `command` attribute, new since Puppet 6, allows you to select which command
    the provider should run. This is necessary for situations where you have multiple
    versions of an installer command available on a machine.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`command`属性，自Puppet 6版本以来新增，允许你选择提供者应运行的命令。这在机器上有多个安装命令版本时是必要的。'
- en: The `name` attribute, which should be the name of the package, will be set as
    the title by default and combined with the command attribute; since Puppet 6,
    this is what makes the `namevar` attribute for a package. In Puppet 5, the provider
    attribute is used instead of the command attribute.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`name` 属性，应该是软件包的名称，默认会将其设置为标题并与命令属性结合；自 Puppet 6 起，这就是使软件包拥有 `namevar` 属性的原因。在
    Puppet 5 中，使用 `provider` 属性而不是命令属性。'
- en: Note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, it may be necessary due to dependency issues to run install commands
    such as `yum` with multiple packages in a single command. There isn’t a way to
    do this under the package type; the best approach would be to use an `exec` type,
    which we will talk about later in this chapter.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，由于依赖关系问题，可能需要在单个命令中运行多个软件包的安装命令，如 `yum`。在软件包类型下没有办法做到这一点；最佳做法是使用 `exec` 类型，我们将在本章稍后讨论。
- en: So, as an exercise, write a manifest for the following; create a new file for
    each platform example, `package_rhel8.pp`, in `vscode` or a terminal.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，作为练习，编写以下内容的清单；为每个平台示例创建一个新文件 `package_rhel8.pp`，可以使用 `vscode` 或终端。
- en: 'On RHEL 8, do the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RHEL 8 上，执行以下操作：
- en: Install `rubygem activerecord` so that it is greater than version 7
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 `rubygem activerecord`，确保其版本大于 7
- en: Install the latest `cowsay` from `yum`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `yum` 安装最新的 `cowsay`
- en: Ensure the `pinball` package is absent from the system in a resource titled
    `no games`
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 `pinball` 包在名为 `no games` 的资源中从系统中删除
- en: View the suggested solution at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/package_rhel8_answer.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/package_rhel8_answer.pp).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 查看建议的解决方案 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/package_rhel8_answer.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/package_rhel8_answer.pp)。
- en: 'On Windows Server, do the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows Server 上，执行以下操作：
- en: Install `ruby` and `devkit` from the `.exe` file already downloaded to `c:\tmp\rubyinstaller-devket-3.1.1-1-x64.exe`
    with the `/VERYSILENT` install option
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从已下载的 `.exe` 文件 `c:\tmp\rubyinstaller-devket-3.1.1-1-x64.exe` 安装 `ruby` 和 `devkit`，并使用
    `/VERYSILENT` 安装选项
- en: Install `rubygem activerecord` so that it is greater than version 7 but less
    than 9
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 `rubygem activerecord`，确保其版本大于 7 但小于 9
- en: Ensure the `pinball` package is installed at version `2005-xp` in a resource
    titled `fun games`
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保 `pinball` 包在名为 `fun games` 的资源中安装，并且版本为 `2005-xp`
- en: View the suggested solution at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/package_windows_answer.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/package_windows_answer.pp).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 查看建议的解决方案 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/package_windows_answer.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/package_windows_answer.pp)。
- en: Note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more advanced Windows package management, it is worth looking at Chocolatey,
    which will be covered in [*Chapter* *8*](B18492_08.xhtml#_idTextAnchor212) ([https://forge.puppet.com/puppetlabs/chocolatey](https://forge.puppet.com/puppetlabs/chocolatey)).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的 Windows 包管理，值得研究 Chocolatey，本章将介绍它，[*第 8 章*](B18492_08.xhtml#_idTextAnchor212)（[https://forge.puppet.com/puppetlabs/chocolatey](https://forge.puppet.com/puppetlabs/chocolatey)）。
- en: The file type
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件类型
- en: Having installed packages, it is then common to add application configuration
    files and directories to contain them. The file type is ideal for creating files
    and making directory structures. It can handle the content, ownership, and permissions
    of files, links, and directories.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完软件包后，通常会添加应用程序配置文件和目录来容纳它们。文件类型非常适合创建文件并构建目录结构。它可以处理文件、链接和目录的内容、所有权和权限。
- en: 'The simplest declaration of a file type is the title as a fully declared path:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 文件类型的最简单声明是将标题作为完全声明的路径：
- en: '[PRE10]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Looking at the file type via `puppet describe file`, in this case, there are
    only two **providers** – a Windows file or a POSIX file, which will match whichever
    operating system family you are configuring.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `puppet describe file` 查看文件类型，在这种情况下，只有两个 **providers**——Windows 文件或 POSIX
    文件，这将与您配置的操作系统族匹配。
- en: For the `ensure` attribute, there are `present` and `absent` options. Selecting
    `present` will default to the file value, ensuring the created resource is a normal
    file but only enforcing that the file path exists regardless of whether it is
    a symbolic link, a file, or a directory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `ensure` 属性，有 `present` 和 `absent` 选项。选择 `present` 将默认使用文件值，确保创建的资源是一个普通文件，但仅强制文件路径存在，无论它是符号链接、文件还是目录。
- en: To create and enforce a resource, we must select the value of a file and use
    `direct` to create a directory or directory nest or `link` to create a symbolic
    link.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和强制执行一个资源，我们必须选择一个文件的值，并使用 `direct` 来创建目录或目录嵌套，或使用 `link` 来创建符号链接。
- en: The path is the `namevar` attribute for this type and should be a fully qualified
    path, or it can default from the title.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是此类型的 `namevar` 属性，应为完全限定的路径，或者可以从标题中默认获取。
- en: 'For example, a resource titled `Puppet directory`, which creates `ensure` for
    the existing `directory` at `C:\ProgramData\PuppetLabs`, is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个名为`Puppet directory`的资源，它为位于`C:\ProgramData\PuppetLabs`的现有`directory`创建了`ensure`，如下所示：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For resources we ensure as files, the `content` attribute gives us multiple
    ways of putting content into the file. The simplest version is simply to put a
    string of the text into the file but using the functions, file, and template,
    we can copy the contents of whole files stored in Puppet modules or use templated
    files, allowing us to substitute values into pre-parsed files. These functions
    will be covered in detail in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194) and
    [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们确保作为文件的资源，`content`属性为我们提供了多种将内容写入文件的方法。最简单的方式是直接将文本字符串放入文件中，但通过使用函数、文件和模板，我们可以复制存储在Puppet模块中的整个文件的内容，或使用模板文件，允许我们将值替换到预先解析的文件中。这些功能将在[*第7章*](B18492_07.xhtml#_idTextAnchor194)和[*第8章*](B18492_08.xhtml#_idTextAnchor212)中详细介绍。
- en: 'Three attributes are then used to manage ownership and permissions: `user`,
    `group`, and `mode`. For `user` and `group`, this is as simple as entering the
    UID and GID or the username and group name. If this is not set, this will default
    to the user and group Puppet is running under. `mode` deals with permissions using
    the Unix 4-digit-style permissions mode, but for Windows systems, entering this
    gives a very rough and limited translation and it is better to leave `mode` undeclared
    and supplement files with the ACL module: [https://forge.puppetlabs.com/puppetlabs/acl](https://forge.puppetlabs.com/puppetlabs/acl).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用三个属性来管理所有权和权限：`user`、`group` 和 `mode`。对于 `user` 和 `group`，这很简单，只需输入 UID
    和 GID 或用户名和组名。如果未设置，这将默认为 Puppet 正在运行的用户和组。`mode` 使用 Unix 风格的 4 位权限模式来处理权限，但对于
    Windows 系统，输入的模式会有一个非常粗略的转换，最好不要声明 `mode`，而是使用 ACL 模块来补充文件：[https://forge.puppetlabs.com/puppetlabs/acl](https://forge.puppetlabs.com/puppetlabs/acl)。
- en: 'To give an example of the attributes we have covered, the following declaration
    creates a file called `config.test` with both `owner` and `group` set and the
    content of two lines of text:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，以下声明创建了一个名为`config.test`的文件，设置了`owner`和`group`，并包含两行文本内容：
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `recurse` parameter allows recursive management of the contents of a directory.
    If set to `true` when ensuring a directory and using `source`, it will copy the
    directory contents recursively. It is important to note Puppet is not a file synchronization
    tool, so do not put too many files under Puppet management, or files that are
    too big. There is no specific number documented, but a common recommendation is
    10 or fewer files in a recursive file resource and no greater than 25 MB. This
    is due to the comparative nature of Puppet, which uses `md5` checksums for content,
    which are expensive to run over large-sized files or large numbers of files.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`recurse`参数允许递归管理目录的内容。当确保目录并使用`source`时，如果设置为`true`，它将递归复制目录内容。需要注意的是，Puppet
    不是文件同步工具，因此不要将过多的文件或过大的文件纳入 Puppet 管理。没有具体的文档限制，但常见的建议是递归文件资源中的文件数不超过10个，且大小不超过25
    MB。这是因为 Puppet 使用 `md5` 校验和来检查内容，而对大文件或大量文件执行此操作的开销较大。'
- en: Information
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In the case of large numbers of files and directory structure, the module archive
    – [https://forge.puppet.com/modules/puppet/archive](https://forge.puppet.com/modules/puppet/archive)
    – can be used to download and extract it into place. Alternatively, when auditing
    and versioning files, it is better to build a package and manage it with the package
    resource we spoke of previously.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件数量和目录结构较大的情况下，可以使用模块归档 – [https://forge.puppet.com/modules/puppet/archive](https://forge.puppet.com/modules/puppet/archive)
    – 来下载并解压到指定位置。或者，在审计和版本管理文件时，最好构建一个包并使用我们之前提到的包资源来进行管理。
- en: Several parameters can provide protection with `recurse` using `max_files`,
    which can warn or error if a command is going to go over a certain limit. `recurselimit`
    can be used to limit how many levels of recursion will be performed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`recurse`时，多个参数可以提供保护，包括`max_files`，当命令超出某个限制时，它可以发出警告或错误。`recurselimit`可以用于限制递归执行的层数。
- en: There are only two scenarios in which it is advised to use this parameter –
    when you have a small number of files and the content of the files should be enforced,
    or when also using the `purge` parameter, which, when set to `true`, will ensure
    no files outside of Puppet’s control will remain in the directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两种情况建议使用此参数——当你有少量文件，并且文件内容应该被强制执行，或者在同时使用`purge`参数时，当其设置为`true`时，它将确保目录中没有Puppet控制之外的文件。
- en: Note
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will review data types and variables in detail in the next chapter, but for
    now, note a parameter that takes `true` or `false` can take a value without quotes,
    and that is the style this book will use.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章详细讨论数据类型和变量，但目前请注意，取值为`true`或`false`的参数可以不带引号，这也是本书采用的风格。
- en: 'The `purge` parameter can only be used with `ensure` set to `directory` and
    `recursive` set to `true` and provides a powerful way to ensure the directory
    only contains files under Puppet management, removing any other files it finds.
    In the following, we give an example of recursion, ensuring the `/etc/httpd/conf`
    directory only contains files under Puppet’s control:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`purge`参数只能与`ensure`设置为`directory`且`recursive`设置为`true`时使用，它提供了一种强大的方法来确保目录中仅包含Puppet管理下的文件，删除它找到的其他文件。在以下示例中，我们演示了递归，确保`/etc/httpd/conf`目录中只包含Puppet控制下的文件：'
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is a `recursive_file_permissions` module ([https://forge.puppet.com/modules/npwalker/recursive_file_permissions](https://forge.puppet.com/modules/npwalker/recursive_file_permissions)),
    which can assist in managing recursive permissions over a large number of files
    in a performant way. This can be combined with the `archive` module we previously
    mentioned.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个`recursive_file_permissions`模块（[https://forge.puppet.com/modules/npwalker/recursive_file_permissions](https://forge.puppet.com/modules/npwalker/recursive_file_permissions)），它可以帮助高效地管理大量文件的递归权限。可以将其与我们之前提到的`archive`模块结合使用。
- en: The `validate_cmd` parameters can be particularly useful with configuration
    files, where there is a known way to check the file we are putting in place. If
    the validation command fails, the old file will be left in place, preventing issues.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`validate_cmd`参数在配置文件中尤其有用，特别是当有已知方法检查我们放置的文件时。如果验证命令失败，旧文件将保留在原处，避免问题发生。'
- en: 'The `target` parameter is required if ensuring a link. By combining it with
    the `path` value, we get a symlink, as demonstrated in the following code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确保创建链接，则`target`参数是必需的。将其与`path`值结合使用时，我们可以得到一个符号链接，如下代码所示：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `source` parameter can be of several types: URIs, local files, NFS shares,
    or web or Puppet modules. This can also be presented as an array to provide multiple
    choices depending on the hostname or operating system, where it would use the
    first file it could find. In the following code block, we show an example, where
    `host` would be substituted with the applicable hostname and `operatingsystem`
    with the locally installed operating system:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`参数可以有多种类型：URI、本地文件、NFS共享，或者是Web或Puppet模块。也可以将其作为数组来提供多个选择，具体取决于主机名或操作系统，此时它会使用它能找到的第一个文件。在以下代码块中，我们展示了一个示例，其中`host`将替换为适用的主机名，`operatingsystem`替换为本地安装的操作系统：'
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, on a Windows server called `server1`, applying this resource
    declaration would look on `nfsserver` under the `exampleapp` share to find the
    first match, looking for `conf.server1`, then `conf.windows` if it could not find
    it, and finally `conf`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，在名为`server1`的Windows服务器上，应用此资源声明将会在`nfsserver`的`exampleapp`共享下查找第一个匹配项，首先寻找`conf.server1`，如果找不到，再查找`conf.windows`，最后查找`conf`。
- en: The `backup` parameter is not recommended, as managing and scaling file buckets
    to store these backups proves difficult, and as we will see in [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272),
    there are better approaches we can consider, managing our code in Git to allow
    for back-out scenarios.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 不推荐使用`backup`参数，因为管理和扩展文件桶以存储这些备份是困难的，正如我们在[*第11章*](B18492_11.xhtml#_idTextAnchor272)中看到的，还有更好的方法可以考虑，例如在Git中管理我们的代码，以便应对回退场景。
- en: The `replace` parameter should be used sparingly, but if set to `true`, allows
    for a file to have content enforced only if it does not exist. If the file exists,
    the state is met. This can be useful for applications that require an initial
    configuration file but then overwrite it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace` 参数应谨慎使用，但如果设置为 `true`，则仅在文件不存在时强制执行内容。如果文件已存在，则状态已满足。这对于需要初始配置文件但随后会覆盖它的应用程序非常有用。'
- en: 'Having discussed a lot of attributes, try practicing constructing examples
    by writing a manifest file to meet the requirements listed:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论了许多属性后，尝试通过编写清单文件来满足列出的要求，以实践构造示例：
- en: On a Unix-based system, ensure only Puppet-controlled files are in the `/``etc/sudoers.d`
    directory.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于 Unix 的系统中，确保 `/etc/sudoers.d` 目录中仅包含 Puppet 控制的文件。
- en: 'Add a `/etc/sudoers.d/mongodb` file with `robin All=(ALL) NOPASSWD: su – mongo`
    content and a validation command, `visudo -c`, owned by `root`, a group of `root`,
    and permission `0660`.'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '添加一个 `/etc/sudoers.d/mongodb` 文件，内容为 `robin All=(ALL) NOPASSWD: su – mongo`，并使用验证命令
    `visudo -c`，文件归 `root` 用户所有，属于 `root` 组，权限设置为 `0660`。'
- en: Create a symlink from `/``opt/mongodb/mongos /home/robin/mongos`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个符号链接，从 `/opt/mongodb/mongos` 到 `/home/robin/mongos`。
- en: View the suggested solution at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/file_unix_answer.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/file_unix_answer.pp).
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看建议的解决方案：[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/file_unix_answer.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/file_unix_answer.pp)。
- en: 'For Windows, see the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows，请参阅以下内容：
- en: On a Windows-based system, ensure only Puppet-controlled files are in the `c:`
    `\inetpub\wwwroot` directory but subdirectories are untouched.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在基于 Windows 的系统中，确保 `c:\inetpub\wwwroot` 目录中仅包含 Puppet 控制的文件，但子目录不受影响。
- en: Add a `c:\inetpub\wwwroot\page with source nfsshare1:\\publish\page.html` and
    a validation command `c:\program` `files\httpvalidator\httpvlidate.exe` file.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `c:\inetpub\wwwroot\page`，内容为 `nfsshare1:\\publish\page.html`，并使用验证命令 `c:\program
    files\httpvalidator\httpvlidate.exe` 文件。
- en: Create a symlink from `c:\program files\httpvalidator\httpvlidate.exe C:\Users\david\Desktop`
    and use the `replace` option to replace the file if it exists.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个符号链接，从 `c:\program files\httpvalidator\httpvlidate.exe` 到 `C:\Users\david\Desktop`，并使用
    `replace` 选项在文件存在时替换它。
- en: View the suggested solution at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/file_windows_answer.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/file_windows_answer.pp).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看建议的解决方案：[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/file_windows_answer.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/file_windows_answer.pp)。
- en: Service types
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务类型
- en: Having installed software and created configuration files, the next common step
    is to start services with the service type. Since system services can vary widely
    in terms of what they support and provide, we must be careful to provide all the
    necessary parameters. Some services lack proper status commands but can be provided
    via the parameters of service.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 安装软件并创建配置文件后，下一步通常是启动具有服务类型的服务。由于系统服务在支持和提供内容上差异很大，我们必须小心提供所有必要的参数。一些服务缺乏正确的状态命令，但可以通过服务的参数提供。
- en: Running and reviewing the output of `puppet describe service -p`, you will see
    various providers, although in most cases, the default service provider is what
    will be required. On certain occasions, such as legacy software on a modern Red
    Hat system only providing `init` scripts, we may expect to select a different
    provider.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行并查看 `puppet describe service -p` 的输出，你将看到各种提供程序，尽管在大多数情况下，默认的服务提供程序是所需的。在某些情况下，如现代
    Red Hat 系统上仅提供 `init` 脚本的旧版软件，我们可能需要选择不同的提供程序。
- en: The first two parameters to consider are `enable` and `ensure`. `ensure` accepts
    the values `stopped` or `running`, which can also be represented as `false` or
    `true`, respectively. This is a simple binary of whether the service should be
    running or not. `enable` defines in the service whether it should start on boot
    and is only provided by certain providers. This can be `true` or `false` to be
    enabled or disabled, and then there are several provider-dependent options; for
    example, on Windows, `false` means the service is disabled and cannot be started,
    and `manual` means the service is set to a manual startup type, which doesn’t
    start with Windows but does allow the service to be started manually. `true` is
    an automatic startup type and `delayed` means the service is set to the automatic
    (*delayed*) startup type, which starts the service a couple of minutes after Windows
    has started up.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的前两个参数是`enable`和`ensure`。`ensure`接受`stopped`或`running`的值，也可以分别表示为`false`或`true`。这是一个简单的二进制值，表示服务是否应该运行。`enable`定义了服务是否应在启动时自动启动，这仅由某些提供程序提供。可以设置为`true`或`false`，表示启用或禁用，然后还有一些依赖于提供程序的选项；例如，在Windows上，`false`表示服务被禁用且无法启动，`manual`表示服务设置为手动启动类型，它不会随Windows一起启动，但允许手动启动该服务。`true`表示自动启动类型，`delayed`表示服务被设置为自动（*延迟*）启动类型，它会在Windows启动几分钟后启动服务。
- en: One final parameter to highlight for Windows would be `logonaccount`, which
    specifies an account for the service to run as.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的另一个Windows参数是`logonaccount`，它指定服务运行时使用的账户。
- en: 'To give examples of the attributes we have covered, see the following code
    for a Windows service, `wuauserv`, a running service with a delayed startup service
    and running as the `localsystem` user. The `bam` service is stopped and disabled:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给出我们已覆盖的属性的示例，请查看以下Windows服务代码，`wuauserv`，这是一个具有延迟启动的正在运行的服务，并以`localsystem`用户身份运行。`bam`服务已停止并禁用：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Comparing this to `systemd`, the default provider for RHEL 8 and other Linux
    systems, we can see in the description under supported features that `systemctl`
    does not have delayed login or `manual` but does have `mask`, which, in system
    terms, means it disables the service so not even services that are dependent on
    it can activate it.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与`systemd`（RHEL 8和其他Linux系统的默认提供程序）进行比较，我们可以在受支持功能的描述中看到，`systemctl`没有延迟登录或`manual`，但有`mask`，在系统术语中，意味着它禁用服务，以至于即使是依赖于它的服务也无法激活它。
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Beware that the defaults for `ensure` and `enabled` are entirely dependent on
    the underlying provider implementation.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ensure`和`enabled`的默认值完全依赖于底层提供程序的实现。
- en: In cases where there are no startup scripts provided for an application, combining
    the `start` and `stop` parameters, you can use Puppet to bridge this gap, defining
    which commands start and stop the service in these parameters. The `pattern` parameter
    would by default take the name of the service and look for the name in the process
    table to confirm a running status, or you can supply a regular expression, strings,
    or any permissible Ruby pattern to search the process table. Alternatively, the
    `status` parameter can be used to point at a status script, which should return
    a zero-exit code if the service is running.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有提供启动脚本的应用程序的情况下，结合`start`和`stop`参数，您可以使用Puppet来弥补这一空白，在这些参数中定义启动和停止服务的命令。`pattern`参数默认会使用服务名称，并在进程表中查找该名称以确认运行状态，或者您可以提供正则表达式、字符串或任何允许的Ruby模式来搜索进程表。或者，可以使用`status`参数指向一个状态脚本，如果服务正在运行，该脚本应返回零退出代码。
- en: 'The following shows an example of a legacy service with scripts for starting,
    stopping, and checking the status of the server pulled together in this service
    resource:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个遗留服务，其中包含启动、停止和检查服务器状态的脚本，这些脚本被整合在这个服务资源中：
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It can be seen based on the nature of implementation that a careful parameter
    choice must be made and that this varies by scenario. Later in this chapter, we
    will show methods for how to cover these differences while declaring resources
    using a splat (`*`).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 根据实现的性质可以看出，必须仔细选择参数，并且这会根据场景的不同而有所变化。本章稍后将展示如何在声明资源时使用星号（`*`）来覆盖这些差异的方法。
- en: Running Puppet locally with multiple resources
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用多个资源本地运行Puppet
- en: In [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212) and [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252),
    we will cover using Puppet agents and classification to apply Puppet code, but
    to test the code developed just now, as mentioned at the start of the chapter,
    `puppet apply` can be used to run code locally. In our labs, we will use Bolt
    to automatically copy our manifest files to our remote labs and run `puppet apply`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18492_08.xhtml#_idTextAnchor212)和[*第10章*](B18492_10.xhtml#_idTextAnchor252)中，我们将讨论如何使用
    Puppet 代理和分类来应用 Puppet 代码，但为了测试刚刚开发的代码，正如本章开始时所提到的，可以使用 `puppet apply` 在本地运行代码。在我们的实验室中，我们将使用
    Bolt 自动将我们的清单文件复制到远程实验室，并运行 `puppet apply`。
- en: Note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: An additional way of applying resources is via the `resource` command we reviewed
    earlier. Adding parameters and settings to the command will cause it to be applied
    to the resource. The Puppet service could be enforced as enabled and running with
    the `puppet resource service puppet ensure=running enable=true` command. You will
    often see this command in Puppet knowledge base articles when performing fixes
    to Puppet services since it can usefully start/restart services without having
    to think about which operating system it is running on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 应用资源的另一种方式是通过我们之前回顾过的 `resource` 命令。向命令添加参数和设置会使其应用于资源。可以使用 `puppet resource
    service puppet ensure=running enable=true` 命令强制 Puppet 服务启用并运行。你通常会在 Puppet 知识库文章中看到这个命令，用于修复
    Puppet 服务，因为它可以方便地启动/重启服务，而无需考虑它运行在哪个操作系统上。
- en: Relationships will be covered in detail in [*Chapter 6*](B18492_06.xhtml#_idTextAnchor185),
    but to allow for resources that are dependent on one another, as the package,
    file, and service pattern requires, the basics of the `require`, `before`, `subscribe`,
    and `notify` metaparameters need to be known. `require` and `before` mirror one
    another, creating a relationship between two resources so that when Puppet runs
    one resource, it will run before the other. It is not semantically important which
    way you define the relationship, although it may prove more logical where there
    is a many-to-one relationship to apply the dependency metaparameter to many resources.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 关系将在[*第6章*](B18492_06.xhtml#_idTextAnchor185)中详细讨论，但为了支持彼此依赖的资源，正如包、文件和服务模式所要求的那样，需要了解
    `require`、`before`、`subscribe` 和 `notify` 这些元参数的基础知识。`require` 和 `before` 是镜像关系，它们在两个资源之间创建一个关系，使得当
    Puppet 运行一个资源时，它会先运行另一个资源。定义关系的方向在语义上并不重要，尽管在多对一关系中，将依赖元参数应用于多个资源可能会更加合乎逻辑。
- en: Similarly, the `subscribe` and `notify` metaparameters allow a resource to not
    only have this dependency but also to send refresh events to types that support
    them if the resource state changes (this can be confirmed in the type documentation
    using `puppet describe`). This is particularly useful in service resources where
    updating a configuration file should result in the service restarting.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`subscribe` 和 `notify` 元参数不仅允许一个资源具有依赖关系，还能在资源状态变化时向支持它们的类型发送刷新事件（可以通过 `puppet
    describe` 在类型文档中确认）。这在服务资源中特别有用，因为更新配置文件应导致服务重启。
- en: 'The syntax for these metaparameters is a resource reference, which comprises
    a resource type with a capital letter and a resource name in square brackets.
    To give some examples of this, the following shows examples of `before`, `notify`,
    and `require` being used to make the package, file, and service pattern:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元参数的语法是资源引用，它由一个首字母大写的资源类型和方括号中的资源名称组成。以下是使用 `before`、`notify` 和 `require`
    来使包、文件和服务模式的示例：
- en: '[PRE18]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, `package` is installed first, the configuration file is then
    added, and the service should start. If the configuration file changes state,
    this will cause the service to restart. In the next section, we will talk in more
    detail about resource references.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`package` 首先被安装，然后添加配置文件，最后服务应该启动。如果配置文件发生变化，这将导致服务重启。在接下来的章节中，我们将更详细地讨论资源引用。
- en: 'Shorthand can be used to create an array of the same resource types in a dependency:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用简写方式在依赖关系中创建相同资源类型的数组：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running Puppet will generate reports that describe how resources, if not in
    the desired state, were changed into the correct state and, if the server was
    in the correct state, will produce little output beyond the time it took to run
    checks. The code can also be run in `noop`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Puppet 会生成报告，描述资源如果不处于所需状态，如何被更改为正确状态，并且如果服务器处于正确状态，输出会非常少，仅仅是运行检查所花费的时间。代码也可以在
    `noop` 模式下运行。
- en: Lab
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验
- en: So, use the lab environment to apply some Puppet code to our client servers.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，使用实验室环境将一些 Puppet 代码应用到我们的客户服务器上。
- en: 'For CentOS, we will install `httpd` and serve a web page displaying *Hello
    World*. Create an `apache_linux.pp` file; this will require the `httpd` package
    to be installed and a file to be created at `/var/www/html/index.html` with the
    following content:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 CentOS，我们将安装 `httpd` 并提供一个显示 *Hello World* 的网页。创建一个 `apache_linux.pp` 文件；这将需要安装
    `httpd` 包，并在 `/var/www/html/index.html` 创建一个文件，内容如下：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have a `/etc/httpd/conf/httpd.conf` configuration file with content sourced
    from [https://raw.githubusercontent.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/main/ch03/httpd.conf](https://raw.githubusercontent.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/main/ch03/httpd.conf)
    and validated by running `httpd -t -f` and an `httpd` service, which is enabled
    on boot and running.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `/etc/httpd/conf/httpd.conf` 配置文件，内容来自 [https://raw.githubusercontent.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/main/ch03/httpd.conf](https://raw.githubusercontent.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/main/ch03/httpd.conf)，并通过运行
    `httpd -t -f` 进行验证，以及一个在引导时启用并运行的 `httpd` 服务。
- en: 'For Windows, create a `grafana_windows.pp` file; we will install the Grafana
    server from [https://dl.grafana.com/oss/release/grafana-8.4.3.windows-amd64.msi](https://dl.grafana.com/oss/release/grafana-8.4.3.windows-amd64.msi),
    ensuring the service is running and enabled and, in the `C:\Program Files\GrafanaLabs\grafana\conf\grafana.ini`
    configuration file, ensuring the content contains the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 系统，创建一个 `grafana_windows.pp` 文件；我们将从 [https://dl.grafana.com/oss/release/grafana-8.4.3.windows-amd64.msi](https://dl.grafana.com/oss/release/grafana-8.4.3.windows-amd64.msi)
    安装 Grafana 服务器，并确保服务正在运行和启用，在 `C:\Program Files\GrafanaLabs\grafana\conf\grafana.ini`
    配置文件中，确保内容包含以下内容：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Updating the configuration file should restart the service.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 更新配置文件应重新启动服务。
- en: You can apply the code you have written using Bolt, which will be covered in
    [*Chapter 12*](B18492_12.xhtml#_idTextAnchor293). Using the `bolt apply apache_linux.pp
    –server linuxclient.example.com` or `bolt apply grafana_windows.pp –server windowsclient.example.com`
    command will copy the manifest to the server and run `puppet apply` on the client.
    For both Linux and Windows examples, test your solution by navigating to `http://hostname:8080`
    and confirming **Hello World** for Linux or the Grafana login page for Windows
    is visible.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Bolt 应用您编写的代码，将在 [*第12章*](B18492_12.xhtml#_idTextAnchor293) 中介绍。使用 `bolt
    apply apache_linux.pp –server linuxclient.example.com` 或 `bolt apply grafana_windows.pp
    –server windowsclient.example.com` 命令将清单复制到服务器，并在客户端运行 `puppet apply`。对于 Linux
    和 Windows 的示例，通过访问 `http://hostname:8080` 并确认 Linux 的 **Hello World** 或 Windows
    的 Grafana 登录页面可见来测试您的解决方案。
- en: Example solutions are available at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/apache_linux.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/apache_linux.pp)
    and [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/grafana_windows.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/grafana_windows.pp).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 示例解决方案可在 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/apache_linux.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/apache_linux.pp)
    和 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/grafana_windows.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/grafana_windows.pp)
    找到。
- en: To test the runs in `noop` mode, you can apply the `_noop => true` option to
    the Bolt command.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `noop` 模式下测试运行，可以将 `_noop => true` 选项应用于 Bolt 命令。
- en: While it would be impractical to discuss every core type in detail, the next
    section will cover at a high level the other core types, which are useful for
    creating more advanced configurations.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然详细讨论每个核心类型可能不切实际，但下一节将高层次地介绍其他核心类型，这些类型对于创建更高级的配置非常有用。
- en: Core resource types
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心资源类型
- en: In this section, we will discuss the core resource types.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论核心资源类型。
- en: User and group types
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户和组类型
- en: The user type and group type are core to most configurations, allowing the `ensure`
    attribute to be set to `present` or `absent`. With a Unix platform as the provider,
    the user would normally have a minimum set of attributes of `uid` and `gid`, with
    the group having a minimum of `gid`. The user can be further enforced via the
    `password` attribute, which can ensure the limits for any password set, passing
    an encrypted password and enforcing the home directory and shell. For Windows
    Server, it is important to note only local users and groups can be managed, although
    a group resource can manage adding domain accounts to the membership of that group
    via the `members` parameter. The names are case sensitive in Puppet but case insensitive
    in Windows. The case should match so we do not lose any of the auto requirements
    that are formed. Windows also uses multiple types of names, so it can be `<name
    of computer\<user name>`, `BUILTIN\<username>`, or just `<username>`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 用户类型和组类型是大多数配置的核心，允许将 `ensure` 属性设置为 `present` 或 `absent`。使用 Unix 平台作为提供程序时，用户通常会有最小的
    `uid` 和 `gid` 属性，而组则最少有 `gid` 属性。用户还可以通过 `password` 属性进一步强制执行，确保为任何设置的密码定义限制，传递加密密码并强制执行主目录和
    Shell 设置。对于 Windows Server，需要注意的是，只能管理本地用户和组，尽管一个组资源可以通过 `members` 参数管理将域账户添加到该组的成员中。Puppet
    中的名称是区分大小写的，但在 Windows 中是不区分大小写的。名称应该匹配，以免丢失任何自动生成的需求。Windows 还使用多种类型的名称，因此可以是
    `<计算机名\<用户名>`、`BUILTIN\<用户名>` 或仅仅是 `<用户名>`。
- en: So, for example, `'DESKTOP-1MT10AJ\david, 'BUILTIN\david'` and `david` are all
    treated the same by Puppet.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`'DESKTOP-1MT10AJ\david, 'BUILTIN\david'` 和 `david` 在 Puppet 中都会被视为相同。
- en: 'The following code shows examples in Windows and Unix of an account and a group:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了 Windows 和 Unix 中账户和组的示例：
- en: '[PRE22]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We see here that Windows user David is a member of the administrator’s group
    and user’s group. We see the user’s group and its list of members. We can then
    see the detailed setup of a Ubuntu user on Unix with password settings, a home
    directory, and group settings. Similarly, certain users and groups can be added
    as resource declarations, ensured absent, and removed from the system.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到，Windows 用户 David 是管理员组和用户组的成员。我们看到用户组及其成员列表。接下来，我们可以看到 Unix 上 Ubuntu
    用户的详细设置，包括密码设置、主目录和组设置。同样，某些用户和组可以作为资源声明被添加、确保不存在，并从系统中删除。
- en: The exec type
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`exec` 类型'
- en: The `exec` type is quite different from most Puppet types and can be dangerous
    if not used correctly. While most Puppet types try to describe the state a server
    should be in, `exec` provides a way of running scripts or commands on servers.
    This means declaring an `exec` type takes effort to make sure the resource will
    be `apt-get update` (the command for updating package sources in Ubuntu), if we
    use the `onlyif` attribute, `unless`, or `creates`, or if the `exec` has a refresh-only
    attribute.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec` 类型与大多数 Puppet 类型有所不同，如果使用不当，可能会很危险。虽然大多数 Puppet 类型尝试描述服务器应该处于的状态，但 `exec`
    提供了一种在服务器上运行脚本或命令的方式。这意味着声明一个 `exec` 类型需要特别注意，确保资源会是 `apt-get update`（Ubuntu 中用于更新包源的命令），如果我们使用
    `onlyif` 属性、`unless` 或 `creates`，或者 `exec` 具有仅刷新属性。'
- en: In the first case, if the command is `exec` reporting runs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，如果命令是 `exec` 报告运行。
- en: With the `onlyif` attribute, we can declare a command that if it returns `true`,
    then our `exec` will run. `unless` is the opposite of `onlyif`, using a command
    that if it returns `true`, then our `exec` will not run. Finally, `creates` looks
    for a file to be created to show the script has run.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `onlyif` 属性，我们可以声明一个命令，如果它返回 `true`，则我们的 `exec` 将会执行。`unless` 是 `onlyif`
    的反义词，使用一个命令，如果它返回 `true`，则我们的 `exec` 不会执行。最后，`creates` 会查找一个文件，以表明脚本已经运行。
- en: 'This first example looks at disabling public Chocolatey access unless the command
    finds in the sources that it is already disabled:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例演示了如何禁用公共 Chocolatey 访问，除非命令在源中找到该访问已经被禁用：
- en: '[PRE23]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This second example shows an example command, which generates a file using
    the `cowsay` command unless that file has already been created:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例展示了一个示例命令，除非该文件已经被创建，否则它会使用 `cowsay` 命令生成一个文件：
- en: '[PRE24]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There is an optional PowerShell provider to allow `exec` to run PowerShell
    scripts: [https://forge.puppet.com/puppetlabs/powershell](https://forge.puppet.com/puppetlabs/powershell).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个可选的 PowerShell 提供程序，允许 `exec` 运行 PowerShell 脚本：[https://forge.puppet.com/puppetlabs/powershell](https://forge.puppet.com/puppetlabs/powershell)。
- en: 'The third scenario uses the `refreshonly` attribute, so using the `notify`
    and `subscribe` attributes, we can set the `exec` to only run if another resource
    is refreshed. The following `exec` can be useful when scripts are simply not going
    to be replaced by Puppet code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况使用了 `refreshonly` 属性，因此通过使用 `notify` 和 `subscribe` 属性，我们可以设置 `exec` 仅在另一个资源被刷新时执行。以下的
    `exec` 对于那些脚本无法被 Puppet 代码替代的情况非常有用：
- en: '[PRE25]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This might be the case if the script/command is vendor-provided or simply a
    heritage script that works, and the effort of refactoring it into Puppet code
    would not be worth it.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本/命令是供应商提供的，或者只是一个已经有效的遗留脚本，并且将其重构为 Puppet 代码的工作量不值得，那么就可能出现这种情况。
- en: 'On Unix platforms, a recent feature called parametrized execs was introduced
    with Puppet 6.24+ and 7.9+, allowing you to pass a `command` attribute as an array,
    the first part of the array being the command and the second part being the arguments.
    This uses the secure method of parametrized system calls to ensure code cannot
    be injected. In the following example, a traditional `exec` with just the command
    would run all the commands separated by the semi-colon, in our simple example
    echoing `real parameters` and running `rm`, while with the improvement of parametrized
    execs, it will take the second argument as a string to be passed and echo it,
    ensuring the original purpose of the command and preventing command injection:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 平台上，Puppet 6.24+ 和 7.9+ 引入了一项名为参数化 exec 的新特性，允许你将 `command` 属性作为一个数组传递，数组的第一部分是命令，第二部分是参数。它采用了参数化系统调用的安全方法，确保代码无法被注入。在以下示例中，传统的
    `exec` 只包含命令，它会执行由分号分隔的所有命令，在我们的简单示例中，会回显 `real parameters` 并运行 `rm`，而使用参数化 exec
    的改进方法，它会将第二个参数作为要传递的字符串并回显，确保命令的原始目的并防止命令注入：
- en: '[PRE26]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example using `echo` is obviously simplified and it will become clearer
    where this plays a part when we look at [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212)
    and [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233). There, we will see how user
    data can be fed into Puppet code and that we must code defensively.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个使用 `echo` 的示例显然被简化了，当我们查看 [*第 8 章*](B18492_08.xhtml#_idTextAnchor212) 和 [*第
    9 章*](B18492_09.xhtml#_idTextAnchor233) 时，这一点将变得更加清晰。到时我们将看到如何将用户数据传入 Puppet 代码中，并且我们必须进行防御性编码。
- en: The Augeas type
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Augeas 类型
- en: Augeas is a type only available on Linux; it was used more historically in earlier
    versions of Puppet when the options for manipulating files were much more limited,
    but in more advanced situations, it can have its uses. It can be computationally
    more expensive, so you should be careful in how you use it. Augeas can parse files
    in their native formats into a tree, which you can then manipulate. It uses lenses
    to perform these translations.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Augeas 是一个仅在 Linux 上可用的类型；它在 Puppet 的早期版本中使用得更多，当时用于操作文件的选项非常有限，但在更复杂的情况下，它仍然有其用处。它可能计算开销较大，因此你需要谨慎使用。Augeas
    可以将文件从其本地格式解析成树状结构，然后你可以对其进行操作。它使用 lenses 来执行这些翻译。
- en: 'To give an example, if we want to manipulate the `access.conf` file, we can
    view the file using `augtool` (the CLI interface for Augeas) and print it using
    the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，如果我们想操作 `access.conf` 文件，可以使用 `augtool`（Augeas 的 CLI 接口）查看文件并使用以下命令打印出来：
- en: '[PRE27]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let’s say our file contains the following lines:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的文件包含以下行：
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This would result in the following being printed using the default lens:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认的 lens 时，结果将打印如下：
- en: '[PRE29]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This allows you to make programmatical references to individual sections and
    values in the syntax, so if in the client state, you wanted to remove any entry
    with the user `john` from all entries, `augtool` could run the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你在语法中对单独的部分和数值进行编程引用，因此如果在客户端状态中，你想从所有条目中删除用户 `john` 的任何条目，`augtool` 可以执行以下操作：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To use this in Puppet, Augeas only has one `changes`, which is the Augeas command
    you wish to run, `lens` if you wish to use a different translation from the default,
    and `onlyif`, which can perform a check of the content of the tree to see whether
    the change needs to be run. Creating the previous example as a Puppet resource
    would look like the following:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Puppet 中使用这个，Augeas 只有一个 `changes`，它是你希望运行的 Augeas 命令，`lens` 是你希望使用的非默认翻译，`onlyif`
    可以检查树的内容，判断是否需要执行更改。将前面的示例创建为 Puppet 资源的方式如下：
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Augeas is a powerful tool but should be used sparingly. More details on the
    syntax can be found at [http://augeas.net/docs/](http://augeas.net/docs/) and
    [https://forge.puppet.com/modules/puppetlabs/augeas_core/reference](https://forge.puppet.com/modules/puppetlabs/augeas_core/reference).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Augeas是一个强大的工具，但应谨慎使用。有关语法的更多细节可以在[http://augeas.net/docs/](http://augeas.net/docs/)和[https://forge.puppet.com/modules/puppetlabs/augeas_core/reference](https://forge.puppet.com/modules/puppetlabs/augeas_core/reference)中找到。
- en: The notify type
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`notify`类型'
- en: 'The `notify` type is used to send messages to the logs. This is more likely
    to be used for debugging purposes than production use, as it is not idempotent,
    and it will cause the Puppet report to see changes on every run. Using the `message`
    parameter as a string of what to print will take a default from the title. A simple
    example would be as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`notify`类型用于向日志发送消息。它更可能用于调试目的，而非生产环境使用，因为它不是幂等的，并且每次运行时都会导致Puppet报告看到变化。使用`message`参数作为要打印的字符串时，会默认从标题中获取值。一个简单的示例如下：'
- en: '[PRE32]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `notice` function can be more practical for printing messages, as they will
    not show up in the Puppet report change logs. See [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`notice`函数更适用于打印消息，因为这些消息不会出现在Puppet报告的变更日志中。请参见[*第5章*](B18492_05.xhtml#_idTextAnchor123)。'
- en: There are more core types, but the commands demonstrated in this chapter to
    list types available, view the attribute, and provide documentation should give
    you the ability to understand how to go on and investigate other types that you
    may find useful, including types installed from `puppet forge`, which will be
    covered in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的核心类型，但本章演示的命令能够列出可用的类型、查看属性并提供文档，这些应该能帮助你理解如何进一步调查其他可能有用的类型，包括从`puppet
    forge`安装的类型，相关内容将在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中详细介绍。
- en: Information
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Throughout this chapter, we have highlighted resources coming under Puppet’s
    control by being added to the catalog, whether they enforce presence or absence.
    Puppet has no concept of back-out, so removing a resource from Puppet’s control
    will just leave it unmanaged as it was set in the last Puppet run. This should
    therefore always be considered in your back-out process for a code change.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经强调了通过添加到目录下，Puppet控制下的资源，无论它们是强制存在还是缺失。Puppet没有回滚的概念，因此从Puppet控制中删除一个资源将仅仅使其变为未管理状态，保持在上一次Puppet运行时的状态。因此，在代码更改的回退过程中，应该始终考虑这一点。
- en: Metaparameters and advanced resources
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元参数和高级资源
- en: 'This section will start by looking at metaparameters, which are attributes
    that work on any resource type. For the lab work, we covered `before`, `required`,
    `notify`, and `subscribe`, which were used to create dependencies between resources.
    To follow this, there are several other useful attributes with a range of effects
    on resources. To see the full documentation of metaparameters on types and providers,
    the `meta` flag can be added to the `describe` command: `puppet describe <file`
    `type> --meta`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将首先介绍元参数，它们是适用于任何资源类型的属性。对于实验部分，我们涵盖了`before`、`required`、`notify`和`subscribe`，这些用于在资源之间创建依赖关系。接下来，还有几个其他有用的属性，具有不同的效果。要查看类型和提供者上元参数的完整文档，可以在`describe`命令中添加`meta`标志：`puppet
    describe <file` `type> --meta`。
- en: audit
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审计
- en: 'The `audit` metaparameter allows us to monitor unmanaged Puppet parameters;
    this could either be an array list of attributes or all for monitoring all undeclared
    attributes. In the following example, we declare this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`audit`元参数允许我们监视未管理的Puppet参数；这可以是一个属性的数组列表，也可以是监视所有未声明属性的`all`。在以下示例中，我们声明了这一点：'
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This creates a `/opt/puppetlabs/puppet/cache/state/state.yaml` file on Puppet
    Enterprise or `/var/lib/puppet/state/state.yaml` in the open source version of
    Puppet, which records the audit state. Applying the preceding resource would produce
    the following output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在Puppet Enterprise中创建一个`/opt/puppetlabs/puppet/cache/state/state.yaml`文件，或者在Puppet的开源版本中创建`/var/lib/puppet/state/state.yaml`文件，用于记录审计状态。应用前述资源将产生以下输出：
- en: '[PRE34]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As the resource was created, its state will be recorded as changing from `absent`
    to `present`, and it will then be reported whether the previously recorded value
    was found to have changed on Puppet runs. The `state.yaml` file would update to
    this new value, so it’s important to take action on this change if it is required.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当资源被创建时，它的状态将被记录为从`absent`（缺失）变化为`present`（存在），然后将报告在Puppet运行时是否发现先前记录的值已发生变化。`state.yaml`文件将更新为这个新值，因此如果需要，必须对这一变化采取相应的措施。
- en: tag
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: 'The `tag` parameter allows us to apply tags to our resource, which can be a
    single string or multiple tags with an array of strings. By default, several tags
    are applied to a resource: the title, resource type, and the class the resource
    is contained in. Tags are particularly useful in scenarios where we only want
    to run parts of our manifests since both Puppet local and agent-based runs can
    take a `--tag` flag to run only resources with a particular tag.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag`参数允许我们为资源应用标签，这些标签可以是单个字符串，也可以是多个字符串组成的数组。默认情况下，多个标签会应用于资源：标题、资源类型和资源所在的类。标签在只希望运行清单的某些部分时特别有用，因为Puppet的本地运行和基于代理的运行都可以使用`--tag`标志，只运行具有特定标签的资源。'
- en: 'For example, let’s look at the Puppet resources in a manifest called `example.pp`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，来看一下名为`example.pp`的Puppet资源清单：
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The group will have the `group`, `ubuntu`, `pci`, and `sox` tags while the user
    will have the `user`, `ubuntu`, and `pci` tags. Additionally, both would have
    a tag of the class name, `example::access`. With the `puppet apply` `--tags` `pci
    example.pp` command, both resources would be applied similarly; `ubuntu` would
    apply both while running with a tag of `sox` would just run the group.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 该组将有`group`、`ubuntu`、`pci`和`sox`标签，而用户将有`user`、`ubuntu`和`pci`标签。此外，两者还将有一个类名标签，`example::access`。使用`puppet
    apply` `--tags` `pci example.pp`命令时，两个资源都会类似地应用；`ubuntu`标签会应用两个资源，而运行带有`sox`标签的命令则只会运行该组。
- en: There are further metaparameters, such as `alias` and `loglevel`, that are simply
    not in common use although they have no risks worth discussing in detail; they
    can be read about at [https://www.puppet.com/docs/puppet/8/metaparameter.html](https://www.puppet.com/docs/puppet/8/metaparameter.html)
    or by running `puppet describe <any` `type> -m`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的元参数，如`alias`和`loglevel`，尽管它们没有太大使用频率且没有值得详细讨论的风险，但仍可以在[https://www.puppet.com/docs/puppet/8/metaparameter.html](https://www.puppet.com/docs/puppet/8/metaparameter.html)查看，或者通过运行`puppet
    describe <any` `type> -m`来了解。
- en: The resource declarations shown before now have followed the same simple declaration
    pattern, but there are several other methods to allow more flexibility and advanced
    features.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示的资源声明遵循了相同的简单声明模式，但还有其他几种方法可以实现更多的灵活性和高级功能。
- en: The resources metatype
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源元类型
- en: 'Puppet has a `resources` metatype, which can be used to ensure unmanaged resources
    of a type are removed. If it is thought of like the output of the `<type>` Puppet
    resource, finding anything with no matching `namevar` attributes from your code
    to mark as `absent`. It uses four attributes; a `purge` attribute, which can be
    `true` or `false`, and two attributes relevant when you are using resources on
    the user type – `unless_system_user`, which accepts `true`, `false`, or a specified
    minimum UID and ensures the system definition, or you can define integers or an
    array of integers in the `minimum_uid` parameter, which will be protected from
    the purge. To generate a list of numbers, the `range()` function from the `stdlib`
    module can make this easier. We will discuss functions in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123),
    to make it clear how functions work. As with all resources, the metaparameters
    can be used and **noop** is advisable here, as purging all users may be too aggressive,
    so seeing which users will be removed may initially be the best reporting to see:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet有一个`resources`元类型，可以用于确保移除未管理的资源类型。如果把它当作`<type>` Puppet资源的输出，可以找到任何没有匹配`namevar`属性的资源，并标记为`absent`。它使用四个属性；一个是`purge`属性，可以为`true`或`false`，另两个属性在使用用户类型的资源时特别相关——`unless_system_user`，该属性接受`true`、`false`或指定的最小UID，并确保系统定义，或者你可以在`minimum_uid`参数中定义整数或整数数组，以保护这些UID免受清除。要生成数字列表，可以使用`stdlib`模块中的`range()`函数，这会使生成过程更加简便。我们将在[*第5章*](B18492_05.xhtml#_idTextAnchor123)中讨论函数，以便清楚地了解函数的工作方式。与所有资源一样，元参数也可以使用，**noop**在这里是建议使用的，因为清除所有用户可能过于激进，因此首先查看哪些用户将被删除可能是最好的报告方法：
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `ssh_authorized_key` type should be managed on the *user* type via the `purge_ssh_keys`
    attribute.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`ssh_authorized_key`类型应通过`purge_ssh_keys`属性在*用户*类型上进行管理。'
- en: Arrays of titles
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标题数组
- en: 'When declaring several resources with the same attributes, the title can be
    declared as an array of resources, acting like multiple resource declarations.
    We will cover arrays in [*Chapter 4*](B18492_04.xhtml#_idTextAnchor078), but for
    now, understand an array of titles can be used with opening square brackets and
    a separating comma, so the title for a resource would be like the following example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明多个具有相同属性的资源时，可以将标题声明为资源数组，像多个资源声明一样工作。我们将在[*第4章*](B18492_04.xhtml#_idTextAnchor078)中讨论数组，但目前请理解，标题数组可以使用开方括号和分隔逗号来声明，因此一个资源的标题将像以下示例：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Overriding parameters
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖参数
- en: 'Here’s the syntax for a resource reference:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是资源引用的语法：
- en: Type starting with a capital
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型首字母大写
- en: Title in square brackets
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方括号中的标题
- en: Opening curly brace (`{`)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开括号（`{`）
- en: Attributes to override
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要覆盖的属性
- en: Closing curly brace (`}`)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭括号（`}`）
- en: 'It is possible to override attributes of a declared resource. In this example,
    we set `Audit` to `true` and `group` to `other_group` on the `resource /``opt/example/bin`
    file:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 可以覆盖已声明资源的属性。在此示例中，我们将`Audit`设置为`true`，并将`group`设置为`other_group`，用于`/opt/example/bin`文件资源：
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is best used combined with the array of titles so that common defaults
    can be defined and then particular attributes set for a named resource. In this
    book, we recommend using this sparingly to avoid confusion when everything is
    declared.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将其与标题数组结合使用，这样可以定义通用的默认值，然后为特定的命名资源设置特定的属性。在本书中，我们建议谨慎使用此功能，以避免在所有内容声明时引起混淆。
- en: Attribute splats
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性展开
- en: 'The attribute splat (`*`) is a mechanism of using a hash to fill out attributes
    of a type; this can be useful in situations where we want to cover the differences
    in attributes used by different providers. In a resource using the normal syntax,
    you can have set of the attributes as `*` and then create a hash of the attributes
    you would use. We will cover hashes, variables, and case statements in [*Chapter
    4*](B18492_04.xhtml#_idTextAnchor078) and [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194),
    but for this example, it should be clear that we are setting the package options
    hash to contain a `name` attribute equal to `apache2` for Debian and `httpd` as
    a default:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 属性展开符（`*`）是一种使用哈希值填充类型属性的机制；在需要覆盖不同提供者使用的属性差异时，这非常有用。在使用正常语法的资源中，你可以将属性集设置为`*`，然后创建一个包含你要使用的属性的哈希值。我们将在[*第4章*](B18492_04.xhtml#_idTextAnchor078)和[*第7章*](B18492_07.xhtml#_idTextAnchor194)中讨论哈希、变量和条件语句，但在这个例子中，应该清楚我们正在设置软件包选项哈希，包含一个`name`属性，对于Debian设置为`apache2`，作为默认值则是`httpd`：
- en: '[PRE39]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This results in the package `http` resource using the name `http2` for Ubuntu
    and Debian systems and `httpd` by default for any other systems. This feature
    should be used carefully so as not to detract from readability.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致`http`软件包资源在Ubuntu和Debian系统上使用`http2`作为名称，而其他系统则默认为`httpd`。此功能应谨慎使用，以免影响可读性。
- en: Lab
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验
- en: To practice a little of what we have discussed, let us follow up on our previous
    example and have a single manifest, `all_grafana.pp`, which can install, configure,
    and run Grafana on both Linux and Windows. As we have not covered facts yet, understand
    that as in our previous example, a case statement could use `$facts ['os']['family']`
    to look for Red Hat or Windows to distinguish between our two clients. Note the
    `rpm install` file is available at [https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm](https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm)
    and the configuration file for Linux is at `/etc/grafana/grafana.ini`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习我们所讨论的内容，让我们回顾之前的例子，创建一个单一的清单文件`all_grafana.pp`，它可以在Linux和Windows上安装、配置并运行Grafana。由于我们尚未讨论事实（facts），请理解，就像我们之前的例子一样，`case`语句可以使用`$facts
    ['os']['family']`来查找Red Hat或Windows，从而区分我们的两个客户端。请注意，`rpm install`文件可以在[https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm](https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm)上获取，Linux的配置文件位于`/etc/grafana/grafana.ini`。
- en: As a second exercise, create a separate manifest to create some users on the
    Linux client, `linux_users.pp create 3 users exampleappdev`, `exampleapptest`,
    `exampleappprod`, and a group, `exampleapp`, with all the users using this group
    as their primary group. `exampleappprod` should purge `ssh` keys from `authorized`.
    Finally, it should check whether there are any other non-system-level users on
    the client (but not enforce anything).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个练习，创建一个单独的清单来在 Linux 客户端上创建一些用户，`linux_users.pp` 创建 3 个用户 `exampleappdev`、`exampleapptest`、`exampleappprod`
    和一个组 `exampleapp`，所有用户都使用此组作为其主要组。 `exampleappprod` 应该从 `authorized` 中清除 `ssh`
    密钥。最后，它应检查客户端是否有其他非系统级别的用户（但不强制执行任何操作）。
- en: 'As per the previous lab, you can test your manifests by running a `bolt` command
    with your manifest name and client name listed: `bolt apply manifestname.pp –``server
    servername.example.com`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上一个实验，您可以通过列出的命令来测试您的清单：`bolt apply manifestname.pp –``server servername.example.com`。
- en: You can find solutions at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/all_grafana.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/all_grafana.pp)
    and [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/linux_users.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/linux_users.pp).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/all_grafana.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/all_grafana.pp)
    和 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/linux_users.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch03/linux_users.pp)
    找到解决方案。
- en: Anti-patterns
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反模式
- en: In this section, we will talk about some resource features you will find documented
    and useable with Puppet but that this book strongly recommends you do not use
    and make it part of your best practices to avoid. The resource features we highlight
    here are powerful but make resource declarations harder to read and require more
    translation and calculations required to see the state we are attempting to get
    the server into.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一些 Puppet 文档中可找到和可用的资源功能，但本书强烈建议您不要使用，并将其作为最佳实践的一部分避免。我们在这里突出显示的资源功能强大，但会使资源声明变得更难阅读，并且需要更多的翻译和计算才能看到我们试图将服务器置于的状态。
- en: Abstract resource types
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象资源类型
- en: 'An abstract resource type is used for declaring a resource when we do not want
    to predefine a type and may decide which resource we will use based on the client.
    In this simple example, a variable is set to the type and the resource is then
    declared using the `Resource[<TYPE>] { <RESOURCE` `BODY>}` syntax:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不希望预定义类型并且可能根据客户端决定要使用哪个资源时，可以使用抽象资源类型来声明资源。在这个简单的示例中，一个变量设置为类型，然后使用 `Resource[<TYPE>]
    { <RESOURCE` `BODY>}` 语法声明资源：
- en: '[PRE40]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A simple translation of this statement would be as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对这种情况的简单翻译如下：
- en: '[PRE41]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This book recommends against using abstracts, it is not commonly used, and it
    makes the code a lot less readable, particularly for less experienced Puppet users.
    The best approach is to use `case` statements or `if` statements, which we will
    cover in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194). If there is too much
    divergence in the code, it becomes best to separate the resources into separate
    classes and not force platforms that share little in resource types together.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本书建议不使用抽象，因为它不常用且使代码变得不易读，尤其是对于经验较少的 Puppet 用户。最佳方法是使用`case`语句或`if`语句，我们将在[*第7章*](B18492_07.xhtml#_idTextAnchor194)中详细讨论。如果代码分歧太大，最好将资源分开到不同的类中，而不要强制共享资源类型较少的平台。
- en: Defaults
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认
- en: There are two methods of declaring defaults, but this book advises against using
    either. A default body with multiple bodies in a resource declaration breaks good
    practices around single purposes for a declaration, and a default resource statement
    can be dangerous in terms of understanding its scoping.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 声明默认值有两种方法，但本书建议不使用任何一种。一个具有多个资源声明体的默认主体会破坏声明的单一用途的良好实践，而默认资源语句在理解其作用域时可能会很危险。
- en: A default resource body
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认资源主体
- en: Here, a resource can have a default body, following the same syntax as a normal
    resource declaration but starting one of the bodies with `default:`; the ordering
    of the bodies does not matter.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，资源可以有一个默认主体，遵循与普通资源声明相同的语法，但以 `default:` 开头其中一个主体；主体的顺序并不重要。
- en: 'This example shows two sets of arrays of titles, taking the defaults and changing
    the default mode for the second array of the titles set:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了两组标题数组，取默认值并为第二组标题集更改默认模式：
- en: '[PRE42]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As discussed when declaring resources, this book strongly recommends keeping
    a clear single-purpose resource declaration as grouping multiple bodies together
    makes the code harder to read. The recommended method for comparable results is
    to use arrays of titles and override parameters where appropriate.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如声明资源时所讨论的，本书强烈建议保持清晰的单一目的资源声明，因为将多个主体组合在一起会使代码更难阅读。对于类似的结果，推荐的方法是使用标题数组并在适当的地方覆盖参数。
- en: Resource default syntax
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源默认语法
- en: 'The second method is to use a default resource statement syntax:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用默认资源语句语法：
- en: The type starting with a capital and `{`
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型以大写字母和 `{` 开始
- en: A List of attributes and default values
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性及默认值列表
- en: Ending with `}`
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `}` 结尾
- en: If the type has multiple namespaces, such as `concat::fragment`, then each namespace
    section should be capitalized.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型有多个命名空间，例如 `concat::fragment`，则每个命名空间部分应大写。
- en: 'In this example, we use a file to set the default for all files resources that
    do not declare a value for an attribute’s owner group or mode:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用一个文件来设置所有未声明属性所有者组或模式值的文件资源的默认值：
- en: '[PRE43]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Commonly used in early versions of Puppet, this is now considered only suitable
    for use on the `site.pp` file (a global settings file we will cover in [*Chapter
    11*](B18492_11.xhtml#_idTextAnchor272)). This is a result of Puppet no longer
    using a dynamic scope for variable lookup and default resources still being dynamically
    scoped, which can result in scope creep and unintentionally affect other resources
    in your catalog. (Scope will be discussed in detail in [*Chapter 6*](B18492_06.xhtml#_idTextAnchor185)).
    Since having defaults in `site.pp` makes them unexpected and less visible, this
    book recommends against using resource defaults.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 的早期版本中常用，现在被认为只适用于 `site.pp` 文件（我们将在[*第11章*](B18492_11.xhtml#_idTextAnchor272)中讨论的全局设置文件）。这是因为
    Puppet 不再使用动态作用域进行变量查找，而默认资源仍然是动态作用域的，这可能导致作用域蔓延，并无意中影响到目录中的其他资源。（作用域将在[*第6章*](B18492_06.xhtml#_idTextAnchor185)中详细讨论）。由于在
    `site.pp` 中使用默认值会使它们变得不易察觉且不够透明，本书建议不要使用资源默认值。
- en: schedule
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: schedule
- en: '`schedule` is a metaparameter used in conjunction with the schedule resource
    type. This allows us to describe a specific schedule with a resource type, which
    defines when a particular resource can be run so that if Puppet is applied outside
    of this time, it will ignore the resource and how many times it can run in this
    period. The schedule resource type uses various attributes to describe ranges,
    repetition, or days: a simple example would be to cover the hours 6 p.m. to 9
    a.m. over Friday night and Saturday morning:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`schedule` 是与 schedule 资源类型结合使用的元参数。它允许我们用资源类型描述特定的计划，定义何时可以运行某个特定资源，以便如果 Puppet
    在这个时间外应用，它将忽略该资源，以及它在此期间可以运行多少次。schedule 资源类型使用各种属性来描述范围、重复或天数：一个简单的示例是覆盖从周五晚上到周六早上6点到9点的时间段：'
- en: '[PRE44]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That could then be applied to a resource:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将其应用于资源：
- en: '[PRE45]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This book advocates against this use case. It may seem tempting, particularly
    for highly regulated environments that have restricted windows for changes, but
    Puppet should enforce the expected state, so diverging from this state should
    be an issue. Creating schedules makes it obscure as to what will be applied and
    opens the state to periods of vulnerability where servers are only partially enforced
    by Puppet.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 本书反对这种使用方式。这可能看起来很诱人，特别是对于那些有严格变更时间窗口的高监管环境，但 Puppet 应该强制执行预期的状态，因此偏离该状态应该是一个问题。创建计划使得应用内容变得不明确，并让状态暴露在服务器只被部分
    Puppet 强制执行的脆弱时期。
- en: Exporters and collectors
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出器和收集器
- en: Exporting and collecting Puppet resources happens when Puppet tries to allow
    information to be exchanged between nodes for interdependency. It allows a resource
    to be declared and run on one node and then other nodes to also apply these resources.
    This is done by exporting the information to the `PuppetDB` database, which Puppet
    runs will consult with when collecting. This means it can only be run via a Puppet
    agent setup and not via local Puppet runs.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Puppet 尝试允许节点之间交换信息以实现相互依赖时，就会发生导出和收集 Puppet 资源。它允许在一个节点上声明并运行资源，然后其他节点也可以应用这些资源。这是通过将信息导出到`PuppetDB`数据库完成的，Puppet
    运行时会在收集时查阅该数据库。这意味着它只能通过 Puppet 代理设置运行，而不能通过本地 Puppet 运行。
- en: 'Exporting a resource just involves adding `@@` in front of a normal resource
    declaration. The exported resource must be unique in `PuppetDB`, so commonly the
    hostname fact (a variable containing the hostname) is used in the declaration.
    In this example, a host entry is being exported to be put in the host file of
    each collecting server:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 导出资源只需在正常的资源声明前加上`@@`。导出的资源在`PuppetDB`中必须是唯一的，因此通常会在声明中使用主机名事实（包含主机名的变量）。在这个示例中，一个主机条目被导出，并将被放入每个收集服务器的主机文件中：
- en: '[PRE46]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Collecting the resource then involves declaring a collector, which is the type
    starting with a capital and a *spaceship* (`<<| |>>`) declaration; inside this,
    tags can be declared to filter the collection. Completing this example, this collection
    would ensure all exported host resources tagged `oracle` would be applied to the
    server:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 收集资源接着涉及声明一个收集器，它是以大写字母开头并带有*飞船*（`<<| |>>`）声明的类型；在其中，可以声明标签来过滤集合。完成此示例后，此集合将确保所有标记为`oracle`的导出主机资源应用到服务器上：
- en: '[PRE47]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Exporting and collecting have two key issues; the first is it becomes harder
    to read the code and understand the resources that may be applied to a node. The
    second is it complicates the scalability and high-availability considerations
    for your Puppet infrastructure setup. As a result, by best practice, this book
    recommends avoiding any use of exporters and collectors.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 导出和收集有两个关键问题；第一个是代码的可读性变差，难以理解可能应用于节点的资源。第二个是它使得Puppet基础设施设置的可扩展性和高可用性考虑变得更加复杂。因此，根据最佳实践，本书建议避免使用任何导出器和收集器。
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about declaring resources and the syntax and styling
    checks that can be performed to develop consistent code. Classes were shown to
    be a way to group resources and allow us to call classes and apply these groups
    of resources to servers. Defined types were then shown as a way to create repeatable
    patterns of Puppet code, which can vary by parameters.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何声明资源以及可以执行的语法和样式检查，以便开发一致的代码。类被展示为一种将资源分组的方法，它允许我们调用类并将这些资源组应用于服务器。定义类型则被展示为一种创建可重复模式的Puppet代码的方法，这些模式可以根据参数有所变化。
- en: We showed how to explore and use types and providers and saw some of the most
    commonly used core types and how to use them well. The file, package, and service
    types were shown to provide a great foundation for installing, configuring, and
    starting an application. It was seen how Puppet resources can relate to each other
    to ensure an order and how to then apply these resources written locally to servers
    for testing.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们展示了如何探索和使用类型与提供者，并了解了一些最常用的核心类型以及如何有效地使用它们。文件、包和服务类型被展示为安装、配置和启动应用程序的良好基础。我们看到，Puppet资源如何相互关联以确保顺序，并如何将这些本地编写的资源应用到服务器上进行测试。
- en: The chapter covered the core resource metaparameters to understand how to use
    various features of resources – tagging to allow filtered runs of resources; auditing
    to monitor changes, which happen to unmanaged attributes on a resource, and using
    `noop` to allow a resource to be declared as non-executable but reported on.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了核心资源元参数，以帮助理解如何使用资源的各种功能——标签用于允许对资源进行过滤运行；审计用于监控发生在资源非托管属性上的变化，使用`noop`可以声明资源为不可执行但仍进行报告。
- en: Finally, various anti-patterns were covered – default resources, which have
    scoping issues; default bodies, which result in overloaded resource statements;
    schedules, which make understanding Puppet runs complex; and export and collectors,
    which have issues both in terms of scalability and availability and in terms of
    abstracting data away from the code.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，介绍了各种反模式——默认资源，它们存在作用域问题；默认体，它们导致资源语句过载；调度，它使得理解Puppet运行变得复杂；以及导出和收集器，它们在可扩展性、可用性以及将数据从代码中抽象化方面存在问题。
- en: In the next chapter, we will cover variables and data types, which will allow
    us to assign values to variables and control what those values are and how they
    can be interacted with. This will allow us to reduce duplication and make our
    resources easier to update and manage, as well as providing a way to pass in data
    to our classes.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍变量和数据类型，这将使我们能够为变量分配值，并控制这些值是什么以及如何与它们进行交互。这将使我们减少重复，并使资源更易于更新和管理，同时提供了一种将数据传递给类的方式。
