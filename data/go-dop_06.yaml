- en: 'Chapter 5: Using Common Data Formats'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章：使用常见的数据格式
- en: One of the key skills that a DevOps engineer requires is the ability to manipulate
    data across a variety of storage mediums.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps工程师需要的关键技能之一是能够跨各种存储介质操作数据。
- en: In the last chapter, we interacted with the local filesystem to read and stream
    files. That is foundational for the skills we will be learning in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们与本地文件系统交互，读取和流式传输文件。这为我们在本章中将要学习的技能打下了基础。
- en: This chapter will focus on how to manipulate common data formats that engineers
    commonly use. These formats are used to configure services, structure log data,
    and to export metrics, among the many other uses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点讲解如何操作工程师常用的常见数据格式。这些格式用于配置服务、结构化日志数据，以及导出度量数据，当然还有很多其他用途。
- en: In this chapter, you will learn how to use `struct` field tags to store metadata
    about fields. Also, you will learn how to stream these formats efficiently when
    working with large amounts of data.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用`struct`字段标签来存储有关字段的元数据。此外，你还将学习如何在处理大量数据时高效地流式传输这些格式。
- en: Unlocking these skills will allow you to engage with services by manipulating
    configuration files, searching through records that might include logs or metrics,
    and outputting data into Excel for reporting purposes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握这些技能将使你能够通过操作配置文件、查找可能包含日志或度量数据的记录，以及将数据导出到Excel中进行报告，从而与服务进行交互。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及以下主题：
- en: CSV files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV文件
- en: Popular encoding formats
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行的编码格式
- en: In the next section, we will dive into the process of utilizing data in one
    of the oldest formats, CSV.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨如何使用最古老的格式之一——CSV来处理数据。
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以从[https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5)下载
- en: CSV files
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSV文件
- en: CSV is one of the most common data sources that a DevOps engineer can encounter.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: CSV是DevOps工程师最常遇到的常见数据源之一。
- en: This simple format has long been a mainstay in the corporate world as one of
    the easiest ways to export data out of a system for manipulation and back into
    a data store.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的格式长期以来一直是企业界的主流，是将数据从系统中导出进行处理，并再导入数据存储的最简单方式之一。
- en: Many critical systems at large cloud providers, such as Google's GCP and Microsoft's
    Azure, have critical data sources and systems based on the CSV format. We have
    seen systems such as network modeling and critical data reporting stored in CSV.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多大型云服务提供商的关键系统，如Google的GCP和Microsoft的Azure，依赖CSV格式的关键数据源和系统。我们已经看到像网络建模和关键数据报告这样的系统存储在CSV中。
- en: Data scientists love CSV for its easy searching and streaming capabilities.
    The added quality of being able to quickly visualize the data in software has
    only added to its appeal.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学家喜欢CSV，因为它易于搜索和流式处理。能够在软件中快速可视化数据的额外优点更是增加了它的吸引力。
- en: And, like many other formats, it is human-readable, which allows the data to
    be manipulated by hand.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 和许多其他格式一样，它是人类可读的，这使得数据可以手动操作。
- en: 'In this section, we are going to focus on importing and exporting CSV data
    using the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于使用以下方法导入和导出CSV数据：
- en: The `strings` package and the `bytes` package
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings`包和`bytes`包'
- en: The `encoding/csv` package
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding/csv`包'
- en: Additionally, we are going to look at importing and exporting data to the popular
    Excel spreadsheet format using `excelize`, which is a popular package for Microsoft
    Excel.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将探讨如何使用`excelize`包将数据导入和导出到流行的Excel电子表格格式。`excelize`是一个广泛使用的Microsoft
    Excel工具包。
- en: Now, let's discuss how we can use simple string/byte manipulation packages to
    read/write CSV files.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论如何使用简单的字符串/字节操作包来读写CSV文件。
- en: Basic value separation using the strings package
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用strings包进行基本的值分隔
- en: 'Go provides several packages that you will find useful in the manipulation
    of the `string` and `[]byte` types:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了几个在操作`string`和`[]byte`类型时非常有用的包：
- en: '`strings`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strings`'
- en: '`bytes`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes`'
- en: 'These packages offer similar functionality such as the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包提供了类似的功能，如以下内容：
- en: Functions to split data such as `strings.Split()`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分割数据的函数，如`strings.Split()`
- en: Functions to merge data with separators such as `strings.Join()`
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并带分隔符数据的函数，如`strings.Join()`
- en: Buffer types that implement the `io` package's interfaces, such as `bytes.Buffer`
    and `strings.Builder`
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了`io`包接口的缓冲区类型，例如`bytes.Buffer`和`strings.Builder`
- en: When dealing with CSV files, a developer either streams the data or reads the
    whole file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 处理CSV文件时，开发人员可以选择流式读取数据或一次性读取整个文件。
- en: Many developers prefer to read an entire file into memory and convert it from
    a `[]byte` type into a `string` type. Strings are easier for developers to understand
    the join and split rules.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员更喜欢将整个文件读取到内存中，并将其从`[]byte`类型转换为`string`类型。字符串对开发人员来说更容易理解连接和拆分规则。
- en: However, this causes a copy to be created during conversion, which can be inefficient
    because you have to double the amount of memory used and dedicate some CPU to
    doing the copy. When that is a problem, developers reach for the `bytes` and `bufio`
    packages. These are slightly more difficult to use, but they prevent any unnecessary
    conversion cost.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这在转换过程中会创建一个副本，这可能会导致效率低下，因为你需要使用双倍的内存并且占用一些CPU进行复制。当出现这个问题时，开发人员通常会使用`bytes`和`bufio`包。虽然这些包稍微难以使用，但它们避免了不必要的转换开销。
- en: Let's look at how we can read an entire file and covert the entries into a structured
    record.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何读取整个文件并将条目转换成结构化记录。
- en: Conversion after reading the whole file
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取整个文件后的转换
- en: 'When doing basic CSV manipulation, sometimes, it is easier to simply split
    data using a carriage return and then split the line based on a comma or other
    separator. Let''s say we have a CSV file representing first and last names and
    break that CSV file into records:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行基本的CSV操作时，有时候更简单的做法是使用换行符拆分数据，然后根据逗号或其他分隔符来拆分每一行。假设我们有一个包含名字和姓氏的CSV文件，我们将这个CSV文件拆分为记录：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code does the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码执行以下操作：
- en: It defines a `record` type based on a slice of strings, `[]string`.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它基于一个字符串切片`[]string`定义了一个`record`类型。
- en: We can check whether a `record` type was valid by calling its `validate()` method.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过调用`validate()`方法来检查一个`record`类型是否有效。
- en: The record's first name can be retrieved using `first()`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`first()`方法获取记录的名字。
- en: The record's last name can be retrieved using `last()`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`last()`方法获取记录的姓氏。
- en: It defines a `readRecs()` function to read a file, called `data.csv`.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它定义了一个`readRecs()`函数来读取名为`data.csv`的文件。
- en: It reads the entire file into memory and converts it into a string called `content`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将整个文件读取到内存中，并转换为名为`content`的字符串。
- en: '`content` is split by the new line character, `\n`, with each entry representing
    a line.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`content`通过换行符`\n`拆分，每个条目代表一行。'
- en: It loops through the lines, splitting each line with a comma, `,`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过逗号（`,`）来拆分每一行。
- en: It assigns each return from `Split`, which is a `[]string` type to a `record`
    type.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将`Split`返回的每个结果（一个`[]string`类型）赋值给`record`类型。
- en: It compiles all records to a slice of records, `[]record`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将所有记录汇总到一个记录切片`[]record`中。
- en: You can view this code in action at [https://play.golang.org/p/CVgQZzScO8Z](https://play.golang.org/p/CVgQZzScO8Z).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://play.golang.org/p/CVgQZzScO8Z](https://play.golang.org/p/CVgQZzScO8Z)查看此代码的运行情况。
- en: Converting line by line
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按行转换
- en: 'If the file is large and we want to be efficient, we can use the `bufio` and
    `bytes` packages:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件较大且我们希望提高效率，可以使用`bufio`和`bytes`包：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This differs from the previous code in that the following occurs:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的代码不同，因为以下情况发生了：
- en: We read each line, one by one, using `bufio.Scanner` instead of the entire file.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们逐行读取每一行，使用`bufio.Scanner`，而不是读取整个文件。
- en: '`scanner.Scan()` reads the next set of content until it sees `\n`.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scanner.Scan()`会读取下一组内容，直到遇到`\n`。'
- en: That content can be retrieved using `scanner.Text()`.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该内容可以通过`scanner.Text()`获取。
- en: You can view this code in action at [https://play.golang.org/p/2JPaNTchaKV](https://play.golang.org/p/2JPaNTchaKV).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://play.golang.org/p/2JPaNTchaKV](https://play.golang.org/p/2JPaNTchaKV)查看此代码的运行情况。
- en: With this version, we are still doing a `[]byte` conversion on each line into
    a `string` type. If you are interested in a version that does not do this, please
    refer to [https://play.golang.org/p/RwsTHzM2dPC](https://play.golang.org/p/RwsTHzM2dPC).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们仍然对每一行进行`[]byte`转换为`string`类型。如果你对不做这种转换的版本感兴趣，请参考[https://play.golang.org/p/RwsTHzM2dPC](https://play.golang.org/p/RwsTHzM2dPC)。
- en: Writing records
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入记录
- en: 'Writing records to CSV is fairly simple using the methods that we played with
    earlier. If after reading our records, we wanted to sort them and write them back
    to a file, we could accomplish this with the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们之前测试过的方法，写入CSV记录是相当简单的。如果在读取记录之后，我们希望对其进行排序并将其写回文件，可以使用以下代码实现：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also modify the `record` type to have this new method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以修改`record`类型，添加这个新方法：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see this running at [https://play.golang.org/p/qBCDAsOSgS6](https://play.golang.org/p/qBCDAsOSgS6).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://play.golang.org/p/qBCDAsOSgS6](https://play.golang.org/p/qBCDAsOSgS6)看到这段代码的运行情况。
- en: 'The `writeRecs()` function does the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`writeRecs()`函数执行以下操作：'
- en: It opens `data-sorted.csv` for writing.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它打开`data-sorted.csv`进行写入。
- en: It sorts the records using `sort.Slice()` from the `sort` package.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`sort`包中的`sort.Slice()`对记录进行排序。
- en: It loops over the records and writes out the CSV file, as generated by the new
    `csv()` method.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它循环遍历记录并写出CSV文件，这是由新的`csv()`方法生成的。
- en: 'The `csv()` method does the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv()`方法执行以下操作：'
- en: It creates a `bytes.Buffer` interface, which acts similar to an in-memory file.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个`bytes.Buffer`接口，类似于一个内存中的文件。
- en: It loops through each field in the record and writes the field value followed
    by a comma.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它循环遍历记录中的每个字段，并写入字段值，后跟逗号。
- en: It writes a carriage return after the content on the CSV line.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在CSV行的内容后写入回车符。
- en: It returns the buffer as a `[]bytes` type that now represents a single line.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回一个`[]bytes`类型的缓冲区，现在表示单行数据。
- en: Using the encoding/csv package
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`encoding/csv`包
- en: To handle CSV encodings that conform to the RFC 4180 standard, [https://www.rfc-editor.org/rfc/rfc4180.html](https://www.rfc-editor.org/rfc/rfc4180.html),
    the standard library provides the `encoding/csv` package.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理符合RFC 4180标准的CSV编码，[https://www.rfc-editor.org/rfc/rfc4180.html](https://www.rfc-editor.org/rfc/rfc4180.html)，标准库提供了`encoding/csv`包。
- en: Developers should opt to use this package for CSV handling when the CSV conforms
    to this specification.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者应选择使用此包处理符合此规范的CSV。
- en: 'This package provides two types for handling CSVs:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包提供了两种类型来处理CSV：
- en: '`Reader` for reading in CSVs'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reader`用于读取CSV。'
- en: '`Writer` for writing CSVs'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Writer`用于写入CSV。'
- en: In this section, we will tackle the same problem as before, but we will utilize
    the `Reader` and `Writer` types.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将解决与之前相同的问题，但我们将使用`Reader`和`Writer`类型。
- en: Reading line by line
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一行一行读取
- en: 'In the same way as before, we want to read each CSV entry from the file one
    at a time and process it to a `record` type:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们想要一次读取文件中的每个CSV条目，并将其处理为`record`类型：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can view this code in action at [https://go.dev/play/p/Sf6A1AbbQAq](https://go.dev/play/p/Sf6A1AbbQAq).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://go.dev/play/p/Sf6A1AbbQAq](https://go.dev/play/p/Sf6A1AbbQAq)查看这段代码的实际运行情况。
- en: 'This function utilizes our reader to perform the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数利用我们的reader执行以下操作：
- en: Pass the file to our `NewReader()`constructor.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件传递给我们的`NewReader()`构造函数。
- en: Set the reader to require two fields per record.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置reader要求每条记录有两个字段。
- en: Remove any leading space in a line.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除行首的空格。
- en: Read each record and store it in a `[]record` slice.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取每条记录并将其存储在`[]record`切片中。
- en: The `Reader` type has other fields that can change how data is read in. For
    more information, please refer to [https://pkg.go.dev/encoding/csv](https://pkg.go.dev/encoding/csv).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reader`类型还有其他字段可以改变数据的读取方式。更多信息请参考[https://pkg.go.dev/encoding/csv](https://pkg.go.dev/encoding/csv)。'
- en: In addition, `Reader` provides a `ReadAll()`method that reads all of the records
    in a single call.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Reader`提供了一个`ReadAll()`方法，可以一次性读取所有记录。
- en: Writing line by line
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一行一行写入
- en: 'The companion of the CSV `Reader` type , `Writer`, makes it simple to write
    to a file. Let''s replace the writing part of our previous `writeRecs()`function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: CSV的`Reader`类型的伴侣，`Writer`，使得写入文件变得简单。让我们替换之前`writeRecs()`函数中的写入部分：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the runnable code: [https://play.golang.org/p/7-dLDzI4b3M](https://play.golang.org/p/7-dLDzI4b3M)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可运行的代码：[https://play.golang.org/p/7-dLDzI4b3M](https://play.golang.org/p/7-dLDzI4b3M)
- en: 'The preceding code does the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码执行以下操作：
- en: It spawns a new `Writer` type that writes to our file.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它生成一个新的`Writer`类型，写入我们的文件。
- en: It flushes our content to the file on function exit.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在函数退出时将内容刷新到文件。
- en: It writes each record out as a CSV file, one per line.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将每条记录写出为CSV文件，每行一条。
- en: Using excelize when dealing with Excel
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在处理Excel时使用excelize
- en: Microsoft's Excel has been a popular tool for visualizing data since the 1980s.
    While the power of the program has grown, its simplicity has helped to make spreadsheets
    a common tool in most businesses.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的Excel自1980年代以来一直是可视化数据的流行工具。尽管该程序的功能不断增强，但它的简易性帮助电子表格成为大多数企业中常见的工具。
- en: While Excel is not CSV, it can import and export data in CSV. For basic usage,
    you can use the `encoding/csv` package detailed earlier in this chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Excel不是CSV格式，但它可以导入和导出CSV数据。对于基本用法，你可以使用本章前面详细介绍的`encoding/csv`包。
- en: However, if your organization uses Excel, it can be more helpful to use its
    native format to write the data and supply visual representations of the data.
    `excelize` is a third-party Go package that can help you do that.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你的组织使用 Excel，使用其原生格式来写入数据并提供数据的可视化展示会更有帮助。`excelize` 是一个第三方 Go 包，可以帮助你完成这项工作。
- en: The package can be found at [https://github.com/qax-os/excelize/tree/v2](https://github.com/qax-os/excelize/tree/v2).
    Additionally, the official documentation can be found at [https://xuri.me/excelize/](https://xuri.me/excelize/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 包含该包的地址为 [https://github.com/qax-os/excelize/tree/v2](https://github.com/qax-os/excelize/tree/v2)。此外，官方文档可以在
    [https://xuri.me/excelize/](https://xuri.me/excelize/) 查阅。
- en: There is also an online version of Excel that is part of Microsoft's Office
    365\. You can manipulate spreadsheets directly there; however, I find it easier
    to manipulate the spreadsheet offline and then import it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 Excel 的在线版本，作为微软 Office 365 的一部分。你可以直接在那儿操作电子表格；不过，我发现离线操作电子表格然后再导入会更方便。
- en: If you are interested in the REST API, you can read about it at [https://docs.microsoft.com/en-us/sharepoint/dev/general-development/excel-services-rest-api](https://docs.microsoft.com/en-us/sharepoint/dev/general-development/excel-services-rest-api).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 REST API 感兴趣，可以在 [https://docs.microsoft.com/en-us/sharepoint/dev/general-development/excel-services-rest-api](https://docs.microsoft.com/en-us/sharepoint/dev/general-development/excel-services-rest-api)
    阅读相关内容。
- en: Creating a .xlsx file and adding some data
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个 .xlsx 文件并添加一些数据
- en: 'Excel has a few characteristics that are helpful to understand:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Excel 有一些特性，对于理解它非常有帮助：
- en: An Excel file has the `.xlsx` extension.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Excel 文件具有 `.xlsx` 扩展名。
- en: Each `.xlsx` file contains **sheets**.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个 `.xlsx` 文件包含**工作表**。
- en: Each sheet includes a set of rows and columns.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个工作表包括一组行和列。
- en: A `.xlsx` file has a default sheet, called **Sheet1**.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.xlsx` 文件有一个默认的工作表，称为 **Sheet1**。'
- en: The intersection of a row and column is called a **cell**.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行和一列的交点称为**单元格**。
- en: Columns start with the letter A.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列从字母 A 开始。
- en: Rows start with the number 1\.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行从数字 1 开始。
- en: 'We are going to add some data that represents server data for a fictional fleet
    of devices. This includes the name of the server, the hardware generation, when
    it was acquired, and the CPU vendor:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些代表虚构设备舰队的服务器数据。这些数据包括服务器名称、硬件代数、获取时间以及 CPU 厂商：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code does the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码执行了以下操作：
- en: It creates an Excel spreadsheet.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个 Excel 电子表格。
- en: It adds column labels.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它添加了列标签。
- en: It adds two servers, `slvaa01` and `slvac14`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它添加了两个服务器，`slvaa01` 和 `slvac14`。
- en: It saves the Excel file.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它保存了 Excel 文件。
- en: There is a `mustParse()`function (used, but not defined above) that converts
    a string representing a date into `time.Time`. In Go, when you see `must` proceeding
    a function name, by convention if the function encounters an error, it will panic.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个 `mustParse()` 函数（上面使用但未定义），它将表示日期的字符串转换为 `time.Time`。在 Go 中，当你看到函数名之前有 `must`
    时，按惯例如果函数遇到错误，它会引发 panic。
- en: You can find the runnable code in the repository at [https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/5/excel/simple/excel.go](https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/5/excel/simple/excel.go).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/5/excel/simple/excel.go](https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/5/excel/simple/excel.go)
    仓库中找到可运行的代码。
- en: 'This example is the simplest way to add data to a sheet. However, it is not
    very scalable. Let''s create one that is:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例是向工作表添加数据的最简单方式。然而，它的可扩展性不强。让我们创建一个更具可扩展性的方法：
- en: '[PRE7]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code does the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码执行了以下操作：
- en: It creates a `serverSheet` type for managing our Excel sheet.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为管理我们的 Excel 工作表创建了一个 `serverSheet` 类型。
- en: It has a constructor that adds our column labels.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个构造函数来添加我们的列标签。
- en: 'Now we need something to add the data:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一些方法来添加数据：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code does the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了以下操作：
- en: It uses a lock to prevent multiple calls.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用锁来防止多次调用。
- en: It performs very basic data validation checks.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它执行非常基础的数据验证检查。
- en: It adds a row and then increments our internal `nextRow` counter.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它添加了一行，并递增我们的内部 `nextRow` 计数器。
- en: Now we have a more scalable way to add data to our sheet. Next, let's discuss
    how to summarize data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个更具可扩展性的方法来向工作表添加数据。接下来，让我们讨论如何总结数据。
- en: Data summarization
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据汇总
- en: 'There are two ways to summarize data that is added:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以总结添加的数据：
- en: Tracking summaries in our object
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的对象中跟踪汇总数据
- en: Excel pivot tables
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Excel 数据透视表
- en: 'For our example, I am going to use the first method. This method comes with
    several advantages:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我将使用第一种方法。这个方法有几个优点：
- en: It is easier to implement.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更容易实现。
- en: It performs faster calculations.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它执行更快的计算。
- en: It removes complex calculations from the spreadsheet.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从电子表格中删除了复杂的计算。
- en: 'However, it comes with a distinctive disadvantage:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它有一个显著的缺点：
- en: Data changes do not affect the summary.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据变化不会影响汇总。
- en: 'To track our data summary, let''s add a `struct` type:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪我们的数据汇总，让我们添加一个`struct`类型：
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s modify the `add()` method that we wrote earlier to summarize our table:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前写的`add()`方法来总结我们的表格：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code does the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码执行以下操作：
- en: It looks at our vendor and adds to our summary counters.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它查看我们的供应商并将其添加到我们的汇总计数器中。
- en: It adds a method to write our summaries to the sheet.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它添加了一个方法，将我们的汇总写入工作表。
- en: Next, let's discuss how we can add visualizations using this data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何使用这些数据添加可视化。
- en: Adding visualizations
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加可视化
- en: One of the reasons for using Excel over CSV for output is to add visualization
    elements. This allows you to quickly generate reports that users can look at that
    are more appealing than CSV and less intensive to write than web pages.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Excel而不是CSV进行输出的原因之一是添加可视化元素。这使得你可以快速生成用户可以查看的报告，这些报告比CSV更具吸引力，而且比网页更容易编写。
- en: 'Adding a chart is done via the `AddChart()`method. `AddChart()`takes in a string
    representing JSON that indicates how to build the chart. In our example, you will
    see a package, called `chart`, that extracts private types from `excelize` used
    to represent the charts and makes them public types. In this way, we can use a
    typed data structure instead of JSON that has been converted into that structure.
    This also allows for the easier discovery of values that you might wish to set:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 添加图表是通过`AddChart()`方法完成的。`AddChart()`接受一个表示JSON的字符串，用于指示如何构建图表。在我们的示例中，你将看到一个名为`chart`的包，它提取了`excelize`中的私有类型，这些类型用于表示图表，并将其转换为公共类型。通过这种方式，我们可以使用一个类型化的数据结构，而不是已经转换成该结构的JSON。这样也方便了发现你可能想要设置的值：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code does the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: It creates a new 3D pie chart type.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一种新的3D饼图类型。
- en: It sets the dimensions, title, and legend.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它设置了尺寸、标题和图例。
- en: It applies the chart values and categories.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应用了图表的值和类别。
- en: It marshals the chart's instructions to JSON.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将图表的指令转化为JSON格式。
- en: It calls `AddChart` to insert the chart into the sheet.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它调用`AddChart`将图表插入到工作表中。
- en: 'You can find the runnable code in the following repository: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5/excel/visualization](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5/excel/visualization)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下代码库中找到可运行的代码：[https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5/excel/visualization](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5/excel/visualization)
- en: So, we have covered the base minimum of using Excel for outputting reports.
    There are many other options, including inserting pictures, pivot tables, and
    advanced formatting directives. And while we wouldn't recommend Excel for data
    input into a system or a data storage format, it can be a useful data output system
    for summaries and viewing data.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经涵盖了使用Excel输出报告的基本要求。还有许多其他选项，包括插入图片、数据透视表和高级格式化指令。尽管我们不推荐使用Excel作为系统的数据输入或数据存储格式，但它对于汇总和查看数据来说，是一个有用的数据输出系统。
- en: Popular encoding formats
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流行的编码格式
- en: CSV is one of the more basic human-readable encodings that DevOps engineers
    will encounter, but it is by no means the only one. Within the last two decades,
    several new formats have emerged that are used to transfer information or provide
    configuration to applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: CSV是DevOps工程师会遇到的最基础的人类可读编码格式之一，但它绝不是唯一的。在过去的二十年里，出现了几种新格式，它们用于传输信息或为应用程序提供配置。
- en: '**JavaScript Object Notation** (**JSON**) is a data serialization format that
    was designed to convert JavaScript objects into a textual representation so that
    they could be saved or transferred. This notation, due to its simplicity and clarity,
    has been adopted by almost every language to transfer data.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**JavaScript对象表示法**（**JSON**）是一种数据序列化格式，旨在将JavaScript对象转换为文本表示形式，以便保存或传输。由于其简洁性和清晰性，这种标记法已经被几乎所有语言采纳，用于数据传输。'
- en: '**Yet Another Markup Language** (**YAML**) is another data serialization format
    that is often used to store configuration information for a service. YAML is the
    primary configuration language in Kubernetes clusters.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**另一种标记语言**（**YAML**）是一种数据序列化格式，常用于存储服务的配置信息。YAML是Kubernetes集群的主要配置语言。'
- en: In this section, we will look at the ways to marshal and unmarshal data from
    Go types into these formats and back into the Go type.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论如何将数据从 Go 类型转换为这些格式，再从这些格式转换回 Go 类型的方式。
- en: The Go field tags
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 字段标签
- en: 'Go has a feature called field tags that allow a developer to add string tags
    to `struct` fields. This allows a Go program to inspect the extra metadata regarding
    a field before performing an operation. Tags are key/value pairs:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有一个叫做字段标签（field tags）的功能，允许开发人员向 `struct` 字段添加字符串标签。这使得 Go 程序在执行操作之前，可以查看有关字段的额外元数据。标签是键/值对：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code snippet, you can see a `struct` type with a field called
    `Last` that has a field tag. The field tag is an inline raw string. Raw strings
    are denoted by backticks. This will produce a tag with a key of `"json"` and a
    value of `"last_name"`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你可以看到一个 `struct` 类型，包含一个名为 `Last` 的字段，该字段具有字段标签。字段标签是一个内联原始字符串。原始字符串用反引号表示。这将生成一个键为
    `"json"`、值为 `"last_name"` 的标签。
- en: Go packages can use the `reflect` package to read these tags. These tags allow
    a package to change the behavior of an operation based on the tag data. In this
    example, it tells our JSON encoder package to use `last_name` instead of `Last`
    when writing data to JSON and the reverse when reading data.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Go 包可以使用 `reflect` 包来读取这些标签。这些标签使得包能够根据标签数据更改操作的行为。在这个例子中，它告诉我们的 JSON 编码器包在写入
    JSON 数据时使用 `last_name` 而不是 `Last`，反之亦然。
- en: This feature is key for packages that handle data marshaling.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性对处理数据序列化的包至关重要。
- en: JSON
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON
- en: Over the past decade, the JSON format has become the de facto format for data
    encoding to disk and for communicating via RPC to services. No language in the
    cloud space can be successful without supporting JSON.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的十年中，JSON 格式已经成为数据编码到磁盘并通过 RPC 与服务通信的事实标准。在云领域，没有支持 JSON 的语言是无法成功的。
- en: 'A developer might encounter JSON as an application configuration language,
    but it is poorly suited for this task due to the following reasons:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员可能会遇到将 JSON 作为应用程序配置语言的情况，但由于以下原因，它并不适合这个任务：
- en: The lack of multiline strings
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏多行字符串
- en: The inability to have comments
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法添加注释
- en: The pickiness regarding its punctuation (that is, good for machines, and bad
    for humans)
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对标点符号的苛求（也就是说，机器适用，人类不适用）
- en: 'For the interchange of data, JSON can be quite useful with only a few downsides,
    such as the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据交换，JSON 在一些小缺点的情况下仍然非常有用，以下是其中的一些：
- en: Schemaless
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无模式
- en: Non-binary format
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非二进制格式
- en: Lack of byte array support
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺乏字节数组支持
- en: A schema is a definition of a message's content that lives outside code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 架构（schema）是对消息内容的定义，它存在于代码之外。
- en: Schemaless means there is no strict definition of what a message contains. This
    means that, for every language that is supported, we must create definitions for
    our messages in that language. Formats such as protocol buffers have entered into
    this space to provide a schema that can be used to generate code for any language.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 无模式意味着没有严格的定义来说明一个消息包含什么内容。这意味着，对于每种受支持的语言，我们必须为该语言创建消息的定义。诸如协议缓冲区（protocol
    buffers）等格式已经进入这个领域，提供了一个可以用来为任何语言生成代码的架构。
- en: JSON is also a human-readable format. These types of formats are not as efficient
    as binary formats in terms of size and speed. This generally matters when trying
    to scale large services. However, many prefer human-readable formats due to their
    ability to be easily debugged.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 也是一种人类可读的格式。这类格式在大小和速度上不如二进制格式高效。通常，当试图扩展大规模服务时，这一点很重要。然而，许多人更喜欢人类可读的格式，因为它们易于调试。
- en: JSON's lack of support for byte arrays is also a failing. JSON can still transfer
    raw bytes, but it requires encoding and decoding the bytes using `base64` encoding
    and storing them in JSON's `string` type. This requires an extra level of encoding
    that should be unnecessary. There are several supersets of JSON that are not widely
    supported (such as Binary JSON, or BSON for short) that contain a byte array type.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 不支持字节数组也是一个缺陷。虽然 JSON 仍然可以传输原始字节，但它需要使用 `base64` 编码对字节进行编码和解码，并将其存储在 JSON
    的 `string` 类型中。这需要额外的编码步骤，而这些步骤本不应存在。有几种 JSON 的超集（例如二进制 JSON，简称 BSON）包含字节数组类型，但它们并未广泛支持。
- en: 'JSON is delivered to a user in one of several ways:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 通过多种方式传递给用户：
- en: As a single message that can contain sub-messages
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个可以包含子消息的单一消息
- en: As an array of JSON messages
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 JSON 消息的数组
- en: As a stream of JSON messages
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 JSON 消息流
- en: JSON's origins started as a format for simply encoding a JavaScript object for
    transfer. However, as its uses have grown, the need for sending large messages
    or streams of messages became a use case.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: JSON最初的起源是作为一种格式，用于简单地编码JavaScript对象以进行传输。然而，随着使用场景的增多，发送大消息或消息流的需求也成为了一个实际应用场景。
- en: Single, large messages can be hard to decode. Generally, JSON decoders are written
    to read the entire message into memory and validate the message's content.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 单个大消息可能很难解码。通常，JSON解码器会读取整个消息到内存中，并验证消息的内容。
- en: To simplify large sets of messages or streaming content, you might encounter
    a message with brackets,`[]`, surrounding a set of messages or individual messages
    separated with carriage returns. These are not valid JSON as intended, but have
    become de facto standards for handling large sets of data as small, individual
    messages that make up part of a whole stream.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化大量的消息集或流式内容，你可能会遇到一个被括号`[]`包围的消息集合，或者是由回车符分隔的单个消息。这些不是按预期的有效JSON，但已经成为处理大量数据作为小的、单独的消息组成整个流的事实标准。
- en: Because JSON is a standard part of the cloud ecosystem, Go has built-in language
    support in the standard library's `encoding/json` package. In the upcoming sections,
    we will detail the most common ways to use the JSON package.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 因为JSON是云生态系统中的标准部分，Go语言在标准库的`encoding/json`包中提供了内置支持。在接下来的部分中，我们将详细介绍使用JSON包的最常见方法。
- en: Marshaling and unmarshaling to maps
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对`map`进行编码和解码
- en: Because JSON is schemaless, it is possible to have messages of different types
    in a stream or in files. This is usually undesirable, and it is better to have
    a top-level message that holds these types of messages.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JSON没有固定的模式，因此在流或文件中可能存在不同类型的消息。这通常是不可取的，最好有一个顶级消息来包含这些不同类型的消息。
- en: When you need to handle multiple message types or do discovery on a message,
    Go allows you to decode messages into `map[string]interface{}`, where the `string`
    key represents the field name and `interface{}` represents the value.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要处理多种消息类型或对消息进行发现时，Go允许你将消息解码成`map[string]interface{}`，其中`string`键表示字段名，`interface{}`表示值。
- en: 'Let''s examine an example of unmarshaling a file into a `map`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个将文件解码成`map`的示例：
- en: '[PRE13]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding example does the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例执行了以下操作：
- en: It reads the content of the `data.json` file into variable `b`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将`data.json`文件的内容读取到变量`b`中。
- en: It creates a `map`, called `data`, to store our JSON content.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建一个名为`data`的`map`，用于存储我们的JSON内容。
- en: It unmarshals the raw bytes representing the JSON into `data`.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将原始字节解码为JSON，存储到`data`中。
- en: It looks up the `user` key in `data`.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它查找`data`中的`user`键。
- en: If `user` does not exist, we return an error.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`user`不存在，我们返回一个错误。
- en: If it does exist, we `type assert` to determine what the value type is.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果确实存在，我们通过`type assert`来确定值的类型。
- en: If the value is a string, we return the content.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值是字符串，我们返回其内容。
- en: If the value is not a string, we return an error.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果值不是字符串，我们返回一个错误。
- en: Using the `map`, we can explore the values in the data to discover a message
    type, `type` `assert` the `interface{}` value to a concrete type, and then use
    the concrete value. Remember that type assertion converts an `interface` variable
    into another `interface` variable or a concrete type such as `string` or `int64`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map`，我们可以探索数据中的值以发现消息类型，`type` `assert` 将`interface{}`值断言为具体类型，然后使用该具体值。记住，类型断言将`interface`变量转换为另一个`interface`变量或具体类型，例如`string`或`int64`。
- en: Using a `map` is the hardest method of data decoding for JSON. It is only recommended
    in cases where the JSON is unpredictable, and there is no control of the data
    provider. It is usually better to have whatever is providing the data change its
    behavior than decoding in this way.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`map`是JSON数据解码中最复杂的方法。仅在JSON不可预测且无法控制数据提供者的情况下推荐使用这种方法。通常，最好是让数据提供者改变其行为，而不是以这种方式进行解码。
- en: 'Marshalling a `map` into JSON is simple:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将`map`编码为JSON很简单：
- en: '[PRE14]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`json.Marshal` will read our `map` and output valid JSON for the contents.`[]byte`
    fields are automatically `base64` encoded into JSON''s `string` type.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.Marshal`会读取我们的`map`并输出有效的JSON内容。`[]byte`字段会自动以`base64`编码转换为JSON的`string`类型。'
- en: Marshaling and unmarshaling to structs
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对结构体进行编码和解码
- en: 'The preferred method of JSON decoding is doing so in a Go `struct` type that
    represents the data. Here is an example of how to create a user record struct,
    which we will use to decode a JSON stream:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 解码的首选方法是在 Go 的 `struct` 类型中进行，这个类型表示数据。以下是创建用户记录结构体的示例，我们将使用它来解码 JSON 流：
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code outputs `{"user_name":"John Doak","user":"jdoak","ID":23}`.
    You can find the runnable code at [https://play.golang.org/p/LzoUpOeEN9y](https://play.golang.org/p/LzoUpOeEN9y).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码输出 `{"user_name":"John Doak","user":"jdoak","ID":23}`。你可以在 [https://play.golang.org/p/LzoUpOeEN9y](https://play.golang.org/p/LzoUpOeEN9y)
    找到可运行的代码。
- en: 'This code does the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了以下操作：
- en: It defines a `Record` type.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个 `Record` 类型。
- en: It uses field tags to tell JSON what the output field mapping should be.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用字段标签告诉 JSON 输出字段映射应为怎样。
- en: It uses a field tag of `-` on `Age` so that it will not be marshaled.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在 `Age` 字段上使用了 `-` 的字段标签，以便该字段不会被序列化。
- en: It creates a `Record` type called `rec`.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个名为 `rec` 的 `Record` 类型。
- en: It marshals `rec` to JSON.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将 `rec` 序列化为 JSON。
- en: It prints the JSON.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它打印出了 JSON。
- en: Notice that the `Name` field was translated to `user_name` and `User` to `user`.
    The `ID` field was unchanged in the output because we did not use a field tag.
    `Age` was not output because we used a field tag of `-`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`Name` 字段被转换为 `user_name`，`User` 转换为 `user`。`ID` 字段在输出中没有改变，因为我们没有使用字段标签。`Age`
    字段没有输出，因为我们使用了 `-` 的字段标签。
- en: Fields that are private because they start with a lowercase letter cannot be
    exported. This is because the JSON marshaler is in a different package and cannot
    see the private type in this package.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于以小写字母开头的字段是私有的，因此无法导出。这是因为 JSON 序列化器在另一个包中，无法看到当前包中的私有类型。
- en: You can read about the field tags that JSON supports in the `encoding/json`
    GoDoc, located under `Marshal()` ([https://pkg.go.dev/encoding/json#Marshal](https://pkg.go.dev/encoding/json#Marshal)).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `encoding/json` GoDoc 中阅读 JSON 支持的字段标签，位于 `Marshal()` 下 ([https://pkg.go.dev/encoding/json#Marshal](https://pkg.go.dev/encoding/json#Marshal))。
- en: The JSON package also includes `MarshalIndent()`, which can be used to output
    more readable JSON with line separators between the fields and indentions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 包还包括 `MarshalIndent()`，它可以用来输出更易读的 JSON，其中字段之间有行分隔符和缩进。
- en: 'Decoding data into a `struct` type, such as `Record` earlier, can be done as
    follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据解码为 `struct` 类型（例如前面的 `Record`）可以如下进行：
- en: '[PRE16]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This transforms text that represents the JSON into a `Record` type stored in
    the `rec` variable. You can find the runnable code at [https://play.golang.org/p/DD8TrKgTUwE](https://play.golang.org/p/DD8TrKgTUwE).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将表示 JSON 的文本转换为存储在 `rec` 变量中的 `Record` 类型。你可以在 [https://play.golang.org/p/DD8TrKgTUwE](https://play.golang.org/p/DD8TrKgTUwE)
    找到可运行的代码。
- en: Marshaling and unmarshaling large messages
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 序列化和反序列化大型消息
- en: Sometimes, we might receive a stream of JSON messages or a file that contains
    a list of JSON messages.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能会收到包含 JSON 消息列表的 JSON 消息流或文件。
- en: 'Go provides `json.Decoder` to handle a series of messages. Here is an example
    borrowed from the GoDoc, where each message is separated by a carriage return:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了 `json.Decoder` 来处理一系列消息。以下是借自 GoDoc 的示例，其中每条消息由回车符分隔：
- en: '[PRE17]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can view this running code at [https://play.golang.org/p/kqmSvfdK4EG](https://play.golang.org/p/kqmSvfdK4EG).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://play.golang.org/p/kqmSvfdK4EG](https://play.golang.org/p/kqmSvfdK4EG)
    查看此运行中的代码。
- en: 'This example does the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子做了以下操作：
- en: It defines a `Message` struct.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了一个 `Message` 结构体。
- en: It wraps the `jsonStream` raw output in an `io.Reader` via `strings.NewReader()`.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过 `strings.NewReader()` 将 `jsonStream` 原始输出包装在 `io.Reader` 中。
- en: It starts a goroutine that decodes the messages as they are read and puts them
    on a channel.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启动了一个 goroutine，解码消息并将其放入通道中。
- en: It reads all messages that are sent until the output channel is closed.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它读取所有发送的消息，直到输出通道被关闭。
- en: It prints out any errors that are encountered.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它打印出遇到的任何错误。
- en: Sometimes, this format of streaming will have brackets,`[]`, around the messages
    and use commas as separators between the entries.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这种流格式会在消息周围加上括号 `[]`，并使用逗号作为条目之间的分隔符。
- en: 'In this case, we can utilize another feature of the decoder, `dec.Token()`,
    to remove them safely:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以利用解码器的另一个特性，`dec.Token()`，来安全地移除它们：
- en: '[PRE18]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can view this running code at [https://play.golang.org/p/_PrUVUy4zRv](https://play.golang.org/p/_PrUVUy4zRv).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://play.golang.org/p/_PrUVUy4zRv](https://play.golang.org/p/_PrUVUy4zRv)
    查看此运行中的代码。
- en: This code works in the same way, except it removes the outer brackets and requires
    a comma-delimited list instead.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码以相同的方式工作，只是它移除了外括号，并且要求使用逗号分隔的列表。
- en: 'Encoding data in a stream is very similar to decoding. We can write JSON messages
    into `io.Writer` to output to a stream. Here''s an example:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在流中编码数据与解码非常相似。我们可以将 JSON 消息写入 `io.Writer`，以输出到流。以下是一个示例：
- en: '[PRE19]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can see this code running at [https://play.golang.org/p/ELICEC4lcax](https://play.golang.org/p/ELICEC4lcax).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://play.golang.org/p/ELICEC4lcax](https://play.golang.org/p/ELICEC4lcax)
    查看这段代码的运行情况。
- en: 'This code does the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用如下：
- en: It reads from a `channel` of `Message`.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从 `Message` 类型的 `channel` 中读取数据。
- en: It writes to an `io.Writer`.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它写入 `io.Writer`。
- en: It returns a channel that signals when the encoder is done processing.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回一个信号通道，表示编码器完成处理。
- en: If an error is returned, it means that the encoder had a problem.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果返回了错误，意味着编码器遇到了问题。
- en: This outputs the JSON as separated values without brackets.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 JSON 输出为分隔的值，不带括号。
- en: JSON final thoughts
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 的最终思考
- en: The `encoding/json` package has support for other methods of decoding that are
    not covered here. You can mix `map[string]interace{}` into your `struct` types
    and vice versa, or you can decode each field and value individually.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`encoding/json` 包支持其他解码方法，这些方法在这里未涉及。你可以将 `map[string]interface{}` 混合到 `struct`
    类型中，反之亦然，或者你可以逐个解码每个字段和数值。'
- en: However, the best use cases are those that are straightforward `struct` types
    as a single value or stream of values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最佳的使用场景是那些直接的 `struct` 类型，作为单个值或值流。
- en: This is why `encoding/json` is my first choice when encoding or decoding JSON
    values. It is not the fastest method, but it is the most flexible.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 `encoding/json` 是我在编码或解码 JSON 值时的首选方法。它不是最快的，但它是最灵活的。
- en: 'There are other third-party libraries that can increase your throughput while
    sacrificing some flexibility. Here is just a small list of packages that you might
    want to consider:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他第三方库可以提高吞吐量，但会牺牲一些灵活性。这里列出了一些你可能想考虑的包：
- en: '[https://github.com/francoispqt/gojay](https://github.com/francoispqt/gojay)'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/francoispqt/gojay](https://github.com/francoispqt/gojay)'
- en: '[https://github.com/goccy/go-json](https://github.com/goccy/go-json)'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/goccy/go-json](https://github.com/goccy/go-json)'
- en: '[https://pkg.go.dev/github.com/json-iterator/go](https://pkg.go.dev/github.com/json-iterator/go)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pkg.go.dev/github.com/json-iterator/go](https://pkg.go.dev/github.com/json-iterator/go)'
- en: '[https://pkg.go.dev/github.com/valyala/fastjson](https://pkg.go.dev/github.com/valyala/fastjson)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pkg.go.dev/github.com/valyala/fastjson](https://pkg.go.dev/github.com/valyala/fastjson)'
- en: YAML encoding
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YAML 编码
- en: YAML (yet another markup language/YAML Ain't Markup Language) is a language
    that is commonly used to write configurations.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: YAML（另一个标记语言/YAML 不等于标记语言）是一种常用于编写配置的语言。
- en: YAML is the default language of services such as Kubernetes to hold configurations,
    and as a DevOps engineer, you are likely to come across it in a variety of applications.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 是 Kubernetes 等服务的默认语言，用于保存配置，作为 DevOps 工程师，你很可能会在各种应用中遇到它。
- en: 'YAML has a few advantages over JSON for use in configurations:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 相对于 JSON 在配置使用中有一些优势：
- en: Support for comments
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持注释
- en: More flexible for humans, such as unquoted strings and quoted strings
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对人类更灵活，如不带引号的字符串和带引号的字符串
- en: Multiline strings
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行字符串
- en: Anchors and references to avoid repetition of the same text data
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锚点和引用来避免重复相同的文本数据
- en: 'YAML is often cited as having the following flaws:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 经常被认为有以下缺点：
- en: It is schemaless.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是无模式的。
- en: The standard is large and some features are confusing.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范很庞大，某些功能可能令人困惑。
- en: Large files can have indention errors that go unnoticed.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大文件可能会出现缩进错误而未被注意到。
- en: Implementations in some languages can accidentally execute code embedded in
    YAML. This can lead to a few security patches in software projects.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些语言中的实现可能会意外执行嵌入在 YAML 中的代码。这可能会导致软件项目中的一些安全补丁。
- en: Go does not have support in the standard library, but it has a third-party library
    that has become the de facto package for YAML serialization, called `go-yaml`
    (https://github.com/go-yaml/yaml).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Go 标准库并不原生支持 YAML，但它有一个第三方库，已经成为 YAML 序列化的事实标准包，名为 `go-yaml` ([https://github.com/go-yaml/yaml](https://github.com/go-yaml/yaml))。
- en: Next, let's discuss how we can read these YAML files to read our configurations.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论如何读取这些 YAML 文件来读取我们的配置。
- en: Marshaling and unmarshaling to maps
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对映射的序列化和反序列化
- en: YAML, like JSON, is schemaless and suffers from the same drawbacks. However,
    unlike JSON, YAML is intended to represent a configuration, so we don't have the
    same need to stream content.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 和 JSON 一样是无模式的，并且有相同的缺点。然而，与 JSON 不同的是，YAML 旨在表示配置，因此我们不需要像处理 JSON 那样去流式处理内容。
- en: For YAML, the general use case would entail encoding/decoding to a `struct`
    type instead of a `map`. However, if you have a need for message discovery, YAML
    can handle a `map` decode in the same way that we can handle it for JSON.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 YAML，一般的使用情况将涉及编码/解码为 `struct` 类型而不是 `map`。然而，如果您需要消息发现，YAML 可以像我们处理 JSON
    一样处理 `map` 解码。
- en: 'Let''s look at an example of unmarshaling a file into a `map`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个将文件解组为 `map` 的示例：
- en: '[PRE20]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding example does the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例做了以下几件事情：
- en: It creates a `map` called `data` to store our YAML content.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个名为 `data` 的 `map` 来存储我们的 YAML 内容。
- en: It unmarshals the raw bytes representing the YAML into `data`.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将表示 YAML 的原始字节解组为 `data`。
- en: It looks up the `user` key in `data`.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它查找 `data` 中的 `user` 键。
- en: If `user` does not exist, we return an error.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `user` 不存在，则返回错误。
- en: For a more complete example, please refer to [https://play.golang.org/p/wkHkmu47e6V](https://play.golang.org/p/wkHkmu47e6V).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看更完整的示例，请参阅 [https://play.golang.org/p/wkHkmu47e6V](https://play.golang.org/p/wkHkmu47e6V)。
- en: 'Marshalling a `map` into YAML is simple:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `map` 编组为 YAML 是简单的：
- en: '[PRE21]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, `yaml.Marshal()`will read our `map` and output valid YAML for the contents.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`yaml.Marshal()` 将读取我们的 `map` 并为其内容输出有效的 YAML。
- en: Marshaling and unmarshaling to structs
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编组和解组为结构体
- en: The `struct` serialization is the preferred way to handle YAML. As YAML is a
    configuration language, programs must know what fields are available ahead of
    time to set program parameters.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct` 序列化是处理 YAML 的首选方式。由于 YAML 是一种配置语言，程序必须预先知道可用的字段以设置程序参数。'
- en: 'YAML serialization works in a similar way to JSON serialization, and you will
    find that similarity across most data serialization packages:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: YAML 序列化的工作方式与 JSON 序列化类似，您会在大多数数据序列化包中找到这种相似性：
- en: '[PRE22]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can see this running code at [https://play.golang.org/p/SvJHLKBsdUP](https://play.golang.org/p/SvJHLKBsdUP).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://play.golang.org/p/SvJHLKBsdUP](https://play.golang.org/p/SvJHLKBsdUP)
    上看到这段正在运行的代码。
- en: 'This outputs the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE23]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding code does the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码做了以下几件事情：
- en: It creates a top-level configuration called `Config`.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个名为 `Config` 的顶级配置。
- en: It creates a list of sub-messages called `Job`.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个名为 `Job` 的子消息列表。
- en: It marshals an example into the text representation.
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将示例编组为文本表示。
- en: 'Unmarshaling is just as easy:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 解组同样简单：
- en: '[PRE24]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code does the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码做了以下几件事情：
- en: It takes a YAML config that is represented by data.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受由数据表示的 YAML 配置。
- en: It converts it into the `Config` type.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将其转换为 `Config` 类型。
- en: It prints out contained `Job` information.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它打印出包含的 `Job` 信息。
- en: It ignores the `whatever` field.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它忽略了 `whatever` 字段。
- en: This code will ignore the unknown `whatever` field. However, in many cases,
    you do not want to ignore a field that could potentially be misspelled. In those
    cases, we can use `UnmarshalStrict()`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将忽略未知的 `whatever` 字段。然而，在许多情况下，您不希望忽略可能拼写错误的字段。在这些情况下，我们可以使用 `UnmarshalStrict()`。
- en: 'That would cause this code to fail with the following message:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致此代码失败，并显示以下消息：
- en: '[PRE25]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When using `UnmarshalStrict()`, you must add new field support to your programs
    and deploy them before adding them to your configs, or you will cause old binaries
    to fail.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UnmarshalStrict()` 时，您必须在将其添加到配置文件之前将新字段支持到您的程序中并部署它们，否则会导致旧的二进制文件失败。
- en: YAML final thoughts
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: YAML 最终思考
- en: The `github.com/go-yaml/yaml` package has support for other methods of serialization
    that we are not going to cover here. One that is used most often is decoding into
    a `yaml.Node` object in order to preserve comments, then changing the content
    and writing the configuration back out. However, this is relatively uncommon.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/go-yaml/yaml` 包支持其他我们这里不会涵盖的序列化方法。其中最常用的一种是解码为 `yaml.Node` 对象，以保留注释，然后更改内容并重新写入配置。然而，这相对不常见。'
- en: In this section, you have learned how to use JSON and YAML to read and write
    data in their respective data formats. In the next section, we will look at how
    to interact with SQL data sources that are used to commonly store data.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经学会如何使用 JSON 和 YAML 读取和写入它们各自的数据格式。在下一节中，我们将探讨如何与常用于存储数据的 SQL 数据源进行交互。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This also ends our chapter on using common data formats. We have covered how
    to read and write with CSV files and Excel reports. Additionally, we have learned
    how to encode and decode data in JSON and YAML formats. This chapter has shown
    how we can decode data in streams while reinforcing ways to concurrently read
    and use data with goroutines.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这也标志着我们关于使用常见数据格式的章节结束。我们已经涵盖了如何读取和写入CSV文件以及Excel报告。此外，我们还学习了如何在JSON和YAML格式中进行数据编码和解码。本章节展示了如何在流中解码数据，同时强化了使用goroutine并发读取和使用数据的方法。
- en: Your newly acquired skills for JSON will be immediately useful in our next chapter.
    In that chapter, we will look at how to connect to SQL databases and interact
    with RPC services. As REST RPC services and databases such as Postgres can use
    JSON, this skill will come in handy.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚学到的JSON技能将在我们下一章立即派上用场。在那一章中，我们将学习如何连接SQL数据库并与RPC服务进行交互。由于REST RPC服务和像Postgres这样的数据库可以使用JSON，这项技能将非常有用。
- en: So, let's jump in!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们开始吧！
