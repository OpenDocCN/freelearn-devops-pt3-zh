- en: <st c="0">6</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">6</st>
- en: <st c="2">Build for Developers and Their Self-Service</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">为开发人员及其自助服务构建</st>
- en: <st c="45">A platform without accessible features is not a platform.</st> <st
    c="104">As a rule, self-service should be included and must improve accessibility
    to add value.</st> <st c="192">In the process of building platforms, there is
    often no distinction between infrastructure and application layers.</st> <st c="307">The
    integration of</st> **<st c="326">Internal Developer Portals</st>** <st c="352">(</st>**<st
    c="354">IDPs</st>**<st c="358">) adds new complexity to this, addressing some
    demands</st> <st c="413">while leaving others unanswered.</st> <st c="447">It
    is important to bring the community into your platform and be open to</st> <st
    c="520">their contributions.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45">没有可访问功能的平台不是一个平台。</st> <st c="104">作为规则，自助服务应该包含在内，并且必须提高可访问性，以增加价值。</st>
    <st c="192">在构建平台的过程中，通常没有区分基础设施层和应用层。</st> <st c="307">内部开发者门户（</st>**<st c="326">IDPs</st>**<st
    c="352">）的集成为此带来了新的复杂性，它解决了一些需求</st> <st c="413">同时也留下了一些未解答的问题。</st> <st c="447">将社区引入你的平台并对他们的贡献持开放态度是很重要的。</st>
- en: <st c="540">In this chapter, we will review some concepts and share some ideas
    for best practices.</st> <st c="628">By the end of the chapter, you should understand
    how to approach the building of a platform that is resilient, flexible, and meets
    your users where</st> <st c="776">they are.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="540">在本章中，我们将回顾一些概念，并分享一些最佳实践的思路。</st> <st c="628">到本章结束时，你应该了解如何构建一个具有韧性、灵活性并能够满足用户需求的平台。</st>
    <st c="776">他们所处的位置。</st>
- en: <st c="785">In this chapter, we’ll cover the following</st> <st c="829">main
    topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="785">在本章中，我们将涵盖以下</st> <st c="829">主要主题：</st>
- en: <st c="841">Software versus platform development – avoiding</st> <st c="890">a
    mix</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="841">软件开发与平台开发——避免</st> <st c="890">混淆</st>
- en: <st c="895">Reducing</st> <st c="905">cognitive load</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="895">减少</st> <st c="905">认知负荷</st>
- en: <st c="919">Self-service</st> <st c="933">developer portals</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="919">自助服务</st> <st c="933">开发者门户</st>
- en: <st c="950">Land, expand, and integrate</st> <st c="979">your IDP</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="950">落地、扩展和集成</st> <st c="979">你的IDP</st>
- en: <st c="987">Architectural considerations for observability in</st> <st c="1038">a
    platform</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="987">平台可观察性的架构考虑</st> <st c="1038">在平台中</st>
- en: <st c="1048">Open your platform for community</st> <st c="1082">and collaboration</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1048">为社区开放你的平台</st> <st c="1082">并促进合作</st>
- en: <st c="1099">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1099">技术要求</st>
- en: <st c="1122">In this chapter, there will be some technical examples with</st>
    `<st c="1183">.yaml</st>` <st c="1188">files and commands.</st> <st c="1209">While
    you don’t need to set up a cluster to follow along, doing so may enhance your
    understanding.</st> <st c="1308">We used the following technologies to develop
    our samples</st> <st c="1366">and explanations:</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1122">在本章中，将会有一些技术示例，包括</st> `<st c="1183">.yaml</st>` <st c="1188">文件和命令。</st>
    <st c="1209">虽然你不需要设置集群来跟随本章内容，但如果设置集群，可能会加深你的理解。</st> <st c="1308">我们使用了以下技术来开发我们的示例</st>
    <st c="1366">和解释：</st>
- en: <st c="1383">kind – the version tested was kind</st> `<st c="1419">v0.22.0 go1.20.13</st>`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1383">kind – 测试版本为kind</st> `<st c="1419">v0.22.0 go1.20.13</st>`
- en: <st c="1436">We used this guide to set up a three-worker node</st> <st c="1486">cluster:</st>
    [<st c="1495">https://kind.sigs.k8s.io/docs/user/quick-start/#configuring-your-kind-cluster</st>](https://kind.sigs.k8s.io/docs/user/quick-start/#configuring-your-kind-cluster)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1436">我们使用本指南设置了一个三节点的</st> <st c="1486">集群：</st> [<st c="1495">https://kind.sigs.k8s.io/docs/user/quick-start/#configuring-your-kind-cluster</st>](https://kind.sigs.k8s.io/docs/user/quick-start/#configuring-your-kind-cluster)
- en: <st c="1572">Docker (a Docker Rootless setup</st> <st c="1605">is recommended)</st>
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1572">Docker（建议使用Docker无根设置）</st> <st c="1605">推荐使用</st>
- en: <st c="1620">The</st> `<st c="1625">kubectl</st>` <st c="1632">command-line
    tool</st>
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1620">The</st> `<st c="1625">kubectl</st>` <st c="1632">命令行工具</st>
- en: <st c="1650">A</st> <st c="1653">GitHub repo</st>
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1650">一个</st> <st c="1653">GitHub 仓库</st>
- en: <st c="1664">The code examples can be found inside the</st> `<st c="1707">Chapter06</st>`
    <st c="1716">folder</st> <st c="1724">here:</st> [<st c="1730">https://github.com/PacktPublishing/Platform-Engineering-for-Architects</st>](https://github.com/PacktPublishing/Platform-Engineering-for-Architects)<st
    c="1800">.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1664">代码示例可以在</st> `<st c="1707">Chapter06</st>` <st c="1716">文件夹内找到</st>
    <st c="1724">这里：</st> [<st c="1730">https://github.com/PacktPublishing/Platform-Engineering-for-Architects</st>](https://github.com/PacktPublishing/Platform-Engineering-for-Architects)<st
    c="1800">。</st>
- en: <st c="1801">We’ll do a couple of small tutorials over the course of the chapter.</st>
    <st c="1871">While not every code snippet needs to be run against a Kubernetes
    cluster, it is recommended to set up a local Kind cluster with at least one control
    plane node and three worker nodes to get the full value of the tutorials.</st>
    <st c="2095">The configuration for the Kind cluster can be found in the GitHub
    repo for</st> <st c="2170">the chapter.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1801">在本章中，我们将进行一些小型教程。</st> <st c="1871">尽管并非每个代码片段都需要在Kubernetes集群中运行，但建议设置一个本地的Kind集群，其中至少包含一个控制平面节点和三个工作节点，以便充分体验教程的价值。</st>
    <st c="2095">Kind集群的配置可以在GitHub上的章节仓库中找到。</st>
- en: <st c="2182">Software versus platform development – avoiding a mix</st>
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2182">软件与平台开发——避免混淆</st>
- en: <st c="2236">In our journey toward</st> <st c="2259">platform development, we
    have to disambiguate between this and other forms of</st> <st c="2336">software
    development.</st> <st c="2359">Remember that the purpose of the platform is to
    enable development and operations teams; it is not something that customers directly
    experience, although they do</st> <st c="2521">benefit indirectly.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2236">在我们迈向</st> <st c="2259">平台开发的过程中，我们必须明确区分平台开发和其他形式的</st> <st c="2336">软件开发。</st>
    <st c="2359">请记住，平台的目的是为了使开发和运维团队能够进行开发和运营；它并不是客户直接体验的东西，尽管客户确实</st> <st c="2521">间接受益。</st>
- en: <st c="2540">The value of the platform is the unification of all the tools,
    services, and applications required to build and land an application in front
    of users.</st> <st c="2692">In short, a platform is a series of services used
    by developers to deliver software applications into the hands of end users.</st>
    <st c="2818">You can</st> <st c="2825">consume existing software applications,
    so it’s possible to develop</st> <st c="2893">a platform without writing</st>
    <st c="2921">any code.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2540">平台的价值在于将构建和交付应用程序所需的所有工具、服务和应用程序统一在一起，呈现在用户面前。</st> <st c="2692">简而言之，平台是开发者用来将软件应用程序交付给最终用户的一系列服务。</st>
    <st c="2818">你可以</st> <st c="2825">使用现有的软件应用程序，因此也可以在不编写</st> <st c="2893">任何代码的情况下开发</st>
    <st c="2921">一个平台。</st>
- en: <st c="2930">So, how do you develop a platform, and how do you develop software?</st>
    <st c="2999">Where do they intersect, and where do</st> <st c="3037">they differ?</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2930">那么，如何开发一个平台，如何开发软件呢？</st> <st c="2999">它们在哪些地方交集，在哪些地方不同？</st>
- en: <st c="3049">The platform life cycle versus the software life cycle</st>
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3049">平台生命周期与软件生命周期</st>
- en: <st c="3104">In</st> <st c="3108">many</st> <st c="3113">regards, the life cycle
    of a</st> <st c="3142">platform looks similar to any</st> **<st c="3172">Software
    Development Life</st>** **<st c="3198">Cycle</st>** <st c="3203">(</st>**<st c="3205">SDLC</st>**<st
    c="3209">).</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3104">在</st> <st c="3108">许多</st> <st c="3113">方面，平台的生命周期看起来与任何</st>
    <st c="3142">软件开发生命周期</st> **<st c="3172">类似</st>** **<st c="3198">（SDLC）</st>**
    <st c="3203">(</st>**<st c="3205">SDLC</st>**<st c="3209">)。</st>
- en: '![Figure 6.1: An SDLC](img/B31164_06_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：一个SDLC](img/B31164_06_01.jpg)'
- en: '<st c="3214">Figure 6.1: An SDLC</st>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3214">图6.1：一个SDLC</st>
- en: <st c="3233">In the previous chapters, we covered the benefits of a robust planning
    phase and treating your platform as a product.</st> <st c="3352">And while it’s
    important not to over-engineer the platform during this process, you’ll still
    end up with a system that has a variety of aspects.</st> <st c="3497">Thus, due
    to its relative size and complexity, the release of a platform may not be as simple
    as pressing a button and letting your change propagate through some servers or
    clusters.</st> <st c="3680">This is in no small part due to the number of moving
    pieces you can find within a platform.</st> <st c="3772">For example, creating
    a new integration to deliver a</st> **<st c="3825">Software Bill of Materials</st>**
    <st c="3851">(</st>**<st c="3853">SBOM</st>**<st c="3857">) will be</st> <st c="3867">less
    disruptive to users than adjusting policies within an existing policy engine to
    be</st> <st c="3956">more restrictive.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3233">在前面的章节中，我们讨论了强大规划阶段的好处，并将平台视为产品的处理方式。</st> <st c="3352">虽然在此过程中避免过度设计平台很重要，但你仍然会最终得到一个具有多方面特性的系统。</st>
    <st c="3497">因此，由于平台的相对规模和复杂性，平台的发布可能不像按下按钮并让你的更改在一些服务器或集群中传播那样简单。</st> <st c="3680">这在很大程度上是因为平台内部有大量的动态组件。</st>
    <st c="3772">例如，创建一个新的集成以交付</st> **<st c="3825">软件材料清单</st>** <st c="3851">(</st>**<st
    c="3853">SBOM</st>**<st c="3857">)将比在现有的策略引擎中调整策略以使其</st> <st c="3867">更具限制性对用户造成的干扰更小。</st>
- en: <st c="3973">If we look</st> <st c="3985">at the anatomy of a typical</st> <st
    c="4012">platform and its</st> <st c="4029">user considerations, it will be easier
    to understand how the platform life cycle differs from</st> <st c="4123">a</st>
    <st c="4126">software application.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3973">如果我们看看</st> <st c="3985">一个典型平台的结构及其</st> <st c="4012">用户考量，理解平台生命周期如何与</st>
    <st c="4123">软件应用程序</st> <st c="4126">有所不同会更加容易。</st>
- en: '![Figure 6.2: An example of IDP components and functional areas](img/B31164_06_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：IDP组件和功能区域示例](img/B31164_06_02.jpg)'
- en: '<st c="4360">Figure 6.2: An example of IDP components and functional areas</st>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4360">图6.2：IDP组件和功能区域示例</st>
- en: <st c="4421">In this platform example, pre-production is on the left, and the
    production environment where customer-facing applications will be deployed is
    on the right (</st>**<st c="4579">Application Landing Zone</st>**<st c="4604">).</st>
    <st c="4608">Whether a single Kubernetes cluster, multi-cluster, or multi-architecture,
    the platform is a cohesive unit that encapsulates these two paradigms.</st> <st
    c="4754">The platform should abstract the architecture away from users, allowing
    them to</st> <st c="4834">work independently.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4421">在这个平台示例中，预生产环境位于左侧，生产环境则位于右侧，客户面向的应用程序将在其中部署（</st>**<st c="4579">应用程序着陆区</st>**<st
    c="4604">）。</st> <st c="4608">无论是单一Kubernetes集群、多集群还是多架构，平台是一个紧密结合的整体，包含这两种范式。</st>
    <st c="4754">平台应该将架构从用户中抽象出来，让他们能够</st> <st c="4834">独立工作。</st>
- en: <st c="4853">Here, DevOps engineers care about how the application is built
    and released.</st> <st c="4931">Things such as progressive rollouts, DORA</st>
    <st c="4973">metrics (</st>[<st c="4982">https://dora.dev/</st>](https://dora.dev/)<st
    c="5000">), and other DevOps practices are what the platform may be expected to
    support.</st> <st c="5081">Similarly, if your organization is quite far along
    in its cloud-native journey, the data surrounding the operations of the production
    application would be something site reliability engineers would concern themselves
    with.</st> <st c="5304">And there are other relevant considerations, such as security
    checks, infrastructure as code, and docs.</st> <st c="5408">Each aspect of these
    can be controlled individually within a platform and made available to all or
    a subset of</st> <st c="5519">the personas.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4853">在这里，DevOps工程师关心的是应用程序如何构建和发布。</st> <st c="4931">诸如渐进式发布、DORA</st>
    <st c="4973">指标（</st>[<st c="4982">https://dora.dev/</st>](https://dora.dev/)<st
    c="5000">）以及其他DevOps实践是平台可能需要支持的内容。</st> <st c="5081">同样，如果您的组织在云原生之路上已经走得很远，那么与生产应用程序操作相关的数据将是站点可靠性工程师关心的内容。</st>
    <st c="5304">还有其他相关的考量因素，比如安全检查、基础设施即代码以及文档。</st> <st c="5408">这些方面的每一项都可以在平台内单独控制，并对所有或部分</st>
    <st c="5519">角色可用。</st>
- en: '*<st c="5532">Figure 6</st>**<st c="5541">.2</st>* <st c="5543">also assumes
    there are personas working in dedicated roles; however, if there’s no dedicated
    DevOps team, it’s likely that developers and quality engineering would share responsibilities
    in that space.</st> <st c="5746">The overall concept should still apply even to
    small organizations, where one person may have a stake in multiple personas’ user
    stories.</st> <st c="5884">Even the theoretical division of the personas should
    assist when undertaking the life cycle of</st> <st c="5979">a platform.</st>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="5532">图6</st>**<st c="5541">.2</st>* <st c="5543">假设有专门的角色在工作；然而，如果没有专门的DevOps团队，那么开发人员和质量工程师很可能会在这方面分担职责。</st>
    <st c="5746">这个整体概念仍然适用于即便是小型组织，在这些组织中，一个人可能需要同时承担多个角色的用户故事。</st> <st c="5884">即使是理论上划分的角色，也应该有助于在进行平台生命周期管理时提供帮助。</st>'
- en: <st c="5990">A platform</st> <st c="6001">is more than just the software; it’s
    also its tuning</st> <st c="6055">in concert with the workloads that help make
    sure it’s performant for its users.</st> <st c="6136">While the needs of the users
    do influence the size, scope, and functionality of the platform, it should be
    designed as agnostically as possible so that one user’s golden path isn’t prioritized</st>
    <st c="6329">over another.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5990">平台</st> <st c="6001">不仅仅是软件；它还是与工作负载协同调优的过程，以确保其对用户的性能。</st> <st
    c="6136">虽然用户需求确实会影响平台的大小、范围和功能，但它应该尽可能设计得不偏不倚，以确保一个用户的黄金路径不会优先于</st> <st c="6329">另一个用户。</st>
- en: <st c="6342">Reliability versus serviceability</st>
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6342">可靠性与可维护性</st>
- en: <st c="6376">A platform’s</st> **<st c="6390">reliability</st>** <st c="6401">and</st>
    **<st c="6406">serviceability</st>** <st c="6420">are the</st> <st c="6428">largest
    factors of its usability by developers in an</st> <st c="6481">organization.</st>
    <st c="6496">But what do each of these things</st> <st c="6529">really mean?</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6376">一个平台的</st> **<st c="6390">可靠性</st>** <st c="6401">和</st> **<st
    c="6406">可服务性</st>** <st c="6420">是开发者在</st> <st c="6428">组织中使用该平台的最大因素。</st>
    <st c="6481">但这些因素到底意味着什么呢？</st> <st c="6496">这些概念各自到底意味着什么呢？</st>
- en: <st c="6541">At its core, reliability</st> <st c="6567">encompasses the overall
    availability of a platform and the</st> <st c="6626">ability of a user to successfully
    interact with it.</st> <st c="6678">Reliability in a platform should assume that
    multi-tenancy (multiple users who are fully isolated from each other) has been
    implemented in the platform.</st> <st c="6831">The reason for this is that the
    concept can still be applied where it’s not required, but your platform still
    supports multiple users with individual needs.</st> <st c="6988">While multi-tenancy
    isn’t an intuitive approach for an internal tool, highly regulated teams may prefer
    to work in an isolated environment to ensure that there’s no risk of security
    and compliance violations.</st> <st c="7197">Even if all your users are internal
    customers, they still shouldn’t be exposed to or impacted by other</st> <st c="7300">user
    workloads.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6541">从本质上讲，可靠性</st> <st c="6567">涵盖了平台的整体可用性以及用户与平台成功互动的能力。</st> <st
    c="6626">平台的可靠性应假设已经在平台中实现了多租户（多个用户之间完全隔离）。</st> <st c="6678">这是因为这个概念仍然可以在不需要的地方应用，但你的平台仍然支持具有各自需求的多个用户。</st>
    <st c="6831">尽管多租户对于内部工具而言并不是直观的做法，但高度监管的团队可能更愿意在一个隔离的环境中工作，以确保没有安全性和合规性违规的风险。</st>
    <st c="6988">即使所有用户都是内部客户，他们仍然不应该暴露于或受到其他</st> <st c="7300">用户工作负载的影响。</st>
- en: <st c="7315">To attain the reliability of a platform, you should leverage tuning
    and a policy that helps you ensure workload isolation and maintain the integrity
    of a platform.</st> <st c="7480">In a Kubernetes environment, a node may be a
    virtual machine or real hardware.</st> <st c="7559">As with any machine, each
    node has a set amount of memory and CPU allocated to it.</st> <st c="7642">However,
    unlike your standard virtual machine, when you overcommit the CPU, a node can
    use the CPU that would otherwise belong to a different node.</st> <st c="7790">This
    is not true of memory, although both can be oversubscribed, and</st> **<st c="7859">Out
    of Memory</st>** <st c="7872">(</st>**<st c="7874">OOM</st>**<st c="7877">) will</st>
    <st c="7885">cause a node to reboot.</st> <st c="7909">This allows the overall
    resource requirements to be kept lower by guaranteeing a resource will be able
    to utilize CPU cycles if they’re available; however, on the other hand, a bad
    process that eats CPU due to a software error may never return the CPU cycles
    to the node pool for availability.</st> <st c="8203">Other factors, such as Pod
    priority, requests, limits, and Pod disruption budgets, can influence how a scheduler
    will determine where and how to schedule Pods, and whether or not the kubelet
    will evict an existing workload.</st> <st c="8427">For more information on these
    topics, it’s important to review the Kubernetes documentation regularly as new
    features and best practices emerge and the project continues to</st> <st c="8600">develop
    (</st>[<st c="8609">https://kubernetes.io/docs/home/</st>](https://kubernetes.io/docs/home/)<st
    c="8642">).</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7315">为了实现平台的可靠性，你应该利用调优和策略，帮助你确保工作负载隔离，并保持平台的完整性。</st> <st c="7480">在
    Kubernetes 环境中，一个节点可以是虚拟机或真实硬件。</st> <st c="7559">与任何机器一样，每个节点都有分配给它的固定内存和 CPU。</st>
    <st c="7642">然而，与标准虚拟机不同，当你超额分配 CPU 时，节点可以使用原本属于其他节点的 CPU。</st> <st c="7790">这一点对内存不适用，虽然内存也可以被过度订阅，且</st>
    **<st c="7859">内存不足</st>** <st c="7872">(</st>**<st c="7874">OOM</st>**<st c="7877">)
    会</st> <st c="7885">导致节点重启。</st> <st c="7909">这样可以通过保证在 CPU 周期可用时，资源能够使用这些 CPU
    周期，从而降低整体资源需求；然而，另一方面，由于软件错误导致的 CPU 占用过多的恶劣进程，可能永远无法将 CPU 周期返回给节点池，以便再次使用。</st>
    <st c="8203">其他因素，例如 Pod 优先级、请求、限制和 Pod 中断预算，会影响调度器如何决定在哪个地方以及如何调度 Pods，是否会驱逐已有的工作负载。</st>
    <st c="8427">有关这些主题的更多信息，重要的是定期查看 Kubernetes 文档，因为新特性和最佳实践不断涌现，而该项目也在持续</st> <st
    c="8600">发展（</st>[<st c="8609">https://kubernetes.io/docs/home/</st>](https://kubernetes.io/docs/home/)<st
    c="8642">）。</st>
- en: <st c="8645">While the final</st> <st c="8661">tuning and orchestration of these
    settings will need to</st> <st c="8717">be determined by the platform engineering
    team, we can generally recommend that this tuning should be part of your planning
    phase.</st> <st c="8849">You should reevaluate continuously over the life cycle
    of</st> <st c="8907">a platform.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8645">虽然这些设置的最终调优和编排需要</st> <st c="8661">由平台工程团队来决定，但我们通常建议，这些调优应该成为规划阶段的一部分。</st>
    <st c="8717">在平台生命周期内，你应该持续不断地进行评估。</st> <st c="8849">你应该在平台的生命周期中持续重新评估。</st>
    <st c="8907">平台。</st>
- en: <st c="8918">The serviceabil</st><st c="8934">ity of a platform is similar to
    reliability, except serviceability looks more at what the golden paths are for
    the users who need to leverage the platform.</st> <st c="9091">For a platform
    to have serviceability, it needs to meet the user’s demands.</st> <st c="9167">Unlike
    self-service, which is a user’s ability to reasonably accomplish all reasonable
    actions without reliance on a governing team, serviceability looks holistically
    at all the user needs and meets them where they are.</st> <st c="9387">Reliability
    could be considered a measurement of serviceability, but the goal of meeting user
    needs is more all-encompassing than just reliability.</st> <st c="9535">Serviceability
    is at the core of a product minds</st><st c="9583">et for</st> <st c="9591">the
    platform.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8918">平台的可服务性</st><st c="8934">类似于可靠性，不同之处在于可服务性更多关注的是需要利用平台的用户的黄金路径。</st>
    <st c="9091">为了使平台具有可服务性，它需要满足用户的需求。</st> <st c="9167">与自助服务不同，自助服务是用户在不依赖管理团队的情况下，能够合理完成所有合理操作的能力，可服务性则从整体上看待所有用户需求，并在用户所在的位置满足这些需求。</st>
    <st c="9387">可靠性可以视为可服务性的衡量标准，但满足用户需求的目标比单纯的可靠性更加全面。</st> <st c="9535">可服务性是平台产品思维的核心</st><st
    c="9583">，</st> <st c="9591">平台的核心。</st>
- en: <st c="9604">Similar to a critical user journey, the</st> <st c="9645">golden
    path maps the more critical use case for a user of a system.</st> <st c="9713">In
    general, this is the series of steps the user can take and expect the</st> <st
    c="9786">desired outcome.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9604">类似于关键用户旅程，</st> <st c="9645">黄金路径映射了系统用户的更关键使用场景。</st> <st c="9713">一般来说，这是用户可以采取的步骤序列，并期望达到</st>
    <st c="9786">预期结果。</st>
- en: <st c="9802">For a developer of an application leveraging an IDP, the golden
    path would be something</st> <st c="9891">like this:</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9802">对于利用IDP的应用程序开发者来说，黄金路径可能是这样的：</st>
- en: '![Figure 6.3: An example of a golden path using an IDP](img/B31164_06_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：使用IDP的黄金路径示例](img/B31164_06_03.jpg)'
- en: '<st c="9973">Figure 6.3: An example of a golden path using an IDP</st>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9973">图6.3：使用IDP的黄金路径示例</st>
- en: <st c="10025">A</st> <st c="10028">developer pushes a commit, and then the</st>
    **<st c="10068">Continuous Integration</st>** <st c="10090">(</st>**<st c="10092">CI</st>**<st
    c="10094">) system</st> <st c="10103">does its magic.</st> <st c="10120">The application
    or an upgrade to the application</st> <st c="10168">lands in production, and then
    it sends data back to logging and observability tools for the developer to leverage,
    enabling them to gain insights into their application’s production state</st>
    <st c="10357">and performance.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10025">开发者推送提交后，</st> **<st c="10068">持续集成</st>** <st c="10090">(</st>**<st
    c="10092">CI</st>**<st c="10094">) 系统</st> <st c="10103">自动执行其魔法。</st> <st c="10120">应用程序或应用程序的升级</st>
    <st c="10168">进入生产环境后，它会将数据发送回日志记录和可观察性工具，供开发者利用，从而使他们能够获得关于应用程序生产状态</st> <st
    c="10357">和性能的洞察。</st>
- en: <st c="10373">The conclusion</st>
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10373">结论</st>
- en: <st c="10388">With this in mind, we can now look at where the SDLC diverges
    for platform engineering as compared to the development of an application that
    a platform would run.</st> <st c="10552">Along our golden path within the platform,
    rather than one service or opaque system that does it all, our users interact
    with a system comprised of different services.</st> <st c="10720">Some or all
    of these services may be homegrown, but it’s more likely that these services are
    a mix of internal tooling and open source technologies working in concert to create
    the entity known as</st> *<st c="10917">the platform</st>*<st c="10929">.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10388">考虑到这一点，我们现在可以看一下，平台工程的SDLC与一个平台运行的应用程序开发之间的分歧。</st> <st c="10552">在平台的黄金路径中，用户不再是与一个完成所有工作的服务或不透明系统交互，而是与由多个服务组成的系统交互。</st>
    <st c="10720">这些服务中的一些或全部可能是自家研发的，但更可能是这些服务是内部工具与开源技术的混合，共同协作，构建出我们所说的</st> *<st
    c="10917">平台</st>*<st c="10929">。</st>
- en: <st c="10930">Since a platform is built of components, you can also break down
    your platform’s SDLC on a per-component basis.</st> <st c="11043">However, as
    with any system, you must watch out for interdependencies that would require multiple
    components to be released</st> <st c="11167">in concert.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10930">由于平台由多个组件构成，你还可以基于每个组件来拆解平台的SDLC。</st> <st c="11043">然而，与任何系统一样，你必须警惕那些需要多个组件一起发布的相互依赖关系。</st>
    <st c="11167">这些组件必须协调发布。</st>
- en: <st c="11178">Your developers will need the ability to leverage these systems
    both transparently and opaquely.</st> <st c="11276">This means that while the
    use of each tool within the platform should be baked into an automated workflow
    for them, they should be able to see what’s happening and debug issues within
    the individual pieces as necessary.</st> <st c="11496">For example, if a Tekton
    CI job fails, the application developer in our example needs to be able to see
    the failed job and gain insights into what failed within the job, enabling them
    to either fix the application or the</st> <st c="11717">CI job.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11178">你的开发人员需要能够透明和不透明地使用这些系统。</st> <st c="11276">这意味着，虽然平台中的每个工具的使用应该自动化融入工作流程中，但开发人员应能够看到发生了什么，并在必要时调试各个部分的问题。</st>
    <st c="11496">例如，如果一个Tekton CI任务失败，我们示例中的应用开发人员需要能够看到失败的任务，并深入了解任务失败的原因，从而帮助他们修复应用或CI任务。</st>
    <st c="11717">CI任务。</st>
- en: <st c="11724">Understanding how to effectively manage the life cycle of a platform
    while minimizing user impact can be a case of drinking your own champagne, meaning
    the platform team uses the same processes and technologies they make available
    to users.</st> <st c="11966">The building and life cycle management of a platform
    can leverage the same DevOps tools;</st> *<st c="12055">star (*) as code</st>*
    <st c="12071">patterns such as</st> *<st c="12089">docs as code</st>*<st c="12101">,</st>
    *<st c="12103">infrastructure as code</st>*<st c="12125">, and</st> *<st c="12131">configuration
    as code</st>* <st c="12152">all factor into the build and release of the platform.</st>
    <st c="12208">However, unlike the software application, for end users of a platform
    these declarative pieces will have the highest impact on them, especially when
    compared to something such as a banki</st><st c="12394">ng application for which
    all of those DevOp</st><st c="12438">s aspects are completely black-boxed for
    the end users.</st> <st c="12495">The identity of the customers greatly impacts
    the weight of one facet of software engineering over the other and, thus, differentiates
    between</st> *<st c="12638">software and</st>* *<st c="12651">platform development</st>*<st
    c="12671">.</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11724">了解如何有效管理平台生命周期，同时尽量减少对用户的影响，可能就像是在“喝自家酿的香槟”，意味着平台团队使用他们提供给用户的相同流程和技术。</st>
    <st c="11966">平台的构建和生命周期管理可以利用相同的DevOps工具；</st> *<st c="12055">代码即配置（star (*)
    as code）</st>* <st c="12071">等模式，如</st> *<st c="12089">文档即代码（docs as code）</st>*<st
    c="12101">、</st> *<st c="12103">基础设施即代码（infrastructure as code）</st>*<st c="12125">和</st>
    *<st c="12131">配置即代码（configuration as code）</st>* <st c="12152">都对平台的构建和发布有重要影响。</st>
    <st c="12208">然而，与软件应用程序不同，对于平台的最终用户来说，这些声明式的内容对他们的影响最大，尤其是与诸如银行应用等完全封闭的DevOps方面相比，后者对最终用户完全是黑盒处理。</st>
    <st c="12394">这些DevOps</st><st c="12438">方面对于平台最终用户来说完全是黑盒的。</st> <st c="12495">客户的身份会极大影响软件工程的某一方面相对于其他方面的重要性，因此区分了</st>
    *<st c="12638">软件开发和</st>* *<st c="12651">平台开发</st>*<st c="12671">。</st>
- en: <st c="12672">That user-centricity is also paramount to understanding what to
    prioritize within a platform to make it successful.</st> <st c="12789">While the
    users themselves will inform that to a large degree, as we continue through the
    chapter, we will highlight aspects that we think are most important for a</st>
    <st c="12953">successful platform.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12672">以用户为中心的设计同样是理解平台成功所需优先考虑的事项的关键。</st> <st c="12789">虽然用户自身会在很大程度上提供相关信息，但随着本章的推进，我们将重点强调我们认为对成功平台最为重要的方面。</st>
    <st c="12953">成功的平台</st>。
- en: <st c="12973">With this new understanding of the SDLC for your platform, we
    can start to use that knowledge to contextualize what it means to build a platform
    as</st> <st c="13122">a product.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12973">通过对平台的SDLC有了新的理解，我们可以开始利用这些知识来阐明将平台构建为**产品**的意义。</st>
- en: <st c="13132">Reducing cognitive load</st>
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="13122">减少认知负荷</st>
- en: <st c="13156">In</st> [*<st c="13160">Chapter 1</st>*](B31164_01.xhtml#_idTextAnchor014)<st
    c="13169">, we touched on the importance of</st> *<st c="13203">reducing cognitive
    load</st>*<st c="13226">. As technology and systems evolve, they become more complex.</st>
    <st c="13288">The high degree of complexity means that understanding every part
    of a system is a significantly larger mental burden.</st> <st c="13407">The old
    days of monolithic applications on the</st> **<st c="13454">Linux, Apache, MySQL,
    PHP</st>** <st c="13479">(</st>**<st c="13481">LAMP</st>**<st c="13485">) stack</st>
    <st c="13493">are behind us.</st> <st c="13509">Instead, microservices, the cloud,
    virtual networks, and so on have become part and parcel of the day-to-day operations
    of a</st> <st c="13634">software application.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13156">在</st> [*<st c="13160">第1章</st>*](B31164_01.xhtml#_idTextAnchor014)<st
    c="13169">中，我们提到了</st> *<st c="13203">减少认知负担</st>*<st c="13226">的重要性。随着技术和系统的发展，它们变得更加复杂。</st>
    <st c="13288">高度的复杂性意味着理解系统的每个部分将成为更大的心理负担。</st> <st c="13407">曾经的单体应用程序时代已经过去，</st>
    **<st c="13454">Linux, Apache, MySQL, PHP</st>** <st c="13479">(</st>**<st c="13481">LAMP</st>**<st
    c="13485">) 堆栈</st> <st c="13493">已经成为历史。</st> <st c="13509">现在，微服务、云、虚拟网络等已成为软件应用程序日常操作的组成部分。</st>
- en: <st c="13655">With modern software architectures, a full stack software engineer
    no longer needs to understand a server or operating system that application code
    runs on.</st> <st c="13813">The platform takes care of that for them.</st> <st
    c="13855">However, as much as the platform can abstract a lot of the details away,
    a developer still needs to be able to have awareness and insights into the underlying
    technologies in so far as they are relevant to their application.</st> <st c="14080">Therefore,
    the platform must strike the balance by making it easy for the users to get from
    it what they need, without the noise o</st><st c="14210">f what</st> <st c="14218">they
    don’t.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13655">在现代软件架构中，完整栈软件工程师不再需要理解运行应用程序代码的服务器或操作系统。</st> <st c="13813">平台为他们处理了这些问题。</st>
    <st c="13855">然而，尽管平台可以抽象出许多细节，开发人员仍然需要对底层技术有一定的意识和理解，特别是当这些技术与他们的应用程序相关时。</st>
    <st c="14080">因此，平台必须在简化用户操作和提供所需信息之间找到平衡，避免提供那些不相关的“噪音”。</st>
- en: <st c="14229">If we compare and</st> <st c="14247">contrast the priorities of
    the</st> <st c="14279">personas, we can contextualize the scope of the platform
    as it applies to</st> <st c="14353">those users.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14229">如果我们对比</st> <st c="14247">和对照不同角色的优先级，</st> <st c="14279">我们可以将平台的范围与这些用户的需求进行对照。</st>
- en: '| **<st c="14365">Platform team</st>** | **<st c="14379">Both</st>** | **<st
    c="14384">Development team</st>** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="14365">平台团队</st>** | **<st c="14379">双方</st>** | **<st c="14384">开发团队</st>**
    |'
- en: '| <st c="14401">Tenant apps</st> | <st c="14413">Platform availability</st>
    | <st c="14435">Application availability</st> |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14401">租户应用程序</st> | <st c="14413">平台可用性</st> | <st c="14435">应用程序可用性</st>
    |'
- en: '| <st c="14460">User management</st> | <st c="14476">Team RBAC</st> | <st c="14486">Application
    SLO/SLI</st> |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14460">用户管理</st> | <st c="14476">团队RBAC</st> | <st c="14486">应用程序SLO/SLI</st>
    |'
- en: '| <st c="14506">User authentication</st> | <st c="14526">Security</st> | <st
    c="14535">Pass/fail</st> <st c="14546">CI tests</st> |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14506">用户认证</st> | <st c="14526">安全</st> | <st c="14535">通过/失败</st>
    <st c="14546">CI测试</st> |'
- en: '| <st c="14554">Networking</st> | <st c="14565">Compliance</st> | <st c="14576">CD</st>
    <st c="14580">job success</st> |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14554">网络</st> | <st c="14565">合规性</st> | <st c="14576">CD</st> <st
    c="14580">工作成功</st> |'
- en: '| <st c="14591">Platform SLO/SLI</st> | <st c="14608">Log aggregation</st>
    | <st c="14624">Application upgrades</st> |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14591">平台SLO/SLI</st> | <st c="14608">日志聚合</st> | <st c="14624">应用程序升级</st>
    |'
- en: '| <st c="14645">Platform upgrades</st> | <st c="14663">Error and</st> <st c="14674">exception
    tracking</st> | <st c="14692">Application</st> <st c="14705">resource benchmarking</st>
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14645">平台升级</st> | <st c="14663">错误和</st> <st c="14674">异常追踪</st>
    | <st c="14692">应用程序</st> <st c="14705">资源基准测试</st> |'
- en: '| <st c="14726">Platform scaling</st> | <st c="14743">Policy violation</st>
    |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14726">平台扩展性</st> | <st c="14743">政策违规</st> |  |'
- en: '| <st c="14760">Platform architecture</st> | <st c="14782">Quota consumption</st>
    |  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14760">平台架构</st> | <st c="14782">配额消耗</st> |  |'
- en: '| <st c="14800">Platform serviceability</st> | <st c="14824">Application performance</st>
    |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14800">平台可维护性</st> | <st c="14824">应用程序性能</st> |  |'
- en: '<st c="14848">Table 6.1: Comparing and contrasting developer versus platform
    team priorities</st>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14848">表6.1：对比开发团队与平台团队的优先级</st>
- en: <st c="14927">As you can</st> <st c="14939">see, even with a platform team</st>
    <st c="14969">taking care of so many aspects of how an application is delivered
    to an end user, the development team for the application still has many considerations.</st>
    <st c="15124">The platform can take care of shared considerations, such as security
    and compliance, but it’s not the job of the platform to guarantee that the app
    the development team produces is performant.</st> <st c="15318">You could consider
    your IDP a managed service, which wouldn’t be a bad definition for</st> <st c="15404">the
    product.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14927">正如你所看到的，即使有平台团队</st> <st c="14939">负责许多应用程序交付给最终用户的方面，应用程序的开发团队仍然有许多需要考虑的问题。</st>
    <st c="14969">平台可以处理共享的考虑因素，例如安全性和合规性，但平台的工作并不是保证开发团队生产的应用程序具有良好的性能。</st> <st
    c="15124">你可以将你的IDP视为一种托管服务，这对于</st> <st c="15404">该产品来说并不是一个坏的定义。</st>
- en: <st c="15416">As a managed service seeks to strike the balance between doing
    and enabling, the preceding table becomes the map to building a successful platform.</st>
    <st c="15565">For example, by investing in tooling around observability and reliability,
    a platform can support the development team in managing their considerations,
    while abstracting away everything else it can.</st> <st c="15765">A developer
    who doesn’t have to care how aggregate logs are stored but knows how to access
    them if needed can simplify day-to-day workflows significantly, allowing more
    cycles to be spent on feature development instead of operational overhead.</st>
    <st c="16009">This reduction of cognitive load can lead to fewer context shifts
    for the team and, therefore, fewer mistakes and less stress.</st> <st c="16136">This
    way, an investment in a platform is an investment in the productivity and health
    of the</st> <st c="16229">development team.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15416">作为一种托管服务，旨在实现“做”和“启用”之间的平衡，前面的表格成为了构建成功平台的路线图。</st> <st c="15565">例如，通过在可观察性和可靠性工具方面进行投资，平台可以支持开发团队管理他们的考量，同时抽象掉它能抽象掉的其他一切。</st>
    <st c="15765">一个不必关心聚合日志如何存储的开发人员，但知道如何在需要时访问它们，可以显著简化日常工作流程，从而让更多的精力投入到功能开发中，而不是运营负担。</st>
    <st c="16009">这种认知负荷的减少可以导致团队的上下文切换更少，从而减少错误和压力。</st> <st c="16136">通过这种方式，对平台的投资就是对开发团队生产力和健康的投资。</st>
    <st c="16229">开发团队。</st>
- en: <st c="16246">If we think back to our fictitious company, Financial One ACME,
    we can imagine how much more the cognitive load matters as it undergoes a cloud
    transformation strategy.</st> <st c="16416">Since the company is not building
    everything greenfield, its developers have to maintain legacy systems and architectures
    while also refactoring for the new era.</st> <st c="16578">A platform in support
    of this effort allows the developers to learn less.</st> <st c="16652">They just
    need to know what the platform expects from them as they approach their refactorization
    and</st> <st c="16754">migration strategy.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16246">如果我们回想一下我们虚构的公司，Financial One ACME，我们可以想象在公司进行云转型战略时，认知负荷会变得更加重要。</st>
    <st c="16416">由于公司并不是从零开始构建一切，开发人员不仅要维护遗留系统和架构，还要进行新的时代重构。</st> <st c="16578">支持这一工作的平台可以让开发人员学得更少。</st>
    <st c="16652">他们只需要知道平台在他们进行重构和</st> <st c="16754">迁移战略时对他们的期望。</st>
- en: <st c="16773">A platform’s commitment to the reduction of cognitive load is
    essentially the promise to developers that you will help them to work more efficiently.</st>
    <st c="16924">Fewer context shifts, expedient and direct feedback loops, and ease
    of use all contribute to developer happiness.</st> <st c="17038">Happy developers
    are less stressed co-workers and contribute to a more positive work environment,
    making it a win-win for the development and</st> <st c="17180">platform teams.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16773">平台对减少认知负荷的承诺本质上是向开发人员做出的承诺，即你将帮助他们更高效地工作。</st> <st c="16924">减少上下文切换、迅速直接的反馈循环和易用性，所有这些都有助于提高开发人员的工作满意度。</st>
    <st c="17038">快乐的开发人员是压力更小的同事，有助于创造更加积极的工作环境，这对开发团队和</st> <st c="17180">平台团队来说都是双赢的局面。</st>
- en: <st c="17195">Utilizing a platform while balancing cognitive load</st>
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17195">在平衡认知负荷的同时使用平台</st>
- en: <st c="17247">While so much of a</st> <st c="17267">platform is serving to build
    an application, it must equally serve to operate the application as well.</st>
    <st c="17370">While the platform’s requirements should be well documented and
    easily understood, humans unfortunately are fairly error-prone; as such, it’s
    incumbent on the platform to enforce its norms.</st> <st c="17560">Kubernetes
    fortunately supports this natively to some degree, with admission controllers</st>
    <st c="17649">and</st> **<st c="17653">Role-Based Access Control</st>** <st c="17678">(</st>**<st
    c="17680">RBAC</st>**<st c="17684">), but you can also leverage tooling such as
    policy engines to ensure that workloads or actions that do not meet those norms
    are rejected and an error is given to the user.</st> <st c="17858">The sooner
    that feedback reaches the user, the lower their cognitive load, as they do not
    have to context-shift to respond to</st> <st c="17984">the platform.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17247">尽管平台的许多功能是为了构建应用程序，但它同样必须能够支持应用程序的运行。</st> <st c="17267">尽管平台的需求应当有详细的文档记录且易于理解，但人类往往容易出错；因此，平台必须强制执行其规范。</st>
    <st c="17370">幸运的是，Kubernetes在一定程度上本身就支持这一点，通过准入控制器</st> <st c="17560">和</st>
    **<st c="17653">基于角色的访问控制</st>** <st c="17678">(</st>**<st c="17680">RBAC</st>**<st
    c="17684">)，但你也可以利用工具如策略引擎来确保那些不符合规范的工作负载或操作被拒绝，并给用户返回错误信息。</st> <st c="17858">越早收到反馈，用户的认知负担越轻，因为他们不需要切换上下文来响应</st>
    <st c="17984">平台。</st>
- en: <st c="17997">So, how are you supposed to reduce the cognitive load for your
    engineering teams with an internal</st> <st c="18096">developer platform?</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17997">那么，如何通过内部</st> <st c="18096">开发者平台来减少工程团队的认知负担呢？</st>
- en: <st c="18115">If you don’t know where to begin, start with empathy as you consider</st>
    <st c="18185">implementation details.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18115">如果你不知道从哪里开始，考虑到实现细节时，从同理心出发。</st>
- en: <st c="18208">Suppose you are one of the engineers using the platform.</st>
    <st c="18266">It is 4 a.m., you are panicking, and nobody else is there to help.</st>
    <st c="18333">Ask yourself, “</st>*<st c="18348">Will this be easy to use?</st>*<st
    c="18374">” When you are satisfied with your approach, ask an engineer to validate</st>
    <st c="18448">your assumptions.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18208">假设你是使用该平台的工程师之一。</st> <st c="18266">现在是凌晨四点，你正处于慌乱中，而没有其他人能帮助你。</st>
    <st c="18333">问问自己：“</st>*<st c="18348">这会容易使用吗？</st>*<st c="18374">” 当你对自己的方法感到满意时，找一位工程师来验证</st>
    <st c="18448">你的假设。</st>
- en: <st c="18465">Every detail should align with this principle.</st> <st c="18513">If
    core functionality is simple and makes life easier, users will not have to take
    on cognitive load.</st> <st c="18614">As you account for other aspects such</st>
    <st c="18652">as integrations, follow the same approach.</st> <st c="18696">Straightforward
    architectures are often the most effective.</st> <st c="18756">If “</st>*<st c="18760">Why
    is this architecture here?</st>*<st c="18791">” cannot be answered with “</st>*<st
    c="18819">Because it helps the user</st>*<st c="18845">,” perhaps it should not
    be there</st> <st c="18879">at all.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18465">每个细节都应与这一原则保持一致。</st> <st c="18513">如果核心功能简单且能简化用户的操作，用户就无需承担认知负担。</st>
    <st c="18614">在考虑其他方面时，</st> <st c="18652">比如集成，遵循相同的方法。</st> <st c="18696">直接的架构往往是最有效的。</st>
    <st c="18756">如果“</st>*<st c="18760">为什么会有这个架构存在？</st>*<st c="18791">”这个问题无法用“</st>*<st
    c="18819">因为它帮助了用户</st>*<st c="18845">”来回答，也许它根本不应该存在。</st> <st c="18879">完全没有必要。</st>
- en: <st c="18886">There are still significant gains that can be made by fine-tuning
    the operations of the IDP.</st> <st c="18980">Additionally, by setting a bar for
    the applications that will run on the platform, your team can define a maturity
    model for them.</st> <st c="19111">That maturity model will help define what an
    application needs to be a successful member of the platform environment, which
    means that developers can work against it as a checklist, instead of needing to
    experiment, ask a human,</st> <st c="19340">or guess.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18886">通过微调IDP的操作，仍然可以取得显著的提升。</st> <st c="18980">此外，设定平台上应用程序的标准，你的团队可以为它们定义一个成熟度模型。</st>
    <st c="19111">这个成熟度模型将帮助定义一个应用程序需要具备哪些条件，才能成为平台环境中的成功成员，这意味着开发者可以以此为检查表进行工作，而无需进行实验、向人请教，</st>
    <st c="19340">或猜测。</st>
- en: <st c="19349">Pre-production versus production</st>
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="19349">前期生产与生产阶段</st>
- en: <st c="19382">A platform covers both</st> <st c="19405">pre-production</st>
    <st c="19420">and production for a software application.</st> <st c="19464">The
    part of the platform where the application</st> <st c="19510">lands is referred
    to as the</st> **<st c="19539">application</st>** **<st c="19551">landing zone</st>**<st
    c="19563">.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19382">一个平台既涵盖</st> <st c="19405">预生产</st> <st c="19420">环境，也涵盖生产环境，用于软件应用程序。</st>
    <st c="19464">平台中应用程序</st> <st c="19510">所在的部分被称为</st> **<st c="19539">应用程序</st>**
    **<st c="19551">着陆区</st>**<st c="19563">。</st>
- en: <st c="19564">While a platform must consider both, the two should never mix,
    so the platform must enforce logical segmentations between the environments.</st>
    <st c="19705">It can do this via architecture or a policy.</st> <st c="19750">However,
    architecture is the best and most secure model, which we’ll cover further in</st>
    [*<st c="19836">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st c="19845">.
    In the current chapter, while we may make references to security best practices
    and segmentation strategies, the in-depth explanations can be found in</st> [*<st
    c="19998">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st c="20007">. The
    important takeaway for these environments in this chapter should be how they interact
    with cognitive load and how the platform aims to reduce that load across</st>
    <st c="20172">both scopes.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19564">尽管平台必须考虑这两者，但这两者永远不应混合，因此平台必须在环境之间强制执行逻辑分隔。</st> <st c="19705">它可以通过架构或策略来实现。</st>
    <st c="19750">然而，架构是最好的，也是最安全的模型，我们将在</st> [*<st c="19836">第七章</st>*](B31164_07.xhtml#_idTextAnchor381)
    <st c="19845">中进一步讨论。在当前章节中，尽管我们可能会提到安全最佳实践和分隔策略，但详细的解释可以在</st> [*<st c="19998">第七章</st>*](B31164_07.xhtml#_idTextAnchor381)
    <st c="20007">中找到。本章中关于这些环境的重要要点应是它们如何与认知负荷互动，以及平台如何旨在减少这两个范围内的负荷。</st>
- en: <st c="20184">Authentication and tenancy</st>
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="20184">身份验证与租户管理</st>
- en: <st c="20211">As your platform</st> <st c="20228">expands and gains adoption,
    it essentially becomes multi-tenant.</st> <st c="20294">This is due to the importance
    of ensuring a least privilege policy in a secure environment, as well as helping
    to ensure users don’t trip over each other.</st> <st c="20449">With</st> <st c="20454">multi-tenancy,
    it’s important to still give the feeling of a single tenancy, which means the
    existence of the other users and tenants must be hidden from</st> <st c="20608">each
    user.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20211">随着平台</st> <st c="20228">的扩展和用户的增加，它实际上变成了多租户平台。</st> <st c="20294">这是由于在安全环境中确保最小权限策略的重要性，以及帮助确保用户之间不会互相干扰。</st>
    <st c="20449">在</st> <st c="20454">多租户环境下，仍然需要提供单租户的体验，这意味着其他用户和租户的存在必须对</st>
    <st c="20608">每个用户隐藏。</st>
- en: <st c="20618">One of the first integrations you’ll add to the platform relates
    to authentication and user management.</st> <st c="20723">Most</st> **<st c="20728">OpenID
    Connect</st>** <st c="20742">(</st>**<st c="20744">OIDC</st>**<st c="20748">)
    providers</st> <st c="20760">can integrate into the common IDP toolchain, so selecting
    the correct one won’t be very difficult.</st> <st c="20860">From there, user management
    is pretty straightforward, although it differs between the common tools.</st>
    <st c="20961">For cognitive load, less is more, so one way for your users to authenticate
    across all aspects of a platform means fewer login workflows to remember, fewer
    logins per day, fewer passwords, and a homogenized experience with the rest of
    the tools in</st> <st c="21209">a company.</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20618">你将添加到平台的第一个集成通常与身份验证和用户管理相关。</st> <st c="20723">大多数</st> **<st
    c="20728">OpenID Connect</st>** <st c="20742">(</st>**<st c="20744">OIDC</st>**<st
    c="20748">) 提供商</st> <st c="20760">可以集成到常见的身份提供者（IDP）工具链中，因此选择正确的提供商不会很困难。</st>
    <st c="20860">从那时起，用户管理就变得相对直接，尽管不同的工具之间有所不同。</st> <st c="20961">为了减少认知负荷，越少越好，因此一种跨平台进行身份验证的方式意味着用户需要记住的登录流程更少，每天的登录次数更少，密码也更少，同时提供与其他工具相同的统一体验，</st>
    <st c="21209">这对于公司内部的其他工具也适用。</st>
- en: <st c="21219">Let’s look at this in a more realistic scenario.</st> <st c="21269">Financial
    One ACME is a bank.</st> <st c="21299">This means they’re in a highly regulated
    industry with a lot of very sensitive data to protect.</st> <st c="21395">Controlling
    who has access to what data and how they access it is one of the most important
    aspects of the company’s security and compliance story.</st> <st c="21543">It’s
    too much to expect users to remember to exercise all of those security and compliance
    practices perfectly every time.</st> <st c="21666">Thus, the platform needs to
    enforce</st> <st c="21702">that programmatically.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21219">让我们在一个更现实的场景中来看这个问题。</st> <st c="21269">Financial One ACME 是一家银行。</st>
    <st c="21299">这意味着它们处于一个高度监管的行业，需要保护大量非常敏感的数据。</st> <st c="21395">控制谁能访问哪些数据，以及如何访问这些数据，是公司安全性和合规性方面最重要的内容之一。</st>
    <st c="21543">期望用户每次都完美地记住并执行所有这些安全和合规实践，实在是过于苛刻。</st> <st c="21666">因此，平台需要程序化地强制执行</st>
    <st c="21702">这些规则。</st>
- en: <st c="21724">Meeting those</st> <st c="21738">requirements in any industry,
    highly regulated or not, all comes down to</st> <st c="21812">RBAC – how you isolate
    users from each other and guarantee that they have the actions they need without
    the access they do not.</st> <st c="21940">Take a look at the following figure
    to see an example of a</st> <st c="21999">multi-tenant IDP.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 满足任何行业的这些<st c="21724">要求</st>，无论是否高度监管，最终都归结于<st c="21738">RBAC —— 如何将用户相互隔离，并确保他们只拥有需要的权限，而没有不必要的访问权限。</st>
    <st c="21812">请查看下图，了解一个</st> <st c="21999">多租户身份提供者（IDP）的示例。</st>
- en: '![Figure 6.4: Multi-tenancy on an IDP cluster](img/B31164_06_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4：IDP 集群中的多租户](img/B31164_06_04.jpg)'
- en: '<st c="22265">Figure 6.4: Multi-tenancy on an IDP cluster</st>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22265">图 6.4：IDP 集群中的多租户</st>
- en: <st c="22308">In this example, workloads from both tenants can share space on
    a node, but through RBAC, the tenants cannot see the other workloads on the same
    nodes where their workloads run.</st> <st c="22487">Another option would be to
    also ensure only one tenant’s workload can run on each node.</st> <st c="22575">However,
    that level of isolation can have negative trade-offs, as it could impact the</st>
    **<st c="22661">high availability</st>** <st c="22678">of those</st> <st c="22687">workloads,
    or require more nodes in order for tenants to have full isolation and high availability.</st>
    <st c="22788">We discussed high availability for a platform in</st> [*<st c="22837">Chapter
    3</st>*](B31164_03.xhtml#_idTextAnchor133)<st c="22846">, and those same principles
    apply to an application that your development team is working on.</st> <st c="22940">Just
    as with the platform, high availability is a characteristic of the resilience
    of an application.</st> <st c="23042">This might mean its ability to handle load
    through scaling, or just its general uptime.</st> <st c="23130">Things that impact
    high availability include location.</st> <st c="23185">While you might have three
    Pods in</st> <st c="23220">a</st> **<st c="23222">ReplicaSet</st>** <st c="23232">for
    an application, if all three of those Pods are on the same node and it is restarted
    (such as with upgrades to the platform), then the application goes down; therefore,
    it is not highly available.</st> <st c="23433">Typically, a highly available application
    will have its replicasets spread across multiple nodes, and if those nodes are
    all in different availability zones, then the application has another layer of
    resilience added to it.</st> <st c="23657">Developers following best practices
    for cloud-native platforms will typically expect their application to be highly
    available, which means at least two other replicasets running on</st> <st c="23838">different
    nodes.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22308">在这个例子中，两个租户的工作负载可以共享一个节点的空间，但通过 RBAC，租户无法看到在同一节点上运行的其他工作负载。</st>
    <st c="22487">另一种选择是确保每个节点上只能运行一个租户的工作负载。</st> <st c="22575">然而，这种隔离程度可能会带来负面影响，因为它可能会影响</st>
    **<st c="22661">高可用性</st>** <st c="22678">，或者需要更多节点来确保租户之间完全隔离并保持高可用性。</st> <st
    c="22788">我们在</st> [*<st c="22837">第 3 章</st>*](B31164_03.xhtml#_idTextAnchor133)<st
    c="22846">讨论了平台的高可用性，这些相同的原则也适用于你的开发团队正在开发的应用程序。</st> <st c="22940">与平台一样，高可用性是应用程序韧性的一项特征。</st>
    <st c="23042">这可能意味着它通过扩展来处理负载的能力，或者仅仅是其整体的正常运行时间。</st> <st c="23130">影响高可用性的因素之一是位置。</st>
    <st c="23185">虽然你可能在</st> <st c="23220">一个</st> **<st c="23222">副本集（ReplicaSet）</st>**
    <st c="23232">中有三个 Pod，但如果这三个 Pod 都在同一个节点上，并且该节点被重启（例如平台升级时），那么应用程序将会停机；因此，它就不是高可用的。</st>
    <st c="23433">通常，高可用的应用程序会将副本集分布在多个节点上，如果这些节点位于不同的可用区，则该应用程序会增加一层额外的韧性。</st> <st
    c="23657">遵循云原生平台最佳实践的开发人员通常会期望他们的应用程序具备高可用性，这意味着至少有两个副本集在</st> <st c="23838">不同节点上运行。</st>
- en: <st c="23854">RBAC</st>
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23854">RBAC</st>
- en: <st c="23859">Regardless of the tenancy model, the kubernetes system RBAC will
    become the spine of self-service for a platform.</st> <st c="23974">You’ll use
    RBAC to restrict user access to the IDP for only the namespaces and environments
    where their workloads will land within the IDP.</st> <st c="24114">You’ll additionally
    have similar</st> <st c="24147">RBAC policies in the end user-facing environment
    where the application will run.</st> <st c="24228">The RBAC policies in the production
    environment will be less permissive than in the development environments, as it
    will be necessary to maintain a higher degree of scrutiny on those permissions.</st>
    <st c="24424">You’ll learn more about this in</st> [*<st c="24456">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="24465">.</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23859">无论租户模型如何，Kubernetes 系统中的 RBAC 将成为平台自服务的骨架。</st> <st c="23974">你将使用
    RBAC 限制用户对 IDP 的访问，仅限于他们的工作负载将落在 IDP 中的命名空间和环境。</st> <st c="24114">此外，你将在面向最终用户的环境中也有类似的</st>
    <st c="24147">RBAC 策略，应用程序将在该环境中运行。</st> <st c="24228">生产环境中的 RBAC 策略将比开发环境中更为严格，因为需要对这些权限进行更高程度的审查。</st>
    <st c="24424">你将在</st> [*<st c="24456">第 7 章</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="24465">中学习更多关于此的内容。</st>
- en: <st c="24466">Further reading</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24466">进一步阅读</st>
- en: <st c="24482">Kubernetes’ official documentation can be found</st> <st c="24531">here:</st>
    [<st c="24537">https://kubernetes.io/docs/reference/access-authn-authz/rbac/</st>](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)<st
    c="24598">.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24482">Kubernetes的官方文档可以在此找到</st> <st c="24531">：</st> [<st c="24537">https://kubernetes.io/docs/reference/access-authn-authz/rbac/</st>](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)<st
    c="24598">。</st>
- en: <st c="24599">Borrowing an example from the official documentation, we can see
    an example of RBAC where a user who is assigned a role would have the capability
    to read secrets, but they would not be able to edit or</st> <st c="24801">delete
    them:</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24599">借用官方文档中的一个示例，我们可以看到一个RBAC示例，在该示例中，分配给用户的角色使其能够读取机密，但不能编辑或</st>
    <st c="24801">删除它们：</st>
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="25134">Similar to this example, by leveraging</st> <st c="25173">RBAC,
    you set your users up to successfully navigate a platform with appropriate guardrails
    in place.</st> <st c="25276">So, how do you determine what a robust RBAC policy
    needs to have to strike the balance between access, actions, and restrictions?</st>
    <st c="25406">This is where self-service takes center stage.</st> <st c="25453">Let’s
    look at some workflows that your users may expect to have on</st> <st c="25520">the
    platform.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25134">与这个示例类似，通过利用</st> <st c="25173">RBAC，你可以为用户设置适当的守护措施，让他们成功地在平台上导航。</st>
    <st c="25276">那么，如何确定一个强健的RBAC策略需要具备哪些条件，以便在访问、操作和限制之间找到平衡呢？</st> <st c="25406">这时，自助服务成为核心。</st>
    <st c="25453">让我们看看你的用户可能会在平台上期望的工作流。</st>
- en: '![Figure 6.5: Example workflows for IDP users](img/B31164_06_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5：IDP用户的示例工作流](img/B31164_06_05.jpg)'
- en: '<st c="25535">Figure 6.5: Example workflows for IDP users</st>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25535">图6.5：IDP用户的示例工作流</st>
- en: <st c="25578">In the example illustrated in</st> *<st c="25609">Figure 6</st>**<st
    c="25617">.5</st>*<st c="25619">, we have multiple teams and, therefore, likely
    multiple users within the teams, reliant on the same systems within a platform.</st>
    <st c="25747">Sometimes, they will be reliant on the same systems at the same
    time.</st> <st c="25817">Depending on your CI/CD system of choice, best practices
    can vary; however, in general, the idea is that the platform team will ensure
    that the components required for the IDP are capable of scaling</st> <st c="26016">to
    users.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*<st c="25609">图6</st>**<st c="25617">.5</st>*<st c="25619">中展示的示例中，我们有多个团队，因此，团队内可能有多个用户，他们依赖于同一平台中的相同系统。</st>
    <st c="25747">有时，他们会在同一时间依赖于相同的系统。</st> <st c="25817">根据你选择的CI/CD系统，最佳实践可能有所不同；然而，一般而言，平台团队的目标是确保为IDP所需的组件能够扩展</st>
    <st c="26016">到用户。</st>
- en: <st c="26025">The authentication system used for the Kubernetes cluster can
    be used for pre-production tools such as Argo CD as well, allowing users to leverage
    independent projects within the same Argo</st> <st c="26215">CD instance.</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26025">用于Kubernetes集群的身份验证系统也可以用于类似Argo CD的预生产工具，允许用户在同一个Argo</st> <st
    c="26215">CD实例中利用独立的项目。</st>
- en: <st c="26227">While it’s not a best practice, it is technically possible to
    do the same access pattern for production-level access; however, when production
    is being accessed, it’s a best practice to have a much stricter set of authentications
    and an even more limited permission set once authenticated.</st> <st c="26518">We’ll
    cover this further in</st> [*<st c="26546">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="26555">,</st> *<st c="26557">Building a</st>* *<st c="26568">Secure Platform</st>*<st
    c="26583">.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26227">虽然这不是最佳实践，但技术上可以对生产级访问实施相同的访问模式；然而，当访问生产环境时，最佳做法是进行更严格的身份验证，并且一旦验证通过，权限集应更加有限。</st>
    <st c="26518">我们将在</st> [*<st c="26546">第7章</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="26555">中进一步讨论，</st> *<st c="26557">构建一个</st>* *<st c="26568">安全平台</st>*<st
    c="26583">。</st>
- en: <st c="26584">Noisy neighbor prevention</st>
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="26584">防止“噪音邻居”问题</st>
- en: <st c="26610">It may not immediately be obvious how a noisy neighbor</st> <st
    c="26665">can impact cognitive load, but the protection from such an event helps
    to prevent production incidents that can be difficult to troubleshoot and resolve,
    especially in an environment where multi-tenancy is the standard.</st> <st c="26886">It
    also helps users troubleshoot their applications or assists the platform team
    in troubleshooting production issues by ruling out scenarios that become less
    likely as more protections are put in place.</st> <st c="27090">Since your developer
    teams should expect to have limited access to the production side of an IDP, and
    no access to the metrics and workloads for other teams, all work done to prevent
    a noisy neighbor helps to ensure that those workloads are less likely to enter
    each team’s</st> <st c="27364">cognitive load.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26610">噪声邻居如何影响认知负荷可能不是显而易见的，但防止这种事件的发生有助于避免生产事件，这些事件可能很难排查和解决，尤其是在多租户环境成为标准的情况下。</st>
    <st c="26665">它还帮助用户排查他们的应用程序，或帮助平台团队排查生产问题，通过排除随着更多保护措施到位而变得不太可能的场景。</st> <st
    c="26886">由于你的开发团队应当预期有限访问IDP的生产端，并且无法访问其他团队的指标和工作负载，因此所有防止噪声邻居的工作都有助于确保这些工作负载不太可能进入每个团队的</st>
    <st c="27364">认知负荷。</st>
- en: <st c="27379">In the context of an IDP, a noisy neighbor means a workload that
    runs in the same environment as another and hogs resources, whether this is through
    an abundance of network traffic, CPU, or memory utilization, or other less-than-neighborly
    behaviors.</st> <st c="27631">Much like a city would have ordinances to prevent
    a neighbor from blocking off a street or playing music way too loud, a platform
    can enforce norms to ensure that one workload doesn’t negatively</st> <st c="27826">impact
    another.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27379">在IDP的上下文中，噪声邻居指的是与其他工作负载在同一环境中运行，并且占用资源的工作负载，无论是通过大量的网络流量、CPU或内存使用，还是其他不太邻里友好的行为。</st>
    <st c="27631">就像城市会有条例防止邻居封锁街道或播放过大声的音乐一样，平台可以实施规范，确保一个工作负载不会对另一个工作负载产生负面影响。</st>
    <st c="27826">影响。</st>
- en: <st c="27841">In many real-world scenarios, one Kubernetes cluster is utilized
    for multiple environments.</st> <st c="27934">For organizations with more limited
    cloud spend budgets, dev, QA, staging, and production environments may all be
    located on the same cluster.</st> <st c="28077">Technically speaking, an entire
    IDP could be one cluster.</st> <st c="28135">While this isn’t what we’d consider
    a best practice, it is an extremely common one, utilized to keep costs down.</st>
    <st c="28248">It’s in these scenarios where noisy neighbors are most likely to
    occur, but it can happen even when production is fully isolated, due to a workload
    either experiencing a software bug or just a higher than normal resource utilization
    for valid reasons.</st> <st c="28500">Containerized workloads have an advantage
    in protecting against noisy neighbor scenarios in these shared environments, in
    that those Pod and container definitions can hold the resource definitions, The
    encapsulation of the workload is a strength, particularly for resource management.</st>
    <st c="28785">While the vast majority of protections against noisy neighbor scenarios
    should happen as part of defensive programming for software applications, as well
    as through accurately benchmarking and identifying theresource need of those applications,
    a platform has the ability to be hardened</st> <st c="29072">as well.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27841">在许多实际场景中，一个Kubernetes集群被用于多个环境。</st> <st c="27934">对于云支出预算较为有限的组织，开发、QA、预生产和生产环境可能都位于同一个集群上。</st>
    <st c="28077">从技术角度讲，整个IDP可以是一个集群。</st> <st c="28135">虽然这不是我们认为的最佳实践，但它是一个极其常见的做法，用于降低成本。</st>
    <st c="28248">正是在这些场景中，噪声邻居最有可能发生，但即使在生产环境完全隔离的情况下，也有可能发生，原因可能是某个工作负载遇到软件漏洞，或因为有效原因导致资源使用率高于正常水平。</st>
    <st c="28500">容器化工作负载在防范这些共享环境中的噪声邻居场景方面有优势，因为这些Pod和容器定义可以持有资源定义，工作负载的封装性是一种优势，特别是在资源管理方面。</st>
    <st c="28785">虽然绝大多数防范噪声邻居场景的保护应当作为软件应用的防御性编程的一部分，另外还应通过准确地对这些应用程序的资源需求进行基准测试和识别，但平台本身也有能力进行硬化。</st>
    <st c="29072">硬化。</st>
- en: <st c="29080">How can you achieve that hardening?</st> <st c="29117">Here’s
    how:</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29080">你如何实现这种硬化？</st> <st c="29117">以下是实现方法：</st>
- en: <st c="29128">Be mindful of the resources that are shared, even with workload
    isolation best practices enforced, such as etcd, the API server, and the</st>
    <st c="29266">networking stack</st>
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="29128">即使在强制实施工作负载隔离最佳实践的情况下，也要注意资源共享，例如 etcd、API 服务器和</st> <st c="29266">网络栈</st>
- en: <st c="29282">Take preventative measures against</st> <st c="29318">CPU starvation</st>
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="29282">采取预防措施避免</st> <st c="29318">CPU 饥饿</st>
- en: <st c="29332">Cluster autoscaling – the automatic addition (or removal)</st>
    <st c="29391">of nodes</st>
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="29332">集群自动扩展——自动添加（或移除）</st> <st c="29391">节点</st>
- en: <st c="29399">The care and feeding of etcd</st>
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="29399">etcd 的维护和管理</st>
- en: <st c="29428">etcd is the key-value store that holds every definition for all
    the Kubernetes objects on a cluster – Pod definitions, job definitions, StatefulSets,
    DaemonSets,</st> **<st c="29591">CustomResourceDefinitions</st>** <st c="29616">(</st>**<st
    c="29618">CRDs</st>**<st c="29622">), and so</st> <st c="29632">on are all stored
    in etcd.</st> <st c="29660">This means it can get quite full as platform usage
    increases.</st> <st c="29722">An etcd project</st> <st c="29737">recommends a
    minimum set of resources allocated to the etcd Pods in order to guarantee successful
    production operations.</st> <st c="29859">The detailed recommendations can be
    found in the etcd docs (</st>[<st c="29919">https://etcd.io/docs/v3.6/op-guide/hardware/</st>](https://etcd.io/docs/v3.6/op-guide/hardware/)<st
    c="29964">) but the functional areas are disks, networking, CPU, and memory.</st>
    <st c="30032">As your cluster utilization grows, so too does the needs of etcd.</st>
    <st c="30098">Generally, the best practices for etcd include ensuring it has priority
    for CPU, networking, and dedicated disks, with high throughput and low latency.</st>
    <st c="30250">A</st> **<st c="30252">solid-state drive</st>** <st c="30269">(</st>**<st
    c="30271">SSD</st>**<st c="30274">) should be used for the etcd storage if possible.</st>
    <st c="30326">The etcd</st> <st c="30335">documentation has several suggestions
    for the tuning of etcd, so we won’t reiterate them here.</st> <st c="30430">It’s
    important to keep up with the latest recommendations from the project itself,
    as the technology will continue to evolve over time.</st> <st c="30566">Since
    etcd is a critical component to the successful operations of a Kubernetes cluster,
    watching it carefully with observability and proactively responding to evidence
    of disk pressure, or other resource issues, will be mission-critical to guarantee</st>
    <st c="30817">platform availability.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29428">etcd 是一个键值存储，用于保存集群中所有 Kubernetes 对象的定义——如 Pod 定义、作业定义、StatefulSets、DaemonSets，</st>
    **<st c="29591">CustomResourceDefinitions</st>** <st c="29616">(</st>**<st c="29618">CRDs</st>**<st
    c="29622">) 等等，这些都保存在 etcd 中。</st> <st c="29660">这意味着，随着平台使用量的增加，etcd 可能会变得相当满。</st>
    <st c="29722">etcd 项目</st> <st c="29737">建议为 etcd Pods 分配一组最小资源，以确保生产环境中的顺利运行。</st>
    <st c="29859">详细的推荐可以在 etcd 文档中找到（</st>[<st c="29919">https://etcd.io/docs/v3.6/op-guide/hardware/</st>](https://etcd.io/docs/v3.6/op-guide/hardware/)<st
    c="29964">），其功能领域包括磁盘、网络、CPU 和内存。</st> <st c="30032">随着集群使用量的增加，etcd 的需求也会增加。</st>
    <st c="30098">通常，etcd 的最佳实践包括确保其优先使用 CPU、网络和专用磁盘，具有高吞吐量和低延迟。</st> <st c="30250">如果可能，应该使用**<st
    c="30252">固态硬盘</st>** (<st c="30271">SSD</st>) 来存储 etcd 数据。</st> <st c="30326">etcd</st>
    <st c="30335">文档中有一些关于 etcd 调优的建议，我们这里不再重复。</st> <st c="30430">保持跟进项目本身的最新建议非常重要，因为技术会随着时间不断演进。</st>
    <st c="30566">由于 etcd 是 Kubernetes 集群成功运行的关键组件，因此必须仔细监视其可观察性，并主动应对磁盘压力或其他资源问题的迹象，这对于保证</st>
    <st c="30817">平台的可用性至关重要。</st>
- en: <st c="30839">Even after your etcd configuration is optimized, the actual usage
    or over usage of etcd can still result in noisy neighbors.</st> <st c="30965">The
    cloud-native CD system Argo CD, for example, stores its jobs as CRD entries, not
    as Kubernetes jobs.</st> <st c="31070">As the number of teams and deployments
    from Argo CD grows, so too does the number of entries in etcd.</st> <st c="31172">If
    etcd fills up, the Kubernetes API server goes down.</st> <st c="31227">To prevent
    this, care must be taken to ensure that etcd is healthy and not</st> <st c="31302">getting
    overfull.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30839">即使在优化了 etcd 配置之后，etcd 的实际使用或过度使用仍然可能导致资源竞争。</st> <st c="30965">例如，云原生
    CD 系统 Argo CD 将作业存储为 CRD 条目，而不是 Kubernetes 作业。</st> <st c="31070">随着 Argo CD 中团队和部署数量的增加，etcd
    中的条目数也会增加。</st> <st c="31172">如果 etcd 填满，Kubernetes API 服务器将会宕机。</st> <st c="31227">为防止这种情况，必须确保
    etcd 健康并且不会</st> <st c="31302">过度填充。</st>
- en: <st c="31319">One method is to ensure that you’re pruning old</st> <st c="31367">CRD
    entries from etcd.</st> <st c="31391">In the case of Argo CD, this functionality
    is built natively into the app.</st> <st c="31466">In the case of standard Kubernetes
    jobs, a time-to-live mechanism can be utilized by applying the time desired, in
    sections, to the</st> `<st c="31598">spec</st>` <st c="31602">field of the job
    definition.</st> <st c="31632">With this, after the given amount of time has passed
    since the job has succeeded or failed, the garbage collection mechanism will run
    and remove the entry, thus managing the size and health</st> <st c="31822">of
    etcd.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31319">一种方法是确保你从 etcd 中修剪掉旧的</st> <st c="31367">CRD 条目。</st> <st c="31391">在
    Argo CD 的情况下，这个功能是原生集成到应用中的。</st> <st c="31466">在标准 Kubernetes 作业的情况下，可以通过在作业定义的</st>
    `<st c="31598">spec</st>` <st c="31602">字段中应用所需的时间，来使用生存时间（TTL）机制。</st> <st c="31632">这样，在作业成功或失败后经过一定时间，垃圾回收机制将运行并移除该条目，从而管理
    etcd 的大小和健康状态。</st>
- en: <st c="31830">Similarly, other Kubernetes kinds have their own way of invoking
    a clean-up mechanism.</st> <st c="31918">For Deployments, there is a spec for</st>
    `<st c="31955">revisionHistoryLimit</st>`<st c="31975">, which will determine
    how many old versions of the Deployment will be stored.</st> <st c="32054">If
    the number is 0, then in the event of a production issue, the deployment cannot
    be rolled back, but etcd is clean as</st> <st c="32174">a whistle.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31830">类似地，其他 Kubernetes 类型也有各自的清理机制。</st> <st c="31918">对于部署（Deployments），有一个规范是</st>
    `<st c="31955">revisionHistoryLimit</st>`<st c="31975">，它决定了将保留多少个旧版本的部署。</st>
    <st c="32054">如果该数字为 0，那么在生产问题发生时，部署将无法回滚，但 etcd 会保持干净，像</st> <st c="32174">口哨一样清晰。</st>
- en: <st c="32184">Exactly how to tune these clean-up measures will be dependent
    on the number of users and the number of etcd entries that those users generate.</st>
    <st c="32328">The size of etcd will also be a factor, and that can be scaled by
    increasing the size of the control plane nodes.</st> <st c="32442">So, when to
    scale, when to prune, and when to consider adding a cluster to the IDP environment
    will be an exercise in cost management, ROI, and a fundamental part of the platform’s
    life cycle.</st> <st c="32635">It will also need to be a factor in the integrations
    you select for your IDP, but we’ll cover cost management more in</st> [*<st c="32753">Chapter
    8</st>*](B31164_08.xhtml#_idTextAnchor430)<st c="32762">.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32184">如何调整这些清理措施，将取决于用户数量以及这些用户生成的 etcd 条目数量。</st> <st c="32328">etcd
    的大小也是一个因素，而这个因素可以通过增加控制平面节点的大小来扩展。</st> <st c="32442">因此，何时扩展，何时修剪，何时考虑向 IDP 环境中添加集群，将是一个成本管理、投资回报率（ROI）和平台生命周期的基本部分。</st>
    <st c="32635">它还需要成为你为 IDP 选择的集成工具的一个因素，但我们会在</st> [*<st c="32753">第 8 章</st>*](B31164_08.xhtml#_idTextAnchor430)<st
    c="32762">中更详细地讨论成本管理。</st>
- en: <st c="32763">Understanding the CPU and the scheduler to avoid starvation</st>
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="32763">理解 CPU 和调度器以避免饥饿现象</st>
- en: <st c="32823">The next resource that is shared at the cluster scope, regardless
    of tenancy models, is the CPU.</st> <st c="32921">As previously</st> <st c="32935">mentioned,
    when we discussed reliability, in Kubernetes, there is a maximum amount of memory
    that can be used on a node object.</st> <st c="33063">All of the Pods and their
    memory requests are totaled, and if the total memory exceeds what is allocated
    to the node, a Pod will either be scheduled to a different node with available
    room or fail to be scheduled.</st> <st c="33277">If a Pod tries to use more memory
    than the node has available, it will be terminated and rescheduled.</st> <st c="33379">There’s
    a strict boundary on memory allocation along the nodes.</st> <st c="33443">A CPU,
    at a glance, appears to have the same functionality, but in reality, all CPUs
    are available to all nodes.</st> <st c="33556">This means that while app performance
    may be primarily a consideration of the development team, the developers shouldn’t
    have to worry about whether the platform can support the needs of an application.</st>
    <st c="33759">While the developer will need to inform the platform of the workload’s
    needs, the platform will need to be able to</st> <st c="33874">support it.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32823">在集群范围内共享的下一个资源是 CPU，无论租户模型如何。</st> <st c="32921">如前所述</st> <st
    c="32935">，在讨论可靠性时，我们提到过，在 Kubernetes 中，每个节点对象可以使用的内存是有限制的。</st> <st c="33063">所有
    Pod 及其内存请求都会被汇总，如果总内存超过分配给节点的内存，Pod 将被调度到有足够空间的其他节点，或者调度失败。</st> <st c="33277">如果
    Pod 尝试使用超出节点可用内存的内存，将会被终止并重新调度。</st> <st c="33379">内存分配在节点之间有严格的边界。</st> <st c="33443">CPU
    看起来也具有相同的功能，但实际上，所有 CPU 都可以被所有节点使用。</st> <st c="33556">这意味着，虽然应用性能可能主要是开发团队的考虑因素，但开发人员不必担心平台是否能够支持应用的需求。</st>
    <st c="33759">虽然开发人员需要告知平台工作负载的需求，但平台需要能够</st> <st c="33874">支持这些需求。</st>
- en: <st c="33885">The actual implementation for</st> <st c="33915">CPU management
    in Kubernetes is the</st> **<st c="33952">Completely Fair Scheduler</st>** <st
    c="33977">(</st>**<st c="33979">CFS</st>**<st c="33982">), which</st> <st c="33991">is
    the same one that</st> <st c="34012">the</st> **<st c="34017">Linux kernel</st>**
    <st c="34029">uses.</st> <st c="34036">Functionally, what this means is that workloads
    on a node can use more of a CPU than the node is allocated if the CPU</st> <st
    c="34154">is available.</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33885">Kubernetes 中的 CPU 管理的实际实现是</st> **<st c="33952">完全公平调度器</st>**
    <st c="33977">(</st>**<st c="33979">CFS</st>**<st c="33982">)，它</st> <st c="33991">与</st>
    <st c="34012">Linux 内核</st> <st c="34029">使用的是相同的调度器。</st> <st c="34036">从功能上来说，这意味着，如果
    CPU</st> <st c="34154">是可用的，</st> 节点上的工作负载可以使用超出节点分配的 CPU 资源。</st>
- en: <st c="34167">While this capability to overcommit CPU can be useful, as it can
    technically support bin packing, allowing a platform to support more workloads
    as long as they’re not running simultaneously, and without needing to reserve
    more virtual hardware (or actual hardware if you’re running on bare metal), there
    are reasons why you might want to prevent some or all of the CPU from being utilized
    in this fashion, even if it’s</st> <st c="34587">technically available.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34167">虽然这种超额分配 CPU 的能力在某些情况下可能有用，因为它可以在技术上支持“二进制打包”，允许平台支持更多的工作负载，只要它们不会同时运行，并且不需要保留更多的虚拟硬件（或者如果你在裸金属上运行，就是实际硬件），但也有一些原因，你可能希望防止部分或所有
    CPU 以这种方式被使用，即使它在</st> <st c="34587">技术上是可用的。</st>
- en: <st c="34609">For example, in a production environment, there may be certain
    workloads that must always be performant or are particularly sensitive to CPU
    caching, while other operations could be a little slower or reschedule to new
    nodes more freely.</st> <st c="34848">For these situations, you can better guarantee
    CPU availability by altering the CPU</st> <st c="34932">manager policy.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34609">例如，在生产环境中，可能会有一些工作负载必须始终保持高性能，或者特别敏感于 CPU 缓存，而其他操作则可以稍微慢一些，或者更自由地重新调度到新节点。</st>
    <st c="34848">对于这些情况，你可以通过更改 CPU</st> <st c="34932">管理策略</st> <st c="34947">更好地保证
    CPU 可用性。</st>
- en: <st c="34947">To understand the full implementation of CPU management</st> <st
    c="35003">in Kubernetes, read the documentation</st> <st c="35042">here:</st>
    [<st c="35048">https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/</st>](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/)<st
    c="35124">.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34947">要了解 Kubernetes 中 CPU 管理的完整实现，</st> <st c="35003">请阅读文档</st> <st
    c="35042">此处：</st> [<st c="35048">https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/</st>](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/)<st
    c="35124">。</st>
- en: <st c="35125">The platform will need to enable CPU management policies in the
    kubelet configuration in order for CPUs to be excluded from the pool.</st> <st
    c="35260">You will have to define how much CPU to reserve, but you can reserve
    all of the CPU, minus what is needed to run the Kubernetes-critical workloads.</st>
    <st c="35408">In order to get the desired outcome, where a Pod is guaranteed the
    CPU it needs at the expense of other Pods, the developer will need to specify
    both requests and limits as whole integers in the Pod spec, and those two values</st>
    <st c="35634">must match.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35125">该平台需要在 kubelet 配置中启用 CPU 管理策略，以便将 CPU 从池中排除。</st> <st c="35260">你需要定义预留多少
    CPU，但可以保留所有 CPU，减去运行 Kubernetes 关键工作负载所需的部分。</st> <st c="35408">为了达到预期的结果，即保证某个
    Pod 具有所需的 CPU，而其他 Pod 则牺牲部分资源，开发者需要在 Pod 配置中指定请求（requests）和限制（limits），并且这两个值</st>
    <st c="35634">必须匹配。</st>
- en: <st c="35645">Here’s an example</st> <st c="35664">Pod spec:</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35645">这是一个示例</st> <st c="35664">Pod 配置：</st>
- en: '[PRE1]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="35864">Once your node is configured in this way, it is known as</st>
    *<st c="35922">guaranteed</st>* <st c="35932">by the platform and, therefore,
    is able to use exclusive</st> <st c="35989">CPU.</st> <st c="35995">The</st> **<st
    c="35999">kube-scheduler</st>** <st c="36013">(</st>**<st c="36015">scheduler</st>**
    <st c="36024">for short) will prioritize it being on nodes that</st> <st c="36074">support
    the CPU needs of the Pod.</st> <st c="36109">If that’s only one</st> <st c="36127">node,
    then the scheduler will prioritize that; however, if you have multiple or all
    nodes configured to use exclusive CPU, then although the priority of the Pod will
    be high and, therefore, less likely to be moved (except in more extreme cases),
    it could still be placed on a</st> <st c="36404">new node.</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35864">一旦你的节点按这种方式配置，它将被平台认定为</st> *<st c="35922">保证的</st>* <st c="35932">，因此能够使用独占</st>
    <st c="35989">CPU。</st> <st c="35995">该</st> **<st c="35999">kube-scheduler</st>**
    <st c="36013">(</st>**<st c="36015">调度器</st>** <st c="36024">简称为调度器) 会优先安排它运行在支持
    Pod CPU 需求的节点上。</st> <st c="36074">如果只有一个节点符合条件，那么调度器会优先选择它；然而，如果你配置了多个或所有节点以使用独占
    CPU，则虽然 Pod 的优先级较高，因而不太可能被迁移（除非遇到极端情况），它仍然可能被放置到</st> <st c="36404">新的节点上。</st>
- en: <st c="36413">To ensure that a specific node is always selected, or a specific
    type of node is always selected, you can label nodes.</st> <st c="36533">Doing
    so helps the scheduler to match Pods to nodes with labels defined in the Pod spec.</st>
    <st c="36622">This further ensures the correct Pod placement, which has use cases
    beyond noisy neighbor prevention</st> <st c="36723">as well.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36413">为了确保始终选择特定节点，或者始终选择某种类型的节点，你可以为节点添加标签。</st> <st c="36533">这样做有助于调度器将
    Pod 匹配到在 Pod 配置中定义标签的节点上。</st> <st c="36622">这进一步确保了 Pod 的正确放置，除了防止“吵闹邻居”外，还可用于其他场景。</st>
    <st c="36723">。</st>
- en: <st c="36731">If you’ve decided to follow along with a local kind cluster and
    haven’t already, let’s set up the cluster now.</st> <st c="36843">First, clone
    the GitHub repository for the book and change the directory to the one for</st>
    [*<st c="36931">Chapter 6</st>*](B31164_06.xhtml#_idTextAnchor341)<st c="36940">:</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36731">如果你决定使用本地 kind 集群并且还没有设置，先让我们来设置这个集群。</st> <st c="36843">首先，克隆本书的
    GitHub 仓库，并切换到</st> [*<st c="36931">第 6 章</st>*](B31164_06.xhtml#_idTextAnchor341)<st
    c="36940">：</st>
- en: '[PRE2]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="37153">After your cluster-named platform is created, set the context
    to the kind cluster for the chapter.</st> <st c="37253">This removes the need
    to add</st> `<st c="37282">--context kind-platform</st>` <st c="37305">to the
    end of each</st> `<st c="37325">kubectl</st>` <st c="37332">command:</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37153">创建好命名为集群的平台后，将上下文设置为本章的 kind 集群。</st> <st c="37253">这样就无需在每个</st>
    `<st c="37282">kubectl</st>` <st c="37305">命令末尾添加</st> `<st c="37325">--context
    kind-platform</st>` <st c="37332">了：</st>
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="37390">Now that we’ve made our lives a little easier, we can begin the
    Pod</st> <st c="37459">labeling demo.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37390">现在我们让工作变得更简单一些，接下来可以开始 Pod</st> <st c="37459">标签演示。</st>
- en: <st c="37473">Here’s the node label command and</st> <st c="37508">example output:</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37473">这是节点标签命令和</st> <st c="37508">示例输出：</st>
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="37610">Run this command to see the label on</st> <st c="37648">the node:</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37610">运行此命令查看节点的标签：</st> <st c="37648">该节点的标签为：</st>
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="37950">Our final</st> <st c="37960">Pod will look something</st> <st
    c="37985">like this:</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37950">我们的最终</st> <st c="37960">Pod 看起来像这样：</st>
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="38315">Important note</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38315">重要提示</st>
- en: <st c="38330">In order for the CPU management policy to be enforced on previous
    workloads and new workloads, you have to drain the node and</st> <st c="38457">restart
    it.</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38330">为了让 CPU 管理策略在之前和新的工作负载上得到执行，你必须清空节点并</st> <st c="38457">重新启动它。</st>
- en: <st c="38468">Outside of the CPU, the</st> <st c="38492">scheduler looks at
    several other different factors to determine how to prioritize or move Pods, including
    an explicit Pod priority.</st> <st c="38625">If Pod priority is not well understood
    or the tenancy of a platform is not well known, it may not be immediately obvious
    to an engineer why they should not place a high priority on their application
    Pods.</st> <st c="38830">As far as a developer is concerned their production application
    is probably the most important workload.</st> <st c="38935">However, this can
    create noisy neighbor situations if not used well.</st> <st c="39004">One over-prioritized
    Pod seems harmless.</st> <st c="39045">In practice, it is a constant denial-of-service
    attack that worsens with scale.</st> <st c="39125">If the Pod is assigned to a
    replicaset and the instances of it grow with the cluster, then there’s a growing
    number of over-prioritized workloads.</st> <st c="39272">If this problem spreads
    to more than one Pod, then the problem compounds.</st> <st c="39346">This degrades
    the platform service, strains underlying hardware, and impairs troubleshooting.</st>
    <st c="39440">Therefore, the platform may want to limit or prevent such assignments.</st>
    <st c="39511">This can be done with the enforcement of quota or</st> <st c="39561">admission
    controllers.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38468">除了 CPU 外，</st> <st c="38492">调度器还会考虑其他几个不同的因素来决定如何优先调度或移动 Pods，包括明确的
    Pod 优先级。</st> <st c="38625">如果 Pod 优先级没有得到充分理解，或者平台的租户情况不明确，工程师可能不会立刻明白为什么不应该把应用
    Pod 的优先级设得很高。</st> <st c="38830">就开发人员而言，他们的生产应用程序可能是最重要的工作负载。</st> <st c="38935">然而，如果使用不当，这可能会导致“吵闹的邻居”问题。</st>
    <st c="39004">一个被过度优先的 Pod 看似无害。</st> <st c="39045">实际上，它就像是一个不断加剧的拒绝服务攻击，随着规模扩大而变得更严重。</st>
    <st c="39125">如果 Pod 被分配到一个副本集，并且随着集群的扩展，其实例数量增加，那么被过度优先的工作负载也会逐渐增多。</st> <st
    c="39272">如果这个问题扩展到多个 Pod，那么问题会加剧。</st> <st c="39346">这会导致平台服务退化，增加底层硬件的压力，并使故障排除变得更加困难。</st>
    <st c="39440">因此，平台可能需要限制或防止这种分配。</st> <st c="39511">这可以通过执行配额或</st> <st c="39561">准入控制器来实现。</st>
- en: <st c="39583">We’ll cover quota and admission controllers later in this chapter.</st>
    <st c="39651">However, if Pod priority is something you’d like to use in a platform,
    here are the general steps necessary to</st> <st c="39762">enable it:</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39583">我们将在本章后面讲解配额和准入控制器。</st> <st c="39651">但是，如果你希望在平台中使用 Pod 优先级，以下是启用它的一般步骤：</st>
- en: <st c="39772">First, create a</st> <st c="39789">priority class.</st> <st c="39805">This
    kind is not scoped to namespaces but is more generally available cluster-wide.</st>
    <st c="39889">Create the class by saving the following content to a YAML file</st>
    <st c="39953">called</st> `<st c="39960">priority.yaml</st>`<st c="39973">:</st>
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="39772">首先，创建一个</st> <st c="39789">优先级类。</st> <st c="39805">这种类型不限于命名空间，而是更广泛地在集群中可用。</st>
    <st c="39889">通过将以下内容保存到一个 YAML 文件</st> <st c="39953">中来创建该类，文件名为</st> `<st c="39960">priority.yaml</st>`<st
    c="39973">：</st>
- en: '[PRE7]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="40196">Next, apply the</st> <st c="40213">priority class:</st>
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="40196">接下来，应用</st> <st c="40213">优先级类：</st>
- en: '[PRE8]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="40324">Now, when we create a Pod, we can select that priority.</st> <st
    c="40381">Save the following</st> <st c="40400">as</st> `<st c="40403">pod.yaml</st>`<st
    c="40411">:</st>
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="40324">现在，当我们创建一个 Pod 时，可以选择该优先级。</st> <st c="40381">将以下内容保存为</st> <st
    c="40400">文件</st> `<st c="40403">pod.yaml</st>`<st c="40411">：</st>
- en: '[PRE9]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="40770">After saving the</st> <st c="40788">Pod, create it with</st> `<st
    c="40808">kubectl create</st>`<st c="40822">:</st>
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="40770">保存 Pod 后，使用</st> `<st c="40808">kubectl create</st>`<st c="40822">创建它：</st>
- en: '[PRE10]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="40871">There are many other tuning options within Kubernetes to ensure
    that the scheduler makes the decisions you’d prefer.</st> <st c="40989">It is
    also possible to run an additional scheduler profile or to replace the default
    scheduler entirely with a customer profile that abides by</st> <st c="41132">different
    rules.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40871">在 Kubernetes 中有许多其他调整选项，可以确保调度器做出你所希望的决策。</st> <st c="40989">也可以运行额外的调度器配置文件，或者完全用一个遵循</st>
    <st c="41132">不同规则的客户配置文件替换默认的调度器。</st>
- en: <st c="41148">This is a pretty advanced operation, as it requires a deep understanding
    of how the scheduler works and how you need to change it to optimize the platform.</st>
    <st c="41305">However, if you do decide that this is necessary, we’d recommend
    starting with an additional profile before replacing</st> <st c="41423">the default.</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41148">这是一项相当高级的操作，因为它需要深入理解调度器的工作原理，以及如何根据需要进行更改以优化平台。</st> <st c="41305">然而，如果您确实决定这是必要的，我们建议在替换默认配置之前，先从额外的配置文件开始。</st>
    <st c="41423">替换默认配置。</st>
- en: <st c="41435">Important note</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41435">重要说明</st>
- en: <st c="41450">For OpenShift users, while the end result is the same, the process
    of implementing an exclusive CPU in OpenShift is slightly different and leverages
    machine sets.</st> <st c="41614">Check the latest OpenShift Container Platform
    docs for up-to-date instructions on this topic for</st> <st c="41711">that product.</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41450">对于 OpenShift 用户，尽管最终结果相同，但在 OpenShift 中实现独占 CPU 的过程略有不同，并且使用了机器集（machine
    sets）。</st> <st c="41614">请查阅最新的 OpenShift 容器平台文档，以获取有关该产品的最新操作指南。</st> <st c="41711">产品相关的最新信息。</st>
- en: <st c="41724">Rate limiting and network health</st>
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="41724">速率限制和网络健康</st>
- en: <st c="41757">Rate limiting</st> <st c="41771">is the capping of network</st>
    <st c="41797">traffic or HTTP requests that a service will respond to from a requestor.</st>
    <st c="41872">Each response has a computational cost, so rate limiting acts as
    a protective measure against endpoints being exploited, either intentionally or
    through</st> <st c="42025">an error.</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41757">速率限制</st> <st c="41771">是对服务响应请求者请求的网络流量或 HTTP 请求的限制。</st> <st
    c="41797">每个响应都有计算成本，因此速率限制作为一种保护措施，防止端点被恶意利用，无论是故意的还是由于</st> <st c="42025">错误导致的。</st>
- en: <st c="42034">A common takedown of a system is</st> <st c="42068">a</st> **<st
    c="42070">Distributed Denial-of-Service</st>** <st c="42099">(</st>**<st c="42101">DDoS</st>**<st
    c="42105">) attack.</st> <st c="42116">While such an attack can be initiated by
    a bad actor, it can also be carried out by accident due to human error or a buggy
    piece of software.</st> <st c="42258">DDoS is the most classic example of a noisy
    neighbor.</st> <st c="42312">Computationally expensive, it can be executed either
    via sheer number of requests floodi</st><st c="42400">ng the networking layer,
    spending compute, or through requests that would result in data returns that are
    astronomically large or computationally expensive</st> <st c="42557">to get.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42034">系统的常见摧毁方式是</st> <st c="42068">**<st c="42070">分布式拒绝服务</st>** <st
    c="42099">（</st>**<st c="42101">DDoS</st>**<st c="42105">）攻击。</st> <st c="42116">虽然此类攻击可以由恶意行为者发起，但也可能由于人为错误或软件缺陷而意外发生。</st>
    <st c="42258">DDoS 是最经典的噪音邻居示例。</st> <st c="42312">计算成本高，它可以通过大量请求淹没网络层，消耗计算资源，或者通过请求返回天文数字般庞大或计算上昂贵的数据来执行。</st>
    <st c="42400">这些请求可能导致的数据返回需要非常庞大或计算量极大的资源才能获取。</st> <st c="42557">获取这些数据的代价极高。</st>
- en: <st c="42564">Rate limits can be implemented to prevent a large number of back-to-back
    calls from creating a noisy neighbor scenario.</st> <st c="42685">This can be
    handled in the cluster ingress, such as nginx.</st> <st c="42744">But there are
    also discreet Kubernetes features within the API server that can be leveraged</st>
    <st c="42836">as well.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42564">可以实现速率限制，以防止大量连续请求造成噪音邻居现象。</st> <st c="42685">可以在集群入口（例如 nginx）中处理此问题。</st>
    <st c="42744">但在 API 服务器中也有一些独立的 Kubernetes 功能可以利用。</st> <st c="42836">同样可以使用。</st>
- en: <st c="42844">On the API server itself, your team can set API priority and fairness
    rules to help prevent traffic flooding.</st> <st c="42955">This is especially
    important if the noisy neighbor situation is coming from an internal source, meaning
    that cluster ingress is not a factor.</st> <st c="43097">For example, if a backup
    job is misconfigured and it’s trying to query data from within a cluster to create
    backups, or push them too often, applying rate limits can help prevent this job
    from flooding the network layer.</st> <st c="43318">By default, basic priority
    and fairness rules are enabled, although it is possible to alter or disable the
    rules entirely if desired.</st> <st c="43452">However, that’s</st> <st c="43468">not
    recommended.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42844">在 API 服务器本身，您的团队可以设置 API 优先级和公平性规则，帮助防止流量泛滥。</st> <st c="42955">如果噪音邻居问题来自内部源（即集群入口不再是一个因素），这尤其重要。</st>
    <st c="43097">例如，如果备份作业配置错误，并且它试图从集群内部查询数据来创建备份，或者过于频繁地推送备份，应用速率限制可以帮助防止该作业淹没网络层。</st>
    <st c="43318">默认情况下，启用了基本的优先级和公平性规则，尽管如果需要，完全可以更改或禁用这些规则。</st> <st c="43452">然而，</st>
    <st c="43468">不推荐这么做。</st>
- en: <st c="43484">Cluster scaling and other policies</st>
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="43484">集群扩展和其他策略</st>
- en: <st c="43519">What other policies prevent noisy neighbor situations?</st> <st
    c="43575">Autoscaling</st> <st c="43586">is the most obvious to the authors, although
    there are surely many more.</st> <st c="43660">All of the tuning and planning
    for how to pack workloads onto the platform only goes so far, without the cluster
    ultimately needing to grow (or shrink) in size.</st> <st c="43821">The most classic
    of all noisy neighbor scenarios is caused simply by a platform too small to meet
    the demand of</st> <st c="43933">its users.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43519">还有哪些策略可以防止“吵闹邻居”情况？</st> <st c="43575">自动扩展</st> <st c="43586">是作者们最明显的选择，尽管肯定还有更多策略。</st>
    <st c="43660">所有的调优和规划，如何将工作负载压缩到平台上，最终都无法避免集群需要扩展（或缩小）规模。</st> <st c="43821">最经典的“吵闹邻居”场景，往往是由于平台规模过小，无法满足</st>
    <st c="43933">用户的需求。</st>
- en: <st c="43943">Where the resource constraints are in the platform will determine
    how the cluster should scale.</st> <st c="44040">If additional resources are needed
    for non-system components that run on worker nodes, then adding another node to
    the cluster will do the trick.</st> <st c="44186">However, if, despite previous
    efforts, etcd is filling up or the API server encounters constraints, a larger
    control plane</st> <st c="44309">is necessary.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43943">平台中的资源约束将决定集群如何扩展。</st> <st c="44040">如果需要为在工作节点上运行的非系统组件提供额外资源，那么向集群中添加一个节点就可以解决问题。</st>
    <st c="44186">然而，如果尽管已经采取了先前的措施，etcd仍然填满，或者API服务器遇到约束，则需要更大的控制平面</st> <st c="44309">来解决。</st>
- en: <st c="44322">Observability data is the</st> <st c="44349">best measure for
    when and how to scale a cluster.</st> <st c="44399">This data can be collected
    on compute resource utilization by workloads and workload performance.</st> <st
    c="44497">As utilization increases, if thresholds for remaining resources are
    met or exceeded, a cluster scaling event can be triggered.</st> <st c="44624">Your
    observability can also be used even more creatively.</st> <st c="44682">A common
    technical interview question is a troubleshooting problem.</st> <st c="44750">The
    solution is always that a cron job uses too many resources and causes system crashes.</st>
    <st c="44840">With observability in place, you don’t need a human to discover
    that; you can use data.</st> <st c="44928">Significant spikes in resource utilization,
    either on the Pod or node level, can be captured and alerted on.</st> <st c="45037">But
    if you needed to respond to an alert, then this is also an opportunity</st> <st
    c="45112">for automation.</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44322">可观测性数据是</st> <st c="44349">衡量何时以及如何扩展集群的最佳标准。</st> <st c="44399">这些数据可以通过工作负载的计算资源利用率和工作负载性能来收集。</st>
    <st c="44497">随着利用率的增加，如果剩余资源的阈值被达到或超过，则可以触发集群扩展事件。</st> <st c="44624">您的可观测性数据也可以被更加创造性地使用。</st>
    <st c="44682">一个常见的技术面试问题是排查问题。</st> <st c="44750">解决方案总是一个定时任务（cron job）占用了过多资源，导致系统崩溃。</st>
    <st c="44840">有了可观测性，您不需要人工去发现这一点；您可以使用数据。</st> <st c="44928">无论是在Pod级别还是节点级别，资源利用的显著波动都可以被捕获并发出警报。</st>
    <st c="45037">但如果您需要响应警报，那么这也是一个自动化的机会。</st>
- en: <st c="45127">And finally, if all else fails, you can use an event-driven system
    to react to the data collected by the observability stack to restart the faulty
    Pod.</st> <st c="45280">This works and should keep the mission-critical components
    going, but it doesn’t replace a human permanently fixing whatever caused the resource
    utilization to</st> <st c="45440">begin with.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45127">最后，如果所有方法都失败了，您可以使用事件驱动系统，基于可观测堆栈收集的数据反应，重新启动故障Pod。</st> <st c="45280">这能有效工作，并保持关键任务组件的运行，但它不能永久替代人为解决导致资源利用问题的根本原因。</st>
    <st c="45440">最初的原因。</st>
- en: <st c="45451">In short, maintaining cluster health and appropriate user and
    workload isolation is key to ensuring that users of a platform can focus on what
    matters most to them, helping us to lay the foundation for the next aspect of
    a successful platform –</st> <st c="45697">self-service.</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45451">简而言之，保持集群健康和适当的用户与工作负载隔离是确保平台用户能够专注于最重要事项的关键，帮助我们为成功平台的下一个方面——</st>
    <st c="45697">自助服务。</st>
- en: <st c="45710">Enabling self-service developer portals</st>
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="45710">启用自助服务开发者门户</st>
- en: <st c="45750">We’ve already stated that a</st> <st c="45779">platform is not
    a platform if self-service isn’t a core tenant of its design.</st> <st c="45857">Now,
    it’s time to understand what that means and how it pertains to the promised reduction
    of cognitive load.</st> <st c="45967">The platform team can’t be on hand to approve
    everything all the time.</st> <st c="46038">As such, it is imperative to put some
    control into the hands of end users, without failing to save them from an increase
    in cognitive load.</st> <st c="46178">This dichotomy requires striking a careful
    balance, which must be discussed and negotiated between the stakeholders to be
    successful.</st> <st c="46312">A platform team trying to control everything too
    tightly prevents the platform from scaling with the users, as it’ll always be
    limited to the size and location of the team.</st> <st c="46485">This means it’s
    time to think about how you help your users help themselves.</st> <st c="46562">What
    should a developer or team be able to do without higher levels of approval?</st>
    <st c="46643">What should be restricted?</st> <st c="46670">How do you enable
    sensible self-service, and how do you enforce reasonable restrictions?</st> <st
    c="46759">We’ve discussed the importance of treating your platform like a product,
    but functionally, the product type is a service.</st> <st c="46881">Any product
    sold “as a service” comes not just with a guarantee of features but also a guarantee
    of engagement and experience from the company selling</st> <st c="47032">the</st>
    **<st c="47036">Software as a Service</st>** <st c="47057">(</st>**<st c="47059">SaaS</st>**<st
    c="47063">) or</st> **<st c="47069">Platform as a Service</st>** <st c="47090">(</st>**<st
    c="47092">PaaS</st>**<st c="47096">).</st> <st c="47100">Even if you’re</st> <st
    c="47114">not selling your PaaS, you should adopt the mindset of service to ensure
    that users are at the center of your</st> <st c="47225">usability considerations.</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45750">我们已经明确指出，如果自助服务不是平台设计的核心要素，那么它就不是一个真正的平台。</st> <st c="45779">现在，是时候理解这意味着什么，以及它如何与减轻认知负担的承诺相关。</st>
    <st c="45857">平台团队不可能时刻在场来审批所有事情。</st> <st c="45967">因此，将一些控制权交到最终用户手中是至关重要的，同时也不能增加他们的认知负担。</st>
    <st c="46038">这种二分法需要找到一个小心的平衡点，这必须通过利益相关者之间的讨论和协商来达成成功。</st> <st c="46178">平台团队如果过于紧密地控制一切，会阻止平台随着用户的发展而扩展，因为它将始终受限于团队的规模和位置。</st>
    <st c="46312">这意味着现在是时候思考如何帮助用户自助。</st> <st c="46485">开发者或团队应该能够在无需更高审批级别的情况下做什么？</st>
    <st c="46562">哪些操作应该被限制？</st> <st c="46643">如何实现合理的自助服务，又如何强制执行合理的限制？</st> <st
    c="46670">我们已经讨论过将平台视为产品的重要性，但从功能上讲，这个产品类型是服务。</st> <st c="46759">任何以“服务”形式销售的产品，不仅需要保证功能，还要保证公司提供的参与度和体验。</st>
    <st c="46881">这适用于**<st c="47036">软件即服务（SaaS）</st>** <st c="47057">或</st> **<st
    c="47069">平台即服务（PaaS）</st>** <st c="47090">。即便你没有销售你的 PaaS，你也应该采纳服务心态，以确保用户始终处于你的</st>
    <st c="47225">可用性考虑的核心。</st>
- en: <st c="47250">Simply put, self-service</st> <st c="47276">means that a user
    can accomplish a reasonable action with reasonable ease, without negatively impacting
    unrelated users or teams.</st> <st c="47406">Understanding self-service as it
    pertains to your platform requires understanding the needs of your users.</st>
    <st c="47513">It’s important to meet your users where they are.</st> <st c="47563">If
    your users are of the kind that spend their whole day on a command</st> <st c="47632">line,
    a</st> **<st c="47641">command-line interface</st>** <st c="47663">(</st>**<st
    c="47665">CLI</st>**<st c="47668">) may be the tool they need most to get the</st>
    <st c="47713">job done.</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47250">简而言之，自助服务</st> <st c="47276">意味着用户可以以合理的方式完成合理的操作，而不会对无关的用户或团队产生负面影响。</st>
    <st c="47406">理解自助服务如何适应你的平台，首先需要了解用户的需求。</st> <st c="47513">了解你的用户所在的工作环境非常重要。</st>
    <st c="47563">如果你的用户是那种整天都待在命令行界面上的人，</st> <st c="47632">那么</st> **<st c="47641">命令行界面（CLI）</st>**
    <st c="47663">可能是他们最需要的工具来完成工作。</st>
- en: <st c="47722">However, if your IDP is being used for docs as code instead, in
    addition to code as code, it’s probable that the team leveraging it may benefit
    from a UI instead of</st> <st c="47888">a CLI.</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47722">然而，如果你的 IDP 被用于文档作为代码，而不是代码作为代码，那么使用它的团队可能会从 UI 中受益，而不是</st> <st
    c="47888">命令行界面（CLI）</st>。
- en: <st c="47894">How does the end user want to accomplish their goals?</st> <st
    c="47949">How does the end user want to receive feedback from platform jobs?</st>
    <st c="48016">When we approach self-service, these are the questions we need to
    ask.</st> <st c="48087">Generally speaking, the platform team should have parameters
    that the developers can operate within.</st> <st c="48188">For example, you can
    guarantee that certain workloads only land in certain locations, and you can tie
    resource (memory and CPU) limits to namespaces within your</st> <st c="48349">Kubernetes
    cluster.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47894">最终用户希望如何实现他们的目标？</st> <st c="47949">最终用户希望如何从平台作业中获取反馈？</st> <st
    c="48016">当我们接近自助服务时，这些是我们需要问的问题。</st> <st c="48087">一般来说，平台团队应该有一些开发者可以操作的参数。</st>
    <st c="48188">例如，你可以保证某些工作负载只会落在特定的位置，并且可以将资源（内存和 CPU）限制绑定到你的</st> <st c="48349">Kubernetes
    集群中的命名空间。</st>
- en: <st c="48368">Tip</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48368">提示</st>
- en: <st c="48372">Once you begin down this path to fine-tune how workloads land
    and consume resources, it starts influencing cluster capacity artificially.</st>
    <st c="48511">It’s important to only implement this strategy when it becomes truly
    necessary, or after creating a comprehensive cluster scaling and</st> <st c="48645">capacity
    plan.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48372">一旦你开始调整工作负载如何分配和消耗资源，这将开始人工影响集群容量。</st> <st c="48511">在真正需要时，或者在创建了全面的集群扩展和</st>
    <st c="48645">容量规划后，才应实施此策略。</st>
- en: <st c="48659">Enforcing quota</st>
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="48659">强制执行配额</st>
- en: <st c="48675">A user or team</st> <st c="48691">should be able to land their
    application within the application landing zone.</st> <st c="48769">However, they
    should not be able to do this without reasonable restrictions.</st> <st c="48846">These
    restrictions, such as resource consumption, can be limited to a per-namespace
    basis.</st> <st c="48937">This is done by specifying the kind ResourceQuota.</st>
    <st c="48988">You’ll make a YAML file and apply it to the namespace.</st> <st
    c="49043">Continue reading to see what it will</st> <st c="49080">look like.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48675">用户或团队</st> <st c="48691">应该能够将他们的应用程序部署到应用程序着陆区。</st> <st c="48769">然而，他们不应该在没有合理限制的情况下这样做。</st>
    <st c="48846">这些限制，如资源消耗，可以在每个命名空间的基础上进行限制。</st> <st c="48937">这可以通过指定 ResourceQuota
    类型来完成。</st> <st c="48988">你需要创建一个 YAML 文件，并将其应用到命名空间。</st> <st c="49043">继续阅读，看看它将</st>
    <st c="49080">是什么样的。</st>
- en: <st c="49090">First, create a YAML file; let’s call</st> <st c="49129">it</st>
    `<st c="49132">your-dev-quota.yaml</st>`<st c="49151">:</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49090">首先，创建一个 YAML 文件；我们称其为</st> <st c="49129">`your-dev-quota.yaml`</st>
    <st c="49151">：</st>
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="49385">Save the file, and now apply the YAML to the namespace.</st> <st
    c="49442">Your command will look something</st> <st c="49475">like this:</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49385">保存文件，现在将 YAML 应用到命名空间。</st> <st c="49442">你的命令看起来像这样：</st> <st
    c="49475">类似这样：</st>
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="49553">Now, your developer can schedule any Pods within their namespaces
    as they need to, but the workloads have to stay within the quota boundaries provided
    to them.</st> <st c="49714">The creation of a quota for namespaces helps to enable
    multi-tenancy within a platform.</st> <st c="49802">Divvying up resources to users
    in a way that utilizes cluster capacity without over-taxing it allows users to
    operate independently, but within</st> <st c="49946">reasonable boundaries.</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49553">现在，你的开发者可以根据需要在他们的命名空间中安排任何 Pods，但工作负载必须保持在分配给他们的配额边界内。</st> <st
    c="49714">为命名空间创建配额有助于在平台中实现多租户。</st> <st c="49802">将资源分配给用户的方式可以在不超负荷集群的情况下利用集群容量，从而允许用户独立操作，但仍然在</st>
    <st c="49946">合理的边界内。</st>
- en: <st c="49968">Quotas can also be managed with GitOps, thereby streamlining requests
    to increase quota or alter quotas from users.</st> <st c="50085">If the process
    for a user to adjust their quota is raising a</st> **<st c="50146">pull request</st>**
    <st c="50158">(</st>**<st c="50160">PR</st>**<st c="50162">) and then</st> <st
    c="50173">waiting for it to be</st> <st c="50194">approved, this makes it much
    easier for them to interact with a platform.</st> <st c="50269">Ease of use will
    be a large factor in the platform’s success within</st> <st c="50337">an organization.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49968">配额也可以通过 GitOps 来管理，从而简化用户增加或更改配额的请求。</st> <st c="50085">如果用户调整配额的过程是发起一个</st>
    **<st c="50146">拉取请求</st>** <st c="50158">(</st>**<st c="50160">PR</st>**<st c="50162">)，然后</st>
    <st c="50173">等待批准，这样可以使他们更容易与平台互动。</st> <st c="50194">易用性将是平台在组织内成功的一个重要因素。</st>
    <st c="50269">易用性将是平台在</st> <st c="50337">组织内成功的关键因素。</st>
- en: <st c="50353">Simple repeatable workflows</st>
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="50353">简单的可重复工作流</st>
- en: <st c="50381">We talked about the</st> <st c="50402">importance of simple workflows
    for reducing cognitive load, and truly, this is a topic we could have stuck anywhere
    in this chapter.</st> <st c="50535">However, this aligns most with self-service,
    as it is a core feature.</st> <st c="50605">For a platform to deliver on the promise
    of self-service, it must be easy to use, and the uses must be easy</st> <st c="50713">to
    remember.</st>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50381">我们谈到了</st> <st c="50402">简化工作流对于减少认知负担的重要性，实际上，这个话题我们可以在本章的任何地方提到。</st>
    <st c="50535">然而，这最符合自服务功能，因为它是核心特性。</st> <st c="50605">为了让平台实现自服务的承诺，它必须易于使用，而且使用方式必须容易</st>
    <st c="50713">记住。</st>
- en: <st c="50725">We refer again to our golden path.</st> <st c="50761">A developer
    building an app pushes a commit.</st> <st c="50806">The change makes its way through
    the CI/CD systems until, ultimately, the app install or upgrade lands in the application
    landing zone.</st> <st c="50942">The journey for that PR must be easy to understand,
    intuitive, and predictable for the development team.</st> <st c="51047">If the
    team needs to make changes to the CI jobs, or the CD logic specific to their application,
    then they should expect to have easy access to the governing systems to do</st>
    <st c="51219">just that.</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50725">我们再次提到我们的黄金路径。</st> <st c="50761">一个开发人员构建应用程序并提交了一个提交。</st> <st
    c="50806">该更改通过 CI/CD 系统直到最终，应用程序安装或升级被推送到应用程序落地区。</st> <st c="50942">该 PR 的整个过程必须对开发团队来说易于理解、直观且可预测。</st>
    <st c="51047">如果团队需要更改 CI 工作或与其应用程序特定的 CD 逻辑，那么他们应该能够轻松访问管理系统来进行</st> <st c="51219">这些操作。</st>
- en: <st c="51229">Let’s bring back our teams for Financial One ACME.</st> <st c="51281">We
    can expand this example one step further and imagine again that the company includes
    multiple personas or user types.</st> <st c="51402">If we consider a development
    team and a corresponding docs team, what would each team need from the</st> <st
    c="51502">CI system?</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51229">让我们重新回到 Financial One ACME 团队。</st> <st c="51281">我们可以进一步扩展这个例子，再次设想公司包含多个角色或用户类型。</st>
    <st c="51402">如果我们考虑一个开发团队和一个相应的文档团队，那么每个团队从</st> <st c="51502">CI 系统中需要什么呢？</st>
- en: <st c="51512">It’s safe to say both teams need the ability to land their jobs
    within the system, to understand whether jobs are successful or failed, and to
    know whether the overall CI pipeline succeeded or failed.</st> <st c="51714">However,
    they may have different needs for interacting with the CI system.</st> <st c="51789">A
    developer or a DevOps engineer may prefer to use a CLI, whereas a docs team or
    a non-technical team may prefer</st> <st c="51901">a</st> **<st c="51904">graphical
    user interface</st>** <st c="51928">(</st>**<st c="51930">GUI</st>**<st c="51933">)
    to leverage</st> <st c="51948">a system.</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51512">可以肯定地说，两个团队都需要能够在系统内完成他们的工作，了解工作是否成功或失败，并知道整体 CI 管道是否成功或失败。</st>
    <st c="51714">然而，他们可能在与 CI 系统交互时有不同的需求。</st> <st c="51789">开发人员或 DevOps 工程师可能更倾向于使用
    CLI，而文档团队或非技术团队可能更喜欢使用</st> **<st c="51904">图形用户界面</st>** <st c="51928">(</st>**<st
    c="51930">GUI</st>**<st c="51933">) 来利用</st> <st c="51948">这个系统。</st>
- en: <st c="51957">The open source CI/CD projects Tekton and Argo CD both ship with
    a GUI.</st> <st c="52030">Both systems also can leverage CLI tools designed to
    interface with the project.</st> <st c="52111">For users of the systems, as long
    as they’ve been granted correct access, they can choose their own adventure for
    the actual interactions with these systems and can determine which is easier,
    keeping a CLI up to date locally or using a GUI occasionally.</st> <st c="52365">By
    being flexible, these tools and your IDP, should you adopt them, enable users
    to self-service based on</st> <st c="52471">their ease.</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51957">开源 CI/CD 项目 Tekton 和 Argo CD 都配备了 GUI。</st> <st c="52030">这两个系统还可以利用专门设计的
    CLI 工具来与项目进行交互。</st> <st c="52111">对于这些系统的用户，只要他们获得了正确的访问权限，他们可以根据自己的需求选择与这些系统交互的方式，并决定哪种方式更容易，保持本地
    CLI 更新，还是偶尔使用 GUI。</st> <st c="52365">通过灵活性，这些工具和你的 IDP（如果你采用它们）能够让用户根据</st> <st
    c="52471">他们的便利性自助服务。</st>
- en: <st c="52482">However, with something such as</st> <st c="52514">CI pipelines,
    which may take significant time to complete, other options such as API calls or
    Webhook integrations into common tools such as Slack may more easily meet the
    users where they are.</st> <st c="52709">Just as with inputs, the platform should
    meet users where they are for outputs, as the fewer times your users have to context-shift,
    the lower their cognitive load and the easier self-service goals</st> <st c="52907">are
    achieved.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52482">然而，对于像</st> <st c="52514">CI 管道这样的任务，可能需要很长时间才能完成，其他选项，如 API 调用或
    Webhook 集成到 Slack 等常用工具中，可能更容易满足用户需求。</st> <st c="52709">就像输入一样，平台应该在输出时满足用户需求，因为用户需要频繁切换上下文的次数越少，他们的认知负担就越轻，自助服务目标就越容易实现。</st>
- en: <st c="52920">Important note</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52920">重要提示</st>
- en: <st c="52935">A CI pipeline</st> <st c="52949">is typically a series of jobs;
    some run synchronously, and some run asynchronously to build and validate an application
    based on recent changes.</st> <st c="53095">This could be one PR at a time (CI
    at its core), but it could also be less frequent, such</st> <st c="53185">as daily.</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52935">CI 管道</st> <st c="52949">通常是一系列任务；其中一些同步运行，一些异步运行，以根据最近的更改构建和验证应用程序。</st>
    <st c="53095">这可能是每次一个 PR（CI 的核心），但也可能不那么频繁，比如每天。</st>
- en: <st c="53194">Even highly technical users love a good GUI, and if they’re already
    interfacing with something such as GitHub or GitLab for a PR review, they may
    not feel like changing paradigms again.</st> <st c="53381">So, while the average
    user may never need to see the internals of the Kubernetes clusters they’re interacting
    with, we did say that the platform should drink its own champagne.</st> <st c="53558">This
    includes best practices such as meeting users where they are.</st> <st c="53625">Some
    Kubernetes solutions such as OpenShift ship with a GUI layer included.</st> <st
    c="53701">For the ones that do not, Lens (</st>[<st c="53733">https://k8slens.dev/</st>](https://k8slens.dev/)<st
    c="53754">) provides</st> <st c="53765">an</st> <st c="53769">easy-to-use GUI.</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53194">即使是高度技术化的用户也喜欢一个好的 GUI，如果他们已经在使用像 GitHub 或 GitLab 这样的工具进行 PR 审查，他们可能不想再改变范式。</st>
    <st c="53381">因此，尽管普通用户可能永远不需要看到他们交互的 Kubernetes 集群的内部细节，但我们确实说过，平台应该“自酿香槟”。</st>
    <st c="53558">这包括一些最佳实践，比如在用户所在的位置与他们会面。</st> <st c="53625">一些 Kubernetes 解决方案，如
    OpenShift，随附 GUI 层。</st> <st c="53701">对于那些没有 GUI 的解决方案，Lens（</st>[<st c="53733">https://k8slens.dev/</st>](https://k8slens.dev/)<st
    c="53754">）提供了一个</st> <st c="53765">易于使用的 GUI。</st>
- en: '![Figure 6.6: The Lens GUI connected to a local kind cluster representing an
    IDP](img/B31164_06_06.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：连接到本地 kind 集群的 Lens GUI，代表一个 IDP](img/B31164_06_06.jpg)'
- en: '<st c="56728">Figure 6.6: The Lens GUI connected to a local kind cluster representing
    an IDP</st>'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56728">图 6.6：连接到本地 kind 集群的 Lens GUI，代表一个 IDP</st>
- en: <st c="56806">To summarize, developer self-service is about meeting your users
    where they are and giving them the tools to be successful with a platform.</st>
    <st c="56947">Tshis means understanding their needs but also giving them the capabilities
    to integrate the platform to their way of working, not making their way of working
    fit</st> <st c="57110">the platform.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56806">总之，开发者自助服务是关于在用户所在的位置与他们会面，并为他们提供成功使用平台的工具。</st> <st c="56947">这意味着理解他们的需求，同时还要赋予他们将平台与他们工作方式整合的能力，而不是让他们的工作方式适应平台。</st>
    <st c="57110">平台。</st>
- en: <st c="57123">Landing, expanding, and integrating your IDP</st>
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="57123">落地、扩展和集成你的 IDP</st>
- en: <st c="57168">If you followed our recommendations in</st> [*<st c="57208">Chapter
    3</st>*](B31164_03.xhtml#_idTextAnchor133)<st c="57217">, you’ve interviewed the
    users, you’ve mapped the use cases, and you’ve designed your platform.</st> <st
    c="57313">Now comes the fun part – turning it into</st> <st c="57354">something
    real.</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57168">如果你按照我们在</st> [*<st c="57208">第 3 章</st>*](B31164_03.xhtml#_idTextAnchor133)<st
    c="57217">中的建议，已经采访了用户，已经绘制了用例，并且设计了你的平台。</st> <st c="57313">现在是有趣的部分——将它变成</st>
    <st c="57354">现实。</st>
- en: <st c="57369">Let’s look at the most basic IDP.</st> <st c="57404">What does
    it do?</st> <st c="57421">Most importantly, users can authenticate to it with
    appropriate access and permissions.</st> <st c="57509">It has a CI system, a CD
    system, at least some basic security tooling such as scanning, and these days,
    something to generate an SBOM.</st> <st c="57644">What about the production location
    for the software that the developers are writing?</st> <st c="57729">Where is
    that?</st> <st c="57744">How does the promotion process look?</st> <st c="57781">Let’s
    look again at our IDP golden path from earlier in</st> *<st c="57837">Figure 6</st>**<st
    c="57845">.3</st>*<st c="57847">.</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57369">让我们来看一下最基础的IDP。</st> <st c="57404">它是做什么的？</st> <st c="57421">最重要的是，用户可以通过适当的访问权限和权限来认证它。</st>
    <st c="57509">它具有CI系统、CD系统，至少一些基本的安全工具，如扫描功能，现如今还可以生成SBOM。</st> <st c="57644">那么开发人员编写的软件的生产位置在哪里呢？</st>
    <st c="57729">它在哪里？</st> <st c="57744">促销流程是怎样的？</st> <st c="57781">让我们再看一下之前提到的IDP黄金路径</st>
    *<st c="57837">图6</st>**<st c="57845">.3</st>*<st c="57847">。</st>
- en: <st c="57848">There are a lot of pieces in this drawing, and software development
    should be iterative, which means we’re not going to be landing everything seen
    here all at once.</st> <st c="58014">So, let’s look at landing an IDP.</st> <st
    c="58048">What does the thinnest viable platform</st> <st c="58087">look like?</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57848">这个图中有很多组成部分，软件开发应该是迭代性的，这意味着我们不会一次性完成所有看到的内容。</st> <st c="58014">所以，让我们来看看如何实现一个IDP。</st>
    <st c="58048">最简单可行的平台</st> <st c="58087">是什么样的？</st>
- en: <st c="58097">It’s probably something</st> <st c="58122">like this:</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58097">它可能是这样的</st> <st c="58122">：</st>
- en: <st c="58132">Authentication</st> <st c="58148">and RBAC</st>
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="58132">身份验证</st> <st c="58148">和RBAC</st>
- en: <st c="58156">Security checks</st>
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="58156">安全检查</st>
- en: <st c="58172">CI/CD</st>
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="58172">CI/CD</st>
- en: <st c="58178">An application</st> <st c="58194">landing zone</st>
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="58178">一个应用</st> <st c="58194">登陆区</st>
- en: <st c="58206">Technically, a CD system isn’t necessary, as long as there’s some
    promotion process for application features and enhancements to reach production.</st>
    <st c="58354">With such a scaled-down approach, or thinnest viable platform, it’s
    fairly easy to see how to land an IDP within an organization.</st> <st c="58484">The
    appeal of a new and shiny product may even drive users to play with it and help
    drive initial adoption.</st> <st c="58592">However, keeping those users engaged
    and attracting the more reticent will require expanding upon the initial offering
    and ensuring that what users use is easy to understand</st> <st c="58766">and
    performant.</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58206">从技术上讲，CD系统并不是必须的，只要有某种促销过程将应用特性和增强功能推向生产环境。</st> <st c="58354">采用这种精简的方法，或者最简可行平台，我们可以很容易地看到如何在一个组织中实现IDP。</st>
    <st c="58484">新产品的吸引力甚至可能促使用户去尝试，并帮助推动初期的采纳。</st> <st c="58592">然而，保持这些用户的参与，并吸引更多犹豫不决的用户，需要扩展初始的提供内容，并确保用户使用的东西是易于理解的</st>
    <st c="58766">且高效的。</st>
- en: <st c="58781">Expanding your IDP, though – how does that look?</st> <st c="58831">Expansion
    may look something like capacity planning, but how will you scale and size your
    resources as the adoption of the platform grows?</st> <st c="58970">In Kubernetes,
    this will mean figuring out cluster sizing and/or</st> <st c="59035">cluster count.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58781">不过，扩展你的IDP——这看起来是什么样的？</st> <st c="58831">扩展可能看起来像是容量规划，但随着平台采用的增长，你如何调整和配置你的资源？</st>
    <st c="58970">在Kubernetes中，这意味着要确定集群的大小和/或</st> <st c="59035">集群数量。</st>
- en: <st c="59049">The expansion will also include features and enhancements, as
    well as planning not just for the development and rollout but also the operations
    of those enhancements.</st> <st c="59217">What are the impacts on the platform
    of adding another feature or integration?</st> <st c="59296">How do you measure
    the success of an enhancement, and how do you use data to determine its return</st>
    <st c="59394">on investments?</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59049">扩展还将包括特性和增强功能的添加，以及不仅是开发和推出的规划，还要考虑这些增强功能的运营。</st> <st c="59217">增加另一个功能或集成会对平台产生什么影响？</st>
    <st c="59296">如何衡量增强功能的成功，并且如何利用数据来确定其投资回报率？</st> <st c="59394">投资回报率如何？</st>
- en: <st c="59409">Enforcement of platform-specific standards</st>
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="59409">强制执行平台特定的标准</st>
- en: <st c="59452">If we refer back to the</st> <st c="59477">beginning of the chapter,
    we mentioned that it’s important that platform-specific standards are easy to
    consume for end users, helping to guarantee a low cognitive load, and that this
    must include the enforcement of</st> <st c="59693">those standards.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59452">如果我们回顾本章开头，我们提到过，平台特定的标准对于终端用户来说应该容易理解，以帮助确保低认知负荷，并且这必须包括对</st>
    <st c="59693">这些标准的强制执行。</st>
- en: <st c="59709">There’s no one set way to do this, since norms can differ from
    platform to platform.</st> <st c="59795">However, we have found that there are
    a few things that work well in terms of both process and technology for you to
    adapt to</st> <st c="59921">your organization.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59709">没有一种固定的方法来做这件事，因为不同平台的规范可能会有所不同。</st> <st c="59795">然而，我们发现有一些在过程和技术上都行之有效的做法，适合你</st>
    <st c="59921">的组织。</st>
- en: <st c="59939">Maturity models</st>
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="59939">成熟度模型</st>
- en: <st c="59955">Maturity models fall</st> <st c="59976">slightly more into the
    sociotechnical aspect of cognitive load reduction.</st> <st c="60051">Defining
    maturity models for software applications as they onboard to a platform can help
    developers know they’re building out their application in the right way.</st>
    <st c="60214">This also helps to ensure that the reduction of cognitive load doesn’t
    result in a worse experience for end users, due to something being overlooked
    or forgotten.</st> <st c="60377">Essentially, it ensures that the interests of
    both parties are aligned from a</st> <st c="60455">platform perspective.</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59955">成熟度模型更倾向于认知负荷减少的社会技术方面。</st> <st c="59976">为软件应用定义成熟度模型，并将其引入平台，可以帮助开发者确保他们以正确的方式构建应用。</st>
    <st c="60051">这还可以确保认知负荷的减少不会由于忽略或遗忘某些内容而导致终端用户体验变差。</st> <st c="60214">从本质上讲，它确保了双方的利益从</st>
    <st c="60377">平台的角度是对齐的。</st>
- en: <st c="60476">An example of a standard for maturity would be that a new application
    would only onboard to a platform after it has been configured for high availability
    and disaster recovery, if it has unit tests, or if the team has written and committed
    their Prometheus queries and Grafana dashboards for application observability.</st>
    <st c="60796">These types of models can be enforced with CI jobs that check for
    the presence of whatever is deemed appropriate by the platform, or they could
    simply be published as guidelines for a team</st> <st c="60985">to follow.</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60476">一个成熟度标准的例子是，新的应用程序只有在经过高可用性和灾难恢复配置后，或者有单元测试，或者团队已经编写并提交了他们的 Prometheus
    查询和 Grafana 仪表盘以供应用可观测时，才会引入平台。</st> <st c="60796">这些类型的模型可以通过 CI 作业进行强制执行，检查平台认为适当的内容是否存在，或者它们可以简单地作为指南发布给团队</st>
    <st c="60985">进行遵循。</st>
- en: <st c="60995">Expanding a platform with common platform integrations</st>
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="60995">通过常见平台集成扩展平台</st>
- en: <st c="61050">Taking a platform beyond the thinnest viable platform and into
    a robust system will require leveraging new integrations and better harnessing
    the initial feature sets.</st> <st c="61219">Some common and useful integrations
    are outlined in</st> <st c="61271">this section.</st>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61050">将一个平台从最薄的可行平台扩展到一个强大的系统，将需要利用新的集成并更好地利用最初的功能集。</st> <st c="61219">一些常见且有用的集成在</st>
    <st c="61271">本节中进行了概述。</st>
- en: <st c="61284">Static analysis</st>
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="61284">静态分析</st>
- en: <st c="61300">How does a user know whether they’re matching with expected maturity
    models and</st> <st c="61381">platform norms?</st> <st c="61397">How do they receive
    feedback if they are not?</st> <st c="61443">One method for establishing this
    enforcement and feedback loop with users is via static analysis.</st> <st c="61541">When
    the development team submits a PR, then CI jobs kick off.</st> <st c="61604">It
    is during the first CI jobs that a static analysis tool is best positioned; this
    way, if the PR fails, the check compute is not spent needlessly on running tests
    or generating SBOMs, and the feedback loop to the end user raises the error much
    faster.</st> <st c="61858">Reducing time to feedback helps to keep developer velocity
    high and cognitive load low, since developers don’t need to remember to check
    back with the platform after a</st> <st c="62026">significant delay.</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61300">用户如何知道自己是否与预期的成熟度模型和</st> <st c="61381">平台规范相匹配？</st> <st c="61397">如果不匹配，他们如何获得反馈？</st>
    <st c="61443">一种与用户建立这种执行和反馈循环的方法是通过静态分析。</st> <st c="61541">当开发团队提交PR时，CI作业会启动。</st>
    <st c="61604">在第一次CI作业时，静态分析工具处于最佳位置；这样，如果PR失败，计算资源就不会浪费在运行测试或生成SBOM上，反馈循环也能更快地将错误信息反馈给最终用户。</st>
    <st c="61858">减少反馈时间有助于保持开发人员的工作效率高，并降低认知负荷，因为开发人员不需要记得在**<st c="62026">较长延迟后**</st>再回去检查平台。</st>
- en: <st c="62044">Example</st> <st c="62052">static analysis tools that can be leveraged
    at PR time are security audits that compare image versions to known</st> **<st
    c="62165">Critical Vulnerability Exploits</st>** <st c="62196">(</st>**<st c="62198">CVEs</st>**<st
    c="62202">) to</st> <st c="62208">ensure that vulnerable code is not being pushed.</st>
    <st c="62257">At the time of writing,</st> **<st c="62281">Snyk</st>** <st c="62285">is
    a</st> <st c="62291">popular choice for this, as it is open source and has free</st>
    <st c="62350">options.</st> **<st c="62359">CodeQL</st>** <st c="62365">is another
    popular choice and is also free for open source projects, so it’s very easy to
    find examples of it in use.</st> <st c="62484">Both of these tools are popular
    because they integrate well with</st> <st c="62549">GitHub workflows.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62044">例如</st> <st c="62052">可以在PR时使用的静态分析工具包括安全审计，这些审计将镜像版本与已知的**<st
    c="62165">关键漏洞利用</st>** <st c="62196">(</st>**<st c="62198">CVE</st>**<st c="62202">)进行比较，</st>
    <st c="62208">以确保不会推送有漏洞的代码。</st> <st c="62257">截至目前，</st> **<st c="62281">Snyk</st>**
    <st c="62285">是一个流行的选择，因为它是开源的，并且提供免费的</st> <st c="62350">选项。</st> **<st c="62359">CodeQL</st>**
    <st c="62365">是另一个流行的选择，也对开源项目免费，因此很容易找到它的使用示例。</st> <st c="62484">这两款工具都很受欢迎，因为它们与</st>
    <st c="62549">GitHub工作流集成得很好。</st>
- en: <st c="62566">For the enforcement of norms, however, there are also static</st>
    <st c="62627">analysis tools that verify whether an application conforms to cloud-native
    best practices.</st> <st c="62719">From the</st> **<st c="62728">StackRox</st>**
    <st c="62736">community,</st> **<st c="62748">KubeLinter</st>** <st c="62758">is
    an</st> <st c="62764">excellent example of this.</st> <st c="62792">It ships with
    a variety of checks but can be configured to skip checks that are not desired
    for a platform, or to accept</st> <st c="62913">custom checks.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62566">然而，对于规范的执行，也有一些静态</st> <st c="62627">分析工具，用于验证应用程序是否符合云原生最佳实践。</st>
    <st c="62719">来自</st> **<st c="62728">StackRox</st>** <st c="62736">社区，</st> **<st
    c="62748">KubeLinter</st>** <st c="62758">就是一个</st> <st c="62764">很好的例子。</st>
    <st c="62792">它带有多种检查，但可以配置为跳过不需要的平台检查，或者接受</st> <st c="62913">自定义检查。</st>
- en: <st c="62927">Both the aforementioned static analysis tools leverage GitHub
    workflows, which are declarative YAML to define what actions should happen within
    a repository once a PR is raised.</st> <st c="63106">For example, to run KubeLinter
    against the main branch of a repository with GitHub workflows, a</st> `<st c="63202">.github/workflows</st>`
    <st c="63219">directory would be added to the GitHub repository, and then a YAML
    file would be committed to it.</st> <st c="63318">That YAML would look something
    like this</st> `<st c="63359">kubelint.yaml</st>` <st c="63372">file:</st>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62927">上述提到的静态分析工具都利用了GitHub工作流，这是一种声明式YAML格式，用于定义当PR被提交时，应该在仓库中执行哪些操作。</st>
    <st c="63106">例如，要在GitHub工作流中对仓库的主分支运行KubeLinter，</st> `<st c="63202">.github/workflows</st>`
    <st c="63219">目录会被添加到GitHub仓库中，然后一个YAML文件会被提交到该目录。</st> <st c="63318">该YAML文件的内容大致如下</st>
    `<st c="63359">kubelint.yaml</st>` <st c="63372">文件：</st>
- en: '[PRE13]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="63834">Admission controllers and policy agents</st>
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="63834">准入控制器和策略代理</st>
- en: <st c="63874">Admission controllers</st> <st c="63896">are another feature of
    Kubernetes.</st> <st c="63932">They come in two flavors, validating and</st> <st
    c="63973">mutating Webhooks.</st> <st c="63992">Both reduce cognitive load and
    also enable self-service.</st> <st c="64049">However, they’re fairly advanced
    topics and may not be part of your platform MVP, or even in the top five integrations.</st>
    <st c="64169">As the platform itself evolves in maturity, these features can</st>
    <st c="64232">be adopted.</st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63874">Admission 控制器</st> <st c="63896">是 Kubernetes 的另一个特性。</st> <st
    c="63932">它们有两种形式，验证型和</st> <st c="63973">变更型 Webhook。</st> <st c="63992">两者都能减少认知负担，并启用自助服务。</st>
    <st c="64049">然而，它们是相对高级的主题，可能不是你平台 MVP 的一部分，甚至可能不在前五名集成中。</st> <st c="64169">随着平台的成熟，这些特性可以</st>
    <st c="64232">被采纳。</st>
- en: <st c="64243">If a mutating Webhook allows a platform to enforce a norm such
    as an environment variable transparently to the user, this allows them to worry
    less about the platform itself and more about the application.</st> <st c="64450">Then,
    if the environment variable changes, the developer doesn’t need to do anything
    differently on their side.</st> <st c="64562">A validating Webhook checks that
    the object being applied matches the expected parameters.</st> <st c="64653">You
    can leverage both types against workloads, and generally, you should always use
    a validation Webhook if you’re using a mutating Webhook to ensure that nothing
    else has incorrectly modified the object after the Webhook</st> <st c="64875">has
    responded.</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64243">如果变更型 Webhook 允许平台强制执行某个规范，例如对用户透明地设置环境变量，这让用户可以减少对平台本身的关注，更多地关注应用程序。</st>
    <st c="64450">然后，如果环境变量发生变化，开发者在他们这边不需要做任何不同的操作。</st> <st c="64562">验证型 Webhook
    检查所应用的对象是否符合预期的参数。</st> <st c="64653">你可以将这两种类型的 Webhook 用于工作负载，通常情况下，如果你使用变更型
    Webhook，你应该始终使用验证型 Webhook，以确保 Webhook 响应后没有其他地方错误地修改对象。</st> <st c="64875">已响应。</st>
- en: <st c="64889">Admission controllers are</st> <st c="64916">powerful but somewhat
    complex.</st> <st c="64947">They require setting up a server to run the controller
    and the Webhooks and responses to be written.</st> <st c="65048">Due to their
    size and complexity, relative to other methods of enforcing platform norms, they’re
    not suitable for a new IDP, but for large organizations with many users, they
    can become a</st> <st c="65236">powerful tool.</st>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64889">Admission 控制器是</st> <st c="64916">强大的，但有些复杂。</st> <st c="64947">它们需要设置服务器来运行控制器，并编写
    Webhook 和响应。</st> <st c="65048">由于它们的体积和复杂性，相较于其他平台规范强制执行方法，它们不适合新的 IDP，但对于拥有大量用户的大型组织，它们可以成为一个</st>
    <st c="65236">强大的工具。</st>
- en: <st c="65250">Admission controllers can be bespoke, but open source</st> <st
    c="65304">policy agents such</st> <st c="65323">as</st> **<st c="65327">Open Policy
    Agent (OPA)</st>** <st c="65350">or</st> **<st c="65354">Kyverno</st>** <st c="65361">leverage</st>
    <st c="65371">the same features and can help simplify their usage.</st> <st c="65424">Leveraging
    policy-based norms can help platform performance and prevent collisions</st> <st
    c="65507">between workloads.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65250">Admission 控制器可以是定制的，但开源</st> <st c="65304">策略代理</st> <st c="65323">例如</st>
    **<st c="65327">Open Policy Agent (OPA)</st>** <st c="65350">或</st> **<st c="65354">Kyverno</st>**
    <st c="65361">利用</st> <st c="65371">相同的特性，并能帮助简化它们的使用。</st> <st c="65424">利用基于策略的规范可以提升平台性能，并防止工作负载之间的冲突。</st>
    <st c="65507">工作负载之间的冲突。</st>
- en: <st c="65525">Observability</st>
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="65525">观察性</st>
- en: <st c="65539">To be covered in greater depth in the next section, observability</st>
    <st c="65605">is something that should exist from day one in the IDP and can and
    will be expanded.</st> <st c="65691">Observability should be considered a living
    integration, meaning that it is always being grown and modified to match the life
    cycle of</st> <st c="65826">a platform.</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65539">在下一节中将更深入地讨论，观察性</st> <st c="65605">是 IDP 从第一天开始就应该具备的特性，并且可以扩展。</st>
    <st c="65691">观察性应该被视为一个持续的集成过程，意味着它始终在增长和修改，以匹配</st> <st c="65826">平台的生命周期。</st>
- en: <st c="65837">Some common observability tools are</st> <st c="65874">Prometheus,
    Grafana, and Loki, and they can be used individually but are better configured
    in conjunction with</st> **<st c="65985">OpenTelemetry</st>** <st c="65998">(</st>**<st
    c="66000">Otel</st>**<st c="66004">) and the Otel protocol.</st> <st c="66030">When
    you combine these with Thanos for long-term storage, you can give yourself a little
    more data to analyze as well, which can be nice to understand the context and
    history of</st> <st c="66208">observability data.</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的可观察性工具包括<st c="65837">Prometheus、Grafana 和 Loki</st>，它们可以单独使用，但与**<st c="65985">OpenTelemetry</st>**
    <st c="65998">(</st>**<st c="66000">Otel</st>**<st c="66004">)</st>及Otel协议结合使用时效果更佳。</st>
    <st c="66030">当你将这些工具与Thanos结合用于长期存储时，你可以获得更多的数据来进行分析，这对于理解可观察性数据的上下文和历史非常有帮助。</st>
- en: <st c="66227">Respectively, these tools specialize in metric queries against
    Kubernetes objects as well as analysis of those metrics, visualization of metrics,
    and log aggregation.</st> <st c="66395">Additionally, this toolset can be used
    by single tenants with multiple users, or as a multi-tenant tool.</st> <st c="66500">The
    user authentication and RBAC for the IDP can be leveraged for these, just as they
    could with the CI/CD solutions we</st> <st c="66620">discussed previously.</st>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66227">这些工具分别专注于对Kubernetes对象的指标查询以及这些指标的分析、指标的可视化和日志聚合。</st> <st c="66395">此外，这套工具可以被多个用户的单租户使用，或者作为一个多租户工具使用。</st>
    <st c="66500">可以利用IDP的用户认证和RBAC，就像我们之前讨论的CI/CD解决方案一样。</st>
- en: <st c="66641">The MVP of a platform and its golden path should be the main focus
    of the initial observability implementation.</st> <st c="66754">Observability
    should be done in a way to measure user satisfaction, and</st> **<st c="66826">Service-Level
    Objectives</st>** <st c="66850">(</st>**<st c="66852">SLOs</st>**<st c="66856">)
    directly</st> <st c="66868">maps to a user’s success with the platform.</st> <st
    c="66912">Therefore, as a best practice, make sure that the core components of
    the golden path are available, have a set target for success and latency, and
    ensure that the platform team can leverage observability to make data-informed
    decisions, including tracking usage of certain features and the failure</st> <st
    c="67210">rates within.</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66641">平台的MVP和黄金路径应该是初始可观察性实施的主要焦点。</st> <st c="66754">可观察性应该以衡量用户满意度的方式进行，且</st>
    **<st c="66826">服务级目标</st>** <st c="66850">(</st>**<st c="66852">SLOs</st>**<st
    c="66856">)</st>直接</st> <st c="66868">映射到用户在平台上的成功。</st> <st c="66912">因此，作为最佳实践，请确保黄金路径的核心组件可用，并为成功和延迟设定目标，同时确保平台团队能够利用可观察性来做出数据驱动的决策，包括跟踪某些功能的使用情况以及其中的失败</st>
    <st c="67210">率。</st>
- en: <st c="67223">As an example, let’s say that Financial One ACME initially shipped
    a new platform MVP, with Tekton included for CI and Argo CD for CD.</st> <st c="67359">But
    thanks to the observability stack, the platform team can see that only 1% of users
    leverage the Tekton integration.</st> <st c="67479">This is an indicator that
    the CI needs are being met elsewhere.</st> <st c="67543">Thanks to this data,
    the team can take the decision to deprecate the Tekton deployment and reclaim
    some cluster capacity, while letting users continue to work in their preferred
    way.</st> <st c="67726">Alternatively, they could work to understand why the feature
    of the platform isn’t being used and seek to help users adopt the new</st> <st
    c="67857">CI system.</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67223">举个例子，假设Financial One ACME最初发布了一个新的平台MVP，包含了Tekton用于CI，Argo CD用于CD。</st>
    <st c="67359">但是，借助可观察性堆栈，平台团队发现只有1%的用户在使用Tekton集成。</st> <st c="67479">这表明CI需求可能在其他地方得到了满足。</st>
    <st c="67543">凭借这些数据，团队可以决定弃用Tekton部署并回收一些集群容量，同时让用户继续以他们喜欢的方式工作。</st> <st c="67726">另外，他们也可以深入理解为什么这个平台功能没有被使用，并寻求帮助用户采纳新的</st>
    <st c="67857">CI系统。</st>
- en: <st c="67867">Integrating your platform</st>
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="67867">集成你的平台</st>
- en: <st c="67893">Integration of the platform</st> <st c="67921">doesn’t just mean
    integrating components with each other; it also means integrating the IDP into
    a company’s way of working.</st> <st c="68047">This entails a service-first culture,
    user-centricity, feedback loops for operational excellence, and meeting users
    where</st> <st c="68169">they are.</st>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67893">平台集成</st> <st c="67921">不仅仅是将各个组件集成在一起；它还意味着将IDP融入到公司的工作方式中。</st>
    <st c="68047">这意味着服务优先的文化、以用户为中心、为运营卓越提供反馈回路，并且要与用户保持一致。</st>
- en: <st c="68178">Once again, we will go back to Financial One ACME.</st> <st c="68230">This
    company needs to balance both a new-age technology stack and a legacy stack.</st>
    <st c="68312">An opportunity exists here to meet these users where they are by
    integrating the existing workflows for authentication into the new platform.</st>
    <st c="68454">If they’re already using GitHub or GitLab, they’re likely using
    some kind of single sign-on, which should be compatible with any</st> <st c="68583">Kubernetes-based
    IDP.</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68178">再一次，我们回到 Financial One ACME。</st> <st c="68230">这家公司需要平衡现代技术栈和遗留技术栈。</st>
    <st c="68312">在这里有一个机会，通过将现有的身份验证工作流整合到新平台中，来满足这些用户的需求。</st> <st c="68454">如果他们已经在使用
    GitHub 或 GitLab，那么他们很可能已经在使用某种单点登录，这应该与任何</st> <st c="68583">基于 Kubernetes 的 IDP
    兼容。</st>
- en: <st c="68604">Integration into a company’s way of working may mean certain options
    to solve some problems don’t meet the users’ needs at this time.</st> <st c="68739">For
    example, if the reason for low Tekton adoption in the Financial One ACME development
    team was because GitHub workflows with Argo CD are capable of handling all of
    their CI/CD needs, then that integration with Tekton may be an effort with a low
    return.</st> <st c="68995">Developers who are refactoring a monolith may find
    more benefit from being able to use a shared CI tool.</st> <st c="69100">This
    would help them to create a common set of tests, and checks between the old monolithic
    system and new system, ensuring that they’re maintaining parity during the transition.</st>
    <st c="69279">In the example of low Tekton adoption, an upfront analysis of the
    decision may prevent wasted time, instead that time may be better spent on the
    integration of a data transformation tool such as Apache Airflow or</st> <st c="69492">Argo
    Workflows.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68604">融入公司的工作方式可能意味着某些解决方案无法在当前满足用户的需求。</st> <st c="68739">例如，如果 Financial
    One ACME 开发团队中 Tekton 采用率低的原因是因为 GitHub 工作流与 Argo CD 足以处理他们所有的 CI/CD 需求，那么与 Tekton
    的整合可能是一个回报较低的努力。</st> <st c="68995">正在重构单体应用的开发者，可能会发现能够使用共享 CI 工具会更有利。</st> <st
    c="69100">这将帮助他们在旧的单体系统与新系统之间创建一组共同的测试和检查，确保在过渡过程中保持一致性。</st> <st c="69279">在
    Tekton 采用率低的例子中，事前分析决策可能防止了浪费时间，而这段时间可能更好地用于集成数据转换工具，如 Apache Airflow 或</st> <st
    c="69492">Argo Workflows。</st>
- en: <st c="69507">Since successful IDP adoption is going to be data-driven, a key
    aspect of this will be</st> **<st c="69595">observability</st>**<st c="69608">.
    The</st> <st c="69613">observability of a platform will help to drive its value
    to consumers and the team that must</st> <st c="69707">maintain it.</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="69507">由于成功的 IDP 采用将依赖于数据驱动，一个关键方面是</st> **<st c="69595">可观察性</st>**<st
    c="69608">。平台的</st> <st c="69613">可观察性将有助于推动其对消费者和必须</st> <st c="69707">维护该平台的团队的价值。</st>
- en: <st c="69719">Architectural considerations for observability in a platform</st>
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="69719">平台中可观察性的架构考虑</st>
- en: <st c="69780">Self-service and cognitive load – we’ve already alluded to the
    importance of observability in these topics.</st> <st c="69889">Your platform
    cannot act in service to its users without observability prioritized.</st> <st
    c="69973">In other words, you should expect to watch and</st> <st c="70020">measure
    everything.</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="69780">自助服务与认知负载——我们已经暗示过这些话题中可观察性的重要性。</st> <st c="69889">没有优先考虑可观察性的情况下，你的平台无法为用户提供服务。</st>
    <st c="69973">换句话说，你应该期望监控和</st> <st c="70020">衡量一切。</st>
- en: <st c="70039">Observability</st> <st c="70054">comes in two flavors; the first
    is observability for the benefit of the platform team.</st> <st c="70141">This
    is the way the platform team will collect data and information to help build their
    reliability.</st> <st c="70242">Using the site reliability practices of SLOs,
    the platform team can measure customer satisfaction by setting SLOs for the platform
    and then creating observability in support</st> <st c="70416">of them.</st>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="70039">可观察性</st> <st c="70054">有两种类型；第一种是为平台团队利益而设的可观察性。</st> <st c="70141">这就是平台团队如何收集数据和信息以帮助提高其可靠性。</st>
    <st c="70242">通过使用 SLO 的站点可靠性实践，平台团队可以通过为平台设定 SLO 来衡量客户满意度，并通过创建可观察性来支持</st> <st
    c="70416">这些目标。</st>
- en: <st c="70424">The good news is that, in the Kubernetes world, this is easier
    because of objects and microservices.</st> <st c="70526">The bad news is that
    there are a lot more things to measure than ever before due to microservices,
    and it’s hard to know whether you’ve captured everything.</st> <st c="70683">Your
    observability should have a life cycle, like your software.</st> <st c="70748">Start
    with good, iterate to better, and realize that observability is a living thing
    that will likely never reach a</st> <st c="70864">completed state.</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="70424">好消息是，在 Kubernetes 世界中，由于对象和微服务，这一切变得更容易。</st> <st c="70526">坏消息是，由于微服务，现在需要衡量的事物比以往多得多，而且很难知道自己是否已经捕获了所有信息。</st>
    <st c="70683">你的可观察性应该有一个生命周期，像你的软件一样。</st> <st c="70748">从良好的开始，逐步改进，并意识到可观察性是一个活的东西，可能永远不会达到一个</st>
    <st c="70864">完成的状态。</st>
- en: <st c="70880">There’s a standard observability toolbox in Prometheus, Grafana,
    Loki, and other</st> **<st c="70962">Free Open Source Software</st>** <st c="70987">(</st>**<st
    c="70989">FOSS</st>**<st c="70993">) projects</st> <st c="71004">that help to
    observe and measure workloads and provide insights into their operations.</st>
    <st c="71092">Often, the consumers of observability data are</st> **<st c="71139">site
    reliability engineers</st>** <st c="71165">(</st>**<st c="71167">SREs</st>**<st
    c="71171">) or</st> <st c="71177">DevOps engineers, but any user who is concerned
    about the operational excellence of their application should be able to easily
    review and use</st> <st c="71319">this information.</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="70880">在 Prometheus、Grafana、Loki 及其他</st> **<st c="70962">自由开源软件</st>**
    <st c="70987">(</st>**<st c="70989">FOSS</st>**<st c="70993">) 项目中，有一个标准的可观察性工具箱</st>
    <st c="71004">，它帮助观察和衡量工作负载，并提供对其操作的洞察。</st> <st c="71092">通常，使用可观察性数据的消费者是</st>
    **<st c="71139">站点可靠性工程师</st>** <st c="71165">(</st>**<st c="71167">SREs</st>**<st
    c="71171">) 或</st> <st c="71177">DevOps 工程师，但任何关心其应用程序运营卓越性的用户，都应能够轻松地审查和使用</st>
    <st c="71319">这些信息。</st>
- en: <st c="71336">Equally important observability tooling that is more applicable
    for troubleshooting a production issue of some kind includes networking tracing,
    liveness probes, and stack traces.</st> <st c="71517">A platform should supply
    the implementation and validation of this toolchain and make it available to users
    in a restricted fashion, ensuring security and compliance</st> <st c="71683">are
    upheld.</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="71336">同样重要的可观察性工具，适用于故障排查生产问题的工具包括网络追踪、存活探针和堆栈跟踪。</st> <st c="71517">一个平台应该提供该工具链的实现和验证，并以受限方式向用户提供，确保安全性和合规性</st>
    <st c="71683">得到维护。</st>
- en: <st c="71694">Naturally, the log and telemetry data retention policies introduce
    their own scaling concerns, and logging and backup systems can be the worst perpetrators
    of noisy neighbor behaviors.</st> <st c="71880">Thus, the care and operations
    of these systems fall to the platform team to ensure a smooth integration into
    the pre-production and production environments.</st> <st c="72037">Other best
    practices around observability, such as sanitizing logs and keeping platform and
    application logs quarantined from each other, are important, but we will cover
    these topics in more detail in</st> [*<st c="72239">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)
    <st c="72248">when building a</st> <st c="72265">secure platform.</st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="71694">自然，日志和遥测数据的保留策略引入了自身的扩展性问题，而日志记录和备份系统可能是最严重的噪声邻居行为的制造者。</st> <st
    c="71880">因此，这些系统的护理和运维工作由平台团队负责，以确保其顺利集成到预生产和生产环境中。</st> <st c="72037">关于可观察性的其他最佳实践，如清理日志并将平台和应用日志隔离开来，这些都是重要的，但我们将在</st>
    [*<st c="72239">第七章</st>*](B31164_07.xhtml#_idTextAnchor381) <st c="72248">中更详细地讲解这些话题，</st>
    <st c="72265">当构建一个</st> <st c="72281">安全平台时。</st>
- en: <st c="72281">Observability in a platform</st>
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="72281">平台中的可观察性</st>
- en: <st c="72309">Observability is, to put it simply, the way you</st> <st c="72358">measure
    your platform.</st> <st c="72381">In a service-based approach to a platform product,
    the SRE practice of an SLO or multiple SLOs is designed to uphold the golden path.</st>
    <st c="72515">If you think about your SDLC, that path should have been previously
    defined in the planning phase.</st> <st c="72614">An SLO that supports a user
    to ensure their success and happiness as they journey along a golden path represents
    a best practice for an</st> <st c="72750">observability strategy.</st>
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="72309">可观察性简单来说就是你</st> <st c="72358">衡量平台的方式。</st> <st c="72381">在基于服务的方法中，SRE实践中的SLO或多个SLO的设计旨在维护黄金路径。</st>
    <st c="72515">如果你考虑一下你的SDLC，这条路径应该在规划阶段已经定义好。</st> <st c="72614">一个支持用户的SLO，确保他们在黄金路径上顺利前行，代表了一个观察性策略的最佳实践。</st>
- en: <st c="72773">If we refer back to Financial One ACME, as well as the golden
    paths that we’ve defined for a successful IDP within this organization, we can
    see an observability strategy start to develop.</st> <st c="72963">The platform
    team can measure the Pod health for the most critical items in a workflow.</st>
    <st c="73051">If Argo CD is crash-looping or a component Pod is not ready, then
    you know that user expectations around CD are not</st> <st c="73167">being met.</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="72773">如果我们回顾一下Financial One ACME，以及在这个组织中为成功的IDP定义的黄金路径，我们可以看到观察性策略开始发展。</st>
    <st c="72963">平台团队可以衡量工作流中最关键项目的Pod健康状况。</st> <st c="73051">如果Argo CD发生崩溃循环，或者某个组件Pod未准备好，那么你就知道CD相关的用户期望未能</st>
    <st c="73167">得到满足。</st>
- en: <st c="73177">If jobs are failing for security checks or SBOM generation, then
    the security and compliance systems need attention.</st> <st c="73295">This could
    block PRs from being merged and interrupt developer workflows as they try to determine
    why necessary checks aren’t succeeding.</st> <st c="73433">All along the golden
    path there is something we can measure that will help inform platform health and</st>
    <st c="73535">developer satisfaction.</st>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73177">如果任务因安全检查或SBOM生成失败，那么安全性和合规系统需要关注。</st> <st c="73295">这可能会阻止PR合并，打断开发人员的工作流，他们需要弄清楚为什么必要的检查没有通过。</st>
    <st c="73433">在整个黄金路径上，总有一些可以衡量的内容，能够帮助指导平台健康和</st> <st c="73535">开发人员的满意度。</st>
- en: <st c="73558">Observability in a platform should be in support of SLOs.</st>
    <st c="73617">These measure customer satisfaction through the collection and analysis
    of data.</st> <st c="73698">When we discussed data-driven decision-making for
    platform evolution in</st> [*<st c="73770">Chapter 1</st>*](B31164_01.xhtml#_idTextAnchor014)<st
    c="73779">, we espoused the value of it as a way to maintain the product mindset
    for a platform.</st> <st c="73866">SLOs are a concrete, data-driven way to create
    a feedback loop that your team can</st> <st c="73948">iterate against.</st>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73558">平台中的可观察性应该支持SLO。</st> <st c="73617">这些通过收集和分析数据来衡量客户满意度。</st>
    <st c="73698">当我们讨论平台演进中的数据驱动决策时，在</st> [*<st c="73770">第一章</st>*](B31164_01.xhtml#_idTextAnchor014)<st
    c="73779">中，我们倡导它作为维持平台产品思维的一种方式。</st> <st c="73866">SLO是一个具体的数据驱动方式，能够创建一个反馈循环，你的团队可以</st>
    <st c="73948">在此基础上进行迭代。</st>
- en: <st c="73964">If your organization cannot meet an SLO, then users are probably
    not happy.</st> <st c="74041">However, even if you’re meeting your SLO target,
    SLOs can still be improved.</st> <st c="74118">It’s reasonable to start with an
    SLO such as “</st>*<st c="74164">jobs will succeed 80% of the time</st>*<st c="74198">”
    and increase that number to 99.99%.</st> <st c="74237">This way, you can still
    evolve a platform without increasing the cognitive load</st> <st c="74317">on
    users.</st>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73964">如果你的组织无法满足SLO，那么用户可能会不满意。</st> <st c="74041">然而，即便你满足了SLO目标，SLO仍然可以改进。</st>
    <st c="74118">开始时设置一个SLO，例如“</st>*<st c="74164">任务80%的时候会成功</st>*<st c="74198">”，然后将这个数字提高到99.99%。</st>
    <st c="74237">这样，你依然可以不断改进平台，而不会增加用户的认知负担。</st>
- en: <st c="74326">Important note</st>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="74326">重要提示</st>
- en: <st c="74341">100% is a bad SLO target because it’s an impossible metric; however,
    the concepts of three, four, or even five nines of availability can</st> <st c="74479">be
    applied.</st>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="74317">100%是一个糟糕的SLO目标，因为这是一个不可能达成的指标；然而，可以应用三九、四九甚至五九的可用性概念。</st>
- en: '<st c="74490">For further reading on SLOs, we recommend</st> *<st c="74533">Site
    Reliability Engineering: How Google Runs</st>* *<st c="74579">Production Systems</st>*<st
    c="74597">.</st>'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="74490">关于SLO的进一步阅读，我们推荐</st> *<st c="74533">《站点可靠性工程：谷歌如何运行</st>* *<st
    c="74579">生产系统》</st>*<st c="74597">。</st>
- en: <st c="74598">Centralized observability – when and why you need it</st>
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="74598">集中式可观察性——你什么时候以及为什么需要它</st>
- en: <st c="74651">What happens when a platform</st> <st c="74681">hits a critical
    failure?</st> <st c="74706">How do developers, DevOps teams, SREs, or whoever
    is responsible for responding to production</st> <st c="74799">outages figure
    out what’s happening?</st> <st c="74837">Immediately logging into the production
    system and debugging and troubleshooting is one option, but it’s not the most
    secure one.</st> <st c="74967">Ultimately, it may become necessary, but it should
    be considered a last resort, not the</st> <st c="75055">first step.</st>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="74651">当平台</st> <st c="74681">遭遇重大故障时，会发生什么？</st> <st c="74706">开发人员、DevOps团队、SRE或任何负责响应生产环境</st>
    <st c="74799">故障的人如何弄清楚发生了什么？</st> <st c="74837">立即登录生产系统进行调试和故障排除是一种选择，但这不是最安全的做法。</st>
    <st c="74967">最终，可能有必要这么做，但它应当被视为最后的手段，而不是</st> <st c="75055">第一步。</st>
- en: <st c="75066">How do you know that your observability stack isn’t the man down?</st>
    <st c="75133">In a single-cluster IDP, these questions are easy to answer.</st>
    <st c="75194">But in a multi-cluster or multi-cloud IDP, those questions become
    more complicated.</st> <st c="75278">This is where a centralized observability
    stack becomes critical for the success of any application, including the IDP itself.</st>
    <st c="75405">A centralized observability stack allows for environment-agnostic
    observability.</st> <st c="75486">The centralized system can reach out to the
    IDP clusters and validate their liveness with probes, or it can simply alert on
    the absence of data.</st> <st c="75631">If the IDP clusters stop calling home
    or shipping logs, that’s a good indicator that there’s</st> <st c="75724">a problem.</st>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="75066">你怎么知道你的可观察性堆栈没有出现故障呢？</st> <st c="75133">在单一集群的IDP中，这些问题很容易回答。</st>
    <st c="75194">但是在多集群或多云的IDP中，这些问题变得更加复杂。</st> <st c="75278">这就是为什么集中式可观察性堆栈对于任何应用程序的成功至关重要，包括IDP本身。</st>
    <st c="75405">集中式可观察性堆栈使得环境无关的可观察性成为可能。</st> <st c="75486">集中式系统可以连接到IDP集群并通过探针验证其存活状态，或者它可以仅仅在没有数据时发出警报。</st>
    <st c="75631">如果IDP集群停止连接主系统或停止发送日志，那是一个很好的指示，说明存在</st> <st c="75724">问题。</st>
- en: <st c="75734">Important metrics</st>
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="75734">重要指标</st>
- en: <st c="75752">Since a platform can be prescriptive about how and where workloads
    run, it can also be prescriptive about how workloads are measured.</st> <st c="75887">For
    example, the DORA DevOps metrics can be collected and used to give indicators
    of quality of service or service health.</st> <st c="76010">A platform can support
    this by making services available to expose the necessary data points, or it can
    enforce the calculation of the metrics by forcibly collecting the necessary metrics,
    since it’s the controlling entity of</st> <st c="76236">the environment.</st>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="75752">由于平台可以对工作负载的运行方式和位置做出规范，它也可以对工作负载的测量方式做出规范。</st> <st c="75887">例如，DORA
    DevOps指标可以被收集并用于提供服务质量或服务健康状况的指示。</st> <st c="76010">平台可以通过提供服务来支持这一点，以暴露必要的数据点，或者它可以通过强制收集必要的指标来执行指标计算，因为它是环境的控制实体。</st>
    <st c="76236">的环境。</st>
- en: <st c="76252">While SLOs and service-level indicators cannot be fully standardized
    across multiple services, a platform should seek to support the collection, aggregation,
    and retention policies of any critical metrics for an application.</st> <st c="76478">Those
    metrics must then be made available easily and with proper RBAC.</st> <st c="76549">This
    allows users to self-service defining metrics and troubleshooting issues with</st>
    <st c="76632">the software.</st>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="76252">虽然SLO和服务级别指标不能完全标准化跨多个服务，平台应该支持收集、聚合和保留任何关键应用程序指标的策略。</st> <st
    c="76478">这些指标必须易于获取，并且具备适当的RBAC权限控制。</st> <st c="76549">这使得用户可以自助定义指标并排除软件中的问题。</st>
    <st c="76632">软件。</st>
- en: <st c="76645">Observability in service for developers</st>
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="76645">为开发人员提供的可观察性服务</st>
- en: <st c="76685">Observability for the consumers</st> <st c="76718">of a platform
    looks a little different from what the platform team might see and do.</st> <st
    c="76803">While the toolbox is roughly the same, the data needed is a little different.</st>
    <st c="76881">In addition to their application performance and uptime, developers
    on the platform will care more about failed CI jobs, DORA DevOps metrics, application
    logs, and exceptions.</st> <st c="77057">They need the ability to see all of their
    observability, with no platform-level observability or observability from other
    tenants.</st> <st c="77188">This not only helps maintain a security and compliance
    posture but also reduces cognitive load, since all the data from all the sources
    can make it hard for developers to understand what data they need and how to</st>
    <st c="77401">interpret it.</st>
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="76685">平台的消费者的可观察性</st> <st c="76718">与平台团队可能看到和操作的情况略有不同。</st> <st c="76803">尽管工具箱大体相同，但所需的数据有所不同。</st>
    <st c="76881">除了他们的应用程序性能和正常运行时间，平台上的开发人员更关心失败的 CI 任务、DORA DevOps 指标、应用程序日志和异常。</st>
    <st c="77057">他们需要能够查看所有的可观察性数据，而不包括平台级别的可观察性或其他租户的可观察性。</st> <st c="77188">这不仅有助于维持安全性和合规性，还减少了认知负担，因为来自所有源的数据可能让开发人员难以理解他们需要什么数据，以及如何</st>
    <st c="77401">解读这些数据。</st>
- en: <st c="77414">There are several ways to approach achieving this clean signal
    to developers.</st> <st c="77493">The observability offering Thanos is specifically
    designed to be a long-term storage solution for Prometheus metrics, natively supporting
    multi-tenancy.</st> <st c="77646">The query language is still Prometheus’ PROMQL,
    which creates a familiar way of interacting with observability data in Thamos.</st>
    <st c="77773">It does, however, expect a somewhat significant amount of dedicated
    cloud storage to support</st> <st c="77866">its operations.</st>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="77414">有几种方法可以实现将清晰的信号传递给开发人员。</st> <st c="77493">Thanos 的可观察性服务专门设计为
    Prometheus 指标的长期存储解决方案，原生支持多租户。</st> <st c="77646">查询语言仍然是 Prometheus 的 PROMQL，这为
    Thanos 中与可观察性数据的交互提供了一种熟悉的方式。</st> <st c="77773">然而，它确实需要一定量的专用云存储来支持</st> <st
    c="77866">其操作。</st>
- en: <st c="77881">When we get into the implications of storing and serving observability
    data in a platform, the issue of scaling the platform takes a new shape.</st>
    <st c="78026">We’ll dive into cost management more concretely in later chapters.</st>
    <st c="78093">However, there are a few high-level considerations we can take a
    look</st> <st c="78163">at now.</st>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="77881">当我们深入探讨在平台中存储和提供可观察性数据的含义时，平台扩展性的问题会呈现出新的形式。</st> <st c="78026">我们将在后续章节中更具体地讨论成本管理。</st>
    <st c="78093">不过，现在我们可以先看一下几个高层次的考虑因素。</st> <st c="78163"> </st>
- en: <st c="78170">As setting up Thanos requires creating object storage and allowing
    access between it and a platform, it adds another layer of complexity to the platform.</st>
    <st c="78325">The storage must be set up, and the networking paths that connect
    it to the rest of the platform must also be created and maintained.</st> <st c="78459">This
    pays dividends for large-scale operations that need to keep observability data
    around for a long time, but it’s not ideal for smaller IDPs or early versions
    of the platform.</st> <st c="78638">Conversely, Prometheus can be used the same
    way, but it can also keep the data in a persistent volume via local mode or not
    persist the data at all, meaning that if the Prometheus Pod were to restart, the
    metrics it had known about would</st> <st c="78876">be lost.</st>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="78170">由于设置 Thanos 需要创建对象存储并允许它与平台之间的访问，它为平台增加了另一层复杂性。</st> <st c="78325">必须设置存储，还必须创建并维护将其与平台其他部分连接的网络路径。</st>
    <st c="78459">对于需要长期存储可观察性数据的大规模操作而言，这样做是有回报的，但对于较小的 IDP 或平台的早期版本来说并不理想。</st>
    <st c="78638">相反，Prometheus 也可以以相同的方式使用，但它还可以通过本地模式将数据保存在持久卷中，或者根本不持久化数据，这意味着如果
    Prometheus Pod 重新启动，它曾经知道的指标将</st> <st c="78876">丢失。</st>
- en: <st c="78884">It’s possible for teams within an IDP to have different needs
    for metric longevity; as such, there is a fairly common pattern of multiple instances
    of Prometheus</st> <st c="79047">using federation.</st>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="78884">在一个 IDP 内，团队可能对指标的长期保存有不同的需求；因此，使用联邦的多个 Prometheus 实例是一种相当常见的模式。</st>
    <st c="79047"> </st>
- en: <st c="79064">Federation is essentially one Prometheus instance that scrapes
    the data it needs from another.</st> <st c="79160">These instances can be on the
    same cluster or across different clusters.</st> <st c="79233">In the use case
    of a multi-tenant IDP, Prometheus federation is a logical choice.</st> <st c="79315">The
    platform owns the application landing zone and, therefore, will hold the source
    of truth for resource utilization within its observability.</st> <st c="79459">However,
    it’s not wise or secure to open that up to all users if the development team also
    uses Prometheus to measure their application health through things such as canary
    routes and synthetic probes.</st> <st c="79661">The developers may want to tie
    that data together with the data that the platform owns to get a full picture
    of their application performance.</st> <st c="79804">By giving the developer Prometheus
    instance federated access to the data it needs, developers can get that information
    without exceeding their</st> <st c="79946">RBAC.</st> <st c="79953">Additionally,
    this model keeps cognitive load low by creating a useful</st> **<st c="80024">signal-to-noise</st>**
    <st c="80039">ratio.</st> <st c="80047">A signal-to-noise ratio</st> <st c="80071">is
    the total number of signals that a developer receives and the number of signals
    that are actionable versus noise.</st> <st c="80188">The less noise a developer
    is exposed to, the more effectively they can parse the data they need</st> <st
    c="80285">to review.</st>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="79064">联邦本质上是一个Prometheus实例从另一个实例抓取所需的数据。</st> <st c="79160">这些实例可以位于同一集群中，也可以跨不同集群。</st>
    <st c="79233">在多租户身份提供者（IDP）的使用场景中，Prometheus联邦是一个合乎逻辑的选择。</st> <st c="79315">平台拥有应用程序的着陆区，因此它将持有其可观察性中的资源使用真实数据源。</st>
    <st c="79459">然而，如果开发团队也使用Prometheus通过金丝雀路由和合成探针等方式来衡量其应用程序的健康状况，那么将这一数据开放给所有用户既不明智也不安全。</st>
    <st c="79661">开发人员可能希望将这些数据与平台拥有的数据结合起来，以全面了解其应用程序性能。</st> <st c="79804">通过允许开发人员的Prometheus实例以联邦方式访问所需的数据，开发人员可以在不超出其</st>
    <st c="79946">RBAC</st> <st c="79953">的范围内获取这些信息。</st> <st c="80024">此外，这种模型通过创建有用的**信噪比**</st>
    <st c="80039">来保持低认知负荷。</st> <st c="80047">信噪比</st> <st c="80071">是开发人员接收到的所有信号数量与可操作信号和噪声的比例。</st>
    <st c="80188">开发人员暴露的噪声越少，他们就能越有效地解析所需的数据</st> <st c="80285">进行审查。</st>
- en: <st c="80295">The actual implementation for this isn’t very difficult; it’s
    a few new lines in the Prometheus YAML file.</st> <st c="80403">The important
    takeaway is that the applications can get information from the platform and any
    necessary shared services, but not from each other.</st> <st c="80549">Since application-level
    observability data is more likely to have personally identifying information or
    other sensitive data in it, this helps the platform team guarantee that security
    and compliance best practices or requirements</st> <st c="80780">are followed.</st>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="80295">实际实现并不困难；只需在Prometheus的YAML文件中添加几行新代码。</st> <st c="80403">关键要点是，应用程序可以从平台和任何必要的共享服务中获取信息，但不能相互获取信息。</st>
    <st c="80549">由于应用程序级别的可观察性数据更有可能包含个人识别信息或其他敏感数据，因此这有助于平台团队确保遵循安全性和合规性最佳实践或要求</st>
    <st c="80780">。</st>
- en: <st c="80793">The recommended example for federation in this case would be cross-service
    federation.</st> <st c="80881">Here, the most common model is to have a central
    Prometheus server that does federation and is scraped by other Prometheus servers
    that may not</st> <st c="81025">support federation.</st>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="81440">这个例子的推荐配置是跨服务联邦。</st> <st c="81499">在这种情况下，最常见的模型是拥有一个中央Prometheus服务器进行联邦操作，并由其他可能不支持联邦的Prometheus服务器抓取数据。</st>
- en: '![Figure 6.7: A Prometheus federation model](img/B31164_06_07.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7：Prometheus联邦模型](img/B31164_06_07.jpg)'
- en: '<st c="81381">Figure 6.7: A Prometheus federation model</st>'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="81381">图6.7：Prometheus联邦模型</st>
- en: <st c="81422">The YAML for the</st> <st c="81440">platform Prometheus instance
    would look a little something</st> <st c="81499">like this:</st>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="81422">平台Prometheus实例的YAML看起来会像这样：</st>
- en: '[PRE14]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="81987">In the</st> *<st c="81995">Figure 6</st>**<st c="82003">.7</st>*
    <st c="82005">example, there is a shared service, and it may be difficult to understand
    what kind of service would be important to multiple application observability
    stacks.</st> <st c="82166">One use case would be for DevOps DORA metrics.</st>
    <st c="82213">In DORA there are four key areas that a team would</st> <st c="82263">measure
    if they’re looking to implement a DORA</st> <st c="82311">maturity model:</st>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="81987">在</st> *<st c="81995">图6</st>**<st c="82003">.7</st>* <st c="82005">示例中，存在一个共享服务，理解哪些服务对多个应用程序的可观察性栈很重要可能会很困难。</st>
    <st c="82166">一个使用场景可能是DevOps DORA指标。</st> <st c="82213">在DORA中，如果团队希望实施DORA成熟度模型，他们会衡量四个关键领域：</st>
- en: '**<st c="82326">Mean time to resolve</st>**<st c="82347">: How long it takes
    to recover from</st> <st c="82384">a failure</st>'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="82326">恢复的平均时间</st>**<st c="82347">：从故障中恢复所需的时间</st>'
- en: '**<st c="82393">Change failure rate</st>**<st c="82413">: How often deployments
    lead</st> <st c="82443">to failures</st>'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="82393">变更失败率</st>**<st c="82413">：部署导致失败的频率</st>'
- en: '**<st c="82454">Lead time to change</st>**<st c="82474">: How long it takes
    for a change to</st> <st c="82511">reach production</st>'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="82454">变更的提前期</st>**<st c="82474">：变更到达生产环境所需的时间</st>'
- en: '**<st c="82527">Deployment frequency</st>**<st c="82548">: How often changes</st>
    <st c="82569">are deployed</st>'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="82527">部署频率</st>**<st c="82548">：变更部署的频率</st>'
- en: <st c="82581">To get this data, the CI/CD systems would need to be queried,
    or they can be configured to send data via a Webhook, and using Prometheus to
    obtain and normalize said data, would allow all compared data to exist in the
    same format, which makes calculation easier.</st> <st c="82845">The implementation
    details for this would involve a Prometheus exporter.</st> <st c="82918">A Prometheus
    exporter is a service that queries data from systems that may not be immediately
    Prometheus-friendly but then transforms it so that it is in a compatible data
    format.</st> <st c="83098">For example, to calculate the lead time to change,
    a Prometheus exporter would get data from the CI system, normalize it, and make
    it available via either a query to the Prometheus API</st> <st c="83283">or federation.</st>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="82581">要获取这些数据，需要查询CI/CD系统，或者可以配置它们通过Webhook发送数据，并使用Prometheus来获取和标准化这些数据，从而使所有比较的数据以相同格式存在，这样可以简化计算。</st>
    <st c="82845">其实现细节将涉及一个Prometheus导出程序。</st> <st c="82918">Prometheus导出程序是一个服务，它从可能不是立即支持Prometheus的系统中查询数据，然后将其转换为兼容的数据格式。</st>
    <st c="83098">例如，为了计算变更的提前期，Prometheus导出程序会从CI系统获取数据，标准化后，通过Prometheus API查询或联合查询使数据可用。</st>
- en: <st c="83297">Whatever observability implementation paths you ultimately use,
    the data and its criticality should be made available to everyone who can leverage
    it, for the success of the platform and the products it supports.</st> <st c="83511">Do
    this with care and also with an understanding that data is a key asset</st> <st
    c="83585">for users.</st>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="83297">无论你最终使用何种可观察性实施路径，数据及其重要性都应对所有能够利用它的人开放，以支持平台和它所支持的产品的成功。</st>
    <st c="83511">在这样做时要小心，同时也要理解数据是用户的一个关键资产。</st> <st c="83585">对于用户来说，数据至关重要。</st>
- en: <st c="83595">Opening your platform for community and collaboration</st>
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="83595">为社区和协作开放你的平台</st>
- en: <st c="83649">We often use the</st> <st c="83666">term</st> *<st c="83672">open
    source</st>*<st c="83683">, but open source doesn’t always mean free, and vice
    versa.</st> <st c="83743">However, when we discuss FOSS, the most important aspect
    of the software is not the technology but the community behind it.</st> <st c="83867">Open
    source communities foster collaboration and help to organically grow software
    in ways that revolutionize</st> <st c="83977">the industry.</st>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="83649">我们经常使用</st> <st c="83666">术语</st> *<st c="83672">开源</st>*<st c="83683">，但开源并不总是意味着免费，反之亦然。</st>
    <st c="83743">然而，当我们讨论FOSS（自由开源软件）时，软件最重要的方面不是技术，而是其背后的社区。</st> <st c="83867">开源社区促进协作，并帮助以革命性的方式自然发展软件，</st>
    <st c="83977">从而改变整个行业。</st>
- en: <st c="83990">When we previously discussed learning about your users, it was
    largely in the context of getting things off the ground, but you need to maintain
    that same user-centricity in order to keep the product running and relevant.</st>
    <st c="84213">The best way to harness the power of your users is to bring them
    to the table with the team, creating a community as seen in FOSS projects that
    invites collaboration, contribution, and communication.</st> <st c="84413">By
    doing so, you can have a data-driven, user-led platform that evolves with the
    organization it is intended to serve.</st> <st c="84532">Oftentimes, a project
    lifts off, but the roadmap beyond that is fuzzy.</st> <st c="84603">As the adrenaline
    of the initial push to an IDP fades, the risk of losing momentum and becoming
    complacent develops.</st> <st c="84720">The community aspect should then act as
    the fuel to keep the</st> <st c="84781">vehicle moving.</st>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="83990">当我们之前讨论了解用户时，主要是在启动阶段的背景下，但你需要保持相同的以用户为中心的思维，以确保产品持续运行并保持相关性。</st>
    <st c="84213">充分利用用户的最佳方式是将他们带到团队的桌面上，创建一个像FOSS项目那样的社区，邀请合作、贡献和交流。</st> <st c="84413">通过这种方式，你可以拥有一个数据驱动、用户主导的平台，随着服务的组织的不断发展而不断演化。</st>
    <st c="84532">许多时候，一个项目会起步，但其后续的路线图却模糊不清。</st> <st c="84603">随着初期推进IDP的兴奋感消退，失去动力和变得自满的风险随之而来。</st>
    <st c="84720">社区的作用应该是充当燃料，保持</st> <st c="84781">车辆前行。</st>
- en: <st c="84796">At this point, you’re likely asking, how do we go about creating
    this community?</st> <st c="84878">How do we bring people to the table without
    undoing the reduction of cognitive load we’ve been striving for with</st> <st
    c="84991">our platform?</st>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="84796">在这一点上，你可能会问，我们该如何创建这个社区呢？</st> <st c="84878">我们如何在不破坏我们为平台所努力减少的认知负担的情况下，将人们吸引到一起呢？</st>
    <st c="84991">我们的平台该如何实现这一目标？</st>
- en: <st c="85004">There’s no one magic button solution for this but, rather, several
    things that can be done in concert, such as adding a contributor guide to a repository
    that sets expectations around what kind of contributions are desired and how contributions
    will</st> <st c="85255">be reviewed.</st>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="85004">对此并没有一种魔法般的解决方案，而是可以通过几种方式同时进行，例如在代码库中添加贡献者指南，设定对期望的贡献类型以及如何评审贡献的明确要求。</st>
    <st c="85255">贡献将如何被审查。</st>
- en: <st c="85267">Another aspect is that some of the tools you might include in
    your platform can help to entice collaboration.</st> <st c="85378">Policy engines,
    for example, entice collaboration because users can propose new policies or adjustments
    to their policies.</st> <st c="85501">By having a repository for policies that
    is open to end users, you can invite PRs against the policies for users to propose
    new permissions or adjustments to existing permissions.</st> <st c="85681">As
    we discussed with self-service, this leverages a known useful workflow of Git
    PRs and</st> <st c="85770">peer review.</st>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="85267">另一个方面是，你可能会在平台中加入一些工具，以帮助吸引合作。</st> <st c="85378">例如，策略引擎能够吸引合作，因为用户可以提出新的策略或对现有策略进行调整。</st>
    <st c="85501">通过设立一个面向最终用户开放的策略库，你可以邀请用户为政策提出PR，提出新的权限或调整现有权限。</st> <st c="85681">正如我们在自助服务中讨论的那样，这利用了Git
    PR和</st> <st c="85770">同行评审的已知有效工作流程。</st>
- en: <st c="85782">Similarly, the use of quotas for an environment is a configuration
    that can be managed with GitOps; a PR for more quotas and some GitHub workflows
    can be leveraged to help developers request quotas.</st> <st c="85982">In both
    examples, the leveraging of Git repos and PRs allows users to interact with a
    platform in a more intuitive way that fits with their workflows.</st> <st c="86133">Once
    again, meeting your “customers” where they are helps to reduce their cognitive
    load, while enticing collaboration is necessary to ensure that the platform continues
    to meet</st> <st c="86311">their needs.</st>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="85782">类似地，环境配额的使用是一种可以通过GitOps进行管理的配置；通过PR请求更多配额，并利用一些GitHub工作流帮助开发者申请配额。</st>
    <st c="85982">在这两个例子中，利用Git仓库和PR允许用户以更直观的方式与平台互动，更符合他们的工作流程。</st> <st c="86133">再一次，站在“客户”的角度帮助减少他们的认知负担，同时吸引合作是确保平台能够继续满足他们需求的必要条件。</st>
- en: <st c="86323">A platform should drink</st> <st c="86348">its own champagne.</st>
    <st c="86367">If the product security team has demands on the application that
    a platform must support, such as the generations of SBOMs or automated penetration
    testing jobs, the platform itself should be evaluated against the same security
    standards.</st> <st c="86606">Doing this is not only an exercise in intellectual
    honesty, ensuring that the way security standards are enforced is reasonable and
    doesn’t interfere with serviceability and self-service, but also a pathway toward
    engagement from your internal community in the development and hardening of</st>
    <st c="86896">the platform.</st>
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="86323">一个平台应该自饮</st> <st c="86348">自己的香槟。</st> <st c="86367">如果产品安全团队对应用程序提出了平台必须支持的要求，比如生成SBOM或自动化渗透测试工作，那么平台本身也应该按照相同的安全标准进行评估。</st>
    <st c="86606">这样做不仅是一次智力诚实的实践，确保安全标准的执行方式合理，并且不会妨碍服务性和自助服务，而且还是与内部社区互动的途径，推动平台的开发和加固。</st>
    <st c="86896">平台。</st>
- en: <st c="86909">A discerning reader may wonder, “</st>*<st c="86943">How do you
    reconcile the dichotomy between the reduction of cognitive load for users and
    their engagement in the</st>* *<st c="87057">platform experience?</st>*<st c="87077">”</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="86909">一位有洞察力的读者可能会问，“</st>*<st c="86943">你如何调和用户认知负担的减少与他们在</st>* *<st
    c="87057">平台体验中的参与之间的矛盾？</st>*<st c="87077">”</st>
- en: <st c="87079">This is an important question, as endless requests for feedback
    may result in silence, since the mental load of generating feedback may be high
    especially if users don’t feel that feedback will</st> <st c="87273">be actioned.</st>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="87079">这是一个重要问题，因为无休止的反馈请求可能导致沉默，尤其是当用户认为反馈不会被采纳时，生成反馈的心理负担可能会非常重。</st>
    <st c="87273">被采纳。</st>
- en: <st c="87285">There is no single approach to gaining community engagement that
    is guaranteed to work, but when we look at some best practices from around the
    FOSS community, we can see there’s</st> <st c="87465">a trend.</st>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="87285">没有一种保证能成功的单一方式来获取社区参与，但当我们回顾FOSS社区中的一些最佳实践时，我们可以看到</st> <st c="87465">一种趋势。</st>
- en: <st c="87473">Planning in the open</st>
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="87473">开放式规划</st>
- en: <st c="87494">Regular planning meetings and community meetings that are attended
    by the platform team, as well as being open to anyone to attend, help to create
    and foster the open collaboration needed to grow a community culture around a
    platform.</st> <st c="87730">In a Kubernetes project, most of the project meetings
    are on a public calendar, and there are mailing lists that individuals can sign
    up for to keep abreast of the latest and greatest news coming from each project.</st>
    <st c="87945">Regular product updates and plans that are emailed out and transparent
    to a company will help to maintain interest and engagement, hopefully resulting
    in the proactive feedback necessary for the long-term success of</st> <st c="88161">the
    IDP.</st>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="87494">定期的计划会议和社区会议，由平台团队参与，并且对任何人开放，帮助创建和培养围绕平台建立开放协作的社区文化。</st> <st
    c="87730">在一个Kubernetes项目中，大多数项目会议都在公开日历上，个人可以订阅邮件列表，及时了解每个项目的最新消息。</st> <st c="87945">定期的产品更新和计划通过邮件发送，且公司内部公开透明，有助于保持兴趣和参与，希望能带来必要的积极反馈，以确保</st>
    <st c="88161">IDP的长期成功。</st>
- en: <st c="88169">Accepting contributions</st>
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="88169">接受贡献</st>
- en: <st c="88193">Accepting contributions is probably one of the more logistically
    difficult sociotechnical aspects of landing and expanding an IDP.</st> <st c="88325">However,
    some open source IDP projects lend themselves very nicely to this paradigm.</st>
    <st c="88410">The recent open source darling Backstage provides, among many other
    features, a plugin-capable architecture.</st> <st c="88519">In other words, by
    laying down Backstage as the IDP framework when a team finds they’re missing functionality
    or would benefit from some additional quality-of-life features, they can leverage
    the plugin</st> <st c="88722">framework to propose the new feature via a PR to
    the internal</st> <st c="88784">IDP project.</st>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="88193">接受贡献可能是部署和扩展IDP过程中最具后勤难度的社会技术性方面之一。</st> <st c="88325">然而，一些开源IDP项目非常适合这种范式。</st>
    <st c="88410">最近的开源宠儿Backstage提供了许多其他功能，其中包括一个支持插件的架构。</st> <st c="88519">换句话说，当一个团队发现缺少某些功能或能从一些额外的生活质量特性中受益时，通过将Backstage作为IDP框架来铺设，他们可以利用插件框架通过PR向内部</st>
    <st c="88722">IDP项目提议新功能。</st>
- en: <st c="88796">While you don’t have to use this exact framework to achieve the
    same results, the pattern that Backstage exemplifies allows for easy contributions
    from users and a standardized way of proposing changes via hands on contribution,
    instead of just sending a request to the platform</st> <st c="89076">team’s backlog.</st>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="88796">虽然你不必使用这个精确的框架来实现相同的结果，但Backstage所展示的模式能够让用户轻松贡献，并通过动手贡献而不是仅仅向平台团队的待办事项列表发送请求，提供一种标准化的变更提案方式。</st>
    <st c="89076">团队的待办事项列表。</st>
- en: <st c="89091">Summary</st>
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="89091">总结</st>
- en: <st c="89099">In this chapter, we looked at how to build for developers and
    the importance of cognitive load.</st> <st c="89196">Protecting users from undesired
    outcomes positively influences their cognitive load and gives them fewer concerns,
    and fewer things to debug if something goes wrong can help keep developers working
    efficiently.</st> <st c="89407">Additionally, the relationship between cognitive
    load and self-service was explored, and we took a look at some common tools and
    patterns to deliver a platform that meets the users where they are.</st> <st c="89604">If
    you were following along with a kind cluster, you may have even gained some hands-on
    experience with these recommendations.</st> <st c="89731">While we touched briefly
    on the security aspects of each of these topics, we’ll cover each of them and
    more topics in depth in the</st> <st c="89862">next chapter.</st>
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="89099">在本章中，我们探讨了如何为开发人员构建平台以及认知负荷的重要性。</st> <st c="89196">保护用户免受不良结果的影响，有助于减轻他们的认知负荷，减少他们的担忧。如果出现问题，减少需要调试的内容，可以帮助开发人员保持高效工作。</st>
    <st c="89407">此外，我们还探讨了认知负荷与自助服务之间的关系，并审视了一些常见的工具和模式，以提供一个能够满足用户需求的平台。</st> <st
    c="89604">如果你正在使用集群并跟随学习，可能还会获得一些关于这些建议的实践经验。</st> <st c="89731">虽然我们简要提到了每个主题的安全方面，但在下一章中，我们将深入探讨这些内容以及更多话题。</st>
    <st c="89862">下一章。</st>
- en: <st c="0">Part 3 – Platforms as a Product Best Practices</st>
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">第三部分 – 作为产品的最佳实践平台</st>
- en: <st c="47">In the last part, we will provide you with the tools to optimize
    your platform for cost efficiency, enabling your users to do the same.</st> <st
    c="184">We will achieve this by outlining the simple steps required to establish
    transparency within your cost landscape and by providing you with best practices
    to reduce your infrastructure expenses.</st> <st c="378">From infrastructure costs,
    we will move on to technical debts, which can negatively impact the maintenance
    costs of the selected technology stack if they are not dealt with correctly.</st>
    <st c="562">You will learn about tools and frameworks to evaluate technical debts
    and the importance of documenting what decisions you make.</st> <st c="691">Finally,
    we will take a look into the future.</st> <st c="737">You will learn about the
    imperative of change and why you have to become an active part of driving change.</st>
    <st c="844">You might discover a different perspective on your golden path and
    some ideas about future</st> <st c="935">relevant technologies.</st>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47">在上一部分，我们将为你提供优化平台以实现成本效率的工具，从而帮助用户也能做到这一点。</st> <st c="184">我们将通过概述在你的成本环境中建立透明度所需的简单步骤，并为你提供减少基础设施费用的最佳实践来实现这一目标。</st>
    <st c="378">从基础设施成本开始，我们将讨论技术债务，如果不正确处理，它们可能会对所选技术栈的维护成本产生负面影响。</st> <st c="562">你将学习如何使用工具和框架评估技术债务，以及记录决策的重要性。</st>
    <st c="691">最后，我们将展望未来。</st> <st c="737">你将了解到变革的必要性，以及为什么你必须成为推动变革的积极一员。</st>
    <st c="844">你可能会发现一个关于你的黄金道路的新视角，以及一些关于未来相关技术的想法。</st> <st c="935">相关技术。</st>
- en: <st c="957">This part has the</st> <st c="976">following chapters:</st>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="957">本部分包含以下章节：</st> <st c="976">以下章节：</st>
- en: '[*<st c="995">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st c="1005">,</st>
    *<st c="1007">Building Secure and Compliant Products</st>*'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="995">第七章</st>*](B31164_07.xhtml#_idTextAnchor381)<st c="1005">,</st>
    *<st c="1007">构建安全合规的产品</st>*'
- en: '[*<st c="1045">Chapter 8</st>*](B31164_08.xhtml#_idTextAnchor430)<st c="1055">,</st>
    *<st c="1057">Cost Management and Best Practices</st>*'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="1045">第八章</st>*](B31164_08.xhtml#_idTextAnchor430)<st c="1055">,</st>
    *<st c="1057">成本管理与最佳实践</st>*'
- en: '[*<st c="1091">Chapter 9</st>*](B31164_09.xhtml#_idTextAnchor479)<st c="1101">,</st>
    *<st c="1103">Choosing Technical Debt to Unbreak Platforms</st>*'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="1091">第九章</st>*](B31164_09.xhtml#_idTextAnchor479)<st c="1101">,</st>
    *<st c="1103">选择技术债务以避免平台崩溃</st>*'
- en: '[*<st c="1147">Chapter 10</st>*](B31164_10.xhtml#_idTextAnchor507)<st c="1158">,</st>
    *<st c="1160">Crafting Platform Products for the Future</st>*'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="1147">第10章</st>*](B31164_10.xhtml#_idTextAnchor507)<st c="1158">,</st>
    *<st c="1160">为未来打造平台产品</st>*'
