- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Leveraging Docker and Kubernetes for Advanced Configurations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用 Docker 和 Kubernetes 进行高级配置
- en: In the previous chapter, we looked at implementing continuous deployment through
    Bitbucket Pipelines and worked with various platforms using various technologies.
    However, we reserved discussions of deploying with Docker and Kubernetes until
    now. Bitbucket Pipelines can leverage containers for its build environment, as
    a build package, and even as runners to run pipeline executions. In each case
    mentioned, you can use a public image or create and use a private image.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了通过 Bitbucket Pipelines 实现持续部署，并使用各种技术平台进行操作。然而，我们将 Docker 和 Kubernetes
    部署的讨论留到现在。Bitbucket Pipelines 可以利用容器作为其构建环境、构建包，甚至作为运行器来执行流水线操作。在上述每种情况下，您可以使用公共镜像或创建并使用私有镜像。
- en: 'In this chapter, we will examine using Docker container technology and Kubernetes.
    We’ll cover the following recipes in this chapter while implementing Bitbucket
    Pipelines:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用 Docker 容器技术和 Kubernetes。我们将在本章中实现 Bitbucket Pipelines 时，涵盖以下内容：
- en: Using a Docker image as a build environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 镜像作为构建环境
- en: Using containerized services in Bitbucket Pipelines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Bitbucket Pipelines 中使用容器化服务
- en: Using Docker commands in Bitbucket Pipelines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Bitbucket Pipelines 中使用 Docker 命令
- en: Deploying a Docker image to Kubernetes using Bitbucket Pipelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Bitbucket Pipelines 将 Docker 镜像部署到 Kubernetes
- en: Setting up Docker-based runners in Linux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 上设置基于 Docker 的运行器
- en: Let’s begin our exploration of Docker and Kubernetes in Bitbucket Pipelines.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始在 Bitbucket Pipelines 中探索 Docker 和 Kubernetes。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before we begin our exploration, we should identify what’s needed to work with
    Docker and Kubernetes in our local development environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索之前，我们应该先明确在本地开发环境中工作所需的 Docker 和 Kubernetes 工具。
- en: To work with **Docker images**, you need to make sure Docker applications are
    installed on your runner machines for executing any Docker commands.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 **Docker 镜像**，需要确保在您的运行器机器上安装了 Docker 应用，以执行任何 Docker 命令。
- en: For development machines that are used to create build environments, a good
    option is Docker Desktop, an application that provides all the required Docker
    tools for building, packaging, running, and deploying applications as containers.
    It is available for Mac, Windows, and Linux machines. More information can be
    found at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用于创建构建环境的开发机器，Docker Desktop 是一个不错的选择，它提供了所有必需的 Docker 工具，用于构建、打包、运行和部署容器化应用。它适用于
    Mac、Windows 和 Linux 操作系统。更多信息请参考 [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)。
- en: Runners only require Docker applications that can build and run containerized
    applications. For that, Docker Engine is a good application to install and configure
    on your runner. It is available for many common Linux distributions, including
    Ubuntu, Debian, and Red Hat. More information can be found at [https://docs.docker.com/engine/](https://docs.docker.com/engine/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 运行器只需要能够构建和运行容器化应用的 Docker 应用。因此，Docker Engine 是一个很好的应用，适合安装并配置在您的运行器上。它支持许多常见的
    Linux 发行版，包括 Ubuntu、Debian 和 Red Hat。更多信息请参考 [https://docs.docker.com/engine/](https://docs.docker.com/engine/)。
- en: For working with Kubernetes clusters, `kubectl` is the preferred tool. The binary
    for `kubectl` can be downloaded for Linux, Mac, or Windows. Package managers such
    as yum for Red Hat Linux, apt for Debian Linux, homebrew for Mac, and chocolatey
    for Windows can also download and install `kubectl`. More information can be found
    at [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 Kubernetes 集群时，`kubectl` 是首选工具。可以为 Linux、Mac 或 Windows 下载 `kubectl` 的二进制文件。像
    Red Hat Linux 的 yum、Debian Linux 的 apt、Mac 的 homebrew 和 Windows 的 chocolatey 等包管理器也可以下载并安装
    `kubectl`。更多信息请参考 [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)。
- en: The sample code for this chapter can be found in the `Chapter9` folder of this
    book’s GitHub repository [https://github.com/PacktPublishing/Atlassian-DevOps-Toolchain-Cookbook/tree/main/Chapter9](https://github.com/PacktPublishing/Atlassian-DevOps-Toolchain-Cookbook/tree/main/Chapter9)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可以在本书 GitHub 仓库的 `Chapter9` 文件夹中找到 [https://github.com/PacktPublishing/Atlassian-DevOps-Toolchain-Cookbook/tree/main/Chapter9](https://github.com/PacktPublishing/Atlassian-DevOps-Toolchain-Cookbook/tree/main/Chapter9)
- en: Introducing containers and Bitbucket Pipelines
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入容器和 Bitbucket Pipelines
- en: One of the most recent advances in technology that furthered the DevOps movement
    was the introduction of **container** technology. As mentioned in [*Chapter 1*](B21937_01.xhtml#_idTextAnchor019),
    instead of setting up complete environments as physical or **virtual machines**
    (**VMs**), an application and its required libraries would reside in a self-contained
    entity called a container. This container interacts with outside resources through
    a managing application. At the time of writing, the most popular application for
    managing containers is Docker Engine from Docker Inc.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 促进 DevOps 运动的最新技术进展之一就是 **容器** 技术的引入。如在 [*第 1 章*](B21937_01.xhtml#_idTextAnchor019)
    中提到的，应用程序及其所需的库将驻留在一个自包含的实体中，称为容器，而不是像物理或 **虚拟机**（**VMs**）那样设置完整的环境。这个容器通过一个管理应用程序与外部资源进行交互。在撰写本文时，最流行的容器管理应用程序是来自
    Docker Inc. 的 Docker 引擎。
- en: Containers have allowed for application portability at an unprecedented level.
    Developers can create an application, package it as a container, and run tests
    on the application in a test environment managing that container. Deployment to
    production would use the same container image, but in an environment with possibly
    more resources, depending on the target, allowing multiple instances of the application
    container for load sharing or high availability.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使应用程序的可移植性达到了前所未有的水平。开发人员可以创建一个应用程序，将其打包为容器，并在管理该容器的测试环境中对应用程序进行测试。部署到生产环境时将使用相同的容器镜像，但在一个可能拥有更多资源的环境中，具体取决于目标，可以支持多个应用程序容器实例进行负载共享或高可用性。
- en: '**Bitbucket Pipelines** can work with containers. So, let’s consider some of
    the uses of containers in Bitbucket Pipelines.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bitbucket Pipelines** 可以与容器配合使用。那么，让我们来考虑一些容器在 Bitbucket Pipelines 中的用途。'
- en: By default, Bitbucket Pipelines uses Docker images as build. You can define
    which Docker image to use for your build.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Bitbucket Pipelines 使用 Docker 镜像作为构建环境。你可以定义用于构建的 Docker 镜像。
- en: You can also use Bitbucket Pipelines to create a Docker container image and
    update the appropriate Docker container repository.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 Bitbucket Pipelines 创建 Docker 容器镜像，并更新相应的 Docker 容器仓库。
- en: Bitbucket Pipelines can use runners that can be created from Docker images to
    execute builds. This may allow for dynamic allocation of runners to perform a
    build by creating as many Docker containers as needed and destroying those containers
    when complete. The only limitation to this is the available resources in your
    environment.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Bitbucket Pipelines 可以使用从 Docker 镜像创建的运行器来执行构建。这可能允许通过动态分配运行器来执行构建，创建所需数量的 Docker
    容器，并在完成后销毁这些容器。唯一的限制是环境中可用的资源。
- en: Another application of container technology comes in the form of Kubernetes.
    Kubernetes was initially developed by Google to abstract applications stored in
    containers as services and provide an environment for establishing and maintaining
    clusters of containerized services.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 容器技术的另一个应用形式就是 Kubernetes。Kubernetes 最初由 Google 开发，用于将存储在容器中的应用程序抽象为服务，并提供一个环境来建立和维护容器化服务的集群。
- en: Finally, Bitbucket Pipelines can build an application into a Docker container
    image. This image can be deployed into a Kubernetes cluster as part of the pipeline
    script.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Bitbucket Pipelines 可以将应用程序构建为 Docker 容器镜像。这个镜像可以作为管道脚本的一部分部署到 Kubernetes
    集群中。
- en: Now that we understand how Docker containers work with Bitbucket Pipelines,
    let’s examine how we can make that happen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了 Docker 容器如何与 Bitbucket Pipelines 配合工作，让我们来看看如何实现这一点。
- en: Using a Docker image as a build environment
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 镜像作为构建环境
- en: Bitbucket Pipelines uses a Docker image as a platform to execute the commands
    found in `bitbucket-pipelines.yml`. This image is normally a default provided
    by Atlassian but can be replaced with a custom image.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Bitbucket Pipelines 使用 Docker 镜像作为平台来执行 `bitbucket-pipelines.yml` 中的命令。该镜像通常是由
    Atlassian 提供的默认镜像，但也可以替换为自定义镜像。
- en: Let’s examine how Bitbucket Pipelines uses these Docker images.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Bitbucket Pipelines 如何使用这些 Docker 镜像。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In Bitbucket Pipelines, the runner executes the commands specified on `bitbucket-pipelines.yml`
    in a build environment. This build environment always uses a Docker container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bitbucket Pipelines 中，运行器在构建环境中执行 `bitbucket-pipelines.yml` 中指定的命令。这个构建环境始终使用
    Docker 容器。
- en: If a Docker image isn’t specified, Bitbucket Pipelines will select a default
    Docker image for the container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定 Docker 镜像，Bitbucket Pipelines 将选择一个默认的 Docker 镜像用于容器。
- en: Default images used by Bitbucket Pipelines are stored by Atlassian in **Docker
    Hub** at [https://hub.docker.com/r/atlassian/default-image/](https://hub.docker.com/r/atlassian/default-image/).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Bitbucket Pipelines 使用的默认镜像由 Atlassian 存储在 **Docker Hub** 上，网址是 [https://hub.docker.com/r/atlassian/default-image/](https://hub.docker.com/r/atlassian/default-image/)。
- en: Version numbers for the default image can be specified. If no version number
    is specified, the version specified with the **latest** tag will be used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认镜像的版本号可以被指定。如果未指定版本号，则会使用带有 **latest** 标签的版本。
- en: 'The following table provides a synopsis of the default image versions:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格提供了默认镜像版本的概览：
- en: '| **Version** | **Tags** | **Contents** |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| **版本** | **标签** | **内容** |'
- en: '| --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1.x (deprecated) | `latest` | Platform: `ubuntu 14.04`Packages available
    out of the box: `wget xvfb curl git: 1.9.1 java: 1.8u66 maven: 3.0.5 node: 4.2.1
    npm: 2.14.7 nvm: 0.29.0 python: 2.7.6` `gcc: 4.8.4` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 1.x（不推荐使用） | `latest` | 平台：`ubuntu 14.04` 开箱即用的软件包：`wget xvfb curl git: 1.9.1
    java: 1.8u66 maven: 3.0.5 node: 4.2.1 npm: 2.14.7 nvm: 0.29.0 python: 2.7.6` `gcc:
    4.8.4` |'
- en: '| 2.x (deprecated) |  | Platform: `ubuntu 16.04`Packages available out of the
    box: `wget xvfb curl ssh git: 2.7.4 mercurial: 3.7.3 java: Open-JDK 1.8u151 maven:
    3.3.9 node: 8.9.4 npm: 5.6.0 nvm: 0.33.8 python: 2.7.12 gcc: 5.4.0` `ant: 1.9.6`
    |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 2.x（不推荐使用） |  | 平台：`ubuntu 16.04` 开箱即用的软件包：`wget xvfb curl ssh git: 2.7.4
    mercurial: 3.7.3 java: Open-JDK 1.8u151 maven: 3.3.9 node: 8.9.4 npm: 5.6.0 nvm:
    0.33.8 python: 2.7.12 gcc: 5.4.0` `ant: 1.9.6` |'
- en: '| 3.x (deprecated) |  | Platform: `ubuntu` `20.04 (LTS)`Packages available
    out of the box: `wget xvfb curl ssh zip jq tar parallel git: 2.39.1 node: 14.17.5
    npm: 6.14.14 nvm: 0.38.0 python: 3.8.10 gcc: 9.4.0` `ant: 1.10.7` |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 3.x（不推荐使用） |  | 平台：`ubuntu` `20.04 (LTS)` 开箱即用的软件包：`wget xvfb curl ssh zip
    jq tar parallel git: 2.39.1 node: 14.17.5 npm: 6.14.14 nvm: 0.38.0 python: 3.8.10
    gcc: 9.4.0` `ant: 1.10.7` |'
- en: '| 4.x (recommended) |  | Platform: `ubuntu` `22.04 (LTS)`Packages available
    out of the box: `wget xvfb curl ssh zip jq tar parallel git: 2.39.1 node: 18.16.1
    npm: 9.5.1 nvm: 0.39.2 python: 3.10.6 gcc: 11.3.0` `ant: 1.10.12` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 4.x（推荐使用） |  | 平台：`ubuntu` `22.04 (LTS)` 开箱即用的软件包：`wget xvfb curl ssh zip
    jq tar parallel git: 2.39.1 node: 18.16.1 npm: 9.5.1 nvm: 0.39.2 python: 3.10.6
    gcc: 11.3.0` `ant: 1.10.12` |'
- en: Table 9.1 – Default Atlassian build environment Docker images
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9.1 – 默认的 Atlassian 构建环境 Docker 镜像
- en: Important note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An image tagged as `latest` is using an older image with other images that are
    created more recently. This allows for backward compatibility with older Bitbucket
    Pipelines builds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 `latest` 的镜像使用的是较旧的镜像，其他镜像则是更近期创建的。这确保了与旧版 Bitbucket Pipelines 构建的向后兼容性。
- en: 'To specify the desired version, add the following line to `bitbucket-pipelines.yml`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定所需版本，请将以下行添加到 `bitbucket-pipelines.yml` 文件中：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `<version number>` represents the desired version or tag (such as `latest`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<version number>`表示所需的版本或标签（例如 `latest`）。
- en: We can specify any Docker image, from a public or private repository, to create
    our build environment. Let’s examine the methods for doing so in our next section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定任何来自公共或私有仓库的 Docker 镜像来创建我们的构建环境。让我们在下一部分中探讨如何做到这一点。
- en: How to do it…
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Bitbucket Pipelines can use any Docker image from public or private repositories.
    The information that’s required differs based on whether the repository is public
    or private.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Bitbucket Pipelines 可以使用来自公共或私有仓库的任何 Docker 镜像。所需的信息依据仓库是公共还是私有而有所不同。
- en: Let’s learn how to use a Docker image from a public registry.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用来自公共注册表的 Docker 镜像。
- en: Using a public image
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用公共镜像
- en: A public repository hosts Docker images available for use by anyone. This repository
    can reside on Docker Hub, another repository, or even a self-published repository,
    so long as it can be accessed on the internet.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 公共仓库托管着任何人都可以使用的 Docker 镜像。该仓库可以托管在 Docker Hub 上，也可以是其他仓库，甚至是自发布的仓库，只要它可以通过互联网访问。
- en: 'Let’s look at using a public Docker image for your build environment:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何使用公共 Docker 镜像作为构建环境：
- en: 'Specify the image by name in the `bitbucket-pipelines.yml` file. If a tag isn’t
    included, the `latest` tag is implied:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bitbucket-pipelines.yml` 文件中通过名称指定镜像。如果没有包含标签，则默认使用 `latest` 标签：
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If an account is specified, it should be included as part of the name:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指定了账户，它应作为名称的一部分：
- en: '[PRE2]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Specific versions can be included after the image’s name with a colon:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在镜像名称后添加冒号和特定版本：
- en: '[PRE3]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you’re using a public image not hosted on Docker Hub, include the repository’s
    URL in the image specification:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果使用的公共镜像不托管在 Docker Hub 上，请在镜像规范中包含仓库的 URL：
- en: '[PRE4]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that, you’ve learned how to specify public Docker images for build environments.
    Now, let’s look at using private images.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就学会了如何为构建环境指定公共 Docker 镜像。接下来，我们来看看如何使用私有镜像。
- en: Using a private image
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用私有镜像
- en: Private Docker repositories are often used by companies and other organizations
    to store custom Docker images containing that organization’s intellectual property.
    These repositories are often secured through authentication policies.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 私有 Docker 仓库通常由公司和其他组织用来存储包含该组织知识产权的自定义 Docker 镜像。这些仓库通常通过认证策略来进行保护。
- en: 'Let’s look at configuring build environments by using private Docker images:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看看如何通过使用私有 Docker 镜像来配置构建环境：
- en: 'You can add secured variables to store your credentials and refer to the variables
    in the `bitbucket-pipelines.yml` file. Variables and secrets were discussed in
    [*Chapter 6*](B21937_06.xhtml#_idTextAnchor103). The following code snippet shows
    an example of a private Docker Hub repository:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以添加安全变量来存储你的凭证，并在`bitbucket-pipelines.yml`文件中引用这些变量。关于变量和秘密的内容可以参考[*第 6 章*](B21937_06.xhtml#_idTextAnchor103)。以下代码片段展示了一个私有
    Docker Hub 仓库的示例：
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If your private Docker repository uses AWS `aws` section:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的私有 Docker 仓库使用 AWS `aws` 部分：
- en: '[PRE6]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Another method of passing AWS credentials involves setting up an IAM role in
    AWS and setting up Bitbucket Pipelines as a web identity provider. This allows
    Bitbucket Pipelines to connect to AWS ECR using Open ID Connect. Detailed instructions
    for this are located at [https://support.atlassian.com/bitbucket-cloud/docs/use-aws-ecr-images-in-pipelines-with-openid-connect/](https://support.atlassian.com/bitbucket-cloud/docs/use-aws-ecr-images-in-pipelines-with-openid-connect/).
    The following code snippet must then be placed in `bitbucket-pipelines.yml`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递 AWS 凭证的另一种方法是通过在 AWS 中设置 IAM 角色，并将 Bitbucket Pipelines 配置为 Web 身份提供者。这使得
    Bitbucket Pipelines 能够使用 Open ID Connect 连接到 AWS ECR。详细说明可以参考[https://support.atlassian.com/bitbucket-cloud/docs/use-aws-ecr-images-in-pipelines-with-openid-connect/](https://support.atlassian.com/bitbucket-cloud/docs/use-aws-ecr-images-in-pipelines-with-openid-connect/)。接下来，必须将以下代码片段放入`bitbucket-pipelines.yml`文件中：
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If your private Docker repository is located in **Google Container Registry**
    (**GCR**), you must create a service account in the GCP admin console that grants
    *Viewer* access to GCR for Bitbucket Pipelines. This will create a private key
    in JSON format. Download the key and save it in Bitbucket Pipelines as a secured
    variable. You can then access the image using the following code snippet:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的私有 Docker 仓库位于 **Google Container Registry** (**GCR**) 中，你必须在 GCP 管理控制台中创建一个服务账户，并授予
    Bitbucket Pipelines 对 GCR 的 *Viewer* 访问权限。这样将创建一个 JSON 格式的私钥。下载该密钥并将其作为安全变量保存在
    Bitbucket Pipelines 中。然后，你可以使用以下代码片段访问该镜像：
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For any other private Docker repository, provide the registry URL and include
    the credentials as secured variables. This is shown in the following code snippet:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于其他任何私有 Docker 仓库，请提供注册表 URL，并将凭证作为安全变量进行配置。以下代码片段展示了这一点：
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With that, you’ve seen a variety of places where Bitbucket Pipelines can retrieve
    Docker images for use as build environments.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，你已经看到 Bitbucket Pipelines 可以从多个地方获取 Docker 镜像来作为构建环境。
- en: Next, we’ll look at defining and using containerized services while running
    our Bitbucket pipeline.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何在运行 Bitbucket pipeline 时定义和使用容器化服务。
- en: Using containerized services in Bitbucket Pipelines
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Bitbucket Pipelines 中使用容器化服务
- en: You can run multiple services in a Bitbucket pipeline by defining containers
    to use. Once the pipeline runs, these services are scheduled to run in the step
    they are invoked. Services that can be invoked in this manner include databases,
    code analytics, and web services.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过定义要使用的容器在 Bitbucket pipeline 中运行多个服务。当 pipeline 运行时，这些服务将在被调用的步骤中按计划执行。可以通过这种方式调用的服务包括数据库、代码分析和
    Web 服务。
- en: In this recipe, we’ll look at defining and using containerized services.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将学习如何定义和使用容器化服务。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备开始
- en: There are a few things to understand about the limitations of using services
    implemented in containers during pipeline executions. Let’s take a close look
    at them now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pipeline 执行过程中，使用容器化服务有一些限制需要理解。我们现在来详细看看这些限制。
- en: There are a limited number of resources available for these containerized services.
    Any given step in the pipeline can work with a maximum of five services. If you
    need to run with a larger number of services, you can define a `docker run` or
    `docker-compose`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些容器化服务可用的资源是有限的。每个 pipeline 步骤最多可以使用五个服务。如果你需要使用更多服务，可以定义 `docker run` 或 `docker-compose`。
- en: Each of these services will run without waiting for service startup. While these
    services are running, you cannot access the services or their logs through REST
    API calls, although logs should be available through the Bitbucket Pipelines `29418`
    will be reserved and cannot be used for external actions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务将会在没有等待服务启动的情况下运行。尽管这些服务正在运行，但你无法通过REST API调用访问服务或其日志，尽管日志应通过Bitbucket Pipelines提供。`29418`将被保留，无法用于外部操作。
- en: 'The most involved limits for services involve memory. Each step can be defined
    as either a regular step with a 4,096 MB memory limit or as a large build step
    (defined by adding the `size: 2x` statement in the step definition), which increases
    the memory limit to 8,192 MB.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '服务的最复杂限制涉及内存。每个步骤可以定义为常规步骤（具有4,096 MB的内存限制）或大构建步骤（通过在步骤定义中添加`size: 2x`语句来定义），这将把内存限制提高到8,192
    MB。'
- en: The memory in a step is divided into one build container and the number of service
    containers as defined by the step. A build container requires a minimum of 1,024
    MB. This amount of memory is needed to handle the build process and any overhead
    required by Bitbucket Pipelines.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤中的内存被分配为一个构建容器和步骤中定义的服务容器数量。构建容器需要至少1,024 MB。这部分内存用于处理构建过程和Bitbucket Pipelines所需的任何开销。
- en: The remaining memory is then available to the service containers. After memory
    is allocated by the build container, 3,027 MB or 7,128 MB is left over for the
    service containers. By default, each service container can receive 1,024 MB or
    a custom amount between 128 MB and the maximum amount. This can be set by using
    the `memory` keyword in the service definition.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的内存将提供给服务容器。在构建容器分配内存后，服务容器将剩余3,027 MB或7,128 MB。默认情况下，每个服务容器可以获得1,024 MB或一个自定义值，范围为128
    MB到最大值。可以通过在服务定义中使用`memory`关键字来设置此值。
- en: If your build step includes Bitbucket Pipes, it uses a built-in Docker service.
    By default, this Docker service occupies 1,024 MB of the build step’s memory but
    can be configured to a custom amount by setting the memory between 128 MB to the
    maximum.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的构建步骤包含Bitbucket Pipes，它使用的是内置的Docker服务。默认情况下，这个Docker服务占用构建步骤的1,024 MB内存，但可以通过将内存设置为128
    MB到最大值之间的自定义值来进行配置。
- en: Now that we understand these limitations, let’s learn how to define the services
    that can run on a given step.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了这些限制，让我们学习如何定义可以在给定步骤上运行的服务。
- en: How to do it…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到……
- en: 'The following is a set of examples of the types of services that can be defined
    within a build step. In this recipe, we’re going to look at examples that use
    them:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以在构建步骤中定义的服务类型的一组示例。在本食谱中，我们将查看使用这些服务的示例：
- en: Database service
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库服务
- en: Data store (for example, NoSQL) service
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据存储服务（例如，NoSQL）
- en: Docker-in-Docker service
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker-in-Docker服务
- en: Let’s look at how to define these services.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何定义这些服务。
- en: Defining a containerized database service
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个容器化的数据库服务
- en: 'Let’s start with what the definition would be for a database service that had
    all default values:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个具有所有默认值的数据库服务的定义开始：
- en: 'In the `definitions:` section, specify the service name in `services:`, add
    the Docker image using the `image:` keyword, and the necessary credentials (as
    secure variables) in the `variables:` section. This should look as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`definitions:`部分，在`services:`中指定服务名称，使用`image:`关键字添加Docker镜像，并在`variables:`部分中添加必要的凭证（作为安全变量）。这应如下所示：
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To use the service in a step, add the service in the `services:` section of
    the step. This is shown in the following code snippet:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在步骤中使用服务，请将服务添加到步骤的`services:`部分。如下所示的代码片段：
- en: '[PRE11]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To customize the memory allocation, add the desired amount of memory, in MB,
    after the `memory:` keyword in the `definitions:` section. The code should now
    look as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要自定义内存分配，请在`definitions:`部分的`memory:`关键字后面添加所需的内存量（以MB为单位）。代码应如下所示：
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now have a database service running for our build step with 2,048 MB in its
    service container.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在构建步骤中运行了一个数据库服务，并且它的服务容器内存为2,048 MB。
- en: Defining a containerized data store service
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义一个容器化的数据存储服务
- en: 'Let’s create our data store service in the same manner that we did in the previous
    example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照前一个示例中的方式创建我们的数据存储服务：
- en: 'In the `definitions:` section, set up the service name in `services:` and add
    the Docker image using the `image:` keyword. These additions should look as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`definitions:`部分，设置`services:`中的服务名称，并使用`image:`关键字添加Docker镜像。这些添加应如下所示：
- en: '[PRE13]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To use the service in a step, simply add it to the `services:` section of the
    step. We’ve also added a command we’re running based on the service. This is shown
    in the following code snippet:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在某个步骤中使用该服务，只需将其添加到该步骤的 `services:` 部分。我们还添加了一个基于该服务运行的命令。如下代码片段所示：
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With that, we’ve learned how to define a containerized service and use it within
    the build step.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经学会了如何定义一个容器化服务并在构建步骤中使用它。
- en: Now, let’s learn how to invoke a Docker-in-Docker service.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何调用 Docker-in-Docker 服务。
- en: Defining a service for Docker-in-Docker
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义 Docker-in-Docker 服务
- en: 'Let’s look at running a Docker service within our build step:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在构建步骤中运行 Docker 服务：
- en: 'In the `definitions:` section, set up the service name in `services:`. This
    should look as follows:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `definitions:` 部分，在 `services:` 中设置服务名称。应该如下所示：
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To use the service in a step, add it to the `services:` section of the step.
    We’ve also added a command we’re running based on the service. This is shown in
    the following code snippet:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在某个步骤中使用该服务，请将其添加到该步骤的 `services:` 部分。我们还添加了一个基于该服务运行的命令。如下代码片段所示：
- en: '[PRE16]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can give your Docker services custom names. Define the service with the
    custom name and set `type:` to `docker`. A detailed example of a custom Docker
    service with memory size customizations is shown in the following code snippet:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以为你的 Docker 服务指定自定义名称。定义服务时使用自定义名称，并将 `type:` 设置为 `docker`。以下代码片段展示了一个自定义
    Docker 服务的详细示例，并包含内存大小的定制：
- en: '[PRE17]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With that, we’ve learned how to define Docker as a service from within Bitbucket
    Pipelines.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经学习了如何在 Bitbucket Pipelines 中将 Docker 定义为一个服务。
- en: Next, we’ll learn how to deploy our Bitbucket Pipelines output as a Docker image
    and push the image to a Docker repository. For that, we need to understand how
    to execute Docker commands. Let’s see how that’s done.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何将 Bitbucket Pipelines 的输出作为 Docker 镜像部署并将其推送到 Docker 仓库。为此，我们需要了解如何执行
    Docker 命令。让我们看看这如何操作。
- en: Using Docker commands in Bitbucket Pipelines
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Bitbucket Pipelines 中使用 Docker 命令
- en: If you have a Dockerfile in your Bitbucket repository, you can use Bitbucket
    Pipelines to build the image and push it to your Docker repository. You can do
    this by executing Docker commands from within the `bitbucket-pipelines.yml` file.
    Let’s take a closer look at how that’s done.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Bitbucket 仓库中有一个 Dockerfile，你可以使用 Bitbucket Pipelines 构建镜像并将其推送到 Docker
    仓库。你可以通过在 `bitbucket-pipelines.yml` 文件中执行 Docker 命令来实现这一点。让我们更详细地看看如何操作。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before adding Docker commands to the `bitbucket-pipelines.yml` file, we need
    to enable the following configurations:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Docker 命令添加到 `bitbucket-pipelines.yml` 文件之前，我们需要启用以下配置：
- en: Allowing access to the Docker daemon
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许访问 Docker 守护进程
- en: Enabling Docker BuildKit
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 Docker BuildKit
- en: These configurations are part of `bitbucket-pipelines.yml`. Let’s see where
    they go.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置是 `bitbucket-pipelines.yml` 文件的一部分。让我们看看它们的位置。
- en: Enabling access to the Docker daemon
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用对 Docker 守护进程的访问
- en: 'Access to the Docker daemon as a service can be done either by adding Docker
    as a service to an individual step, which is recommended so that you can keep
    track of how many services your overall pipeline is running, or by adding Docker
    as a service to all steps. Let’s see how each alternative is done:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 Docker 作为服务添加到某个步骤中，可以实现对 Docker 守护进程的访问，这种方法推荐使用，因为你可以跟踪整体管道正在运行多少个服务，或者也可以将
    Docker 作为服务添加到所有步骤中。让我们看看每种方法是如何实现的：
- en: 'To add Docker as a service for the build step, make sure it is present in the
    `services:` section of the step. This is illustrated in the following code snippet:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 Docker 作为构建步骤的服务使用，请确保它出现在该步骤的 `services:` 部分。如以下代码片段所示：
- en: '[PRE18]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To add Docker as a service globally, add `docker` in the `options:` section
    and set it to `true`, as shown in the following code snippet:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将 Docker 作为全局服务使用，需在 `options:` 部分添加 `docker` 并将其设置为 `true`，如下代码片段所示：
- en: '[PRE19]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are a few things to note about enabling access to the Docker daemon. Docker
    is defined as a service by default, so we don’t need to define it in the `definitions:`
    section of `bitbucket-pipelines.yml`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Docker 守护进程访问时有一些需要注意的事项。默认情况下，Docker 被定义为一个服务，因此我们无需在 `bitbucket-pipelines.yml`
    的 `definitions:` 部分重新定义它。
- en: These days, creating Docker builds involves using Docker BuildKit. So, let’s
    learn how to work with Docker BuildKit in Bitbucket Pipelines.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建 Docker 构建通常需要使用 Docker BuildKit。那么，让我们学习如何在 Bitbucket Pipelines 中使用 Docker
    BuildKit。
- en: Enabling Docker BuildKit
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用 Docker BuildKit
- en: Docker BuildKit is a default part of building when using Docker Desktop or Docker
    Engine v23.0 and beyond. We want to make sure it is enabled to ensure compatibility
    with these versions. So, let’s explore how to work with Docker BuildKit.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Docker BuildKit 是在使用 Docker Desktop 或 Docker Engine v23.0 及以上版本时构建的默认部分。我们希望确保启用它，以确保与这些版本的兼容性。所以，让我们探索如何使用
    Docker BuildKit。
- en: 'To enable Docker BuildKit, make sure the `DOCKER_BUILDKIT` environment variable
    is set to `1`, as shown in the following code snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用 Docker BuildKit，确保将 `DOCKER_BUILDKIT` 环境变量设置为 `1`，如以下代码片段所示：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now, let’s learn how to use Docker commands in Bitbucket Pipelines.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何在 Bitbucket Pipelines 中使用 Docker 命令。
- en: How to do it…
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: With Docker and Docker BuildKit enabled, we can run most Docker commands. For
    security, reasons Bitbucket Pipelines has placed limitations on the Docker commands
    that can be run, as well as the modes of other Docker commands. A detailed list
    of the restrictions can be found at [https://support.atlassian.com/bitbucket-cloud/docs/run-docker-commands-in-bitbucket-pipelines/](https://support.atlassian.com/bitbucket-cloud/docs/run-docker-commands-in-bitbucket-pipelines/).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Docker 和 Docker BuildKit 后，我们可以运行大多数 Docker 命令。出于安全原因，Bitbucket Pipelines
    对可以运行的 Docker 命令以及其他 Docker 命令的模式进行了限制。有关限制的详细列表，请访问[https://support.atlassian.com/bitbucket-cloud/docs/run-docker-commands-in-bitbucket-pipelines/](https://support.atlassian.com/bitbucket-cloud/docs/run-docker-commands-in-bitbucket-pipelines/)。
- en: 'In the meantime, we’ll consider the common use cases for incorporating Docker
    into Bitbucket Pipelines. These include the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，我们将考虑将 Docker 集成到 Bitbucket Pipelines 中的常见用例。这些包括以下内容：
- en: Building a Docker image from a Dockerfile
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Dockerfile 构建 Docker 镜像
- en: Passing secrets to Docker BuildKit from Bitbucket secured variables
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Bitbucket 安全变量将秘密传递给 Docker BuildKit
- en: Passing secrets to Docker BuildKit from external secret managers
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部秘密管理器将秘密传递给 Docker BuildKit
- en: Pushing a Docker image to a Docker repository
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Docker 镜像推送到 Docker 仓库
- en: Let’s examine these common use cases.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些常见的用例。
- en: Building a Docker image from a Dockerfile
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 Dockerfile 构建 Docker 镜像
- en: 'With Docker BuildKit enabled, Bitbucket Pipelines can build a Docker image.
    Let’s look at this in detail:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 Docker BuildKit 后，Bitbucket Pipelines 可以构建 Docker 镜像。让我们详细了解一下：
- en: Make sure that a Dockerfile exists at the root level of your Bitbucket repository.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在你的 Bitbucket 仓库的根目录下存在一个 Dockerfile。
- en: You may want to specify your image’s name as a variable.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能想将镜像名称指定为一个变量。
- en: 'Add the following line in the script portion of your build step:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建步骤的脚本部分添加以下行：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With this done, let’s move on to the next use case.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这一步后，让我们进入下一个用例。
- en: Passing secrets to Docker BuildKit with secured variables
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用安全变量将秘密传递给 Docker BuildKit
- en: 'If we need to pass secrets such as credentials or API keys to a BuildKit build,
    we can use secured variables in Bitbucket to pass them. Here’s how we can do this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要将诸如凭据或 API 密钥等秘密传递给 BuildKit 构建，可以使用 Bitbucket 中的安全变量进行传递。下面是我们可以执行的操作：
- en: Create the secure variable in Bitbucket.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Bitbucket 中创建安全变量。
- en: '[PRE22]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the Dockerfile, add a `RUN` instruction that mounts the secure variable
    (using the `--mount=type=secret` flag) into the default Docker secret store `(/run/secrets/*)`.
    This is illustrated in the following code snippet:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Dockerfile 中，添加一个 `RUN` 指令，将安全变量挂载（使用 `--mount=type=secret` 标志）到默认的 Docker
    秘密存储中 `(/run/secrets/*)`。以下代码片段展示了这一操作：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There’s another way secrets can be passed to Docker BuildKit: using an external
    secret manager. So, let’s explore how to work with external secret managers.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种将秘密传递给 Docker BuildKit 的方法：使用外部秘密管理器。所以，让我们探索如何与外部秘密管理器一起工作。
- en: Passing secrets to Docker BuildKit with external secret managers
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用外部秘密管理器将秘密传递给 Docker BuildKit
- en: 'We can also connect to external secret managers such as Hashicorp Vault or
    Google Cloud Secret Manager to pass secrets such as credentials or API keys to
    a BuildKit build. Let’s learn how:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以连接到外部秘密管理器，例如 Hashicorp Vault 或 Google Cloud Secret Manager，将凭据或 API 密钥等秘密传递给
    BuildKit 构建。让我们学习如何操作：
- en: 'In the `bitbucket-pipelines.yml` file, get the secret from the manager, place
    the secret in a pipeline file, add the `--secret` flag, and identify the source
    as the pipeline file. Remember that the pipeline file will be deleted when the
    pipeline step is complete and the container is removed. The following code snippet
    shows `SECRET` as the secure variable:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `bitbucket-pipelines.yml` 文件中，从管理器获取秘密，将秘密放入管道文件中，添加 `--secret` 标志，并将源标识为管道文件。请记住，管道文件将在管道步骤完成并且容器被移除时被删除。以下代码片段展示了
    `SECRET` 作为安全变量：
- en: '[PRE25]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the Dockerfile, add a `RUN` instruction that mounts the secure variable
    (using the `--mount=type=secret` flag), including the pipeline file containing
    the secret, into the default Docker secret store (`/run/secrets/*`). This is illustrated
    in the following code snippet:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Dockerfile 中，添加一个 `RUN` 指令，挂载安全变量（使用 `--mount=type=secret` 标志），并将包含秘密的管道文件挂载到默认的
    Docker 秘密存储区 (`/run/secrets/*`) 中。以下代码片段演示了这个过程：
- en: '[PRE26]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With that, we’ve built an image that passed a secret found in an external source.
    Now, let’s look at the various actions you can perform, including pushing to a
    Docker registry.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些步骤，我们已经构建了一个包含从外部来源获取的秘密的镜像。现在，让我们来看看你可以执行的各种操作，包括推送到 Docker 注册表。
- en: Pushing a Docker image to a Docker registry
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Docker 镜像推送到 Docker 注册表
- en: 'You can push images you create to Docker Hub or another registry as part of
    a Bitbucket Pipelines script execution. Follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将创建的镜像推送到 Docker Hub 或其他注册表，作为 Bitbucket Pipelines 脚本执行的一部分。请按照以下步骤操作：
- en: Create variables for the image name, username for the Docker repository, and
    password for the Docker repository. The username and password should be secure
    variables.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建镜像名称、Docker 仓库用户名和 Docker 仓库密码的变量。用户名和密码应该是安全变量。
- en: 'Add commands to the script portion of the step to deploy the Docker image.
    To do this, you must do the following:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向步骤的脚本部分添加命令，以部署 Docker 镜像。为此，你需要执行以下操作：
- en: Log in to the Docker repository.
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到 Docker 仓库。
- en: Push the image via `docker push`.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `docker push` 推送镜像。
- en: 'The following code snippet shows a basic example of how to build and push a
    Docker image:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段展示了如何构建并推送 Docker 镜像的基本示例：
- en: '[PRE27]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With that, we’ve learned how to deploy our application as a Docker image by
    building it and pushing the resulting image to a Docker registry. We can take
    our example a step further by deploying the Docker image to a Kubernetes cluster.
    We’ll do this in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经学会了如何通过构建 Docker 镜像并将生成的镜像推送到 Docker 注册表来部署应用程序。接下来，我们可以进一步完善我们的示例，将
    Docker 镜像部署到 Kubernetes 集群。我们将在下一节中介绍这个过程。
- en: Deploying a Docker image to Kubernetes using Bitbucket Pipelines
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Bitbucket Pipelines 将 Docker 镜像部署到 Kubernetes
- en: A potential next step after building the Docker image is to deploy it to a Kubernetes
    cluster. By taking advantage of the redundancy capabilities in a cluster, we can
    perform application upgrades without a service outage occurring.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Docker 镜像之后，可能的下一步是将其部署到 Kubernetes 集群。通过利用集群的冗余能力，我们可以在不发生服务中断的情况下进行应用程序的升级。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The instructions in this recipe assume that you have an existing Kubernetes
    cluster or minikube environment that was created manually.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程假设你已有一个手动创建的 Kubernetes 集群或 minikube 环境。
- en: In addition, you must manually define a deployment that runs the application
    in Kubernetes. So, let’s learn how to create a deployment.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还必须手动定义一个部署，用于在 Kubernetes 中运行应用程序。所以，让我们学习如何创建一个部署。
- en: 'Ensure the application name and the Docker registry username are available
    for easy reference. Execute the `kubectl` command, including the necessary flags,
    as shown in the following code snippet. These will include the application name
    and Docker registry name as part of the image name:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 确保应用程序名称和 Docker 注册表用户名可供轻松引用。执行 `kubectl` 命令，并包括必要的标志，如以下代码片段所示。这些标志将包括应用程序名称和
    Docker 注册表名称作为镜像名称的一部分：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we have established a deployment in Kubernetes, let’s learn about the
    continuous deployment aspect of the application when using Bitbucket Pipelines.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在 Kubernetes 中建立了部署，接下来让我们学习在使用 Bitbucket Pipelines 时，如何实现应用程序的持续部署。
- en: How to do it…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We can integrate with the `kubectl` application from Bitbucket Pipelines in
    one of two ways:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过两种方式将 `kubectl` 应用程序集成到 Bitbucket Pipelines 中：
- en: Using a Pipe to integrate
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道进行集成
- en: Setting up a service
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置服务
- en: Let’s take a look at each method in more detail.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每种方法。
- en: Executing kubectl using pipes
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用管道执行 kubectl
- en: As we saw in [*Chapter 6*](B21937_06.xhtml#_idTextAnchor103), Bitbucket Pipes
    are pre-packaged integrations with common third-party tools and utilities. They
    can be easily added into Bitbucket Pipelines steps and will execute through separate
    containers as services.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第六章*](B21937_06.xhtml#_idTextAnchor103)中看到的那样，Bitbucket Pipes 是与常见第三方工具和实用程序的预打包集成。它们可以轻松地添加到
    Bitbucket Pipelines 步骤中，并通过单独的容器作为服务执行。
- en: 'Let’s learn how to incorporate the pipe for `kubectl`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何将 `kubectl` 管道集成进去：
- en: 'Set up the `kubeconfig` file for reading. This file needs to be `Base64` encoded
    and then stored as a secure variable. You can use the following code to do so:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`kubeconfig`文件以供读取。此文件需要进行`Base64`编码，然后存储为一个安全变量。你可以使用以下代码来实现：
- en: '[PRE29]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the pipe to the script portion of the step. The pipe definition should
    look like this:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将管道添加到步骤的脚本部分。管道定义应该如下所示：
- en: '[PRE30]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: With that, we have deployed to Kubernetes using a pipe via Bitbucket Pipelines.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，我们已经通过Bitbucket Pipelines使用管道部署到了Kubernetes。
- en: Sometimes, we need to execute a different version of `kubectl` than what’s provided
    on a Pipe. In this case, executing from the Atlassian-provided Docker image for
    `kubectl` is a better alternative. One reason for incorporating a different version
    may be to ensure compatibility with an existing Kubernetes cluster on a legacy
    version. Let’s explore that option now.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要执行与管道中提供的版本不同的`kubectl`版本。在这种情况下，从Atlassian提供的`kubectl` Docker镜像中执行是更好的选择。引入不同版本的一个原因可能是为了确保与现有Kubernetes集群的兼容性，尤其是当集群使用的是旧版本时。现在，让我们探索这个选项。
- en: Executing kubectl using a kubectl Docker image
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用kubectl Docker镜像执行kubectl
- en: Bitbucket Pipelines also has a version of `kubectl` that’s encapsulated in its
    own Docker image. This image is located on Docker Hub at [https://hub.docker.com/r/atlassian/pipelines-kubectl](https://hub.docker.com/r/atlassian/pipelines-kubectl)
    and can be used within a Bitbucket Pipelines script to execute `kubectl` commands.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Bitbucket Pipelines也有一个版本的`kubectl`，它封装在自己的Docker镜像中。此镜像位于Docker Hub上，地址为[https://hub.docker.com/r/atlassian/pipelines-kubectl](https://hub.docker.com/r/atlassian/pipelines-kubectl)，可以在Bitbucket
    Pipelines脚本中使用它来执行`kubectl`命令。
- en: 'To deploy on Kubernetes using a `kubectl` service, perform the following steps:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`kubectl`服务在Kubernetes上进行部署时，请执行以下步骤：
- en: Within the deployment step, define the Docker image using the `image:` keyword.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在部署步骤中，使用`image:`关键字定义Docker镜像。
- en: 'Set up our `kubeconfig` file. This time, we’re decoding Base64 to create a
    temporary file that gets destroyed after execution:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们的`kubeconfig`文件。这一次，我们将解码Base64来创建一个临时文件，并在执行后销毁该文件：
- en: '[PRE31]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Execute the `kubectl` command to apply a new version of the application:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`kubectl`命令来应用应用程序的新版本：
- en: '[PRE32]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Putting this all together, we have the following code snippet:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 综合以上内容，我们得到以下代码片段：
- en: '[PRE33]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As seen in the *Configuring deployments* recipe in [*Chapter 8*](B21937_08.xhtml#_idTextAnchor149),
    you can monitor your deployment using the deployment dashboard.
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如在[*第8章*](B21937_08.xhtml#_idTextAnchor149)的*配置部署*食谱中所示，你可以通过部署仪表板监控你的部署。
- en: With that, you’ve learned how to build our application as a Docker image and
    deploy it to a Kubernetes environment.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一切，你已经学会了如何将我们的应用构建为Docker镜像并部署到Kubernetes环境中。
- en: Our last stop in examining how we can leverage Docker moves us from pipelines
    to runners. So, let’s learn how to configure Docker-based runners on Linux.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在探索如何利用Docker时的最后一步是从管道到运行器。因此，让我们学习如何在Linux上配置基于Docker的运行器。
- en: Setting up Docker-based runners on Linux
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上设置基于Docker的运行器
- en: This application of this self-hosted runner allows for the ultimate in dynamic
    configuration. By allowing runners inside Docker containers, we can add or subtract
    runners as needed.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自托管运行器的这一应用提供了动态配置的极致体验。通过允许在Docker容器内运行器，我们可以根据需要添加或删除运行器。
- en: We’ll start with a Linux environment, install Docker, and load and run the Docker
    image for the Bitbucket runner software. Let’s take a look at the complete picture
    of setting up Docker-based runners.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Linux环境开始，安装Docker，然后加载并运行Bitbucket运行器软件的Docker镜像。让我们来看一下设置基于Docker的运行器的完整过程。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Our Linux environment has some prerequisites we must cover before we can proceed.
    First, we need to understand our Linux environment. This environment should have
    the following features:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Linux环境有一些先决条件，在继续之前必须先覆盖它们。首先，我们需要了解我们的Linux环境。此环境应具备以下特性：
- en: You should be using the 64-bit version of Linux.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该使用64位版本的Linux。
- en: A minimum of 8 GB of RAM should be allocated to the host for the runner. If
    you know that you are going to need a lot of room (for example, due to more build
    steps), you should allocate more memory.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少需要为运行器主机分配8 GB的RAM。如果你知道你需要更多空间（例如，由于更多的构建步骤），你应分配更多内存。
- en: At least 512 MB must be allocated for the runner container.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少需要为运行器容器分配512 MB的内存。
- en: Docker v19.03 or above must be installed.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须安装Docker v19.03或更高版本。
- en: 'With the Linux environment set up in this manner, we have to look at best practices
    for our Linux environment recommended by Atlassian. Atlassian recommends the following
    environment configurations:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方式设置好 Linux 环境后，我们需要查看 Atlassian 推荐的 Linux 环境最佳实践。Atlassian 推荐以下环境配置：
- en: Disabling **swap** space in your Linux environment
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁用**交换**空间在你的 Linux 环境中
- en: Configuring `vm.swappiness`
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 `vm.swappiness`
- en: Let’s take a closer look at these recommendations.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些建议。
- en: Disabling swap space
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用交换空间
- en: 'Depending on the Linux distribution you’re using, you may not have the necessary
    commands installed. If the following commands aren’t available in your Linux environment,
    you can install them using the distribution’s preferred package manager:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的 Linux 发行版，你可能没有安装必要的命令。如果以下命令在你的 Linux 环境中不可用，你可以使用该发行版推荐的包管理器进行安装：
- en: 'Check if swap is enabled:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查交换空间是否已启用：
- en: '[PRE34]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Existing swap partitions will appear, as shown in the following output, if
    swap is enabled:'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果交换空间已启用，现有的交换分区会显示在以下输出中：
- en: '[PRE35]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Disable swap by executing the following command:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令禁用交换空间：
- en: '[PRE36]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Reboot your Linux machine.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启你的 Linux 机器。
- en: Repeat these steps until no swap partitions appear.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复这些步骤，直到不再出现交换分区。
- en: At this point, we have eliminated one source of swap storage. However, we should
    eliminate other sources. For that, we will take a look at configuring `vm.swappiness`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经消除了一个交换存储源。然而，我们应该消除其他来源。为此，我们将查看配置 `vm.swappiness`。
- en: Configuring vm.swappiness
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 vm.swappiness
- en: Again, some Linux distributions may not have the commands specified in the following
    steps. If this is the case, install the required commands using the Linux distribution’s
    recommended package manager.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，一些 Linux 发行版可能没有指定以下步骤中的命令。如果是这种情况，使用 Linux 发行版推荐的包管理器安装所需的命令。
- en: 'Let’s take a close look at correctly configuring `vm.swappiness` to disable
    swap:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看如何正确配置 `vm.swappiness` 来禁用交换空间：
- en: 'Check the value of `vm.swappiness` using the following command:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令检查 `vm.swappiness` 的值：
- en: '[PRE37]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If subsequent examinations of the value of `vm.swappiness` are anything other
    than `1`, repeat these steps and ensure the setting is configured correctly in
    `/etc/sysctl.conf`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果后续检查 `vm.swappiness` 的值不是 `1`，请重复这些步骤，并确保在 `/etc/sysctl.conf` 中正确配置该设置。
- en: The next step is highly recommended to maintain the proper operation of your
    Linux environment. Periodically, stale Docker container images should be cleaned
    up. Let’s see how to schedule this operation.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为了保持 Linux 环境的正常运行，强烈建议定期清理过时的 Docker 容器镜像。让我们来看一下如何安排这个操作。
- en: Automating the cleanup process for stale Docker images
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化清理过时 Docker 镜像的过程
- en: 'Our Linux environment should regularly remove unused Docker images to save
    on disk space. We want to ensure we have adequate disk space in our Linux environment
    so that we can continue to operate our runner and ensure its availability for
    Bitbucket Pipelines jobs. The command to remove unused Docker images is `docker
    system prune -af`. A common way of scheduling an automated means for running a
    command is by using **cron**. Let’s see how that can be done:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Linux 环境应定期清除未使用的 Docker 镜像，以节省磁盘空间。我们希望确保在 Linux 环境中有足够的磁盘空间，以便我们可以继续操作我们的
    runner 并确保它在 Bitbucket Pipelines 作业中可用。删除未使用 Docker 镜像的命令是 `docker system prune
    -af`。安排自动运行命令的常见方法是使用**cron**。让我们看看如何操作：
- en: 'For the correct user, open their `crontab` file by typing the following command:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于正确的用户，使用以下命令打开他们的 `crontab` 文件：
- en: '[PRE38]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 0 0 * * 0 docker system prune -af
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 0 0 * * 0 docker system prune -af
- en: '[PRE39]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Save the file and exit the editor.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并退出编辑器。
- en: With that, we’ve used cron to automate the deletion of unused Docker images.
    Now, it’s time to set up our runner.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里，我们已经通过 cron 自动化了未使用的 Docker 镜像删除。现在，轮到设置我们的 runner 了。
- en: How to do it…
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'With the preliminary steps out of the way, it’s time to connect our Linux environment
    to Bitbucket so that it can be used as a runner. Let’s examine how to do that:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成初步步骤后，接下来是将我们的 Linux 环境连接到 Bitbucket，以便它可以作为一个 runner 使用。让我们看看如何操作：
- en: 'On Bitbucket, define a new runner. A workplace runner can be defined by clicking
    the administration cog at the top-right corner of the screen and selecting **Workspace
    settings**:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Bitbucket 中，定义一个新的 runner。通过点击屏幕右上角的管理齿轮，选择**工作区设置**来定义一个工作区 runner：
- en: '![Figure 9.1 – Selecting Workspace settings in Bitbucket](img/B21937_09_01.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 在 Bitbucket 中选择工作区设置](img/B21937_09_01.jpg)'
- en: Figure 9.1 – Selecting Workspace settings in Bitbucket
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 在 Bitbucket 中选择工作区设置
- en: 'In the menu bar on the left, select **Workspace runners**:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单栏中，选择**工作区运行器**：
- en: '![Figure 9.2 – Selecting Workspace runners](img/B21937_09_02.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 选择工作区运行器](img/B21937_09_02.jpg)'
- en: Figure 9.2 – Selecting Workspace runners
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 选择工作区运行器
- en: Alternatively, if you’re setting up a runner for use within a repository, select
    the repository and select **Repository settings** in the repository’s sidebar.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你是在为存储库设置运行器，请选择存储库，并在存储库的侧边栏中选择**存储库设置**。
- en: '![Figure 9.3 – Selecting Repository settings](img/B21937_09_03.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 选择存储库设置](img/B21937_09_03.jpg)'
- en: Figure 9.3 – Selecting Repository settings
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 选择存储库设置
- en: In the **Repository settings** sidebar, select **Runners** under **Pipelines**.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**存储库设置**侧边栏中，选择**Pipelines**下的**运行器**。
- en: '![Figure 9.4 – Selecting Runners](img/B21937_09_04.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 选择运行器](img/B21937_09_04.jpg)'
- en: Figure 9.4 – Selecting Runners
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 选择运行器
- en: Regardless of whether you’re selecting the runner for the workspace or the repository,
    you can create the runner by selecting the **Add** **runner** button.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论是选择工作区的运行器还是存储库的运行器，都可以通过选择**添加** **运行器**按钮来创建运行器。
- en: In the modal that appears, select **Linux Docker (x86_64)** or **Linux Docker
    (arm64)** in the **System and architecture** panel, depending on your underlying
    hardware platform. Click **Next**.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在出现的模态框中，根据你的硬件平台选择**Linux Docker (x86_64)** 或 **Linux Docker (arm64)**，然后点击**下一步**。
- en: '![Figure 9.5 – Selecting Linux Docker under System and architecture](img/B21937_09_05.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 在系统和架构下选择 Linux Docker](img/B21937_09_05.jpg)'
- en: Figure 9.5 – Selecting Linux Docker under System and architecture
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 在系统和架构下选择 Linux Docker
- en: In the next modal, copy the Docker command that’s displayed and paste it into
    a Terminal window in your Linux environment. This command goes to the Docker registry
    to retrieve the Bitbucket Pipelines runner software as a Docker image and creates
    the container.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个模态框中，复制显示的 Docker 命令并将其粘贴到 Linux 环境中的终端窗口中。该命令将访问 Docker 注册表以检索 Bitbucket
    Pipelines 运行器软件作为 Docker 镜像，并创建容器。
- en: '![Figure 9.6 – Copying the Docker command to pull the runner](img/B21937_09_06.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – 复制 Docker 命令以拉取运行器](img/B21937_09_06.jpg)'
- en: Figure 9.6 – Copying the Docker command to pull the runner
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – 复制 Docker 命令以拉取运行器
- en: 'You may want to get the most up-to-date version of the runner when you start
    the runner again or just to make sure you have the latest one. To perform this
    update, execute the following `docker pull` command in your Linux environment:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能希望在重新启动运行器时获取最新版本，或者仅仅是为了确保你拥有最新版本。要执行此更新，请在你的 Linux 环境中执行以下 `docker pull`
    命令：
- en: '[PRE40]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You may encounter the following error when starting the runner:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 启动运行器时，你可能会遇到以下错误：
- en: '[PRE41]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: docker run [all existing parameters] -v /mydir:/mydir -e WORKING_DIRECTORY=/mydir
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: docker run [所有现有参数] -v /mydir:/mydir -e WORKING_DIRECTORY=/mydir
- en: '[PRE42]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With that, we’ve established Docker-based runners for any future executions
    of Bitbucket Pipelines.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经为将来执行 Bitbucket Pipelines 设置了基于 Docker 的运行器。
- en: 'Part 3: Maintaining Operations'
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 部分：维护操作
- en: After release, the focus turns to ensuring that the environment, with its new
    features and products, maintains the same level of performance, scalability, and
    security as before. Measurements of performance, both in the context of how the
    system is operating and whether it is delivering its promised value, are taken
    and displayed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 发布后，焦点转向确保新特性和产品的环境保持与之前相同的性能、可扩展性和安全性。通过对性能进行度量，评估系统的运行状态以及它是否交付了承诺的价值，并将结果展示出来。
- en: 'The displays reflect a focus on observability, ensuring not only that the metrics
    exist but that they are available and visible to everyone: developers, operations
    people, site reliability engineers, and others in the business.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 显示界面着重于可观察性，确保不仅仅是存在度量标准，还要确保这些度量标准对每个人可用且可见：开发人员、运维人员、站点可靠性工程师以及公司中的其他人员。
- en: When problems occur, people from these disciplines come together to collaborate
    on the problem and find a solution.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当问题发生时，这些领域的人员会聚集在一起合作解决问题并找到解决方案。
- en: In this part, we will explore how Atlassian tools such as Jira, Opsgenie, and
    Compass work together and with other tools to allow observability to all disciplines
    and the rapid escalation and resolution of problems.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将探讨 Atlassian 工具（如 Jira、Opsgenie 和 Compass）如何协同工作，以及与其他工具一起如何为各个领域提供可观察性，并快速升级和解决问题。
- en: 'This part has the following chapters:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 10*](B21937_10.xhtml#_idTextAnchor205)*, Collaborating with Operations
    through Continuous Deployment and Observability*'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21937_10.xhtml#_idTextAnchor205)*，通过持续部署和可观察性与运营团队协作*'
- en: '[*Chapter 11*](B21937_11.xhtml#_idTextAnchor214)*, Monitoring Component Activity
    and Metrics* *Through CheckOps* *in Compass*'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21937_11.xhtml#_idTextAnchor214)*，通过 CheckOps 在 Compass 中监控组件活动和指标*'
- en: '[*Chapter 12*](B21937_12.xhtml#_idTextAnchor240)*, Escalating Using Opsgenie
    Alerts*'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21937_12.xhtml#_idTextAnchor240)*，通过 Opsgenie 警报进行升级*'
