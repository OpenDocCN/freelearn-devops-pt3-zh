- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Testing Your Changes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的变更
- en: One of the core tenets of DevOps is the ability to deliver robust changes that
    stand up to scrutiny, have fewer defects, and ultimately reduce the **Change Failure
    Rate** (**CFR**) metric. This can be largely achieved through testing our development
    changes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps的核心原则之一是能够交付经过严格审查、缺陷更少的强大变更，最终减少**变更失败率**（**CFR**）指标。这可以通过测试我们的开发变更在很大程度上实现。
- en: In this chapter, we’ll explore the importance of robustly testing Salesforce
    changes, the different types of testing that apply to your components, and how
    to ensure proper testing as part of your DevOps process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨对Salesforce变更进行全面测试的重要性，适用于你组件的不同测试类型，以及如何确保在DevOps过程中进行适当的测试。
- en: 'We will be covering the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将覆盖以下主要主题：
- en: The importance of testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试的重要性
- en: Apex testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apex测试
- en: Testing your **Lightning Web** **Components** (**LWCs**)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的**Lightning Web** **组件**（**LWCs**）
- en: Testing your flows
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试你的流程
- en: By the end of this chapter, you should be well equipped to create and run tests
    within Salesforce that exercise much of the functionality you implement, whether
    programmatically or declaratively. This will in turn help you deliver better quality
    deployments as your DevOps process matures.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够在Salesforce中创建并运行测试，覆盖你实现的许多功能，无论是编程实现还是声明式实现。这将有助于你在DevOps过程中成熟后交付更高质量的部署。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'If you want to follow along with the examples in this chapter, as a minimum
    you will need to have the following installed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟随本章中的示例进行操作，至少需要安装以下软件：
- en: The Salesforce CLI
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Salesforce CLI
- en: Visual Studio Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: Salesforce extensions for Visual Studio Code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Salesforce扩展工具适用于Visual Studio Code
- en: Additionally, for the *Testing your LWCs* section, you will need to install
    Node.js (which will include **Node Package** **Manager** (**npm**)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于*测试你的LWC*部分，你需要安装Node.js（这将包括**Node包管理器**（**npm**））。
- en: The importance of testing
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试的重要性
- en: Conventional wisdom states that the earlier a software bug is found, the easier
    it is to fix and the less impact and cost it is likely to have. Often referred
    to as a **shift-left** approach—in that given a process diagram moving from left
    to right in sequence, the further left you deal with an issue, the better—the
    idea is that by including robust and thorough testing in your DevOps workflow,
    you stand a much better chance of catching potential issues early. This approach
    applies not only to functional testing of your Salesforce changes but also to
    the security aspects of your design and development too—part of what has been
    dubbed *DevSecOps* in the wider IT industry.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的观点认为，软件缺陷越早发现，修复起来越容易，其可能产生的影响和成本也越小。通常称之为**左移**方法——即在一个从左到右的流程图中，越早处理问题越好——这个理念是通过将强大且全面的测试纳入你的DevOps工作流，你有更好的机会尽早发现潜在问题。这种方法不仅适用于Salesforce变更的功能测试，也适用于你设计和开发的安全方面——这也是在更广泛的IT行业中被称为*DevSecOps*的部分内容。
- en: If we look at the impact of testing in the context of our DORA metrics discussed
    in [*Chapter 2*](B19436_02.xhtml#_idTextAnchor032), we can easily see that testing
    directly impacts the CFR metric. Put simply, the more well tested your changes
    are, the less likely that errors are to be deployed into your later environments.
    *Test early, test often* is a phrase I’ve used across my years in software development
    to nicely summarize my approach.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从我们在[*第2章*](B19436_02.xhtml#_idTextAnchor032)讨论的DORA指标的角度来看测试的影响，我们可以很容易地看出测试直接影响CFR指标。简而言之，你的变更经过充分测试，部署到后续环境中的错误发生的可能性就会降低。我在多年的软件开发中常常使用“*尽早测试，频繁测试*”这句话来很好地总结我的方法。
- en: When we look at testing in the wider aspect of DevOps, it’s important to consider
    it in the context of not just the development or delivery phases of the application
    life cycle, but across every step from design to delivery. As architects, we should
    be mentally testing the requirements and design long before we get to implement
    any changes—picking holes and finding flaws is one of the greatest skills of a
    Salesforce architect. By making sure that a request is valid and its design stands
    up to scrutiny, with questions satisfactorily answered, you’ve tested the approach
    well ahead of time. This is considered to be the cheapest time to uncover flaws
    before developer hours (and thus cost) are spent on a project. It can be thought
    of as the software development equivalent to the phrase *measure twice, cut once*
    often quoted in the construction world.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从更广泛的DevOps角度来看待测试时，重要的是要考虑它不仅仅在应用生命周期的开发或交付阶段，而是贯穿于从设计到交付的每一步。作为架构师，我们应该在实施任何变更之前，就开始从思想上测试需求和设计——找出漏洞和缺陷是Salesforce架构师最重要的技能之一。通过确保请求有效且其设计经得起推敲，且问题得到了令人满意的解答，您已经在很早之前就测试了这个方案。这被认为是在投入开发者时间（及成本）之前发现缺陷的最经济的时机。它可以被视为软件开发领域的“*量好两次，裁剪一次*”，这一说法在建筑行业中也常被引用。
- en: There is an array of different aspects to testing that should be considered
    as part of your overall application delivery model. We’ll cover some of the ones
    that are specific to the Salesforce platform’s technology stack here, but to get
    a holistic view of testing as an architect, you should consider the following
    types of testing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 测试涉及的方面种类繁多，应作为您整体应用交付模型的一部分进行考虑。我们将在这里讨论一些特定于Salesforce平台技术栈的测试，但作为架构师，您应该考虑以下几种测试类型，以全面了解测试。
- en: Integration testing
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Thorough integration testing is critical for validating that different components
    and systems work together as expected. For Salesforce projects, key integrations
    to test include connections between Salesforce and external databases, third-party
    web services, interactions between Salesforce products such as Sales Cloud and
    Service Cloud, and custom Lightning components or other customizations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 彻底的集成测试对于验证不同组件和系统能否按预期协同工作至关重要。对于Salesforce项目，关键的集成测试包括Salesforce与外部数据库、第三方Web服务之间的连接，Salesforce产品（如Sales
    Cloud和Service Cloud）之间的交互，以及自定义Lightning组件或其他自定义功能的测试。
- en: Use a combination of automated API and UI testing, **end-to-end** (**E2E**)
    process validation, and manual spot checks to confirm all integration points consistently
    function as designed from end to end. Import and export data between systems to
    check for accuracy and completeness. Where possible, send test requests to web
    services to validate response handling, or as a fallback, provide mock responses
    for these requests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动化的API和UI测试、**端到端**（**E2E**）流程验证，以及人工抽查相结合的方式，确保所有集成点从端到端始终按设计功能运作。跨系统导入和导出数据，检查数据的准确性和完整性。如有可能，向Web服务发送测试请求，验证响应处理，或者作为备选，提供这些请求的模拟响应。
- en: Regression testing
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回归测试
- en: Regression testing helps verify that existing functionality and integrations
    continue to work as expected after changes are made. Prioritize regression testing
    after deploying major updates, new features, or structural changes such as altering
    permissions or record-sharing rules. By building automated regression test suites
    that run quickly and frequently, focusing on critical business processes and key
    integration points most likely to be impacted by changes, you can quickly check
    and resolve any breaking changes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试帮助验证在进行更改后，现有的功能和集成功能是否仍按预期工作。在部署重大更新、新功能或结构性变更（如修改权限或记录共享规则）后，应优先进行回归测试。通过构建自动化的回归测试套件，使其快速且频繁地运行，重点关注最可能受到更改影响的关键业务流程和集成点，您可以快速检查并解决任何破坏性变更。
- en: Use a combination of automated UI testing, Apex tests to validate logic and
    handlers, cross-browser testing, and Salesforce API checks for data validation,
    and integrate regression testing into the deployment pipeline to run automatically.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自动化UI测试、Apex测试以验证逻辑和处理程序、跨浏览器测试，以及Salesforce API检查数据验证，并将回归测试集成到部署流水线中，自动运行。
- en: Regression testing gives confidence that the system remains stable through ongoing
    enhancements and changes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 回归测试能够确保系统在持续改进和变更过程中保持稳定。
- en: User acceptance testing
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户验收测试
- en: '**User acceptance testing** (**UAT**) usually requires a dedicated Salesforce
    sandbox with test data, roles, and processes modeled on real usage patterns. Involve
    real users in UAT, to validate that new features meet business needs before full
    release. Identify power users across **business units** (**BUs**) to serve as
    UAT testers who deeply understand needs and workflows.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户验收测试**（**UAT**）通常需要一个专门的 Salesforce 沙箱环境，里面有测试数据、角色和模拟的真实使用模式的流程。要让真实用户参与
    UAT，以验证新功能是否满足业务需求，才能正式发布。在 **业务单元**（**BUs**）中，找出关键用户，作为 UAT 测试人员，他们对需求和工作流程有深入了解。'
- en: Be sure to structure formal test plans and reporting to ensure thorough real-world
    validation. Ahead of the start of your UAT process, you should provide testers
    with account access, sample data, and clear test scenarios mapped to business
    use cases.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要制定正式的测试计划和报告，以确保充分的真实环境验证。在 UAT 测试过程开始之前，您应当为测试人员提供账户访问权限、样本数据和清晰的测试场景，并将其映射到业务用例。
- en: Track and triage all issues uncovered during UAT, clarifying requirements with
    users and addressing issues before proceeding to production. It should be noted
    that in many larger organizations, much of this process is done by either a business
    analyst or dedicated testing resources, rather than the architect (whose role
    is more that of overseeing the process and ensuring it is carried out).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪并分类所有在 UAT 过程中发现的问题，明确与用户的需求，并在继续生产部署之前解决这些问题。需要注意的是，在许多较大的组织中，这一过程通常由业务分析师或专门的测试人员完成，而不是架构师（架构师的角色更多是监督过程并确保其顺利进行）。
- en: Large volume testing
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大规模测试
- en: Special testing is required to confirm the Salesforce platform can handle large
    data volumes and heavy user load. Use realistically large datasets in a test org
    to validate performance and stability at scale. Load the database with maximum
    expected data sizes, and import representative sample data. Use performance testing
    tools to simulate peak numbers of concurrent users, identifying governor limits
    or bottlenecks. Optimize configuration to support caching, indexing, and scalability
    best practices. Check for degradation over time as data volumes grow, tuning and
    adding resources as needed. Modeling production-level usage through large volume
    testing helps validate that the system can support business growth.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊测试是必需的，以确认 Salesforce 平台能够处理大数据量和高用户负载。在测试环境中使用实际的大型数据集来验证性能和在大规模下的稳定性。将数据库加载到预期的最大数据大小，并导入具有代表性的样本数据。使用性能测试工具来模拟并发用户的高峰数量，识别治理限制或瓶颈。优化配置以支持缓存、索引和可扩展性最佳实践。随着数据量的增加，检查性能是否有所下降，并根据需要进行调优或增加资源。通过大规模测试模拟生产级使用情况，有助于验证系统是否能支持业务增长。
- en: In the world of Salesforce DevOps, the two most common types of testing are
    unit testing and E2E testing, but as we’ll see shortly, other important tests
    such as integration tests and regression tests should be considered as well.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Salesforce DevOps 的世界里，最常见的两种测试类型是单元测试和端到端（E2E）测试，但正如我们接下来将看到的，其他重要的测试，如集成测试和回归测试，也应该纳入考虑范围。
- en: Unit testing concentrates on verifying individual and separate functions within
    an application—these often relate to a specific individual change that you’re
    developing. It’s important to note that Salesforce enforces a minimum of 75% of
    Apex test coverage across your entire org for production deployments, and even
    more important to note is that this is not a guarantee that functionality is correct.
    A poorly written test can hide or distort actual issues, so unit testing should
    only be considered a part of your overall testing strategy. Additionally, if you
    specify a subset of specific test classes to run as part of a production deployment,
    then every Apex class being deployed needs 75%+ coverage individually rather than
    the org-wide or even deployment-package-wide average. All the more reason to aim
    for as high a percentage of coverage as possible.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试集中于验证应用程序中的各个独立功能——这些功能通常与您正在开发的具体更改相关。需要注意的是，Salesforce 强制要求在整个组织内，Apex
    测试覆盖率至少达到 75% 才能进行生产部署，更重要的是，这并不保证功能是正确的。编写不好的测试可能会掩盖或扭曲实际问题，因此单元测试只能被视为整体测试策略的一部分。此外，如果您指定了某些特定的测试类作为生产部署的一部分，那么每个被部署的
    Apex 类都需要单独达到 75% 以上的覆盖率，而不是依赖于组织级或甚至部署包级的平均覆盖率。这更加证明了需要尽可能争取更高的覆盖率百分比。
- en: Unit testing works best when you construct your application from small, testable
    units instead of monolithic Apex classes, flows, or even objects. Creating brief,
    quick unit tests that can be effortlessly executed motivates developers to include
    them in their development, regression testing, and **continuous integration**
    (**CI**) procedures. As a result, bugs are detected and resolved earlier.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在你将应用程序构建为小的、可测试的单元时效果最佳，而不是将其构建为单体的Apex类、流程，甚至是对象。创建简短、快速的单元测试，这些测试可以轻松执行，能够激励开发人员将其纳入开发、回归测试和**持续集成**（**CI**）过程中。因此，缺陷会被更早发现并解决。
- en: Apex testing
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apex测试
- en: Writing Apex code without proper testing can lead to issues, such as bugs and
    errors, which can negatively impact the user experience and ultimately harm the
    overall success of the project. This is where Apex unit testing comes in as a
    critical part of the development process that helps ensure that the code is functioning
    as intended, meets requirements, and can handle different scenarios. In this regard,
    Apex unit testing is essential for creating high-quality, robust, and maintainable
    code in Salesforce.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 编写没有适当测试的Apex代码可能会导致问题，比如缺陷和错误，这可能会负面影响用户体验，并最终损害项目的整体成功。在这方面，Apex单元测试是开发过程中至关重要的一部分，帮助确保代码按预期运行，满足要求，并能处理不同的场景。在这方面，Apex单元测试对于在Salesforce中创建高质量、强健且可维护的代码至关重要。
- en: These tests should be designed to simulate both positive and negative scenarios.
    This means the code should not only be tested to ensure that it does what it is
    supposed to, but also tested to check that it *doesn’t* do things it’s not supposed
    to. Additionally, Apex unit tests should be written to test operations in a single
    context or a bulkified context, meaning they can test either a single record or
    multiple records at once. To improve test efficiency and isolate code under test,
    mocks and stubs can be used to simulate external dependencies, such as web services
    or database operations. By writing comprehensive unit tests that cover all possible
    scenarios and using best practices such as mock testing, Salesforce developers
    can build reliable, maintainable, and scalable applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试应该设计成模拟正面和负面场景。这意味着代码不仅要测试它是否能按预期完成任务，还要测试它*不会*做它不应该做的事。此外，Apex单元测试应该编写成在单一上下文或批量上下文中进行测试，也就是说，它们可以测试单个记录或一次多个记录。为了提高测试效率并隔离被测代码，可以使用模拟和桩来模拟外部依赖，例如Web服务或数据库操作。通过编写覆盖所有可能场景的全面单元测试，并采用如模拟测试等最佳实践，Salesforce开发人员可以构建可靠、可维护和可扩展的应用程序。
- en: As mentioned earlier, Salesforce enforces a minimum of 75% of unit test coverage
    of your code, but as good architects, we should always strive to get as close
    to 100% coverage as possible. The reality is that there will be some corner cases
    that are not reachable via unit tests—by targeting 100% coverage, these fall into
    a buffer between this high standard and the required 75%, so we should never have
    insufficient coverage in a well-written set of unit tests.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Salesforce要求代码的单元测试覆盖率至少为75%，但作为优秀的架构师，我们应该始终争取尽可能接近100%的覆盖率。现实情况是，确实会有一些角落案例是无法通过单元测试触及的——通过瞄准100%的覆盖率，这些案例会落入高标准和要求的75%之间的缓冲区，因此我们在编写良好的单元测试时，永远不应该有不足的覆盖率。
- en: 'To illustrate a simple example of an Apex unit test, first, consider the following
    Apex class. It contains a static method that calculates the total price of products
    in a shopping cart. These products use a `Product__c` custom object that contains
    a `Price__c` custom field—the custom object is far simpler than the standard `Product2`
    object and associated objects for example purposes:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个简单的Apex单元测试示例，首先，考虑以下Apex类。它包含一个静态方法，用于计算购物车中产品的总价格。这些产品使用一个`Product__c`自定义对象，该对象包含一个`Price__c`自定义字段——为了示例说明，这个自定义对象比标准的`Product2`对象及其关联对象要简单得多：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An initial attempt at a corresponding unit test class that includes both single
    and bulkified tests and covers positive and negative scenarios could look like
    this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个初步尝试的对应单元测试类，包含单个测试和批量化测试，覆盖了正面和负面场景，可能看起来是这样的：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, the unit test class includes four test methods: `testSingleProduct`,
    `testMultipleProducts`, `testNullProducts`, and `testProductsWithoutPrice`. The
    first two methods test the `calculateTotal` method with different numbers of products,
    while the third and fourth methods test it with null and incomplete product data,
    respectively. The use of both single and bulkified tests ensures that the code
    can handle different scenarios and scales well. Additionally, the use of both
    positive and negative flows helps ensure that the code can handle both expected
    and unexpected input data.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，单元测试类包含四个测试方法：`testSingleProduct`、`testMultipleProducts`、`testNullProducts`
    和 `testProductsWithoutPrice`。前两个方法分别使用不同数量的产品来测试 `calculateTotal` 方法，而第三个和第四个方法则分别使用空值和不完整的产品数据来测试。使用单个和批量化测试相结合，确保代码能够处理不同的场景并良好扩展。此外，正面和负面流程的结合使用有助于确保代码能够处理预期的和意外的输入数据。
- en: Although this test class would work, many code scenarios would benefit from
    a `@testSetup` method, which creates the data used by the test. This data is rolled
    back at the end of the test.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个测试类能够正常工作，但许多代码场景将受益于一个 `@testSetup` 方法，用于创建测试中使用的数据。测试结束时，这些数据会被回滚。
- en: 'If we consider the following trigger and corresponding handler class—which
    is illustrative, not a useful real-world example—we can create a test class for
    it that makes use of the `@testSetup` annotation. The trigger, handler class,
    and its test are shown here:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑以下触发器和相应的处理程序类——这个示例是用于说明，并不是一个实际的应用案例——我们可以为它创建一个利用 `@testSetup` 注解的测试类。触发器、处理程序类及其测试在这里显示：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With this method, the `@testSetup` annotation is used to create multiple products
    that are used in the subsequent test methods. This eliminates the need to create
    duplicate product records in each test method, making the test code more efficient
    and easier to read. The first two test methods from our original test class now
    rely on the `@testSetup` method to create products and calculate the total price,
    while the remaining methods test different scenarios. The use of `@testSetup`
    helps ensure that the test data is consistent and the tests are more reliable.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，`@testSetup` 注解用于创建多个产品，这些产品在后续的测试方法中使用。这避免了在每个测试方法中重复创建产品记录，使测试代码更加高效且易于阅读。我们原始测试类中的前两个测试方法现在依赖
    `@testSetup` 方法来创建产品并计算总价格，而剩余的方法则测试不同的场景。使用 `@testSetup` 有助于确保测试数据的一致性，使得测试更可靠。
- en: We can further improve this test class by making use of the `test.startTest()`
    and `test.stopTest()` methods. These are used to separate the setup and execution
    phases of each test method and should be called immediately before and after the
    line(s) of code that specifically execute the code we wish to test. This ensures
    that the performance metrics captured by `Limits.get*()` methods and asynchronous
    operations started by the test method are isolated and not mixed with other operations
    performed before or after the test as part of preparing the test for execution.
    The use of `test.startTest()` and `test.stopTest()` also helps to avoid hitting
    governor limits during test execution, especially when testing bulk data operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `test.startTest()` 和 `test.stopTest()` 方法进一步改进这个测试类。这些方法用于分隔每个测试方法的设置阶段和执行阶段，应该在专门执行我们希望测试的代码之前和之后立即调用。这可以确保通过
    `Limits.get*()` 方法捕获的性能指标以及由测试方法启动的异步操作是独立的，不会与测试执行前后进行的其他操作混合。使用 `test.startTest()`
    和 `test.stopTest()` 也有助于避免在测试执行过程中触发治理限制，特别是在测试批量数据操作时。
- en: It’s important to be thorough and diligent in your Apex unit tests, but as we’ll
    see in the next section, this should not be the only place that you apply a commitment
    to quality. We’ll start by looking at how we can test LWCs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Apex 单元测试中，仔细和勤奋地测试是非常重要的，但正如我们将在下一部分看到的，这不应是唯一应用质量承诺的地方。我们将从测试 LWC 开始。
- en: Testing your LWCs
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的 LWC（Lightning Web Components）
- en: While Salesforce still has more than one approach for developing Lightning components,
    we’re going to focus on testing LWCs, rather than the older Aura components. Salesforce
    introduced LWCs in December 2018, with the release of Salesforce’s Spring ’19
    version. This was announced in a blog post by Salesforce on December 13, 2018,
    titled Introducing Lightning Web Components, available at [https://developer.salesforce.com/blogs/2018/12/introducing-lightning-web-components](https://developer.salesforce.com/blogs/2018/12/introducing-lightning-web-components).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Salesforce 仍然有多种方法来开发 Lightning 组件，但我们将专注于测试 LWC，而不是较旧的 Aura 组件。Salesforce
    于 2018 年 12 月发布了 LWC，并在 Salesforce Spring ’19 版本中推出。这一消息在 2018 年 12 月 13 日由 Salesforce
    发布的博客文章中宣布，标题为《Introducing Lightning Web Components》，可在 [https://developer.salesforce.com/blogs/2018/12/introducing-lightning-web-components](https://developer.salesforce.com/blogs/2018/12/introducing-lightning-web-components)
    阅读。
- en: When it comes to testing LWCs, we can take advantage of the fact that the architecture
    of this type of component is based on more common JavaScript standards and an
    open framework. This allows us to write our unit tests using the popular Jest
    testing framework ([https://jestjs.io/](https://jestjs.io/)), which is already
    used in the wider JavaScript community outside of Salesforce too. Jest is itself
    written in JavaScript and uses the Node.js engine to execute, and npm for installation
    and to manage its dependencies.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试 LWC 时，我们可以利用这种组件架构基于更常见的 JavaScript 标准和开放框架的事实。这使得我们能够使用流行的 Jest 测试框架来编写单元测试（[https://jestjs.io/](https://jestjs.io/)），该框架在
    Salesforce 之外的更广泛的 JavaScript 社区中也已经在使用。Jest 本身是用 JavaScript 编写的，使用 Node.js 引擎执行，并使用
    npm 进行安装和管理其依赖项。
- en: In the Salesforce world, there is a plugin for the SFDX command line called
    `sfdx-lwc-jest` that makes it easy to add Jest and its dependencies to your Salesforce
    projects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Salesforce 的世界里，有一个名为 `sfdx-lwc-jest` 的插件，它可以让你轻松地将 Jest 及其依赖项添加到 Salesforce
    项目中。
- en: 'If you run the following command in your project directory, it will install
    the necessary npm tools and the `@``salesforce/sfdx-lwc-jest` package:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在项目目录中运行以下命令，它将安装必要的 npm 工具和 `@salesforce/sfdx-lwc-jest` 包：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the capability to run Jest tests set up in your project, you next need
    to configure some tests for your LWCs. These tests are run locally on your development
    machine, independently of Salesforce, which makes it a lot easier to both run
    them at the development stage of your project and to include them as part of any
    test automation you add in your DevOps pipeline.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目中设置了运行 Jest 测试的能力后，你需要为 LWC 配置一些测试。这些测试在开发机器上本地运行，独立于 Salesforce，这使得在项目开发阶段运行它们更加容易，同时也便于将它们作为你在
    DevOps 流水线中添加的任何测试自动化的一部分。
- en: If you create an SFDX project using the standard template, it already has all
    these ready-to-write Jest tests. The `project.json` file is configured, as is
    `.forceignore`. This also creates a `__tests__` directory and a skeleton test
    file. However, if you have not created your project from the template, the steps
    for creating the appropriate structure are detailed next—in most cases, the template
    will take care of this for you.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用标准模板创建了一个 SFDX 项目，它已经准备好了所有这些可以编写的 Jest 测试。`project.json` 文件和 `.forceignore`
    文件已经配置好。这也会创建一个 `__tests__` 目录和一个测试文件框架。然而，如果你没有从模板创建项目，接下来的步骤将详细介绍如何创建适当的结构——在大多数情况下，模板会为你处理这些。
- en: 'Your first task should be to create a `__tests__` folder under the top-level
    folder of each component. For example, consider this example LWC folder structure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你的第一项任务应该是在每个组件的顶级文件夹下创建一个 `__tests__` 文件夹。例如，考虑这个 LWC 文件夹结构示例：
- en: '![Figure 4.1 – Example LWC folder structure without tests](img/Figure_4.1_B19436.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 没有测试的示例 LWC 文件夹结构](img/Figure_4.1_B19436.jpg)'
- en: Figure 4.1 – Example LWC folder structure without tests
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 没有测试的示例 LWC 文件夹结构
- en: 'In this example, adding the required `__tests__` folder would result in a structure
    like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，添加所需的 `__tests__` 文件夹后，结构会变成这样：
- en: '![Figure 4.2 – The same LWC folder structure, with the test folder and file
    in place](img/Figure_4.2_B19436.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 相同的 LWC 文件夹结构，包含测试文件夹和文件](img/Figure_4.2_B19436.jpg)'
- en: Figure 4.2 – The same LWC folder structure, with the test folder and file in
    place
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 相同的 LWC 文件夹结构，包含测试文件夹和文件
- en: 'You should also add a wildcarded path to the `__tests__` folder to your `.forceignore`
    file in your project since you shouldn’t deploy Jest tests to your Salesforce
    org—in fact, it will throw an error if you try to do this. Adding the following
    line to the `.forceignore` file should address this issue:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该在项目的`.forceignore`文件中添加一个通配符路径指向`__tests__`文件夹，因为您不应该将Jest测试部署到Salesforce组织中——事实上，如果您尝试这么做，系统会抛出错误。将以下行添加到`.forceignore`文件中应该能解决这个问题：
- en: '`**/``__tests__/**`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`**/``__tests__/**`'
- en: 'Next, you will need to add the following line to the `scripts` section in your
    project’s `package.json` file:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要在项目的`package.json`文件中的`script`部分添加以下行：
- en: '`"``test:unit": "sfdx-lwc-jest"`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`"``test:unit": "sfdx-lwc-jest"`'
- en: Your project is now configured for running Jest tests, and we’ll now look at
    how to construct those tests for your components.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您的项目现在已经配置好可以运行Jest测试，接下来我们将讨论如何为您的组件构建这些测试。
- en: An example Jest test
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个Jest测试示例
- en: 'Now that we have set up the prerequisites for running the Jest tests, we can
    look at a lightweight example test for our `teamComponent` component shown previously:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了运行Jest测试的前提条件，接下来可以查看之前展示的`teamComponent`组件的一个轻量级示例测试：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this test class, we import the `createElement` function from LWC to create
    an instance of the `teamComponent` component, and then we use Jest’s `describe`
    and `it` functions to define a test case that checks that the component renders
    the correct message.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试类中，我们从LWC导入`createElement`函数来创建`teamComponent`组件的实例，然后使用Jest的`describe`和`it`函数定义一个测试用例，检查组件是否正确渲染消息。
- en: The `afterEach` function is used to reset the DOM between test cases, to ensure
    that each test case starts with a clean slate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`afterEach`函数用于在测试用例之间重置DOM，以确保每个测试用例从干净的状态开始。'
- en: In the `it` function, we create an instance of the `teamComponent` component
    using `createElement`, add it to the DOM using `document.body.appendChild`, and
    then use `querySelector` to find the element that contains the message. Finally,
    we use Jest’s expect function to check that the text content of the `p` element
    is equal to *Welcome to* *the team!*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在`it`函数中，我们使用`createElement`创建`teamComponent`组件的实例，使用`document.body.appendChild`将其添加到DOM中，然后使用`querySelector`查找包含消息的元素。最后，我们使用Jest的expect函数检查`p`元素的文本内容是否等于*欢迎加入*
    *团队！*。
- en: This is just an example and your test class will likely need to be more complex
    and cover additional use cases, but this should give you an idea of how to get
    started with writing unit tests for LWCs using Jest. Salesforce Trailhead has
    more detailed examples of testing your LWCs, including those that make use of
    `@wire` services. Now that we have our Jest tests written, let’s look at how we
    run the tests against our code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个示例，您的测试类可能需要更复杂，涵盖更多的用例，但这应该能给您一个关于如何开始使用Jest为LWC编写单元测试的概念。Salesforce Trailhead有更多关于测试LWC的详细示例，包括使用`@wire`服务的示例。现在我们已经编写了Jest测试，让我们来看看如何运行这些测试来验证我们的代码。
- en: Running your Jest tests
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Jest测试
- en: 'To test an LWC in a Salesforce project using Jest, you can follow these steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Jest在Salesforce项目中测试LWC，您可以按照以下步骤操作：
- en: Navigate to the root directory of your LWC component in your terminal.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中导航到LWC组件的根目录。
- en: Run the `npm run test` command. This will execute the Jest test runner and run
    any tests in the `__tests__` directory or in the same directory as the LWCs being
    tested.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm run test`命令。这将执行Jest测试运行器并运行`__tests__`目录中的任何测试，或与正在测试的LWC在同一目录中的测试。
- en: The Jest test runner will display the results of the tests in your terminal.
    If any tests fail, the Jest runner will output detailed information about the
    test failure.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jest测试运行器将在终端中显示测试结果。如果任何测试失败，Jest运行器会输出有关测试失败的详细信息。
- en: You can also run individual tests by specifying the name of the test file or
    test suite that you want to run. For example, you can run a test named `teamComponent.test.js`
    by running the `npm run test` `teamComponent.test.js` command.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过指定要运行的测试文件或测试套件的名称来运行单个测试。例如，您可以通过运行`npm run test` `teamComponent.test.js`命令来运行名为`teamComponent.test.js`的测试。
- en: You can use additional options to customize the behavior of Jest, such as running
    tests in `watch` mode or generating code coverage reports. You can find more information
    on Jest options in the Jest documentation.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用额外的选项来定制Jest的行为，例如在`watch`模式下运行测试或生成代码覆盖率报告。您可以在Jest文档中找到更多关于Jest选项的信息。
- en: At this point, we now have a means of testing our LWCs, but that’s only part
    of the puzzle. In the next section, we’ll start exploring how to test the main
    declarative tool that Salesforce offers—flows.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了测试我们的LWC（Lightning Web Component）的方法，但这只是拼图的一部分。在接下来的部分，我们将开始探索如何测试Salesforce提供的主要声明式工具——流程。
- en: Testing your flows
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的流程
- en: Flows are another extremely common means of developing complex functionality
    in Salesforce, and while they fall into the *clicks not code* category of Salesforce
    development, it is just as important to provide them with rigorous testing as
    it is for code-based solutions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 流程是Salesforce中另一种非常常见的开发复杂功能的方式，虽然它们属于*点击而非代码*的Salesforce开发类别，但对它们进行严格的测试与基于代码的解决方案同样重要。
- en: 'In Flow Builder, you can test your flow without leaving the interface. The
    UI contains two buttons for testing your flow: Run and Debug. Let’s look at what
    they do:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在流程构建器中，你可以在不离开界面的情况下测试你的流程。UI中有两个按钮用于测试你的流程：运行和调试。我们来看看它们的作用：
- en: The Run button executes the most recently saved version of the flow that is
    currently open in the editor.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行按钮执行的是当前在编辑器中打开的、最近保存的版本的流程。
- en: The Debug button provides additional features beyond Run. In addition to running
    the flow, Debug allows you to input values for the flow’s input variables and
    view debug details during the flow’s execution. This allows you to verify how
    the flow processes data and identify any issues or errors.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试按钮提供了比运行按钮更多的功能。除了运行流程，调试按钮还允许你为流程的输入变量输入值，并在流程执行过程中查看调试细节。这使你可以验证流程是如何处理数据的，并找出任何问题或错误。
- en: Every time a flow runs in Salesforce, it initiates a flow interview. A flow
    interview is a unique instance of a flow that follows a specific path based on
    the parameters provided. These parameters can include input variables or components
    on a screen, which can lead the interview down different paths through the flow
    and trigger different actions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 每次在Salesforce中运行流程时，它都会启动一个流程访谈。流程访谈是流程的一个独特实例，根据提供的参数沿特定路径执行。这些参数可以包括输入变量或屏幕上的组件，这些都可以引导访谈沿不同路径执行流程并触发不同的动作。
- en: By creating flow interviews that cover both positive and negative scenarios,
    you can test your flow’s criteria, much like you would with Apex testing. However,
    breaking a flow into smaller tests may be challenging, as a flow interview tests
    the entire flow rather than just one decision at a time. You may need to create
    multiple flow interviews to cover all possible paths through the flow.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建覆盖正面和负面场景的流程访谈，你可以像Apex测试一样测试流程的条件。然而，将一个流程拆分成更小的测试可能具有挑战性，因为一个流程访谈测试的是整个流程，而不仅仅是一次决策。你可能需要创建多个流程访谈来覆盖流程中的所有可能路径。
- en: To simplify testing and ensure comprehensive coverage, it may be beneficial
    to break up the flow into subflows where possible. This architectural approach
    can help create more manageable and efficient tests for your flow.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化测试并确保全面覆盖，将流程拆分成子流程可能是有益的。这个架构方法有助于创建更易于管理和高效的测试。
- en: 'As of the Summer ’22 Salesforce release, it is possible to convert these flow
    interviews into flow tests. After successfully executing a flow interview in the
    flow debugger in Salesforce, you will see a **Convert to Test** action appear
    in the top-right corner of the page, next to **Edit Flow**. To convert the debug
    run to a flow test, click on **Convert to Test**, and a new test screen will appear
    in a modal window. You can create up to 200 tests per flow, so it should be possible
    to create a test for every path your flow can take:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从Summer ’22 Salesforce版本开始，您可以将这些流程访谈转换为流程测试。在Salesforce的流程调试器中成功执行流程访谈后，页面右上角会出现一个**转换为测试**操作，紧挨着**编辑流程**。要将调试运行转换为流程测试，请点击**转换为测试**，然后会在弹出窗口中出现一个新的测试界面。每个流程最多可以创建200个测试，因此应该能够为流程的每个路径创建测试：
- en: '![Figure 4.3 – Creating a new flow test](img/Figure_4.3_B19436.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – 创建新的流程测试](img/Figure_4.3_B19436.jpg)'
- en: Figure 4.3 – Creating a new flow test
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 – 创建新的流程测试
- en: 'During testing of a flow in Salesforce, each assertion is evaluated to confirm
    that the flow behaves as intended, as illustrated in the following screenshot.
    However, it’s important to note that a test can only verify whether a flow element
    was executed and whether the flow resource values were correctly set:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Salesforce中测试流程时，每个断言都会被评估，以确认流程是否按预期行为执行，如下图所示。然而，值得注意的是，测试只能验证流程元素是否执行，以及流程资源值是否正确设置：
- en: '![Figure 4.4 – Providing assertions for our new test, to validate our flow](img/Figure_4.4_B19436.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 为我们的新测试提供断言，以验证我们的流](img/Figure_4.4_B19436.jpg)'
- en: Figure 4.4 – Providing assertions for our new test, to validate our flow
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 为我们的新测试提供断言，以验证我们的流。
- en: 'At the time of writing, there are some important considerations around flow
    tests that an architect should consider when assessing them as part of an overall
    DevOps design:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，架构师在评估流测试作为整体DevOps设计的一部分时应考虑以下一些重要事项：
- en: Flow tests are available only for record-triggered flows
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流测试仅适用于记录触发的流。
- en: Flow tests don’t support flows that run when a record is deleted
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流测试不支持当记录被删除时运行的流。
- en: Flow tests don’t support flow paths that run asynchronously
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流测试不支持异步运行的流路径。
- en: Flow tests cannot be automatically triggered as part of a deployment
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流测试无法作为部署的一部分自动触发。
- en: Flow tests can be based upon specific record IDs, but this can make the tests
    fragile since record IDs are not guaranteed to exist in other environments
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流测试可以基于特定的记录ID，但这可能使测试变得脆弱，因为记录ID在其他环境中并不保证存在。
- en: Flow tests don’t count toward flow test coverage requirements
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流测试不计入流测试覆盖率要求。
- en: This last point is of particular note because if you want to be able to deploy
    flows as **Active**, they need to have test coverage in just the same way that
    Apex code requires coverage (and at the same minimum level of 75%)
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一点尤其值得注意，因为如果你希望能够将流部署为**活动**，它们需要像Apex代码一样有测试覆盖（并且测试覆盖的最低标准为75%）。
- en: The process for this is less mature than that for code, but as a guide, for
    active processes and autolaunched flows, there is a requirement that at least
    one Apex test must achieve the required test coverage percentage of the flow tests.
    However, it’s important to note that flow test coverage requirements do not apply
    to flows that include screens.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这一过程不如代码那样成熟，但作为参考，对于活动流程和自动启动流，至少一个Apex测试必须达到流测试所需的测试覆盖率百分比。然而，值得注意的是，流测试覆盖率要求不适用于包含屏幕的流。
- en: The lack of maturity in flow testing is largely around the absence of consistency
    between the flow tests that you can generate in the Flow Builder UI versus the
    tests required for coverage. Not only do these tests need to be written in code
    as Apex unit tests, but to see the current state of code coverage for the flows
    in your org, you need to query the `FlowTestCoverage` object—for example, from
    the Developer Console.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 流测试的不成熟主要体现在流测试在Flow Builder UI中生成的测试与覆盖范围所需的测试之间缺乏一致性。这些测试不仅需要以Apex单元测试的形式编写代码，而且要查看你组织中流的当前代码覆盖率，还需要查询`FlowTestCoverage`对象——例如，从开发者控制台中查询。
- en: To determine the test coverage of your flows in Salesforce, you need to consider
    all active versions, regardless of whether they have test coverage or not, and
    all inactive versions that are the latest versions and have test coverage. Here
    are example queries for this purpose—to run them, you will need to ensure the
    **Use Tooling API** box is checked in the Developer Console.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定Salesforce中流的测试覆盖率，你需要考虑所有活动版本，无论它们是否有测试覆盖，以及所有最新版本且具有测试覆盖的非活动版本。以下是为此目的提供的示例查询——要运行这些查询，你需要确保在开发者控制台中选中**使用工具API**框。
- en: 'First, you need to determine the number of flows (the latest versions of each)
    that have test coverage, like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要确定具有测试覆盖的流的数量（每个流的最新版本），如下所示：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, get the number of all active versions of flows—with or without test coverage—plus
    the inactive versions that are the latest versions that have test coverage:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，获取所有活动版本的流的数量——无论是否有测试覆盖——以及那些是具有测试覆盖的最新版本的非活动版本：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To determine the test coverage percentage for your Salesforce flows, divide
    the count of the most recent flow versions with test coverage (second script)
    by the overall sum of active and inactive versions that possess test coverage,
    incorporating those lacking test coverage as well (initial script). If all this
    sounds unnecessarily complicated, you’d be right, and we can only hope that this
    area improves with subsequent Salesforce releases.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定Salesforce流的测试覆盖率百分比，将具有测试覆盖的最新版本流的数量（第二个脚本）除以所有活动和非活动版本中具有测试覆盖的总和，同时包括那些没有测试覆盖的版本（初始脚本）。如果这一切听起来过于复杂，你是对的，我们只能希望随着Salesforce版本的更新，这一领域能够得到改进。
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the reasons why testing your changes is a core
    principle of Salesforce DevOps. We also dove into some example tests, showing
    the differences in how they are constructed, depending on the approach you used
    to implement your Salesforce functionality—Apex code, LWC, or flows.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了为什么测试变更是Salesforce DevOps的核心原则。我们还深入分析了一些示例测试，展示了根据你实施Salesforce功能的不同方法——Apex代码、LWC或流程——它们在构建上的差异。
- en: Now that we’ve looked at some of the building blocks of architecting a Salesforce
    DevOps process—culture, version control, and robust testing—in the next chapter,
    we’ll start to look at how we bring these elements together by looking at some
    example workflows and scenarios of day-to-day delivery using the SFDX tool and
    Git. While these tools are one of many approaches to Salesforce DevOps, you’ll
    benefit from seeing some of the principles we’ve discussed as real-world examples,
    which will bring a typical workflow to life.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了构建Salesforce DevOps流程的一些基础要素——文化、版本控制和强大的测试——在下一章中，我们将开始探讨如何通过一些示例工作流和日常交付场景，结合这些元素，使用SFDX工具和Git来实现这一目标。虽然这些工具只是Salesforce
    DevOps的众多方法之一，但通过将我们讨论的一些原则展示为现实世界的例子，你将能看到一个典型的工作流如何运作。
