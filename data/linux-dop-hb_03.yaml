- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Intermediate Linux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中级 Linux
- en: In this chapter, we’re going to continue with the introduction to the Linux
    shell. The topic itself is vast and warrants a book of its own. We will be coming
    back to the topics from the previous chapter and introducing new ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续介绍 Linux shell。本话题非常广泛，足以写成一本独立的书。我们将回顾上一章的内容并介绍新的主题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Globs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符
- en: Automating repetitive tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化重复任务
- en: Software installation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件安装
- en: Managing users
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理
- en: '**Secure Shell** (**SSH**) protocol'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全外壳**（**SSH**）协议'
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: It is highly recommended that you have a Linux system installed and ready for
    use. We recommend it be a virtual machine or a laptop that you can safely reinstall
    from scratch in case something goes horribly wrong. This will let you follow the
    examples in this book and perform any kind of exercise that we give you.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议你安装并准备好使用 Linux 系统。我们建议使用虚拟机或笔记本电脑，这样如果出了什么大问题，可以安全地重新安装。这将让你能够跟随本书的示例并完成我们给出的任何练习。
- en: We are not going to cover an installation. Every distribution may use its own
    installer, be it graphical or text (depending on the distribution and which variant
    you’ve picked). You’ll need to note down or remember the name of your user (conveniently
    called **username** or **login**) and password. There are ways to get into the
    system if you have physical access and you don’t know either the login or password
    or both, but they are way outside the scope of this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会讲解安装过程。每个发行版可能会使用不同的安装程序，无论是图形界面还是文本界面（具体取决于发行版及所选变种）。你需要记下或记住你的用户名称（方便地称为**用户名**或**登录名**）和密码。如果你有物理访问权限，但不知道登录名或密码，甚至两者都不知道，还是有方法可以进入系统，但这些方法远超本书的范围。
- en: Our main distribution in this book is **Debian**. However, you should be okay
    with any of the major ones we covered in the previous chapter, so long as it isn’t
    Alpine.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的主要发行版是**Debian**。不过，你应该可以使用上一章中介绍的任何主要发行版，只要它不是 Alpine。
- en: Globs
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通配符
- en: There is a lot that a shell can do for you to make your life easier. One of
    them is allowing for a level of *uncertainty* when typing in arguments on the
    shell. To that end, the shell defines several special characters that are treated
    like symbols for something, not like literal input. These are called **global
    patterns**, or **globs**. The characters that are used in globs are sometimes
    referred to as **wildcards**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 能为你做很多事情，帮助你简化工作。其中之一就是允许在输入命令参数时存在一定的*不确定性*。为此，shell 定义了几个特殊字符，将它们作为符号使用，而不是字面输入。这些符号称为**全局模式**，或称为**通配符**。在通配符中使用的字符有时被称为**通配符**（wildcards）。
- en: Do not confuse globs with **regular expressions** (**regexps**). While globs
    are quite a powerful tool on their own, they are no match for regexps. On the
    other hand, regexps are not evaluated by bash when it performs pattern matching.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将通配符与**正则表达式**（**regexps**）混淆。虽然通配符本身非常强大，但它们无法与正则表达式相比。另一方面，bash 在执行模式匹配时并不会对正则表达式进行求值。
- en: 'The following table describes shell globs and their meaning. We’re going to
    explain their exact meaning through several examples:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下表描述了 Shell 通配符及其含义。我们将通过几个示例来解释它们的确切含义：
- en: '| **Glob** | **Meaning** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **通配符** | **含义** |'
- en: '| `*` | Matches any number of any characters (also zero) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 匹配任意数量的字符（包括零个字符） |'
- en: '| `?` | Matches exactly one character |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 精确匹配一个字符 |'
- en: '| `[...]` | Matches any one character from a set inside the brackets |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `[...]` | 匹配括号内集合中的任意一个字符 |'
- en: Table 3.1 – Shell globs
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – Shell 通配符
- en: 'The preceding table may be unclear to you, so let’s cover some examples:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上表可能对你来说不够清晰，下面我们将通过一些示例来进一步说明：
- en: '| **Example** | **Meaning** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **示例** | **含义** |'
- en: '| `*` | This will match any string of any length. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 这将匹配任意长度的任何字符串。 |'
- en: '| `*``test*` | This will match anything that has the word *test* inside it:
    `test.txt`, `good_test.txt`, `test_run`, and simply `test` (remember, it matches
    nothing too). |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `*``test*` | 这将匹配任何包含*test*的字符串：`test.txt`、`good_test.txt`、`test_run`，甚至是简单的`test`（记住，它也可以匹配空字符串）。
    |'
- en: '| `test*txt` | This will match anything that has a name starting with *test*
    and ending in *txt*, so `test.txt`, `testtxt`, `test_file.txt`, and so on. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `test*txt` | 这将匹配任何名称以*test*开头，*txt*结尾的文件，例如 `test.txt`、`testtxt`、`test_file.txt`
    等。 |'
- en: '| `test?` | This will match any occurrence of *test* plus one character: `test1`,
    `test2`, `testa`, `test`, and so on. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `test?` | 这将匹配任何一个包含*test*并加上一个字符的情况：`test1`、`test2`、`testa`、`test`，等等。 |'
- en: '| `test.[ch]` | This will match one of two things: `test.c` or `test.h` and
    nothing else. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `test.[ch]` | 这将匹配两种情况中的一种：`test.c` 或 `test.h`，其他情况不匹配。 |'
- en: '| `*.[``ab]` | This will match any string that ends in a dot and either *a*
    or *b.* |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `*.[``ab]` | 这将匹配任何以点号结束并且后面跟着 *a* 或 *b* 的字符串。 |'
- en: '| `?[``tf]` | This will match exactly one character of any kind followed by
    either *t* or *f.* |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `?[``tf]` | 这将匹配任何一种字符，后跟 *t* 或 *f*。 |'
- en: Table 3.2 – Shell globs – examples
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 – Shell 通配符 – 示例
- en: The true power of globs emerges once you start writing some more complicated
    strings of commands (so-called one-liners) or scripts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符的真正威力在于你开始编写一些更复杂的命令字符串（所谓的单行命令）或脚本时才能显现。
- en: 'Some examples of simple commands that get on an entirely new level when combined
    with globs are `find`, `grep`, and `rm`. In the following example, I am using
    globs to remove all files that start with anything, then have test followed by
    a dot, and then log followed by anything. So, the `weirdtest.log`, `anothertest.log1`,
    and `test.log.3` files will be matched, but not `testlog` and `important_test.out`.
    First, let’s list all the files that contain the word *test* in their name:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单命令在与通配符结合使用时会达到全新的层次，像是 `find`、`grep` 和 `rm`。在以下示例中，我使用通配符删除所有以任意字符开始、接着是
    test 和一个点，然后是 log 和任意字符结尾的文件。因此，`weirdtest.log`、`anothertest.log1` 和 `test.log.3`
    文件会被匹配，但 `testlog` 和 `important_test.out` 则不会。首先，让我们列出所有包含 *test* 字样的文件：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You will notice that I have used a wildcard (`*`) to achieve my goal. Now,
    it’s time for the actual removal:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，我使用了通配符（`*`）来实现我的目标。现在，是时候进行实际的删除操作了：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As demonstrated here, it worked. You will also notice that a properly executed
    command doesn’t print any messages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这里演示的那样，它已经成功执行了。你还会注意到，一个正确执行的命令不会打印任何消息。
- en: In this section, we explained how to use globs – special characters that allow
    us to match names in the system with some level of uncertainty. In the next section,
    we are going to introduce mechanisms to automate repetitive tasks.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们解释了如何使用通配符（globs）——这些特殊字符允许我们以一定的不确定性匹配系统中的名称。在下一节中，我们将介绍自动化重复任务的机制。
- en: Automating repetitive tasks
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化重复任务
- en: There are times when you’ll want to make some tasks repetitive. You may write
    a script that will create a backup of a database, check users’ home directory
    permissions, or dump current operating system preformance metrics into a file.
    Modern Linux distributions provide you with two ways of setting these up. There
    is a third method that allows you to run a task once, at a delayed time (the `at`
    command), but here, we’re interested in repetitive tasks.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望使某些任务变得重复。你可能会编写一个脚本来备份数据库、检查用户的主目录权限，或者将当前操作系统的性能指标转储到文件中。现代的 Linux
    发行版提供了两种设置这些任务的方法。还有第三种方法允许你在延迟的时间一次性运行任务（`at` 命令），但在这里我们关注的是重复性任务。
- en: Cron jobs
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cron 作业
- en: '**Cron** is a traditional way of running tasks that need to be executed regularly
    at specified intervals. Usually, they should be obsolete by **systemd timers**,
    but a lot of software provides repeatability through the use of cron jobs and
    Alpine Linux won’t have this in the name of the minimal-sized distribution.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cron** 是一种传统的方式，用来定期执行需要在特定时间间隔内运行的任务。通常，它们应该被 **systemd 定时器** 取代，但许多软件仍通过
    cron 作业提供可重复性，而 Alpine Linux 在最小化发行版的情况下不会包含这一特性。'
- en: 'Cron jobs are essentially commands that are run at predefined intervals. The
    command and their trigger timers are defined in configuration files that live
    in the `/etc/` directory. The exact number of files and directories differ by
    distribution. All of them will have a `/etc/crontab` file. This file usually contains
    an explanation of the fields within it and several actual commands that you can
    use as templates. In the following code block, I have pasted explanations from
    the default `/``etc/crontab` file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Cron 作业本质上是定期执行的命令。这些命令及其触发定时器被定义在位于 `/etc/` 目录中的配置文件中。不同的发行版会有不同数量的文件和目录。所有的发行版都会包含一个
    `/etc/crontab` 文件。这个文件通常包含对其中字段的解释以及几个实际命令，可以作为模板使用。在以下的代码块中，我粘贴了来自默认 `/etc/crontab`
    文件的解释：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Normally, there are two ways to set up a cron job. One of them is to put a
    script that will run your command in one of four directories: `/etc/cron.hourly`,
    `/etc/cron.daily`, `/etc/cron.weekly`, or `/etc/cron.monthly`. They should suffice
    for normal operations. The `/etc/crontab` file specifies when those will be run.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，有两种方法来设置 cron 任务。其一是将一个运行命令的脚本放置在四个目录中的一个：`/etc/cron.hourly`、`/etc/cron.daily`、`/etc/cron.weekly`
    或 `/etc/cron.monthly`。这些目录应该足以满足日常操作。`/etc/crontab` 文件指定了这些任务何时运行。
- en: 'The second option is to use the `crontab` command. The `crontab` command lets
    a given user create an entry in their crontab file. However, there’s a difference
    between a system-wide crontab file (living in the `/etc/` directory) and a per-user
    one. The user cron file doesn’t specify the user field. All entries are run with
    the user’s permission. Let’s look at the differences:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项是使用 `crontab` 命令。`crontab` 命令允许给定的用户在其 crontab 文件中创建一个条目。然而，系统范围的 crontab
    文件（位于 `/etc/` 目录中）和每个用户的 crontab 文件之间是有区别的。用户的 cron 文件不指定用户字段。所有条目都以用户的权限运行。我们来看看这些区别：
- en: '`crontab -l` lists all cron jobs that the user has defined in their crontab
    file'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crontab -l` 列出用户在其 crontab 文件中定义的所有 cron 任务。'
- en: '`crontab -e` lets the user edit the crontab file to add, remove, or modify
    the jobs'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`crontab -e` 让用户编辑 crontab 文件，添加、删除或修改任务。'
- en: Systemd timer
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Systemd 定时器
- en: We are not going to cover **systemd timers** here in detail and will only mention
    why they may be a better option.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细介绍 **systemd 定时器**，只会简要提到它们为何可能是更好的选择。
- en: '**Systemd timer** units are newer versions of **cron daemon** jobs. They can
    do everything that cron can. However, they offer some additional capabilities:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**Systemd 定时器** 单元是 **cron 守护进程** 任务的更新版本。它们可以完成 cron 的所有功能。然而，它们提供了一些额外的能力：'
- en: You can specify the job to run at some time after a system boots.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以指定任务在系统启动后某个时间运行。
- en: You can specify that the job has to run at some interval after some other job
    has run.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以指定任务必须在其他任务运行后的某个间隔内执行。
- en: The dependency on the timer unit can even be a service unit – the normal system
    service task.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对定时器单元的依赖甚至可以是服务单元——即普通的系统服务任务。
- en: The granularity is much better. Cron jobs only go down to every minute. Systemd
    timers can trigger with accuracy defined to a second.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精度更高。Cron 任务的精度通常只能到每分钟一次，而 Systemd 定时器的触发精度可以达到秒级。
- en: In this section, we have covered cron jobs and mentioned systemd timers as the
    two most important ways to automate tasks that have to occur regularly. In the
    next section, we are going to introduce managing software.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 cron 任务，并提到 systemd 定时器是自动化定期任务的两个最重要的方式。下一节中，我们将介绍软件管理。
- en: Software installation
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件安装
- en: Depending on which distribution you’ve chosen and the type of installation you’ve
    decided on, your system may lack software that’s essential for your everyday work.
    It may also be that you one day require a piece of software that isn’t installed
    by default.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您选择的发行版和安装方式，您的系统可能缺少一些日常工作所需的软件。也可能有一天，您需要安装一款默认未安装的软件。
- en: Linux distributions pioneered something that other operating systems mirrored
    later on. The common way of installing software on the Linux operating system
    is by running an appropriate command that will fetch a binary, put it properly
    on the system, add some configuration if required, and make it available to users.
    Today, this may not sound revolutionary at all. After all, we’re living in a world
    of Apple App Store, Google Play, and Microsoft Apps. But back in the day when
    Windows and macOS users had to navigate the internet to find a suitable installer
    for their software, Linux users could install most of it with a single command.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 发行版在一些方面领先于其他操作系统，后来其他操作系统才开始效仿。Linux 操作系统上安装软件的常见方式是运行一个合适的命令，这个命令会下载一个二进制文件，正确地将其放置到系统中，必要时添加一些配置，并使其对用户可用。今天，这可能听起来并不算革命性。毕竟，我们生活在一个拥有
    Apple App Store、Google Play 和 Microsoft Apps 的世界中。但是，在过去，当 Windows 和 macOS 用户需要在互联网上找到合适的软件安装程序时，Linux
    用户只需一个命令就能安装大多数软件。
- en: 'This is important in the automated environments that DevOps would strive to
    set up for several reasons:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点在 DevOps 力图建立的自动化环境中至关重要，原因有多个：
- en: The installable software (distributed in packages) is held in repositories maintained
    by the distribution team. This means that you don’t need to know the software’s
    location on the internet; you just need to know its package name and ensure it’s
    in the repository.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可安装的软件（以软件包形式分发）存储在发行版团队维护的仓库中。这意味着你不需要知道软件在互联网上的位置；你只需要知道它的包名，并确保它在仓库中。
- en: The package standards that we’ll cover here (`rpm` and `deb`) *know* dependencies.
    This means that if the software you’re trying to install depends on another not-yet-installed
    software, it will automatically get pulled and installed.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在这里介绍的包管理标准（`rpm` 和 `deb`）*了解*依赖关系。这意味着，如果你尝试安装的软件依赖于另一个尚未安装的软件，它会自动拉取并安装。
- en: The distributions that we’ll cover here have security teams. They work with
    package maintainers to keep them patched against any known vulnerabilities. However,
    this does not mean that they will actively research vulnerabilities in said packages.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在这里介绍的发行版都有安全团队。它们与包维护者合作，确保修复已知的漏洞。然而，这并不意味着他们会主动研究这些包中的漏洞。
- en: The repositories are mirrored over the internet. This means that even if one
    of them fails (goes offline or is DDoS-ed or for any other reason), you can reach
    its mirror copies from all over the world. This is not necessarily true for commercial
    repositories.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库会在互联网上进行镜像。这意味着，即使其中一个仓库出现故障（下线、被 DDoS 攻击或其他原因），你仍然可以从全球各地访问它的镜像副本。这对于商业仓库未必适用。
- en: You can create a local repository mirror in your LAN if you wish. This will
    give you the fastest download times at the cost of a lot of hard drive space.
    Package repositories can be huge.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你愿意，可以在本地局域网中创建一个本地仓库镜像。这将为你提供最快的下载速度，但代价是大量的硬盘空间。软件包仓库可能非常庞大。
- en: 'The amount and versions of the software depend on the distribution in many
    ways:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 软件的数量和版本在许多方面取决于发行版：
- en: '**The policy distribution has to distribute software with different types of
    licenses**: Some distributions will forbid any software that isn’t strictly open
    and free as defined by the Open Source Initiative. Other distributions will give
    the user a choice of adding repositories that may contain software that is more
    restrictive in its licensing.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**政策分发必须分发具有不同许可证类型的软件**：有些发行版会禁止任何不完全开放和免费的软件（根据开源倡议定义）。其他发行版则会让用户选择是否添加包含更严格许可的软件的仓库。'
- en: '**The number of maintainers and maintainership models**: It is quite obvious
    that distributions can only do as much work as they have man hours to spare. The
    smaller the team, the less software they can package and maintain. Part of the
    work is automated, but a lot will always need to be manual. With Debian being
    a non-commercial distribution, it relies solely on the work of volunteers. Ubuntu
    and Fedora do have commercial backing and part of the team is even employed by
    one of the companies: Canonical and Red Hat. **Red Hat Enterprise Linux** (**RHEL**)
    is entirely built and maintained by Red Hat employees.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护者数量和维护模式**：显而易见，发行版能做的工作量取决于他们拥有多少人力资源。团队越小，能够打包和维护的软件就越少。部分工作是自动化的，但很多工作始终需要人工完成。由于
    Debian 是一个非商业发行版，它完全依赖志愿者的工作。而 Ubuntu 和 Fedora 则有商业支持，部分团队成员甚至是由其中的公司雇佣的：Canonical
    和 Red Hat。**红帽企业 Linux**（**RHEL**）完全由红帽员工构建和维护。'
- en: '**The type of repositories you decide to use**: Some software makers distribute
    their packages in separate repositories, after which you can add them to your
    configuration and use them as if they were regular distribution repositories.
    However, if you do so, there are some things to keep in mind:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你决定使用的仓库类型**：一些软件厂商将它们的软件包分发在独立的仓库中，你可以将其添加到你的配置中，像使用普通的发行版仓库一样使用它们。不过，如果你这样做了，有些事情需要注意：'
- en: '**The software in the third-party repository is not part of the quality effort
    made by the distribution**: This is solely at the discretion of the repository
    maintainer – in this case, the software vendor. This will include security fixes.'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方仓库中的软件不属于发行版的质量管理工作**：这完全取决于仓库维护者——在这种情况下，就是软件供应商。这也包括安全修复。'
- en: '**The software in the third-party repository may not be updated at the same
    time as the core distribution repositories**: This means that sometimes, there
    will be conflicts in package versions required by the software and delivered by
    the distribution. Moreover, the probability of conflict rises with the number
    of third-party repositories you add to your server.'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方仓库中的软件可能不会与核心发行版仓库同时更新**：这意味着有时软件所需的包版本与发行版提供的包版本之间会存在冲突。而且，随着你向服务器添加更多第三方仓库，发生冲突的概率也会增加。'
- en: Debian and Ubuntu
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Debian 和 Ubuntu
- en: The Debian distribution and its derivative, Ubuntu, use the `DEB` package format.
    It was created solely for Debian. We won’t be going into its history here, and
    we will only touch on technical details as required.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Debian 发行版及其衍生版 Ubuntu 使用 `DEB` 包格式。它是专为 Debian 创建的。我们这里不会深入探讨其历史，只会根据需要触及一些技术细节。
- en: 'The command that works directly with package files is `dpkg`. It is used to
    install, remove, configure, and, importantly, build `.deb` packages. It can only
    install packages that exist on the filesystem and doesn’t understand remote repositories.
    Let’s look at some of the possible actions for `dpkg`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 直接操作包文件的命令是 `dpkg`。它用于安装、移除、配置，并且重要的是，构建 `.deb` 包。它只能安装存在于文件系统上的包，并且不理解远程仓库。让我们看看
    `dpkg` 的一些可能操作：
- en: '`dpkg -i package_file.deb`: Installs the package file. This command will go
    through several stages, after which it will install the software.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dpkg -i package_file.deb`：安装包文件。该命令会经过多个阶段，之后安装该软件。'
- en: '`dpkg –unpack package_file.deb`: Unpacking means it puts all important files
    in their respective places but does not configure the package.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dpkg –unpack package_file.deb`：解包意味着它会将所有重要文件放入相应的位置，但不会配置包。'
- en: '`dpkg –configure package`: Note that this requires the package name, not the
    package filename. If, for some reason, packages have been unpacked but not configured,
    you can use the `-a` or `–pending` flag to work on them.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dpkg –configure package`：请注意，这里需要的是包名，而不是包文件名。如果因为某些原因包已解包但未配置，你可以使用 `-a`
    或 `–pending` 标志来处理它们。'
- en: '`dpkg -r package`: This action removes the software but does not delete configuration
    files and eventual data it will contain. This can be useful if you plan to reinstall
    the software in the future.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dpkg -r package`：此操作会移除软件，但不会删除配置文件及其可能包含的数据。如果你打算将来重新安装该软件，这可能会很有用。'
- en: '`dpkg -p package`: This action purges the package and removes everything: software,
    data, configuration files, and caches. Everything.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dpkg -p package`：此操作会清除该包并移除一切：软件、数据、配置文件和缓存。一切。'
- en: 'In the following example, we’re installing a nano-editor from a package that
    was physically downloaded to the system, possibly by clicking a download button
    on a web page. Note that this is not a very usual way of doing things:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们正在从一个物理下载到系统的包中安装 nano 编辑器，这个包可能是通过点击网页上的下载按钮获得的。请注意，这并不是一种常见的做法：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'More often than not, you’ll need to install and remove software using the `apt`
    suite of tools:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会需要使用 `apt` 工具集来安装和移除软件：
- en: '`apt-cache search NAME` will search for a package that contains the given string.
    In the following example, I’m looking for a package that contains the `vim` string
    (vim is one of several popular command-line text editors). The output has been
    shortened by me for brevity:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-cache search NAME` 将搜索包含给定字符串的软件包。在以下示例中，我正在寻找一个包含 `vim` 字符串的软件包（vim 是几个流行的命令行文本编辑器之一）。为了简洁，我已将输出进行了缩短：'
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`apt-get install NAME` will install the package whose name you specify. You
    can install several packages in one line. In the following example, I am installing
    a C compiler, a C++ compiler, and a Go language suite. Note that the output also
    contains a list of packages that are required for my desired software to work
    and that they will be installed to provide that functionality:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-get install NAME` 将安装你指定名称的包。你可以在一行中安装多个软件包。在以下示例中，我正在安装一个C编译器、一个C++编译器和一个Go语言套件。请注意，输出中还包含了一些为了确保我的软件正常工作而需要的依赖包，并且它们将会被安装以提供该功能：'
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The installer stops here and waits for our input. The default action is to
    accept all the additional packages and follow the installation. By typing in `n`
    or `N` and pressing *Enter*, we can stop the process. The `-y` switch for the
    install action will skip that question and automatically proceed to the next step:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 安装程序在这里停止并等待我们的输入。默认操作是接受所有附加包并继续安装。通过输入 `n` 或 `N` 并按下 *Enter*，我们可以停止这个过程。安装操作的
    `-y` 开关将跳过这个问题，并自动继续到下一步：
- en: '`apt-get update` will refresh the package database with new available packages
    and new versions.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-get update` 将刷新包数据库，获取新的可用包和新版本。'
- en: '`apt-get upgrade` will upgrade all installed packages to the newest versions
    listed in the database.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-get upgrade` 将所有已安装的包升级到数据库中列出的最新版本。'
- en: '`apt-get remove NAME` will remove the package of the given name. In the following
    example, we are uninstalling the C++ compiler:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apt-get remove NAME` 将删除给定名称的包。在以下示例中，我们正在卸载 C++ 编译器：'
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: CentOS, RHEL, and Fedora
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CentOS、RHEL 和 Fedora
- en: The other popular group of distributions uses the `RPM` package format. The
    basic tool to interact with packages is `rpm`. The main distribution that uses
    this format is RHEL, which is made by the Red Hat company. The packages always
    have the `.rpm` file extension.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类流行的发行版使用 `RPM` 包格式。与包交互的基本工具是 `rpm`。使用这种格式的主要发行版是由 Red Hat 公司制作的 RHEL。包的文件扩展名始终是
    `.rpm`。
- en: 'They use the `dnf` command to manage packages. There is also the `yum` command,
    which is the original package manager for the RHEL distribution (and, by extension,
    the Fedora and CentOS distributions), but it has been removed. `dnf` is a next-generation
    rewrite of `yum`, with many improvements underneath to make it more robust and
    modern:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它们使用 `dnf` 命令来管理包。还有 `yum` 命令，它是 RHEL 发行版的原始包管理器（并且，扩展到 Fedora 和 CentOS 发行版），但已被移除。`dnf`
    是 `yum` 的下一代重写，具有许多改进，使其更强大、更现代：
- en: '`dnf install package_name` will install a package of a given name, along with
    its dependencies.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dnf install package_name` 将安装给定名称的包及其依赖项。'
- en: '`dnf remove package_name` will remove the package.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dnf remove package_name` 将删除包。'
- en: '`dnf update` will update all packages to the latest versions in the package
    database. You can specify a package name, after which `yum` will update that package.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dnf update` 将所有包更新到包数据库中的最新版本。你可以指定包名，之后 `yum` 将更新该包。'
- en: '`dnf search NAME` will search for package names containing the `NAME` string.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dnf search NAME` 将搜索包含 `NAME` 字符串的包名。'
- en: '`dnf check-update` will refresh the package database.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dnf check-update` 将刷新包数据库。'
- en: With that, let’s take a look at another Linux distribution that is widely used,
    especially as a base for Docker images – Alpine Linux.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看另一款广泛使用的 Linux 发行版，特别是作为 Docker 镜像的基础——Alpine Linux。
- en: Alpine Linux
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Alpine Linux
- en: Alpine Linux is loved especially by engineers working mainly with Docker and
    Kubernetes. As the main web page of the distribution claims, **Small. Simple.
    Secure.** There are no bells and whistles you can find in Debian-based or Red
    Hat-based distributions, but the output Docker image is really small and due to
    their focus on security, you can presume there are no major security vulnerabilities
    if you’ve updated all packages to the recent version.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine Linux 尤其受到主要使用 Docker 和 Kubernetes 的工程师喜爱。正如该发行版的主页所宣称，**小巧、简单、安全**。它没有像基于
    Debian 或 Red Hat 的发行版中那样的花里胡哨，但输出的 Docker 镜像非常小，而且由于它专注于安全，你可以假设如果你已经将所有包更新到最新版本，那么没有重大安全漏洞。
- en: Alpine Linux’s main downside (and an upside, depending on your viewpoint) is
    that it’s compiled with the use of the `musl` libraries instead of the widely
    spread `libc` libraries, although it does use the `libc`, so you will need to
    carry out extra steps to ensure you have your compile-time dependencies installed
    before installing any Python dependencies.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine Linux 的主要缺点（也可以说是优点，视角不同而定）是它使用 `musl` 库而非广泛使用的 `libc` 库进行编译，尽管它确实使用了
    `libc`，因此在安装任何 Python 依赖之前，你需要执行额外的步骤，确保已安装编译时依赖。
- en: The command to interact with packages is `3.16`) and edge, which is a rolling
    release (it always has the latest available version of packages).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与包交互的命令是 `3.16`）和 edge，这是一个滚动更新版本（它始终拥有最新版本的包）。
- en: 'Additionally, there are three repositories you can use to install packages:
    `main`, `community`, and `testing`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有三个仓库可以用来安装包：`main`、`community` 和 `testing`。
- en: You will find officially supported packages in the main repository; all tested
    packages are placed inside the community repository, and testing is used, well,
    for testing, which means that there can be some broken or outdated packages or
    some with security flaws.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你将会在主仓库中找到官方支持的包；所有经过测试的包都放在社区仓库中，而测试版则用于测试，这意味着可能存在一些损坏、过时或带有安全漏洞的包。
- en: Searching for packages
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索包
- en: 'Before searching for or installing any package, it’s advisable to download
    the latest package cache. You can do this by invoking the `apk` `update` command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索或安装任何包之前，建议先下载最新的包缓存。你可以通过调用`apk`的`update`命令来实现：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you’re building a Docker image for later use, it’s a good idea to remove
    this cache on the final step of the build process using the `apk cache` `clean`
    command.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在构建一个用于以后使用的 Docker 镜像，建议在构建过程的最后一步使用`apk cache`的`clean`命令来删除此缓存。
- en: 'Sometimes, we don’t know the exact name of the package while we’re working
    on creating a new Docker image. The easiest way to find whatever you’re searching
    for in this case is just using the web interface: [https://pkgs.alpinelinux.org/packages](https://pkgs.alpinelinux.org/packages).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在我们创建新的 Docker 镜像时，不知道包的确切名称。此时，最简单的方式是使用 Web 界面：[https://pkgs.alpinelinux.org/packages](https://pkgs.alpinelinux.org/packages)。
- en: 'Using the CLI, you will be able to search for partial library names and binary
    names, though you can specify that what you’re searching for is a library using
    the `so:` prefix. Other useful prefixes are `cmd:` for commands and `pc:` for
    `pkg-config` files:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行界面（CLI），你将能够搜索部分库名和二进制文件名，尽管你可以使用`so:`前缀来指定你正在搜索的是库。其他有用的前缀包括`cmd:`用于命令，`pc:`用于`pkg-config`文件：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Installing, upgrading, and uninstalling packages
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装、升级和卸载包
- en: 'You can perform basic operations on packages by using the `add` (installing),
    `del` (uninstalling), and `upgrade` commands. While installing, you can also use
    special prefixes that are available during search operations, but it’s recommended
    to use the exact name of the package instead. Please also note that when adding
    a new package to the system, `apk` will choose the latest version of the package:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`add`（安装）、`del`（卸载）和`upgrade`命令对包执行基本操作。在安装过程中，你也可以使用在搜索操作中可用的特殊前缀，但建议使用包的准确名称。请注意，当向系统添加新包时，`apk`将选择该包的最新版本：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also choose to install a specific version of a package instead of the
    latest version. Unfortunately, it’s impossible to install older versions of the
    package from the same repository because when a new version is deployed, the old
    version is removed. You can, however, install older versions of packages from
    other repositories:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择安装特定版本的包，而不是最新版本。不幸的是，无法从同一仓库安装旧版本的包，因为每当部署新版本时，旧版本会被移除。然而，你可以从其他仓库安装包的旧版本：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also install a custom package you’ve prepared beforehand using the
    following command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用以下命令安装你事先准备好的自定义包：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To upgrade all available packages in your system, you can simply invoke the
    `apk upgrade` command. However, if you want to upgrade only a specific package,
    you will need to add its name after the upgrade option. Remember to refresh the
    package cache beforehand:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级系统中所有可用的包，你可以简单地调用`apk upgrade`命令。但是，如果你只想升级某个特定的包，你需要在升级选项后添加该包的名称。记得在此之前刷新包缓存：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can find all other possible operations by invoking `apk` without any other
    options. One of the most useful operations is the `apk info` command. It will
    print out information about a package or repository (the following output has
    been abbreviated):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过不带任何其他选项地调用`apk`来查找所有可能的操作。最有用的操作之一是`apk info`命令。它会打印出关于包或仓库的信息（以下输出已被缩略）：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this section, we introduced package managers – the standard way to manage
    software in Linux distributions. In the next section, we are going to cover managing
    user accounts.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们介绍了包管理工具——在 Linux 发行版中管理软件的标准方式。在接下来的部分中，我们将介绍用户账户管理。
- en: Managing users
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户管理
- en: 'The user in a Linux system is defined by a set of three files:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 系统中，用户由三组文件定义：
- en: '`/etc/passwd`: This file contains information about the user – that is, the
    user’s name, **unique numerical ID** (**UID**) in the system, the primary group
    the user belongs to GID, the path to the home directory, and the shell that is
    loaded when the user logs in. A typical entry looks like this:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/passwd`：此文件包含关于用户的信息 —— 即用户的名称、**唯一的数字 ID**（**UID**）、用户所属的主要组的 GID、主目录的路径以及用户登录时加载的
    shell。一个典型的条目如下所示：'
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Each line describes exactly one user. Fields are separated by a colon. The
    second field will only contain anything other than `x` in very exotic cases. Here,
    `x` means that the password is stored separately in the `/etc/shadow` file. The
    reason is that permissions for the `/etc/passwd` file have to be a bit more relaxed
    so that the login process can work. `/etc/shadow` can only be read by root and
    root group and written to only by root:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行描述一个用户。字段通过冒号分隔。第二个字段在非常特殊的情况下才会包含除了 `x` 以外的其他内容。在这里，`x` 表示密码存储在 `/etc/shadow`
    文件中。原因是，`/etc/passwd` 文件的权限必须稍微宽松一些，以便登录过程能够正常工作。`/etc/shadow` 只能被 root 用户和 root
    组读取，并且只能由 root 用户写入：
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`/etc/shadow -`: This file contains an encrypted password. As mentioned in
    the preceding bullet, for security reasons, this file can only be read and written
    to by the root user.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/shadow -`：此文件包含加密的密码。正如前面提到的，为了安全起见，只有 root 用户可以读取和写入此文件。'
- en: '`/etc/group -`: This file contains information about user groups that the user
    belongs to. Groups are exactly that: accounts that have been grouped together
    so that their permissions can be managed.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/group -`：此文件包含有关用户所属组的信息。组就是那些已被归类在一起的账户，以便可以管理它们的权限。'
- en: You should never have a reason to modify these files by hand and that goes especially
    for the `/etc/shadow` file. The only way to properly change its contents is by
    using the `passwd` command. We encourage you to read the man page for more information.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你永远不应该手动修改这些文件，特别是 `/etc/shadow` 文件。正确的方法是使用 `passwd` 命令来更改它的内容。我们建议你阅读手册页获取更多信息。
- en: 'Three commands take part in user modification and there are three for managing
    groups: `useradd`, `userdel`, `usermod`, `groupadd`, `groupdel`, and `groupmod`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个命令参与用户修改，另外有三个命令用于管理组：`useradd`、`userdel`、`usermod`、`groupadd`、`groupdel`
    和 `groupmod`。
- en: Adding users
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加用户
- en: '`useradd` adds a user account to the system. Various switches modify the behavior
    of this command. One of the most common versions of calling the `useradd` command
    will add a user, create its home directory, and specify the default shell:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`useradd` 向系统添加一个用户账户。不同的选项修改该命令的行为。调用 `useradd` 命令的最常见版本会添加一个用户，创建其主目录，并指定默认的
    shell：'
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`-m` tells the command to create a home directory, `-d` (here, it’s been passed
    with one minus sign alongside the m) tells the command what the home directory
    should be (notice the absolute path), and `-s` specifies the default shell. More
    parameters can be specified and, again, we encourage you to read the man page
    for more details.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`-m` 告诉命令创建主目录，`-d`（这里它和 `-m` 一起传递了一个减号）告诉命令主目录应该是什么（注意是绝对路径），`-s` 指定默认的 shell。可以指定更多的参数，再次建议你查看手册页获取更多详细信息。'
- en: Modifying users
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改用户
- en: '`usermod` modifies existing user accounts. It can be used to change the group
    membership of the user, home directory, lock the account, and more. One interesting
    option here is the `-p` flag, which lets you non-interactively apply a new password.
    This is useful in automation, when we may want to update a user password from
    a script or a tool, not from the command line. However, there is a security risk
    associated with this: during the command’s execution, anyone in the system can
    list running processes with their parameters and see the password entry. This
    does not automatically compromise the password as it must be provided as encrypted
    through the use of the `crypt (3)` function. However, if an attacker has the encrypted
    version of the password, they can run a password-cracking program against it and,
    finally, brute force its clear text version:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`usermod` 修改现有的用户账户。它可以用来更改用户的组成员、主目录、锁定账户等。这里有一个有趣的选项是 `-p` 标志，它允许你非交互式地应用新密码。这在自动化中非常有用，当我们可能希望通过脚本或工具更新用户密码，而不是通过命令行。然而，这也存在安全风险：在命令执行期间，系统中的任何人都可以列出正在运行的进程及其参数，并查看密码条目。虽然这不会自动危及密码，因为密码必须通过
    `crypt (3)` 函数加密后提供，但如果攻击者获得了加密的密码版本，他们可以运行密码破解程序进行攻击，最终通过暴力破解得到明文密码：'
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding command will add the `auser` user to a group called `admins`.
    The `-a` option means that the user will be added to the supplementary group (it
    won’t be removed from other groups it’s a member of).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将把 `auser` 用户添加到名为 `admins` 的组中。`-a` 选项表示该用户将被添加到附加组（不会从其他已有的组中删除）。
- en: Removing users
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除用户
- en: 'The `userdel` command is used to remove a user from a system. It can only remove
    user entries from system files and leave the home directory intact or delete users
    with home directories:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`userdel` 命令用于从系统中删除用户。它只能从系统文件中删除用户条目，并保持主目录不变，或者删除带有主目录的用户：'
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding command will remove the user, along with its home directory and
    all files. Note that if the user is still logged in, it will not be removed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将删除用户及其主目录和所有文件。注意，如果用户仍然登录，它将不会被删除。
- en: Managing groups
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理组
- en: 'Similarly to managing users, you can add, remove, and modify groups within
    your Linux system. There are equivalent commands to accomplish this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与管理用户类似，你可以在 Linux 系统中添加、删除和修改组。为此有等效的命令：
- en: '`groupadd`: Creates a group in the system. Groups can later be used to group
    users together and specify their execution, directory, or file access rights.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupadd`：在系统中创建一个组。组可以用于将用户归类，并指定其执行、目录或文件访问权限。'
- en: '`groupdel`: Removes the group from the system.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupdel`：从系统中删除该组。'
- en: '`groupmod`: Changes the group definition.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groupmod`：更改组定义。'
- en: 'You can also check which users are currently logged into the system by using
    the `who` command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `who` 命令查看当前登录系统的用户：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also find the UID and GID of the user you’re currently logged into
    using the `id` command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `id` 命令查看当前登录用户的 UID 和 GID：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By executing this command without any options, it will show your user ID and
    all the corresponding groups the user is in. Alternatively, you can provide a
    name you’d like to view the UID or GID of:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令时不带任何选项，它将显示你的用户 ID 和用户所在的所有组。或者，你可以提供一个名称，查看该用户的 UID 或 GID：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To view the primary group’s ID and UID, you can use the `-u` and `-g` options,
    respectively:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看主组的 ID 和 UID，你可以分别使用 `-u` 和 `-g` 选项：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this section, we introduced commands that are used to manage user accounts
    and groups in Linux systems. The next section will explain securely connecting
    to remote systems using SSH.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了用于管理 Linux 系统中用户帐户和组的命令。下一节将解释如何使用 SSH 安全地连接到远程系统。
- en: Secure Shell (SSH) protocol
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全外壳（SSH）协议
- en: In the DevOps world, almost nothing runs locally on your laptop or PC. There
    is one golden standard among ways to reach remote systems and it’s the SSH protocol.
    SSH was developed in 1995 as a secure, encrypted remote shell access tool that
    would replace plaintext utilities such as **telnet** or **rsh**. The main reason
    for this is that in distributed networks, it is too easy to eavesdrop on communication
    and anything that is being transmitted in open text can easily be intercepted.
    This includes important data such as login details.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DevOps 世界中，几乎没有什么东西在你的笔记本电脑或 PC 上本地运行。要连接到远程系统，SSH 协议是公认的黄金标准。SSH 于 1995 年开发，作为一种安全的加密远程
    shell 访问工具，用来取代像 **telnet** 或 **rsh** 这样的明文工具。其主要原因是，在分布式网络中，监听通信过于容易，任何明文传输的内容都容易被截获。这包括诸如登录信息等重要数据。
- en: The most commonly used SSH server (and the client) in the Linux world is **OpenSSH**
    ([https://www.openssh.com/](https://www.openssh.com/)). Other open source servers
    that are still maintained at the time of writing are **lsh** ([http://www.lysator.liu.se/~nisse/lsh/](http://www.lysator.liu.se/~nisse/lsh/)),
    **wolfSSH** ([https://www.wolfssl.com/products/wolfssh/](https://www.wolfssl.com/products/wolfssh/)),
    and **Dropbear** ([https://matt.ucc.asn.au/dropbear/dropbear.xhtml](https://matt.ucc.asn.au/dropbear/dropbear.xhtml)).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 世界中最常用的 SSH 服务器（和客户端）是 **OpenSSH** ([https://www.openssh.com/](https://www.openssh.com/))。截至撰写时，其他仍在维护的开源服务器包括
    **lsh** ([http://www.lysator.liu.se/~nisse/lsh/](http://www.lysator.liu.se/~nisse/lsh/))、**wolfSSH**
    ([https://www.wolfssl.com/products/wolfssh/](https://www.wolfssl.com/products/wolfssh/))
    和 **Dropbear** ([https://matt.ucc.asn.au/dropbear/dropbear.xhtml](https://matt.ucc.asn.au/dropbear/dropbear.xhtml))。
- en: SSH is mainly used to log into a remote machine to execute commands. But it’s
    also capable of transferring files (`22`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 主要用于登录远程机器执行命令。但它也能够传输文件（`22`）。
- en: Configuring OpenSSH
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 OpenSSH
- en: 'After installing the OpenSSH server, your distribution will place a basic configuration
    inside the `/etc/ssh/sshd_config` file. The most basic configuration looks like
    this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 OpenSSH 服务器后，你的发行版将在 `/etc/ssh/sshd_config` 文件中放置一个基本配置。最基本的配置如下所示：
- en: '[PRE23]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let’s investigate each of them before moving option:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续选项之前，让我们先研究一下它们：
- en: '`AuthorizedKeysFIle` tells our server where to look inside the user directory
    for the file where you will store all public keys that can be used to connect
    to this machine as a specified user. So, if you put your public key inside the
    `AlphaOne` home directory, `/home/AlphaOne/.ssh/authorized_keys`, you will be
    able to connect as this user using a counterpart private key (more about keys
    will be covered in the *Creating and managing SSH* *keys* subsection).'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AuthorizedKeysFIle` 告诉我们的服务器在用户目录中查找存储所有可以用来作为指定用户连接到该机器的公钥的文件。因此，如果你将公钥放在
    `AlphaOne` 的主目录中，即 `/home/AlphaOne/.ssh/authorized_keys`，你将能够使用对应的私钥作为该用户进行连接（关于密钥的更多内容将在
    *创建和管理 SSH* *密钥* 小节中讨论）。'
- en: '`AllowTCPForwarding` will enable or disable the ability for all users to forward
    TCP ports. **Port forwarding** is used to access remote machines that are not
    available directly on the internet, but you have access to another machine that
    can connect. This means you’re using an SSH box as a so-called jump host to connect
    to a private network, similar to using a VPN.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllowTCPForwarding` 将启用或禁用所有用户转发 TCP 端口的能力。**端口转发**用于访问那些无法直接在互联网上访问的远程机器，但你可以访问另一个可以连接的机器。这意味着你正在使用
    SSH 主机作为所谓的跳跃主机来连接到私有网络，类似于使用 VPN。'
- en: '`GatewayPorts` is another option that’s connected directly to the port forwarding
    feature. By allowing `GatewayPorts`, you can expose forwarded ports not only to
    your machine but also to other hosts within the network you are connected to.
    Setting this option to `yes` is not recommended for security reasons; you can
    accidentally expose a private network to a network you happen to be connected
    to, for example, in a coffee shop.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GatewayPorts` 是另一个直接与端口转发功能相关的选项。通过允许 `GatewayPorts`，你不仅可以将转发的端口暴露给你的机器，还可以暴露给你连接的网络中的其他主机。由于安全原因，不建议将此选项设置为
    `yes`；你可能会不小心将私有网络暴露给你所在的网络，例如在咖啡馆中。'
- en: '`X11Forwarding` has a very specific use case. Usually, you don’t want to have
    a full-fledged GUI on your servers, but if you have that need, by enabling this
    option, you will be able to log into the remote machine and start a remote graphical
    application, which will appear to run on your local host.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`X11Forwarding` 有一个非常特定的使用场景。通常情况下，你不希望在服务器上运行完整的图形界面，但如果你有这个需求，启用此选项后，你将能够登录到远程机器并启动远程图形应用程序，这些应用程序将像在本地主机上运行一样显示。'
- en: '`Subsystem` enables you to extend the OpenSSH server with additional features,
    such as SFTP in this case.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subsystem` 使你能够通过附加功能扩展 OpenSSH 服务器，例如在此案例中使用 SFTP。'
- en: A very important option that is not specified in the preceding command block
    is `PermitRootLogin`, which, by default, is set to `prohibit-password`. This means
    that you will be able to log in as a root user, but only if you need to authenticate
    using a public and private pair of keys. We recommend setting this option to `no`
    and allowing access to the root user only via the `sudo` command.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令块中没有指定的一个非常重要的选项是 `PermitRootLogin`，默认情况下设置为 `prohibit-password`。这意味着你将能够以
    root 用户身份登录，但只有在需要使用公钥和私钥对进行身份验证时才可以登录。我们建议将此选项设置为 `no`，并且仅通过 `sudo` 命令允许 root
    用户访问。
- en: That’s all. You can, of course, add more advanced configurations, such as using
    `man` `sshd_config` command.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这些。当然，你可以添加更多高级配置，例如使用 `man` `sshd_config` 命令。
- en: In the same way, you can find out how to configure your SSH client – that is,
    by running `man ssh_config`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，你可以了解如何配置 SSH 客户端——也就是说，运行 `man ssh_config`。
- en: 'Some very useful options for the client are shown here:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些非常有用的客户端选项：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`VisualHostKey`, when set to `yes`, will show ASCII graphics for the public
    key of the server. Every server you will be connected to will have a unique key,
    so it’s going to be unique graphics. It’s useful because, as humans, we’re very
    good at spotting patterns, so if you are connecting to the `1.2.35.2` server but
    you intend to get into a different system, chances are that you will figure out
    something is not right just by seeing different graphics than what you expected.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`VisualHostKey` 设置为 `yes` 时，将显示服务器公钥的 ASCII 图形。你将连接的每个服务器都有一个唯一的密钥，因此会有独特的图形。它很有用，因为作为人类，我们非常擅长识别模式，因此如果你连接到
    `1.2.35.2` 服务器，但打算进入不同的系统，你很可能通过看到与预期不同的图形来察觉到不对劲。'
- en: 'Here’s an example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例：
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The host option allows you to set specific options for one or multiple servers.
    In this example, we’re enabling forwarding SSH agent and disabling password logins
    for all servers. Also, we’re setting a default private key we will be using to
    connect to any server. This leads us to SSH keys and ciphers.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 主机选项允许你为一个或多个服务器设置特定的选项。在这个示例中，我们启用了 SSH 代理转发，并禁用了所有服务器的密码登录。此外，我们还设置了一个默认的私钥，用于连接任何服务器。这将引出我们对
    SSH 密钥和加密算法的讨论。
- en: The final option, `AddKeysToAgent`, means that whenever you use (and unlock)
    a key, it will also be added to the SSH agent for future use. That way, you won’t
    need to specify a key to use while connecting and you won’t have to unlock the
    key on every connection attempt.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项，`AddKeysToAgent`，意味着每当你使用（并解锁）一个密钥时，它也会被添加到 SSH 代理中，以供将来使用。这样，你就不需要在连接时指定密钥，也不必在每次连接尝试时解锁密钥。
- en: Creating and managing SSH keys
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和管理 SSH 密钥
- en: 'SSH consists of three components: the transport layer (**Transmission Control
    Protocol** (**TCP**)/**Internet Protocol** (**IP**)), the user authentication
    layer, and a connection layer, which can effectively be multiple connections transferring
    data independently.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 由三个组件组成：传输层（**传输控制协议** (**TCP**)/**互联网协议** (**IP**))，用户身份验证层，以及一个连接层，可以有效地是多个独立传输数据的连接。
- en: In terms of the different authentication options, you have a basic form of password
    authentication, which has proved to be not enough. There’s also public-key authentication,
    which we’ll talk about here. The two remaining ones are `keyboard-interactive`
    and **Generic Security Service Application Programming** **Interface** (**GSSAPI**).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 就不同的身份验证选项而言，你有一种基本的密码身份验证方式，证明它不够安全。还有公钥身份验证，我们将在这里讨论。剩下的两个是 `keyboard-interactive`
    和 **通用安全服务应用程序接口** (**GSSAPI**)。
- en: 'Public-key authentication requires us to generate a key that will have two
    counterparts: private and public. You will put the public key on the server inside
    `authorized_keys`; the private key will be used to authenticate.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥身份验证要求我们生成一个密钥，它将有两个对应的部分：私钥和公钥。你将把公钥放在服务器的 `authorized_keys` 文件中；私钥则用于身份验证。
- en: At the time of writing this book, RSA keys are standard for use with SSH. It
    is secure, but it’s recommended to use bigger keys that are 4,096 bits long, but
    3,072 bits (the default) are considered sufficient. Bigger keys mean slower connections.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，RSA 密钥是与 SSH 一起使用的标准。它是安全的，但建议使用更大的密钥，长度为 4,096 位，但 3,072 位（默认）也被认为足够。更大的密钥意味着更慢的连接速度。
- en: Currently, a better choice is using the `ed25519` type of key, which has a fixed
    length.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当前，更好的选择是使用 `ed25519` 类型的密钥，它具有固定长度。
- en: Additionally, all keys can be secured with a password.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有密钥都可以用密码进行保护。
- en: 'The following code shows how to generate both key types:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何生成这两种密钥类型：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, to put this newly created key on a server, you will need to either copy
    it manually to the `authorized_keys` file or use the `ssh-copy-id` command, which
    will do this for you if you already have other means of access, such as password
    authentication:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要将这个新创建的密钥放到服务器上，你需要手动将其复制到 `authorized_keys` 文件中，或者使用 `ssh-copy-id` 命令，如果你已经有其他访问手段（如密码身份验证），它会为你完成此操作：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You can only perform the next login to this server by using a key.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能通过使用密钥执行下次登录到此服务器的操作。
- en: At this point, you should have a good understanding of how SSH works and how
    to use its most used features. You now know how to create your keys and where
    to save them on the remote system.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经很好地理解了 SSH 的工作原理以及如何使用它的最常用功能。你现在知道如何创建密钥以及如何在远程系统上保存它们。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter concludes our introduction to the basic Linux operations you will
    need in your daily work. It has by no means been comprehensive enough to explain
    everything that you need to know to manage your Linux system, but it is enough
    to get you started and should be enough to help you manage your system. In the
    next chapter, we are going to cover writing shell scripts from the very beginning
    and guide you through basic and more advanced topics.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了我们对日常工作中所需的基本Linux操作的介绍。虽然这并没有全面解释你管理Linux系统所需了解的所有内容，但足以帮助你入门，并帮助你管理系统。在下一章中，我们将从头开始讲解如何编写shell脚本，并指导你学习基本以及更高级的主题。
- en: Exercises
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try out the following exercises to test your knowledge of this chapter:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下练习来测试你对本章内容的掌握：
- en: In Debian/Ubuntu, install the `vim` package.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Debian/Ubuntu中，安装`vim`软件包。
- en: Create a cron job that will create a file called `/tmp/cronfile` every Saturday
    at 10:00 A.M.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个定时任务，每周六上午10:00生成一个名为`/tmp/cronfile`的文件。
- en: Create a group called `admins` and add an existing user to it.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`admins`的组，并将一个现有用户添加到该组中。
