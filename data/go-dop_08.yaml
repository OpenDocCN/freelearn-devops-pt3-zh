- en: 'Chapter 7: Writing Command-Line Tooling'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章：编写命令行工具
- en: Visit any DevOps engineer and you will find their screens filled with terminals
    executing **Command-Line Interface** (**CLI**) applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 访问任何 DevOps 工程师，你会发现他们的屏幕上充满了执行 **命令行界面** (**CLI**) 应用程序的终端。
- en: As a DevOps engineer, we don't want to only use applications that others have
    made for us; we want to be able to write our own CLI applications. These applications
    might communicate to various systems via REST or gRPC, as we discussed in our
    previous chapter. Or you might want to execute various applications and run their
    output through custom processing. An application might even set up a development
    environment and kick off a test cycle for a new release.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 DevOps 工程师，我们不只是希望使用别人为我们制作的应用程序；我们希望能够编写自己的 CLI 应用程序。这些应用程序可以通过 REST 或 gRPC
    与各种系统通信，正如我们在前一章中讨论的那样。或者你可能想要执行各种应用程序，并通过自定义处理运行它们的输出。一个应用程序甚至可以设置开发环境并启动新发布的测试周期。
- en: Whatever your use case, you will need to use some common packages to help you
    manage the application's input and output processing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的用例是什么，你都需要使用一些常见的包来帮助你管理应用程序的输入和输出处理。
- en: In this chapter, you will learn how to use the `flag` and `os` packages to write
    simple CLI applications. For more complex applications, you will learn how to
    use the Cobra package. These skills, combined with the skills gained from our
    previous chapter, will let you build a wide gamut of applications for your needs
    or those of your customers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用 `flag` 和 `os` 包编写简单的 CLI 应用程序。对于更复杂的应用程序，你将学习如何使用 Cobra 包。这些技能，加上我们之前章节中学到的技能，将让你能够为你自己或你客户的需求构建各种应用程序。
- en: 'We will cover the following main topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Implementing application I/O
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现应用程序的 I/O
- en: Using Cobra for advanced CLI applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cobra 构建高级 CLI 应用程序
- en: Handling OS signals
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理操作系统信号
- en: In this first section, we will jump into how to use the standard library's `flag`
    package to build basic command-line programs. Let's get started!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨如何使用标准库的 `flag` 包来构建基本的命令行程序。让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可从 [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7)
    下载。
- en: Implementing application I/O
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现应用程序的 I/O
- en: CLI applications require a way to understand how you want them to execute. This
    might include what files to read, what servers to contact, and what credentials
    to use.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: CLI 应用程序需要一种方式来理解你希望它们执行的方式。这可能包括要读取哪些文件，要联系哪些服务器以及要使用哪些凭据。
- en: 'There are a couple of ways to start an application with the parameters it requires:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方式可以启动一个应用程序，以满足它所需的参数：
- en: Using the `flag` package to define command-line flags
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `flag` 包定义命令行标志
- en: Using `os.Args` to read arguments that are not defined
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `os.Args` 读取未定义的参数
- en: The `flag` package will help you when you have a command-line argument that
    has a strict definition. This might be an argument that defines the endpoint for
    a needed service. The program might want to have a default value for production
    , but allow an override when doing testing. This is perfect for a flag.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个命令行参数具有严格定义时，`flag` 包将对你有所帮助。这可能是一个定义所需服务端点的参数。程序可能希望在生产环境中有一个默认值，但在测试时允许覆盖。这对于标志非常合适。
- en: 'An example might be a program that queries our **Quote of the Day** (**QOTD**)
    server that we created earlier. We might want to have it automatically use our
    production endpoint unless we specify it to use another address. This might look
    like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个程序可能会查询我们之前创建的 **每日引语** (**QOTD**) 服务器。我们可能希望它自动使用我们的生产端点，除非我们指定使用另一个地址。这可能看起来像这样：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This simply contacts our production server and gets our quote. The `--endpoint`
    flag, which defaulted to our production address, will use another address below:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这简单地联系到我们的生产服务器并获取我们的报价。`--endpoint` 标志，默认使用我们的生产地址，将使用下面的另一个地址：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Sometimes, application arguments will suffice. Take an application that reformats
    JSON data for human readability. We might want to just read from `STDIN` if no
    files are provided. In this case, just reading the values from the command line
    will suffice, using the `os` package. This will give us executions that look like
    this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，应用程序的参数就足够了。以一个用于重新格式化 JSON 数据以供人类可读的应用程序为例。如果没有提供文件，我们可能只希望从 `STDIN` 读取数据。在这种情况下，直接从命令行读取值就足够了，可以使用
    `os` 包。这将使我们的执行结果如下所示：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are reading in `file1.json` and `file2.json` and outputting the reformatted
    text.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在读取 `file1.json` 和 `file2.json`，并输出重新格式化的文本。
- en: 'Here, we receive the output from the `wget` call and read that via STDIN to
    our `reformat` binary . This is similar to how `cat` and `grep` work. When our
    arguments are empty, they simply read from `STDIN`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们接收 `wget` 调用的输出，并通过 STDIN 将其读取到我们的 `reformat` 二进制文件中。这类似于 `cat` 和 `grep`
    的工作方式。当我们的参数为空时，它们会直接从 `STDIN` 中读取：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And sometimes, we may want a mix of flags and arguments. The `flag` package
    can help with that as well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能希望将标志和参数混合使用。`flag` 包也可以帮助处理这种情况。
- en: So, let's jump into using the `flag` package.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始使用 `flag` 包吧。
- en: The flag package
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`flag` 包'
- en: To help take in command-line arguments, Go has the standard library `flag` package.
    With `flag`, you can set up default values for your flags, provide descriptions
    for flags, and allow users to override defaults at the command line.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理命令行参数，Go 提供了标准库中的 `flag` 包。使用 `flag`，你可以为标志设置默认值、提供标志描述，并允许用户在命令行中覆盖默认值。
- en: Flags with the `flag` package are simply proceeded by `--`, similar to `--endpoint`.
    Values can simply be a contiguous string following the endpoint or a quoted string.
    While you can use a single `-` instead of `--`, there are some corner cases when
    dealing with Boolean flags. I would recommend using `--` in all cases.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `flag` 包的标志通常以 `--` 开头，类似于 `--endpoint`。值可以是紧跟在端点后的连续字符串或用引号括起来的字符串。虽然你可以使用单个
    `-` 替代 `--`，但在处理布尔型标志时有一些特殊情况，我建议在所有情况下使用 `--`。
- en: 'You can find the `flag` package documentation here: [https://pkg.go.dev/flag](https://pkg.go.dev/flag).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到 `flag` 包的文档：[https://pkg.go.dev/flag](https://pkg.go.dev/flag)。
- en: 'Let''s show a flag in action:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们展示一个标志的实际应用：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code does the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用是：
- en: Defines an `endpoint` variable that stores the flag
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个 `endpoint` 变量来存储标志
- en: Uses a `String` flag
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `String` 标志
- en: Defines the flag as `endpoint`
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标志定义为 `endpoint`
- en: Sets the flag's default value as `myserver.aws.com`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置标志的默认值为 `myserver.aws.com`
- en: Sets the flag's description
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置标志的描述
- en: 'If we don''t pass `--endpoint`, the code will use the default value. To have
    our program read the value, we simply do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不传递`--endpoint`，代码将使用默认值。为了让我们的程序读取该值，我们只需执行以下操作：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Important Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`flag.String()` returns `*string`, hence `*endpoint` above.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag.String()` 返回 `*string`，因此上面的 `*endpoint`。'
- en: '`flag.Parse()` is crucial to making your flags available in your application.
    This should only be called inside your `main()` package.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`flag.Parse()` 对于使标志在应用程序中可用至关重要。这个方法应该只在 `main()` 包内调用。'
- en: Pro Tip
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: A best practice in Go is to never define flags outside your `main` package.
    Simply pass the values as function arguments or in object constructors.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的最佳实践是从不在 `main` 包外定义标志。只需将值作为函数参数或在对象构造函数中传递。
- en: '`flag` also defines a few other flag functions other than `String()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `String()`，`flag` 还定义了其他一些标志函数：
- en: '`Bool()` for capturing `bool`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bool()` 用于捕获 `bool`'
- en: '`Int()` for capturing `int`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int()` 用于捕获 `int`'
- en: '`Int64()` for capturing `int64`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int64()` 用于捕获 `int64`'
- en: '`Uint()` for capturing `uint`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uint()` 用于捕获 `uint`'
- en: '`Uint64()` for capturing `uint64`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uint64()` 用于捕获 `uint64`'
- en: '`Float64()` for capturing `float64`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float64()` 用于捕获 `float64`'
- en: '`Duration()` for capturing `time.Duration`, such as `3m10s`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Duration()` 用于捕获 `time.Duration`，例如 `3m10s`'
- en: Now that we have seen the basic types, let's talk about custom flag types.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过基本类型，接下来我们来谈谈自定义标志类型。
- en: Custom flags
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义标志
- en: Sometimes, we want to take values and put them in types that aren't defined
    in the `flag` package.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望将值放入 `flag` 包中未定义的类型中。
- en: 'To use a custom flag, you must define a type that implements the `flag.Value`
    interface, defined as the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用自定义标志，必须定义一个实现了 `flag.Value` 接口的类型，接口定义如下：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we are going to borrow an example from Godoc that shows a custom value
    called `URLValue`, which handles flags that represent URLs, and store it in our
    standard `*url.URL` type:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将借用一个来自 Godoc 的示例，展示一个名为 `URLValue` 的自定义值，用于处理表示 URL 的标志，并将其存储在我们的标准 `*url.URL`
    类型中：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This code does the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了以下操作：
- en: Defines a `flag.Value` type called `URLValue`
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个名为`URLValue`的`flag.Value`类型。
- en: Creates a flag called `-url` that reads in a valid URL
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`-url`的标志，用于读取有效的URL。
- en: Uses the `URLValue` wrapper to store the URL in a `*url.URL` variable
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`URLValue`包装器将URL存储在`*url.URL`变量中。
- en: Uses the `reflect` package to determine whether `struct` is empty
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`reflect`包来判断`struct`是否为空。
- en: By defining a `Set()` method on a type, as we did previously, you can read in
    any custom value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在类型上定义`Set()`方法，像我们之前所做的那样，你可以读取任何自定义值。
- en: Now that we have our flag types down, let's look at some basic error handling.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了标志类型的使用，接下来看看一些基本的错误处理。
- en: Basic flag error handling
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本的标志错误处理
- en: When we enter flags that are not compatible or have a bad value, often we want
    the program to print out the bad flag and the flag values.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入不兼容的标志或具有错误值的标志时，通常我们希望程序输出错误的标志及其值。
- en: 'This can be accomplished with the `PrintDefaults()` option. Here''s an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`PrintDefaults()`选项来实现。以下是一个示例：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code does the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了以下操作：
- en: Defines a `--help` flag that just prints our defaults if set
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`--help`标志，如果设置了该标志，则只打印默认值。
- en: Defines two other flags, `--prod` and `--dev`
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了另外两个标志，`--prod`和`--dev`。
- en: If `--prod` and `--dev` are set, prints out an error message and the default
    flag values
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设置了`--prod`和`--dev`，则输出错误信息和默认标志值。
- en: If neither are set, puts out an error message and the defaults
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个标志都没有设置，则输出错误信息和默认值。
- en: 'Here is an example of the output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出的示例：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code illustrates how we can have flags with valid default values, but if
    the values are changed to cause an error, we can detect and handle the error.
    And in the spirit of good command-line tools, we provide `--help` to allow users
    to discover the flags they can use.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了如何拥有有效默认值的标志，但如果这些值被更改导致错误，我们可以检测并处理这个错误。按照良好的命令行工具精神，我们提供了`--help`，允许用户查看可以使用的标志。
- en: Shorthand flags
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简写标志
- en: In the previous example, we had a `--help` flag. But often, you may want to
    offer a shorthand such as `-h` for the user to use. These need to have the same
    default values and both need to set the same variable, so they cannot have two
    separate values.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个`--help`标志。但是通常，你可能希望提供一个简写标志，比如`-h`，供用户使用。它们需要具有相同的默认值，并且都需要设置相同的变量，因此它们不能有两个不同的值。
- en: 'We can use the `flag.[Type]Var()` calls to help us accomplish this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`flag.[Type]Var()`调用来帮助我们实现这一点：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we store the results of `--help` and `--h` in our `help` variable. We
    use `init()` to do the setup, as `BoolVar()` does not return a variable; therefore,
    it cannot be used in a `var()` statement.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`--help`和`--h`的结果存储在`help`变量中。我们使用`init()`进行初始化，因为`BoolVar()`不会返回变量；因此，它不能在`var()`语句中使用。
- en: Now that we know how a shorthand flag works, let's have a look at non-flag arguments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了简写标志的工作原理，让我们来看一下非标志参数。
- en: Accessing non-flag arguments
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问非标志参数
- en: Arguments in Go are read in a few ways. You can read the raw arguments using
    `os.Args`, which will also include all the flags. This is great when no flags
    are used.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的参数可以通过几种方式读取。你可以使用`os.Args`读取原始参数，它也会包含所有的标志。若没有使用标志，这是非常方便的。
- en: 'When using flags, `flag.Args()` can be used to retrieve only the non-flag arguments.
    If we want to send a list of authors to a development server and retrieve QOTDs
    for each author, the command might look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标志时，`flag.Args()`可以用来仅检索非标志参数。如果我们想将一份作者列表发送到开发服务器，并为每个作者获取QOTD，命令可能是这样的：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this list, we use a `--dev` flag to indicate that we want to use the development
    server. Following our flag, we have a list of arguments. Let''s retrieve those:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们使用`--dev`标志来指示我们希望使用开发服务器。在标志之后，我们列出了参数。让我们来获取这些参数：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this code, we do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们执行了以下操作：
- en: Retrieve the non-flag arguments using `flag.Args()`.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`flag.Args()`获取非标志参数。
- en: Test that we received at least one author or exit with an error.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试我们是否收到了至少一个作者，否则就退出并显示错误。
- en: We have seen how to retrieve input that comes as arguments or flags. This can
    be used to define how to contact a server or what files to open. Let's look at
    receiving input from a stream.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何获取作为参数或标志传入的输入。这可以用来定义如何联系服务器或打开哪些文件。现在让我们看一下如何从流中接收输入。
- en: Retrieving input from STDIN
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从STDIN获取输入
- en: Most applications that are written today in the DevOps community tend to revolve
    around flags and arguments, as seen previously. One of the less common methods
    of input that DevOps people use daily is piping input into a program.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，DevOps社区中编写的大多数应用程序倾向于围绕标志和参数展开，正如之前所见。DevOps人员每天使用的一种不太常见的输入方法是将输入通过管道传递到程序中。
- en: 'Tools such as `cat`, `xargs`, `sed`, `awk`, and `grep` allow you to pipe the
    output of one tool into the input of the next to accomplish a task. A simple example
    might be just looking for lines in a file we retrieved from the web that contains
    the word `error`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 工具如`cat`、`xargs`、`sed`、`awk`和`grep`允许你将一个工具的输出传递给下一个工具的输入以完成任务。一个简单的例子可能是查找我们从网络获取的文件中包含`error`字样的行：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Programs such as `cat` read input from `STDIN` when no file has been specified.
    Let''s duplicate that here for a program that looks for the word `error` on any
    input line and prints it out:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 像`cat`这样的程序在未指定文件时从`STDIN`读取输入。我们在这里复制了这个行为，编写一个程序来查找每一行中的`error`并打印出来：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This code does the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码做了以下事情：
- en: Compiles a regex using the `regexp` package to look for a line containing `error`
    – the match is case-insensitive.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`regexp`包编译一个正则表达式来查找包含`error`的行——匹配是大小写不敏感的。
- en: Uses `os.Args()` to read our argument list. We use this instead of `flag.Args()`,
    as we haven't defined any flags.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`os.Args()`读取我们的参数列表。我们使用这个而不是`flag.Args()`，因为我们没有定义任何标志。
- en: Uses `os.Stdin` if we have a single argument (the program name), which is an
    `io.Reader` that we wrap in a `bufio.Scanner`.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们只有一个参数（程序名），它会使用`os.Stdin`，这是一个`io.Reader`，我们将其包装在一个`bufio.Scanner`中。
- en: Opens the file if we have a file argument and wraps the `io.Reader` in a `bufio.Scanner`
    object.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个文件参数，它会打开文件，并将`io.Reader`包装在一个`bufio.Scanner`对象中。
- en: Returns an error if we have more arguments.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有更多的参数，它将返回一个错误。
- en: Reads input line by line and prints to `os.Stdout` every line containing the
    word `error`.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行一行地读取输入，并将每一行包含`error`字样的行打印到`os.Stdout`。
- en: Checks whether we had an input error – `io.EOF` is not considered an error and
    won't trip the `if` statement.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们是否有输入错误——`io.EOF`不被视为错误，因此不会触发`if`语句。
- en: You can find this code in the repository [https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/7/filter_errors/main.go](https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/7/filter_errors/main.go).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个代码库中找到此代码：[https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/7/filter_errors/main.go](https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/7/filter_errors/main.go)。
- en: 'Using this code compiled as `filter_errors`, we can use this to scan `wget`
    input (or any piped input) for lines containing the word `error` and then use
    `grep` to filter for a particular error code such as `401` (unauthorized):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用编译后的`filter_errors`代码，我们可以用它来扫描`wget`输入（或任何传入的输入），查找包含`error`字样的行，然后使用`grep`过滤特定的错误代码，如`401`（未授权）：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Or we can search a log file in the same way:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们也可以以相同的方式搜索日志文件：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a simplistic example that can easily be achieved with existing tools,
    but this gives a demonstration of how to build similar tooling.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，借助现有工具很容易实现，但它展示了如何构建类似的工具。
- en: In this section, we have looked at how to read different input from the command
    line in the form of flags and arguments. We looked at shorthand flags that share
    state with long-form flags. You saw how to create custom types to use as flags.
    And finally, we looked at how to successfully use STDIN to read input that is
    sent via a pipe.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们已经学习了如何从命令行读取不同的输入形式，包括标志和参数。我们看到了共享状态的简短标志与长格式标志。你也看到了如何创建自定义类型来用作标志。最后，我们学习了如何成功使用STDIN来读取通过管道传送的输入。
- en: Next, we will look at how to use Cobra, a third-party package, to create more
    sophisticated command-line applications.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用第三方包Cobra来创建更复杂的命令行应用程序。
- en: Using Cobra for advanced CLI applications
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cobra进行高级CLI应用程序
- en: Cobra is a set of packages that allows a developer to create more complex CLI
    applications. This becomes more useful than just the standard `flag` package when
    the complexity of an application causes a list of flags to become numerous.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Cobra是一组软件包，允许开发人员创建更复杂的CLI应用程序。当应用程序的复杂性导致标志列表变得繁多时，它比标准的`flag`包更有用。
- en: In this section, we will talk about how to use Cobra to create structured CLI
    applications that are friendly to developers to add features and allow users to
    understand what is available in an application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将讨论如何使用Cobra创建结构化的CLI应用程序，这些应用程序对开发人员友好，便于添加功能，并使用户能够了解应用程序中可用的功能。
- en: 'A few features that Cobra provides are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Cobra 提供的几个功能如下：
- en: Nested subcommands
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套子命令
- en: Command suggestions
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令建议
- en: Aliases for commands so that you can make changes without breaking users
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为命令创建别名，以便你在不破坏用户的情况下进行更改
- en: Generation of help text from flags and commands
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从标志和命令生成帮助文本
- en: Generation of autocompletion for various shells
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为各种 shell 生成自动补全代码
- en: Man page creation
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手册页创建
- en: 'This section will borrow heavily from the Cobra documentation, which you can
    find here: [https://github.com/spf13/cobra/blob/master/user_guide.md](https://github.com/spf13/cobra/blob/master/user_guide.md).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将大量引用 Cobra 文档，你可以在这里找到：[https://github.com/spf13/cobra/blob/master/user_guide.md](https://github.com/spf13/cobra/blob/master/user_guide.md)。
- en: Code organization
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码组织
- en: 'To make effective use of Cobra and make it easy for developers to understand
    where to add and change commands, Cobra suggests the following structure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效使用 Cobra，并使开发人员更容易理解在哪里添加和更改命令，Cobra 建议使用以下结构：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This structure has your main `main.go` executable at the top-level directory
    and all of your commands under `cmd/`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构将你的主要 `main.go` 可执行文件放在顶层目录下，所有命令都位于 `cmd/` 目录下。
- en: 'The main file for a Cobra application is primarily used to simply initialize
    Cobra and let it perform command executions. The file will look like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Cobra 应用程序的主文件主要用于初始化 Cobra 并让其执行命令。该文件将如下所示：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next, we will look at using the Cobra generator application to generate boilerplate
    code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用 Cobra 生成器应用程序来生成基础代码。
- en: The optional Cobra generator
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选的 Cobra 生成器
- en: 'Cobra provides an application that can generate boilerplate code for our application.
    To get started with the generator, we will create a configuration file for our
    application in our root directory called `~/.cobra.yaml`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Cobra 提供了一个可以为我们的应用程序生成基础代码的应用程序。要开始使用生成器，我们将在根目录创建一个名为 `~/.cobra.yaml` 的配置文件：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will handle printing our MIT license. You can use any of these values
    for the following built-in licenses:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将处理打印我们的 MIT 许可证。你可以使用以下任何一个内置许可证值：
- en: GPLv2
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPLv2
- en: GPLv3
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPLv3
- en: LGPL
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LGPL
- en: AGPL
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AGPL
- en: 2-Clause BSD
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2-Clause BSD
- en: 3-Clause BSD
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3-Clause BSD
- en: 'If you need a license not found here, instructions on how to provide a custom
    license can be found here: [https://github.com/spf13/cobra-cli/blob/main/README.md#configuring-the-cobra-generator](https://github.com/spf13/cobra-cli/blob/main/README.md#configuring-the-cobra-generator).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要这里没有的许可证，可以在这里找到如何提供自定义许可证的说明：[https://github.com/spf13/cobra-cli/blob/main/README.md#configuring-the-cobra-generator](https://github.com/spf13/cobra-cli/blob/main/README.md#configuring-the-cobra-generator)。
- en: By default, Cobra will use this configuration file from your `home` directory.
    If you need a different license, put the configuration in your repository and
    use `cobra --config="config/location.yaml` to use the alternate configuration
    file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Cobra 会使用来自你 `home` 目录的配置文件。如果你需要不同的许可证，请将配置文件放入你的仓库，并使用 `cobra --config="config/location.yaml"`
    来使用替代的配置文件。
- en: 'To download Cobra and build with the Cobra generator, type the following on
    your command line:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载 Cobra 并使用 Cobra 生成器进行构建，请在命令行中键入以下内容：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, to initialize the application, make sure that you are in the new application''s
    root directory and do the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了初始化应用程序，请确保你处于新应用程序的根目录，并执行以下操作：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Important Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`[repo path]` will be something such as `github.com/spf13/newApp`.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`[repo path]` 将是类似 `github.com/spf13/newApp` 的路径。'
- en: 'Let''s create a few commands for our application:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的应用程序创建几个命令：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will deliver us the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供以下内容：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Important Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You are required to use camelCase for command names. Not doing this will cause
    you to encounter errors.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用 camelCase 格式来命名命令。如果不这样做，将会遇到错误。
- en: The `-p` option for `create` is used to make it a subcommand of `config`. The
    string that follows is the parent's name plus `Cmd`. All other `add` calls have
    `-p` set to `rootCmd`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`create` 的 `-p` 选项用于将其作为 `config` 的子命令。后面的字符串是父命令的名称加上 `Cmd`。所有其他 `add` 调用都将
    `-p` 设置为 `rootCmd`。'
- en: 'After you `go build` the application, we can run it like so:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在你执行 `go build` 后，我们可以像这样运行它：
- en: '`app`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`'
- en: '`app serve`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app serve`'
- en: '`app config`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app config`'
- en: '`app config create`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app config create`'
- en: '`app help serve`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app help serve`'
- en: With the boilerplate now in place, we will only need to configure the commands
    to execute.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础代码框架完成后，我们只需要配置要执行的命令。
- en: The command package
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令包
- en: In the `cmd` package that has been generated, you will find a file for each
    command that can be executed. We will need to modify each file to give the correct
    help text, use flags, and execute the command.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成的 `cmd` 包中，你会找到每个可执行命令的文件。我们需要修改每个文件，以便提供正确的帮助文本、使用标志并执行命令。
- en: 'We will look at a generated `cmd/get.go` file for an application created with
    the following commands:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个通过以下命令创建的应用程序生成的 `cmd/get.go` 文件：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This application will talk to the QOTD server that we created in [*Chapter 6*](B17626_06.xhtml#_idTextAnchor367),
    *Interacting with Remote Data Sources*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序将与我们在 [*第六章*](B17626_06.xhtml#_idTextAnchor367) 中创建的 QOTD 服务器进行交互，*与远程数据源交互*。
- en: 'The generated `cmd/get.go` file will look similar to this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `cmd/get.go` 文件将类似于以下内容：
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This code does the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: 'Creates a variable called `serveCmd`:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `serveCmd` 的变量：
- en: Variable name is based on the command name plus `Cmd`.
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名是基于命令名称加上 `Cmd` 后缀。
- en: '`Use` is the argument name for the command line.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Use` 是命令行中的参数名称。'
- en: '`Short` is the brief description.'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Short` 是简要描述。'
- en: '`Long` is a longer description with examples.'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Long` 是一个更长的描述，包含示例。'
- en: '`Run` is the entry point for the code you want to execute.'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Run` 是你要执行的代码的入口点。'
- en: 'Defines `init()`, which does the following:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 `init()`，它执行以下操作：
- en: Adds this command to the `rootCmd` object.
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此命令添加到 `rootCmd` 对象中。
- en: 'Let''s use this to write our QOTD CLI:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用这个来编写我们的 QOTD CLI：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This code does the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: 'Sets up an `addr` variable to hold our server address:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个 `addr` 变量来保存我们的服务器地址：
- en: If `--dev` is passed, it sets `addr` to `devAddr`.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递了 `--dev`，它会将 `addr` 设置为 `devAddr`。
- en: Otherwise, it uses the `--addr` flag's value.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它使用 `--addr` 标志的值。
- en: '`--addr` defaults to `127.0.0.1:80`.'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--addr` 默认为 `127.0.0.1:80`。'
- en: Creates a new client for our QOTD server
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的客户端，用于连接我们的 QOTD 服务器
- en: 'Calls the QOTD server:'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 QOTD 服务器：
- en: Uses `Context` passed to `*cobra.Command`
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用传递给 `*cobra.Command` 的 `Context`
- en: Uses the `--author` flag value, which defaults to an empty string
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--author` 标志的值，默认为空字符串
- en: 'Uses a `--json` flag to determine whether the output should be in JSON:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `--json` 标志来决定输出是否为 JSON 格式：
- en: If JSON, it outputs an inline-defined struct as JSON.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是 JSON 格式，它会将内联定义的结构体输出为 JSON。
- en: Otherwise, it just pretty prints it to the screen.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它只是将其漂亮地打印到屏幕上。
- en: Important Note
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: You will see the `mustBool()` and `mustString()` functions. These simply return
    the value from the flag name that is passed. If the flag isn't defined, it panics.
    This removes a lot of ugly code for something that must always work for the CLI
    application to be valid. These functions are in the repository version.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到 `mustBool()` 和 `mustString()` 函数。这些函数只是返回传递的标志名称对应的值。如果标志未定义，它会触发 panic。这样可以去掉许多冗长的代码，因为这部分内容必须在
    CLI 应用程序中始终有效。这些函数位于代码库版本中。
- en: The flags that you see are not from the standard library `flag` package. Instead,
    this package uses flag types from [https://github.com/spf13/pflag](https://github.com/spf13/pflag).
    This package has more built-in types and methods than the standard `flag` package.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你看到的标志并非来自标准库的 `flag` 包。相反，这个包使用了来自 [https://github.com/spf13/pflag](https://github.com/spf13/pflag)
    的标志类型。这个包比标准 `flag` 包有更多的内置类型和方法。
- en: 'Now, we need to define the flags that we are using in our `Run` function:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在 `Run` 函数中定义我们正在使用的标志：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This code does the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: Adds a flag called `--dev` that can be shortened to `-d` and defaults to `false`
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个名为 `--dev` 的标志，可以缩写为 `-d`，默认为 `false`
- en: Adds a flag called `--addr` that defaults to `"127.0.0.1:80"`
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个名为 `--addr` 的标志，默认为 `"127.0.0.1:80"`
- en: Adds a flag called `--author` that can be shortened to `-a`
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个名为 `--author` 的标志，可以缩写为 `-a`
- en: Adds a flag called `--json` that defaults to `false`
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个名为 `--json` 的标志，默认为 `false`
- en: Important Note
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示
- en: Methods followed by `P`, such as `BoolP()`, define shortened flags as well as
    the long flag names.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以 `P` 结尾的方法，例如 `BoolP()`，定义了缩写的标志以及长标志名称。
- en: The flags we defined are only available when the `get` command is invoked. If
    we create subcommands on `get`, these will only be available on `get` with no
    sub-commands defined.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的标志仅在执行 `get` 命令时可用。如果我们在 `get` 命令下创建子命令，这些标志只会在没有定义子命令的 `get` 命令中可用。
- en: To add flags that work on all subcommands, use `.PersistentFlags()` instead
    of `.Flags()`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加适用于所有子命令的标志，请使用 `.PersistentFlags()` 而不是 `.Flags()`。
- en: 'The code for this client can be found in the repository here: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/cobra/app/](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/cobra/app/).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个客户端的代码可以在以下仓库中找到：[https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/cobra/app/](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/cobra/app/)。
- en: 'Now, we can run our app and call this command. In these examples, you will
    need to run the QOTD server from the gRPC chapter, like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的应用程序并调用这个命令。在这些示例中，你需要运行gRPC章节中的QOTD服务器，像这样：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This runs our application using the server at the `127.0.0.1:3560` address
    and requests a quote from Eleanor Roosevelt, with output in JSON format:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用位于`127.0.0.1:3560`地址的服务器运行我们的应用程序，并请求一个来自埃莉诺·罗斯福的引用，输出为JSON格式：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This next example gets a random quote from the server at address `127.0.0.1:3560`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例从地址为`127.0.0.1:3560`的服务器获取一个随机的引用：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this section, we have learned what the Cobra package is, how to use the Cobra
    generator tool to bootstrap a CLI application, and finally, how to build commands
    for your application using this package.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们学习了Cobra包是什么，如何使用Cobra生成器工具来引导CLI应用程序，最后，如何使用这个包为你的应用程序构建命令。
- en: Next, we are going to look at handling signals to do cleanup before exiting
    your applications.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何处理信号，在退出应用程序之前进行清理。
- en: Handling OS signals
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理操作系统信号
- en: When writing CLI applications, there are occasions when a developer wants to
    handle OS signals. The most common example is a user trying to exit a program,
    usually through a keyboard shortcut.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写CLI应用程序时，开发者有时需要处理操作系统信号。最常见的例子是用户试图退出程序，通常通过快捷键来实现。
- en: In these cases, you may want to do some file cleanup before exiting or cancel
    a call you made to a remote system.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，你可能想在退出之前进行一些文件清理，或取消对远程系统的调用。
- en: In this section, we will talk about how you can capture and respond to these
    events to make your applications more robust.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将讨论如何捕获并响应这些事件，以使你的应用程序更加强健。
- en: Capturing an OS signal
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获操作系统信号
- en: 'Go deals with two types of OS signals:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Go处理两种类型的操作系统信号：
- en: Synchronous
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步
- en: Asynchronous
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步
- en: Synchronous signals generally revolve around program errors. Go treats these
    as runtime panics, and therefore, interception of these can be handled with a
    `defer` statement.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 同步信号通常与程序错误相关。Go将这些信号视为运行时的恐慌，因此可以使用`defer`语句来处理这些信号的拦截。
- en: 'There are different asynchronous signals, depending on the platform, but for
    a Go programmer, the most relevant are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 根据平台的不同，异步信号有所不同，但对于Go程序员来说，最相关的信号如下：
- en: '`SIGHUP`: The connected terminal disconnected.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGHUP`：连接的终端断开。'
- en: '`SIGTERM`: Please quit and do cleanup (generated from a program).'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGTERM`：请退出并进行清理（由程序生成）。'
- en: '`SIGINT`: The same as `SIGTERM` (sent from the terminal).'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGINT`：与`SIGTERM`相同（从终端发送）。'
- en: '`SIGQUIT`: The same as `SIGTERM` plus a core dump (sent from the terminal).'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGQUIT`：与`SIGTERM`相同，外加一个核心转储（从终端发送）。'
- en: '`SIGKILL`: The program must quit; this signal cannot be captured.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SIGKILL`：程序必须退出；此信号无法捕获。'
- en: In situations where these arise, it can be useful to intercept these signals
    so that you can cancel ongoing operations and do a cleanup before exiting. It
    should be noted that `SIGKILL` cannot be intercepted, and `SIGHUP` is simply an
    indication that a process has lost its terminal, not necessarily that it was canceled.
    This could be because it was moved to the background or another similar event.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现这些情况时，拦截信号可以非常有用，这样你就可以取消正在进行的操作并在退出前进行清理。需要注意的是，`SIGKILL`无法被拦截，而`SIGHUP`只是表明一个进程失去了其终端连接，并不一定意味着进程被取消。这可能是因为进程被移动到后台或发生了其他类似事件。
- en: 'To capture a signal, we can use the `os/signal` package. This package allows
    a program to receive notifications of a signal from an OS and respond. Here is
    a simple example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获一个信号，我们可以使用`os/signal`包。这个包允许程序接收来自操作系统的信号通知并做出响应。下面是一个简单的示例：
- en: '[PRE31]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code does the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: Creates a channel, `signals`, on which to receive signals
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`signals`通道来接收信号
- en: Subscribes to signals of the `SIGINT`, `SIGTERM`, and `SIGQUIT` types
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅`SIGINT`、`SIGTERM`和`SIGQUIT`类型的信号
- en: 'Uses a goroutine to handle incoming signals, which does the following:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个 goroutine 来处理传入的信号，执行以下操作：
- en: Calls the `cleanup()` function to handle program cleanup
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`cleanup()`函数来处理程序的清理工作
- en: Exits with the `1` code on `SIGINT` and `SIGTERM`
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在收到`SIGINT`和`SIGTERM`时以`1`代码退出
- en: Panics, which gives a basic core dump on `SIGQUIT`
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`SIGQUIT`信号下发生panic，产生基本的核心转储
- en: Signal-handling code should be done in your `main` package. The `cleanup()`
    function should contain function calls that handle outstanding items, such as
    remote call cancellations and file cleanup.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理代码应该写在`main`包中。`cleanup()`函数应包含处理未完成项目的函数调用，例如远程调用取消和文件清理。
- en: Important Note
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can control the amount of data and generation method of a core dump using
    an environmental variable, `GOTRACEBACK`. You can read about it here: [https://pkg.go.dev/runtime#hdr-Environment_Variables](https://pkg.go.dev/runtime#hdr-Environment_Variables).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过环境变量`GOTRACEBACK`来控制核心转储的数据量和生成方式。你可以在这里阅读相关内容：[https://pkg.go.dev/runtime#hdr-Environment_Variables](https://pkg.go.dev/runtime#hdr-Environment_Variables)。
- en: Using Context to cancel
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`Context`进行取消
- en: The key method in Go to cause operations to stop processing is to use the context
    cancellation feature of Go's `context.Context` object. This object was discussed
    in [*Chapter 2*](B17626_02.xhtml#_idTextAnchor166), *Go Language Essentials*,
    if you need a refresher.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，停止操作的关键方法是使用Go的`context.Context`对象的上下文取消功能。该对象在[*第二章*](B17626_02.xhtml#_idTextAnchor166)，《Go语言精要》中有讨论，如果你需要复习。
- en: By simply creating a `Context` object with cancellation in `main()` and passing
    it to all function calls, we can effectively cancel all ongoing work. This can
    be handy when we want to stop processing and do cleanup because a user hits *Ctrl*
    + *C*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 只需在`main()`中创建一个带取消功能的`Context`对象，并将其传递给所有函数调用，我们就可以有效地取消所有正在进行的工作。当用户按下*Ctrl*
    + *C*时，这对于停止处理并进行清理非常有用。
- en: 'We are going to show an advanced signal handling method on a program that does
    the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示一种高级信号处理方法，程序的功能如下：
- en: Creates a new temporary file every 1 second for 30 seconds
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每1秒创建一个新临时文件，持续30秒
- en: Cleans up files if the program is canceled
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果程序被取消，则清理文件
- en: 'Let''s start by creating a function to handle our signals:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个处理信号的函数：
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code does the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: Creates a new function called `handleSignal()`
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`handleSignal()`的新函数
- en: Has an argument called `cancel`, which is used to signal a function chain to
    stop processing
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个名为`cancel`的参数，用于信号函数链停止处理
- en: Creates an `out` channel that we use to return with the signal received
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`out`通道，用来返回接收到的信号
- en: Creates a `notify` channel to receive signal notifications
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`notify`通道，用于接收信号通知
- en: 'Creates a goroutine to receive signals:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个goroutine来接收信号：
- en: If the signal is for exiting, call `cancel()`.
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果信号是退出信号，则调用`cancel()`。
- en: Return the signal that told us to exit.
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回通知我们退出的信号。
- en: If it is some other signal, just log it.
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是其他信号，仅记录日志。
- en: 'Now, let''s create a function that creates our files:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个函数来创建文件：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This code does the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: 'Loops 30 times, which does the following:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环30次，执行以下操作：
- en: Checks whether our `ctx` is canceled
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们的`ctx`是否已取消
- en: If so, returns the error
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是错误，则返回该错误
- en: Otherwise, creates a file in `tmpFiles`
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，在`tmpFiles`中创建文件
- en: Sleeps for 1 second between file creations
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每隔1秒创建一个新文件，持续30秒
- en: This code will create files in `tmpFiles` named from `0` to `29` unless there
    is a problem writing the file or `Context` is canceled.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在`tmpFiles`中创建从`0`到`29`的文件，除非在写入文件时发生问题或`Context`被取消。
- en: 'Now, we need some code to clean up the files if we receive a `quit` signal.
    If we don''t, the files are left alone:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一些代码来清理文件，如果我们收到`quit`信号。如果没有收到，文件将被保留：
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This code does the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: 'Uses `os.RemoveAll()` to remove the files:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`os.RemoveAll()`删除文件：
- en: Also removes the temporary directory
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时移除临时目录
- en: Notifies the user that cleanup was done
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知用户清理已完成
- en: 'Let''s tie it all together with our `main()`:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些代码整合到我们的`main()`中：
- en: '[PRE35]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code does the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行以下操作：
- en: Creates a temporary file directory
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建临时文件目录
- en: 'Creates a root `Context` object, `ctx`:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个根`Context`对象，`ctx`：
- en: '`ctx` can be canceled with `cancel()`.'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ctx`可以通过`cancel()`取消。'
- en: Calls our `handleSignal()` to handle any signal to quit
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用我们的`handleSignal()`来处理任何退出信号
- en: 'Executes our `createFiles()` function:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行我们的`createFiles()`函数：
- en: If we have an error, we call `cleanup()`.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们遇到错误，调用`cleanup()`。
- en: After cleanup, we see whether we received a signal as opposed to just an error.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清理后，我们查看是否收到了信号，而不仅仅是错误。
- en: If it is a signal and it is `SIGQUIT`, we call `panic()`. This is because `SIGQUIT`
    should core-dump by definition.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果是信号并且是`SIGQUIT`，我们调用`panic()`。这是因为根据定义，`SIGQUIT`应该产生核心转储。
- en: If it was just an error, print the error and return an error code.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果只是一个错误，打印错误并返回错误代码。
- en: 'The full code for this can be found in the repository here: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/signals](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/signals).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的完整内容可以在此仓库找到：[https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/signals](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/signals)。
- en: Important Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The code must be built with `go build` and run as a binary. It cannot be run
    with `go run`, as the `go` binary that forks our program will intercept the signal
    before our program can.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 代码必须通过`go build`构建并作为二进制文件运行。不能使用`go run`，因为`go`二进制文件在分叉我们的程序时会先拦截信号，导致我们的程序无法接收到信号。
- en: 'Multiple types of core dumps can be created in Go, controlled by an environmental
    variable. This is controlled by `GOTRACEBACK`. You can read about it here: [https://pkg.go.dev/runtime#hdr-Environment_Variables](https://pkg.go.dev/runtime#hdr-Environment_Variables).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，可以创建多种类型的核心转储，这些类型由环境变量控制。这个变量由`GOTRACEBACK`控制。你可以在这里阅读相关内容：[https://pkg.go.dev/runtime#hdr-Environment_Variables](https://pkg.go.dev/runtime#hdr-Environment_Variables)。
- en: Cancellation with Cobra
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Cobra一起的取消处理
- en: When Cobra was initially created, the `context` package did not exist. In 2020,
    the program was patched to allow the passing of a `Context` object into `cobra.Command`.
    But unfortunately, the Cobra generator was not updated to generate the necessary
    boilerplate.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当Cobra最初创建时，`context`包还不存在。在2020年，该程序经过修补，允许将`Context`对象传递给`cobra.Command`。但不幸的是，Cobra生成器没有更新以生成必要的模板代码。
- en: 'To add signal handling as we did previously, we simply need to make a couple
    of modifications – first, to the `main.go` file:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 要像之前那样添加信号处理，我们只需进行几个修改 —— 首先是修改`main.go`文件：
- en: '[PRE36]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We will also need to modify `handleSignal()`. You can see those changes here:
    [https://go.dev/play/p/F4SdN-xC-V_L](https://go.dev/play/p/F4SdN-xC-V_L)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改`handleSignal()`。你可以在这里看到这些更改：[https://go.dev/play/p/F4SdN-xC-V_L](https://go.dev/play/p/F4SdN-xC-V_L)
- en: 'Finally, you must change the `cmd/root.go` file like so:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你必须像这样修改`cmd/root.go`文件：
- en: '[PRE37]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We now have signal handling. When writing our `Run` function, we can use `cmd.Context()`
    to retrieve the `Context` object and look for cancelation.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了信号处理。当编写我们的`Run`函数时，我们可以使用`cmd.Context()`来获取`Context`对象并检查是否有取消操作。
- en: Case study – a lack of cancellation leads to a death spiral
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究 – 缺乏取消处理导致死循环
- en: One of the early Google systems to help automate the network was a system called
    Chipmunk. Chipmunk contained authoritative data on the network and would generate
    router configurations from that data.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的Google系统之一，旨在帮助自动化网络管理的系统叫做Chipmunk。Chipmunk包含网络上的权威数据，并根据这些数据生成路由器配置。
- en: Like most software, Chipmunk started off working fast and saving a lot of time.
    As the network continued its yearly tenfold growth, the limits of its design and
    language choice began to show.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数软件一样，Chipmunk最初运行迅速并节省大量时间。随着网络每年增长十倍，设计和语言选择的局限性开始显现。
- en: Chipmunk was built on Django and Python and was not designed for horizontal
    scaling. As the system became busy, configuration requests would start to take
    30 minutes or longer. Timers for these requests would have limits of no more than
    30 minutes.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Chipmunk是基于Django和Python构建的，并没有为横向扩展设计。当系统变得繁忙时，配置请求开始需要30分钟或更长时间。对于这些请求的计时器设置的最大时限为30分钟。
- en: The design had a fatal flaw when generation approached these limits – if a request
    was canceled, the cancellation was not signaled to the running configuration generator.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成接近这些限制时，设计存在一个致命缺陷 —— 如果请求被取消，取消信号不会传递给正在运行的配置生成器。
- en: This meant that if generation took 25 minutes but was canceled 1 minute in,
    the generator would spend the next 24 minutes working, with no one to receive
    the work.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果生成过程花了25分钟，但在1分钟时被取消，那么生成器将继续工作24分钟，却没有人来接收这些工作。
- en: When a call reached the time limit, the callers would time out and retry. But
    the generator was still working on the previous call. This would lead to a cascade
    failure, as multiple compute-heavy calculations were running, some of which no
    longer had a receiver. This would push the new call over the time limit, as the
    Python **Global Interpreter Lock** (**GIL** [https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock))
    prevents true multi-threading and each call was doubling CPU usage.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用达到时间限制时，调用者会超时并重试。但生成器仍在处理前一个调用。这会导致级联失败，因为正在运行多个计算密集型计算，其中一些不再有接收者。这将推动新调用超过时间限制，因为Python的**全局解释器锁**（**GIL**
    [https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock)）阻止了真正的多线程，并且每次调用都会使CPU使用率加倍。
- en: One of the keys to dealing with this type of failure scenario is being able
    to cancel jobs that are no longer needed. This is why it is so important to pipe
    a `context.Context` object throughout a function call chain and look for cancellation
    at logical points. This can greatly reduce the load on a system that reaches a
    threshold and reduce the damage of **Distributed Denial of Service** (**DDoS**)
    attacks.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此类失败场景的关键之一是能够取消不再需要的作业。这就是为什么在整个函数调用链中传递`context.Context`对象并在逻辑点查找取消的重要性所在。这可以极大地减少达到阈值的系统负载，并减少**分布式拒绝服务**（**DDoS**）攻击的损害。
- en: This section has looked at how a program can intercept OS signals and respond
    to those signals. It has provided an example of using `Context` to handle canceling
    executions that can be used in any application. We have discussed how we can integrate
    that into programs generated with the Cobra generator.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了程序如何拦截操作系统信号并对这些信号进行响应。它提供了使用`Context`处理取消执行的示例，可用于任何应用程序。我们讨论了如何将其集成到使用Cobra生成器生成的程序中。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has given you the skills to write basic and advanced command-line
    applications. We discussed how you can use the `flag` package and `os` package
    to receive signals from the user in the form of flags and arguments. We also discussed
    how to read data from `os.Stdin`, which allows you to string multiple executables
    into a chain for processing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了编写基本和高级命令行应用程序的技能。我们讨论了如何使用`flag`包和`os`包接收来自用户的标志和参数形式的信号。我们还讨论了如何从`os.Stdin`读取数据，这使你可以将多个可执行文件串联起来进行处理。
- en: We have discussed more advanced applications, namely the Cobra package and its
    accompanying generator binary, to build advanced command-line tooling with help
    text, shortcuts, and sub-commands.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了更高级的应用程序，特别是Cobra包及其附带的生成器二进制文件，用于构建带有帮助文本、快捷方式和子命令的高级命令行工具。
- en: Finally, we have talked about dealing with signals and providing cleanup on
    cancellation from these signals. This included a case study on why cancellation
    can be critical.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何处理信号并在这些信号的取消时提供清理工作。这包括一个关于为何取消可能至关重要的案例研究。
- en: The skills you have learned here will be critical in writing tooling in the
    future, from interacting with local files to interacting with services.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里学到的技能将在未来编写工具时至关重要，从与本地文件的交互到与服务的交互。
- en: In the next chapter, we will talk about how to automate interactions with the
    command line on your local device or remote devices.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何自动化与本地设备或远程设备上命令行的交互。
