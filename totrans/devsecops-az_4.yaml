- en: <st c="0">4</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Implementing Pre-commit Security Controls</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="43">After the initial planning phase, the application development process
    shifts to the code development phase, which starts on developer systems or workspaces.</st>
    <st c="201">Developers, while skilled in feature development and using coding
    languages, might not know or might overlook security details, leading to mistakes.</st>
    <st c="350">If not detected and addressed early, these mistakes can lead to unintentional
    vulnerabilities that can potentially compromise that software or the data</st>
    <st c="502">it processes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="515">Additionally, if the development environment/workspace is poorly
    managed and maintained, it could result in an entry point for attackers to inject
    malicious code or components into</st> <st c="697">the software.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="710">In this chapter, we will focus on security measures and checks that
    can be implemented before code changes are committed</st> <st c="832">to a</st>
    **<st c="837">version control system</st>** <st c="859">(</st>**<st c="861">VCS</st>**<st
    c="864">) by developers.</st> <st c="882">This includes implementing security
    controls to reduce development environment risks and setting up security safeguards
    to identify and fix vulnerabilities and common mistakes before code is committed
    to the local code repository.</st> <st c="1113">By the end of this chapter, you
    will have gained a solid understanding of the following</st> <st c="1201">key
    areas:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1211">Approaches to maintaining a secure</st> <st c="1247">development
    environment/workspace</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1280">Techniques to prevent the inclusion of sensitive files or secrets</st>
    <st c="1347">in code</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1354">Use of security extensions in IDEs for real-time</st> <st c="1404">security
    feedback</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1421">Implementing pre-commit checks to ensure code safety before committing
    to the</st> <st c="1500">local repository</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1516">These topics will equip you with the necessary knowledge and skills
    to integrate security practices into the code development phase of a DevOps workflow.</st>
    <st c="1671">Let’s</st> <st c="1677">dive in!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1685">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1708">To follow along with the instructions in this chapter, you will
    need</st> <st c="1778">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1792">A PC with an</st> <st c="1806">internet connection</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1825">An active</st> <st c="1836">Azure subscription</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1854">An Azure</st> <st c="1864">DevOps organization</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1883">A GitHub</st> <st c="1893">Enterprise organization</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1916">Overview of the pre-commit coding phase of DevOps</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1966">In the</st> *<st c="1974">Understanding the stages in a DevOps
    workflow</st>* <st c="2019">section from</st> [*<st c="2033">Chapter 1</st>*](B19710_01.xhtml#_idTextAnchor016)<st
    c="2042">,</st> *<st c="2044">Agile, DevOps, and Azure Overview</st>*<st c="2077">,
    we outlined the eight stages of a standard DevOps workflow.</st> <st c="2139">While
    the implementation of these stages can differ among organizations, and some stages
    might even be combined for efficiency, the general sequence</st> <st c="2287">remains
    consistent.</st> <st c="2308">After the planning phase, the process moves to the
    code development stage, which begins with the developer environment.</st> <st
    c="2428">To make our discussion in this book clearer and more structured, we have
    split the code development stage into</st> <st c="2539">two parts:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="3079">git add</st>` <st c="3086">operation, signaling that these changes
    are ready to be saved or committed (</st>*<st c="3163">step 2</st>* <st c="3170">of</st>
    *<st c="3174">Figure 4</st>**<st c="3182">.1</st>*<st c="3184">).</st> <st c="3188">The
    developer then proceeds to save the staged changes to their local repository using
    the</st> `<st c="3279">git commit</st>` <st c="3289">operation (</st>*<st c="3301">step
    3</st>* <st c="3308">of</st> *<st c="3312">Figure 4</st>**<st c="3320">.1</st>*<st
    c="3322">).</st> <st c="3326">This not only stores the changes but also logs a
    record of the modifications.</st> <st c="3404">It is worth noting that most times,
    staging and committing are done as a single operation</st> <st c="3494">for convenience.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="3692">git push</st>` <st c="3700">operation.</st> <st c="3712">This
    phase is all about managing the code in that</st> <st c="3762">central repository:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The code development phase of DevOps](img/B19710_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="3974">Figure 4.1 – The code development phase of DevOps</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4023">Given that our primary attention in this chapter is on the</st>
    *<st c="4083">pre-commit phase</st>*<st c="4099">, it is essential to get some
    understanding of the developer environment where the activities occur.</st> <st
    c="4200">The choice of development environment plays a pivotal role in how security
    is implemented during this phase.</st> <st c="4309">Let us take a closer look
    at the available development environment options before we discuss their implications</st>
    <st c="4421">for security.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4434">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4439">Our aim is not to extensively cover developer environments and
    tooling but to provide a broad overview of the options available.</st> <st c="4569">We
    believe it is beneficial for those overseeing the security of DevOps practices
    to understand these options and their associated</st> <st c="4700">security risks.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4715">Understanding the developer environment options</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="4763">Traditionally, developers</st> <st c="4790">use a local workstation
    as their development environment.</st> <st c="4848">Depending on the organization
    device setup process, this may or may not come with essential tools for coding
    and contributing to a project, such as Git for source control, the required language
    SDKs, and an IDE such as Visual Studio or Visual Studio Code.</st> <st c="5104">Additionally,
    many extensions and tools, including AI ones such as GitHub Copilot, are</st>
    <st c="5191">commonly added.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5206">Using a local workstation for development has several drawbacks,
    the primary one being the delay in reaching a productive state.</st> <st c="5336">Setting
    up the environment with all required installations, such as the IDE, SDKs, extensions,
    and libraries, can be time-consuming.</st> <st c="5469">It might take hours, days,
    or even longer for a developer to become productive after joining a project.</st>
    <st c="5573">As an example, in a recent discussion I (David) had with an engineering
    lead, they shared that it typically takes a month for a developer to submit their
    first PR after joining a project in</st> <st c="5763">their organization!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5782">Another downside of the local workstation is that if the system
    crashes or needs replacement, the entire setup process typically has to be repeated.</st>
    <st c="5932">This can be avoided if there is a continuous backup, but most workstations
    do not have one.</st> <st c="6024">Another challenge is for developers who are
    juggling multiple projects.</st> <st c="6096">In medium to large organizations,
    it is uncommon for developers to focus solely on one project.</st> <st c="6192">They
    often work across different projects or contribute to several simultaneously.</st>
    <st c="6275">Sometimes, the tools needed for one project might conflict with another,
    making it difficult for a developer to transition smoothly from one project to
    another.</st> <st c="6436">Another issue arises from the limited computational
    resources of local workstations when working with large projects such</st> <st
    c="6558">as</st> **<st c="6561">machine learning</st>** <st c="6577">(</st>**<st
    c="6579">ML</st>**<st c="6581">) models or complex</st> <st c="6602">monolithic
    applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6626">From a security perspective, local developer workstations are often
    connected to a company’s internal network either directly or through VPNs.</st>
    <st c="6770">If these computers get breached, the threat is not just about an
    attacker getting the source code; it also opens up the possibility to move sideways
    within the network to access other systems and data.</st> <st c="6972">This lateral
    movement can lead to broader breaches and more</st> <st c="7032">significant damage.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7051">To address these challenges, organizations are exploring modern
    development environment options such as</st> <st c="7156">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7170">Cloud-hosted development workstations</st>**<st c="7208">: Examples
    include</st> **<st c="7228">Platform as a Service</st>** <st c="7249">(</st>**<st
    c="7251">PaaS</st>**<st c="7255">) solutions</st> <st c="7267">such as</st> **<st
    c="7276">Azure Virtual Desktop</st>** <st c="7297">(</st>**<st c="7299">AVD</st>**<st
    c="7302">) or</st> **<st c="7308">Software as a Service</st>** <st c="7329">(</st>**<st
    c="7331">SaaS</st>**<st c="7335">) offerings such as Azure’s</st> **<st c="7364">Dev
    Box</st>**<st c="7371">. Dev Box is a</st> <st c="7386">cloud workstation</st>
    <st c="7404">designed for developers.</st> <st c="7429">It gives them quick access
    to</st> <st c="7459">powerful computers that are ready for coding.</st> <st c="7505">These
    workstations are set up by development</st> <st c="7549">teams with the tools
    they need.</st> <st c="7582">IT teams</st> <st c="7590">can manage these cloud
    workstations similarly to regular laptops.</st> <st c="7657">They can implement
    security hardening, deploy tools, audit, and maintain the environment using automation
    to minimize the risk of data loss.</st> <st c="7798">Developers also like it because
    they can transition between different Dev Box workstations that are provisioned
    for each project, plus they can save costs by putting the workstations in a low-power
    hibernation mode when not</st> <st c="8022">in use.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="8029">Cloud-hosted IDEs</st>**<st c="8047">: Recently, cloud IDEs</st>
    <st c="8070">have become a favored choice for code development.</st> <st c="8122">They
    offer developers the ability to write, run, and debug code directly from a web
    browser without the need for a local development environment.</st> <st c="8268">The
    most</st> <st c="8277">common ones are GitHub Codespaces,</st> **<st c="8312">Amazon
    Web Services</st>** <st c="8331">(</st>**<st c="8333">AWS</st>**<st c="8336">)
    Cloud9, Gitpod, Codeanywhere, and</st> <st c="8373">Eclipse Che.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="8385">Cloud IDEs address many challenges of local workstations.</st>
    <st c="8444">They significantly reduce</st> **<st c="8470">time to productivity</st>**
    <st c="8490">(</st>**<st c="8492">TTP</st>**<st c="8495">) so</st> <st c="8500">that
    developers can start coding in mere minutes after joining a project instead of
    waiting hours or days for tool installations.</st> <st c="8631">For resource-intensive
    projects, cloud IDEs, such as GitHub Codespaces, can scale up to 32 CPU cores
    and 64 GB RAM.</st> <st c="8747">That is a lot of power!</st> <st c="8771">Additionally,
    when working on multiple projects, developers can maintain a separate workspace
    for each project, ensuring no tool</st> <st c="8900">conflicts arise.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*<st c="8916">Figure 4</st>**<st c="8925">.2</st>* <st c="8927">shows the architecture
    of a GitHub Codespace cloud IDE.</st> <st c="8984">As shown, the codespace is
    hosted in a container running on a Linux</st> **<st c="9052">virtual machine</st>**
    <st c="9067">(</st>**<st c="9069">VM</st>**<st c="9071">) in</st> <st c="9076">Azure.</st>
    <st c="9084">We can choose our preferred editor to connect to it.</st> <st c="9137">While
    we can code directly in the web browser, there is also the option to connect using
    various desktop IDEs, including Visual</st> <st c="9265">Studio Code:</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.2 – GitHub codespace architecture](img/B19710_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="9689">Figure 4.2 – GitHub codespace architecture</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="10257">devcontainer.json</st>` <st c="10274">file.</st> <st c="10281">This
    file tells Visual Studio Code or GitHub Codespaces how to create (or access) a
    development container with a well-defined tool and runtime stack needed for</st>
    <st c="10441">the project.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10453">The primary advantage of such a setup is the elimination of setup
    delays as developers can dive straight into coding without the hassles of setting
    up tools and dependencies.</st> <st c="10629">It also has the added benefit of
    environment consistency.</st> <st c="10687">When multiple developers collaborate
    on a project, this ensures that everyone contributes using a</st> <st c="10785">uniform
    environment.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10805">In</st> *<st c="10809">Figure 4</st>**<st c="10817">.3</st>*<st
    c="10819">, we show how a dev container works in Visual Studio Code.</st> <st
    c="10878">Basically, Visual Studio Code interprets the</st> `<st c="10923">devcontainer.json</st>`
    <st c="10940">file and creates a development container with a Visual Studio Code
    server.</st> <st c="11016">It then mounts the workspace files from the local PC
    or clones them into the container.</st> <st c="11104">Any</st> <st c="11108">extra
    extensions defined in the</st> `<st c="11140">devcontainer.json</st>` <st c="11157">file
    are installed inside the container.</st> <st c="11199">This setup lets developers
    easily switch between different project environments by just connecting to</st>
    <st c="11301">another project:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Dev container in Visual Studio Code architecture](img/B19710_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="11400">Figure 4.3 – Dev container in Visual Studio Code architecture</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11461">Having gained insight into the various development environment
    options available, it is essential to also understand the workflow of this stage.</st>
    <st c="11607">In this chapter, our primary emphasis is on pre-commit security,
    so let us explore</st> <st c="11690">this further.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11703">Understanding the security categories in the pre-commit phase</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="11765">There are two</st> <st c="11779">main security categories that
    we will address for this phase.</st> <st c="11842">The first focuses on effective
    security hygiene of the development environment or workspace where coding happens.</st>
    <st c="11956">The second aims to reduce common security errors developers often
    commit</st> <st c="12029">during coding:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Two main security categories in the pre-commit coding phase
    of DevOps](img/B19710_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="12136">Figure 4.4 – Two main security categories in the pre-commit coding
    phase of DevOps</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12218">Let’s start by addressing the first risk category and security
    mitigations to put</st> <st c="12301">in place.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12310">Securing the development environment</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="12347">Attackers</st> <st c="12358">are increasingly targeting developer
    tools and workspaces (IDEs, extensions, SDKs), regardless of whether they are
    running locally or cloud-based, with the intent of interfering with pre-commit
    phase activities.</st> <st c="12570">By compromising these, attackers can embed
    malicious code early in the software development process with the aim of impacting
    a broad number of</st> <st c="12714">downstream consumers.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12735">But why even target activities in the pre-commit phase?</st> <st
    c="12792">Because it can sometimes allow them to bypass tighter security checks
    later in the process.</st> <st c="12884">Unfortunately, many organizations tend
    to trust code from their developers without further scrutiny.</st> <st c="12985">Attackers
    are looking to exploit this trust to sneak in undetected.</st> <st c="13053">A
    notable example is the Solorigate</st> <st c="13089">breach in 2019, where hackers
    discreetly added 4,000 lines of malicious code at an early stage, which allowed
    the code to be officially approved and digitally signed after the code was committed
    to</st> <st c="13287">the repository.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13302">The Solorigate breach</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13324">For a detailed</st> <st c="13340">overview and timeline of the
    Solorigate breach, refer to this</st> <st c="13402">document:</st> [<st c="13412">https://www.microsoft.com/en-us/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/</st>](https://www.microsoft.com/en-us/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13597">Some may know this breach as Sunburst, which is the name of the
    malware that</st> <st c="13675">was injected.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13688">And this is one of the mindset shifts that needs to happen as
    we adopt a DevOps workflow.</st> <st c="13779">Security measures need to be strong
    right from</st> <st c="13825">the early stages of the</st> **<st c="13850">software
    development life cycle</st>** <st c="13881">(</st>**<st c="13883">SDLC</st>**<st
    c="13887">).</st> <st c="13891">Trusting code just because it is from an internal
    source is risky.</st> <st c="13958">Implicit trust should never be given!</st>
    <st c="13996">As you mature in integrating security into your DevOps (DevSecOps),
    you need to ensure that code is only accepted after verifying the security of
    the developer’s environment and after the code itself undergoes a rigorous</st>
    <st c="14217">security review.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14233">Implicit trust should never be given because the code is from
    an internal source!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14315">Let us now turn our attention to understanding some of the entry
    points for attackers into the development environment and addressing</st> <st
    c="14450">those risks.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14462">Risk 1 – IDE vulnerability risks</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="14495">IDEs, as with other applications, can</st> <st c="14533">have
    security flaws.</st> <st c="14555">A</st> <st c="14556">notable example is</st>
    **<st c="14576">CVE-2022-41034</st>**<st c="14590">, a critical vulnerability
    in Visual Studio Code that could be exploited through a crafted link or website,
    to take over the workstation of a Visual Studio Code user!</st> <st c="14757">This
    vulnerability also impacted GitHub Codespaces, GitHub’s web-based editor (</st>[<st
    c="14836">https://github.dev</st>](https://github.dev)<st c="14855">), and</st>
    <st c="14863">Visual Studio Code for the</st> <st c="14890">web (</st>[<st c="14895">https://vscode.dev</st>](https://vscode.dev)<st
    c="14914">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14917">If you think these issues are less common, you will be mistaken.</st>
    <st c="14983">Since January 2022, Visual Studio Code has reported at least six</st>
    **<st c="15048">remote code execution</st>** <st c="15069">(</st>**<st c="15071">RCE</st>**<st
    c="15074">) vulnerabilities!</st> <st c="15094">This is why it is vital to keep
    locally installed IDEs updated.</st> <st c="15158">Managed development</st> <st
    c="15178">platforms such as GitHub Codespaces handle security updates automatically,
    reducing our maintenance tasks.</st> <st c="15285">However, this does not cover
    plugins</st> <st c="15322">or extensions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15336">Visual Studio Code vulnerability lookup</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15376">To</st> <st c="15379">explore a list of disclosed vulnerabilities
    for Visual Studio Code, go to the following</st> <st c="15468">link:</st> [<st
    c="15474">https://www.cvedetails.com/vulnerability-list/vendor_id-26/product_id-50646/Microsoft-Visual-Studio-Code.html</st>](https://www.cvedetails.com/vulnerability-list/vendor_id-26/product_id-50646/Microsoft-Visual-Studio-Code.html)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15583">For more information on CVE-2022041034, refer to this</st> **<st
    c="15638">National Institute of Standards and Technology</st>** <st c="15684">(</st>**<st
    c="15686">NIST</st>**<st c="15690">)</st> <st c="15693">link:</st> [<st c="15699">https://nvd.nist.gov/vuln/detail/CVE-2022-41034</st>](https://nvd.nist.gov/vuln/detail/CVE-2022-41034)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15746">On another note, using managed development environments such as
    GitHub Codespaces offers the added benefit of reduced lateral movement risk.</st>
    <st c="15888">By isolating each development environment in its own VM and network,
    Codespaces ensures tighter security.</st> <st c="15994">While it’s not foolproof
    against all threats, the potential for a breach to spread within the environment
    is</st> <st c="16103">significantly reduced!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16125">Risk 2 – Malicious and vulnerable IDE extensions</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="16174">Visual Studio Code is a</st> <st c="16198">lightweight IDE that
    has a strong ecosystem of extensions for extensibility.</st> <st c="16276">Whatever
    task you aim to achieve in Visual Studio Code, there is likely an extension for
    it.</st> <st c="16369">As of September 2023, the</st> <st c="16395">Visual Studio
    Code Marketplace (</st>[<st c="16427">https://marketplace.visualstudio.com/vscode</st>](https://marketplace.visualstudio.com/vscode)<st
    c="16471">) has over</st> <st c="16483">51,000+ extensions!</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The Visual Studio Code Marketplace](img/B19710_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="17140">Figure 4.5 – The Visual Studio Code Marketplace</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17187">When it</st> <st c="17195">comes to extensions, trust is crucial!</st>
    <st c="17235">Extensions in Visual Studio Code operate with the same rights as
    the logged-in user.</st> <st c="17320">For many developers, this is the local
    administrator role.</st> <st c="17379">This means that a malicious extension has
    the potential to install additional applications (which could be malicious) and
    modify code locally or remotely.</st> <st c="17534">The impact of installing a
    malicious extension can</st> <st c="17585">be significant!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17600">To help mitigate this risk, developers must be able to evaluate
    the trustworthiness of an extension so that they only install</st> <st c="17727">trusted
    extensions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17746">This is why developers must be able to evaluate the trustworthiness
    of an extension before installing it.</st> <st c="17853">To help with this, Microsoft
    implements several measures to ensure the safety of extensions in</st> <st c="17948">the
    marketplace:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Visual Studio Code Marketplace extension security measures](img/B19710_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="18207">Figure 4.6 – Visual Studio Code Marketplace extension security
    measures</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18278">Before</st> <st c="18286">publishing, extensions undergo a virus
    scan, followed by a check to prevent name squatting, for</st> *<st c="18382">official</st>*
    <st c="18390">publisher names (</st>*<st c="18408">Figure 4</st>**<st c="18417">.6</st>*<st
    c="18419">).</st> <st c="18423">After publishing, extensions are rescanned for
    viruses with every update by the publisher.</st> <st c="18514">If the community
    reports an extension as malicious, Microsoft evaluates it.</st> <st c="18590">If
    validated, the extension is removed from the marketplace and added to a</st> *<st
    c="18665">kill list</st>*<st c="18674">, prompting Visual Studio Code to auto-uninstall
    it whenever it is installed (</st>*<st c="18752">Figure 4</st>**<st c="18761">.6</st>*<st
    c="18763">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18766">While Microsoft’s safety measures are commendable, they are not
    foolproof.</st> <st c="18842">Many widely used extensions are created by community
    contributors who are not included in the name-squatting checks for official publishers.</st>
    <st c="18983">A real risk is the impersonation of popular extensions to trick
    developers into installing them.</st> <st c="19080">A case in point is research
    published by the team at Aqua Security.</st> <st c="19148">They created an impersonated
    version of Prettier, a popular Visual Studio Code extension with millions of installs,
    and were able to publish it to the marketplace.</st> <st c="19312">They named
    the URL of their version</st> `<st c="19348">pretier-vscode</st>` <st c="19362">(with
    a single</st> *<st c="19378">t</st>*<st c="19379">), subtly differing from the
    genuine</st> `<st c="19416">prettier-vscode</st>` <st c="19431">(with a double</st>
    *<st c="19447">t</st>*<st c="19448">) – see</st> *<st c="19456">Figure 4</st>**<st
    c="19464">.7</st>*<st c="19466">. Within 48 hours of publishing it, they had about
    a thousand installs from developers in multiple countries around</st> <st c="19582">the
    world!</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Comparing the genuine extension and an impersonation of the
    extension in the marketplace](img/B19710_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="19804">Figure 4.7 – Comparing the genuine extension and an impersonation
    of the extension in the marketplace</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19905">Unfortunately, it</st> <st c="19924">may not be easy to enforce
    large-scale checks.</st> <st c="19971">Some organizations may block the installation
    of unallowed extensions on their corporate firewalls or on endpoint firewalls,
    but this could also lead to friction in situations where developers perceive it
    as impacting their productivity negatively.</st> <st c="20220">Also, using Codespaces
    allows a distinct list of approved extensions.</st> <st c="20290">However, there
    is no way to prevent someone from syncing or adding in other extensions unless
    there is a policy for Visual Studio Code extensions in an org, which comes with
    various</st> <st c="20472">other problems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20487">Developers will need to be trained to be cautious before installing
    extensions.</st> <st c="20568">They should verify publisher details, read the
    reviews and ratings of the extension, and check the download count.</st> <st c="20683">But
    this puts a security responsibility on developers.</st> <st c="20738">Some practices,
    such as Workspace Trust, can help (we will cover this in the next section), but
    a better system to show and control extension permissions would be ideal.</st>
    <st c="20908">There’s been an ongoing discussion about this since</st> <st c="20960">2018!</st>
    <st c="20966">(</st>[<st c="20967">https://github.com/microsoft/vscode/issues/52116</st>](https://github.com/microsoft/vscode/issues/52116)<st
    c="21015">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21018">Aqua Security research</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21041">To learn more</st> <st c="21055">about Aqua Security’s research
    into the risk of Visual Studio Code’s extensions, please refer to this</st> <st
    c="21158">document:</st> [<st c="21168">https://blog.aquasec.com/can-you-trust-your-vscode-extensions</st>](https://blog.aquasec.com/can-you-trust-your-vscode-extensions)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21229">Risk 3 – Working with untrusted code</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="21266">Developers often</st> <st c="21283">leverage open sourced code
    from various sources in their IDEs, including public or untrusted repositories.</st>
    <st c="21391">For example, while researching a new feature or solution to a problem,
    they might look for open source projects or code snippets that address similar
    challenges and open them in their development environment to gain insights from
    them.</st> <st c="21627">This practice, while beneficial, can introduce security
    risks.</st> <st c="21690">Loading code from untrusted sources can expose developers
    to threats such as malicious code execution and compromised dependencies.</st>
    <st c="21822">These threats can potentially steal access keys and tokens from
    the</st> <st c="21890">developer’s environment.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21914">Visual Studio Code, along with its extensions, offers multiple
    ways to execute code.</st> <st c="22000">While these methods streamline the development
    process, they can provide an entry point for exploitation.</st> <st c="22106">A
    notable example is the</st> `<st c="22131">launch.json</st>` <st c="22142">launch
    configuration file, which is located either in the project’s root folder or within
    the developer’s workspace settings.</st> <st c="22269">This file allows developers
    to save debugging</st> <st c="22315">setup details:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Launch configuration attributes](img/B19710_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="22492">Figure 4.8 – Launch configuration attributes</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22536">Within</st> `<st c="22544">launch.json</st>`<st c="22555">, the</st>
    `<st c="22561">preLaunchTask</st>` <st c="22574">attribute defines a task to execute
    before debugging starts, and the</st> `<st c="22644">postDebugTask</st>` <st c="22657">attribute
    determines a task to run after the</st> <st c="22703">debugging session concludes
    (</st>*<st c="22732">Figure 4</st>**<st c="22741">.8</st>*<st c="22743">).</st>
    <st c="22747">While these attributes are designed to enhance the debugging experience,
    they can be manipulated by malicious actors.</st> <st c="22865">An attacker could
    modify these tasks to run arbitrary, potentially</st> <st c="22932">harmful code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22945">Note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22950">For further details on launch configuration and its attributes,
    please refer to this</st> <st c="23036">document:</st> [<st c="23046">https://code.visualstudio.com/docs/editor/debugging#_launchjson-attributes</st>](https://code.visualstudio.com/docs/editor/debugging#_launchjson-attributes)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23120">The risk amplifies when developers work with code from untrusted
    sources that come with a pre-set</st> `<st c="23219">launch.json</st>` <st c="23230">file.</st>
    <st c="23237">Such configurations might contain tasks that execute</st> <st c="23290">malicious
    code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23305">To mitigate this risk, Visual Studio Code introduced</st> <st
    c="23359">the</st> **<st c="23363">Workspace Trust</st>** <st c="23378">feature
    in May 2021 (version 1.57).</st> <st c="23415">This feature adds an extra security
    layer when dealing with untrusted code.</st> <st c="23491">When developers open
    such code, they are prompted by the Workspace Trust dialog to specify their trust
    level for the code.</st> <st c="23614">If the code is deemed untrustworthy, Visual
    Studio Code enters a</st> **<st c="23679">restricted mode</st>**<st c="23694">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Workspace Trust prompt](img/B19710_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="24340">Figure 4.9 – Workspace Trust prompt</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24375">This mode</st> <st c="24385">prevents potentially harmful</st>
    <st c="24415">actions by disabling or limiting certain features, including the
    ability for tasks to run, debugging, workspace settings modification, and privileged
    extensions (</st>*<st c="24577">Figure 4</st>**<st c="24586">.9</st>*<st c="24588">).</st>
    <st c="24592">The responsibility of trusting code that is loaded ultimately lies
    with the developer.</st> <st c="24679">Therefore, it is essential for developers
    to undergo continuous security training, ensuring they make informed decisions
    about which code</st> <st c="24817">to trust.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="24826">To edit the Workspace Trust setting, we can always open the Command
    Palette using</st> *<st c="24909">Ctrl</st>* <st c="24913">+</st> *<st c="24916">Shift</st>*
    <st c="24921">+</st> *<st c="24924">P</st>* <st c="24925">and type</st> `<st c="24935">Workspaces:
    Manage</st>` `<st c="24954">Workspace Trust</st>`<st c="24969">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="24970">To disable Workspace Trust entirely, we can modify the Visual
    Studio Code setting by going to</st> `<st c="25179">security.workspace.trust.enabled:
    false</st>`'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Workspace Trust Visual Studio Code setting](img/B19710_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="25824">Figure 4.10 – Workspace Trust Visual Studio Code setting</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25880">Let us review</st> <st c="25895">a less frequent but significant
    development environment risk – compromised IDE</st> <st c="25974">source code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25986">Risk 4 – Compromised IDE source code</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="26023">There is</st> <st c="26032">also a risk of the source code of
    IDEs being compromised!</st> <st c="26091">This is less common, but it does happen.</st>
    <st c="26132">Imagine the implications if the very tools used for software development
    were compromised.</st> <st c="26223">This is not just a hypothetical risk.</st>
    <st c="26261">A recent real-world incident involved a security researcher</st>
    <st c="26321">named</st> **<st c="26327">RyotaK</st>**<st c="26333">, who discovered
    and exploited a vulnerability in the Visual Studio Code repository on GitHub.</st>
    <st c="26428">The vulnerability was a result of a code injection flaw and a</st>
    <st c="26490">miswritten</st> **<st c="26501">regex expression (regex)</st>**
    <st c="26525">in a</st> **<st c="26531">continuous integration</st>** <st c="26553">(</st>**<st
    c="26555">CI</st>**<st c="26557">) script in Visual Studio Code’s official</st>
    <st c="26600">GitHub repository.</st> <st c="26619">Exploiting this granted him
    write access to the repository’s source code.</st> <st c="26693">This means he
    could potentially alter the code that developers around the world rely on for</st>
    <st c="26785">their work.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26796">If the IDEs’ source code were maliciously altered without detection,
    it could lead to widespread distribution of tampered software tools, potentially
    infecting countless projects with malicious code or backdoors.</st> <st c="27010">This
    could compromise not just individual projects but</st> <st c="27065">entire infrastructures
    if widely adopted tools</st> <st c="27112">were affected.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27126">To get more details on RyotaK’s findings and the repercussions
    of such a compromise, you can delve into his blog post here:</st> [<st c="27251">https://blog.ryotak.net/post/vscode-write-access</st>](https://blog.ryotak.net/post/vscode-write-access)<st
    c="27299">. The blog is in Japanese, so you might need help from translation services
    such as Google Translate if you’re not familiar with</st> <st c="27428">the language.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27441">Additional thoughts on hardening of the development environment</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="27505">What we</st> <st c="27514">have found in our experience is that
    some of the security hardening practices that we discussed are well known and,
    in some cases,</st> *<st c="27645">common sense</st>*<st c="27657">, but they
    often remain unimplemented and unmonitored in many environments.</st> <st c="27733">This
    is challenging to solve.</st> <st c="27763">When people know what to do</st> *<st
    c="27791">but</st>* <st c="27794">do not implement them, providing them with tools
    or some generic security training does not solve the problem.</st> <st c="27906">They
    are deep-rooted.</st> <st c="27928">Solving this usually involves some form of
    advocacy and evangelism within the organization – the hard work needed for</st>
    <st c="28046">culture change.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28061">These environment-hardening practices must be seamless if they
    will ever be implemented.</st> <st c="28151">IDEs must be configured by default
    to auto-update, plugins must be configured by default to auto-update where possible,
    or at least, the organization should have well-defined endpoint management processes
    that include developer tools and plugins.</st> <st c="28398">If possible, the
    ability to remove or adjust these security defaults should be removed or</st>
    <st c="28488">highly discouraged.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28507">This is a difficult thing to do as developers sometimes may need
    to disable some capabilities for the sake of performance or backward compatibility.</st>
    <st c="28657">We cannot just take an all-or-nothing approach as there are legitimate
    reasons why some developers may kick against these security defaults in their
    environment.</st> <st c="28819">We should be understanding and accommodating to
    valid exceptions with the right mitigations in place.</st> <st c="28921">Remember
    that security measures have to be collaborative in a</st> <st c="28983">DevSecOps
    culture.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29001">Addressing common development security mistakes</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="29049">There are</st> <st c="29059">various ways that risks are introduced
    into modern software when they are developed.</st> <st c="29145">Modern software
    applications are for the most part a</st> *<st c="29198">cocktail</st>* <st c="29206">blend
    of proprietary code written by in-house developers and third-party components,
    which can originate from open source repositories,</st> *<st c="29343">source-available</st>*
    <st c="29359">code, or even commercially licensed code, which is less common but
    nonetheless exists (</st>*<st c="29447">Figure 4</st>**<st c="29456">.11</st>*<st
    c="29459">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Modern software composition](img/B19710_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="29585">Figure 4.11 – Modern software composition</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29626">Source-available software</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29652">Source-available software means that the source code of the software
    is publicly available for viewing.</st> <st c="29757">However, it doesn’t necessarily
    grant the same freedoms as</st> **<st c="29816">open source software</st>** <st
    c="29836">(</st>**<st c="29838">OSS</st>**<st c="29841">).</st> <st c="29845">While</st>
    <st c="29851">you can see the code, there may be restrictions on how you can use,
    modify, or distribute it.</st> <st c="29945">Think of it as a</st> *<st c="29962">look
    but don’t touch</st>* <st c="29982">approach to sharing</st> <st c="30003">software
    code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30017">Any of these components could introduce risks into the software!</st>
    <st c="30083">There could be security flaws in our</st> *<st c="30120">in-house
    code</st>*<st c="30133">,</st> *<st c="30135">third-party code and open source
    packages</st>* <st c="30176">could also contain vulnerabilities, plus there is
    the issue of</st> *<st c="30240">exposed secrets</st>*<st c="30255">, which can
    be a big problem.</st> <st c="30285">Identifying and addressing these risks should
    start in the pre-commit phase.</st> <st c="30362">If we catch security problems
    closer to the final stages of the DevOps cycle, it can lead to the delay</st>
    <st c="30465">of a feature release or even worse, become a technical debt that
    grows and becomes tougher to fix as time goes on.</st> <st c="30580">With this
    in mind, let us break down the top three risk categories to prioritize in the
    pre-commit phase, starting with security issues in our</st> <st c="30723">in-house
    code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30737">Risk 1 – Addressing in-house code vulnerability risk</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="30790">Developers are</st> <st c="30805">human and can make security
    mistakes when writing code.</st> <st c="30862">For instance, a developer might
    forget to sanitize user input before using it in database queries, leaving the
    door open for SQL injection attacks.</st> <st c="31010">In another case, a developer
    might neglect to implement proper session timeouts, making the application vulnerable
    to session hijacking.</st> <st c="31147">In the</st> <st c="31153">recent</st>
    **<st c="31161">Storm-0558</st>** <st c="31171">Microsoft breach, it was discovered
    that the developers of the Microsoft 365 mail system assumed certain libraries</st>
    <st c="31286">that they implemented were fully validating the needed scope, and
    they did not add the necessary issuer/scope validation.</st> <st c="31409">This
    oversight magnified the impact of the breach when a signing key</st> <st c="31478">was
    compromised.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31494">Analysis of STORM-0558 breach by Microsoft Security Response Center
    (MSRC)</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31569">To read the full analysis of the Storm-0558 breach, please refer
    to this</st> <st c="31643">document:</st> [<st c="31653">https://msrc.microsoft.com/blog/2023/09/results-of-major-technical-investigations-for-storm-0558-key-acquisition/</st>](https://msrc.microsoft.com/blog/2023/09/results-of-major-technical-investigations-for-storm-0558-key-acquisition/)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31766">The root causes of vulnerabilities in in-house code are diverse,
    therefore there is no single remedy.</st> <st c="31869">Tackling this challenge
    demands a comprehensive strategy, blending both cultural changes and technological
    measures.</st> <st c="31986">We want to make sure that every time a developer
    writes code, they are equipped with the knowledge and tools needed to write the
    most secure code possible.</st> <st c="32142">A foundational step to addressing
    this risk is to equip developers with secure coding training but despite the best
    training efforts, security oversights are inevitable.</st> <st c="32312">To</st>
    <st c="32314">add an extra layer of mitigation, integrating a</st> **<st c="32363">static
    application security testing</st>** <st c="32398">(</st>**<st c="32400">SAST</st>**<st
    c="32404">) solution during the pre-commit phase of DevOps can</st> <st c="32458">be
    beneficial.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32472">Understanding how SAST tools work</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="32506">SAST tools</st> <st c="32518">analyze application source code,
    bytecode, or binary code to identify vulnerabilities without running</st> <st
    c="32619">the program.</st> <st c="32633">Because they can be automated, they
    operate faster than traditional manual reviews.</st> <st c="32717">As their accuracy
    improves, they are becoming the preferred choice over manual code reviews, particularly
    in organizations that have embraced a DevOps model.</st> <st c="32875">SAST tools
    use various methods to achieve this, each with its own advantages</st> <st c="32952">and
    limitations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32968">One common</st> <st c="32980">method is</st> **<st c="32990">syntax
    and semantic analysis</st>**<st c="33018">. Here, the tool breaks down the code
    to understand its structure and patterns.</st> <st c="33098">For example, in a
    situation where user input is directly added to an SQL query in the code, this
    method would recognize the pattern as a potential SQL injection vulnerability.</st>
    <st c="33274">It does this by parsing the code and building abstract representations,
    such as</st> **<st c="33354">abstract syntax trees</st>** <st c="33375">(</st>**<st
    c="33377">ASTs</st>**<st c="33381">), to</st> <st c="33388">identify such patterns.</st>
    <st c="33412">While this method can spot many vulnerabilities, it might also flag
    issues that are not real problems (false positives).</st> <st c="33533">It can
    also be resource-intensive and slow for large</st> <st c="33586">code bases.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33597">Another approach</st> <st c="33614">is</st> **<st c="33618">data
    flow analysis</st>**<st c="33636">, which tracks how data moves through a program
    and analyzes if the data is being handled insecurely.</st> <st c="33738">It uses
    heuristics and predefined rules to trace the flow of data and identify insecure
    handling; for example, if a web application’s code accepts user input in a form
    and then displays it on a web page without cleaning it up first.</st> <st c="33971">By
    mapping out how data travels from the input point to its destination on the web
    page, data flow analysis can spot this as a</st> <st c="34098">potential</st>
    **<st c="34108">cross-site scripting</st>** <st c="34128">(</st>**<st c="34130">XSS</st>**<st
    c="34133">) vulnerability and flag it.</st> <st c="34163">This method is effective
    in identifying vulnerabilities related to data handling, such as SQL injection
    or XSS.</st> <st c="34275">It is not effective in detecting logical vulnerabilities
    such as authentication bypasses that are not directly related to data flow.</st>
    <st c="34408">It might also produce false positives if the tool does not fully
    understand the data’s</st> <st c="34495">life cycle.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="34506">Taint analysis</st>** <st c="34521">is a</st> <st c="34526">specialized
    form of data flow analysis.</st> <st c="34567">It tracks user-controlled input
    to see if it gets processed without validation or sanitization, potentially leading
    to vulnerabilities.</st> <st c="34703">For example, in a chat application where
    users send messages, if these messages are displayed to other users without checking
    or sanitizing them, taint analysis would flag this as a potential stored XSS vulnerability,
    where an attacker’s message could contain malicious scripts that run on another
    user’s browser.</st> <st c="35017">It is effective for finding vulnerabilities
    related to user input, such as injection attacks.</st> <st c="35111">It can produce
    false positives if the tool does not recognize all sanitization methods.</st>
    <st c="35199">It often uses a combination of heuristics and</st> <st c="35245">rule-based
    checks.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35263">Another approach</st> <st c="35281">used by SAST tools</st> <st
    c="35299">is</st> `<st c="35483">true</st>`<st c="35487">/</st>`<st c="35489">false</st>`<st
    c="35494">. If you think of an e-commerce site that is supposed to check</st>
    <st c="35556">if a user is logged in before processing a purchase, this method
    will identify if there is a way in the code that skips this check, leading to
    potential unauthorized access.</st> <st c="35731">This method is effective for
    identifying logical vulnerabilities such as authentication bypass or missing security
    controls.</st> <st c="35856">It is less effective for identifying data-related
    vulnerabilities such as SQL injection</st> <st c="35944">or XSS.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35951">Configuration review</st>** <st c="35972">is</st> <st c="35976">another
    method used by SAST tools for analysis.</st> <st c="36024">It is straightforward
    in how it works.</st> <st c="36063">It analyzes configuration files and settings
    to ensure secure defaults and settings.</st> <st c="36148">It does this by comparing
    configurations against best practices or known secure configurations.</st> <st
    c="36244">For example, if an application configuration is set up to show detailed
    error messages, a configuration review would flag this as an information disclosure
    vulnerability since attackers could gain insights from these messages.</st> <st
    c="36471">This approach is great for catching insecure application settings that
    might be overlooked during manual reviews.</st> <st c="36585">It does not detect
    security problems in the</st> <st c="36629">code’s logic.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36642">Most SAST tools use a mix of methods to offer a well-rounded view
    of possible vulnerabilities.</st> <st c="36738">They aim for precise results,
    considering the specificities of various programming languages and frameworks.</st>
    <st c="36847">Additionally, these tools typically have preset rules or queries
    for different analysis techniques that we mentioned.</st> <st c="36965">Some even
    allow developers/security teams to create custom rules to spot more unique insecure
    coding patterns in</st> <st c="37078">the code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37087">Challenges of SAST tools</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="37112">SAST tools have</st> <st c="37129">benefits, but they also have
    limitations.</st> <st c="37171">One big limitation is that they analyze code without
    running it, so</st> <st c="37239">they don’t always have the full context of the
    application’s behavior, which can lead to a lot of false positives.</st> <st c="37354">A
    false positive is when a tool wrongly identifies a</st> <st c="37407">security
    issue.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37422">Take the example of an application developer who is writing frontend
    logic.</st> <st c="37499">They might not have user input validation and sanitization
    implemented in their code because this is being handled in the backend code, which
    might be in a separate repository.</st> <st c="37676">The SAST tool that analyzes
    the code does not have this context, so it flags the missing implementation as</st>
    <st c="37783">a vulnerability.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37799">Some SAST tools</st> <st c="37816">use simple heuristics or just
    look for basic patterns to identify vulnerabilities.</st> <st c="37899">Tools
    such as these will struggle with analyzing complex code structures.</st> <st c="37973">Just
    because a piece of code matches a simple pattern does not mean that it is vulnerable.</st>
    <st c="38064">This is</st> <st c="38071">why it is important to test these tools
    before using them.</st> <st c="38131">Some are better than others at avoiding
    false positives.</st> <st c="38188">In fact, some tools can get it wrong as much
    as 80% of the time!</st> <st c="38253">This can frustrate developers.</st> <st
    c="38284">Instead of helping to make their work easier, they have to spend time
    figuring out which warnings are real and which are not.</st> <st c="38410">This
    might make them want to skip using</st> <st c="38450">the tool.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38459">Also, some tools just point out identified vulnerabilities without
    clearly explaining why they have been flagged.</st> <st c="38574">Others are better
    at giving clear reasons and even offer automatic fixes to correct the</st> <st
    c="38662">security issue.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38677">In our opinion, these challenges do not diminish the benefits
    that SAST tools provide.</st> <st c="38765">We recommend that security experts
    and developers work together to fine-tune the configuration, queries, and patterns
    of your chosen SAST tool and integrate feedback to gradually reduce false positives
    over time.</st> <st c="38978">It is also a good idea to combine this with manual
    reviews, which we will cover later in</st> [*<st c="39067">Chapter 5</st>*](B19710_05.xhtml#_idTextAnchor098)
    <st c="39076">of</st> <st c="39080">this book.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39090">Understanding SAST integration points in the pre-commit phase</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="39152">Properly</st> <st c="39162">integrating SAST during the pre-commit
    stage of DevOps can detect critical vulnerabilities</st> <st c="39253">in application
    code when they are easiest and cheapest to fix, especially while developers are
    still focused on the task.</st> <st c="39375">This integration can be done either
    through IDE security plugins or as</st> **<st c="39446">pre-commit hooks</st>**<st
    c="39462">. Each</st> <st c="39468">method has its unique benefits.</st> <st c="39501">The</st>
    **<st c="39505">IDE plugin integration</st>** <st c="39527">provides</st> <st
    c="39536">developers with immediate feedback on security issues as they write
    the code.</st> <st c="39615">Some plugins even highlight security concerns with
    squiggly lines, similar to syntax error indications, as illustrated in</st> *<st
    c="39737">Figure 4</st>**<st c="39745">.12</st>*<st c="39748">. This immediate
    feedback serves as</st> **<st c="39784">just-in-time</st>** <st c="39796">(</st>**<st
    c="39798">JIT</st>**<st c="39801">) secure</st> <st c="39811">coding training,
    alerting developers to potential security flaws in real time.</st> <st c="39890">However,
    a limitation is that not all SAST providers offer</st> <st c="39949">such plugins:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – A sample of an IDE extension (Checkov) flagging security issues
    while code is written](img/B19710_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="40844">Figure 4.12 – A sample of an IDE extension (Checkov) flagging
    security issues while code is written</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40943">To</st> <st c="40947">understand what pre-commit hooks are, we
    should first know about</st> `<st c="41305">.git/hooks</st>` <st c="41315">directory
    of every Git repository.</st> <st c="41351">By default, Git provides sample hooks
    in this directory, but they are inactive (they have a</st> `<st c="41443">.</st>``<st
    c="41444">sample</st>` <st c="41451">extension).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41463">There are various types of Git hooks, such as pre-commit, post-commit,
    pre-push, post-receive, and many others.</st> <st c="41576">Each corresponds to
    a different phase in the Git workflow.</st> <st c="41635">The pre-commit hook
    is one of the many Git hooks.</st> <st c="41685">It is triggered right before
    a commit is recorded, allowing us to implement automated inspection of code that
    is about to be committed (</st>*<st c="41821">Figure 4</st>**<st c="41830">.13</st>*<st
    c="41833">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Pre-commit hooks are triggered before a commit is recorded](img/B19710_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="41959">Figure 4.13 – Pre-commit hooks are triggered before a commit is
    recorded</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42031">Pre-commit hooks are versatile and can run a wide variety of scripts.</st>
    <st c="42102">Any script that can be executed from the command line can be used
    as a pre-commit hook.</st> <st c="42190">Given that most SAST tools are available
    as command-line tools, integrating them as pre-commit hooks for automated code</st>
    <st c="42310">assessment becomes straightforward.</st> <st c="42346">If the pre-commit
    hook script exits with a nonzero status, the commit is aborted, giving the developer
    an opportunity to fix issues before re-attempting a</st> <st c="42501">commit
    operation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42518">One challenge</st> <st c="42532">with Git’s default setup is that
    hooks are local to each repository.</st> <st c="42602">However, teams often want
    to share and enforce consistent hooks across all developers.</st> <st c="42689">This
    is where tools such as the pre-commit framework come in handy, helping manage
    shared configurations and</st> <st c="42798">ensuring uniformity.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42818">Pre-commit framework versus pre-commit hooks</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42863">The term</st> *<st c="42873">pre-commit hooks</st>* <st c="42889">can
    sometimes be mistaken for a tool known as the</st> *<st c="42940">pre-commit framework</st>*<st
    c="42960">. As we discussed earlier, the pre-commit hook is a specific type of
    Git hook that is triggered right before a commit is recorded.</st> <st c="43091">The
    pre-commit framework is a separate tool designed to simplify the process of setting
    up and managing pre-commit hooks.</st> <st c="43213">Instead of manually writing
    and managing scripts in the</st> `<st c="43269">.git/hooks</st>` <st c="43279">directory,
    the pre-commit framework allows developers to leverage a wide array of existing
    hooks and easily integrate them into their repositories.</st> <st c="43428">With
    the pre-commit framework, we define the hooks we want in a</st> `<st c="43492">.pre-commit-config.yaml</st>`
    <st c="43515">file, and the tool takes care of installing them into the appropriate
    Git</st> <st c="43590">hooks directory.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43606">While pre-commit hooks are invaluable, there are times when developers
    might need to bypass them.</st> <st c="43705">This could be due to a perceived
    false positive or a valid reason to override the hook.</st> <st c="43793">Commands
    such as</st> `<st c="43810">git commit --no-verify</st>` <st c="43832">allow for
    such bypasses, but they should be used</st> <st c="43882">with caution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43895">SAST tools that integrate with the pre-commit phase</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="43947">Several</st> <st c="43956">SAST providers</st> <st c="43971">offer
    integration during the pre-commit stage of DevOps.</st> <st c="44028">Some of
    these providers are exclusively open source, others are purely commercial, and
    a few provide a basic open source version with an option to upgrade to a full-featured
    commercial version.</st> *<st c="44222">Figure 4</st>**<st c="44230">.14</st>*
    <st c="44233">shows an overview of</st> <st c="44255">common offerings:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Popular SAST tools and how they integrate in pre-commit](img/B19710_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="44699">Figure 4.14 – Popular SAST tools and how they integrate in pre-commit</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44768">Later in this</st> <st c="44783">chapter, we</st> <st c="44794">will
    give our recommendation on choosing the right tool.</st> <st c="44852">For now,
    this section aims to introduce you to some of the popular</st> <st c="44919">options
    available.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44937">What about AI pair programming tools?</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="44975">AI tools</st> <st c="44985">such as GitHub Copilot, Tabnine, and
    Amazon CodeWhisperer bring the power of</st> **<st c="45062">generative AI</st>**
    <st c="45075">(</st>**<st c="45077">GenAI</st>**<st c="45082">) to</st> <st c="45088">development
    teams.</st> <st c="45107">There is no doubt that they help developers to write
    code faster and to feel more satisfied with their work.</st> <st c="45216">Recent
    GitHub research found that developers using these tools work 55% faster than those</st>
    <st c="45306">who don’t.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45316">Source – Research on GitHub Copilot’s impact on developer productivity</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45387">For a closer look at GitHub’s study, check out this</st> <st c="45440">document:</st>
    [<st c="45450">https://github.blog/2022-09-07-research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/</st>](https://github.blog/2022-09-07-research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45565">However, there are concerns about the security of the code these
    tools produce.</st> <st c="45646">GitHub Copilot, for instance, is based on an</st>
    <st c="45690">OpenAI</st> **<st c="45698">large language model</st>** <st c="45718">(</st>**<st
    c="45720">LLM</st>**<st c="45723">).</st> <st c="45727">This model was trained
    on code from publicly available sources, including open source code in GitHub.</st>
    <st c="45829">Some of these code sources are notorious for using outdated APIs
    and implementing insecure coding patterns.</st> <st c="45937">So, there’s a risk
    that the AI might suggest insecure</st> <st c="45991">code snippets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46005">Studies</st> <st c="46014">show that many developers think AI-generated
    code is of high quality, but research suggests otherwise.</st> <st c="46117">A
    recent study evaluated ChatGPT, another OpenAI tool, on 21 programming tasks.</st>
    <st c="46197">It only produced 5 secure programs, while the other 16 had security
    issues in relation to vulnerabilities that were evaluated.</st> <st c="46324">For
    example, when prompted to create an FTP server using C++, ChatGPT’s code lacked
    input validation, making it vulnerable to injection attacks.</st> <st c="46469">However,
    on further prompting, ChatGPT did fix its mistakes.</st> <st c="46530">This shows
    that the quality and security of AI-generated code depend on how precisely developers
    provide carefully</st> <st c="46645">crafted prompts.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46661">We highly recommend that companies keen on using these tools should
    prioritize training their developers on providing clear, security-specific prompts.</st>
    <st c="46814">You can call this</st> *<st c="46832">secure code prompt</st>* *<st
    c="46851">engineering training</st>*<st c="46871">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46872">Further reading – How secure is the code generated by ChatGPT?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46935">For more details on the referenced study, check out the paper
    by researchers from the University of Quebec in</st> <st c="47046">Canada:</st>
    [<st c="47054">https://arxiv.org/pdf/2304.09655v1.pdf</st>](https://arxiv.org/pdf/2304.09655v1.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47092">Risk 2 – Open source component risk</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="47128">OSS packages</st> <st c="47142">offer</st> <st c="47148">flexibility,
    cost savings, and rapid development advantages.</st> <st c="47209">However, they
    can also introduce risks into a software project.</st> <st c="47273">These risks
    can be because of</st> **<st c="47303">security vulnerabilities</st>**<st c="47327">,</st>
    **<st c="47329">package compromise</st>**<st c="47347">, or</st> **<st c="47352">confusion
    attacks</st>**<st c="47369">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47370">When developers add a package to a project, they also take on
    its security risks.</st> <st c="47453">Even though many OSS project maintainers
    prioritize security, the license terms don’t mandate them to ensure it – it is
    not a responsibility that they are obligated to fulfill.</st> <st c="47630">Let
    us discuss some of these risks and how to address them in the pre-commit phase,
    starting with</st> <st c="47728">security vulnerabilities:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47753">Addressing OSS known vulnerabilities risk in the pre-commit phase</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="47819">Known vulnerabilities</st>** <st c="47841">are</st> <st c="47845">unintentional</st>
    <st c="47860">security gaps in the OSS code (think of these as accidental holes
    in the components that are used in a ship).</st> <st c="47970">When identified
    by security researchers, they are responsibly disclosed and publicly recorded
    as</st> **<st c="48067">Common Vulnerabilities and Exposures</st>** <st c="48103">(</st>**<st
    c="48105">CVEs</st>**<st c="48109">) in</st> <st c="48114">known libraries such
    as MITRE’s CVE list (</st>[<st c="48157">https://cve.mitre.org</st>](https://cve.mitre.org)<st
    c="48179">) and the</st> **<st c="48190">National Vulnerability Database</st>**
    <st c="48221">(</st>**<st c="48223">NVD</st>**<st c="48226">) (</st>[<st c="48230">https://nvd.nist.gov</st>](https://nvd.nist.gov)<st
    c="48251">).</st> <st c="48255">These</st> <st c="48260">databases can be searched
    by security tools to identify known vulnerabilities in specific versions of OSS
    packages.</st> <st c="48377">While direct vulnerabilities in the packages that
    developers choose are concerning, there is another hidden risk: transitive dependencies.</st>
    <st c="48516">These are packages that get automatically included as a dependency
    of the selected OSS package (</st>*<st c="48612">Figure 4</st>**<st c="48621">.15</st>*<st
    c="48624">).</st> <st c="48628">A recent study by the research team at Endor Labs
    found that 95% of security issues are found in these</st> <st c="48731">transitive
    dependencies:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – OSS package dependency](img/B19710_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="48905">Figure 4.15 – OSS package dependency</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48941">The State of Dependency Management report by Endor Labs</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48997">You can refer to this document to access the</st> <st c="49043">report:</st>
    [<st c="49051">https://www.endorlabs.com/state-of-dependency-management#</st>](https://www.endorlabs.com/state-of-dependency-management#)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49108">A foundational step to addressing</st> *<st c="49143">OSS known
    vulnerability</st>* <st c="49166">risk in the pre-commit phase is to</st> *<st
    c="49202">equip developers with knowledge on how to pick safe and secure OSS packages
    for their projects</st>*<st c="49296">. Some companies are trying out new ways
    to help developers make these choices.</st> <st c="49376">For example, some have
    started to experiment with the use of LLMs</st> <st c="49442">and GenAI to streamline
    this process.</st> <st c="49480">So, instead of mandating developers to read long
    guidelines on how to pick safe packages, developers can just ask questions such
    as</st> *<st c="49612">Is there a more secure alternative to the OpenSSL library?</st>*<st
    c="49670">, and they will get a response with explanations.</st> <st c="49720">A
    new tool</st> <st c="49731">called</st> **<st c="49738">DroidGPT</st>**<st c="49746">,
    made by Endor Labs, is trying to do just this.</st> <st c="49795">It aims to make
    it easier and faster for developers to choose secure open source packages for
    their projects.</st> <st c="49905">But it is still new (and in private preview),
    and we don’t know yet how well it works in</st> <st c="49994">real situations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50010">Another common approach to addressing known vulnerabilities in
    OSS in the pre-commit phase is to</st> <st c="50107">integrate</st> **<st c="50118">software
    composition analysis</st>** <st c="50147">(</st>**<st c="50149">SCA</st>**<st
    c="50152">) tools similar to how we described SAST tools integration.</st> <st
    c="50213">These tools inspect open source components and third-party libraries
    used in an application to identify known vulnerabilities.</st> <st c="50340">They
    operate by comparing these components against databases of</st> <st c="50404">known
    vulnerabilities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50426">Challenges of SCA tools</st>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: <st c="50450">One of the</st> <st c="50462">grave mistakes that we have seen
    organizations make is to reduce the implementation of DevSecOps to tooling adoption.</st>
    <st c="50580">Implementing DevSecOps effectively is more than just deploying SCA
    tools; it demands careful planning and a deep understanding of the tools’ capabilities
    and limitations.</st> <st c="50751">To understand the dependencies included in
    a project, most SCA tools will scan the project for package management files,
    parse the files to extract dependency information, and perform a vulnerability
    analysis based on the dependencies listed.</st> <st c="50994">For example, when
    dealing with a .NET Core application that uses the NuGet package manager, an SCA
    tool would analyze the</st> `<st c="51116">.csproj</st>` <st c="51123">file to
    extract dependency data, followed by a vulnerability assessment based on</st>
    <st c="51205">those dependencies.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51224">However, solely relying on package manager data to identify dependencies
    can lead to blind spots.</st> <st c="51323">There is often a mismatch between
    the dependencies declared in package management files and what is actively used
    in code.</st> <st c="51446">Some dependencies might be declared but remain unused
    in the actual code, known</st> <st c="51525">as</st> **<st c="51529">unused dependencies</st>**<st
    c="51548">. There might be dependencies used in the code but not listed in the
    package manager file, known</st> <st c="51644">as</st> **<st c="51648">phantom
    dependencies</st>**<st c="51668">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51669">Such discrepancies</st> <st c="51688">can have tangible implications.</st>
    <st c="51721">For one, alerting vulnerabilities in unused dependencies can lead
    to a barrage of unnecessary alerts, adding to the cognitive burden on developers
    who are already pressed for time.</st> <st c="51902">On the other hand, missing
    out on scanning phantom dependencies can introduce significant security blind
    spots, which is</st> <st c="52023">even riskier.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52036">Alerting vulnerabilities in unused software components (unused
    dependencies) adds to the noise, which adds to the cognitive burden on developers
    already working against tight schedules.</st> <st c="52223">Not being able to
    identify and scan phantom dependencies leads to blind spots, which is even</st>
    <st c="52316">more risky.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52327">By recognizing these challenges, more mature SCA tools have evolved.</st>
    <st c="52397">These do not just focus on package manager files but integrate this
    data with direct code analysis to offer a more comprehensive assessment.</st>
    <st c="52538">Our aim here is not to advocate for a specific tool, but we think
    it is important for teams to be aware of these challenges and factor them into
    their</st> <st c="52689">DevSecOps strategy.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52708">Addressing OSS package compromise risks in pre-commit</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`<st c="53300">eslint</st>` <st c="53306">package.</st> <st c="53316">The inserted
    code then stole</st> **<st c="53345">Node Package Manager</st>** <st c="53365">(</st>**<st
    c="53367">npm</st>**<st c="53370">) credentials</st> <st c="53385">from the systems
    of those who added and called the package in</st> <st c="53447">their code.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53458">Instead of modifying the main package, attackers could also add
    a malicious package as a dependency.</st> <st c="53560">This was the case in the
    EventStream attack where a malicious package called</st> `<st c="53637">flatmap-stream</st>`
    <st c="53651">was added to the</st> `<st c="53669">event-stream</st>` <st c="53681">package.</st>
    <st c="53691">The malicious package contained an encrypted payload that was tailored
    to steal Bitcoins from the</st> <st c="53789">Copay app.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53799">ESLint and EventStream attacks</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53830">For an ESLint</st> <st c="53845">attack post-mortem, refer to
    this</st> <st c="53879">link:</st> [<st c="53885">https://eslint.org/blog/2018/07/postmortem-for-malicious-package-publishes/</st>](https://eslint.org/blog/2018/07/postmortem-for-malicious-package-publishes/)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53960">For Snyk’s post-mortem of</st> <st c="53986">the EventStream attack,
    refer to this</st> <st c="54025">link:</st> [<st c="54031">https://snyk.io/blog/a-post-mortem-of-the-malicious-event-stream-backdoor/</st>](https://snyk.io/blog/a-post-mortem-of-the-malicious-event-stream-backdoor/)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54105">Protecting</st> <st c="54116">against package compromise requires
    us to establish a secure package management process.</st> <st c="54206">This includes
    ensuring that developers can only download packages from trusted, reputable sources
    or official repositories and verifying the integrity of these packages through
    checksums or similar techniques to ensure they have not been altered.</st> <st
    c="54453">Staying updated with security alerts for the packages you use can also
    be a safeguard.</st> <st c="54540">Platforms such as GitHub often issue security
    advisories.</st> <st c="54598">Running packages with minimal permissions can further
    reduce the potential damage of a compromised package.</st> <st c="54706">We will
    cover secure dependency management later in</st> [*<st c="54758">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122)
    <st c="54767">of this book, so stay tuned</st> <st c="54796">for that.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54805">Addressing dependency confusion attacks in pre-commit</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="54859">Dependency confusion attacks</st>** <st c="54888">are</st>
    <st c="54893">deceptive tactics where attackers name malicious packages</st> <st
    c="54951">with similar names to genuine ones and upload them to public package
    repositories.</st> <st c="55034">The goal is to deceive developers into downloading
    and integrating these malicious packages, thinking they are legitimate ones, thereby
    introducing vulnerabilities or backdoors into their software projects.</st> <st
    c="55241">A simple typo in the package name could have the developer pulling down
    malicious code that will end up being distributed to application users.</st> <st
    c="55385">Imagine believing you’re securing a life jacket, but it’s actually</st>
    <st c="55452">a weight.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55461">In a recent incident, researchers at Checkmarx, JFrog, and Sonatype
    tracked a threat actor called RED-LILI that targeted Azure developers with malicious</st>
    `<st c="55615">npm</st>` <st c="55618">packages.</st> <st c="55629">The group
    published malicious Azure SDK packages but replaced the</st> `<st c="55695">@azure</st>`
    <st c="55701">scope with</st> `<st c="55713">azure-</st>`<st c="55719">, and in
    some cases, they removed the scope altogether and just published a package with
    the same name (</st>*<st c="55823">Figure 4</st>**<st c="55832">.16</st>*<st c="55835">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Malicious npm packages published by the RED-LILI group](img/B19710_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="56388">Figure 4.16 – Malicious npm packages published by the RED-LILI
    group</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56456">What</st> <st c="56462">sets this group apart is their sophistication.</st>
    <st c="56509">They automated the entire process, from</st> `<st c="56549">npm</st>`
    <st c="56552">account creation to malicious package publishing, even bypassing</st>
    **<st c="56618">one-time password</st>** <st c="56635">(</st>**<st c="56637">OTP</st>**<st
    c="56640">) verifications.</st> <st c="56658">Also, instead of using a single
    account to</st> <st c="56701">publish multiple malicious packages, they created
    a unique account for each package, making detection and cleanup more challenging.</st>
    <st c="56833">In just 1 week, they released around 800</st> <st c="56874">such
    packages!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56888">RED-LILI attack</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56904">To read more</st> <st c="56918">about the RED-LILI supply chain
    threat actor, please refer to this</st> <st c="56985">page:</st> [<st c="56991">https://github.com/checkmarx/red-lili</st>](https://github.com/checkmarx/red-lili)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57028">Dependency confusion attacks can also take other forms.</st> <st
    c="57085">For example, the target could be private packages used within an organization
    instead of OSS packages.</st> <st c="57188">Here is an example</st> <st c="57207">of
    this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57215">Imagine a company named</st> *<st c="57240">TechCorp</st>* <st
    c="57248">that uses a private package called</st> `<st c="57284">SecureLogin</st>`
    <st c="57295">for its internal applications.</st> <st c="57327">This package is
    version</st> `<st c="57351">1.5</st>` <st c="57354">and is not available to the
    public.</st> <st c="57391">An attacker learns about</st> `<st c="57416">SecureLogin</st>`
    <st c="57427">through some leaked documentation or insider information.</st> <st
    c="57486">They then create a malicious package, also named</st> `<st c="57535">SecureLogin</st>`<st
    c="57546">, but give it a higher version number – say,</st> `<st c="57591">2.0</st>`<st
    c="57594">. This malicious package contains code that, when executed, sends sensitive
    user data to the attacker’s server.</st> <st c="57706">The attacker uploads this
    malicious</st> `<st c="57742">SecureLogin</st>` <st c="57753">version</st> `<st
    c="57762">2.0</st>` <st c="57765">to a public package repository.</st> <st c="57798">Now,
    when TechCorp’s developers fetch updates for their packages, the package manager
    sees the</st> *<st c="57893">newer</st>* <st c="57898">version</st> `<st c="57907">2.0</st>`
    <st c="57910">of</st> `<st c="57914">SecureLogin</st>` <st c="57925">and might
    automatically download and integrate it, thinking it’s a legitimate update from
    their own team (marked as</st> *<st c="58042">3</st>* <st c="58043">in</st> *<st
    c="58047">Figure 4</st>**<st c="58055">.17</st>*<st c="58058">).</st> <st c="58062">Once
    integrated, the malicious code activates, compromising</st> <st c="58121">the
    company’s applications and sending sensitive data to</st> <st c="58179">the attacker:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Dependency confusion targeting private packages](img/B19710_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="58403">Figure 4.17 – Dependency confusion targeting private packages</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58464">This is not an unusual attack.</st> <st c="58496">Alex Birsan
    documented how he performed exactly this style of dependency confusion attack
    to breach large companies such as Apple and Microsoft</st> <st c="58640">here:</st>
    [<st c="58646">https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610</st>](mailto:https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58711">In the attack, he scanned the public repositories of target organizations,
    specifically looking for package management files such as</st> `<st c="58845">package.json</st>`<st
    c="58857">. From these files, he identified names of private packages that the
    organizations used internally but were not available on public package repositories.</st>
    <st c="59011">He then created higher versions of the same package names on public
    repositories and waited for them to</st> <st c="59115">be downloaded.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59129">To address the risks of dependency confusion, we need a clear
    plan.</st> <st c="59198">Firstly, developers should undergo secure development
    training, emphasizing the importance of version pinning and teaching them to recognize
    signs of dependency confusion.</st> <st c="59370">Tools such as</st> `<st c="59384">npm</st>`<st
    c="59387">’s</st> `<st c="59391">package-lock.json</st>` <st c="59408">or Python’s</st>
    `<st c="59421">Pipfile.lock</st>` <st c="59433">can help make sure the right package
    versions are installed.</st> <st c="59495">If internal packages are used, it is
    wise to prevent downloads from public sources.</st> <st c="59579">When considering
    a new dependency, it’s beneficial to meticulously review its history, the credibility
    of its maintainers, the contribution process, and its</st> <st c="59735">recent
    changes.</st> <st c="59752">This diligence in package selection and the associated
    security practices should be integral components of any security training strategy.</st>
    <st c="59891">All of these are part of a comprehensive dependency management strategy
    that we will cover later in</st> [*<st c="59991">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122)
    <st c="60000">of</st> <st c="60004">this book.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60014">Risk 3 – Exposed secret risk</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="60043">To enhance</st> <st c="60054">their functionality, modern applications
    frequently interface with various services, such as databases, cloud storage,
    and third-party APIs.</st> <st c="60196">As a result, developers often handle
    secrets such as authentication tokens, passwords, and API keys during the coding
    process to enable and test</st> <st c="60341">these integrations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60360">A common mistake is accidentally committing these secrets into
    VCSs such as Git.</st> <st c="60442">Once pushed, especially to public repositories,
    these secrets can be accessed by malicious actors, leading to potential data breaches
    or unauthorized access.</st> <st c="60600">This is also a risk in private repositories
    where internal threats are just as dangerous as external threats.</st> <st c="60710">Keep
    in mind that private repositories may become public in the future.</st> <st c="60782">A
    recent example is the accidental leak of</st> <st c="60824">Azure Storage</st>
    **<st c="60839">shared access signature</st>** <st c="60862">(</st>**<st c="60864">SAS</st>**<st
    c="60867">) tokens by Microsoft AI researchers in their public GitHub repository.</st>
    <st c="60940">This leak led to the breach of 38 TB of</st> <st c="60980">private
    data.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60993">Note – Analysis of leak in Microsoft’s AI GitHub repository</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61053">To read more about the breach, please refer to this</st> <st c="61106">document:</st>
    [<st c="61116">https://www.wiz.io/blog/38-terabytes-of-private-data-accidentally-exposed-by-microsoft-ai-researchers</st>](https://www.wiz.io/blog/38-terabytes-of-private-data-accidentally-exposed-by-microsoft-ai-researchers)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61217">The challenge of managing secrets in code is multifaceted.</st>
    <st c="61277">It is not just about avoiding committing them, but also about securely
    storing, accessing, and rotating them.</st> <st c="61387">A holistic approach
    is required to tackle this risk.</st> <st c="61440">A clear process should be
    implemented for secret management, and development teams should be educated on
    secret management within the Azure ecosystem.</st> <st c="61591">We will cover
    secret management in a DevOps process with Azure Key Vault later in</st> <st c="61673">this
    book.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61683">In the pre-commit</st> <st c="61702">phase, secret scanning tools,
    similar to SAST tools, can be integrated to detect secrets or sensitive information
    in code bases.</st> <st c="61831">They scan the code for patterns that match common
    secret formats, such as Azure service keys or</st> <st c="61927">connection strings.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61946">These tools operate by using pattern matching, entropy checks,
    and sometimes ML to identify potential secrets in the code.</st> <st c="62070">For
    instance, a string that looks like an Azure service key would be flagged.</st>
    <st c="62148">They can be seamlessly integrated into the pre-commit phase, similar
    to SAST tools, to catch potential leaks before they are committed to</st> <st
    c="62286">source control.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62301">Choosing the right developer-first security tooling</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="62353">The best tools make it easier for engineers to do their work or
    make their work more enjoyable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62449">Tooling plays a</st> <st c="62465">critical role in implementing
    DevSecOps.</st> <st c="62507">Selecting the right tools for the pre-commit phase
    should be a joint decision involving all teams in the software development process.</st>
    <st c="62642">To simplify management and roll out at scale, it is advisable to
    adopt tools that provide a platform-first approach with a developer-first focus.</st>
    <st c="62788">This may not always be possible due to technological stack support
    limitations or</st> <st c="62870">even budget.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62882">Developer-first security tooling refers to security tools and
    solutions that prioritize the needs of developers in the software development
    process.</st> <st c="63032">These categories of tools focus on providing developers
    with the necessary capabilities to develop secure applications from the beginning
    and integrate well with standard</st> <st c="63203">development workflows.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63225">Developers tend to prefer tools that enhance their productivity
    and make their work easier and more enjoyable.</st> <st c="63337">Surveys from
    Stack Overflow and JetBrains in 2020 showed that developers value tools that are
    easy to use, integrate well with their environment, and support their preferred
    languages and frameworks.</st> <st c="63537">Work with them to select the best
    tools for</st> *<st c="63581">them</st>*<st c="63585">. It is pointless to choose
    tools that will not</st> <st c="63633">be used.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63641">Besides meeting developers’ needs, tools in this phase should
    also promote collaboration among all stakeholders.</st> <st c="63755">This ensures
    everyone takes part in the collective responsibility of security.</st> <st c="63834">For
    example, tools should allow easy sharing of security findings</st> <st c="63900">among
    teams.</st> <st c="63913">If a team has created a great query for detecting a
    vulnerable coding pattern, your tool should allow an easy roll-out of the custom
    query to other teams in</st> <st c="64070">your organization.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64088">Emphasis should be on choosing tools that deliver both</st> *<st
    c="64144">useful</st>* <st c="64150">and</st> *<st c="64155">actionable</st>*
    <st c="64165">feedback.</st> <st c="64176">Many tools might give information,
    but if it is not actionable, it is of little value.</st> <st c="64263">Actionable
    feedback is crucial as it educates developers on the reasons behind security flags
    and how to avoid them in</st> <st c="64382">the future.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64393">Hands-on exercise 1 – Performing code review, dependency checks,
    and secret scanning on the IDE</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="64489">To complete</st> <st c="64502">this hands-on exercise, you need
    to have completed the hands-on exercise (</st>*<st c="64576">Hands-on exercise
    1 – Provisioning the lab VM</st>*<st c="64622">) from the previous chapter where
    we provisioned the lab VM.</st> <st c="64684">In this exercise, we will be performing</st>
    <st c="64724">code reviews, checking dependency vulnerabilities, and scanning
    for secrets within our code.</st> <st c="64817">This is an important</st> <st
    c="64838">phase of shifting security left as we get to identify and fix many vulnerabilities
    before committing</st> <st c="64939">the code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64948">In this exercise, we will use the</st> `<st c="64983">eShopOnWeb</st>`
    <st c="64993">application.</st> <st c="65007">This application is related to eShopOnContainers
    application which focuses on containers and microservices.</st> <st c="65115">eShopOnWeb
    on the other hand focuses on traditional web application development.</st> *<st
    c="65196">Figure 4</st>**<st c="65204">.18</st>* <st c="65207">shows the reference
    architecture of the</st> <st c="65248">eShopOnContainers application:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18 – eShopOnContainers reference architecture (Source: https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/introduce-eshoponcontainers-reference-app)](img/B19710_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="65814">Figure 4.18 – eShopOnContainers reference architecture (Source:
    https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/introduce-eshoponcontainers-reference-app)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65987">Following are the tasks that we will complete in</st> <st c="66037">this
    exercise:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="66051">Task 1</st>**<st c="66058">: Connecting to the lab VM using</st>
    <st c="66092">Azure Bastion</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="66105">Task 2</st>**<st c="66112">: Configuring Snyk on Visual</st>
    <st c="66142">Studio Code</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="66173">eShopOnWeb</st>` <st c="66183">to your Visual Studio</st> <st
    c="66206">Code workspace</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="66220">Task 1 – Connecting to the lab VM using Azure Bastion</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="66274">The aim of this task is</st> <st c="66298">to use the Bastion
    service to</st> <st c="66329">establish a connection with the</st> <st c="66361">lab
    VM:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66368">On the Azure portal home page, in the search box, type</st> `<st
    c="66424">DevSecOps-LabVM</st>` <st c="66439">and select the</st> `<st c="66455">DevSecOps-LabVM</st>`
    <st c="66470">VM when</st> <st c="66479">it appears:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Selecting the DevSecOps-LabVM VM](img/B19710_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="66715">Figure 4.19 – Selecting the DevSecOps-LabVM VM</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66761">In</st> <st c="66764">the</st> **<st c="66769">DevSecOps-LabVM</st>**
    <st c="66784">window, in</st> <st c="66796">the</st> **<st c="66800">Connect</st>**
    <st c="66807">section, click on</st> **<st c="66826">Connect</st>** <st c="66833">|</st>
    **<st c="66836">Go</st>** **<st c="66839">to Bastion</st>**<st c="66849">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.20 – Selecting the option to connect to the VM using Bastion](img/B19710_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="67638">Figure 4.20 – Selecting the option to connect to the VM using
    Bastion</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67707">In the</st> `<st c="67806">azureuser</st>`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="67815">Authentication</st>** **<st c="67831">Type</st>**<st c="67835">:</st>
    **<st c="67838">Password</st>**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="67846">Password</st>**<st c="67855">: Enter the password that you
    specified during the</st> <st c="67907">template deployment</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="67926">Open in new browser</st>** **<st c="67947">tab</st>**<st c="67950">:
    Selected</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="67961">Click</st> **<st c="67968">Connect</st>**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Configuring the VM credentials and initiating a connection
    to the VM](img/B19710_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="68145">Figure 4.21 – Configuring the VM credentials and initiating a
    connection to the VM</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68227">If prompted, enable</st> <st c="68247">a pop-up window</st> <st
    c="68264">for the connection to be successful.</st> <st c="68301">Also, click
    to allow clipboard access</st> <st c="68339">if prompted:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="68351">Now that you have access</st> <st c="68377">to the lab VM, let
    us perform code review, dependency checks, secret scanning, and</st> **<st c="68460">software
    bill of materials</st>** <st c="68486">(</st>**<st c="68488">SBOM</st>**<st c="68492">)
    generation within</st> <st c="68513">the IDE.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68521">Task 2 – Configuring Snyk on Visual Studio Code</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="68569">In this task, we will</st> <st c="68591">set up our scanning tool
    within</st> <st c="68624">Visual Studio Code.</st> <st c="68644">We</st> <st c="68646">will
    be using Snyk (</st>[<st c="68667">snyk.io</st>](http://snyk.io)<st c="68675">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68678">On the Desktop of the lab VM, you will find Visual Studio Code.</st>
    <st c="68743">This was pre-installed for you.</st> <st c="68775">Go ahead and
    open Visual</st> <st c="68800">Studio Code.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="68812">There are several open source and commercial tools you can use
    in your IDE to perform code scanning, dependency checks, secrets scanning, and
    SBOM generation.</st> <st c="68972">The</st> <st c="68975">choice of the source
    code analysis tool depends on several things, including the programming language
    in use, whether the tool is open source or</st> <st c="69121">commercial, the
    accuracy of the tool, availability as an extension with preferred IDEs, and so
    on.</st> <st c="69220">It is therefore important for you to review which tool
    will work for your use cases and have proper</st> **<st c="69320">proofs of concept</st>**
    <st c="69337">(</st>**<st c="69339">POCs</st>**<st c="69343">) done</st> <st c="69350">before
    going forward with a particular tool.</st> <st c="69396">The</st> **<st c="69400">Open
    Worldwide Application Security Project</st>** <st c="69443">(</st>**<st c="69445">OWASP</st>**<st
    c="69450">) (</st>[<st c="69454">https://owasp.org/www-community/Source_Code_Analysis_Tools</st>](https://owasp.org/www-community/Source_Code_Analysis_Tools)<st
    c="69513">) shows</st> <st c="69521">a list of some of the tools available in
    the market, platforms supported, and programming languages scanned.</st> <st c="69631">For
    this exercise, we will</st> <st c="69658">be using Snyk, which scans for open
    source security, code security, and</st> **<st c="69730">Infrastructure as Code</st>**
    <st c="69752">(</st>**<st c="69754">IaC</st>**<st c="69757">) security.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="69769">Let’s install the Snyk Visual Studio Code extension by going to</st>
    `<st c="69877">Snyk</st>` <st c="69881">in the search bar.</st> <st c="69901">Click
    on the first instance of Snyk, as shown in the following screenshot, and</st>
    <st c="69980">then</st> **<st c="69985">Install</st>**<st c="69992">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Installing Snyk Visual Studio Code extension](img/B19710_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="70691">Figure 4.22 – Installing Snyk Visual Studio Code extension</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70749">Next, let’s configure the Snyk Visual Studio Code extension.</st>
    <st c="70811">We configure the extension</st> <st c="70837">from the extension
    settings, which can be accessed by clicking on the Snyk logo on the left and clicking
    on the</st> <st c="70949">settings icon, then</st> **<st c="70970">Extension Settings</st>**<st
    c="70988">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Snyk extension settings](img/B19710_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="71503">Figure 4.23 – Snyk extension settings</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71540">Now, let’s configure the Synk extension</st> <st c="71581">as
    follows:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<st c="71628">--all-projects</st>`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="71642">Advanced: Automatic Dependency Management</st>** <st c="71684">is
    checked</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="71695">Advanced Auto Scan Open Source Security</st>** <st c="71735">is
    checked:</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.24 – Snyk advanced extension settings](img/B19710_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="72486">Figure 4.24 – Snyk advanced extension settings</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72532">Check</st> <st c="72539">the</st> **<st c="72543">Code Quality</st>**<st
    c="72555">,</st> **<st c="72557">Code Security</st>**<st c="72570">,</st> **<st
    c="72572">Infrastructure As Code</st>**<st c="72594">, and</st> **<st c="72600">Open
    Source Security</st>** <st c="72620">Snyk features:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.25 – Snyk features extension settings](img/B19710_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="72963">Figure 4.25 – Snyk features extension settings</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="73009">Lastly, make sure</st> **<st c="73028">Snyk: Scanning Mode</st>**
    <st c="73047">is set to</st> **<st c="73058">auto</st>** <st c="73062">and</st>
    **<st c="73067">Snyk: Severity</st>** <st c="73081">is checked</st> <st c="73092">for</st>
    **<st c="73097">critical</st>**<st c="73105">,</st> **<st c="73107">high</st>**<st
    c="73111">,</st> **<st c="73113">medium</st>**<st c="73119">, and</st> **<st c="73125">low</st>**<st
    c="73128">, as</st> <st c="73133">shown in the</st> <st c="73146">following screenshot:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.26 – Snyk scanning and severity extension settings](img/B19710_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="73349">Figure 4.26 – Snyk scanning and severity extension settings</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73408">For Synk to scan your projects, you must be authenticated with
    Snyk using your Snyk API token.</st> <st c="73504">Click on the Snyk icon, then
    select</st> **<st c="73540">Trust workspace</st>** **<st c="73556">and connect</st>**<st
    c="73567">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.27 – Setting up Snyk code extension authentication](img/B19710_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="73996">Figure 4.27 – Setting up Snyk code extension authentication</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74055">Clicking</st> **<st c="74065">Trust workspace and connect</st>**
    <st c="74092">will take</st> <st c="74103">you to the Snyk web application</st>
    <st c="74134">for authentication.</st> <st c="74155">Click</st> **<st c="74161">Authenticate</st>**<st
    c="74173">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.28 – Snyk web application authentication](img/B19710_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="74326">Figure 4.28 – Snyk web application authentication</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74375">After successful authentication, you will receive the confirmation
    as follows.</st> <st c="74455">Close the browser and go back to Visual</st> <st
    c="74495">Studio Code:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Snyk successful authentication](img/B19710_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="74589">Figure 4.29 – Snyk successful authentication</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74633">We can now</st> <st c="74644">proceed to</st> *<st c="74656">Task
    3</st>* <st c="74662">after successfully configuring</st> <st c="74694">the</st>
    <st c="74698">Snyk extension.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74713">Visual Studio Code extension authentication</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74757">Please note, if the above steps cannot successfully configure
    your Synk extension, you may need to manually set the token by</st> <st c="74883">following
    these:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[<st c="74899">https://docs.snyk.io/scm-ide-and-ci-cd-integrations/snyk-ide-plugins-and-extensions/visual-studio-code-extension/visual-studio-code-extension-authentication</st>](https://docs.snyk.io/scm-ide-and-ci-cd-integrations/snyk-ide-plugins-and-extensions/visual-studio-code-extension/visual-studio-code-extension-authentication)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[<st c="75056">https://docs.snyk.io/getting-started/how-to-obtain-and-authenticate-with-your-snyk-api-token</st>](https://docs.snyk.io/getting-started/how-to-obtain-and-authenticate-with-your-snyk-api-token)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="75149">Task 3 – Importing eShopOnWeb to your Visual Studio Code workspace</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="75216">In this task, we will</st> <st c="75239">import the application
    we will be working on</st> <st c="75284">going forward:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75298">We will be</st> <st c="75309">reviewing</st> `<st c="75320">eShopOnWeb</st>`
    <st c="75330">application for security vulnerabilities in your Visual Studio Code
    editor.</st> <st c="75407">Navigate to</st> **<st c="75419">EXPLORER</st>** <st
    c="75427">on the left pane of your Visual Studio Code editor and click on</st>
    **<st c="75492">Clone Repository</st>**<st c="75508">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.30 – Clone Repository](img/B19710_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="75838">Figure 4.30 – Clone Repository</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75868">Paste</st> <st c="75875">the</st> `<st c="75879">eShopOnWeb</st>`
    <st c="75889">repository (</st>[<st c="75902">https://github.com/PacktPublishing/eShopOnWeb_DevSecOps</st>](https://github.com/PacktPublishing/eShopOnWeb_DevSecOps)<st
    c="75958">) to clone from GitHub, then select the</st> **<st c="75999">Clone from
    URL</st>** **<st c="76014">https://github.com/PacktPublishing/eShopOnWeb_DevSecOps</st>**
    <st c="76069">option:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.31 – Clone from GitHub](img/B19710_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="76209">Figure 4.31 – Clone from GitHub</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76240">You will be</st> <st c="76252">required to select a folder as
    the repository destination.</st> <st c="76312">Click</st> `<st c="76346">eShop</st>`<st
    c="76351">, and then click</st> **<st c="76368">Select as</st>** **<st c="76378">Repository
    Destination</st>**<st c="76400">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.32 – Selecting a folder as the repository destination](img/B19710_04_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="76702">Figure 4.32 – Selecting a folder as the repository destination</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76764">A popup</st> <st c="76772">will</st> <st c="76778">appear on the
    bottom-right corner of Visual Studio Code showing the status of the cloning.</st>
    <st c="76869">After completion, you will be asked to open the cloned repository;</st>
    <st c="76936">click</st> **<st c="76942">Open</st>**<st c="76946">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.33 – Opening cloned repository](img/B19710_04_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="77055">Figure 4.33 – Opening cloned repository</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77094">You will be asked if you trust the authors of the files in the
    folder.</st> <st c="77166">Select</st> **<st c="77173">Yes, I trust</st>** **<st
    c="77186">the authors</st>**<st c="77197">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.34 – Trusting the authors of files](img/B19710_04_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="77601">Figure 4.34 – Trusting the authors of files</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77644">Snyk will</st> <st c="77655">then</st> <st c="77659">send a notification
    (in the bottom-right corner of Visual Studio Code) asking</st> **<st c="77738">Trust
    folders and continue</st>** <st c="77764">or</st> **<st c="77768">Don’t trust
    folders</st>**<st c="77787">. Select</st> **<st c="77796">Trust folders</st>**
    **<st c="77810">and continue</st>**<st c="77822">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="77823">Snyk will then start analyzing the files and give the number of
    security issues in the bottom-left corner of your Visual Studio</st> <st c="77952">Code
    editor:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.35 – Snyk showing the number of security issues](img/B19710_04_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="78003">Figure 4.35 – Snyk showing the number of security issues</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78059">Click on the number of problems; this will then show the details
    of security vulnerabilities found</st> <st c="78159">by Snyk:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.36 – List of security issues found on eShop](img/B19710_04_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="79438">Figure 4.36 – List of security issues found on eShop</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79490">Go through</st> <st c="79502">the</st> <st c="79506">list of code
    security, configuration, and code quality issues to understand some of the</st>
    <st c="79594">issues found:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.37 – Code security, configuration, and code quality on eShop](img/B19710_04_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="80738">Figure 4.37 – Code security, configuration, and code quality on
    eShop</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80807">Review the list of errors generated for code security, configuration,
    and code quality.</st> <st c="80896">Select one code security error to understand
    details about the vulnerability, the line of code that is vulnerable, and suggestions
    to fix</st> <st c="81034">the vulnerabilities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81054">Hands-on exercise 2 – Installing and configuring Git pre-commit
    hooks on the IDE</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="81135">In this exercise, we</st> <st c="81157">will install and configure
    Git pre-commit hooks.</st> <st c="81206">As we discussed earlier, a pre-commit
    hook is a specific type of Git hook that is triggered right before a commit is
    recorded.</st> <st c="81333">We will be using the pre-commit framework (</st>[<st
    c="81376">https://pre-commit.com</st>](https://pre-commit.com)<st c="81399">).</st>
    <st c="81403">The</st> <st c="81407">pre-commit framework allows developers to
    leverage a wide array</st> <st c="81471">of existing hooks and easily integrate
    them into their repositories.</st> <st c="81540">A list of supported hooks can
    be found here:</st> [<st c="81585">https://pre-commit.com/hooks.html</st>](https://pre-commit.com/hooks.html)<st
    c="81618">. The hooks are defined in a</st> `<st c="81647">.pre-commit-config.yaml</st>`
    <st c="81670">file, and the tool takes care of installing them into the appropriate
    Git</st> <st c="81745">hooks directory.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81761">Following are the tasks that we will complete in</st> <st c="81811">this
    exercise:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="81825">Task 1</st>**<st c="81832">: Installing pre-commit framework
    on Visual</st> <st c="81877">Studio Code</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="81910">detect-private key</st>` <st c="81928">and</st> `<st c="81933">detect-secrets</st>`
    <st c="81947">pre-commit hooks on Visual</st> <st c="81975">Studio Code</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="81986">Task 1 – Installing pre-commit framework on Visual Studio Code</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="82049">In this task, we</st> <st c="82067">will set up a</st> <st c="82081">pre-commit
    framework tool within Visual</st> <st c="82121">Studio Code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="82133">Install the pre-commit package manager using</st> `<st c="82179">pip</st>`<st
    c="82182">. Run the following command on your Visual</st> <st c="82225">Studio
    terminal:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 4.38 – Pre-commit version installed](img/B19710_04_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="82455">Figure 4.38 – Pre-commit version installed</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="82497">Task 2 – Configuring detect-private key and detect-secrets pre-commit
    hooks on Visual Studio Code</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="82595">In this task, we</st> <st c="82613">will configure two pre-commit
    hooks.</st> <st c="82650">Review</st> <st c="82657">the list of</st> <st c="82669">supported
    hooks on</st> [<st c="82688">https://pre-commit.com/hooks.html</st>](https://pre-commit.com/hooks.html)<st
    c="82721">. You can configure more than one hook in the</st> `<st c="82767">.pre-commit-config.yaml</st>`
    <st c="82790">file.</st> <st c="82797">In this task, we will be configuring the</st>
    `<st c="82838">detect-private-key</st>` <st c="82856">from</st> [<st c="82862">https://github.com/pre-commit/pre-commit-hooks</st>](https://github.com/pre-commit/pre-commit-hooks)
    <st c="82908">and</st> `<st c="82913">detect-secrets</st>` <st c="82927">from</st>
    [<st c="82933">github.com/Yelp/detect-secrets</st>](http://github.com/Yelp/detect-secrets)<st
    c="82963">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="82965">Create a file within the root directory of the</st> `<st c="83012">eShoponWeb</st>`
    <st c="83022">application and name</st> <st c="83044">it</st> `<st c="83047">.pre-commit-config.yaml</st>`<st
    c="83070">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="83071">Add the following script in the</st> `<st c="83104">.</st>``<st
    c="83105">pre-commit-config.yaml</st>` <st c="83128">file:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.39 – Configuring pre-commit hooks](img/B19710_04_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="83343">Figure 4.39 – Configuring pre-commit hooks</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83385">Let’s now install the Git hook scripts by running</st> `<st c="83436">pre-commit
    install</st>`<st c="83454">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.40 – Installing Git hook scripts](img/B19710_04_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="83568">Figure 4.40 – Installing Git hook scripts</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83609">We will now run the hooks against all files available in the</st>
    `<st c="83671">eShoponWeb</st>` <st c="83681">directory:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.41 – Running Git hooks against all files](img/B19710_04_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="84601">Figure 4.41 – Running Git hooks against all files</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84650">We see that</st> <st c="84662">both pre-commit hooks failed becaus</st><st
    c="84698">e a private key was detected, and secrets were found in several locations
    listed.</st> <st c="84781">It is best practice to fix errors and then commit</st>
    <st c="84831">the changes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84843">Since we have configured these two pre-commit hooks, this will
    prevent commits from happening if there are any private keys</st> <st c="84968">and
    secrets.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84980">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="84988">In this chapter, we examined two primary security concerns for
    this development phase.</st> <st c="85076">First, we looked at ensuring a secure
    development environment or workspace.</st> <st c="85152">This means making sure
    that tools and platforms where coding occurs, such as IDEs, are safe from vulnerabilities.</st>
    <st c="85266">We also touched on the risks of malicious IDE extensions and the
    challenges when dealing with untrusted code.</st> <st c="85376">We highlighted
    the need for measures to counteract any potential IDE breaches.</st> <st c="85455">Second,
    we tackled common coding errors that can lead to security issues.</st> <st c="85529">We
    introduced tools such as secret scanning to detect exposed sensitive data, SAST
    to find code vulnerabilities, and SCA to check third-party components for security
    risks.</st> <st c="85702">With this knowledge, you’re now better equipped to handle
    security challenges before committing code in the DevOps process.</st> <st c="85826">Up
    to this point in the book, our DevSecOps discussion has not focused on Azure.</st>
    <st c="85907">That is because there has not been much Azure-specific content to
    discuss up to the pre-commit stage.</st> <st c="86009">This will change in the
    next chapter, where we will discuss the integration of security in source control,
    with an Azure tooling focus.</st> <st c="86145">See</st> <st c="86149">you there!</st>
  prefs: []
  type: TYPE_NORMAL
