- en: <st c="0">4</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">4</st>
- en: <st c="2">Implementing Pre-commit Security Controls</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">实施预提交安全控制</st>
- en: <st c="43">After the initial planning phase, the application development process
    shifts to the code development phase, which starts on developer systems or workspaces.</st>
    <st c="201">Developers, while skilled in feature development and using coding
    languages, might not know or might overlook security details, leading to mistakes.</st>
    <st c="350">If not detected and addressed early, these mistakes can lead to unintentional
    vulnerabilities that can potentially compromise that software or the data</st>
    <st c="502">it processes.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43">在初步规划阶段之后，应用程序开发过程转向代码开发阶段，这一阶段开始于开发者的系统或工作空间。</st> <st c="201">开发者虽然擅长功能开发和使用编程语言，但可能不知道或忽视了安全细节，导致出现错误。</st>
    <st c="350">如果这些错误没有早期发现并解决，可能会导致无意的漏洞，从而可能危及软件或它处理的数据</st> <st c="502">安全。</st>
- en: <st c="515">Additionally, if the development environment/workspace is poorly
    managed and maintained, it could result in an entry point for attackers to inject
    malicious code or components into</st> <st c="697">the software.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="515">此外，如果开发环境/工作空间管理不当，可能会导致攻击者注入恶意代码或组件，成为</st> <st c="697">软件的入口点。</st>
- en: <st c="710">In this chapter, we will focus on security measures and checks that
    can be implemented before code changes are committed</st> <st c="832">to a</st>
    **<st c="837">version control system</st>** <st c="859">(</st>**<st c="861">VCS</st>**<st
    c="864">) by developers.</st> <st c="882">This includes implementing security
    controls to reduce development environment risks and setting up security safeguards
    to identify and fix vulnerabilities and common mistakes before code is committed
    to the local code repository.</st> <st c="1113">By the end of this chapter, you
    will have gained a solid understanding of the following</st> <st c="1201">key
    areas:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="710">在本章中，我们将重点介绍可以在代码更改提交</st> <st c="832">到</st> **<st c="837">版本控制系统</st>**
    <st c="859">(</st>**<st c="861">VCS</st>**<st c="864">)之前实施的安全措施和检查。</st> <st
    c="882">这包括实施安全控制，以减少开发环境的风险，并设置安全保护措施，在代码提交到本地代码仓库之前，识别和修复漏洞及常见错误。</st> <st c="1113">本章结束时，你将全面理解以下</st>
    <st c="1201">关键领域：</st>
- en: <st c="1211">Approaches to maintaining a secure</st> <st c="1247">development
    environment/workspace</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1211">保持安全的</st> <st c="1247">开发环境/工作空间</st>
- en: <st c="1280">Techniques to prevent the inclusion of sensitive files or secrets</st>
    <st c="1347">in code</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1280">防止敏感文件或密钥泄露到代码中的技术</st> <st c="1347">方法</st>
- en: <st c="1354">Use of security extensions in IDEs for real-time</st> <st c="1404">security
    feedback</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1354">在 IDE 中使用安全扩展以获取实时</st> <st c="1404">安全反馈</st>
- en: <st c="1421">Implementing pre-commit checks to ensure code safety before committing
    to the</st> <st c="1500">local repository</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1421">实施预提交检查，以确保在提交到</st> <st c="1500">本地仓库</st> <st c="515">之前代码的安全性。</st>
- en: <st c="1516">These topics will equip you with the necessary knowledge and skills
    to integrate security practices into the code development phase of a DevOps workflow.</st>
    <st c="1671">Let’s</st> <st c="1677">dive in!</st>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1516">这些主题将为你提供必要的知识和技能，以便将安全实践融入到 DevOps 工作流的代码开发阶段。</st> <st c="1671">让我们</st>
    <st c="1677">深入了解！</st>
- en: <st c="1685">Technical requirements</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1685">技术要求</st>
- en: <st c="1708">To follow along with the instructions in this chapter, you will
    need</st> <st c="1778">the following:</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1708">要跟随本章中的指示，你需要</st> <st c="1778">以下内容：</st>
- en: <st c="1792">A PC with an</st> <st c="1806">internet connection</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1792">一台带有</st> <st c="1806">互联网连接的 PC</st>
- en: <st c="1825">An active</st> <st c="1836">Azure subscription</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1825">一个有效的</st> <st c="1836">Azure 订阅</st>
- en: <st c="1854">An Azure</st> <st c="1864">DevOps organization</st>
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1854">一个 Azure</st> <st c="1864">DevOps 组织</st>
- en: <st c="1883">A GitHub</st> <st c="1893">Enterprise organization</st>
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1883">一个 GitHub</st> <st c="1893">企业组织</st>
- en: <st c="1916">Overview of the pre-commit coding phase of DevOps</st>
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1916">DevOps 预提交编码阶段概述</st>
- en: <st c="1966">In the</st> *<st c="1974">Understanding the stages in a DevOps
    workflow</st>* <st c="2019">section from</st> [*<st c="2033">Chapter 1</st>*](B19710_01.xhtml#_idTextAnchor016)<st
    c="2042">,</st> *<st c="2044">Agile, DevOps, and Azure Overview</st>*<st c="2077">,
    we outlined the eight stages of a standard DevOps workflow.</st> <st c="2139">While
    the implementation of these stages can differ among organizations, and some stages
    might even be combined for efficiency, the general sequence</st> <st c="2287">remains
    consistent.</st> <st c="2308">After the planning phase, the process moves to the
    code development stage, which begins with the developer environment.</st> <st
    c="2428">To make our discussion in this book clearer and more structured, we have
    split the code development stage into</st> <st c="2539">two parts:</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1966">在</st> *<st c="1974">理解 DevOps 工作流中的各个阶段</st>* <st c="2019">这一章节中</st>
    [*<st c="2033">第 1 章</st>*](B19710_01.xhtml#_idTextAnchor016)<st c="2042">,</st>
    *<st c="2044">敏捷、DevOps 和 Azure 概述</st>*<st c="2077">，我们概述了标准 DevOps 工作流的八个阶段。</st>
    <st c="2139">尽管这些阶段的实施在不同组织之间可能有所不同，一些阶段甚至可能为了效率而合并，但总体顺序</st> <st c="2287">保持一致。</st>
    <st c="2308">在规划阶段之后，过程进入代码开发阶段，从开发者环境开始。</st> <st c="2428">为了使本书中的讨论更加清晰和结构化，我们将代码开发阶段分为</st>
    <st c="2539">两部分：</st>
- en: '`<st c="3079">git add</st>` <st c="3086">operation, signaling that these changes
    are ready to be saved or committed (</st>*<st c="3163">step 2</st>* <st c="3170">of</st>
    *<st c="3174">Figure 4</st>**<st c="3182">.1</st>*<st c="3184">).</st> <st c="3188">The
    developer then proceeds to save the staged changes to their local repository using
    the</st> `<st c="3279">git commit</st>` <st c="3289">operation (</st>*<st c="3301">step
    3</st>* <st c="3308">of</st> *<st c="3312">Figure 4</st>**<st c="3320">.1</st>*<st
    c="3322">).</st> <st c="3326">This not only stores the changes but also logs a
    record of the modifications.</st> <st c="3404">It is worth noting that most times,
    staging and committing are done as a single operation</st> <st c="3494">for convenience.</st>'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="3079">git add</st>` <st c="3086">操作，表示这些更改已经准备好保存或提交（</st>*<st c="3163">步骤
    2</st>* <st c="3170">在</st> *<st c="3174">图 4</st>**<st c="3182">.1</st>*<st c="3184">）。</st>
    <st c="3188">开发者接着使用</st> `<st c="3279">git commit</st>` <st c="3289">操作将暂存的更改保存到本地代码库（</st>*<st
    c="3301">步骤 3</st>* <st c="3308">在</st> *<st c="3312">图 4</st>**<st c="3320">.1</st>*<st
    c="3322">）。</st> <st c="3326">这不仅存储了更改，还记录了修改的日志。</st> <st c="3404">值得注意的是，大多数情况下，暂存和提交作为单一操作完成</st>
    <st c="3494">以提高效率。</st>'
- en: '`<st c="3692">git push</st>` <st c="3700">operation.</st> <st c="3712">This
    phase is all about managing the code in that</st> <st c="3762">central repository:</st>'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="3692">git push</st>` <st c="3700">操作。</st> <st c="3712">这一阶段专注于管理代码在该</st>
    <st c="3762">中央代码库中的状态：</st>'
- en: '![Figure 4.1 – The code development phase of DevOps](img/B19710_04_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – DevOps 代码开发阶段](img/B19710_04_01.jpg)'
- en: <st c="3974">Figure 4.1 – The code development phase of DevOps</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3974">图 4.1 – DevOps 代码开发阶段</st>
- en: <st c="4023">Given that our primary attention in this chapter is on the</st>
    *<st c="4083">pre-commit phase</st>*<st c="4099">, it is essential to get some
    understanding of the developer environment where the activities occur.</st> <st
    c="4200">The choice of development environment plays a pivotal role in how security
    is implemented during this phase.</st> <st c="4309">Let us take a closer look
    at the available development environment options before we discuss their implications</st>
    <st c="4421">for security.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4023">鉴于本章的主要关注点是</st> *<st c="4083">预提交阶段</st>*<st c="4099">，理解活动发生的开发者环境非常重要。</st>
    <st c="4200">开发环境的选择在这一阶段如何实现安全性起着至关重要的作用。</st> <st c="4309">在我们讨论其对安全性的影响之前，先来仔细看看可用的开发环境选项。</st>
    <st c="4421">以便更好地了解其安全性影响。</st>
- en: <st c="4434">Note</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4434">注意</st>
- en: <st c="4439">Our aim is not to extensively cover developer environments and
    tooling but to provide a broad overview of the options available.</st> <st c="4569">We
    believe it is beneficial for those overseeing the security of DevOps practices
    to understand these options and their associated</st> <st c="4700">security risks.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4439">我们的目标不是全面介绍开发者环境和工具，而是提供一个可用选项的广泛概述。</st> <st c="4569">我们认为，对于负责
    DevOps 实践安全性的人来说，了解这些选项及其相关</st> <st c="4700">安全风险是有益的。</st>
- en: <st c="4715">Understanding the developer environment options</st>
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="4715">理解开发者环境选项</st>
- en: <st c="4763">Traditionally, developers</st> <st c="4790">use a local workstation
    as their development environment.</st> <st c="4848">Depending on the organization
    device setup process, this may or may not come with essential tools for coding
    and contributing to a project, such as Git for source control, the required language
    SDKs, and an IDE such as Visual Studio or Visual Studio Code.</st> <st c="5104">Additionally,
    many extensions and tools, including AI ones such as GitHub Copilot, are</st>
    <st c="5191">commonly added.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4763">传统上，开发人员</st> <st c="4790">使用本地工作站作为开发环境。</st> <st c="4848">根据组织设备设置过程的不同，这可能包含或不包含编码和参与项目所需的基本工具，如用于源代码管理的Git、所需语言的SDK，以及像Visual
    Studio或Visual Studio Code这样的IDE。</st> <st c="5104">此外，许多扩展和工具，包括像GitHub Copilot这样的AI工具，</st>
    <st c="5191">通常会被添加。</st>
- en: <st c="5206">Using a local workstation for development has several drawbacks,
    the primary one being the delay in reaching a productive state.</st> <st c="5336">Setting
    up the environment with all required installations, such as the IDE, SDKs, extensions,
    and libraries, can be time-consuming.</st> <st c="5469">It might take hours, days,
    or even longer for a developer to become productive after joining a project.</st>
    <st c="5573">As an example, in a recent discussion I (David) had with an engineering
    lead, they shared that it typically takes a month for a developer to submit their
    first PR after joining a project in</st> <st c="5763">their organization!</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5206">使用本地工作站进行开发有几个缺点，主要的问题是进入高效状态的延迟。</st> <st c="5336">设置环境并安装所有必需的软件，如IDE、SDK、扩展和库，可能需要耗费大量时间。</st>
    <st c="5469">开发人员加入项目后，可能需要数小时、数天，甚至更长时间才能开始高效工作。</st> <st c="5573">举个例子，我（David）最近与一位工程负责人讨论时，他们分享道，开发人员加入项目后通常需要一个月才能提交第一次PR，</st>
    <st c="5763">这在他们的组织中是常态！</st>
- en: <st c="5782">Another downside of the local workstation is that if the system
    crashes or needs replacement, the entire setup process typically has to be repeated.</st>
    <st c="5932">This can be avoided if there is a continuous backup, but most workstations
    do not have one.</st> <st c="6024">Another challenge is for developers who are
    juggling multiple projects.</st> <st c="6096">In medium to large organizations,
    it is uncommon for developers to focus solely on one project.</st> <st c="6192">They
    often work across different projects or contribute to several simultaneously.</st>
    <st c="6275">Sometimes, the tools needed for one project might conflict with another,
    making it difficult for a developer to transition smoothly from one project to
    another.</st> <st c="6436">Another issue arises from the limited computational
    resources of local workstations when working with large projects such</st> <st
    c="6558">as</st> **<st c="6561">machine learning</st>** <st c="6577">(</st>**<st
    c="6579">ML</st>**<st c="6581">) models or complex</st> <st c="6602">monolithic
    applications.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5782">本地工作站的另一个缺点是，如果系统崩溃或需要更换，整个设置过程通常需要重新开始。</st> <st c="5932">如果有持续的备份，可以避免这种情况，但大多数工作站并没有备份。</st>
    <st c="6024">另一个挑战是，开发人员需要同时处理多个项目。</st> <st c="6096">在中型到大型组织中，开发人员通常不会仅专注于一个项目。</st>
    <st c="6192">他们往往需要跨多个项目工作，或者同时为几个项目做贡献。</st> <st c="6275">有时，一个项目所需的工具可能与另一个项目发生冲突，导致开发人员难以顺利从一个项目过渡到另一个项目。</st>
    <st c="6436">另一个问题是，在处理大型项目时，本地工作站的计算资源有限，例如</st> <st c="6558">像</st> **<st c="6561">机器学习</st>**
    <st c="6577">(</st>**<st c="6579">ML</st>**<st c="6581">)模型或复杂的</st> <st c="6602">单体应用程序。</st>
- en: <st c="6626">From a security perspective, local developer workstations are often
    connected to a company’s internal network either directly or through VPNs.</st>
    <st c="6770">If these computers get breached, the threat is not just about an
    attacker getting the source code; it also opens up the possibility to move sideways
    within the network to access other systems and data.</st> <st c="6972">This lateral
    movement can lead to broader breaches and more</st> <st c="7032">significant damage.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6626">从安全角度来看，本地开发工作站通常通过VPN或直接连接到公司的内部网络。</st> <st c="6770">如果这些计算机遭到入侵，威胁不仅仅是攻击者获取源代码；它还可能使攻击者能够在网络中横向移动，从而访问其他系统和数据。</st>
    <st c="6972">这种横向移动可能导致更广泛的泄露和更</st> <st c="7032">严重的损害。</st>
- en: <st c="7051">To address these challenges, organizations are exploring modern
    development environment options such as</st> <st c="7156">the following:</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7051">为了解决这些挑战，组织正在探索现代开发环境选项，例如</st> <st c="7156">以下几种：</st>
- en: '**<st c="7170">Cloud-hosted development workstations</st>**<st c="7208">: Examples
    include</st> **<st c="7228">Platform as a Service</st>** <st c="7249">(</st>**<st
    c="7251">PaaS</st>**<st c="7255">) solutions</st> <st c="7267">such as</st> **<st
    c="7276">Azure Virtual Desktop</st>** <st c="7297">(</st>**<st c="7299">AVD</st>**<st
    c="7302">) or</st> **<st c="7308">Software as a Service</st>** <st c="7329">(</st>**<st
    c="7331">SaaS</st>**<st c="7335">) offerings such as Azure’s</st> **<st c="7364">Dev
    Box</st>**<st c="7371">. Dev Box is a</st> <st c="7386">cloud workstation</st>
    <st c="7404">designed for developers.</st> <st c="7429">It gives them quick access
    to</st> <st c="7459">powerful computers that are ready for coding.</st> <st c="7505">These
    workstations are set up by development</st> <st c="7549">teams with the tools
    they need.</st> <st c="7582">IT teams</st> <st c="7590">can manage these cloud
    workstations similarly to regular laptops.</st> <st c="7657">They can implement
    security hardening, deploy tools, audit, and maintain the environment using automation
    to minimize the risk of data loss.</st> <st c="7798">Developers also like it because
    they can transition between different Dev Box workstations that are provisioned
    for each project, plus they can save costs by putting the workstations in a low-power
    hibernation mode when not</st> <st c="8022">in use.</st>'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7170">云端开发工作站</st>**<st c="7208">：例如，</st> **<st c="7228">平台即服务（PaaS）</st>**
    <st c="7249">(</st>**<st c="7251">PaaS</st>**<st c="7255">)解决方案，如</st> **<st c="7276">Azure虚拟桌面</st>**
    <st c="7297">(</st>**<st c="7299">AVD</st>**<st c="7302">) 或</st> **<st c="7308">软件即服务（SaaS）</st>**
    <st c="7329">(</st>**<st c="7331">SaaS</st>**<st c="7335">)产品，如Azure的</st> **<st
    c="7364">Dev Box</st>**<st c="7371">。Dev Box是为开发者设计的</st> <st c="7386">云端工作站。</st>
    <st c="7404">它为开发者提供了快速访问</st> <st c="7459">强大计算机的能力，这些计算机已经准备好用于编码。</st> <st
    c="7505">这些工作站由开发团队设置，配备了他们需要的工具。</st> <st c="7549">IT团队可以像管理常规笔记本一样管理这些云端工作站。</st>
    <st c="7582">他们可以实施安全加固，部署工具，审计，并通过自动化维护环境，最大限度地减少数据丢失的风险。</st> <st c="7798">开发者也喜欢它，因为他们可以在不同的Dev
    Box工作站之间切换，每个工作站都为各自的项目提供了资源，并且他们可以通过将工作站置于低功耗休眠模式来节省成本，</st> <st c="8022">当工作站未使用时。</st>'
- en: '**<st c="8029">Cloud-hosted IDEs</st>**<st c="8047">: Recently, cloud IDEs</st>
    <st c="8070">have become a favored choice for code development.</st> <st c="8122">They
    offer developers the ability to write, run, and debug code directly from a web
    browser without the need for a local development environment.</st> <st c="8268">The
    most</st> <st c="8277">common ones are GitHub Codespaces,</st> **<st c="8312">Amazon
    Web Services</st>** <st c="8331">(</st>**<st c="8333">AWS</st>**<st c="8336">)
    Cloud9, Gitpod, Codeanywhere, and</st> <st c="8373">Eclipse Che.</st>'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8029">云端集成开发环境（IDE）</st>**<st c="8047">：最近，云端IDE</st> <st c="8070">已成为代码开发的热门选择。</st>
    <st c="8122">它们使开发者能够直接从网页浏览器中编写、运行和调试代码，无需本地开发环境。</st> <st c="8268">最常见的云端IDE有GitHub
    Codespaces、</st> <st c="8277">**亚马逊网络服务（AWS）**</st> <st c="8312">Cloud9、Gitpod、Codeanywhere，以及</st>
    <st c="8331">Eclipse Che。</st>'
- en: <st c="8385">Cloud IDEs address many challenges of local workstations.</st>
    <st c="8444">They significantly reduce</st> **<st c="8470">time to productivity</st>**
    <st c="8490">(</st>**<st c="8492">TTP</st>**<st c="8495">) so</st> <st c="8500">that
    developers can start coding in mere minutes after joining a project instead of
    waiting hours or days for tool installations.</st> <st c="8631">For resource-intensive
    projects, cloud IDEs, such as GitHub Codespaces, can scale up to 32 CPU cores
    and 64 GB RAM.</st> <st c="8747">That is a lot of power!</st> <st c="8771">Additionally,
    when working on multiple projects, developers can maintain a separate workspace
    for each project, ensuring no tool</st> <st c="8900">conflicts arise.</st>
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="8385">云端IDE解决了许多本地工作站面临的挑战。</st> <st c="8444">它们显著缩短了</st> **<st c="8470">生产力提升时间</st>**
    <st c="8490">(</st>**<st c="8492">TTP</st>**<st c="8495">)，让开发者在加入项目后几分钟内就能开始编写代码，而不是等待数小时或数天来安装工具。</st>
    <st c="8631">对于资源密集型项目，云端IDE（如GitHub Codespaces）可以扩展到32个CPU核心和64GB的内存。</st> <st
    c="8747">这非常强大！</st> <st c="8771">此外，当开发者在多个项目中工作时，他们可以为每个项目维护一个独立的工作区，从而避免工具</st>
    <st c="8900">之间的冲突。</st>
- en: '*<st c="8916">Figure 4</st>**<st c="8925">.2</st>* <st c="8927">shows the architecture
    of a GitHub Codespace cloud IDE.</st> <st c="8984">As shown, the codespace is
    hosted in a container running on a Linux</st> **<st c="9052">virtual machine</st>**
    <st c="9067">(</st>**<st c="9069">VM</st>**<st c="9071">) in</st> <st c="9076">Azure.</st>
    <st c="9084">We can choose our preferred editor to connect to it.</st> <st c="9137">While
    we can code directly in the web browser, there is also the option to connect using
    various desktop IDEs, including Visual</st> <st c="9265">Studio Code:</st>'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="8916">图 4</st>**<st c="8925">.2</st>* <st c="8927">展示了 GitHub Codespace
    云 IDE 的架构。</st> <st c="8984">如图所示，codespace 托管在运行 Linux 的容器中</st> **<st c="9052">虚拟机</st>**
    <st c="9067">（</st>**<st c="9069">VM</st>**<st c="9071">）在</st> <st c="9076">Azure
    上。</st> <st c="9084">我们可以选择我们喜欢的编辑器连接到它。</st> <st c="9137">虽然我们可以直接在 Web 浏览器中编码，但也可以选择使用各种桌面
    IDE，包括 Visual</st> <st c="9265">Studio Code：</st>'
- en: '![Figure 4.2 – GitHub codespace architecture](img/B19710_04_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – GitHub Codespace 架构](img/B19710_04_02.jpg)'
- en: <st c="9689">Figure 4.2 – GitHub codespace architecture</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9689">图 4.2 – GitHub Codespace 架构</st>
- en: '`<st c="10257">devcontainer.json</st>` <st c="10274">file.</st> <st c="10281">This
    file tells Visual Studio Code or GitHub Codespaces how to create (or access) a
    development container with a well-defined tool and runtime stack needed for</st>
    <st c="10441">the project.</st>'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="10257">devcontainer.json</st>` <st c="10274">文件。</st> <st c="10281">该文件告诉
    Visual Studio Code 或 GitHub Codespaces 如何创建（或访问）一个开发容器，其中包含项目所需的明确定义的工具和运行时堆栈。</st>'
- en: <st c="10453">The primary advantage of such a setup is the elimination of setup
    delays as developers can dive straight into coding without the hassles of setting
    up tools and dependencies.</st> <st c="10629">It also has the added benefit of
    environment consistency.</st> <st c="10687">When multiple developers collaborate
    on a project, this ensures that everyone contributes using a</st> <st c="10785">uniform
    environment.</st>
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10453">这种设置的主要优势在于消除设置延迟，开发人员可以直接开始编码，无需设置工具和依赖项。</st> <st c="10629">它还具有环境一致性的额外好处。</st>
    <st c="10687">当多个开发人员共同参与项目时，这确保了每个人都使用</st> <st c="10785">统一的环境。</st>
- en: <st c="10805">In</st> *<st c="10809">Figure 4</st>**<st c="10817">.3</st>*<st
    c="10819">, we show how a dev container works in Visual Studio Code.</st> <st
    c="10878">Basically, Visual Studio Code interprets the</st> `<st c="10923">devcontainer.json</st>`
    <st c="10940">file and creates a development container with a Visual Studio Code
    server.</st> <st c="11016">It then mounts the workspace files from the local PC
    or clones them into the container.</st> <st c="11104">Any</st> <st c="11108">extra
    extensions defined in the</st> `<st c="11140">devcontainer.json</st>` <st c="11157">file
    are installed inside the container.</st> <st c="11199">This setup lets developers
    easily switch between different project environments by just connecting to</st>
    <st c="11301">another project:</st>
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10805">在</st> *<st c="10809">图 4</st>**<st c="10817">.3</st>*<st c="10819">中，我们展示了
    Visual Studio Code 中开发容器的工作原理。</st> <st c="10878">基本上，Visual Studio Code 解析</st>
    `<st c="10923">devcontainer.json</st>` <st c="10940">文件，并创建一个带有 Visual Studio
    Code 服务器的开发容器。</st> <st c="11016">然后，它会将本地 PC 的工作区文件挂载到容器中，或者将它们克隆到容器中。</st> <st
    c="11104">在</st> <st c="11108">`devcontainer.json`</st> <st c="11157">文件中定义的任何额外扩展都会被安装到容器内。</st>
    <st c="11199">这种设置允许开发人员通过简单连接到</st> <st c="11301">另一个项目来轻松切换不同的项目环境：</st>
- en: '![Figure 4.3 – Dev container in Visual Studio Code architecture](img/B19710_04_03.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 – Visual Studio Code 中的开发容器架构](img/B19710_04_03.jpg)'
- en: <st c="11400">Figure 4.3 – Dev container in Visual Studio Code architecture</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11400">图 4.3 – Visual Studio Code 中的开发容器架构</st>
- en: <st c="11461">Having gained insight into the various development environment
    options available, it is essential to also understand the workflow of this stage.</st>
    <st c="11607">In this chapter, our primary emphasis is on pre-commit security,
    so let us explore</st> <st c="11690">this further.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11461">在了解了可用的各种开发环境选项之后，还需要了解这个阶段的工作流程。</st> <st c="11607">在本章中，我们主要关注预提交阶段的安全性，所以让我们进一步探讨</st>
    <st c="11690">这一点。</st>
- en: <st c="11703">Understanding the security categories in the pre-commit phase</st>
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="11703">理解预提交阶段中的安全类别</st>
- en: <st c="11765">There are two</st> <st c="11779">main security categories that
    we will address for this phase.</st> <st c="11842">The first focuses on effective
    security hygiene of the development environment or workspace where coding happens.</st>
    <st c="11956">The second aims to reduce common security errors developers often
    commit</st> <st c="12029">during coding:</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11765">我们将要讨论的</st> <st c="11779">此阶段的两个主要安全类别。</st> <st c="11842">第一个关注开发环境或编码工作空间的有效安全卫生。</st>
    <st c="11956">第二个旨在减少开发人员在编码过程中常犯的安全错误：</st>
- en: '![Figure 4.4 – Two main security categories in the pre-commit coding phase
    of DevOps](img/B19710_04_04.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – DevOps 提交前编码阶段的两个主要安全类别](img/B19710_04_04.jpg)'
- en: <st c="12136">Figure 4.4 – Two main security categories in the pre-commit coding
    phase of DevOps</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12136">图 4.4 – DevOps 提交前编码阶段的两个主要安全类别</st>
- en: <st c="12218">Let’s start by addressing the first risk category and security
    mitigations to put</st> <st c="12301">in place.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12218">让我们从处理第一个风险类别开始，并采取适当的安全措施。</st> <st c="12301">实施必要的安全措施。</st>
- en: <st c="12310">Securing the development environment</st>
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="12310">确保开发环境的安全</st>
- en: <st c="12347">Attackers</st> <st c="12358">are increasingly targeting developer
    tools and workspaces (IDEs, extensions, SDKs), regardless of whether they are
    running locally or cloud-based, with the intent of interfering with pre-commit
    phase activities.</st> <st c="12570">By compromising these, attackers can embed
    malicious code early in the software development process with the aim of impacting
    a broad number of</st> <st c="12714">downstream consumers.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12347">攻击者</st> <st c="12358">越来越多地针对开发者工具和工作空间（集成开发环境、扩展、SDK等），无论它们是本地运行还是基于云的，旨在干扰提交前阶段的活动。</st>
    <st c="12570">通过破坏这些工具，攻击者能够在软件开发过程的早期嵌入恶意代码，目的是影响大量的</st> <st c="12714">下游用户。</st>
- en: <st c="12735">But why even target activities in the pre-commit phase?</st> <st
    c="12792">Because it can sometimes allow them to bypass tighter security checks
    later in the process.</st> <st c="12884">Unfortunately, many organizations tend
    to trust code from their developers without further scrutiny.</st> <st c="12985">Attackers
    are looking to exploit this trust to sneak in undetected.</st> <st c="13053">A
    notable example is the Solorigate</st> <st c="13089">breach in 2019, where hackers
    discreetly added 4,000 lines of malicious code at an early stage, which allowed
    the code to be officially approved and digitally signed after the code was committed
    to</st> <st c="13287">the repository.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12735">但为什么要在提交前阶段针对活动进行防护？</st> <st c="12792">因为这有时可以让它们绕过后续更严格的安全检查。</st>
    <st c="12884">不幸的是，许多组织往往会在没有进一步审查的情况下信任开发人员提交的代码。</st> <st c="12985">攻击者正是利用这种信任，悄悄地将恶意代码潜入系统。</st>
    <st c="13053">一个显著的例子是2019年的Solorigate</st> <st c="13089">安全漏洞，黑客在早期阶段悄无声息地加入了4000行恶意代码，这使得该代码在提交到</st>
    <st c="13287">代码库后，得以通过官方批准并数字签名。</st>
- en: <st c="13302">The Solorigate breach</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13302">Solorigate漏洞</st>
- en: <st c="13324">For a detailed</st> <st c="13340">overview and timeline of the
    Solorigate breach, refer to this</st> <st c="13402">document:</st> [<st c="13412">https://www.microsoft.com/en-us/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/</st>](https://www.microsoft.com/en-us/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13324">有关Solorigate漏洞的详细</st> <st c="13340">概述和时间线，请参考此</st> <st c="13402">文档：</st>
    [<st c="13412">https://www.microsoft.com/en-us/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/</st>](https://www.microsoft.com/en-us/security/blog/2020/12/18/analyzing-solorigate-the-compromised-dll-file-that-started-a-sophisticated-cyberattack-and-how-microsoft-defender-helps-protect/)
- en: <st c="13597">Some may know this breach as Sunburst, which is the name of the
    malware that</st> <st c="13675">was injected.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13597">有些人可能知道这个漏洞作为Sunburst，这也是被</st> <st c="13675">注入的恶意软件的名称。</st>
- en: <st c="13688">And this is one of the mindset shifts that needs to happen as
    we adopt a DevOps workflow.</st> <st c="13779">Security measures need to be strong
    right from</st> <st c="13825">the early stages of the</st> **<st c="13850">software
    development life cycle</st>** <st c="13881">(</st>**<st c="13883">SDLC</st>**<st
    c="13887">).</st> <st c="13891">Trusting code just because it is from an internal
    source is risky.</st> <st c="13958">Implicit trust should never be given!</st>
    <st c="13996">As you mature in integrating security into your DevOps (DevSecOps),
    you need to ensure that code is only accepted after verifying the security of
    the developer’s environment and after the code itself undergoes a rigorous</st>
    <st c="14217">security review.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13688">这是我们采用 DevOps 工作流时必须发生的思维方式转变之一。</st> <st c="13779">安全措施需要从</st>
    <st c="13825">软件开发生命周期的早期阶段就开始强大</st> **<st c="13850">（SDLC）</st>** <st c="13881">。</st>**<st
    c="13883">SDLC</st>**<st c="13887">）。</st> <st c="13891">仅仅因为代码来自内部源，就信任它是很有风险的。</st>
    <st c="13958">不应给予隐性信任！</st> <st c="13996">随着你在将安全性融入 DevOps（DevSecOps）的过程中成熟，你需要确保在验证开发者环境的安全性，并且代码经过严格的</st>
    <st c="14217">安全审查后，才接收代码。</st>
- en: <st c="14233">Implicit trust should never be given because the code is from
    an internal source!</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14233">绝不应该因为代码来自内部源而给予隐性信任！</st>
- en: <st c="14315">Let us now turn our attention to understanding some of the entry
    points for attackers into the development environment and addressing</st> <st
    c="14450">those risks.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14315">现在，让我们将注意力转向理解一些攻击者进入开发环境的入口点，并解决</st> <st c="14450">这些风险。</st>
- en: <st c="14462">Risk 1 – IDE vulnerability risks</st>
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="14462">风险 1 – IDE 漏洞风险</st>
- en: <st c="14495">IDEs, as with other applications, can</st> <st c="14533">have
    security flaws.</st> <st c="14555">A</st> <st c="14556">notable example is</st>
    **<st c="14576">CVE-2022-41034</st>**<st c="14590">, a critical vulnerability
    in Visual Studio Code that could be exploited through a crafted link or website,
    to take over the workstation of a Visual Studio Code user!</st> <st c="14757">This
    vulnerability also impacted GitHub Codespaces, GitHub’s web-based editor (</st>[<st
    c="14836">https://github.dev</st>](https://github.dev)<st c="14855">), and</st>
    <st c="14863">Visual Studio Code for the</st> <st c="14890">web (</st>[<st c="14895">https://vscode.dev</st>](https://vscode.dev)<st
    c="14914">).</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14495">IDE，就像其他应用程序一样，可能</st> <st c="14533">存在安全漏洞。</st> <st c="14555">一个显著的例子是</st>
    **<st c="14576">CVE-2022-41034</st>**<st c="14590">，这是 Visual Studio Code 中的一个关键漏洞，攻击者可以通过构造的链接或网站利用该漏洞，接管
    Visual Studio Code 用户的工作站！</st> <st c="14757">此漏洞还影响了 GitHub Codespaces、GitHub
    的基于 Web 的编辑器（</st> [<st c="14836">https://github.dev</st>](https://github.dev)
    <st c="14855">），以及</st> <st c="14863">Visual Studio Code for the</st> <st c="14890">web（</st>
    [<st c="14895">https://vscode.dev</st>](https://vscode.dev) <st c="14914">）。</st>
- en: <st c="14917">If you think these issues are less common, you will be mistaken.</st>
    <st c="14983">Since January 2022, Visual Studio Code has reported at least six</st>
    **<st c="15048">remote code execution</st>** <st c="15069">(</st>**<st c="15071">RCE</st>**<st
    c="15074">) vulnerabilities!</st> <st c="15094">This is why it is vital to keep
    locally installed IDEs updated.</st> <st c="15158">Managed development</st> <st
    c="15178">platforms such as GitHub Codespaces handle security updates automatically,
    reducing our maintenance tasks.</st> <st c="15285">However, this does not cover
    plugins</st> <st c="15322">or extensions.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14917">如果你认为这些问题较少见，你会错的。</st> <st c="14983">自2022年1月以来，Visual Studio
    Code 已报告至少六个</st> **<st c="15048">远程代码执行</st>** <st c="15069">（</st>**<st c="15071">RCE</st>**<st
    c="15074">）漏洞！</st> <st c="15094">这就是为什么保持本地安装的 IDE 更新至关重要。</st> <st c="15158">像
    GitHub Codespaces 这样的托管开发平台会自动处理安全更新，从而减少我们的维护任务。</st> <st c="15285">然而，这并不涵盖插件</st>
    <st c="15322">或扩展。</st>
- en: <st c="15336">Visual Studio Code vulnerability lookup</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15336">Visual Studio Code 漏洞查询</st>
- en: <st c="15376">To</st> <st c="15379">explore a list of disclosed vulnerabilities
    for Visual Studio Code, go to the following</st> <st c="15468">link:</st> [<st
    c="15474">https://www.cvedetails.com/vulnerability-list/vendor_id-26/product_id-50646/Microsoft-Visual-Studio-Code.html</st>](https://www.cvedetails.com/vulnerability-list/vendor_id-26/product_id-50646/Microsoft-Visual-Studio-Code.html)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15376">要</st> <st c="15379">查看 Visual Studio Code 公布的漏洞列表，请访问以下</st>
    <st c="15468">链接：</st> [<st c="15474">https://www.cvedetails.com/vulnerability-list/vendor_id-26/product_id-50646/Microsoft-Visual-Studio-Code.html</st>](https://www.cvedetails.com/vulnerability-list/vendor_id-26/product_id-50646/Microsoft-Visual-Studio-Code.html)
- en: <st c="15583">For more information on CVE-2022041034, refer to this</st> **<st
    c="15638">National Institute of Standards and Technology</st>** <st c="15684">(</st>**<st
    c="15686">NIST</st>**<st c="15690">)</st> <st c="15693">link:</st> [<st c="15699">https://nvd.nist.gov/vuln/detail/CVE-2022-41034</st>](https://nvd.nist.gov/vuln/detail/CVE-2022-41034)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15583">有关 CVE-2022041034 的更多信息，请参考这个</st> **<st c="15638">国家标准与技术研究院</st>**
    <st c="15684">(</st>**<st c="15686">NIST</st>**<st c="15690">)</st> <st c="15693">链接：</st>
    [<st c="15699">https://nvd.nist.gov/vuln/detail/CVE-2022-41034</st>](https://nvd.nist.gov/vuln/detail/CVE-2022-41034)
- en: <st c="15746">On another note, using managed development environments such as
    GitHub Codespaces offers the added benefit of reduced lateral movement risk.</st>
    <st c="15888">By isolating each development environment in its own VM and network,
    Codespaces ensures tighter security.</st> <st c="15994">While it’s not foolproof
    against all threats, the potential for a breach to spread within the environment
    is</st> <st c="16103">significantly reduced!</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15746">另外，使用如 GitHub Codespaces 等托管开发环境带来的附加好处之一是可以减少横向移动的风险。</st> <st
    c="15888">通过将每个开发环境隔离在独立的虚拟机和网络中，Codespaces 确保了更严格的安全性。</st> <st c="15994">虽然它并不能完全防范所有威胁，但潜在的安全漏洞在环境内蔓延的风险</st>
    <st c="16103">大大降低！</st>
- en: <st c="16125">Risk 2 – Malicious and vulnerable IDE extensions</st>
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="16125">风险 2 – 恶意和存在漏洞的 IDE 扩展</st>
- en: <st c="16174">Visual Studio Code is a</st> <st c="16198">lightweight IDE that
    has a strong ecosystem of extensions for extensibility.</st> <st c="16276">Whatever
    task you aim to achieve in Visual Studio Code, there is likely an extension for
    it.</st> <st c="16369">As of September 2023, the</st> <st c="16395">Visual Studio
    Code Marketplace (</st>[<st c="16427">https://marketplace.visualstudio.com/vscode</st>](https://marketplace.visualstudio.com/vscode)<st
    c="16471">) has over</st> <st c="16483">51,000+ extensions!</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16174">Visual Studio Code 是一款</st> <st c="16198">轻量级 IDE，具有强大的扩展生态系统，支持可扩展性。</st>
    <st c="16276">无论你在 Visual Studio Code 中想要完成什么任务，可能都有相应的扩展。</st> <st c="16369">截至
    2023 年 9 月，</st> <st c="16395">Visual Studio Code 市场（</st>[<st c="16427">https://marketplace.visualstudio.com/vscode</st>](https://marketplace.visualstudio.com/vscode)<st
    c="16471">）已拥有超过</st> <st c="16483">51,000 多个扩展！</st>
- en: '![Figure 4.5 – The Visual Studio Code Marketplace](img/B19710_04_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – Visual Studio Code 市场](img/B19710_04_05.jpg)'
- en: <st c="17140">Figure 4.5 – The Visual Studio Code Marketplace</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17140">图 4.5 – Visual Studio Code 市场</st>
- en: <st c="17187">When it</st> <st c="17195">comes to extensions, trust is crucial!</st>
    <st c="17235">Extensions in Visual Studio Code operate with the same rights as
    the logged-in user.</st> <st c="17320">For many developers, this is the local
    administrator role.</st> <st c="17379">This means that a malicious extension has
    the potential to install additional applications (which could be malicious) and
    modify code locally or remotely.</st> <st c="17534">The impact of installing a
    malicious extension can</st> <st c="17585">be significant!</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17187">对于扩展来说，信任至关重要！</st> <st c="17195">Visual Studio Code 中的扩展以与登录用户相同的权限运行。</st>
    <st c="17235">对于许多开发人员来说，这就是本地管理员角色。</st> <st c="17320">这意味着恶意扩展有可能安装其他应用程序（可能是恶意的），并在本地或远程修改代码。</st>
    <st c="17534">安装恶意扩展的影响可能</st> <st c="17585">是巨大的！</st>
- en: <st c="17600">To help mitigate this risk, developers must be able to evaluate
    the trustworthiness of an extension so that they only install</st> <st c="17727">trusted
    extensions.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17600">为了帮助减轻这一风险，开发人员必须能够评估扩展的可信度，以确保他们只安装</st> <st c="17727">受信任的扩展。</st>
- en: <st c="17746">This is why developers must be able to evaluate the trustworthiness
    of an extension before installing it.</st> <st c="17853">To help with this, Microsoft
    implements several measures to ensure the safety of extensions in</st> <st c="17948">the
    marketplace:</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17746">因此，开发人员必须在安装扩展之前，能够评估其可信度。</st> <st c="17853">为此，微软实施了多项措施，以确保市场中扩展的安全性：</st>
- en: '![Figure 4.6 – Visual Studio Code Marketplace extension security measures](img/B19710_04_06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – Visual Studio Code 市场扩展安全措施](img/B19710_04_06.jpg)'
- en: <st c="18207">Figure 4.6 – Visual Studio Code Marketplace extension security
    measures</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18207">图 4.6 – Visual Studio Code 市场扩展安全措施</st>
- en: <st c="18278">Before</st> <st c="18286">publishing, extensions undergo a virus
    scan, followed by a check to prevent name squatting, for</st> *<st c="18382">official</st>*
    <st c="18390">publisher names (</st>*<st c="18408">Figure 4</st>**<st c="18417">.6</st>*<st
    c="18419">).</st> <st c="18423">After publishing, extensions are rescanned for
    viruses with every update by the publisher.</st> <st c="18514">If the community
    reports an extension as malicious, Microsoft evaluates it.</st> <st c="18590">If
    validated, the extension is removed from the marketplace and added to a</st> *<st
    c="18665">kill list</st>*<st c="18674">, prompting Visual Studio Code to auto-uninstall
    it whenever it is installed (</st>*<st c="18752">Figure 4</st>**<st c="18761">.6</st>*<st
    c="18763">).</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18278">在发布</st> <st c="18286">之前，扩展会经过病毒扫描，并进行检查以防止名称抢注，检查内容包括</st> *<st
    c="18382">官方</st>* <st c="18390">发布者名称（</st>*<st c="18408">图 4</st>**<st c="18417">.6</st>*<st
    c="18419">）。</st> <st c="18423">发布后，扩展会在每次发布者更新时重新进行病毒扫描。</st> <st c="18514">如果社区报告某个扩展为恶意扩展，微软会进行评估。</st>
    <st c="18590">如果验证通过，扩展将从市场中移除，并添加到</st> *<st c="18665">黑名单</st>*<st c="18674">，使得每次安装时，Visual
    Studio Code 会自动卸载它（</st>*<st c="18752">图 4</st>**<st c="18761">.6</st>*<st c="18763">）。</st>
- en: <st c="18766">While Microsoft’s safety measures are commendable, they are not
    foolproof.</st> <st c="18842">Many widely used extensions are created by community
    contributors who are not included in the name-squatting checks for official publishers.</st>
    <st c="18983">A real risk is the impersonation of popular extensions to trick
    developers into installing them.</st> <st c="19080">A case in point is research
    published by the team at Aqua Security.</st> <st c="19148">They created an impersonated
    version of Prettier, a popular Visual Studio Code extension with millions of installs,
    and were able to publish it to the marketplace.</st> <st c="19312">They named
    the URL of their version</st> `<st c="19348">pretier-vscode</st>` <st c="19362">(with
    a single</st> *<st c="19378">t</st>*<st c="19379">), subtly differing from the
    genuine</st> `<st c="19416">prettier-vscode</st>` <st c="19431">(with a double</st>
    *<st c="19447">t</st>*<st c="19448">) – see</st> *<st c="19456">Figure 4</st>**<st
    c="19464">.7</st>*<st c="19466">. Within 48 hours of publishing it, they had about
    a thousand installs from developers in multiple countries around</st> <st c="19582">the
    world!</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18766">虽然微软的安全措施值得称赞，但并非万无一失。</st> <st c="18842">许多广泛使用的扩展是由社区贡献者创建的，这些贡献者不包括在官方发布者的名称抢注检查中。</st>
    <st c="18983">一个真正的风险是仿冒流行扩展，诱使开发人员安装它们。</st> <st c="19080">例如，Aqua Security 团队发布的研究就是一个案例。</st>
    <st c="19148">他们创建了一个仿冒版本的 Prettier，这是一个受欢迎的 Visual Studio Code 扩展，拥有数百万次安装量，并成功发布到了市场。</st>
    <st c="19312">他们将自己版本的 URL 命名为</st> `<st c="19348">pretier-vscode</st>` <st c="19362">（只有一个</st>
    *<st c="19378">t</st>*<st c="19379">），与正版</st> `<st c="19416">prettier-vscode</st>`
    <st c="19431">（有两个</st> *<st c="19447">t</st>*<st c="19448">）微妙不同——见</st> *<st
    c="19456">图 4</st>**<st c="19464">.7</st>*<st c="19466">。发布后的 48 小时内，他们的版本就获得了来自多个国家约一千次开发者的安装。</st>
    <st c="19582">世界各地的开发者纷纷安装！</st>
- en: '![Figure 4.7 – Comparing the genuine extension and an impersonation of the
    extension in the marketplace](img/B19710_04_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 比较市场中正版扩展和仿冒扩展](img/B19710_04_07.jpg)'
- en: <st c="19804">Figure 4.7 – Comparing the genuine extension and an impersonation
    of the extension in the marketplace</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19804">图 4.7 – 比较市场中正版扩展和仿冒扩展</st>
- en: <st c="19905">Unfortunately, it</st> <st c="19924">may not be easy to enforce
    large-scale checks.</st> <st c="19971">Some organizations may block the installation
    of unallowed extensions on their corporate firewalls or on endpoint firewalls,
    but this could also lead to friction in situations where developers perceive it
    as impacting their productivity negatively.</st> <st c="20220">Also, using Codespaces
    allows a distinct list of approved extensions.</st> <st c="20290">However, there
    is no way to prevent someone from syncing or adding in other extensions unless
    there is a policy for Visual Studio Code extensions in an org, which comes with
    various</st> <st c="20472">other problems.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19905">不幸的是，</st> <st c="19924">大规模检查的执行可能并不容易。</st> <st c="19971">一些组织可能会在其企业防火墙或终端防火墙上阻止不允许的扩展安装，但这也可能在开发人员认为这会影响他们的工作效率时带来摩擦。</st>
    <st c="20220">此外，使用 Codespaces 可以有一个独立的批准扩展列表。</st> <st c="20290">然而，除非组织中有 Visual
    Studio Code 扩展的相关政策，否则没有办法防止某人同步或添加其他扩展，这会带来各种</st> <st c="20472">其他问题。</st>
- en: <st c="20487">Developers will need to be trained to be cautious before installing
    extensions.</st> <st c="20568">They should verify publisher details, read the
    reviews and ratings of the extension, and check the download count.</st> <st c="20683">But
    this puts a security responsibility on developers.</st> <st c="20738">Some practices,
    such as Workspace Trust, can help (we will cover this in the next section), but
    a better system to show and control extension permissions would be ideal.</st>
    <st c="20908">There’s been an ongoing discussion about this since</st> <st c="20960">2018!</st>
    <st c="20966">(</st>[<st c="20967">https://github.com/microsoft/vscode/issues/52116</st>](https://github.com/microsoft/vscode/issues/52116)<st
    c="21015">).</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20487">开发者在安装扩展之前需要接受培训，保持谨慎。</st> <st c="20568">他们应该验证发布者的详细信息，阅读扩展的评论和评分，并检查下载次数。</st>
    <st c="20683">但是，这将把安全责任交给开发者。</st> <st c="20738">一些实践方法，例如工作区信任，可以提供帮助（我们将在下一节中介绍），但一个更好的系统来展示和控制扩展权限将是理想的。</st>
    <st c="20908">自</st> <st c="20960">2018年以来，关于这个问题一直在持续讨论！</st> <st c="20966">(</st>[<st
    c="20967">https://github.com/microsoft/vscode/issues/52116</st>](https://github.com/microsoft/vscode/issues/52116)<st
    c="21015">)。</st>
- en: <st c="21018">Aqua Security research</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21018">Aqua Security 研究</st>
- en: <st c="21041">To learn more</st> <st c="21055">about Aqua Security’s research
    into the risk of Visual Studio Code’s extensions, please refer to this</st> <st
    c="21158">document:</st> [<st c="21168">https://blog.aquasec.com/can-you-trust-your-vscode-extensions</st>](https://blog.aquasec.com/can-you-trust-your-vscode-extensions)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21041">想了解更多</st> <st c="21055">有关 Aqua Security 对 Visual Studio Code
    扩展风险的研究，请参考以下</st> <st c="21158">文档：</st> [<st c="21168">https://blog.aquasec.com/can-you-trust-your-vscode-extensions</st>](https://blog.aquasec.com/can-you-trust-your-vscode-extensions)
- en: <st c="21229">Risk 3 – Working with untrusted code</st>
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="21229">风险 3 – 使用不受信任的代码</st>
- en: <st c="21266">Developers often</st> <st c="21283">leverage open sourced code
    from various sources in their IDEs, including public or untrusted repositories.</st>
    <st c="21391">For example, while researching a new feature or solution to a problem,
    they might look for open source projects or code snippets that address similar
    challenges and open them in their development environment to gain insights from
    them.</st> <st c="21627">This practice, while beneficial, can introduce security
    risks.</st> <st c="21690">Loading code from untrusted sources can expose developers
    to threats such as malicious code execution and compromised dependencies.</st>
    <st c="21822">These threats can potentially steal access keys and tokens from
    the</st> <st c="21890">developer’s environment.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21266">开发者经常</st> <st c="21283">在其集成开发环境（IDE）中利用来自各种来源的开源代码，包括公共或不受信任的代码库。</st>
    <st c="21391">例如，在研究新功能或解决问题时，他们可能会寻找解决类似问题的开源项目或代码片段，并将其打开在开发环境中以获得启发。</st> <st
    c="21627">这种做法虽然有益，但也可能带来安全风险。</st> <st c="21690">从不受信任的来源加载代码可能会使开发者面临恶意代码执行和依赖项被篡改等威胁。</st>
    <st c="21822">这些威胁可能会窃取开发者环境中的访问密钥和令牌。</st>
- en: <st c="21914">Visual Studio Code, along with its extensions, offers multiple
    ways to execute code.</st> <st c="22000">While these methods streamline the development
    process, they can provide an entry point for exploitation.</st> <st c="22106">A
    notable example is the</st> `<st c="22131">launch.json</st>` <st c="22142">launch
    configuration file, which is located either in the project’s root folder or within
    the developer’s workspace settings.</st> <st c="22269">This file allows developers
    to save debugging</st> <st c="22315">setup details:</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21914">Visual Studio Code 及其扩展提供了多种执行代码的方式。</st> <st c="22000">虽然这些方法简化了开发过程，但也可能为利用提供了一个入口点。</st>
    <st c="22106">一个显著的例子是</st> `<st c="22131">launch.json</st>` <st c="22142">启动配置文件，它位于项目的根文件夹或开发者的工作区设置中。</st>
    <st c="22269">此文件允许开发者保存调试</st> <st c="22315">设置详细信息：</st>
- en: '![Figure 4.8 – Launch configuration attributes](img/B19710_04_08.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 启动配置属性](img/B19710_04_08.jpg)'
- en: <st c="22492">Figure 4.8 – Launch configuration attributes</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22492">图 4.8 – 启动配置属性</st>
- en: <st c="22536">Within</st> `<st c="22544">launch.json</st>`<st c="22555">, the</st>
    `<st c="22561">preLaunchTask</st>` <st c="22574">attribute defines a task to execute
    before debugging starts, and the</st> `<st c="22644">postDebugTask</st>` <st c="22657">attribute
    determines a task to run after the</st> <st c="22703">debugging session concludes
    (</st>*<st c="22732">Figure 4</st>**<st c="22741">.8</st>*<st c="22743">).</st>
    <st c="22747">While these attributes are designed to enhance the debugging experience,
    they can be manipulated by malicious actors.</st> <st c="22865">An attacker could
    modify these tasks to run arbitrary, potentially</st> <st c="22932">harmful code.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22536">在</st> `<st c="22544">launch.json</st>`<st c="22555">中，</st> `<st
    c="22561">preLaunchTask</st>` <st c="22574">属性定义了在调试开始前执行的任务，而</st> `<st c="22644">postDebugTask</st>`
    <st c="22657">属性决定了在调试会话结束后运行的任务（</st>*<st c="22732">图 4</st>**<st c="22741">.8</st>*<st
    c="22743">）。</st> <st c="22747">虽然这些属性旨在增强调试体验，但它们可能被恶意行为者篡改。</st> <st c="22865">攻击者可以修改这些任务，执行任意的潜在</st>
    <st c="22932">有害代码</st>。
- en: <st c="22945">Note</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22945">注意</st>
- en: <st c="22950">For further details on launch configuration and its attributes,
    please refer to this</st> <st c="23036">document:</st> [<st c="23046">https://code.visualstudio.com/docs/editor/debugging#_launchjson-attributes</st>](https://code.visualstudio.com/docs/editor/debugging#_launchjson-attributes)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22950">有关启动配置及其属性的更多详细信息，请参阅以下文档：</st> [<st c="23046">https://code.visualstudio.com/docs/editor/debugging#_launchjson-attributes</st>](https://code.visualstudio.com/docs/editor/debugging#_launchjson-attributes)
- en: <st c="23120">The risk amplifies when developers work with code from untrusted
    sources that come with a pre-set</st> `<st c="23219">launch.json</st>` <st c="23230">file.</st>
    <st c="23237">Such configurations might contain tasks that execute</st> <st c="23290">malicious
    code.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23120">当开发者使用来自不受信任来源的代码，并且这些代码包含一个预设的</st> `<st c="23219">launch.json</st>`
    <st c="23230">文件时，风险会放大。</st> <st c="23237">此类配置可能包含执行</st> <st c="23290">恶意代码</st>。
- en: <st c="23305">To mitigate this risk, Visual Studio Code introduced</st> <st
    c="23359">the</st> **<st c="23363">Workspace Trust</st>** <st c="23378">feature
    in May 2021 (version 1.57).</st> <st c="23415">This feature adds an extra security
    layer when dealing with untrusted code.</st> <st c="23491">When developers open
    such code, they are prompted by the Workspace Trust dialog to specify their trust
    level for the code.</st> <st c="23614">If the code is deemed untrustworthy, Visual
    Studio Code enters a</st> **<st c="23679">restricted mode</st>**<st c="23694">:</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23305">为了减轻这一风险，Visual Studio Code 于 2021 年 5 月（版本 1.57）推出了</st> **<st
    c="23363">工作区信任</st>** <st c="23378">功能。</st> <st c="23415">该功能在处理不受信任的代码时增加了一层额外的安全防护。</st>
    <st c="23491">当开发者打开这类代码时，工作区信任对话框会提示他们为代码指定信任级别。</st> <st c="23614">如果代码被判定为不可信，Visual
    Studio Code 将进入</st> **<st c="23679">受限模式</st>**<st c="23694">：</st>
- en: '![Figure 4.9 – Workspace Trust prompt](img/B19710_04_09.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 工作区信任提示](img/B19710_04_09.jpg)'
- en: <st c="24340">Figure 4.9 – Workspace Trust prompt</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24340">图 4.9 – 工作区信任提示</st>
- en: <st c="24375">This mode</st> <st c="24385">prevents potentially harmful</st>
    <st c="24415">actions by disabling or limiting certain features, including the
    ability for tasks to run, debugging, workspace settings modification, and privileged
    extensions (</st>*<st c="24577">Figure 4</st>**<st c="24586">.9</st>*<st c="24588">).</st>
    <st c="24592">The responsibility of trusting code that is loaded ultimately lies
    with the developer.</st> <st c="24679">Therefore, it is essential for developers
    to undergo continuous security training, ensuring they make informed decisions
    about which code</st> <st c="24817">to trust.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24375">此模式</st> <st c="24385">通过禁用或限制某些功能来防止潜在的有害</st> <st c="24415">操作，包括任务执行、调试、工作区设置修改和特权扩展（</st>*<st
    c="24577">图 4</st>**<st c="24586">.9</st>*<st c="24588">）。</st> <st c="24592">信任加载代码的责任最终由开发者承担。</st>
    <st c="24679">因此，开发者必须接受持续的安全培训，确保他们能做出明智的决定，选择信任哪些代码。</st>
- en: '<st c="24826">To edit the Workspace Trust setting, we can always open the Command
    Palette using</st> *<st c="24909">Ctrl</st>* <st c="24913">+</st> *<st c="24916">Shift</st>*
    <st c="24921">+</st> *<st c="24924">P</st>* <st c="24925">and type</st> `<st c="24935">Workspaces:
    Manage</st>` `<st c="24954">Workspace Trust</st>`<st c="24969">.</st>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="24826">要编辑工作区信任设置，我们可以随时通过按</st> *<st c="24909">Ctrl</st>* <st c="24913">+</st>
    *<st c="24916">Shift</st>* <st c="24921">+</st> *<st c="24924">P</st>* <st c="24925">打开命令面板并输入</st>
    `<st c="24935">Workspaces: Manage</st>` `<st c="24954">Workspace Trust</st>`<st
    c="24969">。</st>'
- en: '<st c="24970">To disable Workspace Trust entirely, we can modify the Visual
    Studio Code setting by going to</st> `<st c="25179">security.workspace.trust.enabled:
    false</st>`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="24970">要完全禁用工作区信任，我们可以通过以下方式修改 Visual Studio Code 设置</st> `<st c="25179">security.workspace.trust.enabled:
    false</st>`'
- en: '![Figure 4.10 – Workspace Trust Visual Studio Code setting](img/B19710_04_10.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.10 – Workspace Trust Visual Studio Code setting](img/B19710_04_10.jpg)'
- en: <st c="25824">Figure 4.10 – Workspace Trust Visual Studio Code setting</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25824">图 4.10 – 工作区信任 Visual Studio Code 设置</st>
- en: <st c="25880">Let us review</st> <st c="25895">a less frequent but significant
    development environment risk – compromised IDE</st> <st c="25974">source code.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25880">让我们回顾一下</st> <st c="25895">一个较少见但重大的开发环境风险——被篡改的 IDE</st> <st
    c="25974">源代码。</st>
- en: <st c="25986">Risk 4 – Compromised IDE source code</st>
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="25986">风险 4 – 被篡改的 IDE 源代码</st>
- en: <st c="26023">There is</st> <st c="26032">also a risk of the source code of
    IDEs being compromised!</st> <st c="26091">This is less common, but it does happen.</st>
    <st c="26132">Imagine the implications if the very tools used for software development
    were compromised.</st> <st c="26223">This is not just a hypothetical risk.</st>
    <st c="26261">A recent real-world incident involved a security researcher</st>
    <st c="26321">named</st> **<st c="26327">RyotaK</st>**<st c="26333">, who discovered
    and exploited a vulnerability in the Visual Studio Code repository on GitHub.</st>
    <st c="26428">The vulnerability was a result of a code injection flaw and a</st>
    <st c="26490">miswritten</st> **<st c="26501">regex expression (regex)</st>**
    <st c="26525">in a</st> **<st c="26531">continuous integration</st>** <st c="26553">(</st>**<st
    c="26555">CI</st>**<st c="26557">) script in Visual Studio Code’s official</st>
    <st c="26600">GitHub repository.</st> <st c="26619">Exploiting this granted him
    write access to the repository’s source code.</st> <st c="26693">This means he
    could potentially alter the code that developers around the world rely on for</st>
    <st c="26785">their work.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26023">也存在 IDE 源代码被篡改的风险！</st> <st c="26032">虽然这种情况不常见，但确实会发生。</st> <st
    c="26091">想象一下，如果用于软件开发的工具本身被篡改了，会带来什么影响。</st> <st c="26132">这不仅仅是一个假设的风险。</st>
    <st c="26223">最近的一个现实事件涉及一位名为</st> **<st c="26327">RyotaK</st>**<st c="26333">的安全研究员，他发现并利用了
    GitHub 上 Visual Studio Code 仓库中的一个漏洞。</st> <st c="26428">这个漏洞是由代码注入缺陷和一个</st>
    <st c="26490">写错的</st> **<st c="26501">正则表达式（regex）</st>** <st c="26525">以及</st>
    **<st c="26531">持续集成（CI）</st>** <st c="26553">脚本中的问题所导致的，该脚本位于 Visual Studio Code
    官方的</st> <st c="26600">GitHub 仓库。</st> <st c="26619">利用这一漏洞，他获得了写入该仓库源代码的权限。</st>
    <st c="26693">这意味着他有可能修改全球开发者依赖的代码，影响</st> <st c="26785">他们的工作。</st>
- en: <st c="26796">If the IDEs’ source code were maliciously altered without detection,
    it could lead to widespread distribution of tampered software tools, potentially
    infecting countless projects with malicious code or backdoors.</st> <st c="27010">This
    could compromise not just individual projects but</st> <st c="27065">entire infrastructures
    if widely adopted tools</st> <st c="27112">were affected.</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26796">如果 IDE 的源代码被恶意篡改且未被发现，可能导致篡改过的软件工具广泛传播，从而感染大量项目，注入恶意代码或后门。</st>
    <st c="27010">这不仅会危及单个项目，甚至可能影响整个基础设施，特别是如果广泛采用的工具</st> <st c="27065">受到影响的话。</st>
- en: <st c="27126">To get more details on RyotaK’s findings and the repercussions
    of such a compromise, you can delve into his blog post here:</st> [<st c="27251">https://blog.ryotak.net/post/vscode-write-access</st>](https://blog.ryotak.net/post/vscode-write-access)<st
    c="27299">. The blog is in Japanese, so you might need help from translation services
    such as Google Translate if you’re not familiar with</st> <st c="27428">the language.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27126">要了解更多 RyotaK 的发现及其安全漏洞带来的影响，可以查看他的博客文章：</st> [<st c="27251">https://blog.ryotak.net/post/vscode-write-access</st>](https://blog.ryotak.net/post/vscode-write-access)<st
    c="27299">。博客是日文的，如果你不熟悉该语言，可能需要借助翻译服务，如 Google 翻译。</st>
- en: <st c="27441">Additional thoughts on hardening of the development environment</st>
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="27441">关于加强开发环境安全性的更多思考</st>
- en: <st c="27505">What we</st> <st c="27514">have found in our experience is that
    some of the security hardening practices that we discussed are well known and,
    in some cases,</st> *<st c="27645">common sense</st>*<st c="27657">, but they
    often remain unimplemented and unmonitored in many environments.</st> <st c="27733">This
    is challenging to solve.</st> <st c="27763">When people know what to do</st> *<st
    c="27791">but</st>* <st c="27794">do not implement them, providing them with tools
    or some generic security training does not solve the problem.</st> <st c="27906">They
    are deep-rooted.</st> <st c="27928">Solving this usually involves some form of
    advocacy and evangelism within the organization – the hard work needed for</st>
    <st c="28046">culture change.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27505">根据我们的经验，</st> <st c="27514">我们发现，某些我们讨论过的安全加固实践是广为人知的，在某些情况下，</st>
    *<st c="27645">常识</st>*<st c="27657">，但它们在许多环境中仍未得到实施和监控。</st> <st c="27733">这很难解决。</st>
    <st c="27763">当人们知道该做什么</st> *<st c="27791">但</st>* <st c="27794">没有付诸实践时，仅仅提供工具或一些通用的安全培训并不能解决问题。</st>
    <st c="27906">这些问题根深蒂固。</st> <st c="27928">解决这个问题通常需要在组织内进行某种形式的倡导和推广——这是一项艰苦的工作，需要</st>
    <st c="28046">文化变革。</st>
- en: <st c="28061">These environment-hardening practices must be seamless if they
    will ever be implemented.</st> <st c="28151">IDEs must be configured by default
    to auto-update, plugins must be configured by default to auto-update where possible,
    or at least, the organization should have well-defined endpoint management processes
    that include developer tools and plugins.</st> <st c="28398">If possible, the
    ability to remove or adjust these security defaults should be removed or</st>
    <st c="28488">highly discouraged.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28061">这些环境硬化实践必须无缝集成，才能得以实施。</st> <st c="28151">集成开发环境（IDE）必须默认配置为自动更新，插件也必须尽可能默认配置为自动更新，或者至少组织应该有明确定义的端点管理流程，包括开发工具和插件。</st>
    <st c="28398">如果可能的话，应该移除或</st> <st c="28488">强烈不建议调整这些安全默认设置。</st>
- en: <st c="28507">This is a difficult thing to do as developers sometimes may need
    to disable some capabilities for the sake of performance or backward compatibility.</st>
    <st c="28657">We cannot just take an all-or-nothing approach as there are legitimate
    reasons why some developers may kick against these security defaults in their
    environment.</st> <st c="28819">We should be understanding and accommodating to
    valid exceptions with the right mitigations in place.</st> <st c="28921">Remember
    that security measures have to be collaborative in a</st> <st c="28983">DevSecOps
    culture.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28507">这是一项艰巨的任务，因为开发人员有时可能需要为了性能或向后兼容性禁用某些功能。</st> <st c="28657">我们不能采取全有或全无的方法，因为有些开发人员可能出于正当理由反对在其环境中使用这些安全默认设置。</st>
    <st c="28819">我们应该理解并包容那些有效的例外，并采取适当的缓解措施。</st> <st c="28921">记住，安全措施必须是合作性的，才能在</st>
    <st c="28983">DevSecOps文化中有效。</st>
- en: <st c="29001">Addressing common development security mistakes</st>
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="29001">解决常见的开发安全问题</st>
- en: <st c="29049">There are</st> <st c="29059">various ways that risks are introduced
    into modern software when they are developed.</st> <st c="29145">Modern software
    applications are for the most part a</st> *<st c="29198">cocktail</st>* <st c="29206">blend
    of proprietary code written by in-house developers and third-party components,
    which can originate from open source repositories,</st> *<st c="29343">source-available</st>*
    <st c="29359">code, or even commercially licensed code, which is less common but
    nonetheless exists (</st>*<st c="29447">Figure 4</st>**<st c="29456">.11</st>*<st
    c="29459">):</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29049">现代软件在开发过程中引入风险的方式有很多种。</st> <st c="29145">现代软件应用大多数是由内部开发人员编写的专有代码和第三方组件的*<st
    c="29198">混合</st>*，这些组件可能来自开源仓库、</st> *<st c="29343">开放源代码</st>* <st c="29359">，甚至是商业授权代码，虽然不常见，但确实存在（</st>*<st
    c="29447">图 4</st>**<st c="29456">.11</st>*<st c="29459">）：</st>
- en: '![Figure 4.11 – Modern software composition](img/B19710_04_11.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 现代软件组成](img/B19710_04_11.jpg)'
- en: <st c="29585">Figure 4.11 – Modern software composition</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29585">图 4.11 – 现代软件组成</st>
- en: <st c="29626">Source-available software</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29626">开放源代码软件</st>
- en: <st c="29652">Source-available software means that the source code of the software
    is publicly available for viewing.</st> <st c="29757">However, it doesn’t necessarily
    grant the same freedoms as</st> **<st c="29816">open source software</st>** <st
    c="29836">(</st>**<st c="29838">OSS</st>**<st c="29841">).</st> <st c="29845">While</st>
    <st c="29851">you can see the code, there may be restrictions on how you can use,
    modify, or distribute it.</st> <st c="29945">Think of it as a</st> *<st c="29962">look
    but don’t touch</st>* <st c="29982">approach to sharing</st> <st c="30003">software
    code.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29652">源代码可用软件意味着该软件的源代码是公开可供查看的。</st> <st c="29757">然而，它并不一定赋予和</st>
    **<st c="29816">开源软件</st>** <st c="29836">(</st>**<st c="29838">OSS</st>**<st
    c="29841">)</st> <st c="29845">相同的自由。</st> <st c="29851">虽然</st> <st c="29851">你可以查看代码，但可能会有关于如何使用、修改或分发它的限制。</st>
    <st c="29945">可以将其视为一种</st> *<st c="29962">看看但别动手</st>* <st c="29982">的共享软件代码方式。</st>
- en: <st c="30017">Any of these components could introduce risks into the software!</st>
    <st c="30083">There could be security flaws in our</st> *<st c="30120">in-house
    code</st>*<st c="30133">,</st> *<st c="30135">third-party code and open source
    packages</st>* <st c="30176">could also contain vulnerabilities, plus there is
    the issue of</st> *<st c="30240">exposed secrets</st>*<st c="30255">, which can
    be a big problem.</st> <st c="30285">Identifying and addressing these risks should
    start in the pre-commit phase.</st> <st c="30362">If we catch security problems
    closer to the final stages of the DevOps cycle, it can lead to the delay</st>
    <st c="30465">of a feature release or even worse, become a technical debt that
    grows and becomes tougher to fix as time goes on.</st> <st c="30580">With this
    in mind, let us break down the top three risk categories to prioritize in the
    pre-commit phase, starting with security issues in our</st> <st c="30723">in-house
    code.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30017">这些组件中的任何一个都可能给软件带来风险！</st> <st c="30083">我们的</st> *<st c="30120">内部代码</st>*<st
    c="30133">，</st> *<st c="30135">第三方代码和开源包</st>* <st c="30176">也可能存在漏洞，并且还有</st>
    *<st c="30240">暴露的密钥</st>*<st c="30255">，这可能是一个大问题。</st> <st c="30285">识别并解决这些风险应从提交前阶段开始。</st>
    <st c="30362">如果我们在DevOps周期的最后阶段发现安全问题，可能会导致功能发布的延迟，</st> <st c="30465">甚至更糟，变成技术债务，随着时间的推移变得越来越难以修复。</st>
    <st c="30580">考虑到这一点，我们来分解在提交前阶段需要优先处理的前三大风险类别，从我们</st> <st c="30723">内部代码中的安全问题开始。</st>
- en: <st c="30737">Risk 1 – Addressing in-house code vulnerability risk</st>
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="30737">风险1 - 解决内部代码漏洞风险</st>
- en: <st c="30790">Developers are</st> <st c="30805">human and can make security
    mistakes when writing code.</st> <st c="30862">For instance, a developer might
    forget to sanitize user input before using it in database queries, leaving the
    door open for SQL injection attacks.</st> <st c="31010">In another case, a developer
    might neglect to implement proper session timeouts, making the application vulnerable
    to session hijacking.</st> <st c="31147">In the</st> <st c="31153">recent</st>
    **<st c="31161">Storm-0558</st>** <st c="31171">Microsoft breach, it was discovered
    that the developers of the Microsoft 365 mail system assumed certain libraries</st>
    <st c="31286">that they implemented were fully validating the needed scope, and
    they did not add the necessary issuer/scope validation.</st> <st c="31409">This
    oversight magnified the impact of the breach when a signing key</st> <st c="31478">was
    compromised.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30790">开发者是</st> <st c="30805">人类，在编写代码时可能会犯安全错误。</st> <st c="30862">例如，开发者可能忘记在使用用户输入进行数据库查询之前对其进行清理，从而为SQL注入攻击打开了大门。</st>
    <st c="31010">另一个例子是，开发者可能忽略了实施适当的会话超时，导致应用程序容易受到会话劫持。</st> <st c="31147">在</st>
    <st c="31153">最近的</st> **<st c="31161">Storm-0558</st>** <st c="31171">微软泄露事件中，发现微软365邮件系统的开发者假设他们实现的某些库</st>
    <st c="31286">已经完全验证了所需的范围，但他们没有添加必要的发行者/范围验证。</st> <st c="31409">这一疏忽放大了当签名密钥</st>
    <st c="31478">被泄露时事件的影响。</st>
- en: <st c="31494">Analysis of STORM-0558 breach by Microsoft Security Response Center
    (MSRC)</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31494">微软安全响应中心（MSRC）对STORM-0558泄露事件的分析</st>
- en: <st c="31569">To read the full analysis of the Storm-0558 breach, please refer
    to this</st> <st c="31643">document:</st> [<st c="31653">https://msrc.microsoft.com/blog/2023/09/results-of-major-technical-investigations-for-storm-0558-key-acquisition/</st>](https://msrc.microsoft.com/blog/2023/09/results-of-major-technical-investigations-for-storm-0558-key-acquisition/)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31569">要查看 Storm-0558 漏洞的完整分析，请参考以下</st> <st c="31643">文档：</st> [<st
    c="31653">https://msrc.microsoft.com/blog/2023/09/results-of-major-technical-investigations-for-storm-0558-key-acquisition/</st>](https://msrc.microsoft.com/blog/2023/09/results-of-major-technical-investigations-for-storm-0558-key-acquisition/)
- en: <st c="31766">The root causes of vulnerabilities in in-house code are diverse,
    therefore there is no single remedy.</st> <st c="31869">Tackling this challenge
    demands a comprehensive strategy, blending both cultural changes and technological
    measures.</st> <st c="31986">We want to make sure that every time a developer
    writes code, they are equipped with the knowledge and tools needed to write the
    most secure code possible.</st> <st c="32142">A foundational step to addressing
    this risk is to equip developers with secure coding training but despite the best
    training efforts, security oversights are inevitable.</st> <st c="32312">To</st>
    <st c="32314">add an extra layer of mitigation, integrating a</st> **<st c="32363">static
    application security testing</st>** <st c="32398">(</st>**<st c="32400">SAST</st>**<st
    c="32404">) solution during the pre-commit phase of DevOps can</st> <st c="32458">be
    beneficial.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31766">内部代码中的漏洞根本原因是多样的，因此没有单一的解决办法。</st> <st c="31869">解决这一挑战需要一个全面的策略，融合文化变革和技术措施。</st>
    <st c="31986">我们希望确保每次开发人员编写代码时，他们都能拥有所需的知识和工具，以编写最安全的代码。</st> <st c="32142">解决这一风险的基础步骤是为开发人员提供安全编码培训，但尽管经过最佳的培训努力，安全疏忽还是不可避免。</st>
    <st c="32312">为了</st> <st c="32314">增加额外的缓解层，集成一个</st> **<st c="32363">静态应用程序安全测试</st>**
    <st c="32398">(</st>**<st c="32400">SAST</st>**<st c="32404">) 解决方案，在 DevOps 的提交前阶段进行测试可能会</st>
    <st c="32458">带来好处。</st>
- en: <st c="32472">Understanding how SAST tools work</st>
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="32472">理解 SAST 工具的工作原理</st>
- en: <st c="32506">SAST tools</st> <st c="32518">analyze application source code,
    bytecode, or binary code to identify vulnerabilities without running</st> <st
    c="32619">the program.</st> <st c="32633">Because they can be automated, they
    operate faster than traditional manual reviews.</st> <st c="32717">As their accuracy
    improves, they are becoming the preferred choice over manual code reviews, particularly
    in organizations that have embraced a DevOps model.</st> <st c="32875">SAST tools
    use various methods to achieve this, each with its own advantages</st> <st c="32952">and
    limitations.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32506">SAST 工具</st> <st c="32518">分析应用程序源代码、字节码或二进制代码，以在不运行程序的情况下识别漏洞。</st>
    <st c="32619">因为它们可以自动化操作，所以比传统的手动审查更快。</st> <st c="32633">随着准确性的提高，它们正在成为优于手动代码审查的首选，尤其是在已经采纳
    DevOps 模式的组织中。</st> <st c="32717">随着准确性提高，它们正成为比手动代码审查更受青睐的选择，尤其是在已经采用 DevOps
    模式的组织中。</st> <st c="32875">SAST 工具使用多种方法来实现这一目标，每种方法都有其优缺点。</st> <st c="32952">和局限性。</st>
- en: <st c="32968">One common</st> <st c="32980">method is</st> **<st c="32990">syntax
    and semantic analysis</st>**<st c="33018">. Here, the tool breaks down the code
    to understand its structure and patterns.</st> <st c="33098">For example, in a
    situation where user input is directly added to an SQL query in the code, this
    method would recognize the pattern as a potential SQL injection vulnerability.</st>
    <st c="33274">It does this by parsing the code and building abstract representations,
    such as</st> **<st c="33354">abstract syntax trees</st>** <st c="33375">(</st>**<st
    c="33377">ASTs</st>**<st c="33381">), to</st> <st c="33388">identify such patterns.</st>
    <st c="33412">While this method can spot many vulnerabilities, it might also flag
    issues that are not real problems (false positives).</st> <st c="33533">It can
    also be resource-intensive and slow for large</st> <st c="33586">code bases.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32968">一种常见的</st> <st c="32980">方法是</st> **<st c="32990">语法和语义分析</st>**<st
    c="33018">。在此方法中，工具将代码分解以理解其结构和模式。</st> <st c="33098">例如，在用户输入直接添加到 SQL 查询中的情况中，这种方法会将该模式识别为潜在的
    SQL 注入漏洞。</st> <st c="33274">它通过解析代码并构建抽象表示来做到这一点，像是</st> **<st c="33354">抽象语法树</st>**
    <st c="33375">(</st>**<st c="33377">AST</st>**<st c="33381">)，以</st> <st c="33388">识别此类模式。</st>
    <st c="33412">虽然这种方法可以发现许多漏洞，但它也可能会标记出一些并不是真正问题的内容（假阳性）。</st> <st c="33533">对于大型</st>
    <st c="33586">代码库，它也可能是资源密集型且运行缓慢的。</st>
- en: <st c="33597">Another approach</st> <st c="33614">is</st> **<st c="33618">data
    flow analysis</st>**<st c="33636">, which tracks how data moves through a program
    and analyzes if the data is being handled insecurely.</st> <st c="33738">It uses
    heuristics and predefined rules to trace the flow of data and identify insecure
    handling; for example, if a web application’s code accepts user input in a form
    and then displays it on a web page without cleaning it up first.</st> <st c="33971">By
    mapping out how data travels from the input point to its destination on the web
    page, data flow analysis can spot this as a</st> <st c="34098">potential</st>
    **<st c="34108">cross-site scripting</st>** <st c="34128">(</st>**<st c="34130">XSS</st>**<st
    c="34133">) vulnerability and flag it.</st> <st c="34163">This method is effective
    in identifying vulnerabilities related to data handling, such as SQL injection
    or XSS.</st> <st c="34275">It is not effective in detecting logical vulnerabilities
    such as authentication bypasses that are not directly related to data flow.</st>
    <st c="34408">It might also produce false positives if the tool does not fully
    understand the data’s</st> <st c="34495">life cycle.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33597">另一种方法</st> <st c="33614">是</st> **<st c="33618">数据流分析</st>**<st
    c="33636">，它跟踪数据如何通过程序流动，并分析数据是否被不安全地处理。</st> <st c="33738">它使用启发式方法和预定义规则来追踪数据流动并识别不安全处理；例如，如果一个网页应用接受用户在表单中输入，并在没有首先清理数据的情况下直接在网页上显示。</st>
    <st c="33971">通过绘制数据从输入点到其在网页上的目的地的旅程，数据流分析可以识别此类行为作为</st> <st c="34098">潜在的</st>
    **<st c="34108">跨站脚本</st>** <st c="34128">(</st>**<st c="34130">XSS</st>**<st
    c="34133">) 漏洞并标记它。</st> <st c="34163">这种方法在识别与数据处理相关的漏洞方面非常有效，如SQL注入或XSS。</st>
    <st c="34275">它不适用于检测与数据流不直接相关的逻辑漏洞，如身份验证绕过。</st> <st c="34408">如果工具未完全理解数据的生命周期，它可能还会产生误报。</st>
- en: '**<st c="34506">Taint analysis</st>** <st c="34521">is a</st> <st c="34526">specialized
    form of data flow analysis.</st> <st c="34567">It tracks user-controlled input
    to see if it gets processed without validation or sanitization, potentially leading
    to vulnerabilities.</st> <st c="34703">For example, in a chat application where
    users send messages, if these messages are displayed to other users without checking
    or sanitizing them, taint analysis would flag this as a potential stored XSS vulnerability,
    where an attacker’s message could contain malicious scripts that run on another
    user’s browser.</st> <st c="35017">It is effective for finding vulnerabilities
    related to user input, such as injection attacks.</st> <st c="35111">It can produce
    false positives if the tool does not recognize all sanitization methods.</st>
    <st c="35199">It often uses a combination of heuristics and</st> <st c="35245">rule-based
    checks.</st>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="34506">污点分析</st>** <st c="34521">是</st> <st c="34526">数据流分析的一种专业形式。</st>
    <st c="34567">它跟踪用户控制的输入，以查看是否在没有验证或净化的情况下处理，可能导致漏洞。</st> <st c="34703">例如，在聊天应用中，用户发送的消息如果未经检查或净化即显示给其他用户，污点分析将标记此类行为为潜在的存储型跨站脚本（XSS）漏洞，攻击者的消息可能包含恶意脚本在另一个用户的浏览器上运行。</st>
    <st c="35017">它对于发现与用户输入相关的漏洞非常有效，比如注入攻击。</st> <st c="35111">如果工具无法识别所有净化方法，则可能产生误报。</st>
    <st c="35199">它通常使用启发式方法和</st> <st c="35245">基于规则的检查。</st>'
- en: <st c="35263">Another approach</st> <st c="35281">used by SAST tools</st> <st
    c="35299">is</st> `<st c="35483">true</st>`<st c="35487">/</st>`<st c="35489">false</st>`<st
    c="35494">. If you think of an e-commerce site that is supposed to check</st>
    <st c="35556">if a user is logged in before processing a purchase, this method
    will identify if there is a way in the code that skips this check, leading to
    potential unauthorized access.</st> <st c="35731">This method is effective for
    identifying logical vulnerabilities such as authentication bypass or missing security
    controls.</st> <st c="35856">It is less effective for identifying data-related
    vulnerabilities such as SQL injection</st> <st c="35944">or XSS.</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35263">SAST工具采用的另一种方法</st> <st c="35281">是</st> `<st c="35483">true</st>`<st
    c="35487">/</st>`<st c="35489">false</st>`<st c="35494">。例如，考虑一个电子商务网站，该网站应在处理购买前检查用户是否已登录，这种方法将识别代码中是否存在跳过此检查的方式，从而导致潜在的未经授权访问。</st>
    <st c="35731">这种方法非常适用于识别诸如身份验证绕过或缺失安全控制等逻辑漏洞。</st> <st c="35856">但它在识别与数据相关的漏洞，如SQL注入</st>
    <st c="35944">或XSS时效果较差。</st>
- en: '**<st c="35951">Configuration review</st>** <st c="35972">is</st> <st c="35976">another
    method used by SAST tools for analysis.</st> <st c="36024">It is straightforward
    in how it works.</st> <st c="36063">It analyzes configuration files and settings
    to ensure secure defaults and settings.</st> <st c="36148">It does this by comparing
    configurations against best practices or known secure configurations.</st> <st
    c="36244">For example, if an application configuration is set up to show detailed
    error messages, a configuration review would flag this as an information disclosure
    vulnerability since attackers could gain insights from these messages.</st> <st
    c="36471">This approach is great for catching insecure application settings that
    might be overlooked during manual reviews.</st> <st c="36585">It does not detect
    security problems in the</st> <st c="36629">code’s logic.</st>'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="35951">配置审查</st>** <st c="35972">是</st> <st c="35976">SAST工具用于分析的另一种方法。</st>
    <st c="36024">它的工作原理非常直接。</st> <st c="36063">它通过分析配置文件和设置，以确保安全的默认值和设置。</st> <st
    c="36148">它通过将配置与最佳实践或已知的安全配置进行比较来实现这一点。</st> <st c="36244">例如，如果应用程序配置设置为显示详细的错误信息，配置审查将标记此为信息泄露漏洞，因为攻击者可能通过这些信息获取有价值的线索。</st>
    <st c="36471">这种方法非常适合捕捉那些在手动审查中可能被忽视的不安全应用设置。</st> <st c="36585">它不会检测到</st>
    <st c="36629">代码逻辑中的安全问题。</st>'
- en: <st c="36642">Most SAST tools use a mix of methods to offer a well-rounded view
    of possible vulnerabilities.</st> <st c="36738">They aim for precise results,
    considering the specificities of various programming languages and frameworks.</st>
    <st c="36847">Additionally, these tools typically have preset rules or queries
    for different analysis techniques that we mentioned.</st> <st c="36965">Some even
    allow developers/security teams to create custom rules to spot more unique insecure
    coding patterns in</st> <st c="37078">the code.</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36642">大多数SAST工具采用多种方法相结合的方式，提供可能漏洞的全面视角。</st> <st c="36738">它们旨在获得精确的结果，考虑到不同编程语言和框架的特性。</st>
    <st c="36847">此外，这些工具通常会有预设的规则或查询，用于我们提到的不同分析技术。</st> <st c="36965">有些工具甚至允许开发人员/安全团队创建自定义规则，以便在</st>
    <st c="37078">代码中发现更独特的不安全编码模式。</st>
- en: <st c="37087">Challenges of SAST tools</st>
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="37087">SAST工具的挑战</st>
- en: <st c="37112">SAST tools have</st> <st c="37129">benefits, but they also have
    limitations.</st> <st c="37171">One big limitation is that they analyze code without
    running it, so</st> <st c="37239">they don’t always have the full context of the
    application’s behavior, which can lead to a lot of false positives.</st> <st c="37354">A
    false positive is when a tool wrongly identifies a</st> <st c="37407">security
    issue.</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37112">SAST工具有</st> <st c="37129">优点，但也有局限性。</st> <st c="37171">一个大局限性是它们在不运行代码的情况下进行分析，因此</st>
    <st c="37239">它们无法完全掌握应用程序的行为上下文，这可能导致很多误报。</st> <st c="37354">误报是指工具错误地识别出</st>
    <st c="37407">安全问题。</st>
- en: <st c="37422">Take the example of an application developer who is writing frontend
    logic.</st> <st c="37499">They might not have user input validation and sanitization
    implemented in their code because this is being handled in the backend code, which
    might be in a separate repository.</st> <st c="37676">The SAST tool that analyzes
    the code does not have this context, so it flags the missing implementation as</st>
    <st c="37783">a vulnerability.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37422">以应用程序开发人员编写前端逻辑为例。</st> <st c="37499">他们可能没有在代码中实现用户输入验证和清理，因为这部分工作由后端代码处理，而后端代码可能位于一个单独的代码库中。</st>
    <st c="37676">分析代码的SAST工具无法获取到这个上下文信息，因此它会将缺失的实现标记为</st> <st c="37783">漏洞。</st>
- en: <st c="37799">Some SAST tools</st> <st c="37816">use simple heuristics or just
    look for basic patterns to identify vulnerabilities.</st> <st c="37899">Tools
    such as these will struggle with analyzing complex code structures.</st> <st c="37973">Just
    because a piece of code matches a simple pattern does not mean that it is vulnerable.</st>
    <st c="38064">This is</st> <st c="38071">why it is important to test these tools
    before using them.</st> <st c="38131">Some are better than others at avoiding
    false positives.</st> <st c="38188">In fact, some tools can get it wrong as much
    as 80% of the time!</st> <st c="38253">This can frustrate developers.</st> <st
    c="38284">Instead of helping to make their work easier, they have to spend time
    figuring out which warnings are real and which are not.</st> <st c="38410">This
    might make them want to skip using</st> <st c="38450">the tool.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37799">一些 SAST 工具</st> <st c="37816">使用简单的启发式方法或仅仅寻找基本模式来识别漏洞。</st> <st
    c="37899">像这些工具在分析复杂代码结构时会遇到困难。</st> <st c="37973">仅仅因为一段代码符合一个简单的模式，并不意味着它就有漏洞。</st>
    <st c="38064">这就是</st> <st c="38071">为什么在使用这些工具之前进行测试非常重要。</st> <st c="38131">有些工具在避免误报方面比其他工具更为优秀。</st>
    <st c="38188">事实上，有些工具的误报率可能高达80%！</st> <st c="38253">这会让开发人员感到沮丧。</st> <st c="38284">这些工具本应帮助简化工作，但开发人员却不得不花时间弄清楚哪些警告是真实的，哪些不是。</st>
    <st c="38410">这可能会让他们想跳过使用</st> <st c="38450">这些工具。</st>
- en: <st c="38459">Also, some tools just point out identified vulnerabilities without
    clearly explaining why they have been flagged.</st> <st c="38574">Others are better
    at giving clear reasons and even offer automatic fixes to correct the</st> <st
    c="38662">security issue.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38459">此外，一些工具仅指出已识别的漏洞，但没有清楚地解释为什么会被标记。</st> <st c="38574">其他工具则更善于提供明确的原因，甚至提供自动修复来纠正</st>
    <st c="38662">安全问题。</st>
- en: <st c="38677">In our opinion, these challenges do not diminish the benefits
    that SAST tools provide.</st> <st c="38765">We recommend that security experts
    and developers work together to fine-tune the configuration, queries, and patterns
    of your chosen SAST tool and integrate feedback to gradually reduce false positives
    over time.</st> <st c="38978">It is also a good idea to combine this with manual
    reviews, which we will cover later in</st> [*<st c="39067">Chapter 5</st>*](B19710_05.xhtml#_idTextAnchor098)
    <st c="39076">of</st> <st c="39080">this book.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38677">在我们看来，这些挑战并不会削弱 SAST 工具所带来的好处。</st> <st c="38765">我们建议安全专家和开发人员共同合作，微调所选
    SAST 工具的配置、查询和模式，并通过集成反馈逐步减少误报。</st> <st c="38978">将其与手动审查相结合也是一个好主意，我们将在</st>
    [*<st c="39067">第5章</st>*](B19710_05.xhtml#_idTextAnchor098) <st c="39076">中进一步讲解</st>
    <st c="39080">这一部分内容。</st>
- en: <st c="39090">Understanding SAST integration points in the pre-commit phase</st>
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="39090">理解 SAST 在预提交阶段的集成点</st>
- en: <st c="39152">Properly</st> <st c="39162">integrating SAST during the pre-commit
    stage of DevOps can detect critical vulnerabilities</st> <st c="39253">in application
    code when they are easiest and cheapest to fix, especially while developers are
    still focused on the task.</st> <st c="39375">This integration can be done either
    through IDE security plugins or as</st> **<st c="39446">pre-commit hooks</st>**<st
    c="39462">. Each</st> <st c="39468">method has its unique benefits.</st> <st c="39501">The</st>
    **<st c="39505">IDE plugin integration</st>** <st c="39527">provides</st> <st
    c="39536">developers with immediate feedback on security issues as they write
    the code.</st> <st c="39615">Some plugins even highlight security concerns with
    squiggly lines, similar to syntax error indications, as illustrated in</st> *<st
    c="39737">Figure 4</st>**<st c="39745">.12</st>*<st c="39748">. This immediate
    feedback serves as</st> **<st c="39784">just-in-time</st>** <st c="39796">(</st>**<st
    c="39798">JIT</st>**<st c="39801">) secure</st> <st c="39811">coding training,
    alerting developers to potential security flaws in real time.</st> <st c="39890">However,
    a limitation is that not all SAST providers offer</st> <st c="39949">such plugins:</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39152">在</st> <st c="39162">DevOps 的 pre-commit 阶段正确地集成 SAST 可以在应用程序代码中检测到关键的漏洞，</st>
    <st c="39253">这些漏洞在修复时最为简单且成本最低，尤其是在开发人员仍专注于任务时。</st> <st c="39375">这种集成可以通过 IDE
    安全插件或作为</st> **<st c="39446">pre-commit hooks</st>**<st c="39462">进行。</st> <st
    c="39468">每种方法都有其独特的优点。</st> <st c="39501">**IDE 插件集成**</st> <st c="39505">为开发人员提供即时的安全问题反馈，</st>
    <st c="39527">在他们编写代码时。</st> <st c="39536">一些插件甚至用波浪线突出显示安全问题，类似于语法错误指示，如</st>
    *<st c="39737">图 4</st>**<st c="39745">.12</st>*<st c="39748">所示。</st> <st c="39784">这种即时反馈就像是</st>
    **<st c="39796">及时</st>** <st c="39798">（**JIT**）安全编程培训，</st> <st c="39811">能够实时提醒开发人员潜在的安全漏洞。</st>
    <st c="39890">然而，一个限制是并非所有的 SAST 提供商都提供</st> <st c="39949">这样的插件：</st>
- en: '![Figure 4.12 – A sample of an IDE extension (Checkov) flagging security issues
    while code is written](img/B19710_04_12.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – IDE 扩展（Checkov）在代码编写时标记安全问题的示例](img/B19710_04_12.jpg)'
- en: <st c="40844">Figure 4.12 – A sample of an IDE extension (Checkov) flagging
    security issues while code is written</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40844">图 4.12 – IDE 扩展（Checkov）在代码编写时标记安全问题的示例</st>
- en: <st c="40943">To</st> <st c="40947">understand what pre-commit hooks are, we
    should first know about</st> `<st c="41305">.git/hooks</st>` <st c="41315">directory
    of every Git repository.</st> <st c="41351">By default, Git provides sample hooks
    in this directory, but they are inactive (they have a</st> `<st c="41443">.</st>``<st
    c="41444">sample</st>` <st c="41451">extension).</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40943">要</st> <st c="40947">理解什么是 pre-commit hooks，我们首先需要了解每个 Git 仓库的</st>
    `<st c="41305">.git/hooks</st>` <st c="41315">目录。</st> <st c="41351">默认情况下，Git
    在此目录中提供示例 hooks，但它们是未激活的（它们的扩展名为</st> `<st c="41443">.</st>``<st c="41444">sample</st>`
    <st c="41451">）。</st>
- en: <st c="41463">There are various types of Git hooks, such as pre-commit, post-commit,
    pre-push, post-receive, and many others.</st> <st c="41576">Each corresponds to
    a different phase in the Git workflow.</st> <st c="41635">The pre-commit hook
    is one of the many Git hooks.</st> <st c="41685">It is triggered right before
    a commit is recorded, allowing us to implement automated inspection of code that
    is about to be committed (</st>*<st c="41821">Figure 4</st>**<st c="41830">.13</st>*<st
    c="41833">):</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41463">Git hooks 有多种类型，例如 pre-commit、post-commit、pre-push、post-receive
    等等。</st> <st c="41576">每种类型对应 Git 工作流中的不同阶段。</st> <st c="41635">pre-commit hook
    是众多 Git hooks 中的一种。</st> <st c="41685">它会在提交记录之前触发，使我们能够对即将提交的代码进行自动化检查（</st>*<st
    c="41821">图 4</st>**<st c="41830">.13</st>*<st c="41833">）：</st>
- en: '![Figure 4.13 – Pre-commit hooks are triggered before a commit is recorded](img/B19710_04_13.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – Pre-commit hooks 在提交记录之前被触发](img/B19710_04_13.jpg)'
- en: <st c="41959">Figure 4.13 – Pre-commit hooks are triggered before a commit is
    recorded</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41959">图 4.13 – Pre-commit hooks 在提交记录之前被触发</st>
- en: <st c="42031">Pre-commit hooks are versatile and can run a wide variety of scripts.</st>
    <st c="42102">Any script that can be executed from the command line can be used
    as a pre-commit hook.</st> <st c="42190">Given that most SAST tools are available
    as command-line tools, integrating them as pre-commit hooks for automated code</st>
    <st c="42310">assessment becomes straightforward.</st> <st c="42346">If the pre-commit
    hook script exits with a nonzero status, the commit is aborted, giving the developer
    an opportunity to fix issues before re-attempting a</st> <st c="42501">commit
    operation.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42031">Pre-commit 钩子是多功能的，可以运行各种脚本。</st> <st c="42102">任何可以从命令行执行的脚本都可以用作
    pre-commit 钩子。</st> <st c="42190">鉴于大多数 SAST 工具作为命令行工具可用，将它们作为 pre-commit 钩子来进行自动化代码</st>
    <st c="42310">评估变得非常简单。</st> <st c="42346">如果 pre-commit 钩子脚本以非零状态退出，则会中止提交，给开发者一个在重新尝试提交操作之前修复问题的机会。</st>
- en: <st c="42518">One challenge</st> <st c="42532">with Git’s default setup is that
    hooks are local to each repository.</st> <st c="42602">However, teams often want
    to share and enforce consistent hooks across all developers.</st> <st c="42689">This
    is where tools such as the pre-commit framework come in handy, helping manage
    shared configurations and</st> <st c="42798">ensuring uniformity.</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42518">Git 默认设置的一个挑战是钩子是每个仓库本地的。</st> <st c="42532">然而，团队通常希望在所有开发者之间共享和强制一致的钩子。</st>
    <st c="42602">这就是像 pre-commit 框架这样的工具派上用场的地方，它帮助管理共享配置并</st> <st c="42798">确保一致性。</st>
- en: <st c="42818">Pre-commit framework versus pre-commit hooks</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42818">pre-commit 框架与 pre-commit 钩子</st>
- en: <st c="42863">The term</st> *<st c="42873">pre-commit hooks</st>* <st c="42889">can
    sometimes be mistaken for a tool known as the</st> *<st c="42940">pre-commit framework</st>*<st
    c="42960">. As we discussed earlier, the pre-commit hook is a specific type of
    Git hook that is triggered right before a commit is recorded.</st> <st c="43091">The
    pre-commit framework is a separate tool designed to simplify the process of setting
    up and managing pre-commit hooks.</st> <st c="43213">Instead of manually writing
    and managing scripts in the</st> `<st c="43269">.git/hooks</st>` <st c="43279">directory,
    the pre-commit framework allows developers to leverage a wide array of existing
    hooks and easily integrate them into their repositories.</st> <st c="43428">With
    the pre-commit framework, we define the hooks we want in a</st> `<st c="43492">.pre-commit-config.yaml</st>`
    <st c="43515">file, and the tool takes care of installing them into the appropriate
    Git</st> <st c="43590">hooks directory.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42863">术语</st> *<st c="42873">pre-commit 钩子</st>* <st c="42889">有时可能会与一个名为</st>
    *<st c="42940">pre-commit 框架</st>*<st c="42960">的工具混淆。正如我们之前讨论的，pre-commit 钩子是一种特定类型的
    Git 钩子，它会在提交记录之前触发。</st> <st c="43091">pre-commit 框架是一个独立的工具，旨在简化设置和管理 pre-commit
    钩子的过程。</st> <st c="43213">它不需要手动编写和管理</st> `<st c="43269">.git/hooks</st>` <st
    c="43279">目录中的脚本，pre-commit 框架使开发者能够利用各种现有钩子，并轻松地将它们集成到仓库中。</st> <st c="43428">使用
    pre-commit 框架，我们在</st> `<st c="43492">.pre-commit-config.yaml</st>` <st c="43515">文件中定义所需的钩子，工具会负责将它们安装到适当的
    Git</st> <st c="43590">钩子目录中。</st>
- en: <st c="43606">While pre-commit hooks are invaluable, there are times when developers
    might need to bypass them.</st> <st c="43705">This could be due to a perceived
    false positive or a valid reason to override the hook.</st> <st c="43793">Commands
    such as</st> `<st c="43810">git commit --no-verify</st>` <st c="43832">allow for
    such bypasses, but they should be used</st> <st c="43882">with caution.</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43606">尽管 pre-commit 钩子非常宝贵，但有时开发者可能需要绕过它们。</st> <st c="43705">这可能是由于错误的假阳性警告或有充分理由覆盖钩子。</st>
    <st c="43793">像</st> `<st c="43810">git commit --no-verify</st>` <st c="43832">这样的命令允许绕过这些钩子，但它们应该谨慎使用。</st>
- en: <st c="43895">SAST tools that integrate with the pre-commit phase</st>
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="43895">与 pre-commit 阶段集成的 SAST 工具</st>
- en: <st c="43947">Several</st> <st c="43956">SAST providers</st> <st c="43971">offer
    integration during the pre-commit stage of DevOps.</st> <st c="44028">Some of
    these providers are exclusively open source, others are purely commercial, and
    a few provide a basic open source version with an option to upgrade to a full-featured
    commercial version.</st> *<st c="44222">Figure 4</st>**<st c="44230">.14</st>*
    <st c="44233">shows an overview of</st> <st c="44255">common offerings:</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43947">多个</st> <st c="43956">SAST提供商</st> <st c="43971">在DevOps的pre-commit阶段提供集成。</st>
    <st c="44028">其中一些提供商完全是开源的，另一些则是纯商业性质的，少数提供了基础的开源版本，用户可以选择升级到功能齐全的商业版本。</st>
    *<st c="44222">图 4</st>**<st c="44230">.14</st>* <st c="44233">展示了常见的产品概览：</st>
- en: '![Figure 4.14 – Popular SAST tools and how they integrate in pre-commit](img/B19710_04_14.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 流行的SAST工具及其在pre-commit阶段的集成方式](img/B19710_04_14.jpg)'
- en: <st c="44699">Figure 4.14 – Popular SAST tools and how they integrate in pre-commit</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44699">图 4.14 – 流行的SAST工具及其在pre-commit阶段的集成方式</st>
- en: <st c="44768">Later in this</st> <st c="44783">chapter, we</st> <st c="44794">will
    give our recommendation on choosing the right tool.</st> <st c="44852">For now,
    this section aims to introduce you to some of the popular</st> <st c="44919">options
    available.</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44768">本章稍后</st> <st c="44783">我们将提供选择合适工具的建议。</st> <st c="44794">现在，本节旨在介绍一些流行的</st>
    <st c="44919">可用选项。</st>
- en: <st c="44937">What about AI pair programming tools?</st>
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="44937">那么，AI配对编程工具呢？</st>
- en: <st c="44975">AI tools</st> <st c="44985">such as GitHub Copilot, Tabnine, and
    Amazon CodeWhisperer bring the power of</st> **<st c="45062">generative AI</st>**
    <st c="45075">(</st>**<st c="45077">GenAI</st>**<st c="45082">) to</st> <st c="45088">development
    teams.</st> <st c="45107">There is no doubt that they help developers to write
    code faster and to feel more satisfied with their work.</st> <st c="45216">Recent
    GitHub research found that developers using these tools work 55% faster than those</st>
    <st c="45306">who don’t.</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44975">如GitHub Copilot、Tabnine和Amazon CodeWhisperer等AI工具将</st> **<st
    c="45062">生成式AI</st>** <st c="45075">（</st>**<st c="45077">GenAI</st>**<st c="45082">）的力量带入了开发团队。</st>
    <st c="45107">毫无疑问，它们帮助开发者更快地编写代码，并且让他们对自己的工作感到更加满意。</st> <st c="45216">最近的GitHub研究发现，使用这些工具的开发者比未使用工具的开发者工作速度快55%。</st>
- en: <st c="45316">Source – Research on GitHub Copilot’s impact on developer productivity</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45316">来源 – GitHub Copilot对开发者生产力影响的研究</st>
- en: <st c="45387">For a closer look at GitHub’s study, check out this</st> <st c="45440">document:</st>
    [<st c="45450">https://github.blog/2022-09-07-research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/</st>](https://github.blog/2022-09-07-research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/)
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45387">若想更深入了解GitHub的研究，请查看此</st> <st c="45440">文档：</st> [<st c="45450">https://github.blog/2022-09-07-research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/</st>](https://github.blog/2022-09-07-research-quantifying-github-copilots-impact-on-developer-productivity-and-happiness/)
- en: <st c="45565">However, there are concerns about the security of the code these
    tools produce.</st> <st c="45646">GitHub Copilot, for instance, is based on an</st>
    <st c="45690">OpenAI</st> **<st c="45698">large language model</st>** <st c="45718">(</st>**<st
    c="45720">LLM</st>**<st c="45723">).</st> <st c="45727">This model was trained
    on code from publicly available sources, including open source code in GitHub.</st>
    <st c="45829">Some of these code sources are notorious for using outdated APIs
    and implementing insecure coding patterns.</st> <st c="45937">So, there’s a risk
    that the AI might suggest insecure</st> <st c="45991">code snippets.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45565">然而，人们对这些工具生成的代码的安全性表示担忧。</st> <st c="45646">以GitHub Copilot为例，它基于一个</st>
    <st c="45690">OpenAI</st> **<st c="45698">大语言模型</st>** <st c="45718">（</st>**<st
    c="45720">LLM</st>**<st c="45723">）</st>。 <st c="45727">这个模型是通过从公开的资源中获取代码进行训练的，包括GitHub上的开源代码。</st>
    <st c="45829">这些代码来源中有些因使用过时的API和实施不安全的编码模式而臭名昭著。</st> <st c="45937">因此，AI可能会建议不安全的</st>
    <st c="45991">代码片段。</st>
- en: <st c="46005">Studies</st> <st c="46014">show that many developers think AI-generated
    code is of high quality, but research suggests otherwise.</st> <st c="46117">A
    recent study evaluated ChatGPT, another OpenAI tool, on 21 programming tasks.</st>
    <st c="46197">It only produced 5 secure programs, while the other 16 had security
    issues in relation to vulnerabilities that were evaluated.</st> <st c="46324">For
    example, when prompted to create an FTP server using C++, ChatGPT’s code lacked
    input validation, making it vulnerable to injection attacks.</st> <st c="46469">However,
    on further prompting, ChatGPT did fix its mistakes.</st> <st c="46530">This shows
    that the quality and security of AI-generated code depend on how precisely developers
    provide carefully</st> <st c="46645">crafted prompts.</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46005">研究</st> <st c="46014">表明，许多开发者认为AI生成的代码质量很高，但研究却得出了相反的结论。</st>
    <st c="46117">最近的一项研究对ChatGPT（另一个OpenAI工具）在21个编程任务中的表现进行了评估。</st> <st c="46197">它只生成了5个安全的程序，而其他16个程序在评估的漏洞方面存在安全问题。</st>
    <st c="46324">例如，在被要求用C++创建FTP服务器时，ChatGPT的代码缺乏输入验证，容易受到注入攻击。</st> <st c="46469">然而，在进一步的提示下，ChatGPT确实修正了它的错误。</st>
    <st c="46530">这表明，AI生成代码的质量和安全性取决于开发者如何精确地提供经过精心设计的提示。</st>
- en: <st c="46661">We highly recommend that companies keen on using these tools should
    prioritize training their developers on providing clear, security-specific prompts.</st>
    <st c="46814">You can call this</st> *<st c="46832">secure code prompt</st>* *<st
    c="46851">engineering training</st>*<st c="46871">.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46661">我们强烈建议那些希望使用这些工具的公司，应优先培训他们的开发者提供清晰、安全特定的提示。</st> <st c="46814">你可以称之为</st>
    *<st c="46832">安全代码提示</st>* *<st c="46851">工程培训</st>*<st c="46871">。</st>
- en: <st c="46872">Further reading – How secure is the code generated by ChatGPT?</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46872">进一步阅读 – ChatGPT生成的代码有多安全？</st>
- en: <st c="46935">For more details on the referenced study, check out the paper
    by researchers from the University of Quebec in</st> <st c="47046">Canada:</st>
    [<st c="47054">https://arxiv.org/pdf/2304.09655v1.pdf</st>](https://arxiv.org/pdf/2304.09655v1.pdf)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46935">有关引用研究的更多详细信息，请查看来自加拿大魁北克大学的研究人员的论文：</st> <st c="47046">[<st c="47054">https://arxiv.org/pdf/2304.09655v1.pdf</st>](https://arxiv.org/pdf/2304.09655v1.pdf)
- en: <st c="47092">Risk 2 – Open source component risk</st>
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="47092">风险2 – 开源组件风险</st>
- en: <st c="47128">OSS packages</st> <st c="47142">offer</st> <st c="47148">flexibility,
    cost savings, and rapid development advantages.</st> <st c="47209">However, they
    can also introduce risks into a software project.</st> <st c="47273">These risks
    can be because of</st> **<st c="47303">security vulnerabilities</st>**<st c="47327">,</st>
    **<st c="47329">package compromise</st>**<st c="47347">, or</st> **<st c="47352">confusion
    attacks</st>**<st c="47369">.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47128">开源软件包</st> <st c="47142">提供</st> <st c="47148">灵活性、成本节约和快速开发的优势。</st>
    <st c="47209">然而，它们也可能给软件项目引入风险。</st> <st c="47273">这些风险可能来源于</st> **<st c="47303">安全漏洞</st>**<st
    c="47327">、</st> **<st c="47329">软件包被篡改</st>**<st c="47347">，或</st> **<st c="47352">混淆攻击</st>**<st
    c="47369">。</st>
- en: <st c="47370">When developers add a package to a project, they also take on
    its security risks.</st> <st c="47453">Even though many OSS project maintainers
    prioritize security, the license terms don’t mandate them to ensure it – it is
    not a responsibility that they are obligated to fulfill.</st> <st c="47630">Let
    us discuss some of these risks and how to address them in the pre-commit phase,
    starting with</st> <st c="47728">security vulnerabilities:</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47370">当开发者将一个软件包添加到项目中时，他们也承担了该软件包的安全风险。</st> <st c="47453">尽管许多开源项目维护者优先考虑安全性，但许可条款并没有要求他们确保安全——这并非他们必须履行的责任。</st>
    <st c="47630">让我们讨论一些这些风险，以及如何在预提交阶段应对它们，从</st> <st c="47728">安全漏洞</st> <st c="47753">开始：</st>
- en: <st c="47753">Addressing OSS known vulnerabilities risk in the pre-commit phase</st>
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="47753">在预提交阶段解决已知开源软件漏洞风险</st>
- en: '**<st c="47819">Known vulnerabilities</st>** <st c="47841">are</st> <st c="47845">unintentional</st>
    <st c="47860">security gaps in the OSS code (think of these as accidental holes
    in the components that are used in a ship).</st> <st c="47970">When identified
    by security researchers, they are responsibly disclosed and publicly recorded
    as</st> **<st c="48067">Common Vulnerabilities and Exposures</st>** <st c="48103">(</st>**<st
    c="48105">CVEs</st>**<st c="48109">) in</st> <st c="48114">known libraries such
    as MITRE’s CVE list (</st>[<st c="48157">https://cve.mitre.org</st>](https://cve.mitre.org)<st
    c="48179">) and the</st> **<st c="48190">National Vulnerability Database</st>**
    <st c="48221">(</st>**<st c="48223">NVD</st>**<st c="48226">) (</st>[<st c="48230">https://nvd.nist.gov</st>](https://nvd.nist.gov)<st
    c="48251">).</st> <st c="48255">These</st> <st c="48260">databases can be searched
    by security tools to identify known vulnerabilities in specific versions of OSS
    packages.</st> <st c="48377">While direct vulnerabilities in the packages that
    developers choose are concerning, there is another hidden risk: transitive dependencies.</st>
    <st c="48516">These are packages that get automatically included as a dependency
    of the selected OSS package (</st>*<st c="48612">Figure 4</st>**<st c="48621">.15</st>*<st
    c="48624">).</st> <st c="48628">A recent study by the research team at Endor Labs
    found that 95% of security issues are found in these</st> <st c="48731">transitive
    dependencies:</st>'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="47819">已知漏洞</st>** <st c="47841">是</st> <st c="47845">开源软件代码中的</st>
    <st c="47860">安全漏洞（可以将其看作是船只使用组件中意外产生的孔洞）</st>。<st c="47970">当安全研究人员识别出这些漏洞时，它们会被负责任地披露，并以</st>
    **<st c="48067">常见漏洞与暴露</st>** <st c="48103">(</st>**<st c="48105">CVE</st>**<st
    c="48109">)的形式公开记录</st>，<st c="48114">如MITRE的CVE列表（</st>[<st c="48157">https://cve.mitre.org</st>](https://cve.mitre.org)<st
    c="48179">）和</st> **<st c="48190">国家漏洞数据库</st>** <st c="48221">(</st>**<st c="48223">NVD</st>**<st
    c="48226">)（</st>[<st c="48230">https://nvd.nist.gov</st>](https://nvd.nist.gov)<st
    c="48251">）。</st> <st c="48255">这些</st> <st c="48260">数据库可以被安全工具搜索，用以识别特定版本的开源软件包中的已知漏洞。</st>
    <st c="48377">虽然开发人员选择的包中的直接漏洞令人担忧，但还有另一个隐藏的风险：传递性依赖。</st> <st c="48516">这些是作为所选开源软件包的依赖项自动包含的包（</st>*<st
    c="48612">图4.15</st>**<st c="48621">.</st>*<st c="48624">）。</st> <st c="48628">Endor
    Labs研究团队最近的一项研究发现，95%的安全问题出现在这些</st> <st c="48731">传递性依赖中：</st>'
- en: '![Figure 4.15 – OSS package dependency](img/B19710_04_15.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15 – 开源软件包依赖关系](img/B19710_04_15.jpg)'
- en: <st c="48905">Figure 4.15 – OSS package dependency</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48905">图4.15 – 开源软件包依赖关系</st>
- en: <st c="48941">The State of Dependency Management report by Endor Labs</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48941">Endor Labs的《依赖管理现状》报告</st>
- en: <st c="48997">You can refer to this document to access the</st> <st c="49043">report:</st>
    [<st c="49051">https://www.endorlabs.com/state-of-dependency-management#</st>](https://www.endorlabs.com/state-of-dependency-management#)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48997">你可以参考此文档访问</st> <st c="49043">报告：</st> [<st c="49051">https://www.endorlabs.com/state-of-dependency-management#</st>](https://www.endorlabs.com/state-of-dependency-management#)
- en: <st c="49108">A foundational step to addressing</st> *<st c="49143">OSS known
    vulnerability</st>* <st c="49166">risk in the pre-commit phase is to</st> *<st
    c="49202">equip developers with knowledge on how to pick safe and secure OSS packages
    for their projects</st>*<st c="49296">. Some companies are trying out new ways
    to help developers make these choices.</st> <st c="49376">For example, some have
    started to experiment with the use of LLMs</st> <st c="49442">and GenAI to streamline
    this process.</st> <st c="49480">So, instead of mandating developers to read long
    guidelines on how to pick safe packages, developers can just ask questions such
    as</st> *<st c="49612">Is there a more secure alternative to the OpenSSL library?</st>*<st
    c="49670">, and they will get a response with explanations.</st> <st c="49720">A
    new tool</st> <st c="49731">called</st> **<st c="49738">DroidGPT</st>**<st c="49746">,
    made by Endor Labs, is trying to do just this.</st> <st c="49795">It aims to make
    it easier and faster for developers to choose secure open source packages for
    their projects.</st> <st c="49905">But it is still new (and in private preview),
    and we don’t know yet how well it works in</st> <st c="49994">real situations.</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49108">在提交前阶段解决</st> *<st c="49143">OSS 已知漏洞</st>* <st c="49166">风险的基础步骤是</st>
    *<st c="49202">为开发人员提供有关如何为其项目选择安全的开源软件包的知识</st>*<st c="49296">。一些公司正在尝试新的方法来帮助开发人员做出这些选择。</st>
    <st c="49376">例如，一些公司已经开始尝试使用 LLMs 和 GenAI 来简化这个过程。</st> <st c="49442">因此，开发人员不再需要强制阅读关于如何选择安全软件包的长篇指南，他们只需问一些问题，比如</st>
    *<st c="49612">是否有比 OpenSSL 库更安全的替代品？</st>*<st c="49670">，就会得到解释的回答。</st> <st
    c="49720">一种名为</st> <st c="49731">DroidGPT</st>**<st c="49746">的新工具，由 Endor Labs
    制作，正试图实现这一目标。</st> <st c="49795">它旨在帮助开发人员更轻松更快速地为其项目选择安全的开源软件包。</st> <st c="49905">但它仍然是新的（并且处于私人预览阶段），我们尚不清楚它在实际情况中的表现如何。</st>
- en: <st c="50010">Another common approach to addressing known vulnerabilities in
    OSS in the pre-commit phase is to</st> <st c="50107">integrate</st> **<st c="50118">software
    composition analysis</st>** <st c="50147">(</st>**<st c="50149">SCA</st>**<st
    c="50152">) tools similar to how we described SAST tools integration.</st> <st
    c="50213">These tools inspect open source components and third-party libraries
    used in an application to identify known vulnerabilities.</st> <st c="50340">They
    operate by comparing these components against databases of</st> <st c="50404">known
    vulnerabilities.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50010">在提交前阶段处理开源软件已知漏洞的另一种常见方法是</st> <st c="50107">集成</st> **<st c="50118">软件组成分析</st>**
    <st c="50147">(</st>**<st c="50149">SCA</st>**<st c="50152">) 工具，类似于我们描述的 SAST
    工具集成。</st> <st c="50213">这些工具检查应用程序中使用的开源组件和第三方库，以识别已知漏洞。</st> <st c="50340">它们通过将这些组件与已知漏洞的数据库进行比较来运作。</st>
- en: <st c="50426">Challenges of SCA tools</st>
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <st c="50426">SCA 工具面临的挑战</st>
- en: <st c="50450">One of the</st> <st c="50462">grave mistakes that we have seen
    organizations make is to reduce the implementation of DevSecOps to tooling adoption.</st>
    <st c="50580">Implementing DevSecOps effectively is more than just deploying SCA
    tools; it demands careful planning and a deep understanding of the tools’ capabilities
    and limitations.</st> <st c="50751">To understand the dependencies included in
    a project, most SCA tools will scan the project for package management files,
    parse the files to extract dependency information, and perform a vulnerability
    analysis based on the dependencies listed.</st> <st c="50994">For example, when
    dealing with a .NET Core application that uses the NuGet package manager, an SCA
    tool would analyze the</st> `<st c="51116">.csproj</st>` <st c="51123">file to
    extract dependency data, followed by a vulnerability assessment based on</st>
    <st c="51205">those dependencies.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50450">我们看到组织常见的一个严重错误是将 DevSecOps 的实施简化为工具采用。</st> <st c="50580">有效实施
    DevSecOps 不仅仅是部署 SCA 工具；它需要仔细的规划和对工具功能和限制的深刻理解。</st> <st c="50751">为了理解项目中包含的依赖关系，大多数
    SCA 工具会扫描项目的包管理文件，解析文件以提取依赖信息，并基于列出的依赖关系进行漏洞分析。</st> <st c="50994">例如，当处理使用 NuGet
    包管理器的 .NET Core 应用程序时，SCA 工具将分析</st> `<st c="51116">.csproj</st>` <st c="51123">文件以提取依赖数据，并根据</st>
    <st c="51205">这些依赖关系进行漏洞评估。</st>
- en: <st c="51224">However, solely relying on package manager data to identify dependencies
    can lead to blind spots.</st> <st c="51323">There is often a mismatch between
    the dependencies declared in package management files and what is actively used
    in code.</st> <st c="51446">Some dependencies might be declared but remain unused
    in the actual code, known</st> <st c="51525">as</st> **<st c="51529">unused dependencies</st>**<st
    c="51548">. There might be dependencies used in the code but not listed in the
    package manager file, known</st> <st c="51644">as</st> **<st c="51648">phantom
    dependencies</st>**<st c="51668">.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51669">Such discrepancies</st> <st c="51688">can have tangible implications.</st>
    <st c="51721">For one, alerting vulnerabilities in unused dependencies can lead
    to a barrage of unnecessary alerts, adding to the cognitive burden on developers
    who are already pressed for time.</st> <st c="51902">On the other hand, missing
    out on scanning phantom dependencies can introduce significant security blind
    spots, which is</st> <st c="52023">even riskier.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52036">Alerting vulnerabilities in unused software components (unused
    dependencies) adds to the noise, which adds to the cognitive burden on developers
    already working against tight schedules.</st> <st c="52223">Not being able to
    identify and scan phantom dependencies leads to blind spots, which is even</st>
    <st c="52316">more risky.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52327">By recognizing these challenges, more mature SCA tools have evolved.</st>
    <st c="52397">These do not just focus on package manager files but integrate this
    data with direct code analysis to offer a more comprehensive assessment.</st>
    <st c="52538">Our aim here is not to advocate for a specific tool, but we think
    it is important for teams to be aware of these challenges and factor them into
    their</st> <st c="52689">DevSecOps strategy.</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52708">Addressing OSS package compromise risks in pre-commit</st>
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`<st c="53300">eslint</st>` <st c="53306">package.</st> <st c="53316">The inserted
    code then stole</st> **<st c="53345">Node Package Manager</st>** <st c="53365">(</st>**<st
    c="53367">npm</st>**<st c="53370">) credentials</st> <st c="53385">from the systems
    of those who added and called the package in</st> <st c="53447">their code.</st>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53458">Instead of modifying the main package, attackers could also add
    a malicious package as a dependency.</st> <st c="53560">This was the case in the
    EventStream attack where a malicious package called</st> `<st c="53637">flatmap-stream</st>`
    <st c="53651">was added to the</st> `<st c="53669">event-stream</st>` <st c="53681">package.</st>
    <st c="53691">The malicious package contained an encrypted payload that was tailored
    to steal Bitcoins from the</st> <st c="53789">Copay app.</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53799">ESLint and EventStream attacks</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53830">For an ESLint</st> <st c="53845">attack post-mortem, refer to
    this</st> <st c="53879">link:</st> [<st c="53885">https://eslint.org/blog/2018/07/postmortem-for-malicious-package-publishes/</st>](https://eslint.org/blog/2018/07/postmortem-for-malicious-package-publishes/)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53830">有关 ESLint</st> <st c="53845">攻击的事后分析，请参考这个</st> <st c="53879">链接：</st>
    [<st c="53885">https://eslint.org/blog/2018/07/postmortem-for-malicious-package-publishes/</st>](https://eslint.org/blog/2018/07/postmortem-for-malicious-package-publishes/)
- en: <st c="53960">For Snyk’s post-mortem of</st> <st c="53986">the EventStream attack,
    refer to this</st> <st c="54025">link:</st> [<st c="54031">https://snyk.io/blog/a-post-mortem-of-the-malicious-event-stream-backdoor/</st>](https://snyk.io/blog/a-post-mortem-of-the-malicious-event-stream-backdoor/)
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53960">有关 Snyk 对</st> <st c="53986">EventStream 攻击的事后分析，请参考这个</st> <st
    c="54025">链接：</st> [<st c="54031">https://snyk.io/blog/a-post-mortem-of-the-malicious-event-stream-backdoor/</st>](https://snyk.io/blog/a-post-mortem-of-the-malicious-event-stream-backdoor/)
- en: <st c="54105">Protecting</st> <st c="54116">against package compromise requires
    us to establish a secure package management process.</st> <st c="54206">This includes
    ensuring that developers can only download packages from trusted, reputable sources
    or official repositories and verifying the integrity of these packages through
    checksums or similar techniques to ensure they have not been altered.</st> <st
    c="54453">Staying updated with security alerts for the packages you use can also
    be a safeguard.</st> <st c="54540">Platforms such as GitHub often issue security
    advisories.</st> <st c="54598">Running packages with minimal permissions can further
    reduce the potential damage of a compromised package.</st> <st c="54706">We will
    cover secure dependency management later in</st> [*<st c="54758">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122)
    <st c="54767">of this book, so stay tuned</st> <st c="54796">for that.</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54105">防止</st> <st c="54116">包被篡改需要我们建立一个安全的包管理过程。</st> <st c="54206">这包括确保开发者只能从可信的、知名的源或官方仓库下载包，并通过校验和或类似技术验证这些包的完整性，以确保它们没有被篡改。</st>
    <st c="54453">保持关注你使用的包的安全警报也是一种防护措施。</st> <st c="54540">像 GitHub 这样的平台经常发布安全公告。</st>
    <st c="54598">以最小权限运行包可以进一步减少被篡改包可能造成的损害。</st> <st c="54706">我们将在本书的</st> [*<st
    c="54758">第六章</st>*](B19710_06.xhtml#_idTextAnchor122) <st c="54767">中进一步讨论安全依赖管理，敬请期待。</st>
- en: <st c="54805">Addressing dependency confusion attacks in pre-commit</st>
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="54805">解决预提交阶段的依赖混淆攻击</st>
- en: '**<st c="54859">Dependency confusion attacks</st>** <st c="54888">are</st>
    <st c="54893">deceptive tactics where attackers name malicious packages</st> <st
    c="54951">with similar names to genuine ones and upload them to public package
    repositories.</st> <st c="55034">The goal is to deceive developers into downloading
    and integrating these malicious packages, thinking they are legitimate ones, thereby
    introducing vulnerabilities or backdoors into their software projects.</st> <st
    c="55241">A simple typo in the package name could have the developer pulling down
    malicious code that will end up being distributed to application users.</st> <st
    c="55385">Imagine believing you’re securing a life jacket, but it’s actually</st>
    <st c="55452">a weight.</st>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="54859">依赖混淆攻击</st>** <st c="54888">是一种欺骗性战术，攻击者将恶意包命名为与真实包类似的名称，并将其上传到公共包仓库。</st>
    <st c="54951">目标是欺骗开发者下载并集成这些恶意包，认为它们是合法包，从而将漏洞或后门引入他们的软件项目中。</st> <st c="55034">包名称中的一个简单拼写错误可能会导致开发者下载到恶意代码，而这些代码最终会被分发给应用程序用户。</st>
    <st c="55385">想象一下，你以为你正在绑紧救生衣，实际上却绑上了</st> <st c="55452">一块重物。</st>'
- en: <st c="55461">In a recent incident, researchers at Checkmarx, JFrog, and Sonatype
    tracked a threat actor called RED-LILI that targeted Azure developers with malicious</st>
    `<st c="55615">npm</st>` <st c="55618">packages.</st> <st c="55629">The group
    published malicious Azure SDK packages but replaced the</st> `<st c="55695">@azure</st>`
    <st c="55701">scope with</st> `<st c="55713">azure-</st>`<st c="55719">, and in
    some cases, they removed the scope altogether and just published a package with
    the same name (</st>*<st c="55823">Figure 4</st>**<st c="55832">.16</st>*<st c="55835">):</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的一起事件中，Checkmarx、JFrog 和 Sonatype 的研究人员追踪到一个名为 RED-LILI 的威胁行为者，该行为者通过恶意的
    `<st c="55615">npm</st>` <st c="55618">包</st> 以攻击 Azure 开发者。<st c="55629">该小组发布了恶意的
    Azure SDK 包，但将</st> `<st c="55695">@azure</st>` <st c="55701">的作用域替换为</st> `<st
    c="55713">azure-</st>`<st c="55719">，并且在某些情况下，他们完全移除了作用域，仅发布了一个与原名相同的包（</st>*<st
    c="55823">图 4</st>**<st c="55832">.16</st>*<st c="55835">）：</st>
- en: '![Figure 4.16 – Malicious npm packages published by the RED-LILI group](img/B19710_04_16.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.16 – RED-LILI 组发布的恶意 npm 软件包](img/B19710_04_16.jpg)'
- en: <st c="56388">Figure 4.16 – Malicious npm packages published by the RED-LILI
    group</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56388">图 4.16 – RED-LILI 组发布的恶意 npm 软件包</st>
- en: <st c="56456">What</st> <st c="56462">sets this group apart is their sophistication.</st>
    <st c="56509">They automated the entire process, from</st> `<st c="56549">npm</st>`
    <st c="56552">account creation to malicious package publishing, even bypassing</st>
    **<st c="56618">one-time password</st>** <st c="56635">(</st>**<st c="56637">OTP</st>**<st
    c="56640">) verifications.</st> <st c="56658">Also, instead of using a single
    account to</st> <st c="56701">publish multiple malicious packages, they created
    a unique account for each package, making detection and cleanup more challenging.</st>
    <st c="56833">In just 1 week, they released around 800</st> <st c="56874">such
    packages!</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56456">这个组别的独特之处在于他们的复杂性。</st> <st c="56509">他们自动化了整个过程，从</st> `<st c="56549">npm</st>`
    <st c="56552">帐户创建到恶意软件包发布，甚至绕过了</st> **<st c="56618">一次性密码</st>** <st c="56635">（</st>**<st
    c="56637">OTP</st>**<st c="56640">）验证。</st> <st c="56658">此外，他们并非使用单一帐户发布多个恶意软件包，而是为每个软件包创建了一个独特的帐户，这使得检测和清理工作更加具有挑战性。</st>
    <st c="56833">仅在1周内，他们发布了大约800</st> <st c="56874">这样的软件包！</st>
- en: <st c="56888">RED-LILI attack</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56888">RED-LILI 攻击</st>
- en: <st c="56904">To read more</st> <st c="56918">about the RED-LILI supply chain
    threat actor, please refer to this</st> <st c="56985">page:</st> [<st c="56991">https://github.com/checkmarx/red-lili</st>](https://github.com/checkmarx/red-lili)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[<st c="56904">阅读更多</st>](https://github.com/checkmarx/red-lili) <st c="56918">关于供应链威胁行为者
    RED-LILI，请参阅此</st> <st c="56985">页面：</st> [<st c="56991">https://github.com/checkmarx/red-lili</st>](https://github.com/checkmarx/red-lili)'
- en: <st c="57028">Dependency confusion attacks can also take other forms.</st> <st
    c="57085">For example, the target could be private packages used within an organization
    instead of OSS packages.</st> <st c="57188">Here is an example</st> <st c="57207">of
    this:</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57028">依赖混淆攻击也可以采取其他形式。</st> <st c="57085">例如，目标可能是组织内使用的私有包，而不是开源软件包。</st>
    <st c="57188">这里有一个例子</st> <st c="57207">：</st>
- en: <st c="57215">Imagine a company named</st> *<st c="57240">TechCorp</st>* <st
    c="57248">that uses a private package called</st> `<st c="57284">SecureLogin</st>`
    <st c="57295">for its internal applications.</st> <st c="57327">This package is
    version</st> `<st c="57351">1.5</st>` <st c="57354">and is not available to the
    public.</st> <st c="57391">An attacker learns about</st> `<st c="57416">SecureLogin</st>`
    <st c="57427">through some leaked documentation or insider information.</st> <st
    c="57486">They then create a malicious package, also named</st> `<st c="57535">SecureLogin</st>`<st
    c="57546">, but give it a higher version number – say,</st> `<st c="57591">2.0</st>`<st
    c="57594">. This malicious package contains code that, when executed, sends sensitive
    user data to the attacker’s server.</st> <st c="57706">The attacker uploads this
    malicious</st> `<st c="57742">SecureLogin</st>` <st c="57753">version</st> `<st
    c="57762">2.0</st>` <st c="57765">to a public package repository.</st> <st c="57798">Now,
    when TechCorp’s developers fetch updates for their packages, the package manager
    sees the</st> *<st c="57893">newer</st>* <st c="57898">version</st> `<st c="57907">2.0</st>`
    <st c="57910">of</st> `<st c="57914">SecureLogin</st>` <st c="57925">and might
    automatically download and integrate it, thinking it’s a legitimate update from
    their own team (marked as</st> *<st c="58042">3</st>* <st c="58043">in</st> *<st
    c="58047">Figure 4</st>**<st c="58055">.17</st>*<st c="58058">).</st> <st c="58062">Once
    integrated, the malicious code activates, compromising</st> <st c="58121">the
    company’s applications and sending sensitive data to</st> <st c="58179">the attacker:</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57215">假设有一家公司名为</st> *<st c="57240">TechCorp</st>* <st c="57248">，它为内部应用程序使用一个名为</st>
    `<st c="57284">SecureLogin</st>` <st c="57295">的私有包。</st> <st c="57327">这个包的版本是</st>
    `<st c="57351">1.5</st>` <st c="57354">，并且不对公众开放。</st> <st c="57391">有一个攻击者通过某些泄露的文档或内部信息得知</st>
    `<st c="57416">SecureLogin</st>` <st c="57427">的信息。</st> <st c="57486">他们接着创建了一个恶意包，也命名为</st>
    `<st c="57535">SecureLogin</st>`<st c="57546">，但是给它赋予了一个更高的版本号——例如，</st> `<st
    c="57591">2.0</st>`<st c="57594">。这个恶意包包含了当执行时会将敏感用户数据发送到攻击者服务器的代码。</st> <st c="57706">攻击者将这个恶意的</st>
    `<st c="57742">SecureLogin</st>` <st c="57753">版本</st> `<st c="57762">2.0</st>`
    <st c="57765">上传到公共包仓库。</st> <st c="57798">现在，当TechCorp的开发者获取他们的包更新时，包管理器看到</st>
    *<st c="57893">更新的</st>* <st c="57898">版本</st> `<st c="57907">2.0</st>` <st c="57910">的</st>
    `<st c="57914">SecureLogin</st>` <st c="57925">，并可能会自动下载并集成它，认为它是来自自己团队的合法更新（标记为</st>
    *<st c="58042">图4</st>* <st c="58043">中的</st> *<st c="58047">3</st>* <st c="58055">.17</st>*）。</st>
    <st c="58062">一旦集成，恶意代码就会激活，危害</st> <st c="58121">公司的应用程序，并将敏感数据发送给</st> <st c="58179">攻击者：</st>
- en: '![Figure 4.17 – Dependency confusion targeting private packages](img/B19710_04_17.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![Figure 4.17 – 依赖混淆攻击目标：私有包](img/B19710_04_17.jpg)'
- en: <st c="58403">Figure 4.17 – Dependency confusion targeting private packages</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58403">图 4.17 – 依赖混淆攻击目标：私有包</st>
- en: <st c="58464">This is not an unusual attack.</st> <st c="58496">Alex Birsan
    documented how he performed exactly this style of dependency confusion attack
    to breach large companies such as Apple and Microsoft</st> <st c="58640">here:</st>
    [<st c="58646">https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610</st>](mailto:https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610)
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58464">这并不是一种异常攻击。</st> <st c="58496">Alex Birsan 记录了他是如何进行这种类型的依赖混淆攻击，突破苹果和微软等大公司的防线的，详情请见：</st>
    [<st c="58646">https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610</st>](mailto:https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610)
- en: <st c="58711">In the attack, he scanned the public repositories of target organizations,
    specifically looking for package management files such as</st> `<st c="58845">package.json</st>`<st
    c="58857">. From these files, he identified names of private packages that the
    organizations used internally but were not available on public package repositories.</st>
    <st c="59011">He then created higher versions of the same package names on public
    repositories and waited for them to</st> <st c="59115">be downloaded.</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58711">在此次攻击中，他扫描了目标组织的公共仓库，特别寻找诸如</st> `<st c="58845">package.json</st>`<st
    c="58857">这样的包管理文件。通过这些文件，他识别出了组织内部使用的、但未在公共包仓库中提供的私有包名称。</st> <st c="59011">然后，他在公共仓库中创建了相同包名的更高版本，并等待它们被</st>
    <st c="59115">下载。</st>
- en: <st c="59129">To address the risks of dependency confusion, we need a clear
    plan.</st> <st c="59198">Firstly, developers should undergo secure development
    training, emphasizing the importance of version pinning and teaching them to recognize
    signs of dependency confusion.</st> <st c="59370">Tools such as</st> `<st c="59384">npm</st>`<st
    c="59387">’s</st> `<st c="59391">package-lock.json</st>` <st c="59408">or Python’s</st>
    `<st c="59421">Pipfile.lock</st>` <st c="59433">can help make sure the right package
    versions are installed.</st> <st c="59495">If internal packages are used, it is
    wise to prevent downloads from public sources.</st> <st c="59579">When considering
    a new dependency, it’s beneficial to meticulously review its history, the credibility
    of its maintainers, the contribution process, and its</st> <st c="59735">recent
    changes.</st> <st c="59752">This diligence in package selection and the associated
    security practices should be integral components of any security training strategy.</st>
    <st c="59891">All of these are part of a comprehensive dependency management strategy
    that we will cover later in</st> [*<st c="59991">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122)
    <st c="60000">of</st> <st c="60004">this book.</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60014">Risk 3 – Exposed secret risk</st>
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="60043">To enhance</st> <st c="60054">their functionality, modern applications
    frequently interface with various services, such as databases, cloud storage,
    and third-party APIs.</st> <st c="60196">As a result, developers often handle
    secrets such as authentication tokens, passwords, and API keys during the coding
    process to enable and test</st> <st c="60341">these integrations.</st>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60360">A common mistake is accidentally committing these secrets into
    VCSs such as Git.</st> <st c="60442">Once pushed, especially to public repositories,
    these secrets can be accessed by malicious actors, leading to potential data breaches
    or unauthorized access.</st> <st c="60600">This is also a risk in private repositories
    where internal threats are just as dangerous as external threats.</st> <st c="60710">Keep
    in mind that private repositories may become public in the future.</st> <st c="60782">A
    recent example is the accidental leak of</st> <st c="60824">Azure Storage</st>
    **<st c="60839">shared access signature</st>** <st c="60862">(</st>**<st c="60864">SAS</st>**<st
    c="60867">) tokens by Microsoft AI researchers in their public GitHub repository.</st>
    <st c="60940">This leak led to the breach of 38 TB of</st> <st c="60980">private
    data.</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60993">Note – Analysis of leak in Microsoft’s AI GitHub repository</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61053">To read more about the breach, please refer to this</st> <st c="61106">document:</st>
    [<st c="61116">https://www.wiz.io/blog/38-terabytes-of-private-data-accidentally-exposed-by-microsoft-ai-researchers</st>](https://www.wiz.io/blog/38-terabytes-of-private-data-accidentally-exposed-by-microsoft-ai-researchers)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61217">The challenge of managing secrets in code is multifaceted.</st>
    <st c="61277">It is not just about avoiding committing them, but also about securely
    storing, accessing, and rotating them.</st> <st c="61387">A holistic approach
    is required to tackle this risk.</st> <st c="61440">A clear process should be
    implemented for secret management, and development teams should be educated on
    secret management within the Azure ecosystem.</st> <st c="61591">We will cover
    secret management in a DevOps process with Azure Key Vault later in</st> <st c="61673">this
    book.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61217">在代码中管理机密的挑战是多方面的。</st> <st c="61277">这不仅仅是避免将它们提交，还包括安全地存储、访问和轮换它们。</st>
    <st c="61387">需要一种整体的方法来应对这一风险。</st> <st c="61440">应实施清晰的机密管理流程，并且开发团队应接受在 Azure
    生态系统中进行机密管理的培训。</st> <st c="61591">我们将在本书后面讨论如何使用 Azure Key Vault 进行 DevOps 过程中的机密管理。</st>
    <st c="61673">本书后续将详细讲解。</st>
- en: <st c="61683">In the pre-commit</st> <st c="61702">phase, secret scanning tools,
    similar to SAST tools, can be integrated to detect secrets or sensitive information
    in code bases.</st> <st c="61831">They scan the code for patterns that match common
    secret formats, such as Azure service keys or</st> <st c="61927">connection strings.</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61683">在提交前</st> <st c="61702">阶段，可以集成类似于 SAST 工具的机密扫描工具，以检测代码库中的机密或敏感信息。</st>
    <st c="61831">它们扫描代码，寻找与常见机密格式匹配的模式，如 Azure 服务密钥或</st> <st c="61927">连接字符串。</st>
- en: <st c="61946">These tools operate by using pattern matching, entropy checks,
    and sometimes ML to identify potential secrets in the code.</st> <st c="62070">For
    instance, a string that looks like an Azure service key would be flagged.</st>
    <st c="62148">They can be seamlessly integrated into the pre-commit phase, similar
    to SAST tools, to catch potential leaks before they are committed to</st> <st
    c="62286">source control.</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61946">这些工具通过使用模式匹配、熵检查，有时还会使用机器学习来识别代码中的潜在机密。</st> <st c="62070">例如，看起来像
    Azure 服务密钥的字符串将会被标记出来。</st> <st c="62148">它们可以无缝集成到提交前阶段，类似于 SAST 工具，以便在代码提交到</st>
    <st c="62286">源代码管理系统之前捕获潜在的泄露。</st>
- en: <st c="62301">Choosing the right developer-first security tooling</st>
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="62301">选择合适的以开发者为中心的安全工具</st>
- en: <st c="62353">The best tools make it easier for engineers to do their work or
    make their work more enjoyable.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62353">最好的工具能让工程师更轻松地完成工作，或让工作变得更加愉快。</st>
- en: <st c="62449">Tooling plays a</st> <st c="62465">critical role in implementing
    DevSecOps.</st> <st c="62507">Selecting the right tools for the pre-commit phase
    should be a joint decision involving all teams in the software development process.</st>
    <st c="62642">To simplify management and roll out at scale, it is advisable to
    adopt tools that provide a platform-first approach with a developer-first focus.</st>
    <st c="62788">This may not always be possible due to technological stack support
    limitations or</st> <st c="62870">even budget.</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62449">工具在实施 DevSecOps 中扮演着</st> <st c="62465">至关重要的角色。</st> <st c="62507">选择适合提交前阶段的工具应该是一个由所有软件开发过程中的团队共同决定的过程。</st>
    <st c="62642">为了简化管理并在大规模推广时更为高效，建议采用那些提供平台优先、以开发者为中心的工具。</st> <st c="62788">由于技术栈支持限制或</st>
    <st c="62870">预算问题，这可能并不总是可行的。</st>
- en: <st c="62882">Developer-first security tooling refers to security tools and
    solutions that prioritize the needs of developers in the software development
    process.</st> <st c="63032">These categories of tools focus on providing developers
    with the necessary capabilities to develop secure applications from the beginning
    and integrate well with standard</st> <st c="63203">development workflows.</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62882">以开发者为中心的安全工具是指那些在软件开发过程中优先考虑开发者需求的安全工具和解决方案。</st> <st c="63032">这些工具类别专注于为开发者提供必要的功能，从一开始就帮助他们开发安全的应用程序，并能与标准的</st>
    <st c="63203">开发工作流良好集成。</st>
- en: <st c="63225">Developers tend to prefer tools that enhance their productivity
    and make their work easier and more enjoyable.</st> <st c="63337">Surveys from
    Stack Overflow and JetBrains in 2020 showed that developers value tools that are
    easy to use, integrate well with their environment, and support their preferred
    languages and frameworks.</st> <st c="63537">Work with them to select the best
    tools for</st> *<st c="63581">them</st>*<st c="63585">. It is pointless to choose
    tools that will not</st> <st c="63633">be used.</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63225">开发者通常倾向于选择能够提升生产力、让工作更轻松愉快的工具。</st> <st c="63337">2020年Stack Overflow和JetBrains的调查显示，开发者重视那些易于使用、与环境良好集成，并支持其首选语言和框架的工具。</st>
    <st c="63537">与他们合作，选择最适合的工具。</st> *<st c="63581">选择不被使用的工具是毫无意义的。</st>*<st c="63585">
    </st>
- en: <st c="63641">Besides meeting developers’ needs, tools in this phase should
    also promote collaboration among all stakeholders.</st> <st c="63755">This ensures
    everyone takes part in the collective responsibility of security.</st> <st c="63834">For
    example, tools should allow easy sharing of security findings</st> <st c="63900">among
    teams.</st> <st c="63913">If a team has created a great query for detecting a
    vulnerable coding pattern, your tool should allow an easy roll-out of the custom
    query to other teams in</st> <st c="64070">your organization.</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63641">除了满足开发者需求外，这一阶段的工具还应促进所有利益相关者之间的协作。</st> <st c="63755">这确保每个人都参与到集体的安全责任中。</st>
    <st c="63834">例如，工具应允许团队之间轻松共享安全发现</st> <st c="63900">。</st> <st c="63913">如果一个团队创建了一个出色的查询，用于检测易受攻击的编码模式，你的工具应允许轻松将该自定义查询推广到组织中的其他团队。</st>
    <st c="64070">。</st>
- en: <st c="64088">Emphasis should be on choosing tools that deliver both</st> *<st
    c="64144">useful</st>* <st c="64150">and</st> *<st c="64155">actionable</st>*
    <st c="64165">feedback.</st> <st c="64176">Many tools might give information,
    but if it is not actionable, it is of little value.</st> <st c="64263">Actionable
    feedback is crucial as it educates developers on the reasons behind security flags
    and how to avoid them in</st> <st c="64382">the future.</st>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64088">选择工具时应重点考虑那些能提供</st> *<st c="64144">有用</st>* <st c="64150">且</st>
    *<st c="64155">可操作</st>* <st c="64165">反馈的工具。</st> <st c="64176">许多工具可能会提供信息，但如果信息不可操作，则价值不大。</st>
    <st c="64263">可操作的反馈至关重要，因为它可以教育开发者了解安全警告背后的原因，并告诉他们如何避免未来的类似问题。</st>
- en: <st c="64393">Hands-on exercise 1 – Performing code review, dependency checks,
    and secret scanning on the IDE</st>
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="64393">动手练习1 – 在IDE上执行代码审查、依赖检查和秘密扫描</st>
- en: <st c="64489">To complete</st> <st c="64502">this hands-on exercise, you need
    to have completed the hands-on exercise (</st>*<st c="64576">Hands-on exercise
    1 – Provisioning the lab VM</st>*<st c="64622">) from the previous chapter where
    we provisioned the lab VM.</st> <st c="64684">In this exercise, we will be performing</st>
    <st c="64724">code reviews, checking dependency vulnerabilities, and scanning
    for secrets within our code.</st> <st c="64817">This is an important</st> <st
    c="64838">phase of shifting security left as we get to identify and fix many vulnerabilities
    before committing</st> <st c="64939">the code.</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64489">要完成</st> <st c="64502">这个动手练习，你需要先完成前一章节中的动手练习（</st>*<st c="64576">动手练习1
    – 配置实验室虚拟机</st>*<st c="64622">），我们在其中配置了实验室虚拟机。</st> <st c="64684">在这个练习中，我们将进行</st>
    <st c="64724">代码审查、检查依赖关系漏洞，并扫描代码中的秘密信息。</st> <st c="64817">这是实现安全左移的重要阶段，因为我们可以在提交</st>
    <st c="64939">代码之前识别并修复许多漏洞。</st>
- en: <st c="64948">In this exercise, we will use the</st> `<st c="64983">eShopOnWeb</st>`
    <st c="64993">application.</st> <st c="65007">This application is related to eShopOnContainers
    application which focuses on containers and microservices.</st> <st c="65115">eShopOnWeb
    on the other hand focuses on traditional web application development.</st> *<st
    c="65196">Figure 4</st>**<st c="65204">.18</st>* <st c="65207">shows the reference
    architecture of the</st> <st c="65248">eShopOnContainers application:</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用`<st c="64983">eShopOnWeb</st>`应用程序。<st c="64993">该应用程序与eShopOnContainers应用程序相关，后者专注于容器和微服务。</st>
    <st c="65007">另一方面，eShopOnWeb则专注于传统的Web应用程序开发。</st> *<st c="65196">图4</st>**<st
    c="65204">.18</st>* <st c="65207">展示了</st> <st c="65248">eShopOnContainers应用程序的参考架构：</st>
- en: '![Figure 4.18 – eShopOnContainers reference architecture (Source: https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/introduce-eshoponcontainers-reference-app)](img/B19710_03_15.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.18 – eShopOnContainers 参考架构（来源: https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/introduce-eshoponcontainers-reference-app）](img/B19710_03_15.jpg)'
- en: '<st c="65814">Figure 4.18 – eShopOnContainers reference architecture (Source:
    https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/introduce-eshoponcontainers-reference-app)</st>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="65814">图 4.18 – eShopOnContainers 参考架构（来源: https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/introduce-eshoponcontainers-reference-app）</st>'
- en: <st c="65987">Following are the tasks that we will complete in</st> <st c="66037">this
    exercise:</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65987">以下是我们将在</st> <st c="66037">本次练习中完成的任务：</st>
- en: '**<st c="66051">Task 1</st>**<st c="66058">: Connecting to the lab VM using</st>
    <st c="66092">Azure Bastion</st>'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="66051">任务 1</st>**<st c="66058">：使用</st> <st c="66092">Azure Bastion
    连接到实验室虚拟机</st>'
- en: '**<st c="66105">Task 2</st>**<st c="66112">: Configuring Snyk on Visual</st>
    <st c="66142">Studio Code</st>'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="66105">任务 2</st>**<st c="66112">：在 Visual Studio Code 上配置 Snyk</st>'
- en: '`<st c="66173">eShopOnWeb</st>` <st c="66183">to your Visual Studio</st> <st
    c="66206">Code workspace</st>'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="66173">eShopOnWeb</st>` <st c="66183">到你的 Visual Studio</st> <st c="66206">Code
    工作空间</st>'
- en: <st c="66220">Task 1 – Connecting to the lab VM using Azure Bastion</st>
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="66220">任务 1 – 使用 Azure Bastion 连接到实验室虚拟机</st>
- en: <st c="66274">The aim of this task is</st> <st c="66298">to use the Bastion
    service to</st> <st c="66329">establish a connection with the</st> <st c="66361">lab
    VM:</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66274">此任务的目标是</st> <st c="66298">使用 Bastion 服务</st> <st c="66329">建立与</st>
    <st c="66361">实验室虚拟机的连接：</st>
- en: <st c="66368">On the Azure portal home page, in the search box, type</st> `<st
    c="66424">DevSecOps-LabVM</st>` <st c="66439">and select the</st> `<st c="66455">DevSecOps-LabVM</st>`
    <st c="66470">VM when</st> <st c="66479">it appears:</st>
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="66368">在 Azure 门户主页的搜索框中，输入</st> `<st c="66424">DevSecOps-LabVM</st>`
    <st c="66439">并在出现时选择</st> `<st c="66455">DevSecOps-LabVM</st>` <st c="66470">虚拟机：</st>
- en: '![Figure 4.19 – Selecting the DevSecOps-LabVM VM](img/B19710_04_19.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.19 – 选择 DevSecOps-LabVM 虚拟机](img/B19710_04_19.jpg)'
- en: <st c="66715">Figure 4.19 – Selecting the DevSecOps-LabVM VM</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66715">图 4.19 – 选择 DevSecOps-LabVM 虚拟机</st>
- en: <st c="66761">In</st> <st c="66764">the</st> **<st c="66769">DevSecOps-LabVM</st>**
    <st c="66784">window, in</st> <st c="66796">the</st> **<st c="66800">Connect</st>**
    <st c="66807">section, click on</st> **<st c="66826">Connect</st>** <st c="66833">|</st>
    **<st c="66836">Go</st>** **<st c="66839">to Bastion</st>**<st c="66849">:</st>
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="66761">在</st> <st c="66764">**<st c="66769">DevSecOps-LabVM</st>** <st
    c="66784">窗口中，在</st> <st c="66796">**<st c="66800">连接</st>** <st c="66807">部分，点击</st>
    **<st c="66826">连接</st>** <st c="66833">|</st> **<st c="66836">前往 Bastion</st>**<st
    c="66849">：</st>
- en: '![Figure 4.20 – Selecting the option to connect to the VM using Bastion](img/B19710_04_20.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.20 – 选择使用 Bastion 连接虚拟机的选项](img/B19710_04_20.jpg)'
- en: <st c="67638">Figure 4.20 – Selecting the option to connect to the VM using
    Bastion</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67638">图 4.20 – 选择使用 Bastion 连接虚拟机的选项</st>
- en: <st c="67707">In the</st> `<st c="67806">azureuser</st>`
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="67707">在</st> `<st c="67806">azureuser</st>`
- en: '**<st c="67815">Authentication</st>** **<st c="67831">Type</st>**<st c="67835">:</st>
    **<st c="67838">Password</st>**'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="67815">身份验证</st>** **<st c="67831">类型</st>**<st c="67835">：</st> **<st
    c="67838">密码</st>**'
- en: '**<st c="67846">Password</st>**<st c="67855">: Enter the password that you
    specified during the</st> <st c="67907">template deployment</st>'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="67846">密码</st>**<st c="67855">：输入你在</st> <st c="67907">模板部署时指定的密码</st>'
- en: '**<st c="67926">Open in new browser</st>** **<st c="67947">tab</st>**<st c="67950">:
    Selected</st>'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="67926">在新浏览器中打开</st>** **<st c="67947">标签</st>**<st c="67950">：已选择</st>'
- en: <st c="67961">Click</st> **<st c="67968">Connect</st>**
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="67961">点击</st> **<st c="67968">连接</st>**
- en: '![Figure 4.21 – Configuring the VM credentials and initiating a connection
    to the VM](img/B19710_04_21.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.21 – 配置虚拟机凭证并启动连接到虚拟机](img/B19710_04_21.jpg)'
- en: <st c="68145">Figure 4.21 – Configuring the VM credentials and initiating a
    connection to the VM</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68145">图 4.21 – 配置虚拟机凭证并启动连接到虚拟机</st>
- en: <st c="68227">If prompted, enable</st> <st c="68247">a pop-up window</st> <st
    c="68264">for the connection to be successful.</st> <st c="68301">Also, click
    to allow clipboard access</st> <st c="68339">if prompted:</st>
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="68227">如果出现提示，启用</st> <st c="68247">弹出窗口</st> <st c="68264">以确保连接成功。</st>
    <st c="68301">另外，如果提示，点击允许访问剪贴板</st> <st c="68339">：</st>
- en: <st c="68351">Now that you have access</st> <st c="68377">to the lab VM, let
    us perform code review, dependency checks, secret scanning, and</st> **<st c="68460">software
    bill of materials</st>** <st c="68486">(</st>**<st c="68488">SBOM</st>**<st c="68492">)
    generation within</st> <st c="68513">the IDE.</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68351">现在你已经可以访问</st> <st c="68377">实验室虚拟机，让我们在 IDE 中进行代码审查、依赖检查、秘密扫描和</st>
    **<st c="68460">软件物料清单</st>** <st c="68486">(</st>**<st c="68488">SBOM</st>**<st
    c="68492">) 生成。</st>
- en: <st c="68521">Task 2 – Configuring Snyk on Visual Studio Code</st>
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="68521">任务 2 – 在 Visual Studio Code 中配置 Snyk</st>
- en: <st c="68569">In this task, we will</st> <st c="68591">set up our scanning tool
    within</st> <st c="68624">Visual Studio Code.</st> <st c="68644">We</st> <st c="68646">will
    be using Snyk (</st>[<st c="68667">snyk.io</st>](http://snyk.io)<st c="68675">):</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68569">在本任务中，我们将</st> <st c="68591">在</st> <st c="68624">Visual Studio
    Code 中设置扫描工具。</st> <st c="68644">我们</st> <st c="68646">将使用 Snyk（</st>[<st c="68667">snyk.io</st>](http://snyk.io)<st
    c="68675">）：</st>
- en: <st c="68678">On the Desktop of the lab VM, you will find Visual Studio Code.</st>
    <st c="68743">This was pre-installed for you.</st> <st c="68775">Go ahead and
    open Visual</st> <st c="68800">Studio Code.</st>
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="68678">在实验室虚拟机的桌面上，你会找到 Visual Studio Code。</st> <st c="68743">这个程序已经为你预先安装好。</st>
    <st c="68775">请打开 Visual</st> <st c="68800">Studio Code。</st>
- en: <st c="68812">There are several open source and commercial tools you can use
    in your IDE to perform code scanning, dependency checks, secrets scanning, and
    SBOM generation.</st> <st c="68972">The</st> <st c="68975">choice of the source
    code analysis tool depends on several things, including the programming language
    in use, whether the tool is open source or</st> <st c="69121">commercial, the
    accuracy of the tool, availability as an extension with preferred IDEs, and so
    on.</st> <st c="69220">It is therefore important for you to review which tool
    will work for your use cases and have proper</st> **<st c="69320">proofs of concept</st>**
    <st c="69337">(</st>**<st c="69339">POCs</st>**<st c="69343">) done</st> <st c="69350">before
    going forward with a particular tool.</st> <st c="69396">The</st> **<st c="69400">Open
    Worldwide Application Security Project</st>** <st c="69443">(</st>**<st c="69445">OWASP</st>**<st
    c="69450">) (</st>[<st c="69454">https://owasp.org/www-community/Source_Code_Analysis_Tools</st>](https://owasp.org/www-community/Source_Code_Analysis_Tools)<st
    c="69513">) shows</st> <st c="69521">a list of some of the tools available in
    the market, platforms supported, and programming languages scanned.</st> <st c="69631">For
    this exercise, we will</st> <st c="69658">be using Snyk, which scans for open
    source security, code security, and</st> **<st c="69730">Infrastructure as Code</st>**
    <st c="69752">(</st>**<st c="69754">IaC</st>**<st c="69757">) security.</st>
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="68812">在 IDE 中，你可以使用多种开源和商业工具进行代码扫描、依赖检查、秘密扫描和 SBOM 生成。</st> <st c="68972">选择源代码分析工具取决于多个因素，包括使用的编程语言、工具是否开源或</st>
    <st c="69121">商业化、工具的准确性、是否作为扩展支持常用的 IDE 等等。</st> <st c="69220">因此，了解哪些工具适合你的使用场景，并在继续使用某个工具之前进行适当的</st>
    **<st c="69320">概念验证</st>** <st c="69337">(</st>**<st c="69339">POC</st>**<st
    c="69343">) 非常重要。</st> <st c="69350">在使用特定工具之前，进行充分验证。</st> <st c="69396">以下是</st>
    **<st c="69400">全球开源应用程序安全项目</st>** <st c="69443">(</st>**<st c="69445">OWASP</st>**<st
    c="69450">)（</st>[<st c="69454">https://owasp.org/www-community/Source_Code_Analysis_Tools</st>](https://owasp.org/www-community/Source_Code_Analysis_Tools)<st
    c="69513">）列出了市场上可用的一些工具、支持的平台和扫描的编程语言。</st> <st c="69631">对于这个练习，我们将</st> <st
    c="69658">使用 Snyk，它可以扫描开源安全性、代码安全性以及</st> **<st c="69730">基础设施即代码</st>** <st c="69752">(</st>**<st
    c="69754">IaC</st>**<st c="69757">) 安全性。</st>
- en: <st c="69769">Let’s install the Snyk Visual Studio Code extension by going to</st>
    `<st c="69877">Snyk</st>` <st c="69881">in the search bar.</st> <st c="69901">Click
    on the first instance of Snyk, as shown in the following screenshot, and</st>
    <st c="69980">then</st> **<st c="69985">Install</st>**<st c="69992">:</st>
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="69769">我们通过在搜索栏中输入</st> `<st c="69877">Snyk</st>` <st c="69881">来安装 Snyk
    Visual Studio Code 扩展。</st> <st c="69901">点击搜索结果中的第一个 Snyk 实例，如下图所示，然后</st> <st
    c="69980">点击</st> **<st c="69985">安装</st>**<st c="69992">：</st>
- en: '![Figure 4.22 – Installing Snyk Visual Studio Code extension](img/B19710_04_22.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.22 – 安装 Snyk Visual Studio Code 扩展](img/B19710_04_22.jpg)'
- en: <st c="70691">Figure 4.22 – Installing Snyk Visual Studio Code extension</st>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="70691">图 4.22 – 安装 Snyk Visual Studio Code 扩展</st>
- en: <st c="70749">Next, let’s configure the Snyk Visual Studio Code extension.</st>
    <st c="70811">We configure the extension</st> <st c="70837">from the extension
    settings, which can be accessed by clicking on the Snyk logo on the left and clicking
    on the</st> <st c="70949">settings icon, then</st> **<st c="70970">Extension Settings</st>**<st
    c="70988">:</st>
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="70749">接下来，让我们配置 Snyk Visual Studio Code 扩展。</st> <st c="70811">我们从扩展设置开始配置</st>
    <st c="70837">，可以通过点击左侧的 Snyk 图标并点击</st> <st c="70949">设置图标来访问，接着选择</st> **<st
    c="70970">扩展设置</st>**<st c="70988">：</st>
- en: '![Figure 4.23 – Snyk extension settings](img/B19710_04_23.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.23 – Snyk 扩展设置](img/B19710_04_23.jpg)'
- en: <st c="71503">Figure 4.23 – Snyk extension settings</st>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="71503">图 4.23 – Snyk 扩展设置</st>
- en: <st c="71540">Now, let’s configure the Synk extension</st> <st c="71581">as
    follows:</st>
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="71540">现在，让我们按以下步骤配置 Synk 扩展</st> <st c="71581">：</st>
- en: '`<st c="71628">--all-projects</st>`'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="71628">--all-projects</st>`'
- en: '**<st c="71642">Advanced: Automatic Dependency Management</st>** <st c="71684">is
    checked</st>'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="71642">高级：自动依赖管理</st>** <st c="71684">已选中</st>'
- en: '**<st c="71695">Advanced Auto Scan Open Source Security</st>** <st c="71735">is
    checked:</st>'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="71695">高级自动扫描开源安全</st>** <st c="71735">已选中：</st>'
- en: '![Figure 4.24 – Snyk advanced extension settings](img/B19710_04_24.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.24 – Snyk 高级扩展设置](img/B19710_04_24.jpg)'
- en: <st c="72486">Figure 4.24 – Snyk advanced extension settings</st>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="72486">图 4.24 – Snyk 高级扩展设置</st>
- en: <st c="72532">Check</st> <st c="72539">the</st> **<st c="72543">Code Quality</st>**<st
    c="72555">,</st> **<st c="72557">Code Security</st>**<st c="72570">,</st> **<st
    c="72572">Infrastructure As Code</st>**<st c="72594">, and</st> **<st c="72600">Open
    Source Security</st>** <st c="72620">Snyk features:</st>
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="72532">勾选</st> <st c="72539">以下 Snyk 特性：</st> **<st c="72543">代码质量</st>**<st
    c="72555">、</st> **<st c="72557">代码安全</st>**<st c="72570">、</st> **<st c="72572">基础设施即代码</st>**<st
    c="72594">和</st> **<st c="72600">开源安全</st>** <st c="72620">：</st>
- en: '![Figure 4.25 – Snyk features extension settings](img/B19710_04_25.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.25 – Snyk 特性扩展设置](img/B19710_04_25.jpg)'
- en: <st c="72963">Figure 4.25 – Snyk features extension settings</st>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="72963">图 4.25 – Snyk 特性扩展设置</st>
- en: '<st c="73009">Lastly, make sure</st> **<st c="73028">Snyk: Scanning Mode</st>**
    <st c="73047">is set to</st> **<st c="73058">auto</st>** <st c="73062">and</st>
    **<st c="73067">Snyk: Severity</st>** <st c="73081">is checked</st> <st c="73092">for</st>
    **<st c="73097">critical</st>**<st c="73105">,</st> **<st c="73107">high</st>**<st
    c="73111">,</st> **<st c="73113">medium</st>**<st c="73119">, and</st> **<st c="73125">low</st>**<st
    c="73128">, as</st> <st c="73133">shown in the</st> <st c="73146">following screenshot:</st>'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '<st c="73009">最后，确保</st> **<st c="73028">Snyk: 扫描模式</st>** <st c="73047">已设置为</st>
    **<st c="73058">自动</st>** <st c="73062">并且</st> **<st c="73067">Snyk: 严重性</st>**
    <st c="73081">已选中</st> <st c="73092">用于</st> **<st c="73097">严重</st>**<st c="73105">、</st>
    **<st c="73107">高</st>**<st c="73111">、</st> **<st c="73113">中</st>**<st c="73119">和</st>
    **<st c="73125">低</st>**<st c="73128">，如下面的截图所示：</st>'
- en: '![Figure 4.26 – Snyk scanning and severity extension settings](img/B19710_04_26.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.26 – Snyk 扫描和严重性扩展设置](img/B19710_04_26.jpg)'
- en: <st c="73349">Figure 4.26 – Snyk scanning and severity extension settings</st>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73349">图 4.26 – Snyk 扫描和严重性扩展设置</st>
- en: <st c="73408">For Synk to scan your projects, you must be authenticated with
    Snyk using your Snyk API token.</st> <st c="73504">Click on the Snyk icon, then
    select</st> **<st c="73540">Trust workspace</st>** **<st c="73556">and connect</st>**<st
    c="73567">:</st>
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="73408">为了让 Synk 扫描你的项目，你必须使用 Snyk API 密钥进行身份验证。</st> <st c="73504">点击
    Snyk 图标，然后选择</st> **<st c="73540">信任工作区</st>** **<st c="73556">并连接</st>**<st c="73567">：</st>
- en: '![Figure 4.27 – Setting up Snyk code extension authentication](img/B19710_04_27.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.27 – 设置 Snyk 代码扩展身份验证](img/B19710_04_27.jpg)'
- en: <st c="73996">Figure 4.27 – Setting up Snyk code extension authentication</st>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="73996">图 4.27 – 设置 Snyk 代码扩展身份验证</st>
- en: <st c="74055">Clicking</st> **<st c="74065">Trust workspace and connect</st>**
    <st c="74092">will take</st> <st c="74103">you to the Snyk web application</st>
    <st c="74134">for authentication.</st> <st c="74155">Click</st> **<st c="74161">Authenticate</st>**<st
    c="74173">:</st>
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="74055">点击</st> **<st c="74065">信任工作区并连接</st>** <st c="74092">将带你进入 Snyk
    网页应用程序</st> <st c="74134">进行身份验证。</st> <st c="74155">点击</st> **<st c="74161">身份验证</st>**<st
    c="74173">：</st>
- en: '![Figure 4.28 – Snyk web application authentication](img/B19710_04_28.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.28 – Snyk 网页应用程序身份验证](img/B19710_04_28.jpg)'
- en: <st c="74326">Figure 4.28 – Snyk web application authentication</st>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="74326">图 4.28 – Snyk 网页应用程序身份验证</st>
- en: <st c="74375">After successful authentication, you will receive the confirmation
    as follows.</st> <st c="74455">Close the browser and go back to Visual</st> <st
    c="74495">Studio Code:</st>
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Snyk successful authentication](img/B19710_04_29.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: <st c="74589">Figure 4.29 – Snyk successful authentication</st>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74633">We can now</st> <st c="74644">proceed to</st> *<st c="74656">Task
    3</st>* <st c="74662">after successfully configuring</st> <st c="74694">the</st>
    <st c="74698">Snyk extension.</st>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74713">Visual Studio Code extension authentication</st>
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74757">Please note, if the above steps cannot successfully configure
    your Synk extension, you may need to manually set the token by</st> <st c="74883">following
    these:</st>
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[<st c="74899">https://docs.snyk.io/scm-ide-and-ci-cd-integrations/snyk-ide-plugins-and-extensions/visual-studio-code-extension/visual-studio-code-extension-authentication</st>](https://docs.snyk.io/scm-ide-and-ci-cd-integrations/snyk-ide-plugins-and-extensions/visual-studio-code-extension/visual-studio-code-extension-authentication)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[<st c="75056">https://docs.snyk.io/getting-started/how-to-obtain-and-authenticate-with-your-snyk-api-token</st>](https://docs.snyk.io/getting-started/how-to-obtain-and-authenticate-with-your-snyk-api-token)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="75149">Task 3 – Importing eShopOnWeb to your Visual Studio Code workspace</st>
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="75216">In this task, we will</st> <st c="75239">import the application
    we will be working on</st> <st c="75284">going forward:</st>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75298">We will be</st> <st c="75309">reviewing</st> `<st c="75320">eShopOnWeb</st>`
    <st c="75330">application for security vulnerabilities in your Visual Studio Code
    editor.</st> <st c="75407">Navigate to</st> **<st c="75419">EXPLORER</st>** <st
    c="75427">on the left pane of your Visual Studio Code editor and click on</st>
    **<st c="75492">Clone Repository</st>**<st c="75508">:</st>
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.30 – Clone Repository](img/B19710_04_30.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: <st c="75838">Figure 4.30 – Clone Repository</st>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75868">Paste</st> <st c="75875">the</st> `<st c="75879">eShopOnWeb</st>`
    <st c="75889">repository (</st>[<st c="75902">https://github.com/PacktPublishing/eShopOnWeb_DevSecOps</st>](https://github.com/PacktPublishing/eShopOnWeb_DevSecOps)<st
    c="75958">) to clone from GitHub, then select the</st> **<st c="75999">Clone from
    URL</st>** **<st c="76014">https://github.com/PacktPublishing/eShopOnWeb_DevSecOps</st>**
    <st c="76069">option:</st>
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.31 – Clone from GitHub](img/B19710_04_31.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
- en: <st c="76209">Figure 4.31 – Clone from GitHub</st>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76240">You will be</st> <st c="76252">required to select a folder as
    the repository destination.</st> <st c="76312">Click</st> `<st c="76346">eShop</st>`<st
    c="76351">, and then click</st> **<st c="76368">Select as</st>** **<st c="76378">Repository
    Destination</st>**<st c="76400">:</st>
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.32 – Selecting a folder as the repository destination](img/B19710_04_32.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: <st c="76702">Figure 4.32 – Selecting a folder as the repository destination</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76764">A popup</st> <st c="76772">will</st> <st c="76778">appear on the
    bottom-right corner of Visual Studio Code showing the status of the cloning.</st>
    <st c="76869">After completion, you will be asked to open the cloned repository;</st>
    <st c="76936">click</st> **<st c="76942">Open</st>**<st c="76946">:</st>
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.33 – Opening cloned repository](img/B19710_04_33.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: <st c="77055">Figure 4.33 – Opening cloned repository</st>
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77094">You will be asked if you trust the authors of the files in the
    folder.</st> <st c="77166">Select</st> **<st c="77173">Yes, I trust</st>** **<st
    c="77186">the authors</st>**<st c="77197">:</st>
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.34 – Trusting the authors of files](img/B19710_04_34.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: <st c="77601">Figure 4.34 – Trusting the authors of files</st>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77644">Snyk will</st> <st c="77655">then</st> <st c="77659">send a notification
    (in the bottom-right corner of Visual Studio Code) asking</st> **<st c="77738">Trust
    folders and continue</st>** <st c="77764">or</st> **<st c="77768">Don’t trust
    folders</st>**<st c="77787">. Select</st> **<st c="77796">Trust folders</st>**
    **<st c="77810">and continue</st>**<st c="77822">.</st>
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="77823">Snyk will then start analyzing the files and give the number of
    security issues in the bottom-left corner of your Visual Studio</st> <st c="77952">Code
    editor:</st>
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.35 – Snyk showing the number of security issues](img/B19710_04_35.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: <st c="78003">Figure 4.35 – Snyk showing the number of security issues</st>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78059">Click on the number of problems; this will then show the details
    of security vulnerabilities found</st> <st c="78159">by Snyk:</st>
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.36 – List of security issues found on eShop](img/B19710_04_36.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: <st c="79438">Figure 4.36 – List of security issues found on eShop</st>
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79490">Go through</st> <st c="79502">the</st> <st c="79506">list of code
    security, configuration, and code quality issues to understand some of the</st>
    <st c="79594">issues found:</st>
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.37 – Code security, configuration, and code quality on eShop](img/B19710_04_37.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: <st c="80738">Figure 4.37 – Code security, configuration, and code quality on
    eShop</st>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80807">Review the list of errors generated for code security, configuration,
    and code quality.</st> <st c="80896">Select one code security error to understand
    details about the vulnerability, the line of code that is vulnerable, and suggestions
    to fix</st> <st c="81034">the vulnerabilities.</st>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81054">Hands-on exercise 2 – Installing and configuring Git pre-commit
    hooks on the IDE</st>
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="81135">In this exercise, we</st> <st c="81157">will install and configure
    Git pre-commit hooks.</st> <st c="81206">As we discussed earlier, a pre-commit
    hook is a specific type of Git hook that is triggered right before a commit is
    recorded.</st> <st c="81333">We will be using the pre-commit framework (</st>[<st
    c="81376">https://pre-commit.com</st>](https://pre-commit.com)<st c="81399">).</st>
    <st c="81403">The</st> <st c="81407">pre-commit framework allows developers to
    leverage a wide array</st> <st c="81471">of existing hooks and easily integrate
    them into their repositories.</st> <st c="81540">A list of supported hooks can
    be found here:</st> [<st c="81585">https://pre-commit.com/hooks.html</st>](https://pre-commit.com/hooks.html)<st
    c="81618">. The hooks are defined in a</st> `<st c="81647">.pre-commit-config.yaml</st>`
    <st c="81670">file, and the tool takes care of installing them into the appropriate
    Git</st> <st c="81745">hooks directory.</st>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81761">Following are the tasks that we will complete in</st> <st c="81811">this
    exercise:</st>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="81825">Task 1</st>**<st c="81832">: Installing pre-commit framework
    on Visual</st> <st c="81877">Studio Code</st>'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="81910">detect-private key</st>` <st c="81928">and</st> `<st c="81933">detect-secrets</st>`
    <st c="81947">pre-commit hooks on Visual</st> <st c="81975">Studio Code</st>'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="81986">Task 1 – Installing pre-commit framework on Visual Studio Code</st>
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="82049">In this task, we</st> <st c="82067">will set up a</st> <st c="82081">pre-commit
    framework tool within Visual</st> <st c="82121">Studio Code:</st>
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: <st c="82133">Install the pre-commit package manager using</st> `<st c="82179">pip</st>`<st
    c="82182">. Run the following command on your Visual</st> <st c="82225">Studio
    terminal:</st>
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 4.38 – Pre-commit version installed](img/B19710_04_38.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: <st c="82455">Figure 4.38 – Pre-commit version installed</st>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: <st c="82497">Task 2 – Configuring detect-private key and detect-secrets pre-commit
    hooks on Visual Studio Code</st>
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="82595">In this task, we</st> <st c="82613">will configure two pre-commit
    hooks.</st> <st c="82650">Review</st> <st c="82657">the list of</st> <st c="82669">supported
    hooks on</st> [<st c="82688">https://pre-commit.com/hooks.html</st>](https://pre-commit.com/hooks.html)<st
    c="82721">. You can configure more than one hook in the</st> `<st c="82767">.pre-commit-config.yaml</st>`
    <st c="82790">file.</st> <st c="82797">In this task, we will be configuring the</st>
    `<st c="82838">detect-private-key</st>` <st c="82856">from</st> [<st c="82862">https://github.com/pre-commit/pre-commit-hooks</st>](https://github.com/pre-commit/pre-commit-hooks)
    <st c="82908">and</st> `<st c="82913">detect-secrets</st>` <st c="82927">from</st>
    [<st c="82933">github.com/Yelp/detect-secrets</st>](http://github.com/Yelp/detect-secrets)<st
    c="82963">:</st>
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: <st c="82965">Create a file within the root directory of the</st> `<st c="83012">eShoponWeb</st>`
    <st c="83022">application and name</st> <st c="83044">it</st> `<st c="83047">.pre-commit-config.yaml</st>`<st
    c="83070">.</st>
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="83071">Add the following script in the</st> `<st c="83104">.</st>``<st
    c="83105">pre-commit-config.yaml</st>` <st c="83128">file:</st>
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.39 – Configuring pre-commit hooks](img/B19710_04_39.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: <st c="83343">Figure 4.39 – Configuring pre-commit hooks</st>
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83385">Let’s now install the Git hook scripts by running</st> `<st c="83436">pre-commit
    install</st>`<st c="83454">:</st>
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.40 – Installing Git hook scripts](img/B19710_04_40.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
- en: <st c="83568">Figure 4.40 – Installing Git hook scripts</st>
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83609">We will now run the hooks against all files available in the</st>
    `<st c="83671">eShoponWeb</st>` <st c="83681">directory:</st>
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.41 – Running Git hooks against all files](img/B19710_04_41.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: <st c="84601">Figure 4.41 – Running Git hooks against all files</st>
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84650">We see that</st> <st c="84662">both pre-commit hooks failed becaus</st><st
    c="84698">e a private key was detected, and secrets were found in several locations
    listed.</st> <st c="84781">It is best practice to fix errors and then commit</st>
    <st c="84831">the changes.</st>
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84843">Since we have configured these two pre-commit hooks, this will
    prevent commits from happening if there are any private keys</st> <st c="84968">and
    secrets.</st>
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84980">Summary</st>
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="84988">In this chapter, we examined two primary security concerns for
    this development phase.</st> <st c="85076">First, we looked at ensuring a secure
    development environment or workspace.</st> <st c="85152">This means making sure
    that tools and platforms where coding occurs, such as IDEs, are safe from vulnerabilities.</st>
    <st c="85266">We also touched on the risks of malicious IDE extensions and the
    challenges when dealing with untrusted code.</st> <st c="85376">We highlighted
    the need for measures to counteract any potential IDE breaches.</st> <st c="85455">Second,
    we tackled common coding errors that can lead to security issues.</st> <st c="85529">We
    introduced tools such as secret scanning to detect exposed sensitive data, SAST
    to find code vulnerabilities, and SCA to check third-party components for security
    risks.</st> <st c="85702">With this knowledge, you’re now better equipped to handle
    security challenges before committing code in the DevOps process.</st> <st c="85826">Up
    to this point in the book, our DevSecOps discussion has not focused on Azure.</st>
    <st c="85907">That is because there has not been much Azure-specific content to
    discuss up to the pre-commit stage.</st> <st c="86009">This will change in the
    next chapter, where we will discuss the integration of security in source control,
    with an Azure tooling focus.</st> <st c="86145">See</st> <st c="86149">you there!</st>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
