<html><head></head><body>
<div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-105"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-106"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.2.1">Non-Relational DMSs with DevOps</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we will navigate the intricate yet fascinating landscape of integrating non-relational database management systems (also known as NoSQL) with DevOps. </span><span class="koboSpan" id="kobo.3.2">We will begin by examining the pivotal role that data modeling plays in NoSQL databases, shedding light on how it differs from its counterpart in </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">relational databases.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Then, we will explore schema management. </span><span class="koboSpan" id="kobo.5.2">As NoSQL databases offer flexible schemas, we’ll delve into how this flexibility can be both an asset and a challenge when managed within a DevOps framework. </span><span class="koboSpan" id="kobo.5.3">From there, we’ll move on to the crucial topic of deployment automation, where we will discuss how automated tools and workflows can greatly streamline the </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">deployment process.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Performance tuning will also command our attention. </span><span class="koboSpan" id="kobo.7.2">As the scale of data grows exponentially, we’ll learn how to fine-tune our NoSQL databases to meet the demanding performance criteria that modern applications require. </span><span class="koboSpan" id="kobo.7.3">Subsequently, data consistency in a distributed, NoSQL environment will come under the lens, and we’ll learn strategies to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">it effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">Security, an ever-pressing concern, will not be left out of our discussion. </span><span class="koboSpan" id="kobo.9.2">We’ll scrutinize the best practices and mechanisms that can safeguard our data and infrastructure, aligning them seamlessly with </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">DevOps protocols.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Lastly, but just as importantly, we’ll look at anti-patterns, or what not to do when combining NoSQL and DevOps. </span><span class="koboSpan" id="kobo.11.2">This section will serve as a cautionary tale, guiding us away from common pitfalls and steering us toward </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">successful implementation.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">Throughout this chapter, you will gain actionable insights and real-world applications of each key milestone. </span><span class="koboSpan" id="kobo.13.2">The aim is not just to inform but also to equip you with practical knowledge that you can readily apply to your own systems. </span><span class="koboSpan" id="kobo.13.3">Let’s embark on this educational journey to discover how non-relational Database Managements Systems (DMSs) and DevOps can work in harmony to create robust, scalable, and </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">efficient systems.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Activities </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">and challenges</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.19.1">Data modeling</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Schema management</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.21.1">Deployment automation</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.22.1">Performance tuning</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.23.1">Data consistency</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Security</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Anti-patterns (what not </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">to do…)</span></span></li>
</ul>
<h1 id="_idParaDest-107"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.27.1">Activities and challenges</span></h1>
<p><span class="koboSpan" id="kobo.28.1">As part of the DevOps team, some of the main activities and challenges when working with non-relational databases include data modeling, schema management, and deployment automation, as detailed here, along with </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">other examples:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.30.1">Data modeling</span></strong><span class="koboSpan" id="kobo.31.1">: When working with non-relational</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.32.1"> databases, data modeling requires a different approach compared to traditional relational databases. </span><span class="koboSpan" id="kobo.32.2">One example of this is choosing the right data structure for the type of data being stored. </span><span class="koboSpan" id="kobo.32.3">For instance, if storing hierarchical data, a document-based database such as MongoDB may be more suitable than a relational database. </span><span class="koboSpan" id="kobo.32.4">In a relational database, this could be handled using a recursive query, but this would be less efficient and </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">more complicated.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.34.1">Schema management</span></strong><span class="koboSpan" id="kobo.35.1">: Unlike relational databases, non-relational </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.36.1">databases don’t require a fixed schema, which can make schema management more challenging. </span><span class="koboSpan" id="kobo.36.2">One example of this is handling schema migrations, which can be trickier to manage when there isn’t a predefined schema to work with. </span><span class="koboSpan" id="kobo.36.3">In a relational database, schema migrations can be handled through SQL scripts that update the schema, but in a non-relational database, you may be required to write custom code or use </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">third-party tools.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.38.1">Deployment automation</span></strong><span class="koboSpan" id="kobo.39.1">: Automating the deployment</span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.40.1"> of non-relational databases can be more complex than for relational databases. </span><span class="koboSpan" id="kobo.40.2">One example of this is configuring the database for high availability and disaster recovery. </span><span class="koboSpan" id="kobo.40.3">In a relational database, this can be achieved using replication, but in a non-relational database, it may require setting up a distributed system or using a </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">cloud-based</span></span><span class="No-Break"><a id="_idIndexMarker524"/></span><span class="No-Break"><span class="koboSpan" id="kobo.42.1"> service.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.43.1">Performance tuning</span></strong><span class="koboSpan" id="kobo.44.1">: Non-relational databases often require specific performance tuning, depending on the use case. </span><span class="koboSpan" id="kobo.44.2">For</span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.45.1"> example, in a document-based database, indexes need to be optimized based on the data access patterns. </span><span class="koboSpan" id="kobo.45.2">In contrast, a relational database typically relies on query optimization and table design to achieve </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">optimal performance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.47.1">Data consistency</span></strong><span class="koboSpan" id="kobo.48.1">: Unlike relational databases, non-relational databases may not enforce strict </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.49.1">data consistency across multiple nodes in a distributed system. </span><span class="koboSpan" id="kobo.49.2">For example, in a document-based database, data may be replicated asynchronously, which could result in data inconsistencies. </span><span class="koboSpan" id="kobo.49.3">To address this challenge, non-relational databases often provide mechanisms to maintain eventual consistency, such as conflict resolution algorithms or </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">read-after-write consistency.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.51.1">Security</span></strong><span class="koboSpan" id="kobo.52.1">: Non-relational databases may have different security </span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.53.1">concerns than relational databases, such as preventing unauthorized access to specific documents or collections. </span><span class="koboSpan" id="kobo.53.2">For example, in a graph database, access control may need to be implemented at the node or edge level. </span><span class="koboSpan" id="kobo.53.3">In contrast, a relational database typically uses role-based access control at the database or </span><span class="No-Break"><span class="koboSpan" id="kobo.54.1">table level.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.55.1">Let’s dive deeper into each of </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">these points.</span></span></p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.57.1">Data modeling</span></h1>
<p><span class="koboSpan" id="kobo.58.1">Let’s review together three unique challenges around data modeling</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.59.1"> that are specific to </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">non-relational databases.</span></span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.61.1">Denormalization</span></h2>
<p><span class="koboSpan" id="kobo.62.1">In non-relational databases, it’s common</span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.63.1"> to use denormalized data models where data is duplicated across multiple documents or collections. </span><span class="koboSpan" id="kobo.63.2">This is done to improve query performance and avoid expensive joins. </span><span class="koboSpan" id="kobo.63.3">In contrast, relational databases emphasize normalization, where data is organized into separate tables to avoid duplication and maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">data integrity.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">Denormalization can introduce unique challenges around data consistency and update anomalies. </span><span class="koboSpan" id="kobo.65.2">When data is denormalized, it can lead to redundant or inconsistent data, which can be difficult to manage. </span><span class="koboSpan" id="kobo.65.3">For example, if a customer’s address is stored in multiple documents, updating the address in one document may not propagate to all the other documents, leading to </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">inconsistent data.</span></span></p>
<p><span class="koboSpan" id="kobo.67.1">Here’s an example of a denormalized data model </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">in MongoDB:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.69.1">MongoDB</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.70.1">
{
  _id: ObjectId("616246f4cc84d137c857ff03"),
  title: "The Hitchhiker's Guide to the Galaxy",
  author: "Douglas Adams",
  genres: ["Science Fiction", "Comedy"],
  reviews: [
    { user: "Alice", rating: 4 },
    { user: "Bob", rating: 5 },
    { user: "Charlie", rating: 3 }
  ]
}</span></pre> <p><span class="koboSpan" id="kobo.71.1">In this example, the book’s title and author are duplicated across multiple documents, and the book’s genres and reviews are stored as arrays within the same document. </span><span class="koboSpan" id="kobo.71.2">This makes it easier to retrieve all the relevant information about a book in a single query, but it also introduces the risk of inconsistent</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.72.1"> data if one of the reviews is updated </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">or deleted.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.74.1">Nested and dynamic data</span></h2>
<p><span class="koboSpan" id="kobo.75.1">Non-relational databases</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.76.1"> are designed to handle nested and dynamic data</span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.77.1"> structures, such as JSON or XML documents. </span><span class="koboSpan" id="kobo.77.2">This makes it easier to store and retrieve complex data structures, but it also introduces unique challenges around indexing and querying. </span><span class="koboSpan" id="kobo.77.3">In contrast, relational databases have fixed column definitions, which makes it more difficult to store and query nested or </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">dynamic data.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">Nested data structures are common in non-relational databases, where data is stored as a hierarchical tree-like structure. </span><span class="koboSpan" id="kobo.79.2">Here’s an example of a nested document </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">in MongoDB:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.81.1">MongoDB</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.82.1">
{
  _id: ObjectId("6162486dcc84d137c857ff06"),
  name: {
    first: "John",
    last: "Doe"
  },
  email: "johndoe@example.com",
  address: {
    street: "123 Main St",
    city: "Anytown",
    state: "CA",
    zip: "12345"
  }
}</span></pre> <p><span class="koboSpan" id="kobo.83.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">name</span></strong><span class="koboSpan" id="kobo.85.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">address</span></strong><span class="koboSpan" id="kobo.87.1"> fields are nested within the document, which makes it easier to query and update data as a single entity. </span><span class="koboSpan" id="kobo.87.2">However, querying nested data can be challenging, as it requires traversing the entire tree to find the desired data. </span><span class="koboSpan" id="kobo.87.3">To address this, non-relational databases often use indexes to speed up queries on </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">nested data.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">Dynamic data structures</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.90.1"> are also common in non-relational databases, where data</span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.91.1"> can have varying types and properties. </span><span class="koboSpan" id="kobo.91.2">For example, a document-based database such as MongoDB can store documents with different structures in the same collection. </span><span class="koboSpan" id="kobo.91.3">Here’s an example of a dynamic document </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">in MongoDB:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.93.1">MongoDB</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.94.1">
{
  _id: ObjectId("61624c0fcc84d137c857ff0a"),
  name: "Alice",
  age: 30,
  email: "alice@example.com",
  phone: "+1 555-1234",
  address: {
    street: "456 Elm St",
    city: "Anycity",
    state: "NY"
  }
}</span></pre> <p><span class="koboSpan" id="kobo.95.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">address</span></strong><span class="koboSpan" id="kobo.97.1"> field is optional, and the document can contain any combination of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">name</span></strong><span class="koboSpan" id="kobo.99.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">age</span></strong><span class="koboSpan" id="kobo.101.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">email</span></strong><span class="koboSpan" id="kobo.103.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">phone</span></strong><span class="koboSpan" id="kobo.105.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">address</span></strong><span class="koboSpan" id="kobo.107.1"> fields. </span><span class="koboSpan" id="kobo.107.2">This flexibility can make it easier to store and retrieve data, but it also introduces challenges around data validation </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">and indexing.</span></span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.109.1">Data denormalization</span></h2>
<p><span class="koboSpan" id="kobo.110.1">Non-relational databases</span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.111.1"> often use data denormalization to avoid expensive joins and improve query performance. </span><span class="koboSpan" id="kobo.111.2">Data denormalization involves duplicating data across multiple documents or collections so that related data can be retrieved together, without having to perform a </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">join operation.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">However, denormalization can introduce unique challenges around data consistency and </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">update anomalies.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">Here’s an example of data denormalization in a </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">document-based database:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.117.1">MongoDB</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.118.1">
{
  _id: ObjectId("61624919cc84d137c857ff08"),
  title: "The Catcher in the Rye",
  author: "J.D. </span><span class="koboSpan" id="kobo.118.2">Salinger",
  genre: "Fiction",
  year: 1951,
  tags: ["coming of age", "isolation", "alienation"],
  similar_books: [
    { title: "The Bell Jar", author: "Sylvia Plath" },
    { title: "To Kill a Mockingbird", author: "Harper Lee" },
    { title: "The Great Gatsby", author: "F. </span><span class="koboSpan" id="kobo.118.3">Scott Fitzgerald" }
  ]
}</span></pre> <p><span class="koboSpan" id="kobo.119.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">similar_books</span></strong><span class="koboSpan" id="kobo.121.1"> field is denormalized, with the title and author of related books stored within the same document. </span><span class="koboSpan" id="kobo.121.2">This makes it easier to retrieve related data without performing a separate join operation, but it also introduces the risk of inconsistent data if one of the related books is updated </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">or deleted.</span></span></p>
<p><span class="koboSpan" id="kobo.123.1">To address these challenges, non-relational databases offer several features and techniques, such as schemaless design, document validation, indexing, </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">and sharding.</span></span></p>
<p><span class="koboSpan" id="kobo.125.1">Schemaless design means that non-relational databases do not require a predefined schema, which makes it easier to store and retrieve data with varying structures. </span><span class="koboSpan" id="kobo.125.2">Document validation can be used to ensure that data conforms to a specific schema, preventing inconsistencies and improving </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">data quality.</span></span></p>
<p><span class="koboSpan" id="kobo.127.1">Indexing can be used to speed up queries on nested and dynamic data, by creating indexes on specific fields or sub-fields. </span><span class="koboSpan" id="kobo.127.2">Sharding can be used to scale non-relational databases horizontally across multiple nodes, improving performance </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">and availability.</span></span></p>
<p><span class="koboSpan" id="kobo.129.1">In summary, non-relational databases</span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.130.1"> offer unique advantages and challenges around data modeling, compared to relational databases. </span><span class="koboSpan" id="kobo.130.2">While non-relational databases offer more flexibility and scalability, they also require a different approach to data modeling and management. </span><span class="koboSpan" id="kobo.130.3">DevOps teams working with non-relational databases need to be familiar with these unique challenges and techniques, ensuring that their infrastructure is stable </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">and scalable.</span></span></p>
<h1 id="_idParaDest-112"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.132.1">Schema management</span></h1>
<p><span class="koboSpan" id="kobo.133.1">Let’s review together three unique</span><a id="_idIndexMarker537"/><span class="koboSpan" id="kobo.134.1"> challenges around schema management that are specific to </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">non-relational databases.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.136.1">Schemaless data modeling</span></h2>
<p><span class="koboSpan" id="kobo.137.1">One of the main characteristics</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.138.1"> of non-relational databases is that they offer a schemaless data modeling approach. </span><span class="koboSpan" id="kobo.138.2">This means that they don’t enforce a fixed schema on the data and allow for flexible and dynamic data structures. </span><span class="koboSpan" id="kobo.138.3">While this can provide many benefits, such as faster iteration and easier scalability, it can also present some challenges in </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">schema management.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">In a schemaless database, there may not be a standard way to define or enforce the structure of data. </span><span class="koboSpan" id="kobo.140.2">This can make it difficult to ensure data consistency and quality across different documents. </span><span class="koboSpan" id="kobo.140.3">Additionally, it can be challenging to maintain compatibility and manage schema changes </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.142.1">For example, in a document-oriented database such as Couchbase, data can be stored in JSON documents with any arbitrary structure. </span><span class="koboSpan" id="kobo.142.2">Here’s an example of a </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">JSON document:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.144.1">JSON</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.145.1">
{
  "type": "person",
  "name": "Alice",
  "age": 25,
  "address": {
    "street": "123 Main St",
    "city": "Anytown",
    "state": "NY",
    "zip": "12345"
  },
  "interests": ["reading", "traveling", "hiking"]
}</span></pre> <p><span class="koboSpan" id="kobo.146.1">In this example, the document has a top-level field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">type</span></strong><span class="koboSpan" id="kobo.148.1"> that denotes the type of document, as well as a nested </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">address</span></strong><span class="koboSpan" id="kobo.150.1"> field that represents a </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">complex structure.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">To address the challenges of schemaless data modeling, non-relational databases provide features such as schema validation, which allows developers to define and enforce the structure of data. </span><span class="koboSpan" id="kobo.152.2">This can help ensure</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.153.1"> data consistency and quality across </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">different documents.</span></span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.155.1">Dynamic schema evolution</span></h2>
<p><span class="koboSpan" id="kobo.156.1">Non-relational databases</span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.157.1"> also often allow for dynamic schema evolution, which means that a schema can change over time to adapt to new requirements or data models. </span><span class="koboSpan" id="kobo.157.2">This can present some challenges in schema management, especially if the schema changes are not carefully planned </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">and managed.</span></span></p>
<p><span class="koboSpan" id="kobo.159.1">In a dynamically evolving schema, the structure of the data can change frequently, which can make it challenging to maintain backward and forward compatibility. </span><span class="koboSpan" id="kobo.159.2">Additionally, it can be difficult to ensure that all documents conform to the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">schema version.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">For example, in a graph database</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.162.1"> such as Neo4j, the structure of data can change over time as new nodes and relationships are added. </span><span class="koboSpan" id="kobo.162.2">Here’s an example of schema evolution </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">in Neo4j:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.164.1">Neo4j</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.165.1">
// Create an initial schema for a social network
CREATE (u:User {name: 'Alice'})
CREATE (p:Post {title: 'Hello World'})
CREATE (u)-[:POSTED]-&gt;(p)
// Add a new field to the User node
ALTER (u:User) SET u.email = 'alice@example.com'
// Add a new label to the Post node
MATCH (p:Post)
SET p:Article
REMOVE p:Post</span></pre> <p><span class="koboSpan" id="kobo.166.1">In this example, an initial schema is created for a social network, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">User</span></strong><span class="koboSpan" id="kobo.168.1"> node and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">Post</span></strong><span class="koboSpan" id="kobo.170.1"> node connected by a </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">POSTED</span></strong><span class="koboSpan" id="kobo.172.1"> relationship. </span><span class="koboSpan" id="kobo.172.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">User</span></strong><span class="koboSpan" id="kobo.174.1"> node does not have an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">email</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.176.1"> field.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">To evolve the schema, a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">email</span></strong><span class="koboSpan" id="kobo.179.1"> field is added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">User</span></strong><span class="koboSpan" id="kobo.181.1"> node, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">ALTER</span></strong><span class="koboSpan" id="kobo.183.1"> command. </span><span class="koboSpan" id="kobo.183.2">Additionally, a new label called </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">Article</span></strong><span class="koboSpan" id="kobo.185.1"> is added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">Post</span></strong><span class="koboSpan" id="kobo.187.1"> node, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">Post</span></strong><span class="koboSpan" id="kobo.189.1"> label is removed using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">CREATE LABEL</span></strong><span class="koboSpan" id="kobo.191.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">REMOVE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.193.1"> commands.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">To address the challenges of dynamic schema</span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.195.1"> evolution, non-relational databases provide features such as versioning and migration tools. </span><span class="koboSpan" id="kobo.195.2">These tools can help manage changes to the schema and ensure that all documents conform to the latest </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">schema version.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.197.1">Consistency and concurrency control</span></h2>
<p><span class="koboSpan" id="kobo.198.1">Another challenge in non-relational</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.199.1"> schema management is ensuring consistency and concurrency control in a distributed environment. </span><span class="koboSpan" id="kobo.199.2">Non-relational databases often use distributed architectures to achieve scalability and availability, which can create challenges in ensuring that data is consistent across </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">different nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.201.1">In a distributed database environment, different nodes may have different versions of the same data, which can lead to conflicts and inconsistency. </span><span class="koboSpan" id="kobo.201.2">Additionally, concurrency control can be challenging in a distributed environment, as multiple nodes can access and update the same </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">data simultaneously.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">For example, in a key-value store such as Redis, concurrency control can be achieved through the use of optimistic locking. </span><span class="koboSpan" id="kobo.203.2">Here’s an example of optimistic locking </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">in Redis:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.205.1">JavaScript</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.206.1">
// Get the current value of the counter
var counter = await redis.get('counter');
// Increment the counter using optimistic locking
while (true) {
  var tx = redis.multi();
  tx.watch('counter');
  var current = await tx.get('counter');
  var next = parseInt(current) + 1;
  tx.multi();
  tx.set('counter', next);
  var result = await tx.exec();
  if (result !== null) {
    counter = next;
    break;
  }
}
console.log('Counter is now', counter);</span></pre> <p><span class="koboSpan" id="kobo.207.1">In this example, the value of a counter is retrieved from Redis using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">get</span></strong><span class="koboSpan" id="kobo.209.1"> method. </span><span class="koboSpan" id="kobo.209.2">The counter is then incremented using optimistic locking, which involves using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">watch</span></strong><span class="koboSpan" id="kobo.211.1"> method to monitor the </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">counter</span></strong><span class="koboSpan" id="kobo.213.1"> key for changes. </span><span class="koboSpan" id="kobo.213.2">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">counter</span></strong><span class="koboSpan" id="kobo.215.1"> key is modified by another process, the optimistic locking loop retries </span><span class="No-Break"><span class="koboSpan" id="kobo.216.1">the transaction.</span></span></p>
<p><span class="koboSpan" id="kobo.217.1">To address the challenges of consistency and concurrency control, non-relational databases provide features such as distributed locking, versioning, and conflict resolution. </span><span class="koboSpan" id="kobo.217.2">These features can help ensure that data is consistent and up to date across different nodes in a </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">distributed environment.</span></span></p>
<p><span class="koboSpan" id="kobo.219.1">Non-relational databases</span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.220.1"> present unique challenges around schema management compared to relational databases. </span><span class="koboSpan" id="kobo.220.2">These challenges include schemaless data modeling, dynamic schema evolution, and consistency and concurrency control in a distributed environment. </span><span class="koboSpan" id="kobo.220.3">To address these challenges, non-relational databases provide features such as schema validation, versioning, migration tools, and distributed locking. </span><span class="koboSpan" id="kobo.220.4">DevOps teams working with non-relational databases need to be familiar with these unique challenges and techniques, ensuring that their infrastructure is stable </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">and scalable.</span></span></p>
<h1 id="_idParaDest-116"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.222.1">Deployment automation</span></h1>
<p><span class="koboSpan" id="kobo.223.1">Deployment automation</span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.224.1"> is an important aspect of DevOps for both relational and non-relational databases, but there are some unique challenges around deployment automation for non-relational databases. </span><span class="koboSpan" id="kobo.224.2">Here are three challenges specific to non-relational databases, along with explanations and </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">code snippets.</span></span></p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.226.1">Deployment of multiple database engines</span></h2>
<p><span class="koboSpan" id="kobo.227.1">Non-relational databases</span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.228.1"> often have different database engines, each with its own set of deployment and management requirements. </span><span class="koboSpan" id="kobo.228.2">For example, a NoSQL database such as Cassandra may have different deployment requirements than a document-oriented database such </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">as MongoDB.</span></span></p>
<p><span class="koboSpan" id="kobo.230.1">Deploying and managing multiple database engines can be challenging, as it requires specialized knowledge and expertise for each engine. </span><span class="koboSpan" id="kobo.230.2">Additionally, it can be difficult to maintain consistency across different database engines, especially if they have different APIs and </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">query languages.</span></span></p>
<p><span class="koboSpan" id="kobo.232.1">To address this challenge, DevOps teams may use configuration management tools such as Ansible or Chef to automate the deployment and management of different database engines. </span><span class="koboSpan" id="kobo.232.2">These tools allow for the automation of tasks such as installing software, configuring servers, and </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">deploying databases.</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">Here’s an example of deploying Cassandra </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">using Ansible:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.236.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.237.1">
- hosts: cassandra
  become: true
  tasks:
    - name: Add Cassandra repo to APT
      apt_repository:
        repo: "deb http://www.apache.org/dist/cassandra/debian 40x main"
        keyserver: pgp.mit.edu
        state: present
    - name: Install Cassandra
      apt:
        name: cassandra
        state: latest
    - name: Start Cassandra service
      service:
        name: cassandra
        state: started</span></pre> <p><span class="koboSpan" id="kobo.238.1">In this example, Ansible is used to add the Cassandra repository to the APT package manager, install the Cassandra</span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.239.1"> package, and start the </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">Cassandra service.</span></span></p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.241.1">Backup and disaster recovery</span></h2>
<p><span class="koboSpan" id="kobo.242.1">Non-relational databases often require specialized</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.243.1"> backup and disaster recovery strategies, due to the different data structures and distributed architectures used by these databases. </span><span class="koboSpan" id="kobo.243.2">For example, a key-value store, such as Redis, may use a distributed architecture that requires different backup and recovery strategies than a document-oriented database, such </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">as Couchbase.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Backing up and restoring data in a non-relational database can be complex, as it often involves managing data across multiple nodes and ensuring that it is consistent and up to date. </span><span class="koboSpan" id="kobo.245.2">Additionally, disaster recovery can be challenging in a distributed environment, as different nodes may have different versions of the </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">same data.</span></span></p>
<p><span class="koboSpan" id="kobo.247.1">To address this challenge, DevOps teams may use specialized backup and recovery tools for non-relational databases, such as the AWS Backup service for Amazon DynamoDB. </span><span class="koboSpan" id="kobo.247.2">These tools allow for the automated backup and recovery of data across different nodes, and they can help ensure data consistency and </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">up-to-date backups.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">Here’s an example of backing up and restoring data in DynamoDB using the AWS </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">Backup service:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.251.1">AWS CLI</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
// Create a backup of the DynamoDB table
</span><strong class="bold"><span class="koboSpan" id="kobo.253.1">aws dynamodb create-backup --table-name MyTable --backup-name MyBackup</span></strong><span class="koboSpan" id="kobo.254.1">
// Restore the backup to a new DynamoDB table
</span><strong class="bold"><span class="koboSpan" id="kobo.255.1">aws dynamodb restore-table-from-backup --target-table-name MyRestoredTable --backup-arn arn:aws:dynamodb:us-west-2:123456789012:backup:MyBackup</span></strong></pre> <p><span class="koboSpan" id="kobo.256.1">In this example, the AWS CLI is used to create a backup of a DynamoDB table using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">create-backup</span></strong><span class="koboSpan" id="kobo.258.1"> command. </span><span class="koboSpan" id="kobo.258.2">The backup</span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.259.1"> is then restored to a new DynamoDB table, using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">restore-table-from-backup</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.261.1"> command.</span></span></p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.262.1">Capacity planning and scaling</span></h2>
<p><span class="koboSpan" id="kobo.263.1">Non-relational databases</span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.264.1"> often require specialized capacity planning and scaling strategies, due to the distributed architecture used by these databases. </span><span class="koboSpan" id="kobo.264.2">Scaling a non-relational database can be complex, as it often involves adding or removing nodes from a distributed cluster, as well as managing data across </span><span class="No-Break"><span class="koboSpan" id="kobo.265.1">different nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.266.1">Capacity planning and scaling in a non-relational database can also be challenging, as it can be difficult to predict how much storage and processing power will be required as the database grows. </span><span class="koboSpan" id="kobo.266.2">Additionally, scaling a non-relational database can involve different strategies than scaling a relational database, as non-relational databases often use horizontal scaling, where more nodes are added to a cluster to </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">increase capacity.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">To address this challenge, DevOps teams can use specialized tools for capacity planning and scaling in non-relational databases, such as the Kubernetes autoscaler for scaling clusters. </span><span class="koboSpan" id="kobo.268.2">These tools allow for the automated scaling of clusters based on metrics such as CPU usage and network traffic, and they can help ensure that the database infrastructure is </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">always right-sized.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">Here’s an example of scaling</span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.271.1"> a cluster in Cassandra using the </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">Kubernetes autoscaler:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.273.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.274.1">
apiVersion: autoscaling/v2beta2
kind: HorizontalPodAutoscaler
metadata:
  name: cassandra
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: StatefulSet
    name: cassandra
  minReplicas: 3
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70</span></pre> <p><span class="koboSpan" id="kobo.275.1">In this example, the Kubernetes autoscaler is used to scale a Cassandra cluster based on CPU usage. </span><span class="koboSpan" id="kobo.275.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">minReplicas</span></strong><span class="koboSpan" id="kobo.277.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">maxReplicas</span></strong><span class="koboSpan" id="kobo.279.1"> fields define the minimum and maximum number of nodes in the cluster, respectively, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">metrics</span></strong><span class="koboSpan" id="kobo.281.1"> field defines the metric used to scale the cluster (in this case, </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">CPU utilization).</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">To summarize, deployment automation is an important aspect of DevOps for both relational and non-relational databases, but there are some unique challenges around deployment automation for non-relational databases. </span><span class="koboSpan" id="kobo.283.2">These challenges include deploying multiple database engines, backup and disaster recovery, and capacity planning and scaling. </span><span class="koboSpan" id="kobo.283.3">To address these challenges, DevOps teams can use configuration management tools, specialized backup and recovery tools, and capacity</span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.284.1"> planning and scaling tools designed for </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">non-relational databases.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.286.1">Performance tuning</span></h1>
<p><span class="koboSpan" id="kobo.287.1">Performance tuning is a critical aspect of DevOps</span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.288.1"> for both relational and non-relational databases. </span><span class="koboSpan" id="kobo.288.2">However, there are some unique challenges around performance tuning for non-relational databases. </span><span class="koboSpan" id="kobo.288.3">Here are three challenges specific to non-relational databases, along with explanations and </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">code snippets.</span></span></p>
<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.290.1">Data modeling for performance</span></h2>
<p><span class="koboSpan" id="kobo.291.1">One of the unique challenges</span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.292.1"> of performance tuning for non-relational databases is data modeling for performance. </span><span class="koboSpan" id="kobo.292.2">Unlike relational databases, non-relational databases often have flexible schema models that can be optimized for different types of queries and access patterns. </span><span class="koboSpan" id="kobo.292.3">However, this also means that performance tuning may require specialized knowledge of the data model and how it maps to the underlying storage and </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">retrieval mechanisms.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">To address this challenge, DevOps teams may use specialized tools and techniques for data modeling and query optimization in non-relational databases. </span><span class="koboSpan" id="kobo.294.2">For example, graph databases such as Neo4j can use indexing and caching techniques to optimize queries, while key-value stores such as Redis can use data sharding and replication techniques to optimize storage </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">and retrieval.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">Here’s an example of data modeling for performance in a graph database such </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">as Neo4j:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.298.1">Neo4j</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
// Create an index on the Person node's name property
CREATE INDEX ON :Person(name)
// Query for all people with the name "Alice"
MATCH (p:Person {name: 'Alice'})
RETURN p</span></pre> <p><span class="koboSpan" id="kobo.300.1">In this example, an index is created on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">name</span></strong><span class="koboSpan" id="kobo.302.1"> property of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">Person</span></strong><span class="koboSpan" id="kobo.304.1"> node in Neo4j. </span><span class="koboSpan" id="kobo.304.2">This allows for faster querying of people with the name </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">Alice</span></strong><span class="koboSpan" id="kobo.306.1"> by using the index to find </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">matching</span></span><span class="No-Break"><a id="_idIndexMarker555"/></span><span class="No-Break"><span class="koboSpan" id="kobo.308.1"> nodes.</span></span></p>
<h2 id="_idParaDest-122"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.309.1">Distributed query optimization</span></h2>
<p><span class="koboSpan" id="kobo.310.1">Non-relational databases</span><a id="_idIndexMarker556"/><span class="koboSpan" id="kobo.311.1"> often use distributed architectures to achieve scalability and availability. </span><span class="koboSpan" id="kobo.311.2">However, this can present unique challenges around query optimization, as queries may need to be optimized across multiple nodes in </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">the cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">Distributed query optimization in non-relational databases requires specialized knowledge of the database architecture and how queries are executed across different nodes. </span><span class="koboSpan" id="kobo.313.2">Additionally, it can be challenging to maintain consistency and performance across different nodes in the cluster, especially if there are network latency or data </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">transfer issues.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">To address this challenge, DevOps teams can use specialized tools and techniques for distributed query optimization in non-relational databases. </span><span class="koboSpan" id="kobo.315.2">For example, distributed databases such as Cassandra can use techniques, such as partitioning and clustering, to optimize queries across multiple nodes in </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">the cluster.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">Here’s an example of distributed query optimization </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">in Cassandra:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.319.1">CQL</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.320.1">
// Create a table with a partition key and clustering columns
CREATE TABLE users (
  id UUID PRIMARY KEY,
  name TEXT,
  email TEXT,
  created_at TIMESTAMP
) WITH CLUSTERING ORDER BY (created_at DESC)
// Query for all users with a specific email address
SELECT * FROM users WHERE email = 'example@example.com'</span></pre> <p><span class="koboSpan" id="kobo.321.1">In this example, a table is created in Cassandra with a partition key and clustering columns. </span><span class="koboSpan" id="kobo.321.2">This allows for efficient querying of data across multiple nodes in the cluster. </span><span class="koboSpan" id="kobo.321.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">SELECT</span></strong><span class="koboSpan" id="kobo.323.1"> statement queries</span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.324.1"> for all users with a specific email address by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">email</span></strong><span class="koboSpan" id="kobo.326.1"> column as the </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">partition key.</span></span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.328.1">Network latency and data transfer</span></h2>
<p><span class="koboSpan" id="kobo.329.1">Non-relational databases</span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.330.1"> often use distributed architectures that require data to be transferred across the network</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.331.1"> between different nodes in the cluster. </span><span class="koboSpan" id="kobo.331.2">This can create unique challenges around performance tuning, as network latency and data transfer speeds can impact query performance and overall </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">database throughput.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">To address this challenge, DevOps teams can use specialized tools and techniques to optimize network latency and data transfer in non-relational databases. </span><span class="koboSpan" id="kobo.333.2">For example, database caching and load balancing can be used to reduce the amount of data transferred over a network and improve </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">query performance.</span></span></p>
<p><span class="koboSpan" id="kobo.335.1">Here’s an example of database caching </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">in Redis:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.337.1">JavaScript</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.338.1">
// Get a value from the cache
var cachedValue = await redis.get('key');
// If the value is not in the cache, fetch it from the database and store it in the cache
if (cachedValue === null) {
  var result = await db.query('SELECT * FROM my_table WHERE id = ?', [id]);
  if (result.length &gt; 0) {
    cachedValue = result[0];
    await redis.set('key', JSON.stringify(cachedValue), 'EX', 600);
  }
}
console.log('Result is', cachedValue);</span></pre> <p><span class="koboSpan" id="kobo.339.1">In this example, Redis is used as a caching layer to store the result of a database query. </span><span class="koboSpan" id="kobo.339.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">get</span></strong><span class="koboSpan" id="kobo.341.1"> method is used to retrieve the value from the cache. </span><span class="koboSpan" id="kobo.341.2">If the value is not in the cache, the query is executed against the database, and the result is stored in Redis using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.342.1">set</span></strong><span class="koboSpan" id="kobo.343.1"> method, with a TTL of 10 minutes (600 seconds). </span><span class="koboSpan" id="kobo.343.2">The result is then returned to the </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">calling function.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">By using a cache layer</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.346.1"> such as Redis, the database can be queried</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.347.1"> less frequently, reducing the amount of data transferred over the network and improving </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">query performance.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">In summary, performance tuning is an important aspect of DevOps for both relational and non-relational databases, but there are some unique challenges around performance tuning for non-relational databases. </span><span class="koboSpan" id="kobo.349.2">These challenges include data modeling for performance, distributed query optimization, and network latency and data transfer. </span><span class="koboSpan" id="kobo.349.3">To address these challenges, DevOps teams can use specialized tools and techniques for data modeling, query optimization, and network optimization in </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">non-relational databases.</span></span></p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.351.1">Data consistency</span></h1>
<p><span class="koboSpan" id="kobo.352.1">Data consistency is a critical aspect of any</span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.353.1"> database, both relational and non-relational. </span><span class="koboSpan" id="kobo.353.2">However, non-relational databases present some unique challenges around data consistency. </span><span class="koboSpan" id="kobo.353.3">Here are three challenges specific to non-relational databases, along with explanations and </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">code snippets.</span></span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor124"/><span class="koboSpan" id="kobo.355.1">Lack of transactions</span></h2>
<p><span class="koboSpan" id="kobo.356.1">Unlike relational</span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.357.1"> databases, non-relational databases cannot support transactions, or – to be more precise – they can only support limited forms of transactions. </span><span class="koboSpan" id="kobo.357.2">Transactions are critical to ensure data consistency, as they allow for multiple database operations to be treated as a single unit of work. </span><span class="koboSpan" id="kobo.357.3">Without transactions, data consistency can be compromised if one operation fails and others are </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">left incomplete.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">To address this challenge, DevOps teams may need to implement custom transaction-like mechanisms in non-relational databases, such as conditional updates or two-phase commit protocols. </span><span class="koboSpan" id="kobo.359.2">These mechanisms can help ensure that data modifications are atomic </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">and consistent.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">Here’s an example of a conditional update </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">in MongoDB:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.363.1">MongoDB</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.364.1">
// Update the user's email address if the current email address matches the expected value
db.users.update(
  { _id: '123' },
  { $set: { email: 'newemail@example.com' } },
  { multi: false, upsert: false, writeConcern: { w: 'majority' } },
  function(err, result) {
    if (err) {
      console.log(err);
    } else if (result.n === 0) {
      console.log('User not found');
    } else if (result.nModified === 0) {
      console.log('Update failed - email address did not match expected value');
    } else {
      console.log('Update successful');
    }
  }
);</span></pre> <p><span class="koboSpan" id="kobo.365.1">In this example, an update is performed on a user’s email address in MongoDB using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">update</span></strong><span class="koboSpan" id="kobo.367.1"> method. </span><span class="koboSpan" id="kobo.367.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">multi</span></strong><span class="koboSpan" id="kobo.369.1"> option is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">false</span></strong><span class="koboSpan" id="kobo.371.1"> to ensure that only one document is updated, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">upsert</span></strong><span class="koboSpan" id="kobo.373.1"> option is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">false</span></strong><span class="koboSpan" id="kobo.375.1"> to prevent the creation of new documents. </span><span class="koboSpan" id="kobo.375.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">writeConcern</span></strong><span class="koboSpan" id="kobo.377.1"> option is used to ensure</span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.378.1"> that the write operation is durable </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">and consistent.</span></span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor125"/><span class="koboSpan" id="kobo.380.1">Eventual consistency</span></h2>
<p><span class="koboSpan" id="kobo.381.1">Non-relational databases</span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.382.1"> often use eventual consistency models, where data modifications cannot be immediately reflected in all replicas of the data. </span><span class="koboSpan" id="kobo.382.2">This can create challenges around data consistency, as queries may return stale or outdated data if they are performed on replicas that have not yet received the </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">latest modifications.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">To address this challenge, DevOps teams may need to implement custom techniques to manage eventual consistency in non-relational databases, such as conflict resolution or quorum-based consistency. </span><span class="koboSpan" id="kobo.384.2">These techniques can help ensure that data modifications are propagated and consistent across </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">all replicas.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">Here’s an example of quorum-based consistency </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">in Cassandra:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.388.1">CQL</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.389.1">
// Create a Cassandra table with a quorum-based consistency level
CREATE TABLE users (
  id UUID PRIMARY KEY,
  name TEXT,
  email TEXT,
  created_at TIMESTAMP
) WITH read_repair_chance = 0.2 AND dclocal_read_repair_chance = 0.1 AND CL = QUORUM
// Query for all users with a specific email address using a quorum-based consistency level
SELECT * FROM users WHERE email = 'example@example.com' AND CL = QUORUM</span></pre> <p><span class="koboSpan" id="kobo.390.1">In this example, a Cassandra table is created with a quorum-based consistency level, which ensures that at least a majority of replicas must respond to a read or write operation before it is considered successful. </span><span class="koboSpan" id="kobo.390.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">read_repair_chance</span></strong><span class="koboSpan" id="kobo.392.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">dclocal_read_repair_chance</span></strong><span class="koboSpan" id="kobo.394.1"> options are used to repair inconsistencies</span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.395.1"> in the database, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">CL</span></strong><span class="koboSpan" id="kobo.397.1"> option is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">QUORUM</span></strong><span class="koboSpan" id="kobo.399.1"> to ensure </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">quorum-based consistency.</span></span></p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/><span class="koboSpan" id="kobo.401.1">Data sharding</span></h2>
<p><span class="koboSpan" id="kobo.402.1">Non-relational databases</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.403.1"> often use data-sharding techniques to distribute data across multiple nodes in a cluster. </span><span class="koboSpan" id="kobo.403.2">However, data sharding can create challenges around data consistency, as queries may need to be executed across multiple shards, and ensuring consistency across shards can </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">be difficult.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">To address this challenge, DevOps teams may need to implement custom techniques to manage data sharding in non-relational databases, such as consistent hashing or virtual nodes. </span><span class="koboSpan" id="kobo.405.2">These techniques can help ensure that data is distributed evenly across shards and that queries are executed efficiently </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">and consistently.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">Here’s an example of consistent hashing </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">in Riak:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.409.1">Riak</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
// Create a Riak bucket with consistent hashing enabled
curl -XPUT http://localhost:8098/buckets/my_bucket/props \
  -H 'Content-Type: application/json' \
  -d '{ "props": { "consistent_hashing": true } }'
// Store a value in the Riak bucket with a key
curl -XPUT http://localhost:8098/buckets/my_bucket/keys/my_key \
  -H 'Content-Type: application/json' \
  -d '{ "value": "my_value" }'
// Retrieve the value from the Riak bucket using consistent hashing
curl -XGET http://localhost:8098/buckets/my_bucket/keys/my_key \
  -H 'Content-Type: application/json' \
  -H 'X-Riak-Consistent-Hashing: true'</span></pre> <p><span class="koboSpan" id="kobo.411.1">In this example, a Riak bucket is created with consistent hashing enabled, which ensures that data is distributed evenly across shards. </span><span class="koboSpan" id="kobo.411.2">A value is stored in the bucket with a key, and the value is retrieved using consistent hashing by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">X-Riak-Consistent-Hashing</span></strong><span class="koboSpan" id="kobo.413.1"> header </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.417.1">Data consistency is critical for any database, but there are some unique challenges around data consistency for non-relational databases. </span><span class="koboSpan" id="kobo.417.2">These challenges include a lack of transactions, eventual consistency, and data sharding. </span><span class="koboSpan" id="kobo.417.3">To address these challenges, DevOps teams may need to implement custom techniques to manage data consistency in non-relational databases, such as conditional</span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.418.1"> updates, conflict resolution, and </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">consistent hashing.</span></span></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor127"/><span class="koboSpan" id="kobo.420.1">Security</span></h1>
<p><span class="koboSpan" id="kobo.421.1">Security is a critical aspect </span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.422.1">of any database, both relational and non-relational. </span><span class="koboSpan" id="kobo.422.2">However, non-relational databases present some unique challenges around security. </span><span class="koboSpan" id="kobo.422.3">Here are three challenges specific to non-relational databases, along with explanations and </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">code snippets.</span></span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/><span class="koboSpan" id="kobo.424.1">Limited access control</span></h2>
<p><span class="koboSpan" id="kobo.425.1">Non-relational databases may not support</span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.426.1"> the same level of access control as relational databases. </span><span class="koboSpan" id="kobo.426.2">This can create challenges around securing sensitive data and preventing </span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">unauthorized access.</span></span></p>
<p><span class="koboSpan" id="kobo.428.1">To address this challenge, DevOps teams may need to implement custom access control mechanisms in non-relational databases, such as role-based access control or custom authentication mechanisms. </span><span class="koboSpan" id="kobo.428.2">These mechanisms can help ensure that data is accessed only by authorized users and that sensitive data </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">is protected.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Here’s an example of role-based access control </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">in MongoDB:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.432.1">MongoDB</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.433.1">
// Create a user with a specific role in MongoDB
db.createUser({
  user: 'myuser',
  pwd: 'mypassword',
  roles: [ { role: 'readWrite', db: 'mydatabase' } ]
});
// Authenticate with MongoDB using the created user
db.auth('myuser', 'mypassword');
// Query for data in MongoDB using the authenticated user
db.my_collection.find({});</span></pre> <p><span class="koboSpan" id="kobo.434.1">In this example, a user is created in MongoDB with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">readWrite</span></strong><span class="koboSpan" id="kobo.436.1"> role for a specific database. </span><span class="koboSpan" id="kobo.436.2">The user is then authenticated with the database using the created credentials, and data is queried using the </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">authenticated user.</span></span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/><span class="koboSpan" id="kobo.438.1">Distributed denial of service attacks</span></h2>
<p><span class="koboSpan" id="kobo.439.1">Non-relational databases often use distributed</span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.440.1"> architectures that may be vulnerable to </span><strong class="bold"><span class="koboSpan" id="kobo.441.1">distributed denial of service</span></strong><span class="koboSpan" id="kobo.442.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.443.1">DDoS</span></strong><span class="koboSpan" id="kobo.444.1">) attacks. </span><span class="koboSpan" id="kobo.444.2">DDoS attacks can overwhelm a database with traffic, rendering it unavailable</span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.445.1"> and compromising </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">data security.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">To address this challenge, DevOps teams may need to implement custom DDoS prevention mechanisms in non-relational databases, such as load balancing or rate limiting. </span><span class="koboSpan" id="kobo.447.2">These mechanisms can help ensure that a database is protected from excessive traffic and that data security </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">is maintained.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">Here’s an example of rate limiting </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">in Redis:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.451.1">Lua</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.452.1">
// Configure Redis to use a maximum memory limit of 1GB
maxmemory 1gb
// Enable Redis rate limiting for incoming requests
redis.config set lua-time-limit 1000
redis.config set maxmemory-samples 10
redis.eval("local c=redis.call('incr',KEYS[1]);if tonumber(c)==1 then redis.call('expire',KEYS[1],ARGV[1]) end;return c",{1,"rate_limiter"},1)</span></pre> <p><span class="koboSpan" id="kobo.453.1">In this example, Redis is configured to use a maximum memory limit of 1 GB, which helps protect against DDoS attacks that attempt to overload a database with excessive traffic. </span><span class="koboSpan" id="kobo.453.2">Rate limiting is also enabled for incoming requests, which helps ensure that the database is not overwhelmed with too </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">many requests.</span></span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor130"/><span class="koboSpan" id="kobo.455.1">Lack of encryption</span></h2>
<p><span class="koboSpan" id="kobo.456.1">Non-relational databases</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.457.1"> may not support the same level of encryption as relational databases. </span><span class="koboSpan" id="kobo.457.2">This can create challenges around protecting sensitive data and ensuring </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">data privacy.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">To address this challenge, DevOps teams may need to implement custom encryption mechanisms in non-relational databases, such as application-level encryption or network-level encryption. </span><span class="koboSpan" id="kobo.459.2">These mechanisms can help ensure that data is protected both at rest and </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">in transit.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Here’s an example of network-level encryption</span><a id="_idIndexMarker574"/> <span class="No-Break"><span class="koboSpan" id="kobo.462.1">in Cassandra:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.463.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.464.1">
// Enable network-level encryption for Cassandra
server_encryption_options:
  internode_encryption: all
  keystore: /path/to/keystore.jks
  keystore_password: password
  truststore: /path/to/truststore.jks
  truststore_password: password
client_encryption_options:
  enabled: true
  optional: false
  keystore: /path/to/keystore.jks
  keystore_password: password</span></pre> <p><span class="koboSpan" id="kobo.465.1">In this example, network-level encryption is enabled for Cassandra by setting the </span><strong class="source-inline"><span class="koboSpan" id="kobo.466.1">internode_encryption</span></strong><span class="koboSpan" id="kobo.467.1"> option to </span><strong class="source-inline"><span class="koboSpan" id="kobo.468.1">all</span></strong><span class="koboSpan" id="kobo.469.1">, which ensures that all communication between nodes is encrypted. </span><span class="koboSpan" id="kobo.469.2">Keystores and truststores are also specified to provide authentication and encryption key management. </span><span class="koboSpan" id="kobo.469.3">Client-level encryption is also enabled to ensure that data is encrypted in transit between clients </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">and nodes.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">In conclusion, security is critical for any database, but there are some unique challenges around security for non-relational databases. </span><span class="koboSpan" id="kobo.471.2">These challenges include limited access control, DDoS attacks, and lack of encryption. </span><span class="koboSpan" id="kobo.471.3">To address these challenges, DevOps teams may need to implement custom access control mechanisms, DDoS prevention mechanisms, and encryption mechanisms in non-relational databases, such as role-based access control, rate limiting, and </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">network-level</span></span><span class="No-Break"><a id="_idIndexMarker575"/></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1"> encryption.</span></span></p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/><span class="koboSpan" id="kobo.474.1">Anti-patterns (what not to do…)</span></h1>
<p><span class="koboSpan" id="kobo.475.1">There are several anti-patterns/wrong practices</span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.476.1"> that should be avoided when working with NoSQL systems. </span><span class="koboSpan" id="kobo.476.2">Let’s review some obvious examples of what not </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">to do.</span></span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/><span class="koboSpan" id="kobo.478.1">Overusing or misusing denormalization</span></h2>
<p><span class="koboSpan" id="kobo.479.1">Overusing or misusing denormalization</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.480.1"> can lead to inconsistent or redundant data, making it difficult to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">data integrity.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">For example, consider a hypothetical e-commerce application that uses a NoSQL database to store order and product data. </span><span class="koboSpan" id="kobo.482.2">The database uses a denormalized data model, where each order document contains product information as embedded documents. </span><span class="koboSpan" id="kobo.482.3">However, the application team decides to denormalize further and embed order data within each product document as well, simplifying querying. </span><span class="koboSpan" id="kobo.482.4">This leads to redundant data and inconsistent order data, as changes to order data will need to be updated in </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">multiple places.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">Here’s an example of overusing denormalization </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">in MongoDB:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.486.1">JSON</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.487.1">
// Example of overusing denormalization in MongoDB
// Embedding order data within each product document
{
  "_id": "product123",
  "name": "iPhone",
  "description": "Apple iPhone 12 Pro",
  "price": 999,
  "orders": [
    {
      "_id": "order456",
      "customer_id": "customer789",
      "quantity": 2,
      "price": 1998
    },
    {
      "_id": "order789",
      "customer_id": "customer123",
      "quantity": 1,
      "price": 999
    }
  ]
}</span></pre> <p><span class="koboSpan" id="kobo.488.1">In this example, each product document contains order data as embedded documents. </span><span class="koboSpan" id="kobo.488.2">However, this leads to redundant data and inconsistent order data, as changes to order data will need to be updated</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.489.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">multiple places.</span></span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/><span class="koboSpan" id="kobo.491.1">Ignoring or underestimating data consistency</span></h2>
<p><span class="koboSpan" id="kobo.492.1">Ignoring or underestimating</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.493.1"> data consistency can lead to data inconsistencies and loss of </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">data integrity.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">For example, consider a hypothetical social media application that uses a NoSQL database to store user profiles and posts. </span><span class="koboSpan" id="kobo.495.2">The database uses eventual consistency, and the application team underestimates the complexity of managing consistency across nodes. </span><span class="koboSpan" id="kobo.495.3">This leads to inconsistent</span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.496.1"> post data, as users may see different versions of the same post on </span><span class="No-Break"><span class="koboSpan" id="kobo.497.1">different devices.</span></span></p>
<p><span class="koboSpan" id="kobo.498.1">Here’s an example of underestimating data consistency </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">in Cassandra:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.500.1">CQL</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.501.1">
// Example of underestimating data consistency in Cassandra
// Using low consistency levels for reads and writes
CREATE TABLE posts (
  post_id UUID PRIMARY KEY,
  user_id UUID,
  text TEXT
);
INSERT INTO posts (post_id, user_id, text) VALUES (
  uuid(), uuid(), 'Hello, world!'
</span><span class="koboSpan" id="kobo.501.2">) USING CONSISTENCY ONE;
SELECT * FROM posts WHERE post_id = uuid() USING CONSISTENCY ONE;</span></pre> <p><span class="koboSpan" id="kobo.502.1">In this example, Cassandra is used to store post data, but low consistency levels are used for reads and writes. </span><span class="koboSpan" id="kobo.502.2">This can lead to data inconsistencies, as users can see different versions</span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.503.1"> of the same post on </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">different devices.</span></span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor134"/><span class="koboSpan" id="kobo.505.1">Failing to secure a database</span></h2>
<p><span class="koboSpan" id="kobo.506.1">Failing to secure a database</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.507.1"> can lead to data breaches and </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">data loss.</span></span></p>
<p><span class="koboSpan" id="kobo.509.1">For example, consider a hypothetical healthcare application that uses a NoSQL database to store patient data. </span><span class="koboSpan" id="kobo.509.2">The database is not secured properly, and a hacker gains access to the database, compromising sensitive </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">patient data.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">Here’s an example of failing to secure a database </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">in Elasticsearch:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.513.1"> Elasticsearch</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.514.1">
// Example of failing to secure the database in Elasticsearch
// Using default settings without authentication
curl -XPUT 'http://localhost:9200/my_index/my_type/1' -d '
{
  "name": "John Doe",
  "age": 35,
  "email": "john.doe@example.com"
}'</span></pre> <p><span class="koboSpan" id="kobo.515.1">In this example, Elasticsearch is used to store patient data, but default settings are used without authentication. </span><span class="koboSpan" id="kobo.515.2">This can lead to data breaches, as unauthorized users can gain access to </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">the database.</span></span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/><span class="koboSpan" id="kobo.517.1">Overlooking performance tuning</span></h2>
<p><span class="koboSpan" id="kobo.518.1">Overlooking performance tuning</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.519.1"> can lead to slow queries and poor </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">database performance.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">For example, consider a hypothetical logistics application that uses a NoSQL database to store shipping information. </span><span class="koboSpan" id="kobo.521.2">The database is not tuned properly for the application’s workload, leading to slow queries and </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">poor performance.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">Here’s an example of overlooking performance tuning </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">in Couchbase:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.525.1">N1QL</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.526.1">
// Example of overlooking performance tuning in Couchbase
// Using default settings without optimization
// Query for all shipments
SELECT * FROM shipments;
// Query for shipments with a specific status
SELECT * FROM shipments WHERE status = "delivered";</span></pre> <p><span class="koboSpan" id="kobo.527.1">In this example, Couchbase is used to store shipping data, but the default settings are used without optimization. </span><span class="koboSpan" id="kobo.527.2">This can lead</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.528.1"> to slow queries, as the database is not optimized for the </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">application’s workload.</span></span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.530.1">Neglecting to plan for growth</span></h2>
<p><span class="koboSpan" id="kobo.531.1">Neglecting to plan for growth</span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.532.1"> can lead to scalability issues and </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">poor performance.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">For example, consider a hypothetical gaming application that uses a NoSQL database to store user data. </span><span class="koboSpan" id="kobo.534.2">The database is not designed to handle the application’s growing user base, leading to scalability issues and </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">poor performance.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">Here’s an example of neglecting to plan for growth in </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">Amazon DynamoDB:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.538.1">JSON</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.539.1">
// Example of neglecting to plan for growth in DynamoDB
// Using a single partition key for all users
{
  "user_id": "1234567890",
  "name": "John Doe",
  "score": 1000,
  "level": 5
}</span></pre> <p><span class="koboSpan" id="kobo.540.1">In this example, DynamoDB is used to store user data, but a single partition key is used for all users. </span><span class="koboSpan" id="kobo.540.2">This can lead to scalability issues, as the database may not be able to handle the growing number </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">of users.</span></span></p>
<p><span class="koboSpan" id="kobo.542.1">DevOps teams should avoid overusing or misusing denormalization, ignoring or underestimating data consistency, failing to secure a database, overlooking performance tuning, and neglecting to plan for growth. </span><span class="koboSpan" id="kobo.542.2">By avoiding these anti-patterns and wrong practices, teams can ensure that NoSQL databases are used effectively and efficiently, with optimal</span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.543.1"> performance, data consistency, and </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">data security.</span></span></p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.545.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.546.1">In this chapter, we discussed the main activities and challenges involved in working with non-relational databases as part of a DevOps team. </span><span class="koboSpan" id="kobo.546.2">We covered five areas of concern – data modeling, schema management, deployment automation, performance tuning, and security. </span><span class="koboSpan" id="kobo.546.3">For each of these areas, we identified three unique challenges that are specific to non-relational databases and explained why they exist. </span><span class="koboSpan" id="kobo.546.4">We provided in-depth explanations and code snippets for each challenge to illustrate the complexities involved. </span><span class="koboSpan" id="kobo.546.5">Overall, we emphasized that working with non-relational databases requires specialized knowledge and skills, as well as that DevOps teams may need to use custom tools and techniques to ensure that data is managed effectively </span><span class="No-Break"><span class="koboSpan" id="kobo.547.1">and securely.</span></span></p>
<p><span class="koboSpan" id="kobo.548.1">In summary, working with non-relational databases as part of the DevOps team involves specific challenges that differ from those of relational databases. </span><span class="koboSpan" id="kobo.548.2">Non-relational databases offer greater flexibility and scalability but require a different approach to data modeling, schema management, deployment automation, performance tuning, data consistency, </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">and security.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">Data modeling in non-relational databases involves selecting the appropriate data structure for the type of data being stored. </span><span class="koboSpan" id="kobo.550.2">For example, document-based databases such as MongoDB may be more suitable for hierarchical data. </span><span class="koboSpan" id="kobo.550.3">Schema management in non-relational databases can be more challenging, since there is no fixed schema, and schema migrations can be more difficult to manage. </span><span class="koboSpan" id="kobo.550.4">Deployment automation for non-relational databases may require configuring a database for high availability and disaster recovery, which can be more complex than in </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">relational databases.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">Performance tuning in non-relational databases requires optimizing indexes based on data access patterns. </span><span class="koboSpan" id="kobo.552.2">Data consistency is also a challenge, since non-relational databases may not enforce strict data consistency across multiple nodes in a distributed system. </span><span class="koboSpan" id="kobo.552.3">Security in non-relational databases may require implementing access control at a granular level, such as nodes </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">or edges.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">In contrast, relational databases offer a structured approach to data modeling and schema management, making it easier to manage data and schema changes. </span><span class="koboSpan" id="kobo.554.2">However, relational databases can be less flexible and more complex to scale. </span><span class="koboSpan" id="kobo.554.3">Performance tuning in relational databases typically relies on query optimization and table design. </span><span class="koboSpan" id="kobo.554.4">Data consistency is also easier to achieve, since relational databases enforce strict consistency across all nodes. </span><span class="koboSpan" id="kobo.554.5">Security in relational databases typically uses role-based access control at the database or </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">table level.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">Understanding and addressing these differences is essential to achieving optimal results in managing non-relational databases in a DevOps environment. </span><span class="koboSpan" id="kobo.556.2">DevOps teams must be familiar with the specific challenges of non-relational databases and develop customized solutions to address them. </span><span class="koboSpan" id="kobo.556.3">With the right approach, DevOps teams can effectively manage and optimize non-relational databases, providing scalable and reliable data solutions for </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">their organizations.</span></span></p>
<p><span class="koboSpan" id="kobo.558.1">In the next chapter, we will provide a brief overview of </span><strong class="bold"><span class="koboSpan" id="kobo.559.1">artificial intelligence</span></strong><span class="koboSpan" id="kobo.560.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.561.1">AI</span></strong><span class="koboSpan" id="kobo.562.1">), </span><strong class="bold"><span class="koboSpan" id="kobo.563.1">machine learning</span></strong><span class="koboSpan" id="kobo.564.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.565.1">ML</span></strong><span class="koboSpan" id="kobo.566.1">), and </span><strong class="bold"><span class="koboSpan" id="kobo.567.1">big data</span></strong><span class="koboSpan" id="kobo.568.1"> technologies and how they relate to </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">one another.</span></span></p>
</div>
</body></html>