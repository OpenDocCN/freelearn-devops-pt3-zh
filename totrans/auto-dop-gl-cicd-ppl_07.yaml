- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Securing Your Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护你的代码
- en: Now that you know how to configure your GitLab CI/CD pipeline to verify that
    your project’s code is meeting its requirements, the next step in constructing
    a pipeline is to add jobs that look for security vulnerabilities. This is an optional
    step, but since GitLab makes it easy to add security scanning to your pipelines,
    and since there’s virtually no downside other than adding a few minutes to your
    pipeline’s runtime, *we recommend that you enable all security scanners that are
    relevant to* *your projects*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何配置 GitLab CI/CD 管道，以验证项目代码是否满足其要求，构建管道的下一步是添加检查安全漏洞的任务。这是一个可选步骤，但由于
    GitLab 使得将安全扫描添加到管道变得简单，而且除了增加几分钟的管道运行时间外几乎没有任何缺点，*我们建议你启用所有与* *项目相关的* 安全扫描器。
- en: 'We’ll start this chapter by providing an overview of GitLab’s general strategy
    around using security scanners; several aspects of security scanning are helpful
    to understand before you start learning about individual scanners. Then, we’ll
    explain the purpose of each of the seven types of security testing that GitLab
    offers: **Static Application Security Testing** (**SAST**), **Secret Detection**,
    **Dynamic Application Security Testing** (**DAST**), **Dependency Scanning**,
    **Container Scanning**, **License Compliance**, and **Infrastructure as Code**
    (**IaC**) **Scanning**. We’ll show you how to enable each type of scanner in your
    pipelines, and then discuss some sample configuration options and techniques you
    can use to adjust their behavior to best suit your needs. Finally, we’ll cover
    three additional GitLab features that make security scanners easier to use and
    more powerful: reading scanner reports, tracking scanner findings using vulnerability
    management, and integrating outside security scanners.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从概述 GitLab 在使用安全扫描器方面的总体策略开始本章；在开始了解各个扫描器之前，理解安全扫描的几个方面是很有帮助的。接下来，我们将解释 GitLab
    提供的七种安全测试类型的目的：**静态应用安全测试**（**SAST**）、**密钥检测**、**动态应用安全测试**（**DAST**）、**依赖扫描**、**容器扫描**、**许可证合规性**和**基础设施即代码**（**IaC**）**扫描**。我们将向你展示如何在管道中启用每种类型的扫描器，然后讨论一些配置选项和技术，你可以用来调整它们的行为，以最适合你的需求。最后，我们将介绍
    GitLab 的三个附加功能，使安全扫描器更易用、更强大：阅读扫描报告、通过漏洞管理跟踪扫描结果，以及集成外部安全扫描器。
- en: By the end of this chapter, you’ll have learned some critical skills for keeping
    your code safe and your data secure. You’ll understand how to identify which GitLab-provided
    security scanners are relevant to your project. You’ll know how to add them to
    your CI/CD pipelines and configure their behavior to suit your needs. You’ll have
    a solid grasp of the different types of security reports that GitLab provides.
    You’ll also be able to track your team’s progress in remediating any security
    vulnerabilities. Finally, you’ll understand how to add third-party security scanners
    to your pipelines. In short, you’ll feel confident that your code is as secure
    as possible.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，你将掌握一些关键技能，帮助你保持代码安全并保护数据安全。你将了解如何识别哪些 GitLab 提供的安全扫描器与项目相关。你将知道如何将它们添加到
    CI/CD 管道中，并配置它们的行为以满足你的需求。你将牢牢掌握 GitLab 提供的不同类型的安全报告。你还将能够跟踪团队在修复安全漏洞方面的进展。最后，你将了解如何将第三方安全扫描器添加到管道中。简而言之，你会对自己的代码安全性充满信心。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding GitLab’s security scanning strategy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 GitLab 的安全扫描策略
- en: Using SAST to scan your source code for vulnerabilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SAST 扫描源代码中的漏洞
- en: Using Secret Detection to find private information in your repository
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用密钥检测来查找存储库中的私人信息
- en: Using DAST to find vulnerabilities in web applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DAST 查找 Web 应用程序中的漏洞
- en: Using Dependency Scanning to find vulnerabilities in dependencies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖扫描来查找依赖项中的漏洞
- en: Using Container Scanning to find vulnerabilities in Docker images
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器扫描来查找 Docker 镜像中的漏洞
- en: Using License Compliance to manage licenses of dependencies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用许可证合规性来管理依赖项的许可证
- en: Using IaC Scanning to find problems in infrastructure configuration files
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IaC 扫描来查找基础设施配置文件中的问题
- en: Understanding the different types of security reports
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解不同类型的安全报告
- en: Managing security vulnerabilities
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理安全漏洞
- en: Integrating outside security scanners
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成外部安全扫描器
- en: GitLab uses the same handful of configuration techniques for all of its security
    scanners. To avoid repetition, we’ll discuss these in detail only in the section
    dedicated to the first scanner type (SAST). When we discuss configuration techniques
    for the other scanners, we’ll refer you back to the SAST section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 对所有安全扫描器使用相同的一些配置技巧。为了避免重复，我们将在专门讨论第一个扫描器类型（SAST）的章节中详细讨论这些技巧。讨论其他扫描器的配置技巧时，我们会参考
    SAST 章节。
- en: While we’re on the subject of scanner configuration, it’s important to understand
    that most of these scanners offer *many* configuration options, and it is impossible
    to discuss all of them – or even most of them – in this book. Instead, we’ll show
    you how to get each scanner up and running in a fairly basic form, give you a
    sample of the kinds of configuration options that exist for each scanner, and
    point you to the official GitLab documentation as the best source of up-to-date
    information about the full range of configuration settings for each type of scanner.
    Fortunately, the documentation on this subject is both clear and comprehensive.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论扫描器配置时，重要的是要理解这些扫描器大多数提供 *许多* 配置选项，而在本书中讨论所有这些选项——甚至大多数选项——是不可能的。相反，我们会向你展示如何以一种相对简单的方式启动并运行每个扫描器，给你一个关于每个扫描器存在的配置选项的示例，并将你指向官方
    GitLab 文档，作为每种扫描器类型配置设置的最新信息的最佳来源。幸运的是，关于这个主题的文档既清晰又全面。
- en: Finally, note that many of these scanners are only available to users with a
    GitLab Ultimate license. However, GitLab has a history of making Ultimate-only
    scanners available to Premium or Free license users in later releases. At the
    time of writing, SAST, Secret Detection, Container Scanning, and Infrastructure
    as Code Scanning are available to all users regardless of license tier, albeit
    sometimes in a feature-limited (but still useful) form. So, if you find your favorite
    scanner is not yet available for your license, there’s a chance that it will become
    available in the future, even if you never upgrade your license.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，这些扫描器中的许多仅对拥有 GitLab Ultimate 许可证的用户可用。然而，GitLab 有将仅限 Ultimate 用户使用的扫描器在后续版本中提供给
    Premium 或 Free 许可证用户的历史。截至撰写本文时，SAST、Secret Detection、容器扫描和基础设施即代码扫描对所有用户开放，无论其许可证级别如何，尽管有时这些功能会以功能受限（但仍然有用）的形式提供。因此，如果你发现自己喜欢的扫描器尚未对你的许可证开放，那么即使你没有升级许可证，它在未来可能会变得可用。
- en: Technical requirements
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As with the previous chapters, you’ll get the most out of this chapter if you
    have an account on a GitLab instance (either self-managed or **Software-as-a-Service**
    (**SaaS**)) that you can log in to and use for practicing and experimenting with
    the concepts discussed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 和前几章一样，如果你拥有一个可以登录并用于实践和实验的 GitLab 实例账户（无论是自托管的还是 **软件即服务** (**SaaS**))，你会从本章中获得最大的收获。
- en: Understanding GitLab’s security scanning strategy
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 GitLab 的安全扫描策略
- en: There are a few fundamental principles underlying GitLab’s security scanners
    that will be useful for you to know before you learn about what each scanner does.
    Let’s look at those now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习每个扫描器的功能之前，有一些 GitLab 安全扫描器的基本原则你需要了解，这些原则会对你有所帮助。我们现在就来看看这些原则。
- en: GitLab uses open-source scanners
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab 使用开源扫描器
- en: It might surprise you to learn that all the security scanners discussed in this
    chapter are **third-party, open-source tools**; none of them are developed in-house
    by GitLab. For example, IaC scanning is performed by the open-source tool **Keeping
    Infrastructure as Code Secure** (**KICS**), and Dependency Scanning is handled
    by the open-source tool **Gemnasium**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会感到惊讶，了解到本章讨论的所有安全扫描器都是 **第三方开源工具**；其中没有任何一个是 GitLab 内部开发的。例如，基础设施即代码扫描是由开源工具
    **Keeping Infrastructure as Code Secure** (**KICS**) 执行的，依赖性扫描则由开源工具 **Gemnasium**
    处理。
- en: That doesn’t mean that these third-party scanners are inferior to GitLab-developed
    software in any way. They are all rigorously researched and vetted by GitLab before
    they are adopted as official GitLab scanners. Furthermore, GitLab frequently reviews
    new open-source security scanners to see whether they should replace or supplement
    any of the product’s current scanners. So, don’t worry – these scanners are all
    first-rate additions to your pipelines, even if their code wasn’t written by GitLab
    developers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着这些第三方扫描器在任何方面都比GitLab开发的软件差。它们都经过GitLab的严格研究和审查，才被采用为官方GitLab扫描器。此外，GitLab还会定期审查新的开源安全扫描器，看看它们是否应当替代或补充现有产品的扫描器。因此，不用担心——这些扫描器都是你管道中的一流补充，尽管它们的代码不是由GitLab开发者编写的。
- en: 'Security scanners that are developed by organizations or companies that are
    dedicated solely to security are likely to have fewer bugs than proprietary software
    developed by companies for whom security is not their primary focus. As the saying
    about open-source code goes, “*given enough eyeballs, all bugs are shallow.*”
    Making bugs shallow – and then fixing them – is especially important for security-related
    tools: using a poorly designed security scanner that gives you the false impression
    that your code is secure is worse than knowing nothing about your product’s security
    at all.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由专注于安全的组织或公司开发的安全扫描器，通常比那些由非专注于安全的公司开发的专有软件出现的漏洞更少。正如关于开源代码的说法：“*只要有足够多的眼睛，所有的漏洞都浅显易懂*。”
    使漏洞变浅——然后修复它们——对于与安全相关的工具尤其重要：使用设计不良的安全扫描器，给你一个错误的印象，让你以为代码是安全的，比完全不了解产品安全更糟糕。
- en: Since these scanners are open-source software, what’s stopping you from downloading
    them yourself and running them independently of GitLab? Nothing! But it’s hard
    to see why you’d want to. The scanners that are blessed by GitLab are simple to
    integrate into GitLab CI/CD pipelines, and GitLab automatically updates them to
    ensure that your pipelines always run the latest versions (unless you specify
    otherwise), with no action on your part required. If you have CI/CD pipelines
    set up in GitLab already, and if your GitLab license tier gives you access to
    the scanners you need, we advise that you use these tools within GitLab rather
    than running them independently. You would have nothing to gain and a fair amount
    to lose in the form of extra system administration and maintenance if you were
    to download and run them on your own.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些扫描器是开源软件，难道没有什么可以阻止你自己下载它们并独立于GitLab运行它们吗？没有！但很难理解为什么你会想这样做。GitLab认证的扫描器非常容易集成到GitLab
    CI/CD管道中，而且GitLab会自动更新它们，以确保你的管道始终运行最新版本（除非你另行指定），而你无需采取任何行动。如果你已经在GitLab中设置了CI/CD管道，并且你的GitLab许可证级别允许你访问所需的扫描器，我们建议你在GitLab内使用这些工具，而不是独立运行它们。如果你自行下载并运行它们，你不会获得任何好处，反而会因为额外的系统管理和维护而失去不少。
- en: Which languages do GitLab’s security scanners support?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab的安全扫描器支持哪些语言？
- en: To see a list of all the languages supported by each type of GitLab security
    scanner, as well as the names of the open-source tools that are used, consult
    the official GitLab documentation ([https://docs.gitlab.com/ee/user/application_security/sast/#supported-languages-and-frameworks](https://docs.gitlab.com/ee/user/application_security/sast/#supported-languages-and-frameworks)).
    Keep in mind that these details do change from time to time, so it’s wise to revisit
    the documentation periodically to see which new languages are supported by the
    different scanner types.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看每种类型的GitLab安全扫描器支持的所有语言的列表，以及所使用的开源工具的名称，请参阅官方GitLab文档（[https://docs.gitlab.com/ee/user/application_security/sast/#supported-languages-and-frameworks](https://docs.gitlab.com/ee/user/application_security/sast/#supported-languages-and-frameworks)）。请记住，这些细节会不时发生变化，因此建议定期重新查看文档，了解不同扫描器类型支持的新语言。
- en: Scanners are packaged as Docker images
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描器被打包为Docker镜像
- en: When a security scanner runs in your GitLab CI/CD pipeline, it runs within a
    Docker container. This is irrelevant for most GitLab users, but there are three
    implications that you should know about.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当安全扫描器在GitLab CI/CD管道中运行时，它会在Docker容器内运行。对于大多数GitLab用户来说，这一点无关紧要，但有三个影响你应该知道。
- en: First, because the pipeline job that runs a scanner has to pull down the Docker
    image for that scanner, this will add a minute or so to the job’s runtime. Of
    course, the exact delay depends on your network speed and on whether the image
    has been cached somewhere. This usually isn’t a big problem since many scanners
    take a few minutes to run, even after their Docker image has been downloaded.
    Also, most non-trivial pipelines run in minutes rather than seconds, so you probably
    won’t notice any short delays caused by pulling down security scanner Docker images.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点，因为运行扫描器的流水线任务需要拉取该扫描器的 Docker 镜像，所以这会增加任务运行时间大约一分钟左右。当然，具体的延迟取决于你的网络速度，以及镜像是否已经被缓存。这通常不是大问题，因为许多扫描器即使在其
    Docker 镜像下载后，仍需要几分钟才能完成扫描。此外，大多数复杂的流水线任务是以分钟为单位运行的，而不是秒，所以你可能不会注意到因拉取安全扫描器 Docker
    镜像而产生的短暂延迟。
- en: 'Second, any security scanning jobs must run on a GitLab Runner that uses Docker
    or Kubernetes executors. You can refresh your memory about GitLab Runner executors
    by referring to the previous chapter if you’re not sure what this means. If your
    organization uses the SaaS version of GitLab (that is, you use the instance at
    `gitlab.com`), this problem is solved for you: all SaaS-provided GitLab Runners
    use one of those two executors. If you’re using a self-managed instance of GitLab,
    you probably have a GitLab administrator who is in charge of setting up all the
    GitLab Runners that your team needs. Just make sure they understand that at least
    some of those Runners must use Docker or Kubernetes executors if you intend to
    add security scanning to your pipelines.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，任何安全扫描任务必须在使用 Docker 或 Kubernetes 执行器的 GitLab Runner 上运行。如果你不确定这是什么意思，可以参考前一章节来回顾
    GitLab Runner 执行器的相关内容。如果你的组织使用 GitLab 的 SaaS 版本（即你使用的是 `gitlab.com` 上的实例），那么这个问题已经为你解决：所有
    SaaS 提供的 GitLab Runners 都使用这两种执行器之一。如果你使用的是自托管的 GitLab 实例，那么你可能有一个 GitLab 管理员负责设置你团队所需的所有
    GitLab Runners。只需要确保他们明白，至少一些 Runner 必须使用 Docker 或 Kubernetes 执行器，如果你打算在流水线中添加安全扫描的话。
- en: Third, because your jobs download security scanner Docker images every time
    they run, you never have to worry about updating your security scanners. GitLab
    makes sure that the latest version of each scanner is included in the Docker image
    pulled down by each job. That’s one less maintenance chore for you to keep track
    of.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，因为你的任务每次运行时都会下载安全扫描器的 Docker 镜像，所以你无需担心更新安全扫描器。GitLab 会确保每个扫描器的最新版本包含在每次任务拉取的
    Docker 镜像中。这意味着你少了一项需要跟踪的维护任务。
- en: Some scanners use different analyzers for different languages
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些扫描器会为不同的编程语言使用不同的分析器。
- en: Some scanners, such as SAST and Dependency Scanning, rely on different open-source
    tools for scanning code written in different computer languages. GitLab calls
    these language-specific tools **analyzers**. For example, when you enable SAST
    in a project that contains only Go code, GitLab will run an open-source, Go-aware
    SAST analyzer called **Semgrep**. But when you enable SAST on a Ruby-based project,
    GitLab runs a different open-source analyzer called **Brakeman**, which knows
    how to scan Ruby code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一些扫描器，如 SAST 和依赖扫描，依赖于不同的开源工具来扫描用不同编程语言编写的代码。GitLab 称这些语言特定的工具为**分析器**。例如，当你在一个仅包含
    Go 代码的项目中启用 SAST 时，GitLab 会运行一个开源的、支持 Go 的 SAST 分析器，名为**Semgrep**。但当你在一个基于 Ruby
    的项目中启用 SAST 时，GitLab 会运行另一个名为**Brakeman**的开源分析器，它能够扫描 Ruby 代码。
- en: You don’t need to tell GitLab which analyzers to run – it detects the computer
    languages in your project automatically and only runs the analyzers that work
    with those languages. It does this by looking for `.py`, it assumes that your
    project contains Python code and runs Python-based analyzers for any security
    scanners you’ve enabled. It also looks for certain configuration files that are
    traditionally used with various languages, such as `Gemfile` or `Gemfile.lock`
    in Ruby projects, `requirements.txt` in Python projects, and `pom.xml` in Java
    projects that use the Maven build tool. Most of the time, you don’t need to worry
    about making your computer languages easy for GitLab to detect – it’s smart enough
    to do the right thing with almost all projects. But if you find that it’s not
    recognizing languages as it should, you can see lists of trigger files in the
    official GitLab documentation for each security scanner type, and make sure that
    you have at least one trigger file for each language in your project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需告诉 GitLab 运行哪些分析器——它会自动检测项目中的编程语言，并仅运行与这些语言兼容的分析器。GitLab 通过查找 `.py` 文件来推测项目包含
    Python 代码，并为你启用的任何安全扫描器运行基于 Python 的分析器。它还会查找某些传统上与各种语言一起使用的配置文件，如 Ruby 项目中的 `Gemfile`
    或 `Gemfile.lock`，Python 项目中的 `requirements.txt`，以及使用 Maven 构建工具的 Java 项目中的 `pom.xml`。大多数情况下，你不需要担心让
    GitLab 容易检测到你的编程语言——它几乎能自动正确处理所有项目。但如果你发现 GitLab 无法正确识别语言，你可以在 GitLab 官方文档中查找每种安全扫描器类型的触发文件列表，并确保项目中每种语言至少有一个触发文件。
- en: It’s fine to use multiple computer languages in the same project. GitLab will
    detect all languages in the project’s repository and run the appropriate analyzer
    for each, assuming that an analyzer exists for that scanner type and language.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个项目中使用多种编程语言是完全没问题的。GitLab 会检测项目仓库中的所有语言，并为每种语言运行相应的分析器，前提是该扫描器类型和语言都有可用的分析器。
- en: For some combinations of scanner type and language, GitLab has more than one
    analyzer available. When this occurs, it runs all of the relevant analyzers. For
    example, if you enable SAST on a project with Python code, it will run both the
    **Semgrep** and **Bandit** analyzers. If both of the analyzers detect the same
    problems, you may see duplicate results in the scanner reports, with one result
    from each analyzer. This might clutter up your reports somewhat, but it’s better
    to be safe than sorry. Also, since every open-source analyzer is written by a
    different development team with a different focus or area of concern, and since
    different analyzers have different levels of comprehensiveness or maturity, running
    multiple analyzers is a great way to maximize the number of vulnerabilities found.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些扫描器类型和语言的组合，GitLab 提供了多个可用的分析器。在这种情况下，它会运行所有相关的分析器。例如，如果你在一个包含 Python 代码的项目上启用
    SAST，它会同时运行 **Semgrep** 和 **Bandit** 分析器。如果这两个分析器检测到相同的问题，你可能会在扫描报告中看到重复的结果，每个分析器都有一条结果。虽然这可能会让报告稍显杂乱，但宁可多做一些也不愿疏漏任何问题。此外，由于每个开源分析器都是由不同的开发团队编写，具有不同的关注点或专注领域，并且不同的分析器在全面性或成熟度上有所不同，运行多个分析器是发现更多漏洞的好方法。
- en: 'If running more than one analyzer for a particular language is producing too
    much noise, you can configure most scanners to disable individual analyzers. For
    example, you could tell GitLab to run only the Bandit analyzer and not the Semgrep
    analyzer when performing SAST scans on Python code. However, we generally recommend
    that you keep as many analyzers enabled as possible to reduce the chance of vulnerabilities
    slipping through. And there’s no need to disable analyzers for languages that
    are not included in your project: GitLab is smart enough to run only the analyzers
    that support the languages that it detects.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行针对特定语言的多个分析器时产生了过多的噪声，你可以配置大多数扫描器来禁用某些单独的分析器。例如，你可以告诉 GitLab 在对 Python
    代码执行 SAST 扫描时，仅运行 Bandit 分析器，而不运行 Semgrep 分析器。然而，我们通常建议你保持尽可能多的分析器启用，以减少漏洞漏网的机会。对于不在项目中的语言，也没有必要禁用分析器：GitLab
    足够智能，只会运行支持其检测到的语言的分析器。
- en: Not all analyzers for a particular scanner type will find the same problems.
    For example, if you have a divide-by-zero vulnerability in Go code and the same
    vulnerability in Ruby code, one of the two analyzers might report this as a potential
    problem, while the other analyzer might ignore it. Again, this is the result of
    different open-source analyzers being written and maintained by different teams
    of developers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有针对特定扫描器类型的分析器都会发现相同的问题。例如，如果你在 Go 代码中有一个除以零的漏洞，而在 Ruby 代码中有相同的漏洞，其中一个分析器可能会将其报告为潜在问题，而另一个分析器可能会忽略它。同样，这是因为不同的开源分析器是由不同的开发团队编写和维护的。
- en: Vulnerabilities don’t stop the pipeline
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漏洞不会阻止流水线继续运行
- en: The default behavior for most GitLab jobs is to abort the pipeline as soon as
    the stage containing the failed job completes. After all, if your tests fail in
    an early stage, there’s no need to deploy your code in a later stage. GitLab’s
    security scanners sort of follow this standard… and sort of don’t. Let’s explain
    what we mean by that.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数 GitLab 作业，默认行为是当包含失败作业的阶段完成时，中止流水线。毕竟，如果你的测试在早期阶段失败，那么在后续阶段就没有必要部署代码。GitLab
    的安全扫描器在某种程度上遵循这个标准……但也有不遵循的地方。让我们来解释一下这意味着什么。
- en: Every security scanner that runs successfully marks its pipeline job as *passed*,
    regardless of whether it detected any vulnerabilities. In other words, seeing
    that a security scanner’s pipeline job has a *passed* status simply means the
    scanner ran to completion – it doesn’t tell you anything about whether the scanner
    found vulnerabilities. So even if your pipeline’s scanners find a huge number
    of vulnerabilities in your code, their jobs will be given a *passed* status and
    the pipeline will continue to later stages.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个成功运行的安全扫描器都会将其流水线作业标记为*通过*，无论它是否检测到任何漏洞。换句话说，看到安全扫描器的流水线作业状态为*通过*，只是意味着扫描器已完成运行——它并不告诉你扫描器是否发现了漏洞。因此，即使流水线中的扫描器在你的代码中发现了大量漏洞，它们的作业状态仍会被标记为*通过*，并且流水线会继续进入后续阶段。
- en: This might seem counterintuitive. Isn’t detecting a vulnerability similar to
    having an automated test fail? Well, yes and no. Vulnerabilities are typically
    something that your team should look at carefully, but as you’ll learn later when
    we talk about GitLab’s vulnerability management feature, you might decide not
    to fix the vulnerability. GitLab doesn’t want to presume that you will fix all
    the vulnerabilities before deploying your code to production, so it continues
    running pipelines even after vulnerabilities are found. This approach equips development
    teams with all the information GitLab can provide about the security of their
    code, without asking the tool to make any assessments about whether that code
    is suitable to be deployed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不太符合直觉。检测到漏洞不就像自动化测试失败一样吗？嗯，是的，也不是。漏洞通常是团队应该仔细检查的内容，但正如你将在后面了解的，当我们讨论
    GitLab 的漏洞管理功能时，你可能会决定不修复这个漏洞。GitLab 不想假设你会在将代码部署到生产环境之前修复所有漏洞，因此即使发现漏洞，流水线仍会继续运行。这种做法为开发团队提供了关于代码安全的所有信息，而不要求工具评估代码是否适合部署。
- en: Findings appear in three different reports
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现结果出现在三个不同的报告中
- en: Any vulnerabilities or other problems discovered by GitLab’s security scanners
    appear in reports that consolidate the results from all the different scanners.
    There are three of these reports in different places within the GitLab GUI. Each
    report shows subtly different information than the others, and it’s important
    to understand the purpose of each so that you don’t misinterpret the results.
    We’ll discuss this topic in more detail later in this chapter, but for now, we’ll
    just introduce you to the vulnerability report, which you can find by clicking
    **Security & Compliance** in the left navigation pane and then clicking **Vulnerability
    report**. When we discuss the security scanners in the rest of this chapter, we’ll
    include screenshots of sample findings from each scanner as they appear in the
    vulnerability report.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 的安全扫描器发现的任何漏洞或其他问题，都会出现在整合了所有不同扫描器结果的报告中。GitLab 界面中有三个这样的报告，分别位于不同的位置。每个报告显示的信息略有不同，理解每个报告的目的非常重要，这样你就不会误解结果。我们将在本章后面详细讨论这个话题，但现在，我们先简单介绍一下漏洞报告，你可以通过点击左侧导航栏中的**Security
    & Compliance**，然后点击**Vulnerability report**来查看。当我们在本章的其余部分讨论安全扫描器时，我们会展示每个扫描器的示例结果截图，它们会出现在漏洞报告中。
- en: Pipelines can use non-GitLab-provided scanners
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流水线可以使用非 GitLab 提供的扫描器
- en: Although GitLab’s built-in scanners might give you all the protection you need
    from security vulnerabilities, it’s possible to supplement your security testing
    by adding many other third-party scanners to your pipelines. We’ll discuss how
    to configure this type of integration in a dedicated section (*Integrating outside
    security scanners*) toward the end of this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 GitLab 内置的扫描工具可能为你提供所需的所有安全漏洞保护，但你仍然可以通过向管道中添加许多其他第三方扫描工具来补充安全测试。我们将在本章末尾的专门部分（*集成外部安全扫描器*）中讨论如何配置这种集成。
- en: Now that you understand some of the concepts that underly all of GitLab’s security
    scanners, let’s look at each scanner to learn what kinds of problems it can spot
    and how to use them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了一些 GitLab 安全扫描器的基本概念，让我们来看一下每个扫描器，了解它们能够发现哪些问题以及如何使用它们。
- en: Using SAST to scan your source code for vulnerabilities
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SAST 扫描源代码中的漏洞
- en: Let’s start our survey of scanners with **SAST**. *We encourage you to read
    this section carefully, even if you don’t intend to use SAST*, because many of
    the principles and practices involved with using SAST carry over to the other
    scanners as well. Understanding how to use SAST gives you a huge head start in
    terms of enabling, configuring, and reading the findings of other scanners.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**SAST**开始介绍扫描工具。*即使你不打算使用 SAST，也建议你仔细阅读本节内容*，因为使用 SAST 所涉及的许多原则和实践同样适用于其他扫描工具。了解如何使用
    SAST 可以让你在启用、配置和解读其他扫描工具的结果时占得先机。
- en: Understanding SAST
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 SAST
- en: SAST looks at your project’s source code, as opposed to interacting with your
    code as it runs. Sometimes, this approach is referred to as *white-box scanning*,
    meaning that the scanner looks *inside* your app to inspect its code instead of
    staying *outside* the app and simply analyzing its behavior.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SAST 查看的是项目的源代码，而不是在代码运行时与其交互。有时，这种方法被称为*白盒扫描*，意味着扫描器查看应用程序的*内部*以检查其代码，而不是待在应用程序*外部*仅分析其行为。
- en: 'This scanner looks for bad coding practices, anti-patterns, or the hallmarks
    of poorly designed or structured code, which are sometimes referred to as *code
    smells*, that could potentially result in exploitable security problems. For example,
    consider this single line of Python code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 该扫描器会查找不良编码实践、反模式或设计不良、结构不佳的代码特征，这些有时被称为*代码异味*，可能会导致可被利用的安全问题。例如，考虑以下这一行 Python
    代码：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It looks harmless, but non-Python programmers might be surprised to learn that
    it’s considered a security vulnerability. A Python best practice is to use the
    language’s built-in `tempfile` module to create and manage temporary directories
    and files. Any directories or files created with this module are automatically
    deleted when the program finishes executing, which ensures that no sensitive data
    is accidentally left on the computer’s filesystem. Creating a directory to hold
    temporary files is dangerous because it’s easy to forget to clean up after yourself
    by deleting this directory when the program no longer needs it. This is exactly
    the kind of problem that SAST is designed to detect.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来无害，但非 Python 程序员可能会惊讶地发现，它被认为是一个安全漏洞。Python 的最佳实践是使用语言内置的 `tempfile` 模块来创建和管理临时目录和文件。通过该模块创建的任何目录或文件在程序执行完毕后会自动删除，确保没有敏感数据被意外地留在计算机的文件系统中。创建用于存放临时文件的目录是危险的，因为很容易忘记在程序不再需要时删除该目录。这正是
    SAST 设计用来检测的问题。
- en: As mentioned in the previous section, different SAST analyzers for different
    computer languages will look for different security vulnerabilities. The GitLab
    SAST analyzer for a different language might not detect a similar problem in code
    written in that language, either because the code isn’t considered to be a vulnerability
    in that language or because the analyzer might not be as mature or robust as GitLab’s
    Python SAST analyzers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上一节所提到的，不同计算机语言的 SAST 分析器会寻找不同的安全漏洞。GitLab 针对其他语言的 SAST 分析器可能无法检测出该语言代码中的类似问题，这可能是因为该语言中的代码不被认为是漏洞，或者分析器的成熟度和稳定性不如
    GitLab 的 Python SAST 分析器。
- en: Enabling SAST
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用 SAST
- en: 'There are two ways to enable SAST in a GitLab project’s pipeline: manually,
    or with the GitLab GUI. They boil down to the same thing since they both result
    in adding a few lines of content to the `.gitlab-ci.yml` file that configures
    your CI/CD pipeline. Let’s look at both approaches.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以在 GitLab 项目的流水线中启用 SAST：手动启用或通过 GitLab GUI 启用。它们最终是一样的，因为它们都会导致向 `.gitlab-ci.yml`
    文件中添加几行配置 CI/CD 流水线的内容。让我们来看一下这两种方法。
- en: Enabling SAST manually
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动启用 SAST
- en: 'To enable SAST manually, you need to do two things to your project’s `.``gitlab-ci.yml`
    file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动启用 SAST，你需要对项目的 `.gitlab-ci.yml` 文件进行两项操作：
- en: Make sure the pipeline has a `test` stage defined
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保流水线已经定义了 `test` 阶段
- en: Include a template called `Security/SAST.gitlab-ci.yml`
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含名为 `Security/SAST.gitlab-ci.yml` 的模板
- en: 'The code looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下所示：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first of these steps is easy since pipelines usually already have a `test`
    stage defined by the time you must add security scanning. But if you’re adding
    security scanning before you’ve added any other test-related jobs, just add the
    first two lines in the preceding snippet. Of course, if you already have other
    stages defined, don’t delete them when adding your `test` stage – just add `test`
    to the existing stages.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤中的第一步很简单，因为流水线通常在你必须添加安全扫描时，已经定义了 `test` 阶段。但如果你在添加任何其他测试相关的作业之前就要添加安全扫描，只需添加前面片段中的前两行。当然，如果你已经定义了其他阶段，在添加
    `test` 阶段时不要删除它们——只需将 `test` 添加到现有的阶段中。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that the order in which you list stages matters because that’s the
    order in which GitLab will run them in your pipeline.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，列出阶段的顺序很重要，因为 GitLab 会按照这个顺序在流水线中执行它们。
- en: The second step involves adding a template to your CI/CD configuration. A template
    is a file provided by GitLab that contains CI/CD code that defines new job definitions
    or adds other features. By including a template in your CI/CD configuration file,
    you can add job definitions that perform tasks such as SAST scanning without having
    to know how those jobs work.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是将一个模板添加到你的 CI/CD 配置中。模板是 GitLab 提供的文件，包含定义新作业定义或添加其他功能的 CI/CD 代码。通过在你的 CI/CD
    配置文件中包含一个模板，你可以添加执行任务（例如 SAST 扫描）的作业定义，而无需了解这些作业的工作原理。
- en: 'In this case, the template adds a job definition for each GitLab SAST analyzer.
    It also adds logic to detect which languages exist in your project so that it
    knows which of the SAST-related jobs to run. If you imagine that your `hats-for-cats`
    project contains only Python code, you would expect this template to run two new
    jobs in the project’s pipeline: one for Bandit and one for Semgrep, which are
    GitLab’s two Python SAST analyzers.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，模板为每个 GitLab SAST 分析器添加了一个作业定义。它还添加了检测项目中存在哪些语言的逻辑，以便它知道要运行哪些与 SAST 相关的作业。如果你假设你的
    `hats-for-cats` 项目仅包含 Python 代码，你会期望此模板在项目的流水线中运行两个新作业：一个是 Bandit，另一个是 Semgrep，它们是
    GitLab 的两个 Python SAST 分析器。
- en: 'Sure enough, if you commit this change to `.gitlab-ci.yml` and look at the
    details of the pipeline triggered by that commit, you’ll see that those jobs are
    now included in your pipeline, under the `test` stage:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 结果果然如此，如果你将此更改提交到 `.gitlab-ci.yml` 文件，并查看由该提交触发的流水线的详细信息，你会看到这些作业现在已经包含在你的流水线中，位于
    `test` 阶段下：
- en: '![Figure 7.1 – Python SAST jobs on the pipeline details page](img/B18073_07_1.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 流水线详细信息页面上的 Python SAST 作业](img/B18073_07_1.jpg)'
- en: Figure 7.1 – Python SAST jobs on the pipeline details page
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 流水线详细信息页面上的 Python SAST 作业
- en: Remember that if your project contains code in a language other than Python,
    you’ll see different job names and potentially a different number of jobs on this
    page. And if your project contains code in Python and another language, you’ll
    see jobs for the SAST analyzers for each of those languages.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果你的项目包含 Python 以外的其他语言的代码，你将在此页面上看到不同的作业名称，并可能会看到不同数量的作业。如果你的项目同时包含 Python
    和其他语言的代码，你将看到每种语言的 SAST 分析器的作业。
- en: Enabling SAST with the GitLab GUI
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 GitLab GUI 启用 SAST
- en: 'Strangely enough, using the GUI to add SAST scanning to your pipeline is a
    more involved process than doing so manually:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪的是，通过 GUI 向流水线添加 SAST 扫描比手动添加要复杂：
- en: Start the process by navigating to the **Security and Compliance** option in
    the left pane and then selecting **Configuration**. This will direct you to a
    control panel for enabling and configuring most (but not all) of GitLab’s security
    scanners.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到左侧面板中的 **安全与合规性** 选项，然后选择 **配置**，开始这个过程。这将引导你进入一个控制面板，用于启用和配置 GitLab 的大部分（但不是全部）安全扫描器。
- en: The exact GUI controls sometimes change with new GitLab releases, but there
    will be a button that lets you enable SAST. Clicking that button will take you
    to a new page for configuring SAST.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 精确的 GUI 控件有时会随着 GitLab 版本更新而变化，但会有一个按钮让你启用 SAST。点击该按钮会带你到一个新的页面用于配置 SAST。
- en: You can usually keep all the options set to their default values and click the
    button at the bottom that creates a merge request. That will take you to a merge
    request creation page.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通常，你可以将所有选项保持为默认值，然后点击底部的按钮来创建合并请求。这将带你到一个合并请求创建页面。
- en: Once again, you can usually leave all the fields at their default values and
    click the button at the bottom to create the merge request.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次提醒，你通常可以将所有字段保持为默认值，然后点击底部的按钮来创建合并请求。
- en: Navigate to the merge request and merge it to complete the process. Your `.gitlab-ci.yml`
    file should now include the `test` stage if it didn’t do so already, as well as
    include the SAST template described in the previous section. You can see how simply
    editing that file manually would have probably been much easier!
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到合并请求并进行合并以完成过程。如果你的 `.gitlab-ci.yml` 文件之前没有包含 `test` 阶段，现在它应该包括该阶段，并包含前一节中描述的
    SAST 模板。你可以看到，手动编辑该文件可能会更加简单！
- en: 'Once you’ve enabled SAST using the GUI, you should see the same results as
    if you’d enabled SAST manually: two new jobs will be added to each run of your
    pipeline, corresponding to the two Python-based analyzers that GitLab supports
    for SAST.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你通过 GUI 启用了 SAST，你应该会看到与手动启用 SAST 时相同的结果：每次运行管道时，将会添加两个新任务，分别对应 GitLab 支持的两个基于
    Python 的分析器。
- en: Configuring SAST
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置 SAST
- en: Now, you know how to add SAST to your GitLab pipeline. But what if you want
    to change SAST’s default behavior? The techniques you can use for configuring
    SAST are also used to configure most of the other security scanners. We’ll discuss
    these techniques in detail here and then refer you back to this section instead
    of repeating this information when we introduce you to the other scanners.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经知道如何将 SAST 添加到你的 GitLab 管道中。但如果你想改变 SAST 的默认行为怎么办？用于配置 SAST 的技术也适用于配置大多数其他安全扫描器。我们将在这里详细讨论这些技术，并在介绍其他扫描器时，直接参考本节，而不是重复这些信息。
- en: 'There are three ways to configure SAST or any other security scanner:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 SAST 或其他任何安全扫描器的方式有三种：
- en: In `.gitlab-ci.yml`, set a global variable
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `.gitlab-ci.yml` 中，设置全局变量
- en: In `.gitlab-ci.yml`, override a job definition that was originally added by
    the template you included, and set a job-scoped variable for that job
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `.gitlab-ci.yml` 中，重写由你包含的模板原本添加的任务定义，并为该任务设置一个任务范围的变量。
- en: Use the GitLab GUI
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitLab GUI
- en: Which of these three techniques you use to configure SAST or any other scanner
    depends on what configuration option you want to set. Unfortunately, you don’t
    get to pick which of these techniques you’d like to use to set a particular configuration
    option – you have to refer to the GitLab documentation to see which technique
    or techniques you must use to set the configuration option you’re interested in.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用哪种技术来配置 SAST 或其他扫描器，取决于你想要设置的配置选项。不幸的是，你无法选择使用哪种技术来设置特定的配置选项——你必须参考 GitLab
    文档，查看你感兴趣的配置选项需要使用哪种技术或哪几种技术。
- en: Let’s see some examples of configuring SAST.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些配置 SAST 的示例。
- en: Configuring SAST with a global variable
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用全局变量配置 SAST
- en: 'First, say that you want to disable the Semgrep SAST analyzer for Python. You
    can do that by setting a global variable within `.gitlab-ci.yml`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设你想禁用 Python 的 Semgrep SAST 分析器。你可以通过在 `.gitlab-ci.yml` 中设置一个全局变量来做到这一点：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you add this variable to your CI/CD configuration file and then rerun your
    pipeline, you’ll notice that the `semgrep-sast` job you saw in the preceding screenshot
    is now gone.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将此变量添加到你的 CI/CD 配置文件中并重新运行管道，你会注意到在前面截图中看到的 `semgrep-sast` 任务现在已经消失了。
- en: Of course, if your CI/CD configuration file already has a `variables` section,
    you should add this new variable to any existing variables instead of creating
    an entirely new `variables` section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你的 CI/CD 配置文件已经有 `variables` 部分，你应该将这个新变量添加到现有的变量中，而不是创建一个全新的 `variables`
    部分。
- en: Configuring SAST by overriding a job definition and setting a job-scoped variable
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过重写任务定义并设置任务范围变量来配置 SAST
- en: 'Next, imagine that you want the Bandit SAST analyzer not to scan certain directories,
    such as a directory that contains test code. Perhaps you know that your tests
    are filled with security vulnerabilities, but you don’t care because customers
    will never use that code. You can set that configuration option by editing `.gitlab-ci.yml`
    to override the definition of the job that triggers Bandit, and setting a job-scoped
    variable within the new job definition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假设你希望 Bandit SAST 分析器不扫描某些目录，比如包含测试代码的目录。也许你知道你的测试中充满了安全漏洞，但你不在乎，因为客户永远不会使用这些代码。你可以通过编辑
    `.gitlab-ci.yml` 来设置这个配置选项，以覆盖触发 Bandit 的作业定义，并在新的作业定义中设置一个作业范围的变量：
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Don’t be thrown by the strange-looking value of the variable. This particular
    variable expects a value written in the slightly odd `fnmatch` syntax. That’s
    the kind of detail you’ll learn about when you consult the GitLab documentation
    to learn more about various configuration options for this and other scanners.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被变量的奇怪值吓到。这个特殊的变量期望一个使用稍微不同的 `fnmatch` 语法写成的值。这就是你在查阅 GitLab 文档以了解更多关于这个和其他扫描器的各种配置选项时学到的细节。
- en: If you add this code to your CI/CD configuration file and rerun your pipeline,
    the Bandit analyzer will stop reporting any vulnerabilities it finds in the `my_tests`
    directory. We haven’t talked about how to view the results of these analyzers
    yet, but don’t worry – that will come later in this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将这段代码添加到你的 CI/CD 配置文件并重新运行管道，Bandit 分析器将停止报告在 `my_tests` 目录中发现的任何漏洞。我们还没有讨论如何查看这些分析器的结果，但别担心
    —— 这些内容将在本章稍后部分介绍。
- en: Configuring SAST with the GUI
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 GUI 配置 SAST
- en: Finally, you can use GitLab’s GUI to set certain configuration options for some
    scanners. For example, on the same GUI page that you used to enable SAST, you
    can configure SAST to use an analyzer from an alternative Docker image, change
    the pipeline stage it runs in, or change the depth of directories it searches
    when detecting the languages in your project. You can also use that GUI page to
    disable certain language-specific SAST analyzers if you find that they are unhelpful
    or produce findings that duplicate the results generated by other analyzers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用 GitLab 的 GUI 设置某些扫描器的配置选项。例如，在同一 GUI 页面上，你可以配置 SAST 使用来自其他 Docker 镜像的分析器、更改它运行的管道阶段，或更改它在检测项目中的语言时搜索的目录深度。如果你发现某些特定语言的
    SAST 分析器没有帮助，或者生成的结果与其他分析器重复，你也可以在该 GUI 页面上禁用这些分析器。
- en: Compared to other scanner types, SAST makes an unusually large number of configuration
    options available from the GUI. The GitLab documentation can give you more information
    about which options are available in the GUI for other scanners, and which options
    must be set by editing `.``gitlab-ci.yml` instead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他扫描器类型相比，SAST 提供了异常多的配置选项，可以通过图形用户界面（GUI）进行设置。GitLab 文档可以为你提供更多关于其他扫描器在 GUI
    中可用选项的信息，以及哪些选项必须通过编辑 `.gitlab-ci.yml` 文件来设置。
- en: Viewing SAST’s findings
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看 SAST 的发现
- en: 'Once you’ve enabled and, optionally, configured SAST, it will run the appropriate
    analyzer(s) for whatever language(s) it detects in your project, and will display
    its findings in GitLab’s three security reports. For example, here’s the finding
    for the vulnerability related to temporary directories that was described previously,
    as shown in GitLab’s **Vulnerability** **Report** area:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用了 SAST，并且可以选择进行配置，它将根据项目中检测到的语言运行相应的分析器，并在 GitLab 的三个安全报告中显示其结果。例如，这里是 GitLab
    **漏洞** **报告** 区域中描述的与临时目录相关的漏洞的发现：
- en: '![Figure 7.2 – SAST finding](img/B18073_07_2.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – SAST 发现](img/B18073_07_2.jpg)'
- en: Figure 7.2 – SAST finding
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – SAST 发现
- en: 'This wraps up our summary of SAST. Let’s move on to a separate but related
    security scanner: Secret Detection.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们对 SAST 的总结。接下来，让我们讨论一个相关但独立的安全扫描器：秘密检测（Secret Detection）。
- en: Using Secret Detection to find private information in your repository
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用秘密检测在你的代码库中查找私人信息
- en: You can think of Secret Detection as a special, focused version of SAST that’s
    dedicated to finding secrets that are accidentally lurking in your source code,
    such as United States social security numbers or AWS deploy keys. It operates
    in the same way as SAST – that is, by scanning your source code rather than by
    interacting with your executing application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将秘密检测（Secret Detection）看作是SAST（静态应用安全测试）的一种特殊、专注的版本，专门用于发现那些意外出现在源代码中的秘密，例如美国社会保障号码或AWS部署密钥。它的工作方式与SAST相同——也就是通过扫描源代码，而不是通过与正在运行的应用程序进行交互。
- en: Secret Detection used to be part of GitLab’s SAST feature but was eventually
    spun off to become its own first-class security scanner. We are mentioning this
    so that you won’t be confused if you run into references in old documentation
    or blog posts suggesting that Secret Detection is performed by GitLab’s SAST scanner.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密检测曾经是GitLab SAST功能的一部分，但最终被单独分离出来，成为一个独立的一级安全扫描器。我们提到这一点是为了避免你在遇到旧文档或博客文章中的引用时感到困惑，因为这些资料可能会提到秘密检测是由GitLab的SAST扫描器执行的。
- en: Understanding Secret Detection
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解秘密检测
- en: 'Secret Detection looks for a wide variety of strings that represent secrets
    that should not normally be stored in files in a Git repository. In addition to
    the social security numbers and AWS deploy keys already mentioned, here are just
    a few of the 50 or so kinds of secrets it looks for:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密检测会寻找各种各样的字符串，这些字符串代表了那些通常不应存储在Git仓库文件中的秘密。除了前面提到的社会保障号码和AWS部署密钥，下面是它寻找的50多种秘密中的一些：
- en: Short- and long-lived Dropbox API tokens
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短期和长期有效的Dropbox API令牌
- en: GitLab personal access tokens
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab个人访问令牌
- en: Heroku API keys
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heroku API密钥
- en: Private SSH keys
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有SSH密钥
- en: Stripe access tokens
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stripe访问令牌
- en: 'For example, Secret Detection should find and report on all three of the secrets
    contained in this snippet of Python code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，秘密检测应该能找到并报告以下Python代码片段中包含的所有三个秘密：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Secret Detection is based on **regular expressions** (or **regexes**): the
    scanner has a regex for each type of string it tries to detect and reports any
    string literals that match those regexes.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密检测基于**正则表达式**（或**regexes**）：扫描器为每种类型的字符串创建了一个正则表达式，用于检测并报告任何与这些正则表达式匹配的字符串字面量。
- en: 'The use of regexes means that Secret Detection is completely language-agnostic.
    Since it just scans files to see whether any strings match regexes, it doesn’t
    care what computer language is used in your repository. This means that, unlike
    SAST, Secret Detection doesn’t require separate analyzers for different languages:
    it uses one analyzer for all source code files. Secret Detection is even file
    type-agnostic: it will scan configuration files, README files, plain text files,
    and any other non-binary files in your repository. It can look for strings that
    match regexes in a JSON configuration file just as easily as it can look for strings
    in a Go source code file.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的使用意味着秘密检测完全与编程语言无关。由于它只是扫描文件，看是否有任何字符串与正则表达式匹配，它并不关心你的仓库中使用的是哪种计算机语言。这意味着，与SAST不同，秘密检测不需要针对不同语言的单独分析器：它使用一个分析器来处理所有源代码文件。秘密检测甚至不依赖于文件类型：它可以扫描配置文件、README文件、纯文本文件以及仓库中的任何其他非二进制文件。它可以像在Go源代码文件中查找字符串一样，轻松地在JSON配置文件中查找匹配正则表达式的字符串。
- en: 'While regexes are a powerful tool, Secret Detection’s reliance on them does
    mean that the scanner has an important limitation: it can’t detect passwords.
    This sounds surprising at first but makes sense once you realize that a well-written
    password should be difficult to capture with a regex. It’s hard to think up a
    regex that would capture any possible password without also matching non-secret
    text such as a sentence in documentation or a series of words in a GUI element.
    But other than this one case, Secret Detection does a great job at ferreting out
    strings that should be kept in a more secure location than a Git repository.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然正则表达式是一个强大的工具，但秘密检测依赖它们也意味着扫描器有一个重要的限制：它无法检测密码。这个限制一开始可能让人惊讶，但一旦你意识到一个设计良好的密码应该很难用正则表达式捕捉到，这就能理解了。很难设计一个能够捕捉任何可能的密码的正则表达式，而不会同时匹配到像文档中的一句话或图形用户界面元素中的一系列词语这样的非秘密文本。除了这个特定的情况，秘密检测在发现那些应该存储在比Git仓库更安全位置的字符串方面表现出色。
- en: 'There’s one fantastic feature that Secret Detection is the only GitLab scanner
    to offer: **historic mode**. If you enable this mode, Secret Detection will scan
    all the commits in your repository to see whether there have *ever* been any secrets
    committed to it.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个极好的功能是 Secret Detection 是唯一提供的 GitLab 扫描器功能：**历史模式**。如果启用此模式，Secret Detection
    将扫描您仓库中的所有提交，查看是否曾经有任何秘密被提交到其中。
- en: Why is historic mode important? Since one of the goals of version control systems
    such as Git is to allow you to go back to the state of files as they were at any
    point in time, it’s easy to see any secrets that have ever been committed, even
    if they were immediately removed in the very next commit. Once a secret is in
    a Git repository, it’s always retrievable. So, whenever Secret Detection discovers
    a secret, the entry it creates in any of the security scanner reports always mentions
    that the secret should not just be removed, but *revoked*. Any secret that makes
    its way into a Git repository should be considered to have been exposed to the
    world, and should no longer be used.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么历史模式很重要？由于 Git 等版本控制系统的目标之一是允许您回到任何时刻文件的状态，因此即使秘密在下一个提交中被立即删除，也可以很容易地看到任何曾经被提交的秘密。一旦秘密进入
    Git 仓库，它始终是可恢复的。因此，每当 Secret Detection 发现一个秘密时，它在任何安全扫描报告中创建的条目总是会提到该秘密不仅应该被删除，还应该被
    *撤销*。任何进入 Git 仓库的秘密都应该被认为已经暴露给了全世界，应该不再使用。
- en: This is an extremely important point! If Secret Detection finds a password,
    you should immediately retire that password and set a new one (which, of course,
    you shouldn’t check into Git). If it detects a deploy key, you should cancel that
    key and create a new one. This principle holds for any kind of secret. If Secret
    Detection spots it, simply removing it from the repo is not sufficient. It should
    be considered no longer usable and should be replaced as soon as possible.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常重要的观点！如果 Secret Detection 找到一个密码，您应该立即停用该密码并设置一个新密码（当然，您不应该将新密码提交到 Git）。如果它检测到一个部署密钥，您应该取消该密钥并创建一个新的。这一原则适用于任何类型的秘密。如果
    Secret Detection 发现了它，单纯从仓库中删除它是不够的。它应该被认为不再可用，并应尽快更换。
- en: Enabling and configuring Secret Detection
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和配置 Secret Detection
- en: Since Secret Detection used to be a part of SAST, it’s not surprising that you
    can use the same manual or GUI-based methods to enable both scanners.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Secret Detection 以前是 SAST 的一部分，因此您可以使用相同的手动或基于 GUI 的方法来启用这两个扫描器，这一点并不令人惊讶。
- en: 'To enable Secret Detection manually, make sure you have a `test` stage defined
    in your pipeline. Then, include the GitLab-provided template that contains the
    Secret Detection-related job definitions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动启用 Secret Detection，请确保在您的管道中定义了一个 `test` 阶段。然后，包含 GitLab 提供的模板，其中包含与 Secret
    Detection 相关的作业定义：
- en: '[PRE5]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That’s all there is to it! The next time you trigger a pipeline, you will notice
    that a Secret Detection job is now running under the `test` stage.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单！下次触发管道时，您会注意到一个 Secret Detection 作业现在在 `test` 阶段下运行。
- en: 'To enable Secret Detection using the GUI, you can use the same process as for
    SAST: click the `.gitlab-ci.yml` file to include the Secret Detection template
    described previously. If you merge the request and trigger a new pipeline run,
    you’ll find that Secret Detection is now enabled in your pipeline. As with SAST,
    many people find this process more cumbersome than simply editing `.gitlab-ci.yml`
    manually, but your experience may vary.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过图形界面启用 Secret Detection，您可以使用与启用 SAST 相同的过程：点击 `.gitlab-ci.yml` 文件，包含之前描述的
    Secret Detection 模板。如果您合并请求并触发新的管道运行，您会发现 Secret Detection 已经在您的管道中启用。与 SAST 一样，许多人发现这个过程比直接手动编辑
    `.gitlab-ci.yml` 更繁琐，但您的体验可能有所不同。
- en: Like most GitLab security scanners, Secret Detection has several configurable
    options. You can learn about all of the options and how to set them in the GitLab
    documentation, but two are especially worth highlighting here.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数 GitLab 安全扫描器一样，Secret Detection 有多个可配置选项。您可以在 GitLab 文档中了解所有选项及其设置方法，但这里有两个特别值得强调。
- en: First, you might want to enable the special `test/` directory, and have fake
    deploy keys stored in a `docs/` directory. You would probably want to prevent
    Secret Detection from flagging these as security vulnerabilities by excluding
    those directories.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您可能想要启用特定的 `test/` 目录，并将假的部署密钥存储在 `docs/` 目录中。您可能希望通过排除这些目录，防止 Secret Detection
    将它们标记为安全漏洞。
- en: 'You can set both of these configuration options by overriding the `secret_detection`
    job definition that’s provided by the Secret Detection CI/CD template and then
    setting job-scoped variables:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过覆盖由秘密检测 CI/CD 模板提供的 `secret_detection` 作业定义，然后设置作业范围的变量来设置这两个配置选项。
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With Secret Detection already configured and enabled, let us now view its findings.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 已配置并启用秘密检测，现在让我们查看其发现。
- en: Viewing Secret Detection’s findings
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看秘密检测的发现
- en: 'Once you’ve enabled and configured Secret Detection to your liking and it has
    run successfully in a pipeline, you can see the results in the **Vulnerability
    Report** area, just like you did with the SAST results. For example, here are
    the results that are generated by running Secret Detection on the Python code
    provided previously:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您根据喜好启用和配置了秘密检测，并且它在流水线中成功运行，您可以像在 SAST 结果中一样在**漏洞报告**区域看到结果。例如，这些是在之前提供的
    Python 代码上运行秘密检测生成的结果：
- en: '![Figure 7.3 – Secret Detection findings](img/B18073_07_3.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 - 秘密检测发现](img/B18073_07_3.jpg)'
- en: Figure 7.3 – Secret Detection findings
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 - 秘密检测发现
- en: 'Now that you’ve got a handle on Secret Detection, it’s time to look at the
    next security scanner in the GitLab arsenal: DAST.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了秘密检测，是时候看看 GitLab 兵器库中的下一个安全扫描器：DAST。
- en: Using DAST to find vulnerabilities in web applications
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DAST 查找 Web 应用程序中的漏洞
- en: 'Let’s move on to the next type of security scanner: **DAST**. This scanner
    interacts with your code as it runs instead of looking at your source code. If
    SAST and Secret Detection are examples of “white-box” testing – they look inside
    your app to see how it works – then DAST is a form of “black-box” testing – it
    just sends input and looks for potential problems or security vulnerabilities
    in the output, without knowing how your application performs that transformation
    of input into output.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个类型的安全扫描器：**DAST**。此扫描器与您的代码交互运行，而不是查看您的源代码。如果 SAST 和秘密检测是“白盒”测试的例子 -
    它们查看您的应用程序内部的工作方式 - 那么 DAST 是“黑盒”测试的一种形式 - 它只发送输入并查找输出中的潜在问题或安全漏洞，而不知道您的应用程序如何执行输入到输出的转换。
- en: Understanding DAST
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 DAST
- en: 'DAST tests either **web application URLs** or **Web API endpoints**. If you
    feed DAST the URL of a website’s home page, it will visit that page, identify
    any links or clickable GUI elements on the page, follow those links or click those
    elements, and repeat the process. It will continue this “spidering” procedure
    until it has visited every page that it can reach within your app. At each step,
    it checks the results returned by the web application to see whether it finds
    any problems. Here are just three examples of the sorts of things it looks for:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: DAST 测试**Web 应用程序 URL**或**Web API 端点**。如果您向 DAST 提供网站主页的 URL，它将访问该页面，识别页面上的任何链接或可点击的
    GUI 元素，跟随这些链接或点击这些元素，并重复此过程。它将继续执行此“爬行”过程，直到访问您的应用程序内可达到的每个页面。在每个步骤中，它检查 Web 应用程序返回的结果，以查看是否存在任何问题。以下是它寻找的问题类型的三个示例：
- en: Exposure of private personal information
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露私人个人信息
- en: Missing cross-site request forgery tokens
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少跨站请求伪造令牌
- en: Accepting sensitive information such as passwords through query strings
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过查询字符串接受敏感信息，如密码
- en: If you tell DAST to scan a Web API endpoint, it sends information to the endpoint
    and analyzes the response, looking for the same sorts of problems.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您告诉 DAST 扫描 Web API 端点，它会向端点发送信息并分析响应，寻找相同类型的问题。
- en: Regardless of whether it targets URLs or Web API endpoints, DAST can operate
    in either **passive** or **active** mode. Every time DAST runs, it performs a
    passive scan, which means that it makes benign, non-malicious requests similar
    to the requests sent by a real user. If you want a deeper analysis of your web
    app, you can enable a so-called **full scan**, which adds active attacks to the
    passive requests that it normally makes. These active attacks are more aggressive
    and could be considered malicious if they were directed at a website or Web API
    that you don’t own. However, they are invaluable in that they mimic the types
    of attacks that actual hackers might use, and therefore reveal many weaknesses
    that could be exploited by malicious actors.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是针对 URL 还是 Web API 端点，DAST 都可以在 **被动** 或 **主动** 模式下运行。每次 DAST 运行时，它都会执行被动扫描，这意味着它会发送类似真实用户请求的良性、无害的请求。如果你想对你的
    Web 应用进行更深入的分析，可以启用所谓的 **完整扫描**，它会在通常发送的被动请求基础上添加主动攻击。这些主动攻击更具攻击性，如果它们被指向你不拥有的网站或
    Web API，可能会被视为恶意攻击。然而，这些攻击非常宝贵，因为它们模拟了实际黑客可能使用的攻击类型，因此揭示了许多可能被恶意行为者利用的弱点。
- en: Enabling and configuring DAST
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和配置 DAST
- en: DAST has a plethora of configuration options. We’ll cover a handful of the most
    commonly used options, which will be enough to get you up and running with DAST.
    As usual, the official GitLab documentation has full details on all of the ways
    you can configure DAST to behave in non-default ways.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: DAST 提供了大量的配置选项。我们将介绍一些最常用的选项，这些足以帮助你快速开始使用 DAST。像往常一样，GitLab 官方文档提供了关于如何以非默认方式配置
    DAST 的完整细节。
- en: It’s easiest to enable and configure DAST using the GUI. The exact details of
    this process may change in future GitLab releases, so we’ll cover the high-level
    concepts without going too far into specific details.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GUI 启用和配置 DAST 是最简单的。这个过程的具体细节可能会在未来的 GitLab 版本中有所变化，因此我们将介绍高层次的概念，而不深入探讨具体的细节。
- en: 'You can start enabling and configuring DAST by visiting the same security scanner
    configuration page you used for SAST and Secret Detection: click the **Security
    and Compliance** option in the left navigation pane and select **Configuration**.
    From there, you’ll be able to click a button to enable DAST, though the button
    will first take you to another page that lets you set up some configuration options
    that DAST needs to go through.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过访问你为 SAST 和秘密检测使用的相同安全扫描器配置页面来开始启用和配置 DAST：点击左侧导航栏中的 **安全性与合规性** 选项，并选择
    **配置**。从那里，你将能够点击一个按钮来启用 DAST，尽管该按钮首先会将你引导到另一个页面，让你设置 DAST 需要通过的一些配置选项。
- en: First, you’ll need to set up a **scanner profile**. This tells DAST whether
    to use only passive scans or to perform active scans as well. You can also set
    timeout values to limit the amount of time DAST spends spidering a website. GitLab
    will let you name this profile so that you can use the same profile later with
    several different URLs or Web API targets.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要设置一个 **扫描器配置文件**。该配置文件告诉 DAST 是否只使用被动扫描，还是同时执行主动扫描。你还可以设置超时值，以限制 DAST
    在爬取网站时的时间。GitLab 会让你为此配置文件命名，以便以后可以将同一个配置文件用于多个不同的 URL 或 Web API 目标。
- en: Second, GitLab will guide you to create a **site profile**. This profile contains
    the URL of the website’s home page or Web API endpoint that you want to scan.
    If you’re scanning a website, you can optionally add authentication credentials
    to the site profile. These allow DAST to sign in to the website like a user would,
    which typically exposes additional URLs to be scanned.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，GitLab 会引导你创建一个 **站点配置文件**。该配置文件包含你想要扫描的网站首页或 Web API 端点的 URL。如果你扫描的是一个网站，你可以选择性地向站点配置文件添加身份验证凭据。这允许
    DAST 像用户一样登录到网站，通常会暴露出更多需要扫描的 URL。
- en: 'After you’ve created the two profiles, the GUI will present a code snippet
    that you can copy and paste into your project’s `.gitlab-ci.yml` file. This is
    a slightly different workflow than the merge request-driven workflow you use to
    enable SAST or Secret Detection through the GUI, but the result is the same: you
    add a few lines of code to your CI/CD configuration file, instructing DAST to
    run in your pipeline.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了这两个配置文件后，GUI 会呈现一个代码片段，你可以将其复制并粘贴到项目的 `.gitlab-ci.yml` 文件中。这与通过 GUI 启用
    SAST 或秘密检测的合并请求驱动工作流稍有不同，但结果是一样的：你只需向 CI/CD 配置文件中添加几行代码，指示 DAST 在你的流水线中运行。
- en: Which URLs can you target with DAST?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 DAST 目标哪些 URL？
- en: Although you can create a site profile with the URL of any website or web API,
    we strongly recommend that you only target websites and API endpoints that you
    own and manage. This is especially true if you are using DAST’s **full scan**
    option, which conducts more aggressive scanning. Furthermore, we recommend that
    you run DAST only against your application as it runs in a review, staging, or
    pre-production environment. Running DAST against the production version of your
    application could destabilize it, degrade performance for real users, or even
    knock it out completely.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以使用任何网站或 Web API 的 URL 创建站点配置文件，但我们强烈建议你仅针对自己拥有和管理的网站以及 API 端点进行扫描。如果你使用的是
    DAST 的**全面扫描**选项，该选项会进行更具侵略性的扫描，尤其如此。此外，我们建议你仅在应用程序处于审查、暂存或预生产环境中时运行 DAST。将 DAST
    用于生产版本的应用程序可能会导致其不稳定，降低真实用户的性能，甚至可能完全使其崩溃。
- en: 'If you prefer to enable and configure DAST manually, you’ll need to add a `dast`
    stage to your pipeline *after* the `deploy` stage. You must also include the DAST
    template, set a global variable with the URL that you’d like DAST to scan, and
    set any additional global or job-scoped variables that you need to modify DAST’s
    behavior:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢手动启用和配置 DAST，你需要在管道中`deploy`阶段*之后*添加一个`dast`阶段。你还必须包括 DAST 模板，设置一个包含你希望
    DAST 扫描的 URL 的全局变量，并设置任何需要修改 DAST 行为的其他全局或作业范围的变量：
- en: '[PRE7]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You might have noticed that DAST is the first scanner we’ve run across that
    expects to run in its own dedicated stage. The reason for this becomes obvious
    once you remember that DAST scans executing code and not source code: it can’t
    execute your code until it has been built and deployed. Those tasks usually take
    place in the `build` and `deploy` stages, so DAST must occur in a stage that falls
    after those stages in the pipeline.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，DAST 是我们遇到的第一个需要在专用阶段运行的扫描器。之所以如此，一旦你记住 DAST 扫描的是执行中的代码而不是源代码，这个原因就变得显而易见：它不能在代码构建和部署之前执行你的代码。这些任务通常发生在`build`和`deploy`阶段，因此
    DAST 必须在这些阶段之后的一个阶段中进行。
- en: 'Because DAST can sometimes take a long time to work its way through all the
    pages of a website, and because you don’t always want to hold up your pipeline
    while DAST does its thing, GitLab also allows you to run DAST scans on demand
    or according to a schedule. The process of triggering an on-demand scan or creating
    a scanning schedule is quite straightforward: in the **Security & Compliance**
    option in the left navigation pane, select **On-demand scans** and let the GUI
    wizard guide you through the process.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DAST 有时需要很长时间才能遍历网站的所有页面，而且你通常不希望在 DAST 执行时阻塞管道，因此 GitLab 还允许你按需运行 DAST 扫描或根据计划运行。触发按需扫描或创建扫描计划的过程非常简单：在左侧导航窗格的**安全与合规**选项中，选择**按需扫描**，然后让图形界面向导引导你完成整个过程。
- en: As mentioned previously, DAST offers an unusually wide array of configurable
    options. There are far too many to describe here, but the options we’ve discussed
    so far are enough for you to get useful vulnerability findings in most cases.
    If you need to set timeout values for the spider process, disable particular vulnerability
    checks, set login credentials for the target website, or adjust DAST’s behavior
    in other ways, you can find all the information you need in the official GitLab
    documentation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，DAST 提供了种类繁多的可配置选项。这里无法一一列举，但到目前为止我们讨论的选项已经足够让你在大多数情况下获得有用的漏洞发现。如果你需要为蜘蛛过程设置超时值、禁用特定的漏洞检查、为目标网站设置登录凭证，或以其他方式调整
    DAST 的行为，你可以在官方 GitLab 文档中找到所有需要的信息。
- en: Viewing DAST’s findings
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看 DAST 的发现
- en: 'The results of a DAST scan show up in the **Vulnerability Report** area, just
    like the results for SAST and Secret Detection. Since we don’t have a full **Hats
    for Cats** app available to run DAST against, here are some sample results from
    running a DAST passive scan against [https://example.com](https://example.com).
    You can see that all of the results concern header fields, which is the most common
    type of finding resulting from passive scans:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: DAST 扫描的结果会显示在**漏洞报告**区域，就像 SAST 和秘密检测的结果一样。由于我们没有完整的**Hats for Cats**应用可供运行
    DAST，这里是运行 DAST 被动扫描 [https://example.com](https://example.com) 的一些示例结果。你可以看到，所有的结果都涉及标题字段，这是被动扫描最常见的发现类型：
- en: '![Figure 7.4 – DAST findings](img/B18073_07_4.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – DAST 发现](img/B18073_07_4.jpg)'
- en: Figure 7.4 – DAST findings
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – DAST 发现
- en: That concludes your introduction to DAST. Now, let’s change gears and investigate
    Dependency Scanning, a type of security scan that looks at code that you’ve imported
    into your project from some outside source.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你对 DAST 的介绍。现在，让我们转换一下话题，研究一下依赖扫描，这是一个安全扫描类型，它检查你从外部来源导入到项目中的代码。
- en: Using Dependency Scanning to find vulnerabilities in dependencies
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用依赖扫描来发现依赖中的漏洞
- en: Why write your own functions when someone else has already written, tested,
    and documented a library to perform exactly what you need? It’s often easy to
    find third-party Python modules, Ruby gems, Java JARs, or other open-source software
    packages that speed up the development of your project. Unfortunately, these third-party
    dependencies can contain security vulnerabilities, and if you include them in
    your project, you inherit those problems. This is where GitLab’s Dependency Scanning
    feature steps in – it ensures that any dependencies you use are free of known
    vulnerabilities.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要自己编写函数，而别人已经编写、测试并文档化了一个库，可以完美地完成你所需的功能呢？通常，找到第三方的 Python 模块、Ruby gem、Java
    JAR 或其他开源软件包是很容易的，它们能加速项目的开发。不幸的是，这些第三方依赖可能包含安全漏洞，如果你将它们引入到项目中，你也会继承这些问题。GitLab
    的依赖扫描功能就是在这个时候发挥作用——它确保你使用的任何依赖都是没有已知漏洞的。
- en: Understanding Dependency Scanning
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解依赖扫描
- en: Like SAST, Dependency Scanning supports many languages – including all of the
    major languages you’d expect – but not every language under the Sun. You can consult
    the GitLab documentation to see an up-to-date list of supported languages.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 像 SAST 一样，依赖扫描支持许多语言——包括你期待的所有主流语言——但并不是所有语言都支持。你可以查阅 GitLab 文档，查看支持的语言的最新列表。
- en: Dependency Scanning knows how to parse the configuration files used by the package
    managers of each supported language, and it uses this information to determine
    which dependencies your project relies on. For example, it might scan `Gemfile.lock`
    in a Ruby project, `requirements.txt` or `requirements.pip` in a Python project,
    or `pom.xml` in a Java project that uses the Maven build tool. As you can see
    from the fact that we mentioned two different Python configuration files, the
    scanner is smart enough to know that some languages use several different files
    to list their configurations and it can parse all the most commonly used files
    in each language. Just like SAST, Dependency Scanning can handle projects that
    contain several different computer languages. It will parse the dependency configuration
    files for any languages that it detects, and look for vulnerabilities in all of
    them.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖扫描知道如何解析每种支持语言的包管理器所使用的配置文件，并利用这些信息来确定项目依赖哪些库。例如，它可能会扫描 Ruby 项目的 `Gemfile.lock`、Python
    项目的 `requirements.txt` 或 `requirements.pip`，或者使用 Maven 构建工具的 Java 项目的 `pom.xml`
    文件。正如你从我们提到的两个不同的 Python 配置文件中看到的那样，扫描器足够智能，知道某些语言使用多个文件来列出它们的配置，它可以解析每种语言中最常用的文件。就像
    SAST 一样，依赖扫描能够处理包含多种不同计算机语言的项目。它会解析它检测到的任何语言的依赖配置文件，并在所有这些文件中寻找漏洞。
- en: 'For example, if your Hats for Cats website is built on an old version of the
    Django web framework, your project might contain a `requirements.txt` file with
    just one entry:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的网站 “Hats for Cats” 是建立在旧版本的 Django Web 框架上的，项目中可能会有一个 `requirements.txt`
    文件，其中只有一行内容：
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The scanner looks not just for the names and version numbers of dependencies
    that your project declares explicitly but also for the names and version numbers
    of any dependencies that those dependencies have. In other words, it looks recursively
    through the dependency tree to detect transitive dependencies, as well as direct
    dependencies. It reports on vulnerabilities found on *any* dependencies within
    the tree, which means that you might see vulnerabilities reported in dependencies
    that you didn’t even know your project used.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描器不仅会查找项目显式声明的依赖的名称和版本号，还会查找这些依赖的任何子依赖的名称和版本号。换句话说，它会递归地遍历依赖树，检测传递性依赖以及直接依赖。它会报告在依赖树中的*任何*依赖中发现的漏洞，这意味着你可能会看到一些你甚至不知道项目使用的依赖中存在的漏洞。
- en: Once Dependency Scanning knows the names and version numbers of each dependency
    in your project, it looks up each dependency name and version number in a database
    to see whetherthere are known vulnerabilities in that particular version of that
    particular library. It’s important to understand that Dependency Scanning does
    not do SAST-style scanning of the dependency code – that is, it does not analyze
    the code within the dependencies, trying to detect new vulnerabilities. Instead,
    it uses a much more straightforward strategy. It simply determines whether the
    database contains any information about vulnerabilities that have *already been
    discovered* in that version of that dependency. This may sound like an unsophisticated
    approach, but it turns out to be extremely useful and is quite good at revealing
    problems with commonly used libraries.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦依赖扫描知道了项目中每个依赖的名称和版本号，它会在数据库中查找每个依赖的名称和版本号，查看该版本的特定库是否存在已知漏洞。需要理解的是，依赖扫描并不会像SAST那样扫描依赖代码——也就是说，它不会分析依赖中的代码，试图发现新的漏洞。相反，它采用了一种更加直接的策略。它只是确定数据库中是否包含有关该版本依赖库中*已知漏洞*的信息。这听起来可能是一个不太复杂的方法，但事实证明它非常有用，并且在揭示常用库中存在的问题方面表现得相当出色。
- en: Dependency Scanning has a special feature that isn’t always available but can
    be a nice time-saver when it is. If the scanner detects a vulnerability in an
    old version of a library and knows that the vulnerability has been fixed in a
    later version of the same library, it will sometimes offer to create a merge request
    that rewrites your project’s dependency configuration file so that it uses the
    later, fixed version of the library. This only happens under some circumstances
    and with some languages but is worth taking advantage of when it’s offered.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖扫描有一个特殊功能，虽然并不总是可用，但在可用时可以节省不少时间。如果扫描器检测到库的旧版本中存在漏洞，并且知道该漏洞在同一库的后续版本中已被修复，它有时会提供创建一个合并请求的选项，重新编写项目的依赖配置文件，使其使用后续版本的已修复库。这只在某些情况下和某些语言中发生，但在提供此选项时，值得利用。
- en: Enabling and configuring Dependency Scanning
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和配置依赖扫描
- en: You have the same GUI or manual options for adding Dependency Scanning to your
    project’s pipelines as you do for SAST, Secret Detection, or DAST. To enable it
    through the GUI, click the `.gitlab-ci.yml` file, which enables the scanner. Merge
    the merge request, and you’re done.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像在SAST、Secret Detection或DAST中那样，通过图形界面或手动方式将依赖扫描添加到项目的流水线中。通过图形界面启用它，只需点击`.gitlab-ci.yml`文件，该文件启用扫描器。合并合并请求，操作完成。
- en: 'Enabling it manually is even simpler. Just make sure your pipeline has a `test`
    stage defined and add the Dependency Scanning template to `.gitlab-ci.yml`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 手动启用更为简单。只需确保您的流水线已定义`test`阶段，并将依赖扫描模板添加到`.gitlab-ci.yml`中：
- en: '[PRE9]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Like the other scanners, Dependency Scanning has several configurable options.
    Also, like the other scanners, these are controlled either by setting global variables
    in `.gitlab-ci.yml` or by overriding job definitions and setting job-scoped variables
    in that file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他扫描器一样，依赖扫描有多个可配置选项。同样，像其他扫描器一样，这些选项可以通过在`.gitlab-ci.yml`中设置全局变量，或通过重写作业定义并在该文件中设置作业范围的变量来控制。
- en: 'For example, the following code sets a job-scoped variable that tells Dependency
    Scanning’s Python analyzer to look for a dependency configuration file with a
    non-standard name instead of the traditional `requirements.txt` file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码设置了一个作业范围的变量，告诉依赖扫描的Python分析器查找一个非标准名称的依赖配置文件，而不是传统的`requirements.txt`文件：
- en: '[PRE10]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Viewing Dependency Scanning’s findings
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看依赖扫描结果
- en: 'The vulnerability report shows any potential security problems detected in
    your project’s dependencies. For example, here are five critical and high-severity
    vulnerabilities stemming from Hats for Cats’ dependency on an old version of the
    Django library, as specified in the sample `requirements.txt` file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞报告显示了在项目依赖中检测到的任何潜在安全问题。例如，以下是来自《Hats for Cats》项目中依赖于旧版本Django库的五个关键和高严重性的漏洞，正如示例中的`requirements.txt`文件所指定的那样：
- en: '![Figure 7.5 – Dependency Scanning findings](img/B18073_07_5.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 依赖扫描发现](img/B18073_07_5.jpg)'
- en: Figure 7.5 – Dependency Scanning findings
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 依赖扫描发现
- en: 'By now, you should have a firm grasp of what Dependency Scanning does and how
    to use it. Let’s move on and look at a Docker-focused security scanner: Container
    Scanning.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经牢牢掌握了依赖扫描的功能和使用方法。接下来，我们来看看一个以 Docker 为中心的安全扫描工具：容器扫描。
- en: Using Container Scanning to find vulnerabilities in Docker images
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器扫描查找 Docker 镜像中的漏洞
- en: 'Container Scanning does for Docker images what Dependency Scanning does for
    your project’s dependencies: it checks for known vulnerabilities in the particular
    versions of Linux distributions that your project uses as a base when it builds
    Docker images.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 容器扫描对 Docker 镜像的作用类似于依赖扫描对项目依赖的作用：它检查你的项目在构建 Docker 镜像时使用的特定版本的 Linux 发行版中已知的漏洞。
- en: Understanding Container Scanning
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解容器扫描
- en: If you package and deploy your application as a Docker image – or, technically,
    an Open Container Initiative-compliant image – you should use GitLab’s Container
    Scanning feature to find known vulnerabilities in the base Linux distribution
    that your image is built on top of.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将应用程序打包并部署为 Docker 镜像——或者更严格地说，是一个符合开放容器倡议（OCI）标准的镜像——你应该使用 GitLab 的容器扫描功能来查找镜像构建所基于的基础
    Linux 发行版中的已知漏洞。
- en: If you haven’t worked with Docker images before, this might sound mysterious,
    but it’s not complicated. Think of a Docker image as a little bit like a virtual
    machine. There’s a special file called `Dockerfile` that serves as a “recipe”
    for creating that virtual machine. This `Dockerfile` file specifies which Linux
    distribution to use as the virtual machine’s operating system, which additional
    software packages you should install on top of Linux to support your application,
    and ultimately what application you want to install on the virtual machine. This
    whole stack of the operating system and the dependencies and your application
    makes up a Docker image.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有使用过 Docker 镜像，这听起来可能有些神秘，但其实并不复杂。可以把 Docker 镜像想象成类似于虚拟机的东西。它有一个特殊的文件叫做`Dockerfile`，它作为创建该虚拟机的“配方”。这个`Dockerfile`文件指定了使用哪个
    Linux 发行版作为虚拟机的操作系统，应该在 Linux 上安装哪些额外的软件包来支持你的应用程序，以及最终要在虚拟机上安装的应用程序是什么。操作系统、依赖项和你的应用程序组成了整个
    Docker 镜像。
- en: Container Scanning looks for vulnerabilities both in the software packages that
    come installed by default in that base Linux operating system and in any additional
    packages that you specified in your `Dockerfile`. As you would expect, the older
    the Linux distribution, and the more dependencies you install on it, the more
    problems Container Scanning is likely to find.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 容器扫描会寻找漏洞，既包括在基础 Linux 操作系统中默认安装的软件包，也包括你在`Dockerfile`中指定的任何额外软件包。正如你所料，Linux
    发行版越旧，安装的依赖越多，容器扫描可能发现的问题就越多。
- en: Although Container Scanning doesn’t know how to find vulnerable packages in
    all versions of all Linux distributions, it does support the last two or three
    versions of the most commonly used distributions. Unless you use a truly exotic
    distribution to serve as the base of your application’s Docker image, you should
    be able to use Container Scanning. The GitLab documentation has a list of all
    supported distributions if you’d like to make sure your images are scannable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器扫描不能找到所有 Linux 发行版的所有版本中的漏洞包，但它支持最常用的发行版的最后两个或三个版本。除非你使用了一个非常特殊的发行版作为应用程序
    Docker 镜像的基础，否则应该能够使用容器扫描。如果你想确保你的镜像是可以扫描的，GitLab 文档中有一个支持的发行版列表。
- en: 'Container Scanning has an optional feature that is disabled by default: it
    can also look for vulnerabilities in “language packages,” which are libraries
    that are added by a language’s package manager. For example, you might use Ruby’s
    `bundler` utility to install the `Ruby on Rails` gem, or Python’s `pip` tool to
    install the `Flask` module. You might notice that this functionality covers the
    same ground as GitLab’s Dependency Scanning – and as a result, often produces
    duplicate findings. Because of this, many GitLab users rely on Dependency Scanning
    instead of enabling this feature in Container Scanning.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 容器扫描有一个默认禁用的可选功能：它还可以查找“语言包”中的漏洞，语言包是由语言的包管理器添加的库。例如，你可能使用 Ruby 的`bundler`工具安装`Ruby
    on Rails` gem，或者使用 Python 的`pip`工具安装`Flask`模块。你可能会注意到，这个功能与 GitLab 的依赖扫描功能覆盖了相同的领域——因此，通常会产生重复的结果。因为这个原因，许多
    GitLab 用户更倾向于使用依赖扫描，而不是启用容器扫描中的这个功能。
- en: Although Container Scanning can look for problems in any Docker image that it
    can access via the web, its default behavior is to scan any images it finds in
    your project’s **Container Registry**. The Container Registry is a feature provided
    for all GitLab projects and lets you store Docker images in a safe, access-controlled
    location instead of storing them on a site such as Docker Hub, which is open to
    everyone, or in an instance of a tool such as Artifactory. To use Container Scanning
    to inspect an image in the Container Registry, you’ll need your pipeline to build
    a Docker image and then push it to the registry. We’ll discuss this process in
    the next chapter on deployment strategies.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管容器扫描可以查找任何它能够通过网络访问的 Docker 镜像中的问题，但其默认行为是扫描在你项目的**容器注册表**中找到的任何镜像。容器注册表是
    GitLab 项目提供的一项功能，允许你将 Docker 镜像存储在一个安全的、受访问控制的位置，而不是存储在像 Docker Hub 这样的公开站点，或像
    Artifactory 这样的工具实例中。要使用容器扫描检查容器注册表中的镜像，你需要让你的管道构建一个 Docker 镜像并将其推送到注册表。我们将在下一章讨论有关部署策略的内容。
- en: Enabling and configuring Container Scanning
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和配置容器扫描
- en: 'You can enable Container Scanning by manually editing `.gitlab-ci.yml` or by
    using the GitLab GUI. To enable it manually, make sure your pipeline contains
    a `test` stage and include the Container Scanning template:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过手动编辑 `.gitlab-ci.yml` 或使用 GitLab 图形界面来启用容器扫描。若手动启用，确保你的管道包含一个 `test` 阶段，并添加容器扫描模板：
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To configure Container Scanning with the GUI, you can use the same technique
    as for the other scanners discussed so far: click the **Security & Compliance**
    option in the left navigation pane, select **Configuration**, and find the control
    for enabling Container Scanning. This will produce an MR that adds the preceding
    template to your CI/CD configuration file. Merge this MR, and you’re done.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用图形界面配置容器扫描，你可以使用与目前为止讨论的其他扫描器相同的技术：点击左侧导航栏中的**安全与合规**选项，选择**配置**，然后找到启用容器扫描的控件。这样会生成一个合并请求（MR），将前述模板添加到你的
    CI/CD 配置文件中。合并这个 MR 后，你就完成了。
- en: 'If you’re happy with having Container Scanning look for Docker images in your
    project’s Container Registry, these manual or GUI-based techniques for enabling
    the scanner are the only steps you need to perform. But if you need to change
    its default behavior, you can use two of the same techniques you’ve used to configure
    other scanners: set a global variable or override a job definition and set a job-scoped
    variable. Some of the configuration options available for this scanner include
    aiming the scanner at a Docker image stored in a location other than your project’s
    Container Registry, enabling language package scanning, or setting the minimum
    severity level that a vulnerability must have to be included in the Container
    Scanning’s findings.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望容器扫描检查项目的容器注册表中的 Docker 镜像，那么这些手动或图形界面启用扫描器的方法就是你需要执行的唯一步骤。但是，如果你需要更改其默认行为，你可以使用你已用于配置其他扫描器的两种方法：设置全局变量或覆盖作业定义并设置作业作用域变量。此扫描器的一些可配置选项包括将扫描器指向存储在你项目容器注册表以外位置的
    Docker 镜像、启用语言包扫描，或设置漏洞必须具备的最低严重性级别，才能包含在容器扫描的结果中。
- en: Viewing Container Scanning’s findings
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看容器扫描的结果
- en: It’s not unusual for Container Scanning to find dozens of vulnerabilities in
    a Docker image that you’ve built, especially if you’re using a less-than-recent
    Linux distribution as your base image. When you consider the huge number of packages
    that are installed by default on every Linux distribution, and the speed with
    which vulnerabilities are found in open-source packages, this is not surprising.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在你构建的 Docker 镜像中，容器扫描发现数十个漏洞并不罕见，尤其是当你使用的基础镜像是较旧的 Linux 发行版时。考虑到每个 Linux 发行版默认安装的大量软件包，以及在开源软件包中发现漏洞的速度，这并不令人惊讶。
- en: 'For example, Alpine Linux is known as one of the smallest major distributions,
    meaning that it has fewer packages installed than other popular distributions,
    such as Ubuntu or Debian. This makes it a popular distribution to use as a base
    for Docker images. If you build a Docker image based on Alpine Linux version 3.14.1,
    which is only 10 months old at the time of writing, Container Scanning finds no
    fewer than 30 vulnerabilities among its default packages. You can see a handful
    of the highest severity vulnerabilities found in a Docker image built on this
    distribution, as displayed in the **Vulnerability** **Report** area:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Alpine Linux 作为一个小巧的主要发行版而著名，这意味着它安装的包比其他流行发行版（如 Ubuntu 或 Debian）少。这使得它成为
    Docker 镜像的基础发行版之一。如果您基于 Alpine Linux 版本 3.14.1（在撰写本文时仅有 10 个月的历史）构建 Docker 镜像，容器扫描会发现其默认包中至少有
    30 个漏洞。您可以看到在基于该发行版构建的 Docker 镜像中发现的一些最高严重性漏洞，如**漏洞** **报告**区域所显示：
- en: '![Figure 7.6 – Container Scanning findings](img/B18073_07_6.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 容器扫描结果](img/B18073_07_6.jpg)'
- en: Figure 7.6 – Container Scanning findings
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 容器扫描结果
- en: 'Now that we’ve covered the basics of Container Scanning, let’s take a look
    at yet another security scanner: License Compliance.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了容器扫描的基础知识，让我们来看看另一个安全扫描工具：许可证合规性。
- en: Using License Compliance to manage licenses of dependencies
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用许可证合规性来管理依赖项的许可证
- en: It can be easy to lose track of what software licenses are used by your project’s
    various dependencies. It’s also easy to forget which licenses are compatible with
    your project’s overall license, and which licenses should be excluded for various
    reasons. This is where GitLab’s License Compliance feature can help out.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易忽视项目中各种依赖项所使用的软件许可证，也容易忘记哪些许可证与项目的总体许可证兼容，哪些许可证因各种原因应被排除在外。在这方面，GitLab 的许可证合规性功能可以提供帮助。
- en: Understanding License Compliance
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解许可证合规性
- en: Most open-source libraries are released under a software license. There are
    hundreds of licenses available – though only 20 or so are commonly used – and
    the legal details of each vary considerably. If you use a third-party library
    in your project, you must make sure that the library’s license and the license
    under which you intend to release your software are compatible with each other.
    If they are incompatible, you must replace that dependency with an alternative
    library that uses a friendlier license.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开源库都发布在某种软件许可证下。虽然有数百种许可证可供选择，但通常只有大约 20 种常用许可证，而且每种许可证的法律细节差异较大。如果在项目中使用了第三方库，必须确保该库的许可证与您打算发布软件的许可证兼容。如果它们不兼容，您必须将该依赖项替换为使用更友好许可证的替代库。
- en: 'What do we mean by “compatible” when talking about licenses? Most licenses
    are considered to be **permissive**, meaning that you can use software released
    under that license for almost any purpose. Two well-known examples of this type
    of license are the MIT license and the BSD license. You generally won’t face any
    compatibility problems if you stick to dependencies that use permissive licenses.
    Other licenses are **protective** rather than permissive, meaning that they restrict
    how you can use software that’s released under those licenses. Here are some examples
    of the restrictions imposed by protective licenses:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论许可证时，什么是“兼容”的意思？大多数许可证被认为是**宽松的**，这意味着您可以几乎出于任何目的使用该许可证下发布的软件。两种广为人知的宽松许可证例子是
    MIT 许可证和 BSD 许可证。如果您使用的是宽松许可证的依赖项，通常不会遇到兼容性问题。其他许可证则是**保护性的**，而非宽松的，这意味着它们限制了您如何使用根据这些许可证发布的软件。以下是保护性许可证所施加的一些限制示例：
- en: Some open-source licenses such as GPL or AGPL fall under a category informally
    called **copyleft**. Software released under these licenses can be used as dependencies
    in other projects, but only if those other projects are themselves released under
    the same copyleft license. For example, if your Hats for Cats app uses an open-source
    Python sorting library that is released under the GPL license, then *the entire
    Hats for Cats project must also use the GPL license*. It’s not hard to see how
    this would be a problem if you intended to sell your software rather than release
    it as open source.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些开源许可证，如 GPL 或 AGPL，属于一种非正式的类别，通常称为**反向版权**。根据这些许可证发布的软件可以作为依赖项在其他项目中使用，但前提是这些其他项目本身也必须使用相同的反向版权许可证。例如，如果您的《猫帽子》应用使用了一个基于
    GPL 许可证发布的开源 Python 排序库，那么*整个《猫帽子》项目也必须使用 GPL 许可证*。如果您打算销售软件而不是将其作为开源发布，这可能会成为一个问题。
- en: To use more controversial terms, copyleft licenses are sometimes called “viral”
    because they can be thought of as “infecting” parent projects. This disease metaphor
    is probably unfair, and many fine pieces of software have been released using
    copyleft licenses, but the fact remains that you need to be careful about using
    them.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一些更具争议性的术语，copyleft（版权左）许可证有时被称为“病毒性”许可证，因为它们可以被认为是“感染”父项目。这个疾病隐喻可能不公平，许多优秀的软件都是通过copyleft许可证发布的，但事实依然是，你需要小心使用这些许可证。
- en: Some licenses explicitly *disallow use by certain industries*, such as the military.
    Code released under a military exclusion license can’t be used as a dependency
    for missile guidance software, for example.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些许可证明确*禁止某些行业使用*，比如军事行业。例如，基于军事排除许可证发布的代码不能作为导弹制导软件的依赖项使用。
- en: A license could *exclude usage of the software by certain countries*. This isn’t
    commonly seen, but it is legal for a license to include restrictions of this type.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些许可证可能*排除某些国家/地区使用该软件*。这种情况并不常见，但许可证包含此类限制是合法的。
- en: As you can see, it’s important to understand what licenses your project’s dependencies
    use so that you’re aware of any restrictions imposed by those licenses and you
    steer well clear of any dependencies that are released under licenses that will
    restrict your ability to use or sell your software in the ways that you intend.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，理解你的项目依赖项使用的许可证非常重要，这样你就可以意识到这些许可证可能带来的任何限制，并且避免使用那些发布在限制你以预期方式使用或销售软件的许可证下的依赖项。
- en: 'GitLab’s License Compliance feature has three phases:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab的License Compliance功能分为三个阶段：
- en: The scanner looks through your project’s dependencies and generates a list of
    all licenses used.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描器会查看项目的依赖项，并生成所有使用的许可证的列表。
- en: The software development team – or your company’s legal department – creates
    **license policies** that explicitly allow or deny each license that’s found in
    your project’s dependencies. Alternatively, you can preemptively create license
    policies before any dependencies are added to the project if you already know
    which licenses are incompatible with your main project’s overall license.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发团队或公司法务部门会创建**许可证政策**，明确允许或拒绝项目依赖项中找到的每个许可证。或者，如果你已经知道哪些许可证与你的主项目的整体许可证不兼容，可以在添加任何依赖项之前预先创建许可证政策。
- en: If a developer introduces a new dependency on a branch, and that dependency
    uses a license that has been denied, the License Compliance feature blocks the
    merge request for that branch until the license is removed or the block is overridden.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果开发者在分支上引入了一个新的依赖项，而该依赖项使用了一个被拒绝的许可证，那么License Compliance功能会阻止该分支的合并请求，直到移除许可证或解除阻止。
- en: 'From this workflow, you can tell that creating license policies is an important
    part of using the License Compliance feature. To view, create, delete, or edit
    license policies, click **Security & Compliance** in the left navigation pane
    and then click **License compliance**. Here’s what that screen looks like when
    you’ve approved two licenses and denied two other licenses:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个工作流中，你可以看出，创建许可证政策是使用License Compliance功能的重要部分。要查看、创建、删除或编辑许可证政策，请点击左侧导航窗格中的**安全与合规性**，然后点击**许可证合规性**。以下是当你批准了两个许可证并拒绝了两个其他许可证时，该屏幕的显示效果：
- en: '![Figure 7.7 – License policies](img/B18073_07_7.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 许可证政策](img/B18073_07_7.jpg)'
- en: Figure 7.7 – License policies
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 许可证政策
- en: 'The workflow description mentions the power of License Compliance to block
    any merge request that introduces a dependency that uses a license that has been
    explicitly denied with a license policy. To block an MR, License Compliance deactivates
    or hides the **Merge** button so that it can’t be clicked. Here’s a blocked MR,
    which displays a list of licenses used by a new dependency (and its dependencies)
    that have been introduced on the MR’s branch:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流描述提到，License Compliance（许可证合规性）具有阻止任何引入依赖项且使用被许可证政策明确拒绝的许可证的合并请求（MR）的能力。为了阻止MR，License
    Compliance 会停用或隐藏**合并**按钮，使其无法点击。以下是一个被阻止的MR，显示了在MR分支上引入的新依赖项（及其依赖项）所使用的许可证列表：
- en: '![Figure 7.8 – Merge request blocked by a denied license](img/B18073_07_8.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 被拒绝许可证阻止的合并请求](img/B18073_07_8.jpg)'
- en: Figure 7.8 – Merge request blocked by a denied license
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 被拒绝许可证阻止的合并请求
- en: Using GitLab rulesets to unblock an MR
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用GitLab规则集解除MR阻止
- en: GitLab has several other triggers that cause an MR to become blocked until some
    sort of corrective action is taken, in addition to the case you’ve just seen.
    To take just one example, when a developer writes new product code without writing
    automated tests to cover that code, GitLab can be configured to notice that the
    “code coverage” figure on the developer’s branch has dropped, and the MR for that
    branch will be blocked until the developer adds automated tests that test their
    new code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您刚刚看到的情况，GitLab 还有几个其他触发器，导致合并请求（MR）被阻止，直到采取某种纠正措施为止。举一个例子，当开发者编写新产品代码时，如果没有为该代码编写自动化测试，GitLab
    可以配置为注意到开发者分支上的“代码覆盖率”下降，并且该分支的 MR 会被阻止，直到开发者添加自动化测试来测试他们的新代码。
- en: Any MR that is automatically blocked can be unblocked with a GitLab feature
    called **approval rules**. These rules allow specific people to unblock an MR
    simply by **approving** that MR. Each of these approval rules has a name; the
    rule that lets you override blocks caused by denied licenses is called **License-Check**.
    We don’t have room to go into configuring approval rules here, but they are quite
    straightforward to set up and use. The GitLab documentation can give you more
    details.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 任何被自动阻止的 MR 都可以通过 GitLab 的 **审批规则** 功能解锁。这些规则允许特定人员仅通过**批准**该 MR 来解锁。每个审批规则都有一个名称；允许您覆盖由被拒绝许可证引起的阻止的规则称为
    **License-Check**。我们没有足够的篇幅在这里详细介绍审批规则，但它们的设置和使用非常简单。GitLab 文档可以为您提供更多细节。
- en: Enabling and configuring License Compliance
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和配置许可证合规性
- en: 'You can’t use the GUI to enable License Compliance, but the manual technique
    of enabling it should seem very familiar by now. Just ensure that you have a `test`
    stage defined in your pipeline and include the License Compliance template:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您无法使用 GUI 启用许可证合规性，但启用它的手动方法现在应该很熟悉了。只需确保在您的流水线中定义了 `test` 阶段，并包含许可证合规性模板：
- en: '[PRE12]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Configuring License Compliance can be accomplished in the same way you configure
    the other scanners: edit `.gitlab-ci.yml` to either set a global variable or override
    a job definition and set a job-scoped variable.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 配置许可证合规性可以像配置其他扫描工具一样完成：编辑 `.gitlab-ci.yml` 文件，设置全局变量或覆盖作业定义并设置作业范围的变量。
- en: As mentioned previously, an important part of configuring License Compliance
    is creating the license policies that stipulate which open-source licenses are
    allowed or denied for your project’s dependencies. To create or edit these policies,
    navigate to the **Security & Compliance** option in the left navigation pane,
    click **License compliance**, and click the **Policies** tab. From there, you
    can add policies to either allow or deny any of the hundreds of licenses that
    GitLab recognizes. You can create policies for licenses, regardless of whether
    your project contains dependencies with those licenses. It might make sense for
    your legal team to create policies for any denied licenses before the development
    of your project begins so that MRs are blocked immediately if they introduce dependencies
    that use denied licenses.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，配置许可证合规性的重要部分是创建许可证政策，规定哪些开源许可证可以或不可以用于项目的依赖项。要创建或编辑这些政策，请导航到左侧导航窗格中的**安全与合规性**选项，点击**许可证合规性**，然后点击**政策**标签。在那里，您可以添加政策来允许或拒绝GitLab识别的数百种许可证中的任何一种。无论项目是否包含这些许可证的依赖项，您都可以为许可证创建政策。在项目开发开始之前，您的法务团队可能需要为任何被拒绝的许可证创建政策，这样如果合并请求引入了使用被拒绝许可证的依赖项，就会立即被阻止。
- en: Prerequisite for editing license policies
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑许可证政策的先决条件
- en: This is not well documented by GitLab, but to add, remove, or edit license policies,
    you must first run at least one instance of a pipeline that contains the License
    Scanning job. This “unlocks” the allowed and denied license lists and lets you
    edit policies.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 并没有很好地记录这部分内容，但要添加、删除或编辑许可证政策，您必须首先运行至少一个包含许可证扫描作业的流水线实例。这样做会“解锁”允许和拒绝的许可证列表，并允许您编辑政策。
- en: Viewing License Compliance’s findings
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看许可证合规性的发现
- en: Unlike the other scanners we’ve looked at so far, License Compliance does not
    display its findings in the **Vulnerability Report** window. To see which licenses
    it has identified among the *dependencies on your project’s default branch*, click
    the **Security & Compliance** option in the left navigation pane, and then click
    **License compliance**.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止查看的其他扫描工具不同，许可证合规性不会在 **漏洞报告** 窗口中显示其发现的内容。要查看它在*项目默认分支的依赖项*中识别出的许可证，点击左侧导航窗格中的**安全与合规性**选项，然后点击**许可证合规性**。
- en: To see which licenses are used by *dependencies that are on a feature or bugfix
    branch*, navigate to the pipeline details page for a pipeline that ran against
    that branch and click the **Licenses** tab. This view also shows you which licenses
    are allowed, which are denied, and which are not yet categorized.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看*依赖项在功能或 bug 修复分支上的许可证*，请导航到该分支上运行的流水线详情页并点击 **Licenses** 标签。此视图还会显示哪些许可证是允许的，哪些是被拒绝的，哪些尚未分类。
- en: 'You’re now equipped to put License Compliance to use in your projects. It’s
    time to tackle the final security scanner provided by GitLab: Infrastructure as
    Code Scanning.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经具备了将许可证合规性应用于项目的能力。是时候处理 GitLab 提供的最后一个安全扫描工具：基础设施即代码扫描（IaC）。
- en: Using IaC Scanning to find problems in infrastructure configuration files
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IaC 扫描来查找基础设施配置文件中的问题
- en: In the last decade or so, the phrase “treat hardware as cattle, not pets” has
    been used to describe a new approach to managing computers. By thinking of hardware
    as a fungible commodity rather than a collection of special snowflakes, development
    and operations teams are liberated from carefully configuring and maintaining
    the computers they use to host deployment environments, run databases, serve web
    applications, or do any of the countless other tasks involved with developing
    and deploying software. By using so-called IaC tools such as Ansible or Terraform
    to configure and maintain the configuration state on hardware (whether real or
    virtual, local or cloud-based), system administrators can adjust server capacity,
    create new environments, or experiment with hardware configurations without worrying
    about how difficult it will be to revert their systems if something goes wrong
    or an experiment fails. To get back to normal, they can simply wipe out the old
    machines and reconfigure them automatically with IaC tools, using settings that
    have already been proven to work. The time savings and freedom this grants development
    teams are enormous.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去十年左右，“把硬件当作牲畜，而非宠物”这句话被用来描述一种新的计算机管理方法。通过将硬件视为一种可替代的商品，而不是一堆特殊的“雪花”计算机，开发和运维团队可以摆脱仔细配置和维护用于托管部署环境、运行数据库、提供
    Web 应用或进行软件开发与部署中涉及的其他无数任务的计算机的困扰。通过使用像 Ansible 或 Terraform 这样的 IaC 工具来配置和维护硬件（无论是实际的还是虚拟的，本地的还是基于云的）上的配置状态，系统管理员可以调整服务器容量、创建新环境或实验硬件配置，而无需担心如果出现问题或实验失败，恢复系统的难度。要恢复正常，他们只需抹掉旧机器，并使用已经证明有效的设置通过
    IaC 工具自动重新配置这些机器。这样为开发团队节省的时间和获得的自由是巨大的。
- en: But with this new freedom comes a new kind of vulnerability. It’s easy to create
    configuration files for IaC tools that introduce security vulnerabilities to machines
    that are configured with those files. GitLab’s IaC scanner looks for exactly that
    sort of vulnerability. Once they are identified, a team can remediate them in
    the configuration file and then easily reconfigure their machines using the newer,
    safer setup.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种新自由带来了新的漏洞类型。很容易创建会导致安全漏洞的 IaC 工具配置文件，这些漏洞会影响使用这些文件配置的机器。GitLab 的 IaC 扫描工具正是用来发现这种类型的漏洞。一旦识别出这些漏洞，团队可以在配置文件中修复它们，然后轻松地重新配置机器，使用更新且更安全的设置。
- en: Understanding IaC Scanning
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 IaC 扫描
- en: GitLab’s IaC Scanning is a specialized form of SAST. It looks through a project’s
    repository to see whether it can find any configuration files from the supported
    IaC tools (the GitLab documentation can give you an up-to-date list of which IaC
    tools this scanner supports). It then identifies any vulnerabilities or poor programming
    practices in those configuration files.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 的 IaC 扫描是一种专门的 SAST 形式。它会浏览项目的仓库，查看是否能找到任何来自支持的 IaC 工具的配置文件（GitLab 文档可以为你提供这个扫描工具支持的
    IaC 工具的最新列表）。然后，它会识别这些配置文件中的漏洞或不良编程实践。
- en: 'Here’s a trivial Terraform configuration file that creates an S3 bucket:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个简单的 Terraform 配置文件，用于创建一个 S3 存储桶：
- en: '[PRE13]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This code looks simple enough, but it introduces several security vulnerabilities
    and fails to follow some best practices for Terraform configuration files, as
    you’ll see in an IaC scanning report later in this chapter.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来足够简单，但它引入了几个安全漏洞，并未遵循 Terraform 配置文件的一些最佳实践，正如你将在本章后面的 IaC 扫描报告中看到的那样。
- en: Enabling and configuring IaC scanning
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用和配置 IaC 扫描
- en: 'As with many of the other scanners, you can enable IaC Scanning either with
    the GUI or by manually editing `.gitlab-ci.yml`. To enable it through the GitLab
    GUI, you can use the same technique you used to enable the other scanners: under
    the **Security & Compliance** option in the left navigation pane, click **Configuration**,
    tell the GUI to create a merge request, and merge the merge request.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable IaC Scanning manually, add a `test` stage to your project’s pipeline
    if it doesn’t already have one, and include the scanner’s template:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: IaC Scanning doesn’t currently offer any configuration options but may do so
    in the future.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Viewing IaC Scanning’s findings
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Terraform configuration for creating an S3 bucket that was presented previously
    contains quite a few problems in just a few lines of code. There are some security
    vulnerabilities and some failures to follow best practices around creating S3
    resources. The findings shown in the Vulnerability Report are invaluable in helping
    you understand where you need to tighten up your Terraform code to eliminate these
    problems:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – IaC Scanning findings](img/B18073_07_9.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – IaC Scanning findings
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: By looking at the **Tool** column of the findings in the vulnerability report,
    you’ll see that the IaC Scanning findings are all listed as coming from SAST instead
    of the IaC scanner. That’s because the IaC scanner is classified within GitLab
    as belonging to the SAST group of tools. To see only IaC findings in the vulnerability
    report, you’ll need to pick **SAST** in the **Tool** dropdown – and even then,
    you’ll still see findings from the SAST tool and any third-party scanners you’ve
    integrated into the SAST group of tools.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes our survey of GitLab’s seven security scanners. Let’s move on
    to discuss two features that GitLab offers to make its security scanners easier
    to use and more powerful: reports and vulnerability management.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the different types of security reports
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All GitLab security scanners display their results in three separate reports.
    Because each report shows results from all of the scanners, there’s no need to
    bounce around the GitLab GUI, collecting information from all the different scanners.
    However, each of the three report locations presents a slightly different spin
    on the scanners’ findings. It’s important to understand how these three reports
    differ, so let’s look at each one:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The `main` or `master`). If you want to know how secure your stable code base
    is, look at the vulnerability report. It won’t tell you anything about the state
    of security on any feature or bugfix branches – only the default branch.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **pipeline details page** for each pipeline that runs tells you about security
    problems that exist on whatever branch that pipeline ran on. So, if a pipeline
    ran against the default branch, its pipeline details page will contain the same
    information as the vulnerability report. But the pipeline details page for pipelines
    that run against feature or bugfix branches will alert you to whatever vulnerabilities
    exist on those branches, regardless of whether they also exist on the default
    branch. This page will reveal a tab called **Licenses** if License Compliance
    is enabled and has detected dependencies with licenses, and a tab called **Security**
    if it has findings from any of the other scanners to display. The types of information
    displayed on the pipeline details page are identical to what is displayed in the
    vulnerability report, albeit formatted slightly differently.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every **merge request** displays scanner results from the most recent pipeline
    that ran against the MR’s source branch. However, the reports found in MRs are
    different from the vulnerability report and the pipeline details report in an
    important way: an MR report only displays the *differences* between vulnerabilities
    found by the last pipeline that ran on the MR’s source branch and vulnerabilities
    found on the MR’s target branch. In other words, it shows a delta view rather
    than a full list of all vulnerabilities on its branch.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s consider an example to illustrate the difference between these three
    reports:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that the `main` branch for Hats for Cats has one SAST vulnerability
    and one problem spotted by Secret Detection.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A developer makes a branch off of `main` called `make-hats-sortable`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Following the best practices of GitLab Flow, the developer creates an MR with
    `make-hats-sortable` as the source branch and `main` as the target branch.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The developer commits code to the `make-hats-sortable` branch. Let’s say that
    the commit fixes the SAST vulnerability but introduces a new DAST vulnerability.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s what each of the three reports will show at this point:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: The `main` branch.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `make-hats-sortable` branch (that is, the merge request’s source branch)
    shows only the vulnerabilities found by Secret Detection and DAST since the SAST
    vulnerability has been fixed on that branch.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `make-hats-sortable` and `main` branches.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That concludes our discussion of the different types of GitLab security reports.
    After you read these reports and understand where your security vulnerabilities
    lie, how do you track your progress in remediating those vulnerabilities? That’s
    the topic of the next section.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Managing security vulnerabilities
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever any scanner except License Compliance finds a vulnerability, it grants
    that vulnerability the **Needs Triage** status. This status shows up in the vulnerability’s
    entry in the vulnerability report and the pipeline details page report.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'You should decide what you intend to do about each vulnerability that has that
    status and change its status accordingly. Here are the possible status values:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**Dismissed** means that you do not intend to remediate this vulnerability.
    Maybe you’ve determined that it’s a false positive, maybe you’ve decided it’s
    a real problem but isn’t worth fixing, or maybe you’ve realized that it doesn’t
    apply to your product or your users.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confirmed** means that it’s a real problem, and you do intend to fix it.
    After setting a finding to this status, you would normally create an issue to
    track your progress as your team works to remediate this vulnerability. GitLab
    offers a few shortcuts in the report GUIs to do this, and even prepopulates the
    issue’s title and description with information from the finding to make it as
    easy as possible to fix.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resolved** means that you have fixed the problem, so it no longer exists
    in your project. This status has to be set manually. *GitLab will not automatically
    resolve vulnerabilities*. This is because it does not want to accidentally resolve
    problems that are still present, thereby giving you a false sense of security.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitLab’s vulnerability management feature just boils down to setting the status
    of a vulnerability and then optionally using a GitLab issue to track progress
    on fixing that vulnerability. A typical vulnerability management workflow might
    look like this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: A scanner reports a vulnerability, giving it the **Needs** **Triage** status.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The development team triages the vulnerability and decides not to fix it, in
    which case you set its status to **Dismissed** and stop the workflow.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alternatively, the team triages the vulnerability and decides that it does need
    to be fixed, in which case you can set its status to **Confirmed**.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, you can create an issue that contains information about the vulnerability
    and possibly instructions on how to fix it. This issue is discussed, added to
    a sprint, and assigned to a developer just like any other issue.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The developer assigned to the issue creates a branch, creates a merge request
    for that branch, and fixes the issue on that branch.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The “delta” security report for the merge request shows that the issue exists
    on the default branch but no longer exists on the developer’s branch.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your team merges the merge request. The vulnerability is now remediated in the
    default branch.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You close the issue.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the vulnerability report, you must set the vulnerability’s status to **Resolved**.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This process may feel cumbersome when you see it laid out like this, but most
    people quickly get used to the flow and come to appreciate the visibility it gives
    them into the state of security in their projects.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you know how to track your team’s efforts at fixing security vulnerabilities
    in your code. There’s one final topic to tackle in this chapter: using security
    scanners other than the ones that are provided by GitLab.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Integrating outside security scanners
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many teams are committed to using one or more security scanners that are not
    part of GitLab’s security offering. Never fear – it’s usually possible to integrate
    outside scanners into your GitLab CI/CD pipelines.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Integration has two parts. First, you need to tell your pipeline to trigger
    the outside scanner. This is easy, so long as your scanner comes packaged in a
    Docker image and can be run from the command line:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Create a new pipeline job in the `test` stage (unless there’s a reason to run
    it elsewhere).
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `images` keyword in the job definition to specify the location of the
    Docker image that contains the scanner you’d like to add to your pipeline.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `script` section of the job definition, trigger the scanner using whatever
    CLI command you use when you run it manually. You might need to pass some options
    to the CLI command to control where it generates its results file, and what format
    it uses for that file.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `allow_failure: true` to your job definition so that the pipeline will
    continue to run even if the outside scanner finds vulnerabilities.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second part of integrating an outside scanner is to tell GitLab how to include
    the scanner’s results in the three standard GitLab security reports that we’ve
    discussed in this chapter. GitLab can only incorporate these results if they are
    written to a JSON file that conforms to specific JSON schemas, where each scanner
    type (SAST, DAST, and so on) has a separate schema. The documentation for each
    scanner type provides more information about these schemas.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Integrating third-party scanners that generate non-standard results files
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: If your third-party scanner can’t generate results files that validate against
    the appropriate schema, you’ll need to write a short script to parse the results
    and create a new results file that does conform to the schema. You’ll need to
    trigger this script somewhere in your pipeline after the scanner runs.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'In the job definition you create for the third-party scanner, you must declare
    the scanner’s results file to be an artifact, specifically an artifact that contains
    the results for a certain type of security report. For example, if you are integrating
    an additional SAST scanner that creates a results file called `my_scanner/results.json`,
    you would need to include this code in the job definition that runs that scanner:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This high-level description may be all you need to integrate third-party scanners,
    but if you need more detailed configuration instructions – including guidance
    on results schemas, best practices for what to name your pipeline job and results
    files, and more – the official GitLab documentation has a very thorough page on
    exactly this topic.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is one of the biggest and most complicated topics covered in this book,
    so congratulations on making it through! Let’s take stock of what we learned in
    this chapter.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: First, we covered some common principles that underly all of GitLab’s security
    scanners. We discussed the fact that all of the scanners are open-source tools
    developed outside of GitLab, and why that’s a good thing. We saw that some scanners
    use different analyzers to support different computer languages, though all scanners
    support the most commonly used languages, and some scanners are completely language-agnostic.
    We learned about the implications of packaging the scanners as Docker images.
    We saw that scanners don’t stop CI/CD pipelines when they find vulnerabilities,
    and we learned that it’s usually possible to integrate outside scanners into your
    pipelines if the GitLab-provided scanners aren’t sufficient for your needs.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we marched through the list of GitLab security scanners, learning what
    kinds of problems each one looks for, how to enable them with the GUI or manually,
    how to configure their behavior, and how to view their findings. We saw the following:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: SAST looks for vulnerabilities in source code
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret Detection looks for sensitive information that should not be stored in
    Git repositories
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DAST finds vulnerabilities in running web apps or Web APIs
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Scanning spots known vulnerabilities in your project’s third-party
    libraries
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container Scanning finds known problems with Linux distributions that form the
    base of your Docker images
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: License Compliance identifies dependencies with licenses that are incompatible
    with your overall project license
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IaC Scanning looks for infrastructure configuration files that could introduce
    vulnerabilities into computers that you manage
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we investigated three topics adjacent to the scanners themselves:
    the differences between the three different security reports provided by GitLab,
    managing security vulnerabilities that are identified by the scanners, and integrating
    outside scanners into your pipeline for projects that need even more protection.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, security concerns have become such a large and important part
    of developing software. But as we’ve seen throughout this chapter, GitLab’s suite
    of tools for detecting and fixing security vulnerabilities is one of its most
    powerful and valuable features. We can breathe a little easier knowing that many
    potential problems can now be identified early in the development process when
    there’s still plenty of time to fix them before they result in embarrassing, expensive,
    or reputation-damaging security breaches in production.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: At this point, your code has been written, verified, and secured. The next step
    in the software development life cycle is to package and deploy it. We’ll tackle
    those tasks in the next chapter.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
