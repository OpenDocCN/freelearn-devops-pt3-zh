- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Services in Linux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’re going to explain services (programs running in the background
    as daemons) in more depth. We’re going to explain `init` scripts and `systemd`
    units. We are also going to cover Alpine Linux `rc` commands that manage services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux services in detail
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few words about Upstart, an alternative
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need a Linux system at hand where you can execute
    privileged commands, either using `sudo` or jumping straight to the root account
    (although we particularly recommend the first one). You’ll also need a Linux text
    editor of your choice that will produce pure text files. If you are going to edit
    on a Windows system, use a text editor that enables you to save Unix files. We
    recommend editing in the command line with one of your favorite command-line text
    editors: `vim`, `emacs`, `joe`, `nano`, or whatever suits you.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Linux services in detail
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unless you are running some kind of low-level embedded device on your desktop—and
    we strongly doubt it—your operating system manages a multitude of tasks to create
    a comfortable and productive environment for you. Be it Mac OS X, Linux, Windows,
    or FreeBSD, they all run a multitude of background programs that together provide
    a useful system. The same goes for server flavors of those operating systems.
    A background program or background process (in Unix and Linux called, fluffily,
    a daemon) means a program that is not attached to any input (keyboard, mouse,
    etc.) or output (monitor, terminal, etc.). This way, they can start working even
    when no one is logged in to the system and keep working when the user logs out.
    They can also run under the privileges of a user who can never log in to the system,
    making their execution much safer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The number of services running on your Linux system will, in large part, depend
    on the distribution and, in even larger part, on the system’s purpose.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The history of Linux service management
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can probably imagine, the task of managing the system services—the programs
    required to run so that your computer is usable to you—is not a trivial one. The
    software that runs them must be stable and robust. This, and the fact that the
    system is expected to start rarely, especially on servers, made the Linux-adopted
    solution survive for decades. The increasing need to start services in parallel
    (through the emergence and widespread use of many threaded CPUs) and more intelligently
    gave way to several implementations of the new `init` system, which we will cover
    next.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: systemd
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`systemd` is a service manager for Linux that is able to manage services that
    start with the operating system. It replaces traditional `init` scripts. It is
    responsible for starting and stopping system services, managing system state,
    and logging system events. It has become the default `init` system for many popular
    Linux distributions, including CentOS, Fedora Linux, **Red Hat Enterprise Linux**
    (**RHEL**), and Ubuntu Linux.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`是一个用于Linux的服务管理器，能够管理与操作系统一起启动的服务。它取代了传统的`init`脚本。它负责启动和停止系统服务，管理系统状态，以及记录系统事件。它已经成为许多流行Linux发行版的默认`init`系统，包括CentOS、Fedora
    Linux、**红帽企业Linux**（**RHEL**）和Ubuntu Linux。'
- en: This service manager is responsible for controlling the initialization of the
    system itself (services required for the Linux OS), starting and stopping system
    services, and managing system resources. It provides another way of managing services
    and other system components, and it allows system administrators to configure
    and customize the behavior of their systems in a more standardized way than with
    `init`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务管理器负责控制系统本身的初始化（Linux操作系统所需的服务）、启动和停止系统服务，以及管理系统资源。它提供了另一种管理服务和其他系统组件的方式，并且允许系统管理员以比`init`更标准化的方式配置和自定义系统行为。
- en: One of the key features of `systemd` is its ability to start services in parallel,
    which can significantly reduce the boot time of a system. It also includes a number
    of tools for managing and monitoring system services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`的一个关键特性是能够并行启动服务，这可以显著减少系统的启动时间。它还包括一些用于管理和监控系统服务的工具。'
- en: Another thing `systemd` is praised for is the uniformity of service configurations
    it has finally brought to the Linux world. In every Linux distribution, the `systemd`
    configuration files are delivered to the same path; they look the same. There
    are, however, still some differences depending on the path binaries are being
    installed to. `systemd` is also better at knowing whether a process is running,
    making it more difficult to end up in a situation where we can’t start a process
    because of stale files.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`systemd`受到赞扬的另一点是它最终为Linux世界带来的服务配置统一性。在每个Linux发行版中，`systemd`配置文件都被送到相同的路径，并且看起来相同。然而，根据二进制文件的安装路径，仍然存在一些差异。`systemd`还更擅长判断进程是否正在运行，这使得我们更不容易遇到因为过时的文件无法启动进程的情况。
- en: 'One of the major advantages of `systemd` is its awareness of dependencies.
    The service (running program under `systemd` control) configuration contains information
    about all the other services it depends on and can also point to services that
    depend on it. What’s more, the service can inform `systemd` about which targets
    it requires to run: if your service needs the network to be up and running, you
    can put this information into the configuration, and `systemd` will ensure your
    daemon will be brought up only after the network is properly configured.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`的一个主要优势是它对依赖关系的意识。服务（在`systemd`控制下的运行程序）配置包含了关于它依赖的所有其他服务的信息，还可以指向依赖于它的服务。而且，服务可以向`systemd`告知它需要运行的目标：如果您的服务需要网络运行，您可以将此信息写入配置中，`systemd`会确保只有在网络正确配置后才会启动您的守护进程。'
- en: 'The following is a list of some of the tools and utilities that are provided
    as part of `systemd`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是作为`systemd`一部分提供的一些工具和实用程序的列表：
- en: '`systemd`: This is the main system and service manager. It is the main program
    that controls the initialization and management of services and other system components.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd`：这是主要的系统和服务管理器。它是控制服务和其他系统组件初始化和管理的主要程序。'
- en: '`systemctl`: This is the command-line utility for managing system services
    and other system components. It can be used to start, stop, restart, enable, and
    disable services, as well as to view the status of services and other system components.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl`：这是一个命令行工具，用于管理系统服务和其他系统组件。它可以用于启动、停止、重启、启用和禁用服务，还可以查看服务和其他系统组件的状态。'
- en: '`journalctl`: This is used for viewing and manipulating the system log, which
    is managed by `systemd`. It can be used to view log messages, filter log messages
    based on various criteria, and export log data to a file.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`journalctl`：用于查看和操作系统日志，日志由`systemd`管理。它可以用来查看日志消息，根据各种标准过滤日志消息，并将日志数据导出到文件。'
- en: '`coredumpctl`: This is a utility, as the name suggests, that helps retrieve
    core dumps from `systemd`’s journal.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coredumpctl`：这是一个实用工具，顾名思义，它有助于从`systemd`的日志中检索核心转储。'
- en: '`systemd-analyze`: This can be used for analyzing the boot performance of a
    system. It measures the time it takes for a system to boot, as well as the time
    it takes to identify potential bottlenecks and performance issues.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-analyze`：这个工具可以用来分析系统的启动性能。它衡量系统启动所需的时间，以及识别潜在的瓶颈和性能问题的时间。'
- en: '`systemd-cgls`: This is a command-line utility for viewing the control group
    hierarchy on a system. `systemd` to manage system resources and to isolate processes
    from one another.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-cgls`：这是一个用于查看系统上控制组层级的命令行工具。`systemd` 用于管理系统资源并将进程相互隔离。'
- en: '`systemd-delta`: This is a command-line utility for analyzing the differences
    between the default configuration files provided by `systemd` and any local modifications
    made to these files.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-delta`：这是一个用于分析 `systemd` 提供的默认配置文件与对这些文件所做的本地修改之间差异的命令行工具。'
- en: '`systemd-detect-virt`: This is a command-line utility for detecting the virtualization
    environment in which a system is running. It can be used to determine whether
    a system is running in a **virtual machine** (**VM**), a container, or on bare
    metal.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-detect-virt`：这是一个用于检测系统运行的虚拟化环境的命令行工具。它可以用来判断系统是运行在**虚拟机**（**VM**）、容器中，还是裸机上。'
- en: '`systemd-inhibit`: This is a command-line utility for preventing certain system
    actions, such as suspending or shutting down the system, from being performed.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-inhibit`：这是一个命令行工具，用于防止执行某些系统操作，例如暂停或关闭系统。'
- en: '`systemd-nspawn`: This is a command-line utility for running processes in lightweight
    containers. It can be used to create and manage containers, as well as to execute
    processes within containers.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-nspawn`：这是一个用于在轻量级容器中运行进程的命令行工具。它可以用来创建和管理容器，以及在容器内执行进程。'
- en: This is just a list of more common tools and utilities that are provided as
    part of `systemd`. There are many more, but we will not cover them here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 `systemd` 提供的一些常见工具和实用程序的列表。还有很多其他工具，但我们在这里不再讨论它们。
- en: Targets
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: In `systemd`, a **target** is a specific state that the system can be in, and
    it is represented by a symbolic name. Targets are used to define the high-level
    behavior of the system, and they are typically used to group together a set of
    related services and other system components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `systemd` 中，**目标** 是系统可以处于的特定状态，并通过一个符号名称表示。目标用于定义系统的高级行为，通常用于将一组相关的服务和其他系统组件组合在一起。
- en: For example, `multi-user.target` is a target that represents a system that is
    ready to provide multi-user access, with networking and other services enabled;
    `graphical.target` is a target that represents a system that is ready to display
    a graphical login screen, with a graphical desktop environment and related services
    enabled.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`multi-user.target` 是一个表示已准备好提供多用户访问的系统，启用了网络和其他服务；`graphical.target` 是一个表示已准备好显示图形登录界面的系统，启用了图形桌面环境和相关服务。
- en: Targets are typically defined in unit files, which are configuration files that
    describe the properties and behavior of system components. When a target is activated,
    `systemd` will start all of the services and other system components that are
    associated with that target.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目标通常在单元文件中定义，这些文件是描述系统组件属性和行为的配置文件。当目标被激活时，`systemd` 将启动所有与该目标相关的服务和其他系统组件。
- en: '`systemd` includes a number of predefined targets that cover a wide range of
    common system states, and administrators can also define custom targets to suit
    the specific needs of their systems. Targets can be activated using the `systemctl`
    command, or by modifying the default target that is set when the system boots.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd` 包括许多预定义的目标，涵盖了广泛的常见系统状态，管理员还可以定义自定义目标以满足其系统的特定需求。目标可以通过 `systemctl`
    命令激活，或者通过修改系统启动时设置的默认目标来激活。'
- en: 'Here are some examples of predefined `systemd` targets:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些预定义的 `systemd` 目标的示例：
- en: '`poweroff.target`: Represents a system that is shutting down or powered off'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poweroff.target`：表示一个正在关机或已关闭的系统。'
- en: '`rescue.target`: Represents a system that is running in rescue mode, with minimal
    services enabled'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rescue.target`：表示一个处于救援模式的系统，启用了最小化的服务。'
- en: '`multi-user.target`: Represents a system that is ready to provide multi-user
    access, with networking and other services enabled'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multi-user.target`：表示一个已经准备好提供多用户访问、启用网络和其他服务的系统。'
- en: '`graphical.target`: Represents a system that is ready to display a graphical
    login screen, with a graphical desktop environment and related services enabled'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reboot.target`: Represents a system that is rebooting'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emergency.target`: Represents a system that is running in emergency mode,
    with only the most essential services enabled'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a `systemd` unit file that defines a custom target:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This unit file defines a target named `Custom Target` that is meant to be activated
    as part of `multi-user.target`. The `WantedBy` directive specifies that the target
    should be activated when `multi-user.target` is activated.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example of a `systemd` unit file named `custom.target` that
    defines a custom target:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is a unit file that is using our `custom.target` target:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This unit file defines a target named `Unit File With Custom Target` and a service
    named `My simple service`. The `ExecStart` directive specifies the command that
    should be used to start the service, and the `Type` directive specifies the type
    of service. The `WantedBy` directive in the `[Install]` section of the service
    unit specifies that the service should be activated when `custom.target` is activated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we have touched upon unit files a bit, let’s dig into them deeper and
    see what is possible with them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Unit files
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unit files are usually stored in the `/lib/systemd/` system directory of Linux
    OS filesystems. No files in this directory should be altered in any way since
    they will be replaced by files contained in packages when a service is upgraded
    using a packet manager.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Instead, to modify a unit file of a specific service, create your customized
    unit file inside the `/etc/systemd/system` directory. Files in this `etc` directory
    will take precedence over the default location.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '`systemd` is able to provide unit activation using the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`systemd`. At its simplest, you will need to add a dependency with `multi-user.target`
    or with `network.target` if your service is using networking.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/``etc/systemd/system` directory.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: You can also define template unit files. Those special units
    can be used to create multiple instances of the same general unit.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private/tmp` or network access, and limit kernel capabilities.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: You can start a unit based on activity on or the availability of
    a file or directory in the filesystem.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Socket**: This a special type of file in the Linux operating system that
    enables communication between two processes. Using this feature, you can delay
    starting a service until the associated socket is accessed. You can also create
    a unit file that simply creates a socket early in a boot process and a separate
    unit file that uses this socket.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bus**: You can activate a unit by using the bus interface provided by D-Bus.
    D-Bus is simply a message bus used for **inter-process communication** (**IPC**),
    most commonly used in GUIs such as GNOME or KDE.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev` file, located in the `/dev` directory). This will leverage a mechanism
    known as `udev`, which is a Linux subsystem that supplies device events.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you’ve started a service, you will probably want to check whether it’s
    up and healthy by taking a look at the log files. This job is taken care of by
    `journald`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every service managed by `systemd` sends its logs to `journald`—a special part
    of `systemd`. There is a special command-line tool for managing those logs: `journalctl`.
    In its simplest form, running a `journalctl` command will simply output all system
    logs, with the newest ones being at the top. While the format of the logs is similar
    to `syslog`—the traditional tool for gathering logs on Linux—`journald` captures
    more data. It collects data from the boot process, kernel logs, and more.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'The boot logs are transient by default. This means they are not saved between
    system reboots. There is, however, a possibility to record them permanently. There
    are two ways to do it, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a special directory. When `journald` detects it during system boot,
    it will save logs there: `sudo mkdir -``p /var/log/journal`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit the `journald` configuration file and enable persistent boot logs. Open
    the `/etc/systemd/journald.conf` file with your favorite editor and, in the `[Journal]`
    section, edit the `Storage` option to look like this:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`journald` is capable of filtering logs by service by the use of the `-u service.name`
    option—that is, `journalctl -u httpd.service` will only print logs from the `httpd`
    daemon. There’s a possibility of printing logs from a given timeframe, printing
    from more than one service, searching logs by `man journalctl` command for this.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have covered the most often used services software in the
    Linux world—`systemd`. In the next section, we are going to look at OpenRC—a system
    used in Alpine Linux, the Linux distribution of choice for containers in the cloud.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: OpenRC
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alpine Linux uses another system for managing system services called `init`
    system originally developed for the use of Gentoo Linux. It is designed to be
    lightweight, simple, and easy to maintain. OpenRC uses plain text configuration
    files, which makes it easy to customize and configure. It is also easy to extend
    with custom scripts and programs. OpenRC is flexible and can be used on a wide
    variety of systems, from embedded devices to servers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are examples of how OpenRC is used in Alpine Linux:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '`ssh`, and `cron`. You can use the `rc-service` command to start, stop, or
    check the status of a service. For example, to start the `ssh` service, you can
    run `rc-service` `ssh start`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customizing system initialization and shutdown**: OpenRC allows you to write
    custom scripts to customize the behavior of your system during startup or shutdown.
    These scripts are executed at specific points in the boot process and can be used
    to set up custom configurations or perform other tasks.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rc-update` command to add or remove services from different runlevels. For
    example, to make a service start at boot, you can run `rc-update add <``service>
    boot`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start a service, use the following `rc-service` command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To stop a service, use the following `rc-service` command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To check the status of a service, use the following `rc-service` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To enable a service to start at boot, use the following `rc-update` command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To disable a service from starting at boot, use the following `rc-update` command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Default in this context means a default runlevel of the Alpine Linux system.
    Runlevels in general are used to define the system’s behavior. There are several
    predefined runlevels common to most Linux distributions, each of which corresponds
    to a specific set of services that are started or stopped.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'In Alpine Linux, these are the default runlevels:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '`default`: This is the default runlevel and is used when the system is booted
    normally. Services that are started in this runlevel include networking, SSH,
    and system logging.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boot`: This runlevel is used when the system is booting. Services that are
    started in this runlevel include the system console, the system clock, and the
    kernel.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`single`: This runlevel is used when the system is booted into single-user
    mode. Only a minimal set of services is started in this runlevel, including the
    system console and the system clock.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shutdown`: This runlevel is used when the system is shutting down. Services
    that are stopped in this runlevel include networking, SSH, and system logging.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenRC uses a very similar way of defining service actions to SysV `init` we
    mentioned earlier in this chapter. Commands such as `start`, `stop`, `restart`,
    and `status` are defined in a Bash script. Here is a basic example of a service:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To create a new service, you can copy this file to a new file and modify the
    `name`, `description`, `start`, `stop`, and `restart` functions as needed. The
    `start` function should contain the command to start the service, the `stop` function
    should contain the command to stop the service, and the `restart` function should
    stop and start the service. Those can be the same as for SysV `init`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: In OpenRC, `init` scripts are typically stored in the `/etc/init.d` directory.
    These are scripts that are used to start and stop services and manage the system’s
    runlevels.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: To create a new `init` script for OpenRC, you can create a new file in the `/etc/init.d`
    directory and make it executable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created your `init` script, you can use the `rc-update` command
    to add it to the default runlevel, which will cause the service to start at boot.
    For example, to add the `exampleservice` service to the default runlevel, you
    can run the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In most cases, we’ll be using Alpine Linux in a Docker environment where there’s
    little use for OpenRC, but it’s still useful to know for some edge-case usage.
    We will look at Docker in more detail in [*Chapter 8*](B18197_08.xhtml#_idTextAnchor166)
    and [*Chapter 9*](B18197_09.xhtml#_idTextAnchor245).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at OpenRC, software that controls system services
    in Alpine Linux. In the next section, we are going to introduce, very shortly,
    an outdated form of SysV `init`, which may come up with older or minimal Linux
    distributions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: SysV init
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously mentioned, the `init` process is the most important continuously
    running process in the system. It’s responsible for starting system services when
    the system boots up or when an administrator requests it, and stopping system
    services when the system is shutting down or when requested, all in the proper
    order. It’s also responsible for restarting services on request. Since `init`
    will execute code on behalf of the root user, it is imperative that it’s well
    tested for stability and security risks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: One of the charming properties of the old `init` system was its simplicity.
    The starting, stopping, and restarting of a service was managed by a script—one
    that had to be written by either the application author, the distribution package
    owner for this application, or the system administrator—if the service was not
    installed from packages. The scripts were simple and easy to understand, write,
    and debug.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The more the complexity of software grew, however, the more the old `init` system
    showed its age. Starting up a simple service was okay. Starting up an application
    consisting of several programs grew more difficult, especially as the dependencies
    between them became more important. `init` lacks observation of dependencies of
    startup of the services it takes care of.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Another place where the old `init` system became more and more unfit for modern
    systems was serial startup: it was unable to start services in parallel, thus
    negating modern multicore CPU gains. The time was nigh to look for a system more
    fit to the new times.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical `init` system consists of several components, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: A `/etc/init.d` or `/etc/rc.d/init.d` directory that contains start/stop scripts.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `/etc/inittab` file that defines runlevels and sets up a default one.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `/etc/rcX.d` directory that contains all the scripts for services that should
    be started or stopped in the runlevel `X`, where `X` is a number from `0` (zero)
    to `6`. We will get to the details in the next paragraph.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `/etc/init.d/` directory contains shell scripts responsible for starting,
    stopping, and restarting services. The script accepts a single argument of either
    `start`, `stop`, or `restart`. Each argument passed to the script executes a proper
    function (usually named the same as the argument: `start`, `stop`, or `restart`),
    and the function runs a set of steps to properly start, stop, or restart the given
    service. The kind of final state of the start process that the system ends up
    in is called a **runlevel**. The runlevel determines whether services are being
    started or stopped and which of them are being started if this is the course of
    action.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: To determine the type of action to call, a link to the script would be created
    in the directory related to the runlevel in question.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume we want the system to end up in runlevel `3`. If we want our service
    to be started in this runlevel, we would create a link to the `/etc/rc.d/my_service`
    script pointing to the `/etc/rc3.d/` directory. The name of the link determines
    the type of action and the order. So, if we wanted the service to be started after
    numbers `01`-`49`, we would call it `/etc/rc.3/S50my_service`. The letter `S`
    tells the `init` system to start the service, and the number `50` tells it to
    start it after all services with lower numbers have been started. Please note
    that the numbering is more of a framework. It is not guaranteed that there are
    scripts with all other numbers prior to `50`. The same goes for stopping services.
    After determining which runlevel is the default for stopping the system (usually
    `0`), a proper `symlink` is created for the service script.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The major problem with the preceding framework is that it’s totally unaware
    of dependencies. The only way to ensure that the services on which your daemon
    depends are running is to script it around in your `start` function. In the case
    of more complex applications comprising many services, this may lead to bigger
    start/stop scripts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Another issue with `init` scripts being raised by admins and developers was
    that there are multiple standards on how to write them and multiple different
    tools around `init` scripts. Basically, every major Linux distribution had its
    own way of writing those scripts and its own library of helper functions. Let’s
    consider an `init` script starting the same `My Service` service on Slackware
    Linux and Debian/GNU Linux. This is also where the introductory chapter on writing
    shell scripts comes in handy.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, Slackware and Debian, we are going to cut some original content
    out for brevity, leaving only the most important parts. Do not worry as both distributions
    deliver wholly commented example scripts.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `init` script will work in a Slackware Linux environment. The
    script starts with a header where we declare the name of the service and some
    important paths:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The good thing is that an example script delivered with Slackware is very well
    commented. We have to declare a path to the binary for the daemon. We also have
    to declare the user and group that the service will run as, effectively deciding
    filesystem permissions for it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section defines all important actions for the service: `start`, `stop`,
    `and restart`. There are usually a few others, but we have cut them out for brevity:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `start` function checks whether the service is running utilizing the `pid`
    file. The `pid` file is a text file that contains the PID of the service. It gives
    information about both the main process of the service and its status. There is
    a caveat, however. It is possible that the service isn’t running anymore and the
    `pid` file still exists. That would prevent the `start` function from actually
    starting the service.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: After the check determines that the `pid` file doesn’t exist, which means that
    the service is not running, a special tool called `daemon` is used to start the
    process with user and group permissions, pointing to a configuration file, log
    file, and `pid` file locations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'The function communicates its actions using the `bash echo` command, which
    prints the given text. In case of automatic execution, the output of the `echo`
    command will be logged to system logs depending on the logging `daemon` configuration:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Again, the `stop` function checks whether the service is running using the
    `pid` file. The probability of the service running without a proper `pid` file
    is almost nonexistent. After the check is done, a special command called `killproc`
    is used to terminate the process. In the final part of the function, the script
    does some housekeeping tasks, cleaning the `pid` file and the `lock` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `restart` function is very simple. It reuses the already defined `start`
    and `stop` functions to do exactly what it says: restart the service. This is
    often useful if the service configuration requires the binary to be loaded again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The final part of the script evaluates the action we want to take—start, stop,
    or restart the service—and calls the proper function. If we ask it to do something
    it doesn’t recognize, the script will print out usage instructions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The following script, however, is intended for a Debian Linux environment:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Again, the script starts with a header section that defines paths to be later
    used in the `start` and `stop` sections. Normally there are more lines, but we’ve
    cut them out for brevity, again:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `start` function looks similar to the one from the Slackware version. You’ll
    notice some subtle differences, however, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The `start-stop-daemon` helper function is being used here to manage the running
    service instead of `daemon` and `killproc`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are specialized functions for logging instead of simple echo: `log_daemon_msg`,
    `log_failure_msg`, and `log_end_msg`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `start-stop-daemon` function accepts special flags to determine the action
    (`start` and `stop`) as well as detaching the program from the terminal, making
    it effectively a system service (`--background`), as seen here:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `stop` function is pretty similar to the `stop` function from Slackware,
    with similar differences to those the `start` function had.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the script containing the `restart` function and the task evaluation
    is not that interesting, and we’ve cut it out.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: As you probably still remember from the section about `systemd`, it solves some
    of those problems. SysV is not seen too often in modern systems, so you will most
    commonly need to deal with `systemd` instead.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: There is, however, another replacement for SysV `init` called Upstart.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: A few words about Upstart, an alternative
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Upstart is an event-based replacement for the traditional SysV `init` system
    used to manage and control services and daemons on a system. Upstart was introduced
    in Ubuntu `6.10` and later versions and is designed to improve boot time, simplify
    system configuration, and provide more flexibility in managing system services.
    It has now been largely replaced by `systemd` in most Linux distributions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Upstart is used to manage the initialization process of the system and to start,
    stop, and supervise tasks and services. It is designed to be more flexible and
    efficient than the traditional `init` daemon and to provide more information about
    the status of tasks and services.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: All that can be managed by `systemd` and/or `cron` has become an industry standard,
    so if you don’t have a good reason for using those or already have a system using
    Upstart, we discourage you from using it as a default.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered system services—or daemons in the Unix and Linux
    world—and the software most often used to manage them. We explained what those
    are, how to inspect their state, and how to control them. In the next chapter,
    we are going to dive into Linux networking.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
