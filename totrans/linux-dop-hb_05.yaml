- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Managing Services in Linux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 Linux 中的服务
- en: In this chapter, we’re going to explain services (programs running in the background
    as daemons) in more depth. We’re going to explain `init` scripts and `systemd`
    units. We are also going to cover Alpine Linux `rc` commands that manage services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入解释服务（作为守护进程在后台运行的程序）。我们将解释 `init` 脚本和 `systemd` 单元。我们还将介绍管理服务的 Alpine
    Linux `rc` 命令。
- en: 'The chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容包括以下主题：
- en: Understanding Linux services in detail
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 详细了解 Linux 服务
- en: A few words about Upstart, an alternative
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Upstart 的简要介绍，作为一种替代方案
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need a Linux system at hand where you can execute
    privileged commands, either using `sudo` or jumping straight to the root account
    (although we particularly recommend the first one). You’ll also need a Linux text
    editor of your choice that will produce pure text files. If you are going to edit
    on a Windows system, use a text editor that enables you to save Unix files. We
    recommend editing in the command line with one of your favorite command-line text
    editors: `vim`, `emacs`, `joe`, `nano`, or whatever suits you.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容，你需要一台可以执行特权命令的 Linux 系统，可以使用 `sudo` 或直接跳到 root 账户（尽管我们特别推荐使用前者）。你还需要一款
    Linux 文本编辑器，能够生成纯文本文件。如果你打算在 Windows 系统上编辑，请使用支持保存 Unix 文件的文本编辑器。我们推荐在命令行中使用你喜欢的命令行文本编辑器进行编辑：`vim`、`emacs`、`joe`、`nano`，或者任何你习惯使用的编辑器。
- en: Understanding Linux services in detail
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细了解 Linux 服务
- en: Unless you are running some kind of low-level embedded device on your desktop—and
    we strongly doubt it—your operating system manages a multitude of tasks to create
    a comfortable and productive environment for you. Be it Mac OS X, Linux, Windows,
    or FreeBSD, they all run a multitude of background programs that together provide
    a useful system. The same goes for server flavors of those operating systems.
    A background program or background process (in Unix and Linux called, fluffily,
    a daemon) means a program that is not attached to any input (keyboard, mouse,
    etc.) or output (monitor, terminal, etc.). This way, they can start working even
    when no one is logged in to the system and keep working when the user logs out.
    They can also run under the privileges of a user who can never log in to the system,
    making their execution much safer.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你在桌面上运行某种低级别的嵌入式设备——我们强烈怀疑这一点——否则你的操作系统会管理大量任务，为你创建一个舒适且高效的环境。无论是 Mac OS X、Linux、Windows
    还是 FreeBSD，它们都运行许多后台程序，这些程序共同提供一个有用的系统。服务器版本的操作系统也是如此。后台程序或后台进程（在 Unix 和 Linux
    中称为“守护进程”）是指不与任何输入（键盘、鼠标等）或输出（显示器、终端等）连接的程序。这样，它们即使在没有人登录系统时也能开始工作，并且在用户注销时继续工作。它们还可以在一个永远无法登录系统的用户的权限下运行，从而使它们的执行更加安全。
- en: The number of services running on your Linux system will, in large part, depend
    on the distribution and, in even larger part, on the system’s purpose.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Linux 系统上运行的服务数量，很大程度上取决于发行版，甚至更大程度上取决于系统的用途。
- en: The history of Linux service management
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 服务管理的历史
- en: As you can probably imagine, the task of managing the system services—the programs
    required to run so that your computer is usable to you—is not a trivial one. The
    software that runs them must be stable and robust. This, and the fact that the
    system is expected to start rarely, especially on servers, made the Linux-adopted
    solution survive for decades. The increasing need to start services in parallel
    (through the emergence and widespread use of many threaded CPUs) and more intelligently
    gave way to several implementations of the new `init` system, which we will cover
    next.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，管理系统服务——即那些让你的计算机能够使用的程序——是一项复杂的任务。运行这些服务的软件必须稳定且强大。这一点，以及系统启动不频繁，尤其是在服务器上，促使了
    Linux 采用的解决方案得以持续数十年。随着许多线程 CPU 的出现并广泛使用，启动服务的需求日益增加，且更需要智能化管理，促成了新 `init` 系统的多个实现，我们将在接下来的部分中介绍。
- en: systemd
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: systemd
- en: '`systemd` is a service manager for Linux that is able to manage services that
    start with the operating system. It replaces traditional `init` scripts. It is
    responsible for starting and stopping system services, managing system state,
    and logging system events. It has become the default `init` system for many popular
    Linux distributions, including CentOS, Fedora Linux, **Red Hat Enterprise Linux**
    (**RHEL**), and Ubuntu Linux.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`是一个用于Linux的服务管理器，能够管理与操作系统一起启动的服务。它取代了传统的`init`脚本。它负责启动和停止系统服务，管理系统状态，以及记录系统事件。它已经成为许多流行Linux发行版的默认`init`系统，包括CentOS、Fedora
    Linux、**红帽企业Linux**（**RHEL**）和Ubuntu Linux。'
- en: This service manager is responsible for controlling the initialization of the
    system itself (services required for the Linux OS), starting and stopping system
    services, and managing system resources. It provides another way of managing services
    and other system components, and it allows system administrators to configure
    and customize the behavior of their systems in a more standardized way than with
    `init`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务管理器负责控制系统本身的初始化（Linux操作系统所需的服务）、启动和停止系统服务，以及管理系统资源。它提供了另一种管理服务和其他系统组件的方式，并且允许系统管理员以比`init`更标准化的方式配置和自定义系统行为。
- en: One of the key features of `systemd` is its ability to start services in parallel,
    which can significantly reduce the boot time of a system. It also includes a number
    of tools for managing and monitoring system services.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`的一个关键特性是能够并行启动服务，这可以显著减少系统的启动时间。它还包括一些用于管理和监控系统服务的工具。'
- en: Another thing `systemd` is praised for is the uniformity of service configurations
    it has finally brought to the Linux world. In every Linux distribution, the `systemd`
    configuration files are delivered to the same path; they look the same. There
    are, however, still some differences depending on the path binaries are being
    installed to. `systemd` is also better at knowing whether a process is running,
    making it more difficult to end up in a situation where we can’t start a process
    because of stale files.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`systemd`受到赞扬的另一点是它最终为Linux世界带来的服务配置统一性。在每个Linux发行版中，`systemd`配置文件都被送到相同的路径，并且看起来相同。然而，根据二进制文件的安装路径，仍然存在一些差异。`systemd`还更擅长判断进程是否正在运行，这使得我们更不容易遇到因为过时的文件无法启动进程的情况。
- en: 'One of the major advantages of `systemd` is its awareness of dependencies.
    The service (running program under `systemd` control) configuration contains information
    about all the other services it depends on and can also point to services that
    depend on it. What’s more, the service can inform `systemd` about which targets
    it requires to run: if your service needs the network to be up and running, you
    can put this information into the configuration, and `systemd` will ensure your
    daemon will be brought up only after the network is properly configured.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`的一个主要优势是它对依赖关系的意识。服务（在`systemd`控制下的运行程序）配置包含了关于它依赖的所有其他服务的信息，还可以指向依赖于它的服务。而且，服务可以向`systemd`告知它需要运行的目标：如果您的服务需要网络运行，您可以将此信息写入配置中，`systemd`会确保只有在网络正确配置后才会启动您的守护进程。'
- en: 'The following is a list of some of the tools and utilities that are provided
    as part of `systemd`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是作为`systemd`一部分提供的一些工具和实用程序的列表：
- en: '`systemd`: This is the main system and service manager. It is the main program
    that controls the initialization and management of services and other system components.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd`：这是主要的系统和服务管理器。它是控制服务和其他系统组件初始化和管理的主要程序。'
- en: '`systemctl`: This is the command-line utility for managing system services
    and other system components. It can be used to start, stop, restart, enable, and
    disable services, as well as to view the status of services and other system components.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl`：这是一个命令行工具，用于管理系统服务和其他系统组件。它可以用于启动、停止、重启、启用和禁用服务，还可以查看服务和其他系统组件的状态。'
- en: '`journalctl`: This is used for viewing and manipulating the system log, which
    is managed by `systemd`. It can be used to view log messages, filter log messages
    based on various criteria, and export log data to a file.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`journalctl`：用于查看和操作系统日志，日志由`systemd`管理。它可以用来查看日志消息，根据各种标准过滤日志消息，并将日志数据导出到文件。'
- en: '`coredumpctl`: This is a utility, as the name suggests, that helps retrieve
    core dumps from `systemd`’s journal.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coredumpctl`：这是一个实用工具，顾名思义，它有助于从`systemd`的日志中检索核心转储。'
- en: '`systemd-analyze`: This can be used for analyzing the boot performance of a
    system. It measures the time it takes for a system to boot, as well as the time
    it takes to identify potential bottlenecks and performance issues.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-analyze`：这个工具可以用来分析系统的启动性能。它衡量系统启动所需的时间，以及识别潜在的瓶颈和性能问题的时间。'
- en: '`systemd-cgls`: This is a command-line utility for viewing the control group
    hierarchy on a system. `systemd` to manage system resources and to isolate processes
    from one another.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-cgls`：这是一个用于查看系统上控制组层级的命令行工具。`systemd` 用于管理系统资源并将进程相互隔离。'
- en: '`systemd-delta`: This is a command-line utility for analyzing the differences
    between the default configuration files provided by `systemd` and any local modifications
    made to these files.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-delta`：这是一个用于分析 `systemd` 提供的默认配置文件与对这些文件所做的本地修改之间差异的命令行工具。'
- en: '`systemd-detect-virt`: This is a command-line utility for detecting the virtualization
    environment in which a system is running. It can be used to determine whether
    a system is running in a **virtual machine** (**VM**), a container, or on bare
    metal.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-detect-virt`：这是一个用于检测系统运行的虚拟化环境的命令行工具。它可以用来判断系统是运行在**虚拟机**（**VM**）、容器中，还是裸机上。'
- en: '`systemd-inhibit`: This is a command-line utility for preventing certain system
    actions, such as suspending or shutting down the system, from being performed.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-inhibit`：这是一个命令行工具，用于防止执行某些系统操作，例如暂停或关闭系统。'
- en: '`systemd-nspawn`: This is a command-line utility for running processes in lightweight
    containers. It can be used to create and manage containers, as well as to execute
    processes within containers.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd-nspawn`：这是一个用于在轻量级容器中运行进程的命令行工具。它可以用来创建和管理容器，以及在容器内执行进程。'
- en: This is just a list of more common tools and utilities that are provided as
    part of `systemd`. There are many more, but we will not cover them here.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 `systemd` 提供的一些常见工具和实用程序的列表。还有很多其他工具，但我们在这里不再讨论它们。
- en: Targets
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标
- en: In `systemd`, a **target** is a specific state that the system can be in, and
    it is represented by a symbolic name. Targets are used to define the high-level
    behavior of the system, and they are typically used to group together a set of
    related services and other system components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `systemd` 中，**目标** 是系统可以处于的特定状态，并通过一个符号名称表示。目标用于定义系统的高级行为，通常用于将一组相关的服务和其他系统组件组合在一起。
- en: For example, `multi-user.target` is a target that represents a system that is
    ready to provide multi-user access, with networking and other services enabled;
    `graphical.target` is a target that represents a system that is ready to display
    a graphical login screen, with a graphical desktop environment and related services
    enabled.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`multi-user.target` 是一个表示已准备好提供多用户访问的系统，启用了网络和其他服务；`graphical.target` 是一个表示已准备好显示图形登录界面的系统，启用了图形桌面环境和相关服务。
- en: Targets are typically defined in unit files, which are configuration files that
    describe the properties and behavior of system components. When a target is activated,
    `systemd` will start all of the services and other system components that are
    associated with that target.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目标通常在单元文件中定义，这些文件是描述系统组件属性和行为的配置文件。当目标被激活时，`systemd` 将启动所有与该目标相关的服务和其他系统组件。
- en: '`systemd` includes a number of predefined targets that cover a wide range of
    common system states, and administrators can also define custom targets to suit
    the specific needs of their systems. Targets can be activated using the `systemctl`
    command, or by modifying the default target that is set when the system boots.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd` 包括许多预定义的目标，涵盖了广泛的常见系统状态，管理员还可以定义自定义目标以满足其系统的特定需求。目标可以通过 `systemctl`
    命令激活，或者通过修改系统启动时设置的默认目标来激活。'
- en: 'Here are some examples of predefined `systemd` targets:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些预定义的 `systemd` 目标的示例：
- en: '`poweroff.target`: Represents a system that is shutting down or powered off'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poweroff.target`：表示一个正在关机或已关闭的系统。'
- en: '`rescue.target`: Represents a system that is running in rescue mode, with minimal
    services enabled'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rescue.target`：表示一个处于救援模式的系统，启用了最小化的服务。'
- en: '`multi-user.target`: Represents a system that is ready to provide multi-user
    access, with networking and other services enabled'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multi-user.target`：表示一个已经准备好提供多用户访问、启用网络和其他服务的系统。'
- en: '`graphical.target`: Represents a system that is ready to display a graphical
    login screen, with a graphical desktop environment and related services enabled'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`graphical.target`：表示一个已经准备好显示图形登录屏幕的系统，启用了图形桌面环境和相关服务。'
- en: '`reboot.target`: Represents a system that is rebooting'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reboot.target`：表示一个正在重启的系统。'
- en: '`emergency.target`: Represents a system that is running in emergency mode,
    with only the most essential services enabled'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emergency.target`：表示一个运行在紧急模式下的系统，仅启用最基本的服务。'
- en: 'Here is an example of a `systemd` unit file that defines a custom target:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个定义自定义目标的`systemd`单元文件示例：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This unit file defines a target named `Custom Target` that is meant to be activated
    as part of `multi-user.target`. The `WantedBy` directive specifies that the target
    should be activated when `multi-user.target` is activated.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元文件定义了一个名为`Custom Target`的目标，旨在作为`multi-user.target`的一部分被激活。`WantedBy`指令指定，当`multi-user.target`被激活时，目标应该被激活。
- en: 'Here is another example of a `systemd` unit file named `custom.target` that
    defines a custom target:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个名为`custom.target`的`systemd`单元文件示例，它定义了一个自定义目标：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is a unit file that is using our `custom.target` target:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用我们`custom.target`目标的单元文件：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This unit file defines a target named `Unit File With Custom Target` and a service
    named `My simple service`. The `ExecStart` directive specifies the command that
    should be used to start the service, and the `Type` directive specifies the type
    of service. The `WantedBy` directive in the `[Install]` section of the service
    unit specifies that the service should be activated when `custom.target` is activated.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单元文件定义了一个名为`Unit File With Custom Target`的目标和一个名为`My simple service`的服务。`ExecStart`指令指定了启动服务时应使用的命令，而`Type`指令指定了服务的类型。服务单元中`[Install]`部分的`WantedBy`指令指定，当`custom.target`被激活时，服务应该被激活。
- en: Now, as we have touched upon unit files a bit, let’s dig into them deeper and
    see what is possible with them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们已经简单介绍了单元文件，让我们深入了解它们，看看能用它们做些什么。
- en: Unit files
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元文件
- en: Unit files are usually stored in the `/lib/systemd/` system directory of Linux
    OS filesystems. No files in this directory should be altered in any way since
    they will be replaced by files contained in packages when a service is upgraded
    using a packet manager.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 单元文件通常存储在Linux操作系统文件系统中的`/lib/systemd/`系统目录中。此目录中的文件不应以任何方式修改，因为当通过软件包管理器升级服务时，这些文件将会被包中的文件替换。
- en: Instead, to modify a unit file of a specific service, create your customized
    unit file inside the `/etc/systemd/system` directory. Files in this `etc` directory
    will take precedence over the default location.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，要修改特定服务的单元文件，请在`/etc/systemd/system`目录中创建自定义单元文件。此`etc`目录中的文件将优先于默认位置的文件。
- en: '`systemd` is able to provide unit activation using the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`systemd`能够使用以下方式提供单元激活：'
- en: '`systemd`. At its simplest, you will need to add a dependency with `multi-user.target`
    or with `network.target` if your service is using networking.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemd`。最简单的情况是，如果您的服务使用了网络，您需要添加一个与`multi-user.target`或`network.target`的依赖关系。'
- en: '`/``etc/systemd/system` directory.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/systemd/system`目录。'
- en: '**Templates**: You can also define template unit files. Those special units
    can be used to create multiple instances of the same general unit.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：您还可以定义模板单元文件。这些特殊单元可用于创建同一通用单元的多个实例。'
- en: '`private/tmp` or network access, and limit kernel capabilities.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private/tmp`或网络访问，并限制内核功能。'
- en: '**Path**: You can start a unit based on activity on or the availability of
    a file or directory in the filesystem.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：您可以基于文件系统中某个文件或目录的活动或可用性来启动一个单元。'
- en: '**Socket**: This a special type of file in the Linux operating system that
    enables communication between two processes. Using this feature, you can delay
    starting a service until the associated socket is accessed. You can also create
    a unit file that simply creates a socket early in a boot process and a separate
    unit file that uses this socket.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字**：这是Linux操作系统中的一种特殊类型的文件，它允许两个进程之间进行通信。通过使用此功能，您可以延迟启动服务，直到相关的套接字被访问。您还可以创建一个单元文件，在启动过程的早期仅创建一个套接字，并创建一个单独的单元文件来使用此套接字。'
- en: '**Bus**: You can activate a unit by using the bus interface provided by D-Bus.
    D-Bus is simply a message bus used for **inter-process communication** (**IPC**),
    most commonly used in GUIs such as GNOME or KDE.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总线**：您可以使用D-Bus提供的总线接口来激活单元。D-Bus只是一个用于**进程间通信**（**IPC**）的消息总线，最常用于GNOME或KDE等图形用户界面中。'
- en: '`dev` file, located in the `/dev` directory). This will leverage a mechanism
    known as `udev`, which is a Linux subsystem that supplies device events.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dev` 文件，位于 `/dev` 目录下）。这将利用一种被称为 `udev` 的机制，`udev` 是一个 Linux 子系统，用于提供设备事件。'
- en: Once you’ve started a service, you will probably want to check whether it’s
    up and healthy by taking a look at the log files. This job is taken care of by
    `journald`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启动了一个服务，你可能希望通过查看日志文件来检查它是否正常运行。这项工作由 `journald` 完成。
- en: Logging
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志记录
- en: 'Every service managed by `systemd` sends its logs to `journald`—a special part
    of `systemd`. There is a special command-line tool for managing those logs: `journalctl`.
    In its simplest form, running a `journalctl` command will simply output all system
    logs, with the newest ones being at the top. While the format of the logs is similar
    to `syslog`—the traditional tool for gathering logs on Linux—`journald` captures
    more data. It collects data from the boot process, kernel logs, and more.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个由 `systemd` 管理的服务都会将其日志发送到 `journald`——`systemd` 的一个特殊部分。管理这些日志有一个专用的命令行工具：`journalctl`。在最简单的形式下，运行
    `journalctl` 命令会输出所有系统日志，最新的日志会显示在最上面。虽然日志的格式类似于 `syslog`——这是 Linux 上用于收集日志的传统工具——但
    `journald` 捕获了更多数据。它收集了启动过程、内核日志等信息。
- en: 'The boot logs are transient by default. This means they are not saved between
    system reboots. There is, however, a possibility to record them permanently. There
    are two ways to do it, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 启动日志默认是临时的。这意味着它们不会在系统重启之间保存。然而，也可以将它们永久记录下来。下面是两种方法：
- en: 'Create a special directory. When `journald` detects it during system boot,
    it will save logs there: `sudo mkdir -``p /var/log/journal`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个特殊的目录。当 `journald` 在系统启动时检测到该目录时，它会将日志保存在该目录中：`sudo mkdir -p /var/log/journal`。
- en: 'Edit the `journald` configuration file and enable persistent boot logs. Open
    the `/etc/systemd/journald.conf` file with your favorite editor and, in the `[Journal]`
    section, edit the `Storage` option to look like this:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑 `journald` 配置文件并启用持久化启动日志。使用你喜欢的编辑器打开 `/etc/systemd/journald.conf` 文件，在 `[Journal]`
    部分，将 `Storage` 选项修改为如下所示：
- en: '[PRE3]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`journald` is capable of filtering logs by service by the use of the `-u service.name`
    option—that is, `journalctl -u httpd.service` will only print logs from the `httpd`
    daemon. There’s a possibility of printing logs from a given timeframe, printing
    from more than one service, searching logs by `man journalctl` command for this.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`journald` 可以通过使用 `-u service.name` 选项按服务过滤日志——也就是说，`journalctl -u httpd.service`
    只会打印来自 `httpd` 守护进程的日志。你也可以通过 `man journalctl` 命令来查看如何在指定的时间范围内打印日志，或从多个服务中打印日志。'
- en: In this section, we have covered the most often used services software in the
    Linux world—`systemd`. In the next section, we are going to look at OpenRC—a system
    used in Alpine Linux, the Linux distribution of choice for containers in the cloud.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 Linux 世界中最常用的服务软件——`systemd`。在下一节中，我们将探讨 OpenRC——一种用于 Alpine Linux
    的系统，Alpine Linux 是云端容器首选的 Linux 发行版。
- en: OpenRC
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenRC
- en: Alpine Linux uses another system for managing system services called `init`
    system originally developed for the use of Gentoo Linux. It is designed to be
    lightweight, simple, and easy to maintain. OpenRC uses plain text configuration
    files, which makes it easy to customize and configure. It is also easy to extend
    with custom scripts and programs. OpenRC is flexible and can be used on a wide
    variety of systems, from embedded devices to servers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine Linux 使用另一种用于管理系统服务的系统——`init` 系统，最初为 Gentoo Linux 开发。它旨在轻量、简单且易于维护。OpenRC
    使用纯文本配置文件，使其易于定制和配置。它也很容易通过自定义脚本和程序进行扩展。OpenRC 灵活，可以在各种系统上使用，从嵌入式设备到服务器。
- en: 'The following are examples of how OpenRC is used in Alpine Linux:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 OpenRC 在 Alpine Linux 中的使用示例：
- en: '`ssh`, and `cron`. You can use the `rc-service` command to start, stop, or
    check the status of a service. For example, to start the `ssh` service, you can
    run `rc-service` `ssh start`.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh` 和 `cron`。你可以使用 `rc-service` 命令来启动、停止或检查服务的状态。例如，要启动 `ssh` 服务，可以运行 `rc-service`
    `ssh start`。'
- en: '**Customizing system initialization and shutdown**: OpenRC allows you to write
    custom scripts to customize the behavior of your system during startup or shutdown.
    These scripts are executed at specific points in the boot process and can be used
    to set up custom configurations or perform other tasks.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义系统初始化和关机**：OpenRC 允许你编写自定义脚本来定制系统在启动或关机过程中的行为。这些脚本会在启动过程中的特定点执行，用于设置自定义配置或执行其他任务。'
- en: '`rc-update` command to add or remove services from different runlevels. For
    example, to make a service start at boot, you can run `rc-update add <``service>
    boot`.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rc-update`命令用于将服务添加或移除到不同的运行级别。例如，要使服务在启动时启动，可以运行`rc-update add <service>
    boot`。'
- en: 'To start a service, use the following `rc-service` command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动服务，请使用以下`rc-service`命令：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To stop a service, use the following `rc-service` command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止服务，请使用以下`rc-service`命令：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To check the status of a service, use the following `rc-service` command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查服务的状态，请使用以下`rc-service`命令：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To enable a service to start at boot, use the following `rc-update` command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用服务在启动时启动，请使用以下`rc-update`命令：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To disable a service from starting at boot, use the following `rc-update` command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁止服务在启动时启动，请使用以下`rc-update`命令：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Default in this context means a default runlevel of the Alpine Linux system.
    Runlevels in general are used to define the system’s behavior. There are several
    predefined runlevels common to most Linux distributions, each of which corresponds
    to a specific set of services that are started or stopped.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中，默认指的是Alpine Linux系统的默认运行级别。运行级别通常用于定义系统的行为。大多数Linux发行版都有几个预定义的运行级别，每个运行级别对应一组特定的服务，这些服务会被启动或停止。
- en: 'In Alpine Linux, these are the default runlevels:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Alpine Linux中，以下是默认的运行级别：
- en: '`default`: This is the default runlevel and is used when the system is booted
    normally. Services that are started in this runlevel include networking, SSH,
    and system logging.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：这是默认的运行级别，用于系统正常启动时。此运行级别中启动的服务包括网络、SSH和系统日志。'
- en: '`boot`: This runlevel is used when the system is booting. Services that are
    started in this runlevel include the system console, the system clock, and the
    kernel.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boot`：此运行级别在系统启动时使用。此运行级别中启动的服务包括系统控制台、系统时钟和内核。'
- en: '`single`: This runlevel is used when the system is booted into single-user
    mode. Only a minimal set of services is started in this runlevel, including the
    system console and the system clock.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`single`：此运行级别在系统启动到单用户模式时使用。此运行级别中启动的服务仅包含一组最小服务，包括系统控制台和系统时钟。'
- en: '`shutdown`: This runlevel is used when the system is shutting down. Services
    that are stopped in this runlevel include networking, SSH, and system logging.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown`：此运行级别在系统关闭时使用。此运行级别中停止的服务包括网络、SSH和系统日志。'
- en: 'OpenRC uses a very similar way of defining service actions to SysV `init` we
    mentioned earlier in this chapter. Commands such as `start`, `stop`, `restart`,
    and `status` are defined in a Bash script. Here is a basic example of a service:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: OpenRC使用与我们在本章前面提到的SysV `init`非常相似的方式来定义服务操作。像`start`、`stop`、`restart`和`status`这样的命令是在Bash脚本中定义的。以下是一个基本的服务示例：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To create a new service, you can copy this file to a new file and modify the
    `name`, `description`, `start`, `stop`, and `restart` functions as needed. The
    `start` function should contain the command to start the service, the `stop` function
    should contain the command to stop the service, and the `restart` function should
    stop and start the service. Those can be the same as for SysV `init`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的服务，可以将此文件复制到新文件并根据需要修改`name`、`description`、`start`、`stop`和`restart`函数。`start`函数应包含启动服务的命令，`stop`函数应包含停止服务的命令，`restart`函数应停止并重新启动服务。它们可以与SysV
    `init`中的相同。
- en: In OpenRC, `init` scripts are typically stored in the `/etc/init.d` directory.
    These are scripts that are used to start and stop services and manage the system’s
    runlevels.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在OpenRC中，`init`脚本通常存储在`/etc/init.d`目录中。这些脚本用于启动和停止服务以及管理系统的运行级别。
- en: To create a new `init` script for OpenRC, you can create a new file in the `/etc/init.d`
    directory and make it executable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要为OpenRC创建一个新的`init`脚本，可以在`/etc/init.d`目录中创建一个新文件并使其可执行。
- en: 'Once you have created your `init` script, you can use the `rc-update` command
    to add it to the default runlevel, which will cause the service to start at boot.
    For example, to add the `exampleservice` service to the default runlevel, you
    can run the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`init`脚本后，可以使用`rc-update`命令将其添加到默认运行级别，这将导致服务在启动时启动。例如，要将`exampleservice`服务添加到默认运行级别，可以运行以下命令：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In most cases, we’ll be using Alpine Linux in a Docker environment where there’s
    little use for OpenRC, but it’s still useful to know for some edge-case usage.
    We will look at Docker in more detail in [*Chapter 8*](B18197_08.xhtml#_idTextAnchor166)
    and [*Chapter 9*](B18197_09.xhtml#_idTextAnchor245).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们将在Docker环境中使用Alpine Linux，在这种环境下OpenRC的使用不多，但它仍然对某些边缘案例的使用有所帮助。我们将在[*第8章*](B18197_08.xhtml#_idTextAnchor166)和[*第9章*](B18197_09.xhtml#_idTextAnchor245)中更详细地讨论Docker。
- en: In this section, we have looked at OpenRC, software that controls system services
    in Alpine Linux. In the next section, we are going to introduce, very shortly,
    an outdated form of SysV `init`, which may come up with older or minimal Linux
    distributions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经介绍了OpenRC，它是管理Alpine Linux中系统服务的软件。在下一节中，我们将简要介绍一种过时的SysV `init`形式，这种形式可能出现在较老或最小化的Linux发行版中。
- en: SysV init
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SysV init
- en: As previously mentioned, the `init` process is the most important continuously
    running process in the system. It’s responsible for starting system services when
    the system boots up or when an administrator requests it, and stopping system
    services when the system is shutting down or when requested, all in the proper
    order. It’s also responsible for restarting services on request. Since `init`
    will execute code on behalf of the root user, it is imperative that it’s well
    tested for stability and security risks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`init`进程是系统中最重要的、持续运行的进程。它负责在系统启动时或管理员请求时启动系统服务，在系统关机时或请求时停止系统服务，且按正确的顺序执行。它还负责在请求时重新启动服务。由于`init`将代表root用户执行代码，因此必须确保其经过充分的稳定性和安全性测试。
- en: One of the charming properties of the old `init` system was its simplicity.
    The starting, stopping, and restarting of a service was managed by a script—one
    that had to be written by either the application author, the distribution package
    owner for this application, or the system administrator—if the service was not
    installed from packages. The scripts were simple and easy to understand, write,
    and debug.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的`init`系统的一个迷人特点是它的简单性。服务的启动、停止和重启是通过脚本来管理的——这些脚本必须由应用程序作者、该应用程序的发行版包所有者或系统管理员编写——如果该服务不是通过包安装的。脚本简单且易于理解、编写和调试。
- en: The more the complexity of software grew, however, the more the old `init` system
    showed its age. Starting up a simple service was okay. Starting up an application
    consisting of several programs grew more difficult, especially as the dependencies
    between them became more important. `init` lacks observation of dependencies of
    startup of the services it takes care of.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，随着软件复杂性的增加，旧的`init`系统的局限性变得越来越明显。启动一个简单的服务还可以，但启动由多个程序组成的应用变得更加困难，尤其是当它们之间的依赖关系变得更加重要时。`init`缺乏对它所管理的服务启动依赖关系的观察。
- en: 'Another place where the old `init` system became more and more unfit for modern
    systems was serial startup: it was unable to start services in parallel, thus
    negating modern multicore CPU gains. The time was nigh to look for a system more
    fit to the new times.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的`init`系统越来越不适合现代系统的另一个原因是串行启动：它无法并行启动服务，从而抵消了现代多核CPU的优势。是时候寻找一个更适合新时代的系统了。
- en: 'A typical `init` system consists of several components, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的`init`系统由以下几个组件组成：
- en: A `/etc/init.d` or `/etc/rc.d/init.d` directory that contains start/stop scripts.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含启动/停止脚本的`/etc/init.d`或`/etc/rc.d/init.d`目录。
- en: A `/etc/inittab` file that defines runlevels and sets up a default one.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`/etc/inittab`文件，用于定义运行级别并设置默认的运行级别。
- en: A `/etc/rcX.d` directory that contains all the scripts for services that should
    be started or stopped in the runlevel `X`, where `X` is a number from `0` (zero)
    to `6`. We will get to the details in the next paragraph.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`/etc/rcX.d`目录，包含所有应在运行级别`X`中启动或停止的服务的脚本，其中`X`是从`0`（零）到`6`的数字。我们将在下一段中详细介绍。
- en: 'The `/etc/init.d/` directory contains shell scripts responsible for starting,
    stopping, and restarting services. The script accepts a single argument of either
    `start`, `stop`, or `restart`. Each argument passed to the script executes a proper
    function (usually named the same as the argument: `start`, `stop`, or `restart`),
    and the function runs a set of steps to properly start, stop, or restart the given
    service. The kind of final state of the start process that the system ends up
    in is called a **runlevel**. The runlevel determines whether services are being
    started or stopped and which of them are being started if this is the course of
    action.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`/etc/init.d/` 目录包含用于启动、停止和重启服务的 Shell 脚本。该脚本接受一个参数，可以是 `start`、`stop` 或 `restart`。传递给脚本的每个参数都会执行相应的函数（通常函数名称与参数相同：`start`、`stop`
    或 `restart`），该函数会执行一系列步骤来正确启动、停止或重启指定的服务。系统最终进入的启动过程的最终状态被称为**运行级别**。运行级别决定了服务是否正在启动或停止，并且如果是启动服务，哪些服务会被启动。'
- en: To determine the type of action to call, a link to the script would be created
    in the directory related to the runlevel in question.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定要调用的操作类型，会在与相关运行级别相对应的目录中创建一个指向脚本的链接。
- en: Let’s assume we want the system to end up in runlevel `3`. If we want our service
    to be started in this runlevel, we would create a link to the `/etc/rc.d/my_service`
    script pointing to the `/etc/rc3.d/` directory. The name of the link determines
    the type of action and the order. So, if we wanted the service to be started after
    numbers `01`-`49`, we would call it `/etc/rc.3/S50my_service`. The letter `S`
    tells the `init` system to start the service, and the number `50` tells it to
    start it after all services with lower numbers have been started. Please note
    that the numbering is more of a framework. It is not guaranteed that there are
    scripts with all other numbers prior to `50`. The same goes for stopping services.
    After determining which runlevel is the default for stopping the system (usually
    `0`), a proper `symlink` is created for the service script.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望系统最终进入运行级别 `3`。如果我们希望在该运行级别启动我们的服务，我们会创建一个指向 `/etc/rc.d/my_service` 脚本的链接，该链接指向
    `/etc/rc3.d/` 目录。链接的名称决定了操作的类型和顺序。因此，如果我们希望服务在 `01` 到 `49` 之间的数字之后启动，我们会将其命名为
    `/etc/rc.3/S50my_service`。字母 `S` 告诉 `init` 系统启动该服务，数字 `50` 告诉它在所有较低数字的服务启动之后再启动该服务。请注意，编号更多的是一种框架，并不能保证在
    `50` 之前有所有其他数字的脚本。停止服务也是如此。在确定停止系统的默认运行级别后（通常是 `0`），会为服务脚本创建一个适当的 `symlink`。
- en: The major problem with the preceding framework is that it’s totally unaware
    of dependencies. The only way to ensure that the services on which your daemon
    depends are running is to script it around in your `start` function. In the case
    of more complex applications comprising many services, this may lead to bigger
    start/stop scripts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 前述框架的主要问题在于它完全没有考虑依赖关系。确保守护进程所依赖的服务正在运行的唯一方法是将其脚本化，放入 `start` 函数中。在包含多个服务的复杂应用程序中，这可能会导致更大的启动/停止脚本。
- en: Another issue with `init` scripts being raised by admins and developers was
    that there are multiple standards on how to write them and multiple different
    tools around `init` scripts. Basically, every major Linux distribution had its
    own way of writing those scripts and its own library of helper functions. Let’s
    consider an `init` script starting the same `My Service` service on Slackware
    Linux and Debian/GNU Linux. This is also where the introductory chapter on writing
    shell scripts comes in handy.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员和开发人员提出的另一个与 `init` 脚本相关的问题是，关于如何编写这些脚本有多个标准，并且有多种不同的工具与 `init` 脚本相关。基本上，每个主要的
    Linux 发行版都有自己编写这些脚本的方式和自己的辅助函数库。我们来看看在 Slackware Linux 和 Debian/GNU Linux 上启动相同的
    `My Service` 服务的 `init` 脚本。这也是编写 Shell 脚本的入门章节派上用场的地方。
- en: In both cases, Slackware and Debian, we are going to cut some original content
    out for brevity, leaving only the most important parts. Do not worry as both distributions
    deliver wholly commented example scripts.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Slackware 和 Debian 两种情况下，为了简洁起见，我们将删去一些原始内容，只保留最重要的部分。请不用担心，因为这两种发行版都提供了完全注释的示例脚本。
- en: 'The following `init` script will work in a Slackware Linux environment. The
    script starts with a header where we declare the name of the service and some
    important paths:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的 `init` 脚本将在 Slackware Linux 环境中工作。脚本以头部开始，我们在头部声明服务名称和一些重要的路径：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The good thing is that an example script delivered with Slackware is very well
    commented. We have to declare a path to the binary for the daemon. We also have
    to declare the user and group that the service will run as, effectively deciding
    filesystem permissions for it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 好的一点是，Slackware 提供的示例脚本有很好的注释。我们需要声明守护进程的二进制文件路径。我们还需要声明服务将以哪个用户和组身份运行，这实际上决定了它的文件系统权限。
- en: 'The next section defines all important actions for the service: `start`, `stop`,
    `and restart`. There are usually a few others, but we have cut them out for brevity:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分定义了服务的所有重要操作：`start`、`stop` 和 `restart`。通常会有其他操作，但为了简洁我们将其省略：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `start` function checks whether the service is running utilizing the `pid`
    file. The `pid` file is a text file that contains the PID of the service. It gives
    information about both the main process of the service and its status. There is
    a caveat, however. It is possible that the service isn’t running anymore and the
    `pid` file still exists. That would prevent the `start` function from actually
    starting the service.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 函数利用 `pid` 文件检查服务是否正在运行。`pid` 文件是一个包含服务 PID 的文本文件。它提供关于服务主进程及其状态的信息。然而有一个问题，服务可能已经停止运行，但
    `pid` 文件仍然存在。这会导致 `start` 函数无法实际启动服务。'
- en: After the check determines that the `pid` file doesn’t exist, which means that
    the service is not running, a special tool called `daemon` is used to start the
    process with user and group permissions, pointing to a configuration file, log
    file, and `pid` file locations.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查到 `pid` 文件不存在后，这意味着服务没有运行，一个名为 `daemon` 的特殊工具被用来以用户和组权限启动进程，并指向配置文件、日志文件和
    `pid` 文件的位置。
- en: 'The function communicates its actions using the `bash echo` command, which
    prints the given text. In case of automatic execution, the output of the `echo`
    command will be logged to system logs depending on the logging `daemon` configuration:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过 `bash echo` 命令来传达它的操作，`echo` 命令会打印出给定的文本。如果是自动执行，`echo` 命令的输出将根据日志 `daemon`
    配置记录到系统日志中：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Again, the `stop` function checks whether the service is running using the
    `pid` file. The probability of the service running without a proper `pid` file
    is almost nonexistent. After the check is done, a special command called `killproc`
    is used to terminate the process. In the final part of the function, the script
    does some housekeeping tasks, cleaning the `pid` file and the `lock` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`stop` 函数使用 `pid` 文件检查服务是否正在运行。没有 `pid` 文件而服务仍在运行的可能性几乎为零。检查完成后，一个名为 `killproc`
    的特殊命令被用来终止该进程。在函数的最后部分，脚本执行一些清理任务，清除 `pid` 文件和 `lock` 文件：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `restart` function is very simple. It reuses the already defined `start`
    and `stop` functions to do exactly what it says: restart the service. This is
    often useful if the service configuration requires the binary to be loaded again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`restart` 函数非常简单。它重用已经定义的 `start` 和 `stop` 函数，准确执行它所说的：重启服务。如果服务配置需要重新加载二进制文件，这通常很有用：'
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The final part of the script evaluates the action we want to take—start, stop,
    or restart the service—and calls the proper function. If we ask it to do something
    it doesn’t recognize, the script will print out usage instructions.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的最后部分评估我们想要执行的操作——启动、停止或重启服务——并调用相应的函数。如果我们要求它执行一个它不识别的操作，脚本会打印出使用说明。
- en: 'The following script, however, is intended for a Debian Linux environment:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下脚本是为 Debian Linux 环境设计的：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Again, the script starts with a header section that defines paths to be later
    used in the `start` and `stop` sections. Normally there are more lines, but we’ve
    cut them out for brevity, again:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，脚本以一个头部部分开始，定义了稍后将在 `start` 和 `stop` 部分使用的路径。通常会有更多的行，但为了简洁，我们将它们省略了：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `start` function looks similar to the one from the Slackware version. You’ll
    notice some subtle differences, however, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 函数与 Slackware 版本中的类似。但你会注意到一些微妙的差异，如下所示：'
- en: The `start-stop-daemon` helper function is being used here to manage the running
    service instead of `daemon` and `killproc`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里使用了`start-stop-daemon`辅助函数来管理运行中的服务，而不是使用`daemon`和`killproc`。
- en: 'There are specialized functions for logging instead of simple echo: `log_daemon_msg`,
    `log_failure_msg`, and `log_end_msg`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里使用了专门的日志记录函数，而不是简单的 echo：`log_daemon_msg`、`log_failure_msg` 和 `log_end_msg`。
- en: 'The `start-stop-daemon` function accepts special flags to determine the action
    (`start` and `stop`) as well as detaching the program from the terminal, making
    it effectively a system service (`--background`), as seen here:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start-stop-daemon`函数接受特殊标志来确定操作（`start`和`stop`），并将程序从终端中分离，使其有效地成为系统服务（`--background`），如下面所示：'
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `stop` function is pretty similar to the `stop` function from Slackware,
    with similar differences to those the `start` function had.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`stop`函数与Slackware的`stop`函数非常相似，具有与`start`函数相似的差异。'
- en: The rest of the script containing the `restart` function and the task evaluation
    is not that interesting, and we’ve cut it out.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的脚本包含`restart`函数和任务评估部分并不太有趣，因此我们已将其省略。
- en: As you probably still remember from the section about `systemd`, it solves some
    of those problems. SysV is not seen too often in modern systems, so you will most
    commonly need to deal with `systemd` instead.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能还记得在关于`systemd`的章节中提到的，它解决了其中的一些问题。SysV在现代系统中不常见，因此你通常需要处理的是`systemd`。
- en: There is, however, another replacement for SysV `init` called Upstart.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有另一个替代SysV `init`的工具，叫做Upstart。
- en: A few words about Upstart, an alternative
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Upstart，一种替代方案，简要说明
- en: Upstart is an event-based replacement for the traditional SysV `init` system
    used to manage and control services and daemons on a system. Upstart was introduced
    in Ubuntu `6.10` and later versions and is designed to improve boot time, simplify
    system configuration, and provide more flexibility in managing system services.
    It has now been largely replaced by `systemd` in most Linux distributions.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Upstart是一个基于事件的替代方案，替代传统的SysV `init`系统，用于管理和控制系统上的服务和守护进程。Upstart在Ubuntu `6.10`及其后续版本中被引入，旨在提高启动时间，简化系统配置，并提供更灵活的系统服务管理方式。现在，它已在大多数Linux发行版中被`systemd`取代。
- en: Upstart is used to manage the initialization process of the system and to start,
    stop, and supervise tasks and services. It is designed to be more flexible and
    efficient than the traditional `init` daemon and to provide more information about
    the status of tasks and services.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Upstart用于管理系统的初始化过程，并启动、停止和监督任务与服务。它设计上比传统的`init`守护进程更灵活高效，并提供关于任务和服务状态的更多信息。
- en: All that can be managed by `systemd` and/or `cron` has become an industry standard,
    so if you don’t have a good reason for using those or already have a system using
    Upstart, we discourage you from using it as a default.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可以由`systemd`和/或`cron`管理的内容已成为行业标准，所以如果没有充分的理由使用它们，或者你已经有一个使用Upstart的系统，我们不建议你将其作为默认选择。
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered system services—or daemons in the Unix and Linux
    world—and the software most often used to manage them. We explained what those
    are, how to inspect their state, and how to control them. In the next chapter,
    we are going to dive into Linux networking.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了系统服务——即Unix和Linux世界中的守护进程——以及最常用的管理它们的软件。我们解释了这些是什么，如何检查它们的状态，以及如何控制它们。在下一章中，我们将深入探讨Linux网络。
