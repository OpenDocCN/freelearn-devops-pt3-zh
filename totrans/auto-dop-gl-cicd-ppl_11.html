<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer130">
			<h1 id="_idParaDest-257" class="chapter-number"><a id="_idTextAnchor268"/>11</h1>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor269"/>End-to-End Example</h1>
			<p>By now, you’ve seen how the different parts of GitLab help you write, review, verify, secure, package, and deploy software. These features have been presented one at a time, so let’s put them all together in a single end-to-end example so you can see the whole process in one fell swoop. There won’t be any new material in this chapter, so it will be a great chance to review what you’ve learned in earlier chapters and see it all consolidated in one <span class="No-Break">extended workflow.</span></p>
			<p>This chapter is broken into many subsections, each showing how to use GitLab to help with a different part of the software development <span class="No-Break">life cycle:</span></p>
			<ul>
				<li>Setting up <span class="No-Break">your environment</span></li>
				<li><span class="No-Break">Writing code</span></li>
				<li>Establishing the <span class="No-Break">pipeline infrastructure</span></li>
				<li>Verifying <span class="No-Break">your code</span></li>
				<li>Securing <span class="No-Break">your code</span></li>
				<li>Improving <span class="No-Break">your pipeline</span></li>
				<li>Delivering your code to the <span class="No-Break">right environment</span></li>
			</ul>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor270"/>Technical requirements</h1>
			<p>If you’d like to follow along as we develop a piece of software with GitLab, all you need is an account on a GitLab instance, whether Software-as-a-Service (SaaS) <span class="No-Break">or self-hosted.</span></p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor271"/>Setting up your environment</h1>
			<p>Before you start writing any<a id="_idIndexMarker766"/> code, you need to organize a few preliminary things. Specifically, you need to make a GitLab project for storing your code and running your pipelines, you need to make some GitLab issues to help plan and track your work, and you need to clone the project’s repository to your local computer so that you can write code using your favorite IDE instead of entirely within the <span class="No-Break">GitLab GUI.</span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor272"/>Making a GitLab project</h2>
			<p>Let’s rewind to the <a id="_idIndexMarker767"/>beginning of our journey with the Hats for Cats web app. We know we want to make a web app for our online feline accessories store, so let’s start by making a GitLab project to hold not only our web app’s code but<a id="_idIndexMarker768"/> also the additional GitLab components that we’ll be using as we build <span class="No-Break">the app.</span></p>
			<p class="callout-heading">A note about the GUI</p>
			<p class="callout">Throughout this chapter, we’ll continue our practice of showing you code snippets but generally not showing the steps for using the GitLab GUI. This is because we want to avoid having the screenshots drift away from reality as the GitLab GUI changes in <span class="No-Break">future releases.</span></p>
			<p>We could make a Hats for Cats project directly within the top-level namespace of our GitLab account, but it seems likely that we’ll want to make more projects in the future—perhaps for other web apps, perhaps for other versions of the web app aimed at different platforms—so first, let’s make a GitLab group to hold all of our projects. Let’s pretend that our company is called Acme Software, so we’ll start with a group called, unsurprisingly, <span class="No-Break">Acme Software:</span></p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B18073_11_1.jpg" alt="Figure 11.1 – The Acme Software group" width="1482" height="645"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – The Acme Software group</p>
			<p>Within this group, we can add a new project that holds the Hats for Cats web app. Let’s call it <strong class="source-inline">Hats for Cats</strong>, and let’s choose the <strong class="bold">Create blank project</strong> option rather than creating it from a project template. This means that it will begin its life with a boilerplate <strong class="source-inline">README.md</strong> file in its <a id="_idIndexMarker769"/>Git repository, but nothing else. Here’s <a id="_idIndexMarker770"/>what the new project looks like immediately <span class="No-Break">after creation:</span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B18073_11_2.jpg" alt="Figure 11.2 – The Hats for Cats project" width="1206" height="625"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – The Hats for Cats project</p>
			<p>As you already know, this project will hold not only the code for our web app but also the configuration file for our CI/CD<a id="_idIndexMarker771"/> pipeline, branches and <strong class="bold">Merge Requests</strong> (<strong class="bold">MRs</strong>) related to our code, packaged bits of code ready for deployment, and issues to help us plan and track our work. That leads nicely into the next step of our workflow: creating <span class="No-Break">GitLab issues.</span></p>
			<p class="callout-heading">Placing all projects within a group</p>
			<p class="callout">For technical reasons, the screenshots in the rest of this chapter show the <strong class="bold">Hats for Cats</strong> project directly under the user’s account instead of within the <strong class="bold">Acme Software</strong> group. However, the best practice is to create all of your company or organization’s projects within a single <span class="No-Break">master group.</span></p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor273"/>Planning work with GitLab issues</h2>
			<p>Using GitLab issues to<a id="_idIndexMarker772"/> plan and track your work is an<a id="_idIndexMarker773"/> optional but highly recommended part of writing software with GitLab. You can, of course, use other tools such as Jira or Trello to map out your work, but many developers find that GitLab issues give them all the power they need for standard project <span class="No-Break">management tasks.</span></p>
			<p>GitLab projects for non-trivial pieces of software might contain tens, hundreds, or, in extreme cases, thousands of issues—for instructional purposes, let’s create just four issues for our project. To<a id="_idIndexMarker774"/> build the <strong class="bold">minimum viable product</strong> (<strong class="bold">MVP</strong>) for our web app, let’s make issues with <span class="No-Break">these titles:</span></p>
			<ul>
				<li><strong class="source-inline">Allow user to </strong><span class="No-Break"><strong class="source-inline">log in</strong></span></li>
				<li><strong class="source-inline">Allow user to </strong><span class="No-Break"><strong class="source-inline">search inventory</strong></span></li>
				<li><strong class="source-inline">Allow user to buy </strong><span class="No-Break"><strong class="source-inline">a hat</strong></span></li>
				<li><strong class="source-inline">Allow user to </strong><span class="No-Break"><strong class="source-inline">log out</strong></span></li>
			</ul>
			<p>Once those are in place, let’s think about GitLab labels. Some teams use multiple labels on each issue to indicate ownership, assign priority, or perform other administrative functions. Let’s create and assign an unscoped <strong class="bold">security</strong> label to show that the login and log-out issues need extra scrutiny from our security team. Let’s also make scoped <strong class="bold">priority::high</strong> and <strong class="bold">priority::low</strong> labels to indicate which features should be worked on first and which came come later. For now, just assign <strong class="bold">priority::high</strong> to the login issue—we’ll decide as a team later what priority labels to give to the rest of <span class="No-Break">the issues.</span></p>
			<p>Next, let’s tackle the metadata for the login issue, which is the feature we want to develop first. We open that issue, assign it to a developer, set the <strong class="bold">Weight</strong> field to <strong class="bold">5</strong> (which, after some discussion, we decide is a reasonable weight for a medium-sized task), use a quick action to estimate that it will take 15 hours of work to complete, and set a due date. Setting metadata at the same time that the issue is created is a practice that you often see among teams that use the Kanban workflow; if we were using the Scrum workflow, we might have saved assigning a due date, weight, or estimated hours until the next backlog <span class="No-Break">grooming ceremony.</span></p>
			<p>After creating these four issues, creating and assigning appropriate labels, and filling in metadata for one issue, clicking <strong class="bold">Issues</strong> | <strong class="bold">List</strong> in the left-hand navigation pane should show som<a id="_idTextAnchor274"/>ething like this. Notice<a id="_idIndexMarker775"/> that the metadata is displayed right in the issue list, which <span class="No-Break">is handy:</span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B18073_11_3.jpg" alt="Figure 11.3 – Hats for Cats issues and issue metadata" width="1478" height="635"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Hats for Cats issues and issue metadata</p>
			<p>You’re done with getting <a id="_idIndexMarker776"/>your GitLab environment set up: you’ve created a GitLab group, made a GitLab project inside it, and made some issues to work against. Now, you’re ready to start writing code and storing it in <span class="No-Break">that project.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor275"/>Setting up a local Git repository</h2>
			<p>Although we <em class="italic">could</em> do all of <a id="_idIndexMarker777"/>our development work within the GitLab instance, that would make writing code difficult and testing<a id="_idIndexMarker778"/> impossible. Instead, let’s clone the repository to a local computer so that we can develop using whatever desktop IDEs or other tools we’re most <span class="No-Break">comfortable with.</span></p>
			<p>First, we need to make sure that we’ve generated a public/private key pair on our workstation and uploaded the public key to our GitLab account. This only needs to be done once for any GitLab instance we’re working with, so let’s assume that we’ve already taken care of this. The GitLab documentation has more information about <span class="No-Break">this process.</span></p>
			<p>Next, we need to grab the address that we’ll use to clone the <strong class="bold">Hats for Cats</strong> project’s repository. Since we’re using key-based security instead of manually entering authentication credentials with every Git command, we copy the project’s SSH address using the GUI, and then clone it by running this command on our local machine (if you’re following along at home, you’ll see a slightly different address based on your GitLab <span class="No-Break">account name):</span></p>
			<pre class="console">
git clone git@gitlab.com:acme-software/hats-for-cats.git</pre>
			<p>We can then move into the directory created by the clone operation and look around. If everything has worked as <a id="_idIndexMarker779"/>expected, we should see local copies of the same files that exist in the GitLab-hosted copy of the repository—which at this point is just one <span class="No-Break"><strong class="source-inline">README.md</strong></span><span class="No-Break"> file:</span></p>
			<pre class="console">
~$ cd hats-for-cats
~/hats-for-cats$ ls
README.md</pre>
			<p>Now, we’re all set to do local development, push any changes we make up to the copy of the repository on GitLab, and pull down any changes that coworkers have <span class="No-Break">pushed up.</span></p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor276"/>Writing code</h1>
			<p>You’re almost at the point where you can start coding. First, you’ll need a Git branch to commit the code to. Then, you’ll need a MR so that you can see the results of pipeline tasks that run against that code, and <a id="_idIndexMarker780"/>also so that you can eventually merge the code into the <strong class="source-inline">main</strong> branch. Let’s go over those steps, and then make and push your <span class="No-Break">first commit.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor277"/>Creating a Git branch to work on</h2>
			<p>Now that we’re ready to<a id="_idIndexMarker781"/> add the login feature requested by our first assigned issue, we need a Git branch to commit to. We might as well name our branch after the title of the issue we’re <span class="No-Break">working on:</span></p>
			<pre class="console">
git branch add-login-feature</pre>
			<p>Switch onto the new branch so any new commits end up on that branch and not on the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> branch:</span></p>
			<pre class="console">
git checkout add-login-feature</pre>
			<p>At this point, we might as well push this branch up to the GitLab-hosted copy of the repository so that it exists in both <a id="_idIndexMarker782"/>places. For the first push, we need to use a slightly <span class="No-Break">longer command:</span></p>
			<pre class="console">
git push --set-upstream origin add-login-feature</pre>
			<p>For subsequent pushes, after we’ve added some commits, we can rely on a <span class="No-Break">simpler command:</span></p>
			<pre class="console">
git push</pre>
			<p>If we look at the project’s repository in GitLab, we can see that it now lists <strong class="bold">add-login-feature</strong> within the dropdown of the <span class="No-Break">project’s branches.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor278"/>Creating an MR</h2>
			<p>Let’s follow GitLab best practices <a id="_idIndexMarker783"/>and immediately make an MR associated with the branch we just created. Navigate to <strong class="bold">Ns</strong> in the left-hand navigation pane <a id="_idIndexMarker784"/>and click on <strong class="bold">New merge request</strong>. Select <strong class="bold">add-login-feature</strong> as the source branch and <strong class="bold">main</strong> as the target branch, and click <strong class="bold">Compare branches </strong><span class="No-Break"><strong class="bold">and continue</strong></span><span class="No-Break">.</span></p>
			<p>Title the MR <strong class="source-inline">Draft: add login feature</strong> and add <strong class="source-inline">Closes #X</strong> in the description field, where <strong class="source-inline">X</strong> is replaced by the number of the <strong class="bold">Allow user to log in</strong> issue (tip: as soon as you type <strong class="source-inline">#</strong> in the description, the GUI will present you with a dropdown showing all the issues you’ve created, so you don’t need to look up the issue number manually). Now, we’ve created the “three amigos” of issue, branch, and MR, so we’re ready to get to work developing <span class="No-Break">our feature.</span></p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor279"/>Committing and pushing code</h2>
			<p>It’s time to write some code! Instead of <a id="_idIndexMarker785"/>writing an actual login page with real GUI elements and logic, let’s use our local computer to make a file called <strong class="source-inline">login.py</strong> in the root of the <strong class="bold">add-login-feature</strong> branch of our project’s Git repository. Populate that file with placeholder code, such as <strong class="source-inline">print("Welcome to Hats for Cats!")</strong>. Since we’re doing this on our local computer rather than on GitLab, we need to use Git <a id="_idIndexMarker786"/>terminal commands or a GUI tool for Git (such as <strong class="bold">Sourcetree</strong> or <strong class="bold">Tower</strong>, or the Git<a id="_idIndexMarker787"/> tools built into IDEs such as <strong class="bold">IntelliJ IDEA</strong> or <strong class="bold">Visual Studio Code</strong>) to add our new file to the Git staging area and then commit it with an appropriate message. Perform these operations on the command line <span class="No-Break">like this:</span></p>
			<pre class="console">
git add login.py
git commit -m "add initial version of log in page"</pre>
			<p>It’s important to reiterate <a id="_idIndexMarker788"/>at this point that the local commit will <em class="italic">not</em> trigger a CI/CD pipeline. The GitLab instance doesn’t know that the commit exists, and even if it did, it doesn’t have any way of seeing the code included in that commit. However, as soon as we push any local commits up to GitLab, it will detect those commits in its own copy of the repository and run a pipeline against whatever commits we <span class="No-Break">pushed up.</span></p>
			<p>Let’s push the <strong class="bold">add-login-feature</strong> <span class="No-Break">branch now:</span></p>
			<pre class="console">
git push</pre>
			<p class="callout-heading">Pushing frequently is important!</p>
			<p class="callout">We could have waited to push this branch until we had made several local commits to it, but since much of the power of GitLab’s CI/CD pipelines comes from having them run frequently against small code changes, it’s usually wisest to push after every <span class="No-Break">local commit.</span></p>
			<p>This was such a simple edit—adding a single file that contains a single line of code—that you might be wondering why we didn’t just make the edit and commit the change within the GitLab GUI instead of going through the hassle of editing and committing locally and then pushing that edit up to GitLab. Honestly, with a change this small, we could easily have gotten away with performing the edit right on GitLab. If this were a real-world project, that’s exactly what we would advise you to do, but since most development work is quite a bit more complicated than the placeholder code included here, we thought it would be helpful to show you the typical <em class="italic">edit-and-commit-locally-and-then-push</em> workflow that <a id="_idTextAnchor280"/>you’ll be using for most of your <span class="No-Break">development work.</span></p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor281"/>Establishing the pipeline infrastructure</h1>
			<p>You’ve stored some code in the repository, so now it’s time to set up a pipeline to run a variety of tasks to build, verify, and secure <a id="_idIndexMarker789"/>your code. In some cases, you might also want to set up a GitLab Runner to execute those pipeline tasks, although that task is usually taken care of for you by your GitLab administrator or the GitLab <span class="No-Break">SaaS platform.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor282"/>Creating a pipeline</h2>
			<p>Pushing commits to GitLab so that it can run CI/CD pipelines on our new code won’t work unless we define what tasks<a id="_idIndexMarker790"/> we’d like our pipeline to perform. We’ll add several tasks to our <strong class="bold">Hats for Cats</strong> project’s pipeline as we go through the rest of this chapter, but for now, let’s get a bare-bones pipeline <span class="No-Break">in place.</span></p>
			<p>Just as we did with our initial file, we could create the <strong class="source-inline">.gitlab-ci.yml</strong> pipeline configuration file locally, commit it, and push it up to GitLab, but since the GitLab GUI offers a handy editor dedicated to writing and debugging pipeline configuration files, it often makes more sense to edit it on GitLab. Having a local copy of <strong class="source-inline">.gitlab-ci.yml</strong> isn’t important since we can’t use it to run pipelines on our local <span class="No-Break">machine anyway.</span></p>
			<p>In the left-hand navigation pane, select <strong class="bold">CI/CD</strong> | <strong class="bold">Editor</strong> to fire up the dedicated pipeline editor, select the <strong class="bold">add-login-feature</strong> branch from the dropdown, and create a new <strong class="source-inline">.gitlab-ci.yml</strong>. At this point, we’re not sure what stages we’re going to end up needing in our pipeline. It could be reasonably argued that there’s no point defining stages until you actually need them, but we’re fairly confident that we’ll need the basic trio of <strong class="source-inline">build</strong>, <strong class="source-inline">test</strong>, and <strong class="source-inline">deploy</strong>, so in the interest of fleshing out this example, let’s add all three <span class="No-Break">right now:</span></p>
			<pre class="console">
stages:
    - build
    - test
    - deploy</pre>
			<p>Since Python is an interpreted rather than compiled language, we don’t have any jobs to define within the <strong class="source-inline">build</strong> stage yet. We also haven’t written any automated tests yet, so there’s no point in adding jobs to execute tests. We’ll want to run some security scans and do other verification tasks, but we’ll define those jobs later. We’re also going to need to deploy our code to various environments, but that too will be tackled down the road. For now, let’s just add a dummy job so that GitLab doesn’t complain about the lack of any job definitions in our pipeline (if we didn’t, GitLab would actually consider the pipeline configuration file to be malformed, and the linter that appears at the top of the dedicated editor would squawk at us). Paste this below the <span class="No-Break"><strong class="source-inline">stages:</strong></span><span class="No-Break"> section:</span></p>
			<pre class="console">
# temporary job that we'll delete later
job1:
    stage: build
    script:
        - echo "in job1"</pre>
			<p>After committing this change, we navigate to <strong class="bold">CI/CD</strong> | <strong class="bold">Pipelines</strong> in the GitLab GUI to confirm that the pipeline ran—it should have triggered automatically when we committed the changes to <strong class="source-inline">.gitlab-ci.yml</strong>—and that it executed <strong class="source-inline">job1</strong> on a shared runner without any <a id="_idIndexMarker791"/>problems. Of course, if you’re working on a GitLab instance that doesn’t offer any shared runners, you’ll need to create your own runners for this project before the pipeline will run. Fortunately, that’s the very next step in <span class="No-Break">our workflow.</span></p>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor283"/>Creating a runner</h2>
			<p>As you know, users of the<a id="_idIndexMarker792"/> SaaS version of GitLab can run their pipelines on the GitLab Runners provided as part of their software subscription, but if you’re using a self-hosted version of GitLab, or if you want to run some pipelines on your own hardware to avoid exhausting your subscription’s GitLab Runner minutes, you’ll want to set up one or more of your own GitLab Runners. Let’s create some specific runners that are dedicated to our <strong class="bold">Hats for </strong><span class="No-Break"><strong class="bold">Cats</strong></span><span class="No-Break"> project.</span></p>
			<p>We decide to create runners on a spare Linux box that’s lying around. Remembering that the versions of the GitLab Runner binary that’s included in major Linux distribution repositories are often a few versions old, we consult the GitLab documentation to find out how to add the official GitLab repository to our Linux box’s package management system, download the latest GitLab Runner binary, install it as a service, and make sure it’s running. Since the exact process for this varies by the operating system and Linux distribution, we won’t include explicit <span class="No-Break">instructions here.</span></p>
			<p class="callout-heading">GitLab Runner versions</p>
			<p class="callout">Although GitLab Runners usually work even when they are a few minor versions away from the version of the GitLab instance (15.0 vs. 15.3, for example), they will operate most reliably if you keep the two versions <span class="No-Break">in sync.</span></p>
			<p>Once the <strong class="source-inline">gitlab-runner</strong> binary is<a id="_idIndexMarker793"/> installed on the computer that will host the runners, we need to create runners by registering them. Before doing so, we need to collect some information. We’ve already decided that the runners will be specific to the <strong class="bold">Hats for Cats</strong> project, so we navigate to <strong class="bold">Settings</strong> | <strong class="bold">CI/CD</strong> | <strong class="bold">Runners</strong> and make note of both the GitLab instance’s URL and the project’s registration token, as displayed on that screen. Let’s say that we’re using a self-hosted GitLab instance at <a href="https://gitlab.hats-for-cats.com">https://gitlab.hats-for-cats.com</a>, and that the registration token for the <strong class="bold">Hats for Cats</strong> project <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">abc123</strong></span><span class="No-Break">.</span></p>
			<p>We decide to register two runners. We could call them anything we want, but we settle on the most obvious naming scheme: <strong class="bold">Hats for Cats 1</strong> and <strong class="bold">Hats for </strong><span class="No-Break"><strong class="bold">Cats 2</strong></span><span class="No-Break">.</span></p>
			<p>Next, we choose to use the Docker executor with both runners since that gives them the most flexibility: they can handle any CI/CD pipeline job because they can execute jobs within a Docker image that has all of the required tools already installed. We decide to specify <strong class="source-inline">alpine:latest</strong> as the default Docker image that the runners will use for jobs that don’t specify an image since that’s the smallest full-featured Linux distribution and therefore the quickest to download. Finally, we decide not to add any tags to the runners since we don’t intend either runner to be special-purpose in <span class="No-Break">any way.</span></p>
			<p>Of course, we can’t register runners with the Docker executor unless Docker is installed and running on the machine that’s hosting the runners. Installation instructions for Docker change occasionally and vary according to the operating system, so the official Docker documentation is your best source of information for <span class="No-Break">this step.</span></p>
			<p>Once Docker is up and running on the same host machine as the runners we could register a single runner interactively with <strong class="source-inline">gitlab-runner register</strong>, but in this case, let’s register the runners non-interactively by passing in all the details as options to a single terminal command. We register the first runner using this command on the Linux box that will host the runners (changing the <strong class="source-inline">--url</strong> and <strong class="source-inline">--registration-token</strong> values <span class="No-Break">as appropriate):</span></p>
			<pre class="console">
sudo gitlab-runner register \
  --non-interactive \
  --url "https://gitlab.hats-for-cats.com/" \
  --registration-token "abc123" \
  --executor "docker" \
  --docker-image "alpine:latest" \
  --description "Hats for Cats 1"</pre>
			<p class="callout-heading">Do I need to use sudo?</p>
			<p class="callout">Check the GitLab documentation to find out whether the <strong class="source-inline">gitlab-runner</strong> binary requires <strong class="source-inline">sudo</strong> or administrator permissions on your operating system; the command behaves differently on <span class="No-Break">different platforms.</span></p>
			<p>We can run the same<a id="_idIndexMarker794"/> command, changing the value of the <strong class="source-inline">--description</strong> option, to create the <span class="No-Break">second runner.</span></p>
			<p>Now that both runners have been registered, let’s double-check that they’re both up <span class="No-Break">and running:</span></p>
			<pre class="console">
~$ sudo gitlab-runner verify
Runtime platform         arch=amd64 os=linux pid=6365
revision=bbcb5aba version=15.3.0
Running in system-mode.
Verifying runner... is alive             runner=LuKAFv53
Verifying runner... is alive             runner=Rtq7yC5e</pre>
			<p>Finally, let’s refresh the GitLab page that we reached via <strong class="bold">Settings</strong> | <strong class="bold">CI/CD</strong> | <strong class="bold">Runners</strong> and make sure both runners were able to check in with our GitLab instance and declare themselves ready to accept jobs from the <strong class="bold">Hats for Cats</strong> project. Here’s the relevant portion of <span class="No-Break">that screen:</span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B18073_11_4.jpg" alt="Figure 11.4 – Specific runners for the Hats for Cats project" width="426" height="187"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Specific runners for the Hats for Cats project</p>
			<p>Before proceeding, you might want to review the GitLab documentation to learn more about the <strong class="source-inline">concurrent</strong> and <strong class="source-inline">check_interval</strong> options in the master configuration file for your registered runners. Sometimes, adjusting the values of these two options can help runners pick up jobs<a id="_idIndexMarker795"/> more quickly. This configuration file is <strong class="source-inline">/etc/gitlab-runner/config.toml</strong> on Linux systems that run the <strong class="source-inline">gitlab-runner</strong> binary as root, but might exist in other locations when <strong class="source-inline">gitlab-runner</strong> is not run as root or is run on other operating systems. Running <strong class="source-inline">gitlab-runner list</strong> (with or without <strong class="source-inline">sudo</strong>, depending on how you registered your runners) should reveal the location of this file on <span class="No-Break">your system.</span></p>
			<p class="callout-heading">Optional: disabling shared runners</p>
			<p class="callout">If you’re following along in your own GitLab account, you might want to go to <strong class="bold">Settings</strong> | <strong class="bold">CI/CD</strong> | <strong class="bold">Runners</strong> and disable all the shared runners for the <strong class="bold">Hats for Cats</strong> project. This ensures that all of the project’s CI/CD pipeline jobs will be assigned to one of the two runners we <span class="No-Break">just registered.</span></p>
			<p>With a basic CI/CD pipeline configuration file in place and two runners registered, we’ve completed the setup of the basic pipeline infrastructure for our project. Now, we need to start filling the pipeline with jobs so that it can run all the tests and scans that make GitLab pipelines such a powerful software <span class="No-Break">development tool.</span></p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor284"/>Verifying your code</h1>
			<p>Let’s configure your pipeline so that it can verify your code by running functional tests, Code Quality scanning, and <span class="No-Break">fuzz tests.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor285"/>Adding functional tests to the pipeline</h2>
			<p>Many teams start <a id="_idIndexMarker796"/>populating their pipelines by adding tasks to run automated functional tests to make sure their code is behaving<a id="_idIndexMarker797"/> the way it was designed to. You learned in previous chapters that there are many different sorts of functional tests. In this example, we’ll add some basic automated unit tests<a id="_idIndexMarker798"/> written with the <strong class="source-inline">pytest</strong> framework. Our project’s code is not yet complicated enough to require real unit tests, but for the sake of this example, we can add dummy tests so that GitLab can run them and display <span class="No-Break">their results.</span></p>
			<p>Before adding any tests, let’s make our login code <em class="italic">slightly</em> more complicated by adding a function that our tests can exercise, and a “to-do” comment that not only reminds us to flesh out this placeholder function later but also gives the Code Quality scanner something to detect when we add it to our pipeline down the road. Either locally (in which case you need to follow up with a commit and a push) or in the GitLab GUI, add this simple code to the <strong class="bold">add-login-feature</strong> branch’s copy of the <span class="No-Break"><strong class="source-inline">login.py</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
def log_user_in(username, password):
    return (username == "Dana") and (password == "p@ssw0rd")
# TODO: replace this placeholder code with real logic</pre>
			<p>We also need to declare a dependency on the <strong class="source-inline">pytest</strong> framework so that GitLab can install it before running the automated tests. Since this is a Python project, we declare this dependency in a new <strong class="source-inline">requirements.txt</strong> file at the top level of the project repository (still on the <strong class="bold">add-login-feature</strong> branch) with a single line <span class="No-Break">of content:</span></p>
			<pre class="source-code">
pytest==7.1.3</pre>
			<p>There are different ways to group automated unit tests in files and directories, but let’s keep things simple by adding a single <strong class="source-inline">test_login.py</strong> file at the root level of the repository, in the same <strong class="bold">add-login-feature</strong> branch that we’ve been <span class="No-Break">working in.</span></p>
			<p>We’ll put three tests in that file: one to check our login feature with good credentials, one to test logging in with a<a id="_idIndexMarker799"/> bad username, and one to test logging in with a bad password. We also need to import the function being tested so that it<a id="_idIndexMarker800"/> can be called by the unit tests. Add this <a id="_idIndexMarker801"/>code <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">test_login.py</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
from login import log_user_in
def test_login_good_credentials():
    assert log_user_in("Dana", "p@ssw0rd")
def test_login_bad_username():
    assert not log_user_in("foo", "p@ssw0rd")
def test_login_bad_password():
    assert not log_user_in("Dana", "foo")</pre>
			<p class="callout-heading">Expanding your automated tests</p>
			<p class="callout">These unit test examples are simpler than what you would typically use in a real project. Most unit test frameworks—regardless of which language they test—offer a wide variety of options and additional features to make your tests more comprehensive and powerful. We advise you to get to know your chosen test framework thoroughly since automated tests are such an important part of writing <span class="No-Break">high-quality code.</span></p>
			<p>Let’s add a job to the <strong class="source-inline">test</strong> stage of our pipeline to install the <strong class="source-inline">pytest</strong> library (as listed in <strong class="source-inline">requirements.txt</strong>) and run the tests. The job should ask the runner to execute its commands in a Docker container that has a recent version of Python. The <strong class="source-inline">pytest</strong> test framework automatically identifies any files that contain tests, so we don’t need to specify which test file to execute. We do need to tell <strong class="source-inline">pytest</strong> to generate an output file in the <strong class="source-inline">junit</strong> format, which is<a id="_idIndexMarker802"/> a test results format that GitLab knows how to ingest and display. Add this job definition to your existing <strong class="source-inline">.gitlab-ci.yml</strong> file on the <span class="No-Break"><strong class="bold">add-login-feature</strong></span><span class="No-Break"> branch:</span></p>
			<pre class="source-code">
unit-tests:
    stage: test
    image: python:3.10
    script:
        - pip install -r requirements.txt
        - pytest --junit-xml=unit_test_results.xml</pre>
			<p>Now that we have defined a real job in our CI/CD pipeline, you can delete the definition for the temporary <strong class="source-inline">job1</strong> job if you want to declutter the pipeline <span class="No-Break">configuration file.</span></p>
			<p>After the pipeline triggered by<a id="_idIndexMarker803"/> this commit completes, you’ll notice that even though the <strong class="source-inline">unit-tests</strong> job ran successfully, the pipeline details page doesn’t show any test results. That’s because we didn’t tell GitLab to preserve the results as an artifact. Let’s fix that by adding this code to<a id="_idIndexMarker804"/> the end of the <strong class="source-inline">unit-tests</strong> job definition, making sure all lines are indented correctly so that this code is understood by GitLab as part of the existing <span class="No-Break">job definition:</span></p>
			<pre class="source-code">
    artifacts:
        reports:
            junit: unit_test_results.xml
        when: always</pre>
			<p>This should get us to a state where our unit tests are running and passing, which is a huge step forward in ensuring that our code lives up to its design specifications. If you’ve been following along, you should see output similar to this on the <strong class="bold">Tests</strong> tab of the most recent pipeline details page, showing that all three of our unit tests are running <span class="No-Break">and passing:</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B18073_11_5.jpg" alt="Figure 11.5 – Test results on a pipeline details page" width="703" height="305"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.5 – Test results on a pipeline details page</p>
			<p>Once your automated tests pass, you can be confident that your code is doing what it was designed to do. However, just behaving<a id="_idIndexMarker805"/> correctly isn’t good enough: your code also needs to be written well. This helps to ensure that your code is readable and maintainable and will be less likely to develop bugs when you <a id="_idIndexMarker806"/>extend it with new features in<a id="_idIndexMarker807"/> the future, so now, let’s look at how to make sure your code is of <span class="No-Break">high quality.</span></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor286"/>Adding Code Quality scanning to the pipeline</h2>
			<p>Let’s add a task to our pipeline<a id="_idIndexMarker808"/> called Code Quality scanning, which will help us assess the quality of our code. As with all of GitLab’s<a id="_idIndexMarker809"/> scanners, Code Quality only<a id="_idIndexMarker810"/> works with certain computer languages. However—as described in the GitLab documentation for this feature—it supports all of the usual suspects, <span class="No-Break">including Python.</span></p>
			<p>We enable the scanner by including its template at the end of our project’s CI/CD configuration file, on the same <strong class="bold">add-login-feature</strong> branch where we’ve done all of <span class="No-Break">our work:</span></p>
			<pre class="source-code">
include:
    - template: Code-Quality.gitlab-ci.yml</pre>
			<p>If you inspect the pipeline that was triggered by committing this change to <strong class="source-inline">.gitlab-ci.yml</strong>, you’ll notice that the Code Quality scanning job failed. Don’t panic! This failure stems from Code Quality being something of an odd duck among GitLab’s scanners. It uses a technique called <strong class="bold">Docker-in-Docker</strong>, which <a id="_idIndexMarker811"/>requires that the runner assigned to the Code Quality job must be configured in a certain way. Although all shared runners provided by GitLab for SaaS customers are capable of running Code Quality jobs, the runners we registered earlier are not, so let’s create a new runner just to handle Code Quality. The GitLab<a id="_idIndexMarker812"/> documentation has more information about why the special configuration is necessary for this one type of scanning, but the details are not important for most GitLab users to understand. For the purposes of this demonstration, you just need to know that <a id="_idIndexMarker813"/>we can register a new runner called <strong class="source-inline">runner for code quality</strong> by typing this command on the same <a id="_idIndexMarker814"/>machine that’s hosting our other runners. Just like when we registered those runners, you’ll need to replace the <strong class="source-inline">--url</strong> and <strong class="source-inline">--registration-token</strong> values with the appropriate values for <span class="No-Break">your system:</span></p>
			<pre class="console">
sudo gitlab-runner register \
  --non-interactive \
  --url "https://gitlab.hats-for-cats.com/" \
  --registration-token "abc123" \
  --executor "docker" \
  --docker-image "docker:stable" \
  --description "runner for code quality" \
  --tag-list "code-quality-capable " \
  --builds-dir "/tmp/builds" \
  --docker-volumes "/cache"\
  --docker-volumes "/tmp/builds:/tmp/builds" \
  --docker-volumes "/var/run/docker.sock:/var/run/docker.sock"</pre>
			<p>We configured this new runner with a <strong class="source-inline">code-quality-capable</strong> tag, which indicates that it can handle running Code Quality jobs. In order to make sure that our job is assigned to this specific runner, we need to override the Code Quality scanner’s job definition and assign it the <a id="_idIndexMarker815"/>same tag. While we tinker with the pipeline configuration file, let’s also disable a <a id="_idIndexMarker816"/>service that’s used by some runners to handle this job but that isn’t required by our runner. Add this <a id="_idIndexMarker817"/>job definition override to the end of your <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitlab-ci.yml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
code_quality:
    tags:
        - code-quality-capable
    services: []    # disable all services</pre>
			<p>As soon as we commit this last change, GitLab kicks off a pipeline run and presents the Code Quality results in a new <strong class="bold">Code Quality</strong> tab on the pipeline <span class="No-Break">details page:</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B18073_11_6.jpg" alt="Figure 11.6 – Code Quality results on a pipeline details page" width="558" height="199"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – Code Quality results on a pipeline details page</p>
			<p>The Code Quality scanner reminds us to take care of the “to-do” comment we added to <strong class="source-inline">login.py</strong> earlier. Good advice, but let’s ignore it for now so we can move on to <span class="No-Break">fuzz testing.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor287"/>Adding a fuzz test to the pipeline</h2>
			<p>Let’s set up a fuzz test to<a id="_idIndexMarker818"/> see whether the <strong class="source-inline">log_user_in</strong> function has any bugs that weren’t caught by our automated unit tests. <a href="B18073_06.xhtml#_idTextAnchor133"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> has a thorough description of the architectural elements involved in fuzz testing, so <a id="_idIndexMarker819"/>please refer back to that<a id="_idIndexMarker820"/> chapter if you need a refresher on what role each piece of <span class="No-Break">code plays.</span></p>
			<p class="callout-heading">Reminder</p>
			<p class="callout">Fuzz testing, like several other features discussed throughout the book, is only available with a GitLab Ultimate license. The GitLab documentation for each feature tells you which license tier that feature requires. The reason that this book doesn’t mention which licenses are required for which features is that GitLab frequently makes features available at lower tiers after they’ve been tested in higher tiers for <span class="No-Break">a while.</span></p>
			<p>The fuzz test will test the <strong class="source-inline">log_user_in</strong> function that lives in the <strong class="source-inline">login.py</strong> file. If you remember from <a href="B18073_06.xhtml#_idTextAnchor133"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, this code is called the <strong class="bold">code under test</strong>. As it’s written right now, this function is simple enough that <a id="_idIndexMarker821"/>we can tell just by looking at it that fuzz testing won’t find any<a id="_idIndexMarker822"/> problems. In other words, fuzz testing is overkill for such a simple function, but we can imagine that the function might become more complicated in the future, and as it becomes more complicated, it will be more likely to have bugs. Therefore, it’s a good idea to create a fuzz test for this simple code under test now so that it can find new bugs if we rewrite the function using more complicated and error-prone code in <span class="No-Break">the future.</span></p>
			<p>Let’s put the <strong class="bold">fuzz target</strong> code in a file called <strong class="source-inline">log_in_user_fuzz_target.py</strong> in the root of the repository’s <strong class="bold">add-login-feature</strong> branch. The file should contain this <span class="No-Break">Python code:</span></p>
			<pre class="source-code">
from login import log_user_in
from pythonfuzz.main import PythonFuzz
@PythonFuzz
def fuzz(bytes):
    try:
        string = str(bytes, 'UTF-8')
        divider = int(len(string) / 2)
        username = string[:divider]
        password = string[divider:]
        log_user_in(username, password)
    except UnicodeDecodeError:
        pass
if __name__ == '__main__':
    fuzz()</pre>
			<p>Most of this is boilerplate code copied from sample fuzz targets in the GitLab documentation. The section that requires some programming creativity on our part is the logic in the <strong class="source-inline">fuzz()</strong> method. This code converts the random bytes sent by the fuzz engine into a random string, uses<a id="_idIndexMarker823"/> the first half of the string as the username and<a id="_idIndexMarker824"/> the second half as the password, and passes the username and password to the code <span class="No-Break">under test.</span></p>
			<p>Next, we need to<a id="_idIndexMarker825"/> include the GitLab fuzz testing template in the <strong class="source-inline">.gitlab-ci.yml</strong> file in the <strong class="source-inline">add-login-feature</strong> branch. Add the <strong class="source-inline">Coverage-Fuzzing.gitlab-ci.yml</strong> template within the existing <strong class="source-inline">include:</strong> section after the Code Quality template that we’ve already added. The complete <strong class="source-inline">include:</strong> section should end up looking <span class="No-Break">like this:</span></p>
			<pre class="source-code">
include:
    - template: Code-Quality.gitlab-ci.yml
    - template: Coverage-Fuzzing.gitlab-ci.yml</pre>
			<p>Because this template declares that fuzz test jobs run in their own <strong class="source-inline">fuzz</strong> stage, we must add that stage under the <strong class="source-inline">stages:</strong> keyword at the top of <strong class="source-inline">.gitlab-ci.yml</strong> in the <strong class="source-inline">add-login-feature</strong> branch. When you’re done, the complete stage definition section should look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
stages:
    - build
    - test
    - deploy
    - fuzz</pre>
			<p>Finally, let’s create a pipeline job to trigger the fuzz test against our code under test. Add this job definition to the end of <strong class="source-inline">.gitlab-ci.yml</strong> on the <span class="No-Break"><strong class="source-inline">add-login-feature</strong></span><span class="No-Break"> branch:</span></p>
			<pre class="source-code">
fuzz-test-for-log-user-in:
    image: python:3.10
    extends: .fuzz_base
    script:
        - pip install --extra-index-url https://gitlab.com/api/v4/projects/19904939/packages/pypi/simple pythonfuzz
        - ./gitlab-cov-fuzz run --engine pythonfuzz -- log_user_in_fuzz_target.py</pre>
			<p>If you check the pipeline<a id="_idIndexMarker826"/> details page for the pipeline that was triggered by this commit, you should see jobs for unit tests, Code Quality, and now fuzz testing. If you click into the fuzz testing job to see its output, you’ll notice<a id="_idIndexMarker827"/> that it’s sending a seemingly infinite number of sets of random data to the code under test, with no<a id="_idIndexMarker828"/> signs of stopping. However, we know from <a href="B18073_06.xhtml#_idTextAnchor133"><span class="No-Break"><em class="italic">Chapter 6</em></span></a> that it will stop as soon as it either finds a bug or times out. Because this pipeline is running on a non-default branch, the timeout is set to a hefty 60 minutes (default branches have 10-minute timeouts). While that might be a reasonable amount of time to uncover deep bugs in complicated code, it’s overkill for our dead-simple <span class="No-Break">login code.</span></p>
			<p>Let’s speed up our pipeline by configuring the job to send 1,000 sets of random bytes to the function being tested, and then stop if it hasn’t found any bugs. Of course, we can bump up the maximum number of random data sets later if we think more complicated login code would benefit from more thorough <span class="No-Break">fuzz testing.</span></p>
			<p>To limit the number of runs performed by the fuzz test, cancel the currently running pipeline (there’s no need to wait for it to time out after 60 minutes), and add these lines anywhere within the <strong class="source-inline">fuzz-test-for-log-user-in</strong> job definition. Make sure they’re indented correctly<a id="_idIndexMarker829"/> so that you’re defining a job-scoped variable and not a <span class="No-Break">global variable:</span></p>
			<pre class="source-code">
    variables:
        COVFUZZ_ARGS: '--runs=1000'</pre>
			<p>Also in the <strong class="source-inline">fuzz-test-for-log-user-in</strong> job definition, replace the second line in the <strong class="source-inline">script:</strong> section with the following (note that this is all a single long line <span class="No-Break">of code):</span></p>
			<pre class="source-code">
        - ./gitlab-cov-fuzz run --engine pythonfuzz --additional-args $COVFUZZ_ARGS -- log_user_in_fuzz_target.py</pre>
			<p>If you look at the output of a fuzz test job that runs after these changes, you’ll see that it stops after the first 1,000 unsuccessful attempts to find a bug. You’ll also notice that no <strong class="bold">Security</strong> tab shows up <a id="_idIndexMarker830"/>on the pipeline details page because the fuzz test has no findings to report (fuzz testing is considered by GitLab to be a<a id="_idIndexMarker831"/> type of security scanner rather than a type of code quality scanner, despite its aim of finding bugs rather than <span class="No-Break">security vulnerabilities).</span></p>
			<p>Our pipeline is really coming along! Let’s keep the momentum going by adding some <span class="No-Break">security scanners.</span></p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor288"/>Securing your code</h1>
			<p>For this sample use case, you’re going to add four scanners to your pipeline: <strong class="bold">Static Application Security Testing</strong> (<strong class="bold">SAST</strong>), Secret Detection, Dependency Scanning, and License Compliance. You’ll also review how to add a <span class="No-Break">third-party scanner.</span></p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor289"/>Adding SAST to the pipeline</h2>
			<p>In general, adding <a id="_idIndexMarker832"/>a GitLab-provided security<a id="_idIndexMarker833"/> scanner to a pipeline is a trivial process. To <a id="_idIndexMarker834"/>enable SAST and make sure our Hats for Cats source code doesn’t contain security vulnerabilities, we simply need to include a new template in <strong class="source-inline">.gitlab-ci.yml</strong> on the <strong class="source-inline">add-login-feature</strong> branch. Add this line anywhere within the existing <strong class="source-inline">include:</strong> section, making sure that it’s <span class="No-Break">indented correctly:</span></p>
			<pre class="source-code">
    - template: Security/SAST.gitlab-ci.yml</pre>
			<p>This enables SAST, but we also want to configure it so that it doesn’t scan our automated test file or our fuzz target file. The GitLab<a id="_idIndexMarker835"/> documentation tells us which variable to set to<a id="_idIndexMarker836"/> accomplish this. Add a new section to the end of <strong class="source-inline">.gitlab-ci.yml</strong> in order to set the correct <span class="No-Break">global variable:</span></p>
			<pre class="source-code">
variables:
    SAST_EXCLUDED_PATHS: "test_login.py,log_user_in_fuzz_target.py"</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">There are only two lines in this code: the second line is long enough that it wraps in a possibly <span class="No-Break">confusing way.</span></p>
			<p>Wait for the pipeline to finish<a id="_idIndexMarker837"/> and check out its details page. Under the <strong class="bold">Security</strong> tab, you’ll see that SAST has reported a vulnerability about a hardcoded password in <strong class="source-inline">login.py</strong>. We will ignore this vulnerability for the sake of keeping the demo moving along, but it’s comforting to see that SAST is up <span class="No-Break">and running:</span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B18073_11_7.jpg" alt="Figure 11.7 – SAST results on a pipeline details page" width="718" height="498"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – SAST results on a pipeline details page</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor290"/>Adding Secret Detection to the pipeline</h2>
			<p>Let’s add SAST’s cousin, Secret <a id="_idIndexMarker838"/>Detection, to our CI/CD pipeline. On the <strong class="source-inline">add-login-feature</strong> branch, include a new <a id="_idIndexMarker839"/>template in the existing <strong class="source-inline">include:</strong> section of <strong class="source-inline">.gitlab-ci.yml</strong>. Double-check your indentation and we<a id="_idIndexMarker840"/> should be good <span class="No-Break">to go:</span></p>
			<pre class="source-code">
    - template: Security/Secret-Detection.gitlab-ci.yml</pre>
			<p>We should consider some of the configuration options for Secret Detection. There’s no need to enable “historic” mode since our repository only has a few commits and we’re confident that we haven’t added any secrets to it so far. However, it makes sense to tell Secret Detection not to scan our test files since any secrets kept in them will be made-up secrets for testing purposes only. In the future, we might group all of our test-related code into a <strong class="source-inline">tests/</strong> directory, but since we don’t have that directory yet, we’ll explicitly exclude individual files. Do this by overriding the appropriate job definition and setting a <span class="No-Break">job-scoped variable:</span></p>
			<pre class="source-code">
secret_detection:
    variables:
        SECRET_DETECTION_EXCLUDED_PATHS: "login_test.py,log_user_in_fuzz_target.py"</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The last line in this code snippet is actually one line that wraps awkwardly, so be sure to paste it in as a <span class="No-Break">single line.</span></p>
			<p>Finally, let’s give Secret <a id="_idIndexMarker841"/>Detection a secret to detect. Let’s<a id="_idIndexMarker842"/> pretend that our intern Carl<a id="_idIndexMarker843"/> accidentally pastes an AWS access token into <strong class="source-inline">login.py</strong>. Add this line to the end of that file on the <span class="No-Break"><strong class="source-inline">add-login-feature</strong></span><span class="No-Break"> branch:</span></p>
			<pre class="console">
AWS_access_token = 'AKIAABCDEFGH12345678'</pre>
			<p>When the resulting pipeline finishes, check that the <strong class="bold">Security</strong> tab on its pipeline details page reports a security vulnerability from <span class="No-Break">Secret Detection:</span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B18073_11_8.jpg" alt="Figure 11.8 – Secret Detection results on a pipeline details page" width="1096" height="282"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Secret Detection results on a pipeline details page</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor291"/>Adding Dependency Scanning to the pipeline</h2>
			<p>So far, the only <a id="_idIndexMarker844"/>dependency that <a id="_idIndexMarker845"/>our project has declared is the <strong class="source-inline">pytest</strong> automated testing framework. Since that dependency won’t be used in production, we probably don’t care<a id="_idIndexMarker846"/> if it has security vulnerabilities, but it’s smart to add Dependency Scanning to our pipeline so that we’ll be alerted to any security problems in dependencies that we might add in <span class="No-Break">the future.</span></p>
			<p>On the <strong class="bold">add-login-feature</strong> branch, add this new line to the existing <span class="No-Break"><strong class="source-inline">include:</strong></span><span class="No-Break"> section:</span></p>
			<pre class="source-code">
    - template: Security/Dependency-Scanning.gitlab-ci.yml</pre>
			<p>Now that Dependency Scanning is up and running, let’s give it something to find. Let’s say that the Hats for Cats web app will be built on the Django web app framework for Python and that we decide to use <a id="_idIndexMarker847"/>an older version of Django that we’re already comfortable with. Add this new line to the end of the existing <strong class="source-inline">requirements.txt</strong> file on the <strong class="source-inline">add-login-feature</strong> branch, noting that it should be flush-left rather <span class="No-Break">than indented:</span></p>
			<pre class="source-code">
django==3.2</pre>
			<p>Since this version is<a id="_idIndexMarker848"/> significantly behind the current version of 4.1.1, we might expect Dependency Scanning to find security vulnerabilities in it. Lo and behold, if we trigger a pipeline and then look at the <strong class="bold">Security</strong> tab on the pipeline details page, we see at least 15 potential problems with our dependency! You might find it helpful to use the <strong class="bold">Severity</strong> and <strong class="bold">Tool</strong> filters above the results table to reduce clutter and focus on the most <span class="No-Break">important vulnerabilities:</span></p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B18073_11_9.jpg" alt="Figure 11.9 – Critical severity Dependency Scanning results on a pipeline details page" width="1113" height="562"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Critical severity Dependency Scanning results on a pipeline details page</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor292"/>Adding License Compliance to the pipeline</h2>
			<p>Since we’ve<a id="_idIndexMarker849"/> declared a few software dependencies for the <strong class="bold">Hats for Cats</strong> project, it’s a good idea to add License <a id="_idIndexMarker850"/>Compliance scanning<a id="_idIndexMarker851"/> to the pipeline so that we don’t run afoul of problems with incompatible licenses. On the <strong class="source-inline">add-login-feature</strong> branch, add a new template to the <strong class="source-inline">include:</strong> section, double-checking <span class="No-Break">your indentation:</span></p>
			<pre class="source-code">
    - template: Security/License-Scanning.gitlab-ci.yml</pre>
			<p>On the details page for the pipeline that was triggered by this edit, click on the new <strong class="bold">Licenses</strong> tab to see the different software licenses used by the Django and <strong class="source-inline">pytest</strong> libraries, and also by their dependencies. Interestingly, the License Compliance scanner was unable to figure out what license Django itself uses, so it’s listed as <strong class="bold">unknown</strong>. Normally, you would consult with your legal team to decide whether to explicitly allow or deny each of these licenses by clicking on the <strong class="bold">Manage licenses</strong> button on this page, but in order to keep the demo moving along, we’ll skip <span class="No-Break">that step.</span></p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B18073_11_10.jpg" alt="Figure 11.10 – Licenses used by project dependencies" width="1132" height="312"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Licenses used by project dependencies</p>
			<p class="callout-heading">Some scanners are excluded from this demo</p>
			<p class="callout">You may have noticed that we didn’t add DAST, Container Scanning, or Infrastructure as Code Scanning to our pipeline. We’ve excluded them partly because the Hats for Cats demo web app doesn’t include enough functioning code to package into a Docker image and interact with as a normal user would, and because we don’t need to use infrastructure-as-code tools to configure any new machines as part of the <strong class="bold">Hats for Cats</strong> project. Equally, we also want to show that not all scanners are relevant to all projects. You should enable and configure only the scanners that make sense for your particular project; adding unnecessary scanners complicates your CI/CD pipeline configuration file and bogs down your pipeline without adding <span class="No-Break">any value.</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor293"/>Integrating a third-party security scanner into the pipeline</h2>
			<p>Imagine that there’s a third-party<a id="_idIndexMarker852"/> security scanner that we’ve used in the past and want to add to our <strong class="bold">Hats for Cats</strong> project <a id="_idIndexMarker853"/>pipeline. It’s called <strong class="source-inline">gui-proofreader</strong> and is a form of SAST scanning that checks for typos in user-facing text. Let’s say that it’s available <a id="_idIndexMarker854"/>as a Docker image on Docker Hub and that you can run the scanner against all the code in your repository by cloning the repository to a <strong class="source-inline">gui-proofreader</strong> Docker container and running the <strong class="source-inline">proofread-my-gui.sh</strong> shell script within <span class="No-Break">that container.</span></p>
			<p>Let’s add a job to our CI/CD pipeline that does exactly that. Add this job definition at the end of <strong class="source-inline">.gitlab-ci.yml</strong> on the <span class="No-Break"><strong class="source-inline">add-login-feature</strong></span><span class="No-Break"> branch:</span></p>
			<pre class="source-code">
proofread:
    stage: test
    image: gui-proofreader:latest
    script:
        - ./proofread-my-gui.sh</pre>
			<p>That’s enough to trigger the third-party scanner, but we still need to integrate its output into the GitLab security reports. This step is simple: declare the scanner’s output as an artifact that contains a SAST report (there are several report types we could assign it to, but this particular<a id="_idIndexMarker855"/> scanner feels like a flavor of SAST, so let’s use that). Add this code to the bottom of the definition <a id="_idIndexMarker856"/>of the <span class="No-Break"><strong class="source-inline">proofread</strong></span><span class="No-Break"> job:</span></p>
			<pre class="source-code">
    artifacts:
        reports:
            sast: gui-proofreader-report.json</pre>
			<p>Of course, we would need to <a id="_idIndexMarker857"/>adjust the name of the results file specified in the job definition to match whatever file name the <strong class="source-inline">gui-proofreader</strong> scanner actually generates. Also, GitLab will only be able to parse and display those results if the file conforms to GitLab’s official JSON schema for SAST scanners (the details of the various security scanner results schemas are given in the GitLab documentation for each type of scanner). If the <strong class="source-inline">gui-proofreader</strong> scanner can’t generate output using that schema, we will need to write a small script that converts the scanner’s output into a JSON file with the appropriate schema, run that script in a separate job in a later pipeline stage, and move the artifact declaration from the <strong class="source-inline">proofread</strong> job into the new <span class="No-Break">script’s job.</span></p>
			<p>Since this job won’t work as written—as there’s no Docker image called <strong class="source-inline">gui-proofeader</strong> on Docker Hub—it’s best to either exclude this job definition from your <strong class="source-inline">.gitlab-ci.yml</strong> file or to comment it out. However, if you ever do want to integrate a third-party scanner, this is a model you <span class="No-Break">can follow.</span></p>
			<h1 id="_idParaDest-281"><a id="_idTextAnchor294"/>Improving your pipeline</h1>
			<p>You’ve set up a <a id="_idIndexMarker858"/>pipeline to make sure your code is of high quality and doesn’t have security vulnerabilities. In many cases, you can stop there. However, for this sample use case, you’ll go a step further and look into using a DAG to speed up the pipeline. You’ll also see whether it’s worth splitting the pipeline’s configuration code into <a id="_idIndexMarker859"/>multiple files to improve readability <span class="No-Break">and maintainability.</span></p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor295"/>Using a DAG to speed up the pipeline</h2>
			<p>Our pipeline isn’t complicated enough to justify converting it into a DAG quite yet, but if we continue to add<a id="_idIndexMarker860"/> more jobs, we’ll eventually want to use DAGs for some or all of it for performance reasons. Let’s preview this by using the <strong class="source-inline">needs</strong> keyword now<a id="_idIndexMarker861"/> to add some DAG elements to <span class="No-Break">our pipeline.</span></p>
			<p>First, let’s say that we want the <strong class="source-inline">code_quality</strong> job to run only after the <strong class="source-inline">unit-tests</strong> job passes. After all, we might think that our code needs to work correctly before we worry about making it pretty and maintainable. We could accomplish that by putting <strong class="source-inline">code_quality</strong> in a later stage than <strong class="source-inline">unit-tests</strong>, but since they both feel like they conceptually belong to the <strong class="bold">test</strong> stage, let’s keep them in that stage and instead set up a DAG to enforce the job order we want. Add this code to the end of the <strong class="source-inline">code_quality</strong> <span class="No-Break">job definition:</span></p>
			<pre class="source-code">
    needs: ["unit-tests"]</pre>
			<p>Now that one mini-DAG is set up, let’s make another. Perhaps we’re unhappy with the job that runs our fuzz test running after all of the other scanners are complete. This happens because the fuzz test job is in its own <strong class="bold">fuzz</strong> stage, which runs after the <strong class="bold">test</strong> stage. We could override its job definition and move it to the <strong class="bold">test</strong> stage, but in this case, we decide to use the DAG feature to allow it to run as soon as the pipeline starts instead of waiting around for its pipeline stage to be called. Add this code to the end of the job definition <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">fuzz-test-for-log-user-in</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    needs: []</pre>
			<p>When we run a pipeline that contains these edits, we see exactly the behavior we’d hoped for: <strong class="source-inline">fuzz-test-for-log-user-in</strong> runs immediately and <strong class="source-inline">code_quality</strong> is paused until <span class="No-Break"><strong class="source-inline">unit-tests</strong></span><span class="No-Break"> completes:</span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B18073_11_11.jpg" alt="Figure 11.11 – DAG causing jobs to run not according to stage order" width="737" height="471"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – DAG causing jobs to run not according to stage order</p>
			<p>We can double-check our<a id="_idIndexMarker862"/> understanding of the pipeline’s flow by clicking on <strong class="bold">Job dependencies</strong> in the<a id="_idIndexMarker863"/> pipeline details page and toggling <strong class="bold">Show dependencies</strong> on. After the pipeline finishes, we can see which jobs ran in what order, due to “<span class="No-Break">needs” relationships:</span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B18073_11_12.jpg" alt="Figure 11.12 – Job dependencies view of the completed pipeline" width="743" height="578"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.12 – Job dependencies view of the completed pipeline</p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor296"/>Breaking the pipeline into several files</h2>
			<p>Now that we’ve set up our project’s CI/CD pipeline to verify and secure our code, let’s see whether we can<a id="_idIndexMarker864"/> keep our pipeline configuration well organized and easy to read. As the file stands right now, it’s much simpler than <strong class="source-inline">.gitlab-ci.yml</strong> files for real-world projects tend to be, and normally we would suggest that our configuration file is clean enough as is and doesn’t warrant any refactoring. However, in order to demonstrate how we might maintain it as it becomes more complicated, let’s separate it into two <span class="No-Break">files anyway.</span></p>
			<p>Say we decide to standardize our security scanning process across all of our team’s projects. A good way to do this is to separate our security-related job definitions into a different CI/CD pipeline configuration file, and then include it in each project’s CI/CD <span class="No-Break">configuration file.</span></p>
			<p>Create a new file called <strong class="source-inline">security-jobs.yml</strong> in the root of the <strong class="bold">Hats for Cats</strong> project’s repository, on the <strong class="source-inline">add-login-feature</strong> branch. Add this line to the <span class="No-Break">new file:</span></p>
			<pre class="source-code">
include:</pre>
			<p>Cut these lines from the <strong class="source-inline">include:</strong> section of <strong class="source-inline">.gitlab-ci.yml</strong> and paste them into the <strong class="source-inline">include:</strong> section <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">security-jobs.yml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    - template: Security/SAST.gitlab-ci.yml
    - template: Security/Secret-Detection.gitlab-ci.yml
    - template: Security/Dependency-Scanning.gitlab-ci.yml
    - template: Security/License-Scanning.gitlab-ci.yml</pre>
			<p>Finally, include the new configuration file in the original configuration file by adding this line anywhere within the <strong class="source-inline">include:</strong> section <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">.gitlab-ci.yml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    - local: security-jobs.yml</pre>
			<p>When the pipeline runs <a id="_idIndexMarker865"/>after you make these changes, you’ll see that it behaves exactly like it did before we refactored its configuration files. This demonstrates how you can break a long, complicated CI/CD pipeline configuration file into two or more subfiles, each of which can be reused in multiple projects <span class="No-Break">if desired.</span></p>
			<p>Note that because <strong class="source-inline">security-jobs.yml</strong> is in the same project as <strong class="source-inline">.gitlab-ci.yml</strong>, we used the <strong class="source-inline">include:</strong> keyword and <strong class="source-inline">local:</strong> sub-keyword to point to it. If we were including it from a different project, we’d need to use the <strong class="source-inline">include:</strong> and <strong class="source-inline">file:</strong> keywords instead. The GitLab documentation has more information on how to use different forms of <strong class="source-inline">include:</strong> in different situations, and is well <span class="No-Break">worth reviewing.</span></p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor297"/>Delivering your code to the right environment</h1>
			<p>Your code is written, verified, and secured. The only step left is to <span class="No-Break">deploy it.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor298"/>Deploying the code</h2>
			<p>The final task of our <a id="_idIndexMarker866"/>pipeline is to deploy the <strong class="bold">Hats for Cats</strong> code to the right environment. Normally, we’d define separate jobs to deploy code to a review environment, the pre-production environment, or the production environment. Then, we would use GitLab’s <strong class="source-inline">rules:</strong> and <strong class="source-inline">if:</strong> keywords to control which one of those three jobs should run, depending on which Git branch the pipeline was <span class="No-Break">running on.</span></p>
			<p>To keep things simple in this example, let’s just walk through how to deploy it to the production environment. We’ll imagine that we want this to happen whenever we run the pipeline on the <span class="No-Break"><strong class="bold">production</strong></span><span class="No-Break"> branch.</span></p>
			<p>As you learned in <a href="B18073_08.xhtml#_idTextAnchor205"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, there are countless techniques you can use to deploy code. Which technique you choose depends largely on what sort of environment you’re deploying to: an AWS EC2 VM, a Kubernetes cluster, a bare-metal machine, or something else. For this example, let’s imagine that we’re deploying our code to a machine with an IP address of <strong class="source-inline">192.168.0.1</strong>, which is running an Apache web server that hosts the Hats for Cats site. Furthermore, let’s say that to deploy a new version of our web app, we simply need to <a id="_idIndexMarker867"/>copy our files to the right directory on the Apache host machine and issue a command to <span class="No-Break">restart Apache.</span></p>
			<p>This deployment process is very straightforward. Add this job definition to <strong class="source-inline">.gitlab-ci.yml</strong> on the <span class="No-Break"><strong class="source-inline">add-login-feature</strong></span><span class="No-Break"> branch:</span></p>
			<pre class="console">
deploy-to-production:
    stage: deploy
    image: registry.hats-for-cats.com/ubuntu-with-deploy-key:latest
    rules:
        - if: $CI_COMMIT_REF_NAME == "production"
    script:
        - scp -r . root@192.168.0.1:/home/hats-for-cats/production
        - ssh root@192.168.0.1 service apache2 restart</pre>
			<p>You might wonder about the image specified in this job definition. There are several ways we could set up the public/private SSH key pair that the <strong class="source-inline">scp</strong> command relies on, but one way to accomplish this involves making our own Docker image, which we store in an internal Docker container registry. Of course, we could also store this image within the container registry of this project or a different project, but for now, let’s assume we have a separate, company-wide Docker container registry set up. The image contains a Linux distribution with the OpenSSH library (which provides the <strong class="source-inline">scp</strong> command) and also has a public/private key pair that was generated in advance. We then configure the Apache host computer to accept the private key from that Docker image. With that infrastructure in place, the GitLab Runner can execute <strong class="source-inline">scp</strong> from within the special Docker image, and the <a id="_idIndexMarker868"/>key pair takes care of authenticating to the <span class="No-Break">Apache host.</span></p>
			<p>The <strong class="source-inline">rules:</strong> and <strong class="source-inline">if:</strong> keywords in this job definition prevent the job from running unless the pipeline runs on the <strong class="bold">production</strong> branch. As mentioned previously, we’d normally create additional definitions for the <strong class="source-inline">deploy-to-review</strong> and <strong class="source-inline">deploy-to-staging</strong> jobs, which would each use different logic to specify which branches they should <span class="No-Break">run on.</span></p>
			<p>Since our <strong class="source-inline">deploy-to-production</strong> job won’t run on the <strong class="source-inline">add-login-feature</strong> branch to which we’re committing the edited <strong class="source-inline">.gitlab-ci.yml</strong> file, we won’t see it run when the commit triggers a new pipeline. However, we do want to make sure it deploys code correctly, so how can we test <span class="No-Break">this job?</span></p>
			<p>First, we need to merge the <strong class="source-inline">add-login-feature</strong> branch into the <strong class="bold">main</strong> branch. We’re done adding our code and configuring our pipeline, so now’s a perfect time to merge anyway. Navigate to our <strong class="bold">add login feature</strong> MR, removing <strong class="source-inline">Draft:</strong> from the beginning of its title to make it mergeable, and click on the <strong class="bold">Merge</strong> button. Since we linked this MR to the <strong class="bold">Allow user to log in</strong> issue, merging the MR will automatically close the issue <span class="No-Break">as well.</span></p>
			<p>This merge adds all of our pipeline configuration details to the <strong class="bold">main</strong> branch. It runs a pipeline on that branch, but we still won’t see the <strong class="source-inline">deploy-to-production</strong> job run since the pipeline isn’t running on the <strong class="bold">production</strong> branch. Navigate to <strong class="bold">Repository | Branches</strong> in the left-hand navigation pane and create a new branch called <strong class="bold">production</strong>. Creating this branch triggers a new pipeline. Finally, we’ll be able to see the <strong class="source-inline">deploy-to-production</strong> job running in that pipeline. Of course, we shouldn’t expect it to actually pass because we haven’t created the Docker image specified in the job definition, and we don’t have an actual production environment living at <strong class="source-inline">192.168.0.1</strong>, but at least we can see that the job runs, which is all that we can realistically test at this point. Declare victory and crack open an iced beverage of your choice. This concludes the example workflow for the <strong class="bold">Hats for </strong><span class="No-Break"><strong class="bold">Cats</strong></span><span class="No-Break"> project.</span></p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor299"/>Summary</h1>
			<p>In this chapter, we made a group and project to hold our code and other related components and made issues to plan and track our work. Then, we cloned the project’s repository to a local workstation so that we could write code using our favorite desktop tools. Then, we made a branch to commit our work to and an MR for that branch, linked it to an associated issue, and committed and pushed code for a new software feature. We set up a bare-bones CI/CD pipeline to which we can add a variety of tasks and registered specific runners for the project’s pipeline. We added automated unit tests to the pipeline to make sure the code satisfies its design specifications, as well as Code Quality scanning, and registered a special runner just for that scanner. We also added a fuzz test to the pipeline to find bugs in critical functions, and SAST to the pipeline to find security vulnerabilities in our code. We added Secret Detection to the pipeline to find any secrets that were inadvertently committed to the repository and added Dependency Scanning to the pipeline to learn about any security problems in the third-party libraries that our project relies on. Then, we added License Compliance to the pipeline to exclude third-party libraries that use software licenses that are incompatible with our project’s own license and integrated a third-party scanner into the pipeline, which is triggered automatically and integrates its results into existing GitLab dashboards and reports. We rewrote parts of the pipeline as a DAG to improve its performance and separated the pipeline configuration code into multiple files to improve its readability and maintainability and added logic so that code on the correct branch is automatically deployed to the <span class="No-Break">production environment.</span></p>
			<p>Although we covered a lot of ground, it’s important to remember that this was just one example workflow. We used only a portion of the countless features offered by GitLab CI/CD pipelines, and we barely investigated any of the different configuration options for those features. There are often multiple ways of accomplishing the same tasks in a pipeline, and there are limitless ways you can organize those tasks into stages and jobs, so don’t feel like this example is the <em class="italic">One True Way</em> to use GitLab CI/CD pipelines. Be creative, experiment, have fun figuring out what pipeline features are most useful for your projects, and enjoy discovering which configuration settings for those features make the most sense for you and <span class="No-Break">your team.</span></p>
			<p>In the next chapter, we will learn about troubleshooting and the road ahead <span class="No-Break">with GitLab.</span></p>
		</div>
		<div>
			<div id="_idContainer131" class="IMG---Figure">
			</div>
		</div>
	</div>
</div>
</body></html>