<html><head></head><body>
		<div id="_idContainer218">
			<h1 id="_idParaDest-333"><em class="italic"><a id="_idTextAnchor335"/>Chapter 16</em>: Loosely Coupled Architecture and Microservices</h1>
			<p>Interestingly, software architecture has a bigger impact on software delivery performance than the type of systems that you build. It doesn't matter if your product is a cloud service, embedded software that runs on manufactured hardware, a consumer app, an enterprise application, or even mainframe software. This has basically no impact on engineering performance if your architecture has certain characteristics (<em class="italic">Forsgren N., Humble, J., and Kim, G., 2018</em>). There are high and low performers for every system type. But the characteristics of architecture are clearly correlated with engineering velocity and make it one of the key accelerators.</p>
			<p>In this chapter, I'll give you an overview of loosely coupled systems and how you can evolve your software and system design to achieve a high engineering velocity.</p>
			<p>The following topics will be covered in this chapter:</p>
			<ul>
				<li>Loosely coupled systems</li>
				<li>Microservices</li>
				<li>Evolutionary design</li>
				<li>Event-based architecture</li>
			</ul>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor336"/>Loosely coupled systems</h1>
			<p>All <a id="_idIndexMarker1099"/>developers that have worked at least once on a tightly coupled, monolithic application know the problems it induces. The communication overhead and the meetings needed to perform bigger changes. New bugs that occur after fixing a bug in another part of the application. Changes that break functionality from other developers. All these problems lead to fear of integrating and deploying and slow down developer velocity.</p>
			<p>When designing your system and software, you should focus on the following characteristics:</p>
			<ul>
				<li><strong class="bold">Deployability</strong>: Can each team release their application independent of other applications or teams?</li>
				<li><strong class="bold">Testability</strong>: Can each team do most of their testing without requiring a test environment in <a id="_idIndexMarker1100"/>which multiple independent solutions from other teams must be deployed together?</li>
			</ul>
			<p>The team size here is a<a id="_idIndexMarker1101"/> small <strong class="bold">two-pizza team</strong> (see <a href="B17827_17_Epub.xhtml#_idTextAnchor342"><em class="italic">Chapter 17</em></a>, <em class="italic">Empower Your Teams</em>). If you design your systems for the deployability and testability of small teams, it will automatically lead to loosely coupled systems with well-defined interfaces.</p>
			<h1 id="_idParaDest-335"><a id="_idTextAnchor337"/>Microservices</h1>
			<p>The most <a id="_idIndexMarker1102"/>common architectural pattern for loosely coupled systems is the <strong class="bold">microservices</strong> pattern, <em class="italic">"an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API"</em> (<em class="italic">Lewis J. &amp; Fowler M., 2014</em>).</p>
			<p>Microservices evolved out <a id="_idIndexMarker1103"/>of <strong class="bold">Service-Oriented Architecture</strong> (<strong class="bold">SOA</strong>) with some additional characteristics. Microservices <a id="_idIndexMarker1104"/>have <strong class="bold">decentralized data management</strong> – meaning that every service completely owns its own data. Additionally, microservices favor lightweight messaging instead of complex protocols or central orchestration <a id="_idIndexMarker1105"/>for interservice <a id="_idIndexMarker1106"/>communication – <strong class="bold">smart endpoints</strong> and <strong class="bold">dumb pipes</strong>.</p>
			<p>One important characteristic of microservices is often missed – they are built around business capabilities. This also defines how small a service should be. To define the scope of your services, you must understand <a id="_idIndexMarker1107"/>the business domain. One microservice matches <a id="_idIndexMarker1108"/>one <strong class="bold">bounded context</strong> in <strong class="bold">domain-driven design</strong> (<em class="italic">Eric Evans, 2003</em>).</p>
			<p>Another characteristic is that microservices are completely and independently <strong class="bold">deployable</strong> and <strong class="bold">testable</strong>. That's the reason why they are associated with high engineering velocity.</p>
			<p>Microservices have many<a id="_idIndexMarker1109"/> advantages. They scale very well, as you can scale every service independently. They also allow each team to work with its own programming languages and data storage solution that best meets its needs. Most importantly, they allow teams in big and complex applications to move fast without disrupting other teams.</p>
			<p>But these advantages come with a cost. Microservice-based applications are complex and hard to operate and troubleshoot.</p>
			<p>There are many famous microservice-based solutions – for example, Netflix and Amazon. They run world-scale services and have an architecture that allows them to deploy thousands of times each day.</p>
			<p>But there are also many companies that have tried to implement microservices and have failed. The number of greenfield projects that fail is especially high. The reason for this is often a lack of knowledge of the business domain and the wrong definition of the bounded context for each service, especially when the application is developed by an external company that has yet to learn the <strong class="bold">ubiquitous language</strong> of the domain. Another reason is that the complexity of operating the service is underestimated.</p>
			<p>So, instead of implementing microservices, you should focus on the <strong class="bold">deployability</strong> and <strong class="bold">testability</strong> characteristics of your architecture and adjust the solution design to your needs. The needs are not constant and evolve over time – and so should your architecture.</p>
			<h1 id="_idParaDest-336"><a id="_idTextAnchor338"/>Evolutionary design</h1>
			<p>The <a id="_idIndexMarker1110"/>advantages and disadvantages of certain architectural styles shift<a id="_idIndexMarker1111"/> for various reasons. One is the scale of your application. Another is the knowledge of your domain and your customers and the ability to operate at scale. Depending on these factors, different architectural styles are better suited for you (see <em class="italic">Figure 16.1</em>):</p>
			<div>
				<div id="_idContainer217" class="IMG---Figure">
					<img src="image/B17827_16_001.jpg" alt="Figure 16.1 – The advantages and disadvantages shift with scale&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 16.1 – The advantages and disadvantages shift with scale</p>
			<p>Constantly adapting<a id="_idIndexMarker1112"/> your architecture and system design to your current needs<a id="_idIndexMarker1113"/> is called <strong class="bold">evolutionary design</strong>. To start a greenfield product, it's best to start with a monolithic approach and one team. This allows you to move fast without much overhead. If you scale up and learn more about the domain, you can start to modularize your application using the capabilities of your programming language. At one point, the complexity and scale will be so high that microservices help you to keep your product testable and deployable.</p>
			<p>The question is this – how do you arrive at the architecture you need from the architecture you have? A complete rewrite is very expensive and risky. The better approach is to evolve your design. Martin Fowler calls<a id="_idIndexMarker1114"/> this the <strong class="bold">StranglerFigApplication</strong> pattern (<em class="italic">Martin Fowler, 2004</em>). The strangler fig is a plant that seeds in the upper branches of a tree and gradually grows its roots downward over the tree until it roots in the soil. The supporting tree is strangled and dies at some point – leaving an organic structure that supports itself.</p>
			<p>Instead of rewriting your application, you grow a new "strangler fig" application around it, letting it grow gradually until the old system is strangled and can be shut down.</p>
			<h1 id="_idParaDest-337"><a id="_idTextAnchor339"/>Event-driven architecture</h1>
			<p>There are <a id="_idIndexMarker1115"/>other architectural styles besides microservices, monolithic, and multi-tier applications – for example, <strong class="bold">Event-Driven Architecture</strong> (<strong class="bold">EDA</strong>). EDA is a pattern around the publication, processing, and persistence of events. The <a id="_idIndexMarker1116"/>backbone is a message broker – for example, <strong class="bold">Apache Kafka</strong> – and individual services or components can publish events (a <strong class="bold">publisher</strong>) or subscribe to events (a <strong class="bold">subscriber</strong>).</p>
			<p>EDA can be a good fit with a microservices-based approach – but it can also be used with other architectural styles. It can help you to keep consistency in loosely coupled components or services, and it can scale perfectly horizontally due to the asynchronous nature of events and is therefore well suited for solutions that process big amounts of data in motion, such as IoT solutions that process sensor data in near real time.</p>
			<p>Especially in cloud-native environments, EDA can help you to move fast and to build loosely coupled and global scalable solutions in a very short time.</p>
			<p>One pattern that is often <a id="_idIndexMarker1117"/>used with EDA is <strong class="bold">event sourcing</strong>. Instead of persisting entities, event sourcing captures all changes to the application state – including the entities – as a sequence of events (see <em class="italic">Martin Fowler, 2005</em>). To retrieve an entity, the application must replay all events to get to the latest state. Since events are immutable, this provides a perfect audit trail. You can think of the event stream as an immutable stream of facts that can be seen as the single source of truth. In addition to auditability, event sourcing has many benefits in scalability and testability.</p>
			<p>Event sourcing is a suitable pattern if you need to capture intent, purpose, or reason for your data, when it's vital to avoid conflicting updates, and when you must keep a history and frequently roll back changes. Event sourcing <a id="_idIndexMarker1118"/>works very well together with <strong class="bold">Command and Query Responsibility Segregation</strong> (<strong class="bold">CQRS</strong>) – a pattern that separates read and write operations.</p>
			<p>But be aware that event sourcing is very complex, and modeling a domain in events does not come naturally to most developers. If the aforementioned criteria do not suit your product, then event sourcing is probably not a good pattern for you.</p>
			<p>An architectural style that is more suitable for simple domains is the <strong class="bold">Web-Queue-Worker</strong>. It's a<a id="_idIndexMarker1119"/> pattern mainly used with serverless PaaS components, and it consists of a web frontend that serves client requests and a worker that performs long-running tasks in the background. Frontend and backend are stateless and communicate using a message queue. The pattern is normally combined with other cloud services such as an identity provider, a database, a Redis cache, and a CDN. Web-Queue-Worker is a good pattern to get started with cloud-native applications.</p>
			<p>Whatever architectural style you pick, keep it as simple as possible. It's better to start simple and evolve your design over time with increasing demands than to overengineer and end up with a complex solution that slows you down.</p>
			<h1 id="_idParaDest-338"><a id="_idTextAnchor340"/>Summary</h1>
			<p>If you are adopting CI/CD and DevOps practices but you're not accelerating, then you should have a close look at your solution architecture as one of the key indicators for engineering velocity. Focus on the deployability and testability characteristics rather than on the architectural styles.</p>
			<p>In this chapter, I gave you an overview of loosely coupled systems' evolutionary design, and I introduced some relevant architectural styles and patterns.</p>
			<p>In the next chapter, we'll discuss the correlation between your organizational structure and your software architecture and how it all comes together in GitHub.</p>
			<h1 id="_idParaDest-339"><a id="_idTextAnchor341"/>Further reading</h1>
			<p>These are the references from this chapter that you can also use to get more information on the topics:</p>
			<ul>
				<li>Forsgren N., Humble, J., and Kim, G. (2018). <em class="italic">Accelerate: The Science of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations</em> (1st ed.) [E-book]. IT Revolution Press.</li>
				<li>Lewis J. and Fowler M. (2014). <em class="italic">Microservices</em>: <a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a>.</li>
				<li>Eric Evans (2003). <em class="italic">Domain-Driven Design: Tackling Complexity in the Heart of Software</em>. Addison-Wesley Professional.</li>
				<li>Martin Fowler (2004). <em class="italic">StranglerFigApplication</em>: <a href="https://martinfowler.com/bliki/StranglerFigApplication.html">https://martinfowler.com/bliki/StranglerFigApplication.html</a>.</li>
				<li>Michael T. Nygard (2017). <em class="italic">Release It!: Design and Deploy Production-Ready Software</em>. Pragmatic Programmers.</li>
				<li>Martin Fowler (2005). <em class="italic">Event Sourcing</em>: <a href="https://martinfowler.com/eaaDev/EventSourcing.html">https://martinfowler.com/eaaDev/EventSourcing.html</a>.</li>
				<li>Lucas Krause (2015). <em class="italic">Microservices: Patterns and Applications – Designing fine-grained services by applying patterns</em> [Kindle Edition].</li>
			</ul>
		</div>
	</body></html>