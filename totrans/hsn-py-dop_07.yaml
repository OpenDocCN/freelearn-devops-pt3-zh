- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of the future is full unemployment. So that we can play.
  prefs: []
  type: TYPE_NORMAL
- en: – Arthur C Clarke
  prefs: []
  type: TYPE_NORMAL
- en: This is probably going to be my favorite chapter. Seriously, once you have drunk
    the sweet nectar of automation, you won’t look back. Well, I guess I’m getting
    ahead of myself. I will start with the concept of time. The only way you control
    your destiny, the way you live, and what you do is by controlling your own time,
    by choosing what you do. And to do that, you need to choose what it is that you
    do with your time.
  prefs: []
  type: TYPE_NORMAL
- en: All human advancement correlates to doing something in a way that requires fewer
    and fewer workers and continually decreased effort so that greater effort can
    then be applied elsewhere. All of this defines the concept of automation. It is
    inventing ways to reduce time investment in the boring stuff so that you can move
    on and do more exciting or engaging stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Human beings invented agriculture so that they wouldn’t have to spend so much
    time hunting and gathering food. They could grow their own; the food, in many
    ways, grew itself (automatically some would say) and a little bit of tinkering
    led to the food that we eat to this day. The creation of farming automated the
    food creation process, which kickstarted towns and owning property and most of
    human civilization.
  prefs: []
  type: TYPE_NORMAL
- en: During the Industrial Revolution, the automation of manufacturing processes
    resulted in cheap, mass-manufactured goods being brought to practically every
    household. The ability to create identical goods that were of high quality and
    worked perfectly was revolutionary. It meant that the labor required to create
    something was greatly reduced meaning that that labor could be focused elsewhere.
    The invention of the steam engine, electricity, and motor vehicles also reduced
    labor in a number of different areas while saving time in many others.
  prefs: []
  type: TYPE_NORMAL
- en: '*Around the World in Eighty Days* by *Jules Verne* was a novel symbolizing
    how far human innovation had gone toward shortening trips around the globe. Within
    a hundred years of the publication of that novel, man had conquered all forms
    of terrestrial travel, making the book trivial. The next question that was then
    asked was how the human mind could be made faster and more automated. This is
    where computers came in. Computers turn the human brain into the most efficient
    tool in the world. They have automated a lot of our menial mental workload, allowing
    the human brain to be freed up for more leisurely tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: However, this process is a never-ending one. There is always some way to get
    better and to do something faster and without taking up any more of one’s focus.
    In the DevOps field, we have made it into one of our core principles because of
    how much innovation, creativity, and coming up with new ideas are valued in the
    field of technology. You cannot stay in the same place you were yesterday. You
    must automate and move on.
  prefs: []
  type: TYPE_NORMAL
- en: And that is what this chapter will be about. It will concern *Automating the
    Boring Stuff with Python* (another great Python book by *Al Sweigart*) and letting
    you use your mind and your creativity to maximum utilization. You do not want
    to be stuck in the causal loop of doing the same upload, running the same script
    manually, or fixing that recurring server issue manually even though it only takes
    about 5 seconds but logging into it takes 10 minutes. All of these are problems
    where automation is the answer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Automation of server maintenance within the server and outside of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation of container creation through managed services and otherwise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated launching of a playbook using Google Forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating server maintenance and patching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I once had a friend whose only job most days was to wait for a website to go
    down, check why it had gone done, and do one of two things or commands that he
    had been given to bring it back up again. I had another friend whose job was to
    manually restart an NGINX server whenever it went down. I once met a man whose
    job largely involved just downloading CSVs from one place, putting them somewhere
    else, and clicking a start button. Now, to some of you, that might sound like
    a swell gig (to me, it doesn’t sound half bad either), but the thing about it
    is that it is a waste of time for both that individual’s employers and that individual
    themselves. There is no growth or improvement for either, and in my experience
    of life, that is a waste of human life.
  prefs: []
  type: TYPE_NORMAL
- en: In the coming samples, we are going to see how we can maintain multiple instance
    fleets based on a series of common commands and then we are going to find a way
    to patch an OS after we have discovered the type of OS it is running. We are going
    to do all of this with the help of Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sample 1: Running fleet maintenance on multiple instance fleets at once'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Maintaining a server involves a lot of work – a lot of repetitive work. This
    is why server maintenance was initially automated. It minimizes human error and
    also makes sure that the process occurs the same way every time. A fleet of servers
    works similarly. It is just about using the automation script for all of them
    since they are copies of an original server. But what about multiple instance
    fleets with different needs? Here, Python can be of assistance. All you need to
    do is associate each fleet with the correct script for maintaining it. This can
    allow you to manage multiple fleets over multiple clouds if you want to. So, without
    further ado, let’s see how we can do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first write the code for AWS instances to find the instances that are
    running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will give us a list of instances from EC2 to use. You can use a number
    of identifiers to define your fleet. You can even use a pre-defined system manager
    fleet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s now do the same thing for Google Cloud Compute Engine instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the **Google Cloud Platform** (**GCP**) code, there are a few differences
    because you need to specify the GCP project ID and you have to define the request
    to the API along with the API itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s find a command to run through these instances. It can be any placeholder
    command. You can later use the commands you want for it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code for GCP and AWS differs a bit because of the way that the
    APIs have been developed for it. However, they both will produce the result of
    executing an SSH command on their servers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: So, if we iterate through the lists that we previously produced through the
    function to update them with a command, we can make a mass change or update to
    our entire instance fleet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This method is good for a generic fleet where we presume that all the OS are
    the same or that they run the same commands. But what if we were in an environment
    where the OS could be different? How would we then go about using commands? In
    the next section, we will explore this possibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sample 2: Centralizing OS patching for critical updates'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OS are like any brand, really. Well, at least among most of the tech community,
    it’s like Coke and Pepsi – except if Coke or Pepsi was your belligerent pet who
    constantly wanted your attention and needed maintenance. What I’m trying to say
    is the flavor you want is your preference. But, if you’re going to share a fridge,
    there will probably be flavors that you are not familiar with. So, the fridge
    needs to be accommodating to all flavors. This is a rather long-winded analogy,
    but you’ll get what I’m saying as we keep going. This fridge sorting is even more
    difficult (and important) when dealing with servers, which can have a similar
    diversity. To patch OS correctly, we must first understand which OS we are operating
    on. Then, we need to apply the correct command to ensure that the patching is
    done correctly for that OS. This again is where Python comes in. It has libraries
    that can do both and when combined can be a powerful asset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start off with the process of patching a single OS. We will use a `apt`
    package manager for this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the code, it’s simply a matter of running an `update` command
    using Python’s `subprocess` module, which once again reinforces the incredible
    connection that Python has with the OS that it is working on.
  prefs: []
  type: TYPE_NORMAL
- en: 'But this is just for a Debian Linux instance. What would happen if that instance
    was, say, Red Hat or CentOS? What if the script had to function for both? Then
    we just need to add an additional library: `platform`. This library will give
    us the knowledge we need to distinguish between the platforms and the ability
    to write all the patch code in one script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code works for Debian distributions, the latest RedHat distributions
    (older ones use `yum` instead), and Windows PowerShell. The script will determine
    which OS you are currently running on and run an update accordingly. Since the
    command can be modified, you can change it and make the update whatever you’d
    like it to be. You can also add on OS such as Darwin for macOS or more obscure
    Linux distributions.
  prefs: []
  type: TYPE_NORMAL
- en: You may now be thinking “*Patching an OS is going to break my server.*” Fair
    enough. That can happen a lot, especially for older dependencies. And in the case
    of a lot of Linux servers, the latest versions of OS can take years to become
    approved server versions. If you feel that this is a hassle, then maybe you should
    try out containers. There’s plenty of opportunity there for the automation enthusiast
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Automating container creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Containers** – in the eyes of many – are magic. You can put all the stuff
    you need for a smaller application or a section of a larger application into an
    environment solely catered to it where it can function on its own. It’s like creating
    a separate planet where polar bears can live in their native environment forever
    free from the terrors of global warming. In this way, containers are amazing since
    they can help maintain nearly extinct technologies in environments that can sustain
    them. That is truly magic. But casting the spell is rather bothersome, which is
    why we automate stuff.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sample 1: Creating containers based on a list of requirements'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Containers change between initialization and stoppage based on changes in the
    state of the files and configurations within the container. Capturing an image
    from this changed container will give an image that has several layers added on
    top of the initial layer. This is a way to create custom containers as well. This
    can be useful when the containers that we find are largely what our requirements
    are but are not exactly our requirements. We can add a few steps (and a few layers)
    to make our container just as we would like it. We can then turn this into an
    image, which can then be replicated for other containers. We can do all of this
    with Python (big surprise, amirite?):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s once again start off with some simple code to start a container based
    on an image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This set of commands will run a container containing the latest version of Ubuntu.
    It will also give us the ID of the container, which will be important in the next
    step. This will be our starting point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s add on to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have a new container that has the new command added on top of everything
    else in Ubuntu. This container is different from the original one but built upon
    the original.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to export this image for later use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will save your image in the desired file path. Putting all of this code
    together, we get the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The full code gives us the complete picture and shows us that all of this can
    be done in just a few short steps. Adding layers simply means adding more commands.
    You can even start with an empty template that has nothing in it if you want.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is all good if you are creating individual customized images, but another
    complicated aspect of containers is orchestrating multiple containers together
    to perform a task. This requires a lot of work and is why Kubernetes was created.
    Kubernetes clusters – even though they simplify container orchestration a lot
    – can be quite a handful. This is another area of container automation, then,
    that Python can be useful for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sample 2: Spinning up Kubernetes clusters'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I will start off with a personal note: when I first got into Kubernetes, it
    was probably the hardest thing in the world for me. I came from a development
    background and something like container orchestration was completely alien to
    me at the time. Kubernetes was born out of a very complicated need because of
    the rise in popularity of microservices. It was created to make life simpler for
    larger projects that were a mishmash of smaller projects. When it finally clicked
    for me, I realized how important Kubernetes was. It didn’t stop me from still
    being confused, though. So, I went to the coding well and it turns out there are
    a bunch of resources for guys like me. Once again, Python was a big help.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a Kubernetes cluster usually involves using it in a cloud service.
    For this exercise, we are going to write code for setting up clusters in Google
    Cloud and Microsoft Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation will create a Kubernetes cluster in your Google Cloud project.
    Now let’s look at a way to do it in Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This creation code is fairly standard as well; it is simply a change in terminology.
    This is probably not the most efficient way to write code for this function (that
    will come later with Infrastructure as Code), but it gets the job done.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of what we have looked at so far is gibberish to the layman, and sometimes
    the layman is the one most frequently operating resources. So let’s now look at
    a process that can be a blueprint for automating more complex processes to involve
    the layman more in the resource creation process.
  prefs: []
  type: TYPE_NORMAL
- en: Automated launching of playbooks based on parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, even the most basic tasks when automated can become difficult
    to understand. If you have to automate or trigger multiple tasks, the complexity
    starts to increase. Not everyone can understand them, and it shouldn’t be the
    job of everyone to understand them. That is why even a lot of modern servers have
    user interfaces that make the processing of information easier for many.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in many cases, even this level of abstraction isn’t enough. It may
    be necessary to create a tool in which users can simply enter their inputs and
    the server handles the creation of complex workflows and resources automatically.
    In short, you can make playbooks with parameters that will create resources based
    on an overview given to it by someone who would like the creation of the resource
    but does not want to bother with the intricacies behind it (in most places, these
    rather whimsical folk are called customers). Let’s see how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: We will start by making a Google Form (yes, seriously). Go to [forms.google.com](http://forms.google.com)
    and click on the big plus (+) button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Instance selection](img/B21320_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Instance selection
  prefs: []
  type: TYPE_NORMAL
- en: It’s a simple Google Form for two different sizes of EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to write a Google Apps Script script and an AWS Lambda function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This Lambda function takes an input consisting of the size of the EC2 instance
    to be created and then creates that instance. We can define an endpoint for it
    using the Lambda URL or the API gateway.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once this function and this endpoint have been made, you can then call the
    endpoint from Apps Script and make the trigger and the input from the form. In
    the form editor, click on the three dots at the top right and click on **Script
    editor**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Accessing Script editor](img/B21320_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Accessing Script editor
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now write the API script in what is essentially JavaScript:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will run the Lambda function, though there is a final step to trigger it
    by adding a trigger. On the left pane of the Apps Script project, click on the
    **Triggers** option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Calling Lambda using Apps Script](img/B21320_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Calling Lambda using Apps Script
  prefs: []
  type: TYPE_NORMAL
- en: 'At the bottom right, click on **Add Trigger**, which will open the form to
    create a trigger where you can define all the necessary parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Adding a trigger for when the form is submitted…](img/B21320_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Adding a trigger for when the form is submitted…
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can add the source of the event, and the function, and select the event
    type.
  prefs: []
  type: TYPE_NORMAL
- en: In doing so, we will create a workflow that will trigger a function when form
    data is submitted and use the data provided to the function to trigger an API
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it, that’s one way to connect all of the machinations that
    happen behind the scenes in a Lambda function with a simple Google Form.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the beauty of automation along with the means
    to achieve it. We learned how to automate virtual machine maintenance and container
    operations. We even learned how to add a layer of automation on top of that that
    would allow us to get people who are significantly less in the know involved in
    our process. Automation is a good thing. People will often believe otherwise and
    fear the automation of a lot of tasks, but the point of automation is to ensure
    that it is easier for people to live their lives. A life is not meant for boring
    repetitive tasks, it is meant for exploration. Automation is key to free up time
    for exploration. You control your life by controlling your time. Automation lets
    you do that.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss the events that drive not only automation
    but most DevOps infrastructure in general. We will look into event-driven architecture
    and use cases where it is advantageous, as well as – of course – how Python can
    help.
  prefs: []
  type: TYPE_NORMAL
