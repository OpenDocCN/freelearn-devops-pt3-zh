- en: <st c="0">7</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">7</st>
- en: <st c="2">Implementing Security in the Test and Release Phases of DevOps</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">在 DevOps 的测试和发布阶段实现安全性</st>
- en: <st c="64">The goal of the</st> **<st c="81">test</st>** <st c="85">phase is
    to</st> <st c="98">make sure the compiled application provides the expected functionalities
    and does not contain any bugs that were not detected in the</st> <st c="231">build
    phase.</st> <st c="244">The goal of the</st> **<st c="260">release</st>** <st
    c="267">phase is to prepare and deliver the tested application for deployment
    to production or other target environments.</st> <st c="382">Depending on a project’s
    release strategy, the test and release phases often overlap.</st> <st c="468">It
    is common to release software into a pre-production environment for automated
    runtime testing, using tools such as Selenium, before releasing it to production.</st>
    <st c="631">In this chapter, we will cover DevSecOps practices to secure and integrate
    security into these phases.</st> <st c="734">By the end of this chapter, you will
    understand these key</st> <st c="792">security practices:</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64">测试</st>阶段的目标是**<st c="81">确保编译后的应用程序提供预期功能，并且不包含在构建阶段未检测到的任何错误。</st>**
    <st c="231">发布</st>阶段的目标是**<st c="260">为将测试过的应用程序准备并交付部署到生产或其他目标环境。</st>** <st
    c="382">根据项目的发布策略，测试和发布阶段通常是重叠的。</st> <st c="468">通常，软件会先发布到预生产环境进行自动化运行时测试，使用如
    Selenium 等工具，然后再发布到生产环境。</st> <st c="631">在本章中，我们将讨论 DevSecOps 实践，确保并将安全集成到这些阶段中。</st>
    <st c="734">在本章结束时，您将理解以下关键</st> <st c="792">安全实践：</st>
- en: <st c="811">Ensuring that release artifacts are built from</st> <st c="859">protected
    branches</st>
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="811">确保发布构件是从</st> <st c="859">受保护的分支构建的</st>
- en: <st c="877">Implementing a code</st> <st c="898">review process</st>
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="877">实现代码</st> <st c="898">审查流程</st>
- en: <st c="912">Selecting a secure</st> <st c="932">artifact source</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="912">选择一个安全的</st> <st c="932">构件源</st>
- en: <st c="947">Implementing a process to validate</st> <st c="983">artifact integrity</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="947">实现验证</st> <st c="983">构件完整性的过程</st>
- en: <st c="1001">Managing secrets securely in the</st> <st c="1035">release phase</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1001">在</st> <st c="1035">发布阶段安全地管理机密</st>
- en: <st c="1048">Validating and enforcing runtime security with</st> <st c="1096">release
    gates</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1048">使用</st> <st c="1096">发布门禁</st> <st c="1151">来验证并强制执行运行时安全</st>
- en: <st c="1109">Let’s</st> <st c="1116">get started!</st>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1109">让我们</st> <st c="1116">开始吧！</st>
- en: <st c="1128">Technical requirements</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1128">技术要求</st>
- en: <st c="1151">To follow along with the instructions in this chapter, you will
    need</st> <st c="1221">the following:</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1221">要跟随本章的说明，您将需要</st> <st c="1356">以下内容：</st>
- en: <st c="1235">A PC with</st> <st c="1246">internet connection</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1235">一台配有</st> <st c="1246">互联网连接的 PC</st>
- en: <st c="1265">An active</st> <st c="1276">Azure subscription</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1265">一个有效的</st> <st c="1276">Azure 订阅</st>
- en: <st c="1294">An Azure</st> <st c="1304">DevOps organization</st>
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1294">一个 Azure</st> <st c="1304">DevOps 组织</st>
- en: <st c="1323">A GitHub</st> <st c="1333">Enterprise organization</st>
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1323">一个 GitHub</st> <st c="1333">企业组织</st>
- en: <st c="1356">Understanding the continuous deployment phase of DevOps</st>
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1356">了解 DevOps 的持续部署阶段</st>
- en: '**<st c="1412">Continuous Deployment (CD)</st>** <st c="1439">is a DevOps practice
    where code changes that have been successfully</st> <st c="1508">integrated and
    passed automated testing are automatically transitioned to the production environment.</st>
    <st c="1610">Activities</st> <st c="1621">in this phase include packaging the
    code into deployable formats, storing the packages in an artifact repository,
    and validating the software in a pre-production runtime environment before its
    final transition to the production</st> <st c="1849">runtime environment.</st>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="1412">持续部署（CD）</st>** <st c="1439">是 DevOps 实践之一，成功集成并通过自动化测试的代码更改会自动过渡到生产环境。</st>
    <st c="1610">这一阶段的活动包括将代码打包成可部署的格式，将包存储在构件库中，并在其最终过渡到生产</st> <st c="1849">运行时环境之前，在预生产运行时环境中验证软件。</st>'
- en: <st c="1869">The process ensures that new features, bug fixes, and updates are
    rapidly and consistently delivered to users without manual intervention, enabling
    a seamless flow from development to deployment.</st> <st c="2066">The key to a
    successful CD is a robust automated testing framework that validates changes and
    ensures the stability and reliability of the application in a</st> <st c="2222">real-world
    setting.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1869">该过程确保新特性、错误修复和更新能够快速且持续地交付给用户，无需人工干预，从而实现从开发到部署的无缝流转。</st> <st
    c="2066">成功的持续交付（CD）的关键在于一个强大的自动化测试框架，能够验证更改并确保应用程序在</st> <st c="2222">实际环境中的稳定性和可靠性。</st>
- en: '*<st c="2241">Figure 7</st>**<st c="2250">.1</st>* <st c="2252">shows a simplified
    example of a DevOps CD process.</st> <st c="2304">In the scenario, an application
    package, labeled as</st> *<st c="2356">APP:V1</st>*<st c="2362">, is published
    into the artifact store from the build process.</st> <st c="2425">The creation
    of the new package initiates a CD pipeline, which automatically deploys it to
    a staging environment for testing.</st> <st c="2551">Once the testing has successfully
    passed, the package is deployed to the production environment where it becomes
    available for</st> <st c="2678">end-user access.</st>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="2241">图 7</st>**<st c="2250">.1</st>* <st c="2252">展示了一个简化的 DevOps
    CD 过程示例。</st> <st c="2304">在该场景中，一个标记为</st> *<st c="2356">APP:V1</st>*<st c="2362">的应用程序包从构建过程中发布到工件库。</st>
    <st c="2425">新包的创建启动了一个 CD 流水线，该流水线会自动将其部署到暂存环境中进行测试。</st> <st c="2551">测试成功通过后，包被部署到生产环境中，供</st>
    <st c="2678">最终用户访问。</st>'
- en: '![Figure 7.1 – Continuous delivery example scenario](img/B19710_07_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 持续交付示例场景](img/B19710_07_01.jpg)'
- en: <st c="3035">Figure 7.1 – Continuous delivery example scenario</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3035">图 7.1 – 持续交付示例场景</st>
- en: <st c="3084">Implementing</st> <st c="3098">security in the CD phase involves
    securely storing the release artifacts, validating their security before release,
    ensuring</st> <st c="3223">the runtime environment’s security before software
    deployment, and using</st> **<st c="3296">infrastructure as code</st>** <st c="3318">(</st>**<st
    c="3320">IaC</st>**<st c="3323">) to automatically configure the runtime environment’s
    security.</st> <st c="3389">Let us review</st> <st c="3403">these areas.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3084">在 CD 阶段实施安全性包括安全存储发布工件，在发布前验证其安全性，确保</st> <st c="3223">运行环境的安全性在软件部署前得到保障，并使用</st>
    **<st c="3296">基础设施即代码</st>** <st c="3318">(</st>**<st c="3320">IaC</st>**<st
    c="3323">) 自动配置运行环境的安全性。</st> <st c="3389">让我们回顾一下</st> <st c="3403">这些领域。</st>
- en: <st c="3415">Protecting release artifacts in the release phase</st>
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3415">在发布阶段保护发布工件</st>
- en: <st c="3465">DevOps processes are about speed and agility.</st> <st c="3512">The
    aim is to remove obstacles that could slow down</st> <st c="3564">the</st> <st
    c="3568">speed to market.</st> <st c="3585">It is not unusual for code changes
    to move from a developer’s workspace to the production environment</st> <st c="3687">within
    minutes, mainly driven by automation and with few manual checks.</st> <st c="3759">It
    is impressive to read about the deployment figures from organizations that are
    more mature in their DevOps practices.</st> <st c="3880">For example, Netflix
    maintains over 600 services in production and does around 100 deployments a day;
    Uber operates over 1,000 services in production with several thousand deployments
    weekly; WeChat has more than 3,000 services in production and manages approximately
    1,000</st> <st c="4154">deployments daily!</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3465">DevOps 过程注重速度和灵活性。</st> <st c="3512">其目标是消除可能减缓</st> <st c="3564">市场速度的障碍。</st>
    <st c="3568">通常情况下，代码更改会在几分钟内从开发者的工作区移动到生产环境</st> <st c="3585">，主要依靠自动化，且几乎没有人工检查。</st>
    <st c="3687">阅读那些在 DevOps 实践上更为成熟的组织的部署数据令人印象深刻。</st> <st c="3759">例如，Netflix
    维持着超过 600 个生产环境中的服务，每天进行约 100 次部署；Uber 运营着超过 1,000 个生产环境中的服务，每周进行几千次部署；WeChat
    生产环境中的服务超过 3,000 个，每天大约进行 1,000 次</st> <st c="4154">部署！</st>
- en: <st c="4172">Note</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4172">注意</st>
- en: <st c="4177">For information that highlights the deployment pace of companies
    such as Netflix, Uber, and WeChat, please refer to this</st> <st c="4299">document:</st>
    [<st c="4309">https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition</st>](https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition)<st
    c="4386">.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解如 Netflix、Uber 和微信等公司的部署速度信息，请参阅此[文档](https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition)。
- en: <st c="4387">To integrate security in the release phase, start by reviewing
    your CI/CD process and ensuring that no one (person or application) can deploy
    code changes or new artifacts without</st> <st c="4568">strict reviews and approvals.</st>
    <st c="4598">The</st> <st c="4602">reviews should include both automated checks
    and human-led reviews.</st> <st c="4670">Following zero-trust principles, you
    have to assume that an attacker might eventually gain access to a system within
    your CI/CD process (source control, CI system, or artifact repository).</st> <st
    c="4859">To mitigate this, we need to implement measures that prevent any single
    entity from independently pushing code ch</st><st c="4972">anges or release artifacts
    through the</st> <st c="5012">release pipeline.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在发布阶段集成安全性，首先需要审查您的 CI/CD 流程，确保没有任何人（无论是个人还是应用程序）能够在没有严格审查和批准的情况下部署代码更改或新的工件。审查应包括自动化检查和人工审核。遵循零信任原则，您必须假设攻击者最终可能会获得对
    CI/CD 流程中某个系统的访问权限（如源代码控制、CI 系统或工件库）。为了解决这个问题，我们需要实施措施，防止任何单一实体独立推送代码更改或通过发布管道发布工件。
- en: <st c="5029">Ensuring that release artifacts are built from protected branches</st>
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保发布工件是从受保护的分支构建的
- en: <st c="5095">Implementing</st> <st c="5109">security in the test and release
    phases of DevOps starts with the security of the artifacts that will be deployed
    – we refer</st> <st c="5234">to them as</st> **<st c="5245">release artifacts</st>**<st
    c="5262">.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 DevOps 测试和发布阶段的安全性始于对将要部署的工件的安全性——我们称之为**发布工件**。
- en: <st c="5263">Note</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: <st c="5268">A release artifact is software or a software component that is
    packaged and ready for deployment.</st> <st c="5367">Artifacts vary depending
    on the technology stack and target deployment platforms.</st> <st c="5449">For</st>
    <st c="5453">example, Java applications are typically packaged as</st> `<st c="5649">.dll</st>`
    <st c="5653">or</st> `<st c="5657">.exe</st>` <st c="5661">files) are the compiled
    code artifacts</st> <st c="5701">that are deployed to run on the .NET runtime.</st>
    <st c="5747">In JavaScript</st> <st c="5761">or Node.js projects,</st> `<st c="5890">package.json</st>`
    <st c="5902">file.</st> <st c="5909">For</st> <st c="5913">Python applications,</st>
    `<st c="5941">.whl</st>`<st c="5945">) files are a more modern packaging format,
    aimed at replacing egg files.</st> <st c="6020">They facilitate the distribution
    and installation of Python libraries and applications.</st> <st c="6108">For containerized
    solutions, applications are packaged as</st> <st c="6166">container images.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 发布工件是已打包并准备好部署的软件或软件组件。工件根据技术栈和目标部署平台的不同而有所不同。例如，Java 应用通常打包为`.dll`或`.exe`文件，它们是编译后的代码工件，部署后在
    .NET 运行时上运行。在 JavaScript 或 Node.js 项目中，`package.json`文件。对于 Python 应用，`.whl`文件是一种更现代的打包格式，旨在替代
    egg 文件。它们促进了 Python 库和应用的分发和安装。对于容器化解决方案，应用被打包为容器镜像。
- en: <st c="6183">A good starting point is to protect all branches that are used
    to create these release artifacts.</st> <st c="6282">In GitHub Enterprise, this
    can be done with</st> **<st c="6326">Branch protection rules</st>**<st c="6349">,
    and in Azure DevOps, this can be done with</st> **<st c="6394">Branch Policies</st>**<st
    c="6409">.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的起点是保护所有用于创建这些发布工件的分支。在 GitHub Enterprise 中，可以使用**分支保护规则**来实现，在 Azure DevOps
    中，则可以使用**分支策略**来实现。
- en: <st c="6410">To implement in GitHub Enterprise, navigate to</st> **<st c="6458">Repository
    Settings</st>**<st c="6477">, then</st> **<st c="6484">Code and automation</st>**
    <st c="6503">|</st> **<st c="6506">Branches</st>** <st c="6514">|</st> **<st c="6517">Branch
    protection rules</st>**<st c="6540">, and then click on</st> **<st c="6560">Add
    rule</st>**<st c="6568">.</st> *<st c="6570">Figure 7</st>**<st c="6578">.2</st>*
    <st c="6580">shows an example of a branch protection rule that is used to protect
    any branch</st> <st c="6661">that contains the word “release.” This requires admin
    permissions or a custom role with the</st> **<st c="6753">Edit repository</st>**
    **<st c="6769">rules</st>** <st c="6774">permission.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6410">要在 GitHub Enterprise 中实现，请导航至</st> **<st c="6458">仓库设置</st>**<st
    c="6477">，然后</st> **<st c="6484">代码与自动化</st>** <st c="6503">|</st> **<st c="6506">分支</st>**
    <st c="6514">|</st> **<st c="6517">分支保护规则</st>**<st c="6540">，然后点击</st> **<st
    c="6560">添加规则</st>**<st c="6568">。</st> *<st c="6570">图 7</st>**<st c="6578">.2</st>*
    <st c="6580">显示了一个用于保护包含“release”字样的分支的示例分支保护规则。</st> <st c="6661">这需要管理员权限或具有</st>
    **<st c="6753">编辑仓库</st>** **<st c="6769">规则</st>** <st c="6774">权限的自定义角色。</st>
- en: '![Figure 7.2 – Sample branch protection rule in GitHub Enterprise](img/B19710_07_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – GitHub Enterprise 中的示例分支保护规则](img/B19710_07_02.jpg)'
- en: <st c="7593">Figure 7.2 – Sample branch protection rule in GitHub Enterprise</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7593">图 7.2 – GitHub Enterprise 中的示例分支保护规则</st>
- en: <st c="7656">To implement in Azure DevOps, go to</st> **<st c="7693">Project
    Settings</st>** <st c="7709">|</st> **<st c="7712">Repos</st>** <st c="7717">|</st>
    **<st c="7720">Repositories</st>**<st c="7732">, select a</st> **<st c="7743">repository</st>**<st
    c="7753">, choose</st> **<st c="7762">Policies</st>** <st c="7770">|</st> **<st
    c="7773">Branch Policies</st>**<st c="7788">, and select a</st> **<st c="7803">branch</st>**
    <st c="7809">(note that you may need to scroll down to see your list of branches).</st>
    *<st c="7880">Figure 7</st>**<st c="7888">.3</st>* <st c="7890">shows an example
    of a branch policy in Azure DevOps.</st> <st c="7944">This requires admin permissions
    or a custom role with the</st> **<st c="8002">Edit</st>** **<st c="8007">policies</st>**
    <st c="8015">permission.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7656">要在 Azure DevOps 中实现，请转到</st> **<st c="7693">项目设置</st>** <st c="7709">|</st>
    **<st c="7712">仓库</st>** <st c="7717">|</st> **<st c="7720">Repositories</st>**<st
    c="7732">，选择一个</st> **<st c="7743">仓库</st>**<st c="7753">，选择</st> **<st c="7762">策略</st>**
    <st c="7770">|</st> **<st c="7773">分支策略</st>**<st c="7788">，并选择一个</st> **<st c="7803">分支</st>**
    <st c="7809">(注意，您可能需要滚动才能看到分支列表)。</st> *<st c="7880">图 7</st>**<st c="7888">.3</st>*
    <st c="7890">显示了 Azure DevOps 中的分支策略示例。</st> <st c="7944">这需要管理员权限或具有</st> **<st
    c="8002">编辑</st>** **<st c="8007">策略</st>** <st c="8015">权限的自定义角色。</st>
- en: '![Figure 7.3 – Sample branch protection rule in Azure DevOps](img/B19710_07_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – Azure DevOps 中的示例分支保护规则](img/B19710_07_03.jpg)'
- en: <st c="8687">Figure 7.3 – Sample branch protection rule in Azure DevOps</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8687">图 7.3 – Azure DevOps 中的示例分支保护规则</st>
- en: <st c="8745">Overall, both platforms offer similar branch protection features.</st>
    <st c="8812">GitHub Enterprise may not have</st> <st c="8843">direct branch protection
    settings for build validation and human reviews, but these capabilities can be
    achieved through alternative methods (see</st> *<st c="8989">Figure 7</st>**<st
    c="8997">.4</st>*<st c="8999">).</st> <st c="9003">A notable distinction is the
    lack of support for requiring signed commits in Azure DevOps, which is available
    in GitHub Enterprise.</st> <st c="9135">For a detailed comparison of branch protection
    features between the two platforms, see</st> *<st c="9222">Figure 7</st>**<st
    c="9230">.4</st>*<st c="9232">.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8745">总体而言，这两个平台提供了类似的分支保护功能。</st> <st c="8812">GitHub Enterprise 可能没有</st>
    <st c="8843">直接的构建验证和人工审核分支保护设置，但这些功能可以通过其他方法实现（见</st> *<st c="8989">图 7</st>**<st
    c="8997">.4</st>*<st c="8999">）。</st> <st c="9003">一个显著的区别是 Azure DevOps 不支持要求提交签名，而
    GitHub Enterprise 支持这一功能。</st> <st c="9135">关于这两个平台之间分支保护功能的详细比较，请参见</st> *<st
    c="9222">图 7</st>**<st c="9230">.4</st>*<st c="9232">。</st>
- en: '![Figure 7.4 – Branch protection feature comparison](img/B19710_07_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 分支保护功能比较](img/B19710_07_04.jpg)'
- en: <st c="9716">Figure 7.4 – Branch protection feature comparison</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9716">图 7.4 – 分支保护功能比较</st>
- en: <st c="9765">Following zero-trust principles, we also want to make sure that
    branch protection policies are enforced for everyone, including administrators.</st>
    <st c="9910">This is extremely important since administrator accounts are often
    targeted for account hijacking due to their</st> <st c="10021">privileged role.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9765">遵循零信任原则，我们还希望确保对所有人（包括管理员）强制执行分支保护策略。</st> <st c="9910">这一点非常重要，因为管理员帐户通常会成为账户劫持的目标，原因是它们的</st>
    <st c="10021">特权角色。</st>
- en: <st c="10037">Adopt a zero-trust approach to all main release branches for everyone
    with exceptions only in rare scenarios</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10037">采用零信任方法，适用于所有主要发布分支，只有在极少数情况下才允许例外。</st>
- en: <st c="10146">In GitHub</st> <st c="10157">Enterprise, we can activate the</st>
    **<st c="10189">Do not allow bypassing the above settings</st>** <st c="10230">option
    in our branch protection rule (see</st> *<st c="10273">Figure 7</st>**<st c="10281">.5</st>*<st
    c="10283">).</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10146">在 GitHub</st> <st c="10157">Enterprise 中，我们可以激活</st> **<st c="10189">不允许绕过上述设置</st>**
    <st c="10230">选项，作为我们的分支保护规则的一部分（参见</st> *<st c="10273">图 7</st>**<st c="10281">.5</st>*<st
    c="10283">）。</st>
- en: '![Figure 7.5 – Enforce branch protection settings for everyone in GitHub Enterprise](img/B19710_07_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 在 GitHub Enterprise 中强制执行所有人的分支保护设置](img/B19710_07_05.jpg)'
- en: <st c="10729">Figure 7.5 – Enforce branch protection settings for everyone in
    GitHub Enterprise</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10729">图 7.5 – 在 GitHub Enterprise 中强制执行所有人的分支保护设置</st>
- en: <st c="10810">In Azure DevOps, there is no equivalent setting for this, but
    we can restrict or audit roles/users with permissions to bypass policies on pull
    requests and pushes.</st> <st c="10975">By default, no role, including administrators,
    has these permissions assigned (see</st> *<st c="11058">Figure 7</st>**<st c="11066">.6</st>*<st
    c="11068">).</st> <st c="11072">To review permissions in Azure DevOps, navigate
    to</st> **<st c="11123">Project Settings</st>** <st c="11139">|</st> **<st c="11142">Repos</st>**
    <st c="11147">|</st> **<st c="11150">Repositories</st>**<st c="11162">, select
    a</st> **<st c="11173">repository</st>**<st c="11183">, then</st> **<st c="11190">Security</st>**<st
    c="11198">, and check</st> **<st c="11210">Bypass policies when completing pull
    requests</st>** <st c="11255">and</st> **<st c="11260">Bypass policies when pushing</st>**
    <st c="11288">(</st>*<st c="11290">Figure 7</st>**<st c="11298">.6</st>*<st c="11300">).</st>
    <st c="11304">The permission can also be configured at the branch level, rather
    than the</st> <st c="11379">repository level.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10810">在 Azure DevOps 中没有类似的设置，但我们可以限制或审计有权限绕过拉取请求和推送策略的角色/用户。</st> <st
    c="10975">默认情况下，没有任何角色，包括管理员，拥有这些权限（参见</st> *<st c="11058">图 7</st>**<st c="11066">.6</st>*<st
    c="11068">）。</st> <st c="11072">要在 Azure DevOps 中查看权限，导航至</st> **<st c="11123">项目设置</st>**
    <st c="11139">|</st> **<st c="11142">代码库</st>** <st c="11147">|</st> **<st c="11150">仓库</st>**<st
    c="11162">，选择一个</st> **<st c="11173">仓库</st>**<st c="11183">，然后选择</st> **<st c="11190">安全</st>**<st
    c="11198">，并检查</st> **<st c="11210">完成拉取请求时绕过策略</st>** <st c="11255">和</st> **<st
    c="11260">推送时绕过策略</st>** <st c="11288">(</st>*<st c="11290">图 7</st>**<st c="11298">.6</st>*<st
    c="11300">)。</st> <st c="11304">该权限也可以在分支级别配置，而不是在</st> <st c="11379">仓库级别。</st>
- en: '![Figure 7.6 – Reviewing permissions to bypass branch protection policies in
    Azure DevOps](img/B19710_07_06.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 在 Azure DevOps 中查看绕过分支保护策略的权限](img/B19710_07_06.jpg)'
- en: <st c="12078">Figure 7.6 – Reviewing permissions to bypass branch protection
    policies in Azure DevOps</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12078">图 7.6 – 在 Azure DevOps 中查看绕过分支保护策略的权限</st>
- en: <st c="12165">In case</st> <st c="12174">of a compromise of an administrator
    account, branch protection settings could be disabled to allow an attacker to
    fast-track malicious code changes to production by bypassing the required checks.</st>
    <st c="12370">For this reason, it is important to also track and audit branch
    protection and sensitive permission changes to spot unusual bypass attempts.</st>
    *<st c="12511">Figure 7</st>**<st c="12519">.7</st>* <st c="12521">shows an example
    audit log entry for a modification to a sensitive branch protection setting in</st>
    <st c="12618">GitHub Enterprise.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12165">如果</st> <st c="12174">管理员帐户被攻破，分支保护设置可能会被禁用，允许攻击者绕过必需的检查，快速将恶意代码更改推送到生产环境。</st>
    <st c="12370">因此，跟踪和审计分支保护及敏感权限的更改非常重要，以便发现异常的绕过尝试。</st> *<st c="12511">图 7</st>**<st
    c="12519">.7</st>* <st c="12521">展示了在</st> <st c="12618">GitHub Enterprise 中修改敏感分支保护设置的审计日志条目的示例。</st>
- en: '![Figure 7.7 – Sample log entry for a modification to a sensitive branch protection
    setting](img/B19710_07_07.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 修改敏感分支保护设置的示例日志条目](img/B19710_07_07.jpg)'
- en: <st c="13012">Figure 7.7 – Sample log entry for a modification to a sensitive
    branch protection setting</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13012">图 7.7 – 修改敏感分支保护设置的日志示例</st>
- en: <st c="13101">For information on enabling auditing, please refer to the</st>
    *<st c="13160">Ensuring the build environment is logged</st>* <st c="13200">section
    in</st> [*<st c="13212">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122)<st
    c="13221">.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13101">有关启用审计的信息，请参考</st> *<st c="13160">确保构建环境已记录</st>* <st c="13200">部分内容，详见</st>
    [*<st c="13212">第 6 章</st>*](B19710_06.xhtml#_idTextAnchor122)<st c="13221">。</st>
- en: <st c="13222">Implementing a code review process</st>
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="13222">实施代码审查流程</st>
- en: <st c="13257">Another good security measure is to require human-led reviews
    for both the release branches</st> <st c="13350">and the deployment workflow/pipeline
    configuration files.</st> <st c="13408">This should be in addition to automated
    security scans that are enforced for code to be merged with the release branches.</st>
    <st c="13530">Automated scans are useful but can be bypassed, hence the need for
    human checks.</st> <st c="13611">Even with necessary controls in place, new bypass
    methods may be discovered.</st> <st c="13688">Including experienced human reviewers
    provides an additional layer of defense against potential</st> <st c="13784">malicious
    attacks.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13257">另一个好的安全措施是要求对发布分支</st> <st c="13350">和部署工作流/管道配置文件进行人工审查。</st>
    <st c="13408">这应该作为代码与发布分支合并前强制执行的自动化安全扫描之外的额外措施。</st> <st c="13530">自动化扫描是有用的，但可能会被绕过，因此需要人工检查。</st>
    <st c="13611">即使实施了必要的控制，也可能会发现新的绕过方法。</st> <st c="13688">包括经验丰富的人工审阅者提供了一层额外的防护，防止潜在的</st>
    <st c="13784">恶意攻击。</st>
- en: <st c="13802">Both the GitHub Enterprise and Azure DevOps platforms support
    granular implementation of code reviewers where we can assign different reviewers
    for different paths of the code base.</st> <st c="13985">In Azure DevOps, this
    can be implemented with a branch protection control while in GitHub Enterprise,
    this can be implemented with a branch protection control</st> <st c="14144">combined
    with a capability</st> <st c="14171">called</st> `<st c="14178">CODEOWNERS</st>`<st
    c="14188">.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13802">GitHub Enterprise 和 Azure DevOps 平台都支持细粒度的代码审阅实施，我们可以为代码库的不同路径分配不同的审阅者。</st>
    <st c="13985">在 Azure DevOps 中，这可以通过分支保护控制实现，而在 GitHub Enterprise 中，则可以通过分支保护控制</st>
    <st c="14144">结合</st> <st c="14171">一种名为</st> `<st c="14178">CODEOWNERS</st>`<st
    c="14188">的功能来实现。</st>
- en: <st c="14189">To enable granular code review in Azure DevOps, navigate to</st>
    **<st c="14250">Project Settings</st>**<st c="14266">, then</st> **<st c="14273">Repos</st>**<st
    c="14278">, and select</st> **<st c="14291">Repositories</st>**<st c="14303">.
    Choose a repository, click on</st> **<st c="14335">Policies</st>**<st c="14343">,
    and then scroll down to the</st> **<st c="14373">Branch Policies</st>** <st c="14388">section
    to find your release branch.</st> <st c="14426">Under</st> **<st c="14432">Branch
    Policies</st>**<st c="14447">, activate</st> **<st c="14458">Require a minimum
    number of reviewers</st>** <st c="14495">by setting it to</st> **<st c="14513">On</st>**<st
    c="14515">. Enter the number of required reviewers and choose from the available
    options (</st>*<st c="14595">Figure 7</st>**<st c="14604">.8</st>*<st c="14606">).</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14189">要在 Azure DevOps 中启用细粒度代码审查，请导航至</st> **<st c="14250">项目设置</st>**<st
    c="14266">，然后选择</st> **<st c="14273">仓库</st>**<st c="14278">，接着点击</st> **<st c="14291">仓库</st>**<st
    c="14303">。选择一个仓库，点击</st> **<st c="14335">策略</st>**<st c="14343">，然后滚动到</st> **<st
    c="14373">分支策略</st>** <st c="14388">部分，找到你的发布分支。</st> <st c="14426">在</st> **<st
    c="14432">分支策略</st>**<st c="14447">下，激活</st> **<st c="14458">要求最低数量的审阅者</st>**
    <st c="14495">并将其设置为</st> **<st c="14513">开启</st>**<st c="14515">。输入所需的审阅者数量，并从可用选项中选择（</st>*<st
    c="14595">图 7</st>**<st c="14604">.8</st>*<st c="14606">）。</st>
- en: '![Figure 7.8 – Enabling human-led code reviews in Azure DevOps](img/B19710_07_08.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 在 Azure DevOps 中启用人工代码审查](img/B19710_07_08.jpg)'
- en: <st c="15304">Figure 7.8 – Enabling human-led code reviews in Azure DevOps</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15304">图 7.8 – 在 Azure DevOps 中启用人工代码审查</st>
- en: <st c="15364">We can</st> <st c="15372">also automatically add reviewers to
    pull requests that change files in specific directories and files.</st> <st c="15475">For
    example, we may want to add members of the security team to review any change
    to the pipeline file or security champions in the development team to review code
    changes to the release branch.</st> <st c="15670">We can do this by configuring
    the option to</st> **<st c="15714">Automatically include reviewers</st>** <st
    c="15745">(</st>*<st c="15747">Figure 7</st>**<st c="15755">.9</st>*<st c="15757">).</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15364">我们还可以</st> <st c="15372">自动向拉取请求中添加审查者，审查那些更改特定目录和文件中的内容的文件。</st>
    <st c="15475">例如，我们可能希望将安全团队的成员添加为审查者，以审查任何对管道文件的更改，或者将开发团队中的安全冠军添加为审查者，以审查发布分支的代码更改。</st>
    <st c="15670">我们可以通过配置选项来实现这一点，</st> **<st c="15714">自动添加审查者</st>** <st c="15745">(</st>*<st
    c="15747">图 7</st>**<st c="15755">.9</st>*<st c="15757">)。</st>
- en: '![Figure 7.9 – Adding required reviewers in an Azure repository branch policy](img/B19710_07_09.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 在 Azure 仓库分支策略中添加必需的审查者](img/B19710_07_09.jpg)'
- en: <st c="16089">Figure 7.9 – Adding required reviewers in an Azure repository
    branch policy</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16089">图 7.9 – 在 Azure 仓库分支策略中添加必需的审查者</st>
- en: <st c="16164">If the setting is marked as</st> **<st c="16193">Required</st>**<st
    c="16201">, every individual listed as a reviewer must approve the changes.</st>
    <st c="16267">If group names are added as reviewers, at least one member from
    each group</st> <st c="16342">must approve the changes.</st> <st c="16368">If
    approval is required from only one group, then the number of approvals needed
    is the minimum number specified for that group.</st> <st c="16497">For example,
    a group could be formed for each development team that includes the security champions
    from the team, and this group would be required as a reviewer.</st> <st c="16660">This
    ensures that at least one person with security experience and training reviews
    the code changes before they</st> <st c="16773">are approved.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16164">如果设置标记为</st> **<st c="16193">必需</st>**<st c="16201">，则每个列为审查者的个人必须批准更改。</st>
    <st c="16267">如果将小组名称添加为审查者，则每个小组至少需要有一个成员</st> <st c="16342">批准更改。</st> <st c="16368">如果只需要一个小组的批准，那么所需的批准数就是该小组指定的最小数量。</st>
    <st c="16497">例如，可以为每个开发团队组成一个小组，其中包括该团队的安全冠军，而该小组将作为审查者。</st> <st c="16660">这可以确保至少有一个具有安全经验和培训的人在批准之前审查代码更改。</st>
    <st c="16773">被批准。</st>
- en: <st c="16786">For GitHub Enterprise, we can enable a branch protection rule
    to require a pull request before merging by selecting the</st> `<st c="17031">CODEOWNERS</st>`
    <st c="17041">file (</st>*<st c="17048">Figure 7</st>**<st c="17057">.10</st>*<st
    c="17060">).</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16786">对于 GitHub Enterprise，我们可以启用一个分支保护规则，在合并之前要求拉取请求，通过选择</st> `<st
    c="17031">CODEOWNERS</st>` <st c="17041">文件 (</st>*<st c="17048">图 7</st>**<st
    c="17057">.10</st>*<st c="17060">)。</st>
- en: '![Figure 7.10 – Enabling a Code Owners review in a GitHub Enterprise branch
    protection policy](img/B19710_07_10.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 在 GitHub Enterprise 分支保护策略中启用代码拥有者审查](img/B19710_07_10.jpg)'
- en: <st c="18171">Figure 7.10 – Enabling a Code Owners review in a GitHub Enterprise
    branch protection policy</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18171">图 7.10 – 在 GitHub Enterprise 分支保护策略中启用代码拥有者审查</st>
- en: <st c="18262">CODEOWNERS</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18262">CODEOWNERS</st>
- en: '`<st c="18273">CODEOWNERS</st>` <st c="18284">is a feature</st> <st c="18298">of
    GitHub that we can use to specify individuals or teams that are responsible for
    maintaining specific parts of a project.</st> <st c="18422">When changes are made
    to those parts, the designated code owners are automatically required to review
    and approve the changes before they can be merged.</st> <st c="18575">We can use
    this feature to implement code reviews for release branches and deployment</st>
    <st c="18661">workflow files.</st>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18273">CODEOWNERS</st>` <st c="18284">是 GitHub 的一个功能</st> <st c="18298">，我们可以用它指定负责维护项目特定部分的个人或团队。</st>
    <st c="18422">当对这些部分进行更改时，指定的代码拥有者会自动被要求审查并批准这些更改，才能合并。</st> <st c="18575">我们可以使用此功能为发布分支和部署</st>
    <st c="18661">工作流文件实施代码审查。</st>'
- en: <st c="18676">To use</st> `<st c="18684">CODEOWNERS</st>`<st c="18694">, we
    need to create a file called</st> `<st c="18728">CODEOWNERS</st>` <st c="18738">in
    the</st> `<st c="18746">.github/</st>`<st c="18754">,</st> `<st c="18756">root</st>`<st
    c="18760">, or</st> `<st c="18765">docs/</st>` <st c="18770">directory of the
    repository.</st> <st c="18800">The file uses a pattern that follows most (not
    all) of the same rules used in</st> `<st c="18878">gitignore</st>` <st c="18887">files.</st>
    <st c="18895">For example, a line entry of</st> `<st c="18924">/workflows/ @dev
    @security</st>` <st c="18950">means that any changes inside the</st> `<st c="18985">/workflows</st>`
    <st c="18995">directory will require approval from members of the</st> `<st c="19048">@dev
    or @security</st>` <st c="19065">teams, but approvals from both are</st> <st c="19101">not
    required.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18676">要使用</st> `<st c="18684">CODEOWNERS</st>`<st c="18694">，我们需要在</st>
    `<st c="18728">CODEOWNERS</st>` <st c="18738">文件中创建一个文件，文件路径为</st> `<st c="18746">.github/</st>`<st
    c="18754">、</st> `<st c="18756">根目录</st>`<st c="18760">，或</st> `<st c="18765">docs/</st>`
    <st c="18770">仓库目录。</st> <st c="18800">该文件使用一种模式，遵循大多数（但不是所有）在</st> `<st c="18878">gitignore</st>`
    <st c="18887">文件中使用的规则。</st> <st c="18895">例如，</st> `<st c="18924">/workflows/
    @dev @security</st>` <st c="18950">这一行条目的含义是，任何位于</st> `<st c="18985">/workflows</st>`
    <st c="18995">目录中的更改都需要</st> `<st c="19048">@dev 或 @security</st>` <st c="19065">团队成员的批准，但不需要两个团队都批准。</st>
- en: <st c="19114">A line entry of</st> `<st c="19131">**/releases @securitychampions
    @teamleaders</st>` <st c="19174">means the</st> `<st c="19185">@securitychampions</st>`
    <st c="19203">and</st> `<st c="19208">@teamleaders</st>` <st c="19220">teams own
    any file in any</st> `<st c="19247">/releases</st>` <st c="19256">directory.</st>
    <st c="19268">To</st> <st c="19271">learn more about the</st> `<st c="19292">CODEOWNERS</st>`
    <st c="19302">file, please refer to this</st> <st c="19330">document:</st> [<st
    c="19340">https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax</st>](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax)<st
    c="19491">.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19114">一行条目</st> `<st c="19131">**/releases @securitychampions @teamleaders</st>`
    <st c="19174">的含义是</st> `<st c="19185">@securitychampions</st>` <st c="19203">和</st>
    `<st c="19208">@teamleaders</st>` <st c="19220">团队拥有</st> `<st c="19247">/releases</st>`
    <st c="19256">目录中的任何文件。</st> <st c="19268">要</st> <st c="19271">了解有关</st> `<st
    c="19292">CODEOWNERS</st>` <st c="19302">文件的更多信息，请参阅以下文档：</st> [<st c="19340">https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax</st>](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax)<st
    c="19491">。</st>
- en: <st c="19492">Now that</st> <st c="19502">we understand one of some of the controls
    that we can implement to ensure release artifacts only come from validated code,
    let us move on to examine the secure storage of</st> <st c="19673">these artifacts.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19492">现在我们了解了确保发布构件仅来自经过验证代码的一些控制措施，接下来让我们探讨这些构件的安全存储。</st>
- en: <st c="19689">Selecting secure artifact sources</st>
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="19689">选择安全的构件源</st>
- en: <st c="19723">Another key security best practice in the test and release phases
    of DevOps is to secure the artifacts</st> <st c="19827">that will be deployed.</st>
    <st c="19850">These artifacts should be stored in trusted locations that maintain
    their integrity</st> <st c="19934">and prevent tampering.</st> <st c="19957">Both
    GitHub Actions and Azure Pipelines support deploying artifacts from various sources,
    such as build environments, package repositories, container repositories, file
    shares, and source control repositories.</st> *<st c="20167">Figure 7</st>**<st
    c="20175">.11</st>* <st c="20178">shows a screenshot of supported artifact sources
    for a classic Azure</st> <st c="20248">release pipeline.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19723">DevOps 测试和发布阶段的另一个关键安全最佳实践是确保将要部署的构件</st> <st c="19827">的安全性。</st>
    <st c="19850">这些构件应存储在可信的位置，以维护其完整性</st> <st c="19934">并防止篡改。</st> <st c="19957">GitHub
    Actions 和 Azure Pipelines 都支持从多种来源部署构件，例如构建环境、软件包仓库、容器仓库、文件共享和源代码控制仓库。</st> *<st
    c="20167">图 7</st>**<st c="20175">.11</st>* <st c="20178">显示了经典 Azure 发布管道支持的构件源的截图。</st>
- en: <st c="20265">DevSecOps</st> <st c="20276">requires us to only use artifact
    sources that support</st> **<st c="20330">immutability</st>**<st c="20342">,</st>
    **<st c="20344">traceability</st>**<st c="20356">, and</st> **<st c="20362">access
    control</st>**<st c="20376">. Immutability guarantees integrity by ensuring</st>
    <st c="20424">that an artifact’s contents will not change from when it is published,
    tested for security, and eventually released to production.</st> <st c="20555">This
    can be implemented</st> <st c="20579">at the artifact source level or the package
    level.</st> <st c="20630">Implementing at the source level means that our artifact
    sources should not allow any modifications to packages once published.</st> <st
    c="20758">To correct any issues, a new version should be published instead of
    modifying an existing one.</st> <st c="20853">This ensures that the content of
    the artifact that</st> <st c="20904">has been security tested is the same as the
    one deployed.</st> <st c="20962">Sources such as file shares,</st> **<st c="20991">Azure
    Container Registry</st>** <st c="21015">(</st>**<st c="21017">ACR</st>**<st c="21020">),
    and GitHub Packages should be used carefully as they are mutable by default.</st>
    <st c="21101">Anyone with the right set of permissions can update the content
    of published artifacts that are stored in them.</st> <st c="21213">This can be
    exploited by attackers to replace the original version with a compromised one</st>
    <st c="21303">before deployment.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20265">DevSecOps</st> <st c="20276">要求我们仅使用支持</st> **<st c="20330">不变性</st>**<st
    c="20342">、</st> **<st c="20344">可追溯性</st>**<st c="20356">和</st> **<st c="20362">访问控制</st>**<st
    c="20376">的工件源。不变性通过确保</st> <st c="20424">工件的内容从发布、进行安全测试到最终发布到生产环境时不会发生变化，从而保证完整性。</st>
    <st c="20555">这可以在工件源级别或包级别实现。</st> <st c="20579">在源级别实现意味着我们的工件源一旦发布后，不应允许对包进行任何修改。</st>
    <st c="20630">要纠正任何问题，应该发布新版本，而不是修改现有版本。</st> <st c="20758">这确保了已进行安全测试的工件内容与实际部署的工件内容相同。</st>
    <st c="20853">像文件共享、</st> **<st c="20991">Azure 容器注册表</st>** <st c="21015">（</st>**<st
    c="21017">ACR</st>**<st c="21020">）和 GitHub 包等来源应谨慎使用，因为它们默认是可变的。</st> <st c="21101">任何拥有正确权限的人都可以更新存储在这些源中的已发布工件的内容。</st>
    <st c="21213">攻击者可以利用这一点，在部署前将原版本替换为已被篡改的版本。</st> <st c="21303">。</st>
- en: '![Figure 7.11 – Supported artifact sources for a classic Azure release pipeline](img/B19710_07_11.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 经典 Azure 发布管道的支持工件源](img/B19710_07_11.jpg)'
- en: <st c="21464">Figure 7.11 – Supported artifact sources for a classic Azure release
    pipeline</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21464">图 7.11 – 经典 Azure 发布管道的支持工件源</st>
- en: <st c="21541">For ACR, we can</st> <st c="21558">enforce immutability at the
    artifact store level by configuring image locking.</st> <st c="21637">This is
    achieved using the</st> `<st c="21664">az acr repository update</st>` <st c="21688">command.</st>
    *<st c="21698">Figure 7</st>**<st c="21706">.12</st>* <st c="21709">shows a sample
    GitHub workflow that uses this command to lock a new container image in the build
    and</st> <st c="21811">publish phase.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21541">对于 ACR，我们可以</st> <st c="21558">通过配置镜像锁定，在工件存储级别强制实施不变性。</st> <st
    c="21637">这是通过使用</st> `<st c="21664">az acr repository update</st>` <st c="21688">命令来实现的。</st>
    *<st c="21698">图 7</st>**<st c="21706">.12</st>* <st c="21709">展示了一个使用此命令将新的容器镜像锁定在构建和</st>
    <st c="21811">发布阶段的 GitHub 工作流示例。</st>
- en: '![Figure 7.12 – Sample GitHub workflow with ACR image locking](img/B19710_07_12.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 带 ACR 镜像锁定的 GitHub 工作流示例](img/B19710_07_12.jpg)'
- en: <st c="22553">Figure 7.12 – Sample GitHub workflow with ACR image locking</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22553">图 7.12 – 带 ACR 镜像锁定的 GitHub 工作流示例</st>
- en: <st c="22612">Immutability is one of several factors to consider when selecting
    artifact sources.</st> <st c="22697">Other important factors to consider are traceability
    and versioning.</st> <st c="22766">Traceability gives visibility into a package’s
    origin and links it to code changes, test cases, and work items.</st> <st c="22878">This
    makes it easier to perform forensic auditing in case of a breach.</st> <st c="22949">Versioning
    allows us to track security outcomes between different versions of our artifacts
    and allows quick rollbacks to secure versions when facing major</st> <st c="23105">zero-day
    vulnerabilities.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22612">不变性是选择工件源时需要考虑的几个因素之一。</st> <st c="22697">其他重要的因素包括可追溯性和版本控制。</st>
    <st c="22766">可追溯性使我们能够查看包的来源，并将其与代码更改、测试用例和工作项关联起来。</st> <st c="22878">这使得在发生安全漏洞时，进行法医审计变得更加容易。</st>
    <st c="22949">版本控制使我们能够在不同版本的工件之间跟踪安全结果，并在面临重大</st> <st c="23105">零日漏洞时，快速回滚到安全版本。</st>
- en: <st c="23130">Support for</st> <st c="23143">traceability and versioning varies
    by artifact source.</st> <st c="23198">For example, file shares are basic storage
    solutions that typically lack built-in versioning and traceability to source control.</st>
    <st c="23327">Implementing these features in file shares usually requires additional
    tools or</st> <st c="23407">custom configurations.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23130">对</st> <st c="23143">可追溯性和版本控制的支持因工件来源而异。</st> <st c="23198">例如，文件共享是基本的存储解决方案，通常缺乏内建的版本控制和源控制的可追溯性。</st>
    <st c="23327">在文件共享中实现这些功能通常需要额外的工具或</st> <st c="23407">自定义配置。</st>
- en: <st c="23429">File shares are generally not recommended as artifact sources
    in DevOps workflows.</st> <st c="23513">Workflow/pipeline artifacts naturally
    include these features, while ACR, GitHub Packages, and Azure Artifacts might
    also need</st> <st c="23639">extra configuration.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23429">一般来说，文件共享不推荐作为 DevOps 工作流中的工件来源。</st> <st c="23513">工作流/管道工件本身通常包含这些功能，而
    ACR、GitHub Packages 和 Azure Artifacts 可能还需要</st> <st c="23639">额外的配置。</st>
- en: <st c="23659">Understanding workflow/pipeline artifacts</st>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="23659">理解工作流/管道工件</st>
- en: <st c="23701">Both GitHub</st> <st c="23714">Actions and Azure Pipelines support
    options to publish artifacts internally within the build platform.</st> <st c="23817">For
    GitHub Actions, the</st> `<st c="23841">upload-artifact</st>` <st c="23856">action
    can be used to upload an artifact into an</st> **<st c="23906">Actions artifacts</st>**
    <st c="23923">store (</st>*<st c="23931">Figure 7</st>**<st c="23940">.13</st>*<st
    c="23943">).</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23701">GitHub</st> <st c="23714">Actions 和 Azure Pipelines 都支持将工件发布到构建平台内部的选项。</st>
    <st c="23817">对于 GitHub Actions，</st> `<st c="23841">upload-artifact</st>` <st
    c="23856">操作可以用来将工件上传到</st> **<st c="23906">Actions 工件</st>** <st c="23923">存储库（</st>*<st
    c="23931">图 7</st>**<st c="23940">.13</st>*<st c="23943">）。</st>
- en: '![Figure 7.13 – GitHub Actions upload-artifact action](img/B19710_07_13.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – GitHub Actions 上传工件操作](img/B19710_07_13.jpg)'
- en: <st c="24500">Figure 7.13 – GitHub Actions upload-artifact action</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24500">图 7.13 – GitHub Actions 上传工件操作</st>
- en: <st c="24551">For Azure</st> <st c="24562">Pipelines, the</st> `<st c="24577">PublishPipelineArtifact</st>`
    <st c="24600">or</st> `<st c="24604">PublishBuildArtifact</st>` <st c="24624">tasks
    can be used for the same purpose (</st>*<st c="24665">Figure 7</st>**<st c="24674">.14</st>*<st
    c="24677">).</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24551">对于 Azure</st> <st c="24562">Pipelines，可以使用</st> `<st c="24577">PublishPipelineArtifact</st>`
    <st c="24600">或</st> `<st c="24604">PublishBuildArtifact</st>` <st c="24624">任务来实现相同的目的（</st>*<st
    c="24665">图 7</st>**<st c="24674">.14</st>*<st c="24677">）。</st>
- en: '![Figure 7.14 – Azure Pipelines PublishPipelineArtifact task](img/B19710_07_14.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – Azure Pipelines 发布 Pipeline 工件任务](img/B19710_07_14.jpg)'
- en: <st c="25294">Figure 7.14 – Azure Pipelines PublishPipelineArtifact task</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25294">图 7.14 – Azure Pipelines 发布 Pipeline 工件任务</st>
- en: <st c="25352">These options are popular because they are easy to use, yet they
    impact immutability and traceability.</st> <st c="25456">Because the artifacts
    are stored within the build platform and they have a link to the workflow/pipeline
    run or job that created them, so, in this case, they offer built-in traceability.</st>
    <st c="25643">However, retention policies and behavior should also be considered
    to understand the overall impact.</st> <st c="25744">For example, GitHub Enterprise
    stores action</st> <st c="25789">artifacts for 90 days, but this can be extended
    up to 400 days.</st> <st c="25853">The customization can be done at the Enterprise,
    Organization, or Repository levels (</st>*<st c="25938">Figure 7</st>**<st c="25947">.15</st>*<st
    c="25950">).</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25352">这些选项之所以受欢迎，是因为它们易于使用，但它们会影响不可变性和可追溯性。</st> <st c="25456">因为这些工件存储在构建平台中，并且它们与创建它们的工作流/管道运行或作业有链接，因此在这种情况下，它们提供了内建的可追溯性。</st>
    <st c="25643">然而，也应考虑保留策略和行为，以了解其整体影响。</st> <st c="25744">例如，GitHub Enterprise
    存储操作</st> <st c="25789">工件 90 天，但这一期限可以延长至 400 天。</st> <st c="25853">定制化可以在企业、组织或仓库级别进行（</st>*<st
    c="25938">图 7</st>**<st c="25947">.15</st>*<st c="25950">）。</st>
- en: '![Figure 7.15 – Configuring the retention period for GitHub workflow artifacts](img/B19710_07_15.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – 配置 GitHub 工作流工件的保留期限](img/B19710_07_15.jpg)'
- en: <st c="26239">Figure 7.15 – Configuring the retention period for GitHub workflow
    artifacts</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26239">图 7.15 – 配置 GitHub 工作流工件的保留期限</st>
- en: <st c="26315">Configuring artifact retention period in GitHub Enterprise</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26315">在 GitHub Enterprise 中配置工件保留期</st>
- en: <st c="26374">The</st> <st c="26379">artifacts retention settings can be customized
    at different levels in</st> <st c="26449">GitHub Enterprise:</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26374">工件</st> <st c="26379">的保留设置可以在以下不同级别进行定制：</st> <st c="26449">GitHub
    Enterprise：</st>
- en: '**<st c="26467">Enterprise</st>**<st c="26478">: Go to</st> **<st c="26487">Settings</st>**
    <st c="26495">|</st> **<st c="26498">Policies</st>** <st c="26506">|</st> **<st
    c="26509">Actions</st>** <st c="26516">|</st> **<st c="26519">Policies</st>**
    <st c="26527">|</st> **<st c="26530">Artifact and</st>** **<st c="26543">log retention</st>**<st
    c="26556">.</st>'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="26467">企业</st>**<st c="26478">：前往</st> **<st c="26487">设置</st>** <st
    c="26495">|</st> **<st c="26498">策略</st>** <st c="26506">|</st> **<st c="26509">操作</st>**
    <st c="26516">|</st> **<st c="26519">策略</st>** <st c="26527">|</st> **<st c="26530">工件和</st>**
    **<st c="26543">日志保留</st>**<st c="26556">。</st>'
- en: '**<st c="26557">Organization</st>**<st c="26570">: Go to</st> **<st c="26579">Settings</st>**
    <st c="26587">|</st> **<st c="26590">Code, planning, and automation</st>** <st
    c="26620">|</st> **<st c="26623">Actions</st>** <st c="26630">|</st> **<st c="26633">General</st>**
    <st c="26640">|</st> **<st c="26643">Artifact and</st>** **<st c="26656">log retention</st>**<st
    c="26669">.</st>'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="26557">组织</st>**<st c="26570">：前往</st> **<st c="26579">设置</st>** <st
    c="26587">|</st> **<st c="26590">代码、规划与自动化</st>** <st c="26620">|</st> **<st c="26623">操作</st>**
    <st c="26630">|</st> **<st c="26633">常规</st>** <st c="26640">|</st> **<st c="26643">工件和</st>**
    **<st c="26656">日志保留</st>**<st c="26669">。</st>'
- en: '**<st c="26670">Repository</st>**<st c="26681">: Go to</st> **<st c="26690">Settings</st>**
    <st c="26698">|</st> **<st c="26701">Code and automation</st>** <st c="26720">|</st>
    **<st c="26723">Actions</st>** <st c="26730">|</st> **<st c="26733">General</st>**
    <st c="26740">|</st> **<st c="26743">Artifact and</st>** **<st c="26756">log retention</st>**<st
    c="26769">.</st>'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="26670">仓库</st>**<st c="26681">：前往</st> **<st c="26690">设置</st>** <st
    c="26698">|</st> **<st c="26701">代码与自动化</st>** <st c="26720">|</st> **<st c="26723">操作</st>**
    <st c="26730">|</st> **<st c="26733">常规</st>** <st c="26740">|</st> **<st c="26743">工件和</st>**
    **<st c="26756">日志保留</st>**<st c="26769">。</st>'
- en: <st c="26770">The chosen retention period affects traceability.</st> <st c="26821">If
    we set a retention period of 100 days and we need to download a previous artifact
    from 120 days ago to investigate a recently discovered breach, we won’t be able
    to do so, unless we have transferred the artifact to another storage location.</st>
    <st c="27065">In Azure Pipelines, deleting a pipeline run also deletes all associated
    artifacts.</st> <st c="27148">This can also compromise traceability if a deleted
    artifact needs to be</st> <st c="27220">investigated later.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26770">选择的保留期限会影响可追溯性。</st> <st c="26821">如果我们设置了 100 天的保留期，而我们需要下载 120
    天前的某个工件以调查最近发现的漏洞，我们将无法做到这一点，除非我们已经将该工件转移到其他存储位置。</st> <st c="27065">在 Azure Pipelines
    中，删除管道运行也会删除所有关联的工件。</st> <st c="27148">如果删除的工件稍后需要调查，这也可能会影响可追溯性。</st>
- en: <st c="27239">From an immutabilit</st><st c="27259">y standpoint, the GitHub</st>
    `<st c="27285">upload-artifact</st>` <st c="27300">action can overwrite artifacts
    if the</st> `<st c="27339">overwrite</st>` <st c="27348">option is enabled (</st>*<st
    c="27368">Figure 7</st>**<st c="27377">.16</st>*<st c="27380">).</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27239">从不变性</st><st c="27259">的角度来看，GitHub</st> `<st c="27285">upload-artifact</st>`
    <st c="27300">操作如果启用</st> `<st c="27339">覆盖</st>` <st c="27348">选项，可以覆盖工件（</st>*<st
    c="27368">图 7</st>**<st c="27377">.16</st>*<st c="27380">）。</st>
- en: '![Figure 7.16 – Implementing an artifact overwrite](img/B19710_07_16.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – 实现工件覆盖](img/B19710_07_16.jpg)'
- en: <st c="27576">Figure 7.16 – Implementing an artifact overwrite</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27576">图 7.16 – 实现工件覆盖</st>
- en: <st c="27624">If developers</st> <st c="27639">do not pin release artifacts
    by IDs and use names instead, this could be exploited in an artifact swap attack.</st>
    <st c="27750">The Azure Pipelines</st> `<st c="27770">PublishPipelineArtifact@1</st>`
    <st c="27795">task behaves differently from this.</st> <st c="27832">It is designed
    to ensure immutable artifacts for a given build.</st> <st c="27896">Once published,
    another artifact with the same name cannot</st> <st c="27955">be published.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27624">如果开发人员</st> <st c="27639">没有通过 ID 锁定发布工件，而是使用名称，那么可能会在工件交换攻击中被利用。</st>
    <st c="27750">Azure Pipelines</st> `<st c="27770">PublishPipelineArtifact@1</st>`
    <st c="27795">任务的行为与此不同。</st> <st c="27832">它的设计目的是确保给定构建的工件不可变。</st> <st c="27896">一旦发布，不能再发布另一个具有相同名称的工件。</st>
- en: <st c="27968">Note</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27968">注意</st>
- en: <st c="27973">For more information on the action and task behavior, refer to
    the</st> <st c="28041">following documents:</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27973">有关操作和任务行为的更多信息，请参阅</st> <st c="28041">以下文档：</st>
- en: '`<st c="28061">upload-artifact</st>`<st c="28077">:</st> [<st c="28080">https://github.com/actions/upload-artifact</st>](https://github.com/actions/upload-artifact)<st
    c="28122">.</st>'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="28061">upload-artifact</st>`<st c="28077">：</st> [<st c="28080">https://github.com/actions/upload-artifact</st>](https://github.com/actions/upload-artifact)<st
    c="28122">。</st>'
- en: '`<st c="28123">PublishPipelineArtifact@1</st>`<st c="28149">:</st> [<st c="28152">https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/publish-pipeline-artifact-v1</st>](https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/publish-pipeline-artifact-v1)<st
    c="28253">.</st>'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="28123">PublishPipelineArtifact@1</st>`<st c="28149">：</st> [<st c="28152">https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/publish-pipeline-artifact-v1</st>](https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/publish-pipeline-artifact-v1)<st
    c="28253">。</st>'
- en: <st c="28254">Now that we have discussed security considerations for using workflow/pipeline
    artifacts as release sources, let us explore similar considerations for</st> <st
    c="28406">standalone services.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28254">现在我们已经讨论了使用工作流/管道工件作为发布源的安全性问题，接下来让我们探讨独立服务的类似安全考虑。</st>
- en: <st c="28426">Understanding Azure Artifacts and GitHub Packages</st>
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="28426">理解 Azure Artifacts 和 GitHub Packages</st>
- en: <st c="28476">Both GitHub Enterprise and Azure DevOps provide standalone services
    for storing and managing</st> <st c="28570">release artifacts.</st> <st c="28589">GitHub
    Enterprise offers GitHub Packages, while Azure DevOps provides Azure Artifacts.</st>
    <st c="28676">Both services</st> <st c="28690">support feeds that can handle various
    package types such as NPM, NuGet, Maven, Python, and Universal packages.</st>
    <st c="28801">GitHub Packages also supports</st> <st c="28831">containers while
    Azure Artifacts does</st> <st c="28869">not.</st> <st c="28874">Azure offers ACR
    for storing containers.</st> <st c="28915">From a security consideration, both
    services are similar (</st>*<st c="28973">Figure 7</st>**<st c="28982">.17</st>*<st
    c="28985">).</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28476">GitHub Enterprise 和 Azure DevOps 都提供用于存储和管理</st> <st c="28570">发布工件的独立服务。</st>
    <st c="28589">GitHub Enterprise 提供 GitHub Packages，而 Azure DevOps 提供 Azure Artifacts。</st>
    <st c="28676">这两项服务</st> <st c="28690">都支持可以处理各种包类型（如 NPM、NuGet、Maven、Python 和
    Universal 包）的源。</st> <st c="28801">GitHub Packages 还支持</st> <st c="28831">容器，而
    Azure Artifacts 则</st> <st c="28869">不支持。</st> <st c="28874">Azure 提供 ACR 用于存储容器。</st>
    <st c="28915">从安全性的角度来看，这两项服务是相似的（</st>*<st c="28973">图 7</st>**<st c="28982">.17</st>*<st
    c="28985">）。</st>
- en: '![Figure 7.17 – Security considerations in GitHub Packages and Azure Artifacts](img/B19710_07_17.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.17 – GitHub Packages 和 Azure Artifacts 中的安全考虑](img/B19710_07_17.jpg)'
- en: <st c="29156">Figure 7.17 – Security considerations in GitHub Packages and Azure
    Artifacts</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29156">图 7.17 – GitHub Packages 和 Azure Artifacts 中的安全考虑</st>
- en: <st c="29232">Packages in both GitHub Packages and Azure Artifacts are immutable
    by default.</st> <st c="29312">Once a package version is published, it cannot
    be modified.</st> <st c="29372">Any updates or fixes must be published as new
    versions, ensuring that deployed artifacts are consistent with those that have
    been verified.</st> <st c="29512">Traceability in Azure Artifacts is primarily
    managed through integration with Azure DevOps services.</st> <st c="29613">Each
    artifact is linked to a specific pipeline run, including details such as build
    number and associated commits.</st> <st c="29728">This data is crucial for reconstructing
    the artifact’s development history.</st> <st c="29804">Each package in GitHub
    Packages stores detailed provenance information including the commit SHA, branch,
    or tag from which it was built.</st> <st c="29941">This level of detail is particularly
    valuable for compliance and</st> <st c="30006">security auditing.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29232">GitHub Packages 和 Azure Artifacts 中的工件默认是不可变的。</st> <st c="29312">一旦发布了某个版本的工件，它就不能被修改。</st>
    <st c="29372">任何更新或修复必须作为新版本发布，从而确保已部署的工件与经过验证的工件一致。</st> <st c="29512">Azure
    Artifacts 中的可追溯性主要通过与 Azure DevOps 服务的集成来管理。</st> <st c="29613">每个工件都与特定的管道运行相关联，包含构建编号和关联的提交等详细信息。</st>
    <st c="29728">这些数据对于重建工件的开发历史至关重要。</st> <st c="29804">GitHub Packages 中的每个包都存储详细的来源信息，包括构建该包的提交
    SHA、分支或标签。</st> <st c="29941">这种详细程度对于合规性和</st> <st c="30006">安全审计尤为重要。</st>
- en: <st c="30024">Implementing artifact signing for integrity checks</st>
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="30024">实施工件签名以进行完整性检查</st>
- en: <st c="30075">Securing</st> <st c="30085">the DevOps</st> <st c="30096">workflow
    involves ensuring the integrity of every step in the software supply chain.</st>
    <st c="30181">If an attacker breaches the artifact store, they could tamper with
    packages meant for production and upload unauthorized artifacts.</st> <st c="30313">For
    example, in the CodeCov incident, an attacker used leaked credentials to upload
    a harmful artifact, leading to direct downloads by users.</st> <st c="30455">One
    mitigation strategy is to enforce an integrity validation process for all release
    artifacts.</st> <st c="30552">This includes signing packages and verifying digital
    signatures before deployment.</st> <st c="30635">Various tools</st> <st c="30649">and
    approaches could be used for this, but two common</st> <st c="30703">ones are</st>
    **<st c="30712">Sigstore’s Cosign</st>** <st c="30729">and</st> **<st c="30734">Notation</st>**<st
    c="30742">. Let us</st> <st c="30751">review these.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30075">确保</st> <st c="30085">DevOps</st> <st c="30096">工作流的安全性涉及确保软件供应链中每个步骤的完整性。</st>
    <st c="30181">如果攻击者突破了工件存储，他们可能篡改本应用于生产的包并上传未经授权的工件。</st> <st c="30313">例如，在CodeCov事件中，攻击者利用泄露的凭证上传了一个有害的工件，导致用户直接下载。</st>
    <st c="30455">一种缓解策略是强制执行所有发布工件的完整性验证过程。</st> <st c="30552">这包括对包进行签名并在部署之前验证数字签名。</st>
    <st c="30635">可以使用各种工具</st> <st c="30649">和方法来实现这一点，但两个常见的</st> <st c="30703">方法是</st>
    **<st c="30712">Sigstore的Cosign</st>** <st c="30729">和</st> **<st c="30734">Notation</st>**<st
    c="30742">。我们来</st> <st c="30751">回顾一下这些。</st>
- en: <st c="30764">Implementing artifact signing using Sigstore’s Cosign</st>
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="30764">使用Sigstore的Cosign实现工件签名</st>
- en: '**<st c="30818">Sigstore</st>** <st c="30827">is a set</st> <st c="30837">of
    open-source tools designed to automate the digital signing</st> <st c="30899">and
    verification of software</st> <st c="30928">artifacts.</st> <st c="30939">It is
    primarily aimed at software artifacts such as container images and binaries, but
    it can be used for any file type, including ZIP archives.</st> <st c="31084">It
    combines several tools and technologies, including</st> <st c="31138">the following:</st>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="30818">Sigstore</st>** <st c="30827">是一套</st> <st c="30837">旨在自动化软件工件的数字签名</st>
    <st c="30899">和验证的开源工具</st> <st c="30928">。它主要针对容器镜像和二进制文件等软件工件，但也可以用于任何文件类型，包括ZIP压缩包。</st>
    <st c="31084">它结合了几种工具和技术，包括</st> <st c="31138">以下内容：</st>'
- en: '**<st c="31152">Cosign</st>**<st c="31159">: This</st> <st c="31167">signs
    and verifies containers</st> <st c="31197">and artifacts</st>'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="31152">Cosign</st>**<st c="31159">：用于</st> <st c="31167">签名和验证容器</st>
    <st c="31197">及工件</st>'
- en: '**<st c="31210">Fulcio</st>**<st c="31217">: A free</st> <st c="31227">root
    certification authority that issues</st> <st c="31268">temporary certificates</st>'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="31210">Fulcio</st>**<st c="31217">：一个免费的</st> <st c="31227">根证书颁发机构，颁发</st>
    <st c="31268">临时证书</st>'
- en: '**<st c="31290">Rekor</st>**<st c="31296">: This records</st> <st c="31312">signed
    metadata to a</st> <st c="31333">tamper-resistant ledger</st>'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="31290">Rekor</st>**<st c="31296">：它将</st> <st c="31312">签名元数据记录到</st>
    <st c="31333">防篡改的分类账中</st>'
- en: '**<st c="31356">OpenID Connect</st>**<st c="31371">: This</st> <st c="31379">provides</st>
    <st c="31388">identity verification</st>'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="31356">OpenID Connect</st>**<st c="31371">：这是</st> <st c="31379">身份验证</st>'
- en: <st c="31409">Sigstore</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31409">Sigstore</st>
- en: <st c="31418">To learn</st> <st c="31428">more about the Sigstore project, you
    can visit their website at</st> [<st c="31492">https://www.sigstore.dev/</st>](https://www.sigstore.dev/)
    <st c="31517">and explore their GitHub repository</st> <st c="31554">at</st> [<st
    c="31557">https://github.com/sigstore</st>](https://github.com/sigstore)<st c="31584">.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31418">欲了解更多关于Sigstore项目的信息，请访问他们的官方网站</st> [<st c="31492">https://www.sigstore.dev/</st>](https://www.sigstore.dev/)
    <st c="31517">并探索他们的GitHub仓库</st> <st c="31554">地址为</st> [<st c="31557">https://github.com/sigstore</st>](https://github.com/sigstore)<st
    c="31584">。</st>
- en: '**<st c="31585">Cosign</st>** <st c="31592">(one of the tools included in the
    Sigstore project) simplifies signing and verifying</st> <st c="31678">software
    artifacts such as container images by making the process of managing signatures
    invisible.</st> <st c="31778">It automatically signs artifacts, stores the signatures
    in an OCI registry, and performs verifications without user intervention regarding
    signature handling.</st> <st c="31937">When signing a Docker image, Cosign creates
    a special tag in the OCI registry that incorporates the image’s unique digest
    (its immutable identifier) into the tag name.</st> <st c="32105">This allows for
    easy retrieval and verification of the image’s signature based on</st> <st c="32187">its
    digest.</st>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="31585">Cosign</st>** <st c="31592">(作为 Sigstore 项目中的工具之一) 通过使签名管理过程不可见，简化了软件工件（如容器镜像）的签名和验证。</st>
    <st c="31678">它自动签署工件，将签名存储在 OCI 注册表中，并在无需用户干预签名处理的情况下执行验证。</st> <st c="31778">在签署
    Docker 镜像时，Cosign 会在 OCI 注册表中创建一个特殊的标签，将镜像的唯一摘要（其不可变标识符）纳入标签名称中。</st> <st c="32105">这使得根据镜像的摘要轻松检索和验证镜像的签名。</st>'
- en: <st c="32198">To use</st> <st c="32206">Cosign, we</st> *<st c="32217">first</st>*
    <st c="32222">must ensure</st> <st c="32235">that it is installed on the runner/agent
    used for our workflow/pipeline.</st> <st c="32308">For GitHub, this can be done
    using the</st> `<st c="32347">cosign-installer</st>` <st c="32363">GitHub</st>
    <st c="32371">marketplace task (</st>*<st c="32389">Figure 7</st>**<st c="32398">.18</st>*<st
    c="32401">).</st> <st c="32405">For Azure DevOps, we use a command line step with
    our preferred OS package manager, as detailed</st> <st c="32501">at</st> [<st
    c="32504">https://docs.sigstore.dev/system_config/installation/</st>](https://docs.sigstore.dev/system_config/installation/)<st
    c="32557">.</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32198">要使用</st> <st c="32206">Cosign，我们</st> *<st c="32217">首先</st>*
    <st c="32222">必须确保它已安装在用于我们的工作流/管道的 runner/agent 上。</st> <st c="32308">对于 GitHub，可以使用</st>
    `<st c="32347">cosign-installer</st>` <st c="32363">GitHub</st> <st c="32371">市场任务（</st>*<st
    c="32389">图 7</st>**<st c="32398">.18</st>*<st c="32401">）。</st> <st c="32405">对于
    Azure DevOps，我们使用命令行步骤配合我们喜欢的操作系统包管理器，详情请参考</st> <st c="32501">在</st> [<st c="32504">https://docs.sigstore.dev/system_config/installation/</st>](https://docs.sigstore.dev/system_config/installation/)<st
    c="32557">。</st>
- en: '![Figure 7.18 – The cosign-installer GitHub marketplace task](img/B19710_07_18.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.18 – cosign-installer GitHub 市场任务](img/B19710_07_18.jpg)'
- en: <st c="33001">Figure 7.18 – The cosign-installer GitHub marketplace task</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33001">图 7.18 – cosign-installer GitHub 市场任务</st>
- en: <st c="33059">The</st> *<st c="33064">second</st>* <st c="33070">step is optional.</st>
    <st c="33089">We could generate the key pairs that will be used for the digital
    signature using the</st> `<st c="33175">cosign generate-key-pair</st>` <st c="33199">command.</st>
    <st c="33209">This allows for more control but introduces the complexity of key
    management.</st> <st c="33287">Cosign also supports keyless signing, which uses
    ephemeral keys and logs the signing process transparently.</st> <st c="33395">This
    approach improves security and simplifies operations by eliminating the direct
    management of keys.</st> <st c="33499">The</st> *<st c="33503">third</st>* <st
    c="33508">step is to sign our artifact using the</st> `<st c="33548">cosign sign</st>`
    <st c="33559">command.</st> <st c="33569">The</st> *<st c="33573">final</st>*
    <st c="33578">step is to verify the signature with the</st> `<st c="33620">cosign
    verify</st>` <st c="33633">command, as part of our</st> <st c="33658">pre-deployment
    check.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33059">步骤</st> *<st c="33064">二</st>* <st c="33070">是可选的。</st> <st c="33089">我们可以使用</st>
    `<st c="33175">cosign generate-key-pair</st>` <st c="33199">命令生成将用于数字签名的密钥对。</st>
    <st c="33209">这提供了更多的控制权，但也带来了密钥管理的复杂性。</st> <st c="33287">Cosign 还支持无密钥签名，这种方法使用短暂的密钥并透明地记录签名过程。</st>
    <st c="33395">这种方法通过消除密钥的直接管理，提高了安全性并简化了操作。</st> <st c="33499">步骤</st> *<st c="33503">三</st>*
    <st c="33508">是使用</st> `<st c="33548">cosign sign</st>` <st c="33559">命令签名我们的工件。</st>
    <st c="33569">步骤</st> *<st c="33573">四</st>* <st c="33578">是使用</st> `<st c="33620">cosign
    verify</st>` <st c="33633">命令验证签名，作为我们</st> <st c="33658">部署前检查的一部分。</st>
- en: <st c="33679">Implementing artifact signing using Notation</st>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="33679">使用 Notation 实现工件签名</st>
- en: <st c="33724">Notation</st> <st c="33734">is another tool that can be used to</st>
    <st c="33770">sign and verify the integrity and the publisher of digital artifacts.</st>
    <st c="33840">It is part of the Notary project, an incubating</st> <st c="33888">project
    of the</st> **<st c="33903">Cloud Native Computing</st>** **<st c="33926">Foundation</st>**
    <st c="33936">(</st>**<st c="33938">CNCF</st>**<st c="33942">).</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33724">Notation</st> <st c="33734">是另一个可以用于</st> <st c="33770">对数字构件进行签名并验证其完整性和发布者的工具。</st>
    <st c="33840">它是 Notary 项目的一部分，该项目是</st> <st c="33888">一个由</st> **<st c="33903">云原生计算</st>**
    **<st c="33926">基金会</st>** <st c="33936">(</st>**<st c="33938">CNCF</st>**<st
    c="33942">)的孵化项目。</st>
- en: <st c="33945">Notary project</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33945">Notary 项目</st>
- en: <st c="33960">To learn</st> <st c="33970">more about the Notary project, you
    can visit their website at</st> [<st c="34032">https://notaryproject.dev/</st>](https://notaryproject.dev/)
    <st c="34058">and explore their GitHub repository</st> <st c="34095">at</st> [<st
    c="34098">https://github.com/notaryproject</st>](https://github.com/notaryproject)<st
    c="34130">.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33960">要了解</st> <st c="33970">有关 Notary 项目的更多信息，您可以访问他们的官网</st> [<st
    c="34032">https://notaryproject.dev/</st>](https://notaryproject.dev/) <st c="34058">并浏览他们的
    GitHub 仓库</st> <st c="34095">，网址为</st> [<st c="34098">https://github.com/notaryproject</st>](https://github.com/notaryproject)<st
    c="34130">。</st>
- en: <st c="34131">Similar to Sigstore, it is also primarily aimed at software artifacts
    such as container images and binaries, but it can be used for any file type, including
    ZIP files.</st> <st c="34300">Digital artifacts can be signed during the build
    process and their integrity and origin verified at deployment.</st> *<st c="34412">Figure
    7</st>**<st c="34420">.19</st>* <st c="34423">provides a high-level overview of
    how Notation is integrated into a</st> <st c="34492">DevOps workflow.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34131">与 Sigstore 类似，它主要面向软件构件，如容器镜像和二进制文件，但也可以用于任何文件类型，包括 ZIP 文件。</st>
    <st c="34300">数字构件可以在构建过程中进行签名，并在部署时验证其完整性和来源。</st> *<st c="34412">图 7</st>**<st
    c="34420">.19</st>* <st c="34423">提供了 Notation 如何集成到</st> <st c="34492">DevOps
    工作流中的高级概述。</st>
- en: '![Figure 7.19 – How Notation is integrated into a DevOps workflow](img/B19710_07_19.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.19 – Notation 如何集成到 DevOps 工作流中](img/B19710_07_19.jpg)'
- en: <st c="34704">Figure 7.19 – How Notation is integrated into a DevOps workflow</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34704">图 7.19 – Notation 如何集成到 DevOps 工作流中</st>
- en: <st c="34767">To use</st> <st c="34775">Notation, we</st> *<st c="34788">first</st>*
    <st c="34793">must ensure</st> <st c="34806">that it is installed on the runner/agent
    used for our workflow/pipeline.</st> <st c="34879">For GitHub, this can be done
    using the</st> `<st c="34918">notation-action</st>` <st c="34933">GitHub marketplace
    action.</st> <st c="34961">Azure DevOps also has a</st> `<st c="34985">Notation</st>`
    <st c="34993">marketplace task that we can use for this (</st>*<st c="35037">Figure
    7</st>**<st c="35046">.20</st>*<st c="35049">).</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34767">要使用</st> <st c="34775">Notation，我们</st> *<st c="34788">首先</st>*
    <st c="34793">必须确保它已安装在用于我们工作流/流水线的运行器/代理上。</st> <st c="34879">对于 GitHub，可以使用</st>
    `<st c="34918">notation-action</st>` <st c="34933">GitHub 市场动作来完成。</st> <st c="34961">Azure
    DevOps 也有一个</st> `<st c="34985">Notation</st>` <st c="34993">市场任务，我们可以用来完成这个操作（</st>*<st
    c="35037">图 7</st>**<st c="35046">.20</st>*<st c="35049">）。</st>
- en: '![Figure 7.20 – Azure DevOps Notation marketplace task](img/B19710_07_20.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – Azure DevOps Notation 市场任务](img/B19710_07_20.jpg)'
- en: <st c="35131">Figure 7.20 – Azure DevOps Notation marketplace task</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35131">图 7.20 – Azure DevOps Notation 市场任务</st>
- en: <st c="35183">The</st> *<st c="35188">second</st>* <st c="35194">step is to
    sign our artifact.</st> <st c="35225">The Notation task in Azure Pipelines natively
    supports the Azure Key Vault plugin, which enables the Notation CLI to generate
    signatures using Azure-Key-Vault-managed certificates and keys (</st>*<st c="35415">Figure
    7</st>**<st c="35424">.21</st>*<st c="35427">).</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35183">第二</st> *<st c="35188">步</st>* <st c="35194">是对我们的构件进行签名。</st>
    <st c="35225">Azure Pipelines 中的 Notation 任务原生支持 Azure Key Vault 插件，这使得 Notation
    CLI 能够使用 Azure Key Vault 管理的证书和密钥生成签名（</st>*<st c="35415">图 7</st>**<st c="35424">.21</st>*<st
    c="35427">）。</st>
- en: '![Figure 7.21 – Implementing Notation in Azure Pipelines](img/B19710_07_21.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.21 – 在 Azure Pipelines 中实现 Notation](img/B19710_07_21.jpg)'
- en: <st c="35668">Figure 7.21 – Implementing Notation in Azure Pipelines</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35668">图 7.21 – 在 Azure Pipelines 中实现 Notation</st>
- en: <st c="35722">It supports</st> <st c="35735">signing with self-signed</st> <st
    c="35760">certificates and</st> `<st c="35858">notation sign</st>` <st c="35871">command.</st>
    <st c="35881">The</st> <st c="35885">third and final step is to verify the signature
    as part of our pre-deployment checks.</st> <st c="35971">Notation supports specifying
    a Trust Policy file that defines the signature verification levels that we want
    to enforce.</st> <st c="36092">There are four</st> <st c="36107">verification
    levels:</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35722">它支持</st> <st c="35735">使用自签名</st> <st c="35760">证书进行签名和</st> `<st
    c="35858">notation sign</st>` <st c="35871">命令。</st> <st c="35881">第三个也是最后一步是将签名作为预部署检查的一部分进行验证。</st>
    <st c="35971">Notation 支持指定一个信任策略文件，定义我们希望强制执行的签名验证级别。</st> <st c="36092">有四个</st>
    <st c="36107">验证级别：</st>
- en: '**<st c="36127">Strict</st>**<st c="36134">: This</st> <st c="36142">enforces
    all validations.</st> <st c="36168">If any validation fails, the verification
    fails.</st> <st c="36217">Best for build environments or</st> <st c="36248">high-assurance
    deployment.</st>'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="36127">严格</st>**<st c="36134">：此设置</st> <st c="36142">强制执行所有验证。</st>
    <st c="36168">如果任何验证失败，则验证失败。</st> <st c="36217">适用于构建环境或</st> <st c="36248">高安全性部署。</st>'
- en: '**<st c="36274">Permissive</st>**<st c="36285">: This</st> <st c="36293">conducts
    most validations but logs issues such as revocation and expiry.</st> <st c="36366">Suitable
    for deployment or runtime when integrity and authenticity</st> <st c="36433">are
    key.</st>'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="36274">宽松</st>**<st c="36285">：此设置</st> <st c="36293">执行大部分验证，但记录诸如撤销和过期等问题。</st>
    <st c="36366">适用于部署或运行时，当完整性和真实性</st> <st c="36433">至关重要时。</st>'
- en: '**<st c="36441">Audit</st>**<st c="36447">: Only</st> <st c="36455">ensures
    signature integrity if present; logs other</st> <st c="36506">validation failures.</st>'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="36441">审计</st>**<st c="36447">：仅</st> <st c="36455">确保签名完整性（如果存在）；记录其他</st>
    <st c="36506">验证失败。</st>'
- en: '**<st c="36526">Skip</st>**<st c="36531">: This does</st> <st c="36544">not
    perform signature verification.</st> <st c="36580">It is used when mixing signed
    and unsigned artifacts but requires specifying exact registry URLs</st> <st c="36677">in
    registryScopes.</st>'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="36526">跳过</st>**<st c="36531">：此操作</st> <st c="36544">不执行签名验证。</st>
    <st c="36580">用于混合签名和未签名的工件，但需要指定确切的注册表 URL</st> <st c="36677">在 registryScopes
    中。</st>'
- en: '*<st c="36695">Figure 7</st>**<st c="36704">.22</st>* <st c="36707">displays</st>
    <st c="36717">the four levels (strict, permissive, audit, and skip) and</st> <st
    c="36775">their</st> <st c="36781">respective validations.</st>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="36695">图 7</st>**<st c="36704">.22</st>* <st c="36707">展示了</st> <st
    c="36717">四种级别（严格、宽松、审计和跳过）及其</st> <st c="36775">各自的验证方式。</st>'
- en: '![Figure 7.22 – Notation’s verification levels](img/B19710_07_22.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.22 – Notation 的验证级别](img/B19710_07_22.jpg)'
- en: <st c="37310">Figure 7.22 – Notation’s verification levels</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37310">图 7.22 – Notation 的验证级别</st>
- en: <st c="37354">To learn</st> <st c="37364">more about Notation’s Trust Policy
    file, please refer to this</st> <st c="37426">document:</st> [<st c="37436">https://github.com/notaryproject/specifications/blob/v1.0.0/specs/trust-store-trust-policy.md</st>](https://github.com/notaryproject/specifications/blob/v1.0.0/specs/trust-store-trust-policy.md)<st
    c="37529">.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37354">要了解</st> <st c="37364">有关 Notation 信任策略文件的更多信息，请参考以下</st> <st
    c="37426">文档：</st> [<st c="37436">https://github.com/notaryproject/specifications/blob/v1.0.0/specs/trust-store-trust-policy.md</st>](https://github.com/notaryproject/specifications/blob/v1.0.0/specs/trust-store-trust-policy.md)<st
    c="37529">。</st>
- en: <st c="37530">Managing secrets securely in the release phase</st>
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="37530">在发布阶段安全地管理密钥</st>
- en: <st c="37577">In automated build and deployment pipelines, developers may need
    to supply credentials</st> <st c="37665">needed to access internal</st> <st c="37691">or
    external services.</st> <st c="37713">For example, a build pipeline task that
    downloads code from a private repository may require the credentials to be provided.</st>
    <st c="37838">Another task may be to download a package from a private registry
    and the necessary credentials must be supplied.</st> <st c="37952">In a deployment
    pipeline, a task may</st> *<st c="37989">need</st>* <st c="37993">the credentials
    to connect to a hosted Kubernetes cluster to deploy the latest version of</st>
    <st c="38084">an application.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37577">在自动化构建和部署管道中，开发人员可能需要提供访问内部</st> <st c="37665">或外部服务所需的凭证。</st>
    <st c="37691">例如，从私有仓库下载代码的构建管道任务可能需要提供凭证。</st> <st c="37838">另一个任务可能是从私有注册表下载包，必须提供必要的凭证。</st>
    <st c="37952">在部署管道中，某个任务可能</st> *<st c="37989">需要</st>* <st c="37993">凭证以连接到托管的
    Kubernetes 集群，部署最新版本的</st> <st c="38084">应用程序。</st>
- en: <st c="38099">Note</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38099">注意</st>
- en: <st c="38104">A good security best practice is to prioritize the use of workload
    identities for access instead of secrets.</st> <st c="38214">For example, implementing
    managed identities to access Azure services.</st> <st c="38285">Secrets should
    only be used for scenarios where workload identities are not</st> <st c="38361">yet
    supported.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38104">一个好的安全最佳实践是优先使用工作负载身份进行访问，而不是使用密钥。</st> <st c="38214">例如，实施托管身份来访问Azure服务。</st>
    <st c="38285">密钥应仅在工作负载身份尚未支持的场景中使用。</st>
- en: <st c="38375">These sensitive credentials should never be stored in plaintext
    within build or deployment pipeline workflow files.</st> <st c="38492">One possible
    option is to store the credentials as encrypted environment</st> <st c="38565">variables.</st>
    <st c="38576">These are referred to as</st> **<st c="38601">secrets</st>** <st
    c="38608">in GitHub</st> <st c="38619">Enterprise and</st> **<st c="38634">secret
    variables</st>** <st c="38650">in Azure Pipelines.</st> <st c="38671">For our
    discussion, we will just refer to them</st> <st c="38718">as</st> *<st c="38721">secrets</st>*<st
    c="38728">.</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38375">这些敏感凭证绝不应以明文存储在构建或部署流水线工作流文件中。</st> <st c="38492">一种可行的选择是将凭证存储为加密的环境</st>
    <st c="38565">变量。</st> <st c="38576">这些在GitHub</st> **<st c="38601">Enterprise</st>**
    <st c="38608">中被称为</st> **<st c="38634">密钥</st>** <st c="38650">，在Azure Pipelines中被称为</st>
    **<st c="38634">密钥变量</st>**。</st> <st c="38671">在我们的讨论中，我们将其称为</st> *<st c="38721">密钥</st>*<st
    c="38728">。</st>
- en: <st c="38729">In GitHub, secrets can be set at the organization, repository,
    or repository environment levels.</st> <st c="38827">In Azure DevOps, they can
    be set at the project (using variable groups), pipeline, stage, or job levels.</st>
    <st c="38932">Organization/project-level secrets allow teams to share secrets
    across multiple workflows or pipelines.</st> <st c="39036">This reduces the need
    to create duplicate secrets across multiple repositories/pipelines.</st> <st c="39126">Secrets
    are encrypted at rest using a 2048-bit RSA key and are accessible on the agent
    for tasks and scripts</st> <st c="39235">to use.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38729">在GitHub中，密钥可以在组织、仓库或仓库环境级别设置。</st> <st c="38827">在Azure DevOps中，它们可以在项目（使用变量组）、流水线、阶段或作业级别设置。</st>
    <st c="38932">组织/项目级别的密钥允许团队在多个工作流或流水线中共享密钥。</st> <st c="39036">这减少了在多个仓库/流水线中创建重复密钥的需求。</st>
    <st c="39126">密钥在静止时使用2048位RSA密钥加密，并可供任务和脚本在代理上使用。</st> <st c="39235">。
- en: <st c="39242">On both platforms, users with read permissions cannot read secrets,
    but those with write permissions to a repository/project can read all secrets.</st>
    <st c="39390">To reduce the risk of a secret leak, we need to be careful about
    who is granted write access to</st> <st c="39486">our repositories/projects.</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39242">在这两个平台上，具有读取权限的用户无法读取密钥，但具有写入权限的用户可以读取所有密钥。</st> <st c="39390">为了减少密钥泄漏的风险，我们需要小心授予谁对我们仓库/项目的写入权限。</st>
- en: <st c="39512">In following zero-trust principles, we need to assume that breaches
    can happen and only grant the minimum necessary privileges for the secrets in
    use in workflows/pipelines.</st> <st c="39687">This approach reduces the potential
    impact in case a user with write access is compromised.</st> <st c="39779">For
    example, a secret that is used for deploying applications to a Kubernetes cluster
    should only have that specific permission.</st> <st c="39908">It should not have
    permission to modify other configurations in</st> <st c="39972">the cluster.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39512">遵循零信任原则时，我们需要假设漏洞可能发生，并仅授予执行工作流/流水线所需的最小权限。</st> <st c="39687">这种方法在用户的写入权限被泄露时，能减少潜在的影响。</st>
    <st c="39779">例如，用于将应用程序部署到Kubernetes集群的密钥，应该只拥有该特定权限。</st> <st c="39908">它不应该有权限修改集群中的其他配置。</st>
- en: <st c="39984">Both GitHub Actions and Azure Pipelines try to mask secrets in
    log outputs (</st>*<st c="40061">Figure 7</st>**<st c="40070">.23</st>*<st c="40073">).</st>
    <st c="40077">They look for secrets that are printed in plain text on the command
    line, as well as exact</st> <st c="40168">matches of secret values in</st> <st
    c="40196">the logged outputs.</st> <st c="40216">However, this process is not
    perfect.</st> <st c="40254">Developers must still exercise caution to prevent</st>
    <st c="40304">accidental exposure.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39984">GitHub Actions 和 Azure Pipelines 都尝试在日志输出中屏蔽秘密（</st>*<st c="40061">图
    7</st>**<st c="40070">.23</st>*<st c="40073">）。</st> <st c="40077">它们会查找在命令行中以纯文本形式打印的秘密，以及日志输出中秘密值的精确匹配。</st>
    <st c="40168">然而，这个过程并不完美。</st> <st c="40216">开发者仍然需要谨慎，防止</st> <st c="40304">意外暴露。</st>
- en: '![Figure 7.23 – A masked secret in an Azure Pipeline log](img/B19710_07_23.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.23 – Azure Pipeline 日志中的屏蔽秘密](img/B19710_07_23.jpg)'
- en: <st c="40819">Figure 7.23 – A masked secret in an Azure Pipeline log</st>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40819">图 7.23 – Azure Pipeline 日志中的屏蔽秘密</st>
- en: '<st c="40873">For example, it is not recommended to define a secret value using
    a structured data format such as JSON, XML, or YAML.</st> <st c="40993">This could
    lead to redaction failures.</st> <st c="41032">An example of this is if a secret
    value is defined as</st> `<st c="41086">{"apikey": "secretpass"}</st>`<st c="41110">;
    if the exact value is printed to the console in plain text, it may not be masked
    (</st>*<st c="41195">Figure 7</st>**<st c="41204">.24</st>*<st c="41207">).</st>
    <st c="41211">Instead, developers should create individual plain secrets for each
    sensitive value instead of mapping them in a structured data format, to ensure
    they are properly masked</st> <st c="41383">in logs.</st>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="40873">例如，不推荐使用 JSON、XML 或 YAML 等结构化数据格式来定义秘密值。</st> <st c="40993">这可能导致屏蔽失败。</st>
    <st c="41032">一个例子是，如果秘密值被定义为</st> `<st c="41086">{"apikey": "secretpass"}</st>`<st
    c="41110">；如果该精确值以纯文本形式打印到控制台，它可能无法被屏蔽（</st>*<st c="41195">图 7</st>**<st c="41204">.24</st>*<st
    c="41207">）。</st> <st c="41211">开发者应为每个敏感值创建单独的普通秘密，而不是将它们映射在结构化数据格式中，以确保它们在日志中能够被正确屏蔽。</st>
    <st c="41383">在日志中。</st>'
- en: '![Figure 7.24 – An example of an unmasked secret due to the structured data
    format](img/B19710_07_24.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.24 – 由于结构化数据格式导致的未屏蔽秘密示例](img/B19710_07_24.jpg)'
- en: <st c="42036">Figure 7.24 – An example of an unmasked secret due to the structured
    data format</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42036">图 7.24 – 由于结构化数据格式导致的未屏蔽秘密示例</st>
- en: <st c="42116">Also, if a secret is used to generate a sensitive value within
    a workflow/pipeline, that generated</st> <st c="42216">value should be registered
    as a secret to</st> <st c="42258">ensure it is masked if it appears in the logs.</st>
    <st c="42305">For example, a private key may be used to generate a signed</st>
    **<st c="42365">JSON Web Token</st>** <st c="42379">(</st>**<st c="42381">JWT</st>**<st
    c="42384">) to access</st> <st c="42397">a web API.</st> <st c="42408">That JWT
    should be registered as a secret, or it will not be masked if it is recorded in
    the workflow/pipeline log output.</st> <st c="42531">Similarly, if a secret is
    transformed in any way, such as being Base64 or URL-encoded, it should also be
    registered as a secret to ensure it will be masked if it appears in</st> <st c="42704">log
    outputs.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42116">此外，如果在工作流/管道中使用一个秘密来生成敏感值，生成的</st> <st c="42216">值应注册为秘密，以</st>
    <st c="42258">确保如果它出现在日志中时会被屏蔽。</st> <st c="42305">例如，可能使用一个私钥来生成一个签名的</st> **<st
    c="42365">JSON Web Token</st>** <st c="42379">（</st>**<st c="42381">JWT</st>**<st
    c="42384">）以访问</st> <st c="42397">Web API。</st> <st c="42408">该 JWT 应该注册为秘密，否则如果它被记录在工作流/管道日志输出中，它将不会被屏蔽。</st>
    <st c="42531">类似地，如果一个秘密被以某种方式转换，例如被 Base64 编码或 URL 编码，它也应该注册为秘密，以确保如果它出现在</st>
    <st c="42704">日志输出中时能够被屏蔽。</st>
- en: <st c="42716">Integrating a secret vault in your DevOps pipelines</st>
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="42716">在你的 DevOps 管道中集成秘密保管库</st>
- en: <st c="42768">Apart from implementing secrets in our workflows/pipelines, we
    could also implement processes to</st> <st c="42866">centrally manage secrets</st>
    <st c="42891">using a secret management service such as Azure Key Vault or HashiCorp
    Vault.</st> <st c="42969">This is the preferred option as it has the added advantage
    of scalability, and it allows for the decoupling of secret management from the
    DevOps platform.</st> <st c="43124">As we mentioned previously, a better approach
    is to transition to using workload identities if supported for</st> <st c="43233">your
    scenario.</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42768">除了在我们的工作流/管道中实现密钥管理外，我们还可以实现一些流程，</st> <st c="42866">使用如 Azure
    Key Vault 或 HashiCorp Vault 等密钥管理服务来集中管理密钥。</st> <st c="42891">这是首选方案，因为它具有可扩展性的优势，并且它允许将密钥管理与
    DevOps 平台解耦。</st> <st c="42969">正如我们之前提到的，更好的做法是，如果您的场景支持，过渡到使用工作负载身份。</st>
- en: <st c="43247">Azure Key Vault is a secrets management service, a key management
    service, and a certificate management service.</st> <st c="43361">A</st> **<st
    c="43363">secret</st>** <st c="43369">is data under 25 KB (for standard vaults)
    that can be stored and retrieved in plain text.</st> <st c="43460">Examples include
    passwords, database connection strings, and storage account connection strings.</st>
    **<st c="43557">Keys</st>** <st c="43561">are cryptographic keys (i.e., secrets
    generated using an algorithm) that can be imported or generated in the vault.</st>
    <st c="43678">Key Vault currently supports RSA and elliptic curve keys.</st> **<st
    c="43736">Certificates</st>** <st c="43748">are self-signed</st> <st c="43765">SSL/TLS
    certificates generated</st> <st c="43796">in Key Vault or third-party SSL/TLS
    certificates that have been imported into the vault.</st> *<st c="43885">Figure
    7</st>**<st c="43893">.25</st>* <st c="43896">shows example use cases of these
    three</st> <st c="43936">object types.</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43247">Azure Key Vault 是一个密钥管理服务、证书管理服务和密钥管理服务。</st> <st c="43361">A</st>
    **<st c="43363">密钥</st>** <st c="43369">是数据大小不超过 25 KB（对于标准保管库），可以以明文形式存储和检索。</st>
    <st c="43460">例如，密码、数据库连接字符串和存储账户连接字符串。</st> **<st c="43557">密钥</st>** <st c="43561">是加密密钥（即使用算法生成的密钥），可以导入或在保管库中生成。</st>
    <st c="43678">Key Vault 目前支持 RSA 和椭圆曲线密钥。</st> **<st c="43736">证书</st>** <st c="43748">是自签名的</st>
    <st c="43765">SSL/TLS 证书，可以在 Key Vault 中生成，或是导入到保管库中的第三方 SSL/TLS 证书。</st> *<st
    c="43885">图 7</st>**<st c="43893">.25</st>* <st c="43896">展示了这三种对象类型的示例使用案例。</st>
- en: '![Figure 7.25 – Sample Azure Key Vault use cases](img/B19710_07_25.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.25 – 示例 Azure Key Vault 使用案例](img/B19710_07_25.jpg)'
- en: <st c="44434">Figure 7.25 – Sample Azure Key Vault use cases</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44434">图 7.25 – 示例 Azure Key Vault 使用案例</st>
- en: <st c="44480">To integrate the Azure Key Vault into our GitHub Action workflows,
    we can implement the</st> `<st c="44569">azure/get-keyvault-secrets</st>` <st
    c="44595">action that is authenticated with a workload identity or a service principal.</st>
    <st c="44674">In an Azure DevOps pipeline, this integration can be done with the</st>
    `<st c="44741">AzureKeyVault</st>` <st c="44754">task that uses a service connection
    that is backed by a managed identity or a service principal (</st>*<st c="44852">Figure
    7</st>**<st c="44861">.26</st>*<st c="44864">).</st> <st c="44868">For both options,
    we want to make sure that the access is scoped to the secret that is needed.</st>
    <st c="44963">This requires a least privileged</st> <st c="44996">access design.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44480">要将 Azure Key Vault 集成到我们的 GitHub Action 工作流中，我们可以实现</st> `<st
    c="44569">azure/get-keyvault-secrets</st>` <st c="44595">操作，该操作通过工作负载身份或服务主体进行身份验证。</st>
    <st c="44674">在 Azure DevOps 管道中，此集成可以通过</st> `<st c="44741">AzureKeyVault</st>`
    <st c="44754">任务完成，该任务使用受托管身份或服务主体支持的服务连接（</st>*<st c="44852">图 7</st>**<st c="44861">.26</st>*<st
    c="44864">）。</st> <st c="44868">对于这两种选项，我们需要确保访问权限仅限于所需的密钥。</st> <st c="44963">这需要最小权限访问设计。</st>
- en: '![Figure 7.26 – Sample Azure DevOps integration with Key Vault](img/B19710_07_26.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.26 – 示例 Azure DevOps 与 Key Vault 集成](img/B19710_07_26.jpg)'
- en: <st c="45211">Figure 7.26 – Sample Azure DevOps integration with Key Vault</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45211">图 7.26 – 示例 Azure DevOps 与 Key Vault 集成</st>
- en: <st c="45271">Now, let us</st> <st c="45284">review another best practice</st>
    <st c="45313">regarding securing our build/release environment –</st> <st c="45364">implementing
    auditing.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45271">现在，让我们</st> <st c="45284">回顾另一个关于确保构建/发布环境安全的最佳实践——</st> <st c="45313">实施审计。</st>
- en: <st c="45386">Implementing auditing for the CI/CD environment</st>
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="45386">为 CI/CD 环境实施审计</st>
- en: <st c="45434">The CIS framework also recommends enabling logging in the build/release
    environment.</st> <st c="45520">This is</st> <st c="45528">critical for security</st>
    <st c="45550">monitoring, threat detection, and forensic analysis in the case
    of an incident.</st> <st c="45630">Ideally, logging should be enabled on both
    the control plane, for management operations, and the</st> <st c="45727">data
    plane.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45434">CIS框架还建议在构建/发布环境中启用日志记录。</st> <st c="45520">这对于安全性</st> <st c="45528">监控、威胁检测和在发生事件时的取证分析至关重要。</st>
    <st c="45550">理想情况下，日志记录应在控制平面启用，以进行管理操作，以及在</st> <st c="45727">数据平面。</st>
- en: <st c="45738">Enabling and configuring control plane logging</st>
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="45738">启用和配置控制平面日志记录</st>
- en: <st c="45785">In</st> **<st c="45789">GitHub Enterprise Cloud</st>** <st c="45812">(</st>**<st
    c="45814">GHEC</st>**<st c="45818">), we</st> <st c="45825">don’t need</st> <st
    c="45836">to do anything to enable control plane audit</st> <st c="45881">logs.</st>
    <st c="45887">They are enabled by default.</st> <st c="45916">The logs can be</st>
    <st c="45932">viewed at the enterprise level</st> <st c="45963">via</st> **<st
    c="45967">Settings</st>** <st c="45975">|</st> **<st c="45978">Audit Log</st>**
    <st c="45987">|</st> **<st c="45990">Events</st>**<st c="45996">, or at the organization
    level through</st> **<st c="46035">Organization</st>** <st c="46047">|</st> **<st
    c="46050">Settings</st>** <st c="46058">|</st> **<st c="46061">Archive</st>**
    <st c="46068">|</st> **<st c="46071">Logs</st>** <st c="46075">|</st> **<st c="46078">Audit
    Log</st>** <st c="46087">|</st> **<st c="46090">Events</st>**<st c="46096">. By
    default, only events from the last three months are visible, but events are stored
    for up to seven months after which they</st> <st c="46224">are deleted.</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45785">在</st> **<st c="45789">GitHub Enterprise Cloud</st>** <st c="45812">(</st>**<st
    c="45814">GHEC</st>**<st c="45818">)，我们</st> <st c="45825">不需要</st> <st c="45836">做任何事情来启用控制平面审计</st>
    <st c="45881">日志。</st> <st c="45887">它们默认已启用。</st> <st c="45916">这些日志可以</st> <st
    c="45932">在企业级别查看</st> <st c="45963">通过</st> **<st c="45967">设置</st>** <st c="45975">|</st>
    **<st c="45978">审计日志</st>** <st c="45987">|</st> **<st c="45990">事件</st>**<st
    c="45996">，或者在组织级别通过</st> **<st c="46035">组织</st>** <st c="46047">|</st> **<st
    c="46050">设置</st>** <st c="46058">|</st> **<st c="46061">归档</st>** <st c="46068">|</st>
    **<st c="46071">日志</st>** <st c="46075">|</st> **<st c="46078">审计日志</st>** <st
    c="46087">|</st> **<st c="46090">事件</st>**<st c="46096">查看。默认情况下，只有最近三个月的事件可见，但事件会保存长达七个月，之后会被</st>
    <st c="46224">删除。</st>
- en: <st c="46236">The logs</st> <st c="46246">capture a range of events</st> <st
    c="46272">including workflow control plane activities categorized under</st> **<st
    c="46334">org</st>** <st c="46337">and</st> **<st c="46342">workflow</st>**<st
    c="46350">. This includes actions</st> <st c="46374">such as creation, update,
    deletion, and execution</st> <st c="46424">of workflows.</st> <st c="46438">A
    comprehensive list of the audited events is available</st> <st c="46494">here:</st>
    [<st c="46500">https://docs.github.com/en/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization</st>](https://docs.github.com/en/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization)<st
    c="46661">.</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46236">这些日志</st> <st c="46246">记录了一系列事件</st> <st c="46272">，包括分类在</st>
    **<st c="46334">org</st>** <st c="46337">和</st> **<st c="46342">workflow</st>**<st
    c="46350">下的工作流控制平面活动。</st> <st c="46374">这包括诸如创建、更新、删除和执行</st> <st c="46424">工作流等操作。</st>
    <st c="46438">审计事件的完整列表可以在此查看：</st> [<st c="46500">https://docs.github.com/en/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization</st>](https://docs.github.com/en/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization)<st
    c="46661">。</st>
- en: <st c="46662">For privacy, the audit logs omit the source IP address of events.</st>
    <st c="46729">To add source IP addresses to the audit logs, the adjustment can
    be made at either the enterprise or</st> <st c="46830">organization level:</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46662">为了保护隐私，审计日志省略了事件的源IP地址。</st> <st c="46729">要将源IP地址添加到审计日志中，可以在企业级别或</st>
    <st c="46830">组织级别进行调整：</st>
- en: '**<st c="46849">Enterprise level</st>**<st c="46866">: Navigate through</st>
    **<st c="46886">Enterprise</st>** <st c="46896">|</st> **<st c="46899">Settings</st>**
    <st c="46907">|</st> **<st c="46910">Audit Log</st>** <st c="46919">|</st> **<st
    c="46922">Settings</st>**<st c="46930">. Activate and save the</st> **<st c="46954">Enable
    source IP</st>** **<st c="46971">disclosure</st>** <st c="46981">option.</st>'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="46849">企业级别</st>**<st c="46866">：导航至</st> **<st c="46886">企业</st>**
    <st c="46896">|</st> **<st c="46899">设置</st>** <st c="46907">|</st> **<st c="46910">审计日志</st>**
    <st c="46919">|</st> **<st c="46922">设置</st>**<st c="46930">。启用并保存</st> **<st
    c="46954">启用源 IP</st>** **<st c="46971">披露</st>** <st c="46981">选项。</st>'
- en: '**<st c="46989">Organization level</st>**<st c="47008">: Go to</st> **<st c="47017">Organization</st>**
    <st c="47029">|</st> **<st c="47032">Settings</st>** <st c="47040">|</st> **<st
    c="47043">Archive</st>** <st c="47050">|</st> **<st c="47053">Logs</st>** <st
    c="47057">|</st> **<st c="47060">Audit Log</st>** <st c="47069">|</st> **<st c="47072">Settings</st>**<st
    c="47080">. Activate and save the</st> **<st c="47104">Enable source IP</st>**
    **<st c="47121">disclosure</st>** <st c="47131">option.</st>'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="46989">组织级别</st>**<st c="47008">：进入</st> **<st c="47017">组织</st>**
    <st c="47029">|</st> **<st c="47032">设置</st>** <st c="47040">|</st> **<st c="47043">存档</st>**
    <st c="47050">|</st> **<st c="47053">日志</st>** <st c="47057">|</st> **<st c="47060">审计日志</st>**
    <st c="47069">|</st> **<st c="47072">设置</st>**<st c="47080">。启用并保存</st> **<st
    c="47104">启用源 IP</st>** **<st c="47121">披露</st>** <st c="47131">选项。</st>'
- en: '![Figure 7.27 – Enabling source IP recording for audit logs](img/B19710_07_27.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.27 – 启用源 IP 记录以进行审计日志](img/B19710_07_27.jpg)'
- en: <st c="47556">Figure 7.27 – Enabling source IP recording for audit logs</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47556">图 7.27 – 启用源 IP 记录以进行审计日志</st>
- en: <st c="47613">To stream the logs externally, maybe to keep them for longer than
    the maximum retention period, we have the option to stream directly to Amazon
    S3, Azure Blob Storage, Google</st> <st c="47789">Cloud Storage, Splunk, and Datadog.</st>
    <st c="47825">We can</st> <st c="47832">also stream to other third-party services
    via Azure Event</st> <st c="47890">Hub.</st> <st c="47895">This can</st> <st c="47904">be
    configured at the enterprise level via</st> **<st c="47946">Settings</st>** <st
    c="47954">|</st> **<st c="47957">Audit log</st>** <st c="47966">|</st> **<st c="47969">Log
    streaming</st>** <st c="47982">|</st> **<st c="47985">Configure stream</st>**<st
    c="48001">.</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47613">为了将日志流式传输到外部，可能是为了将其保存超过最大保留期限，我们可以选择直接将日志流式传输到 Amazon S3、Azure
    Blob Storage、Google</st> <st c="47789">Cloud Storage、Splunk 和 Datadog。</st> <st
    c="47825">我们还可以</st> <st c="47832">通过 Azure Event</st> <st c="47890">Hub 将其流式传输到其他第三方服务。</st>
    <st c="47895">这可以</st> <st c="47904">通过</st> **<st c="47946">设置</st>** <st c="47954">|</st>
    **<st c="47957">审计日志</st>** <st c="47966">|</st> **<st c="47969">日志流式传输</st>**
    <st c="47982">|</st> **<st c="47985">配置流式传输</st>**<st c="48001">。</st>
- en: '![Figure 7.28 – Configuring audit log streaming at the enterprise level](img/B19710_07_28.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.28 – 在企业级配置审计日志流式传输](img/B19710_07_28.jpg)'
- en: <st c="48291">Figure 7.28 – Configuring audit log streaming at the enterprise
    level</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48291">图 7.28 – 在企业级配置审计日志流式传输</st>
- en: <st c="48360">For Azure Pipelines, control plane logging can be enabled in the
    organization settings in</st> **<st c="48451">Security</st>** <st c="48459">|</st>
    **<st c="48462">Policies</st>** <st c="48470">|</st> **<st c="48473">Security
    policies</st>** <st c="48490">|</st> **<st c="48493">Log</st>** **<st c="48497">Audit
    Events</st>**<st c="48509">.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48360">对于 Azure Pipelines，可以在</st> **<st c="48451">安全</st>** <st c="48459">|</st>
    **<st c="48462">策略</st>** <st c="48470">|</st> **<st c="48473">安全策略</st>** <st
    c="48490">|</st> **<st c="48493">日志</st>** **<st c="48497">审计事件</st>**<st c="48509">。</st>
- en: '![Figure 7.29 – Enabling audit logging](img/B19710_07_29.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.29 – 启用审计日志记录](img/B19710_07_29.jpg)'
- en: <st c="48854">Figure 7.29 – Enabling audit logging</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48854">图 7.29 – 启用审计日志记录</st>
- en: <st c="48890">Once</st> <st c="48896">this setting is enabled, it records multiple
    events, including</st> <st c="48959">Azure Pipeline</st> <st c="48974">control
    plane events</st> <st c="48995">such as pipeline creation, modification, deletion,
    and</st> <st c="49050">execution.</st> <st c="49061">The full list of pipeline
    events that are audited can be found</st> <st c="49124">here:</st> [<st c="49130">https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops#pipelines</st>](https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops#pipelines)<st
    c="49240">.</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48890">启用此设置后，它会记录多个事件，包括</st> <st c="48959">Azure Pipeline</st> <st
    c="48974">控制平面事件</st> <st c="48995">，如管道创建、修改、删除和</st> <st c="49050">执行。</st>
    <st c="49061">可以在此处找到已审计的完整管道事件列表：</st> [<st c="49130">https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops#pipelines</st>](https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops#pipelines)<st
    c="49240">。</st>
- en: <st c="49241">Once enabled, the events can be viewed in</st> **<st c="49284">Organization
    Settings</st>** <st c="49305">|</st> **<st c="49308">General</st>** <st c="49315">|</st>
    **<st c="49318">Auditing</st>** <st c="49326">|</st> **<st c="49329">Logs</st>**<st
    c="49333">. The events are stored for 90 days, after which they</st> <st c="49387">are
    deleted.</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49241">启用后，可以在</st> **<st c="49284">组织设置</st>** <st c="49305">|</st>
    **<st c="49308">常规</st>** <st c="49315">|</st> **<st c="49318">审计</st>** <st c="49326">|</st>
    **<st c="49329">日志</st>**<st c="49333">中查看事件。这些事件会保存 90 天，之后会</st> <st c="49387">被删除。</st>
- en: <st c="49399">They collect the logs in a centralized log store where we can
    keep them for longer, and we can configure audit streams in</st> **<st c="49522">Organization
    Settings</st>** <st c="49543">|</st> **<st c="49546">General</st>** <st c="49553">|</st>
    **<st c="49556">Auditing</st>** <st c="49564">|</st> **<st c="49567">Streams</st>**
    <st c="49574">|</st> **<st c="49577">New stream</st>**<st c="49587">, where we
    have the option to export the logs to Azure Monitor, Splunk, or other third-party
    solutions via Azure</st> <st c="49700">Event Grid.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49399">它们将日志收集到集中式日志存储中，在这里我们可以保存更长时间，并且可以在</st> **<st c="49522">组织设置</st>**
    <st c="49543">|</st> **<st c="49546">常规</st>** <st c="49553">|</st> **<st c="49556">审计</st>**
    <st c="49564">|</st> **<st c="49567">流</st>** <st c="49574">|</st> **<st c="49577">新建流</st>**<st
    c="49587">中配置审计流，在这里我们可以选择通过 Azure</st> <st c="49700">事件网格将日志导出到 Azure Monitor、Splunk
    或其他第三方解决方案。</st>
- en: '![Figure 7.30 – Azure DevOps audit stream options](img/B19710_07_30.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.30 – Azure DevOps 审计流选项](img/B19710_07_30.jpg)'
- en: <st c="49913">Figure 7.30 – Azure DevOps audit stream options</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49913">图 7.30 – Azure DevOps 审计流选项</st>
- en: <st c="49960">Enabling and configuring data plane logging</st>
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="49960">启用和配置数据平面日志记录</st>
- en: <st c="50004">GHEC</st> <st c="50010">workflow run logs (build environment data
    plane logs) are also</st> <st c="50073">enabled by default and retained for 90
    days</st> <st c="50117">by default.</st> <st c="50129">The retention</st> <st
    c="50143">settings can be adjusted to a maximum of 400 days at the enterprise,
    organization, or</st> <st c="50229">repository levels:</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50004">GHEC</st> <st c="50010">工作流运行日志（构建环境数据平面日志）默认也</st> <st c="50073">已启用并保留
    90 天</st> <st c="50117">默认情况下。</st> <st c="50129">保留</st> <st c="50143">设置可以在企业、组织或</st>
    <st c="50229">仓库级别调整，最大可调为 400 天：</st>
- en: '**<st c="50247">Enterprise level</st>**<st c="50264">: Navigate through</st>
    **<st c="50284">Enterprise</st>** <st c="50294">|</st> **<st c="50297">Settings</st>**
    <st c="50305">|</st> **<st c="50308">Policies</st>** <st c="50316">|</st> **<st
    c="50319">Actions</st>** <st c="50326">|</st> **<st c="50329">Artifact and log
    retention</st>**<st c="50355">. Set the retention days and</st> <st c="50384">click</st>
    **<st c="50390">Save</st>**<st c="50394">.</st>'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="50247">企业级</st>**<st c="50264">: 导航到</st> **<st c="50284">企业</st>**
    <st c="50294">|</st> **<st c="50297">设置</st>** <st c="50305">|</st> **<st c="50308">策略</st>**
    <st c="50316">|</st> **<st c="50319">操作</st>** <st c="50326">|</st> **<st c="50329">工件和日志保留</st>**<st
    c="50355">。设置保留天数并</st> <st c="50384">点击</st> **<st c="50390">保存</st>**<st c="50394">。</st>'
- en: '**<st c="50395">Organization level</st>**<st c="50414">: Go to</st> **<st c="50423">Organization</st>**
    <st c="50435">|</st> **<st c="50438">Settings</st>** <st c="50446">|</st> **<st
    c="50449">Code, planning, and automation</st>** <st c="50479">|</st> **<st c="50482">Artifact
    and log retention</st>**<st c="50508">. Set the retention days and</st> <st c="50537">click</st>
    **<st c="50543">Save</st>**<st c="50547">.</st>'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="50395">组织级别</st>**<st c="50414">：前往</st> **<st c="50423">组织</st>**
    <st c="50435">|</st> **<st c="50438">设置</st>** <st c="50446">|</st> **<st c="50449">代码、规划与自动化</st>**
    <st c="50479">|</st> **<st c="50482">工件和日志保留</st>**<st c="50508">。设置保留天数后</st>
    <st c="50537">点击</st> **<st c="50543">保存</st>**<st c="50547">。</st>'
- en: '**<st c="50548">Repository level</st>**<st c="50565">: Go to</st> **<st c="50574">Repository</st>**
    <st c="50584">|</st> **<st c="50587">Settings</st>** <st c="50595">|</st> **<st
    c="50598">Code and automation</st>** <st c="50617">|</st> **<st c="50620">Actions</st>**
    <st c="50627">|</st> **<st c="50630">General</st>** <st c="50637">|</st> **<st
    c="50640">Artifact and log retention</st>**<st c="50666">. Set the retention days
    and</st> <st c="50695">click</st> **<st c="50701">Save</st>**<st c="50705">.</st>'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="50548">仓库级别</st>**<st c="50565">：前往</st> **<st c="50574">仓库</st>**
    <st c="50584">|</st> **<st c="50587">设置</st>** <st c="50595">|</st> **<st c="50598">代码与自动化</st>**
    <st c="50617">|</st> **<st c="50620">操作</st>** <st c="50627">|</st> **<st c="50630">常规</st>**
    <st c="50637">|</st> **<st c="50640">工件和日志保留</st>**<st c="50666">。设置保留天数后</st>
    <st c="50695">点击</st> **<st c="50701">保存</st>**<st c="50705">。</st>'
- en: '![Figure 7.31 – Configuring workflow log retention policy in GitHub](img/B19710_07_31.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.31 – 在 GitHub 中配置工作流日志保留策略](img/B19710_07_31.jpg)'
- en: <st c="50980">Figure 7.31 – Configuring workflow log retention policy in GitHub</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50980">图 7.31 – 在 GitHub 中配置工作流日志保留策略</st>
- en: <st c="51045">Azure</st> <st c="51052">Pipelines build logs are also enabled
    by default and retained</st> <st c="51114">for 30 days by default.</st> <st c="51138">The</st>
    <st c="51142">retention settings</st> <st c="51161">can be adjusted via</st> **<st
    c="51181">Project Settings</st>** <st c="51197">|</st> **<st c="51200">Pipelines</st>**
    <st c="51209">|</st> **<st c="51212">Settings</st>** <st c="51220">|</st> **<st
    c="51223">Retention policy</st>** <st c="51239">|</st> **<st c="51242">Days to</st>**
    **<st c="51250">keep runs</st>**<st c="51259">.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51045">Azure</st> <st c="51052">流水线的构建日志默认启用，并且会默认保留</st> <st c="51114">30
    天。</st> <st c="51138">这些</st> <st c="51142">保留设置</st> <st c="51161">可以通过</st>
    **<st c="51181">项目设置</st>** <st c="51197">|</st> **<st c="51200">流水线</st>** <st
    c="51209">|</st> **<st c="51212">设置</st>** <st c="51220">|</st> **<st c="51223">保留策略</st>**
    <st c="51239">|</st> **<st c="51242">保留运行天数</st>** **<st c="51250">。</st>
- en: '![Figure 7.32 – Configuring retention policy in Azure DevOps project settings](img/B19710_07_32.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.32 – 在 Azure DevOps 项目设置中配置保留策略](img/B19710_07_32.jpg)'
- en: <st c="51593">Figure 7.32 – Configuring retention policy in Azure DevOps project
    settings</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51593">图 7.32 – 在 Azure DevOps 项目设置中配置保留策略</st>
- en: <st c="51668">Let’s now learn about</st> <st c="51691">security gates.</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51668">现在让我们了解一下</st> <st c="51691">安全网关。</st>
- en: <st c="51706">Implementing security gates in release pipelines</st>
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="51706">在发布流水线中实现安全网关</st>
- en: <st c="51755">Gates are</st> <st c="51766">important components</st> <st c="51787">of
    software release pipelines.</st> <st c="51818">They act as quality checkpoints
    that software must pass before moving to the next stage of deployment.</st> <st
    c="51921">Their main objective use case is to reduce the likelihood of deploying
    poor quality software that fails to meet agreed performance and</st> <st c="52056">quality
    standards.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51755">网关是</st> <st c="51766">软件发布流水线中的重要组成部分。</st> <st c="51787">它们作为质量检查点，在软件进入下一个部署阶段之前，必须通过这些检查。</st>
    <st c="51818">它们的主要目标是减少部署不合格的软件的可能性，这些软件未能达到商定的性能和</st> <st c="52056">质量标准。</st>
- en: <st c="52074">For example, a development team might deploy software or updates
    to a test environment, run automated load and functional tests using tools such
    as Azure Load Testing</st> <st c="52242">and Selenium, and review</st> <st c="52267">the
    results in</st> <st c="52282">Azure Monitor.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52074">例如，一个开发团队可能会将软件或更新部署到测试环境，使用如 Azure Load Testing</st> <st c="52242">和
    Selenium 等工具运行自动化负载和功能测试，并在</st> <st c="52267">Azure Monitor 中查看</st> <st c="52282">结果。</st>
- en: <st c="52296">If the</st> <st c="52304">software meets the agreed</st> **<st
    c="52330">service-level agreements</st>** <st c="52354">(</st>**<st c="52356">SLAs</st>**<st
    c="52360">), it is deployed to the next stage.</st> <st c="52398">If it does not
    meet the SLAs, the deployment stops, and the telemetry data is collected for the
    team to investigate and resolve the issues (</st>*<st c="52538">Figure 7</st>**<st
    c="52547">.33</st>*<st c="52550">).</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52296">如果</st> <st c="52304">软件符合约定的</st> **<st c="52330">服务水平协议</st>**
    <st c="52354">(</st>**<st c="52356">SLA</st>**<st c="52360">)，则将部署到下一个阶段。</st>
    <st c="52398">如果不符合SLA，则部署会停止，并且会收集遥测数据供团队调查并解决问题（</st>*<st c="52538">图 7</st>**<st
    c="52547">.33</st>*<st c="52550">）。</st>
- en: '![Figure 7.33 – Sample quality gate testing in a release pipeline](img/B19710_07_33.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.33 – 发布流水线中的示例质量门测试](img/B19710_07_33.jpg)'
- en: <st c="52807">Figure 7.33 – Sample quality gate testing in a release pipeline</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52807">图 7.33 – 发布流水线中的示例质量门测试</st>
- en: <st c="52870">DevSecOps extends the use of gates to include the validation of
    security (security gates) – see</st> *<st c="52967">Figure 7</st>**<st c="52975">.34</st>*<st
    c="52978">. The goal of a security gate is to prevent the most critical software
    risks from being deployed to production or other environments with higher</st>
    <st c="53123">exploitation risks.</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52870">DevSecOps 扩展了门的使用范围，包括安全性验证（安全门） – 见</st> *<st c="52967">图 7</st>**<st
    c="52975">.34</st>*<st c="52978">。安全门的目标是防止最关键的软件风险被部署到生产环境或其他具有更高</st> <st c="53123">利用风险的环境中。</st>
- en: '![Figure 7.34 – Sample security gate testing in a release pipeline](img/B19710_07_34.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.34 – 发布流水线中的示例安全门测试](img/B19710_07_34.jpg)'
- en: <st c="53432">Figure 7.34 – Sample security gate testing in a release pipeline</st>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53432">图 7.34 – 发布流水线中的示例安全门测试</st>
- en: <st c="53496">Security gates</st> <st c="53512">in release pipelines vary based
    on project needs.</st> **<st c="53562">Dynamic application security testing</st>**
    <st c="53598">(</st>**<st c="53600">DAST</st>**<st c="53604">) gates use tools
    such as OWASP ZAP, Burp Suite, and Acunetix to test running applications in a
    pre-production environment.</st> <st c="53729">These tools check for issues such
    as API security, SSL/TLS configuration, and</st> <st c="53807">authentication.</st>
    **<st c="53823">Compliance gates</st>** <st c="53839">ensure regulatory</st> <st
    c="53858">standards are met, while</st> **<st c="53883">penetration testing gates</st>**
    <st c="53908">simulate cyberattacks to</st> <st c="53934">find vulnerabilities.</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53496">发布流水线中的安全门</st> <st c="53512">根据项目需求有所不同。</st> **<st c="53562">动态应用安全测试</st>**
    <st c="53598">(</st>**<st c="53600">DAST</st>**<st c="53604">) 门使用如 OWASP ZAP、Burp
    Suite 和 Acunetix 等工具，在预生产环境中测试运行中的应用程序。</st> <st c="53729">这些工具检查诸如 API 安全、SSL/TLS
    配置和</st> <st c="53807">身份验证等问题。</st> **<st c="53823">合规性门</st>** <st c="53839">确保符合监管</st>
    <st c="53858">标准，而</st> **<st c="53883">渗透测试门</st>** <st c="53908">则模拟网络攻击，</st>
    <st c="53934">以发现漏洞。</st>
- en: <st c="53955">Effective security gates require balancing thorough security checks
    while maintaining development speed.</st> <st c="54061">Start with the most critical
    checks that offer the most value and expand gradually.</st> <st c="54145">To determine
    the most critical checks, begin with the major issues currently seen in production
    and implement checks to prevent these from reaching production.</st> <st c="54305">Continuously
    refine your process based on feedback and evolving</st> <st c="54369">security
    threats.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53955">有效的安全门需要在保持开发速度的同时平衡全面的安全检查。</st> <st c="54061">从最关键的检查开始，这些检查提供最大的价值，然后逐步扩展。</st>
    <st c="54145">要确定最关键的检查，从当前在生产环境中看到的主要问题开始，并实施检查，以防这些问题进入生产环境。</st> <st c="54305">根据反馈和不断发展的</st>
    <st c="54369">安全威胁持续完善你的过程。</st>
- en: <st c="54386">Regarding maintaining development speed, security gates should
    be automated as much as possible to avoid slowing down the software release process.</st>
    <st c="54535">If security gates are used to stop non-compliant software from being
    deployed to production, it is recommended to implement a well-governed manual
    override process.</st> <st c="54700">This should require a minimum of two manual
    approvers to prevent it from being abused as a security bypass and to ensure that
    only business-accepted risks are</st> <st c="54859">allowed through.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54386">关于保持开发速度，安全门应尽可能自动化，以避免减缓软件发布过程。</st> <st c="54535">如果使用安全门阻止不符合要求的软件部署到生产环境，建议实施一个管理良好的手动覆盖流程。</st>
    <st c="54700">这应该至少需要两名手动批准者，以防止其被滥用作为安全绕过，并确保只有业务可接受的风险才会</st> <st c="54859">被允许通过。</st>
- en: <st c="54875">Implementing DAST as security gates</st>
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="54875">将 DAST 实施为安全门</st>
- en: <st c="54911">Unlike the</st> <st c="54923">security assessments covered in
    previous chapters, DAST identifies security issues while an application is running.</st>
    <st c="55039">It is a great</st> <st c="55053">complement to</st> **<st c="55067">static
    application security testing</st>** <st c="55102">(</st>**<st c="55104">SAST</st>**<st
    c="55108">) and SCA assessments as it can detect runtime issues that may not be
    apparent in the code alone.</st> <st c="55207">It does this by simulating attacks
    against a running application.</st> <st c="55273">For example, a DAST tool may
    crawl a running web application</st> <st c="55334">and send malformed inputs to
    identify issues such as SQL injection,</st> **<st c="55402">cross-site scripting</st>**
    <st c="55422">(</st>**<st c="55424">XSS</st>**<st c="55427">), and insecure direct</st>
    <st c="55451">object references.</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54911">与前面章节中涵盖的安全评估不同，DAST 在应用程序运行时识别安全问题。</st> <st c="55039">它是一个很好的</st>
    <st c="55053">补充，</st> **<st c="55067">静态应用程序安全测试</st>** <st c="55102">(</st>**<st
    c="55104">SAST</st>**<st c="55108">) 和 SCA 评估，因为它可以检测代码中可能没有明显显示的运行时问题。</st> <st
    c="55207">它通过模拟攻击正在运行的应用程序来实现这一点。</st> <st c="55273">例如，DAST 工具可能会爬取一个正在运行的 Web
    应用程序</st> <st c="55334">并发送格式错误的输入，以识别如 SQL 注入、</st> **<st c="55402">跨站脚本攻击</st>**
    <st c="55422">(</st>**<st c="55424">XSS</st>**<st c="55427">) 和不安全的直接</st> <st
    c="55451">对象引用等问题。</st>
- en: <st c="55469">Integrating DAST into a project that follows a DevOps process
    in a way that does not impact users requires an understanding of the deployment
    strategy and collaborating with the pipeline development teams.</st> <st c="55676">The
    deployment strategy influences the types of tests and the approach to implementing
    them.</st> <st c="55769">For example, the traditional application deployment strategy
    involves releasing it into a</st> *<st c="55859">test</st>* <st c="55863">environment,
    and then into a</st> *<st c="55893">staging</st>* <st c="55900">environment before
    going to</st> *<st c="55929">production</st>*<st c="55939">. Test and staging
    deployments are ideal points for integrating a continuous</st> <st c="56016">DAST
    process.</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55469">将 DAST 集成到遵循 DevOps 流程的项目中，并且不影响用户，需要了解部署策略，并与管道开发团队合作。</st> <st
    c="55676">部署策略会影响测试类型和实施方式。</st> <st c="55769">例如，传统的应用程序部署策略包括将其发布到</st> *<st
    c="55859">测试</st>* <st c="55863">环境中，然后进入</st> *<st c="55893">暂存</st>* <st c="55900">环境，最后到达</st>
    *<st c="55929">生产</st>*<st c="55939">环境。测试和暂存部署是集成持续</st> <st c="56016">DAST 过程的理想点。</st>
- en: <st c="56029">There are</st> <st c="56040">modern deployment strategies embraced
    by DevOps teams that allow for more frequent deployments to production and sometimes
    even testing in production.</st> <st c="56191">Strategies such as deployment rings,
    Canary releases,</st> **<st c="56245">dark launching</st>**<st c="56259">, and
    A/B</st> <st c="56269">testing fall into this category.</st> <st c="56302">The
    main thing to keep in mind when integrating DAST with these strategies is that
    tests should be conducted in a production-like but non-production environment
    to ensure accurate results while protecting the data in the</st> <st c="56523">production
    environment.</st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56029">现在有</st> <st c="56040">一些现代部署策略被 DevOps 团队采纳，这些策略允许更频繁地部署到生产环境，有时甚至在生产环境中进行测试。</st>
    <st c="56191">如部署环、金丝雀发布、</st> **<st c="56245">黑暗发布</st>**<st c="56259">和 A/B</st>
    <st c="56269">测试都属于这一类。</st> <st c="56302">在将 DAST 集成到这些策略中时，主要需要注意的是，测试应在类似生产的非生产环境中进行，以确保准确的结果，同时保护生产环境中的数据。</st>
- en: <st c="56546">Challenges of implementing DAST in a DevOps process</st>
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="56546">在 DevOps 流程中实施 DAST 的挑战</st>
- en: <st c="56598">The effectiveness of a DAST tool is tied to the types of tests
    it can perform automatically.</st> <st c="56692">This may sound simple, but there
    are many nuances.</st> <st c="56743">For example, the tests for</st> <st c="56770">a
    web application differ</st> <st c="56795">from those for an API application, which
    in turn differ from those for a generative AI app implementing a</st> **<st c="56901">retrieval-augmented
    generation</st>** <st c="56931">(</st>**<st c="56933">RAG</st>**<st c="56936">)
    workflow.</st> <st c="56949">If a DAST tool only supports attacks</st> <st c="56986">against
    web and API applications, it may not add much value for other types of applications.</st>
    <st c="57079">Don’t integrate DAST just for the sake of integration.</st> <st
    c="57134">The value must be clearly defined, as there is a velocity cost.</st>
    <st c="57198">Ensure that the benefits of DAST outweigh the impact on development
    speed and efficiency.</st> <st c="57288">Properly assess the specific security
    needs and potential vulnerabilities of the application to determine whether DAST
    integration</st> <st c="57419">is worthwhile.</st>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="56598">DAST 工具的有效性与它能够自动执行的测试类型密切相关。</st> <st c="56692">这听起来可能很简单，但其中有很多细微的差别。</st>
    <st c="56743">例如，针对</st> <st c="56770">Web 应用程序的测试与针对 API 应用程序的测试不同，后者又与针对实现**<st
    c="56901">检索增强生成</st>**（**<st c="56933">RAG</st>**）工作流的生成式 AI 应用程序的测试不同。</st>
    <st c="56949">如果一个 DAST 工具仅支持针对 Web 和 API 应用程序的攻击，那么它可能对其他类型的应用程序价值不大。</st> <st
    c="56986">不要仅仅为了集成而集成 DAST。</st> <st c="57134">必须明确定义其价值，因为集成带来一定的速度成本。</st> <st
    c="57198">确保 DAST 的收益超过对开发速度和效率的影响。</st> <st c="57288">要正确评估应用程序的特定安全需求和潜在漏洞，以确定
    DAST 集成是否值得。</st> '
- en: <st c="57433">The majority of existing DAST tools focus on testing web applications.</st>
    <st c="57505">While many organizations have web-based apps, other types of applications
    may not be covered.</st> <st c="57599">Most DAST solutions test only the exposed
    HTTP and HTML interfaces of web-enabled applications.</st> <st c="57695">However,
    some</st> <st c="57709">solutions are designed specifically for non-web protocols
    and data malformation, such as</st> **<st c="57798">remote procedure</st>** **<st
    c="57815">calls</st>** <st c="57820">(</st>**<st c="57822">RPC</st>**<st c="57825">).</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57433">大多数现有的 DAST 工具专注于测试 Web 应用程序。</st> <st c="57505">虽然许多组织有基于 Web
    的应用程序，但其他类型的应用程序可能未被涵盖。</st> <st c="57599">大多数 DAST 解决方案仅测试 Web 启用应用程序的暴露 HTTP
    和 HTML 接口。</st> <st c="57695">然而，某些</st> <st c="57709">解决方案是专门为非 Web 协议和数据畸形设计的，比如</st>
    **<st c="57798">远程过程</st>** **<st c="57815">调用</st>**（**<st c="57822">RPC</st>**）。</st>
- en: <st c="57828">Another challenge is that while DAST has existed for a while,
    most tools were created for use by security teams within legacy processes.</st>
    <st c="57966">Modern DAST solutions, however, are built from the ground up for
    developers, QA, and DevOps professionals, making the tooling and its outputs more
    relatable and accessible to them.</st> <st c="58147">One of the key features of
    modern DAST solutions is the flexibility of deployment, including containerized
    or agent-based scanners and options for both cloud and</st> <st c="58309">self-hosted
    reporting.</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57828">另一个挑战是，尽管 DAST 已存在一段时间，但大多数工具是为传统流程中的安全团队使用而创建的。</st> <st c="57966">然而，现代
    DAST 解决方案是从零开始为开发人员、QA 和 DevOps 专业人员构建的，使得工具及其输出对他们来说更具相关性和可访问性。</st> <st c="58147">现代
    DAST 解决方案的一个关键特点是部署的灵活性，包括容器化或基于代理的扫描仪，并提供云端和</st> <st c="58309">自托管报告的选项。</st>
- en: <st c="58331">Remediation is another area of challenge.</st> <st c="58374">Remediation
    guidance from DAST tools may not be contextual.</st> <st c="58434">For example,
    a DAST tool may identify a SQL injection vulnerability in a running application,
    but it may not be able to identify the line of code that developers need to</st>
    <st c="58604">change to fix the issue.</st> <st c="58629">This is where another
    tooling category,</st> **<st c="58669">interactive application security testing</st>**
    <st c="58709">(</st>**<st c="58711">IAST</st>**<st c="58715">), can help.</st>
    <st c="58729">IAST combines the security functions of SAST and DAST into one tool
    and provides more actionable insights</st> <st c="58835">for developers.</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58331">修复是另一个挑战领域。</st> <st c="58374">来自 DAST 工具的修复指导可能缺乏上下文。</st> <st
    c="58434">例如，DAST 工具可能会识别到运行中的应用程序中的 SQL 注入漏洞，但它可能无法识别开发人员需要</st> <st c="58604">更改的代码行，以修复该问题。</st>
    <st c="58629">这就是另一个工具类别，</st> **<st c="58669">互动式应用程序安全测试</st>** <st c="58709">(</st>**<st
    c="58711">IAST</st>**<st c="58715">)，可以提供帮助的地方。</st> <st c="58729">IAST 将 SAST
    和 DAST 的安全功能合并为一个工具，并为开发人员提供更多可操作的见解。</st>
- en: <st c="58850">Even</st> <st c="58856">though both IAST and DAST</st> <st c="58882">focus
    on application behavior during runtime, IAST offers a more comprehensive analysis
    by combining internal application flow analysis, scanning, and black-box testing.</st>
    <st c="59052">This enables IAST to link findings similar to those in DAST directly
    to the source code.</st> <st c="59141">It achieves this by analyzing the code
    executed in tests and pinpointing the exact location of vulnerabilities in the
    code.</st> <st c="59265">However, as a relatively new approach to application
    security, IAST has its drawbacks.</st> <st c="59352">It is dependent on the programming
    language and can slow down the</st> <st c="59418">CI pipeline.</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58850">尽管</st> <st c="58856">IAST 和 DAST 都</st> <st c="58882">关注运行时的应用程序行为，IAST
    通过结合内部应用程序流分析、扫描和黑盒测试提供更全面的分析。</st> <st c="59052">这使得 IAST 可以将与 DAST 类似的发现直接链接到源代码。</st>
    <st c="59141">它通过分析测试中执行的代码，精确定位代码中的漏洞。</st> <st c="59265">然而，作为一种相对较新的应用程序安全方法，IAST
    也有其缺点。</st> <st c="59352">它依赖于编程语言，并且可能会减慢</st> <st c="59418">CI 管道的速度。</st>
- en: <st c="59430">Implementing security gates in Azure Pipelines and GitHub Actions</st>
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="59430">在 Azure Pipelines 和 GitHub Actions 中实现安全门</st>
- en: <st c="59496">In Azure Pipelines, release strategies are set up as</st> **<st
    c="59550">stages</st>** <st c="59556">in a release pipeline.</st> <st c="59580">For
    classic</st> <st c="59592">pipelines, quality gates are defined</st> <st c="59629">using
    pre-deployment</st> <st c="59650">and post-deployment</st> <st c="59670">conditions
    for each</st> <st c="59690">stage.</st> **<st c="59697">Pre-deployment conditions</st>**
    <st c="59722">are checks and validations that must be satisfied before a deployment
    stage can start.</st> <st c="59810">They serve as</st> <st c="59824">gatekeepers
    to ensure that quality criteria are met before the deployment begins.</st> **<st
    c="59906">Post-deployment conditions</st>** <st c="59932">are checks that happen
    after a deployment has completed and before it proceeds to the next stage.</st>
    <st c="60031">They are used to verify that the deployment did not introduce any
    new issues and that the application is functioning correctly.</st> <st c="60159">To
    implement them, follow</st> <st c="60185">these steps:</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59496">在 Azure Pipelines 中，发布策略被设置为</st> **<st c="59550">阶段</st>** <st
    c="59556">在发布管道中。</st> <st c="59580">对于经典</st> <st c="59592">管道，质量门是通过使用每个</st>
    <st c="59629">阶段的预部署</st> <st c="59650">和后部署</st> <st c="59670">条件来定义的。</st> **<st
    c="59697">预部署条件</st>** <st c="59722">是在部署阶段开始之前必须满足的检查和验证。</st> <st c="59810">它们作为</st>
    <st c="59824">守门员，确保在部署开始之前满足质量标准。</st> **<st c="59906">后部署条件</st>** <st c="59932">是在部署完成后、进入下一阶段之前进行的检查。</st>
    <st c="60031">它们用于验证部署是否引入了新的问题，并确保应用程序正常运行。</st> <st c="60159">要实现它们，请按照以下步骤操作：</st>
- en: <st c="60197">In Azure Pipelines, navigate to</st> **<st c="60230">Pipelines</st>**
    <st c="60239">|</st> **<st c="60242">Releases</st>**<st c="60250">.</st>
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60197">在 Azure Pipelines 中，导航到</st> **<st c="60230">Pipelines</st>**
    <st c="60239">|</st> **<st c="60242">Releases</st>**<st c="60250">。</st>
- en: <st c="60251">Select the relevant</st> <st c="60272">release pipeline.</st>
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60251">选择相关的</st> <st c="60272">发布管道。</st>
- en: <st c="60289">Choose either pre-deployment or post-deployment conditions for
    the release stage (</st>*<st c="60372">Figure 7</st>**<st c="60381">.35</st>*<st
    c="60384">).</st>
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择发布阶段的部署前或部署后条件（*图 7.35*）。
- en: <st c="60387">Under</st> **<st c="60394">Gates</st>**<st c="60399">, click</st>
    **<st c="60407">Add</st>** <st c="60410">to configure your release</st> <st c="60437">gate
    settings.</st>
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**门控**下，点击**添加**来配置你的发布门控设置。
- en: '![Figure 7.35 – Configuring pre-deployment or post-deployment conditions](img/B19710_07_35.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.35 – 配置部署前或部署后条件](img/B19710_07_35.jpg)'
- en: <st c="61390">Figure 7.35 – Configuring pre-deployment or post-deployment conditions</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.35 – 配置部署前或部署后条件
- en: <st c="61460">GitHub</st> <st c="61468">Actions offers a similar functionality</st>
    <st c="61507">with environments, which</st> <st c="61532">can have protection
    rules</st> <st c="61558">that serve as release gates.</st> <st c="61587">For instance,
    a workflow in GitHub can include a job that must be manually approved by designated
    reviewers before the deployment can proceed to the next environment.</st> <st
    c="61754">This is particularly useful for workflows that deploy to multiple stages,
    such as staging and production.</st> <st c="61860">Each stage can have its own
    set of rules that are enforced by these gates.</st> <st c="61935">To read more
    about environments and protection rules, please refer to this</st> <st c="62010">document:</st>
    [<st c="62020">https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#custom-deployment-protection-rules</st>](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#custom-deployment-protection-rules)<st
    c="62167">.</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions 提供了类似的功能，使用环境可以设置保护规则作为发布门控。例如，GitHub 中的一个工作流可以包括一个任务，在部署到下一个环境之前，必须由指定的审核人员手动批准。这在需要部署到多个阶段（如预发布和生产环境）的工作流中尤为有用。每个阶段可以有自己的规则集，这些规则由这些门控进行强制执行。要了解更多有关环境和保护规则的信息，请参阅此文档：[https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#custom-deployment-protection-rules](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#custom-deployment-protection-rules)。
- en: <st c="62168">Hands-on exercise – Integrating security within the build and
    test phases</st>
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实践操作 – 在构建和测试阶段集成安全性
- en: <st c="62242">In this</st> <st c="62251">exercise, we will be integrating security</st>
    <st c="62293">within the build and test phases of our pipeline.</st> <st c="62343">We
    will practically implement artifact signing for integrity and implement DAST</st>
    <st c="62423">using ZAP.</st>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，我们将在管道的构建和测试阶段中集成安全性。我们将实际实施制品签名以确保完整性，并使用 ZAP 实现 DAST。
- en: <st c="62433">The following are the tasks for</st> <st c="62466">this exercise:</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本次练习的任务：
- en: '**<st c="62480">Task</st>** **<st c="62486">1 –</st>** <st c="62489">Implementing
    artifact signing for</st> <st c="62524">integrity checks</st>'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务 1 –** 实现制品签名以进行完整性检查'
- en: '**<st c="62540">Task</st>** **<st c="62546">2 –</st>** <st c="62549">Integrating
    DAST tools to find and fix security vulnerabilities in the</st> <st c="62621">test</st>
    <st c="62625">phase</st>'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务 2 –** 集成 DAST 工具以发现并修复测试阶段的安全漏洞'
- en: <st c="62631">Prerequisites</st>
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前提条件
- en: <st c="62645">Before diving</st> <st c="62660">into the first task, let’s first
    create a key vault in Azure Key Vault then generate a self-signed key and certificate.</st>
    <st c="62780">This is what we will use later to sign the image</st> <st c="62829">with
    Notation.</st>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始第一个任务之前，首先在 Azure Key Vault 中创建一个密钥库，然后生成一个自签名密钥和证书。稍后我们将使用这个密钥和证书通过 Notation
    签署镜像。
- en: <st c="62843">Navigate to your Azure portal</st> <st c="62874">at</st> [<st
    c="62877">https://portal.azure.com</st>](https://portal.azure.com)<st c="62901">.</st>
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入你的 Azure 门户 [https://portal.azure.com](https://portal.azure.com)。
- en: <st c="62902">Search for</st> `<st c="62914">key vaults</st>` <st c="62924">in
    the search bar and select</st> **<st c="62954">Key vaults</st>**<st c="62964">.</st>
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="62902">在搜索栏中搜索</st> `<st c="62914">key vaults</st>` <st c="62924">并选择</st>
    **<st c="62954">密钥保管库</st>**<st c="62964">。</st>
- en: '![Figure 7.36 – Search and select Key vaults](img/B19710_07_36.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.36 – 搜索并选择密钥保管库](img/B19710_07_36.jpg)'
- en: <st c="63210">Figure 7.36 – Search and select Key vaults</st>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63210">图 7.36 – 搜索并选择密钥保管库</st>
- en: <st c="63252">Click on</st> **<st c="63262">Create</st>** <st c="63268">and
    fill in the required details, click</st> **<st c="63309">Review + create</st>**<st
    c="63324">, and then</st> <st c="63335">click</st> **<st c="63341">Create</st>**<st
    c="63347">.</st>
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="63252">点击</st> **<st c="63262">创建</st>** <st c="63268">并填写所需的详细信息，然后点击</st>
    **<st c="63309">审核 + 创建</st>**<st c="63324">，然后</st> <st c="63335">点击</st> **<st
    c="63341">创建</st>**<st c="63347">。</st>
- en: '![Figure 7.37 – Create a key vault](img/B19710_07_37.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.37 – 创建密钥保管库](img/B19710_07_37.jpg)'
- en: <st c="65266">Figure 7.37 – Create a key vault</st>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65266">图 7.37 – 创建密钥保管库</st>
- en: <st c="65298">Now that we’ve created the key vault, let’s now create a self-signed
    certificate using Azure CLI.</st> <st c="65397">First, create a certificate policy
    file which, when executed, creates a</st> <st c="65469">valid certificate compatible
    with Notation.</st> <st c="65513">Copy the following code into Azure CLI bash
    terminal to create the policy file.</st> <st c="65593">Copy this</st> <st c="65603">from</st>
    [<st c="65608">https://github.com/PacktPublishing/eShopOnWeb/blob/main/policy.txt</st>](https://github.com/PacktPublishing/eShopOnWeb/blob/main/policy.txt)<st
    c="65674">.</st>
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="65298">现在我们已经创建了密钥保管库，接下来我们使用 Azure CLI 创建一个自签名证书。</st> <st c="65397">首先，创建一个证书策略文件，执行该文件后将生成一个</st>
    <st c="65469">与 Notation 兼容的有效证书。</st> <st c="65513">将以下代码复制到 Azure CLI bash 终端中以创建策略文件。</st>
    <st c="65593">从</st> [<st c="65608">https://github.com/PacktPublishing/eShopOnWeb/blob/main/policy.txt</st>](https://github.com/PacktPublishing/eShopOnWeb/blob/main/policy.txt)<st
    c="65674">复制此内容</st>。
- en: '![Figure 7.38 – Content of certificate policy file](img/B19710_07_38.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.38 – 证书策略文件内容](img/B19710_07_38.jpg)'
- en: <st c="66078">Figure 7.38 – Content of certificate policy file</st>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="66078">图 7.38 – 证书策略文件内容</st>
- en: <st c="66126">Create the certificate by pasting the following command to your</st>
    <st c="66191">Bash terminal</st><st c="66204">:</st>
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="66126">通过将以下命令粘贴到您的</st> <st c="66191">Bash 终端</st><st c="66204">来创建证书：</st>
- en: '[PRE0]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="66302">Remember to</st> <st c="66315">change the key vault name to the
    one created in</st> *<st c="66363">step 3</st>*<st c="66369">.</st> *<st c="66371">Figure
    7</st>**<st c="66379">.39</st>* <st c="66382">shows the successful creation of
    a</st> <st c="66418">self-signed certificate.</st>
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="66302">记得</st> <st c="66315">将密钥保管库的名称更改为在</st> *<st c="66363">步骤 3</st>*<st
    c="66369">中创建的名称。</st> *<st c="66371">图 7</st>**<st c="66379">.39</st>* <st c="66382">展示了一个</st>
    <st c="66418">自签名证书的成功创建。</st>
- en: '![Figure 7.39 – Create a self-signed certificate](img/B19710_07_39.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.39 – 创建自签名证书](img/B19710_07_39.jpg)'
- en: <st c="67677">Figure 7.39 – Create a self-signed certificate</st>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="67677">图 7.39 – 创建自签名证书</st>
- en: <st c="67723">Let’s confirm the certificate was created by going to your key
    vault then navigate to</st> **<st c="67810">Objects</st>** <st c="67817">and then
    click on</st> **<st c="67836">Certificates</st>**<st c="67848">. You will find
    the just created</st> <st c="67881">certificate here.</st>
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="67723">让我们确认证书已经创建，方法是进入您的密钥保管库，然后导航到</st> **<st c="67810">对象</st>**
    <st c="67817">并点击</st> **<st c="67836">证书</st>**<st c="67848">。您将在这里找到刚刚创建的</st>
    <st c="67881">证书。</st>
- en: '![Figure 7.40 – Self-signed certificate (test-io) created](img/B19710_07_40.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.40 – 创建自签名证书（test-io）](img/B19710_07_40.jpg)'
- en: <st c="68347">Figure 7.40 – Self-signed certificate (test-io) created</st>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="68347">图 7.40 – 创建自签名证书（test-io）</st>
- en: <st c="68402">In</st> [*<st c="68406">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122)<st
    c="68415">, hands on</st> *<st c="68426">Exercise 1 – Integrating SAST, SCA, and
    secret scanning into the build process</st>* <st c="68504">section, we ran</st>
    `<st c="68521">azure-pipelines.yml</st>` <st c="68540">which built and deployed
    the docker image.</st> <st c="68584">Several resources were created including
    a</st> <st c="68627">container registry.</st> <st c="68647">Several access permissions
    need to be set before configuring the notation task to sign the</st> <st c="68738">image
    created.</st>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68752">Let’s first</st> <st c="68765">authorize access to the</st> `<st
    c="68907">AcrPull</st>` <st c="68914">and</st> `<st c="68919">AcrPush</st>`<st
    c="68926">. Let’s configure ACR and AKV environment variables on Azure CLI</st>
    <st c="68991">Bash terminal.</st>
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="69154">Authorize access to ACR by first setting the subscription that
    contains the</st> <st c="69231">ACR resource.</st>
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="69413">and</st>
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="69616">Let’s now authorize access to AKV where the following roles are
    required for signing using</st> <st c="69708">self-signed certificates:</st>
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="69733">Key Vault Certificates Officer</st>** <st c="69764">for creating
    and</st> <st c="69782">reading certificates</st>'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="69802">Key Vault Certificates User</st>** <st c="69830">for reading</st>
    <st c="69843">existing certificates</st>'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="69864">Key Vault Crypto User</st>** <st c="69886">for</st> <st c="69891">signing
    operations</st>'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="69909">First set the subscription that contains the AKV resource using</st>
    <st c="69974">the command:</st>
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="70134">and</st>
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="70361">Now let’s</st> <st c="70372">create the Docker Registry service
    connection.</st> <st c="70419">To sign the images using notation, we will use
    the Docker task in Azure Pipelines to log into the ACR.</st> <st c="70522">This
    task allows you to build, push and pull</st> <st c="70567">Docker images.</st>
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="70581">Navigate to</st> **<st c="70594">Project Settings</st>** <st c="70610">and
    then</st> **<st c="70620">Service connections</st>**<st c="70639">.</st>
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.41 – Setting service connections](img/B19710_07_41.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: <st c="70975">Figure 7.41 – Setting service connections</st>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71016">Choose</st> **<st c="71024">New service connection</st>** <st
    c="71046">and select</st> **<st c="71058">Docker Registry</st>**<st c="71073">.</st>
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="71074">Next choose</st> **<st c="71087">Azure</st>** **<st c="71093">Container
    Registry</st>**<st c="71111">.</st>
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="71112">Select</st> **<st c="71120">Service Principal</st>** <st c="71137">in
    the</st> **<st c="71145">Authentication Type</st>** <st c="71164">field and enter
    the service</st> <st c="71193">principal details including your Azure Subscription
    and</st> <st c="71249">ACR registry.</st>
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="71262">Enter the</st> **<st c="71273">Service connection name</st>**
    <st c="71296">to use when referring to this service connection as shown in the</st>
    <st c="71362">following figure:</st>
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入**服务连接名称**，如以下图示所示：
- en: '![Figure 7.42 – Setting Docker Registry service connection](img/B19710_07_42.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.42 – 设置 Docker 注册表服务连接](img/B19710_07_42.jpg)'
- en: <st c="71743">Figure 7.42 – Setting Docker Registry service connection</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.42 – 设置 Docker 注册表服务连接
- en: <st c="71799">The last</st> <st c="71809">bit of access needed is to grant Azure
    Key Vault access policy to your</st> <st c="71880">service principal.</st>
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，需要的访问权限是将 Azure Key Vault 访问策略授予您的服务主体。
- en: <st c="71898">Open the Azure Resource Manager service connection you created
    and click on</st> **<st c="71975">Manage Service Principal</st>** <st c="71999">to
    access the Azure service</st> <st c="72028">principal portal.</st>
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您创建的 Azure 资源管理器服务连接，点击**管理服务主体**，访问 Azure 服务主体门户。
- en: <st c="72045">Copy the</st> **<st c="72055">Application (client) ID</st>**<st
    c="72078">. This ID will be used to grant permissions to the</st> <st c="72129">service
    principal.</st>
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制**应用程序（客户端）ID**。此 ID 将用于授予权限给服务主体。
- en: <st c="72147">Navigate to the</st> **<st c="72164">Azure Key Vault</st>** <st
    c="72179">portal and go to the</st> **<st c="72201">Access</st>** **<st c="72208">Policies</st>**
    <st c="72216">page.</st>
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**Azure Key Vault**门户，进入**访问****策略**页面。
- en: '<st c="72222">Create a new access policy with the following permissions: key
    sign, secret get, and</st> <st c="72308">certificate get.</st>'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的访问策略，包含以下权限：密钥签名、秘密获取和证书获取。
- en: <st c="72324">Assign this</st> <st c="72337">new access policy to a service
    principal using the</st> **<st c="72388">Application (client) ID</st>** <st c="72412">you</st>
    <st c="72416">copied earlier.</st>
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您之前复制的**应用程序（客户端）ID**，将此新访问策略分配给服务主体。
- en: <st c="72431">Save the changes to complete</st> <st c="72461">the setup.</st>
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改以完成设置。
- en: <st c="72471">Now that we've met the prerequisites, we can begin with</st> <st
    c="72528">the tasks.</st>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已满足先决条件，可以开始任务。
- en: <st c="72538">Task 1 – Implementing artifact signing for integrity checks</st>
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务 1 – 实现工件签名以进行完整性检查
- en: <st c="72598">In this task, we will be signing our artifacts using Notation
    to enforce authenticity and integrity</st> <st c="72699">validation for all release
    artifacts, including container images, by adding a digital signature</st> <st
    c="72795">that will be validated during</st> <st c="72825">deployment.</st> <st
    c="72837">The signature is used to verify that the artifact is from a trusted
    publisher and no modification has been made.</st> <st c="72950">This prevents
    tampering of packages and artifacts meant for production like in the CodeCov incident
    we</st> <st c="73053">covered earlier.</st>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在此任务中，我们将使用 Notation 对工件进行签名，强制执行所有发布工件（包括容器镜像）的真实性和完整性验证，通过添加在部署过程中验证的数字签名。该签名用于验证工件是否来自受信任的发布者，且没有经过修改。这防止了诸如我们之前提到的
    CodeCov 事件中出现的生产包和工件的篡改。
- en: <st c="73069">Let’s implement artifact signing</st> <st c="73103">using Notation:</st>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Notation 实现工件签名：
- en: <st c="73118">Navigate to your DevOps instance at</st> [<st c="73155">https://dev.azure.com</st>](https://dev.azure.com)
    <st c="73176">and choose the organization you used in the</st> <st c="73221">previous
    chapter.</st>
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您的 DevOps 实例，访问[https://dev.azure.com](https://dev.azure.com)，并选择您在前一章中使用的组织。
- en: <st c="73238">Select the</st> **<st c="73250">eShopOnWeb</st>** <st c="73260">private
    project we were using in the</st> <st c="73298">previous chapter.</st>
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们在前一章中使用的**eShopOnWeb**私有项目。
- en: <st c="73315">Azure DevOps has a</st> `<st c="73496">azure-pipelines.yml</st>`<st
    c="73516">).</st> <st c="73520">Click on the pipeline editing panel and search</st>
    <st c="73567">for</st> `<st c="73571">notation</st>`<st c="73579">.</st>
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure DevOps 有一个 `<st c="73496">azure-pipelines.yml</st>`<st c="73516">。</st>
    <st c="73520">点击流水线编辑面板并搜索</st> <st c="73567">符号</st> `<st c="73571">notation</st>`<st
    c="73579">。</st>
- en: '![Figure 7.43 – Notation marketplace task on Azure DevOps pipeline](img/B19710_07_43.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.43 – Azure DevOps 流水线上的符号市场任务](img/B19710_07_43.jpg)'
- en: <st c="73652">Figure 7.43 – Notation marketplace task on Azure DevOps pipeline</st>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.43 – Azure DevOps 流水线上的符号市场任务
- en: <st c="73716">Click on</st> <st c="73726">the</st> **<st c="73730">Notation</st>**
    <st c="73738">task and select</st> **<st c="73755">Install</st>** <st c="73762">under</st>
    **<st c="73769">Command to run</st>**<st c="73783">. Then, click</st> <st c="73797">the</st>
    **<st c="73801">Add</st>** <st c="73804">button.</st> <st c="73813">This will</st>
    <st c="73823">add the task for installing Notation to your pipeline as shown in
    the</st> <st c="73893">following figure:</st>
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '点击**<st c="73730">符号</st>**任务并选择**<st c="73755">安装</st>**<st c="73769">在</st>**<st
    c="73769">运行命令</st>**下。然后，点击**<st c="73801">添加</st>**<st c="73804">按钮。</st> <st
    c="73813">这将</st> <st c="73823">将安装符号的任务添加到您的流水线中，如下图所示：</st> '
- en: '![Figure 7.44 – Notation Install task on Azure DevOps pipeline](img/B19710_07_44.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.44 – Azure DevOps 流水线中的符号安装任务](img/B19710_07_44.jpg)'
- en: <st c="74016">Figure 7.44 – Notation Install task on Azure DevOps pipeline</st>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.44 - Azure DevOps 流水线中的符号安装任务
- en: <st c="74076">Next, let’s add the Notation task for signing our artifacts.</st>
    <st c="74138">Navigate back to the pipeline editing panel and search for notation
    again.</st> <st c="74213">This time, we will select</st> **<st c="74239">Sign</st>**
    <st c="74243">under</st> **<st c="74250">Command</st>** **<st c="74258">to run</st>**<st
    c="74264">.</st>
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加用于签署我们的工件的符号任务。<st c="74138">返回流水线编辑面板并再次搜索符号。</st> <st c="74213">这次，我们将选择**<st
    c="74239">签署</st>**在**<st c="74250">命令</st>** **<st c="74258">运行</st>**下。</st>
- en: <st c="74265">On the</st> `<st c="74400">crx6xa5yuubr2hm.azurecr.io/eshoponweb/web:latest</st>`<st
    c="74448">).</st>
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="74400">crx6xa5yuubr2hm.azurecr.io/eshoponweb/web:latest</st>`。'
- en: <st c="74451">The Notation task in Azure Pipelines natively supports the Azure
    Key Vault plugin, which enables the Notation CLI to generate signatures using
    Azure-Key-Vault-managed certificates and keys.</st> <st c="74642">Select</st>
    **<st c="74649">Azure Key Vault Plugin</st>** <st c="74671">under</st> **<st c="74678">Plugin</st>**
    <st c="74684">and then select the service connection earlier created in the</st>
    [*<st c="74747">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122) <st c="74756">hands-on
    exercise.</st>
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure Pipelines 中的符号任务原生支持 Azure Key Vault 插件，这使得符号 CLI 可以使用 Azure-Key-Vault
    管理的证书和密钥生成签名。选择**<st c="74649">Azure Key Vault 插件</st>**在**<st c="74678">插件</st>**下，然后选择之前在[*第
    6 章*](B19710_06.xhtml#_idTextAnchor122)实操练习中创建的服务连接。
- en: <st c="74775">For the</st> **<st c="74784">Key ID</st>** <st c="74790">section,
    add the result you get from running the following command</st> <st c="74858">on
    Azure</st> <st c="74867">Cloud Shell.</st> <st c="74880">Add the</st> <st c="74888">correct
    certificate and key</st> <st c="74916">vault names.</st>
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于**<st c="74784">密钥 ID</st>**部分，添加您通过在 Azure Cloud Shell 中运行以下命令获得的结果。<st c="74880">添加正确的证书和密钥</st>
    <st c="74916">保管库名称。</st>
- en: '[PRE6]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Figure 7.45 – Key ID value](img/B19710_07_45.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.45 – 密钥 ID 值](img/B19710_07_45.jpg)'
- en: <st c="75229">Figure 7.45 – Key ID value</st>
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.45 - 密钥 ID 值
- en: <st c="75255">In this case, the Key ID</st> <st c="75281">is</st> `<st c="75284">https://devsecopskeyvaulttest.vault.azure.net/keys/test-io/0daaced86b764e37855e02740e4f2d7c</st>`<st
    c="75375">.</st>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，密钥 ID 是 `<st c="75284">https://devsecopskeyvaulttest.vault.azure.net/keys/test-io/0daaced86b764e37855e02740e4f2d7c</st>`。
- en: <st c="75376">Notation supports signing using self-signed certificates and CA-issued
    certificates.</st> <st c="75462">For this task, we will use self-signed certificates.</st>
    <st c="75515">Scroll down and check</st> **<st c="75537">Self-signed Certificate</st>**<st
    c="75560">. Then, click</st> **<st c="75574">Add</st>** <st c="75577">to add the
    sign task to</st> <st c="75602">your pipeline.</st>
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.46 – Sign Notation marketplace task on Azure DevOps pipeline](img/B19710_07_46.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: <st c="75690">Figure 7.46 – Sign Notation marketplace task on Azure DevOps pipeline</st>
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75759">Run</st> <st c="75764">the pipeline</st> <st c="75777">and check</st>
    <st c="75787">on the two tasks added.</st> <st c="75811">Upon successful execution,
    the image will be signed as shown in</st> *<st c="75875">Figure 7</st>**<st c="75883">.47</st>*<st
    c="75886">:</st>
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.47 – Notation tasks completed, and image signed.](img/B19710_07_47.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: <st c="77070">Figure 7.47 – Notation tasks completed, and image signed.</st>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77127">Let’s</st> <st c="77134">now look</st> <st c="77143">at how we
    can perform DAST</st> <st c="77170">on the application running in the</st> <st
    c="77204">test environment.</st>
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77221">Task 2 – Integrating DAST tools to find and fix security vulnerabilities
    in the test phase</st>
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="77312">This</st> <st c="77318">task aims to</st> <st c="77331">integrate
    ZAP</st> <st c="77345">to perform</st> <st c="77356">DAST.</st> <st c="77362">There
    are several other commercial and open-source DAST tools such as Acunetix, Checkmarx
    DAST, Fortify WebInspect, Insight by Rapid7, PortSwigger Burp Suite, and Veracode,
    just to mention a few.</st> <st c="77558">Many of these tools are available on
    the Azure DevOps Marketplace (</st>[<st c="77625">https://marketplace.visualstudio.com/azuredevops</st>](https://marketplace.visualstudio.com/azuredevops)<st
    c="77674">).</st> <st c="77678">It is important</st> <st c="77694">to perform
    a DAST scan because it looks at a broad range of vulnerabilities, including input
    validation that could make an application vulnerable to XSS or SQL injection.</st>
    <st c="77865">DAST is performed on an application that is running.</st> <st c="77918">It
    runs automated penetration tests on your web applications</st> <st c="77979">and
    APIs</st> <st c="77988">that are</st> <st c="77997">already</st> <st c="78005">running.</st>
    <st c="78014">It simulates real-world attacks covering the</st> *<st c="78059">OWASP
    Top</st>* *<st c="78069">10</st>* <st c="78071">(</st>[<st c="78073">https://owasp.org/www-project-top-ten/</st>](https://owasp.org/www-project-top-ten/)<st
    c="78111">).</st>
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78114">In the previous task, we ran a pipeline that built and deployed
    the</st> <st c="78183">eShopOnWeb application.</st>
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.48 – The eShopOnWeb application deployed](img/B19710_07_48.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: <st c="78571">Figure 7.48 – The eShopOnWeb application deployed</st>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78620">Let’s see how we can perform DAST scans on our running application</st>
    <st c="78688">using ZAP:</st>
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78698">OWASP ZAP is available on the Azure Marketplace.</st> <st c="78748">Navigate
    to the Azure Marketplace at</st> [<st c="78785">https://marketplace.visualstudio.com/azuredevops</st>](https://marketplace.visualstudio.com/azuredevops)<st
    c="78833">, and search for</st> `<st c="78850">OWASP ZAP Scanner</st>`<st c="78867">.
    Click on</st> **<st c="78878">Get it free</st>**<st c="78889">, select the correct
    organization to install the extension, and then go back to your project</st> <st
    c="78982">after installation.</st>
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.49 – OWASP ZAP Scanner in Azure Marketplace](img/B19710_07_49.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: <st c="79187">Figure 7.49 – OWASP ZAP Scanner in Azure Marketplace</st>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79239">We will</st> <st c="79248">add the OWASP ZAP Scanner task in a
    pipeline YAML file.</st> <st c="79304">For this</st> <st c="79313">instance, we
    will create a new pipeline for OWASP ZAP, however, you can still add the same
    tasks in the</st> <st c="79417">existing pipeline.</st>
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="79435">Navigate</st> <st c="79445">to</st> **<st c="79448">Pipelines</st>**
    <st c="79457">on</st> <st c="79461">the left, select</st> **<st c="79478">Pipelines</st>**<st
    c="79487">, and then select</st> **<st c="79505">New pipeline</st>**<st c="79517">.</st>
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="79518">Select</st> **<st c="79526">Azure Repos Git</st>** <st c="79541">and
    then</st> **<st c="79551">eShopOnWeb</st>**<st c="79561">. We will use</st> **<st
    c="79575">Starter pipeline</st>**<st c="79591">.</st>
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="79592">Delete the starter scripts, and then add the</st> **<st c="79638">OWASP
    Zap Scanner</st>** <st c="79655">task from the</st> **<st c="79670">Tasks</st>**
    <st c="79675">assistant.</st>
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.50 – OWASP ZAP Scanner in Azure Marketplace](img/B19710_07_50.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: <st c="79962">Figure 7.50 – OWASP ZAP Scanner in Azure Marketplace</st>
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80014">Set</st> `<st c="80040">1500</st>` <st c="80044">and select</st>
    **<st c="80056">Targeted Scan</st>** <st c="80069">as your scan type.</st> <st
    c="80089">Input</st> <st c="80095">the URL</st> <st c="80103">for the</st> <st
    c="80111">app deployed</st> <st c="80124">on the test environment and then</st>
    <st c="80157">click</st> **<st c="80163">Add</st>**<st c="80166">.</st>
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.51 – Set the OWASP Zap Scanner configurations](img/B19710_07_51.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: <st c="80352">Figure 7.51 – Set the OWASP Zap Scanner configurations</st>
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80406">The YAML file should now look like this after adding a</st> <st
    c="80462">display name.</st>
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.52 – The OWASP Zap Scanner task](img/B19710_07_52.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: <st c="80721">Figure 7.52 – The OWASP Zap Scanner task</st>
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80761">We</st> <st c="80765">need to publish the report generated by
    the OWASP ZAP Scanner</st> <st c="80827">task.</st> <st c="80833">From the</st>
    <st c="80842">assistant</st> `<st c="80878">publish build artifacts</st>`<st c="80901">.
    Leave the</st> <st c="80913">Path to publish as</st> `<st c="80932">$(Build.ArtifactStagingDirectory)</st>`
    <st c="80965">and the artifact name as</st> **<st c="80991">ZAP Reports</st>**<st
    c="81002">.</st>
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.53 – Publish build artifacts task](img/B19710_07_53.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: <st c="81447">Figure 7.53 – Publish build artifacts task</st>
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81489">Our</st> <st c="81494">YAML file</st> <st c="81504">now looks</st>
    <st c="81514">like</st> <st c="81519">the</st> <st c="81523">following:</st>
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.54 – OWASP ZAP and Publish tasks](img/B19710_07_54.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
- en: <st c="81864">Figure 7.54 – OWASP ZAP and Publish tasks</st>
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81905">The report is generated in JSON and HTML formats, which are machine
    readable, so the output can be used for further processing.</st> <st c="82034">We
    can also have the scan results published to the</st> **<st c="82085">Tests results</st>**
    <st c="82098">tab by adding the code snippets of the</st> **<st c="82138">Install
    handlebars</st>**<st c="82156">,</st> **<st c="82158">Report Generation</st>**<st
    c="82175">, and</st> **<st c="82181">Publish Report (Nunit Style)</st>** <st c="82209">code
    sections</st> <st c="82224">from</st> [<st c="82229">https://marketplace.visualstudio.com/items?itemName=CSE-DevOps.zap-scanner</st>](https://marketplace.visualstudio.com/items?itemName=CSE-DevOps.zap-scanner)<st
    c="82303">.</st>
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="82304">Once you’ve added the preceding three code snippets, update the
    file path parameter from the</st> **<st c="82398">Install handlebars</st>** <st
    c="82416">code snippet to</st> <st c="82433">the following:</st>
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="82515">Save</st> <st c="82521">and commit</st> <st c="82532">the new
    pipeline and then</st> <st c="82558">run it.</st>
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="82565">After a</st> <st c="82574">few minutes, the</st> <st c="82591">tasks
    are completed, and the scan results</st> <st c="82633">are published.</st>
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.55 – OWASP ZAP and Publish tasks successful](img/B19710_07_55.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: <st c="83026">Figure 7.55 – OWASP ZAP and Publish tasks successful</st>
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83078">Let’s see</st> <st c="83089">the scan</st> <st c="83098">results
    from</st> <st c="83111">the</st> **<st c="83115">Test results</st>** <st c="83127">tab.</st>
    <st c="83133">Navigate</st> <st c="83142">to the successful pipeline run and click
    on the</st> **<st c="83190">Tests</st>** <st c="83195">tab.</st>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.56 – The Tests results tab](img/B19710_07_56.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: <st c="83527">Figure 7.56 – The Tests results tab</st>
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83562">Go through the scan results and familiarize yourself with the
    findings from</st> <st c="83639">OWASP ZAP.</st>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83649">Summary</st>
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="83657">In this chapter, we covered several checks that should be performed
    before releasing an application to production.</st> <st c="83773">This includes
    ensuring that release artifacts are built from protected branches, implementing
    a code review process, selecting a secure artifact source, implementing a process
    to validate artifact integrity, managing secrets securely in the release phase,
    implementing IaC security scans, and validating and enforcing runtime security
    with release gates.</st> <st c="84128">We also covered runtime verification tools
    in place</st> <st c="84180">including DAST.</st>
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84195">In the next chapter, we will look at continuous security monitoring
    on Azure.</st> <st c="84274">Now that we have deployed the resources, we need
    to make sure they remain secure.</st> <st c="84356">Let’s</st> <st c="84362">dive
    in.</st>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
