- en: <st c="0">7</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">7</st>
- en: <st c="2">Implementing Security in the Test and Release Phases of DevOps</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">在 DevOps 的测试和发布阶段实现安全性</st>
- en: <st c="64">The goal of the</st> **<st c="81">test</st>** <st c="85">phase is
    to</st> <st c="98">make sure the compiled application provides the expected functionalities
    and does not contain any bugs that were not detected in the</st> <st c="231">build
    phase.</st> <st c="244">The goal of the</st> **<st c="260">release</st>** <st
    c="267">phase is to prepare and deliver the tested application for deployment
    to production or other target environments.</st> <st c="382">Depending on a project’s
    release strategy, the test and release phases often overlap.</st> <st c="468">It
    is common to release software into a pre-production environment for automated
    runtime testing, using tools such as Selenium, before releasing it to production.</st>
    <st c="631">In this chapter, we will cover DevSecOps practices to secure and integrate
    security into these phases.</st> <st c="734">By the end of this chapter, you will
    understand these key</st> <st c="792">security practices:</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64">测试</st>阶段的目标是**<st c="81">确保编译后的应用程序提供预期功能，并且不包含在构建阶段未检测到的任何错误。</st>**
    <st c="231">发布</st>阶段的目标是**<st c="260">为将测试过的应用程序准备并交付部署到生产或其他目标环境。</st>** <st
    c="382">根据项目的发布策略，测试和发布阶段通常是重叠的。</st> <st c="468">通常，软件会先发布到预生产环境进行自动化运行时测试，使用如
    Selenium 等工具，然后再发布到生产环境。</st> <st c="631">在本章中，我们将讨论 DevSecOps 实践，确保并将安全集成到这些阶段中。</st>
    <st c="734">在本章结束时，您将理解以下关键</st> <st c="792">安全实践：</st>
- en: <st c="811">Ensuring that release artifacts are built from</st> <st c="859">protected
    branches</st>
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="811">确保发布构件是从</st> <st c="859">受保护的分支构建的</st>
- en: <st c="877">Implementing a code</st> <st c="898">review process</st>
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="877">实现代码</st> <st c="898">审查流程</st>
- en: <st c="912">Selecting a secure</st> <st c="932">artifact source</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="912">选择一个安全的</st> <st c="932">构件源</st>
- en: <st c="947">Implementing a process to validate</st> <st c="983">artifact integrity</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="947">实现验证</st> <st c="983">构件完整性的过程</st>
- en: <st c="1001">Managing secrets securely in the</st> <st c="1035">release phase</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1001">在</st> <st c="1035">发布阶段安全地管理机密</st>
- en: <st c="1048">Validating and enforcing runtime security with</st> <st c="1096">release
    gates</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1048">使用</st> <st c="1096">发布门禁</st> <st c="1151">来验证并强制执行运行时安全</st>
- en: <st c="1109">Let’s</st> <st c="1116">get started!</st>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1109">让我们</st> <st c="1116">开始吧！</st>
- en: <st c="1128">Technical requirements</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1128">技术要求</st>
- en: <st c="1151">To follow along with the instructions in this chapter, you will
    need</st> <st c="1221">the following:</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1221">要跟随本章的说明，您将需要</st> <st c="1356">以下内容：</st>
- en: <st c="1235">A PC with</st> <st c="1246">internet connection</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1235">一台配有</st> <st c="1246">互联网连接的 PC</st>
- en: <st c="1265">An active</st> <st c="1276">Azure subscription</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1265">一个有效的</st> <st c="1276">Azure 订阅</st>
- en: <st c="1294">An Azure</st> <st c="1304">DevOps organization</st>
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1294">一个 Azure</st> <st c="1304">DevOps 组织</st>
- en: <st c="1323">A GitHub</st> <st c="1333">Enterprise organization</st>
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1323">一个 GitHub</st> <st c="1333">企业组织</st>
- en: <st c="1356">Understanding the continuous deployment phase of DevOps</st>
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1356">了解 DevOps 的持续部署阶段</st>
- en: '**<st c="1412">Continuous Deployment (CD)</st>** <st c="1439">is a DevOps practice
    where code changes that have been successfully</st> <st c="1508">integrated and
    passed automated testing are automatically transitioned to the production environment.</st>
    <st c="1610">Activities</st> <st c="1621">in this phase include packaging the
    code into deployable formats, storing the packages in an artifact repository,
    and validating the software in a pre-production runtime environment before its
    final transition to the production</st> <st c="1849">runtime environment.</st>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="1412">持续部署（CD）</st>** <st c="1439">是 DevOps 实践之一，成功集成并通过自动化测试的代码更改会自动过渡到生产环境。</st>
    <st c="1610">这一阶段的活动包括将代码打包成可部署的格式，将包存储在构件库中，并在其最终过渡到生产</st> <st c="1849">运行时环境之前，在预生产运行时环境中验证软件。</st>'
- en: <st c="1869">The process ensures that new features, bug fixes, and updates are
    rapidly and consistently delivered to users without manual intervention, enabling
    a seamless flow from development to deployment.</st> <st c="2066">The key to a
    successful CD is a robust automated testing framework that validates changes and
    ensures the stability and reliability of the application in a</st> <st c="2222">real-world
    setting.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1869">该过程确保新特性、错误修复和更新能够快速且持续地交付给用户，无需人工干预，从而实现从开发到部署的无缝流转。</st> <st
    c="2066">成功的持续交付（CD）的关键在于一个强大的自动化测试框架，能够验证更改并确保应用程序在</st> <st c="2222">实际环境中的稳定性和可靠性。</st>
- en: '*<st c="2241">Figure 7</st>**<st c="2250">.1</st>* <st c="2252">shows a simplified
    example of a DevOps CD process.</st> <st c="2304">In the scenario, an application
    package, labeled as</st> *<st c="2356">APP:V1</st>*<st c="2362">, is published
    into the artifact store from the build process.</st> <st c="2425">The creation
    of the new package initiates a CD pipeline, which automatically deploys it to
    a staging environment for testing.</st> <st c="2551">Once the testing has successfully
    passed, the package is deployed to the production environment where it becomes
    available for</st> <st c="2678">end-user access.</st>'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="2241">图 7</st>**<st c="2250">.1</st>* <st c="2252">展示了一个简化的 DevOps
    CD 过程示例。</st> <st c="2304">在该场景中，一个标记为</st> *<st c="2356">APP:V1</st>*<st c="2362">的应用程序包从构建过程中发布到工件库。</st>
    <st c="2425">新包的创建启动了一个 CD 流水线，该流水线会自动将其部署到暂存环境中进行测试。</st> <st c="2551">测试成功通过后，包被部署到生产环境中，供</st>
    <st c="2678">最终用户访问。</st>'
- en: '![Figure 7.1 – Continuous delivery example scenario](img/B19710_07_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 持续交付示例场景](img/B19710_07_01.jpg)'
- en: <st c="3035">Figure 7.1 – Continuous delivery example scenario</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3035">图 7.1 – 持续交付示例场景</st>
- en: <st c="3084">Implementing</st> <st c="3098">security in the CD phase involves
    securely storing the release artifacts, validating their security before release,
    ensuring</st> <st c="3223">the runtime environment’s security before software
    deployment, and using</st> **<st c="3296">infrastructure as code</st>** <st c="3318">(</st>**<st
    c="3320">IaC</st>**<st c="3323">) to automatically configure the runtime environment’s
    security.</st> <st c="3389">Let us review</st> <st c="3403">these areas.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3084">在 CD 阶段实施安全性包括安全存储发布工件，在发布前验证其安全性，确保</st> <st c="3223">运行环境的安全性在软件部署前得到保障，并使用</st>
    **<st c="3296">基础设施即代码</st>** <st c="3318">(</st>**<st c="3320">IaC</st>**<st
    c="3323">) 自动配置运行环境的安全性。</st> <st c="3389">让我们回顾一下</st> <st c="3403">这些领域。</st>
- en: <st c="3415">Protecting release artifacts in the release phase</st>
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3415">在发布阶段保护发布工件</st>
- en: <st c="3465">DevOps processes are about speed and agility.</st> <st c="3512">The
    aim is to remove obstacles that could slow down</st> <st c="3564">the</st> <st
    c="3568">speed to market.</st> <st c="3585">It is not unusual for code changes
    to move from a developer’s workspace to the production environment</st> <st c="3687">within
    minutes, mainly driven by automation and with few manual checks.</st> <st c="3759">It
    is impressive to read about the deployment figures from organizations that are
    more mature in their DevOps practices.</st> <st c="3880">For example, Netflix
    maintains over 600 services in production and does around 100 deployments a day;
    Uber operates over 1,000 services in production with several thousand deployments
    weekly; WeChat has more than 3,000 services in production and manages approximately
    1,000</st> <st c="4154">deployments daily!</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3465">DevOps 过程注重速度和灵活性。</st> <st c="3512">其目标是消除可能减缓</st> <st c="3564">市场速度的障碍。</st>
    <st c="3568">通常情况下，代码更改会在几分钟内从开发者的工作区移动到生产环境</st> <st c="3585">，主要依靠自动化，且几乎没有人工检查。</st>
    <st c="3687">阅读那些在 DevOps 实践上更为成熟的组织的部署数据令人印象深刻。</st> <st c="3759">例如，Netflix
    维持着超过 600 个生产环境中的服务，每天进行约 100 次部署；Uber 运营着超过 1,000 个生产环境中的服务，每周进行几千次部署；WeChat
    生产环境中的服务超过 3,000 个，每天大约进行 1,000 次</st> <st c="4154">部署！</st>
- en: <st c="4172">Note</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4172">注意</st>
- en: <st c="4177">For information that highlights the deployment pace of companies
    such as Netflix, Uber, and WeChat, please refer to this</st> <st c="4299">document:</st>
    [<st c="4309">https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition</st>](https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition)<st
    c="4386">.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 若要了解如 Netflix、Uber 和微信等公司的部署速度信息，请参阅此[文档](https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition)。
- en: <st c="4387">To integrate security in the release phase, start by reviewing
    your CI/CD process and ensuring that no one (person or application) can deploy
    code changes or new artifacts without</st> <st c="4568">strict reviews and approvals.</st>
    <st c="4598">The</st> <st c="4602">reviews should include both automated checks
    and human-led reviews.</st> <st c="4670">Following zero-trust principles, you
    have to assume that an attacker might eventually gain access to a system within
    your CI/CD process (source control, CI system, or artifact repository).</st> <st
    c="4859">To mitigate this, we need to implement measures that prevent any single
    entity from independently pushing code ch</st><st c="4972">anges or release artifacts
    through the</st> <st c="5012">release pipeline.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在发布阶段集成安全性，首先需要审查您的 CI/CD 流程，确保没有任何人（无论是个人还是应用程序）能够在没有严格审查和批准的情况下部署代码更改或新的工件。审查应包括自动化检查和人工审核。遵循零信任原则，您必须假设攻击者最终可能会获得对
    CI/CD 流程中某个系统的访问权限（如源代码控制、CI 系统或工件库）。为了解决这个问题，我们需要实施措施，防止任何单一实体独立推送代码更改或通过发布管道发布工件。
- en: <st c="5029">Ensuring that release artifacts are built from protected branches</st>
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保发布工件是从受保护的分支构建的
- en: <st c="5095">Implementing</st> <st c="5109">security in the test and release
    phases of DevOps starts with the security of the artifacts that will be deployed
    – we refer</st> <st c="5234">to them as</st> **<st c="5245">release artifacts</st>**<st
    c="5262">.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 DevOps 测试和发布阶段的安全性始于对将要部署的工件的安全性——我们称之为**发布工件**。
- en: <st c="5263">Note</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: <st c="5268">A release artifact is software or a software component that is
    packaged and ready for deployment.</st> <st c="5367">Artifacts vary depending
    on the technology stack and target deployment platforms.</st> <st c="5449">For</st>
    <st c="5453">example, Java applications are typically packaged as</st> `<st c="5649">.dll</st>`
    <st c="5653">or</st> `<st c="5657">.exe</st>` <st c="5661">files) are the compiled
    code artifacts</st> <st c="5701">that are deployed to run on the .NET runtime.</st>
    <st c="5747">In JavaScript</st> <st c="5761">or Node.js projects,</st> `<st c="5890">package.json</st>`
    <st c="5902">file.</st> <st c="5909">For</st> <st c="5913">Python applications,</st>
    `<st c="5941">.whl</st>`<st c="5945">) files are a more modern packaging format,
    aimed at replacing egg files.</st> <st c="6020">They facilitate the distribution
    and installation of Python libraries and applications.</st> <st c="6108">For containerized
    solutions, applications are packaged as</st> <st c="6166">container images.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 发布工件是已打包并准备好部署的软件或软件组件。工件根据技术栈和目标部署平台的不同而有所不同。例如，Java 应用通常打包为`.dll`或`.exe`文件，它们是编译后的代码工件，部署后在
    .NET 运行时上运行。在 JavaScript 或 Node.js 项目中，`package.json`文件。对于 Python 应用，`.whl`文件是一种更现代的打包格式，旨在替代
    egg 文件。它们促进了 Python 库和应用的分发和安装。对于容器化解决方案，应用被打包为容器镜像。
- en: <st c="6183">A good starting point is to protect all branches that are used
    to create these release artifacts.</st> <st c="6282">In GitHub Enterprise, this
    can be done with</st> **<st c="6326">Branch protection rules</st>**<st c="6349">,
    and in Azure DevOps, this can be done with</st> **<st c="6394">Branch Policies</st>**<st
    c="6409">.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的起点是保护所有用于创建这些发布工件的分支。在 GitHub Enterprise 中，可以使用**分支保护规则**来实现，在 Azure DevOps
    中，则可以使用**分支策略**来实现。
- en: <st c="6410">To implement in GitHub Enterprise, navigate to</st> **<st c="6458">Repository
    Settings</st>**<st c="6477">, then</st> **<st c="6484">Code and automation</st>**
    <st c="6503">|</st> **<st c="6506">Branches</st>** <st c="6514">|</st> **<st c="6517">Branch
    protection rules</st>**<st c="6540">, and then click on</st> **<st c="6560">Add
    rule</st>**<st c="6568">.</st> *<st c="6570">Figure 7</st>**<st c="6578">.2</st>*
    <st c="6580">shows an example of a branch protection rule that is used to protect
    any branch</st> <st c="6661">that contains the word “release.” This requires admin
    permissions or a custom role with the</st> **<st c="6753">Edit repository</st>**
    **<st c="6769">rules</st>** <st c="6774">permission.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6410">要在 GitHub Enterprise 中实现，请导航至</st> **<st c="6458">仓库设置</st>**<st
    c="6477">，然后</st> **<st c="6484">代码与自动化</st>** <st c="6503">|</st> **<st c="6506">分支</st>**
    <st c="6514">|</st> **<st c="6517">分支保护规则</st>**<st c="6540">，然后点击</st> **<st
    c="6560">添加规则</st>**<st c="6568">。</st> *<st c="6570">图 7</st>**<st c="6578">.2</st>*
    <st c="6580">显示了一个用于保护包含“release”字样的分支的示例分支保护规则。</st> <st c="6661">这需要管理员权限或具有</st>
    **<st c="6753">编辑仓库</st>** **<st c="6769">规则</st>** <st c="6774">权限的自定义角色。</st>
- en: '![Figure 7.2 – Sample branch protection rule in GitHub Enterprise](img/B19710_07_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – GitHub Enterprise 中的示例分支保护规则](img/B19710_07_02.jpg)'
- en: <st c="7593">Figure 7.2 – Sample branch protection rule in GitHub Enterprise</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7593">图 7.2 – GitHub Enterprise 中的示例分支保护规则</st>
- en: <st c="7656">To implement in Azure DevOps, go to</st> **<st c="7693">Project
    Settings</st>** <st c="7709">|</st> **<st c="7712">Repos</st>** <st c="7717">|</st>
    **<st c="7720">Repositories</st>**<st c="7732">, select a</st> **<st c="7743">repository</st>**<st
    c="7753">, choose</st> **<st c="7762">Policies</st>** <st c="7770">|</st> **<st
    c="7773">Branch Policies</st>**<st c="7788">, and select a</st> **<st c="7803">branch</st>**
    <st c="7809">(note that you may need to scroll down to see your list of branches).</st>
    *<st c="7880">Figure 7</st>**<st c="7888">.3</st>* <st c="7890">shows an example
    of a branch policy in Azure DevOps.</st> <st c="7944">This requires admin permissions
    or a custom role with the</st> **<st c="8002">Edit</st>** **<st c="8007">policies</st>**
    <st c="8015">permission.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7656">要在 Azure DevOps 中实现，请转到</st> **<st c="7693">项目设置</st>** <st c="7709">|</st>
    **<st c="7712">仓库</st>** <st c="7717">|</st> **<st c="7720">Repositories</st>**<st
    c="7732">，选择一个</st> **<st c="7743">仓库</st>**<st c="7753">，选择</st> **<st c="7762">策略</st>**
    <st c="7770">|</st> **<st c="7773">分支策略</st>**<st c="7788">，并选择一个</st> **<st c="7803">分支</st>**
    <st c="7809">(注意，您可能需要滚动才能看到分支列表)。</st> *<st c="7880">图 7</st>**<st c="7888">.3</st>*
    <st c="7890">显示了 Azure DevOps 中的分支策略示例。</st> <st c="7944">这需要管理员权限或具有</st> **<st
    c="8002">编辑</st>** **<st c="8007">策略</st>** <st c="8015">权限的自定义角色。</st>
- en: '![Figure 7.3 – Sample branch protection rule in Azure DevOps](img/B19710_07_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – Azure DevOps 中的示例分支保护规则](img/B19710_07_03.jpg)'
- en: <st c="8687">Figure 7.3 – Sample branch protection rule in Azure DevOps</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8687">图 7.3 – Azure DevOps 中的示例分支保护规则</st>
- en: <st c="8745">Overall, both platforms offer similar branch protection features.</st>
    <st c="8812">GitHub Enterprise may not have</st> <st c="8843">direct branch protection
    settings for build validation and human reviews, but these capabilities can be
    achieved through alternative methods (see</st> *<st c="8989">Figure 7</st>**<st
    c="8997">.4</st>*<st c="8999">).</st> <st c="9003">A notable distinction is the
    lack of support for requiring signed commits in Azure DevOps, which is available
    in GitHub Enterprise.</st> <st c="9135">For a detailed comparison of branch protection
    features between the two platforms, see</st> *<st c="9222">Figure 7</st>**<st
    c="9230">.4</st>*<st c="9232">.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8745">总体而言，这两个平台提供了类似的分支保护功能。</st> <st c="8812">GitHub Enterprise 可能没有</st>
    <st c="8843">直接的构建验证和人工审核分支保护设置，但这些功能可以通过其他方法实现（见</st> *<st c="8989">图 7</st>**<st
    c="8997">.4</st>*<st c="8999">）。</st> <st c="9003">一个显著的区别是 Azure DevOps 不支持要求提交签名，而
    GitHub Enterprise 支持这一功能。</st> <st c="9135">关于这两个平台之间分支保护功能的详细比较，请参见</st> *<st
    c="9222">图 7</st>**<st c="9230">.4</st>*<st c="9232">。</st>
- en: '![Figure 7.4 – Branch protection feature comparison](img/B19710_07_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 分支保护功能比较](img/B19710_07_04.jpg)'
- en: <st c="9716">Figure 7.4 – Branch protection feature comparison</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9716">图 7.4 – 分支保护功能比较</st>
- en: <st c="9765">Following zero-trust principles, we also want to make sure that
    branch protection policies are enforced for everyone, including administrators.</st>
    <st c="9910">This is extremely important since administrator accounts are often
    targeted for account hijacking due to their</st> <st c="10021">privileged role.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9765">遵循零信任原则，我们还希望确保对所有人（包括管理员）强制执行分支保护策略。</st> <st c="9910">这一点非常重要，因为管理员帐户通常会成为账户劫持的目标，原因是它们的</st>
    <st c="10021">特权角色。</st>
- en: <st c="10037">Adopt a zero-trust approach to all main release branches for everyone
    with exceptions only in rare scenarios</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10037">采用零信任方法，适用于所有主要发布分支，只有在极少数情况下才允许例外。</st>
- en: <st c="10146">In GitHub</st> <st c="10157">Enterprise, we can activate the</st>
    **<st c="10189">Do not allow bypassing the above settings</st>** <st c="10230">option
    in our branch protection rule (see</st> *<st c="10273">Figure 7</st>**<st c="10281">.5</st>*<st
    c="10283">).</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10146">在 GitHub</st> <st c="10157">Enterprise 中，我们可以激活</st> **<st c="10189">不允许绕过上述设置</st>**
    <st c="10230">选项，作为我们的分支保护规则的一部分（参见</st> *<st c="10273">图 7</st>**<st c="10281">.5</st>*<st
    c="10283">）。</st>
- en: '![Figure 7.5 – Enforce branch protection settings for everyone in GitHub Enterprise](img/B19710_07_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 在 GitHub Enterprise 中强制执行所有人的分支保护设置](img/B19710_07_05.jpg)'
- en: <st c="10729">Figure 7.5 – Enforce branch protection settings for everyone in
    GitHub Enterprise</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10729">图 7.5 – 在 GitHub Enterprise 中强制执行所有人的分支保护设置</st>
- en: <st c="10810">In Azure DevOps, there is no equivalent setting for this, but
    we can restrict or audit roles/users with permissions to bypass policies on pull
    requests and pushes.</st> <st c="10975">By default, no role, including administrators,
    has these permissions assigned (see</st> *<st c="11058">Figure 7</st>**<st c="11066">.6</st>*<st
    c="11068">).</st> <st c="11072">To review permissions in Azure DevOps, navigate
    to</st> **<st c="11123">Project Settings</st>** <st c="11139">|</st> **<st c="11142">Repos</st>**
    <st c="11147">|</st> **<st c="11150">Repositories</st>**<st c="11162">, select
    a</st> **<st c="11173">repository</st>**<st c="11183">, then</st> **<st c="11190">Security</st>**<st
    c="11198">, and check</st> **<st c="11210">Bypass policies when completing pull
    requests</st>** <st c="11255">and</st> **<st c="11260">Bypass policies when pushing</st>**
    <st c="11288">(</st>*<st c="11290">Figure 7</st>**<st c="11298">.6</st>*<st c="11300">).</st>
    <st c="11304">The permission can also be configured at the branch level, rather
    than the</st> <st c="11379">repository level.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10810">在 Azure DevOps 中没有类似的设置，但我们可以限制或审计有权限绕过拉取请求和推送策略的角色/用户。</st> <st
    c="10975">默认情况下，没有任何角色，包括管理员，拥有这些权限（参见</st> *<st c="11058">图 7</st>**<st c="11066">.6</st>*<st
    c="11068">）。</st> <st c="11072">要在 Azure DevOps 中查看权限，导航至</st> **<st c="11123">项目设置</st>**
    <st c="11139">|</st> **<st c="11142">代码库</st>** <st c="11147">|</st> **<st c="11150">仓库</st>**<st
    c="11162">，选择一个</st> **<st c="11173">仓库</st>**<st c="11183">，然后选择</st> **<st c="11190">安全</st>**<st
    c="11198">，并检查</st> **<st c="11210">完成拉取请求时绕过策略</st>** <st c="11255">和</st> **<st
    c="11260">推送时绕过策略</st>** <st c="11288">(</st>*<st c="11290">图 7</st>**<st c="11298">.6</st>*<st
    c="11300">)。</st> <st c="11304">该权限也可以在分支级别配置，而不是在</st> <st c="11379">仓库级别。</st>
- en: '![Figure 7.6 – Reviewing permissions to bypass branch protection policies in
    Azure DevOps](img/B19710_07_06.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 在 Azure DevOps 中查看绕过分支保护策略的权限](img/B19710_07_06.jpg)'
- en: <st c="12078">Figure 7.6 – Reviewing permissions to bypass branch protection
    policies in Azure DevOps</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12078">图 7.6 – 在 Azure DevOps 中查看绕过分支保护策略的权限</st>
- en: <st c="12165">In case</st> <st c="12174">of a compromise of an administrator
    account, branch protection settings could be disabled to allow an attacker to
    fast-track malicious code changes to production by bypassing the required checks.</st>
    <st c="12370">For this reason, it is important to also track and audit branch
    protection and sensitive permission changes to spot unusual bypass attempts.</st>
    *<st c="12511">Figure 7</st>**<st c="12519">.7</st>* <st c="12521">shows an example
    audit log entry for a modification to a sensitive branch protection setting in</st>
    <st c="12618">GitHub Enterprise.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12165">如果</st> <st c="12174">管理员帐户被攻破，分支保护设置可能会被禁用，允许攻击者绕过必需的检查，快速将恶意代码更改推送到生产环境。</st>
    <st c="12370">因此，跟踪和审计分支保护及敏感权限的更改非常重要，以便发现异常的绕过尝试。</st> *<st c="12511">图 7</st>**<st
    c="12519">.7</st>* <st c="12521">展示了在</st> <st c="12618">GitHub Enterprise 中修改敏感分支保护设置的审计日志条目的示例。</st>
- en: '![Figure 7.7 – Sample log entry for a modification to a sensitive branch protection
    setting](img/B19710_07_07.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 修改敏感分支保护设置的示例日志条目](img/B19710_07_07.jpg)'
- en: <st c="13012">Figure 7.7 – Sample log entry for a modification to a sensitive
    branch protection setting</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13012">图 7.7 – 修改敏感分支保护设置的日志示例</st>
- en: <st c="13101">For information on enabling auditing, please refer to the</st>
    *<st c="13160">Ensuring the build environment is logged</st>* <st c="13200">section
    in</st> [*<st c="13212">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122)<st
    c="13221">.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13101">有关启用审计的信息，请参考</st> *<st c="13160">确保构建环境已记录</st>* <st c="13200">部分内容，详见</st>
    [*<st c="13212">第 6 章</st>*](B19710_06.xhtml#_idTextAnchor122)<st c="13221">。</st>
- en: <st c="13222">Implementing a code review process</st>
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="13222">实施代码审查流程</st>
- en: <st c="13257">Another good security measure is to require human-led reviews
    for both the release branches</st> <st c="13350">and the deployment workflow/pipeline
    configuration files.</st> <st c="13408">This should be in addition to automated
    security scans that are enforced for code to be merged with the release branches.</st>
    <st c="13530">Automated scans are useful but can be bypassed, hence the need for
    human checks.</st> <st c="13611">Even with necessary controls in place, new bypass
    methods may be discovered.</st> <st c="13688">Including experienced human reviewers
    provides an additional layer of defense against potential</st> <st c="13784">malicious
    attacks.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13257">另一个好的安全措施是要求对发布分支</st> <st c="13350">和部署工作流/管道配置文件进行人工审查。</st>
    <st c="13408">这应该作为代码与发布分支合并前强制执行的自动化安全扫描之外的额外措施。</st> <st c="13530">自动化扫描是有用的，但可能会被绕过，因此需要人工检查。</st>
    <st c="13611">即使实施了必要的控制，也可能会发现新的绕过方法。</st> <st c="13688">包括经验丰富的人工审阅者提供了一层额外的防护，防止潜在的</st>
    <st c="13784">恶意攻击。</st>
- en: <st c="13802">Both the GitHub Enterprise and Azure DevOps platforms support
    granular implementation of code reviewers where we can assign different reviewers
    for different paths of the code base.</st> <st c="13985">In Azure DevOps, this
    can be implemented with a branch protection control while in GitHub Enterprise,
    this can be implemented with a branch protection control</st> <st c="14144">combined
    with a capability</st> <st c="14171">called</st> `<st c="14178">CODEOWNERS</st>`<st
    c="14188">.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13802">GitHub Enterprise 和 Azure DevOps 平台都支持细粒度的代码审阅实施，我们可以为代码库的不同路径分配不同的审阅者。</st>
    <st c="13985">在 Azure DevOps 中，这可以通过分支保护控制实现，而在 GitHub Enterprise 中，则可以通过分支保护控制</st>
    <st c="14144">结合</st> <st c="14171">一种名为</st> `<st c="14178">CODEOWNERS</st>`<st
    c="14188">的功能来实现。</st>
- en: <st c="14189">To enable granular code review in Azure DevOps, navigate to</st>
    **<st c="14250">Project Settings</st>**<st c="14266">, then</st> **<st c="14273">Repos</st>**<st
    c="14278">, and select</st> **<st c="14291">Repositories</st>**<st c="14303">.
    Choose a repository, click on</st> **<st c="14335">Policies</st>**<st c="14343">,
    and then scroll down to the</st> **<st c="14373">Branch Policies</st>** <st c="14388">section
    to find your release branch.</st> <st c="14426">Under</st> **<st c="14432">Branch
    Policies</st>**<st c="14447">, activate</st> **<st c="14458">Require a minimum
    number of reviewers</st>** <st c="14495">by setting it to</st> **<st c="14513">On</st>**<st
    c="14515">. Enter the number of required reviewers and choose from the available
    options (</st>*<st c="14595">Figure 7</st>**<st c="14604">.8</st>*<st c="14606">).</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14189">要在 Azure DevOps 中启用细粒度代码审查，请导航至</st> **<st c="14250">项目设置</st>**<st
    c="14266">，然后选择</st> **<st c="14273">仓库</st>**<st c="14278">，接着点击</st> **<st c="14291">仓库</st>**<st
    c="14303">。选择一个仓库，点击</st> **<st c="14335">策略</st>**<st c="14343">，然后滚动到</st> **<st
    c="14373">分支策略</st>** <st c="14388">部分，找到你的发布分支。</st> <st c="14426">在</st> **<st
    c="14432">分支策略</st>**<st c="14447">下，激活</st> **<st c="14458">要求最低数量的审阅者</st>**
    <st c="14495">并将其设置为</st> **<st c="14513">开启</st>**<st c="14515">。输入所需的审阅者数量，并从可用选项中选择（</st>*<st
    c="14595">图 7</st>**<st c="14604">.8</st>*<st c="14606">）。</st>
- en: '![Figure 7.8 – Enabling human-led code reviews in Azure DevOps](img/B19710_07_08.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 在 Azure DevOps 中启用人工代码审查](img/B19710_07_08.jpg)'
- en: <st c="15304">Figure 7.8 – Enabling human-led code reviews in Azure DevOps</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15304">图 7.8 – 在 Azure DevOps 中启用人工代码审查</st>
- en: <st c="15364">We can</st> <st c="15372">also automatically add reviewers to
    pull requests that change files in specific directories and files.</st> <st c="15475">For
    example, we may want to add members of the security team to review any change
    to the pipeline file or security champions in the development team to review code
    changes to the release branch.</st> <st c="15670">We can do this by configuring
    the option to</st> **<st c="15714">Automatically include reviewers</st>** <st
    c="15745">(</st>*<st c="15747">Figure 7</st>**<st c="15755">.9</st>*<st c="15757">).</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15364">我们还可以</st> <st c="15372">自动向拉取请求中添加审查者，审查那些更改特定目录和文件中的内容的文件。</st>
    <st c="15475">例如，我们可能希望将安全团队的成员添加为审查者，以审查任何对管道文件的更改，或者将开发团队中的安全冠军添加为审查者，以审查发布分支的代码更改。</st>
    <st c="15670">我们可以通过配置选项来实现这一点，</st> **<st c="15714">自动添加审查者</st>** <st c="15745">(</st>*<st
    c="15747">图 7</st>**<st c="15755">.9</st>*<st c="15757">)。</st>
- en: '![Figure 7.9 – Adding required reviewers in an Azure repository branch policy](img/B19710_07_09.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 在 Azure 仓库分支策略中添加必需的审查者](img/B19710_07_09.jpg)'
- en: <st c="16089">Figure 7.9 – Adding required reviewers in an Azure repository
    branch policy</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16089">图 7.9 – 在 Azure 仓库分支策略中添加必需的审查者</st>
- en: <st c="16164">If the setting is marked as</st> **<st c="16193">Required</st>**<st
    c="16201">, every individual listed as a reviewer must approve the changes.</st>
    <st c="16267">If group names are added as reviewers, at least one member from
    each group</st> <st c="16342">must approve the changes.</st> <st c="16368">If
    approval is required from only one group, then the number of approvals needed
    is the minimum number specified for that group.</st> <st c="16497">For example,
    a group could be formed for each development team that includes the security champions
    from the team, and this group would be required as a reviewer.</st> <st c="16660">This
    ensures that at least one person with security experience and training reviews
    the code changes before they</st> <st c="16773">are approved.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16164">如果设置标记为</st> **<st c="16193">必需</st>**<st c="16201">，则每个列为审查者的个人必须批准更改。</st>
    <st c="16267">如果将小组名称添加为审查者，则每个小组至少需要有一个成员</st> <st c="16342">批准更改。</st> <st c="16368">如果只需要一个小组的批准，那么所需的批准数就是该小组指定的最小数量。</st>
    <st c="16497">例如，可以为每个开发团队组成一个小组，其中包括该团队的安全冠军，而该小组将作为审查者。</st> <st c="16660">这可以确保至少有一个具有安全经验和培训的人在批准之前审查代码更改。</st>
    <st c="16773">被批准。</st>
- en: <st c="16786">For GitHub Enterprise, we can enable a branch protection rule
    to require a pull request before merging by selecting the</st> `<st c="17031">CODEOWNERS</st>`
    <st c="17041">file (</st>*<st c="17048">Figure 7</st>**<st c="17057">.10</st>*<st
    c="17060">).</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16786">对于 GitHub Enterprise，我们可以启用一个分支保护规则，在合并之前要求拉取请求，通过选择</st> `<st
    c="17031">CODEOWNERS</st>` <st c="17041">文件 (</st>*<st c="17048">图 7</st>**<st
    c="17057">.10</st>*<st c="17060">)。</st>
- en: '![Figure 7.10 – Enabling a Code Owners review in a GitHub Enterprise branch
    protection policy](img/B19710_07_10.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 在 GitHub Enterprise 分支保护策略中启用代码拥有者审查](img/B19710_07_10.jpg)'
- en: <st c="18171">Figure 7.10 – Enabling a Code Owners review in a GitHub Enterprise
    branch protection policy</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18171">图 7.10 – 在 GitHub Enterprise 分支保护策略中启用代码拥有者审查</st>
- en: <st c="18262">CODEOWNERS</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18262">CODEOWNERS</st>
- en: '`<st c="18273">CODEOWNERS</st>` <st c="18284">is a feature</st> <st c="18298">of
    GitHub that we can use to specify individuals or teams that are responsible for
    maintaining specific parts of a project.</st> <st c="18422">When changes are made
    to those parts, the designated code owners are automatically required to review
    and approve the changes before they can be merged.</st> <st c="18575">We can use
    this feature to implement code reviews for release branches and deployment</st>
    <st c="18661">workflow files.</st>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18273">CODEOWNERS</st>` <st c="18284">是 GitHub 的一个功能</st> <st c="18298">，我们可以用它指定负责维护项目特定部分的个人或团队。</st>
    <st c="18422">当对这些部分进行更改时，指定的代码拥有者会自动被要求审查并批准这些更改，才能合并。</st> <st c="18575">我们可以使用此功能为发布分支和部署</st>
    <st c="18661">工作流文件实施代码审查。</st>'
- en: <st c="18676">To use</st> `<st c="18684">CODEOWNERS</st>`<st c="18694">, we
    need to create a file called</st> `<st c="18728">CODEOWNERS</st>` <st c="18738">in
    the</st> `<st c="18746">.github/</st>`<st c="18754">,</st> `<st c="18756">root</st>`<st
    c="18760">, or</st> `<st c="18765">docs/</st>` <st c="18770">directory of the
    repository.</st> <st c="18800">The file uses a pattern that follows most (not
    all) of the same rules used in</st> `<st c="18878">gitignore</st>` <st c="18887">files.</st>
    <st c="18895">For example, a line entry of</st> `<st c="18924">/workflows/ @dev
    @security</st>` <st c="18950">means that any changes inside the</st> `<st c="18985">/workflows</st>`
    <st c="18995">directory will require approval from members of the</st> `<st c="19048">@dev
    or @security</st>` <st c="19065">teams, but approvals from both are</st> <st c="19101">not
    required.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19114">A line entry of</st> `<st c="19131">**/releases @securitychampions
    @teamleaders</st>` <st c="19174">means the</st> `<st c="19185">@securitychampions</st>`
    <st c="19203">and</st> `<st c="19208">@teamleaders</st>` <st c="19220">teams own
    any file in any</st> `<st c="19247">/releases</st>` <st c="19256">directory.</st>
    <st c="19268">To</st> <st c="19271">learn more about the</st> `<st c="19292">CODEOWNERS</st>`
    <st c="19302">file, please refer to this</st> <st c="19330">document:</st> [<st
    c="19340">https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax</st>](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax)<st
    c="19491">.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19492">Now that</st> <st c="19502">we understand one of some of the controls
    that we can implement to ensure release artifacts only come from validated code,
    let us move on to examine the secure storage of</st> <st c="19673">these artifacts.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19689">Selecting secure artifact sources</st>
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="19723">Another key security best practice in the test and release phases
    of DevOps is to secure the artifacts</st> <st c="19827">that will be deployed.</st>
    <st c="19850">These artifacts should be stored in trusted locations that maintain
    their integrity</st> <st c="19934">and prevent tampering.</st> <st c="19957">Both
    GitHub Actions and Azure Pipelines support deploying artifacts from various sources,
    such as build environments, package repositories, container repositories, file
    shares, and source control repositories.</st> *<st c="20167">Figure 7</st>**<st
    c="20175">.11</st>* <st c="20178">shows a screenshot of supported artifact sources
    for a classic Azure</st> <st c="20248">release pipeline.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20265">DevSecOps</st> <st c="20276">requires us to only use artifact
    sources that support</st> **<st c="20330">immutability</st>**<st c="20342">,</st>
    **<st c="20344">traceability</st>**<st c="20356">, and</st> **<st c="20362">access
    control</st>**<st c="20376">. Immutability guarantees integrity by ensuring</st>
    <st c="20424">that an artifact’s contents will not change from when it is published,
    tested for security, and eventually released to production.</st> <st c="20555">This
    can be implemented</st> <st c="20579">at the artifact source level or the package
    level.</st> <st c="20630">Implementing at the source level means that our artifact
    sources should not allow any modifications to packages once published.</st> <st
    c="20758">To correct any issues, a new version should be published instead of
    modifying an existing one.</st> <st c="20853">This ensures that the content of
    the artifact that</st> <st c="20904">has been security tested is the same as the
    one deployed.</st> <st c="20962">Sources such as file shares,</st> **<st c="20991">Azure
    Container Registry</st>** <st c="21015">(</st>**<st c="21017">ACR</st>**<st c="21020">),
    and GitHub Packages should be used carefully as they are mutable by default.</st>
    <st c="21101">Anyone with the right set of permissions can update the content
    of published artifacts that are stored in them.</st> <st c="21213">This can be
    exploited by attackers to replace the original version with a compromised one</st>
    <st c="21303">before deployment.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Supported artifact sources for a classic Azure release pipeline](img/B19710_07_11.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
- en: <st c="21464">Figure 7.11 – Supported artifact sources for a classic Azure release
    pipeline</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21541">For ACR, we can</st> <st c="21558">enforce immutability at the
    artifact store level by configuring image locking.</st> <st c="21637">This is
    achieved using the</st> `<st c="21664">az acr repository update</st>` <st c="21688">command.</st>
    *<st c="21698">Figure 7</st>**<st c="21706">.12</st>* <st c="21709">shows a sample
    GitHub workflow that uses this command to lock a new container image in the build
    and</st> <st c="21811">publish phase.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Sample GitHub workflow with ACR image locking](img/B19710_07_12.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: <st c="22553">Figure 7.12 – Sample GitHub workflow with ACR image locking</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22612">Immutability is one of several factors to consider when selecting
    artifact sources.</st> <st c="22697">Other important factors to consider are traceability
    and versioning.</st> <st c="22766">Traceability gives visibility into a package’s
    origin and links it to code changes, test cases, and work items.</st> <st c="22878">This
    makes it easier to perform forensic auditing in case of a breach.</st> <st c="22949">Versioning
    allows us to track security outcomes between different versions of our artifacts
    and allows quick rollbacks to secure versions when facing major</st> <st c="23105">zero-day
    vulnerabilities.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23130">Support for</st> <st c="23143">traceability and versioning varies
    by artifact source.</st> <st c="23198">For example, file shares are basic storage
    solutions that typically lack built-in versioning and traceability to source control.</st>
    <st c="23327">Implementing these features in file shares usually requires additional
    tools or</st> <st c="23407">custom configurations.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23429">File shares are generally not recommended as artifact sources
    in DevOps workflows.</st> <st c="23513">Workflow/pipeline artifacts naturally
    include these features, while ACR, GitHub Packages, and Azure Artifacts might
    also need</st> <st c="23639">extra configuration.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23659">Understanding workflow/pipeline artifacts</st>
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="23701">Both GitHub</st> <st c="23714">Actions and Azure Pipelines support
    options to publish artifacts internally within the build platform.</st> <st c="23817">For
    GitHub Actions, the</st> `<st c="23841">upload-artifact</st>` <st c="23856">action
    can be used to upload an artifact into an</st> **<st c="23906">Actions artifacts</st>**
    <st c="23923">store (</st>*<st c="23931">Figure 7</st>**<st c="23940">.13</st>*<st
    c="23943">).</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – GitHub Actions upload-artifact action](img/B19710_07_13.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: <st c="24500">Figure 7.13 – GitHub Actions upload-artifact action</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24551">For Azure</st> <st c="24562">Pipelines, the</st> `<st c="24577">PublishPipelineArtifact</st>`
    <st c="24600">or</st> `<st c="24604">PublishBuildArtifact</st>` <st c="24624">tasks
    can be used for the same purpose (</st>*<st c="24665">Figure 7</st>**<st c="24674">.14</st>*<st
    c="24677">).</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – Azure Pipelines PublishPipelineArtifact task](img/B19710_07_14.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: <st c="25294">Figure 7.14 – Azure Pipelines PublishPipelineArtifact task</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25352">These options are popular because they are easy to use, yet they
    impact immutability and traceability.</st> <st c="25456">Because the artifacts
    are stored within the build platform and they have a link to the workflow/pipeline
    run or job that created them, so, in this case, they offer built-in traceability.</st>
    <st c="25643">However, retention policies and behavior should also be considered
    to understand the overall impact.</st> <st c="25744">For example, GitHub Enterprise
    stores action</st> <st c="25789">artifacts for 90 days, but this can be extended
    up to 400 days.</st> <st c="25853">The customization can be done at the Enterprise,
    Organization, or Repository levels (</st>*<st c="25938">Figure 7</st>**<st c="25947">.15</st>*<st
    c="25950">).</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Configuring the retention period for GitHub workflow artifacts](img/B19710_07_15.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
- en: <st c="26239">Figure 7.15 – Configuring the retention period for GitHub workflow
    artifacts</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26315">Configuring artifact retention period in GitHub Enterprise</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26374">The</st> <st c="26379">artifacts retention settings can be customized
    at different levels in</st> <st c="26449">GitHub Enterprise:</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="26467">Enterprise</st>**<st c="26478">: Go to</st> **<st c="26487">Settings</st>**
    <st c="26495">|</st> **<st c="26498">Policies</st>** <st c="26506">|</st> **<st
    c="26509">Actions</st>** <st c="26516">|</st> **<st c="26519">Policies</st>**
    <st c="26527">|</st> **<st c="26530">Artifact and</st>** **<st c="26543">log retention</st>**<st
    c="26556">.</st>'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="26557">Organization</st>**<st c="26570">: Go to</st> **<st c="26579">Settings</st>**
    <st c="26587">|</st> **<st c="26590">Code, planning, and automation</st>** <st
    c="26620">|</st> **<st c="26623">Actions</st>** <st c="26630">|</st> **<st c="26633">General</st>**
    <st c="26640">|</st> **<st c="26643">Artifact and</st>** **<st c="26656">log retention</st>**<st
    c="26669">.</st>'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="26670">Repository</st>**<st c="26681">: Go to</st> **<st c="26690">Settings</st>**
    <st c="26698">|</st> **<st c="26701">Code and automation</st>** <st c="26720">|</st>
    **<st c="26723">Actions</st>** <st c="26730">|</st> **<st c="26733">General</st>**
    <st c="26740">|</st> **<st c="26743">Artifact and</st>** **<st c="26756">log retention</st>**<st
    c="26769">.</st>'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26770">The chosen retention period affects traceability.</st> <st c="26821">If
    we set a retention period of 100 days and we need to download a previous artifact
    from 120 days ago to investigate a recently discovered breach, we won’t be able
    to do so, unless we have transferred the artifact to another storage location.</st>
    <st c="27065">In Azure Pipelines, deleting a pipeline run also deletes all associated
    artifacts.</st> <st c="27148">This can also compromise traceability if a deleted
    artifact needs to be</st> <st c="27220">investigated later.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27239">From an immutabilit</st><st c="27259">y standpoint, the GitHub</st>
    `<st c="27285">upload-artifact</st>` <st c="27300">action can overwrite artifacts
    if the</st> `<st c="27339">overwrite</st>` <st c="27348">option is enabled (</st>*<st
    c="27368">Figure 7</st>**<st c="27377">.16</st>*<st c="27380">).</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – Implementing an artifact overwrite](img/B19710_07_16.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: <st c="27576">Figure 7.16 – Implementing an artifact overwrite</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27624">If developers</st> <st c="27639">do not pin release artifacts
    by IDs and use names instead, this could be exploited in an artifact swap attack.</st>
    <st c="27750">The Azure Pipelines</st> `<st c="27770">PublishPipelineArtifact@1</st>`
    <st c="27795">task behaves differently from this.</st> <st c="27832">It is designed
    to ensure immutable artifacts for a given build.</st> <st c="27896">Once published,
    another artifact with the same name cannot</st> <st c="27955">be published.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27968">Note</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27973">For more information on the action and task behavior, refer to
    the</st> <st c="28041">following documents:</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="28061">upload-artifact</st>`<st c="28077">:</st> [<st c="28080">https://github.com/actions/upload-artifact</st>](https://github.com/actions/upload-artifact)<st
    c="28122">.</st>'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="28123">PublishPipelineArtifact@1</st>`<st c="28149">:</st> [<st c="28152">https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/publish-pipeline-artifact-v1</st>](https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/publish-pipeline-artifact-v1)<st
    c="28253">.</st>'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="28254">Now that we have discussed security considerations for using workflow/pipeline
    artifacts as release sources, let us explore similar considerations for</st> <st
    c="28406">standalone services.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28426">Understanding Azure Artifacts and GitHub Packages</st>
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="28476">Both GitHub Enterprise and Azure DevOps provide standalone services
    for storing and managing</st> <st c="28570">release artifacts.</st> <st c="28589">GitHub
    Enterprise offers GitHub Packages, while Azure DevOps provides Azure Artifacts.</st>
    <st c="28676">Both services</st> <st c="28690">support feeds that can handle various
    package types such as NPM, NuGet, Maven, Python, and Universal packages.</st>
    <st c="28801">GitHub Packages also supports</st> <st c="28831">containers while
    Azure Artifacts does</st> <st c="28869">not.</st> <st c="28874">Azure offers ACR
    for storing containers.</st> <st c="28915">From a security consideration, both
    services are similar (</st>*<st c="28973">Figure 7</st>**<st c="28982">.17</st>*<st
    c="28985">).</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Security considerations in GitHub Packages and Azure Artifacts](img/B19710_07_17.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: <st c="29156">Figure 7.17 – Security considerations in GitHub Packages and Azure
    Artifacts</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29232">Packages in both GitHub Packages and Azure Artifacts are immutable
    by default.</st> <st c="29312">Once a package version is published, it cannot
    be modified.</st> <st c="29372">Any updates or fixes must be published as new
    versions, ensuring that deployed artifacts are consistent with those that have
    been verified.</st> <st c="29512">Traceability in Azure Artifacts is primarily
    managed through integration with Azure DevOps services.</st> <st c="29613">Each
    artifact is linked to a specific pipeline run, including details such as build
    number and associated commits.</st> <st c="29728">This data is crucial for reconstructing
    the artifact’s development history.</st> <st c="29804">Each package in GitHub
    Packages stores detailed provenance information including the commit SHA, branch,
    or tag from which it was built.</st> <st c="29941">This level of detail is particularly
    valuable for compliance and</st> <st c="30006">security auditing.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30024">Implementing artifact signing for integrity checks</st>
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="30075">Securing</st> <st c="30085">the DevOps</st> <st c="30096">workflow
    involves ensuring the integrity of every step in the software supply chain.</st>
    <st c="30181">If an attacker breaches the artifact store, they could tamper with
    packages meant for production and upload unauthorized artifacts.</st> <st c="30313">For
    example, in the CodeCov incident, an attacker used leaked credentials to upload
    a harmful artifact, leading to direct downloads by users.</st> <st c="30455">One
    mitigation strategy is to enforce an integrity validation process for all release
    artifacts.</st> <st c="30552">This includes signing packages and verifying digital
    signatures before deployment.</st> <st c="30635">Various tools</st> <st c="30649">and
    approaches could be used for this, but two common</st> <st c="30703">ones are</st>
    **<st c="30712">Sigstore’s Cosign</st>** <st c="30729">and</st> **<st c="30734">Notation</st>**<st
    c="30742">. Let us</st> <st c="30751">review these.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30764">Implementing artifact signing using Sigstore’s Cosign</st>
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**<st c="30818">Sigstore</st>** <st c="30827">is a set</st> <st c="30837">of
    open-source tools designed to automate the digital signing</st> <st c="30899">and
    verification of software</st> <st c="30928">artifacts.</st> <st c="30939">It is
    primarily aimed at software artifacts such as container images and binaries, but
    it can be used for any file type, including ZIP archives.</st> <st c="31084">It
    combines several tools and technologies, including</st> <st c="31138">the following:</st>'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="31152">Cosign</st>**<st c="31159">: This</st> <st c="31167">signs
    and verifies containers</st> <st c="31197">and artifacts</st>'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="31210">Fulcio</st>**<st c="31217">: A free</st> <st c="31227">root
    certification authority that issues</st> <st c="31268">temporary certificates</st>'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="31290">Rekor</st>**<st c="31296">: This records</st> <st c="31312">signed
    metadata to a</st> <st c="31333">tamper-resistant ledger</st>'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="31356">OpenID Connect</st>**<st c="31371">: This</st> <st c="31379">provides</st>
    <st c="31388">identity verification</st>'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="31409">Sigstore</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31418">To learn</st> <st c="31428">more about the Sigstore project, you
    can visit their website at</st> [<st c="31492">https://www.sigstore.dev/</st>](https://www.sigstore.dev/)
    <st c="31517">and explore their GitHub repository</st> <st c="31554">at</st> [<st
    c="31557">https://github.com/sigstore</st>](https://github.com/sigstore)<st c="31584">.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="31585">Cosign</st>** <st c="31592">(one of the tools included in the
    Sigstore project) simplifies signing and verifying</st> <st c="31678">software
    artifacts such as container images by making the process of managing signatures
    invisible.</st> <st c="31778">It automatically signs artifacts, stores the signatures
    in an OCI registry, and performs verifications without user intervention regarding
    signature handling.</st> <st c="31937">When signing a Docker image, Cosign creates
    a special tag in the OCI registry that incorporates the image’s unique digest
    (its immutable identifier) into the tag name.</st> <st c="32105">This allows for
    easy retrieval and verification of the image’s signature based on</st> <st c="32187">its
    digest.</st>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32198">To use</st> <st c="32206">Cosign, we</st> *<st c="32217">first</st>*
    <st c="32222">must ensure</st> <st c="32235">that it is installed on the runner/agent
    used for our workflow/pipeline.</st> <st c="32308">For GitHub, this can be done
    using the</st> `<st c="32347">cosign-installer</st>` <st c="32363">GitHub</st>
    <st c="32371">marketplace task (</st>*<st c="32389">Figure 7</st>**<st c="32398">.18</st>*<st
    c="32401">).</st> <st c="32405">For Azure DevOps, we use a command line step with
    our preferred OS package manager, as detailed</st> <st c="32501">at</st> [<st
    c="32504">https://docs.sigstore.dev/system_config/installation/</st>](https://docs.sigstore.dev/system_config/installation/)<st
    c="32557">.</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – The cosign-installer GitHub marketplace task](img/B19710_07_18.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: <st c="33001">Figure 7.18 – The cosign-installer GitHub marketplace task</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33059">The</st> *<st c="33064">second</st>* <st c="33070">step is optional.</st>
    <st c="33089">We could generate the key pairs that will be used for the digital
    signature using the</st> `<st c="33175">cosign generate-key-pair</st>` <st c="33199">command.</st>
    <st c="33209">This allows for more control but introduces the complexity of key
    management.</st> <st c="33287">Cosign also supports keyless signing, which uses
    ephemeral keys and logs the signing process transparently.</st> <st c="33395">This
    approach improves security and simplifies operations by eliminating the direct
    management of keys.</st> <st c="33499">The</st> *<st c="33503">third</st>* <st
    c="33508">step is to sign our artifact using the</st> `<st c="33548">cosign sign</st>`
    <st c="33559">command.</st> <st c="33569">The</st> *<st c="33573">final</st>*
    <st c="33578">step is to verify the signature with the</st> `<st c="33620">cosign
    verify</st>` <st c="33633">command, as part of our</st> <st c="33658">pre-deployment
    check.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33679">Implementing artifact signing using Notation</st>
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="33724">Notation</st> <st c="33734">is another tool that can be used to</st>
    <st c="33770">sign and verify the integrity and the publisher of digital artifacts.</st>
    <st c="33840">It is part of the Notary project, an incubating</st> <st c="33888">project
    of the</st> **<st c="33903">Cloud Native Computing</st>** **<st c="33926">Foundation</st>**
    <st c="33936">(</st>**<st c="33938">CNCF</st>**<st c="33942">).</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33945">Notary project</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33960">To learn</st> <st c="33970">more about the Notary project, you
    can visit their website at</st> [<st c="34032">https://notaryproject.dev/</st>](https://notaryproject.dev/)
    <st c="34058">and explore their GitHub repository</st> <st c="34095">at</st> [<st
    c="34098">https://github.com/notaryproject</st>](https://github.com/notaryproject)<st
    c="34130">.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34131">Similar to Sigstore, it is also primarily aimed at software artifacts
    such as container images and binaries, but it can be used for any file type, including
    ZIP files.</st> <st c="34300">Digital artifacts can be signed during the build
    process and their integrity and origin verified at deployment.</st> *<st c="34412">Figure
    7</st>**<st c="34420">.19</st>* <st c="34423">provides a high-level overview of
    how Notation is integrated into a</st> <st c="34492">DevOps workflow.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – How Notation is integrated into a DevOps workflow](img/B19710_07_19.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: <st c="34704">Figure 7.19 – How Notation is integrated into a DevOps workflow</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34767">To use</st> <st c="34775">Notation, we</st> *<st c="34788">first</st>*
    <st c="34793">must ensure</st> <st c="34806">that it is installed on the runner/agent
    used for our workflow/pipeline.</st> <st c="34879">For GitHub, this can be done
    using the</st> `<st c="34918">notation-action</st>` <st c="34933">GitHub marketplace
    action.</st> <st c="34961">Azure DevOps also has a</st> `<st c="34985">Notation</st>`
    <st c="34993">marketplace task that we can use for this (</st>*<st c="35037">Figure
    7</st>**<st c="35046">.20</st>*<st c="35049">).</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – Azure DevOps Notation marketplace task](img/B19710_07_20.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: <st c="35131">Figure 7.20 – Azure DevOps Notation marketplace task</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35183">The</st> *<st c="35188">second</st>* <st c="35194">step is to
    sign our artifact.</st> <st c="35225">The Notation task in Azure Pipelines natively
    supports the Azure Key Vault plugin, which enables the Notation CLI to generate
    signatures using Azure-Key-Vault-managed certificates and keys (</st>*<st c="35415">Figure
    7</st>**<st c="35424">.21</st>*<st c="35427">).</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Implementing Notation in Azure Pipelines](img/B19710_07_21.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: <st c="35668">Figure 7.21 – Implementing Notation in Azure Pipelines</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35722">It supports</st> <st c="35735">signing with self-signed</st> <st
    c="35760">certificates and</st> `<st c="35858">notation sign</st>` <st c="35871">command.</st>
    <st c="35881">The</st> <st c="35885">third and final step is to verify the signature
    as part of our pre-deployment checks.</st> <st c="35971">Notation supports specifying
    a Trust Policy file that defines the signature verification levels that we want
    to enforce.</st> <st c="36092">There are four</st> <st c="36107">verification
    levels:</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="36127">Strict</st>**<st c="36134">: This</st> <st c="36142">enforces
    all validations.</st> <st c="36168">If any validation fails, the verification
    fails.</st> <st c="36217">Best for build environments or</st> <st c="36248">high-assurance
    deployment.</st>'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="36274">Permissive</st>**<st c="36285">: This</st> <st c="36293">conducts
    most validations but logs issues such as revocation and expiry.</st> <st c="36366">Suitable
    for deployment or runtime when integrity and authenticity</st> <st c="36433">are
    key.</st>'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="36441">Audit</st>**<st c="36447">: Only</st> <st c="36455">ensures
    signature integrity if present; logs other</st> <st c="36506">validation failures.</st>'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="36526">Skip</st>**<st c="36531">: This does</st> <st c="36544">not
    perform signature verification.</st> <st c="36580">It is used when mixing signed
    and unsigned artifacts but requires specifying exact registry URLs</st> <st c="36677">in
    registryScopes.</st>'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="36695">Figure 7</st>**<st c="36704">.22</st>* <st c="36707">displays</st>
    <st c="36717">the four levels (strict, permissive, audit, and skip) and</st> <st
    c="36775">their</st> <st c="36781">respective validations.</st>'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Notation’s verification levels](img/B19710_07_22.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: <st c="37310">Figure 7.22 – Notation’s verification levels</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37354">To learn</st> <st c="37364">more about Notation’s Trust Policy
    file, please refer to this</st> <st c="37426">document:</st> [<st c="37436">https://github.com/notaryproject/specifications/blob/v1.0.0/specs/trust-store-trust-policy.md</st>](https://github.com/notaryproject/specifications/blob/v1.0.0/specs/trust-store-trust-policy.md)<st
    c="37529">.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37530">Managing secrets securely in the release phase</st>
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="37577">In automated build and deployment pipelines, developers may need
    to supply credentials</st> <st c="37665">needed to access internal</st> <st c="37691">or
    external services.</st> <st c="37713">For example, a build pipeline task that
    downloads code from a private repository may require the credentials to be provided.</st>
    <st c="37838">Another task may be to download a package from a private registry
    and the necessary credentials must be supplied.</st> <st c="37952">In a deployment
    pipeline, a task may</st> *<st c="37989">need</st>* <st c="37993">the credentials
    to connect to a hosted Kubernetes cluster to deploy the latest version of</st>
    <st c="38084">an application.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38099">Note</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38104">A good security best practice is to prioritize the use of workload
    identities for access instead of secrets.</st> <st c="38214">For example, implementing
    managed identities to access Azure services.</st> <st c="38285">Secrets should
    only be used for scenarios where workload identities are not</st> <st c="38361">yet
    supported.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38375">These sensitive credentials should never be stored in plaintext
    within build or deployment pipeline workflow files.</st> <st c="38492">One possible
    option is to store the credentials as encrypted environment</st> <st c="38565">variables.</st>
    <st c="38576">These are referred to as</st> **<st c="38601">secrets</st>** <st
    c="38608">in GitHub</st> <st c="38619">Enterprise and</st> **<st c="38634">secret
    variables</st>** <st c="38650">in Azure Pipelines.</st> <st c="38671">For our
    discussion, we will just refer to them</st> <st c="38718">as</st> *<st c="38721">secrets</st>*<st
    c="38728">.</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38729">In GitHub, secrets can be set at the organization, repository,
    or repository environment levels.</st> <st c="38827">In Azure DevOps, they can
    be set at the project (using variable groups), pipeline, stage, or job levels.</st>
    <st c="38932">Organization/project-level secrets allow teams to share secrets
    across multiple workflows or pipelines.</st> <st c="39036">This reduces the need
    to create duplicate secrets across multiple repositories/pipelines.</st> <st c="39126">Secrets
    are encrypted at rest using a 2048-bit RSA key and are accessible on the agent
    for tasks and scripts</st> <st c="39235">to use.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39242">On both platforms, users with read permissions cannot read secrets,
    but those with write permissions to a repository/project can read all secrets.</st>
    <st c="39390">To reduce the risk of a secret leak, we need to be careful about
    who is granted write access to</st> <st c="39486">our repositories/projects.</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39512">In following zero-trust principles, we need to assume that breaches
    can happen and only grant the minimum necessary privileges for the secrets in
    use in workflows/pipelines.</st> <st c="39687">This approach reduces the potential
    impact in case a user with write access is compromised.</st> <st c="39779">For
    example, a secret that is used for deploying applications to a Kubernetes cluster
    should only have that specific permission.</st> <st c="39908">It should not have
    permission to modify other configurations in</st> <st c="39972">the cluster.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39984">Both GitHub Actions and Azure Pipelines try to mask secrets in
    log outputs (</st>*<st c="40061">Figure 7</st>**<st c="40070">.23</st>*<st c="40073">).</st>
    <st c="40077">They look for secrets that are printed in plain text on the command
    line, as well as exact</st> <st c="40168">matches of secret values in</st> <st
    c="40196">the logged outputs.</st> <st c="40216">However, this process is not
    perfect.</st> <st c="40254">Developers must still exercise caution to prevent</st>
    <st c="40304">accidental exposure.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – A masked secret in an Azure Pipeline log](img/B19710_07_23.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: <st c="40819">Figure 7.23 – A masked secret in an Azure Pipeline log</st>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="40873">For example, it is not recommended to define a secret value using
    a structured data format such as JSON, XML, or YAML.</st> <st c="40993">This could
    lead to redaction failures.</st> <st c="41032">An example of this is if a secret
    value is defined as</st> `<st c="41086">{"apikey": "secretpass"}</st>`<st c="41110">;
    if the exact value is printed to the console in plain text, it may not be masked
    (</st>*<st c="41195">Figure 7</st>**<st c="41204">.24</st>*<st c="41207">).</st>
    <st c="41211">Instead, developers should create individual plain secrets for each
    sensitive value instead of mapping them in a structured data format, to ensure
    they are properly masked</st> <st c="41383">in logs.</st>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 – An example of an unmasked secret due to the structured data
    format](img/B19710_07_24.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: <st c="42036">Figure 7.24 – An example of an unmasked secret due to the structured
    data format</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42116">Also, if a secret is used to generate a sensitive value within
    a workflow/pipeline, that generated</st> <st c="42216">value should be registered
    as a secret to</st> <st c="42258">ensure it is masked if it appears in the logs.</st>
    <st c="42305">For example, a private key may be used to generate a signed</st>
    **<st c="42365">JSON Web Token</st>** <st c="42379">(</st>**<st c="42381">JWT</st>**<st
    c="42384">) to access</st> <st c="42397">a web API.</st> <st c="42408">That JWT
    should be registered as a secret, or it will not be masked if it is recorded in
    the workflow/pipeline log output.</st> <st c="42531">Similarly, if a secret is
    transformed in any way, such as being Base64 or URL-encoded, it should also be
    registered as a secret to ensure it will be masked if it appears in</st> <st c="42704">log
    outputs.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42716">Integrating a secret vault in your DevOps pipelines</st>
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="42768">Apart from implementing secrets in our workflows/pipelines, we
    could also implement processes to</st> <st c="42866">centrally manage secrets</st>
    <st c="42891">using a secret management service such as Azure Key Vault or HashiCorp
    Vault.</st> <st c="42969">This is the preferred option as it has the added advantage
    of scalability, and it allows for the decoupling of secret management from the
    DevOps platform.</st> <st c="43124">As we mentioned previously, a better approach
    is to transition to using workload identities if supported for</st> <st c="43233">your
    scenario.</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43247">Azure Key Vault is a secrets management service, a key management
    service, and a certificate management service.</st> <st c="43361">A</st> **<st
    c="43363">secret</st>** <st c="43369">is data under 25 KB (for standard vaults)
    that can be stored and retrieved in plain text.</st> <st c="43460">Examples include
    passwords, database connection strings, and storage account connection strings.</st>
    **<st c="43557">Keys</st>** <st c="43561">are cryptographic keys (i.e., secrets
    generated using an algorithm) that can be imported or generated in the vault.</st>
    <st c="43678">Key Vault currently supports RSA and elliptic curve keys.</st> **<st
    c="43736">Certificates</st>** <st c="43748">are self-signed</st> <st c="43765">SSL/TLS
    certificates generated</st> <st c="43796">in Key Vault or third-party SSL/TLS
    certificates that have been imported into the vault.</st> *<st c="43885">Figure
    7</st>**<st c="43893">.25</st>* <st c="43896">shows example use cases of these
    three</st> <st c="43936">object types.</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Sample Azure Key Vault use cases](img/B19710_07_25.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: <st c="44434">Figure 7.25 – Sample Azure Key Vault use cases</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44480">To integrate the Azure Key Vault into our GitHub Action workflows,
    we can implement the</st> `<st c="44569">azure/get-keyvault-secrets</st>` <st
    c="44595">action that is authenticated with a workload identity or a service principal.</st>
    <st c="44674">In an Azure DevOps pipeline, this integration can be done with the</st>
    `<st c="44741">AzureKeyVault</st>` <st c="44754">task that uses a service connection
    that is backed by a managed identity or a service principal (</st>*<st c="44852">Figure
    7</st>**<st c="44861">.26</st>*<st c="44864">).</st> <st c="44868">For both options,
    we want to make sure that the access is scoped to the secret that is needed.</st>
    <st c="44963">This requires a least privileged</st> <st c="44996">access design.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26 – Sample Azure DevOps integration with Key Vault](img/B19710_07_26.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: <st c="45211">Figure 7.26 – Sample Azure DevOps integration with Key Vault</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45271">Now, let us</st> <st c="45284">review another best practice</st>
    <st c="45313">regarding securing our build/release environment –</st> <st c="45364">implementing
    auditing.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45386">Implementing auditing for the CI/CD environment</st>
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="45434">The CIS framework also recommends enabling logging in the build/release
    environment.</st> <st c="45520">This is</st> <st c="45528">critical for security</st>
    <st c="45550">monitoring, threat detection, and forensic analysis in the case
    of an incident.</st> <st c="45630">Ideally, logging should be enabled on both
    the control plane, for management operations, and the</st> <st c="45727">data
    plane.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45738">Enabling and configuring control plane logging</st>
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="45785">In</st> **<st c="45789">GitHub Enterprise Cloud</st>** <st c="45812">(</st>**<st
    c="45814">GHEC</st>**<st c="45818">), we</st> <st c="45825">don’t need</st> <st
    c="45836">to do anything to enable control plane audit</st> <st c="45881">logs.</st>
    <st c="45887">They are enabled by default.</st> <st c="45916">The logs can be</st>
    <st c="45932">viewed at the enterprise level</st> <st c="45963">via</st> **<st
    c="45967">Settings</st>** <st c="45975">|</st> **<st c="45978">Audit Log</st>**
    <st c="45987">|</st> **<st c="45990">Events</st>**<st c="45996">, or at the organization
    level through</st> **<st c="46035">Organization</st>** <st c="46047">|</st> **<st
    c="46050">Settings</st>** <st c="46058">|</st> **<st c="46061">Archive</st>**
    <st c="46068">|</st> **<st c="46071">Logs</st>** <st c="46075">|</st> **<st c="46078">Audit
    Log</st>** <st c="46087">|</st> **<st c="46090">Events</st>**<st c="46096">. By
    default, only events from the last three months are visible, but events are stored
    for up to seven months after which they</st> <st c="46224">are deleted.</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46236">The logs</st> <st c="46246">capture a range of events</st> <st
    c="46272">including workflow control plane activities categorized under</st> **<st
    c="46334">org</st>** <st c="46337">and</st> **<st c="46342">workflow</st>**<st
    c="46350">. This includes actions</st> <st c="46374">such as creation, update,
    deletion, and execution</st> <st c="46424">of workflows.</st> <st c="46438">A
    comprehensive list of the audited events is available</st> <st c="46494">here:</st>
    [<st c="46500">https://docs.github.com/en/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization</st>](https://docs.github.com/en/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization)<st
    c="46661">.</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46662">For privacy, the audit logs omit the source IP address of events.</st>
    <st c="46729">To add source IP addresses to the audit logs, the adjustment can
    be made at either the enterprise or</st> <st c="46830">organization level:</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="46849">Enterprise level</st>**<st c="46866">: Navigate through</st>
    **<st c="46886">Enterprise</st>** <st c="46896">|</st> **<st c="46899">Settings</st>**
    <st c="46907">|</st> **<st c="46910">Audit Log</st>** <st c="46919">|</st> **<st
    c="46922">Settings</st>**<st c="46930">. Activate and save the</st> **<st c="46954">Enable
    source IP</st>** **<st c="46971">disclosure</st>** <st c="46981">option.</st>'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="46989">Organization level</st>**<st c="47008">: Go to</st> **<st c="47017">Organization</st>**
    <st c="47029">|</st> **<st c="47032">Settings</st>** <st c="47040">|</st> **<st
    c="47043">Archive</st>** <st c="47050">|</st> **<st c="47053">Logs</st>** <st
    c="47057">|</st> **<st c="47060">Audit Log</st>** <st c="47069">|</st> **<st c="47072">Settings</st>**<st
    c="47080">. Activate and save the</st> **<st c="47104">Enable source IP</st>**
    **<st c="47121">disclosure</st>** <st c="47131">option.</st>'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.27 – Enabling source IP recording for audit logs](img/B19710_07_27.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: <st c="47556">Figure 7.27 – Enabling source IP recording for audit logs</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47613">To stream the logs externally, maybe to keep them for longer than
    the maximum retention period, we have the option to stream directly to Amazon
    S3, Azure Blob Storage, Google</st> <st c="47789">Cloud Storage, Splunk, and Datadog.</st>
    <st c="47825">We can</st> <st c="47832">also stream to other third-party services
    via Azure Event</st> <st c="47890">Hub.</st> <st c="47895">This can</st> <st c="47904">be
    configured at the enterprise level via</st> **<st c="47946">Settings</st>** <st
    c="47954">|</st> **<st c="47957">Audit log</st>** <st c="47966">|</st> **<st c="47969">Log
    streaming</st>** <st c="47982">|</st> **<st c="47985">Configure stream</st>**<st
    c="48001">.</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28 – Configuring audit log streaming at the enterprise level](img/B19710_07_28.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: <st c="48291">Figure 7.28 – Configuring audit log streaming at the enterprise
    level</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48360">For Azure Pipelines, control plane logging can be enabled in the
    organization settings in</st> **<st c="48451">Security</st>** <st c="48459">|</st>
    **<st c="48462">Policies</st>** <st c="48470">|</st> **<st c="48473">Security
    policies</st>** <st c="48490">|</st> **<st c="48493">Log</st>** **<st c="48497">Audit
    Events</st>**<st c="48509">.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29 – Enabling audit logging](img/B19710_07_29.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: <st c="48854">Figure 7.29 – Enabling audit logging</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48890">Once</st> <st c="48896">this setting is enabled, it records multiple
    events, including</st> <st c="48959">Azure Pipeline</st> <st c="48974">control
    plane events</st> <st c="48995">such as pipeline creation, modification, deletion,
    and</st> <st c="49050">execution.</st> <st c="49061">The full list of pipeline
    events that are audited can be found</st> <st c="49124">here:</st> [<st c="49130">https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops#pipelines</st>](https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops#pipelines)<st
    c="49240">.</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49241">Once enabled, the events can be viewed in</st> **<st c="49284">Organization
    Settings</st>** <st c="49305">|</st> **<st c="49308">General</st>** <st c="49315">|</st>
    **<st c="49318">Auditing</st>** <st c="49326">|</st> **<st c="49329">Logs</st>**<st
    c="49333">. The events are stored for 90 days, after which they</st> <st c="49387">are
    deleted.</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49399">They collect the logs in a centralized log store where we can
    keep them for longer, and we can configure audit streams in</st> **<st c="49522">Organization
    Settings</st>** <st c="49543">|</st> **<st c="49546">General</st>** <st c="49553">|</st>
    **<st c="49556">Auditing</st>** <st c="49564">|</st> **<st c="49567">Streams</st>**
    <st c="49574">|</st> **<st c="49577">New stream</st>**<st c="49587">, where we
    have the option to export the logs to Azure Monitor, Splunk, or other third-party
    solutions via Azure</st> <st c="49700">Event Grid.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30 – Azure DevOps audit stream options](img/B19710_07_30.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: <st c="49913">Figure 7.30 – Azure DevOps audit stream options</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49960">Enabling and configuring data plane logging</st>
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="50004">GHEC</st> <st c="50010">workflow run logs (build environment data
    plane logs) are also</st> <st c="50073">enabled by default and retained for 90
    days</st> <st c="50117">by default.</st> <st c="50129">The retention</st> <st
    c="50143">settings can be adjusted to a maximum of 400 days at the enterprise,
    organization, or</st> <st c="50229">repository levels:</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="50247">Enterprise level</st>**<st c="50264">: Navigate through</st>
    **<st c="50284">Enterprise</st>** <st c="50294">|</st> **<st c="50297">Settings</st>**
    <st c="50305">|</st> **<st c="50308">Policies</st>** <st c="50316">|</st> **<st
    c="50319">Actions</st>** <st c="50326">|</st> **<st c="50329">Artifact and log
    retention</st>**<st c="50355">. Set the retention days and</st> <st c="50384">click</st>
    **<st c="50390">Save</st>**<st c="50394">.</st>'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="50395">Organization level</st>**<st c="50414">: Go to</st> **<st c="50423">Organization</st>**
    <st c="50435">|</st> **<st c="50438">Settings</st>** <st c="50446">|</st> **<st
    c="50449">Code, planning, and automation</st>** <st c="50479">|</st> **<st c="50482">Artifact
    and log retention</st>**<st c="50508">. Set the retention days and</st> <st c="50537">click</st>
    **<st c="50543">Save</st>**<st c="50547">.</st>'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="50548">Repository level</st>**<st c="50565">: Go to</st> **<st c="50574">Repository</st>**
    <st c="50584">|</st> **<st c="50587">Settings</st>** <st c="50595">|</st> **<st
    c="50598">Code and automation</st>** <st c="50617">|</st> **<st c="50620">Actions</st>**
    <st c="50627">|</st> **<st c="50630">General</st>** <st c="50637">|</st> **<st
    c="50640">Artifact and log retention</st>**<st c="50666">. Set the retention days
    and</st> <st c="50695">click</st> **<st c="50701">Save</st>**<st c="50705">.</st>'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.31 – Configuring workflow log retention policy in GitHub](img/B19710_07_31.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
- en: <st c="50980">Figure 7.31 – Configuring workflow log retention policy in GitHub</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51045">Azure</st> <st c="51052">Pipelines build logs are also enabled
    by default and retained</st> <st c="51114">for 30 days by default.</st> <st c="51138">The</st>
    <st c="51142">retention settings</st> <st c="51161">can be adjusted via</st> **<st
    c="51181">Project Settings</st>** <st c="51197">|</st> **<st c="51200">Pipelines</st>**
    <st c="51209">|</st> **<st c="51212">Settings</st>** <st c="51220">|</st> **<st
    c="51223">Retention policy</st>** <st c="51239">|</st> **<st c="51242">Days to</st>**
    **<st c="51250">keep runs</st>**<st c="51259">.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.32 – Configuring retention policy in Azure DevOps project settings](img/B19710_07_32.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: <st c="51593">Figure 7.32 – Configuring retention policy in Azure DevOps project
    settings</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51668">Let’s now learn about</st> <st c="51691">security gates.</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51706">Implementing security gates in release pipelines</st>
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="51755">Gates are</st> <st c="51766">important components</st> <st c="51787">of
    software release pipelines.</st> <st c="51818">They act as quality checkpoints
    that software must pass before moving to the next stage of deployment.</st> <st
    c="51921">Their main objective use case is to reduce the likelihood of deploying
    poor quality software that fails to meet agreed performance and</st> <st c="52056">quality
    standards.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52074">For example, a development team might deploy software or updates
    to a test environment, run automated load and functional tests using tools such
    as Azure Load Testing</st> <st c="52242">and Selenium, and review</st> <st c="52267">the
    results in</st> <st c="52282">Azure Monitor.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52296">If the</st> <st c="52304">software meets the agreed</st> **<st
    c="52330">service-level agreements</st>** <st c="52354">(</st>**<st c="52356">SLAs</st>**<st
    c="52360">), it is deployed to the next stage.</st> <st c="52398">If it does not
    meet the SLAs, the deployment stops, and the telemetry data is collected for the
    team to investigate and resolve the issues (</st>*<st c="52538">Figure 7</st>**<st
    c="52547">.33</st>*<st c="52550">).</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.33 – Sample quality gate testing in a release pipeline](img/B19710_07_33.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: <st c="52807">Figure 7.33 – Sample quality gate testing in a release pipeline</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52870">DevSecOps extends the use of gates to include the validation of
    security (security gates) – see</st> *<st c="52967">Figure 7</st>**<st c="52975">.34</st>*<st
    c="52978">. The goal of a security gate is to prevent the most critical software
    risks from being deployed to production or other environments with higher</st>
    <st c="53123">exploitation risks.</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34 – Sample security gate testing in a release pipeline](img/B19710_07_34.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: <st c="53432">Figure 7.34 – Sample security gate testing in a release pipeline</st>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53496">Security gates</st> <st c="53512">in release pipelines vary based
    on project needs.</st> **<st c="53562">Dynamic application security testing</st>**
    <st c="53598">(</st>**<st c="53600">DAST</st>**<st c="53604">) gates use tools
    such as OWASP ZAP, Burp Suite, and Acunetix to test running applications in a
    pre-production environment.</st> <st c="53729">These tools check for issues such
    as API security, SSL/TLS configuration, and</st> <st c="53807">authentication.</st>
    **<st c="53823">Compliance gates</st>** <st c="53839">ensure regulatory</st> <st
    c="53858">standards are met, while</st> **<st c="53883">penetration testing gates</st>**
    <st c="53908">simulate cyberattacks to</st> <st c="53934">find vulnerabilities.</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53955">Effective security gates require balancing thorough security checks
    while maintaining development speed.</st> <st c="54061">Start with the most critical
    checks that offer the most value and expand gradually.</st> <st c="54145">To determine
    the most critical checks, begin with the major issues currently seen in production
    and implement checks to prevent these from reaching production.</st> <st c="54305">Continuously
    refine your process based on feedback and evolving</st> <st c="54369">security
    threats.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54386">Regarding maintaining development speed, security gates should
    be automated as much as possible to avoid slowing down the software release process.</st>
    <st c="54535">If security gates are used to stop non-compliant software from being
    deployed to production, it is recommended to implement a well-governed manual
    override process.</st> <st c="54700">This should require a minimum of two manual
    approvers to prevent it from being abused as a security bypass and to ensure that
    only business-accepted risks are</st> <st c="54859">allowed through.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54875">Implementing DAST as security gates</st>
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="54911">Unlike the</st> <st c="54923">security assessments covered in
    previous chapters, DAST identifies security issues while an application is running.</st>
    <st c="55039">It is a great</st> <st c="55053">complement to</st> **<st c="55067">static
    application security testing</st>** <st c="55102">(</st>**<st c="55104">SAST</st>**<st
    c="55108">) and SCA assessments as it can detect runtime issues that may not be
    apparent in the code alone.</st> <st c="55207">It does this by simulating attacks
    against a running application.</st> <st c="55273">For example, a DAST tool may
    crawl a running web application</st> <st c="55334">and send malformed inputs to
    identify issues such as SQL injection,</st> **<st c="55402">cross-site scripting</st>**
    <st c="55422">(</st>**<st c="55424">XSS</st>**<st c="55427">), and insecure direct</st>
    <st c="55451">object references.</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55469">Integrating DAST into a project that follows a DevOps process
    in a way that does not impact users requires an understanding of the deployment
    strategy and collaborating with the pipeline development teams.</st> <st c="55676">The
    deployment strategy influences the types of tests and the approach to implementing
    them.</st> <st c="55769">For example, the traditional application deployment strategy
    involves releasing it into a</st> *<st c="55859">test</st>* <st c="55863">environment,
    and then into a</st> *<st c="55893">staging</st>* <st c="55900">environment before
    going to</st> *<st c="55929">production</st>*<st c="55939">. Test and staging
    deployments are ideal points for integrating a continuous</st> <st c="56016">DAST
    process.</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56029">There are</st> <st c="56040">modern deployment strategies embraced
    by DevOps teams that allow for more frequent deployments to production and sometimes
    even testing in production.</st> <st c="56191">Strategies such as deployment rings,
    Canary releases,</st> **<st c="56245">dark launching</st>**<st c="56259">, and
    A/B</st> <st c="56269">testing fall into this category.</st> <st c="56302">The
    main thing to keep in mind when integrating DAST with these strategies is that
    tests should be conducted in a production-like but non-production environment
    to ensure accurate results while protecting the data in the</st> <st c="56523">production
    environment.</st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56546">Challenges of implementing DAST in a DevOps process</st>
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="56598">The effectiveness of a DAST tool is tied to the types of tests
    it can perform automatically.</st> <st c="56692">This may sound simple, but there
    are many nuances.</st> <st c="56743">For example, the tests for</st> <st c="56770">a
    web application differ</st> <st c="56795">from those for an API application, which
    in turn differ from those for a generative AI app implementing a</st> **<st c="56901">retrieval-augmented
    generation</st>** <st c="56931">(</st>**<st c="56933">RAG</st>**<st c="56936">)
    workflow.</st> <st c="56949">If a DAST tool only supports attacks</st> <st c="56986">against
    web and API applications, it may not add much value for other types of applications.</st>
    <st c="57079">Don’t integrate DAST just for the sake of integration.</st> <st
    c="57134">The value must be clearly defined, as there is a velocity cost.</st>
    <st c="57198">Ensure that the benefits of DAST outweigh the impact on development
    speed and efficiency.</st> <st c="57288">Properly assess the specific security
    needs and potential vulnerabilities of the application to determine whether DAST
    integration</st> <st c="57419">is worthwhile.</st>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57433">The majority of existing DAST tools focus on testing web applications.</st>
    <st c="57505">While many organizations have web-based apps, other types of applications
    may not be covered.</st> <st c="57599">Most DAST solutions test only the exposed
    HTTP and HTML interfaces of web-enabled applications.</st> <st c="57695">However,
    some</st> <st c="57709">solutions are designed specifically for non-web protocols
    and data malformation, such as</st> **<st c="57798">remote procedure</st>** **<st
    c="57815">calls</st>** <st c="57820">(</st>**<st c="57822">RPC</st>**<st c="57825">).</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57828">Another challenge is that while DAST has existed for a while,
    most tools were created for use by security teams within legacy processes.</st>
    <st c="57966">Modern DAST solutions, however, are built from the ground up for
    developers, QA, and DevOps professionals, making the tooling and its outputs more
    relatable and accessible to them.</st> <st c="58147">One of the key features of
    modern DAST solutions is the flexibility of deployment, including containerized
    or agent-based scanners and options for both cloud and</st> <st c="58309">self-hosted
    reporting.</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58331">Remediation is another area of challenge.</st> <st c="58374">Remediation
    guidance from DAST tools may not be contextual.</st> <st c="58434">For example,
    a DAST tool may identify a SQL injection vulnerability in a running application,
    but it may not be able to identify the line of code that developers need to</st>
    <st c="58604">change to fix the issue.</st> <st c="58629">This is where another
    tooling category,</st> **<st c="58669">interactive application security testing</st>**
    <st c="58709">(</st>**<st c="58711">IAST</st>**<st c="58715">), can help.</st>
    <st c="58729">IAST combines the security functions of SAST and DAST into one tool
    and provides more actionable insights</st> <st c="58835">for developers.</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58850">Even</st> <st c="58856">though both IAST and DAST</st> <st c="58882">focus
    on application behavior during runtime, IAST offers a more comprehensive analysis
    by combining internal application flow analysis, scanning, and black-box testing.</st>
    <st c="59052">This enables IAST to link findings similar to those in DAST directly
    to the source code.</st> <st c="59141">It achieves this by analyzing the code
    executed in tests and pinpointing the exact location of vulnerabilities in the
    code.</st> <st c="59265">However, as a relatively new approach to application
    security, IAST has its drawbacks.</st> <st c="59352">It is dependent on the programming
    language and can slow down the</st> <st c="59418">CI pipeline.</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59430">Implementing security gates in Azure Pipelines and GitHub Actions</st>
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="59496">In Azure Pipelines, release strategies are set up as</st> **<st
    c="59550">stages</st>** <st c="59556">in a release pipeline.</st> <st c="59580">For
    classic</st> <st c="59592">pipelines, quality gates are defined</st> <st c="59629">using
    pre-deployment</st> <st c="59650">and post-deployment</st> <st c="59670">conditions
    for each</st> <st c="59690">stage.</st> **<st c="59697">Pre-deployment conditions</st>**
    <st c="59722">are checks and validations that must be satisfied before a deployment
    stage can start.</st> <st c="59810">They serve as</st> <st c="59824">gatekeepers
    to ensure that quality criteria are met before the deployment begins.</st> **<st
    c="59906">Post-deployment conditions</st>** <st c="59932">are checks that happen
    after a deployment has completed and before it proceeds to the next stage.</st>
    <st c="60031">They are used to verify that the deployment did not introduce any
    new issues and that the application is functioning correctly.</st> <st c="60159">To
    implement them, follow</st> <st c="60185">these steps:</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60197">In Azure Pipelines, navigate to</st> **<st c="60230">Pipelines</st>**
    <st c="60239">|</st> **<st c="60242">Releases</st>**<st c="60250">.</st>
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="60251">Select the relevant</st> <st c="60272">release pipeline.</st>
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="60289">Choose either pre-deployment or post-deployment conditions for
    the release stage (</st>*<st c="60372">Figure 7</st>**<st c="60381">.35</st>*<st
    c="60384">).</st>
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="60387">Under</st> **<st c="60394">Gates</st>**<st c="60399">, click</st>
    **<st c="60407">Add</st>** <st c="60410">to configure your release</st> <st c="60437">gate
    settings.</st>
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.35 – Configuring pre-deployment or post-deployment conditions](img/B19710_07_35.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: <st c="61390">Figure 7.35 – Configuring pre-deployment or post-deployment conditions</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61460">GitHub</st> <st c="61468">Actions offers a similar functionality</st>
    <st c="61507">with environments, which</st> <st c="61532">can have protection
    rules</st> <st c="61558">that serve as release gates.</st> <st c="61587">For instance,
    a workflow in GitHub can include a job that must be manually approved by designated
    reviewers before the deployment can proceed to the next environment.</st> <st
    c="61754">This is particularly useful for workflows that deploy to multiple stages,
    such as staging and production.</st> <st c="61860">Each stage can have its own
    set of rules that are enforced by these gates.</st> <st c="61935">To read more
    about environments and protection rules, please refer to this</st> <st c="62010">document:</st>
    [<st c="62020">https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#custom-deployment-protection-rules</st>](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#custom-deployment-protection-rules)<st
    c="62167">.</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62168">Hands-on exercise – Integrating security within the build and
    test phases</st>
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="62242">In this</st> <st c="62251">exercise, we will be integrating security</st>
    <st c="62293">within the build and test phases of our pipeline.</st> <st c="62343">We
    will practically implement artifact signing for integrity and implement DAST</st>
    <st c="62423">using ZAP.</st>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62433">The following are the tasks for</st> <st c="62466">this exercise:</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="62480">Task</st>** **<st c="62486">1 –</st>** <st c="62489">Implementing
    artifact signing for</st> <st c="62524">integrity checks</st>'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="62540">Task</st>** **<st c="62546">2 –</st>** <st c="62549">Integrating
    DAST tools to find and fix security vulnerabilities in the</st> <st c="62621">test</st>
    <st c="62625">phase</st>'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="62631">Prerequisites</st>
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="62645">Before diving</st> <st c="62660">into the first task, let’s first
    create a key vault in Azure Key Vault then generate a self-signed key and certificate.</st>
    <st c="62780">This is what we will use later to sign the image</st> <st c="62829">with
    Notation.</st>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62843">Navigate to your Azure portal</st> <st c="62874">at</st> [<st
    c="62877">https://portal.azure.com</st>](https://portal.azure.com)<st c="62901">.</st>
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="62902">Search for</st> `<st c="62914">key vaults</st>` <st c="62924">in
    the search bar and select</st> **<st c="62954">Key vaults</st>**<st c="62964">.</st>
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.36 – Search and select Key vaults](img/B19710_07_36.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: <st c="63210">Figure 7.36 – Search and select Key vaults</st>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63252">Click on</st> **<st c="63262">Create</st>** <st c="63268">and
    fill in the required details, click</st> **<st c="63309">Review + create</st>**<st
    c="63324">, and then</st> <st c="63335">click</st> **<st c="63341">Create</st>**<st
    c="63347">.</st>
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.37 – Create a key vault](img/B19710_07_37.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: <st c="65266">Figure 7.37 – Create a key vault</st>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65298">Now that we’ve created the key vault, let’s now create a self-signed
    certificate using Azure CLI.</st> <st c="65397">First, create a certificate policy
    file which, when executed, creates a</st> <st c="65469">valid certificate compatible
    with Notation.</st> <st c="65513">Copy the following code into Azure CLI bash
    terminal to create the policy file.</st> <st c="65593">Copy this</st> <st c="65603">from</st>
    [<st c="65608">https://github.com/PacktPublishing/eShopOnWeb/blob/main/policy.txt</st>](https://github.com/PacktPublishing/eShopOnWeb/blob/main/policy.txt)<st
    c="65674">.</st>
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.38 – Content of certificate policy file](img/B19710_07_38.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: <st c="66078">Figure 7.38 – Content of certificate policy file</st>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66126">Create the certificate by pasting the following command to your</st>
    <st c="66191">Bash terminal</st><st c="66204">:</st>
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="66302">Remember to</st> <st c="66315">change the key vault name to the
    one created in</st> *<st c="66363">step 3</st>*<st c="66369">.</st> *<st c="66371">Figure
    7</st>**<st c="66379">.39</st>* <st c="66382">shows the successful creation of
    a</st> <st c="66418">self-signed certificate.</st>
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.39 – Create a self-signed certificate](img/B19710_07_39.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: <st c="67677">Figure 7.39 – Create a self-signed certificate</st>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67723">Let’s confirm the certificate was created by going to your key
    vault then navigate to</st> **<st c="67810">Objects</st>** <st c="67817">and then
    click on</st> **<st c="67836">Certificates</st>**<st c="67848">. You will find
    the just created</st> <st c="67881">certificate here.</st>
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.40 – Self-signed certificate (test-io) created](img/B19710_07_40.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: <st c="68347">Figure 7.40 – Self-signed certificate (test-io) created</st>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68402">In</st> [*<st c="68406">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122)<st
    c="68415">, hands on</st> *<st c="68426">Exercise 1 – Integrating SAST, SCA, and
    secret scanning into the build process</st>* <st c="68504">section, we ran</st>
    `<st c="68521">azure-pipelines.yml</st>` <st c="68540">which built and deployed
    the docker image.</st> <st c="68584">Several resources were created including
    a</st> <st c="68627">container registry.</st> <st c="68647">Several access permissions
    need to be set before configuring the notation task to sign the</st> <st c="68738">image
    created.</st>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68752">Let’s first</st> <st c="68765">authorize access to the</st> `<st
    c="68907">AcrPull</st>` <st c="68914">and</st> `<st c="68919">AcrPush</st>`<st
    c="68926">. Let’s configure ACR and AKV environment variables on Azure CLI</st>
    <st c="68991">Bash terminal.</st>
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="69154">Authorize access to ACR by first setting the subscription that
    contains the</st> <st c="69231">ACR resource.</st>
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="69413">and</st>
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="69616">Let’s now authorize access to AKV where the following roles are
    required for signing using</st> <st c="69708">self-signed certificates:</st>
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="69733">Key Vault Certificates Officer</st>** <st c="69764">for creating
    and</st> <st c="69782">reading certificates</st>'
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="69802">Key Vault Certificates User</st>** <st c="69830">for reading</st>
    <st c="69843">existing certificates</st>'
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="69864">Key Vault Crypto User</st>** <st c="69886">for</st> <st c="69891">signing
    operations</st>'
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="69909">First set the subscription that contains the AKV resource using</st>
    <st c="69974">the command:</st>
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="70134">and</st>
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="70361">Now let’s</st> <st c="70372">create the Docker Registry service
    connection.</st> <st c="70419">To sign the images using notation, we will use
    the Docker task in Azure Pipelines to log into the ACR.</st> <st c="70522">This
    task allows you to build, push and pull</st> <st c="70567">Docker images.</st>
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="70581">Navigate to</st> **<st c="70594">Project Settings</st>** <st c="70610">and
    then</st> **<st c="70620">Service connections</st>**<st c="70639">.</st>
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.41 – Setting service connections](img/B19710_07_41.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
- en: <st c="70975">Figure 7.41 – Setting service connections</st>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71016">Choose</st> **<st c="71024">New service connection</st>** <st
    c="71046">and select</st> **<st c="71058">Docker Registry</st>**<st c="71073">.</st>
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="71074">Next choose</st> **<st c="71087">Azure</st>** **<st c="71093">Container
    Registry</st>**<st c="71111">.</st>
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="71112">Select</st> **<st c="71120">Service Principal</st>** <st c="71137">in
    the</st> **<st c="71145">Authentication Type</st>** <st c="71164">field and enter
    the service</st> <st c="71193">principal details including your Azure Subscription
    and</st> <st c="71249">ACR registry.</st>
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="71262">Enter the</st> **<st c="71273">Service connection name</st>**
    <st c="71296">to use when referring to this service connection as shown in the</st>
    <st c="71362">following figure:</st>
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.42 – Setting Docker Registry service connection](img/B19710_07_42.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: <st c="71743">Figure 7.42 – Setting Docker Registry service connection</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71799">The last</st> <st c="71809">bit of access needed is to grant Azure
    Key Vault access policy to your</st> <st c="71880">service principal.</st>
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="71898">Open the Azure Resource Manager service connection you created
    and click on</st> **<st c="71975">Manage Service Principal</st>** <st c="71999">to
    access the Azure service</st> <st c="72028">principal portal.</st>
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="72045">Copy the</st> **<st c="72055">Application (client) ID</st>**<st
    c="72078">. This ID will be used to grant permissions to the</st> <st c="72129">service
    principal.</st>
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="72147">Navigate to the</st> **<st c="72164">Azure Key Vault</st>** <st
    c="72179">portal and go to the</st> **<st c="72201">Access</st>** **<st c="72208">Policies</st>**
    <st c="72216">page.</st>
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<st c="72222">Create a new access policy with the following permissions: key
    sign, secret get, and</st> <st c="72308">certificate get.</st>'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="72324">Assign this</st> <st c="72337">new access policy to a service
    principal using the</st> **<st c="72388">Application (client) ID</st>** <st c="72412">you</st>
    <st c="72416">copied earlier.</st>
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="72431">Save the changes to complete</st> <st c="72461">the setup.</st>
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="72471">Now that we've met the prerequisites, we can begin with</st> <st
    c="72528">the tasks.</st>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72538">Task 1 – Implementing artifact signing for integrity checks</st>
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="72598">In this task, we will be signing our artifacts using Notation
    to enforce authenticity and integrity</st> <st c="72699">validation for all release
    artifacts, including container images, by adding a digital signature</st> <st
    c="72795">that will be validated during</st> <st c="72825">deployment.</st> <st
    c="72837">The signature is used to verify that the artifact is from a trusted
    publisher and no modification has been made.</st> <st c="72950">This prevents
    tampering of packages and artifacts meant for production like in the CodeCov incident
    we</st> <st c="73053">covered earlier.</st>
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73069">Let’s implement artifact signing</st> <st c="73103">using Notation:</st>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73118">Navigate to your DevOps instance at</st> [<st c="73155">https://dev.azure.com</st>](https://dev.azure.com)
    <st c="73176">and choose the organization you used in the</st> <st c="73221">previous
    chapter.</st>
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="73238">Select the</st> **<st c="73250">eShopOnWeb</st>** <st c="73260">private
    project we were using in the</st> <st c="73298">previous chapter.</st>
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="73315">Azure DevOps has a</st> `<st c="73496">azure-pipelines.yml</st>`<st
    c="73516">).</st> <st c="73520">Click on the pipeline editing panel and search</st>
    <st c="73567">for</st> `<st c="73571">notation</st>`<st c="73579">.</st>
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.43 – Notation marketplace task on Azure DevOps pipeline](img/B19710_07_43.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: <st c="73652">Figure 7.43 – Notation marketplace task on Azure DevOps pipeline</st>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73716">Click on</st> <st c="73726">the</st> **<st c="73730">Notation</st>**
    <st c="73738">task and select</st> **<st c="73755">Install</st>** <st c="73762">under</st>
    **<st c="73769">Command to run</st>**<st c="73783">. Then, click</st> <st c="73797">the</st>
    **<st c="73801">Add</st>** <st c="73804">button.</st> <st c="73813">This will</st>
    <st c="73823">add the task for installing Notation to your pipeline as shown in
    the</st> <st c="73893">following figure:</st>
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.44 – Notation Install task on Azure DevOps pipeline](img/B19710_07_44.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: <st c="74016">Figure 7.44 – Notation Install task on Azure DevOps pipeline</st>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74076">Next, let’s add the Notation task for signing our artifacts.</st>
    <st c="74138">Navigate back to the pipeline editing panel and search for notation
    again.</st> <st c="74213">This time, we will select</st> **<st c="74239">Sign</st>**
    <st c="74243">under</st> **<st c="74250">Command</st>** **<st c="74258">to run</st>**<st
    c="74264">.</st>
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="74265">On the</st> `<st c="74400">crx6xa5yuubr2hm.azurecr.io/eshoponweb/web:latest</st>`<st
    c="74448">).</st>
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="74451">The Notation task in Azure Pipelines natively supports the Azure
    Key Vault plugin, which enables the Notation CLI to generate signatures using
    Azure-Key-Vault-managed certificates and keys.</st> <st c="74642">Select</st>
    **<st c="74649">Azure Key Vault Plugin</st>** <st c="74671">under</st> **<st c="74678">Plugin</st>**
    <st c="74684">and then select the service connection earlier created in the</st>
    [*<st c="74747">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122) <st c="74756">hands-on
    exercise.</st>
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="74775">For the</st> **<st c="74784">Key ID</st>** <st c="74790">section,
    add the result you get from running the following command</st> <st c="74858">on
    Azure</st> <st c="74867">Cloud Shell.</st> <st c="74880">Add the</st> <st c="74888">correct
    certificate and key</st> <st c="74916">vault names.</st>
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Figure 7.45 – Key ID value](img/B19710_07_45.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: <st c="75229">Figure 7.45 – Key ID value</st>
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75255">In this case, the Key ID</st> <st c="75281">is</st> `<st c="75284">https://devsecopskeyvaulttest.vault.azure.net/keys/test-io/0daaced86b764e37855e02740e4f2d7c</st>`<st
    c="75375">.</st>
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75376">Notation supports signing using self-signed certificates and CA-issued
    certificates.</st> <st c="75462">For this task, we will use self-signed certificates.</st>
    <st c="75515">Scroll down and check</st> **<st c="75537">Self-signed Certificate</st>**<st
    c="75560">. Then, click</st> **<st c="75574">Add</st>** <st c="75577">to add the
    sign task to</st> <st c="75602">your pipeline.</st>
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.46 – Sign Notation marketplace task on Azure DevOps pipeline](img/B19710_07_46.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: <st c="75690">Figure 7.46 – Sign Notation marketplace task on Azure DevOps pipeline</st>
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75759">Run</st> <st c="75764">the pipeline</st> <st c="75777">and check</st>
    <st c="75787">on the two tasks added.</st> <st c="75811">Upon successful execution,
    the image will be signed as shown in</st> *<st c="75875">Figure 7</st>**<st c="75883">.47</st>*<st
    c="75886">:</st>
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.47 – Notation tasks completed, and image signed.](img/B19710_07_47.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
- en: <st c="77070">Figure 7.47 – Notation tasks completed, and image signed.</st>
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77127">Let’s</st> <st c="77134">now look</st> <st c="77143">at how we
    can perform DAST</st> <st c="77170">on the application running in the</st> <st
    c="77204">test environment.</st>
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77221">Task 2 – Integrating DAST tools to find and fix security vulnerabilities
    in the test phase</st>
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="77312">This</st> <st c="77318">task aims to</st> <st c="77331">integrate
    ZAP</st> <st c="77345">to perform</st> <st c="77356">DAST.</st> <st c="77362">There
    are several other commercial and open-source DAST tools such as Acunetix, Checkmarx
    DAST, Fortify WebInspect, Insight by Rapid7, PortSwigger Burp Suite, and Veracode,
    just to mention a few.</st> <st c="77558">Many of these tools are available on
    the Azure DevOps Marketplace (</st>[<st c="77625">https://marketplace.visualstudio.com/azuredevops</st>](https://marketplace.visualstudio.com/azuredevops)<st
    c="77674">).</st> <st c="77678">It is important</st> <st c="77694">to perform
    a DAST scan because it looks at a broad range of vulnerabilities, including input
    validation that could make an application vulnerable to XSS or SQL injection.</st>
    <st c="77865">DAST is performed on an application that is running.</st> <st c="77918">It
    runs automated penetration tests on your web applications</st> <st c="77979">and
    APIs</st> <st c="77988">that are</st> <st c="77997">already</st> <st c="78005">running.</st>
    <st c="78014">It simulates real-world attacks covering the</st> *<st c="78059">OWASP
    Top</st>* *<st c="78069">10</st>* <st c="78071">(</st>[<st c="78073">https://owasp.org/www-project-top-ten/</st>](https://owasp.org/www-project-top-ten/)<st
    c="78111">).</st>
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78114">In the previous task, we ran a pipeline that built and deployed
    the</st> <st c="78183">eShopOnWeb application.</st>
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.48 – The eShopOnWeb application deployed](img/B19710_07_48.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
- en: <st c="78571">Figure 7.48 – The eShopOnWeb application deployed</st>
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78620">Let’s see how we can perform DAST scans on our running application</st>
    <st c="78688">using ZAP:</st>
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78698">OWASP ZAP is available on the Azure Marketplace.</st> <st c="78748">Navigate
    to the Azure Marketplace at</st> [<st c="78785">https://marketplace.visualstudio.com/azuredevops</st>](https://marketplace.visualstudio.com/azuredevops)<st
    c="78833">, and search for</st> `<st c="78850">OWASP ZAP Scanner</st>`<st c="78867">.
    Click on</st> **<st c="78878">Get it free</st>**<st c="78889">, select the correct
    organization to install the extension, and then go back to your project</st> <st
    c="78982">after installation.</st>
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.49 – OWASP ZAP Scanner in Azure Marketplace](img/B19710_07_49.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: <st c="79187">Figure 7.49 – OWASP ZAP Scanner in Azure Marketplace</st>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79239">We will</st> <st c="79248">add the OWASP ZAP Scanner task in a
    pipeline YAML file.</st> <st c="79304">For this</st> <st c="79313">instance, we
    will create a new pipeline for OWASP ZAP, however, you can still add the same
    tasks in the</st> <st c="79417">existing pipeline.</st>
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="79435">Navigate</st> <st c="79445">to</st> **<st c="79448">Pipelines</st>**
    <st c="79457">on</st> <st c="79461">the left, select</st> **<st c="79478">Pipelines</st>**<st
    c="79487">, and then select</st> **<st c="79505">New pipeline</st>**<st c="79517">.</st>
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="79518">Select</st> **<st c="79526">Azure Repos Git</st>** <st c="79541">and
    then</st> **<st c="79551">eShopOnWeb</st>**<st c="79561">. We will use</st> **<st
    c="79575">Starter pipeline</st>**<st c="79591">.</st>
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="79592">Delete the starter scripts, and then add the</st> **<st c="79638">OWASP
    Zap Scanner</st>** <st c="79655">task from the</st> **<st c="79670">Tasks</st>**
    <st c="79675">assistant.</st>
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.50 – OWASP ZAP Scanner in Azure Marketplace](img/B19710_07_50.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
- en: <st c="79962">Figure 7.50 – OWASP ZAP Scanner in Azure Marketplace</st>
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80014">Set</st> `<st c="80040">1500</st>` <st c="80044">and select</st>
    **<st c="80056">Targeted Scan</st>** <st c="80069">as your scan type.</st> <st
    c="80089">Input</st> <st c="80095">the URL</st> <st c="80103">for the</st> <st
    c="80111">app deployed</st> <st c="80124">on the test environment and then</st>
    <st c="80157">click</st> **<st c="80163">Add</st>**<st c="80166">.</st>
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.51 – Set the OWASP Zap Scanner configurations](img/B19710_07_51.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: <st c="80352">Figure 7.51 – Set the OWASP Zap Scanner configurations</st>
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80406">The YAML file should now look like this after adding a</st> <st
    c="80462">display name.</st>
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.52 – The OWASP Zap Scanner task](img/B19710_07_52.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
- en: <st c="80721">Figure 7.52 – The OWASP Zap Scanner task</st>
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80761">We</st> <st c="80765">need to publish the report generated by
    the OWASP ZAP Scanner</st> <st c="80827">task.</st> <st c="80833">From the</st>
    <st c="80842">assistant</st> `<st c="80878">publish build artifacts</st>`<st c="80901">.
    Leave the</st> <st c="80913">Path to publish as</st> `<st c="80932">$(Build.ArtifactStagingDirectory)</st>`
    <st c="80965">and the artifact name as</st> **<st c="80991">ZAP Reports</st>**<st
    c="81002">.</st>
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.53 – Publish build artifacts task](img/B19710_07_53.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: <st c="81447">Figure 7.53 – Publish build artifacts task</st>
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81489">Our</st> <st c="81494">YAML file</st> <st c="81504">now looks</st>
    <st c="81514">like</st> <st c="81519">the</st> <st c="81523">following:</st>
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.54 – OWASP ZAP and Publish tasks](img/B19710_07_54.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
- en: <st c="81864">Figure 7.54 – OWASP ZAP and Publish tasks</st>
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81905">The report is generated in JSON and HTML formats, which are machine
    readable, so the output can be used for further processing.</st> <st c="82034">We
    can also have the scan results published to the</st> **<st c="82085">Tests results</st>**
    <st c="82098">tab by adding the code snippets of the</st> **<st c="82138">Install
    handlebars</st>**<st c="82156">,</st> **<st c="82158">Report Generation</st>**<st
    c="82175">, and</st> **<st c="82181">Publish Report (Nunit Style)</st>** <st c="82209">code
    sections</st> <st c="82224">from</st> [<st c="82229">https://marketplace.visualstudio.com/items?itemName=CSE-DevOps.zap-scanner</st>](https://marketplace.visualstudio.com/items?itemName=CSE-DevOps.zap-scanner)<st
    c="82303">.</st>
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="82304">Once you’ve added the preceding three code snippets, update the
    file path parameter from the</st> **<st c="82398">Install handlebars</st>** <st
    c="82416">code snippet to</st> <st c="82433">the following:</st>
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="82515">Save</st> <st c="82521">and commit</st> <st c="82532">the new
    pipeline and then</st> <st c="82558">run it.</st>
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="82565">After a</st> <st c="82574">few minutes, the</st> <st c="82591">tasks
    are completed, and the scan results</st> <st c="82633">are published.</st>
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.55 – OWASP ZAP and Publish tasks successful](img/B19710_07_55.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
- en: <st c="83026">Figure 7.55 – OWASP ZAP and Publish tasks successful</st>
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83078">Let’s see</st> <st c="83089">the scan</st> <st c="83098">results
    from</st> <st c="83111">the</st> **<st c="83115">Test results</st>** <st c="83127">tab.</st>
    <st c="83133">Navigate</st> <st c="83142">to the successful pipeline run and click
    on the</st> **<st c="83190">Tests</st>** <st c="83195">tab.</st>
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.56 – The Tests results tab](img/B19710_07_56.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
- en: <st c="83527">Figure 7.56 – The Tests results tab</st>
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83562">Go through the scan results and familiarize yourself with the
    findings from</st> <st c="83639">OWASP ZAP.</st>
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83649">Summary</st>
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="83657">In this chapter, we covered several checks that should be performed
    before releasing an application to production.</st> <st c="83773">This includes
    ensuring that release artifacts are built from protected branches, implementing
    a code review process, selecting a secure artifact source, implementing a process
    to validate artifact integrity, managing secrets securely in the release phase,
    implementing IaC security scans, and validating and enforcing runtime security
    with release gates.</st> <st c="84128">We also covered runtime verification tools
    in place</st> <st c="84180">including DAST.</st>
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84195">In the next chapter, we will look at continuous security monitoring
    on Azure.</st> <st c="84274">Now that we have deployed the resources, we need
    to make sure they remain secure.</st> <st c="84356">Let’s</st> <st c="84362">dive
    in.</st>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
