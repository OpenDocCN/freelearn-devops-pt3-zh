- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infrastructure as Code (IaC) with Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud computing is one of the primary factors of DevOps enablement today. The
    initial apprehensions about the cloud are a thing of the past. With an army of
    security and compliance experts manning cloud platforms 24x7, organizations are
    now trusting the *public cloud* like never before. Along with cloud computing,
    another buzzword has taken the industry by storm – **Infrastructure as Code**
    (**IaC**). This chapter will focus on IaC with **Terraform**, and by the end of
    this chapter, you will understand the concept and have enough hands-on experience
    with Terraform to get you started on your journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to IaC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Terraform and Azure providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Terraform workflows and creating your first resource using Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform state and backends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform workspaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform outputs, state, console, and graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you can use any machine to run Terraform. Terraform supports
    many platforms, including Windows, Linux, and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: You will need an active Azure subscription to follow the exercises. Currently,
    Azure is offering a free trial for 30 days with $200 worth of free credits; you
    can sign up at [https://azure.microsoft.com/en-in/free](https://azure.microsoft.com/en-in/free).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also need to clone the following GitHub repository for some of the
    exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to clone the repository into your home directory,
    and `cd` into the `ch8` directory to access the required resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So, let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to IaC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IaC is the concept of using code to define infrastructure. While most people
    can visualize infrastructure as something tangible, virtual infrastructure is
    already commonplace and has existed for around two decades. Cloud providers provide
    a web-based console through which you can manage your infrastructure intuitively.
    But the process is not repeatable or recorded.
  prefs: []
  type: TYPE_NORMAL
- en: If you spin up a set of infrastructure components using the console in one environment
    and want to replicate it in another, it is a duplication of effort. To solve this
    problem, cloud platforms provide APIs to manipulate resources within the cloud
    and some command-line tools that can help trigger the APIs. You can start writing
    scripts using commands to create the infrastructure and parameterize them to use
    the same scripts in another environment. Well, that solves the problem, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Not really! Writing scripts is an imperative way of managing infrastructure.
    Though you can still call it IaC, its problem is that it does not effectively
    manage infrastructure changes. Let me give you a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: What would happen if you needed to modify something already in the script? Changing
    the script somewhere in the middle and rerunning the entire thing may create havoc
    with your infrastructure. Imperative management of infrastructure is not idempotent.
    So, managing changes becomes a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if someone manually changes the script-managed infrastructure using the
    console? Will your script be able to detect it correctly? What if you want to
    change the same thing using a script? It will soon start to get messy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the advent of hybrid cloud architecture, most organizations use multiple
    cloud platforms for their needs. When you are in such a situation, managing multiple
    clouds with imperative scripts soon becomes a problem. Different clouds have different
    ways of interacting with their APIs and have distinct command-line tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The solution to all these problems is a declarative IaC solution such as Terraform.
    HashiCorp’s Terraform is the most popular IaC tool available on the market. It
    helps you automate and manage your infrastructure using code and can run on various
    platforms. As it is declarative, you just need to define what you need (the desired
    end state) instead of describing how to achieve it. It has the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: It supports multiple cloud platforms via providers and exposes a single declarative
    **HashiCorp Configuration Language** (**HCL**)-based interface to interact with
    it. Therefore, it allows you to manage various cloud platforms using a similar
    language and syntax. So, having a few Terraform experts within your team can handle
    all your IaC needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It tracks the state of the resources it manages using state files and supports
    local and remote backends to store and manage them. That helps in making the Terraform
    configuration idempotent. So, if someone manually changes a Terraform-managed
    resource, Terraform can detect the difference in the next run and prompt corrective
    action to bring it to the defined configuration. The admin can then absorb the
    change or resolve any conflicts before applying it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enables GitOps in infrastructure management. With Terraform, you can have
    the infrastructure configuration alongside application code, making versioning,
    managing, and releasing infrastructure the same as managing code. You can also
    include code scanning and gating using pull requests so that someone can review
    and approve the changes to higher environments before you apply them. A great
    power indeed!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform has multiple offerings – **open source**, **cloud**, and **enterprise**.
    The open source offering is a simple **command-line interface** (**CLI**)-based
    tool that you can download on any supported **operating system** (**OS**) and
    use. The cloud and enterprise offerings are more of a wrapper on top of the open
    source one. They provide a web-based GUI and advanced features such as **policy
    as code** with **Sentinel**, **cost analysis**, **private modules**, **GitOps**,
    and **CI/CD pipelines**.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will discuss the open source offering and its core functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform open source is divided into two main parts – **Terraform Core** and
    **Terraform providers**, as seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Terraform architecture](img/B19877_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Terraform architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the functions of both components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Terraform Core** is the CLI that we will use to interact with Terraform.
    It takes two main inputs – your Terraform configuration files and the existing
    state. It then takes the difference in configuration and applies it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terraform providers** are plugins that Terraform uses to interact with cloud
    providers. The providers translate the Terraform configuration into the respective
    cloud’s REST API calls so that Terraform can manage its associated infrastructure.
    For example, if you want Terraform to manage AWS infrastructure, you must use
    the Terraform AWS provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now let’s see how we can install open source Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing Terraform is simple; go to [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)
    and follow the instructions for your platform. Most of it will require you to
    download a binary and move it to your system path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ve been using Ubuntu throughout this book, I will show the installation
    on Ubuntu. Use the following commands to use the `apt` package manager to install
    Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether Terraform has been installed successfully with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It shows that Terraform has been installed successfully. Terraform uses Terraform
    providers to interact with cloud providers, so let’s look at those in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform has a decentralized architecture. While the Terraform CLI contains
    Terraform’s core functionality and provides all functionalities not related to
    any specific cloud provider, Terraform providers provide the interface between
    the Terraform CLI and the cloud providers themselves. This decentralized approach
    has allowed public cloud vendors to offer their Terraform providers so that their
    customers can use Terraform to manage infrastructure in their cloud. Such is Terraform’s
    popularity that it has now become an essential requirement for every public cloud
    provider to offer a Terraform provider.
  prefs: []
  type: TYPE_NORMAL
- en: We will interact with Azure for this chapter’s entirety and use the Azure Terraform
    provider for our activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the resources for this section, `cd` into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Before we go ahead and configure the provider, we need to understand how Terraform
    needs to authenticate and authorize with the Azure APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization with Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to authenticate and authorize with Azure is to log in to your
    account using the Azure CLI. When you use the Azure provider within your Terraform
    file, it will automatically act as your account and do whatever it needs to. Now,
    this sounds dangerous. Admins generally have a lot of access, and having a tool
    that acts as an admin might not be a great idea. What if you want to plug Terraform
    into your CI/CD pipelines? Well, there is another way to do it – by using **Azure
    service principals**. Azure service principals allow you to access the required
    features without using a named user account. You can then apply the **principle
    of least privilege** to the service principal and provide only the necessary access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before configuring the service principal, let’s install the Azure CLI on our
    machine. To do so, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will download a shell script and execute it using `bash`.
    The script will then automatically download and configure the Azure CLI. To confirm
    whether the Azure CLI is installed successfully, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We see that the Azure CLI is correctly installed on the system. Now, let’s go
    ahead and configure the service principal.
  prefs: []
  type: TYPE_NORMAL
- en: To configure the Azure service principal, follow these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in to Azure using the following command and follow all the steps the command
    prompts. You must browse to a specified URL and enter the given code. Once you’ve
    logged in, you will get a JSON response that will include some details, something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Make a note of the `id` attribute, which is the subscription ID, and if you
    have more than one subscription, you can use the following to set it to the correct
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Use the following command to create a `contributor` role to allow Terraform
    to manage the subscription’s infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Follow the principle of least privilege while granting access to the service
    principal. Do not give privileges thinking you might need them in the future.
    If any future access is required, you can grant it later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `contributor` access for simplicity, but finer-grained access is possible
    and should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ve successfully created the `appId`, `password`, and `tenant`. We will need
    these to configure Terraform to use the service principal. In the next section,
    let’s define the Azure Terraform provider with the details.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Azure Terraform provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we define the Azure Terraform provider, let’s understand what makes a
    Terraform root module. The Terraform root module is just a working directory within
    your filesystem containing one or more `.tf` files that help you define your configuration
    and are where you would typically run your Terraform commands.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform scans all your `.tf` files, combines them, and processes them internally
    as one. Therefore, you can have one or more `.tf` files that you can split according
    to your needs. While there are no defined standards for naming `.tf` files, most
    conventions use `main.tf` as the main Terraform file where they define resources,
    a `vars.tf` file for defining variables, and `outputs.tf` for defining outputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this discussion, let’s create a `main.tf` file within our working directory
    and add a `provider` configuration like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding file contains two blocks. The `terraform` block contains the `required_providers`
    block, which declares the `version` constraint for the `azurerm` provider. The
    `provider` block declares an `azurerm` provider, which requires four parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always constrain the provider version, as providers are released without notice,
    and if you don’t include the version number, something that works on your machine
    might not work on someone else’s machine or the CI/CD pipeline. Using a version
    constraint avoids breaking changes and keeps you in control.
  prefs: []
  type: TYPE_NORMAL
- en: You might have noticed that we have declared several variables within the preceding
    file instead of directly inputting the values. There are two main reasons for
    that – we want to make our template as generic as possible to promote reuse. So,
    suppose we want to apply a similar configuration in another subscription or use
    another service principal; we should be able to change it by changing the variable
    values. Secondly, we don’t want to check `client_id` and `client_secret` in source
    control. It is a bad practice as we expose our service principal to users beyond
    those who need to know about it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Never store sensitive data in source control. Instead, use a `tfvars` file to
    manage sensitive information and keep it in a secret management system such as
    HashiCorp’s Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so as we’ve defined the provider resource and the attribute values are
    sourced from variables, the next step would be to declare variables. Let’s have
    a look at that now.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To declare variables, we will need to create a `vars.tf` file with the following
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, we’ve defined four variables here using `variable` blocks. Variable blocks
    typically have a `type` and a `description`. The `type` attribute defines the
    data type of the variable we declare and defaults to the `string` data type. It
    can be a primitive data type such as `string`, `number`, or `bool`, or a complex
    data structure such as `list`, `set`, `map`, `object`, or `tuple`. We will look
    at types in detail when we use them later in the exercises. The `description`
    attribute provides more information regarding the variable so users can refer
    to it for better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always set the `description` attribute right from the beginning, as it is user-friendly
    and promotes the reuse of your template.
  prefs: []
  type: TYPE_NORMAL
- en: The `client_secret` variable also contains a third attribute called `sensitive`,
    a Boolean attribute set to `true`. When the `sensitive` attribute is `true`, the
    Terraform CLI does not display it in the screen’s output. This attribute is highly
    recommended for sensitive variables such as passwords and secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always declare a sensitive variable as `sensitive`. This is because if you use
    Terraform within your CI/CD pipelines, unprivileged users might access sensitive
    information by looking at the logs.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the other three, an attribute called `default` will help you specify
    default variable values. The default values help you provide the best possible
    value for a variable, which your users can override if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always use default values where possible, as they allow you to provide users
    with soft guidance about your enterprise standard and save them time.
  prefs: []
  type: TYPE_NORMAL
- en: The next step would be to provide variable values. Let’s have a look at that.
  prefs: []
  type: TYPE_NORMAL
- en: Providing variable values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a few ways to provide variable values within Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-var``-var` flags with the `variable_name=variable_value` string to supply
    the values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.tfvars``.tfvars` (if you prefer HCL) or `.tfvars.json` (if you prefer JSON)
    via the command line with the `-``var-file` flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terraform.tfvars` or end it with an extension of `.auto.tfvars` within the
    Terraform workspace. Terraform will automatically scan these files and take the
    values from there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TF_VAR_<var-name>` structure containing the variable value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default**: When you run a Terraform plan without providing values to variables
    in any other way, the Terraform CLI will prompt for the values, and you must manually
    enter them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If multiple methods are used to provide the same variable’s value, the first
    method in the preceding list has the highest precedence for a specific variable.
    It overrides anything that is defined in the methods listed later.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `terraform.tfvars` file for this activity and provide the values
    for the variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following data to the `terraform.tfvars` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you are checking the Terraform configuration into source control, add the
    file to the ignore list to avoid accidentally checking it in.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use Git, adding the following to the `.gitignore` file will suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s go ahead and look at the Terraform workflow to progress further.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Terraform workflow typically consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init`: Initializes the Terraform `init` command multiple times during your
    build, as it does not change your workspace or state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`plan`: It runs a speculative plan on the requested resources. This command
    typically connects with the cloud provider and then checks whether the objects
    managed by Terraform exist within the cloud provider and whether they have the
    same configuration as defined in the Terraform template. It then shows the delta
    in the plan output that an admin can review and change the configuration if unsatisfied.
    If satisfied, they can apply the plan to commit the changes to the cloud platform.
    The `plan` command does not make any changes to the current infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apply`: This applies the delta configuration to the cloud platform. When you
    use `apply` by itself, it runs the `plan` command first and asks for confirmation.
    If you supply a plan to it, it applies the plan directly. You can also use `apply`
    without running the plan using the `-``auto-approve` flag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destroy`: The `destroy` command destroys the entire infrastructure Terraform
    manages. It is, therefore, not a very popular command and is rarely used in a
    production environment. That does not mean that the `destroy` command is not helpful.
    Suppose you are spinning up a development infrastructure for temporary purposes
    and don’t need it later. In that case, destroying everything you created using
    this command takes a few minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To access the resources for this section, `cd` into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s look at these in detail with hands-on exercises.
  prefs: []
  type: TYPE_NORMAL
- en: terraform init
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To initialize a Terraform workspace, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As the Terraform workspace has been initialized, we can create an **Azure resource
    group** to start working with the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the first resource – Azure resource group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We must use the `azurerm_resource_group` resource within the `main.tf` file
    to create an Azure resource group. Add the following to your `main.tf` file to
    do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we’ve used two variables, we’ve got to declare those, so add the following
    to the `vars.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to add the resource group name and location to the `terraform.tfvars`
    file. Therefore, add the following to the `terraform.tfvars` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: So, now we’re ready to run a plan, but before we do so, let’s use `terraform
    fmt` to format our files into the canonical standard.
  prefs: []
  type: TYPE_NORMAL
- en: terraform fmt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `terraform fmt` command formats the `.tf` files into a canonical standard.
    Use the following command to format your files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The command lists the files that it formatted. The next step is to validate
    your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: terraform validate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `terraform validate` command validates the current configuration and checks
    whether there are any syntax errors. To validate your configuration, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The success output denotes that our configuration is valid. If there were any
    errors, it would have highlighted them in the validated output.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always run `fmt` and `validate` before every Terraform plan. It saves you a
    ton of planning time and helps you keep your configuration in good shape.
  prefs: []
  type: TYPE_NORMAL
- en: As the configuration is valid, we are ready to run a plan.
  prefs: []
  type: TYPE_NORMAL
- en: terraform plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run a Terraform plan, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `plan` output tells us that if we run `terraform apply` immediately, it
    will create a single `terraform_exercise` resource group. It also outputs a note
    that since we did not save this plan, the subsequent application is not guaranteed
    to result in the same action. Meanwhile, things might have changed; therefore,
    Terraform will rerun `plan` and prompt us for `yes` when applying. Thus, you should
    save the plan to a file if you don’t want surprises.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always save `terraform plan` output to a file and use the file to apply the
    changes. This is to avoid any last-minute surprises with things that might have
    changed in the background and `apply` not doing what it is intended to do, especially
    when your plan is reviewed as a part of your process.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s go ahead and save the plan to a file first using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This time, the plan is saved to a file called `rg_terraform_exercise.tfplan`.
    We can use this file to apply the changes subsequently.
  prefs: []
  type: TYPE_NORMAL
- en: terraform apply
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To apply the changes using the `plan` file, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it! Terraform has applied the configuration. Let’s use the Azure
    CLI to verify whether the resource group is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to list all resource groups within your subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We see that our resource group is created and within the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There might be instances when `apply` is partially successful. In that case,
    Terraform will automatically taint resources it believes weren’t created successfully.
    Such resources will be recreated automatically in the next run. If you want to
    taint a resource for recreation manually, you can use the `terraform` `taint`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we want to destroy the resource group as we no longer need it. We can
    use `terraform destroy` for that.
  prefs: []
  type: TYPE_NORMAL
- en: terraform destroy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To destroy the resource group, we can run a speculative plan first. It is always
    a best practice to run a speculative plan to confirm that what we need to destroy
    is within the output to have no surprises later. Terraform, like Linux, does not
    have an undo button.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a speculative destroy plan, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As we see, as the resource group was the only resource managed by Terraform,
    it has listed that as the resource that will be destroyed. There are two ways
    of destroying the resource: using `terraform destroy` on its own or saving the
    speculative plan using the `out` parameter and running `terraform apply` on the
    destroy plan.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the first method for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to destroy all resources managed by Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this time, Terraform reruns `plan` and prompts for a value. It will only
    accept `yes``yes`, and hit *Enter* to confirm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: And it has now destroyed the resource group.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve looked at a basic root module and explored the Terraform workflow. The
    basic root module helps us create and manage resources but lacks a very important
    feature – reusability. Terraform provides us with modules to allow reusability
    for common templates. Let’s look at it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Terraform modules** are reusable, repeatable templates. They allow abstraction
    in provisioning infrastructure, which is much needed if your usage grows beyond
    just some proof of concept. HashiCorp visualizes modules as designed by experts
    who know the enterprise standard and used by developers who want to apply the
    enterprise standard infrastructure in their projects. That way, things are standard
    across the organization. It saves developers time and avoids duplication of efforts.
    Modules can be versioned and distributed using a **module repository** or through
    your version control. That provides infrastructure admins with an ample amount
    of power and control at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we created a resource group in the last section, let’s modularize that in
    the next exercise. To access the resources for this section, `cd` into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Within this directory, we have the following directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have the `main.tf`, `terraform.tfvars`, and `vars.tf` files
    in the root directory like before. However, we have included an additional `modules`
    directory, which contains a `resource_group` subdirectory that contains a `main.tf`
    file and a `vars.tf` file. Let’s look at both.
  prefs: []
  type: TYPE_NORMAL
- en: '`modules/resource_group/main.tf` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It only contains an `azurerm_resource_group` resource with a name and location
    sourced from the `name` and `location` variables defined in the following `modules/resource_group/vars.tf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the root module, which is the current directory, we’ve modified the `main.tf`
    file to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, instead of defining the resource directly in this file, we have
    defined a module called `rg`, whose `source` is `./modules/resource_group`. Note
    that we pass the value for the variables defined for the module, that is, `name`,
    and `location`, from the variables defined at the root level, that is, `var.rg_name`
    and `var.rg_location`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go ahead and see what happens when we initialize and apply this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to initialize the Terraform workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Terraform has detected the new module and initialized it during
    init.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you define a new module, you must always reinitialize Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go ahead and run a plan using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, it will create the resource group. However, this is now a part
    of the module addressed `module.rg.azurerm_resource_group.rg`. To apply the plan,
    let’s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And the resource group has been created! To destroy the resource group, let’s
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By using modules, you can simplify infrastructure creation and management, enhance
    collaboration among teams, and establish a consistent approach to deploying resources
    in a scalable and maintainable manner.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Use Terraform modules to encapsulate and reuse infrastructure configurations,
    promoting modularity and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we’ve seen Terraform creating and destroying resources, but how does
    Terraform know what it had created before and what it needs to destroy? Well,
    it uses a **state file** for that. Let’s have a look.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Terraform state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform uses a state file to track what it has deployed and what resources
    it is managing. The state file is essential as it records all the infrastructure
    Terraform maintains. If you lose it, Terraform will lose track of what it has
    done so far and start treating resources as new and needing to be created again.
    Therefore, you should protect your state as code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform stores state in backends. By default, Terraform stores the state
    file as `terraform.tfstate` within the `workspace` directory, which is called
    the local backend. However, that is not the best way of managing the state. There
    are a couple of reasons why you should not store state in a local system:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple admins cannot work on the same infrastructure if the state file is
    stored within someone’s local directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local workstations are not backed up; therefore, the risk of losing the state
    file is high even if you have a single admin doing the job
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might argue that we can resolve these problems by checking the state file
    into source control with the `.tf` files. Don’t do that! State files are plaintext,
    and if your infrastructure configuration contains sensitive information such as
    passwords, anyone can see it. Therefore, you need to store a state file securely.
    Also, storing state files in source control does not provide state locking, resulting
    in conflicts if multiple people are simultaneously modifying the state file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Never store state files in source control. Use a `.gitignore` file entry to
    bypass the `terraform.tfstate` file.
  prefs: []
  type: TYPE_NORMAL
- en: The best place to store your Terraform state is on remote cloud storage. Terraform
    provides a remote backend to store state remotely. There are multiple types of
    remote backends you can use. When writing this book, `plan` and `apply` within
    the backend, and only Terraform Cloud and Enterprise support it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: While choosing the state storage solution, you should prefer storage with state
    locking. That will allow multiple people to manipulate the resources without stepping
    on each other’s shoes and causing conflict, as once a state file is locked, others
    cannot acquire it until the lock is released.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’re using Azure, we can use Azure Storage to store our state. The advantages
    are three-fold:'
  prefs: []
  type: TYPE_NORMAL
- en: Your state file is centralized. You can have multiple admins working together
    and managing the same infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The store is encrypted at rest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get automatic backup, redundancy, and high availability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To access the resources for this section, `cd` into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now use the `azurerm` backend and use Azure Storage to persist our Terraform
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Azure Storage backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we will end up in a chicken-or-egg situation if we use Terraform to build
    a backend to store its state, we will have to configure this bit without using
    Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, let’s use the `az` command to configure the storage account in a
    different resource group that Terraform will not manage.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Azure Storage resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s start by defining a few variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$` `RESOURCE_GROUP=tfstate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` `STORAGE_ACCOUNT_NAME=tfstate$RANDOM`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$` `CONTAINER_NAME=tfstate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a resource group first using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s go ahead and create a storage account within the resource group
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to fetch the account key using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can go ahead and create a Blob Storage container using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If we receive a `created` response, the storage account is created and ready
    for use. Now, we can go and define the backend configuration file in Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a backend configuration in Terraform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we create the backend, we will need the `STORAGE_ACCOUNT_NAME` value.
    To get this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the backend configuration in Terraform, create a file called `backend.tf`
    within the workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the backend configuration, we’ve defined the `resource_group_name` backend
    where the Blob Storage instance exists – `storage_account_name`, `container_name`,
    and `key`. The `key` attribute specifies the filename that we will use to define
    the state of this configuration. There might be multiple projects that you are
    managing using Terraform, and all of them will need separate state files. Therefore,
    the `key` attribute defines the state file’s name that we will use for our project.
    That allows multiple Terraform projects to use the same Azure Blob Storage to
    store the state.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always use the name of the project as the name of the key. For example, if your
    project name is `foo`, name the key `foo.tfstate`. That will prevent potential
    conflicts with others and also allow you to locate your state file quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To initialize the Terraform workspace with the new backend configuration, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: When we initialize that, Terraform detects that the backend has changed and
    checks whether anything is available in the existing backend. If it finds something,
    it asks whether we want to migrate the current state to the new backend. If it
    does not, it automatically switches to the new backend, as we see here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go ahead and use the `terraform plan` command to run a plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as we see, `terraform plan` tells us that it will create a new resource
    group called `terraform-exercise`. Let’s apply the configuration, and this time
    with an `auto-approve` flag so that the plan does not run again, and Terraform
    immediately applies the changes using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We now have the resource created successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go to Azure Blob Storage and see whether we have a `tfstate` file
    there, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Terraform state](img/B19877_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Terraform state
  prefs: []
  type: TYPE_NORMAL
- en: As we see, we have a file called `example.tfstate` within the blob container.
    That is how remote storage works, and now anyone with access to the Blob Storage
    instance can use the Terraform configuration and make changes.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve been managing resources using the default workspace, but what
    if there are multiple environments that you need to control using the same configuration?
    Well, Terraform offers workspaces for those scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform workspaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software development requires multiple environments. You develop software within
    your workspace, deploy it into the development environment, unit test it, and
    then promote the tested code to a test environment. Your QA team will test the
    code extensively in the test environment, and once all test cases pass, you can
    promote your code to production.
  prefs: []
  type: TYPE_NORMAL
- en: That means you must maintain a similar infrastructure in all environments. With
    an IaC tool such as Terraform, infrastructure is represented as code, and we must
    manage our code to fit multiple environments. But Terraform isn’t just code; it
    also contains state files, and we must maintain state files for every environment.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to create three resource groups, `terraform-exercise-dev`,
    `terraform-exercise-test`, and `terraform-exercise-prod`. Each resource group
    will contain a similar set of infrastructure with similar properties. For example,
    each resource group includes an Ubuntu **Virtual** **Machine** (**VM**).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple method to approach the problem is by creating a structure like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Can you see the duplication? The same files occur multiple times, all containing
    the same configuration. The only thing that might change is the `terraform.tfvars`
    file for each environment.
  prefs: []
  type: TYPE_NORMAL
- en: So, this does not sound like a great way to approach this problem, and that’s
    why Terraform provides workspaces for it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Terraform workspaces** are nothing but independent state files. So, you have
    a single configuration and multiple state files for each environment. Sounds simple,
    right? Let’s have a look.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to represent the same configuration by using Terraform workspaces
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, this looks simple. It just contains a single set of files. Let’s have a
    look at each of them to understand them better.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the resources for this section, `cd` into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main.tf` file contains a `resource_group` resource with a name that includes
    an environment suffix, along with other resources that we need to create within
    the resource group, such as the VNet, subnet, and VM, something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To access the name of the workspace, Terraform provides the `terraform.workspace`
    variable, which we have used to define the `resource_group` name. So, the template
    is now ready to take configuration for any environment, and we will have a separate
    resource group for each environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, update the `backend.tf` file with the `tfstate` container name we created
    in the last section and initialize the Terraform workspace by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, once Terraform has initialized, let’s create a `dev` workspace by using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You’re now in a new, empty workspace. Workspaces isolate their state, so if
    you run `terraform plan`, Terraform will not see any existing state for this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: So, as we’re in a new, empty workspace called `dev`, let’s run a plan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to run a plan on the `dev` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s go ahead and apply the plan using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As the `dev` plan has been applied and the resources are created in the `dev`
    resource group, let’s create a workspace for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'As the new workspace is created, let’s run a plan on the test workspace using
    the following command and save it to the `test.tfplan` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the resources will be created in the `terraform-ws-test` resource
    group. So, let’s go ahead and apply the plan using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `test` plan has been applied as well. Now let’s go ahead and inspect the
    created resources.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Terraform workspaces are ideal for maintaining separate infrastructure configurations
    for different environments, such as development, staging, and production. This
    helps prevent accidental configuration changes and ensures consistent setups.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s use the `az` command to list the resource groups. As we know, our resource
    groups have a resource group prefix of `terraform-ws`. Therefore, use the following
    command to list all resource groups containing the prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we have two resource groups, `terraform-ws-dev` and `terraform-ws-test`.
    So, two resource groups have been created successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also verify this in the Azure portal, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Resource groups](img/B19877_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Resource groups
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go ahead and inspect the resources on the `terraform-ws-dev` resource
    group using the Azure portal by clicking on `terraform-ws-dev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Terraform dev resource group](img/B19877_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Terraform dev resource group
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a virtual network, a network interface, an OS disk, and a VM within
    the resource group. We should expect similar resources with the same names in
    the `terraform-ws-test` resource group. Let’s go ahead and have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Terraform test resource group](img/B19877_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Terraform test resource group
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we also have similar resources in the `terraform-ws-test` resource
    group.
  prefs: []
  type: TYPE_NORMAL
- en: We did all this using a single configuration, but there should be two state
    files for each workspace since they are two sets of resources. Let’s have a look.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting state files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we had used the local backend for the state files, we would get the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: So, Terraform creates a directory called `terrafom.tfstate.d`; within that,
    it creates directories for each workspace. Within the directories, it stores the
    state file for each workspace as `terraform.tfstate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But since we are using a remote backend and using Azure Blob Storage for it,
    let’s inspect the files within it using the Azure console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Terraform workspace state](img/B19877_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Terraform workspace state
  prefs: []
  type: TYPE_NORMAL
- en: As we see, there are two state files, one for each environment. Therefore, the
    state files are suffixed with an `env:dev` or `env:test` string. That is how workspaces
    are managed in Azure Blob Storage. The remote backend’s structure for maintaining
    state files depends on the provider plugins, and therefore, there might be different
    ways of managing multiple states for various backends. However, the Terraform
    CLI will interpret workspaces the same way, irrespective of the backends, so nothing
    changes for the end user from a CLI perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s go ahead and clean up both resource groups to avoid unnecessary charges.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’re already within the test workspace, let’s run the following command
    to destroy resources within the test workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s switch to the `dev` workspace using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As we’re within the `dev` workspace, use the following command to destroy all
    resources within the `dev` workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In a while, we should see that both resource groups are gone. Now, let’s look
    at some of the advanced concepts of Terraform in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform output, state, console, and graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we understand that Terraform uses state files to manage resources, let’s
    look at some advanced commands to help us appreciate and make more sense of the
    Terraform state concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the resources for this section, `cd` into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s go ahead and look at our first command – `terraform output`.
  prefs: []
  type: TYPE_NORMAL
- en: terraform output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve looked at variables but haven’t yet discussed outputs. Terraform
    outputs are return values of a Terraform configuration that allow users to export
    configuration to users or any modules that might use the current module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go with the last example and add an output variable that exports the
    private IP of the network interface attached to the VM in the `outputs.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s go ahead and apply the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'After Terraform has applied the configuration, it shows the outputs at the
    end of the console result. You can run the following to inspect the output anytime
    later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Outputs are stored in the state file like everything else, so let’s look at
    how we can manage Terraform state using the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Terraform state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform stores the configuration it manages in state files and therefore provides
    a command for advanced state management. The `terraform state` command helps you
    manage the state of the current configuration. While the state file is plaintext
    and you can manually modify it, using the `terraform state` command is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: But before we get into details, we must understand why we want to do that. Things
    might not always go according to plan, so the state file may have corrupt data.
    You also might want to see specific attributes of a particular resource after
    you’ve applied it. The state file might need to be investigated for the root cause
    analysis of a specific infrastructure provisioning problem. Let’s have a look
    at the most common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the current state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To view the current state, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: That will output all resources that Terraform has created and manages, including
    outputs. Of course, this can be overwhelming for some, and we may want to view
    the list of resources Terraform manages.
  prefs: []
  type: TYPE_NORMAL
- en: Listing resources in the current state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To list the resources in the Terraform state file, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: And as we see, there are five resources managed by Terraform. You might want
    to remove a resource from the Terraform state. It might be possible that someone
    has removed a resource manually as it is no longer required, but it isn’t removed
    from the Terraform configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a resource from the state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To remove a state manually from the Terraform state file, you must use the
    `terraform state rm <resource>` command. For example, to remove the Azure VM resource
    from the Terraform state, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind that this has merely removed the resource from the state file and
    has not touched the actual resource sitting on Azure.
  prefs: []
  type: TYPE_NORMAL
- en: There might be instances where someone spun up a VM manually within Azure, and
    we now want Terraform to manage it. This kind of situation happens mostly in brownfield
    projects. In that case, we must declare the same configuration within Terraform
    and then import existing resources in the Terraform state. To do so, we can use
    the `terraform` `import` command.
  prefs: []
  type: TYPE_NORMAL
- en: Importing existing resources into Terraform state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can use the `terraform import` command to import existing resources into
    Terraform state. The `terraform import` command is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to reimport the `httpd` VM into the state, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether the resource is imported to the state, we can list the resources
    again using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: As we see, we have the VM within the state file. If we want to dig further into
    the resources, we can use `terraform console`.
  prefs: []
  type: TYPE_NORMAL
- en: terraform console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `terraform console` command provides an interactive console to investigate
    state files, dynamically build paths, and evaluate expressions even before using
    them in resources. It is a potent tool that most advanced Terraform users use.
    For example, let’s launch the console and look through the configuration of the
    VM resource we just imported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following commands to launch the console and get the resource group
    of the VM and the `id` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the VM is in the correct resource group, and we’re satisfied
    that the import was correct.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform dependencies and graphs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terraform uses a dependency model to manage in what order resources are created
    and destroyed. There are two kinds of dependencies – *implicit* and *explicit*.
    We’ve been using implicit dependencies until now, where the VM depended upon the
    network interface, and the network interface depended upon the subnet. The subnet
    depended upon the virtual network, and all of these resources depended on the
    resource group. These dependencies naturally occur when we use one resource’s
    output as another’s input.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes, we want to define an explicit dependency on a resource,
    especially when there is no way to define an implicit dependency on it. You can
    use the `depends_on` attribute for that kind of operation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Avoid explicit dependencies unless needed, as Terraform uses parallelism to
    manage resources. If explicit dependencies are not required, it will slow down
    Terraform runs because it can process multiple parallel resources.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize the dependencies between resources, we can export a graph from
    the state file and convert that into a PNG file using a tool such as **Graphviz**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to export the dependency graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then process the graph file using the Graphviz tool. To install the
    tool on Ubuntu, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the following command to convert the graph file into a PNG file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The graph is available at [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e/blob/main/ch8/terraform-graph.png](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e/blob/main/ch8/terraform-graph.png).
    Now, let’s go ahead and see how we can clean up our resources.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we already know, we run the following command to clean up the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: It will clear resources from the resource group and delete the resource group
    after that.
  prefs: []
  type: TYPE_NORMAL
- en: While using `terraform destroy` can be an easy way to eliminate resources you
    don’t need, it is best if you stick to this only in the `dev` environment and
    never use it in production. Instead, you can remove resources you don’t need from
    the configuration and then run `terraform apply`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve discussed Terraform’s core and understood some of the
    most common commands and functionalities from a hands-on perspective. We started
    with understanding IaC, introduced Terraform as an IaC tool, installed Terraform,
    understood Terraform providers, and used the Azure Terraform provider to manage
    infrastructure in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at Terraform variables and multiple ways of supplying values
    to the variables. We discussed the core Terraform workflow and several commands
    you would use to manage infrastructure using Terraform. We then looked at Terraform
    modules and then at Terraform state as an essential component that helps Terraform
    keep track of the infrastructure it is managing.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at local and remote state storage and used Azure Blob Storage as the
    remote state backend. We then discussed Terraform workspaces and how they enable
    us to use the same Terraform configuration to build multiple environments with
    hands-on exercises.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at some advanced operations with Terraform state using the `outputs`,
    `state`, and `console` commands. We finally looked at how Terraform manages dependencies
    and viewed a dependency graph using the `graph` command.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into configuration management using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Why should we constrain the provider version?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should always use the `fmt` and `validate` functions before a Terraform
    plan. (True/False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the Terraform `plan` command do? (Choose two)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Refreshes the current state with the existing infrastructure state
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Gets the delta between the current configuration and the expected configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Applies the configuration to the cloud
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Destroys the configuration in the cloud
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What does the `terraform apply` command do? (Choose three)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Refreshes the current state with the existing infrastructure
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Gets the delta between the current configuration and the expected configuration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Applies the configuration to the cloud
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Destroys the configuration in the cloud
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why should you never store state files in source control? (Choose two)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. State files are plaintext, and therefore you expose sensitive information
    to unprivileged users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Source control does not support state locking, and therefore it might result
    in potential conflicts between users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Multiple admins cannot work on the same configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following are valid Terraform remote backends? (Choose five)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. S3
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Azure Blob Storage
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Artifactory
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Git
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: E. HTTP
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: F. Terraform Enterprise
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which command will mark a resource for recreation in the next `apply`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where are state files stored in the local backend if you use workspaces?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command should we use to remove a Terraform resource from the state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command should we use to import an existing cloud resource within the state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because Terraform providers are released separately to the Terraform CLI, different
    versions might break the existing configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A, B
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A, B, C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A, B
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A, B, C, E, F
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `taint` command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`terraform.tfstate.d`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`terraform state` `rm <resource>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`terraform import <``resource> <id>`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
