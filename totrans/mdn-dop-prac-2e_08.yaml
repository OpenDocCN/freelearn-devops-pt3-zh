- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Infrastructure as Code (IaC) with Terraform
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 实现基础设施即代码（IaC）
- en: Cloud computing is one of the primary factors of DevOps enablement today. The
    initial apprehensions about the cloud are a thing of the past. With an army of
    security and compliance experts manning cloud platforms 24x7, organizations are
    now trusting the *public cloud* like never before. Along with cloud computing,
    another buzzword has taken the industry by storm – **Infrastructure as Code**
    (**IaC**). This chapter will focus on IaC with **Terraform**, and by the end of
    this chapter, you will understand the concept and have enough hands-on experience
    with Terraform to get you started on your journey.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 云计算是当今推动 DevOps 实现的主要因素之一。关于云计算的初步担忧已经成为过去。随着一支安全和合规专家24小时驻守在云平台，组织现在比以往任何时候都更加信任*公共云*。与云计算一起，另一个热词也席卷了整个行业——**基础设施即代码**（**IaC**）。本章将重点讲解使用
    **Terraform** 实现 IaC，到了本章结束时，你将理解这一概念，并拥有足够的 Terraform 实践经验，帮助你开始自己的旅程。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Introduction to IaC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IaC 简介
- en: Setting up Terraform and Azure providers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Terraform 和 Azure 提供者
- en: Understanding Terraform workflows and creating your first resource using Terraform
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Terraform 工作流并使用 Terraform 创建你的第一个资源
- en: Terraform modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 模块
- en: Terraform state and backends
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 状态和后端
- en: Terraform workspaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 工作空间
- en: Terraform outputs, state, console, and graphs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform 输出、状态、控制台和图表
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you can use any machine to run Terraform. Terraform supports
    many platforms, including Windows, Linux, and macOS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，你可以使用任何机器来运行 Terraform。Terraform 支持多个平台，包括 Windows、Linux 和 macOS。
- en: You will need an active Azure subscription to follow the exercises. Currently,
    Azure is offering a free trial for 30 days with $200 worth of free credits; you
    can sign up at [https://azure.microsoft.com/en-in/free](https://azure.microsoft.com/en-in/free).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要一个有效的 Azure 订阅来进行练习。目前，Azure 提供为期 30 天的免费试用，并赠送价值 $200 的免费积分；你可以在 [https://azure.microsoft.com/en-in/free](https://azure.microsoft.com/en-in/free)
    注册。
- en: 'You will also need to clone the following GitHub repository for some of the
    exercises:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要克隆以下 GitHub 仓库来进行一些练习：
- en: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)'
- en: 'Run the following command to clone the repository into your home directory,
    and `cd` into the `ch8` directory to access the required resources:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将仓库克隆到你的主目录，并 `cd` 进入 `ch8` 目录以访问所需资源：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, let’s get started!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: Introduction to IaC
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IaC 简介
- en: IaC is the concept of using code to define infrastructure. While most people
    can visualize infrastructure as something tangible, virtual infrastructure is
    already commonplace and has existed for around two decades. Cloud providers provide
    a web-based console through which you can manage your infrastructure intuitively.
    But the process is not repeatable or recorded.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码（IaC）是使用代码来定义基础设施的概念。虽然大多数人能将基础设施想象成某种有形的东西，但虚拟基础设施已经是司空见惯的存在，并且已经存在了大约二十年。云服务提供商提供了一个基于
    Web 的控制台，通过它，你可以直观地管理你的基础设施。然而，这个过程不可重复且没有记录。
- en: If you spin up a set of infrastructure components using the console in one environment
    and want to replicate it in another, it is a duplication of effort. To solve this
    problem, cloud platforms provide APIs to manipulate resources within the cloud
    and some command-line tools that can help trigger the APIs. You can start writing
    scripts using commands to create the infrastructure and parameterize them to use
    the same scripts in another environment. Well, that solves the problem, right?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个环境中使用控制台启动一组基础设施组件，并希望在另一个环境中复制它，那就相当于重复劳动。为了解决这个问题，云平台提供了 API 来操作云中的资源，并提供一些命令行工具帮助触发这些
    API。你可以开始编写脚本，使用命令来创建基础设施，并将其参数化以便在另一个环境中使用同样的脚本。嗯，这样就解决问题了，对吧？
- en: 'Not really! Writing scripts is an imperative way of managing infrastructure.
    Though you can still call it IaC, its problem is that it does not effectively
    manage infrastructure changes. Let me give you a few examples:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是完全如此！编写脚本是管理基础设施的一种命令式方式。尽管你仍然可以称之为 IaC，但它的问题在于没有有效地管理基础设施变更。让我举几个例子：
- en: What would happen if you needed to modify something already in the script? Changing
    the script somewhere in the middle and rerunning the entire thing may create havoc
    with your infrastructure. Imperative management of infrastructure is not idempotent.
    So, managing changes becomes a problem.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要修改脚本中已经存在的内容，怎么办？在脚本的中间某个地方进行更改，并重新运行整个脚本，可能会对你的基础设施造成混乱。命令式管理基础设施是不可幂等的。因此，管理更改会成为一个问题。
- en: What if someone manually changes the script-managed infrastructure using the
    console? Will your script be able to detect it correctly? What if you want to
    change the same thing using a script? It will soon start to get messy.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有人使用控制台手动更改了脚本管理的基础设施，怎么办？你的脚本能正确检测到吗？如果你想用脚本改变同样的内容，会发生什么？这很快就会变得杂乱无章。
- en: With the advent of hybrid cloud architecture, most organizations use multiple
    cloud platforms for their needs. When you are in such a situation, managing multiple
    clouds with imperative scripts soon becomes a problem. Different clouds have different
    ways of interacting with their APIs and have distinct command-line tools.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随着混合云架构的出现，大多数组织都使用多个云平台来满足他们的需求。当你处于这种情况时，使用命令式脚本管理多个云很快就会变得成问题。不同的云平台有不同的与API交互的方式，并且有各自独特的命令行工具。
- en: 'The solution to all these problems is a declarative IaC solution such as Terraform.
    HashiCorp’s Terraform is the most popular IaC tool available on the market. It
    helps you automate and manage your infrastructure using code and can run on various
    platforms. As it is declarative, you just need to define what you need (the desired
    end state) instead of describing how to achieve it. It has the following features:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 解决所有这些问题的方案是像Terraform这样的声明性IaC解决方案。HashiCorp的Terraform是市场上最流行的IaC工具。它帮助你使用代码自动化和管理基础设施，并能在各种平台上运行。由于它是声明式的，你只需定义你需要的内容（期望的最终状态），而不需要描述如何实现它。它具有以下特性：
- en: It supports multiple cloud platforms via providers and exposes a single declarative
    **HashiCorp Configuration Language** (**HCL**)-based interface to interact with
    it. Therefore, it allows you to manage various cloud platforms using a similar
    language and syntax. So, having a few Terraform experts within your team can handle
    all your IaC needs.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过提供程序支持多个云平台，并公开一个基于**HashiCorp配置语言**（**HCL**）的单一声明性接口与其交互。因此，它允许你使用相似的语言和语法管理各种云平台。所以，团队中如果有几位Terraform专家，就能处理你所有的IaC需求。
- en: It tracks the state of the resources it manages using state files and supports
    local and remote backends to store and manage them. That helps in making the Terraform
    configuration idempotent. So, if someone manually changes a Terraform-managed
    resource, Terraform can detect the difference in the next run and prompt corrective
    action to bring it to the defined configuration. The admin can then absorb the
    change or resolve any conflicts before applying it.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过状态文件跟踪其管理的资源的状态，并支持本地和远程后端存储和管理这些状态文件。这有助于使Terraform配置具有幂等性。因此，如果有人手动更改了Terraform管理的资源，Terraform可以在下次运行时检测到差异，并提示进行纠正操作，以将其恢复到定义的配置。管理员可以在应用更改之前吸收此更改或解决任何冲突。
- en: It enables GitOps in infrastructure management. With Terraform, you can have
    the infrastructure configuration alongside application code, making versioning,
    managing, and releasing infrastructure the same as managing code. You can also
    include code scanning and gating using pull requests so that someone can review
    and approve the changes to higher environments before you apply them. A great
    power indeed!
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在基础设施管理中实现了GitOps。通过Terraform，你可以将基础设施配置与应用程序代码放在一起，使版本控制、管理和发布基础设施的方式与管理代码相同。你还可以通过拉取请求包含代码扫描和门控，以便在应用更高环境之前，有人可以审查并批准对更高环境的更改。确实是一项强大的功能！
- en: Terraform has multiple offerings – **open source**, **cloud**, and **enterprise**.
    The open source offering is a simple **command-line interface** (**CLI**)-based
    tool that you can download on any supported **operating system** (**OS**) and
    use. The cloud and enterprise offerings are more of a wrapper on top of the open
    source one. They provide a web-based GUI and advanced features such as **policy
    as code** with **Sentinel**, **cost analysis**, **private modules**, **GitOps**,
    and **CI/CD pipelines**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform提供了多个版本——**开源**、**云**和**企业**版。开源版是一个简单的基于**命令行界面**（**CLI**）的工具，你可以在任何支持的**操作系统**（**OS**）上下载并使用。云和企业版更多的是对开源版的包装。它们提供基于Web的GUI和高级功能，如**代码即策略**（**Sentinel**）、**成本分析**、**私有模块**、**GitOps**和**CI/CD流水线**。
- en: This chapter will discuss the open source offering and its core functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论开源提供和其核心功能。
- en: 'Terraform open source is divided into two main parts – **Terraform Core** and
    **Terraform providers**, as seen in the following diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 开源分为两个主要部分——**Terraform Core** 和 **Terraform 提供者**，如下图所示：
- en: '![Figure 8.1 – Terraform architecture](img/B19877_08_1.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – Terraform 架构](img/B19877_08_1.jpg)'
- en: Figure 8.1 – Terraform architecture
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – Terraform 架构
- en: 'Let’s look at the functions of both components:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这两个组件的功能：
- en: '**Terraform Core** is the CLI that we will use to interact with Terraform.
    It takes two main inputs – your Terraform configuration files and the existing
    state. It then takes the difference in configuration and applies it.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Terraform Core** 是我们用来与 Terraform 交互的 CLI。它有两个主要输入——你的 Terraform 配置文件和现有状态。然后，它会计算配置差异并应用它。'
- en: '**Terraform providers** are plugins that Terraform uses to interact with cloud
    providers. The providers translate the Terraform configuration into the respective
    cloud’s REST API calls so that Terraform can manage its associated infrastructure.
    For example, if you want Terraform to manage AWS infrastructure, you must use
    the Terraform AWS provider.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Terraform 提供者** 是 Terraform 用来与云提供商交互的插件。提供者将 Terraform 配置转换为相应云的 REST API
    调用，以便 Terraform 管理相关的基础设施。例如，如果你希望 Terraform 管理 AWS 基础设施，则必须使用 Terraform AWS 提供者。'
- en: Now let’s see how we can install open source Terraform.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何安装开源 Terraform。
- en: Installing Terraform
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Terraform
- en: Installing Terraform is simple; go to [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)
    and follow the instructions for your platform. Most of it will require you to
    download a binary and move it to your system path.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Terraform 非常简单；只需访问[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)，并根据你的平台按照说明进行操作。大部分内容将要求你下载一个二进制文件并将其移到系统路径中。
- en: 'Since we’ve been using Ubuntu throughout this book, I will show the installation
    on Ubuntu. Use the following commands to use the `apt` package manager to install
    Terraform:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在本书中一直使用 Ubuntu，因此我将展示如何在 Ubuntu 上安装 Terraform。使用以下命令，借助 `apt` 包管理器来安装 Terraform：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Check whether Terraform has been installed successfully with the following
    command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令检查 Terraform 是否已成功安装：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It shows that Terraform has been installed successfully. Terraform uses Terraform
    providers to interact with cloud providers, so let’s look at those in the next
    section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示 Terraform 已成功安装。Terraform 使用 Terraform 提供者与云提供商进行交互，接下来我们将在下一节中讨论这些内容。
- en: Terraform providers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform 提供者
- en: Terraform has a decentralized architecture. While the Terraform CLI contains
    Terraform’s core functionality and provides all functionalities not related to
    any specific cloud provider, Terraform providers provide the interface between
    the Terraform CLI and the cloud providers themselves. This decentralized approach
    has allowed public cloud vendors to offer their Terraform providers so that their
    customers can use Terraform to manage infrastructure in their cloud. Such is Terraform’s
    popularity that it has now become an essential requirement for every public cloud
    provider to offer a Terraform provider.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 采用去中心化架构。Terraform CLI 包含 Terraform 的核心功能，并提供与特定云提供商无关的所有功能，而 Terraform
    提供者则为 Terraform CLI 和云提供商之间提供接口。这种去中心化的方式使得公共云供应商能够提供他们自己的 Terraform 提供者，从而使他们的客户可以使用
    Terraform 来管理云中的基础设施。由于 Terraform 的流行，现在每个公共云提供商都必须提供 Terraform 提供者。
- en: We will interact with Azure for this chapter’s entirety and use the Azure Terraform
    provider for our activity.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将与 Azure 进行交互，并使用 Azure Terraform 提供者来进行操作。
- en: 'To access the resources for this section, `cd` into the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，请在终端中 `cd` 到以下目录：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Before we go ahead and configure the provider, we need to understand how Terraform
    needs to authenticate and authorize with the Azure APIs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续配置提供者之前，我们需要了解 Terraform 如何与 Azure API 进行身份验证和授权。
- en: Authentication and authorization with Azure
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Azure 的身份验证和授权
- en: The simplest way to authenticate and authorize with Azure is to log in to your
    account using the Azure CLI. When you use the Azure provider within your Terraform
    file, it will automatically act as your account and do whatever it needs to. Now,
    this sounds dangerous. Admins generally have a lot of access, and having a tool
    that acts as an admin might not be a great idea. What if you want to plug Terraform
    into your CI/CD pipelines? Well, there is another way to do it – by using **Azure
    service principals**. Azure service principals allow you to access the required
    features without using a named user account. You can then apply the **principle
    of least privilege** to the service principal and provide only the necessary access.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Azure 进行身份验证和授权的最简单方法是使用 Azure CLI 登录到你的帐户。当你在 Terraform 文件中使用 Azure 提供程序时，它将自动充当你的帐户并执行所需的操作。现在，这听起来有点危险。管理员通常有很多访问权限，而有一个作为管理员的工具可能不是一个好主意。如果你想将
    Terraform 插入到 CI/CD 流水线中怎么办？其实，还有另一种方法——通过使用 **Azure 服务主体**。Azure 服务主体允许你在不使用指定用户帐户的情况下访问所需功能。你可以对服务主体应用
    **最小权限原则**，只提供必要的访问权限。
- en: 'Before configuring the service principal, let’s install the Azure CLI on our
    machine. To do so, run the following command:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置服务主体之前，让我们在机器上安装 Azure CLI。为此，请运行以下命令：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding command will download a shell script and execute it using `bash`.
    The script will then automatically download and configure the Azure CLI. To confirm
    whether the Azure CLI is installed successfully, run the following command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将下载一个 shell 脚本，并使用 `bash` 执行它。脚本将自动下载并配置 Azure CLI。要确认 Azure CLI 是否安装成功，请运行以下命令：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We see that the Azure CLI is correctly installed on the system. Now, let’s go
    ahead and configure the service principal.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 Azure CLI 在系统上正确安装。现在，让我们继续配置服务主体。
- en: To configure the Azure service principal, follow these steps.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置 Azure 服务主体，请按照以下步骤操作。
- en: 'Log in to Azure using the following command and follow all the steps the command
    prompts. You must browse to a specified URL and enter the given code. Once you’ve
    logged in, you will get a JSON response that will include some details, something
    like the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令登录 Azure，并按照命令提示的步骤操作。你必须浏览到指定的 URL 并输入给定的代码。登录后，你将获得一个包含一些详细信息的 JSON
    响应，内容可能如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make a note of the `id` attribute, which is the subscription ID, and if you
    have more than one subscription, you can use the following to set it to the correct
    one:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记下`id`属性，它是订阅 ID，如果你有多个订阅，可以使用以下命令将其设置为正确的订阅：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Use the following command to create a `contributor` role to allow Terraform
    to manage the subscription’s infrastructure.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个`contributor`角色，允许 Terraform 管理订阅的基础设施。
- en: Tip
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Follow the principle of least privilege while granting access to the service
    principal. Do not give privileges thinking you might need them in the future.
    If any future access is required, you can grant it later.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在授予服务主体访问权限时，遵循最小权限原则。不要因为未来可能需要某些权限就提前授予它们。如果未来需要任何访问权限，你可以稍后再授予。
- en: 'We use `contributor` access for simplicity, but finer-grained access is possible
    and should be used:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `contributor` 权限是为了简化，但也可以使用更细粒度的权限，这种权限应该被使用：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve successfully created the `appId`, `password`, and `tenant`. We will need
    these to configure Terraform to use the service principal. In the next section,
    let’s define the Azure Terraform provider with the details.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了`appId`、`password`和`tenant`。我们将需要这些信息来配置 Terraform 使用服务主体。在下一节中，我们将根据这些详细信息定义
    Azure Terraform 提供程序。
- en: Using the Azure Terraform provider
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Azure Terraform 提供程序
- en: Before we define the Azure Terraform provider, let’s understand what makes a
    Terraform root module. The Terraform root module is just a working directory within
    your filesystem containing one or more `.tf` files that help you define your configuration
    and are where you would typically run your Terraform commands.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义 Azure Terraform 提供程序之前，让我们了解什么构成了 Terraform 根模块。Terraform 根模块仅是你文件系统中的一个工作目录，包含一个或多个
    `.tf` 文件，这些文件帮助你定义配置，并且通常是在这里运行 Terraform 命令。
- en: Terraform scans all your `.tf` files, combines them, and processes them internally
    as one. Therefore, you can have one or more `.tf` files that you can split according
    to your needs. While there are no defined standards for naming `.tf` files, most
    conventions use `main.tf` as the main Terraform file where they define resources,
    a `vars.tf` file for defining variables, and `outputs.tf` for defining outputs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 会扫描所有 `.tf` 文件，将它们合并，并在内部作为一个整体处理。因此，你可以根据需要将一个或多个 `.tf` 文件拆分开来。虽然没有为
    `.tf` 文件命名的标准，但大多数约定使用 `main.tf` 作为主 Terraform 文件，其中定义资源，使用 `vars.tf` 文件来定义变量，使用
    `outputs.tf` 文件来定义输出。
- en: 'For this discussion, let’s create a `main.tf` file within our working directory
    and add a `provider` configuration like the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本讨论中，让我们在工作目录中创建一个 `main.tf` 文件，并添加如下的 `provider` 配置：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding file contains two blocks. The `terraform` block contains the `required_providers`
    block, which declares the `version` constraint for the `azurerm` provider. The
    `provider` block declares an `azurerm` provider, which requires four parameters.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的文件包含两个块。`terraform` 块包含 `required_providers` 块，声明了 `azurerm` 提供程序的 `version`
    约束。`provider` 块声明了一个 `azurerm` 提供程序，它需要四个参数。
- en: Tip
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always constrain the provider version, as providers are released without notice,
    and if you don’t include the version number, something that works on your machine
    might not work on someone else’s machine or the CI/CD pipeline. Using a version
    constraint avoids breaking changes and keeps you in control.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 始终约束提供程序版本，因为提供程序的发布没有通知，如果你不包含版本号，在你的机器上可用的功能可能在其他人的机器或 CI/CD 流水线中无法正常工作。使用版本约束可以避免破坏性变更，并保持对版本的控制。
- en: You might have noticed that we have declared several variables within the preceding
    file instead of directly inputting the values. There are two main reasons for
    that – we want to make our template as generic as possible to promote reuse. So,
    suppose we want to apply a similar configuration in another subscription or use
    another service principal; we should be able to change it by changing the variable
    values. Secondly, we don’t want to check `client_id` and `client_secret` in source
    control. It is a bad practice as we expose our service principal to users beyond
    those who need to know about it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在前面的文件中声明了几个变量，而不是直接输入值。这背后有两个主要原因——我们希望使模板尽可能通用，以促进复用。所以，假设我们希望在另一个订阅中应用相似的配置，或者使用另一个服务主体，我们应该能够通过修改变量值来改变它。其次，我们不希望将
    `client_id` 和 `client_secret` 存储在源代码管理中。这是一个不好的做法，因为我们将服务主体暴露给了不需要知道的人。
- en: Tip
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Never store sensitive data in source control. Instead, use a `tfvars` file to
    manage sensitive information and keep it in a secret management system such as
    HashiCorp’s Vault.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将敏感数据存储在源代码控制中。相反，使用 `tfvars` 文件来管理敏感信息，并将其存储在像 HashiCorp Vault 这样的秘密管理系统中。
- en: Okay, so as we’ve defined the provider resource and the attribute values are
    sourced from variables, the next step would be to declare variables. Let’s have
    a look at that now.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，既然我们已经定义了提供程序资源，并且属性值来自变量，接下来的步骤是声明变量。现在让我们看看如何操作。
- en: Terraform variables
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform 变量
- en: 'To declare variables, we will need to create a `vars.tf` file with the following
    data:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明变量，我们需要创建一个 `vars.tf` 文件，并包含以下数据：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So, we’ve defined four variables here using `variable` blocks. Variable blocks
    typically have a `type` and a `description`. The `type` attribute defines the
    data type of the variable we declare and defaults to the `string` data type. It
    can be a primitive data type such as `string`, `number`, or `bool`, or a complex
    data structure such as `list`, `set`, `map`, `object`, or `tuple`. We will look
    at types in detail when we use them later in the exercises. The `description`
    attribute provides more information regarding the variable so users can refer
    to it for better understanding.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在这里使用 `variable` 块定义了四个变量。变量块通常包含 `type` 和 `description`。`type` 属性定义了我们声明的变量的数据类型，默认为
    `string` 数据类型。它可以是诸如 `string`、`number`、`bool` 这样的基本数据类型，或者是诸如 `list`、`set`、`map`、`object`
    或 `tuple` 这样的复杂数据结构。稍后在练习中我们会详细讨论这些类型。`description` 属性提供了有关变量的更多信息，用户可以参考它以便更好地理解。
- en: Tip
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always set the `description` attribute right from the beginning, as it is user-friendly
    and promotes the reuse of your template.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 始终从一开始就设置 `description` 属性，因为它对用户友好并促进模板的复用。
- en: The `client_secret` variable also contains a third attribute called `sensitive`,
    a Boolean attribute set to `true`. When the `sensitive` attribute is `true`, the
    Terraform CLI does not display it in the screen’s output. This attribute is highly
    recommended for sensitive variables such as passwords and secrets.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`client_secret` 变量还包含一个名为 `sensitive` 的第三属性，一个设置为 `true` 的布尔属性。当 `sensitive`
    属性为 `true` 时，Terraform CLI 不会在屏幕输出中显示它。对于像密码和机密这样的敏感变量，强烈建议使用此属性。'
- en: Tip
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always declare a sensitive variable as `sensitive`. This is because if you use
    Terraform within your CI/CD pipelines, unprivileged users might access sensitive
    information by looking at the logs.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 始终将敏感变量声明为 `sensitive`。这是因为如果在您的 CI/CD 管道中使用 Terraform，非特权用户可能通过查看日志访问敏感信息。
- en: Apart from the other three, an attribute called `default` will help you specify
    default variable values. The default values help you provide the best possible
    value for a variable, which your users can override if necessary.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除其他三者外，名为 `default` 的属性将帮助您指定变量的默认值。默认值可帮助您为变量提供最佳可能的值，用户如有需要可以覆盖它们。
- en: Tip
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always use default values where possible, as they allow you to provide users
    with soft guidance about your enterprise standard and save them time.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下始终使用默认值，因为它们允许您向用户提供关于企业标准的软指导，并节省他们的时间。
- en: The next step would be to provide variable values. Let’s have a look at that.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤将是提供变量值。让我们来看看这一点。
- en: Providing variable values
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供变量值
- en: 'There are a few ways to provide variable values within Terraform:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Terraform 中提供变量值有几种方法：
- en: '`-var``-var` flags with the `variable_name=variable_value` string to supply
    the values.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-var` 标志及 `variable_name=variable_value` 字符串以提供这些值。'
- en: '`.tfvars``.tfvars` (if you prefer HCL) or `.tfvars.json` (if you prefer JSON)
    via the command line with the `-``var-file` flag.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.tfvars`（如果您喜欢 HCL）或 `.tfvars.json`（如果您喜欢 JSON），通过命令行使用 `-var-file` 标志。'
- en: '`terraform.tfvars` or end it with an extension of `.auto.tfvars` within the
    Terraform workspace. Terraform will automatically scan these files and take the
    values from there.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Terraform 工作区中使用 `terraform.tfvars` 或以 `.auto.tfvars` 扩展名结束。Terraform 将自动扫描这些文件并从中获取值。
- en: '`TF_VAR_<var-name>` structure containing the variable value.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `TF_VAR_<var-name>` 结构包含变量值。
- en: '**Default**: When you run a Terraform plan without providing values to variables
    in any other way, the Terraform CLI will prompt for the values, and you must manually
    enter them.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认**：当您在任何其他方式中不为变量提供值时运行 Terraform 计划时，Terraform CLI 将提示输入这些值，并且您必须手动输入它们。'
- en: If multiple methods are used to provide the same variable’s value, the first
    method in the preceding list has the highest precedence for a specific variable.
    It overrides anything that is defined in the methods listed later.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用多种方法提供同一变量的值，则在前述列表中的第一种方法对特定变量具有最高优先级。它会覆盖后面列出的任何定义。
- en: We will use the `terraform.tfvars` file for this activity and provide the values
    for the variables.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `terraform.tfvars` 文件进行此活动，并为变量提供值。
- en: 'Add the following data to the `terraform.tfvars` file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下数据添加到 `terraform.tfvars` 文件中：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you are checking the Terraform configuration into source control, add the
    file to the ignore list to avoid accidentally checking it in.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将 Terraform 配置提交到源代码控制中，请将该文件添加到忽略列表以避免意外提交。
- en: 'If you use Git, adding the following to the `.gitignore` file will suffice:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 Git，请将以下内容添加到 `.gitignore` 文件中即可：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let’s go ahead and look at the Terraform workflow to progress further.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续查看 Terraform 工作流程，以进一步进行。
- en: Terraform workflow
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform 工作流程
- en: 'The Terraform workflow typically consists of the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 工作流通常包括以下步骤：
- en: '`init`: Initializes the Terraform `init` command multiple times during your
    build, as it does not change your workspace or state.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init`：在您的构建过程中多次初始化 Terraform `init` 命令，因为它不会更改您的工作区或状态。'
- en: '`plan`: It runs a speculative plan on the requested resources. This command
    typically connects with the cloud provider and then checks whether the objects
    managed by Terraform exist within the cloud provider and whether they have the
    same configuration as defined in the Terraform template. It then shows the delta
    in the plan output that an admin can review and change the configuration if unsatisfied.
    If satisfied, they can apply the plan to commit the changes to the cloud platform.
    The `plan` command does not make any changes to the current infrastructure.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plan`：此命令会在请求的资源上运行一个预估计划。此命令通常与云提供商连接，然后检查Terraform管理的对象是否存在于云提供商中，以及它们是否与Terraform模板中定义的配置一致。然后，它会显示计划输出中的差异，管理员可以审查并在不满意时更改配置。如果满意，他们可以应用计划，将更改提交到云平台。`plan`命令不会对当前基础设施进行任何更改。'
- en: '`apply`: This applies the delta configuration to the cloud platform. When you
    use `apply` by itself, it runs the `plan` command first and asks for confirmation.
    If you supply a plan to it, it applies the plan directly. You can also use `apply`
    without running the plan using the `-``auto-approve` flag.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apply`：此命令将增量配置应用到云平台。当你单独使用`apply`时，它会首先运行`plan`命令并要求确认。如果提供计划，它会直接应用该计划。你也可以在不运行计划的情况下使用`apply`，通过使用`-auto-approve`标志来自动批准。'
- en: '`destroy`: The `destroy` command destroys the entire infrastructure Terraform
    manages. It is, therefore, not a very popular command and is rarely used in a
    production environment. That does not mean that the `destroy` command is not helpful.
    Suppose you are spinning up a development infrastructure for temporary purposes
    and don’t need it later. In that case, destroying everything you created using
    this command takes a few minutes.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`destroy`：`destroy`命令销毁Terraform管理的整个基础设施。因此，它并不是一个非常受欢迎的命令，在生产环境中很少使用。不过，这并不意味着`destroy`命令没有用处。假设你正在为临时目的搭建开发环境，之后不再需要它，那么通过此命令销毁你创建的所有内容只需要几分钟。'
- en: 'To access the resources for this section, `cd` into the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，`cd`进入以下目录：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, let’s look at these in detail with hands-on exercises.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过实际操作来详细了解这些内容。
- en: terraform init
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: terraform init
- en: 'To initialize a Terraform workspace, run the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化Terraform工作区，请运行以下命令：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As the Terraform workspace has been initialized, we can create an **Azure resource
    group** to start working with the cloud.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Terraform工作区已被初始化，我们可以创建一个**Azure资源组**来开始与云进行交互。
- en: Creating the first resource – Azure resource group
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建第一个资源 – Azure资源组
- en: 'We must use the `azurerm_resource_group` resource within the `main.tf` file
    to create an Azure resource group. Add the following to your `main.tf` file to
    do so:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在`main.tf`文件中使用`azurerm_resource_group`资源来创建Azure资源组。请将以下内容添加到`main.tf`文件中：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As we’ve used two variables, we’ve got to declare those, so add the following
    to the `vars.tf` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了两个变量，因此我们需要声明它们，请将以下内容添加到`vars.tf`文件中：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we need to add the resource group name and location to the `terraform.tfvars`
    file. Therefore, add the following to the `terraform.tfvars` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将资源组名称和位置添加到`terraform.tfvars`文件中。因此，请将以下内容添加到`terraform.tfvars`文件中：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: So, now we’re ready to run a plan, but before we do so, let’s use `terraform
    fmt` to format our files into the canonical standard.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好执行计划了，但在此之前，让我们使用`terraform fmt`将我们的文件格式化为标准格式。
- en: terraform fmt
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: terraform fmt
- en: 'The `terraform fmt` command formats the `.tf` files into a canonical standard.
    Use the following command to format your files:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform fmt`命令将`.tf`文件格式化为标准格式。使用以下命令格式化你的文件：'
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The command lists the files that it formatted. The next step is to validate
    your configuration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令列出了它已格式化的文件。下一步是验证你的配置。
- en: terraform validate
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: terraform validate
- en: 'The `terraform validate` command validates the current configuration and checks
    whether there are any syntax errors. To validate your configuration, run the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform validate`命令验证当前配置，并检查是否有任何语法错误。要验证配置，请运行以下命令：'
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The success output denotes that our configuration is valid. If there were any
    errors, it would have highlighted them in the validated output.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 成功输出表示我们的配置有效。如果有任何错误，它会在验证输出中突出显示。
- en: Tip
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always run `fmt` and `validate` before every Terraform plan. It saves you a
    ton of planning time and helps you keep your configuration in good shape.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次执行Terraform计划之前，请始终运行`fmt`和`validate`。这可以节省大量规划时间，并帮助你保持配置的良好状态。
- en: As the configuration is valid, we are ready to run a plan.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于配置有效，我们可以准备运行一个计划。
- en: terraform plan
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: terraform plan
- en: 'To run a Terraform plan, use the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行Terraform计划，请使用以下命令：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `plan` output tells us that if we run `terraform apply` immediately, it
    will create a single `terraform_exercise` resource group. It also outputs a note
    that since we did not save this plan, the subsequent application is not guaranteed
    to result in the same action. Meanwhile, things might have changed; therefore,
    Terraform will rerun `plan` and prompt us for `yes` when applying. Thus, you should
    save the plan to a file if you don’t want surprises.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`plan`输出告诉我们，如果我们立即运行`terraform apply`，它将创建一个名为`terraform_exercise`的单一资源组。它还输出了一条提示，说明由于我们没有保存此计划，后续的应用操作无法保证执行相同的操作。同时，事情可能已发生变化；因此，Terraform将在应用时重新运行`plan`并提示我们输入`yes`。因此，如果不想遇到意外，应该将计划保存到文件中。'
- en: Tip
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always save `terraform plan` output to a file and use the file to apply the
    changes. This is to avoid any last-minute surprises with things that might have
    changed in the background and `apply` not doing what it is intended to do, especially
    when your plan is reviewed as a part of your process.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 始终将`terraform plan`输出保存到文件，并使用该文件来应用更改。这样可以避免最后一分钟的意外，避免背景中可能发生的变化导致`apply`没有按预期执行，尤其是在您的计划作为流程的一部分进行审查时。
- en: 'So, let’s go ahead and save the plan to a file first using the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们先使用以下命令将计划保存到文件中：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This time, the plan is saved to a file called `rg_terraform_exercise.tfplan`.
    We can use this file to apply the changes subsequently.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，计划被保存为名为`rg_terraform_exercise.tfplan`的文件。我们可以使用这个文件来随后应用更改。
- en: terraform apply
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: terraform apply
- en: 'To apply the changes using the `plan` file, run the following command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`plan`文件应用更改，请运行以下命令：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: And that’s it! Terraform has applied the configuration. Let’s use the Azure
    CLI to verify whether the resource group is created.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！Terraform已应用配置。让我们使用Azure CLI验证资源组是否已创建。
- en: 'Run the following command to list all resource groups within your subscription:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令列出您订阅中的所有资源组：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We see that our resource group is created and within the list.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到资源组已创建并出现在列表中。
- en: 'There might be instances when `apply` is partially successful. In that case,
    Terraform will automatically taint resources it believes weren’t created successfully.
    Such resources will be recreated automatically in the next run. If you want to
    taint a resource for recreation manually, you can use the `terraform` `taint`
    command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有时`apply`可能部分成功。在这种情况下，Terraform会自动标记它认为未成功创建的资源。这些资源将在下一次运行时自动重新创建。如果您希望手动标记某个资源以供重新创建，可以使用`terraform`的`taint`命令：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Suppose we want to destroy the resource group as we no longer need it. We can
    use `terraform destroy` for that.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望销毁资源组，因为我们不再需要它。我们可以使用`terraform destroy`来完成。
- en: terraform destroy
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: terraform destroy
- en: To destroy the resource group, we can run a speculative plan first. It is always
    a best practice to run a speculative plan to confirm that what we need to destroy
    is within the output to have no surprises later. Terraform, like Linux, does not
    have an undo button.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要销毁资源组，我们可以先运行一个推测性的计划。始终建议运行推测性计划，以确认我们需要销毁的内容是否包含在输出中，以免稍后出现意外。Terraform就像Linux一样，没有撤销按钮。
- en: 'To run a speculative destroy plan, use the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个推测性的销毁计划，请使用以下命令：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we see, as the resource group was the only resource managed by Terraform,
    it has listed that as the resource that will be destroyed. There are two ways
    of destroying the resource: using `terraform destroy` on its own or saving the
    speculative plan using the `out` parameter and running `terraform apply` on the
    destroy plan.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，由于资源组是Terraform管理的唯一资源，它已列出该资源作为将要销毁的资源。销毁资源有两种方式：使用`terraform destroy`单独运行，或使用`out`参数保存推测性计划后，运行`terraform
    apply`来应用销毁计划。
- en: Let’s use the first method for now.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们先使用第一种方法。
- en: 'Run the following command to destroy all resources managed by Terraform:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令销毁所有由Terraform管理的资源：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, this time, Terraform reruns `plan` and prompts for a value. It will only
    accept `yes``yes`, and hit *Enter* to confirm:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这次，Terraform重新运行`plan`并提示输入一个值。它只会接受`yes`，然后按*Enter*键确认：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: And it has now destroyed the resource group.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它已经销毁了资源组。
- en: We’ve looked at a basic root module and explored the Terraform workflow. The
    basic root module helps us create and manage resources but lacks a very important
    feature – reusability. Terraform provides us with modules to allow reusability
    for common templates. Let’s look at it in the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过一个基础的根模块，并探讨了 Terraform 的工作流程。基础根模块帮助我们创建和管理资源，但缺少一个非常重要的特性——可重用性。Terraform
    为我们提供了模块，允许我们对常见模板进行重用。在下一部分，我们将看看它。
- en: Terraform modules
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform 模块
- en: '**Terraform modules** are reusable, repeatable templates. They allow abstraction
    in provisioning infrastructure, which is much needed if your usage grows beyond
    just some proof of concept. HashiCorp visualizes modules as designed by experts
    who know the enterprise standard and used by developers who want to apply the
    enterprise standard infrastructure in their projects. That way, things are standard
    across the organization. It saves developers time and avoids duplication of efforts.
    Modules can be versioned and distributed using a **module repository** or through
    your version control. That provides infrastructure admins with an ample amount
    of power and control at the same time.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Terraform 模块**是可重用、可重复的模板。它们允许在基础设施提供过程中进行抽象，这在您的使用场景超出一些概念验证时非常需要。HashiCorp
    将模块视为由专家设计，这些专家了解企业标准，并被希望在项目中应用企业标准基础设施的开发人员使用。这样，整个组织的事情都能保持标准化。这为开发人员节省时间，避免重复劳动。模块可以版本控制并通过
    **模块仓库** 或版本控制系统分发。这同时为基础设施管理员提供了丰富的权限和控制。'
- en: 'As we created a resource group in the last section, let’s modularize that in
    the next exercise. To access the resources for this section, `cd` into the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分我们创建了资源组，接下来让我们将其模块化。在下一个练习中，为了访问该部分的资源，请执行以下操作：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Within this directory, we have the following directory structure:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在此目录中，我们有以下目录结构：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As we can see, we have the `main.tf`, `terraform.tfvars`, and `vars.tf` files
    in the root directory like before. However, we have included an additional `modules`
    directory, which contains a `resource_group` subdirectory that contains a `main.tf`
    file and a `vars.tf` file. Let’s look at both.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，根目录中我们仍然有 `main.tf`、`terraform.tfvars` 和 `vars.tf` 文件。然而，我们增加了一个 `modules`
    目录，其中包含一个 `resource_group` 子目录，里面有一个 `main.tf` 文件和一个 `vars.tf` 文件。让我们来看一下这两个文件。
- en: '`modules/resource_group/main.tf` looks like the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`modules/resource_group/main.tf` 文件如下所示：'
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It only contains an `azurerm_resource_group` resource with a name and location
    sourced from the `name` and `location` variables defined in the following `modules/resource_group/vars.tf`
    file:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 它只包含一个 `azurerm_resource_group` 资源，其名称和位置来自以下 `modules/resource_group/vars.tf`
    文件中定义的 `name` 和 `location` 变量：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the root module, which is the current directory, we’ve modified the `main.tf`
    file to look like the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在根模块中，也就是当前目录，我们已修改 `main.tf` 文件，使其如下所示：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we can see, instead of defining the resource directly in this file, we have
    defined a module called `rg`, whose `source` is `./modules/resource_group`. Note
    that we pass the value for the variables defined for the module, that is, `name`,
    and `location`, from the variables defined at the root level, that is, `var.rg_name`
    and `var.rg_location`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们没有直接在此文件中定义资源，而是定义了一个名为 `rg` 的模块，其 `source` 是 `./modules/resource_group`。请注意，我们从根级别定义的变量（即
    `var.rg_name` 和 `var.rg_location`）传递给模块中定义的变量，即 `name` 和 `location` 的值。
- en: Now, let’s go ahead and see what happens when we initialize and apply this configuration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看看当我们初始化并应用这个配置时会发生什么。
- en: 'Run the following command to initialize the Terraform workspace:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令来初始化 Terraform 工作区：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we can see, Terraform has detected the new module and initialized it during
    init.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Terraform 在初始化时已检测到新模块并对其进行了初始化。
- en: Tip
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Whenever you define a new module, you must always reinitialize Terraform.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每当定义新模块时，您必须始终重新初始化 Terraform。
- en: 'Now, let’s go ahead and run a plan using the following command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续运行以下命令来进行计划：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we can see, it will create the resource group. However, this is now a part
    of the module addressed `module.rg.azurerm_resource_group.rg`. To apply the plan,
    let’s run the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它将创建资源组。然而，这现在是模块 `module.rg.azurerm_resource_group.rg` 的一部分。要应用计划，让我们运行以下命令：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And the resource group has been created! To destroy the resource group, let’s
    run the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 资源组已创建！要销毁该资源组，让我们运行以下命令：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By using modules, you can simplify infrastructure creation and management, enhance
    collaboration among teams, and establish a consistent approach to deploying resources
    in a scalable and maintainable manner.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模块，您可以简化基础设施的创建和管理，增强团队之间的协作，并建立一种一致的方法来以可扩展和可维护的方式部署资源。
- en: Tip
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Use Terraform modules to encapsulate and reuse infrastructure configurations,
    promoting modularity and reusability.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 模块封装并重用基础设施配置，促进模块化和可重用性。
- en: Until now, we’ve seen Terraform creating and destroying resources, but how does
    Terraform know what it had created before and what it needs to destroy? Well,
    it uses a **state file** for that. Let’s have a look.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们已经看到 Terraform 创建和销毁资源，但 Terraform 如何知道它之前创建了什么以及需要销毁什么呢？嗯，它使用**状态文件**来解决这个问题。我们来看看。
- en: Managing Terraform state
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 Terraform 状态
- en: Terraform uses a state file to track what it has deployed and what resources
    it is managing. The state file is essential as it records all the infrastructure
    Terraform maintains. If you lose it, Terraform will lose track of what it has
    done so far and start treating resources as new and needing to be created again.
    Therefore, you should protect your state as code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 使用状态文件来跟踪已部署的内容及其管理的资源。状态文件至关重要，因为它记录了 Terraform 维护的所有基础设施。如果丢失了状态文件，Terraform
    将无法追踪已执行的操作，并且会将资源当作新的、需要重新创建的资源。因此，您应该像代码一样保护状态文件。
- en: 'Terraform stores state in backends. By default, Terraform stores the state
    file as `terraform.tfstate` within the `workspace` directory, which is called
    the local backend. However, that is not the best way of managing the state. There
    are a couple of reasons why you should not store state in a local system:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 将状态存储在后端。默认情况下，Terraform 将状态文件存储为 `terraform.tfstate`，并放置在 `workspace`
    目录中，这称为本地后端。然而，这并不是管理状态的最佳方式。您不应将状态存储在本地系统中，原因有几个：
- en: Multiple admins cannot work on the same infrastructure if the state file is
    stored within someone’s local directory
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态文件存储在某人的本地目录中，多个管理员无法共同操作同一基础设施。
- en: Local workstations are not backed up; therefore, the risk of losing the state
    file is high even if you have a single admin doing the job
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地工作站没有备份；因此，即使只有一个管理员在执行任务，丢失状态文件的风险仍然很高。
- en: You might argue that we can resolve these problems by checking the state file
    into source control with the `.tf` files. Don’t do that! State files are plaintext,
    and if your infrastructure configuration contains sensitive information such as
    passwords, anyone can see it. Therefore, you need to store a state file securely.
    Also, storing state files in source control does not provide state locking, resulting
    in conflicts if multiple people are simultaneously modifying the state file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会争辩说，我们可以通过将状态文件与 `.tf` 文件一起检查到源代码管理中来解决这些问题。不要这样做！状态文件是纯文本的，如果您的基础设施配置包含敏感信息，如密码，任何人都可以看到它。因此，您需要安全存储状态文件。此外，将状态文件存储在源代码管理中并不能提供状态锁定功能，如果多人同时修改状态文件，会导致冲突。
- en: Tip
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Never store state files in source control. Use a `.gitignore` file entry to
    bypass the `terraform.tfstate` file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要将状态文件存储在源代码管理中。使用 `.gitignore` 文件条目跳过 `terraform.tfstate` 文件。
- en: The best place to store your Terraform state is on remote cloud storage. Terraform
    provides a remote backend to store state remotely. There are multiple types of
    remote backends you can use. When writing this book, `plan` and `apply` within
    the backend, and only Terraform Cloud and Enterprise support it.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 存储 Terraform 状态的最佳位置是远程云存储。Terraform 提供了远程后端来远程存储状态。您可以使用多种类型的远程后端。当编写本书时，`plan`
    和 `apply` 在后端运行，只有 Terraform Cloud 和 Enterprise 支持这一功能。
- en: Tip
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: While choosing the state storage solution, you should prefer storage with state
    locking. That will allow multiple people to manipulate the resources without stepping
    on each other’s shoes and causing conflict, as once a state file is locked, others
    cannot acquire it until the lock is released.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择状态存储方案时，您应该优先选择支持状态锁定的存储。这将允许多人操作资源而不互相干扰，一旦状态文件被锁定，其他人将无法获取它，直到锁定被释放。
- en: 'As we’re using Azure, we can use Azure Storage to store our state. The advantages
    are three-fold:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 Azure，因此可以使用 Azure 存储来保存状态。其优点有三：
- en: Your state file is centralized. You can have multiple admins working together
    and managing the same infrastructure.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的状态文件是集中管理的。您可以让多个管理员一起工作并管理相同的基础设施。
- en: The store is encrypted at rest.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在休眠状态下是加密的。
- en: You get automatic backup, redundancy, and high availability.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你将获得自动备份、冗余和高可用性。
- en: 'To access the resources for this section, `cd` into the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，`cd`到以下目录：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Let’s now use the `azurerm` backend and use Azure Storage to persist our Terraform
    state.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`azurerm`后端，并使用Azure存储来持久化我们的Terraform状态。
- en: Using the Azure Storage backend
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Azure存储后端
- en: As we will end up in a chicken-or-egg situation if we use Terraform to build
    a backend to store its state, we will have to configure this bit without using
    Terraform.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于如果我们使用Terraform来构建存储其状态的后端，我们将陷入“鸡和蛋”的局面，所以我们必须在不使用Terraform的情况下配置这部分内容。
- en: Therefore, let’s use the `az` command to configure the storage account in a
    different resource group that Terraform will not manage.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用`az`命令在一个Terraform不会管理的不同资源组中配置存储帐户。
- en: Creating Azure Storage resources
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Azure存储资源
- en: 'Let’s start by defining a few variables:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义一些变量开始：
- en: '`$` `RESOURCE_GROUP=tfstate`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` `RESOURCE_GROUP=tfstate`'
- en: '`$` `STORAGE_ACCOUNT_NAME=tfstate$RANDOM`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` `STORAGE_ACCOUNT_NAME=tfstate$RANDOM`'
- en: '`$` `CONTAINER_NAME=tfstate`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$` `CONTAINER_NAME=tfstate`'
- en: 'Create a resource group first using the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令创建资源组：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let’s go ahead and create a storage account within the resource group
    using the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续使用以下命令在资源组内创建一个存储帐户：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The next step is to fetch the account key using the following command:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用以下命令获取帐户密钥：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, we can go ahead and create a Blob Storage container using the following
    command:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令创建一个Blob存储容器：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If we receive a `created` response, the storage account is created and ready
    for use. Now, we can go and define the backend configuration file in Terraform.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们收到`created`响应，则表示存储帐户已创建并准备就绪。现在，我们可以继续在Terraform中定义后端配置文件。
- en: Creating a backend configuration in Terraform
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Terraform中创建后端配置
- en: 'Before we create the backend, we will need the `STORAGE_ACCOUNT_NAME` value.
    To get this, run the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建后端之前，我们需要`STORAGE_ACCOUNT_NAME`的值。要获取此值，请运行以下命令：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To create the backend configuration in Terraform, create a file called `backend.tf`
    within the workspace:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Terraform中创建后端配置，创建一个名为`backend.tf`的文件，并放在工作区内：
- en: '[PRE43]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the backend configuration, we’ve defined the `resource_group_name` backend
    where the Blob Storage instance exists – `storage_account_name`, `container_name`,
    and `key`. The `key` attribute specifies the filename that we will use to define
    the state of this configuration. There might be multiple projects that you are
    managing using Terraform, and all of them will need separate state files. Therefore,
    the `key` attribute defines the state file’s name that we will use for our project.
    That allows multiple Terraform projects to use the same Azure Blob Storage to
    store the state.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端配置中，我们定义了`resource_group_name`后端，其中存在Blob存储实例 —— `storage_account_name`，`container_name`和`key`。`key`属性指定我们将用于定义此配置状态的文件名。你可能会使用Terraform管理多个项目，它们都需要单独的状态文件。因此，`key`属性定义了我们将为项目使用的状态文件的名称。这使得多个Terraform项目可以使用相同的Azure
    Blob存储来存储状态。
- en: Tip
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always use the name of the project as the name of the key. For example, if your
    project name is `foo`, name the key `foo.tfstate`. That will prevent potential
    conflicts with others and also allow you to locate your state file quickly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用项目的名称作为`key`的名称。例如，如果你的项目名称是`foo`，则将`key`命名为`foo.tfstate`。这样可以防止与其他项目发生潜在冲突，并且还可以让你快速找到状态文件。
- en: 'To initialize the Terraform workspace with the new backend configuration, run
    the following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用新的后端配置初始化Terraform工作区，请运行以下命令：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When we initialize that, Terraform detects that the backend has changed and
    checks whether anything is available in the existing backend. If it finds something,
    it asks whether we want to migrate the current state to the new backend. If it
    does not, it automatically switches to the new backend, as we see here.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化时，Terraform会检测到后端已更改，并检查现有后端中是否有任何内容。如果它找到内容，它会询问是否要将当前状态迁移到新后端。如果没有，它会自动切换到新后端，就像我们在这里看到的那样。
- en: 'Now, let’s go ahead and use the `terraform plan` command to run a plan:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续使用`terraform plan`命令来运行计划：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So, as we see, `terraform plan` tells us that it will create a new resource
    group called `terraform-exercise`. Let’s apply the configuration, and this time
    with an `auto-approve` flag so that the plan does not run again, and Terraform
    immediately applies the changes using the following command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`terraform plan` 告诉我们，它将创建一个名为 `terraform-exercise` 的新资源组。让我们应用这个配置，这次使用`auto-approve`标志，这样计划就不会再次运行，Terraform
    会立即应用更改，使用以下命令：
- en: '[PRE46]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We now have the resource created successfully.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经成功创建了资源。
- en: 'Now, let’s go to Azure Blob Storage and see whether we have a `tfstate` file
    there, as shown in the following screenshot:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们去 Azure Blob 存储查看是否有一个 `tfstate` 文件，如下图所示：
- en: '![Figure 8.2 – Terraform state](img/B19877_08_2.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – Terraform 状态](img/B19877_08_2.jpg)'
- en: Figure 8.2 – Terraform state
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – Terraform 状态
- en: As we see, we have a file called `example.tfstate` within the blob container.
    That is how remote storage works, and now anyone with access to the Blob Storage
    instance can use the Terraform configuration and make changes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在 Blob 容器中有一个名为`example.tfstate`的文件。这就是远程存储的工作方式，现在任何有权限访问 Blob 存储实例的人都可以使用
    Terraform 配置并进行更改。
- en: So far, we’ve been managing resources using the default workspace, but what
    if there are multiple environments that you need to control using the same configuration?
    Well, Terraform offers workspaces for those scenarios.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用默认工作区管理资源，但如果有多个环境需要使用相同的配置进行控制怎么办？好吧，Terraform 为这些场景提供了工作区。
- en: Terraform workspaces
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform 工作区
- en: Software development requires multiple environments. You develop software within
    your workspace, deploy it into the development environment, unit test it, and
    then promote the tested code to a test environment. Your QA team will test the
    code extensively in the test environment, and once all test cases pass, you can
    promote your code to production.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发需要多个环境。你在工作区内开发软件，将其部署到开发环境，进行单元测试，然后将经过测试的代码提升到测试环境。你的 QA 团队将在测试环境中对代码进行广泛的测试，一旦所有测试用例通过，你就可以将代码推广到生产环境。
- en: That means you must maintain a similar infrastructure in all environments. With
    an IaC tool such as Terraform, infrastructure is represented as code, and we must
    manage our code to fit multiple environments. But Terraform isn’t just code; it
    also contains state files, and we must maintain state files for every environment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你必须在所有环境中保持类似的基础设施。借助像 Terraform 这样的 IaC 工具，基础设施以代码的形式呈现，我们必须管理我们的代码以适应多个环境。但
    Terraform 不仅仅是代码；它还包含状态文件，我们必须为每个环境维护状态文件。
- en: Suppose you want to create three resource groups, `terraform-exercise-dev`,
    `terraform-exercise-test`, and `terraform-exercise-prod`. Each resource group
    will contain a similar set of infrastructure with similar properties. For example,
    each resource group includes an Ubuntu **Virtual** **Machine** (**VM**).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建三个资源组，分别是 `terraform-exercise-dev`、`terraform-exercise-test` 和 `terraform-exercise-prod`。每个资源组将包含一组相似的基础设施，具有类似的属性。例如，每个资源组都包括一个
    Ubuntu **虚拟** **机**（**VM**）。
- en: 'A simple method to approach the problem is by creating a structure like the
    following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的一种简单方法是创建如下结构：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Can you see the duplication? The same files occur multiple times, all containing
    the same configuration. The only thing that might change is the `terraform.tfvars`
    file for each environment.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看到重复吗？相同的文件多次出现，所有文件都包含相同的配置。唯一可能改变的是每个环境的 `terraform.tfvars` 文件。
- en: So, this does not sound like a great way to approach this problem, and that’s
    why Terraform provides workspaces for it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这听起来并不是一个很好的解决方法，这就是为什么 Terraform 为此提供了工作区。
- en: '**Terraform workspaces** are nothing but independent state files. So, you have
    a single configuration and multiple state files for each environment. Sounds simple,
    right? Let’s have a look.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**Terraform 工作区**仅仅是独立的状态文件。所以，你有一个配置和多个状态文件，每个环境都有一个。听起来很简单，对吧？让我们看一看。'
- en: 'Another way to represent the same configuration by using Terraform workspaces
    is the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform 工作区表示相同配置的另一种方式如下：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Now, this looks simple. It just contains a single set of files. Let’s have a
    look at each of them to understand them better.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这看起来很简单。它只包含一组文件。让我们逐一查看它们，以便更好地理解它们。
- en: 'To access the resources for this section, `cd` into the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，请`cd`到以下位置：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `main.tf` file contains a `resource_group` resource with a name that includes
    an environment suffix, along with other resources that we need to create within
    the resource group, such as the VNet, subnet, and VM, something like the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`main.tf`文件包含一个`resource_group`资源，其名称包括环境后缀，以及我们需要在该资源组内创建的其他资源，如VNet、子网和VM，类似以下内容：'
- en: '[PRE50]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To access the name of the workspace, Terraform provides the `terraform.workspace`
    variable, which we have used to define the `resource_group` name. So, the template
    is now ready to take configuration for any environment, and we will have a separate
    resource group for each environment.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问工作区的名称，Terraform提供了`terraform.workspace`变量，我们已使用该变量定义`resource_group`名称。所以，模板现在已准备好接受任何环境的配置，并且我们将为每个环境创建一个独立的资源组。
- en: 'Also, update the `backend.tf` file with the `tfstate` container name we created
    in the last section and initialize the Terraform workspace by using the following
    command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，更新`backend.tf`文件，添加我们在上一节中创建的`tfstate`容器名称，并使用以下命令初始化Terraform工作区：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, once Terraform has initialized, let’s create a `dev` workspace by using
    the following command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦Terraform初始化完成，让我们使用以下命令创建一个`dev`工作区：
- en: '[PRE52]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You’re now in a new, empty workspace. Workspaces isolate their state, so if
    you run `terraform plan`, Terraform will not see any existing state for this configuration.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在处于一个新的、空的工作区。工作区会隔离其状态，因此如果你运行`terraform plan`，Terraform将不会看到此配置的任何现有状态。
- en: So, as we’re in a new, empty workspace called `dev`, let’s run a plan.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，既然我们处于一个名为`dev`的新空工作区，让我们运行一个计划。
- en: 'Use the following command to run a plan on the `dev` environment:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令在`dev`环境中运行计划：
- en: '[PRE53]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let’s go ahead and apply the plan using the following command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续使用以下命令应用该计划：
- en: '[PRE54]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As the `dev` plan has been applied and the resources are created in the `dev`
    resource group, let’s create a workspace for testing:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`dev`计划已被应用，资源已创建在`dev`资源组中，我们来创建一个测试用的工作区：
- en: '[PRE55]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As the new workspace is created, let’s run a plan on the test workspace using
    the following command and save it to the `test.tfplan` file:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新工作区已创建，让我们使用以下命令在测试工作区运行计划，并将其保存到`test.tfplan`文件中：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As we can see, the resources will be created in the `terraform-ws-test` resource
    group. So, let’s go ahead and apply the plan using the following command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，资源将被创建在`terraform-ws-test`资源组中。所以，让我们继续使用以下命令应用计划：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `test` plan has been applied as well. Now let’s go ahead and inspect the
    created resources.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`test`计划也已经应用。现在让我们继续检查已创建的资源。'
- en: Tip
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Terraform workspaces are ideal for maintaining separate infrastructure configurations
    for different environments, such as development, staging, and production. This
    helps prevent accidental configuration changes and ensures consistent setups.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform工作区非常适合为不同的环境（如开发、预生产和生产）维护独立的基础设施配置。这有助于防止意外的配置更改，并确保一致的设置。
- en: Inspecting resources
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查资源
- en: 'Let’s use the `az` command to list the resource groups. As we know, our resource
    groups have a resource group prefix of `terraform-ws`. Therefore, use the following
    command to list all resource groups containing the prefix:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`az`命令列出资源组。如我们所知，我们的资源组有一个前缀`terraform-ws`。因此，使用以下命令列出所有包含该前缀的资源组：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we can see, we have two resource groups, `terraform-ws-dev` and `terraform-ws-test`.
    So, two resource groups have been created successfully.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们有两个资源组，`terraform-ws-dev`和`terraform-ws-test`。所以，两个资源组已成功创建。
- en: 'You can also verify this in the Azure portal, as shown in the following screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在Azure门户中验证这一点，如下图所示：
- en: '![Figure 8.3 – Resource groups](img/B19877_08_3.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 资源组](img/B19877_08_3.jpg)'
- en: Figure 8.3 – Resource groups
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 资源组
- en: 'Now, let’s go ahead and inspect the resources on the `terraform-ws-dev` resource
    group using the Azure portal by clicking on `terraform-ws-dev`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用Azure门户，通过点击`terraform-ws-dev`来检查`terraform-ws-dev`资源组中的资源：
- en: '![Figure 8.4 – Terraform dev resource group](img/B19877_08_4.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – Terraform开发资源组](img/B19877_08_4.jpg)'
- en: Figure 8.4 – Terraform dev resource group
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – Terraform开发资源组
- en: 'We have a virtual network, a network interface, an OS disk, and a VM within
    the resource group. We should expect similar resources with the same names in
    the `terraform-ws-test` resource group. Let’s go ahead and have a look:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在资源组中有一个虚拟网络、一个网络接口、一个操作系统磁盘和一台虚拟机。我们应该期待在`terraform-ws-test`资源组中有相同名称的类似资源。让我们来看看：
- en: '![Figure 8.5 – Terraform test resource group](img/B19877_08_5.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – Terraform 测试资源组](img/B19877_08_5.jpg)'
- en: Figure 8.5 – Terraform test resource group
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – Terraform 测试资源组
- en: As we can see, we also have similar resources in the `terraform-ws-test` resource
    group.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们在 `terraform-ws-test` 资源组中也有类似的资源。
- en: We did all this using a single configuration, but there should be two state
    files for each workspace since they are two sets of resources. Let’s have a look.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一个配置完成了所有这些操作，但由于它们是两组资源，每个工作空间应该有两个状态文件。让我们来看一下。
- en: Inspecting state files
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查状态文件
- en: 'If we had used the local backend for the state files, we would get the following
    structure:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用本地后端来存储状态文件，我们将得到以下结构：
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: So, Terraform creates a directory called `terrafom.tfstate.d`; within that,
    it creates directories for each workspace. Within the directories, it stores the
    state file for each workspace as `terraform.tfstate`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，Terraform 创建了一个名为 `terrafom.tfstate.d` 的目录；在这个目录下，它为每个工作空间创建了相应的子目录。在这些子目录中，它将每个工作空间的状态文件保存为
    `terraform.tfstate`。
- en: 'But since we are using a remote backend and using Azure Blob Storage for it,
    let’s inspect the files within it using the Azure console:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于我们使用的是远程后端，并且使用 Azure Blob 存储来存储它，让我们通过 Azure 控制台检查其中的文件：
- en: '![Figure 8.6 – Terraform workspace state](img/B19877_08_6.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – Terraform 工作空间状态](img/B19877_08_6.jpg)'
- en: Figure 8.6 – Terraform workspace state
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – Terraform 工作空间状态
- en: As we see, there are two state files, one for each environment. Therefore, the
    state files are suffixed with an `env:dev` or `env:test` string. That is how workspaces
    are managed in Azure Blob Storage. The remote backend’s structure for maintaining
    state files depends on the provider plugins, and therefore, there might be different
    ways of managing multiple states for various backends. However, the Terraform
    CLI will interpret workspaces the same way, irrespective of the backends, so nothing
    changes for the end user from a CLI perspective.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，有两个状态文件，每个环境一个。因此，状态文件的后缀分别是 `env:dev` 或 `env:test` 字符串。这就是在 Azure Blob
    存储中管理工作空间的方式。远程后端用于维护状态文件的结构取决于提供商插件，因此，管理多个后端的状态可能会有不同的方式。但是，Terraform CLI 会以相同的方式解释工作空间，无论后端如何，因此，从
    CLI 角度来看，最终用户没有变化。
- en: Cleaning up
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理
- en: Now, let’s go ahead and clean up both resource groups to avoid unnecessary charges.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续清理这两个资源组，以避免不必要的费用。
- en: 'As we’re already within the test workspace, let’s run the following command
    to destroy resources within the test workspace:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在测试工作空间内，让我们运行以下命令销毁测试工作空间中的资源：
- en: '[PRE60]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, let’s switch to the `dev` workspace using the following command:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令切换到 `dev` 工作空间：
- en: '[PRE61]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As we’re within the `dev` workspace, use the following command to destroy all
    resources within the `dev` workspace:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在 `dev` 工作空间中，使用以下命令销毁 `dev` 工作空间中的所有资源：
- en: '[PRE62]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In a while, we should see that both resource groups are gone. Now, let’s look
    at some of the advanced concepts of Terraform in the next section.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们应该能看到两个资源组已经消失。接下来，让我们在下一节中了解一些 Terraform 的高级概念。
- en: Terraform output, state, console, and graphs
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform 输出、状态、控制台和图表
- en: While we understand that Terraform uses state files to manage resources, let’s
    look at some advanced commands to help us appreciate and make more sense of the
    Terraform state concept.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们知道 Terraform 使用状态文件来管理资源，但让我们来看一些高级命令，帮助我们更好地理解和掌握 Terraform 状态的概念。
- en: 'To access the resources for this section, `cd` into the following:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节中的资源，`cd` 到以下路径：
- en: '[PRE63]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Now, let’s go ahead and look at our first command – `terraform output`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下我们的第一个命令——`terraform output`。
- en: terraform output
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: terraform 输出
- en: So far, we’ve looked at variables but haven’t yet discussed outputs. Terraform
    outputs are return values of a Terraform configuration that allow users to export
    configuration to users or any modules that might use the current module.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了变量，但还没有讨论输出。Terraform 输出是 Terraform 配置的返回值，允许用户将配置导出给用户或任何可能使用当前模块的模块。
- en: 'Let’s go with the last example and add an output variable that exports the
    private IP of the network interface attached to the VM in the `outputs.tf` file:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续上一个例子，在 `outputs.tf` 文件中添加一个输出变量，用来导出附加到虚拟机的网络接口的私有 IP：
- en: '[PRE64]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, let’s go ahead and apply the configuration:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续应用配置：
- en: '[PRE65]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'After Terraform has applied the configuration, it shows the outputs at the
    end of the console result. You can run the following to inspect the output anytime
    later:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在Terraform应用配置后，它会在控制台结果的末尾显示输出。你可以随时运行以下命令来检查输出：
- en: '[PRE66]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Outputs are stored in the state file like everything else, so let’s look at
    how we can manage Terraform state using the CLI.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 输出像其他内容一样存储在状态文件中，因此让我们来看一下如何使用CLI管理Terraform状态。
- en: Managing Terraform state
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理Terraform状态
- en: Terraform stores the configuration it manages in state files and therefore provides
    a command for advanced state management. The `terraform state` command helps you
    manage the state of the current configuration. While the state file is plaintext
    and you can manually modify it, using the `terraform state` command is recommended.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform将其管理的配置存储在状态文件中，因此提供了一个用于高级状态管理的命令。`terraform state`命令帮助你管理当前配置的状态。尽管状态文件是纯文本格式的，你可以手动修改它，但推荐使用`terraform
    state`命令。
- en: But before we get into details, we must understand why we want to do that. Things
    might not always go according to plan, so the state file may have corrupt data.
    You also might want to see specific attributes of a particular resource after
    you’ve applied it. The state file might need to be investigated for the root cause
    analysis of a specific infrastructure provisioning problem. Let’s have a look
    at the most common use cases.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入讨论细节之前，我们必须了解为什么要这么做。事情可能不会总是按计划进行，因此状态文件可能包含损坏的数据。你可能还想在应用某个资源后查看该资源的特定属性。状态文件可能需要进行调查，以便进行特定基础设施配置问题的根本原因分析。让我们看看最常见的使用场景。
- en: Viewing the current state
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看当前状态
- en: 'To view the current state, we can run the following command:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前状态，我们可以运行以下命令：
- en: '[PRE67]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: That will output all resources that Terraform has created and manages, including
    outputs. Of course, this can be overwhelming for some, and we may want to view
    the list of resources Terraform manages.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出所有Terraform创建和管理的资源，包括输出内容。当然，对于一些人来说，这可能会显得信息过载，我们可能只想查看Terraform管理的资源列表。
- en: Listing resources in the current state
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出当前状态中的资源
- en: 'To list the resources in the Terraform state file, run the following command:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出Terraform状态文件中的资源，可以运行以下命令：
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: And as we see, there are five resources managed by Terraform. You might want
    to remove a resource from the Terraform state. It might be possible that someone
    has removed a resource manually as it is no longer required, but it isn’t removed
    from the Terraform configuration.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Terraform管理着五个资源。你可能希望将某个资源从Terraform状态中移除。也许有人手动移除了某个资源，因为它不再需要，但它并未从Terraform配置中移除。
- en: Removing a resource from the state
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从状态中移除资源
- en: 'To remove a state manually from the Terraform state file, you must use the
    `terraform state rm <resource>` command. For example, to remove the Azure VM resource
    from the Terraform state, run the following command:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动从Terraform状态文件中移除状态，必须使用`terraform state rm <resource>`命令。例如，要从Terraform状态中移除Azure虚拟机资源，可以运行以下命令：
- en: '[PRE69]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Bear in mind that this has merely removed the resource from the state file and
    has not touched the actual resource sitting on Azure.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这仅仅是从状态文件中移除了该资源，实际在Azure上存在的资源并未受到影响。
- en: There might be instances where someone spun up a VM manually within Azure, and
    we now want Terraform to manage it. This kind of situation happens mostly in brownfield
    projects. In that case, we must declare the same configuration within Terraform
    and then import existing resources in the Terraform state. To do so, we can use
    the `terraform` `import` command.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有某些情况，其中有人在Azure中手动创建了虚拟机，而我们现在希望Terraform来管理它。这种情况大多发生在棕地项目中。在这种情况下，我们必须在Terraform中声明相同的配置，然后将现有资源导入到Terraform状态中。为此，我们可以使用`terraform
    import`命令。
- en: Importing existing resources into Terraform state
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将现有资源导入Terraform状态
- en: 'You can use the `terraform import` command to import existing resources into
    Terraform state. The `terraform import` command is structured as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`terraform import`命令将现有资源导入到Terraform状态中。`terraform import`命令的结构如下：
- en: '[PRE70]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For example, to reimport the `httpd` VM into the state, run the following command:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将`httpd`虚拟机重新导入状态，可以运行以下命令：
- en: '[PRE71]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To check whether the resource is imported to the state, we can list the resources
    again using the following command:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查资源是否已导入状态，我们可以再次列出资源，使用以下命令：
- en: '[PRE72]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As we see, we have the VM within the state file. If we want to dig further into
    the resources, we can use `terraform console`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，VM 已经存在于状态文件中。如果我们想进一步了解资源，可以使用 `terraform console`。
- en: terraform console
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: terraform console
- en: The `terraform console` command provides an interactive console to investigate
    state files, dynamically build paths, and evaluate expressions even before using
    them in resources. It is a potent tool that most advanced Terraform users use.
    For example, let’s launch the console and look through the configuration of the
    VM resource we just imported.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform console` 命令提供了一个交互式控制台，用于调查状态文件、动态构建路径并在使用资源之前评估表达式。这是一个强大的工具，大多数高级
    Terraform 用户都在使用它。例如，我们启动控制台并查看我们刚刚导入的 VM 资源配置。'
- en: 'Use the following commands to launch the console and get the resource group
    of the VM and the `id` value:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动控制台并获取 VM 的资源组和 `id` 值：
- en: '[PRE73]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As we can see, the VM is in the correct resource group, and we’re satisfied
    that the import was correct.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，VM 位于正确的资源组中，我们确认导入操作是正确的。
- en: Terraform dependencies and graphs
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform 依赖关系和图形
- en: Terraform uses a dependency model to manage in what order resources are created
    and destroyed. There are two kinds of dependencies – *implicit* and *explicit*.
    We’ve been using implicit dependencies until now, where the VM depended upon the
    network interface, and the network interface depended upon the subnet. The subnet
    depended upon the virtual network, and all of these resources depended on the
    resource group. These dependencies naturally occur when we use one resource’s
    output as another’s input.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 使用依赖模型来管理资源的创建和销毁顺序。有两种依赖关系——*隐式*和*显式*。直到现在，我们一直在使用隐式依赖关系，其中 VM 依赖于网络接口，网络接口依赖于子网，子网依赖于虚拟网络，所有这些资源都依赖于资源组。这些依赖关系通常发生在我们将一个资源的输出作为另一个资源的输入时。
- en: However, sometimes, we want to define an explicit dependency on a resource,
    especially when there is no way to define an implicit dependency on it. You can
    use the `depends_on` attribute for that kind of operation.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们希望显式定义资源之间的依赖关系，尤其是当没有方法定义隐式依赖时。你可以使用 `depends_on` 属性来进行这种操作。
- en: Tip
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Avoid explicit dependencies unless needed, as Terraform uses parallelism to
    manage resources. If explicit dependencies are not required, it will slow down
    Terraform runs because it can process multiple parallel resources.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 除非必要，否则避免使用显式依赖关系，因为 Terraform 使用并行处理来管理资源。如果不需要显式依赖关系，它将加速 Terraform 运行，因为它可以并行处理多个资源。
- en: To visualize the dependencies between resources, we can export a graph from
    the state file and convert that into a PNG file using a tool such as **Graphviz**.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化资源之间的依赖关系，我们可以从状态文件导出图形，并使用像**Graphviz**这样的工具将其转换为 PNG 文件。
- en: 'Run the following command to export the dependency graph:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令导出依赖图：
- en: '[PRE74]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We can then process the graph file using the Graphviz tool. To install the
    tool on Ubuntu, run the following command:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用 Graphviz 工具处理图形文件。在 Ubuntu 上安装该工具，运行以下命令：
- en: '[PRE75]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now run the following command to convert the graph file into a PNG file:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行以下命令将图形文件转换为 PNG 文件：
- en: '[PRE76]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The graph is available at [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e/blob/main/ch8/terraform-graph.png](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e/blob/main/ch8/terraform-graph.png).
    Now, let’s go ahead and see how we can clean up our resources.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图形可以在 [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e/blob/main/ch8/terraform-graph.png](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e/blob/main/ch8/terraform-graph.png)
    处查看。现在，让我们继续查看如何清理资源。
- en: Cleaning up resources
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理资源
- en: 'As we already know, we run the following command to clean up the resources:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，我们运行以下命令来清理资源：
- en: '[PRE77]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: It will clear resources from the resource group and delete the resource group
    after that.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 它将清除资源组中的资源，并在此之后删除资源组。
- en: While using `terraform destroy` can be an easy way to eliminate resources you
    don’t need, it is best if you stick to this only in the `dev` environment and
    never use it in production. Instead, you can remove resources you don’t need from
    the configuration and then run `terraform apply`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 `terraform destroy` 可以轻松删除不需要的资源，但最好只在 `dev` 环境中使用它，绝不要在生产环境中使用。相反，你可以从配置中删除不需要的资源，然后运行
    `terraform apply`。
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we’ve discussed Terraform’s core and understood some of the
    most common commands and functionalities from a hands-on perspective. We started
    with understanding IaC, introduced Terraform as an IaC tool, installed Terraform,
    understood Terraform providers, and used the Azure Terraform provider to manage
    infrastructure in Azure.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Terraform的核心内容，并从实践角度理解了一些最常见的命令和功能。我们从理解IaC开始，介绍了Terraform作为IaC工具，安装了Terraform，了解了Terraform提供程序，并使用Azure
    Terraform提供程序管理Azure中的基础设施。
- en: We then looked at Terraform variables and multiple ways of supplying values
    to the variables. We discussed the core Terraform workflow and several commands
    you would use to manage infrastructure using Terraform. We then looked at Terraform
    modules and then at Terraform state as an essential component that helps Terraform
    keep track of the infrastructure it is managing.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们看了Terraform变量以及多种为变量提供值的方式。我们讨论了核心的Terraform工作流程以及你将用来管理基础设施的几个命令。然后，我们看了Terraform模块，接着看了Terraform状态，作为一个重要组成部分，帮助Terraform跟踪它所管理的基础设施。
- en: We looked at local and remote state storage and used Azure Blob Storage as the
    remote state backend. We then discussed Terraform workspaces and how they enable
    us to use the same Terraform configuration to build multiple environments with
    hands-on exercises.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了本地和远程状态存储，并使用Azure Blob存储作为远程状态后端。接着，我们讨论了Terraform工作空间，以及它们如何通过实践操作使我们能够使用相同的Terraform配置构建多个环境。
- en: We then looked at some advanced operations with Terraform state using the `outputs`,
    `state`, and `console` commands. We finally looked at how Terraform manages dependencies
    and viewed a dependency graph using the `graph` command.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们看了一些关于Terraform状态的高级操作，使用了`outputs`、`state`和`console`命令。最后，我们查看了Terraform如何管理依赖关系，并使用`graph`命令查看了依赖图。
- en: In the next chapter, we will delve into configuration management using Ansible.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入讨论使用Ansible的配置管理。
- en: Questions
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why should we constrain the provider version?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们应该限制提供程序版本？
- en: You should always use the `fmt` and `validate` functions before a Terraform
    plan. (True/False)
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该始终在Terraform计划之前使用`fmt`和`validate`函数。（对/错）
- en: What does the Terraform `plan` command do? (Choose two)
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Terraform `plan`命令做什么？（选择两个）
- en: A. Refreshes the current state with the existing infrastructure state
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 刷新当前状态与现有基础设施状态
- en: B. Gets the delta between the current configuration and the expected configuration
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 获取当前配置与预期配置之间的差异
- en: C. Applies the configuration to the cloud
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 将配置应用于云端
- en: D. Destroys the configuration in the cloud
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 销毁云端的配置
- en: What does the `terraform apply` command do? (Choose three)
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`terraform apply`命令做什么？（选择三个）'
- en: A. Refreshes the current state with the existing infrastructure
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 刷新当前状态与现有基础设施
- en: B. Gets the delta between the current configuration and the expected configuration
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 获取当前配置与预期配置之间的差异
- en: C. Applies the configuration to the cloud
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 将配置应用于云端
- en: D. Destroys the configuration in the cloud
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 销毁云端的配置
- en: Why should you never store state files in source control? (Choose two)
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你绝不应该将状态文件存储在源代码管理中？（选择两个）
- en: A. State files are plaintext, and therefore you expose sensitive information
    to unprivileged users.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 状态文件是纯文本的，因此你暴露了敏感信息给没有权限的用户。
- en: B. Source control does not support state locking, and therefore it might result
    in potential conflicts between users.
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 源代码管理不支持状态锁定，因此可能会导致用户之间的潜在冲突。
- en: C. Multiple admins cannot work on the same configuration.
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 多个管理员不能同时在同一配置上工作。
- en: Which of the following are valid Terraform remote backends? (Choose five)
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是有效的Terraform远程后端？（选择五个）
- en: A. S3
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. S3
- en: B. Azure Blob Storage
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. Azure Blob存储
- en: C. Artifactory
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Artifactory
- en: D. Git
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. Git
- en: E. HTTP
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: E. HTTP
- en: F. Terraform Enterprise
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: F. Terraform企业版
- en: Which command will mark a resource for recreation in the next `apply`?
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令将在下次`apply`中标记一个资源以供重建？
- en: Where are state files stored in the local backend if you use workspaces?
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用工作空间，本地后端中的状态文件存储在哪里？
- en: What command should we use to remove a Terraform resource from the state?
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用什么命令将Terraform资源从状态中移除？
- en: What command should we use to import an existing cloud resource within the state?
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用什么命令将现有的云资源导入到状态中？
- en: Answers
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Because Terraform providers are released separately to the Terraform CLI, different
    versions might break the existing configuration
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为Terraform提供程序是单独发布到Terraform CLI的，不同版本可能会破坏现有配置
- en: 'True'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对
- en: A, B
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B
- en: A, B, C
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B, C
- en: A, B
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B
- en: A, B, C, E, F
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B, C, E, F
- en: The `taint` command
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`taint` 命令'
- en: '`terraform.tfstate.d`'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`terraform.tfstate.d`'
- en: '`terraform state` `rm <resource>`'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`terraform state` `rm <resource>`'
- en: '`terraform import <``resource> <id>`'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`terraform import <``resource> <id>`'
