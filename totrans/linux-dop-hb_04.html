<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer014">
<h1 class="chapter-number" id="_idParaDest-69"><a id="_idTextAnchor063"/><a id="_idTextAnchor064"/>4</h1>
<h1 id="_idParaDest-70"><a id="_idTextAnchor065"/>Automating with Shell Scripts</h1>
<p>In this chapter, we’re going to demonstrate system administration task automation with shell scripts. We are going to illustrate several ways of handling scripting using Bash shell. The plan is to create a script that will automate the creation of the database dump. This task, while easy, will demonstrate how things can go sideways and how to handle <span class="No-Break">those situations.</span></p>
<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Backing up <span class="No-Break">a database</span></li>
<li><span class="No-Break">Understanding scripting</span></li>
<li>Understanding Bash built-ins <span class="No-Break">and grammar</span></li>
<li>Understanding the backup script – <span class="No-Break">first steps</span></li>
<li>Handling errors <span class="No-Break">and debugging</span></li>
</ul>
<h1 id="_idParaDest-71"><a id="_idTextAnchor066"/>Technical requirements</h1>
<p>For this chapter, you will require a Linux system where you can install packages and are not afraid to break things in the process. To that end, a virtual machine would be most preferred, typically running on an old computer that you can reinstall from scratch. We do not expect to break anything, but during learning, this <span class="No-Break">may happen.</span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor067"/>Backing up a database</h1>
<p>In terms <a id="_idIndexMarker260"/>of most common databases, such as MySQL and PostgreSQL, there are at least two different ways to back up <span class="No-Break">a database:</span></p>
<ul>
<li>Take a database dump by extracting all current data, along with the <span class="No-Break">database schema</span></li>
<li>Copy <span class="No-Break">replication logs</span></li>
</ul>
<p>In cloud environments, you can also take a snapshot of the disk database where the backup is <span class="No-Break">being saved.</span></p>
<p>A database dump <a id="_idIndexMarker261"/>can also be used as a full backup. Replication logs aren’t self-sufficient database dumps, so you will need to combine them with a full backup. This is called an <span class="No-Break">incremental backup.</span></p>
<p>Doing a full backup can take a long time, especially for big databases. While it’s running, the database puts a lock on its data files, so it doesn’t save new data on the disk; instead, it stores everything in the replication logs until the database lock is released. For large databases, this operation can take hours. Because of that, we will be creating a full backup once a week and copying all replication logs every hour. Additionally, we will be creating a daily disk snapshot of our AWS <span class="No-Break">database instance.</span></p>
<p>With this knowledge, we can start creating the most basic version of <span class="No-Break">our script<a id="_idTextAnchor068"/>.</span></p>
<h1 id="_idParaDest-73">Understanding scripting</h1>
<p>A shell script is <a id="_idIndexMarker262"/>a simple text file filled with commands. Unlike compiled programs, shell scripts are not evaluated before execution, but rather while they are being executed. This makes for a very quick development process – there’s no compilation at all. But at the same time, the execution is a bit slower. Also, the errors that the compiler would have caught surface during execution and can often lead to <span class="No-Break">script exiting.</span></p>
<p>On the upside, there’s not much to learn when you are writing a script – much less than when you are writing a program in C or Python. Interacting with system commands is as simple as just typing <span class="No-Break">their names.</span></p>
<p>Bash lacks a lot of sophistication in programming languages: there are not many data types and structures, there’s very rudimentary control of scope, and the memory implementation is not meant to be efficient <span class="No-Break">with scale.</span></p>
<p>There’s not one good rule of thumb for choosing when to write a script and when to develop a program. However, there are some points to consider. A good candidate for a shell script is <span class="No-Break">as follows:</span></p>
<ul>
<li>It’s not very long. We can’t give you a rule, but when you start to go into hundreds of lines, it may be good to consider using Python or splitting it into <span class="No-Break">several scripts.</span></li>
<li>It interacts with system commands, sometimes a lot. You can consider it an automated way of running <span class="No-Break">those commands.</span></li>
<li>It doesn’t do a lot of data handling. There are few arrays, strings, and numbers. <span class="No-Break">That’s all.</span></li>
<li>It doesn’t do any system calls. Shell scripts are not there for system calls. There’s no straightforward way to <span class="No-Break">do it.</span></li>
</ul>
<p>The basic <a id="_idIndexMarker263"/>structure of a shell script is <span class="No-Break">as follows:</span></p>
<pre class="source-code">
#!/bin/bash
echo "Hello world"</pre>
<p>The first line starts with the so-called she-bang. It’s being used to tell the system which interpreter (in this case, it’s Bash) to use to run this script. In a lot of scripts found online, she-bang looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
#!/usr/bin/env bash</pre>
<p>Using the <strong class="source-inline">env</strong> command has a big advantage and disadvantage at the same time. The advantage of using it is that it will use a Bash executable that is first in the current user <strong class="source-inline">PATH</strong> environment variable. It all depends on the purpose. The <strong class="source-inline">env</strong> command also won’t let you pass any arguments to the interpreter <span class="No-Break">you choose.</span></p>
<p>The second line of the preceding script simply displays <strong class="bold">Hello world</strong>. It uses a built-in command echo that does just that – it displays whatever text you put <span class="No-Break">as input.</span></p>
<p>Now, to execute this script, we will need to save it to a file. It’s good practice to end this file with a <strong class="source-inline">.sh</strong> or <strong class="source-inline">.bash</strong> suffix. There are two ways to execute this new script – by invoking the interpreter with a script name or by directly executing the script by <span class="No-Break">its name:</span></p>
<pre class="console">
admin@myhome:~$ bash ./myscript.sh
Hello world
admin@myhome:~$</pre>
<p>To directly execute the script, we will need to change its permissions so that it can be executed; otherwise, the system won’t recognize it as something it <span class="No-Break">can execute:</span></p>
<pre class="console">
admin@myhome:~$ chmod +x myscript.sh
admin@myhome:~$ ./myscript.sh
Hello world
admin@myhome:~$</pre>
<p>Similarly, we<a id="_idIndexMarker264"/> could easily set Python or any other shell as an interpreter of <span class="No-Break">our script.</span></p>
<p>For now, let’s focus on Bash and look at some built-in Bash commands that we’re going <span class="No-Break">to <a id="_idTextAnchor069"/>use.</span></p>
<h1 id="_idParaDest-74">Understanding Bash built-ins and grammar</h1>
<p>Let’s get back to the fundamentals before we start creating a script. First, we will look into the Bash scripting language syntax and <span class="No-Break">its limitations.</span></p>
<p>Built-in commands <a id="_idIndexMarker265"/>are commands that are integral to Bash and are the main scripting syntax we are going to use. Bash will try to execute any other commands from the system it <span class="No-Break">runs on.</span></p>
<p>Just like any other interpreted language (for example, Python or Ruby), Bash has unique syntax and <a id="_idIndexMarker266"/>grammar. Let’s look <span class="No-Break">into it.</span></p>
<p>Bash, similar to other programming languages, interprets files from top to bottom and from left to right. Each line usually contains one or more commands. You can glue several commands together in one line using a pipe (<strong class="source-inline">|</strong>) or double pipe character (<strong class="source-inline">||</strong>), semicolon (<strong class="source-inline">;</strong>), or double ampersands (<strong class="source-inline">&amp;&amp;</strong>). It’s useful to remember that double pipes have the same function as logical <strong class="source-inline">OR</strong> and double ampersands have the same function as logical <strong class="source-inline">AND</strong>. This way, you can run commands in sequence and execute the next command depending on the outcome of the previous command, without using more complex conditional statements. This is called a list or chain <span class="No-Break">of commands:</span></p>
<pre class="console">
commandA &amp;&amp; commandB</pre>
<p>In the preceding command,  you can see an example of using double ampersands. Here, <strong class="source-inline">commandB</strong> will only be executed if <strong class="source-inline">commandA</strong> is successfully executed. We can chain more commands like this by adding <strong class="source-inline">||</strong> at the end of <span class="No-Break">the chain.</span></p>
<pre class="console">
commandA || commandB</pre>
<p>This example, on the other hand, shows how to use a double pipe. Here, <strong class="source-inline">commandB</strong> will only be executed if <strong class="source-inline">commandA</strong> fails <span class="No-Break">to execute.</span></p>
<p>Bash (or any other shell in Linux) determines whether a<a id="_idIndexMarker267"/> command failed to execute or exited with success by using return codes. Every command needs to exit with a positive number – zero (<strong class="source-inline">0</strong>) is a code for success, and any other code is a failure. If you chain multiple commands with <strong class="source-inline">AND(&amp;&amp;)</strong>  or <strong class="source-inline">OR</strong> <strong class="source-inline">(||)</strong>, the return status of the whole line will be determined by the previous command that <span class="No-Break">was executed.</span></p>
<p>What about a single ampersand (<strong class="source-inline">&amp;</strong>) after a command? It has an entirely different function – it will execute a command it is after in the background and the script will continue running without waiting for the command to complete. It’s useful for tasks that aren’t required to be completed for other parts of the program, or running multiple instances of the same command at the same time, such as running a full backup of multiple databases to shorten <span class="No-Break">execution time.</span></p>
<p>Now that we know how to chain commands, we can jump into another core feature of any programming language – <span class="No-Break">variables.</span></p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor070"/>Variables</h2>
<p>In Bash, there<a id="_idIndexMarker268"/> are two types of variables: global and local variables. <em class="italic">Global variables</em> are <a id="_idIndexMarker269"/>accessible throughout the whole time the<a id="_idIndexMarker270"/> script is running unless the variable is unset. <em class="italic">Local variables</em> are accessible only within a block of the script (for example, a <span class="No-Break">defined function).</span></p>
<p>Whenever a script gets executed, it gets an existing set of variables from the currently running shell; this is called an <em class="italic">environment</em>. You can add new variables to the environment using the <strong class="source-inline">export</strong> command, and remove variables by using the <strong class="source-inline">use unset</strong> command. You can also add functions to the environment by using the <strong class="source-inline">declare -</strong><span class="No-Break"><strong class="source-inline">x</strong></span><span class="No-Break"> command.</span></p>
<p>All parameters, regardless of whether they’re local or global, are prefixed with a dollar sign (<strong class="source-inline">$</strong>). So, if you have a variable named <strong class="source-inline">CARS</strong> (case-sensitive), to refer to it, you will need to write <strong class="source-inline">$CARS</strong> inside <span class="No-Break">your script.</span></p>
<p>For variables, single or double quotes (or no quotes) matter. If you put a variable in a single quote, it won’t be expanded, and a variable name inside quotes will be treated as a literal string. Variables inside double quotes will be expanded, and it’s considered a safe way to refer to variables (and concatenate them, or glue them together) because if there is a space or other special character in a string, it won’t be significant for the script – that is, it won’t <span class="No-Break">be executed.</span></p>
<p>Sometimes, you <a id="_idIndexMarker271"/>will need to concatenate multiple variables. You can do this using curly brackets (<strong class="source-inline">{}</strong>). For example, <strong class="source-inline">"${VAR1}${VAR2}"</strong> will expand to whatever you have <strong class="source-inline">VAR1</strong> and <strong class="source-inline">VAR2</strong> set to. In that context, you can also use curly brackets to cut or replace parts of the string. Here’s <span class="No-Break">an example:</span></p>
<pre class="source-code">
name="John"
welcome_str="Hello ${name}"
echo "${welcome_str%John}Jack"</pre>
<p>The preceding code will display <strong class="bold">Hello Jack</strong> instead of <strong class="bold">Hello John</strong>. The <strong class="source-inline">%</strong> operator will only remove characters from the end of the string. If you want to cut variables from the beginning of the string, you would use the <strong class="source-inline">#</strong> operator in the <span class="No-Break">same way.</span></p>
<p>If you refer to a variable without any quotes, space inside the value of the variable may break the flow of the script and impede debugging, so we strongly suggest using either single or <span class="No-Break">dou<a id="_idTextAnchor071"/>ble quotes.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor072"/>Parameters</h2>
<p>There are two kinds <a id="_idIndexMarker272"/>of parameters we could use, but both are a special kind of variable, so each is prefixed with a dollar <span class="No-Break">sign (</span><span class="No-Break"><strong class="source-inline">$</strong></span><span class="No-Break">).</span></p>
<p>The first kind of parameters you need to<a id="_idIndexMarker273"/> be aware of are <em class="italic">positional parameters</em> – these are the parameters that are passed to your script or a function inside a script. All parameters are indexed starting with <strong class="source-inline">1</strong> until <strong class="source-inline">n</strong>, where <strong class="source-inline">n</strong> is the last parameter. You’ll refer to each of these parameters with <strong class="source-inline">$1</strong> until <strong class="source-inline">$n</strong>. You’re probably wondering what will happen if you <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">$0</strong></span><span class="No-Break">.</span></p>
<p><strong class="source-inline">$0</strong> contains the name of your script, so it’s useful for generating documentation within a script, <span class="No-Break">for example.</span></p>
<p>To refer to all available parameters starting from 1, you can use <strong class="source-inline">$@</strong> (dollar <span class="No-Break">sign, at).</span></p>
<p>Here are some other special parameters that are <span class="No-Break">commonly used:</span></p>
<ul>
<li><strong class="source-inline">#</strong>: Number of <span class="No-Break">positional parameters</span></li>
<li><strong class="source-inline">?</strong>: Exit code of the most recently executed <span class="No-Break">foreground command</span></li>
<li><strong class="source-inline">$</strong>: Process ID<a id="_idTextAnchor073"/> of <span class="No-Break">the shell</span></li>
</ul>
<h2 id="_idParaDest-77"><a id="_idTextAnchor074"/>Loops</h2>
<p>You are<a id="_idIndexMarker274"/> probably familiar with different types of loops as they are in other programming languages. You can find all of those in Bash, but with a slightly different syntax than you might be <span class="No-Break">familiar with.</span></p>
<p>The <a id="_idIndexMarker275"/>most basic, a<strong class="source-inline"> for loop</strong>, looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
for variable_name in other_variable; do some_commands; done</pre>
<p>This variant of the <strong class="source-inline">for</strong> loop sets whatever element inside <strong class="source-inline">other_variable</strong> as a value of <strong class="source-inline">variable_name</strong> and executes <strong class="source-inline">some_commands</strong> for every element it finds. After it’s completed, it exits the loop with the status of the last executed command. The <strong class="source-inline">in other_variable</strong> part can be omitted – in that case, the <strong class="source-inline">for</strong> loop executes <strong class="source-inline">some_commands</strong> once for each positional parameter. The use of this parameter will look <span class="No-Break">like this:</span></p>
<pre class="source-code">
for variable_name; do some_commands; done</pre>
<p>The preceding <strong class="source-inline">for</strong> loop will run as many times as you added input variables for your function (or script in this case). You can refer to all positional parameters <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">$@</strong></span><span class="No-Break">.</span></p>
<p>The following is a for loop in a form known <span class="No-Break">from C/C++:</span></p>
<pre class="source-code">
for (( var1 ; var2 ; var3 )); do some_commands; done</pre>
<p>Here’s an example use of <span class="No-Break">this syntax:</span></p>
<pre class="source-code">
for ((i=1; i&lt;=5; i++)); do echo $i; done</pre>
<p>The first expression sets the <strong class="source-inline">i</strong> variable to <strong class="source-inline">1</strong>, the second expression is a condition to be met for the loop to still run, and the final expression is incrementing the <strong class="source-inline">i</strong> variable by 1. Each loop run will display the next value set to the <span class="No-Break"><strong class="source-inline">i</strong></span><span class="No-Break"> variable.</span></p>
<p>The output of this command will look <span class="No-Break">like this<a id="_idTextAnchor075"/>:</span></p>
<pre class="source-code">
1
2
3
4
5</pre>
<p>Another <a id="_idIndexMarker276"/>useful loop is a <strong class="source-inline">while loop</strong>, which runs as many times as needed until the condition is met (the command we pass to it exits with a success – it returns zero). Its counterpart is a loop called <strong class="source-inline">until</strong>, which will keep running so long as the command we pass to it returns a <span class="No-Break">non-zero status:</span></p>
<pre class="console">
while some_command; do some_command; done
until some_command; do some_command; done</pre>
<p>You can create an infinite loop by using a command that will always meet the condition, so for the <strong class="source-inline">while</strong> loop, it can be <span class="No-Break">simply </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
<p>The most commonly used <a id="_idIndexMarker277"/>blocks of commands are conditionals and are used with <strong class="source-inline">if</strong> statements. Let’s ta<a id="_idTextAnchor076"/>ke a <span class="No-Break">closer look.</span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Conditional execution – if statement</h2>
<p>The if statement <a id="_idIndexMarker278"/>has the <span class="No-Break">following syntax:</span></p>
<pre class="console">
if test_command
then
  executed_if_test_was_true
fi</pre>
<p><strong class="source-inline">test_command</strong> can be any command you can think of, but commonly, the test is wrapped between double or single square brackets. The difference between these two is the former is a system command called <strong class="source-inline">test</strong> (you can check its syntax by executing <strong class="source-inline">man test</strong>), while the latter is a Bash built-in and more <span class="No-Break">powerful test.</span></p>
<p>The rule of thumb for putting variables between square brackets is using double quotes, so if a variable contains spaces, it won’t change the intention of <span class="No-Break">our test:</span></p>
<pre class="console">
if [[ -z "$SOME_VAR" ]]; then
    echo "Variable SOME_VAR is empty"
fi</pre>
<p>The <strong class="source-inline">-z</strong> test checks whether the <strong class="source-inline">$SOME_VAR</strong> variable is empty. It evaluates to <strong class="source-inline">true</strong> if the variable is empty and <strong class="source-inline">false</strong> <span class="No-Break">if not.</span></p>
<p>The following<a id="_idIndexMarker279"/> are other commonly <span class="No-Break">used tests:</span></p>
<ul>
<li><strong class="source-inline">-a</strong>: <span class="No-Break">Logical AND</span></li>
<li><strong class="source-inline">-o</strong>: <span class="No-Break">Logical OR</span></li>
<li><strong class="source-inline">-eq</strong>: Is <span class="No-Break">equal to</span></li>
<li><strong class="source-inline">-ne</strong>: Is not <span class="No-Break">equal to</span></li>
<li><strong class="source-inline">-gt or &gt;</strong>: Is <span class="No-Break">greater than</span></li>
<li><strong class="source-inline">-ge or &gt;=</strong>: Is greater than or <span class="No-Break">equal to</span></li>
<li><strong class="source-inline">-lt or &lt;</strong>: Is <span class="No-Break">less than</span></li>
<li><strong class="source-inline">-le or &lt;=</strong>: Is less than or <span class="No-Break">equal to</span></li>
<li><strong class="source-inline">= or ==</strong>: Is <span class="No-Break">equal to</span></li>
<li><strong class="source-inline">!=</strong>: Is not <span class="No-Break">equal to</span></li>
<li><strong class="source-inline">-z</strong>: String is null (its length is <span class="No-Break">zero characters)</span></li>
<li><strong class="source-inline">-n</strong>: String is <span class="No-Break">not null</span></li>
<li><strong class="source-inline">-e</strong>: File exists (directory, symlink, device file, or any other file in <span class="No-Break">the filesystem)</span></li>
<li><strong class="source-inline">-f</strong>: File is a regular file (not a directory or <span class="No-Break">device file)</span></li>
<li><strong class="source-inline">-d</strong>: File is <span class="No-Break">a directory</span></li>
<li><strong class="source-inline">-h</strong> or <strong class="source-inline">-L</strong>: File is a <span class="No-Break">symbolic link</span></li>
<li><strong class="source-inline">-r</strong>: File has read permission (for the user running <span class="No-Break">the test)</span></li>
<li><strong class="source-inline">-w</strong>: File has write permission (for the user running <span class="No-Break">the test)</span></li>
<li><strong class="source-inline">-x</strong>: File can be executed by the user that executed <span class="No-Break">the script</span></li>
</ul>
<p>Note that tests may behave differently when using a system test (single square brackets, <strong class="source-inline">[...]</strong>) rather than the built-in one (double square <span class="No-Break">brackets, </span><span class="No-Break"><strong class="source-inline">[[...]]</strong></span><span class="No-Break">).</span></p>
<p>The double equal<a id="_idIndexMarker280"/> comparison operator, while comparing strings when using globbing, will match the pattern or literal string, depending on whether you’ve quoted the pattern <span class="No-Break">or not.</span></p>
<p>The following is an example of pattern matching if the string starts <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">w</strong></span><span class="No-Break">:</span></p>
<pre class="console">
if [[ $variable == w* ]];
    echo "Starts with w"
fi</pre>
<p>When using a system test (a single square bracket) instead of a built-in one, the test will try to find whether the <strong class="source-inline">$</strong> variable matches any of the filenames in the local directory (including those with spaces). This can lead to some <span class="No-Break">unpredictable outcomes.</span></p>
<p>The following is an example of pattern matching if the string <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">w*</strong></span><span class="No-Break">:</span></p>
<pre class="console">
if [[ $variable == "w*" ]];
    echo "String is literally 'w*'"
fi</pre>
<p>Equipped with this knowledge, we’re ready to start creating and running scripts. So, let<a id="_idTextAnchor078"/>’s jump right <span class="No-Break">to it!</span></p>
<h1 id="_idParaDest-79">Understanding the backup script – first steps</h1>
<p>Now that <a id="_idIndexMarker281"/>we know what <a id="_idIndexMarker282"/>a script can look like, we can start writing one. You can use your favorite console editor or IDE to do this. Let’s create an empty file named <strong class="source-inline">run_backups.sh</strong> and change its permissions so that <span class="No-Break">they’re executable:</span></p>
<pre class="console">
admin@myhome:~$ touch run_backups.sh &amp;&amp; chmod +x run_backups.sh
admin@myhome:~$ ls -l run_backups.sh
-rwxr-xr-x  1 admin  admin  0 Dec  1 15:56 run_backups.sh</pre>
<p>It’s an empty file, so we’ll need to add a basic database backup command and proceed from there. We won’t be covering granting this script access to a database. We will be backing up a PostgreSQL database and using the <strong class="source-inline">pg_dump</strong> tool for <span class="No-Break">that purpose.</span></p>
<p>Let’s input a<a id="_idIndexMarker283"/> shebang line and a <strong class="source-inline">pg_dump</strong> command call in our <span class="No-Break">base script:</span></p>
<pre class="console">
#!/usr/bin/env bash
pg_dump mydatabase &gt; mydatabase.sql</pre>
<p>To execute this script, we’ll need to start the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ ./run_backups.sh</pre>
<p>The dot and slash indicate that we want to execute something that is located in a current directory, and its name is <strong class="source-inline">run_backups.sh</strong>. Without the initial dot-slash pair, the shell we’re running on (here, <strong class="source-inline">bash</strong>) would look into the <strong class="source-inline">PATH</strong> environment variable and would try to find our script in one of the directories <span class="No-Break">listed there:</span></p>
<pre class="console">
admin@myhome:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</pre>
<p>As you can see, it’s a list of directories delimited with <span class="No-Break">a colon.</span></p>
<p>Now, let’s see what our Bash script does <span class="No-Break">when executed:</span></p>
<pre class="console">
admin@myhome:~$ ./run_backups.sh
./run_backups.sh: line 3: pg_dump: command not found</pre>
<p>Unless you already have <strong class="source-inline">pg_dump</strong> installed on your system, you will see this error. It means that Bash didn’t find the command we intended to run. It also displays the line where the error occurred. Also, an empty <strong class="source-inline">mydatabase.sql</strong> file <span class="No-Break">was created.</span></p>
<p>Normally, we would proceed with creating a Docker image with all the tools we need, and a second one with a PostgreSQL database running. But since this will be covered in <a href="B18197_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, let’s just proceed and install everything we need on a local machine. Assuming you’re on an Ubuntu or a Debian Linux machine, you want to run the <span class="No-Break">following commands:</span></p>
<pre class="console">
admin@myhome:~$ sudo apt-get update
Get:1 http://archive.ubuntu.com/ubuntu jammy InRelease [270 kB]
[Condensed for brevity]
Get:18 http://archive.ubuntu.com/ubuntu jammy-backports/main amd64 Packages [3520 B]
Fetched 24.9 MB in 6s (4016 kB/s)
Reading package lists... Done
admin@myhome:~$ sudo apt-get install postgresql
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following additional packages will be installed:
  cron libbsd0 libcommon-sense-perl libedit2 libgdbm-compat4 libgdbm6 libicu70 libjson-perl libjson-xs-perl libldap-2.5-0 libldap-common libllvm14 libmd0 libperl5.34 libpopt0 libpq5 libreadline8
[Condensed for brevity]
Suggested packages:
  anacron checksecurity default-mta | mail-transport-agent gdbm-l10n libsasl2-modules-gssapi-mit | libsasl2-modules-gssapi-heimdal libsasl2-modules-ldap libsasl2-modules-otp libsasl2-modules-sql
[Condensed for brevity]
0 upgraded, 42 newly installed, 0 to remove and 2 not upgraded.
Need to get 68.8 MB of archives.
After this operation, 274 MB of additional disk space will be used.
Do you want to continue? [Y/n] y</pre>
<p>After user confirmation, the database will be installed, configured, and started in the background. We’ve cut the further output <span class="No-Break">for readability.</span></p>
<p>After <a id="_idIndexMarker284"/>installation, you might need an additional configuration change for the database so that you can connect to the database with another tool called <strong class="source-inline">psql</strong>, which is a console command that’s useful for connecting to PostgreSQL. In the <strong class="source-inline">/etc/postgresql/14/main/pg_hba.conf</strong> file, we have defined trust relationships and who can connect to the database using <span class="No-Break">multiple mechanisms.</span></p>
<p>Find the <span class="No-Break">following line:</span></p>
<pre class="source-code">
local   all  postgres peer</pre>
<p>Change it to <span class="No-Break">the following:</span></p>
<pre class="source-code">
local   all  all  trust</pre>
<p>After making this modification, you can restart the database with the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ sudo systemctl restart postgresql
* Restarting PostgreSQL 14 database server</pre>
<p>Now, you should be able to log in to the database and list all <span class="No-Break">available databases:</span></p>
<pre class="console">
admin@myhome:~$ psql -U postgres postgres
psql (14.5 (Ubuntu 14.5-0ubuntu0.22.04.1))
Type "help" for help.
postgres=# \l
                              List of databases
   Name    |  Owner   | Encoding | Collate |  Ctype  |   Access privileges
-----------+----------+----------+---------+---------+-----------------------
 postgres  | postgres | UTF8     | C.UTF-8 | C.UTF-8 |
 template0 | postgres | UTF8     | C.UTF-8 | C.UTF-8 | =c/postgres          +
           |          |          |         |         | postgres=CTc/postgres
 template1 | postgres | UTF8     | C.UTF-8 | C.UTF-8 | =c/postgres          +
           |          |          |         |         |
postgres=CTc/postgres
(3 rows)
postgres=# \q
admin@myhome:~$</pre>
<p>After logging in, we list all available databases with <strong class="source-inline">\l</strong> (backslash, lowercase L) and quit the <strong class="source-inline">psql</strong> shell with <strong class="source-inline">\q</strong> (backslash, lowercase Q). Once this is set, we can get back to our script and try to run <span class="No-Break">it again:</span></p>
<pre class="console">
admin@myhome:~$ ./run_backups.sh
pg_dump: error: connection to server on socket "/var/run/postgresql/.s.PGSQL.5432" failed: FATAL:  role "root" does not exist</pre>
<p>There’s no<a id="_idIndexMarker285"/> root role in PostgreSQL, which is an expected error at this point. We will need to use a different role to connect to the database. The default is <strong class="source-inline">postgres</strong> and the option to pass to <strong class="source-inline">pg_dump</strong> is <strong class="source-inline">-U</strong>, the same as what we used with <strong class="source-inline">psql</strong>. After updating it, our script will look <span class="No-Break">like this:</span></p>
<pre class="source-code">
#!/usr/bin/env bash
pg_dump -U postgres mydatabase &gt; mydatabase.sql</pre>
<p>The final step is to create a database and some actual data so that the output <strong class="source-inline">sql</strong> file won’t be empty. The following script will create a database named <strong class="source-inline">mydatabase</strong> and create two tables that contain <span class="No-Break">random data:</span></p>
<pre class="source-code">
CREATE DATABASE mydatabase;
\c mydatabase
CREATE TABLE random_data AS SELECT data_series, md5(random()::text) from generate_series(1,100000) data_series;
CREATE TABLE another_random AS SELECT data_series, md5(random()::text) from generate_series(1,100000) data_series;</pre>
<p>The <strong class="source-inline">CREATE DATABASE</strong> line is <a id="_idIndexMarker286"/>creating a database named <strong class="source-inline">mydatabase</strong>. The second line indicates we’re connecting to this new database. Two additional lines starting with <strong class="source-inline">CREATE TABLE</strong> are both creating tables and filling them with data using built-in PostgreSQL functions. Let’s break it down into two distinct queries – <strong class="source-inline">SELECT</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">CREATE</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
SELECT data_series, md5(random()::text) from generate_series(1,100000) data_series;</pre>
<p>There are a few things going <span class="No-Break">on here:</span></p>
<ul>
<li>The <strong class="source-inline">generate_series()</strong> function is creating a series of integers starting from 1 up to 100,000 – this will generate all our records in <span class="No-Break">a table</span></li>
<li>The <strong class="source-inline">data_series</strong> keyword, just before a semicolon, names output from the <strong class="source-inline">generate_series()</strong> function, so it’s an actual field name in a table we intend <span class="No-Break">to create</span></li>
<li>The <strong class="source-inline">random()</strong> function is generating a value between 0 and 1 – that is, greater than or equal to 0 and less <span class="No-Break">than 1</span></li>
<li>The <strong class="source-inline">::text </strong>after the<strong class="source-inline"> random()</strong> function is converting output from this function <span class="No-Break">into text</span></li>
<li>The <strong class="source-inline">md5()</strong> function is taking the output from <strong class="source-inline">random()::text</strong> and hashing it with an <strong class="source-inline">md5</strong> algorithm, ensuring that we have a unique string and run as many times as the <strong class="source-inline">generate_series()</strong> function’s output amount will be (here, this is from 1 <span class="No-Break">to 100,000)</span></li>
<li>Finally, <strong class="source-inline">SELECT data_series, md5()</strong> is producing a table with two fields (<strong class="source-inline">data_series</strong> and <strong class="source-inline">md5</strong>) with data generated by <span class="No-Break">both functions</span></li>
</ul>
<p>Now, getting back to <strong class="source-inline">CREATE TABLE</strong>, there’s a part called <strong class="source-inline">another_random AS</strong> – this will get the output from <strong class="source-inline">SELECT</strong> and create a table <span class="No-Break">for us.</span></p>
<p>With this <a id="_idIndexMarker287"/>knowledge, we can create a <strong class="source-inline">sql</strong> script and execute it <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">psql</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
admin@myhome:~$ psql -U postgres &lt; create_db.sql
CREATE DATABASE
You are now connected to database "mydatabase" as user "postgres".</pre>
<p>To check whether we’ve created something and investigate the data we’ve created, again, we will need to use <strong class="source-inline">psql</strong> and the <strong class="source-inline">SELECT</strong> query on our <span class="No-Break">new database:</span></p>
<pre class="source-code">
admin@myhome:~$ psql (14.1)
Type "help" for help.
postgres=# \c mydatabase
You are now connected to database "mydatabase" as user "postgres".
mydatabase=# \dt
             List of relations
 Schema |      Name      | Type  |  Owner
--------+----------------+-------+----------
 public | another_random | table | postgres
 public | random_data    | table | postgres
(2 rows)
mydatabase=# select * from random_data ;
 data_series |               md5
-------------+----------------------------------
           1 | 4c250205e8f6d5396167ec69e3436d21
           2 | a5d562ccd600b3c4c70149361d3ab307
           3 | 7d363fac3c83d35733566672c765317f
           4 | 2fd7d594e6d972698038f88d790e9a35
--More--</pre>
<p><strong class="source-inline">--More–</strong> at <a id="_idIndexMarker288"/>the end of the preceding output indicates there are more records to be shown. You can see more data by pressing the spacebar or quit by pressing <em class="italic">Q</em> on <span class="No-Break">your keyboard.</span></p>
<p>Once you have created a database and filled it with some data, you can try to run our backup <span class="No-Break">script again:</span></p>
<pre class="source-code">
admin@myhome:~$ ./run_backup.sh
admin@myhome:~$</pre>
<p>There are no errors, so we have probably created a full database dump <span class="No-Break">with success:</span></p>
<pre class="source-code">
admin@myhome:~$ ls -l mydatabase.sql
-rw-r--r--    1 root     root      39978060 Dec 15 10:30 mydatabase.sql</pre>
<p>The output file isn’t empty; let’s see <span class="No-Break">what’s inside:</span></p>
<pre class="source-code">
admin@myhome:~$ head mydatabase.sql
--
-- PostgreSQL database dump
--
-- Dumped from database version 14.1
-- Dumped by pg_dump version 14.1
SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;</pre>
<p>After some <strong class="source-inline">SET</strong> statements, you<a id="_idIndexMarker289"/> should also find <strong class="source-inline">CREATE TABLE</strong> and <strong class="source-inline">INSERT</strong> statements. I haven’t provided full output here as it would take up a lot <span class="No-Break">of space.</span></p>
<p>In this section, we learned how to set up a testing environment for our script and made it possible for our script to create a database dump. In the next section, we’ll focus more on error handling and checking <a id="_idTextAnchor079"/>whether the backup <span class="No-Break">was successful.</span></p>
<h1 id="_idParaDest-80">Handling errors and debugging</h1>
<p>While <a id="_idIndexMarker290"/>running our backup script, we can encounter several errors: access to the database might be blocked, the <strong class="source-inline">pg_dump</strong> process might get killed, we may be out of disk space, or any other error preventing us from completing a full <span class="No-Break">database dump.</span></p>
<p>In any of those cases, we will need to catch the error and handle <span class="No-Break">it gracefully.</span></p>
<p>Additionally, we might <a id="_idIndexMarker291"/>want to refactor the script to make it configurable, make use of functions, and debug the script. Debugging will prove very useful, especially when dealing with <span class="No-Break">larger scripts.</span></p>
<p>Let’s dive right into it and start with adding <span class="No-Break">a function:</span></p>
<pre class="source-code">
#!/usr/bin/env bash
function run_dump() {
  database_name=$1
  pg_dump -U postgres $database_name &gt; $database_name.sql
}
run_dump mydatabase</pre>
<p>We’ve <a id="_idIndexMarker292"/>added a <strong class="source-inline">run_dump</strong> function that takes one argument and sets a local variable called <strong class="source-inline">database_name</strong> with the content of this argument. It then uses this local variable to pass options to the <span class="No-Break"><strong class="source-inline">pg_dump</strong></span><span class="No-Break"> command.</span></p>
<p>This will<a id="_idIndexMarker293"/> immediately allow us to back up multiple databases by using a for loop, <span class="No-Break">like so:</span></p>
<pre class="source-code">
for dbname in mydatabase mydatabase2 mydatabase3; do
    run_dump $dbname
done</pre>
<p>This loop will create a full dump of the databases: <strong class="source-inline">mydatabase</strong>, <strong class="source-inline">mydatabase2</strong>, and <strong class="source-inline">mydatabase3</strong>. Backups will be done one by one using this function. We can now put a list of the databases in a variable to make it more configurable. The current script will look <span class="No-Break">like this:</span></p>
<pre class="source-code">
#!/usr/bin/env bash
databases="mydatabase"
function run_dump() {
  database_name=$1
  pg_dump -U postgres $database_name &gt; $database_name.sql
}
for database in $databases; do
  run_dump "$database"
done</pre>
<p>Now, this backup script is becoming more complicated. We need to note a few things that will be <span class="No-Break">happening now:</span></p>
<ul>
<li>If any of the backups should fail, the script will <span class="No-Break">continue running</span></li>
<li>If the backups fail due to <strong class="source-inline">pg_dump</strong> not having access to the database, we will overwrite our previous <span class="No-Break">database dump</span></li>
<li>We will be overwriting the dump file on <span class="No-Break">every run</span></li>
</ul>
<p>Several<a id="_idIndexMarker294"/> default <a id="_idIndexMarker295"/>settings are considered to be good practice to override in a script. One that would mitigate the first problem we’ve pointed out is aborting running when any command returns a value that’s different than zero (or <strong class="source-inline">true</strong>). This means the command finished running with an error. The option’s name is <strong class="source-inline">errexit</strong> and can we override it with the <strong class="source-inline">set</strong> command, a Bash built-in command. We could do this in <span class="No-Break">two ways:</span></p>
<pre class="console">
set -o errexit
set -e</pre>
<p>Here are some other options we <span class="No-Break">recommend using:</span></p>
<ul>
<li><strong class="source-inline">set -u</strong>: This treats any unset variable we try to use in a script as <span class="No-Break">an error</span></li>
<li><strong class="source-inline">set -o pipefail</strong>: When using chaining commands with a pipe, the exit status of this pipeline will be the status of the last command that finished with a non-zero status or zero (a success) if all commands <span class="No-Break">exit successfully</span></li>
<li><strong class="source-inline">set -C</strong> or <strong class="source-inline">set -o noclobber</strong>: If set, Bash won’t overwrite any existing file with the redirection commands (for example, <strong class="source-inline">&gt;</strong>, which we’re using in <span class="No-Break">our script)</span></li>
</ul>
<p>An additional option that is extremely useful is <strong class="source-inline">set -x</strong> or <strong class="source-inline">set -o xtrace</strong>, which causes Bash to print every command before executing <span class="No-Break">said command.</span></p>
<p>Let’s see how it works for a simple <span class="No-Break">Bash script:</span></p>
<pre class="console">
#!/usr/bin/env bash
set -x
echo "Hello!"</pre>
<p>Here’s the output of executing <span class="No-Break">this script:</span></p>
<pre class="source-code">
admin@myhome:~$ ./simple_script.sh
+ echo 'Hello!'
Hello!</pre>
<p>Let’s<a id="_idIndexMarker296"/> update <a id="_idIndexMarker297"/>our backup script with the recommended <span class="No-Break">Bash settings:</span></p>
<pre class="source-code">
#!/usr/bin/env bash
set -u
set -o pipefail
set -C
databases="mydatabase"
function run_dump() {
  database_name=$1
  pg_dump -U postgres $database_name &gt; $database_name.sql
}
for database in $databases; do
  run_dump "$database"
done</pre>
<p>Now, let’s get back to the console to test whether it’s still working as <span class="No-Break">we expect:</span></p>
<pre class="source-code">
admin@myhome:~$ ./run_backups.sh
./run_backups.sh: line 12: mydatabase.sql: cannot overwrite existing file</pre>
<p>We’ve enabled<a id="_idIndexMarker298"/> the <strong class="source-inline">noclobber</strong> option and it has prevented <a id="_idIndexMarker299"/>us from overwriting previously made backups. We’ll need to rename or delete the old file before we can proceed. This time, let’s also enable the <strong class="source-inline">xtrace</strong> option to see what command script is <span class="No-Break">being executed:</span></p>
<pre class="source-code">
admin@myhome:~$ rm mydatabase.sql
admin@myhome:~$ bash -x ./run_backups.sh
+ set -u
+ set -o pipefail
+ set -C
+ databases=mydatabase
+ for database in $databases
+ run_dump mydatabase
+ database_name=mydatabase
+ pg_dump -U postgres mydatabase</pre>
<p>To mitigate the overwrite existing file error, we could do one of <span class="No-Break">three things:</span></p>
<ul>
<li>Delete the previous file before attempting to run the backup, which would destroy the <span class="No-Break">previous backup.</span></li>
<li>Rename the previous backup file and add a current <span class="No-Break">date suffix.</span></li>
<li>Make sure that every time we run a script, the dump file has a different name, such as a current date. This would ensure we are keeping previous backups in case we need to get back to a version that’s earlier than the last <span class="No-Break">full backup.</span></li>
</ul>
<p>In this case, the most common solution would be the final one we’ve proposed – generate a different backup file name every time the backup runs. First, let’s try to get a timestamp with the local date and time in the <strong class="source-inline">YYYYMMDD_HHMM</strong> format, where we have the <span class="No-Break">following options:</span></p>
<ul>
<li><strong class="source-inline">YYYY</strong>: The current year in a <span class="No-Break">four-digit format</span></li>
<li><strong class="source-inline">MM</strong>: The current month in a <span class="No-Break">two-digit format</span></li>
<li><strong class="source-inline">DD</strong>: The day of the month in a <span class="No-Break">two-digit format</span></li>
<li><strong class="source-inline">HH</strong>: The <span class="No-Break">current hour</span></li>
<li><strong class="source-inline">MM</strong>: The <span class="No-Break">current minute</span></li>
</ul>
<p>We can <a id="_idIndexMarker300"/>achieve this by using the <strong class="source-inline">date</strong> command. By default, it <a id="_idIndexMarker301"/>will return the current date, day of the week, and the <span class="No-Break">time zone:</span></p>
<pre class="console">
admin@myhome:~$ date
Fri Dec 16 14:51:34 UTC 2022</pre>
<p>To change the default output of this command, we’ll need to pass a date format string using <span class="No-Break">formatting characters.</span></p>
<p>The most common formatting characters for the <strong class="source-inline">date</strong> command are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">%Y</strong>: Year (for <span class="No-Break">example, 2022)</span></li>
<li><strong class="source-inline">%m</strong>: <span class="No-Break">Month (01-12)</span></li>
<li><strong class="source-inline">%B</strong>: Long month name (for <span class="No-Break">example, January)</span></li>
<li><strong class="source-inline">%b</strong>: Short month name (for <span class="No-Break">example, Jan)</span></li>
<li><strong class="source-inline">%d</strong>: Day of month (for example, 01-31, depending on how many days are in a <span class="No-Break">certain month)</span></li>
<li><strong class="source-inline">%j</strong>: Day of year (for <span class="No-Break">example, 001-366)</span></li>
<li><strong class="source-inline">%u</strong>: Day of <span class="No-Break">week (1-7)</span></li>
<li><strong class="source-inline">%A</strong>: Full weekday name (for <span class="No-Break">example, Friday)</span></li>
<li><strong class="source-inline">%a</strong>: Short weekday name (for <span class="No-Break">example, Fri)</span></li>
<li><strong class="source-inline">%H</strong>: <span class="No-Break">Hour (00-23)</span></li>
<li><strong class="source-inline">%I</strong>: <span class="No-Break">Hour (01-12)</span></li>
<li><strong class="source-inline">%M</strong>: <span class="No-Break">Minute (00-59)</span></li>
<li><strong class="source-inline">%S</strong>: <span class="No-Break">Second (00-59)</span></li>
<li><strong class="source-inline">%D</strong>: Display date <span class="No-Break">as mm/dd/yy</span></li>
</ul>
<p>To format the <a id="_idIndexMarker302"/>date in a format we want, we’ll need to use formatting characters, <strong class="source-inline">%Y%m%d_%H%M</strong>, and pass it to the <strong class="source-inline">date</strong> command <span class="No-Break">for interpretation:</span></p>
<pre class="console">
admin@myhome:~$ date +"%Y%m%d_%H%M"
20221216_1504</pre>
<p>To pass the <a id="_idIndexMarker303"/>output string to a variable in our script, we’ll need to run the date in a subshell (a Bash process executed by our <span class="No-Break">Bash script):</span></p>
<pre class="source-code">
timestamp=$(date +"%Y%m%d_%H%M")</pre>
<p>Let’s put it inside our script and use a <strong class="source-inline">timestamp</strong> variable to generate an <span class="No-Break">output filename:</span></p>
<pre class="source-code">
#!/usr/bin/env bash
set -u
set -o pipefail
set -C
timestamp=$(date +"%Yum'd_%H%M")
databases="mydatabase"
function run_dump() {
  database_name="$1"
  pg_dump -U postgres "$database_name" &gt; "${database_name}_${timestamp}".sql
}
for database in $databases; do
  run_dump "$database"
done</pre>
<p>If you <a id="_idIndexMarker304"/>have <a id="_idIndexMarker305"/>spotted curly braces between variables in a <strong class="source-inline">pg_dump</strong> line, you’re probably wondering why we need them. We use curly braces to make sure that the variable name will be correct when we expand a variable to a string. In our case, we’re preventing Bash from trying to search for a variable name, <strong class="source-inline">$database_name_</strong>, that <span class="No-Break">doesn’t exist.</span></p>
<p>Now, each time we run our backup script, it will try to create a new file with the current date and time of the backup start time. If we’re running this script every day, the number of files will increase over time and will eventually fill our disk space. So, we’ll also need our script to remove old backups – say, 14 days <span class="No-Break">and older.</span></p>
<p>We can achieve this by using the <strong class="source-inline">find</strong> command. Let’s find all files beginning with a database name, followed by an underscore, and ending with<strong class="source-inline">.sql</strong> that are older than <span class="No-Break">14 days:</span></p>
<pre class="console">
admin@myhome:~$ find . -name "mydatabase_*.sql" -type f -mtime +14
./mydatabase_20221107.sql</pre>
<p>The <strong class="source-inline">find</strong> command has a peculiar syntax that is a bit different than other command-line tools have, so let’s describe what each <span class="No-Break">option means:</span></p>
<ul>
<li><strong class="source-inline">.</strong> (a dot): This is a directory where we want to search for our files. Dot means <em class="italic">a </em><span class="No-Break"><em class="italic">current directory</em></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">-name</strong>: This option can take a full string or wildcards such as <strong class="source-inline">*</strong> or <strong class="source-inline">?</strong> and it’s looking for filenames in this case. It’s case-sensitive. If we’re not certain that the file or directory we’re looking for is uppercase or lowercase, we could use the <strong class="source-inline">-iname</strong> <span class="No-Break">option instead.</span></li>
<li><strong class="source-inline">-type f</strong>: This indicates we’re looking for a regular file. Other options are <span class="No-Break">as follows:</span><ul><li><span class="No-Break"><strong class="source-inline">d</strong></span><span class="No-Break">: Directory</span></li><li><strong class="source-inline">l</strong>: <span class="No-Break">Symbolic link</span></li><li><strong class="source-inline">s</strong>: A <span class="No-Break">socket file</span></li><li><strong class="source-inline">p</strong>: <span class="No-Break">FIFO file</span></li><li><strong class="source-inline">b</strong>: <span class="No-Break">Block device</span></li><li><strong class="source-inline">c</strong>: A <span class="No-Break">character device</span></li></ul></li>
<li><strong class="source-inline">-mtime +14</strong>: The modification time of this file should be older than 14 days. This option can also take other units (seconds, - <strong class="source-inline">s</strong>, weeks, - <strong class="source-inline">w</strong>, hours, - <strong class="source-inline">h</strong>, and days, - <strong class="source-inline">d</strong> – it’s the default if no unit <span class="No-Break">is given).</span></li>
</ul>
<p>To <a id="_idIndexMarker306"/>delete<a id="_idIndexMarker307"/> found files, we have at least two options: the <strong class="source-inline">-delete</strong> option or the <strong class="source-inline">rm</strong> command via an <strong class="source-inline">-exec find</strong> option. Let’s see how this looks in <span class="No-Break">both cases:</span></p>
<pre class="console">
admin@myhome:~$ find . -name "mydatabase_*.sql" -type f -mtime +14 -delete
admin@myhome:~$ find . -name "mydatabase_*.sql" -type f -mtime +14 -exec rm -- {} \;</pre>
<ul>
<li>In this case, a safer choice would be to use <strong class="source-inline">-execdir</strong> instead of <strong class="source-inline">-exec</strong>. The difference is subtle but important: <strong class="source-inline">-</strong> <strong class="source-inline">exec</strong> will not be executed in the same directory where the found file is located, but <strong class="source-inline">-execdir</strong> will, which makes it a safer option in <span class="No-Break">edge cases.</span></li>
</ul>
<p>Let’s deconstruct what we have after the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">exec</strong></span><span class="No-Break"> option:</span></p>
<ul>
<li><strong class="source-inline">rm</strong>: This is a CLI tool for removing files <span class="No-Break">or directories.</span></li>
<li><strong class="source-inline">--</strong> (double dash): This indicates that it will take arguments from <strong class="source-inline">stdin</strong>, or the output of the <span class="No-Break"><strong class="source-inline">find</strong></span><span class="No-Break"> command.</span></li>
<li><strong class="source-inline">{}</strong>: This will substitute for a filename <span class="No-Break">we’ve found.</span></li>
<li><strong class="source-inline">\;</strong> (backslash, semicolon): This will take multiple commands to be executed by <strong class="source-inline">-exec</strong>. A backslash is an escape character that prevents this semicolon from being interpreted as a separator for the next command. The <strong class="source-inline">find</strong> utility uses <strong class="source-inline">;</strong> or <strong class="source-inline">+</strong> to terminate the shell commands, so we could note it as <strong class="source-inline">";"</strong>, <strong class="source-inline">\+</strong>, or <strong class="source-inline">+ </strong>(<span class="No-Break">without quotes).</span></li>
<li>The <strong class="source-inline">-delete</strong> option is good for removing files, but it always returns <strong class="source-inline">true</strong>, so it will fail silently if, for example, our script doesn’t have permission to remove any files. It’s relatively safe to use it in our script, so we’ll go ahead <span class="No-Break">with it.</span></li>
</ul>
<p>Now, let’s <a id="_idIndexMarker308"/>embed<a id="_idIndexMarker309"/> this into our script and see the final iteration <span class="No-Break">of it:</span></p>
<pre class="source-code">
#!/usr/bin/env bash
set -u
set -o pipefail
set -C
timestamp=$(date +"%Y%m%d_%H%M")
databases="mydatabase"
function cleanup_old_backups() {
  database_name="$1"
  find . -type f -name "${database_name}_*.sql" -mtime +14 -delete
}
function run_dump() {
  database_name="$1"
  pg_dump -U postgres "$database_name" &gt; "${database_name}_${timestamp}".sql
}
for database in $databases; do
  cleanup_old_backups "$database"
  run_dump "$database"
done</pre>
<p>Here, we’ve added a <a id="_idIndexMarker310"/>function called <strong class="source-inline">cleanup_old_backups</strong> that <a id="_idIndexMarker311"/>will run before creating a new dump to free some space for fresh files. We’re calling this function inside a for loop just before <strong class="source-inline">run_dump</strong>. This script can be run automatically by a <strong class="source-inline">cron daemon</strong> or <strong class="source-inline">systemd cron</strong> service; we’ll cover this in more detail in <a href="B18197_05.xhtml#_idTextAnchor083"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Managing Services </em><span class="No-Break"><em class="italic">in Linux</em></span><span class="No-Break">.</span></p>
<p>In this section, we learned about the recommended options to enable in shell scripts and how to enable debugging options. We know now how to create functions and loops. Additionally, we partially touched on PostgreSQL and how to create a <span class="No-Break">testing database.</span></p>
<p>The next chapter will take us deeper into various Linux serv<a id="_idTextAnchor080"/>ices and how to manage them using <strong class="source-inline">init</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">systemd</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-81">Summary</h1>
<p>Shell scripting is a very common way of automating periodically running tasks in a Linux system. Sometimes, it evolves to a bigger system chained together with multiple Bash scripts and Python programs to complete complex tasks using multiple smaller tasks that do one thing at the same time in a very <span class="No-Break">reliable way.</span></p>
<p>In modern systems, you will probably see as much Bash as <span class="No-Break">Python scripts.</span></p>
<p>In this chapter, we learned how to create an executable script, as well as how to create a simple backup script that handles errors and generates a new filename on each run. We also added a function that removes old backups so that we can avoid filling the disk space. Additionally, as a side effect, we learned how to create a new PostgreSQL database and allow access to it from a <span class="No-Break">local system.</span></p>
<p>In the next chapter, we’ll learn h<a id="_idTextAnchor081"/>ow to create Linux services and how to <span class="No-Break">manage them.</span></p>
<h1 id="_idParaDest-82">Exercises</h1>
<p>Try out the following exercises to test your knowledge of <span class="No-Break">this chapter:</span></p>
<ol>
<li>Write a function that will list all databases and feed that list to the for loop <span class="No-Break">we’ve created.</span></li>
<li>Change a date timestamp into another format of <span class="No-Break">your choosing.</span></li>
<li>Catch any errors the <strong class="source-inline">find</strong> function could return (for example, it couldn’t delete <span class="No-Break">a file).</span></li>
</ol>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer015">
<h1 id="_idParaDest-83" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor082"/>Part 2: Your Day-to-Day DevOps Tools</h1>
<p>In this second part, we will learn about Linux internals. Starting with managing services and networking, we will then move on to look at the most common tools, such as Git <span class="No-Break">and Docker.</span></p>
<p>This part has the <span class="No-Break">following chapters:</span></p>
<ul>
<li><a href="B18197_05.xhtml#_idTextAnchor083"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing Services in Linux</em></li>
<li><a href="B18197_06.xhtml#_idTextAnchor098"><em class="italic">Chapter 6</em></a>, <em class="italic">Networking in Linux</em></li>
<li><a href="B18197_07.xhtml#_idTextAnchor147"><em class="italic">Chapter 7</em></a>, <em class="italic">Git, Your Doorway to DevOps</em></li>
<li><a href="B18197_08.xhtml#_idTextAnchor166"><em class="italic">Chapter 8</em></a>, <em class="italic">Docker Basics</em></li>
<li><a href="B18197_09.xhtml#_idTextAnchor245"><em class="italic">Chapter 9</em></a>, <em class="italic">A Deep Dive into Docker</em></li>
</ul>
</div>
<div>
<div id="_idContainer016">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer017">
</div>
</div>
</div></body></html>