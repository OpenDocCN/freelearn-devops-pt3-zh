<html><head></head><body>
		<div id="_idContainer100">
			<h1 id="_idParaDest-114" class="hapter-number"><a id="_idTextAnchor155"/>8</h1>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor156"/>Understanding Event-Driven Architecture</h1>
			<p class="author-quote">Al freir de los huevos lo vera. (It will be seen in the frying of the eggs.)</p>
			<p class="author-quote">– Miguel de Cervantes (Don Quixote)</p>
			<p>In any application, everything can be divided into <strong class="bold">events</strong>. Events are triggered either by some interaction with an external actor (either another application or a user) or by other events. An application is basically the triggering of multiple sequences of events to perform some sort of function. Google Drive, for example, is an application, and its function is just storage. Of course, this is an oversimplification and there are a lot of things that go into storing, organizing, and serving files, but that is the basic gist of it. It functions based on a series of events, each of which comes from a <span class="No-Break">certain source.</span></p>
			<p>Now, different events require different technologies, frameworks, and libraries within the system to interact with each other in perfect harmony. When this harmony is naturally achieved, it is a thing of beauty. However, it almost never is. There is always some sort of bottleneck or some custom part that needs to be made, and it almost always concerns the data that comes from an event. You can have the perfect tool for your system but it’s useless if it cannot process the events that it receives. So, what conclusion did all the brainiacs come up with when they realized this? They figured out that there are no perfect systems, nor are there perfect events. What is required is a system that is not tightly bound to any sort of data processing, a system that can take a bit of human error. Not a less precise system, but one that works with the realities of the situation that it has been put in: a loosely <span class="No-Break">coupled system.</span></p>
			<p>Systems such as these are built so that they take events from multiple sources and process them for output in the simplest way possible. They break down every single event and event handler into their own components. These components then interact with other components based entirely on the input they receive and the output they give. If it can be helped, no component is fully dependent on the other. A system like this may seem inefficient, but when the goal is reliability in an unreliable world, it becomes <span class="No-Break">quite appealing.</span></p>
			<p>So, now that I have finished my customary monologue, let’s look at how to break down that unnecessary monolith. In this chapter, you will learn about <span class="No-Break">the following:</span></p>
			<ul>
				<li>The basic concepts behind and use of <strong class="bold">Publisher/Subscriber</strong> (<span class="No-Break"><strong class="bold">Pub/Sub</strong></span><span class="No-Break">) architecture</span></li>
				<li>The general concept behind <strong class="bold">loosely coupled architecture</strong> and why Python is already well suited <span class="No-Break">for it</span></li>
				<li>The effective industry standard for breaking down a monolithic application into smaller <span class="No-Break">loose components</span></li>
			</ul>
			<p>There will also be some Python, as well as some other things. In fact, that is exactly what I am about to get into <span class="No-Break">right now.</span></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor157"/>Technical requirements</h1>
			<p>The following may help you in fully benefiting from <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Python installed with the <span class="No-Break"><strong class="sour e-inline">confluent-kafka</strong></span><span class="No-Break"> library</span></li>
				<li>An <span class="No-Break">AWS account</span></li>
				<li>An open mind (figuratively, not literally; well, if you want to do so literally, it’s fine but I don’t <span class="No-Break">recommend it)</span></li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor158"/>Introducing Pub/Sub and employing Kafka with Python using the confluent-kafka library</h1>
			<p>Before we get into what the modern Pub/Sub model is, let’s go into a bit of detail about the technology that made this field possible: <strong class="bold">Apache Kafka</strong>, the third most famous Kafka after Franz and <em class="itali">Kafka on the Shore</em>. Originally designed for use in LinkedIn (a great website), it was made open source in early 2011. The concept behind it was pretty simple: there is a log of information and events that any number of systems can consume, and data can be published to the log for consumption by these systems. Sound simple enough? Well, it is now, but it took some thinking to come up with it. But this is the system that is responsible for most modern data infrastructure that we see today. Have you ever gotten a notification on your phone? It is because of this library. Have you ever made a contactless payment with your phone or credit card? Chances are, Kafka’s in there. Ever gotten a notification for a YouTube video? <span class="No-Break">Definitely Kafka.</span></p>
			<p>In most cases where raw unadulterated Kafka is used, the distributor of information is called the <strong class="bold">producer</strong> and the receiver of said information is called the <strong class="bold">consumer</strong>. In most modern nomenclature, as well as with most cloud services, they are instead called the <strong class="bold">publisher</strong> and <span class="No-Break">the </span><span class="No-Break"><strong class="bold">subscriber</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B21320_08_1.jpg" alt="Figure 8.1 – Events processing with the ﻿Pub/﻿Sub model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Events processing with the Pub/Sub model</p>
			<p>Before we dive into the use of Kafka and Python in DevOps, we must first look at a sample usage of Kafka with Python using the <span class="No-Break"><strong class="sour e-inline">confluent-kafka</strong></span><span class="No-Break"> library:</span></p>
			<ol>
				<li>Let’s first install the library <span class="No-Break">using </span><span class="No-Break"><strong class="sour e-inline">pip</strong></span><span class="No-Break">:</span><pre class="sour e- ode"><strong class="bold">pip install confluent-kafka</strong></pre></li>
				<li>Now, as mentioned before, Kafka is divided between a producer and a consumer. So, let’s first write a piece of code that creates <span class="No-Break">a producer:</span><pre class="sour e- ode">from confluent_kafka import Producer
import socket
conf = {'bootstrap.servers': '&lt;host_name&gt;:9092',
        'client.id': socket.gethostname()}
producer = Producer(conf)</pre></li>
				<li>This code will configure a producer. Replace <strong class="sour e-inline">host_name</strong> with the name of an Apache Kafka cluster (online or locally). Next, we need to use the configured producer to send some data. Let’s look at that <span class="No-Break">code now:</span><pre class="sour e- ode">producer.produce(topic, key="key", value="value")</pre><p class="list-inset">Here, <strong class="sour e-inline">topic</strong> is the location where the publisher or producer will distribute their content for it to be consumed. The <strong class="sour e-inline">key</strong> and the <strong class="sour e-inline">value</strong> elements are the keys and values that will be distributed by <span class="No-Break">the producer.</span></p></li>
				<li>Let’s now add some code for a consumer that will pick up messages sent by <span class="No-Break">the producer:</span><pre class="sour e- ode">from confluent_kafka import Consumer
conf = {'bootstrap.servers': '&lt;host_name&gt;:9092',
        'group.id': '&lt;group_id_here&gt;',
        'auto.offset.reset': 'smallest'}
consumer = Consumer(conf)</pre><p class="list-inset">The consumer now listens on the same host that the producer sends messages on. So, when the producer produces a message, the consumer can consume it. When a consumer is subscribed to a topic, that consumer is constantly listening to the message at certain intervals. Once the message arrives, it will begin the process of interpreting the message and sending it to the <span class="No-Break">appropriate location.</span></p></li>
				<li>To have the consumer continually listen to the producer for messages, we can place it in <span class="No-Break">a loop:</span><pre class="sour e- ode">while True:
msg = consumer.poll(timeout=1.0)
if msg is None: continue
break
#If msg is not None, it will break the loop and the message will be processed</pre></li>
			</ol>
			<p>This is simply understanding the way that these Pub/Sub mechanisms work. In application, it is much easier since some sort of mechanism to perform this will already be provided for you. This is, however, a good way to learn how to make custom Pub/Sub structures if you want to, and to just understand Pub/Sub structures <span class="No-Break">in general.</span></p>
			<p>Here’s what the key takeaway from this should be: this is how the world works. Exactly like this. Most of the things that come to your phone come from this. Most of the things that go out of your phone go to this. It’s also true on a more fundamental level as well, as we will see in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor159"/>Understanding the importance of events and consequences</h1>
			<p>Alright, so now you are in on the secret. Everything is push and pull. People just toss data out there and hope it hits something. And if you’ve also realized that that is the most effective approach toward growth and development, kudos to you. If you haven’t, well, we are about to go into a little <span class="No-Break">story time.</span></p>
			<p>I currently live in Uppsala, Sweden, and for quite a while, I thought I was the only person from Nepal who lived here. Now, Uppsala is a big town by Swedish standards and a lot of students from all over the world live here as well. But, even if Nepalese people lived here, how would I have known them? Something that specific is very hard to find, even in this day and age. But then, the most remarkable set of coincidences (some may even say events, eh?) happened, which brought me into contact with other people from Nepal. I only realized just how remarkable they were once I backtracked through all <span class="No-Break">of them.</span></p>
			<p>I had just recently gotten a job offer (the one that I currently have) in Stockholm and I was getting on the train to Stockholm to iron out the details. On the train, I met a friend of mine with whom I collaborate on projects at the student union in Uppsala. In fact, we had met just the other day to discuss those projects. I saw him and sat down next to him, and I saw that he was with two other friends. One of them was a teaching assistant on a project that I had to submit the very next day. That was cool, but that wasn’t even the most important event that happened on the train. His other friend and I got to talking and, through him, I got the number of another Nepalese person who was also living in Uppsala. What kismet! Through that person, I have actually managed to find almost a dozen others who live in the same town as me, who have come on the <span class="No-Break">same journey.</span></p>
			<p>So, here’s the thing: I skipped to the end of this story because, in a way, that’s how we live our lives, trying to finish something up and get to the end of the story to begin a new one. It is how we read, how we consume content, and basically, how we behave socially. But, over time, I contemplated the story, and I thought back to the set of events that had brought me up to that point, so let’s backtrack (and I promise there is a satisfying conclusion to this that isn’t just me bragging about <span class="No-Break">my luck):</span></p>
			<ul>
				<li>I met my friend who introduced me to his friend on the student union <span class="No-Break">developer team</span></li>
				<li>I joined that team to try and make some new friends in Uppsala, but the information for that came from a WhatsApp group that I joined based on a recommendation from another friend from <span class="No-Break">my faculty</span></li>
				<li>I became friends with him before we even joined the faculty because we ended up on a student nation tour (look up Uppsala student nations for a fun and <span class="No-Break">interesting read)</span></li>
				<li>I joined that tour because of the recommendation that I got on my first day in Uppsala during <span class="No-Break">my orientation</span></li>
			</ul>
			<p>But this is the saner half of the event tree that led to this event. The other half is even <span class="No-Break">more interesting:</span></p>
			<ul>
				<li>I was on that train because I went to sign a <span class="No-Break">job contract.</span></li>
				<li>I got the offer for that job because I made a post about having all 11 Google Cloud certifications on the Google forums, and the company that I currently work for just happened <span class="No-Break">to notice.</span></li>
				<li>I made that post exclusively because I got all 11 of those certifications. I got the last one on the day before I left for Sweden. Had I only gotten 10, I wouldn’t have <span class="No-Break">made it.</span></li>
				<li>I got those certifications largely as a sort of reinforcement of the knowledge that I wanted to deliver with <span class="No-Break">this book.</span></li>
				<li>I got the offer for this book from my publisher after applying for it based on the link that I found in one of their other books, which was a Google Cloud <span class="No-Break">examination book.</span></li>
			</ul>
			<p>So, in a roundabout way, writing this book helped me secure the job I have today, and it eventually led to me finding more Nepalese people in Uppsala. If you couldn’t be bothered with all of that, let me show it to <span class="No-Break">you visually:</span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B21320_08_2.jpg" alt="Figure 8.2 – The events that drove a part of my life"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – The events that drove a part of my life</p>
			<p>The events in our lives lead to the most extraordinary circumstances, and this was just one of the <a id="_idIndexMarker298"/>events that came about from this whole saga. Several other remarkable things happened through all of this that made me realize that the true consequences <a id="_idIndexMarker299"/>of our actions are truly unpredictable and yet, most of the time, a lot better or at least more exciting than anything we could have <span class="No-Break">possibly planned.</span></p>
			<p>Self-indulgent? Probably. But that is the magic of DevOps. Conforming to tight structures and solid preconceived notions leads to fear and stunts growth. They hide and overshadow opportunities that spontaneity brings. There is no room to find, discover, and fail. Yes, fail, because in something so tightly packed as a monolith, failure can be disastrous. In something loosely coupled, failure is simply a growth opportunity. You can move pieces in and out and iterate to your best possible version. You may look at my story and say that a lot of it is luck and coincidence – for example, in finding the exact person I needed on the train or just happening to have my forum post viewed – but luck is simply an amalgamation of one’s sustained attempts. People sometimes get lucky once or twice, but people who are not afraid to fail and who go with the flow are found to be lucky a lot more. God hates <span class="No-Break">a coward.</span></p>
			<p>So, switching <a id="_idIndexMarker300"/>gears to something a little less philosophical, loosely coupled architecture is a sort of framework you can use to achieve this kind of meaningful <a id="_idIndexMarker301"/>event-based system in your workload. This entire passage was initially supposed to be the next section before it took a life of its own (spontaneity, amirite?). So, let’s dive into the actual nitty-gritty now and see what we <span class="No-Break">can find.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor160"/>Exploring loosely coupled architecture</h1>
			<p>Alright, in a vacuum, loosely coupled architecture seems like a bad idea. You disperse your components so much that there is no rhyme or reason as to how any information gets from <a id="_idIndexMarker302"/>one place to another. You can’t count any sort of consistent time for all your data to collate into one place for the thing you want to happen to <span class="No-Break">actually happen.</span></p>
			<p>However, there are a few factors that make loosely coupled architecture so effective in a practical setting. These factors are both philosophical and architectural. Firstly, no matter how well you design a system, it will fail somewhere at some time. The loosely coupled architecture allows the system to fail gracefully and to recover from failures in a way that doesn’t affect other components and users of the system. Because each component is isolated, these components can be identified after a single failure (a lot of the time, a clone component will succeed). This failure can be logged and detected and the correct parties can be notified without any interruption to the system. The failed component will not disrupt activities and it is not considered to be a bad thing. In fact, failure teaches us the weaknesses and shortcomings of the system, which can then be worked on quickly because you are only working on that <span class="No-Break">isolated component.</span></p>
			<p>The next factor comes from availability. Loosely coupled architecture offers small components that are replicated for each individual use. Now, you would say that this is a limit in and of itself since even if you can divide the resources between users, there won’t be enough resources to go around. In the past, this would have been true, but with modern applications running on the cloud, there can be infinite provisioning for services that support a loose architecture. You can handle the volume of resources effectively because the scale for the services that can run this kind of architecture is nearly infinite. This results in an environment where an architecture that will provision based on use becomes the optimal architecture. A more tightly coupled architecture might suit more limited means, but that is not the case for scenarios with flexible resources and <span class="No-Break">unknown loads.</span></p>
			<p>Finally, the last factor that puts loosely coupled architecture in the lead is laziness. Yes, laziness. I have found in my life that the leading cause behind my laziness is not the fact that I don’t want to do something, but rather because my brain is overwhelmed with useless information about something that I might want to do. I started actually getting somewhere <a id="_idIndexMarker303"/>when instead of trying to figure out these minutiae in a way that was ineffective and useless, I just started doing things and figuring them out as I went along. That’s basically why loosely coupled architecture is good. There are fewer things to worry about and it is easier to work on. Instead of worrying about every single little thing before you even start implementing the system, you can just start implementing and worry about optimization later. This is perfect for someone like me who uses this approach for practically everything, and it’s the same for some of the biggest companies in the world as well. If you’ve heard of the Toyota way, it essentially follows the same principle: making mistakes and learning from them to get better. You can look it up; I encourage you to. But, in conclusion, this type of architecture is for the lazy, pragmatic developer who is just trying to <span class="No-Break">get somewhere.</span></p>
			<p>For the past several paragraphs, you have endured my philosophical rants, and now we get to the more pragmatic part where I show you stuff and try to reinforce what I ranted about. So, that is what we’re going to get into right now. We are going to make a basic application (just a lambda function, actually) that is triggered when an image is uploaded into an S3 bucket, takes the image and resizes it to a standard size, deletes the original image, and replaces it with the <span class="No-Break">resized one:</span></p>
			<pre class="sour e- ode">import osimport tempfileimport boto3from PIL import Images3 = boto3.client('s3')def lambda_handler(event, context):    # Get the name of the bucket and the image name when upload is triggered.    bucket = event['Records'][0]['s3']['bucket']['name']    key = event['Records'][0]['s3']['object']['key']    new_width = 300 #width of image    new_height = 200 #height of image    with tempfile.TemporaryDirectory() as tmpdir:        # Download the original image from S3 into a pre-defined temporary directory        download_path = os.path.join(tmpdir, 'original.jpg')       #download the S3 file into the temporay path        s3.download_file(bucket, key, download_path)        with Image.open(download_path) as image:            image = image.resize((new_width, new_height))            # Save the resized image in its own path            resized_path = os.path.join(tmpdir, 'resized.jpg')            image.save(resized_path)        # Upload the resized image back to the S3 bucket and delete the original       s3.delete_object(Bucket=bucket, Key=key)       s3.upload_file(resized_path, bucket, key)    return {        'statusCode': 200,        'body': 'You don't really need this because its not for people!'    }</pre>
			<p>This is a simple code for a very simple yet important function. The trigger for the image conversion can be placed either at the lambda function or the S3 bucket itself. If you have ever used one of those online services that convert your PDF to a Microsoft Word document or convert your WAVs into MP3s, they basically run on this concept. Even with a very minimal interface, they can be very effective and <span class="No-Break">quite popular.</span></p>
			<p>Perhaps before <a id="_idIndexMarker304"/>reading this book, you may have had the misconception that building some of these services might be difficult. In the world we live in, they are not. Once we have opened these horizons, everything becomes clearer, and one of the things that becomes clearest of all is the ability to move on from the old inefficient ways into newer, simpler ways. Let’s look at the path to <span class="No-Break">that transition.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor161"/>Killing your monolith with the strangler fig</h1>
			<p>If you oppose <a id="_idIndexMarker305"/>killing anything (and I understand), simply <a id="_idIndexMarker306"/>change the word/s in your mind to happier ones (such as “sleeping” or “napping”). But the <strong class="bold">strangler fig</strong> is being talked about here <a id="_idIndexMarker307"/>because it is one of the most prominent methods in the <strong class="bold">digital transformation</strong> and/or modernization of applications. You may have heard the term <a id="_idIndexMarker308"/>digital transformation and immediately dismissed it as some buzzword, which, fair enough, most of the time when people use that word, it is. But open your eyes and ears for a moment and treat the term for what it actually is: it <a id="_idIndexMarker309"/>is changing old things into new things. It is basically <a id="_idIndexMarker310"/>changing your system from within while either maintaining the same functionality or increasing functionality. It is the breaking of the monolith into a loosely <span class="No-Break">coupled architecture.</span></p>
			<p>For starters, let’s look at the potential structure of a <span class="No-Break">monolithic application:</span></p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B21320_08_3.jpg" alt="Figure 8.3 – A basic monolith"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – A basic monolith</p>
			<p>It’s quite crude, but that is basically how most monolithic applications are structured. They have a user interface, which interacts with two different types of operations: operations on the database and generic data operations (<strong class="bold">Misc</strong> in the diagram). Even this monolith is rather more divided than regular monoliths since we have given it a separate database. The database can also be directly within the <span class="No-Break">monolith sometimes.</span></p>
			<p>Breaking down this monolith is not just about making it disassociated; it is about making sure that each component can act as an individual entity in case it becomes of use in some other project or in a different way in the same project. But to continue with the breaking <a id="_idIndexMarker311"/>down of this monolith, we can keep that going by first <a id="_idIndexMarker312"/>removing the miscellaneous functions that require no interaction with the users or the database from <span class="No-Break">the monolith.</span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B21320_08_4.jpg" alt="Figure 8.4 – Removing miscellaneous APIs from the monolith"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Removing miscellaneous APIs from the monolith</p>
			<p>So, this diagram indicates that the separation between the monolith and the miscellaneous functions divides those functions into individual components. This is the foundation of serverless architecture. It is all about exclusively having individual functions as individual endpoints to call only for certain use cases. This stage helps get the easy stuff out of the way and also helps make it so that the people performing the transformation can practically start grasping the concept behind it. It’s a lot easier to manage random functions if they are just endpoints somewhere that you can call randomly and modify to suit <span class="No-Break">certain needs.</span></p>
			<p>Now, the next step toward breaking down this monolith is the division of the user interface and <a id="_idIndexMarker313"/>the backend portion that performs the data <a id="_idIndexMarker314"/>operations. This involves placing an API or a backend for the frontend in <span class="No-Break">between them.</span></p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B21320_08_5.jpg" alt="Figure 8.5 – A fully decoupled architecture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – A fully decoupled architecture</p>
			<p>The final structure after breaking down the monolith looks like <span class="No-Break"><em class="itali">Figure 8</em></span><em class="itali">.5</em>. It’s a bit like my consequences diagram but not as foolish. There are a lot of moving parts here, but then again, there are a lot of moving parts in cars too; it’s what makes them work. More importantly, let’s look at this from the lens of the two things emphasized in this chapter, availability <span class="No-Break">and failure:</span></p>
			<ul>
				<li>If the user interface for some reason stops loading, it will fall back to a different region. This region will have the same capabilities; if it’s further from the user, it might be slower, but it will do <span class="No-Break">the job.</span></li>
				<li>The API or backend for the frontend can receive calls from multiple user interfaces and can access multiple servers that have access to <span class="No-Break">the database.</span></li>
				<li>The backend can then simply be there to connect to the database for operations. There is no need for anything there except <span class="No-Break">for queries.</span></li>
				<li>The database itself becomes more secure due to the layers present and it becomes easier to increase <span class="No-Break">its availability.</span></li>
				<li>The miscellaneous functions are simply endpoints that can be put in or taken out as it suits the <span class="No-Break">development team.</span></li>
			</ul>
			<p>Well, that is <a id="_idIndexMarker315"/>quite the process, isn’t it? But it is one that <a id="_idIndexMarker316"/>gives results and helps make your application or workload more sustainable and futureproof. It doesn’t work for every workload, but it is fantastic in helping older systems use modern <span class="No-Break">technology better.</span></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, you learned about the event-driven architecture that comprises a lot of modern application development. You also, hopefully, learned about actions and their consequences and how important positive actions are to development and your life in general. Lastly, you learned about a way to modernize older applications toward this new philosophy through the use of the <span class="No-Break">strangler fig.</span></p>
			<p>In the next chapter, you will get even more hands-on with Python and learn about the role that Python can play in <strong class="bold">CI/CD</strong> (short for <strong class="bold">continuous integration/continuous delivery</strong>). It’s a fun topic and will help you implement the Python skills and concepts you’ve been studying in <span class="No-Break">this chapter.</span></p>
		</div>
		<div id="_idContainer101" class="Content">
			<p class="hidden"><a id="_idTextAnchor163"/><a href=""/></p>
		</div>
		<div id="_idContainer102" class="Content">
			<p class="hidden"><a id="_idTextAnchor164"/></p>
		</div>
	</body></html>