- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enriching DevOps Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we take a holistic approach to DevOps, examining the critical
    role of metrics in enhancing development processes, the integration of security
    practices through DevSecOps, and strategies for scaling collaboration effectively
    within organizations. We will delve into how metrics, enabled by tools such as
    GitHub, drive visibility and performance, explore methods to seamlessly embed
    security into the development lifecycle, and discuss fostering a collaborative,
    trust-based culture, emphasizing InnerSource principles to effectively scale DevOps
    practices. This comprehensive overview aims to provide a nuanced understanding
    of the multifaceted nature of modern DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main headings in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging metrics in DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevSecOps – Security as a continuous matter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling the collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging metrics in DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What does it mean to measure metrics in DevOps? Measuring metrics in DevOps
    is about quantifying various aspects of the software development and delivery
    process to improve efficiency, quality, and collaboration. Metrics provide a data-driven
    approach to assess performance, identify bottlenecks, and inform decision-making.
    They are critical for continuous improvement, enabling teams to track progress
    against objectives and align efforts with organizational goals.
  prefs: []
  type: TYPE_NORMAL
- en: In DevOps, metrics can be categorized into different types. Performance metrics,
    such as deployment frequency and change lead time, measure the efficiency of the
    deployment pipeline. Quality metrics, such as defect rates and mean time to recovery,
    assess the stability and reliability of the software. Process metrics look at
    the efficiency of development processes, and people metrics focus on team performance
    and satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Tools and automation are essential for effectively measuring these metrics.
    **Continuous Integration**/**Continuous Deployment** (**CI**/**CD**) tools such
    as **GitHub Actions**, issue tracking systems, and application performance monitoring
    tools are commonly used to collect and analyze data. We will now cover some well-known
    metrics measurements and ideas.
  prefs: []
  type: TYPE_NORMAL
- en: Four keys – DORA metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **DevOps Research and Assessment** (**DORA**) metrics, introduced in the
    influential book *Accelerate* by Nicole Forsgren, Jez Humble, and Gene Kim, have
    become a key framework in software development. These metrics, often referred
    to as the **four keys**, go beyond being mere indicators; they offer a comprehensive
    approach to assessing and improving DevOps practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list helps with understanding DORA metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment frequency**: This measures how often you successfully release
    to production. Aim for regular, smaller deployments. This approach reduces risks
    and encourages a culture of continuous feedback and improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lead Time for changes**: This tracks the time from code commit to production
    deployment. Shortening this time by streamlining development and QA processes
    can boost your team’s efficiency and ability to adapt to market changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change failure rate**: This metric assesses the percentage of deployments
    that fail in production. Improving testing, quality assurance, and monitoring
    can lower these failures, enhancing the quality of your releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mean Time To Recovery (MTTR)**: This measures the average time to recover
    from a failure in production. Developing robust incident response strategies and
    investing in automation can help reduce this time, ensuring greater system reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are the following reasons why so many teams love and use these metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Objective insights**: DORA metrics provide clear, quantifiable insights into
    your team’s performance, supporting data-driven decisions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A path to improvement**: Identifying strengths and weaknesses through these
    metrics helps target areas for improvement in your DevOps practices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Industry benchmarking**: These metrics allow you to compare your practices
    with industry standards, aiming to reach and maintain best practices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, as with any metric, these indicators are a means to measure, not a
    goal in themselves. Let us note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context matters**: Always interpret these metrics within your organization’s
    unique context and goals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beyond the numbers**: Remember to balance these quantitative measures with
    qualitative aspects such as team morale and customer satisfaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stay adaptable**: As your organization and the industry evolve, so should
    your approach to these metrics'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teams are often classified into four performance levels—elite, high, medium,
    and low—based on these metrics. The ultimate goal is to reach **elite** status,
    which signifies a high-performing, agile, and efficient DevOps environment.
  prefs: []
  type: TYPE_NORMAL
- en: The DORA metrics offer a valuable lens through which to view and enhance your
    DevOps practices. Thoughtfully applying these metrics can lead to a more efficient,
    quality-driven, and effective software development process, positioning your organization
    to excel in the ever-changing landscape of technology.
  prefs: []
  type: TYPE_NORMAL
- en: SPACE framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While DORA metrics focus on the specific operational aspects of DevOps, the
    SPACE framework, introduced by Dr. Nicole Forsgren and her colleagues, complements
    this by broadening the perspective to encompass **Developer Experience** (**DevEx**).
    This dual approach allows organizations to balance technical excellence with a
    deep consideration of the human factors that drive successful software development.
  prefs: []
  type: TYPE_NORMAL
- en: Developed by Dr. Nicole Forsgren, along with her collaborators, the SPACE framework
    provides a multi-dimensional view of software development, considering aspects
    beyond the traditional scope of DevOps. **SPACE**, an acronym for **satisfaction
    and well-being, performance, activity, communication and collaboration, and efficiency
    and flow**, offers a holistic strategy to improve both the technical and human
    sides of development teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the elements of the SPACE Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Satisfaction and well-being**: Prioritizing the mental and emotional health
    of developers, recognizing that their satisfaction and well-being directly impact
    productivity, innovation, and effectiveness.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Reframing traditional performance metrics to include not just
    speed and output but also quality and the overall impact on project and organizational
    goals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Activity**: Focusing on optimizing the daily workflows and tasks of developers
    to align with both the project’s objectives and individual career aspirations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication and collaboration**: Encouraging open communication and effective
    collaboration is crucial for breaking down silos and fostering cohesive progress
    in development projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency and flow**: This involves aiming for a state of flow in work processes
    where developers can work seamlessly, leading to improved creativity and high-quality
    output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SPACE framework adds a vital dimension to DevOps strategies by emphasizing
    that technical efficiency and success cannot be fully realized without considering
    the well-being and satisfaction of the team. This holistic view is key to setting
    leading organizations apart, as it acknowledges the importance of a positive developer
    experience for sustainable growth and innovation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the benefits of integrating the SPACE framework in DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Comprehensive development strategy**: By including human-centric aspects,
    the SPACE framework ensures a more balanced and thorough approach to software
    development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced team dynamics**: Focusing on satisfaction, communication, and collaboration
    leads to a more motivated, cohesive, and effective team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Benchmarking across multiple dimensions**: SPACE allows organizations to
    benchmark not only their technical performance but also their cultural and human-centric
    practices against industry standards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the SPACE framework with DORA metrics provides a more complete picture
    of an organization’s DevOps practices. It ensures that while operational efficiency
    and technical benchmarks are met, the human aspects that are pivotal to the success
    and satisfaction of the development team are also given due attention. This dual
    approach paves the way for a more successful, well-rounded, and sustainable DevOps
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics at GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the multifaceted domain of DevOps, there exists a wide spectrum of metrics,
    each offering different approaches and insights. This document hones in on the
    collaborative dimensions of Git and GitHub, emphasizing metrics that are key to
    understanding and enhancing teamwork within these platforms. Grasping the nuances
    of these specific metrics and how they function is essential for effectively utilizing
    Git and GitHub in a DevOps setting, ensuring a more cohesive and productive collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Insights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub offers an array of features that provide deep insights into various aspects
    of software development, aiding teams in enhancing their development. It tracks
    changes over time in various areas such as contributions, code frequency, and
    repository health. Each of these features plays a crucial role in understanding
    project dynamics, team collaboration, and community engagement.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub metrics can track how healthy collaboration is between repositories,
    their contributors, and teams. In addition, it also provides a bird’s eye view
    of library dependencies with regard to security.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a brief overview of the GitHub Insights features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pulse**: **Pulse** is a feature that gives a quick overview of the activity
    in a repository over a specific period. It helps teams track the progress of their
    project, showing what has been completed and what is still pending, including
    merged pull requests, proposed changes and opened or closed issues. **Pulse**
    is instrumental in giving a snapshot view of the project’s health and momentum:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Pulse in GitHub Insights](img/B21203_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Pulse in GitHub Insights
  prefs: []
  type: TYPE_NORMAL
- en: '**Contributors**: The **Contributors** section offers insights into who is
    contributing to a project and how. It tracks individual contributions, such as
    commits, pull requests, and issues created. This feature is crucial for recognizing
    the efforts of team members and understanding the distribution of work within
    the team:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Contributors in GitHub Insights](img/B21203_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Contributors in GitHub Insights
  prefs: []
  type: TYPE_NORMAL
- en: '**Community**: This section assesses the health of a project’s community by
    tracking aspects such as user engagement and contributor activity. It encourages
    open source best practices, helping to ensure that the project is welcoming and
    inclusive, which is essential for fostering a vibrant and sustainable community:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Community in GitHub Insights](img/B21203_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Community in GitHub Insights
  prefs: []
  type: TYPE_NORMAL
- en: '**Community Standards**: This section provides a checklist to help maintain
    a healthy and welcoming environment for contributors. This includes a code of
    conduct, contributing guidelines, issue and pull request templates, and more.
    Adhering to these standard documentations is to build a respectful and collaborative
    community:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Community standards in GitHub Insights](img/B21203_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Community standards in GitHub Insights
  prefs: []
  type: TYPE_NORMAL
- en: '**Traffic**: Traffic analytics provide data on how many people are viewing
    and interacting with a repository. It includes information on clones, views, visitors,
    and referring sites. Understanding traffic helps gauge the popularity and reach
    of a project, informing strategies for future growth and engagement:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Traffic in GitHub Insights](img/B21203_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Traffic in GitHub Insights
  prefs: []
  type: TYPE_NORMAL
- en: '**Commits**: The **Commits** feature gives a detailed history of changes made
    to the project. It allows teams to track progress, review changes, and understand
    the evolution of the codebase over time. This feature is essential for maintaining
    a comprehensive and traceable record of the development process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Commits in GitHub Insights](img/B21203_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Commits in GitHub Insights
  prefs: []
  type: TYPE_NORMAL
- en: '**Code frequency**: This graphs the volume of additions and deletions to the
    codebase over time. This visual representation helps teams understand coding patterns
    and periods of high activity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Code frequency in GitHub Insights](img/B21203_06_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Code frequency in GitHub Insights
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency graph**: The **Dependencies** tab shows the repository’s dependencies
    and the projects that depend on it. This is crucial for managing third-party libraries,
    understanding potential security vulnerabilities, and ensuring the integrity and
    reliability of the code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Dependency graph in GitHub Insights](img/B21203_06_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Dependency graph in GitHub Insights
  prefs: []
  type: TYPE_NORMAL
- en: '**Network**: The **Network** feature visualizes the repository’s fork network,
    showing the branches and forks from the original repository. This can reveal how
    changes are being merged back into the main project and how the community is contributing
    and branching off:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Network in GitHub Insights](img/B21203_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Network in GitHub Insights
  prefs: []
  type: TYPE_NORMAL
- en: '**Forks**: The **Forks** feature indicates how many times the repository has
    been forked by other users. This metric is a strong indicator of a project’s impact
    and reach within the GitHub community. It can signal active engagement and potential
    areas for collaboration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Forks in GitHub Insights](img/B21203_06_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Forks in GitHub Insights
  prefs: []
  type: TYPE_NORMAL
- en: By utilizing these features, teams and project maintainers can gain a comprehensive
    understanding of their project’s performance, community engagement, and collaborative
    dynamics. These insights are invaluable for making informed decisions, fostering
    community growth, and driving continuous improvement in the development team.
  prefs: []
  type: TYPE_NORMAL
- en: These configurations prove particularly effective for community-based development
    initiatives such as open source, as well as for InnerSource efforts that integrate
    aspects such as community-based culture within a corporate setting. Visualizing
    contributions offers a practical way to grasp an overview of who is contributing
    and how. The balance of documentation on GitHub holds significant importance for
    fostering team collaboration, highlighting the critical role of managing both
    excess and deficiency. However, it is important to note that these insights may
    not universally apply to all projects.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the needs, integrating methodologies, such as the four keys or
    employing the SPACE framework in combination, can offer tailored approaches to
    enhance project outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: Issue metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Measuring issue metrics is a crucial aspect of maintaining a healthy and efficient
    software development environment. These metrics provide invaluable insights into
    how quickly and effectively a team addresses issues, which is a key component
    of the overall DevEx. By tracking metrics such as the number of open issues, the
    time taken to close an issue, and the backlog of issues, teams can gauge their
    responsiveness and problem-solving abilities. This, in turn, directly impacts
    the team’s productivity, satisfaction, and the quality of the software they produce.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub Action `issue-metrics`, available at `github/issue-metrics` ([https://github.com/github/issue-metrics](https://github.com/github/issue-metrics)),
    serves as a powerful example of how teams can automate and simplify the process
    of tracking issue-related metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following GitHub Action measures several key metrics by searching for issues,
    pull requests, and discussions in a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – issue-metrics works with GitHub Actions](img/B21203_06_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – issue-metrics works with GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: It generates a comprehensive report in the form of a GitHub issue, offering
    a clear and organized view of the data. The items to be analyzed can be filtered
    using a search query, making the tool adaptable to various needs and contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the available metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time to first response**: Measures the duration from the creation of an issue
    to the initial comment or review, giving insights into the team’s initial engagement
    with new issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time to close**: Tracks the period from the creation of an issue to its closure,
    indicating the overall speed of issue resolution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time to answer (discussions)**: Specifically for discussions, this metric
    measures the time from creation to an answer, reflecting the team’s engagement
    in discussions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LABELS_TO_MEASURE` environment variable to be set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging a tool such as `issue-metrics` can significantly enhance a team’s
    ability to monitor and improve their issue-handling processes. This not only boosts
    the efficiency of the development cycle but also plays a vital role in maintaining
    a positive developer experience and a healthy team dynamic. There is a lot of
    data that can be taken from GitHub. Let’s find out what works for your team.
  prefs: []
  type: TYPE_NORMAL
- en: Pull request metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pull request metrics are crucial in understanding the dynamics of code reviews
    and the team’s capacity to adapt to and integrate new changes. Metrics such as
    the time taken to merge a pull request and the ratio of opened-to-closed pull
    requests provide valuable insights into the efficiency of the code review process,
    the team’s responsiveness, and their collaborative effectiveness. These metrics
    are particularly useful in identifying bottlenecks and fostering improvements
    in collaboration and code quality. Since the closure of an issue often coincides
    with the closure of a pull request, you should be sure to measure not only the
    issue but also the pull request when you measure it. You can also use the `issue-metrics`
    GitHub Action to measure pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of InnerSource, which, as mentioned in [*Chapter 4*](B21203_04.xhtml#_idTextAnchor077),
    refers to the adoption of open source practices within an organization, these
    metrics take on additional significance. InnerSource metrics focus on aspects
    such as cross-team collaboration, the reuse of code across projects, and the contribution
    rates from different teams. In GitHub organizations, the concept of **teams**
    allows for defining groups of members belonging to specific functional or organizational
    areas. By analyzing pull requests, organizations can measure the extent of collaboration
    that occurs outside these defined teams. This is particularly valuable for gauging
    the effectiveness of InnerSource initiatives, as it reflects cross-team interaction
    and distributed contribution models.
  prefs: []
  type: TYPE_NORMAL
- en: Quantifying the number of collaborations that transcend team boundaries is a
    crucial metric for organizations promoting InnerSource and distributed contribution
    models. It highlights how open collaboration practices are being embraced across
    different segments of the organization and can pinpoint areas where more effort
    is needed to break down silos.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, leveraging metrics in DevOps is about more than just tracking
    numbers. It is about using data to drive better software delivery practices, enhance
    team collaboration, and continuously improve the overall health of development
    processes. By carefully selecting and analyzing these metrics, organizations can
    create a more efficient, responsive, and collaborative development environment.
  prefs: []
  type: TYPE_NORMAL
- en: DevSecOps – Security as a continuous matter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the traditional approach to software development, security was often relegated
    as a final step, typically handled by a dedicated security department or outsourced
    to external vendors. This method, while standard, led to security considerations
    being somewhat isolated from the core development process. Security assessments
    were conducted at specific checkpoints, often resulting in the identification
    of vulnerabilities late in the development cycle when they were more challenging
    and costly to address.
  prefs: []
  type: TYPE_NORMAL
- en: However, the landscape of software development and security has undergone a
    significant transformation. In today’s fast-paced, continuously evolving digital
    environment, treating security as an afterthought is no longer viable. Security
    concerns need to be interwoven throughout the development process, not tacked
    on at the end. This shift in perspective and practice gave rise to the concept
    of DevSecOps.
  prefs: []
  type: TYPE_NORMAL
- en: DevSecOps represents a fundamental change both culturally and technically in
    how security is perceived and implemented in software development. It is a methodology
    that integrates security practices within the DevOps process, making security
    a continuous concern rather than a discrete or final phase. In DevSecOps, security
    is not solely the responsibility of a separate team but is a shared responsibility,
    deeply embedded within the DNA of the project lifecycle from its inception.
  prefs: []
  type: TYPE_NORMAL
- en: Security shift-left
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of **shift-left** predates DevSecOps but has been significantly
    embraced and refined within the DevSecOps framework. Traditionally, security was
    often a separate concern, managed by specialized teams, and typically addressed
    late in the development cycle. However, in the DevSecOps era, this paradigm has
    shifted significantly. Security is no longer a distinct responsibility of a dedicated
    security department but has become a shared and integral part of the development
    team’s workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'This integration of security early in the development cycle is not just a procedural
    change; it is a fundamental redefinition of how security is handled. The proactive
    stance of shift-left is essential in today’s fast-paced development environments
    because it enables teams to detect and address security issues much earlier. This
    approach is typically more cost-effective and less complex than trying to rectify
    security issues post-deployment. This proactive strategy is pivotal for several
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Early detection of vulnerabilities**: Integrating security practices from
    the beginning enables teams to identify and mitigate potential vulnerabilities
    early. This not only reduces the risk of security breaches but also lessens the
    complexity involved in fixing issues later in the development cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost-effective security management**: Addressing security issues in the later
    stages of development or after deployment can be significantly more expensive.
    Early integration helps minimize these costs by preventing the escalation of security
    flaws into more serious problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cultural shift in development practices**: Shift-left advocates for a culture
    change where security is the collective responsibility of the entire development
    team, not just a concern for security specialists. This fosters a more holistic
    view of security in the development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevSecOps plays a crucial role in operationalizing the shift-left approach.
    It involves integrating security tools and practices into the CI/CD pipeline,
    ensuring that security checks and balances are an integral part of the development
    workflow. This includes automated security testing, regular code reviews for security
    vulnerabilities, and ongoing monitoring of the software in production.
  prefs: []
  type: TYPE_NORMAL
- en: Security features in GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As for GitHub security capabilities, several features stand out for their effectiveness
    in enhancing the safety and integrity of software development. These include **Dependabot**,
    **code scanning**, **secret scanning** (including push protection), and **dependency
    review**. Each of these functionalities plays a critical role in fortifying the
    security posture of projects managed on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Notably, while code scanning, secret scanning (with push protection), and dependency
    review are part of the **GitHub Advanced Security** suite, at the time of writing,
    they are available for free for public repositories. This accessibility underscores
    GitHub’s commitment to providing robust security tools to a wide range of developers
    and organizations. By leveraging these tools, teams can significantly enhance
    their security practices, ensuring that vulnerabilities are identified and addressed
    promptly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the major security features of each.
  prefs: []
  type: TYPE_NORMAL
- en: Dependabot – Streamlining dependency management and security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In today’s fast-paced software development ecosystem, where open source software
    is extensively utilized, ensuring that dependencies are up-to-date and secure
    has become increasingly challenging. Manually tracking each dependency for updates
    or vulnerabilities is no longer feasible, given the sheer volume and frequency
    of updates in the open source world. This is where Dependabot, integrated into
    GitHub, becomes indispensable. Dependabot, a feature integrated into GitHub, plays
    a vital role in automating this aspect of software maintenance, ensuring that
    projects remain secure and up-to-date with minimal manual intervention. It automates
    the monitoring and updating of dependencies, a task crucial for maintaining the
    security and integrity of applications, thereby addressing a key need in modern
    software development where rapid and continuous deployment is the norm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how Dependabot enhances the development workflow to keep dependencies
    updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic scanning for vulnerabilities**: Dependabot continuously monitors
    the dependencies in your codebase, checking for any known vulnerabilities. This
    includes not just the direct dependencies of your project but also the transitive
    dependencies (the dependencies of your dependencies).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated pull requests for updates**: When an outdated or vulnerable dependency
    is detected, Dependabot does not just stop at notifying you. It goes a step further
    by automatically creating pull requests to update the dependency to a newer, more
    secure version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customizable configuration**: Developers have control over how Dependabot
    operates within their projects. You can configure settings such as the frequency
    of checks, which dependencies to include or exclude, and how to handle versioning
    updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Dependabot for optimal performance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Dependabot is a critical tool for keeping your project dependencies secure
    and up-to-date. To maximize its effectiveness, it is important to understand and
    configure its various settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependabot alerts**: Set up alerts to be notified about vulnerabilities in
    your dependencies. You can manually generate Dependabot pull requests to address
    these vulnerabilities. Configuring alert notifications ensures you are promptly
    informed about potential security issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependabot rules**: This feature allows you to manage how alerts are handled.
    You can review and adjust these settings to ensure Dependabot responds to security
    issues in a way that aligns with your project’s needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependabot security updates**: Enabling this option lets Dependabot automatically
    attempt to create pull requests for every open alert with an available patch.
    For more granular control, you can disable this and specify your preferences using
    Dependabot rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grouped security updates** (**Beta**): This setting groups all updates that
    resolve a Dependabot alert into a single pull request per package manager and
    directory. It is useful for managing multiple updates efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dependabot.yml` file, where you can specify parameters such as frequency,
    directories to check, and package tools to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is Dependabot’s configuration menu. You can enable or disable each of
    the settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Dependabot configuration](img/B21203_06_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Dependabot configuration
  prefs: []
  type: TYPE_NORMAL
- en: Properly configuring Dependabot not only helps to maintain the security of your
    project but also ensures that your dependency management process is smooth and
    aligned with your project’s workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for optimal adoption
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the context of automated dependency management, Dependabot’s role extends
    beyond merely updating packages. For its full potential to be realized, there
    are crucial complementary practices and configurations that teams need to adopt:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration with test automation**: The automatic updating of packages by
    Dependabot necessitates a robust suite of automated tests. This is essential because
    each dependency update, while potentially fixing vulnerabilities, also carries
    the risk of introducing new issues or incompatibilities. A comprehensive set of
    automated tests ensures that any changes introduced by dependency updates do not
    break existing functionality. Therefore, high test coverage is not just beneficial
    but a fundamental requirement for leveraging Dependabot effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient notification management**: Another important aspect is the efficient
    configuration of Dependabot notifications. Without proper management, Dependabot
    can generate an overwhelming number of alerts, leading to notification fatigue
    among team members. This scenario often results in important updates being overlooked
    or ignored, undermining the tool’s effectiveness; to avoid this, it is crucial
    to set up suitable notification configurations that strike a balance between staying
    informed and avoiding excessive alerts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fostering a responsive culture**: Finally, it is vital to cultivate a culture
    where Dependabot alerts are given prompt attention. Ignoring alerts can lead to
    accumulating vulnerabilities, rendering the automated updates ineffective. Teams
    should prioritize addressing Dependabot pull requests promptly or set configurations
    that align with their capacity to handle updates. This might involve scheduling
    updates at a manageable frequency or categorizing the severity of updates to prioritize
    them effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, while Dependabot significantly streamlines dependency management,
    its effectiveness hinges on supporting practices such as high test coverage, efficient
    notification management, and a proactive response culture. These elements work
    together to ensure that automated dependency updates enhance, rather than disrupt,
    the software development process.
  prefs: []
  type: TYPE_NORMAL
- en: Code scanning – Implementing and leveraging automated security analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Incorporating code scanning into your software development process is a proactive
    step towards enhancing the security and quality of your codebase. GitHub provides
    an effective and user-friendly way to implement this through its code scanning
    features. This process involves the automated analysis of your code for potential
    vulnerabilities and coding errors, and it plays a crucial role in the early detection
    and resolution of security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with code scanning
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Enabling code scanning is very simple. The first step is to enable code scanning
    in your GitHub repository settings. This setting is found under the **Security**
    tab in the repository settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Code scanning configuration](img/B21203_06_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Code scanning configuration
  prefs: []
  type: TYPE_NORMAL
- en: Code scanning can be performed using GitHub Actions or by integrating third-party
    tools. GitHub Actions offer a seamless way to automate code scanning within the
    GitHub environment. For specific needs or preferences, third-party tools can also
    be integrated into your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking **Explore workflows**, You will get to the marketplace page and
    can look for GitHub Actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Explore workflows](img/B21203_06_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Explore workflows
  prefs: []
  type: TYPE_NORMAL
- en: 'For the default configuration, click **Set up** in the code scanning configuration
    menu, *Figure 6**.12*, and then **Default** will bring up the basic setup screen.
    You can configure the language settings and enable CodeQL (at the time of writing,
    JavaScript, TypeScript, and Python are supported):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – CodeQL default configuration](img/B21203_06_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – CodeQL default configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Once set up, an initial analysis is performed. You can see the progress of
    the execution of the CodeQL analysis as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – CodeQL Setup](img/B21203_06_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – CodeQL Setup
  prefs: []
  type: TYPE_NORMAL
- en: 'This will run as GitHub Actions, but there will be no YAML file under the `.github/workflows/`
    directory, and the backend will handle and apply the settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – CodeQL Setup completion](img/B21203_06_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – CodeQL Setup completion
  prefs: []
  type: TYPE_NORMAL
- en: 'If the scan result has no security issue, the code scanning shows that it is
    healthy on the page under the **Security** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – When all tools are working as expected](img/B21203_06_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – When all tools are working as expected
  prefs: []
  type: TYPE_NORMAL
- en: 'If any vulnerabilities are found, code scanning will let you know the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Security vulnerability notification](img/B21203_06_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Security vulnerability notification
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an issue directly from the scan result page. To dismiss a code
    scanning result in GitHub, first select the alert you wish to address. Then, choose
    the appropriate dismissal reason: select **False positive** if the alert is invalid,
    **Used in tests** if the alert pertains to code not used in production, or **Won’t
    fix** if the alert is irrelevant to your project. This process helps to refine
    the focus of code scanning to relevant and actionable security alerts.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Security alert contents](img/B21203_06_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Security alert contents
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to make these settings more detailed, you can choose **Advanced**
    instead of **Default** on the configuration page and use YAML to make your own
    settings. If the language requires a build to be analyzed, an **Advanced** setup
    will be required regardless of what level of detail the user would like to set
    code scanning at. You will see the same interface or setup regularly in GitHub
    Actions, where you can configure triggers and other settings as you would for
    typical GitHub Actions and also have the flexibility to handle more complex workflows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – CodeQL Advanced configuration](img/B21203_06_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – CodeQL Advanced configuration
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of code scanning
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Starting with code scanning in GitHub involves enabling the feature in your
    repository and configuring the necessary tools, either through GitHub Actions
    or third-party integrations. The benefits of implementing code scanning are substantial,
    ranging from the early detection of vulnerabilities to seamless integration with
    the development process, ultimately leading to a more secure and robust codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the benefits of code scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scanning for vulnerabilities and errors**: The primary function of code scanning
    is to systematically analyze the codebase for known vulnerabilities and coding
    errors. This includes scanning for issues such as SQL injection, **Cross-Site
    Scripting** (**XSS**), and other common security vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CodeQL for semantic analysis**: An integral part of GitHub’s code scanning
    feature is CodeQL, a powerful tool for semantic code analysis. CodeQL interprets
    the code as a database, enabling more complex and thorough queries to identify
    vulnerabilities that simpler scanning methods might miss.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration with GitHub workflow**: The integration of code scanning tools
    within the GitHub workflow ensures that security checks are a seamless part of
    the development process without causing significant disruption or delay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret scanning and push protection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In today’s cloud-centric software development landscape, the importance of securing
    sensitive information such as API keys, tokens, or credentials cannot be overstated.
    GitHub recognizes this imperative with its secret scanning and push protection
    features, which are crucial for bolstering the security of your repositories.
  prefs: []
  type: TYPE_NORMAL
- en: The practice of hardcoding secrets in code is a risky endeavor. As developers
    increasingly utilize cloud environments, the chances of inadvertently including
    crucial secrets in repository code are higher. Despite being vigilant, there are
    instances where sensitive information can mistakenly be uploaded to a repository.
    In the world of Git, where the core function is to maintain code history and not
    alter it, removing secrets once they are committed can be challenging and sometimes
    nearly impossible. The impact of such exposure is significant, as it can lead
    to security breaches and compromise of sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the need for preventive measures such as **Secret scanning**
    and **Push protection** becomes evident:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Secret scanning configuration](img/B21203_06_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Secret scanning configuration
  prefs: []
  type: TYPE_NORMAL
- en: Secret scanning – Proactive detection of exposed secrets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Secret scanning is a feature that actively scans your repositories to identify
    exposed secrets. This functionality is easily activated through your repository
    settings. Once enabled, it continuously monitors your codebase and, upon detecting
    exposed secrets, alerts you promptly. This immediate notification system allows
    developers and repository administrators to take swift action to secure their
    repositories and the associated services, thereby preventing potential security
    breaches.
  prefs: []
  type: TYPE_NORMAL
- en: Push protection – Preventing accidental exposure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Complementing secret scanning is the push protection feature. This feature adds
    a crucial layer of precaution to your repository’s security measures. When activated
    in your repository settings, this feature operates during push operations. It
    does not perform a blanket check of all code but scrutinizes the changes being
    pushed for the presence of potential secrets or sensitive data. If such risks
    are detected, the push is blocked, thereby preventing the accidental introduction
    of vulnerabilities into your repository.
  prefs: []
  type: TYPE_NORMAL
- en: Together, secret scanning and push protection form a comprehensive defense mechanism
    for your repositories. Secret scanning vigilantly identifies and alerts exposed
    secrets, while push protection acts as a safeguard, preventing the unintentional
    inclusion of sensitive information in your codebase. These features are indispensable
    for maintaining the integrity and security of your software projects, ensuring
    that your code remains secure from inadvertent vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency review – Ensuring secure and informed dependency management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dependency review is designed to detect security risks in code dependencies,
    as defined in the manifest files. It supports various programming languages, with
    JavaScript’s `package.json` and Python’s `requirements.txt` being notable examples.
  prefs: []
  type: TYPE_NORMAL
- en: This becomes particularly crucial during the pull request process. When changes
    are made to manifest files, dependency review automatically checks if these changes
    introduce any security risks. If any risks are detected, the CI job associated
    with dependency review will fail, signaling potential security concerns. This
    integration into the pull request workflow allows for an automated and proactive
    approach to ensuring that any updates or additions to dependencies do not compromise
    the project’s security.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency analysis during pull requests
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Seeing the dependency review is straightforward; you can utilize it in diff
    mode within a pull request to visually verify differences by using the rich diff
    setting on the edited package manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Dependency review in the rich diff mode](img/B21203_06_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – Dependency review in the rich diff mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, dependency review is seamlessly integrated into the pull request
    process on GitHub. You can use `actions/dependency-review-action` ([https://github.com/actions/dependency-review-action](https://github.com/actions/dependency-review-action))
    for this integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Dependency review with GitHub Actions](img/B21203_06_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Dependency review with GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: 'This integration allows teams to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Review dependency changes**: When a pull request involves adding or updating
    dependencies, dependency review provides a clear and detailed view of these changes.
    This includes information about the new or updated packages, their versions, and
    the impact of these changes on the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Analyze security implications**: One of the tool’s key strengths is its ability
    to analyze how changes in dependencies could affect the project’s security. It
    flags potential vulnerabilities introduced by new or updated dependencies, enabling
    teams to assess and address security risks proactively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make informed decisions**: By providing comprehensive insights into dependency
    changes and their implications, dependency review empowers teams to make informed
    decisions. Teams can evaluate the necessity, benefits, and potential risks of
    incorporating new or updated dependencies into their projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The integration of dependency review into the pull request process serves as
    a proactive measure to ensure that all dependency changes are scrutinized for
    security implications before they are merged into the codebase. This proactive
    approach is crucial for maintaining the security integrity of applications, especially
    in an environment where dependencies can often be a source of vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the collaboration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As organizations evolve, the imperative to expand DevOps beyond its traditional
    scope becomes increasingly apparent. This section addresses the critical concept
    of scaling collaboration, an element pivotal for transcending standard DevOps
    practices and embracing a more inclusive organizational approach.
  prefs: []
  type: TYPE_NORMAL
- en: Our journey so far has taken us through the realms of Git, GitHub, GitHub Actions,
    and the DevSecOps worldview, focusing on their individual and collective metrics.
    The next progressive step is to scale these collaborative frameworks. Scaling
    collaboration entails not just enhancing communication within the Dev and Ops
    teams but also broadening your collaborative impact to being organization-wide.
    It is about nurturing a mindset dedicated to positive contributions across all
    organizational levels. It would be great if we could collaborate with different
    teams, not just Dev and Ops.
  prefs: []
  type: TYPE_NORMAL
- en: Why scaling collaboration is imperative
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of DevEx, the need for scaled collaboration becomes even more
    pronounced with the increasing adoption of microservices in cloud architecture,
    which inherently intertwines with DevOps. When various people have dependencies
    on each other, their own work may be potentially stopped by the development of
    others. We have arrived in a world where we need to redefine how we should collaborate
    well with people who have different development styles and priorities and how
    we should relate to the rest of the people on our team. The demand for advanced
    collaborative strategies is at its peak. Additionally, the emergence of platform
    engineering highlights the growing complexity within technology infrastructure
    management, further amplifying the cognitive load on teams. This environment of
    managing sprawling repositories and engaging in continuous collaboration necessitates
    a shift towards viewing code management as a shared organizational resource and
    collaborating well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the absence of sustainable codebase management, organizations face several
    challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased code burden**: Concentrating code maintenance responsibilities
    on a few individuals can lead to burnout and create critical bottlenecks. Code
    maintenance is sometimes neglected. It is often the case that after code is shipped,
    human resources are reduced, and the burden of maintenance becomes more and more
    dependent on a small number of individuals.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code duplication**: A lack of continuous code management often results in
    missing out on leveraging past work, leading to the repetitive and unnecessary
    reinvention of solutions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code as a liability**: Neglected code management can transform code into
    a burdensome liability, characterized by difficulties in upkeep and an increase
    in unmaintained code and noise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting a **distributed contribution model** is essential in such scenarios.
    This model broadens the scope of collaboration and amplifies its impact across
    the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you need to cultivate a collaborative organizational culture. Expanding
    collaboration is synonymous with fostering a healthier organizational culture.
    When team members across the board leverage platforms such as GitHub for open,
    transparent collaboration, it naturally cultivates a highly collaborative atmosphere.
    Such a cultural transformation is instrumental in rendering the organization more
    agile, innovative, and effective.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, scaling collaboration in the realm of DevOps is about more than
    enhancing communication; it is about embracing distributed contribution models
    and nurturing a culture of open collaboration. This approach is key to dismantling
    silos, spurring innovation, and ensuring a responsive and efficient development
    environment, paving the way for a more unified and productive organizational fabric.
  prefs: []
  type: TYPE_NORMAL
- en: InnerSource – Distributed collaboration model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: InnerSource, a term coined by Tim O’Reilly in 2000, represents a significant
    shift in how companies approach software development. It is about leveraging open
    source development methodologies within the confines of an organization, culturally
    transforming to a shared economy model similar to open source. This approach is
    a journey towards breaking down organizational silos while respecting the unique
    culture and internal limitations of the enterprise. InnerSource aims to loosen
    up siloed organizations and enable collaboration with a high degree of transparency.
    It allows engineers within the organization to work more comfortably and happily,
    and enabling lateral collaboration can create synergy between organizations. Such
    synergy will ultimately lead to innovation and organizational strength. What we
    can achieve with InnerSource is not only about breaking down the silos of the
    development team but also about going beyond that.
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed in [*Chapter 1*](B21203_01.xhtml#_idTextAnchor014), InnerSource
    hinges on several key principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Openness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transparency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prioritized mentorship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Voluntary code contribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These principles may sometimes be overlooked in the DevOps context, yet they
    are inherently woven into many existing practices. For example, **Extreme Programming**
    (**XP**) involves the concept of **collective code ownership** (also known as
    **team code ownership** and **shared code**). Platform engineering, another critical
    area, assumes the avoidance of reinventing the wheel. Importantly, diving into
    platform engineering often necessitates InnerSource-style collaboration, as it
    is about distributed contribution rather than a single team bearing all responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: But what exactly constitutes InnerSource? A common misconception is that merely
    using GitHub equates to practicing InnerSource. Well, GitHub is for teams to share
    code, and using the issue and pull request features makes it operate like open
    source-style development. However, as Silona Bonewald, a founding member of InnerSource
    Commons, points out, the challenge is not just about using GitHub to increase
    transparency in code. The real task is to find and nurture the source of open
    source within the company, developing it as a community-centric endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a quote from a well-known book on InnerSource. This quote represents
    the essence of InnerSource.
  prefs: []
  type: TYPE_NORMAL
- en: The idea that GitHub is all that’s needed to be InnerSource is a concept we
    fight against daily. Most people do not realize that it takes much more than GitHub
    to find, create, and grow open source communities. The communities create the
    software, not the other way around, but more often than not, large companies lack
    a sense of holistic community.
  prefs: []
  type: TYPE_NORMAL
- en: – Understanding the InnerSource Checklist, Siona Bonewald.
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub does not automatically lead to a distributed collaboration model.
    In the first place, the concept of InnerSource predates GitHub, emerging at a
    time when such platforms were not yet the norm. InnerSource is fundamentally about
    culture; it is a way of thinking and collaborating that goes beyond tools and
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Crucial repository capabilities for effective InnerSource
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are the necessary repository functions to enable InnerSource collaboration
    and foster a co-operative environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Discoverability**: This involves making codebases, documentation, and related
    materials easily findable and navigable. First of all, this implies the ability
    to search and, moreover, to discover value. No matter how great a library is,
    it is meaningless if searchers do not know how to use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composability**: This involves allowing quick and easy use of source code
    in various contexts. It needs to be versatile enough to be incorporated into many
    different things. Simple, function-specific repositories are preferred over monolithic
    repositories. Of course, if many people are going to use it, it can be large,
    and I am not claiming that a monolithic repository cannot adopt InnerSource. However,
    it would be even better if each component were loosely designed, easy to use,
    and easy to manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONTRIBUTING.md` file. It is good to have a low hurdle to contact the owner
    or maintainer of a given repository. Creating a welcoming atmosphere is important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: This involves ensuring that code can be continuously maintained
    and is essential. Just as many people are reluctant to use an open source repository
    that stopped being updated several years ago, the same is true of InnerSource.
    People will not use a repository that is no longer maintained. In other words,
    InnerSource is not suited to project types, i.e., projects that have a deadline
    and a cutover and that have clearly stated when they will stop updating. Repositories
    need to be maintained on a continuous basis. If you find a useful InnerSource
    seed in such a project, find a way to continue to maintain it organizationally
    rather than stopping development. These are considered essential for success.
    This is also closely tied to the culture of the team. I encourage you to think
    about what would be a good fit for your team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code ownership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In InnerSource, the source code is viewed as belonging to the organization.
    The code is for everyone. However, this does not necessarily mean giving up all
    ownership.
  prefs: []
  type: TYPE_NORMAL
- en: There is a concept of **weak code ownership**. In this ownership style, the
    code is assigned to owners, but developers can change the code owned by others.
    If someone wants to make a change to someone else’s code, they should have a conversation
    with the code owner first.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from that, there is also the concept of **collective code ownership**,
    which is the idea of completely abandoning ownership of the code, but the meaning
    of “*everyone owns the code*” means that, at the same time, “*nobody owns the
    code*.” This can lead to problems of accountability and maintenance continuity.
    In many cases, InnerSource organizations adopt weak code ownership and promote
    collaboration between the host team and guest team.
  prefs: []
  type: TYPE_NORMAL
- en: An asynchronous way of working
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enabling asynchronous collaboration will be necessary to promote the adoption
    of InnerSource in the organization. This derives from contexts such as open source
    development, where teams are distributed around the world and people in different
    time zones collaborate, but there are many other positive aspects as well.
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons why silos can be created within an organization, the
    most prominent of which is probably due to internal politics and other attempts
    to hide information.
  prefs: []
  type: TYPE_NORMAL
- en: The adoption of InnerSource brings transparency to the organization, but complete
    transparency is brought about by asynchronous ways of working. In fact, it is
    difficult to ensure transparency in a synchronous process. How can those who could
    not attend the meeting see the content of the meeting and participate in the decision-making
    process? How can they later learn the background of the decisions that were made
    without being recorded?
  prefs: []
  type: TYPE_NORMAL
- en: In open source, most conversations can be found in GitHub issues and pull requests,
    and these discussions can be traced back to the past. This reduces the barrier
    to participation for those who wish to get involved, thanks to a culture of documentation.
    The accumulated conversations serve as a form of documentation, often referred
    to as passive documentation. Such conversation histories are valuable because
    they represent an accumulation of trust. Users and contributors to the InnerSource
    repository have different needs, priorities, and ways of engaging with it. As
    these individuals collaborate, embracing asynchronous collaboration becomes important
    to ensure everyone’s participation.
  prefs: []
  type: TYPE_NORMAL
- en: InnerSource program office
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Implementing InnerSource at an organizational level often requires an **InnerSource
    Program Office** (**ISPO**), which might evolve from traditional OSPO roles or
    be part of development technology teams. Their role is to seamlessly integrate
    the distributed contribution model throughout the organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ISPO ensures the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sharing of InnerSource policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conducting mentoring and training
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advisory on InnerSource strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing incentive models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing support activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring proper tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key metrics for evaluating InnerSource include the number of repositories with
    multiple contributors from different teams, the presence of `CONTRIBUTING.md`
    and `README.md` files, and the number of forks and cross-team pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: InnerSource patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: InnerSource patterns ([https://patterns.innersourcecommons.org/](https://patterns.innersourcecommons.org/))
    are essentially codified best practices in InnerSource, structured in a specific
    format for ease of understanding, evaluation, and application in diverse contexts.
    These patterns, which are detailed in this book, represent the most mature and
    effective practices identified and collected by the InnerSource Commons Community.
    They serve as a valuable guide for implementing InnerSource methodologies, providing
    practical and proven solutions to common challenges faced in collaborative software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – InnerSource patterns](img/B21203_06_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – InnerSource patterns
  prefs: []
  type: TYPE_NORMAL
- en: 'Adopting InnerSource patterns can significantly increase the adoption and effectiveness
    of InnerSource within an organization. To effectively use these patterns, do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identify relevant patterns**: Assess the challenges your organization faces
    with InnerSource and identify patterns that address these specific issues'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Adapt to your context**: Customize the pattern to fit the unique circumstances
    and culture of your organization'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Implement and evaluate**: Apply the solution proposed in the pattern and
    continually assess its effectiveness, making adjustments as needed'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Key InnerSource patterns for effective collaboration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of January 2024, 24 mature patterns are covered, with more being added as
    they develop. InnerSource patterns provide structured approaches to common challenges
    in collaborative development. I will not list them all here, but I will introduce
    five typical patterns that have proven effective in many different organizations
    and contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are my favorites and would be a good entry point for you to see what
    the patterns are all about:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trusted Committers**: This pattern is useful for projects receiving consistent
    external feedback and contributions. It involves recognizing and rewarding the
    contributions of external collaborators, beyond individual contributions, by designating
    them as “Trusted Committers.” This role involves responsibilities such as mentoring
    and quality control, further integrating contributors into the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InnerSource license**: When different legal entities within the same organization
    want to share source code, legal and accounting concerns may arise. An InnerSource
    license provides a legal framework for such sharing, clarifying rights and obligations
    and facilitating new forms of collaboration within the organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InnerSource portal**: To facilitate discovery of InnerSource projects, an
    InnerSource Portal can be established. This intranet site lists all available
    InnerSource projects, making it easier for potential contributors to find projects
    of interest and for project owners to attract external participation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`, `CONTRIBUTING.md`, and `COMMUNICATION.md` enable self-service
    for new contributors, allowing them to find answers to common questions independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**30-day warranty**: This pattern addresses the hesitation teams might have
    in accepting outside contributions. By offering a 30-day warranty, the contributing
    team commits to fixing any bugs in their code post-integration. This increases
    trust and makes the acceptance of external contributions more likely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These InnerSource patterns offer practical solutions to foster collaboration,
    streamline contribution processes, and build trust in InnerSource initiatives.
    By implementing these patterns, organizations can create a more open, efficient,
    and co-operative development environment.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, InnerSource is not just a methodology but a cultural paradigm
    that emphasizes open, transparent, and community-centric software development
    within an organization. Its successful implementation hinges not just on tools
    such as GitHub but on the broader cultural embrace of open source principles and
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub for scalable collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating an environment that supports a distributed contribution model is crucial.
    This is true for both DevOps and InnerSource approaches. However, configuring
    GitHub optimally is essential to enable this model of collaboration. A non-optimal
    setup can severely restrict development efforts, especially in enterprises where
    there’s often a tendency to overemphasize security, leading to overly stringent
    configurations that hinder collaboration. The key challenge lies in finding the
    right balance between security and collaboration. Projects should be structured
    to maximize participation, necessitating the thoughtful management of visibility
    and access. This means implementing a GitHub configuration that provides controlled
    visibility, protecting sensitive code while still promoting knowledge sharing
    and collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations need to walk the fine line between a security-first perspective
    and a collaboration-first perspective. This involves managing the risk associated
    with sensitive code while also encouraging internal code sharing to boost productivity
    and innovation. The visibility needs can vary across different InnerSource projects,
    and understanding these nuances is critical to effective collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When configuring GitHub, GitHub provides three layers of configuration. Each
    of these levels is **enterprise**, **organization**, and **repository**. It is
    vital to understand how these levels interact:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enterprise level**: Exercise caution with restrictive settings at this level.
    Overly restrictive configurations can create friction for developers, leading
    to shadow IT practices. Default nudges can be more effective than complete restrictions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organization level**: Empowering repository owners to manage visibility and
    permissions is often more effective than imposing broad policies from the top.
    This approach avoids the pitfalls of overly narrow policies and adapts to evolving
    organizational needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository level**: For sensitive repositories, consider implementing stricter
    controls within certain organizations instead of applying blanket constraints
    across all enterprise code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the appropriate base repository permissions is crucial. Options such
    as **Read** allow every enterprise member to view every repository, which may
    be suitable in some contexts. However, **No Policy** or **No Permissions** offers
    more flexibility, allowing different organizations within the enterprise to choose
    their own base permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Forking vs. branching for internal collaboration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the distributed collaboration model, both forking and branching are valuable
    methods for code development, with each offering distinct benefits. Forking enables
    quick, one-off contributions without needing permission from repository owners,
    making it ideal for minor changes or spontaneous contributions. This method is
    particularly beneficial for InnerSource as it offers a lower-friction way to make
    small contributions compared to branch-based development.
  prefs: []
  type: TYPE_NORMAL
- en: The choice between forking and branching often depends on the project’s nature
    and the GitHub instance’s configuration—internal or public-facing. In internal
    instances, forking is less risky, but in public-facing instances with compliance
    and regulatory concerns, forking might need to be limited. It is important to
    combine configuration with architecture to enable forking as an option without
    increasing the risk of accidental disclosure.
  prefs: []
  type: TYPE_NORMAL
- en: Base permissions in GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Base permissions in GitHub are crucial as they define the collaboration environment
    within an organization and can be set at various levels.
  prefs: []
  type: TYPE_NORMAL
- en: '**Enterprise level**: At the enterprise level, base permissions apply to all
    repositories and define default access for all enterprise members. **Read** permissions
    grant every member read access to every repository, which is suitable in certain
    environments. However, **No Policy** often provides more flexibility for each
    organization, allowing each organization within the enterprise to tailor repository
    permissions to their needs. It is crucial to carefully select these settings to
    avoid overly restrictive policies that can hinder collaboration and innovation.
    **No Policy** or **Read** are common choices, enabling different organizations
    to set varying base permissions, ranging from wide to narrow internal sharing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Organization level**: At the organization level, there is no **No Policy**
    option, and the choices range from **Read** to **No Permission**. Selecting **Read**
    allows wide sharing within the organization, while **No Permission** offers more
    controlled access, accommodating a range of sharing levels within the organization.
    The goal for base permissions is to enable low-friction repository creation and
    read access at scale while allowing repository owners to make informed choices
    on sharing their repositories. They should have the flexibility to choose the
    sharing level appropriate for the type of code in their repository without being
    forced into wide or narrow sharing based on the GitHub organization’s typical
    usage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ultimate goal in setting base permissions is to create an environment that
    supports both easy repository creation and access and gives repository owners
    the autonomy to decide on sharing levels. This approach ensures that repositories
    are shared in a way that suits their specific needs and type of code rather than
    being limited by overarching organizational policies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter begins with an exploration of DevOps metrics and also mentions
    DevSecOps. Concepts such as InnerSource, known for their strong compatibility
    with DevOps and their ability to enhance collaboration beyond a single team to
    the entire organization’s excellence, are introduced.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps is fundamentally a culture that can be refined by adopting individual
    practices, re-evaluating tool usage, and properly setting up metrics. This refining
    process is ongoing. There are a variety of books available, so we encourage you
    to learn more and find the best form of DevOps for your team.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Accelerate: The Science of Lean Software and DevOps: Building and Scaling
    High Performing Technology Organizations* by Nicole Forsgren, Jez Humble, and
    Gene Kim ([https://en.wikipedia.org/wiki/Accelerate_(book)](https://en.wikipedia.org/wiki/Accelerate_(book)))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SPACE of Developer Productivity by Nicole Forsgren, Margaret-Anne Storey,
    Thomas Zimmermann, Brian Houck, and Jenna Butler ([https://queue.acm.org/detail.cfm?id=3454124](https://queue.acm.org/detail.cfm?id=3454124))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with InnerSource* by Andy Oram ([https://www.oreilly.com/radar/getting-started-with-innersource/](https://www.oreilly.com/radar/getting-started-with-innersource/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding the InnerSource Checklist* by Silona Bonewald ([https://innersourcecommons.org/learn/books/understanding-the-innersource-checklist/](https://innersourcecommons.org/learn/books/understanding-the-innersource-checklist/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*InnerSource Patterns* by the InnerSource Commons Community ([https://patterns.innersourcecommons.org/](https://patterns.innersourcecommons.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
