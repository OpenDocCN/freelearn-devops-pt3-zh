- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI/CD Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll learn how to automate our DevOps processes with **Continuous
    Integration and Continuous Delivery** (**CI/CD**). We’ll also look at some popular
    tools for achieving this.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging the power of CI/CD, we can create a more efficient, reliable,
    and streamlined workflow for our Salesforce development and operations. This approach
    allows us to quickly react to changes, reduces the risk of deployment failures,
    and ultimately, helps us deliver better-quality software.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover the following main topics.
  prefs: []
  type: TYPE_NORMAL
- en: '**Introduction to CI/CD**: Firstly, we will define CI/CD, explain its benefits,
    and discuss how it fits into a DevOps strategy. We’ll also highlight the key principles
    and best practices to follow when implementing CI/CD.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub Actions**: This section will focus on GitHub Actions, a flexible and
    powerful CI/CD tool that integrates directly with your GitHub repositories. We’ll
    explore how to set up workflows, automate tests, and handle deployments, all within
    the GitHub platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins**: A longstanding favorite in the CI/CD community, Jenkins is another
    tool we’ll dive into. We’ll show you how to configure Jenkins for Salesforce projects,
    create pipelines, and leverage its extensive plugin ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Salesforce-specific tools**: Salesforce offers several tools that can aid
    in CI/CD, such as **Salesforce DX** (**SFDX**) and the Salesforce CLI. We’ll discuss
    how to leverage these tools to streamline your CI/CD process and tackle Salesforce-specific
    challenges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Practical use of the CI/CD pipeline**: We’ll finish by looking at the advantages
    that our newly-built CI/CD pipeline affords us as part of a robust DevOps implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should have a robust understanding of the role
    of CI/CD in Salesforce DevOps, the tools available for implementing it, and the
    steps you can take to begin automating your own processes.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Jenkins, you’ll need a server that can host the Jenkins software. This could
    be a physical server, a virtual machine, or a cloud-based server. The specific
    requirements will depend on the scale of your projects, but as a minimum, you
    should plan for at least 1 GB of memory, 50 GB of disk space, and a modern CPU.
    It’s worth noting that, for learning purposes, it is possible to run Jenkins on
    your local development machine if you want to follow the processes and steps in
    this book, but for real-world use, as part of your DevOps toolchain, a dedicated
    hosting solution is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: SFDX and the Salesforce CLI are crucial tools for Salesforce DevOps. To use
    them, you’ll need to install the Salesforce CLI on your system. If you’ve not
    already got them in place, you can revisit [*Chapter 5*](B19436_05.xhtml#_idTextAnchor115),
    which covers setting them up in detail.
  prefs: []
  type: TYPE_NORMAL
- en: To implement CI/CD in Salesforce, you’ll need an active Salesforce developer
    account. If you’re working with a team, you’ll also need an SFDX “hub” organization,
    where you can create and manage scratch orgs.
  prefs: []
  type: TYPE_NORMAL
- en: A crucial part of CI/CD is version control. GitHub is the most widely used platform
    and is recommended for its excellent integration with CI/CD tools. You’ll need
    a GitHub account and a repository for your Salesforce code.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter is available at [https://github.com/PacktPublishing/Salesforce-DevOps-for-Architects/tree/main/Chapter7](https://github.com/PacktPublishing/Salesforce-DevOps-for-Architects/tree/main/Chapter7).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world of software development has evolved dramatically over the years, with
    an increasing focus on agility, efficiency, and quality. In this context, CI and
    CD have emerged as key practices that can drive significant improvements in development
    workflows. In this section, we will explore the core concepts of CI/CD, their
    benefits, and their role in a DevOps strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Integration (CI)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI is a process in which developers commit their code into a shared repository
    frequently. Each of these commits can then undergo an automated build and test
    cycle to identify problems in the early stages of the development life cycle.
    This CI process helps to reduce integration problems and allows the development
    team to receive immediate feedback on any issues.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery (CD)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CD takes the ideas of CI one step further. It automates the software release
    process as far as being ready for production but falls just short of the actual
    production deployment. This practice ensures that the code and config contained
    in the repository (usually the main or master branch) are always in a production-ready
    state, reduces the risk and effort of deployments, and allows teams to deliver
    updates and improvements to customers more quickly and regularly. The software
    is deployment-ready after automated testing, but a human decision is required
    on when to deploy to production.
  prefs: []
  type: TYPE_NORMAL
- en: Together, CI and CD form the backbone of modern DevOps practices. They promote
    a culture of collaboration, fast feedback cycles, and a focus on high-quality
    output. Implementing CI/CD can lead to more efficient development processes, fewer
    bugs reaching production, and a better product for your users.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of Salesforce, CI/CD can bring additional benefits. Salesforce
    projects often involve multiple developers working on several aspects of a complex
    system. With CI/CD, you can ensure that changes are integrated and tested frequently,
    reducing the risk of conflicts and errors. Also, automated deployments can simplify
    the process of pushing changes to testing, staging, and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: However, it’s important to note that implementing CI/CD is not just a matter
    of using certain tools or following specific steps. It’s a cultural shift that
    requires buy-in from the entire team, a focus on automation and testing, and an
    ongoing commitment to improving your processes. This may involve improving existing
    testing practices or addressing technical debt and poor architecture – all of
    which can be prerequisites for properly implementing CI/CD. While these changes
    can seem daunting, the benefits of adopting CI/CD typically outweigh the effort
    required. In the following sections, we’ll delve into the specific tools and practices
    that can help you bring the benefits of CI/CD to your Salesforce projects. Even
    though the initial effort may be substantial, the payoff from improved automation,
    testing, and delivery processes is well worth it. With team commitment and a focus
    on continuous improvement, CI/CD can transform how you build and deliver on Salesforce.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A crucial concept within the CI/CD landscape is that of a pipeline. A CI/CD
    pipeline is a series of steps that your changes, whether in the form of code,
    metadata, or even data, will go through to make their way from development to
    production. It automates the process of integrating code changes, validating them
    with tests, and delivering them to the end users. It is usually visualized as
    a series of stages, each with a specific purpose. When a change is introduced
    (for example, when a developer pushes code to the repository), it triggers the
    pipeline, and the change moves through the stages. Let’s look at some of the typical
    pipeline stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build stage**: This is where the code is compiled, dependencies are fetched,
    and the software is packaged for deployment. For a Salesforce project, this might
    involve creating a new SFDX scratch org, pushing the code to the org, and running
    any required scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test stage**: Automated tests are run against the build to ensure it behaves
    as expected. This could include unit tests, integration tests, and functional
    tests. In a Salesforce context, this must involve running Apex tests and possibly
    testing other components, such as Visualforce pages or Lightning components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deploy stage**: If the build passes all tests, it can be deployed to a staging
    environment for further testing, and if it passes there, it can be deployed to
    the production environment. Salesforce-specific tools such as SFDX and change
    sets can be used for these deployments. Ultimately, these tools are wrappers around
    the Metadata API, which remains the sole underlying way to deploy changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor stage**: After deployment, the application is monitored to ensure
    it’s functioning correctly in the production environment. Any issues that arise
    can be fed back into the development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these stages is typically automated, meaning that the change can progress
    from one stage to the next without manual intervention, assuming that all checks
    pass. This automation is a key benefit of CI/CD pipelines, as it reduces the risk
    of human error, speeds up the delivery process, and provides quick feedback to
    the development team.
  prefs: []
  type: TYPE_NORMAL
- en: Each stage is designed to catch different types of issues. For instance, the
    build stage might catch syntax errors, while the test stage could catch functional
    bugs, and the monitoring stage could identify performance issues or errors in
    the live environment. Using tools such as PMD for static code analysis, or other
    code linters, such as ESLint for your Lightning Web Components, reinforces consistent
    code style and best practices across the entire development team. With rules encoded
    into the tools, developers get immediate feedback if they violate conventions.
    This promotes readable, maintainable code and, of course, can be added to your
    pipelines to run automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of Salesforce, a CI/CD pipeline can help manage the complexities
    of developing in a multi-tenant, metadata-driven environment. It allows teams
    to develop, test, and deploy changes in a controlled, repeatable way, reducing
    the risks associated with manual deployments and ensuring high-quality output.
    In the coming sections, we’ll discuss how to implement such a pipeline using popular
    tools such as GitHub Actions and Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our journey into the realm of CI/CD, we encounter various tools that help
    facilitate these practices. One of these tools, which stands out for its simplicity
    and tight integration with the GitHub platform, is GitHub Actions. This powerful
    automation tool allows you to create custom **Software Development Life Cycle**
    (**SDLC**) workflows directly in your GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions enables you to automate, customize, and execute your software
    development workflows right in your repository. You can deploy workflows in the
    same place where you store code and collaborate on projects. This translates into
    faster, more streamlined development cycles as you can manage CI/CD from within
    your GitHub projects, without needing to rely on external tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In GitHub Actions, workflows, jobs, and actions have a hierarchical relationship,
    which allows you to organize and structure your CI/CD process. This hierarchy
    has the following levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.github/workflows` directory of your repository holds `.yml` or `.yaml` files
    where workflows are defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runs-on` directive. A single workflow can execute numerous jobs, which, by
    default, operate concurrently, although you can adjust them to run one after the
    other. Each job is composed of several steps, each performing specific tasks.
    These jobs can utilize either the same runner or different ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step**: Steps represent the most granular level of work within a job. Each
    step is responsible for executing a single command or action. They can either
    carry out commands, which are any shell commands, or actions, which are reusable
    code chunks. These actions could be developed by you, developed by GitHub, or
    sourced from the community through a public repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The hierarchical relationship between workflows, jobs, and steps](img/Figure_7.1_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The hierarchical relationship between workflows, jobs, and steps
  prefs: []
  type: TYPE_NORMAL
- en: A step in a job can be either a command that runs in a shell or an action. In
    the following example, each step in the job either runs a command in a shell (such
    as `npm install sfdx-cli --global`) or uses an action (such as `actions/checkout@v2`).
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions provides more than just the ability to establish CI/CD pipelines.
    It also allows for the automation of a broad spectrum of tasks, such as issue
    triaging and package publishing. This makes it a multifaceted tool essential for
    any developer’s toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: For Salesforce developers and architects, tasks can be automated using GitHub
    Actions, such as running Apex tests, deploying code to scratch orgs, and promoting
    changes to staging and production environments. In the following sections, we’ll
    delve deeper into how to set up and use GitHub Actions for Salesforce CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub workflows in action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by looking at a real-world example of a Git workflow and then walk
    through what it is doing. Consider the GitHub workflow shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This GitHub workflow is initiated whenever push or pull request events occur
    on the main branch. We then need to define the job(s) within the workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, we have defined a singular job named `deploy`, which executes
    in an `ubuntu-latest` environment. The `runs-on:` field in a GitHub Actions workflow
    configures the kind of machine that the job will be run on. This field can assume
    a variety of values, which, in turn, determine the type of runner used for the
    execution of the job.
  prefs: []
  type: TYPE_NORMAL
- en: A runner is a server equipped with the GitHub Actions runner application, tasked
    with executing jobs. The `ubuntu-latest` value indicates that the job should run
    on the latest stable Ubuntu virtual machine hosted by GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define the steps that the job should execute. Firstly, we do
    some preparation by checking out the code in our repository and installing the
    Salesforce CLI to run additional steps with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first step uses `actions/checkout@v2` to check out the source code of the
    current repository. With GitHub Actions, it’s possible to utilize actions that
    are contained in your own repository, in a public repository, or within a Docker
    container image in GitHub’s own collection of published images. The `uses:` keyword
    in your GitHub Actions workflow is used to specify these actions.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `actions/checkout@v2` refers to the checkout action from the `actions`
    repository, and `v2` is the tag of the version you want to use. This checkout
    action checks out your repository under `$GITHUB_WORKSPACE`, so your workflow
    can access it.
  prefs: []
  type: TYPE_NORMAL
- en: By specifying `v2`, you are instructing the workflow to use the second major
    version of the checkout action. This version could include new features, changes,
    or bug fixes compared to the previous version (`v1`). The maintainers of the action
    define these versions according to semantic versioning rules.
  prefs: []
  type: TYPE_NORMAL
- en: It’s good practice to specify a version (instead of using the default branch,
    usually `main` or `master`) to protect your workflows from potential breaking
    changes introduced into those branches.
  prefs: []
  type: TYPE_NORMAL
- en: The second step is to install the Salesforce CLI globally. The Salesforce CLI
    is used to authenticate with your Salesforce org and run your Apex unit tests.
    However, the Salesforce CLI isn’t pre-installed on GitHub’s virtual environments,
    so you need to install it in your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Salesforce CLI has two main distribution methods – as a binary executable
    file and as a Node.js package installed through npm. We chose to use the binary
    distribution in our script, as the npm installation can run into permissions issues
    when trying to add extra plugins. The npm package requires Node.js and needs to
    be installed globally, which typically requires sudo permissions. Using sudo can
    lead to filesystem permission problems down the line. The binary distribution
    avoids these problems, which is why we opted for that method. The Node.js npm
    package is also available, but we avoided it due to the potential permission issues
    when adding plugins. Now, we can move on to the next step in our job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding step, we are making use of GitHub’s per-repository secrets
    to retrieve a stored value and copying that value into a temporary file *only
    for the life cycle of this job*. The file contains an SFDX authorization URL,
    which allows the job to connect to our Salesforce Developer Hub org easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three choices available to create this authentication file. The simplest
    approach involves redirecting the output of the `sf org display --verbose --json`
    command to a file. As an illustration, consider the scenario of utilizing an org
    that you have already authorized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Inside the resulting JSON file, you can find the URL stored in the `sfdxAuthUrl`
    property within a results object. Please note that the `force:org:display --verbose`
    command only displays the refresh token for orgs authorized with the web server
    flow, not the JWT bearer flow.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you have the option to generate a JSON file with a top-level property
    called `sfdxAuthUrl`, which contains the authentication URL. Alternatively, you
    can create a plain text file that solely includes the URL without any additional
    content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SFDX authorization URL follows this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`force://<clientId>:<clientSecret>:<refreshToken>@<instanceUrl>`'
  prefs: []
  type: TYPE_NORMAL
- en: The URL uses `force://` instead of http:// or `https://`, and `instanceUrl`
    does not include `https://`. It is just the domain name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step authenticates with the Salesforce org using the newly created
    file, which contains the authorization URL, and gives it the alias `HubOrg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Having authenticated our Dev Hub, we are now able to automatically generate
    a new scratch org for our testing needs and transfer our code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With this new scratch org in place, with the `ciorg` alias, we can execute
    our Apex tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we delete the scratch org when we’ve finished. This is an important
    step, since Salesforce enforces limits on how many active scratch orgs you can
    have in each Dev Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each step within a job operates in its own distinct context. However, using
    GitHub workflow syntax, these individual steps can be orchestrated to interact
    and cooperate with each other. The workflow configuration provides the ability
    to establish dependencies between steps, such as specifying that a step must wait
    for the successful completion of another before it starts. It also allows one
    step to utilize the output from another, among other interactions. This flexible
    configuration enables complex automated processes to be built from a collection
    of individual steps.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions provides a versatile platform for tailoring your CI/CD pipeline
    when working with SFDX. With its capability to run a wide array of tasks, from
    executing shell commands to running scripts or even third-party software, GitHub
    Actions can be uniquely customized to fit your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: This adaptability is also applicable to SFDX, where you can utilize GitHub Actions
    to automate numerous tasks. These can include executing unit tests, deploying
    code to various environments, and even overseeing data migration. By leveraging
    the power of GitHub Actions, you can create an efficient, reliable, and automated
    CI/CD pipeline that enhances the development and deployment process for your SFDX
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: While the preceding steps will provide you with a basic automated workflow for
    using GitHub Actions for your Salesforce CI/CD needs, you can extend it with more
    automated testing, static code analysis, approval processes, and more. You find
    extensive documentation and tutorials in the official GitHub Actions documentation
    at [https://docs.github.com/en/actions/learn-github-actions](https://docs.github.com/en/actions/learn-github-actions).
  prefs: []
  type: TYPE_NORMAL
- en: If you want an alternative approach to your CI/CD, you could instead look at
    Jenkins. It has a considerable number of plugins available, can be self-hosted
    to give you more control of your implementation, and has a more intuitive UI to
    set up and manage your pipeline. In the next section, we’ll look at Jenkins in
    a little more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins is an open source automation server that has solidified its place as
    an essential tool in the DevOps community. It has been a go-to choice for many
    organizations due to its extensive feature set, its plugin ecosystem, and the
    high degree of flexibility and control it offers.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is engineered to manage a range of DevOps activities and processes,
    from a straightforward CI server to a comprehensive CD hub, accommodating any
    kind of project, regardless of the size or complexity. It allows you to automate
    the different stages of your delivery pipeline, providing continuous feedback
    to the project team about the health of their project.
  prefs: []
  type: TYPE_NORMAL
- en: One of the significant advantages of Jenkins is its extensibility through plugins.
    With over 1,000 plugins in the Update Center, Jenkins integrates with practically
    every tool in the CI/CD toolchain. You can use it to build, test, and deliver
    code in any language, to any platform. This extensibility makes Jenkins a versatile
    tool that can adapt to a wide range of project needs.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins uses a distributed architecture that can easily scale as your needs
    grow. You can set up Jenkins to distribute work across multiple machines, enabling
    projects to build, test, and deploy faster. This distributed nature of Jenkins
    is particularly beneficial for large and complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: Much like GitHub Actions, Jenkins can be configured to handle tasks such as
    running Apex tests, creating and managing SFDX scratch orgs, and deploying metadata
    to various Salesforce environments. Jenkins can also be integrated with version
    control systems, such as Git, enhancing its capabilities within a Salesforce CI/CD
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of setting up a Jenkins CI/CD pipeline for Salesforce is the
    installation of Jenkins itself. This varies slightly depending on your operating
    system. Jenkins is a Java-based application, so it runs on any platform that supports
    Java. It’s advisable to always ensure that your system packages are up to date
    before starting any new installations.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re running Ubuntu Linux, the process begins with updating your system
    packages via the `apt update` and `apt upgrade` commands run in your terminal.
    You then need to install Java, as Jenkins requires it to run. The OpenJDK package
    is a good option and can be installed with `apt install openjdk-17-jdk`. At the
    time of writing, JDK 20 is the most recent version of the Java SE platform. However,
    JDK 17 LTS holds the status of being the most up-to-date **Long-Term Support**
    (**LTS**) release for the Java SE platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you should add the Jenkins repository to your sources list, which is
    a prerequisite for the Jenkins installation. You can accomplish this by fetching
    the Jenkins repository key with the `wget` command and adding it to your system’s
    software repository list. The key is required to authenticate and ensure that
    packages installed on your system are from a trusted source. You can download
    the Jenkins repository key directly from Jenkins’ own servers with the following
    `wget` command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `-q` option tells `wget` to operate quietly, meaning it won’t output progress
    information. The `-O -` option tells it to write the downloaded content to standard
    output, represented by `-`. This content is then piped, using the `|` symbol,
    into the `sudo apt-key add -` command, which adds the key to your system’s list
    of trusted keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to add the Jenkins repository to your system’s software repository
    list. This is done by appending the Jenkins repository URL to the list of repositories
    stored in the `/etc/apt/sources.list.d/` directory. You can do this with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `echo` command prints its argument, in this case, the Jenkins repository
    URL and the type of packages to use (binary). This output is piped into the `sudo
    tee` command. The `tee` command is used to append the input it receives to a file,
    in this case, the `jenkins.list` file in the `/``etc/apt/sources.list.d/` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Once these commands have been run, your system’s package manager is set up to
    install Jenkins and keep it updated. The next step would be to update the package
    list with `sudo apt update`, and then you can proceed with installing Jenkins
    via `sudo apt` `install jenkins`.
  prefs: []
  type: TYPE_NORMAL
- en: For macOS users, you’ll first need to install Homebrew, a package manager that
    simplifies the installation of software on macOS. Once Homebrew is installed,
    you can use it to install OpenJDK, and then Jenkins itself. Just like with Ubuntu,
    once Jenkins is installed, you should start the service and make sure it’s set
    to start automatically when the system boots.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, the process is slightly different. You’ll need to download the Jenkins
    WAR file directly from the Jenkins website and have the latest version of JDK
    installed from Oracle’s website. After setting up the `JAVA_HOME` environment
    variable, you can run Jenkins by navigating to the directory where the Jenkins
    WAR file is stored and using the `java -``jar` command.
  prefs: []
  type: TYPE_NORMAL
- en: In all three cases, once Jenkins is running, you can access the Jenkins dashboard
    by navigating to http://localhost:8080 in a web browser. You’ll be guided through
    the rest of the setup process, which includes setting up an admin user and configuring
    security settings.
  prefs: []
  type: TYPE_NORMAL
- en: After Jenkins is installed and running, you’ll need to prepare it for SFDX.
    SFDX comprises a suite of tools designed to enhance and simplify all stages of
    the development and deployment process. It requires the Salesforce CLI, so you’ll
    need to install that on the same machine as Jenkins. We covered the installation
    of the Salesforce CLI earlier, in [*Chapter 5*](B19436_05.xhtml#_idTextAnchor115),
    if you need a reminder of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Once the Salesforce CLI is installed, you’ll need to ensure Jenkins can interact
    with it. This is done by adding the path to the Salesforce CLI in the Jenkins
    system configuration settings. You can navigate to these settings via the **Manage
    Jenkins** | **Configure System** menu on the Jenkins dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins operates by using plugins for specific tasks and integrations. For SFDX,
    the key plugins you need to install are the Pipeline plugin, the Git plugin, and,
    depending on your choice of version control solution, either the GitHub plugin,
    the Bitbucket plugin, or any plugins that may be specific to your Git provider.
    In this example, we’re going to focus on the GitHub option. The Pipeline plugin
    enables the creation of CD pipelines in Jenkins, while the Git and GitHub plugins
    enable Jenkins to interact with Git repositories.
  prefs: []
  type: TYPE_NORMAL
- en: These plugins can be installed via the **Manage Plugins** menu in the Jenkins
    dashboard. After they’re installed, Jenkins will be able to interact with SFDX
    and pull code from a GitHub repository, forming the basis of your CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The addition of Git support via the plugin enables Jenkins to monitor a Git
    repository for changes, pull those changes when they occur, and then take certain
    actions based on those changes. Jenkins achieves this by using webhooks and polling.
    Webhooks are triggers that are sent from GitHub to Jenkins when a change occurs,
    while polling means Jenkins will periodically ask GitHub whether there has been
    a change.
  prefs: []
  type: TYPE_NORMAL
- en: To set up a webhook, you’ll need to navigate to your repository on GitHub, go
    to the `/github-webhook/` (e.g., [http://your-jenkins-url/github-webhook/](http://your-jenkins-url/github-webhook/)).
    Make sure `application/json` and the events you are interested in are selected
    (such as `Just the` `push event`).
  prefs: []
  type: TYPE_NORMAL
- en: If webhooks are not an option due to network restrictions, you can opt to have
    Jenkins periodically poll GitHub for changes. This is done through the **Poll
    SCM** option in the job configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The actions that Jenkins takes in response to detected changes are defined in
    a **Jenkinsfile**, which contains all the stages of your Jenkins pipeline. It’s
    checked into source control, providing an easy way to version it and allowing
    it to be shared across multiple jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic Jenkinsfile for a CI/CD workflow – pulling changes, running unit tests,
    checking whether they pass, and then deploying to the next environment if they
    do – might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this first section, we set up some variables. As we’re referencing credentials,
    it’s recommended that you don’t hardcode them into the Jenkinsfile but, instead,
    pull them from environment variables on the server that is running Jenkins. Once
    these are set up, we can start with the first stage of our pipeline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This first stage of the pipeline simply pulls the latest changes from our source
    control, ready for Jenkins to work with. In the next section of the file, we can
    wrap everything else with the set of credentials we wish to use for interacting
    with Salesforce, so that all the stages contained inside the code block use the
    same details. These credentials are supplied in the form of a **JSON Web Token**
    (**JWT**) file and then added to the configuration with a reference to that file
    – instructions on creating this, as well as a connected app within Salesforce,
    can be found in the official documentation at [https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ci_jenkins_config_env.htm](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ci_jenkins_config_env.htm):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With these credentials in place, we can do a similar thing with the working
    environment, so that all commands run in the context of the code we just retrieved
    from source control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our build environment in place, we can start moving the code
    to our Salesforce environment. In this first step, shown as follows, we use our
    credentials to authenticate to our SFDX Dev Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once our Dev Hub is authenticated, we are able to create a new scratch org
    for our code testing, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now push our changes to the newly created scratch org in the next stage,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have a freshly created scratch org populated with our latest
    changes. We can use this to run the full suite of unit tests and ensure our tests
    pass, with another section in our CI/CD pipeline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we tidy up by deleting the scratch org – this helps preserve the number
    of active scratch orgs governor limit in our Salesforce dev hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This Jenkinsfile uses a declarative pipeline syntax, which has a more rigid
    structure than the scripted pipeline syntax. It begins with the node keyword,
    indicating the start of the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Each stage contains one or more steps to be performed. As you can see, this
    structure is like that of GitHub Actions, which we covered in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The `checkout scm` command is a built-in Jenkins command that fetches the source
    code from the repository defined in the Jenkins job.
  prefs: []
  type: TYPE_NORMAL
- en: The various other steps run commands in the Salesforce CLI. This is a very basic
    example; a real-world Jenkinsfile would be more complex. For example, you might
    want to add error handling, send notifications based on the job result, or add
    stages for things such as code analysis or integration testing. It’s worth noting
    that Jenkins, while enormously powerful, is more complex than setting up GitHub
    Actions, and it’s worth spending time getting familiar with the tool and how Jenkinsfiles
    work in more detail. The official Jenkins website at [https://jenkins.io](https://jenkins.io)
    has a wealth of material to guide you, not least of which is the Jenkins Handbook
    – [https://www.jenkins.io/doc/book/](https://www.jenkins.io/doc/book/).
  prefs: []
  type: TYPE_NORMAL
- en: Salesforce-specific tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the world of Salesforce development, there is an essential need for tools
    specifically designed to accommodate Salesforce’s unique architecture and development
    paradigm. Two of these tools that hold particular importance are SFDX and the
    Salesforce CLI, acting as central figures in the Salesforce development process
    and enhancing the efficiency of CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: SFDX, which is an approach to Salesforce development supported by a suite of
    development tools provided by Salesforce, not only fosters source-driven development
    but also facilitates team collaboration and orchestrates testing and deployment
    continuously. It’s built with an ecosystem-centric approach, ensuring seamless
    integration with other tools within the DevOps landscape. The Salesforce CLI,
    a fundamental component of SFDX, serves as a command-line tool that allows the
    scripting of a multitude of tasks across Salesforce orgs, ranging from creating
    scratch orgs and managing data to executing Apex code.
  prefs: []
  type: TYPE_NORMAL
- en: The real potential of SFDX and the Salesforce CLI unfolds when integrated with
    external CI/CD tools such as Jenkins and GitHub Actions. These tools, although
    powerful, lack an innate understanding of Salesforce’s metadata-driven and multi-tenant
    architecture. That’s precisely where SFDX and the CLI step in, bridging the gap
    between these external tools and the Salesforce-specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a scenario where a developer pushes code to a GitHub repository. GitHub
    Actions could initiate a workflow, leveraging the Salesforce CLI to create a new
    scratch org, push the updated code, and execute Apex tests. Similarly, Jenkins
    can incorporate Salesforce CLI commands within its build steps, enabling it to
    handle tasks such as creating and managing scratch orgs or deploying metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond triggering actions and facilitating workflows, SFDX and the Salesforce
    CLI also enforce best practices in Salesforce development. SFDX’s source-driven
    approach encourages developers to rely on version control systems as the source
    of truth. The Salesforce CLI, with its broad command range, promotes automation,
    thereby reducing errors and enhancing the quality of your Salesforce code base.
  prefs: []
  type: TYPE_NORMAL
- en: Both SFDX and the Salesforce CLI are continuously updated by Salesforce. They
    remain tightly integrated with Salesforce’s own development, always staying aligned
    with the latest Salesforce features and improvements. Therefore, by incorporating
    these tools into your CI/CD pipeline, you are not just addressing today’s needs
    but are also poised to harness future advancements in Salesforce development.
  prefs: []
  type: TYPE_NORMAL
- en: SFDX and the Salesforce CLI serve as invaluable tools in constructing an efficient
    and effective CI/CD pipeline for Salesforce. They provide the critical link between
    the Salesforce platform and external CI/CD tools such as Jenkins and GitHub Actions,
    enabling them to handle Salesforce-specific tasks. By capitalizing on these tools,
    you can build a robust, automated, and future-proof CI/CD pipeline, revolutionizing
    your Salesforce development process, reducing manual effort, minimizing errors,
    and accelerating delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Practical use of the CI/CD pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once an automated CI/CD pipeline is in place for Salesforce development, new
    disciplines and practices can emerge to take full advantage of its capabilities.
    The most immediate benefit is the real-time visibility that the pipeline dashboard
    provides into the health of the entire process. Build statuses, test results,
    deployment records, and other key indicators can be monitored to quickly identify
    pipeline failures and rapidly troubleshoot any issues before they become major
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Increased visibility facilitates practices such as incorporating quality gates
    into the process. Required standards such as code coverage thresholds can be enforced,
    ensuring quality before releases. With CI, developers gain the confidence to merge
    code frequently into a shared mainline repository, promoting effective trunk-based
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Another major advantage is how the pipeline tightens and shortens feedback loops.
    Automated testing and rapid build/deploy cycles mean developers get near-instant
    feedback on any changes. Issues can be identified and fixed immediately, before
    more work piles up.
  prefs: []
  type: TYPE_NORMAL
- en: Automation also reduces risk when releasing frequently. Advanced teams can implement
    automated rollback procedures to instantly reverse bad deployments directly from
    the pipeline. Of course, data from pipeline metrics can be analyzed to find opportunities
    for tuning – key indicators such as lead time, deployment frequency, and change
    failure rate reveal areas for continuous improvement.
  prefs: []
  type: TYPE_NORMAL
- en: With the new visibility and automation the pipeline facilitates, developers
    are freed from tedious manual quality checks to focus their energy on writing
    great code. They can release faster with confidence, knowing automation is handling
    testing, quality enforcement, and promotion up the pipeline behind the scenes.
    This allows teams to fully leverage modern development practices that increase
    agility.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored a couple of solutions to implement a Salesforce
    CI/CD pipeline, using freely available tools. In looking at the setup for both
    GitHub Actions and Jenkins, we saw that the fundamental steps of the pipeline
    are the same, but with differences in the specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also seen that these tools depend heavily on the Salesforce CLI tool and
    the SFDX approach to managing your metadata, to carry out the steps that make
    up the CI/CD pipeline. Of course, the use of SFDX is not mandatory – anything
    that leverages the Metadata API could be used instead, but it’s worth noting that
    building the necessary scripts to manage this entire process represents a significant
    development and maintenance effort by whoever is responsible for managing your
    DevOps toolchain. This can be mitigated by adopting DevOps solutions and platforms
    that are designed to work specifically with Salesforce only. We’ll cover some
    of the options on the market in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll continue to round out our overall DevOps implementation
    by looking at ticketing systems, which allow for better management of work items
    and not only help bring a clearer picture of progress on your development changes
    but also contribute to breaking those changes up into smaller units of work, which
    lends itself to the DevOps principle of releasing early and often.
  prefs: []
  type: TYPE_NORMAL
