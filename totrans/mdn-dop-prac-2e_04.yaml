- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and Managing Container Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered containerization with Docker, where we installed
    Docker and ran our first container. We covered some core fundamentals, including
    Docker volumes, mounts, storage drivers, and logging drivers. We also covered
    Docker Compose as a declarative method of managing containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will discuss the core building blocks of containers: container images.
    Container images also fulfill a core principle of modern DevOps practices: config
    as code. Therefore, understanding container images, how they work, and how to
    build an image effectively is very important for a modern DevOps engineer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Dockerfiles, components, and directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building and managing Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flattening Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing containers with distroless images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Docker registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, we assume that you have Docker installed on a Linux machine
    running Ubuntu 18.04 Bionic LTS or later with sudo access. You can read [*Chapter
    3*](B19877_03.xhtml#_idTextAnchor220), *Containerization with Docker*, for more
    details on how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to clone a GitHub repository for some of the exercises in
    this chapter, which you can find at [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e).
    Also, you need a Docker Hub account for most of the activities. To create one,
    go to [https://hub.docker.com/](https://hub.docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Docker architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you’re a passionate chef dedicated to creating mouthwatering dishes
    that satisfy hungry customers. In your kitchen, which is a magical place called
    Docker, you have special powers to plan, make, and showcase your culinary creations.
    Let’s break down the key parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ingredients (Application Code and Dependencies)**: Imagine your kitchen has
    shelves filled with ingredients such as flour, eggs, and spices. These ingredients
    come together in a specific way to make a dish. Similarly, your application code
    and dependencies work together to build your application.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recipe (Image)**: Each recipe is like a plan for a particular dish. Imagine
    having a recipe for chocolate cake or pasta carbonara. These recipes are like
    the building blocks for your creations. In the same way, a Docker image is a plan
    for making your Docker container.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recipe Cards (Dockerfile)**: Your cooking journey involves using special
    recipe cards called Dockerfiles. These cards show you the important steps and
    ingredients (commands) to follow. For example, a Dockerfile for a chocolate cake
    might have steps such as “Mix the flour and sugar” or “Add eggs and cocoa powder.”
    These Dockerfiles guide your helpers (Docker) in making the dish (container).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cooked Dish (Container)**: When someone wants a dish, you use the recipe
    (image) to make it. Then, you have a fresh, hot dish ready to serve. These dishes
    are separate, but they can be made again and again (thanks to the recipe), just
    like a container.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kitchen Staff (Docker Engine)**: In your bustling kitchen, your helpers (Docker
    Engine) play a big role. They do the hard work, from getting ingredients to following
    the recipe and serving the dish. You give them instructions (Docker commands),
    and they make it happen. They even clean up after making each dish.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Special Set Menu (Docker Compose)**: Sometimes, you want to serve a special
    meal with multiple dishes that go well together. Think of a meal with an appetizer,
    a main course, and a dessert. Using Docker Compose is like creating a special
    menu for that occasion. It lists recipes (images) for each part of the meal and
    how they should be served. You can even customize it to create a whole meal experience
    with just one command.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Storage Area (Volumes)**: In your kitchen, you need a place to keep ingredients
    and dishes. Think of Docker volumes as special storage areas where you can keep
    important things, such as data and files, that multiple dishes (containers) can
    use.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Communication Channels (Networks)**: Your kitchen is a busy place with lots
    of talking and interacting. In Docker, networks are like special communication
    paths that help different parts of your kitchen (containers) talk to each other.'
  prefs: []
  type: TYPE_NORMAL
- en: So, Docker is like your magical kitchen where you make dishes (containers) using
    plans (Dockerfiles) and ingredients (images) with the assistance of your kitchen
    helpers (Docker Engine). You can even serve entire meals (Docker Compose) and
    use special storage areas (volumes) and communication paths (networks) to make
    your dishes even more amazing. Just like a chef gets better with practice, exploring
    Docker will help you become a master of DevOps in no time! Now, let’s dive deeper
    into Docker architecture to understand its nuances!
  prefs: []
  type: TYPE_NORMAL
- en: As we already know, Docker uses the *build once, run anywhere* concept. Docker
    packages applications into images. Docker images form the blueprint of containers,
    so a container is an instance of an image.
  prefs: []
  type: TYPE_NORMAL
- en: A container image packages applications and their dependencies, so they are
    a single immutable unit you can run on any machine that runs Docker. You can also
    visualize them as a snapshot of the container.
  prefs: []
  type: TYPE_NORMAL
- en: We can build and store Docker images in a Docker registry, such as **Docker
    Hub**, and then download and use those images in the system where we want to deploy
    them. Images comprise several layers, which helps break images into multiple parts.
    The layers tend to be reusable stages that other images can build upon. This also
    means we don’t have to transmit the entire image over a network when changing
    images. We only transmit the delta, which saves a lot of network I/O. We will
    talk about the layered filesystem in detail later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the components Docker uses to orchestrate the following
    activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Docker architecture](img/B19877_Figure_4.01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Docker architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'The components are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker daemon**: This process runs on the servers that we want to run our
    containers on. They deploy and run containers on the Docker server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker registries**: These store and distribute Docker images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker` commands to the Docker daemon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand Docker architecture’s key components and how Docker images
    play an essential role, let’s understand Docker images and their components, directives,
    and registries in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker images form the blueprint of Docker containers. Just like you need a
    blueprint for a shipping container to determine its size and what goods it will
    contain, a Docker image specifies what packages, source code, dependencies, and
    libraries it needs to use. It also determines what it needs to do for the source
    code to run effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, it consists of a series of steps you would perform on a base OS
    image to get your application up and running. This may include installing packages
    and dependencies, copying the source code to the correct folder, building your
    code to generate a binary, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can store Docker images in a container registry, a centralized location
    from where your Docker machines can pull images to create containers.
  prefs: []
  type: TYPE_NORMAL
- en: Docker images use a layered filesystem. Instead of a huge monolithic block on
    the filesystem that comprises the template to run containers, we have many layers,
    one on top of the other. But what does this mean? What problem does this solve?
    Let’s have a look in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The layered filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Layers in Docker are intermediate Docker images. The idea is that every Dockerfile
    statement we execute on top of a layer changes something within the layer and
    builds a new one. The subsequent statement modifies the current one to generate
    the next one. The final layer executes the Docker `CMD` or `ENTRYPOINT` command,
    and the resulting image comprises several layers arranged one on top of the other.
    Let’s understand this by looking at a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we pull the *Flask application* we built in the previous chapter, we will
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, many `Pull complete` statements are beside random IDs. These
    are called **layers**. The current layer contains just the differences between
    the previous and current filesystem. A container image comprises several layers.
  prefs: []
  type: TYPE_NORMAL
- en: Containers contain an additional writable filesystem on top of the image layers.
    This is the layer where your containers modify the filesystem to provide the expected
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: There are several advantages of using layers instead of merely copying the entire
    filesystem of the container. Since image layers are read-only, multiple containers
    created from an image share the same layered filesystem, decreasing the overall
    disk and network footprint. Layers also allow you to share filesystems between
    images. For example, if two images come from a single base image, both images
    share the same base layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a Python application that runs on an Ubuntu OS.
    At a high level, you will see a base layer (Ubuntu OS) and Python installed on
    top of it. On top of Python, we’ve installed the Python app. All these components
    form the image. When we create a container out of the image and run it, we get
    the writable filesystem on top as the final layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Container layers](img/B19877_Figure_4.02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Container layers
  prefs: []
  type: TYPE_NORMAL
- en: So, you can create multiple Python app images from the same base image and customize
    them according to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: The writable filesystem is unique for every container you spin from container
    images, even if you create containers from the same image.
  prefs: []
  type: TYPE_NORMAL
- en: Image history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand images and their layers, you can always inspect the image history.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s inspect the history of the last Docker image by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there are several layers, and every layer has associated commands.
    You can also see when the layers were created and the size of the disk space occupied
    by each. Some layers do not occupy any disk space, as they haven’t added anything
    new to the filesystem, such as `CMD` and `EXPOSE` directives. These perform some
    functions, but they do not write anything to the filesystem. While commands such
    as `apk add` write to the filesystem, you can see them taking up disk space.
  prefs: []
  type: TYPE_NORMAL
- en: Every layer modifies the old layer in some way, so every layer is just a delta
    of the filesystem configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will deep dive into Dockerfiles and find out how we
    can build Docker images and see what the layered architecture looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Dockerfiles, components, and directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Dockerfile is a simple file that constitutes a series of steps to build a
    Docker image. Each step is known as a **directive**. There are different kinds
    of directives. Let’s look at a simple example to understand how this works.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a simple NGINX container by building the image from scratch rather
    than using the one available on Docker Hub. NGINX is very popular web server software
    that you can use for a variety of applications; for example, it can serve as a
    load balancer or a reverse proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at each line and directive one by one to understand how this Dockerfile
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FROM` directive specifies what the base image for this container should
    be. This means we are using another image as the base and will be building layers
    on top of it. We use the `ubuntu:bionic` package as the base image for this build
    since we want to run NGINX on Ubuntu.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RUN` directives specify the commands we need to run on a particular layer.
    You can run more than one command by separating them with `&&`. We want to run
    multiple commands in a single line if we’re going to club dependent commands in
    a single layer. Every layer should meet a particular objective. In the preceding
    example, the first `RUN` directive is used to install `curl`, while the next `RUN`
    directive is used to install `nginx`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be wondering why we have `apt update` before every installation. This
    is required, as Docker builds images using layers. So, one layer should not have
    implicit dependencies on the previous one. In this example, if we omit `apt update`
    while installing `nginx`, and if we want to update the `nginx` version without
    changing anything in the directive containing `apt update` (that is, the line
    that installs `curl`), when we run the build, `apt update` will not run again,
    so your `nginx` installation might fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `CMD` directive specifies a list of commands that we need to run when the
    built image runs as a container. This is the default command that will be executed,
    and its output will end up in the container logs. Your container can contain one
    or more `CMD` directives. For a long-running process such as NGINX, the last `CMD`
    should contain something that will not pass control back to the shell and continue
    to run for the container’s lifetime. In this case, we run `nginx -g daemon off;`,
    which is a standard way of running NGINX in the foreground.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some directives can easily be confused with each other, such as `ENTRYPOINT`
    and `CMD` or `CMD` and `RUN`. These also test how solid your Docker fundamentals
    are, so let’s look at both.
  prefs: []
  type: TYPE_NORMAL
- en: Can we use ENTRYPOINT instead of CMD?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of `CMD`, you can use `ENTRYPOINT`. While they serve a similar purpose,
    they are two very different directives. Every Docker container has a default `ENTRYPOINT`
    – `/bin/sh -c`. Anything you add to `CMD` is appended post-`ENTRYPOINT` and executed;
    for example, `CMD ["nginx", "-g", "daemon off;"]` will be generated as `/bin/sh
    -c nginx -g daemon off;`. If you use a custom `ENTRYPOINT` instead, the commands
    you use while launching the container will be appended after it. So, if you define
    `ENTRYPOINT ["nginx", "-g"]` and use `docker run nginx daemon off;`, you will
    get a similar result.
  prefs: []
  type: TYPE_NORMAL
- en: To get a similar result without adding any `CMD` arguments while launching the
    container, you can also use `ENTRYPOINT ["nginx", "-g", "``daemon off;"]`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Use `ENTRYPOINT` unless there is a need for a specific `CMD` requirement. Using
    `ENTRYPOINT` ensures that users cannot change the default behavior of your container,
    so it’s a more secure alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at `RUN` versus `CMD`.
  prefs: []
  type: TYPE_NORMAL
- en: Are RUN and CMD the same?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No, `RUN` and `CMD` are different and serve different purposes. While `RUN`
    is used to build the container and only modifies the filesystem while building
    it, `CMD` commands are only executed on the writable container layer after the
    container is running.
  prefs: []
  type: TYPE_NORMAL
- en: While there can be several `RUN` statements in a Dockerfile, each modifying
    the existing layer and generating the next, if a Dockerfile contains more than
    one `CMD` command, all but the last one are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: The `RUN` directives are used to execute statements within the container filesystem
    to build and customize the container image, thus modifying the image layers. The
    idea of using a `CMD` command is to provide the default command(s) with the container
    image that will be executed at runtime. This only changes the writeable container
    filesystem. You can also override the commands by passing a custom command in
    the `docker` `run` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go ahead and build our first container image.
  prefs: []
  type: TYPE_NORMAL
- en: Building our first container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building a container image is very simple. It is actually a one-line command:
    `docker build -t <image-name>:version <build_context>`. While we will discuss
    building container images in detail in the *Building and managing container images*
    section, let’s first build the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that the name of the container had a prefix in front
    of it. That is your Docker Hub account name. The name of the image has a structure
    of `<registry-url>/<account-name>/<container-image-name>:<version>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`registry-url`: The URL to the Docker registry – defaults to `docker.io`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`account-name`: The user or account that owns the image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container-image-name`: The container image’s name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: The image version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s create a container out of the image using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the container is up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run `curl localhost`, we get the default `nginx` `html` response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That’s great! We have built our first image using a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we wanted to customize the image according to our requirements? Practically
    speaking, no one would want an NGINX container just responding with the default
    `Welcome to nginx!` message, so let’s create an index page and use that instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This one outputs a custom message instead of the default NGINX HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: We all know that the default NGINX directory containing the `index.html` file
    is `/var/www/html`. If we can copy the `index.html` file into this directory,
    it should sort out our problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, modify the Dockerfile so that it includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ve added two directives to the file: `WORKDIR` and `ADD`. Let’s understand
    what each one does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WORKDIR`: This defines the current working directory, which is `/var/www/html`
    in this case. The last `WORKDIR` in the Dockerfile also specifies the working
    directory when the container is executed. So, if you `exec` into a running container,
    you will land in the last defined `WORKDIR`. `WORKDIR` can be absolute as well
    as relative to the current working directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD`: This adds a local file to the container filesystem – the working directory,
    in this case. You can also use a `COPY` directive here instead of `ADD`, though
    `ADD` offers some more features, such as downloading files from a URL and using
    an archive such as a TAR or ZIP package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we build this file, we expect the `index.html` file to be copied to the
    `/var/www/html` directory within the container filesystem. Let’s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This time, the build was much faster! When we executed the Docker build, it
    used a lot of layers from the cache. That is one of the advantages of layered
    architecture; you only build the changing part and use the existing one the way
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always add source code after installing packages and dependencies. The source
    code changes frequently and the packages more or less remain the same. This will
    result in faster builds and save a lot of CI/CD time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s rerun the container and see what we get. Note that you need to remove
    the old container before doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can’t see the container anymore. Now, let’s rerun the container
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the container is up and running. Let’s use `curl localhost`
    to see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get a custom message instead of the default NGINX HTML response!
  prefs: []
  type: TYPE_NORMAL
- en: This looks good enough for now, but I will discuss a few more directives to
    make this image more reliable. First, we haven’t explicitly documented what port
    this container should expose. This works perfectly fine, as we know that NGINX
    runs on port `80`, but what if someone wants to use your image and doesn’t know
    the port? In that scenario, it is best practice to define the port explicitly.
    We will use the `EXPOSE` directive for that.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Always use the `EXPOSE` directive to give more clarity and meaning to your image.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to define the action to the container process if someone sends
    a `docker stop` command. While most processes take the hint and kill the process,
    it makes sense to explicitly specify what `STOPSIGNAL` the container should send
    on a `docker stop` command. We will use the `STOPSIGNAL` directive for that.
  prefs: []
  type: TYPE_NORMAL
- en: Now, while Docker monitors the container process and keeps it running unless
    it receives a `SIGTERM` or a stop, what would happen if your container process
    hangs for some reason? While your application is in a hung state, Docker still
    thinks it is running as your process is still running. Therefore, monitoring the
    application through an explicit health check would make sense. We will use the
    `HEALTHCHECK` directive for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s combine all these aspects and see what we get in the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: While `EXPOSE` and `STOPSIGNAL` are self-explanatory, let’s look at the `HEALTHCHECK`
    directive. The `HEALTHCHECK` directive runs a command (hence `CMD`) called `curl
    -f localhost`. So, this container will report itself as healthy until the result
    of the `curl` command is a success.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HEALTHCHECK` directive also contains the following optional fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--interval (default: 30s)`: The interval between two subsequent health checks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--timeout (default: 30s)`: The health check probe timeout. If the health check
    times out, it implies a health check failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--start-period (default: 0s)`: The time lag between starting the container
    and the first health check. This allows you to ensure your container is up before
    a health check.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--retries (default: 3)`: The number of times the probe will retry before declaring
    an unhealthy status.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s build this container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s time to run it and see for ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have successfully launched the container, let’s try `ps` and see
    what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the container shows `health: starting`, which means the health
    check hasn’t been started yet, and we are waiting for the start time to expire.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s wait a while and then try `docker` `ps` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, it reports the container as healthy. So, our container is now more
    reliable, as anyone monitoring it will know what part of the application is healthy
    and what part is not.
  prefs: []
  type: TYPE_NORMAL
- en: This health check only reports on the container’s health status. It takes no
    action beyond that. You are responsible for periodically monitoring the containers
    and writing a script to action unhealthy containers.
  prefs: []
  type: TYPE_NORMAL
- en: One way to manage this would be to create a script that checks for unhealthy
    containers and restarts them. You can schedule such a script in your crontab.
    You can also create a long-running `systemd` script that continuously polls the
    container processes and checks for the health status.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: While using `HEALTHCHECK` is a great option, you should avoid using it to run
    your containers on Kubernetes or a similar container orchestrator. You should
    make use of liveness and readiness probes instead. Similarly, you can define health
    checks on Docker Compose if you are using it, so use that instead of baking the
    health check into the container image.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go ahead and learn how to build and manage Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Building and managing Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We built some Docker images in the previous section, so by now, you should
    know how to write Dockerfiles and create Docker images from them. We’ve also covered
    a few best practices regarding it, which, in summary, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Always add the layers that do not change frequently first, followed by the layers
    that may change often. For example, install your packages and dependencies first
    and copy the source code later. Docker builds the Dockerfile from the part you
    change until the end, so if you change a line that comes later, Docker takes all
    the existing layers from the cache. Adding more frequently changing parts later
    in the build helps reduce the build time and will result in a faster CI/CD experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine multiple commands to create as few layers as possible. Avoid multiple
    consecutive `RUN` directives. Instead, combine them into a single RUN directive
    using the `&&` clauses. This will help reduce the overall container footprint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only add the required files within your container. Your container does not need
    the heavyweight package managers and the Go toolkit while running your containers
    if you have already compiled the code into a binary. We will discuss how to do
    this in detail in the following sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker images are traditionally built using a sequence of steps specified in
    the Dockerfile. But as we already know, Docker is DevOps-compliant and uses config
    management practices from the beginning. Most people build their code within the
    Dockerfile. Therefore, we will also need the programming language library in the
    build context. With a simple sequential Dockerfile, these programming language
    tools and libraries end up within the container image. These are known as single-stage
    builds, which we will cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Single-stage builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s containerize a simple Go application that prints `Hello, World!` on the
    screen. While I am using **Golang** in this application, this concept is applicable
    universally, irrespective of the programming language.
  prefs: []
  type: TYPE_NORMAL
- en: The respective files for this example are present in the `ch4/go-hello-world/single-stage`
    directory within this book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the Go application file, `app.go`, first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The Dockerfile appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is standard stuff. We take the `golang:1.20.5` base image, declare a `WORKDIR`
    `/tmp`, copy `app.go` from the host filesystem to the container, and build the
    Go application to generate a binary. Finally, we use the `CMD` directive with
    the generated binary to be executed when we run the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run the Docker image and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the expected response back. Now, let’s run the following command to
    list the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This image is huge! It takes 803 MB to print `Hello, World!` on the screen.
    This is not the most efficient way of building Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at the solution, let’s understand why the image is so bloated
    in the first place. We use the Golang base image, which contains the entire Go
    toolkit and generates a simple binary. We do not need the complete Go toolkit
    for this application to run; it can efficiently run in an Alpine Linux image.
  prefs: []
  type: TYPE_NORMAL
- en: Docker solves this problem by providing multi-stage builds. You can split your
    build into stages where you can build your code in one stage and then, in the
    second stage, export the built code to another context that begins with a different
    base image that is much lighter and only contains those files and components that
    we need to run the code. We’ll have a look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-stage builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s modify the Dockerfile according to the multi-stage build process and see
    what we get.
  prefs: []
  type: TYPE_NORMAL
- en: The respective files for this example are present in the `ch4/go-hello-world/multi-stage`
    directory within this book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The Dockerfile contains two `FROM` directives: `FROM golang:1.20.5 AS build`
    and `FROM alpine:3.18.0`. The first `FROM` directive also includes an `AS` directive
    that declares the stage and names it `build`. Anything we do after this `FROM`
    directive can be accessed using the `build` term until we encounter another `FROM`
    directive, which would form the second stage. Since the second stage is the one
    we want to run our image from, we are not using an `AS` directive.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first stage, we build our Golang code to generate the binary using the
    `golang` base image.
  prefs: []
  type: TYPE_NORMAL
- en: In the second stage, we use the Alpine base image and copy the `/tmp/app` file
    from the build stage into our current stage. This is the only file we need to
    run in the container. The rest were only required to build and bloat our container
    during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s build the image and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the same output, but this time with a minimal footprint. Let’s look
    at the image to confirm this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This one occupies just 9.17 MB instead of the huge 803 MB. This is a massive
    improvement! We have reduced the image size by almost 100 times.
  prefs: []
  type: TYPE_NORMAL
- en: That is how we increase efficiency within our container image. Building efficient
    images is the key to running production-ready containers, and most professional
    images you find on Docker Hub use multi-stage builds to create efficient images.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Use multi-stage builds where possible to include minimal content within your
    image. Consider using an Alpine base image if possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at managing images within Docker, some best
    practices, and some of the most frequently used commands.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In modern DevOps practices, Docker images are primarily built either on a developer
    machine or a CI/CD pipeline. The images are stored in a container registry and
    then deployed to multiple staging environments and production machines. They might
    run Docker or a container orchestrator, such as Kubernetes, on top of them.
  prefs: []
  type: TYPE_NORMAL
- en: To efficiently use images, we must understand how to tag them.
  prefs: []
  type: TYPE_NORMAL
- en: Primarily, Docker pulls the image once when you do a Docker run. This means
    that once an image with a particular version is on the machine, Docker will not
    attempt to pull it on every run unless you explicitly pull it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pull the image explicitly, you can use the `docker` `pull` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we attempt to launch a container using this image, it will instantly
    launch the container without pulling the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So, using the latest tag on an image is a bad idea, and the best practice is
    to use semantic versions as your tag. There are two primary reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: If you build the latest image every time, orchestrators such as Docker Compose
    and Kubernetes will assume the image is already on your machine and will not pull
    your image by default. Using an image pull policy such as `Always` on Kubernetes
    or a script to pull the image is a waste of network bandwidth. It is also important
    to note that Docker Hub limits the number of pulls you can make on open source
    images, so you must limit your pulls to only when necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker tags allow you to roll out or roll back your container deployment quickly.
    If you always use the latest tag, the new build overrides the old one, so there
    is no way you can roll back a faulty container to the last known good version.
    Using versioned images in production is also a good idea to ensure your container’s
    stability. If, for some reason, you lose the local image and decide to rerun your
    container, you may not get the same version of the software you were already running,
    as the latest tag changes frequently. So, it’s best to use a particular container
    version in production for stability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images comprise multiple layers, and most of the time, there is a relationship
    between various versions of containers that run on your server. With time, new
    versions of images roll out in your production environment, so removing the old
    images by doing some housekeeping is best. This will reclaim some valuable space
    the container images occupy, resulting in a cleaner filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a particular image, you can use the `docker` `rmi` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Oh! We get an error, but why? It’s because we have a container running and using
    this image.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You cannot remove images currently used by a running container.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will have to stop and remove the container. Then, you can remove
    the image using the preceding command. If you want to do everything at once, you
    can force removal by using the `-f` flag, which will stop the container, remove
    it, and then remove the image. So, unless you know what you are doing, do not
    use the `-``f` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We built our container many times, but what should we do if we need to push
    it to Docker Hub or other registries? But before we do that, we will have to authenticate
    it with Docker Hub using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can push the image to Docker Hub using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This has pushed four layers and mounted the rest from Ubuntu. We used Ubuntu
    as the base image, which is already available on Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have multiple tags for the image and you want to push all of them, then
    you can use the `-a` or `--all-tags` option in the `push` command. This will push
    all the tags for that particular image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When your build fails for some reason and you make changes to your Dockerfile,
    it’s possible that the old images’ layers will remain dangling. Therefore, it
    is best practice to prune the dangling images at regular intervals. You can use
    `docker images prune` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next section, we’ll look at another way to improve Docker image efficiency:
    flattening Docker images.'
  prefs: []
  type: TYPE_NORMAL
- en: Flattening Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker inherently uses a layered filesystem, and we have already discussed why
    it is necessary and how it is beneficial in depth. However, in some particular
    use cases, Docker practitioners have observed that a Docker image with fewer layers
    performs better. You can reduce layers in an image by flattening it. However,
    it is still not a best practice, and you need to do this only if you see a performance
    improvement, as this would result in a filesystem overhead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To flatten a Docker image, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Run a Docker container with the usual image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do a `docker export` of the running container to a `.``tar` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do a `docker import` of the `.tar` file into another image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s use the `nginx-hello-world` image to flatten it and export it to another
    image; that is, `<your_dockerhub_user>/nginx-hello-world:flat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on, let’s get the history of the latest image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run a Docker image with the latest image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s take an export out of the running container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Import `nginx-hello-world-flat.tar` to a new image; that is, `<your_dockerhub_user>/nginx-hello-world:flat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s list the images and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see that the flat image is present and that it occupies less space
    than the latest image. If we view its history, we should see just a single layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It has flattened the image. But is it a best practice to flatten Docker images?
    Well, it depends. Let’s understand when and how to flatten Docker images and what
    you should consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Are several applications using a similar base image? If that is the case, then
    flattening images will only increase the disk footprint, as you won’t be able
    to take advantage of a layered filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider alternatives to flattening images using a small base image, such as
    Alpine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-stage builds are helpful for most complied languages and can reduce your
    image’s size considerably.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also slim down images by using as few layers as possible by combining
    multiple steps into a single `RUN` directive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider whether the benefits of flattening the image outweigh the disadvantages,
    whether you'll get considerable performance improvements, and whether performance
    is critical for your application needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These considerations will help you understand your container image footprint
    and help you manage container images. Remember that although reducing the image’s
    size is ideal, flattening it should be a last resort.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all the images we’ve used have been derived from a Linux distribution
    and always used a distro as their base image. You can also run a container without
    using a Linux distro as the base image to make it more secure. We’ll have a look
    at how in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing containers with distroless images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distroless containers are one of the latest trends in the container world. They
    are promising because they consider all the aspects of optimizing containers for
    the Enterprise environment. You should consider three important things while optimizing
    containers – performance, security, and cost.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don’t make containers out of thin air. You must download images from your
    container registry and then run the container out of the image. Each step uses
    network and disk I/O. The bigger the image, the more resources it consumes and
    the less performance you get from it. Therefore, a smaller Docker image naturally
    performs better.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security is one of the most important aspects of the current IT landscape. Companies
    usually focus on this aspect and invest a lot of money and time. Since containers
    are a relatively new technology, they are vulnerable to hacking, so appropriately
    securing your containers is important. Standard Linux distributions have a lot
    of stuff that can allow hackers to access more than they could have if you secured
    your container properly. Therefore, you must ensure you only have what you need
    within the container.
  prefs: []
  type: TYPE_NORMAL
- en: Cost
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A smaller image also results in a lower cost. The lower your container footprint,
    the more containers you can pack within a machine, so there are fewer machines
    you would need to run your applications. This means you save a lot of money that
    would accumulate over time.
  prefs: []
  type: TYPE_NORMAL
- en: As a modern DevOps engineer, you must ensure your images are optimized for all
    these aspects. Distroless images help take care of all of them. Therefore, let’s
    understand what distroless images are and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Distroless images are the most minimal images and only contain your application,
    dependencies, and the necessary files for your container process to run. Most
    of the time, you do not need package managers such as `apt` or a shell such as
    `bash`. Not having a shell has its advantages. For one, it will help you avoid
    any outside party gaining access to your container while it is running. Your container
    has a small attack surface and won’t have many security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Google provides distroless images in their official GCR registry, available
    on their GitHub page at [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless).
    Let’s get hands-on and see what we can do with them.
  prefs: []
  type: TYPE_NORMAL
- en: The required resources for this exercise are in `ch4/go-hello-world/distroless`
    in this book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by creating a Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This Dockerfile is similar to the multi-stage build Dockerfile for the `go-hello-world`
    container, but instead of using `alpine`, it uses `gcr.io/distroless/base` as
    the base image. This image contains a minimalistic Linux glibc-enabled system
    and lacks a package manager or a shell. You can use it to run binaries compiled
    in a language such as Go, Rust, or D.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s build this first using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run this image and see what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It works! Let’s look at the size of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It’s just 22.3 MB. Yes, it’s a bit more than the Alpine image, but it does not
    contain a shell, so it is more secure from that point of view. Also, there are
    distroless images available for interpreted programming languages, such as Python
    and Java, that you can use instead of the bloated image containing the toolkits
  prefs: []
  type: TYPE_NORMAL
- en: Docker images are stored in Docker registries, and we have all been using Docker
    Hub for a while. In the next section, we’ll understand what they are and what
    our options are for storing our images.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Docker registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Docker registry** is a stateless, highly scalable server-side application
    that stores and lets you distribute Docker images. The registry is open source
    under the permissive **Apache license**. It is a storage and distribution system
    where all your Docker servers can connect and upload and download images as and
    when needed. It acts as a distribution site for your images.
  prefs: []
  type: TYPE_NORMAL
- en: A Docker registry contains several Docker repositories. A Docker repository
    holds several versions of a specific image. For example, all the versions of the
    `nginx` image are stored within a single repository within Docker Hub called `nginx`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Docker interacts with its public Docker registry instance, called
    Docker Hub, which helps you distribute your images to the broader open source
    community.
  prefs: []
  type: TYPE_NORMAL
- en: Not all images can be public and open source, and many proprietary activities
    are ongoing. Docker allows you to use a private Docker registry for a scenario
    you can host within your infrastructure called **Docker Trusted Registry**. Several
    online options are available, including using a SaaS service, such as GCR, or
    creating private repositories at Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: While the SaaS option is readily available and intuitive, let’s consider hosting
    our private Docker registry.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting your private Docker registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker provides an image that you can run on any server that has Docker installed.
    Once the container is up and running, you can use that as the Docker registry.
    Let’s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we know that the registry is running on localhost and listening on port
    `80`, let’s try to push an image to this registry. First, let’s tag the image
    to specify `localhost` as the registry. We will add a registry location at the
    beginning of the Docker tag so that Docker knows where to push the image. We already
    know that the structure of a Docker tag is `<registry_url>/<user>/<image_name>:<image_version>`.
    We will use the `docker tag` command to give another name to an existing image,
    as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can go ahead and push the image to the local Docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it! It is as simple as that!
  prefs: []
  type: TYPE_NORMAL
- en: There are other considerations as well since this is too simplistic. You will
    also have to mount volumes; otherwise, you will lose all the images when you restart
    the registry container. Also, there is no authentication in place, so anyone accessing
    this server can push or pull images, but we don’t desire this. Also, communication
    is insecure, and we want to encrypt the images during transit.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create the local directories that we will mount to the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s generate an `htpasswd` file for adding authentication to the registry.
    For this, we will run the `htpasswd` command from within a new Docker registry
    container to create a file on our local directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to generate some self-signed certificates for enabling TLS
    on the repository. Add your server name or IP when asked for a **Fully Qualified
    Domain Name** (**FQDN**). You can leave the other fields blank or add appropriate
    values for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we proceed further, let’s remove the existing registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to launch our container with the required configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The container is now up and running. Let’s use `https` this time, but before
    that, let’s `docker login` to the registry. Add the username and password you
    set while creating the `htpasswd` file (in this case, `user` and `pass`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the login succeeded, we can go ahead and push our image to the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This time, it works the way we want it to.
  prefs: []
  type: TYPE_NORMAL
- en: Other public registries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from running your registry in a dedicated Docker server, other cloud and
    on-premises options exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most public cloud providers offer paid online registries and container-hosting
    solutions that you can easily use while running in the cloud. Some of them are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Elastic Container Registry** (**ECR**): This is a popular AWS offering
    you can use if your infrastructure runs on AWS. It is a highly available, highly
    performant, fully managed solution. It can host public and private registries,
    and you only pay for the storage you consume and the amount of data transferred
    to the internet. The best part is that it integrates with AWS IAM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Container Registry** (**GCR**): Backed by **Google Cloud Storage**
    (**GCS**), GCR is one of the best choices if you run your infrastructure on GCP.
    It hosts both public and private repositories, and you only pay for the storage
    on GCS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Container Registry** (**ACR**): This fully managed, geo-replicated
    container registry only supports a private registry. It is a good option if you
    are running your infrastructure on Azure. Besides storing container images, it
    also stores Helm charts and other artifacts that help you manage your containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle Cloud Infrastructure Registry**: Oracle Cloud Infrastructure Registry
    is a highly available Oracle-managed container registry. It can host both public
    and private repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CoreOS Quay**: This supports OAuth and LDAP authentication. It offers both
    (paid) private and (free) public repositories, automatic security scanning, and
    automated image builds via integration with GitLab, GitHub, and Bitbucket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don’t want to go with managed options in the cloud or run on-premises,
    you can also use distribution management software such as *Sonatype Nexus* or
    *JFrog Artifactory*. Both tools support Docker registries out of the box. You
    can create a Docker registry there using fancy UIs, and then use `docker login`
    to connect to the registry.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered a lot of ground. At this point, you should
    understand Docker from a hands-on perspective. We started with Docker images,
    how to use a Dockerfile to build Docker images, the components and directives
    of the Dockerfile, and how to create efficient images by following some best practices.
    We also discussed flattening Docker images and improving container security using
    distroless images. Finally, we discussed Docker registries, how to run a private
    Docker registry on a Docker server, and how to use other turnkey solutions, such
    as Sonatype Nexus and JFrog Artifactory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick summary of some best practices for managing Docker containers
    effectively and efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use Official Images**: Whenever possible, start with official Docker images
    from reputable sources such as Docker Hub. These images are well-maintained, regularly
    updated, and often come with better security practices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimize Containers**: Follow the “one service per container” principle.
    Each container should have a single responsibility, which helps with maintainability
    and scaling.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize Container Sizes**: Keep containers as lightweight as possible. Use
    Alpine Linux or other minimal base images and remove unnecessary files and dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Environment Variables**: Store configuration and sensitive data in environment
    variables rather than hardcoding it into the container. This enhances portability
    and security.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent Data**: Store application data outside containers using Docker
    volumes or bind mounts. This ensures that data persists even if containers are
    replaced or stopped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Naming**: Give containers meaningful and unique names. This helps
    with easy identification and troubleshooting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Limits**: Set resource limits (CPU and memory) for containers to
    prevent one misbehaving container from affecting others on the same host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Restart Policies**: Define restart policies to determine how containers
    should behave when they exit or crash. Choose the appropriate policy based on
    your application’s requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Compose**: Use Docker Compose to define and manage multi-container
    applications. It simplifies the deployment and orchestration of complex setups.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network Isolation**: Use Docker networks to isolate containers and control
    communication between them. This enhances security and manageability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health Checks**: Implement health checks in your containers to ensure they
    run as expected. This helps with automated monitoring and recovery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdout`) and standard error (`stderr`) streams. This makes it easier to collect
    and analyze logs using Docker’s logging mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security Best Practices**: Keep containers up to date with security patches,
    avoid running containers as the root, and follow security best practices to avoid
    vulnerabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version Control Dockerfiles**: Store Dockerfiles in version control systems
    (e.g., Git) and regularly review and update them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container Cleanup**: Regularly remove unused containers, images, and volumes
    to free up disk space. Consider using tools such as Docker’s built-in prune commands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestration Tools**: Explore container orchestration tools such as Kubernetes
    or Docker Swarm for managing larger and more complex container deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Maintain clear and up-to-date documentation for your containers
    and images, including how to run them, their required environment variables, and
    any other configuration details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backup and Restore**: Establish backup and restore processes for container
    data and configuration to recover them quickly in case of failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and Scaling**: Implement monitoring and alerting for your containers
    to ensure they run smoothly. Use scaling mechanisms to handle the increased load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these best practices, you can ensure that your Docker container
    environment is well-organized, secure, maintainable, and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will delve into container orchestration using Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker images use a layered model. (True/False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can delete an image from a server if a container using that image is already
    running. (True/False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you remove a running container from a server? (Choose two)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `docker` `rm <container_id>`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. `docker rm -``f <container_id>`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. `docker stop <container_id> && docker` `rm <container_id>`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. `docker stop -``f <container_id>`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following options are container build best practices? (Choose four)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Always add layers that don’t frequently change at the beginning of the Dockerfile.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Combine multiple steps into a single directive to reduce layers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Only use the required files in the container to keep it lightweight and reduce
    the attack surface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Use semantic versioning in your Docker tags and avoid the latest version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: E. Include package managers and a shell within the container, as this helps
    with troubleshooting a running container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: F. Only use an `apt update` at the start of your Dockerfile.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should always flatten Docker images to a single layer. (True/False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A distroless container contains a shell. (True/False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the ways to improve container efficiency? (Choose four)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Try to use a smaller base image if possible, such as Alpine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Only use multi-stage builds to add the required libraries and dependencies
    to the container and omit heavyweight toolkits that are not necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Use distroless base images where possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Flatten Docker images.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: E. Use single-stage builds to include package managers and a shell, as this
    will help in troubleshooting in production.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is a best practice to prune Docker images from time to time. (True/False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Health checks should always be baked into your Docker image. (True/False)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False – you cannot delete an image that is being used by a running container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B, C
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A, B, C, D
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False – only flatten Docker images if you'll benefit from better performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False – distroless containers do not contain a shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A, B, C, D
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False – if you’re using Kubernetes or Docker Compose, use the liveness probes
    or define health checks with a YAML file instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Part 2:Container Orchestration and Serverless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part will build upon *Part 1* and introduce you to managing containers
    with container orchestration and serverless technologies. In this part, you will
    learn how to manage containers both on-premises and in the cloud using cutting-edge
    tools and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19877_05.xhtml#_idTextAnchor536), *Container Orchestration with
    Kubernetes*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19877_06.xhtml#_idTextAnchor668), *Managing Advanced Kubernetes
    Resources*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19877_07.xhtml#_idTextAnchor866), *Containers as a Service (CaaS)
    and Serverless*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
