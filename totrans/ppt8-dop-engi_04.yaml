- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Variables and Data Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和数据类型
- en: This chapter will cover how Puppet handles variables and, in particular, how
    Puppet differs from most declarative languages in terms of how they are used and
    declared. We will look at the core data types that are used to define what the
    value of a variable can contain and how it can be interacted with. Then, we will
    look at how data types and variables allow the classes we discussed in [*Chapter
    3*](B18492_03.xhtml#_idTextAnchor048) to receive external data and handle default
    values.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Puppet 如何处理变量，特别是 Puppet 在如何使用和声明变量方面与大多数声明性语言的不同之处。我们将查看用于定义变量值所能包含的内容以及如何与之交互的核心数据类型。然后，我们将探讨数据类型和变量如何允许我们在[*第3章*](B18492_03.xhtml#_idTextAnchor048)中讨论的类接收外部数据并处理默认值。
- en: Arrays and hashes will be discussed in detail, including how to declare them,
    access values, and manipulate them with operations. The `Sensitive` data type
    will be shown, which you can use to secure values in logs and reports while making
    the limitations of this data type and what it does not secure clear. We will also
    cover abstract data types and show you how to allow more complex and flexible
    definitions of variables and values. The chapter will finish by covering how variable
    scopes and namespaces work with variables. We will also discuss the scope of variables
    and how variables from different scopes can be accessed and which scopes can access
    which levels of data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和哈希将会详细讨论，包括如何声明它们、访问值以及如何使用操作对它们进行操作。`Sensitive` 数据类型将会展示，你可以使用它来保护日志和报告中的值，同时明确该数据类型的限制以及它无法保护的内容。我们还将涵盖抽象数据类型，并展示如何允许更复杂和灵活的变量与值的定义。本章的最后，我们将讨论变量的作用域和命名空间如何与变量一起工作。我们还会讨论变量的作用域，以及如何访问不同作用域的变量，以及哪些作用域可以访问哪些级别的数据。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主要内容：
- en: Variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Arrays and hashes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和哈希
- en: Abstract data types, including `Sensitive`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象数据类型，包括 `Sensitive`
- en: Scope
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to provision a Puppet server standard architecture
    with a Windows client and a Linux client by downloading the `params.json` file
    from [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/params.json)
    and then using the following command from your `pecdm` directory:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要通过下载 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/params.json)
    文件，然后在 `pecdm` 目录中使用以下命令，来准备一个包含 Windows 客户端和 Linux 客户端的 Puppet 服务器标准架构：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In various sections of this chapter, examples will be given of using the `notify`
    function, which outputs to the agent command line. These examples can just be
    run in the local development environment by putting all the code into a manifest
    file – for example, `example.pp` – and then running `puppet` `apply example.pp`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的各个部分将给出使用 `notify` 函数的示例，该函数输出到代理命令行。这些示例可以通过将所有代码放入清单文件中——例如，`example.pp`——并运行
    `puppet apply example.pp` 在本地开发环境中执行。
- en: 'Alternatively, any variables that are required can be set using the environment
    variable format of `FACTER_variable_name` and running `puppet apply –e ''<example_code>''`.
    To run one of the substring examples, you can run the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，任何必需的变量都可以使用 `FACTER_variable_name` 的环境变量格式进行设置，并运行 `puppet apply –e '<example_code>'`。要运行其中一个子字符串示例，你可以运行以下代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Variables
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'In this section, we will cover how to use variables in Puppet and how this
    differs from other procedural languages. The key thing to understand about Puppet
    variables is that they are only assigned once during compilation in a given scope.
    In a traditional procedural language, it’s common to use variables throughout
    your code, where you might gather the current state as your code runs, use variables
    to keep track of it, and update it to act and make procedural decisions at various
    stages of your code. The following is an example of a simple PowerShell script
    that runs a command several times and adds the output to a single variable. It
    does so by using `select-string` to search for files containing `?` in the `.sh`
    and `.pp` files in the user’s code directory:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讲解如何在 Puppet 中使用变量，以及这与其他过程性语言的区别。理解 Puppet 变量的关键是，它们在给定作用域内的编译过程中仅被赋值一次。在传统的过程性语言中，通常会在代码中广泛使用变量，在代码运行时收集当前状态，使用变量来追踪并在代码的不同阶段更新它，以便做出处理和决策。以下是一个简单的
    PowerShell 脚本示例，它多次运行命令，并将输出添加到一个单一变量中。它通过使用`select-string`在用户代码目录中的`.sh`和`.pp`文件中查找包含`?`的文件来实现：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This state check is not done in Puppet since all evaluation takes place at the
    start of the catalog, based on the state the server sent to be compiled. This,
    in turn, provides the steps required to get it into a desired state. In Puppet,
    we assign variables for repetitive uses such as file paths or conditional logic
    such as `if` or `case`. In these cases, a value must be chosen to be assigned,
    depending on the initial state.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有的求值在目录开始时进行，并基于服务器发送过来的编译状态，Puppet 并不会执行这个状态检查。这样就提供了将服务器状态转化为所需状态所需的步骤。在
    Puppet 中，我们为重复使用的内容（如文件路径）或条件逻辑（如`if`或`case`）分配变量。在这些情况下，必须选择一个值并进行赋值，具体取决于初始状态。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are simplifying the process slightly here as there are now deferred functions
    that can run after complications. However, this still does not allow us to reassign
    variables. We will cover this in more detail in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里稍微简化了过程，因为现在有延迟函数可以在复杂性处理后运行。然而，这仍然不允许我们重新赋值。我们将在[*第5章*](B18492_05.xhtml#_idTextAnchor123)中更详细地讲解这一点。
- en: 'Puppet variables are declared with a dollar sign (`$`) followed by the variable’s
    name, an equals symbol (`=`), and the value to assign. For example, a variable
    called `example_variable` that’s assigned a value of `''this is a value''` would
    look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 变量的声明格式是：美元符号（`$`）后跟变量名，再加上等号（`=`）和要赋值的值。例如，一个名为`example_variable`，值为`'this
    is a value'`的变量应该像这样：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that, unlike resources, variables depend on the order of evaluation and
    must be declared in code before they are called.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与资源不同，变量依赖于求值顺序，并且必须在代码中声明后才能调用。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are several variables known as built-in variables that return server information.
    However, since these are more about infrastructure and the environment, they will
    be covered in [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252) and [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272),
    where they will be relevant.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个被称为内置变量的变量，它们返回服务器信息。然而，由于这些更多涉及基础设施和环境，它们将在[*第10章*](B18492_10.xhtml#_idTextAnchor252)和[*第11章*](B18492_11.xhtml#_idTextAnchor272)中详细讲解，在相关部分讨论。
- en: Naming
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名
- en: Variable names are case-sensitive, and they can include upper and lowercase
    letters, numbers, and underscores but must start with an underscore (`_`) or lowercase
    letter. The exception is regex capture variables, which are variables only named
    with numbers such as `$0`, `$1`, and so on. We will cover these in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194)
    and [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272), where we will use them as
    part of conditionals and node definitions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名是区分大小写的，可以包含大写字母、小写字母、数字和下划线，但必须以下划线（`_`）或小写字母开头。例外的是正则表达式捕获变量，这些变量仅使用数字命名，例如`$0`、`$1`等。我们将在[*第7章*](B18492_07.xhtml#_idTextAnchor194)和[*第11章*](B18492_11.xhtml#_idTextAnchor272)中讨论它们，并将它们作为条件语句和节点定义的一部分使用。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Starting a variable name with an underscore will limit it to local scope use,
    as discussed in detail at the end of this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名以下划线开头将限制其仅限于局部作用域使用，具体细节将在本章末尾讨论。
- en: Reserved variable names
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留的变量名
- en: 'There are several built-in variables that you cannot use in your code. These
    are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些内置变量是不能在代码中使用的，具体如下：
- en: '`$``facts`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$``facts`'
- en: '`$``trusted`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$``trusted`'
- en: '`$``server_facts`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$``server_facts`'
- en: These are all built-in variables generated from Facter, which cannot be used
    or reassigned. We will discuss these variables in detail in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123),
    as well as what values they provide.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是从 Facter 生成的内置变量，不能被使用或重新赋值。我们将在 [*第五章*](B18492_05.xhtml#_idTextAnchor123)中详细讨论这些变量，以及它们提供的值。
- en: As we covered in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), the `$title`
    and `$name` variables are used by classes and defined types and should not be
    used.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第三章*](B18492_03.xhtml#_idTextAnchor048)中所讲，`$title` 和 `$name` 变量是由类和定义的类型使用的，应该避免使用。
- en: The full list of reserved words can be viewed in the Puppet documentation at
    [https://www.puppet.com/docs/puppet/8/lang_reserved.html](https://www.puppet.com/docs/puppet/8/lang_reserved.html).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 保留字的完整列表可以在 Puppet 文档中查看，链接为 [https://www.puppet.com/docs/puppet/8/lang_reserved.html](https://www.puppet.com/docs/puppet/8/lang_reserved.html)。
- en: Interpolation
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值
- en: 'Puppet variables can be evaluated and resolved into their assigned values when
    called without quotes or as part of a variable mixed with our data in double quotes.
    The style guide enforced by the lint checks will ensure single quotes are used
    when an assignment does not contain a variable and no quotes are used when an
    assignment only contains a variable. A mix of values and variables can be written
    with double quotes. When you should use a mix is stated in the style guide. This
    is checked by the linter to ensure it uses curly braces `{}`. This can be seen
    in the following example of assigning `mixed_variable` to the variable’s declaration
    when using double quotes for interpolation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 变量在调用时可以被评估并解析为其赋值，前提是没有使用引号，或者作为变量与我们数据中的双引号部分混合时使用。lint 检查强制执行的样式指南将确保在赋值中不包含变量时使用单引号，而仅包含变量时不使用引号。值和变量的混合可以通过双引号来书写。样式指南中会指出何时使用这种混合写法。linter
    会检查确保它使用了大括号 `{}`。这可以通过下面的示例看到，在使用双引号进行插值时，`mixed_variable` 被赋值给变量声明：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we described in the previous chapter, the `notify` function can be used
    to check the values of variables:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中所描述的，`notify` 函数可以用来检查变量的值：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This section discussed how Puppet variables differ compared to other programming
    languages due to statefulness and how it can declare, access, and name variables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了 Puppet 变量如何与其他编程语言的变量不同，特别是在有状态性方面，以及它如何声明、访问和命名变量。
- en: Data types
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'Every value in Puppet has a data type; in the previous section, for example,
    the variables had `String` values assigned. A data type, when used as a capitalized
    unquoted string, such as `Integer`, can be used to specify what parameters in
    a class, defined type, or lambda should contain, allowing the data to be validated:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 中的每个值都有一个数据类型；例如，在上一节中，变量被赋值为 `String` 类型。数据类型，当作为大写的不带引号的字符串使用时，如 `Integer`，可以用来指定类、定义的类型或
    Lambda 中应该包含的参数，从而实现数据验证：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Data types can also be used to compare a variable’s value, conditionally check
    values, and take different actions, depending on the result. For example, to confirm
    that a variable contains an integer, the following match expression can be used.
    Here, we are confirming that the `example_integer` variable contains an integer:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型还可以用来比较变量的值、条件检查值，并根据结果执行不同的操作。例如，为了确认一个变量是否包含整数，可以使用以下匹配表达式。在这里，我们确认 `example_integer`
    变量包含一个整数：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Conditional statements and comparisons will be covered in full in [*Chapter
    7*](B18492_07.xhtml#_idTextAnchor194).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句和比较将在 [*第七章*](B18492_07.xhtml#_idTextAnchor194)中详细介绍。
- en: The next section will run through the most commonly used core Puppet data types.
    Unfortunately, Puppet has no equivalent to the `puppet describe` command for data
    types .so all references must be taken from the web and GitHub documentation at
    [https://www.puppet.com/docs/puppet/8/lang_data_type.html](https://www.puppet.com/docs/puppet/8/lang_data_type.html).
    If you’re using types provided by modules from the forge, which will be covered
    in detail in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212), the documentation
    should be on the reference page of the module. Various functions work with data
    types, but we will not cover this here. We will look at functions in detail in
    [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分将介绍最常用的 Puppet 核心数据类型。不幸的是，Puppet 没有类似于 `puppet describe` 命令的数据类型，所以所有参考必须来自于网络和
    GitHub 文档，具体请见[https://www.puppet.com/docs/puppet/8/lang_data_type.html](https://www.puppet.com/docs/puppet/8/lang_data_type.html)。如果您使用的是来自
    Forge 模块提供的类型，这将在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中详细介绍，文档应该在模块的参考页面中。各种函数可与数据类型一起使用，但这里不会讨论此内容。我们将在[*第5章*](B18492_05.xhtml#_idTextAnchor123)中详细讨论函数。
- en: Strings
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings are the most common data type used in Puppet and, as discussed in [*Chapter
    1*](B18492_01.xhtml#_idTextAnchor018), were originally the only type of data used
    in early Puppet. Strings are pieces of unstructured text of any length, encoded
    in UTF-8\. There are four ways to declare strings in Puppet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是 Puppet 中最常用的数据类型，正如在[*第1章*](B18492_01.xhtml#_idTextAnchor018)中讨论的那样，最早的
    Puppet 中仅使用字符串类型。字符串是任何长度的非结构化文本，以 UTF-8 编码。有四种方式可以在 Puppet 中声明字符串：
- en: Unquoted
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未加引号
- en: Single quoted
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单引号
- en: Double quoted
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双引号
- en: Heredocs
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heredoc
- en: Unquoted strings
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未加引号的字符串
- en: Unquoted strings are single words starting with a lowercase letter and containing
    only letters, digits, hyphens (`-`), and underscores (`_`) and must not be reserved
    words. Reserved words are typically keywords such as class or other language functions;
    the full list can be viewed at [https://www.puppet.com/docs/puppet/8/lang_reserved.html#lang_reserved_words](https://www.puppet.com/docs/puppet/8/lang_reserved.html#lang_reserved_words).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 未加引号的字符串是以小写字母开头的单词，只包含字母、数字、连字符 (`-`) 和下划线 (`_`)，且不能是保留字。保留字通常是诸如 class 之类的关键字或其他语言函数；完整列表可以在[https://www.puppet.com/docs/puppet/8/lang_reserved.html#lang_reserved_words](https://www.puppet.com/docs/puppet/8/lang_reserved.html#lang_reserved_words)查看。
- en: 'Unquoted strings are used for resource attributes that accept a limited set
    of words, such as the Puppet service resource type, which accepts `running` or
    `stopped` for its `ensure` attribute:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 未加引号的字符串用于接受有限单词集的资源属性，例如 Puppet 服务资源类型，它的 `ensure` 属性只能接受 `running` 或 `stopped`：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Single-quoted strings
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单引号字符串
- en: Single-quoted strings can contain multiple words but, as previously discussed,
    cannot interpolate variables. However, they can contain line breaks and escape
    sequences using a backslash (`\`), an escape backslash, or a single quote (`'`).
    This allows the use of single quotes within the string itself and for a backslash
    to be used at the end of a string. Additionally, a line break can be achieved
    via the *Enter* key.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号字符串可以包含多个单词，但如前所述，不能进行变量插值。然而，它们可以包含换行符和使用反斜杠 (`\`)、转义反斜杠或单引号 (`'`) 的转义序列。这允许在字符串本身内使用单引号，并在字符串末尾使用反斜杠。此外，可以通过按下
    *Enter* 键来实现换行符。
- en: 'The following example shows the `sed_command` variable with the single quotes
    needed as part of the `sed` command to escape in the single-quoted string and
    then the `install_dir` variable for a Windows file path with an ending backslash:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 `sed_command` 变量，其中包含作为 `sed` 命令一部分所需的单引号，以在单引号字符串中进行转义，然后是 `install_dir`
    变量，表示带有结尾反斜杠的 Windows 文件路径：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Double-quoted
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双引号
- en: 'Double-quoted strings can fully interpolate variables and more available escape
    characters. In addition to the single quote, backslash, and escape characters,
    double quotes can interpret the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号字符串可以完全插入变量，并且支持更多可用的转义字符。除了单引号、反斜杠和转义字符，双引号还可以解释以下内容：
- en: '`\``n`: Newline'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\``n`: 换行符'
- en: '`\r`: Carriage return'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r`: 回车'
- en: '`\``s`: Space'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\``s`: 空格'
- en: '`\``t`: Tab'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\``t`: 制表符'
- en: '`\$`: Dollar sign, to prevent variable interpolation'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\$`: 美元符号，用于防止变量插值'
- en: '`\uXXXX`: Here, `xxxx` is a four-digit hex number for a Unicode character'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\uXXXX`: 其中 `xxxx` 是表示 Unicode 字符的四位十六进制数字'
- en: '`\u{X}`: Here, `X` is a hex number between two and six digits between curly
    braces, `{}`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u{X}`: 其中 `X` 是两个到六位数字之间的十六进制数字，位于大括号 `{}` 内'
- en: '`\"`: Double quote'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\"`: 双引号'
- en: '`\r\n`: Window line break'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r\n`: Windows 换行符'
- en: As per single quotes, a line break can also be used within text (that is, just
    by hitting *Enter*).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 和单引号一样，换行符也可以在文本中使用（即只需按下 *Enter* 键）。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If a backslash is used in double quotes without you escaping it and without
    a valid escape character after, it will continue and treat it as normal characters
    but result in the following message in the logs: *Warning: Unrecognized escape
    sequence*. Here is an example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在双引号中使用反斜杠而没有进行转义，且后面没有有效的转义字符，它将继续处理并将其视为普通字符，但会在日志中显示以下信息：*警告：未识别的转义序列*。以下是一个示例：
- en: '`Warning: Unrecognized escape sequence ''\T''` `at C:/Users/david/code/test.pp:1:50`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`警告：未识别的转义序列 ''\T''` `位于 C:/Users/david/code/test.pp:1:50`'
- en: This commonly affects Windows user paths that are used in double quotes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常影响使用双引号的 Windows 用户路径。
- en: 'A simple example of a double-quoted string making use of new lines and tabs
    (which are important to the syntax of Makefile content) is as follows. This creates
    a string to then be used in the content of a file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的双引号字符串示例，使用换行符和制表符（这些在 Makefile 内容的语法中非常重要），如下所示。这会创建一个字符串，然后可以在文件内容中使用：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Heredocs
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Heredoc
- en: 'Puppet’s implementation of heredocs involves using a tag to indicate the start
    and end of the heredoc file’s content. The starting tag is typically composed
    of the following elements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 对 heredoc 的实现涉及使用标签来指示 heredoc 文件内容的开始和结束。起始标签通常由以下元素组成：
- en: '`''@(''`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''@(''`'
- en: A string, known as the end text, that may be surrounded by double quotes to
    enable interpolation
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串，称为结束文本，可以用双引号括起来以启用插值
- en: An optional escape switch (or switches) that begin with a forward slash to enable
    escape switches in the text
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的转义开关（或多个开关），以斜杠（/）开头，用于在文本中启用转义开关
- en: An optional colon (`:`) followed by a syntax name check
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的冒号（`:`），后跟语法名称检查
- en: '`'')''`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`'')''`'
- en: 'To use a heredoc in Puppet, the content should be entered on the lines immediately
    following the starting tag, with the exact formatting that is desired. The end
    of the heredoc is indicated by an end tag, which should include the following
    elements:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Puppet 中使用 heredoc，内容应在起始标签后的行中输入，保持所需的精确格式。heredoc 的结束由结束标签表示，结束标签应包括以下元素：
- en: An optional vertical bar (`|`), which indicates how much indentation should
    be stripped from the lines of the text
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的竖线（`|`），表示应该从文本行中删除多少缩进
- en: An optional hyphen (`-`), which removes the final line break from the heredoc
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的短横线（`-`），它会从 heredoc 中移除最后的换行符
- en: The same end text tag that was used in the starting tag
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与起始标签中使用的结束文本标签相同
- en: 'The end text in a Puppet heredoc is a string that can consist of mixed-case
    letters, numbers, and spaces, but cannot include line breaks, slashes, colons,
    or parentheses. By default, the content of the heredoc will not interpret escape
    characters, so optional escape switches must be declared if they are needed. The
    following escape switches are available and mirror the same escape sequences for
    double-quoted strings, but do not require double quotes (since they have no special
    meaning in heredocs):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet heredoc 中的结束文本是一个字符串，可以由大小写字母、数字和空格组成，但不能包含换行符、斜杠、冒号或圆括号。默认情况下，heredoc
    的内容不会解析转义字符，因此如果需要转义开关，必须声明它们。以下转义开关可用，并且与双引号字符串的转义序列相同，但不需要双引号（因为它们在 heredoc
    中没有特殊含义）：
- en: '`n`: New line'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`: 换行符'
- en: '`r`: Carriage return'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`: 回车符'
- en: '`t`: Tab'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`: 制表符'
- en: '`s`: Space'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`: 空格'
- en: '`$`: Dollar sign, to prevent interpolation if the end text is double-quoted'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`: 美元符号，用于防止在双引号文本中进行插值'
- en: '`u`: Unicode characters'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`: Unicode 字符'
- en: '`L`: A new line or carriage return'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`L`: 换行符或回车符'
- en: '`\:`: All of the previously mentioned escape sequences are available'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\:`: 所有之前提到的转义序列均可用'
- en: When any escape sequence is selected, you can use `\\` to escape a backslash.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择任何转义序列时，可以使用 `\\` 来转义反斜杠。
- en: Variable interpolation is disabled by default so, as discussed, the end text
    should be surrounded in double quotes if needed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下禁用变量插值，因此，如前所述，结束文本应在需要时用双引号括起来。
- en: 'Syntax checking is available for various content, such as Puppet manifests
    via `pp` or Ruby files via `ruby`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 语法检查适用于各种内容，例如通过 `pp` 的 Puppet 清单或通过 `ruby` 的 Ruby 文件：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Syntax checking will only run if variable interpolation is not turned on; if
    a type unavailable to Puppet is entered, it will be ignored. The full details
    of available syntax checkers can be found in the Puppet specification, which also
    contains details on creating custom syntax checkers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 语法检查仅在没有启用变量插值的情况下运行；如果输入了 Puppet 不支持的类型，它将被忽略。有关可用语法检查器的详细信息，可以在 Puppet 规范中找到，该规范还包含有关创建自定义语法检查器的详细内容。
- en: 'Heredoc declarations can be placed anywhere a string declaration can be, so,
    for example, a long command in an `exec` command could be declared as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Heredoc 声明可以放置在任何可以声明字符串的地方，因此，举个例子，`exec` 命令中的长命令可以如下声明：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This book recommends using heredocs sparingly. For long commands in exec, as
    shown in the preceding example, this may be suitable, but particularly for file
    content, it typically clutters and confuses the code with text and is better placed
    in templates, as covered in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194), or
    as files in modules, as covered in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
    The topic of how best to store data will be discussed in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本书建议谨慎使用 heredocs。在 `exec` 中执行长命令时，如前面示例所示，这种做法可能合适，但特别是对于文件内容，通常会使代码变得杂乱并且容易混淆，因此最好将其放在模板中，如[*第
    7 章*](B18492_07.xhtml#_idTextAnchor194)所讲，或作为模块中的文件，如[*第 8 章*](B18492_08.xhtml#_idTextAnchor212)所述。关于如何最好地存储数据的问题将在[*第
    9 章*](B18492_09.xhtml#_idTextAnchor233)中讨论。
- en: Accessing substrings in variables
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问变量中的子字符串
- en: To call a string in Puppet, the simplest method is to use the `$` symbol, followed
    by the variable name. However, if the variable name contains invalid characters,
    such as a space, Puppet will assume that the variable name has ended. Therefore,
    to ensure proper interpolation of variables within strings, it is safest to enclose
    the variable name in curly braces, `{}`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 中调用字符串，最简单的方法是使用 `$` 符号，后跟变量名。但是，如果变量名包含无效字符，如空格，Puppet 将认为变量名已结束。因此，为了确保在字符串中正确地插入变量，最好将变量名括在花括号
    `{}` 中。
- en: 'To access a particular character or substring within a string, Puppet allows
    you to specify a range of indices using `[<start index>, <stop position>]`, which
    can include support for negative numbers to count back from the end of a string
    or change the order of characters to be returned. For example, the following code
    sets a variable named `''example_string''` to the `''``substring''` string:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问字符串中的特定字符或子字符串，Puppet 允许你使用 `[<start index>, <stop position>]` 指定一个索引范围，这也支持负数索引，从字符串末尾倒数或改变返回字符的顺序。例如，下面的代码将一个名为
    `'example_string'` 的变量设置为 `'``substring'` 字符串：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Various combinations can be used; for example, a single character can be called
    by taking an index from the start, such as 3, to return `s` (we start at 0).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用各种组合；例如，可以通过从开头取索引（例如 `3`）来调用单个字符，从而返回 `s`（我们从 `0` 开始）。
- en: 'To extract a single character from a string variable in Puppet, you can specify
    the index of the desired character starting from `0`. For example, to extract
    the third character of a string variable, you would use an index of `3` (since
    indexing starts at `0`). In Puppet, this can be expressed as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串变量中提取单个字符，在 Puppet 中，你可以指定从 `0` 开始的字符索引。例如，要提取字符串变量的第三个字符，你可以使用索引 `3`（因为索引从
    `0` 开始）。在 Puppet 中，这可以如下表达：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This would return the character at index `3`, which in this case would be `'s'`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回索引 `3` 处的字符，在本例中为 `'s'`。
- en: 'A negative index can go from the end and return the same `s` character with
    `-6`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 负数索引可以从字符串末尾开始，使用 `-6` 返回相同的 `s` 字符：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To extract a specific portion of a string variable in Puppet, you can use the
    square bracket notation to indicate the start index and the stop position of the
    substring. For example, if you have a string variable named `''example_string''`
    with a value of `''substring''`, and you want to extract a substring that starts
    at the third character and includes the next five characters, you can use the
    following syntax in Puppet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Puppet 中提取字符串变量的特定部分，可以使用方括号表示子字符串的起始索引和结束位置。例如，如果你有一个名为 `'example_string'`
    的字符串变量，其值为 `'substring'`，并且你想提取一个从第三个字符开始并包含接下来的五个字符的子字符串，你可以在 Puppet 中使用以下语法：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This would return the substring that starts at index `3` (which corresponds
    to the letter `'s'` in `'substring'`) and includes the next five characters, which
    in this case would be `'string'`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回从索引 `3` 开始（对应于 `'substring'` 中的字母 `'s'`）并包含接下来的五个字符，在本例中为 `'string'`。
- en: 'To extract a substring starting from a negative index position, you can specify
    a negative value for the stop position. For example, to extract the substring
    that starts from the fourth index from the end and includes the next three characters,
    you can use the following syntax:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取从负索引位置开始的子字符串，可以为停止位置指定负值。例如，要提取从倒数第四个索引位置开始并包含接下来的三个字符，可以使用以下语法：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This would return the substring that starts at the fourth character from the
    end (which corresponds to the letter `'t'` in `'substring'`) and includes the
    next three characters, which in this case would be `'tri'`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回从倒数第四个字符开始的子字符串（它对应于“substring”中的字母‘t’），并包括接下来的三个字符，在这种情况下是‘tri’。
- en: 'Finally, to extract a substring that starts from a negative index position
    and includes a positive number of characters, you can use the following syntax:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要提取一个从负索引位置开始并包括一定数量正整数的子字符串，可以使用以下语法：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would return the substring that starts at the fourth character from the
    end (which corresponds to the letter `'t'` in `'substring'`) and includes the
    next four characters, which in this case would be `'ring'`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回从倒数第四个字符开始的子字符串（它对应于“substring”中的字母‘t’），并包括接下来的四个字符，在这种情况下是‘ring’。
- en: 'This sort of substring work can be particularly useful when package names,
    application versions, or other consistent name strings need to be broken up into
    different variables. As a more practical example, an organization has hostnames
    that start with a location code and contain a role, their environment, and a server
    ID:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种子字符串操作在需要将包名、应用程序版本或其他一致的名称字符串拆分为不同变量时非常有用。作为一个更实际的例子，一个组织有主机名，它们以位置代码开始，并包含角色、环境和服务器ID：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: String data type parameter
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串数据类型参数
- en: 'When setting the type of a parameter as a string, the capitalized keyword of
    `String` is used, along with optional minimum and maximum lengths of the string:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当将参数的类型设置为字符串时，使用大写关键字`String`，并可选地指定字符串的最小和最大长度：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The default for the minimum is 0 and the maximum is infinity. To use the default
    implicitly, you can use the default unquoted string keyword.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最小值默认为0，最大值默认为无限。如果要隐式使用默认值，可以使用默认的未加引号字符串关键字。
- en: 'Let’s look at a class called `database`, which accepts a database ID string
    of four characters, a username between six and eight characters that defaults
    to `dbuser` if it’s not provided, and a description of any length:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个名为`database`的类，它接受一个四个字符的数据库ID字符串，一个长度在六到八个字符之间的用户名（如果未提供，默认值为`dbuser`），以及一个长度不限的描述：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Numbers
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: 'This section will cover the two types Puppet uses for numbers: integers and
    floating points. We will also look at what arithmetic operations can be performed
    on them, how numbers can convert to and from strings, and the variations on these
    types.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍Puppet用于数字的两种类型：整数和浮动点数。我们还将看看可以对它们执行哪些算术操作，数字如何与字符串之间转换，以及这些类型的变化。
- en: 'Both types of numbers are declared without quotation marks. Here, casing does
    not matter where letters are used. The following patterns are available:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型的数字都没有使用引号进行声明。在这里，字母的大小写不重要。以下模式是可用的：
- en: '`–` (positive is presumed in absence)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–`（假设为正数）'
- en: Numeric digits (starting with a `0` for octal)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字字符（八进制数字以`0`开始）
- en: '`–` (positive is presumed in absence)*   `0x` or `0X` (case is not important)*   A
    mix of numeric digits and upper or lowercase letters*   `–` (positive is presumed
    in absence)*   Numeric digits (a `0` is required if using a number between -1
    and 1)*   A decimal point*   Numeric digits*   An optional `e` or `E` preceded
    by digits (for scientific float)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–`（假设为正数）* `0x`或`0X`（大小写不重要）* 数字字符与大写或小写字母的混合* `–`（假设为正数）* 数字字符（使用-1到1之间的数字时需要`0`）*
    小数点* 数字字符* 可选的`e`或`E`，后面跟着数字（用于科学浮点数）'
- en: 'The following are some simple and appropriately named examples of each of the
    preceding types:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些简单且恰当命名的例子，涵盖了上述类型中的每一项：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is important to note that an octal or hexadecimal number cannot be expressed
    as a floating-point number and will result in an error as it is not a valid octal
    or hexadecimal number, as applicable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，八进制或十六进制数字不能表示为浮点数，如果尝试这样做，将会导致错误，因为它不是有效的八进制或十六进制数字。
- en: Arithmetic operators
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'We cannot perform operations to reassign a variable but can assign new variables
    based on operations between assigned variables. The following expressions can
    be used between variables:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法对变量执行重新赋值操作，但可以基于已赋值变量之间的运算来赋予新变量。以下表达式可以用于变量之间：
- en: '`+`: Addition'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`: 加法'
- en: '`-`: Subtraction'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`: 减法'
- en: '`/`: Division'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`: 除法'
- en: '`*`: Multiplication'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`: 乘法'
- en: '`%`: Modulo, the remainder of dividing left by right'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`: 取余，表示左边除以右边的余数'
- en: '`<<`: Left shift'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<<`: 左移'
- en: '`>>`: Right shift'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>>`: 右移'
- en: Left shift and right shift are less familiar and need further explanation. A
    left shift is the first variable multiplied by two to the power of the second
    variable. Taking an example of `5 << 3`, this would translate into 5 * 23, which
    would result in 40.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 左移和右移运算较为陌生，需要进一步解释。左移是将第一个变量乘以 2 的第二个变量次幂。例如，`5 << 3` 等同于 5 * 23，结果为 40。
- en: A right shift is the first variable divided by two to the power of the second
    variable. Taking an example of `32 >> 2,` this would translate into 32 / 22, which
    would result in 8.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 右移是将第一个变量除以第二个变量的 2 的幂。例如，`32 >> 2` 等同于 32 / 22，结果为 8。
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For both left shift and right shift, floats will round down to an integer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于左移和右移，浮点数将向下舍入为整数。
- en: Additionally, the negative symbol (`-`) can be used as a prefix to negate a
    variable and brackets can be used to manage the priority of operations, where
    **Brackets, Orders (powers/indices or roots), Division, Multiplication, Addition,
    and Subtraction** (**BODMAS**) rules apply. Shifts are essentially treated as
    multiplication and modulo division in this priority.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，负号（`-`）可以用作前缀来取反变量，并且括号可以用来管理运算的优先级，在这里 **括号、次序（指数/幂或根号）、除法、乘法、加法和减法** (**BODMAS**)
    规则适用。移位运算在这个优先级中本质上被当作乘法和取余运算来处理。
- en: Any operations between an integer and a float will result in a float and an
    operation on an integer, which would result in a float being rounded down to an
    integer.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 整数与浮点数之间的任何运算都会得到浮点数，且对整数的运算会导致浮点数向下舍入为整数。
- en: 'The following are some examples of using these operators:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用这些运算符的一些示例：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To further show brackets enforcing BODMAS rules, the following example will
    be equal to negative 40:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步展示括号如何强制执行 BODMAS 规则，以下示例将等于负 40：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: String to numeric conversion
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串到数值的转换
- en: 'If a string is used in a numeric operation, it will automatically convert,
    but this will not happen in any other context. To convert a string into a number,
    an object can be declared as an integer, float, or numeric (we will cover numeric
    objects in the *Abstract data types, including Sensitive* section). An example
    of conversion is taking a string, `1`, to an integer and a string, `1.1`, to a
    float:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字符串用于数值运算，它会自动转换，但在其他任何上下文中则不会发生此情况。要将字符串转换为数字，可以声明对象为整数、浮点数或数值（我们将在 *抽象数据类型，包括敏感数据*
    部分介绍数值对象）。转换的示例是将字符串 `1` 转换为整数，字符串 `1.1` 转换为浮点数：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Numeric to string conversion
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值到字符串的转换
- en: 'Numeric types automatically convert into strings when interpolated in a string;
    the automatic conversion uses base 10 notation. The `String` object declaration
    can also be used to convert, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类型在与字符串插值时会自动转换为字符串；这种自动转换使用的是十进制表示法。`String` 对象声明也可以用于转换，示例如下：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Integer data type
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数数据类型
- en: 'When setting the type of a parameter as an integer, the capitalized `Integer`
    keyword is used, along with optional minimum and maximum values of the integer:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当将参数类型设置为整数时，使用大写的 `Integer` 关键字，并可以指定整数的最小值和最大值：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The defaults are technically negative infinity and positive infinity but as
    Puppet uses 64-bit signed integers, this is in the region of −9,223,372,036,854,775,808
    to 9,223,372,036,854,775,807.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值在技术上是负无穷大和正无穷大，但由于 Puppet 使用 64 位带符号整数，这个范围大约是从 −9,223,372,036,854,775,808
    到 9,223,372,036,854,775,807。
- en: Float data type
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数据类型
- en: 'When setting the type of a parameter as a float, the capitalized `Float` keyword
    is used, along with optional minimum and maximum values of the integer:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当将参数类型设置为浮点数时，使用大写的 `Float` 关键字，并可以指定整数的最小值和最大值：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The defaults are technically plus and negative infinity but in practical terms,
    this is the range of a double precision float of -1.7E+308 to +1.7E+308 in Ruby
    implementation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值在技术上是正无穷大和负无穷大，但在实际操作中，这个范围是 Ruby 实现中双精度浮点数的 -1.7E+308 到 +1.7E+308。
- en: 'As an example, consider the following code block, which defines `Class application::filesystem`
    for assigning a percentage of a volume group within known limits of `100` to `10000`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码块，它定义了`Class application::filesystem`，用于在已知的`100`到`10000`的范围内为一个卷组分配百分比：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: undef
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`undef`'
- en: '`undef` is considered equivalent to nil in Ruby and represents the absence
    of a value assigned to a variable. By default, the `strict_variables` setting
    is set to `false`, which means variables that have not been declared have a default
    value of `undef`. In [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252), we will
    see that this can be set in the `puppet.conf` configuration file.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`undef`在Ruby中被视为等同于nil，表示没有给变量赋值。默认情况下，`strict_variables`设置为`false`，这意味着未声明的变量默认值为`undef`。在[*第10章*](B18492_10.xhtml#_idTextAnchor252)中，我们将看到可以在`puppet.conf`配置文件中设置此项。'
- en: 'As a simple example, the following line will notify `Print` that `test1` has
    not been declared:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个简单的例子，以下代码会通知`Print`，`test1`尚未声明：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The only value an `undef` data type has is the unquoted `undef` and it is not
    used for parameter data typing by itself. This is because enforcing the absence
    of a value would have no purpose.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`undef`数据类型的唯一值是未加引号的`undef`，并且它本身不用于参数数据类型。这是因为强制要求值的缺失没有意义。'
- en: In the *Abstract data types, including Sensitive* section of this chapter, we’ll
    see how `undef` values can be accepted for parameters as a part of a selection
    of feasible options.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的*抽象数据类型，包括敏感类型*部分，我们将看到如何接受`undef`值作为参数的一部分，作为可行选项的选择。
- en: When interpolated into a string, `undef` is converted into an empty string (`''`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入到字符串中时，`undef`会被转换为空字符串(`''`)。
- en: Callout
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 调用
- en: In [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123) and [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212),
    we will learn about functions such as `delete_undef_values` and `filter`, which
    can be used to trim the arrays and hashes of `undef` values.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第5章*](B18492_05.xhtml#_idTextAnchor123)和[*第8章*](B18492_08.xhtml#_idTextAnchor212)中，我们将学习一些函数，如`delete_undef_values`和`filter`，它们可以用于修剪数组和哈希中的`undef`值。
- en: Booleans
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: Booleans in Puppet represent `true` or `false` and in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194),
    when looking at `if`/`case` statements, you’ll see that all Puppet comparisons
    return a Boolean type. A Boolean variable should simply contain an unquoted `true`
    or `false` value. As a result, this makes the data type quite simple with no parameters
    – just the capitalized `Boolean` keyword.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet中的布尔值代表`true`或`false`，在[*第7章*](B18492_07.xhtml#_idTextAnchor194)中，当我们查看`if`/`case`语句时，你会发现所有Puppet的比较都会返回布尔类型。布尔变量应该仅包含一个未加引号的`true`或`false`值。因此，这使得数据类型非常简单，没有参数——只有大写的`Boolean`关键字。
- en: 'As an example, the following code is for an `exampleapp` class that has a parameter
    to manage users that are set to `true` by default and a couple of variables hard-coded:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，下面的代码是一个`exampleapp`类，它有一个管理用户的参数，默认设置为`true`，并且有一些硬编码的变量：
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Conversion
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换
- en: Automatic conversion into Boolean values will occur in most cases unless an
    explicit data type has been specified. For example, in an `if` statement, a variable
    can be used as if it were a Boolean by simply writing `$variable_name`. However,
    automatic conversion can be confusing because only `undef` will result in a conversion
    to `false`. This means that the `'false'` string, an empty string (`''`), an integer
    of `0`, and a float of `0.0` will all convert into `true`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，除非显式指定了数据类型，否则会自动将其转换为布尔值。例如，在`if`语句中，变量可以像布尔值一样使用，只需写`$variable_name`。然而，自动转换可能会让人困惑，因为只有`undef`会被转换为`false`。这意味着`'false'`字符串、空字符串(`''`)、整数`0`和浮点数`0.0`都会被转换为`true`。
- en: When using a Boolean declaration, an empty string will fail to convert, as will
    `undef`, while a string of `'false'`, an integer of `0`, or a float of `0.0` will
    convert into `false`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用布尔声明时，空字符串无法转换，`undef`也一样，而`'false'`字符串、整数`0`或浮点数`0.0`会转换为`false`。
- en: Since this is confusing, it is safer to use the `num2bool` and `str2bool` functions
    from the `puppetlabs-stdlib` module, which will be covered in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这可能会让人困惑，因此最好使用来自`puppetlabs-stdlib`模块的`num2bool`和`str2bool`函数，这将在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中讲解。
- en: Regexp
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'The `regexp` type is different from the types we’ve seen so far. It represents
    a valid regular expression in Puppet, which are expressions contained between
    forward slashes based on Ruby’s regex implementation: [http://ruby-doc.org/core/Regexp.html](http://ruby-doc.org/core/Regexp.html).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`regexp`类型不同于我们迄今为止看到的类型。它表示Puppet中的有效正则表达式，正则表达式由基于Ruby正则表达式实现的正斜杠之间的表达式表示：[http://ruby-doc.org/core/Regexp.html](http://ruby-doc.org/core/Regexp.html)。'
- en: Regex use will be covered in more detail in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194),
    where it will be more practically applied. However, it is worth noting that, later
    in this chapter, several abstract types that combine multiple types, including
    `regexp`, will be covered.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的使用将在[*第7章*](B18492_07.xhtml#_idTextAnchor194)中更详细地介绍，届时它将得到更实际的应用。不过，值得注意的是，本章稍后会介绍几个包含多个类型的抽象类型，包括`regexp`。
- en: Lab
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验室
- en: In the previous chapter, a combined `all_grafana` manifest was created and a
    solution was provided at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp).
    Adjust this file so that it is within a class called `all_grafana` and instead
    of using Facter, parameters are used.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，创建了一个合并的`all_grafana`清单，并提供了一个解决方案，详见[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp)。调整此文件，使其包含在一个名为`all_grafana`的类中，并且不再使用Facter，而是使用参数。
- en: 'These parameters should include the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数应包括以下内容：
- en: '**Source download**: A string variable defaulting to [https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm](https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源下载**：一个默认指向[https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm](https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm)的字符串变量'
- en: '**Port**: The port for the service to listen on as an integer'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端口**：服务监听的端口，类型为整数'
- en: '**Service enabled**: By a Boolean'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务启用**：通过布尔值'
- en: To achieve class assignment, write a class declaration that assigns the variables
    to ensure the class is included in a catalog run. When you run `bolt` against
    your manifest, it will ensure you have included your variables. Solutions are
    available at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现类的赋值，编写一个类声明，分配变量以确保该类包含在目录运行中。当你在清单上运行`bolt`时，它将确保你已经包含了变量。解决方案可参考[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp)。
- en: Arrays and hashes
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和哈希
- en: 'This section will cover the two core collections of data in Puppet: arrays
    and hashes. You will learn how to create, access, and perform operations to manipulate
    the values into a new variable.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖Puppet中的两种核心数据集合：数组和哈希。你将学习如何创建、访问以及执行操作，将值操作到一个新的变量中。
- en: Assigning arrays
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配数组
- en: 'Puppet arrays are created by surrounding comma-separated lists of values with
    square brackets. An optional comma can be added after the last element, but this
    book recommends against that for styling. For example, an array called `example_array`
    containing the `first`, `second`, and `third` strings, and would be declared as
    follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet数组是通过用方括号括起来的以逗号分隔的值列表来创建的。最后一个元素后可以添加可选的逗号，但本书不推荐这样做，以保持样式一致。例如，名为`example_array`的数组，包含`first`、`second`和`third`字符串，可以如下声明：
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Arrays can contain any data type, as well as a mix of data types. A Puppet
    variable cannot be reassigned in terms of individual values or in terms of any
    other manipulation such as the addition or removal of values. The following code
    shows how to assign the `mixed_example_array` array with the integer of `1`, a
    Boolean value of `false` from the `example_boolean` variable, and the `example`
    string:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 数组可以包含任何数据类型，也可以包含不同类型的混合数据。Puppet变量不能在单独的值上重新赋值，也不能通过添加或移除值等任何其他操作进行修改。以下代码演示了如何将`mixed_example_array`数组赋值为整数`1`、来自`example_boolean`变量的布尔值`false`，以及`example`字符串：
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Arrays can also be empty with nothing between the brackets, `[]`. They will
    not be identified as `undef` but as an empty array. It would be unlikely to declare
    an array empty directly; this normally occurs as a result of interpolated variables
    and operators causing it to become empty.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 数组也可以为空，方括号中没有任何内容，`[]`。它们不会被识别为 `undef`，而是一个空数组。通常不会直接声明一个空数组；这通常是由于插值变量和运算符导致数组变为空。
- en: Accessing an array index
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数组索引
- en: 'To access an array variables element, a specific element can be specified by
    index, which will return that element. For example, to take the second string
    in the second index of `example_array` and assign it to a variable, you can use
    the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数组变量的元素，可以通过索引指定特定的元素，这将返回该元素。例如，要获取 `example_array` 中第二个索引位置的第二个字符串并将其赋值给变量，可以使用以下代码：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code shows a `notify` resource outputting the string interpolating
    the third element from `example_array` as negative numbers counting back from
    the end of the array:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了一个 `notify` 资源，它输出一个字符串，插入了从 `example_array` 中倒数第三个元素的负数：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Accessing an element that does not exist will result in `undef` being returned.
    You mustn’t put any spacing between the square bracket and the variable name;
    otherwise, it will be interpreted as a variable and the square brackets will be
    separate.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 访问不存在的元素将返回 `undef`。你不能在方括号和变量名之间放置任何空格；否则，它会被解释为一个变量，方括号会被分开。
- en: Accessing a subset of an array
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数组的子集
- en: 'When accessing a subset of an array, a second number is used to indicate the
    stopping point. This is different from how substrings are handled. In the case
    of arrays, a positive number represents the number of elements to return. For
    example, using a count position of `1` will return an array with a single element.
    To extract a sub-array containing only the `''second''` element from `example_array`,
    you could use the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 访问数组子集时，使用第二个数字表示停止点。这与处理子字符串的方式不同。对于数组，正数表示要返回的元素数量。例如，使用计数位置 `1` 将返回一个包含单一元素的数组。要从
    `example_array` 中提取一个只包含 `'second'` 元素的子数组，你可以使用以下代码：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will assign the `['second']` sub-array to the `$``sub_array` variable.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 `['second']` 子数组赋值给 `$``sub_array` 变量。
- en: Choosing a length beyond the length of the array will simply return the available
    elements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 选择超过数组长度的长度将仅返回可用的元素。
- en: 'A negative length will count back from the end of the array. Importantly, unlike
    accessing substrings, you cannot reverse the order by going past the starting
    index; this will simply return an empty array. In the following example, the `negative_sub`
    array will return the whole array since its starting position is `0` and its finishing
    position is the first element from the end of the array. The `empty_sub_array`
    variable will be assigned an empty array since the ending position would be before
    the starting position. The `second_element_array` variable would be assigned an
    array with the second element:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 负长度将从数组的末尾开始倒数。重要的是，与访问子字符串不同，不能通过越过起始索引来反转顺序；这将仅返回一个空数组。在下面的示例中，`negative_sub`
    数组将返回整个数组，因为它的起始位置是 `0`，结束位置是数组末尾的第一个元素。`empty_sub_array` 变量将被赋值为空数组，因为结束位置会在起始位置之前。`second_element_array`
    变量将被赋值为一个包含第二个元素的数组：
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Nested array
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套数组
- en: A nested array can be declared by inserting an array value within an array as
    many times as needed. The value can then be accessed by using multiple sets of
    square brackets to access the desired level. As an example, if a nested array
    is created with the first element as a string, a second value as an array of three
    strings, and a third value of a string, attempting to access the first element
    as a nested element results in returning a string, `i`, since the element at index
    `0` returns a string. A second set of brackets are then used on the `first` string.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在数组内插入数组值来声明嵌套数组，插入的次数根据需要决定。然后，可以通过使用多个方括号来访问所需的级别。例如，如果创建一个嵌套数组，第一项是一个字符串，第二项是一个包含三个字符串的数组，第三项是一个字符串，尝试将第一项作为嵌套元素访问时，将返回字符串
    `i`，因为索引为 `0` 的元素返回的是字符串。然后，在 `first` 字符串上使用第二组方括号。
- en: 'The `nest_second` variable returns the `nest_second` string since it returns
    the nested array at element `1`; then, with the second set of brackets accesses
    the second element:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`nest_second` 变量返回 `nest_second` 字符串，因为它返回了索引为 `1` 的嵌套数组；然后，使用第二组方括号访问第二个元素：'
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To interpolate nesting in an array, curly brackets must surround the variable
    name and square brackets. For example, the following `notify` resource will print
    the first element of `nested_array`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数组中插入嵌套变量，必须用大括号包围变量名和方括号。例如，以下 `notify` 资源将打印 `nested_array` 的第一个元素：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is possible to use the subset approach within nested brackets, but this can
    create confusing and hard-to-follow accesses and is not a recommended style in
    this book.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在嵌套括号内使用子集方法，但这可能会产生令人困惑且难以跟踪的访问方式，因此本书中不推荐这种风格。
- en: Array operators
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组操作符
- en: 'Arrays cannot be manipulated once assigned but operators can manipulate the
    content of arrays to assign new array variables. The following operators are available:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数组被赋值，就不能再直接操作它，但操作符可以操作数组的内容，以便分配新的数组变量。以下是可用的操作符：
- en: '`<<`: Append'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<<`：追加'
- en: '`+`: Concatenate'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+`：连接'
- en: '`-`: Remove'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-`：删除'
- en: '`*`: Splat'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`：扩展（Splat）'
- en: Append
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 追加（Append）
- en: 'Append takes any type of value and adds it as a new element at the end of the
    array. This includes adding an array as a nested array. To combine two arrays,
    concatenate (`+`) must be used. To demonstrate this, let’s look at an example
    of an array with integers `1` and `2` as elements that appends `3` into a new
    array. This will produce a new array, `[1,2,''three'']`; appending an array of
    `[3,4]` to `example_array` will produce a new nested array, `[1,2,[3,4]]`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 追加（Append）接受任何类型的值，并将其作为新元素添加到数组的末尾。这包括将一个数组作为嵌套数组添加。要合并两个数组，必须使用连接操作符（`+`）。为了演示这一点，我们来看一个包含整数
    `1` 和 `2` 的数组，它追加 `3` 形成一个新数组。这将产生一个新数组 `[1,2,'three']`；将 `[3,4]` 数组追加到 `example_array`
    会形成一个新的嵌套数组 `[1,2,[3,4]]`：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Concatenate
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接（Concatenate）
- en: 'Concatenate takes an array and essentially combines its content with another
    array. If the first value is not an array, the compiler will assume this is a
    numerical operator. For numbers, strings, Booleans, and regular expressions, it
    will essentially work the same as an append and add the value to the end. To achieve
    a nested array entry, you must supply a nested array. So, to show some examples,
    `combined_1` will become an array of `[1,2,1]`, `combined_2` will be assigned
    `[1,2,1,2]`, and `combined_3` will result in a nested array being assigned `[1,2,[1]]`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Concatenate`（连接）接收一个数组，并本质上将其内容与另一个数组结合。如果第一个值不是数组，编译器会假定这是一个数值操作符。对于数字、字符串、布尔值和正则表达式，它的工作方式基本与追加相同，都会将值添加到数组的末尾。为了实现嵌套数组的条目，你必须提供一个嵌套数组。因此，举几个例子，`combined_1`
    将变成一个数组 `[1,2,1]`，`combined_2` 会被赋值为 `[1,2,1,2]`，而 `combined_3` 会得到一个嵌套数组 `[1,2,[1]]`：'
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If a hash must be concatenated, it will be converted into an array unless it
    is turned into an array with a single hash element. So, in the following code,
    the converted variable would be assigned a nested array with elements of `test`
    and `value`, giving it an array of `[1,2,[test,''value'']`, while the `nested_hash`
    variable would add a nested hash that assigns `[1,2,{test => ''``value''}]`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要连接一个哈希，它会被转换成数组，除非它已经变成只有一个哈希元素的数组。例如，在下面的代码中，转换后的变量将被赋值为一个嵌套数组，元素为 `test`
    和 `value`，并赋值为 `[1,2,[test,'value']]`，而 `nested_hash` 变量则会添加一个嵌套哈希，赋值为 `[1,2,{test
    => '``value'}]`：
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Remove
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除（Remove）
- en: 'Remove assigns an array after removing all matching elements from a source.
    The first variable must be an array; otherwise, it will be assumed to be a numeric
    operator. For the second variable, if it’s a number, string, Boolean, or regular
    expression, it will search each element of the first variable array and remove
    it if there is a match. For example, removing the `one` string from `another_example_array`
    will match the first element and the third element and remove them, but not the
    first element of the nested array, assigning `[''two'',''three'',''four'',''three'',[''one'',''three'',''four'']`
    to the `remove_string` variable:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作会在从源数组中删除所有匹配元素后分配一个新数组。第一个变量必须是一个数组；否则，它将被视为数值操作符。对于第二个变量，如果是数字、字符串、布尔值或正则表达式，它会检查第一个数组中的每个元素，并在找到匹配时删除它。例如，从
    `another_example_array` 中删除字符串 `one` 会匹配第一个元素和第三个元素并将其删除，但不会删除嵌套数组中的第一个元素，结果会将
    `['two','three','four','three',['one','three','four']]` 赋值给 `remove_string` 变量：
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you have an array as a second variable, it will iterate through each element
    in that array, removing them as if they had been presented directly, as in our
    previous example. In this example, it will remove `one` as per the previous example
    and then perform the searches for matching strings of `three` and `four`, removing
    the fourth, fifth, and sixth elements while assigning `[''two'',[''one'',''three'',''four'']]`
    to the `remove_array` variable:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二个变量是数组时，它会遍历数组中的每个元素，像直接呈现一样删除它们，就像我们之前的例子。在这个例子中，它将按照之前的例子移除`one`，然后继续搜索匹配的`three`和`four`字符串，移除第四、第五和第六个元素，同时将`['two',['one','three','four']]`赋值给`remove_array`变量：
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When a nested array is used as the second variable, it will match any elements
    with the same array and remove them. So, in this example, the `remove_nested_array`
    variable will be assigned `[''one'',''two'',''one'',''three'',''four'',''three'']`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当嵌套数组作为第二个变量时，它会匹配与相同数组的所有元素并将其移除。所以，在这个例子中，`remove_nested_array`变量将被赋值为`['one','two','one','three','four','three']`：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As with concatenation, hashes must be placed in an array; otherwise, they will
    remove any matching element of a translated nested array.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 与连接操作一样，哈希必须放置在数组中；否则，它们将删除翻译后的嵌套数组中的任何匹配元素。
- en: Splat
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展开符
- en: Splats are different from the other operators as they are used to make an array
    provide comma-separated lists as an argument in a function call. This is true
    for both case and selector statements. Using array splats will be covered in detail
    in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123) and [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 展开符与其他运算符不同，它们用于将数组作为函数调用的参数，提供以逗号分隔的列表。这在条件语句和选择器语句中都适用。使用数组展开符将在[*第5章*](B18492_05.xhtml#_idTextAnchor123)和[*第7章*](B18492_07.xhtml#_idTextAnchor194)中详细讲解。
- en: Array data type
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组数据类型
- en: 'When setting the data type of a parameter to an array, the capitalized `Array`
    keyword must be used with a data type for elements of the array, the minimum size
    of the array, and the maximum size of the array:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置参数的数据类型为数组时，必须使用大写的`Array`关键字，并指定数组元素的数据类型、数组的最小大小和最大大小：
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The defaults for data types are data, which will be covered in the *Abstract
    data types, including Sensitive* section of this chapter, but this means that
    numbers (both integers and floats), strings, Booleans, and regular expressions,
    as well as arrays and hashes of these types apply. If you select a more specific
    data type, such as `String`, it will expect every element in the array to contain
    a string. In the *Abstract data types, including Sensitive* section, other mixed
    types will be covered that provide more flexibility.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的默认值是数据，这将在本章的*抽象数据类型，包括敏感数据*部分中讲解，但这意味着数字（包括整数和浮点数）、字符串、布尔值和正则表达式，以及这些类型的数组和哈希都适用。如果选择更具体的数据类型，例如`String`，则期望数组中的每个元素都包含一个字符串。在*抽象数据类型，包括敏感数据*部分中，还将讲解其他混合类型，这些类型提供了更多的灵活性。
- en: The minimum size is 0, while the maximum size is infinite.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最小大小为0，最大大小为无限。
- en: 'As an example, the `database` class could accept a variable of `db_uids`, where
    at least one element is expected in the array but could contain up to six elements.
    The `user_names` variable can be an empty array or up to five elements but most
    only contain strings. Finally, the `extra_flags` variable is an array with default
    values, so it can be an empty array up to an infinite size with the contents matched
    against data types:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`database`类可以接受一个`db_uids`变量，其中至少期望一个元素，但最多可以包含六个元素。`user_names`变量可以是一个空数组或最多五个元素，但大多数情况下只包含字符串。最后，`extra_flags`变量是一个具有默认值的数组，因此它可以是一个空数组，大小可无限，且内容与数据类型匹配：
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Assigning hashes
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值哈希
- en: 'Hashes are written as comma-spaced key-value pairs separated by `=>` and the
    list is surrounded by curl braces, `{ }`. A trailing comma can be added after
    the last pair, but this is not a recommended style by this book. For example,
    the following hash pairs could be declined to assign the `make` key with the `skoda`
    string, the `model` key with the `rapid` string, and the `year` key with the `2014`
    integer:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希作为以逗号分隔的键值对书写，键值对之间用`=>`分隔，列表被大括号`{ }`包围。最后一对键值后可以加上尾随逗号，但本书不推荐这种样式。例如，以下哈希对可以用来为`make`键赋值为`skoda`字符串，`model`键赋值为`rapid`字符串，`year`键赋值为`2014`整数：
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For style purposes, a new line is often taken with each key to ensure the start
    of the keys line up and the arrows line up. Taking a final new line for the closing
    curly brace and lining it up with the opening curly brace is what this book recommends
    when writing arrays:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了格式化风格，通常每个键都会占用一行，以确保键的开始对齐，箭头也能对齐。本书推荐在编写数组时，使用一个新的空行来结束大括号，并将其与起始大括号对齐：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Hash keys and values can be any type, but it rarely makes sense for the keys
    to be anything but strings. Just like arrays, hashes are variables in Puppet and
    can only be assigned once and not manipulated unless a new hash is assigned.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希的键和值可以是任何类型，但键通常应该是字符串类型，其他类型很少有实际意义。就像数组一样，哈希在 Puppet 中是变量，且只能赋值一次，除非重新分配一个新的哈希，否则无法对其进行修改。
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Puppet can only serialize string hash keys into a catalog. Therefore, you cannot
    assign a hash with non-string keys to a resource attribute or class parameter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 只能将字符串类型的哈希键序列化到目录中。因此，无法将非字符串键的哈希分配给资源属性或类参数。
- en: Accessing hash values
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问哈希值
- en: 'Similarly to arrays, hash values can be accessed using square brackets with
    the key value to access. As an example, the following would print the `rapid`
    value:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，哈希值可以通过方括号和键值来访问。举个例子，下面的代码将打印出`rapid`值：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Nested hashes
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套哈希
- en: 'As with arrays, by declaring a hash within a hash, a nested hash can be created,
    which can be accessed with chained keys. The following example shows a variable
    package list containing the `packages` and `services` keys. The `packages` key
    contains the `httpd` key, with a string value of `latest`, and the `cowsay` key,
    with a float value of `4.0`. The `services` key contains the `httpd` key with
    a string value of `running` and the `nginx` key with a string value of `stopped`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组一样，通过在哈希中声明一个哈希，可以创建一个嵌套哈希，这样就可以通过链式键来访问。以下示例展示了一个包含`packages`和`services`键的变量包列表。`packages`键包含`httpd`键，其值为字符串`latest`，以及`cowsay`键，其值为浮动值`4.0`。`services`键包含`httpd`键，其值为字符串`running`，以及`nginx`键，其值为字符串`stopped`：
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To print both of the nested `httpd` keys, a `notify` resource can be declared,
    as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印出嵌套的两个`httpd`键，可以声明一个`notify`资源，如下所示：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Hash operators
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希运算符
- en: There are two operators for hashes – merging (`+`), which can assign a new hash
    by adding key pairs to an existing hash, and removal (`-`), which can assign a
    new hash by removing key pairs from an existing hash.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希有两个运算符——合并（`+`）和移除（`-`）。合并可以通过将键值对添加到现有的哈希中来分配一个新的哈希，而移除则通过从现有哈希中删除键值对来分配一个新的哈希。
- en: Merging
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并
- en: 'Merging is performed by taking a hash variable, a `+` symbol, and a hash or
    an array with an even number of values. Note that this is done while looking to
    add a new key; if a key already exists, it will not be added. In the following
    example, merging a hash with the `database` key with an `oracle` string and a
    `version` key with an integer of `11` with the `app_web` hash with a `web_server`
    key with a string of `httpd` and a `version` key with a value of `12` will result
    in the `combined_app` variable containing the `database` key and value and the
    `web_server` key and value. However, it will ignore the `app_web` key version
    as a key already existed in `app_db`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 合并通过将一个哈希变量、一个`+`符号和一个具有偶数个值的哈希或数组来完成。请注意，合并时如果要添加的键已经存在，它将不会被重复添加。在下面的示例中，将一个包含`database`键和字符串`oracle`、`version`键和整数`11`的哈希与包含`web_server`键和字符串`httpd`、`version`键和`12`值的`app_web`哈希合并，最终会得到`combined_app`变量，包含`database`键值对和`web_server`键值对。然而，`app_web`中的`version`键将被忽略，因为`app_db`中已经存在该键：
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Removal
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除
- en: 'The removal operator takes a hash variable, a `–` symbol, and a hash, an array
    of keys, or a single string key. If giving a hash, the values in the hash will
    not matter as the removal is simply removing any matching keys. In the following
    example, a hash of `software_versions` with the `oracle` key and an integer of
    `11`, the `httpd` key and a value of `12`, and the `cowsay` key with a value of
    `9` can be seen. When a single key is removed to create the `no_cowsay` variable,
    the key-value pair of `cowsay` and `9` is removed. When `only_cowsay` is assigned,
    the values of `oracle` and `httpd` in the hash to be removed do not matter and
    it will simply remove the key and value. For the `only_oracle` variable, removing
    an array will make the removal operator run through each matching key and remove
    matches:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作符接受一个哈希变量，一个`–`符号，以及一个哈希、一个键的数组或一个单一的字符串键。如果提供哈希，则哈希中的值不重要，因为删除操作只是删除匹配的键。在以下示例中，可以看到一个`software_versions`哈希，其中包含`oracle`键和整数`11`，`httpd`键和值`12`，以及`cowsay`键和值`9`。当删除一个键以创建`no_cowsay`变量时，`cowsay`和`9`的键值对被删除。当`only_cowsay`被赋值时，要删除的哈希中`oracle`和`httpd`的值不重要，它将简单地删除键值对。而对于`only_oracle`变量，删除一个数组将使删除操作符遍历每个匹配的键并删除匹配项：
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Hash data type
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希数据类型
- en: 'The hash data type accepts an optional key type and value type; if a key type
    is specified, a value type must be specified. A minimum size and maximum size
    can be specified for how many key pairs there should be:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希数据类型接受可选的键类型和值类型；如果指定了键类型，则必须指定值类型。可以为键对的数量指定最小和最大大小：
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For example, the following class has a `tunables` parameter, which must contain
    a hash with `1` to `10` key-value pairs of strings and integers:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下类具有一个`tunables`参数，它必须包含一个包含`1`到`10`个键值对（字符串和整数）的哈希：
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Mixing hashes and arrays
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合哈希和数组
- en: Since the value of a hash key value or an array value can be any data type,
    nesting can be performed. Care should be taken not to overcomplicate the structure.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希键值或数组值可以是任何数据类型，因此可以进行嵌套操作。但应注意不要让结构过于复杂。
- en: 'The following example shows the `server_cmdb` hash containing a hash of `nfs_share_servers`,
    with the `prod` and `dev` keys containing arrays of strings:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了包含`nfs_share_servers`哈希的`server_cmdb`哈希，其中`prod`和`dev`键包含字符串数组：
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To access the first `prod` array’s third value, `prdnfs02`, the following call
    could be made:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问第一个`prod`数组的第三个值`prdnfs02`，可以执行以下调用：
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Lab
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验
- en: To practice what we’ve covered, write a class that takes an array of packages
    and installs the packages with a hash-defining standard parameter for installing
    the provider and version. Remember to declare the class with variables, as per
    the previous lab. As an example, you could install the latest version of the RubyGems
    webrick, puma, and sinatra. The suggested solution can be found at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/packages_array_hash_paramters.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/packages_array_hash_paramters.pp).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习我们所讲解的内容，编写一个类，该类接受一个软件包数组，并使用哈希定义的标准参数来安装提供者和版本的包。记得根据之前的实验声明类中的变量。例如，你可以安装最新版本的RubyGems，包括webrick、puma和sinatra。建议的解决方案可以在[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/packages_array_hash_paramters.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/packages_array_hash_paramters.pp)中找到。
- en: Abstract data types, including Sensitive
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象数据类型，包括敏感数据
- en: Abstract data types give you the flexibility to mix the core data types for
    parameter enforcement and particular patterns, as well as provide some more advanced
    features in terms of parameter checking. There are a large number of abstract
    types, so this section will cover the most commonly used ones. Other types can
    be found at [https://github.com/puppetlabs/puppet-specifications/blob/master/language/types_values_variables.md](https://github.com/puppetlabs/puppet-specifications/blob/master/language/types_values_variables.md)
    and [https://www.puppet.com/docs/puppet/8/lang_data_abstract.html#variant-data-type](https://www.puppet.com/docs/puppet/8/lang_data_abstract.html#variant-data-type).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象数据类型为你提供了灵活性，可以混合核心数据类型进行参数强制和特定模式的实现，还能在参数检查方面提供一些更高级的功能。抽象数据类型有很多种，所以下面的部分将覆盖最常用的几种。其他类型可以在[https://github.com/puppetlabs/puppet-specifications/blob/master/language/types_values_variables.md](https://github.com/puppetlabs/puppet-specifications/blob/master/language/types_values_variables.md)和[https://www.puppet.com/docs/puppet/8/lang_data_abstract.html#variant-data-type](https://www.puppet.com/docs/puppet/8/lang_data_abstract.html#variant-data-type)找到。
- en: Prefixes
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前缀
- en: Although not Puppet terminology, the types we’ll review will be described as
    prefixes, where a type is prefixed in front of another type with no options.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不是 Puppet 的术语，我们将回顾的类型将被描述为前缀，其中一个类型在另一个类型前加上前缀，且没有其他选项。
- en: Sensitive
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敏感
- en: 'The `Sensitive` data type is used to mark strings as sensitive, which means
    the value will be displayed in plain text in the code and the catalog, but not
    in any Puppet reports or logs. By prefixing the `Sensitive` keyword to parameters
    and assignments with brackets, the strings’ contents are made sensitive. This
    affects both string types and resources that can contain strings or can be converted
    into strings. In the following example, we are showing a string, a string in an
    array, and an array that can be assigned. The output will print `[value redacted]`
    over the section that has been marked as sensitive:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sensitive` 数据类型用于标记字符串为敏感值，这意味着该值将在代码和目录中以明文显示，但不会出现在任何 Puppet 报告或日志中。通过在参数和赋值前加上
    `Sensitive` 关键字，这些字符串的内容会被标记为敏感。此操作影响字符串类型以及可以包含字符串或可以转换为字符串的资源。在以下示例中，我们展示了一个字符串、一个字符串数组和一个可以分配的数组。输出将打印
    `[value redacted]`，表示已标记为敏感的部分：'
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When the value must be used in code, the `unwrap` function allows us to view
    the sensitive value. This example shows how it could be unwrapped to print with
    a `notify` resource:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当值需要在代码中使用时，`unwrap` 函数允许我们查看敏感值。此示例展示了如何解开该值并使用 `notify` 资源打印：
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is purely an example and would defeat the purpose of hiding a value from
    logging and reporting; more likely, it would be passed to another resource. Resources
    such as user-recognized sensitive values for attributes such as `password` do
    not need to be unwrapped, but resources such as `exec` do not interpolate, so
    the values must be unwrapped. To avoid leaking data resources such as `exec`,
    which cannot interpolate, you can wrap it as `Sensitive` to ensure no part is
    exposed in logging. The following example shows passing the sensitive string to
    `user` and passing the sensitive string as a password to a `curl` command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅仅是一个示例，且会违背隐藏日志和报告中值的目的；更可能的是，它会传递给另一个资源。像 `password` 这样的属性，其用户识别的敏感值不需要解包，但像
    `exec` 这样的资源则不能插值，因此值必须解包。为了避免泄露数据，像 `exec` 这样的资源不能插值，你可以将其包装为 `Sensitive`，以确保在日志中不会暴露任何部分。以下示例展示了将敏感字符串传递给
    `user`，并将敏感字符串作为密码传递给 `curl` 命令：
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If only the unwrap is performed when running Puppet with `debug`, the command
    and password would be fully visible.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在使用 `debug` 运行 Puppet 时仅执行解包操作，命令和密码将完全可见。
- en: In [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194), we will cover templates,
    including how to use sensitive values. However, as of Puppet 7.0 and 6.20, you
    no longer need to unwrap sensitive values before using them in templates.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第七章*](B18492_07.xhtml#_idTextAnchor194) 中，我们将讨论模板，包括如何使用敏感值。然而，从 Puppet
    7.0 和 6.20 开始，你不再需要在模板中使用敏感值之前将其解包。
- en: Note
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Securing data fully from end to end will be discussed in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的端到端数据保护将在 [*第九章*](B18492_09.xhtml#_idTextAnchor233) 中讨论。
- en: '`Enum` and more advanced pattern data type patterns, which will be covered
    in the next section, will not work with `Sensitive` and should be avoided. Here,
    you should only use basic types such as `string`.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enum` 和更高级的模式数据类型模式将在下一节中介绍，这些模式与 `Sensitive` 不兼容，应避免使用。在此，你应仅使用基本类型，如 `string`。'
- en: Optional
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选
- en: 'The `Optional` data type allows `undef` to be used as an acceptable input for
    a data type, in addition to the types allowed by the data type it prefixes:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`Optional` 数据类型允许 `undef` 作为数据类型的可接受输入，除此之外，还可以使用它所前缀的其他类型：'
- en: '[PRE62]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For example, to allow an `Integer` parameter or `undef` to be assigned to the
    `oracle_uid` variable, simply add the `Optional` keyword in front of the `Integer`
    type:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要允许将 `Integer` 参数或 `undef` 分配给 `oracle_uid` 变量，只需在 `Integer` 类型前添加 `Optional`
    关键字：
- en: '[PRE63]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `notundef` type has the opposite effect but is of much more limited and
    exceptional use.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`notundef` 类型有相反的效果，但用途更为有限且是例外情况。'
- en: Patterns
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式
- en: Pattern types allow for combinations of types, such as regular expressions or
    specific choices of strings, to be enforced on attributes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 模式类型允许对属性应用类型组合，例如正则表达式或特定的字符串选择。
- en: Enum
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举
- en: 'The `Enum` data type allows you to enumerate strings, allowing multiple options
    to be used on a `class` parameter. The following code declares `Enum`, followed
    by an array of strings as options with a minimum of one string or more:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enum` 数据类型允许你列举字符串，使得多个选项可以在 `class` 参数中使用。以下代码声明了 `Enum`，后面跟着一个字符串数组，作为选项，最少包含一个或更多的字符串：'
- en: '[PRE64]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following example shows how to use this in a class called `regional` with
    a parameter of `uk_region` accepting one of the available UK regions:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在名为 `regional` 的类中使用这个，类的参数 `uk_region` 接受一个可用的英国区域：
- en: '[PRE65]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Variant
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变种
- en: 'The `Variant` data type allows you to combine any other data types as an array.
    The following code uses the `Variant` keyword and declares the list of allowed
    types on a parameter:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Variant` 数据类型允许你将其他任何数据类型组合成一个数组。以下代码使用 `Variant` 关键字，并声明了参数允许的类型列表：'
- en: '[PRE66]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For example, the following class accepts Booleans of `true` and `false` or
    the `true` or `false` strings for the `create_user_home` variable. It will also
    take a string or an array of strings for the `user_names` variable:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的类接受 `true` 和 `false` 的布尔值，或者 `true` 和 `false` 字符串作为 `create_user_home`
    变量的值。它还将接受一个字符串或一个字符串数组作为 `user_names` 变量的值：
- en: '[PRE67]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Pattern
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模式
- en: 'The `Pattern` data type is similar to `Variant` but is a way of providing a
    list of regular expressions where the parameter can match any of them. The syntax
    is as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pattern` 数据类型类似于 `Variant`，但是它提供了一种方式来提供一组正则表达式，参数可以匹配其中任何一个。其语法如下：'
- en: '[PRE68]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here, we are declaring with the `Pattern` keyword, followed by an array of
    `regexp` types. For example, the following defined type, `server_access`, takes
    a hostname that must have a string starting with `edi`, `gla`, or `abe`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `Pattern` 关键字进行声明，后面跟着一个 `regexp` 类型的数组。例如，以下定义的类型 `server_access`，要求主机名是以
    `edi`、`gla` 或 `abe` 开头的字符串：
- en: '[PRE69]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Arrays and hashes
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组和哈希
- en: In this section, we will cover the various arrays and hashes types.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将涵盖各种数组和哈希类型。
- en: Tuple
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: 'In the previous section, we discussed that the array type could have one type
    declared for all of its content. Tuple allows any number of types to be used at
    specific indexes within an array and optional minimum and maximum sizes. The minimum
    size, if smaller than the number of types assigned, makes those types optional,
    while a maximum size allows for the last type to be repeated if the maximum size
    is greater than the number of types declared. A maximum size requires a minimum
    size to be declared:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了数组类型可以声明一个类型来包含其所有内容。`Tuple` 允许在数组的特定索引位置使用任意数量的类型，并支持可选的最小值和最大值。最小值如果小于已分配的类型数量，则这些类型变为可选，而最大值则允许最后一个类型在最大值大于已声明类型数量时重复。最大值需要声明一个最小值：
- en: '[PRE70]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To provide an example of this, let’s consider three variables: `user_declaration`,
    `calculation`, and `file_download`. The `user_declaration` variable requires a
    string for the username, an integer for the UID, and at least one string up to
    eight characters in length, which represents the groups that a user can be assigned
    to. The `calculation` variable requires an integer, a float, and an integer. The
    `file_download` variable requires a URI and a string, and, optionally, an integer.
    Please note that the integer is optional and is not required:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个例子，假设有三个变量：`user_declaration`、`calculation` 和 `file_download`。`user_declaration`
    变量需要一个字符串表示用户名，一个整数表示UID，以及至少一个长度不超过八个字符的字符串，表示用户可以被分配到的组。`calculation` 变量需要一个整数，一个浮动数和一个整数。`file_download`
    变量需要一个 URI 和一个字符串，另外，整数是可选的，并不是必须的：
- en: '[PRE71]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Struct
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构体
- en: '`Struct` provides a similar type to `Tuple` for hashes. In the `Hash` data
    type, a single key type and value type was declared, while a struct allows for
    a particular order string keys with the option to have `optional` or `undef` and
    value types to be declared. Unlike `Tuple`, there is no minimum or maximum size:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`Struct` 提供了一种类似于 `Tuple` 的类型来处理哈希。在 `Hash` 数据类型中，单个键类型和值类型被声明，而结构体允许按特定顺序声明字符串键，并且键的值可以选择性地为
    `optional` 或 `undef`，同时允许声明值类型。与 `Tuple` 不同，没有最小或最大大小的限制：'
- en: '[PRE72]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To illustrate how the use of optional keys and values can affect variable assignments,
    let’s consider three examples: `config_file`, `application_binary`, and `application_startup`.
    The `config_file` variable requires key pairs, including the `mode` key with a
    string value of either `file` or `link`, and a `path` key with a string value.
    The `application_binary` variable is similar to `config_file`, but it allows for
    an optional `owner` key with a string value. If present, the `owner` key must
    have a string value. The `application_startup` variable requires an `owner` key
    that can either be undefined or a string. Additionally, the value for each key
    must match the expected data type:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明可选键和值如何影响变量赋值，让我们考虑三个例子：`config_file`、`application_binary` 和 `application_startup`。`config_file`
    变量需要键值对，包括具有字符串值的 `mode` 键，其值可以是 `file` 或 `link`，以及具有字符串值的 `path` 键。`application_binary`
    变量与 `config_file` 相似，但它允许可选的 `owner` 键，值为字符串。如果存在，`owner` 键必须有字符串值。`application_startup`
    变量要求一个 `owner` 键，可以是未定义值或字符串。此外，每个键的值必须匹配预期的数据类型：
- en: '[PRE73]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Parent data types
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父数据类型
- en: 'The following data types allow you to group multiple data types into a single
    parameter. Using them directly can make code shorter and clearer:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下数据类型允许将多种数据类型组合为单一参数。直接使用它们可以使代码更简洁、更清晰：
- en: '`Any`: The `Any` type matches any Puppet data type, making it useful when the
    exact data type is unknown or does not matter.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`任意`：`任意`类型匹配任何 Puppet 数据类型，当确切的数据类型未知或不重要时非常有用。'
- en: '`Collection`: The `Collection` type matches any array or hash data type, making
    it useful when an array or hash can have multiple data types.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`集合`：`集合`类型匹配任何数组或哈希数据类型，当数组或哈希可以包含多种数据类型时非常有用。'
- en: '`Scalar`: The `Scalar` data type matches strings, Booleans, regular expressions,
    and numerics. It is useful when a single value with any of these data types is
    required.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标量`：`标量`数据类型匹配字符串、布尔值、正则表达式和数字。当需要包含这些数据类型的单个值时非常有用。'
- en: '`Data`: The `Data` type matches scalar, undefs, and arrays containing values
    that match data, and hashes with keys matching scalars and values that match data.
    It is useful when complex data structures are required.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据`：`数据`类型匹配标量、未定义值、包含匹配数据的数组，以及具有匹配标量的键和匹配数据的值的哈希。当需要复杂数据结构时非常有用。'
- en: '`Numeric`: The `Numeric` type matches float and integer data types, which is
    useful when a numerical value is required.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数字`：`数字`类型匹配浮动和整数数据类型，当需要数值时非常有用。'
- en: Lab
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实验室
- en: Continuing our work on the `all_grafana` class, create an `all_grafana_data_types`
    class and add to it so that it accepts a `file_options` parameter. This must have
    a name but can optionally have a mode, a user, and a group as a hash. Ensure each
    of those resources has restricted data types. Add a Grafana user and a sensitive
    parameter password that is passed to the user.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们的 `all_grafana` 类的工作，创建一个 `all_grafana_data_types` 类，并将其添加，使其接受一个 `file_options`
    参数。此参数必须有一个名称，但可以选择性地具有模式、用户和作为哈希的组。确保这些资源的每个数据类型都是受限制的。添加一个 Grafana 用户和一个传递给该用户的敏感参数密码。
- en: To achieve class assignment, write a class declaration before you assign the
    class some variables. When you run `bolt` against your manifest, it will include
    your variables. The solutions are available at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现类赋值，请在赋值类之前编写类声明。当你在清单上运行 `bolt` 时，它将包含你的变量。解决方案可以在 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp)
    上找到。
- en: Scope
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: In Puppet, a scope is a level of code that has limited access to variables and
    default settings for resources. The three levels of scope are top scope, node
    scope, and local scope. Top scope variables reflect variables that are declared
    globally, most commonly in the `site.pp` manifest file. Node scope variables are
    assigned in node definitions, which are typically also made in `site.pp` or via
    an `site.pp` manifest file within a Puppet environment to make them globally available
    to all nodes. Alternatively, variables can be declared in a node definition in
    `site.pp` or the ENC to be made available at the node level for a particular server
    or group of servers. `site.pp` is a special manifest file in Puppet that contains
    the main configuration for a Puppet environment. A resource default is a default
    setting for a resource, which can be overridden in a more specific scope, such
    as node scope or local scope. The full use of `site.pp`, ENC, and node definitions
    will be explained in detail in [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 中，作用域是具有对变量和资源默认设置有限访问权限的代码级别。作用域有三个级别：顶级作用域、节点作用域和本地作用域。顶级作用域变量反映的是全局声明的变量，最常见的是在
    `site.pp` 清单文件中声明。节点作用域变量是在节点定义中分配的，通常也在 `site.pp` 中声明，或通过 Puppet 环境中的 `site.pp`
    清单文件使其对所有节点全局可用。或者，可以在 `site.pp` 中的节点定义或 ENC 中声明变量，以便在节点级别为特定服务器或服务器组提供变量。`site.pp`
    是 Puppet 中的一个特殊清单文件，包含 Puppet 环境的主要配置。资源默认值是资源的默认设置，可以在更具体的作用域中覆盖，例如节点作用域或本地作用域。`site.pp`、ENC
    和节点定义的完整使用将在 [*第 10 章*](B18492_10.xhtml#_idTextAnchor252) 中详细解释。
- en: When accessing a variable, by default, the server will access the lowest level
    first and essentially override variables of the same name at higher levels. Other
    local scopes can be accessed by using the namespace but cannot be assigned values.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问变量时，默认情况下，服务器将首先访问最低级别的变量，并且本质上会覆盖更高级别中同名的变量。其他本地作用域可以通过使用命名空间进行访问，但不能赋值。
- en: 'Here’s an example of how these concepts work together in a single Puppet manifest
    file. We can define a global variable called `''global''` with a string value
    of `''world''`, and a node definition that, by default, assigns all nodes a variable
    called `''node''` with a string value of `''mynode''`. The node definition includes
    two classes, `''local''` and `''also_local''`. In the `''local''` class, we assign
    a variable called `''global''` with a string value of `''override''`, which has
    a local scope and overrides the global value. We will use two notify resources
    to demonstrate how variable scope works. The first notify resource prints `''Print
    override''`, showing that the `''global''` local variable has overridden the global
    value. The second notify resource uses the `::` syntax to reference the global
    variable, so it prints `''Print world''`. The third notify resource prints `''Print
    node''` because there are no local variables with that name. In the `''also_local''`
    class, we define a new variable called `''another_global''` with a string value
    of `''another world''`. The first `notify` resource in this class uses the directly-accessed
    variable to print `''Print another override''`. The second `notify` resource uses
    the `::` syntax to reference the global variable and prints `''Print another world''`
    because no local variable called `''global''` is declared. A `notify` resource
    is a Puppet resource type that simply logs a message to the console or system
    log. It’s commonly used for debugging or informational purposes:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例，展示这些概念如何在单个 Puppet 清单文件中一起工作。我们可以定义一个名为 `'global'` 的全局变量，其值为字符串 `'world'`，并定义一个节点定义，该定义默认为所有节点分配一个名为
    `'node'` 的变量，值为字符串 `'mynode'`。该节点定义包括两个类，`'local'` 和 `'also_local'`。在 `'local'`
    类中，我们将一个名为 `'global'` 的变量赋值为字符串 `'override'`，它具有本地作用域并覆盖全局值。我们将使用两个通知资源来演示变量作用域是如何工作的。第一个通知资源打印
    `'Print override'`，显示 `'global'` 本地变量已覆盖全局值。第二个通知资源使用 `::` 语法引用全局变量，因此它打印 `'Print
    world'`。第三个通知资源打印 `'Print node'`，因为没有具有该名称的本地变量。在 `'also_local'` 类中，我们定义了一个新变量
    `'another_global'`，其值为字符串 `'another world'`。该类中的第一个 `notify` 资源使用直接访问的变量打印 `'Print
    another override'`。第二个 `notify` 资源使用 `::` 语法引用全局变量并打印 `'Print another world'`，因为没有声明名为
    `'global'` 的本地变量。`notify` 资源是 Puppet 的一种资源类型，简单地将消息记录到控制台或系统日志中，通常用于调试或信息目的。
- en: '[PRE74]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Resource titles or references to resources are not limited by scope as they
    must be unique to the whole catalog. As shown in the preceding example, the `notify`
    resources that were used in the `also_local` class had their titles adjusted so
    that they contained `another`. This helps us avoid resource title clashes when
    the variables are interpolated. Otherwise, both the `local` and `also_local` classes
    would have contained `notify` resources called `Print override` and `Print world`
    and would fail to compile with duplicate resources.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 资源标题或对资源的引用不受作用域限制，因为它们必须在整个目录中唯一。如前面示例所示，在 `also_local` 类中使用的 `notify` 资源的标题被调整为包含
    `another`。这有助于我们避免在变量插值时出现资源标题冲突。否则，`local` 和 `also_local` 类都会包含名为 `Print override`
    和 `Print world` 的 `notify` 资源，且会因重复资源而无法编译。
- en: As discussed, the `also_local` class can call the `global` variable from the
    `local` class but cannot assign it to that local scope.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`also_local` 类可以从 `local` 类中调用 `global` 变量，但不能将其赋值给该本地作用域。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned that Puppet variables are different from those in
    normal procedural languages as they can only be assigned once. We saw that certain
    words are reserved and cannot be used in naming variables. We also saw that Puppet
    variables can be interpolated, depending on how and where strings are placed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 Puppet 变量与普通过程语言中的变量不同，因为它们只能被赋值一次。我们看到某些词是保留的，不能用作变量命名。我们还看到，Puppet
    变量可以进行插值，这取决于字符串的放置方式和位置。
- en: We covered various core data types and how they can be used to both restrict
    parameters and assign variables. We also looked at `undef` and Booleans, which
    need to be carefully managed when translating values to get the expected results.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了各种核心数据类型及其如何用于限制参数和赋值变量。我们还探讨了 `undef` 和布尔值，它们在转换值时需要小心管理，以获得预期的结果。
- en: Next, we looked at arrays and hashes and how to assign them. Although they can’t
    be changed, we learned how operators can manipulate them into new assignments.
    We also covered how arrays and hashes can be nested and mixed as hashes of arrays
    and arrays of hashes.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们研究了数组和哈希以及如何为它们赋值。尽管它们不能被更改，但我们了解了运算符如何将它们转化为新的赋值。我们还讲解了数组和哈希如何嵌套以及它们如何混合为数组的哈希或哈希的数组。
- en: Then, we looked at abstract data types and how they apply restrictions to parameters
    more flexibly with the `Sensitive` type, which provides scoped protection for
    logs and reporting.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们研究了抽象数据类型及其如何通过 `Sensitive` 类型更加灵活地限制参数，它为日志和报告提供了作用域保护。
- en: After, we reviewed how Puppet variables can be declared at different scopes
    and how variables can be shared/seen in different scopes.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们回顾了如何在不同的作用域中声明 Puppet 变量，以及如何在不同的作用域中共享/查看变量。
- en: In the next chapter, we will cover facts and functions. We will look at the
    system profiling tool, Facter, the information it gathers, and how it can be customized
    to gather user-specific data on system profiles. Functions provide Ruby code plugins,
    allowing code to be run at compile time, which can perform actions such as data
    manipulation or affect the catalog run. We will cover built-in functions and functions
    from the standard `lib` module, from Puppet Forge, which can be used to manipulate
    data types into the variables we discussed in this chapter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍事实和函数。我们将查看系统配置工具 Facter，它收集的信息，以及如何定制以收集用户特定的系统配置数据。函数提供 Ruby 代码插件，允许在编译时运行代码，可以执行数据操作或影响目录的运行。我们将讨论内置函数以及来自标准
    `lib` 模块的函数，这些函数可以用于将数据类型转化为我们在本章中讨论的变量。
