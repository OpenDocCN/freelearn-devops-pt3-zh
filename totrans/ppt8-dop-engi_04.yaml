- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Variables and Data Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量和数据类型
- en: This chapter will cover how Puppet handles variables and, in particular, how
    Puppet differs from most declarative languages in terms of how they are used and
    declared. We will look at the core data types that are used to define what the
    value of a variable can contain and how it can be interacted with. Then, we will
    look at how data types and variables allow the classes we discussed in [*Chapter
    3*](B18492_03.xhtml#_idTextAnchor048) to receive external data and handle default
    values.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍 Puppet 如何处理变量，特别是 Puppet 在如何使用和声明变量方面与大多数声明性语言的不同之处。我们将查看用于定义变量值所能包含的内容以及如何与之交互的核心数据类型。然后，我们将探讨数据类型和变量如何允许我们在[*第3章*](B18492_03.xhtml#_idTextAnchor048)中讨论的类接收外部数据并处理默认值。
- en: Arrays and hashes will be discussed in detail, including how to declare them,
    access values, and manipulate them with operations. The `Sensitive` data type
    will be shown, which you can use to secure values in logs and reports while making
    the limitations of this data type and what it does not secure clear. We will also
    cover abstract data types and show you how to allow more complex and flexible
    definitions of variables and values. The chapter will finish by covering how variable
    scopes and namespaces work with variables. We will also discuss the scope of variables
    and how variables from different scopes can be accessed and which scopes can access
    which levels of data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和哈希将会详细讨论，包括如何声明它们、访问值以及如何使用操作对它们进行操作。`Sensitive` 数据类型将会展示，你可以使用它来保护日志和报告中的值，同时明确该数据类型的限制以及它无法保护的内容。我们还将涵盖抽象数据类型，并展示如何允许更复杂和灵活的变量与值的定义。本章的最后，我们将讨论变量的作用域和命名空间如何与变量一起工作。我们还会讨论变量的作用域，以及如何访问不同作用域的变量，以及哪些作用域可以访问哪些级别的数据。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主要内容：
- en: Variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Data types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类型
- en: Arrays and hashes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和哈希
- en: Abstract data types, including `Sensitive`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象数据类型，包括 `Sensitive`
- en: Scope
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to provision a Puppet server standard architecture
    with a Windows client and a Linux client by downloading the `params.json` file
    from [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/params.json)
    and then using the following command from your `pecdm` directory:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要通过下载 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/params.json)
    文件，然后在 `pecdm` 目录中使用以下命令，来准备一个包含 Windows 客户端和 Linux 客户端的 Puppet 服务器标准架构：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In various sections of this chapter, examples will be given of using the `notify`
    function, which outputs to the agent command line. These examples can just be
    run in the local development environment by putting all the code into a manifest
    file – for example, `example.pp` – and then running `puppet` `apply example.pp`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的各个部分将给出使用 `notify` 函数的示例，该函数输出到代理命令行。这些示例可以通过将所有代码放入清单文件中——例如，`example.pp`——并运行
    `puppet apply example.pp` 在本地开发环境中执行。
- en: 'Alternatively, any variables that are required can be set using the environment
    variable format of `FACTER_variable_name` and running `puppet apply –e ''<example_code>''`.
    To run one of the substring examples, you can run the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，任何必需的变量都可以使用 `FACTER_variable_name` 的环境变量格式进行设置，并运行 `puppet apply –e '<example_code>'`。要运行其中一个子字符串示例，你可以运行以下代码：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Variables
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'In this section, we will cover how to use variables in Puppet and how this
    differs from other procedural languages. The key thing to understand about Puppet
    variables is that they are only assigned once during compilation in a given scope.
    In a traditional procedural language, it’s common to use variables throughout
    your code, where you might gather the current state as your code runs, use variables
    to keep track of it, and update it to act and make procedural decisions at various
    stages of your code. The following is an example of a simple PowerShell script
    that runs a command several times and adds the output to a single variable. It
    does so by using `select-string` to search for files containing `?` in the `.sh`
    and `.pp` files in the user’s code directory:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讲解如何在 Puppet 中使用变量，以及这与其他过程性语言的区别。理解 Puppet 变量的关键是，它们在给定作用域内的编译过程中仅被赋值一次。在传统的过程性语言中，通常会在代码中广泛使用变量，在代码运行时收集当前状态，使用变量来追踪并在代码的不同阶段更新它，以便做出处理和决策。以下是一个简单的
    PowerShell 脚本示例，它多次运行命令，并将输出添加到一个单一变量中。它通过使用`select-string`在用户代码目录中的`.sh`和`.pp`文件中查找包含`?`的文件来实现：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This state check is not done in Puppet since all evaluation takes place at the
    start of the catalog, based on the state the server sent to be compiled. This,
    in turn, provides the steps required to get it into a desired state. In Puppet,
    we assign variables for repetitive uses such as file paths or conditional logic
    such as `if` or `case`. In these cases, a value must be chosen to be assigned,
    depending on the initial state.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有的求值在目录开始时进行，并基于服务器发送过来的编译状态，Puppet 并不会执行这个状态检查。这样就提供了将服务器状态转化为所需状态所需的步骤。在
    Puppet 中，我们为重复使用的内容（如文件路径）或条件逻辑（如`if`或`case`）分配变量。在这些情况下，必须选择一个值并进行赋值，具体取决于初始状态。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are simplifying the process slightly here as there are now deferred functions
    that can run after complications. However, this still does not allow us to reassign
    variables. We will cover this in more detail in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里稍微简化了过程，因为现在有延迟函数可以在复杂性处理后运行。然而，这仍然不允许我们重新赋值。我们将在[*第5章*](B18492_05.xhtml#_idTextAnchor123)中更详细地讲解这一点。
- en: 'Puppet variables are declared with a dollar sign (`$`) followed by the variable’s
    name, an equals symbol (`=`), and the value to assign. For example, a variable
    called `example_variable` that’s assigned a value of `''this is a value''` would
    look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 变量的声明格式是：美元符号（`$`）后跟变量名，再加上等号（`=`）和要赋值的值。例如，一个名为`example_variable`，值为`'this
    is a value'`的变量应该像这样：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that, unlike resources, variables depend on the order of evaluation and
    must be declared in code before they are called.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与资源不同，变量依赖于求值顺序，并且必须在代码中声明后才能调用。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are several variables known as built-in variables that return server information.
    However, since these are more about infrastructure and the environment, they will
    be covered in [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252) and [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272),
    where they will be relevant.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个被称为内置变量的变量，它们返回服务器信息。然而，由于这些更多涉及基础设施和环境，它们将在[*第10章*](B18492_10.xhtml#_idTextAnchor252)和[*第11章*](B18492_11.xhtml#_idTextAnchor272)中详细讲解，在相关部分讨论。
- en: Naming
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名
- en: Variable names are case-sensitive, and they can include upper and lowercase
    letters, numbers, and underscores but must start with an underscore (`_`) or lowercase
    letter. The exception is regex capture variables, which are variables only named
    with numbers such as `$0`, `$1`, and so on. We will cover these in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194)
    and [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272), where we will use them as
    part of conditionals and node definitions.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名是区分大小写的，可以包含大写字母、小写字母、数字和下划线，但必须以下划线（`_`）或小写字母开头。例外的是正则表达式捕获变量，这些变量仅使用数字命名，例如`$0`、`$1`等。我们将在[*第7章*](B18492_07.xhtml#_idTextAnchor194)和[*第11章*](B18492_11.xhtml#_idTextAnchor272)中讨论它们，并将它们作为条件语句和节点定义的一部分使用。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Starting a variable name with an underscore will limit it to local scope use,
    as discussed in detail at the end of this chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名以下划线开头将限制其仅限于局部作用域使用，具体细节将在本章末尾讨论。
- en: Reserved variable names
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留的变量名
- en: 'There are several built-in variables that you cannot use in your code. These
    are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些内置变量是不能在代码中使用的，具体如下：
- en: '`$``facts`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$``facts`'
- en: '`$``trusted`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$``trusted`'
- en: '`$``server_facts`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$``server_facts`'
- en: These are all built-in variables generated from Facter, which cannot be used
    or reassigned. We will discuss these variables in detail in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123),
    as well as what values they provide.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是从 Facter 生成的内置变量，不能被使用或重新赋值。我们将在 [*第五章*](B18492_05.xhtml#_idTextAnchor123)中详细讨论这些变量，以及它们提供的值。
- en: As we covered in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), the `$title`
    and `$name` variables are used by classes and defined types and should not be
    used.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 [*第三章*](B18492_03.xhtml#_idTextAnchor048)中所讲，`$title` 和 `$name` 变量是由类和定义的类型使用的，应该避免使用。
- en: The full list of reserved words can be viewed in the Puppet documentation at
    [https://www.puppet.com/docs/puppet/8/lang_reserved.html](https://www.puppet.com/docs/puppet/8/lang_reserved.html).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 保留字的完整列表可以在 Puppet 文档中查看，链接为 [https://www.puppet.com/docs/puppet/8/lang_reserved.html](https://www.puppet.com/docs/puppet/8/lang_reserved.html)。
- en: Interpolation
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插值
- en: 'Puppet variables can be evaluated and resolved into their assigned values when
    called without quotes or as part of a variable mixed with our data in double quotes.
    The style guide enforced by the lint checks will ensure single quotes are used
    when an assignment does not contain a variable and no quotes are used when an
    assignment only contains a variable. A mix of values and variables can be written
    with double quotes. When you should use a mix is stated in the style guide. This
    is checked by the linter to ensure it uses curly braces `{}`. This can be seen
    in the following example of assigning `mixed_variable` to the variable’s declaration
    when using double quotes for interpolation:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 变量在调用时可以被评估并解析为其赋值，前提是没有使用引号，或者作为变量与我们数据中的双引号部分混合时使用。lint 检查强制执行的样式指南将确保在赋值中不包含变量时使用单引号，而仅包含变量时不使用引号。值和变量的混合可以通过双引号来书写。样式指南中会指出何时使用这种混合写法。linter
    会检查确保它使用了大括号 `{}`。这可以通过下面的示例看到，在使用双引号进行插值时，`mixed_variable` 被赋值给变量声明：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we described in the previous chapter, the `notify` function can be used
    to check the values of variables:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中所描述的，`notify` 函数可以用来检查变量的值：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This section discussed how Puppet variables differ compared to other programming
    languages due to statefulness and how it can declare, access, and name variables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了 Puppet 变量如何与其他编程语言的变量不同，特别是在有状态性方面，以及它如何声明、访问和命名变量。
- en: Data types
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'Every value in Puppet has a data type; in the previous section, for example,
    the variables had `String` values assigned. A data type, when used as a capitalized
    unquoted string, such as `Integer`, can be used to specify what parameters in
    a class, defined type, or lambda should contain, allowing the data to be validated:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 中的每个值都有一个数据类型；例如，在上一节中，变量被赋值为 `String` 类型。数据类型，当作为大写的不带引号的字符串使用时，如 `Integer`，可以用来指定类、定义的类型或
    Lambda 中应该包含的参数，从而实现数据验证：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Data types can also be used to compare a variable’s value, conditionally check
    values, and take different actions, depending on the result. For example, to confirm
    that a variable contains an integer, the following match expression can be used.
    Here, we are confirming that the `example_integer` variable contains an integer:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型还可以用来比较变量的值、条件检查值，并根据结果执行不同的操作。例如，为了确认一个变量是否包含整数，可以使用以下匹配表达式。在这里，我们确认 `example_integer`
    变量包含一个整数：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Conditional statements and comparisons will be covered in full in [*Chapter
    7*](B18492_07.xhtml#_idTextAnchor194).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句和比较将在 [*第七章*](B18492_07.xhtml#_idTextAnchor194)中详细介绍。
- en: The next section will run through the most commonly used core Puppet data types.
    Unfortunately, Puppet has no equivalent to the `puppet describe` command for data
    types .so all references must be taken from the web and GitHub documentation at
    [https://www.puppet.com/docs/puppet/8/lang_data_type.html](https://www.puppet.com/docs/puppet/8/lang_data_type.html).
    If you’re using types provided by modules from the forge, which will be covered
    in detail in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212), the documentation
    should be on the reference page of the module. Various functions work with data
    types, but we will not cover this here. We will look at functions in detail in
    [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分将介绍最常用的 Puppet 核心数据类型。不幸的是，Puppet 没有类似于 `puppet describe` 命令的数据类型，所以所有参考必须来自于网络和
    GitHub 文档，具体请见[https://www.puppet.com/docs/puppet/8/lang_data_type.html](https://www.puppet.com/docs/puppet/8/lang_data_type.html)。如果您使用的是来自
    Forge 模块提供的类型，这将在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中详细介绍，文档应该在模块的参考页面中。各种函数可与数据类型一起使用，但这里不会讨论此内容。我们将在[*第5章*](B18492_05.xhtml#_idTextAnchor123)中详细讨论函数。
- en: Strings
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Strings are the most common data type used in Puppet and, as discussed in [*Chapter
    1*](B18492_01.xhtml#_idTextAnchor018), were originally the only type of data used
    in early Puppet. Strings are pieces of unstructured text of any length, encoded
    in UTF-8\. There are four ways to declare strings in Puppet:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是 Puppet 中最常用的数据类型，正如在[*第1章*](B18492_01.xhtml#_idTextAnchor018)中讨论的那样，最早的
    Puppet 中仅使用字符串类型。字符串是任何长度的非结构化文本，以 UTF-8 编码。有四种方式可以在 Puppet 中声明字符串：
- en: Unquoted
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未加引号
- en: Single quoted
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单引号
- en: Double quoted
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双引号
- en: Heredocs
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Heredoc
- en: Unquoted strings
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未加引号的字符串
- en: Unquoted strings are single words starting with a lowercase letter and containing
    only letters, digits, hyphens (`-`), and underscores (`_`) and must not be reserved
    words. Reserved words are typically keywords such as class or other language functions;
    the full list can be viewed at [https://www.puppet.com/docs/puppet/8/lang_reserved.html#lang_reserved_words](https://www.puppet.com/docs/puppet/8/lang_reserved.html#lang_reserved_words).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 未加引号的字符串是以小写字母开头的单词，只包含字母、数字、连字符 (`-`) 和下划线 (`_`)，且不能是保留字。保留字通常是诸如 class 之类的关键字或其他语言函数；完整列表可以在[https://www.puppet.com/docs/puppet/8/lang_reserved.html#lang_reserved_words](https://www.puppet.com/docs/puppet/8/lang_reserved.html#lang_reserved_words)查看。
- en: 'Unquoted strings are used for resource attributes that accept a limited set
    of words, such as the Puppet service resource type, which accepts `running` or
    `stopped` for its `ensure` attribute:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 未加引号的字符串用于接受有限单词集的资源属性，例如 Puppet 服务资源类型，它的 `ensure` 属性只能接受 `running` 或 `stopped`：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Single-quoted strings
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单引号字符串
- en: Single-quoted strings can contain multiple words but, as previously discussed,
    cannot interpolate variables. However, they can contain line breaks and escape
    sequences using a backslash (`\`), an escape backslash, or a single quote (`'`).
    This allows the use of single quotes within the string itself and for a backslash
    to be used at the end of a string. Additionally, a line break can be achieved
    via the *Enter* key.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号字符串可以包含多个单词，但如前所述，不能进行变量插值。然而，它们可以包含换行符和使用反斜杠 (`\`)、转义反斜杠或单引号 (`'`) 的转义序列。这允许在字符串本身内使用单引号，并在字符串末尾使用反斜杠。此外，可以通过按下
    *Enter* 键来实现换行符。
- en: 'The following example shows the `sed_command` variable with the single quotes
    needed as part of the `sed` command to escape in the single-quoted string and
    then the `install_dir` variable for a Windows file path with an ending backslash:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了 `sed_command` 变量，其中包含作为 `sed` 命令一部分所需的单引号，以在单引号字符串中进行转义，然后是 `install_dir`
    变量，表示带有结尾反斜杠的 Windows 文件路径：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Double-quoted
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双引号
- en: 'Double-quoted strings can fully interpolate variables and more available escape
    characters. In addition to the single quote, backslash, and escape characters,
    double quotes can interpret the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号字符串可以完全插入变量，并且支持更多可用的转义字符。除了单引号、反斜杠和转义字符，双引号还可以解释以下内容：
- en: '`\``n`: Newline'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\``n`: 换行符'
- en: '`\r`: Carriage return'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r`: 回车'
- en: '`\``s`: Space'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\``s`: 空格'
- en: '`\``t`: Tab'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\``t`: 制表符'
- en: '`\$`: Dollar sign, to prevent variable interpolation'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\$`: 美元符号，用于防止变量插值'
- en: '`\uXXXX`: Here, `xxxx` is a four-digit hex number for a Unicode character'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\uXXXX`: 其中 `xxxx` 是表示 Unicode 字符的四位十六进制数字'
- en: '`\u{X}`: Here, `X` is a hex number between two and six digits between curly
    braces, `{}`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\u{X}`: 其中 `X` 是两个到六位数字之间的十六进制数字，位于大括号 `{}` 内'
- en: '`\"`: Double quote'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\"`: 双引号'
- en: '`\r\n`: Window line break'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r\n`: Windows 换行符'
- en: As per single quotes, a line break can also be used within text (that is, just
    by hitting *Enter*).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'If a backslash is used in double quotes without you escaping it and without
    a valid escape character after, it will continue and treat it as normal characters
    but result in the following message in the logs: *Warning: Unrecognized escape
    sequence*. Here is an example:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '`Warning: Unrecognized escape sequence ''\T''` `at C:/Users/david/code/test.pp:1:50`'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: This commonly affects Windows user paths that are used in double quotes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of a double-quoted string making use of new lines and tabs
    (which are important to the syntax of Makefile content) is as follows. This creates
    a string to then be used in the content of a file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Heredocs
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Puppet’s implementation of heredocs involves using a tag to indicate the start
    and end of the heredoc file’s content. The starting tag is typically composed
    of the following elements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`''@(''`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string, known as the end text, that may be surrounded by double quotes to
    enable interpolation
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional escape switch (or switches) that begin with a forward slash to enable
    escape switches in the text
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional colon (`:`) followed by a syntax name check
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`'')''`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use a heredoc in Puppet, the content should be entered on the lines immediately
    following the starting tag, with the exact formatting that is desired. The end
    of the heredoc is indicated by an end tag, which should include the following
    elements:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: An optional vertical bar (`|`), which indicates how much indentation should
    be stripped from the lines of the text
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional hyphen (`-`), which removes the final line break from the heredoc
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same end text tag that was used in the starting tag
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The end text in a Puppet heredoc is a string that can consist of mixed-case
    letters, numbers, and spaces, but cannot include line breaks, slashes, colons,
    or parentheses. By default, the content of the heredoc will not interpret escape
    characters, so optional escape switches must be declared if they are needed. The
    following escape switches are available and mirror the same escape sequences for
    double-quoted strings, but do not require double quotes (since they have no special
    meaning in heredocs):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '`n`: New line'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r`: Carriage return'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t`: Tab'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: Space'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: Dollar sign, to prevent interpolation if the end text is double-quoted'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u`: Unicode characters'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L`: A new line or carriage return'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\:`: All of the previously mentioned escape sequences are available'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When any escape sequence is selected, you can use `\\` to escape a backslash.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Variable interpolation is disabled by default so, as discussed, the end text
    should be surrounded in double quotes if needed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax checking is available for various content, such as Puppet manifests
    via `pp` or Ruby files via `ruby`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Syntax checking will only run if variable interpolation is not turned on; if
    a type unavailable to Puppet is entered, it will be ignored. The full details
    of available syntax checkers can be found in the Puppet specification, which also
    contains details on creating custom syntax checkers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 语法检查仅在没有启用变量插值的情况下运行；如果输入了 Puppet 不支持的类型，它将被忽略。有关可用语法检查器的详细信息，可以在 Puppet 规范中找到，该规范还包含有关创建自定义语法检查器的详细内容。
- en: 'Heredoc declarations can be placed anywhere a string declaration can be, so,
    for example, a long command in an `exec` command could be declared as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Heredoc 声明可以放置在任何可以声明字符串的地方，因此，举个例子，`exec` 命令中的长命令可以如下声明：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This book recommends using heredocs sparingly. For long commands in exec, as
    shown in the preceding example, this may be suitable, but particularly for file
    content, it typically clutters and confuses the code with text and is better placed
    in templates, as covered in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194), or
    as files in modules, as covered in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
    The topic of how best to store data will be discussed in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本书建议谨慎使用 heredocs。在 `exec` 中执行长命令时，如前面示例所示，这种做法可能合适，但特别是对于文件内容，通常会使代码变得杂乱并且容易混淆，因此最好将其放在模板中，如[*第
    7 章*](B18492_07.xhtml#_idTextAnchor194)所讲，或作为模块中的文件，如[*第 8 章*](B18492_08.xhtml#_idTextAnchor212)所述。关于如何最好地存储数据的问题将在[*第
    9 章*](B18492_09.xhtml#_idTextAnchor233)中讨论。
- en: Accessing substrings in variables
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问变量中的子字符串
- en: To call a string in Puppet, the simplest method is to use the `$` symbol, followed
    by the variable name. However, if the variable name contains invalid characters,
    such as a space, Puppet will assume that the variable name has ended. Therefore,
    to ensure proper interpolation of variables within strings, it is safest to enclose
    the variable name in curly braces, `{}`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 中调用字符串，最简单的方法是使用 `$` 符号，后跟变量名。但是，如果变量名包含无效字符，如空格，Puppet 将认为变量名已结束。因此，为了确保在字符串中正确地插入变量，最好将变量名括在花括号
    `{}` 中。
- en: 'To access a particular character or substring within a string, Puppet allows
    you to specify a range of indices using `[<start index>, <stop position>]`, which
    can include support for negative numbers to count back from the end of a string
    or change the order of characters to be returned. For example, the following code
    sets a variable named `''example_string''` to the `''``substring''` string:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问字符串中的特定字符或子字符串，Puppet 允许你使用 `[<start index>, <stop position>]` 指定一个索引范围，这也支持负数索引，从字符串末尾倒数或改变返回字符的顺序。例如，下面的代码将一个名为
    `'example_string'` 的变量设置为 `'``substring'` 字符串：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Various combinations can be used; for example, a single character can be called
    by taking an index from the start, such as 3, to return `s` (we start at 0).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用各种组合；例如，可以通过从开头取索引（例如 `3`）来调用单个字符，从而返回 `s`（我们从 `0` 开始）。
- en: 'To extract a single character from a string variable in Puppet, you can specify
    the index of the desired character starting from `0`. For example, to extract
    the third character of a string variable, you would use an index of `3` (since
    indexing starts at `0`). In Puppet, this can be expressed as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要从字符串变量中提取单个字符，在 Puppet 中，你可以指定从 `0` 开始的字符索引。例如，要提取字符串变量的第三个字符，你可以使用索引 `3`（因为索引从
    `0` 开始）。在 Puppet 中，这可以如下表达：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This would return the character at index `3`, which in this case would be `'s'`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回索引 `3` 处的字符，在本例中为 `'s'`。
- en: 'A negative index can go from the end and return the same `s` character with
    `-6`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 负数索引可以从字符串末尾开始，使用 `-6` 返回相同的 `s` 字符：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To extract a specific portion of a string variable in Puppet, you can use the
    square bracket notation to indicate the start index and the stop position of the
    substring. For example, if you have a string variable named `''example_string''`
    with a value of `''substring''`, and you want to extract a substring that starts
    at the third character and includes the next five characters, you can use the
    following syntax in Puppet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Puppet 中提取字符串变量的特定部分，可以使用方括号表示子字符串的起始索引和结束位置。例如，如果你有一个名为 `'example_string'`
    的字符串变量，其值为 `'substring'`，并且你想提取一个从第三个字符开始并包含接下来的五个字符的子字符串，你可以在 Puppet 中使用以下语法：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This would return the substring that starts at index `3` (which corresponds
    to the letter `'s'` in `'substring'`) and includes the next five characters, which
    in this case would be `'string'`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回从索引 `3` 开始（对应于 `'substring'` 中的字母 `'s'`）并包含接下来的五个字符，在本例中为 `'string'`。
- en: 'To extract a substring starting from a negative index position, you can specify
    a negative value for the stop position. For example, to extract the substring
    that starts from the fourth index from the end and includes the next three characters,
    you can use the following syntax:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This would return the substring that starts at the fourth character from the
    end (which corresponds to the letter `'t'` in `'substring'`) and includes the
    next three characters, which in this case would be `'tri'`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to extract a substring that starts from a negative index position
    and includes a positive number of characters, you can use the following syntax:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would return the substring that starts at the fourth character from the
    end (which corresponds to the letter `'t'` in `'substring'`) and includes the
    next four characters, which in this case would be `'ring'`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of substring work can be particularly useful when package names,
    application versions, or other consistent name strings need to be broken up into
    different variables. As a more practical example, an organization has hostnames
    that start with a location code and contain a role, their environment, and a server
    ID:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: String data type parameter
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When setting the type of a parameter as a string, the capitalized keyword of
    `String` is used, along with optional minimum and maximum lengths of the string:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The default for the minimum is 0 and the maximum is infinity. To use the default
    implicitly, you can use the default unquoted string keyword.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a class called `database`, which accepts a database ID string
    of four characters, a username between six and eight characters that defaults
    to `dbuser` if it’s not provided, and a description of any length:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Numbers
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will cover the two types Puppet uses for numbers: integers and
    floating points. We will also look at what arithmetic operations can be performed
    on them, how numbers can convert to and from strings, and the variations on these
    types.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Both types of numbers are declared without quotation marks. Here, casing does
    not matter where letters are used. The following patterns are available:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`–` (positive is presumed in absence)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric digits (starting with a `0` for octal)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`–` (positive is presumed in absence)*   `0x` or `0X` (case is not important)*   A
    mix of numeric digits and upper or lowercase letters*   `–` (positive is presumed
    in absence)*   Numeric digits (a `0` is required if using a number between -1
    and 1)*   A decimal point*   Numeric digits*   An optional `e` or `E` preceded
    by digits (for scientific float)'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some simple and appropriately named examples of each of the
    preceding types:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is important to note that an octal or hexadecimal number cannot be expressed
    as a floating-point number and will result in an error as it is not a valid octal
    or hexadecimal number, as applicable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We cannot perform operations to reassign a variable but can assign new variables
    based on operations between assigned variables. The following expressions can
    be used between variables:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '`+`: Addition'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: Subtraction'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`: Division'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: Multiplication'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%`: Modulo, the remainder of dividing left by right'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<<`: Left shift'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>>`: Right shift'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Left shift and right shift are less familiar and need further explanation. A
    left shift is the first variable multiplied by two to the power of the second
    variable. Taking an example of `5 << 3`, this would translate into 5 * 23, which
    would result in 40.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: A right shift is the first variable divided by two to the power of the second
    variable. Taking an example of `32 >> 2,` this would translate into 32 / 22, which
    would result in 8.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: For both left shift and right shift, floats will round down to an integer.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the negative symbol (`-`) can be used as a prefix to negate a
    variable and brackets can be used to manage the priority of operations, where
    **Brackets, Orders (powers/indices or roots), Division, Multiplication, Addition,
    and Subtraction** (**BODMAS**) rules apply. Shifts are essentially treated as
    multiplication and modulo division in this priority.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Any operations between an integer and a float will result in a float and an
    operation on an integer, which would result in a float being rounded down to an
    integer.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some examples of using these operators:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To further show brackets enforcing BODMAS rules, the following example will
    be equal to negative 40:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: String to numeric conversion
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a string is used in a numeric operation, it will automatically convert,
    but this will not happen in any other context. To convert a string into a number,
    an object can be declared as an integer, float, or numeric (we will cover numeric
    objects in the *Abstract data types, including Sensitive* section). An example
    of conversion is taking a string, `1`, to an integer and a string, `1.1`, to a
    float:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Numeric to string conversion
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Numeric types automatically convert into strings when interpolated in a string;
    the automatic conversion uses base 10 notation. The `String` object declaration
    can also be used to convert, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Integer data type
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When setting the type of a parameter as an integer, the capitalized `Integer`
    keyword is used, along with optional minimum and maximum values of the integer:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The defaults are technically negative infinity and positive infinity but as
    Puppet uses 64-bit signed integers, this is in the region of −9,223,372,036,854,775,808
    to 9,223,372,036,854,775,807.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Float data type
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When setting the type of a parameter as a float, the capitalized `Float` keyword
    is used, along with optional minimum and maximum values of the integer:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The defaults are technically plus and negative infinity but in practical terms,
    this is the range of a double precision float of -1.7E+308 to +1.7E+308 in Ruby
    implementation.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following code block, which defines `Class application::filesystem`
    for assigning a percentage of a volume group within known limits of `100` to `10000`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: undef
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`undef` is considered equivalent to nil in Ruby and represents the absence
    of a value assigned to a variable. By default, the `strict_variables` setting
    is set to `false`, which means variables that have not been declared have a default
    value of `undef`. In [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252), we will
    see that this can be set in the `puppet.conf` configuration file.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example, the following line will notify `Print` that `test1` has
    not been declared:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The only value an `undef` data type has is the unquoted `undef` and it is not
    used for parameter data typing by itself. This is because enforcing the absence
    of a value would have no purpose.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In the *Abstract data types, including Sensitive* section of this chapter, we’ll
    see how `undef` values can be accepted for parameters as a part of a selection
    of feasible options.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: When interpolated into a string, `undef` is converted into an empty string (`''`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Callout
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123) and [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212),
    we will learn about functions such as `delete_undef_values` and `filter`, which
    can be used to trim the arrays and hashes of `undef` values.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Booleans in Puppet represent `true` or `false` and in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194),
    when looking at `if`/`case` statements, you’ll see that all Puppet comparisons
    return a Boolean type. A Boolean variable should simply contain an unquoted `true`
    or `false` value. As a result, this makes the data type quite simple with no parameters
    – just the capitalized `Boolean` keyword.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following code is for an `exampleapp` class that has a parameter
    to manage users that are set to `true` by default and a couple of variables hard-coded:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Conversion
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automatic conversion into Boolean values will occur in most cases unless an
    explicit data type has been specified. For example, in an `if` statement, a variable
    can be used as if it were a Boolean by simply writing `$variable_name`. However,
    automatic conversion can be confusing because only `undef` will result in a conversion
    to `false`. This means that the `'false'` string, an empty string (`''`), an integer
    of `0`, and a float of `0.0` will all convert into `true`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: When using a Boolean declaration, an empty string will fail to convert, as will
    `undef`, while a string of `'false'`, an integer of `0`, or a float of `0.0` will
    convert into `false`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Since this is confusing, it is safer to use the `num2bool` and `str2bool` functions
    from the `puppetlabs-stdlib` module, which will be covered in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Regexp
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `regexp` type is different from the types we’ve seen so far. It represents
    a valid regular expression in Puppet, which are expressions contained between
    forward slashes based on Ruby’s regex implementation: [http://ruby-doc.org/core/Regexp.html](http://ruby-doc.org/core/Regexp.html).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Regex use will be covered in more detail in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194),
    where it will be more practically applied. However, it is worth noting that, later
    in this chapter, several abstract types that combine multiple types, including
    `regexp`, will be covered.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Lab
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, a combined `all_grafana` manifest was created and a
    solution was provided at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp).
    Adjust this file so that it is within a class called `all_grafana` and instead
    of using Facter, parameters are used.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'These parameters should include the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '**Source download**: A string variable defaulting to [https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm](https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm)'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: The port for the service to listen on as an integer'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service enabled**: By a Boolean'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve class assignment, write a class declaration that assigns the variables
    to ensure the class is included in a catalog run. When you run `bolt` against
    your manifest, it will ensure you have included your variables. Solutions are
    available at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and hashes
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will cover the two core collections of data in Puppet: arrays
    and hashes. You will learn how to create, access, and perform operations to manipulate
    the values into a new variable.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Assigning arrays
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Puppet arrays are created by surrounding comma-separated lists of values with
    square brackets. An optional comma can be added after the last element, but this
    book recommends against that for styling. For example, an array called `example_array`
    containing the `first`, `second`, and `third` strings, and would be declared as
    follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Arrays can contain any data type, as well as a mix of data types. A Puppet
    variable cannot be reassigned in terms of individual values or in terms of any
    other manipulation such as the addition or removal of values. The following code
    shows how to assign the `mixed_example_array` array with the integer of `1`, a
    Boolean value of `false` from the `example_boolean` variable, and the `example`
    string:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Arrays can also be empty with nothing between the brackets, `[]`. They will
    not be identified as `undef` but as an empty array. It would be unlikely to declare
    an array empty directly; this normally occurs as a result of interpolated variables
    and operators causing it to become empty.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an array index
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To access an array variables element, a specific element can be specified by
    index, which will return that element. For example, to take the second string
    in the second index of `example_array` and assign it to a variable, you can use
    the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following code shows a `notify` resource outputting the string interpolating
    the third element from `example_array` as negative numbers counting back from
    the end of the array:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Accessing an element that does not exist will result in `undef` being returned.
    You mustn’t put any spacing between the square bracket and the variable name;
    otherwise, it will be interpreted as a variable and the square brackets will be
    separate.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a subset of an array
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When accessing a subset of an array, a second number is used to indicate the
    stopping point. This is different from how substrings are handled. In the case
    of arrays, a positive number represents the number of elements to return. For
    example, using a count position of `1` will return an array with a single element.
    To extract a sub-array containing only the `''second''` element from `example_array`,
    you could use the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will assign the `['second']` sub-array to the `$``sub_array` variable.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a length beyond the length of the array will simply return the available
    elements.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'A negative length will count back from the end of the array. Importantly, unlike
    accessing substrings, you cannot reverse the order by going past the starting
    index; this will simply return an empty array. In the following example, the `negative_sub`
    array will return the whole array since its starting position is `0` and its finishing
    position is the first element from the end of the array. The `empty_sub_array`
    variable will be assigned an empty array since the ending position would be before
    the starting position. The `second_element_array` variable would be assigned an
    array with the second element:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Nested array
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A nested array can be declared by inserting an array value within an array as
    many times as needed. The value can then be accessed by using multiple sets of
    square brackets to access the desired level. As an example, if a nested array
    is created with the first element as a string, a second value as an array of three
    strings, and a third value of a string, attempting to access the first element
    as a nested element results in returning a string, `i`, since the element at index
    `0` returns a string. A second set of brackets are then used on the `first` string.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nest_second` variable returns the `nest_second` string since it returns
    the nested array at element `1`; then, with the second set of brackets accesses
    the second element:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To interpolate nesting in an array, curly brackets must surround the variable
    name and square brackets. For example, the following `notify` resource will print
    the first element of `nested_array`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is possible to use the subset approach within nested brackets, but this can
    create confusing and hard-to-follow accesses and is not a recommended style in
    this book.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Array operators
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays cannot be manipulated once assigned but operators can manipulate the
    content of arrays to assign new array variables. The following operators are available:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '`<<`: Append'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: Concatenate'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: Remove'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: Splat'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Append takes any type of value and adds it as a new element at the end of the
    array. This includes adding an array as a nested array. To combine two arrays,
    concatenate (`+`) must be used. To demonstrate this, let’s look at an example
    of an array with integers `1` and `2` as elements that appends `3` into a new
    array. This will produce a new array, `[1,2,''three'']`; appending an array of
    `[3,4]` to `example_array` will produce a new nested array, `[1,2,[3,4]]`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Concatenate
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Concatenate takes an array and essentially combines its content with another
    array. If the first value is not an array, the compiler will assume this is a
    numerical operator. For numbers, strings, Booleans, and regular expressions, it
    will essentially work the same as an append and add the value to the end. To achieve
    a nested array entry, you must supply a nested array. So, to show some examples,
    `combined_1` will become an array of `[1,2,1]`, `combined_2` will be assigned
    `[1,2,1,2]`, and `combined_3` will result in a nested array being assigned `[1,2,[1]]`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If a hash must be concatenated, it will be converted into an array unless it
    is turned into an array with a single hash element. So, in the following code,
    the converted variable would be assigned a nested array with elements of `test`
    and `value`, giving it an array of `[1,2,[test,''value'']`, while the `nested_hash`
    variable would add a nested hash that assigns `[1,2,{test => ''``value''}]`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Remove
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remove assigns an array after removing all matching elements from a source.
    The first variable must be an array; otherwise, it will be assumed to be a numeric
    operator. For the second variable, if it’s a number, string, Boolean, or regular
    expression, it will search each element of the first variable array and remove
    it if there is a match. For example, removing the `one` string from `another_example_array`
    will match the first element and the third element and remove them, but not the
    first element of the nested array, assigning `[''two'',''three'',''four'',''three'',[''one'',''three'',''four'']`
    to the `remove_string` variable:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When you have an array as a second variable, it will iterate through each element
    in that array, removing them as if they had been presented directly, as in our
    previous example. In this example, it will remove `one` as per the previous example
    and then perform the searches for matching strings of `three` and `four`, removing
    the fourth, fifth, and sixth elements while assigning `[''two'',[''one'',''three'',''four'']]`
    to the `remove_array` variable:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When a nested array is used as the second variable, it will match any elements
    with the same array and remove them. So, in this example, the `remove_nested_array`
    variable will be assigned `[''one'',''two'',''one'',''three'',''four'',''three'']`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As with concatenation, hashes must be placed in an array; otherwise, they will
    remove any matching element of a translated nested array.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Splat
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Splats are different from the other operators as they are used to make an array
    provide comma-separated lists as an argument in a function call. This is true
    for both case and selector statements. Using array splats will be covered in detail
    in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123) and [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Array data type
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When setting the data type of a parameter to an array, the capitalized `Array`
    keyword must be used with a data type for elements of the array, the minimum size
    of the array, and the maximum size of the array:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The defaults for data types are data, which will be covered in the *Abstract
    data types, including Sensitive* section of this chapter, but this means that
    numbers (both integers and floats), strings, Booleans, and regular expressions,
    as well as arrays and hashes of these types apply. If you select a more specific
    data type, such as `String`, it will expect every element in the array to contain
    a string. In the *Abstract data types, including Sensitive* section, other mixed
    types will be covered that provide more flexibility.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The minimum size is 0, while the maximum size is infinite.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the `database` class could accept a variable of `db_uids`, where
    at least one element is expected in the array but could contain up to six elements.
    The `user_names` variable can be an empty array or up to five elements but most
    only contain strings. Finally, the `extra_flags` variable is an array with default
    values, so it can be an empty array up to an infinite size with the contents matched
    against data types:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Assigning hashes
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hashes are written as comma-spaced key-value pairs separated by `=>` and the
    list is surrounded by curl braces, `{ }`. A trailing comma can be added after
    the last pair, but this is not a recommended style by this book. For example,
    the following hash pairs could be declined to assign the `make` key with the `skoda`
    string, the `model` key with the `rapid` string, and the `year` key with the `2014`
    integer:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'For style purposes, a new line is often taken with each key to ensure the start
    of the keys line up and the arrows line up. Taking a final new line for the closing
    curly brace and lining it up with the opening curly brace is what this book recommends
    when writing arrays:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Hash keys and values can be any type, but it rarely makes sense for the keys
    to be anything but strings. Just like arrays, hashes are variables in Puppet and
    can only be assigned once and not manipulated unless a new hash is assigned.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Puppet can only serialize string hash keys into a catalog. Therefore, you cannot
    assign a hash with non-string keys to a resource attribute or class parameter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Accessing hash values
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly to arrays, hash values can be accessed using square brackets with
    the key value to access. As an example, the following would print the `rapid`
    value:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Nested hashes
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with arrays, by declaring a hash within a hash, a nested hash can be created,
    which can be accessed with chained keys. The following example shows a variable
    package list containing the `packages` and `services` keys. The `packages` key
    contains the `httpd` key, with a string value of `latest`, and the `cowsay` key,
    with a float value of `4.0`. The `services` key contains the `httpd` key with
    a string value of `running` and the `nginx` key with a string value of `stopped`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To print both of the nested `httpd` keys, a `notify` resource can be declared,
    as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Hash operators
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two operators for hashes – merging (`+`), which can assign a new hash
    by adding key pairs to an existing hash, and removal (`-`), which can assign a
    new hash by removing key pairs from an existing hash.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Merging is performed by taking a hash variable, a `+` symbol, and a hash or
    an array with an even number of values. Note that this is done while looking to
    add a new key; if a key already exists, it will not be added. In the following
    example, merging a hash with the `database` key with an `oracle` string and a
    `version` key with an integer of `11` with the `app_web` hash with a `web_server`
    key with a string of `httpd` and a `version` key with a value of `12` will result
    in the `combined_app` variable containing the `database` key and value and the
    `web_server` key and value. However, it will ignore the `app_web` key version
    as a key already existed in `app_db`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Removal
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The removal operator takes a hash variable, a `–` symbol, and a hash, an array
    of keys, or a single string key. If giving a hash, the values in the hash will
    not matter as the removal is simply removing any matching keys. In the following
    example, a hash of `software_versions` with the `oracle` key and an integer of
    `11`, the `httpd` key and a value of `12`, and the `cowsay` key with a value of
    `9` can be seen. When a single key is removed to create the `no_cowsay` variable,
    the key-value pair of `cowsay` and `9` is removed. When `only_cowsay` is assigned,
    the values of `oracle` and `httpd` in the hash to be removed do not matter and
    it will simply remove the key and value. For the `only_oracle` variable, removing
    an array will make the removal operator run through each matching key and remove
    matches:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Hash data type
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The hash data type accepts an optional key type and value type; if a key type
    is specified, a value type must be specified. A minimum size and maximum size
    can be specified for how many key pairs there should be:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For example, the following class has a `tunables` parameter, which must contain
    a hash with `1` to `10` key-value pairs of strings and integers:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Mixing hashes and arrays
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the value of a hash key value or an array value can be any data type,
    nesting can be performed. Care should be taken not to overcomplicate the structure.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the `server_cmdb` hash containing a hash of `nfs_share_servers`,
    with the `prod` and `dev` keys containing arrays of strings:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To access the first `prod` array’s third value, `prdnfs02`, the following call
    could be made:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Lab
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To practice what we’ve covered, write a class that takes an array of packages
    and installs the packages with a hash-defining standard parameter for installing
    the provider and version. Remember to declare the class with variables, as per
    the previous lab. As an example, you could install the latest version of the RubyGems
    webrick, puma, and sinatra. The suggested solution can be found at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/packages_array_hash_paramters.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/packages_array_hash_paramters.pp).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Abstract data types, including Sensitive
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract data types give you the flexibility to mix the core data types for
    parameter enforcement and particular patterns, as well as provide some more advanced
    features in terms of parameter checking. There are a large number of abstract
    types, so this section will cover the most commonly used ones. Other types can
    be found at [https://github.com/puppetlabs/puppet-specifications/blob/master/language/types_values_variables.md](https://github.com/puppetlabs/puppet-specifications/blob/master/language/types_values_variables.md)
    and [https://www.puppet.com/docs/puppet/8/lang_data_abstract.html#variant-data-type](https://www.puppet.com/docs/puppet/8/lang_data_abstract.html#variant-data-type).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Prefixes
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although not Puppet terminology, the types we’ll review will be described as
    prefixes, where a type is prefixed in front of another type with no options.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Sensitive` data type is used to mark strings as sensitive, which means
    the value will be displayed in plain text in the code and the catalog, but not
    in any Puppet reports or logs. By prefixing the `Sensitive` keyword to parameters
    and assignments with brackets, the strings’ contents are made sensitive. This
    affects both string types and resources that can contain strings or can be converted
    into strings. In the following example, we are showing a string, a string in an
    array, and an array that can be assigned. The output will print `[value redacted]`
    over the section that has been marked as sensitive:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When the value must be used in code, the `unwrap` function allows us to view
    the sensitive value. This example shows how it could be unwrapped to print with
    a `notify` resource:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is purely an example and would defeat the purpose of hiding a value from
    logging and reporting; more likely, it would be passed to another resource. Resources
    such as user-recognized sensitive values for attributes such as `password` do
    not need to be unwrapped, but resources such as `exec` do not interpolate, so
    the values must be unwrapped. To avoid leaking data resources such as `exec`,
    which cannot interpolate, you can wrap it as `Sensitive` to ensure no part is
    exposed in logging. The following example shows passing the sensitive string to
    `user` and passing the sensitive string as a password to a `curl` command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If only the unwrap is performed when running Puppet with `debug`, the command
    and password would be fully visible.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194), we will cover templates,
    including how to use sensitive values. However, as of Puppet 7.0 and 6.20, you
    no longer need to unwrap sensitive values before using them in templates.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Securing data fully from end to end will be discussed in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233).
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '`Enum` and more advanced pattern data type patterns, which will be covered
    in the next section, will not work with `Sensitive` and should be avoided. Here,
    you should only use basic types such as `string`.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Optional
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Optional` data type allows `undef` to be used as an acceptable input for
    a data type, in addition to the types allowed by the data type it prefixes:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For example, to allow an `Integer` parameter or `undef` to be assigned to the
    `oracle_uid` variable, simply add the `Optional` keyword in front of the `Integer`
    type:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `notundef` type has the opposite effect but is of much more limited and
    exceptional use.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Patterns
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern types allow for combinations of types, such as regular expressions or
    specific choices of strings, to be enforced on attributes.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Enum
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Enum` data type allows you to enumerate strings, allowing multiple options
    to be used on a `class` parameter. The following code declares `Enum`, followed
    by an array of strings as options with a minimum of one string or more:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following example shows how to use this in a class called `regional` with
    a parameter of `uk_region` accepting one of the available UK regions:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Variant
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Variant` data type allows you to combine any other data types as an array.
    The following code uses the `Variant` keyword and declares the list of allowed
    types on a parameter:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For example, the following class accepts Booleans of `true` and `false` or
    the `true` or `false` strings for the `create_user_home` variable. It will also
    take a string or an array of strings for the `user_names` variable:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Pattern
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Pattern` data type is similar to `Variant` but is a way of providing a
    list of regular expressions where the parameter can match any of them. The syntax
    is as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Here, we are declaring with the `Pattern` keyword, followed by an array of
    `regexp` types. For example, the following defined type, `server_access`, takes
    a hostname that must have a string starting with `edi`, `gla`, or `abe`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Arrays and hashes
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will cover the various arrays and hashes types.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Tuple
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we discussed that the array type could have one type
    declared for all of its content. Tuple allows any number of types to be used at
    specific indexes within an array and optional minimum and maximum sizes. The minimum
    size, if smaller than the number of types assigned, makes those types optional,
    while a maximum size allows for the last type to be repeated if the maximum size
    is greater than the number of types declared. A maximum size requires a minimum
    size to be declared:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To provide an example of this, let’s consider three variables: `user_declaration`,
    `calculation`, and `file_download`. The `user_declaration` variable requires a
    string for the username, an integer for the UID, and at least one string up to
    eight characters in length, which represents the groups that a user can be assigned
    to. The `calculation` variable requires an integer, a float, and an integer. The
    `file_download` variable requires a URI and a string, and, optionally, an integer.
    Please note that the integer is optional and is not required:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Struct
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Struct` provides a similar type to `Tuple` for hashes. In the `Hash` data
    type, a single key type and value type was declared, while a struct allows for
    a particular order string keys with the option to have `optional` or `undef` and
    value types to be declared. Unlike `Tuple`, there is no minimum or maximum size:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To illustrate how the use of optional keys and values can affect variable assignments,
    let’s consider three examples: `config_file`, `application_binary`, and `application_startup`.
    The `config_file` variable requires key pairs, including the `mode` key with a
    string value of either `file` or `link`, and a `path` key with a string value.
    The `application_binary` variable is similar to `config_file`, but it allows for
    an optional `owner` key with a string value. If present, the `owner` key must
    have a string value. The `application_startup` variable requires an `owner` key
    that can either be undefined or a string. Additionally, the value for each key
    must match the expected data type:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Parent data types
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following data types allow you to group multiple data types into a single
    parameter. Using them directly can make code shorter and clearer:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '`Any`: The `Any` type matches any Puppet data type, making it useful when the
    exact data type is unknown or does not matter.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection`: The `Collection` type matches any array or hash data type, making
    it useful when an array or hash can have multiple data types.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scalar`: The `Scalar` data type matches strings, Booleans, regular expressions,
    and numerics. It is useful when a single value with any of these data types is
    required.'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Data`: The `Data` type matches scalar, undefs, and arrays containing values
    that match data, and hashes with keys matching scalars and values that match data.
    It is useful when complex data structures are required.'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Numeric`: The `Numeric` type matches float and integer data types, which is
    useful when a numerical value is required.'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lab
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing our work on the `all_grafana` class, create an `all_grafana_data_types`
    class and add to it so that it accepts a `file_options` parameter. This must have
    a name but can optionally have a mode, a user, and a group as a hash. Ensure each
    of those resources has restricted data types. Add a Grafana user and a sensitive
    parameter password that is passed to the user.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: To achieve class assignment, write a class declaration before you assign the
    class some variables. When you run `bolt` against your manifest, it will include
    your variables. The solutions are available at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Puppet, a scope is a level of code that has limited access to variables and
    default settings for resources. The three levels of scope are top scope, node
    scope, and local scope. Top scope variables reflect variables that are declared
    globally, most commonly in the `site.pp` manifest file. Node scope variables are
    assigned in node definitions, which are typically also made in `site.pp` or via
    an `site.pp` manifest file within a Puppet environment to make them globally available
    to all nodes. Alternatively, variables can be declared in a node definition in
    `site.pp` or the ENC to be made available at the node level for a particular server
    or group of servers. `site.pp` is a special manifest file in Puppet that contains
    the main configuration for a Puppet environment. A resource default is a default
    setting for a resource, which can be overridden in a more specific scope, such
    as node scope or local scope. The full use of `site.pp`, ENC, and node definitions
    will be explained in detail in [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: When accessing a variable, by default, the server will access the lowest level
    first and essentially override variables of the same name at higher levels. Other
    local scopes can be accessed by using the namespace but cannot be assigned values.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how these concepts work together in a single Puppet manifest
    file. We can define a global variable called `''global''` with a string value
    of `''world''`, and a node definition that, by default, assigns all nodes a variable
    called `''node''` with a string value of `''mynode''`. The node definition includes
    two classes, `''local''` and `''also_local''`. In the `''local''` class, we assign
    a variable called `''global''` with a string value of `''override''`, which has
    a local scope and overrides the global value. We will use two notify resources
    to demonstrate how variable scope works. The first notify resource prints `''Print
    override''`, showing that the `''global''` local variable has overridden the global
    value. The second notify resource uses the `::` syntax to reference the global
    variable, so it prints `''Print world''`. The third notify resource prints `''Print
    node''` because there are no local variables with that name. In the `''also_local''`
    class, we define a new variable called `''another_global''` with a string value
    of `''another world''`. The first `notify` resource in this class uses the directly-accessed
    variable to print `''Print another override''`. The second `notify` resource uses
    the `::` syntax to reference the global variable and prints `''Print another world''`
    because no local variable called `''global''` is declared. A `notify` resource
    is a Puppet resource type that simply logs a message to the console or system
    log. It’s commonly used for debugging or informational purposes:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Resource titles or references to resources are not limited by scope as they
    must be unique to the whole catalog. As shown in the preceding example, the `notify`
    resources that were used in the `also_local` class had their titles adjusted so
    that they contained `another`. This helps us avoid resource title clashes when
    the variables are interpolated. Otherwise, both the `local` and `also_local` classes
    would have contained `notify` resources called `Print override` and `Print world`
    and would fail to compile with duplicate resources.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: As discussed, the `also_local` class can call the `global` variable from the
    `local` class but cannot assign it to that local scope.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that Puppet variables are different from those in
    normal procedural languages as they can only be assigned once. We saw that certain
    words are reserved and cannot be used in naming variables. We also saw that Puppet
    variables can be interpolated, depending on how and where strings are placed.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: We covered various core data types and how they can be used to both restrict
    parameters and assign variables. We also looked at `undef` and Booleans, which
    need to be carefully managed when translating values to get the expected results.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at arrays and hashes and how to assign them. Although they can’t
    be changed, we learned how operators can manipulate them into new assignments.
    We also covered how arrays and hashes can be nested and mixed as hashes of arrays
    and arrays of hashes.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at abstract data types and how they apply restrictions to parameters
    more flexibly with the `Sensitive` type, which provides scoped protection for
    logs and reporting.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: After, we reviewed how Puppet variables can be declared at different scopes
    and how variables can be shared/seen in different scopes.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover facts and functions. We will look at the
    system profiling tool, Facter, the information it gathers, and how it can be customized
    to gather user-specific data on system profiles. Functions provide Ruby code plugins,
    allowing code to be run at compile time, which can perform actions such as data
    manipulation or affect the catalog run. We will cover built-in functions and functions
    from the standard `lib` module, from Puppet Forge, which can be used to manipulate
    data types into the variables we discussed in this chapter.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
