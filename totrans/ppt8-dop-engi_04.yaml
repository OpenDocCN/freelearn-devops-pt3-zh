- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables and Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will cover how Puppet handles variables and, in particular, how
    Puppet differs from most declarative languages in terms of how they are used and
    declared. We will look at the core data types that are used to define what the
    value of a variable can contain and how it can be interacted with. Then, we will
    look at how data types and variables allow the classes we discussed in [*Chapter
    3*](B18492_03.xhtml#_idTextAnchor048) to receive external data and handle default
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and hashes will be discussed in detail, including how to declare them,
    access values, and manipulate them with operations. The `Sensitive` data type
    will be shown, which you can use to secure values in logs and reports while making
    the limitations of this data type and what it does not secure clear. We will also
    cover abstract data types and show you how to allow more complex and flexible
    definitions of variables and values. The chapter will finish by covering how variable
    scopes and namespaces work with variables. We will also discuss the scope of variables
    and how variables from different scopes can be accessed and which scopes can access
    which levels of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays and hashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract data types, including `Sensitive`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need to provision a Puppet server standard architecture
    with a Windows client and a Linux client by downloading the `params.json` file
    from [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/params.json)
    and then using the following command from your `pecdm` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In various sections of this chapter, examples will be given of using the `notify`
    function, which outputs to the agent command line. These examples can just be
    run in the local development environment by putting all the code into a manifest
    file – for example, `example.pp` – and then running `puppet` `apply example.pp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, any variables that are required can be set using the environment
    variable format of `FACTER_variable_name` and running `puppet apply –e ''<example_code>''`.
    To run one of the substring examples, you can run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover how to use variables in Puppet and how this
    differs from other procedural languages. The key thing to understand about Puppet
    variables is that they are only assigned once during compilation in a given scope.
    In a traditional procedural language, it’s common to use variables throughout
    your code, where you might gather the current state as your code runs, use variables
    to keep track of it, and update it to act and make procedural decisions at various
    stages of your code. The following is an example of a simple PowerShell script
    that runs a command several times and adds the output to a single variable. It
    does so by using `select-string` to search for files containing `?` in the `.sh`
    and `.pp` files in the user’s code directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This state check is not done in Puppet since all evaluation takes place at the
    start of the catalog, based on the state the server sent to be compiled. This,
    in turn, provides the steps required to get it into a desired state. In Puppet,
    we assign variables for repetitive uses such as file paths or conditional logic
    such as `if` or `case`. In these cases, a value must be chosen to be assigned,
    depending on the initial state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are simplifying the process slightly here as there are now deferred functions
    that can run after complications. However, this still does not allow us to reassign
    variables. We will cover this in more detail in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123).
  prefs: []
  type: TYPE_NORMAL
- en: 'Puppet variables are declared with a dollar sign (`$`) followed by the variable’s
    name, an equals symbol (`=`), and the value to assign. For example, a variable
    called `example_variable` that’s assigned a value of `''this is a value''` would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that, unlike resources, variables depend on the order of evaluation and
    must be declared in code before they are called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are several variables known as built-in variables that return server information.
    However, since these are more about infrastructure and the environment, they will
    be covered in [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252) and [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272),
    where they will be relevant.
  prefs: []
  type: TYPE_NORMAL
- en: Naming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variable names are case-sensitive, and they can include upper and lowercase
    letters, numbers, and underscores but must start with an underscore (`_`) or lowercase
    letter. The exception is regex capture variables, which are variables only named
    with numbers such as `$0`, `$1`, and so on. We will cover these in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194)
    and [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272), where we will use them as
    part of conditionals and node definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Starting a variable name with an underscore will limit it to local scope use,
    as discussed in detail at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reserved variable names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several built-in variables that you cannot use in your code. These
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$``facts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$``trusted`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$``server_facts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all built-in variables generated from Facter, which cannot be used
    or reassigned. We will discuss these variables in detail in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123),
    as well as what values they provide.
  prefs: []
  type: TYPE_NORMAL
- en: As we covered in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), the `$title`
    and `$name` variables are used by classes and defined types and should not be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: The full list of reserved words can be viewed in the Puppet documentation at
    [https://www.puppet.com/docs/puppet/8/lang_reserved.html](https://www.puppet.com/docs/puppet/8/lang_reserved.html).
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Puppet variables can be evaluated and resolved into their assigned values when
    called without quotes or as part of a variable mixed with our data in double quotes.
    The style guide enforced by the lint checks will ensure single quotes are used
    when an assignment does not contain a variable and no quotes are used when an
    assignment only contains a variable. A mix of values and variables can be written
    with double quotes. When you should use a mix is stated in the style guide. This
    is checked by the linter to ensure it uses curly braces `{}`. This can be seen
    in the following example of assigning `mixed_variable` to the variable’s declaration
    when using double quotes for interpolation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we described in the previous chapter, the `notify` function can be used
    to check the values of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This section discussed how Puppet variables differ compared to other programming
    languages due to statefulness and how it can declare, access, and name variables.
  prefs: []
  type: TYPE_NORMAL
- en: Data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every value in Puppet has a data type; in the previous section, for example,
    the variables had `String` values assigned. A data type, when used as a capitalized
    unquoted string, such as `Integer`, can be used to specify what parameters in
    a class, defined type, or lambda should contain, allowing the data to be validated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Data types can also be used to compare a variable’s value, conditionally check
    values, and take different actions, depending on the result. For example, to confirm
    that a variable contains an integer, the following match expression can be used.
    Here, we are confirming that the `example_integer` variable contains an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Conditional statements and comparisons will be covered in full in [*Chapter
    7*](B18492_07.xhtml#_idTextAnchor194).
  prefs: []
  type: TYPE_NORMAL
- en: The next section will run through the most commonly used core Puppet data types.
    Unfortunately, Puppet has no equivalent to the `puppet describe` command for data
    types .so all references must be taken from the web and GitHub documentation at
    [https://www.puppet.com/docs/puppet/8/lang_data_type.html](https://www.puppet.com/docs/puppet/8/lang_data_type.html).
    If you’re using types provided by modules from the forge, which will be covered
    in detail in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212), the documentation
    should be on the reference page of the module. Various functions work with data
    types, but we will not cover this here. We will look at functions in detail in
    [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123).
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Strings are the most common data type used in Puppet and, as discussed in [*Chapter
    1*](B18492_01.xhtml#_idTextAnchor018), were originally the only type of data used
    in early Puppet. Strings are pieces of unstructured text of any length, encoded
    in UTF-8\. There are four ways to declare strings in Puppet:'
  prefs: []
  type: TYPE_NORMAL
- en: Unquoted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single quoted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double quoted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heredocs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unquoted strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unquoted strings are single words starting with a lowercase letter and containing
    only letters, digits, hyphens (`-`), and underscores (`_`) and must not be reserved
    words. Reserved words are typically keywords such as class or other language functions;
    the full list can be viewed at [https://www.puppet.com/docs/puppet/8/lang_reserved.html#lang_reserved_words](https://www.puppet.com/docs/puppet/8/lang_reserved.html#lang_reserved_words).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unquoted strings are used for resource attributes that accept a limited set
    of words, such as the Puppet service resource type, which accepts `running` or
    `stopped` for its `ensure` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Single-quoted strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Single-quoted strings can contain multiple words but, as previously discussed,
    cannot interpolate variables. However, they can contain line breaks and escape
    sequences using a backslash (`\`), an escape backslash, or a single quote (`'`).
    This allows the use of single quotes within the string itself and for a backslash
    to be used at the end of a string. Additionally, a line break can be achieved
    via the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the `sed_command` variable with the single quotes
    needed as part of the `sed` command to escape in the single-quoted string and
    then the `install_dir` variable for a Windows file path with an ending backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Double-quoted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Double-quoted strings can fully interpolate variables and more available escape
    characters. In addition to the single quote, backslash, and escape characters,
    double quotes can interpret the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`\``n`: Newline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\r`: Carriage return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\``s`: Space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\``t`: Tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\$`: Dollar sign, to prevent variable interpolation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\uXXXX`: Here, `xxxx` is a four-digit hex number for a Unicode character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\u{X}`: Here, `X` is a hex number between two and six digits between curly
    braces, `{}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\"`: Double quote'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\r\n`: Window line break'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As per single quotes, a line break can also be used within text (that is, just
    by hitting *Enter*).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'If a backslash is used in double quotes without you escaping it and without
    a valid escape character after, it will continue and treat it as normal characters
    but result in the following message in the logs: *Warning: Unrecognized escape
    sequence*. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Warning: Unrecognized escape sequence ''\T''` `at C:/Users/david/code/test.pp:1:50`'
  prefs: []
  type: TYPE_NORMAL
- en: This commonly affects Windows user paths that are used in double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of a double-quoted string making use of new lines and tabs
    (which are important to the syntax of Makefile content) is as follows. This creates
    a string to then be used in the content of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Heredocs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Puppet’s implementation of heredocs involves using a tag to indicate the start
    and end of the heredoc file’s content. The starting tag is typically composed
    of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''@(''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string, known as the end text, that may be surrounded by double quotes to
    enable interpolation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional escape switch (or switches) that begin with a forward slash to enable
    escape switches in the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional colon (`:`) followed by a syntax name check
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`'')''`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use a heredoc in Puppet, the content should be entered on the lines immediately
    following the starting tag, with the exact formatting that is desired. The end
    of the heredoc is indicated by an end tag, which should include the following
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: An optional vertical bar (`|`), which indicates how much indentation should
    be stripped from the lines of the text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional hyphen (`-`), which removes the final line break from the heredoc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same end text tag that was used in the starting tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The end text in a Puppet heredoc is a string that can consist of mixed-case
    letters, numbers, and spaces, but cannot include line breaks, slashes, colons,
    or parentheses. By default, the content of the heredoc will not interpret escape
    characters, so optional escape switches must be declared if they are needed. The
    following escape switches are available and mirror the same escape sequences for
    double-quoted strings, but do not require double quotes (since they have no special
    meaning in heredocs):'
  prefs: []
  type: TYPE_NORMAL
- en: '`n`: New line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r`: Carriage return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t`: Tab'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: Space'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$`: Dollar sign, to prevent interpolation if the end text is double-quoted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u`: Unicode characters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L`: A new line or carriage return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`\:`: All of the previously mentioned escape sequences are available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When any escape sequence is selected, you can use `\\` to escape a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: Variable interpolation is disabled by default so, as discussed, the end text
    should be surrounded in double quotes if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntax checking is available for various content, such as Puppet manifests
    via `pp` or Ruby files via `ruby`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Syntax checking will only run if variable interpolation is not turned on; if
    a type unavailable to Puppet is entered, it will be ignored. The full details
    of available syntax checkers can be found in the Puppet specification, which also
    contains details on creating custom syntax checkers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Heredoc declarations can be placed anywhere a string declaration can be, so,
    for example, a long command in an `exec` command could be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This book recommends using heredocs sparingly. For long commands in exec, as
    shown in the preceding example, this may be suitable, but particularly for file
    content, it typically clutters and confuses the code with text and is better placed
    in templates, as covered in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194), or
    as files in modules, as covered in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
    The topic of how best to store data will be discussed in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing substrings in variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To call a string in Puppet, the simplest method is to use the `$` symbol, followed
    by the variable name. However, if the variable name contains invalid characters,
    such as a space, Puppet will assume that the variable name has ended. Therefore,
    to ensure proper interpolation of variables within strings, it is safest to enclose
    the variable name in curly braces, `{}`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access a particular character or substring within a string, Puppet allows
    you to specify a range of indices using `[<start index>, <stop position>]`, which
    can include support for negative numbers to count back from the end of a string
    or change the order of characters to be returned. For example, the following code
    sets a variable named `''example_string''` to the `''``substring''` string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Various combinations can be used; for example, a single character can be called
    by taking an index from the start, such as 3, to return `s` (we start at 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract a single character from a string variable in Puppet, you can specify
    the index of the desired character starting from `0`. For example, to extract
    the third character of a string variable, you would use an index of `3` (since
    indexing starts at `0`). In Puppet, this can be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This would return the character at index `3`, which in this case would be `'s'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A negative index can go from the end and return the same `s` character with
    `-6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract a specific portion of a string variable in Puppet, you can use the
    square bracket notation to indicate the start index and the stop position of the
    substring. For example, if you have a string variable named `''example_string''`
    with a value of `''substring''`, and you want to extract a substring that starts
    at the third character and includes the next five characters, you can use the
    following syntax in Puppet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This would return the substring that starts at index `3` (which corresponds
    to the letter `'s'` in `'substring'`) and includes the next five characters, which
    in this case would be `'string'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract a substring starting from a negative index position, you can specify
    a negative value for the stop position. For example, to extract the substring
    that starts from the fourth index from the end and includes the next three characters,
    you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This would return the substring that starts at the fourth character from the
    end (which corresponds to the letter `'t'` in `'substring'`) and includes the
    next three characters, which in this case would be `'tri'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to extract a substring that starts from a negative index position
    and includes a positive number of characters, you can use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This would return the substring that starts at the fourth character from the
    end (which corresponds to the letter `'t'` in `'substring'`) and includes the
    next four characters, which in this case would be `'ring'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sort of substring work can be particularly useful when package names,
    application versions, or other consistent name strings need to be broken up into
    different variables. As a more practical example, an organization has hostnames
    that start with a location code and contain a role, their environment, and a server
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: String data type parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When setting the type of a parameter as a string, the capitalized keyword of
    `String` is used, along with optional minimum and maximum lengths of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The default for the minimum is 0 and the maximum is infinity. To use the default
    implicitly, you can use the default unquoted string keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a class called `database`, which accepts a database ID string
    of four characters, a username between six and eight characters that defaults
    to `dbuser` if it’s not provided, and a description of any length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section will cover the two types Puppet uses for numbers: integers and
    floating points. We will also look at what arithmetic operations can be performed
    on them, how numbers can convert to and from strings, and the variations on these
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both types of numbers are declared without quotation marks. Here, casing does
    not matter where letters are used. The following patterns are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`–` (positive is presumed in absence)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric digits (starting with a `0` for octal)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`–` (positive is presumed in absence)*   `0x` or `0X` (case is not important)*   A
    mix of numeric digits and upper or lowercase letters*   `–` (positive is presumed
    in absence)*   Numeric digits (a `0` is required if using a number between -1
    and 1)*   A decimal point*   Numeric digits*   An optional `e` or `E` preceded
    by digits (for scientific float)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some simple and appropriately named examples of each of the
    preceding types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that an octal or hexadecimal number cannot be expressed
    as a floating-point number and will result in an error as it is not a valid octal
    or hexadecimal number, as applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We cannot perform operations to reassign a variable but can assign new variables
    based on operations between assigned variables. The following expressions can
    be used between variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+`: Addition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: Subtraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`: Division'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: Multiplication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%`: Modulo, the remainder of dividing left by right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<<`: Left shift'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>>`: Right shift'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Left shift and right shift are less familiar and need further explanation. A
    left shift is the first variable multiplied by two to the power of the second
    variable. Taking an example of `5 << 3`, this would translate into 5 * 23, which
    would result in 40.
  prefs: []
  type: TYPE_NORMAL
- en: A right shift is the first variable divided by two to the power of the second
    variable. Taking an example of `32 >> 2,` this would translate into 32 / 22, which
    would result in 8.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For both left shift and right shift, floats will round down to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the negative symbol (`-`) can be used as a prefix to negate a
    variable and brackets can be used to manage the priority of operations, where
    **Brackets, Orders (powers/indices or roots), Division, Multiplication, Addition,
    and Subtraction** (**BODMAS**) rules apply. Shifts are essentially treated as
    multiplication and modulo division in this priority.
  prefs: []
  type: TYPE_NORMAL
- en: Any operations between an integer and a float will result in a float and an
    operation on an integer, which would result in a float being rounded down to an
    integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some examples of using these operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To further show brackets enforcing BODMAS rules, the following example will
    be equal to negative 40:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: String to numeric conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a string is used in a numeric operation, it will automatically convert,
    but this will not happen in any other context. To convert a string into a number,
    an object can be declared as an integer, float, or numeric (we will cover numeric
    objects in the *Abstract data types, including Sensitive* section). An example
    of conversion is taking a string, `1`, to an integer and a string, `1.1`, to a
    float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Numeric to string conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Numeric types automatically convert into strings when interpolated in a string;
    the automatic conversion uses base 10 notation. The `String` object declaration
    can also be used to convert, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Integer data type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When setting the type of a parameter as an integer, the capitalized `Integer`
    keyword is used, along with optional minimum and maximum values of the integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The defaults are technically negative infinity and positive infinity but as
    Puppet uses 64-bit signed integers, this is in the region of −9,223,372,036,854,775,808
    to 9,223,372,036,854,775,807.
  prefs: []
  type: TYPE_NORMAL
- en: Float data type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When setting the type of a parameter as a float, the capitalized `Float` keyword
    is used, along with optional minimum and maximum values of the integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The defaults are technically plus and negative infinity but in practical terms,
    this is the range of a double precision float of -1.7E+308 to +1.7E+308 in Ruby
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following code block, which defines `Class application::filesystem`
    for assigning a percentage of a volume group within known limits of `100` to `10000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: undef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`undef` is considered equivalent to nil in Ruby and represents the absence
    of a value assigned to a variable. By default, the `strict_variables` setting
    is set to `false`, which means variables that have not been declared have a default
    value of `undef`. In [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252), we will
    see that this can be set in the `puppet.conf` configuration file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a simple example, the following line will notify `Print` that `test1` has
    not been declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The only value an `undef` data type has is the unquoted `undef` and it is not
    used for parameter data typing by itself. This is because enforcing the absence
    of a value would have no purpose.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Abstract data types, including Sensitive* section of this chapter, we’ll
    see how `undef` values can be accepted for parameters as a part of a selection
    of feasible options.
  prefs: []
  type: TYPE_NORMAL
- en: When interpolated into a string, `undef` is converted into an empty string (`''`).
  prefs: []
  type: TYPE_NORMAL
- en: Callout
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123) and [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212),
    we will learn about functions such as `delete_undef_values` and `filter`, which
    can be used to trim the arrays and hashes of `undef` values.
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Booleans in Puppet represent `true` or `false` and in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194),
    when looking at `if`/`case` statements, you’ll see that all Puppet comparisons
    return a Boolean type. A Boolean variable should simply contain an unquoted `true`
    or `false` value. As a result, this makes the data type quite simple with no parameters
    – just the capitalized `Boolean` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following code is for an `exampleapp` class that has a parameter
    to manage users that are set to `true` by default and a couple of variables hard-coded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automatic conversion into Boolean values will occur in most cases unless an
    explicit data type has been specified. For example, in an `if` statement, a variable
    can be used as if it were a Boolean by simply writing `$variable_name`. However,
    automatic conversion can be confusing because only `undef` will result in a conversion
    to `false`. This means that the `'false'` string, an empty string (`''`), an integer
    of `0`, and a float of `0.0` will all convert into `true`.
  prefs: []
  type: TYPE_NORMAL
- en: When using a Boolean declaration, an empty string will fail to convert, as will
    `undef`, while a string of `'false'`, an integer of `0`, or a float of `0.0` will
    convert into `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is confusing, it is safer to use the `num2bool` and `str2bool` functions
    from the `puppetlabs-stdlib` module, which will be covered in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
  prefs: []
  type: TYPE_NORMAL
- en: Regexp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `regexp` type is different from the types we’ve seen so far. It represents
    a valid regular expression in Puppet, which are expressions contained between
    forward slashes based on Ruby’s regex implementation: [http://ruby-doc.org/core/Regexp.html](http://ruby-doc.org/core/Regexp.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Regex use will be covered in more detail in [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194),
    where it will be more practically applied. However, it is worth noting that, later
    in this chapter, several abstract types that combine multiple types, including
    `regexp`, will be covered.
  prefs: []
  type: TYPE_NORMAL
- en: Lab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, a combined `all_grafana` manifest was created and a
    solution was provided at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp).
    Adjust this file so that it is within a class called `all_grafana` and instead
    of using Facter, parameters are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'These parameters should include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source download**: A string variable defaulting to [https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm](https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Port**: The port for the service to listen on as an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service enabled**: By a Boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To achieve class assignment, write a class declaration that assigns the variables
    to ensure the class is included in a catalog run. When you run `bolt` against
    your manifest, it will ensure you have included your variables. Solutions are
    available at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana.pp).
  prefs: []
  type: TYPE_NORMAL
- en: Arrays and hashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will cover the two core collections of data in Puppet: arrays
    and hashes. You will learn how to create, access, and perform operations to manipulate
    the values into a new variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Assigning arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Puppet arrays are created by surrounding comma-separated lists of values with
    square brackets. An optional comma can be added after the last element, but this
    book recommends against that for styling. For example, an array called `example_array`
    containing the `first`, `second`, and `third` strings, and would be declared as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Arrays can contain any data type, as well as a mix of data types. A Puppet
    variable cannot be reassigned in terms of individual values or in terms of any
    other manipulation such as the addition or removal of values. The following code
    shows how to assign the `mixed_example_array` array with the integer of `1`, a
    Boolean value of `false` from the `example_boolean` variable, and the `example`
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Arrays can also be empty with nothing between the brackets, `[]`. They will
    not be identified as `undef` but as an empty array. It would be unlikely to declare
    an array empty directly; this normally occurs as a result of interpolated variables
    and operators causing it to become empty.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an array index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To access an array variables element, a specific element can be specified by
    index, which will return that element. For example, to take the second string
    in the second index of `example_array` and assign it to a variable, you can use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows a `notify` resource outputting the string interpolating
    the third element from `example_array` as negative numbers counting back from
    the end of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Accessing an element that does not exist will result in `undef` being returned.
    You mustn’t put any spacing between the square bracket and the variable name;
    otherwise, it will be interpreted as a variable and the square brackets will be
    separate.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a subset of an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When accessing a subset of an array, a second number is used to indicate the
    stopping point. This is different from how substrings are handled. In the case
    of arrays, a positive number represents the number of elements to return. For
    example, using a count position of `1` will return an array with a single element.
    To extract a sub-array containing only the `''second''` element from `example_array`,
    you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This will assign the `['second']` sub-array to the `$``sub_array` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a length beyond the length of the array will simply return the available
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'A negative length will count back from the end of the array. Importantly, unlike
    accessing substrings, you cannot reverse the order by going past the starting
    index; this will simply return an empty array. In the following example, the `negative_sub`
    array will return the whole array since its starting position is `0` and its finishing
    position is the first element from the end of the array. The `empty_sub_array`
    variable will be assigned an empty array since the ending position would be before
    the starting position. The `second_element_array` variable would be assigned an
    array with the second element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Nested array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A nested array can be declared by inserting an array value within an array as
    many times as needed. The value can then be accessed by using multiple sets of
    square brackets to access the desired level. As an example, if a nested array
    is created with the first element as a string, a second value as an array of three
    strings, and a third value of a string, attempting to access the first element
    as a nested element results in returning a string, `i`, since the element at index
    `0` returns a string. A second set of brackets are then used on the `first` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nest_second` variable returns the `nest_second` string since it returns
    the nested array at element `1`; then, with the second set of brackets accesses
    the second element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To interpolate nesting in an array, curly brackets must surround the variable
    name and square brackets. For example, the following `notify` resource will print
    the first element of `nested_array`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to use the subset approach within nested brackets, but this can
    create confusing and hard-to-follow accesses and is not a recommended style in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Array operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays cannot be manipulated once assigned but operators can manipulate the
    content of arrays to assign new array variables. The following operators are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<<`: Append'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: Concatenate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: Remove'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: Splat'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Append
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Append takes any type of value and adds it as a new element at the end of the
    array. This includes adding an array as a nested array. To combine two arrays,
    concatenate (`+`) must be used. To demonstrate this, let’s look at an example
    of an array with integers `1` and `2` as elements that appends `3` into a new
    array. This will produce a new array, `[1,2,''three'']`; appending an array of
    `[3,4]` to `example_array` will produce a new nested array, `[1,2,[3,4]]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Concatenate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Concatenate takes an array and essentially combines its content with another
    array. If the first value is not an array, the compiler will assume this is a
    numerical operator. For numbers, strings, Booleans, and regular expressions, it
    will essentially work the same as an append and add the value to the end. To achieve
    a nested array entry, you must supply a nested array. So, to show some examples,
    `combined_1` will become an array of `[1,2,1]`, `combined_2` will be assigned
    `[1,2,1,2]`, and `combined_3` will result in a nested array being assigned `[1,2,[1]]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If a hash must be concatenated, it will be converted into an array unless it
    is turned into an array with a single hash element. So, in the following code,
    the converted variable would be assigned a nested array with elements of `test`
    and `value`, giving it an array of `[1,2,[test,''value'']`, while the `nested_hash`
    variable would add a nested hash that assigns `[1,2,{test => ''``value''}]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Remove
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Remove assigns an array after removing all matching elements from a source.
    The first variable must be an array; otherwise, it will be assumed to be a numeric
    operator. For the second variable, if it’s a number, string, Boolean, or regular
    expression, it will search each element of the first variable array and remove
    it if there is a match. For example, removing the `one` string from `another_example_array`
    will match the first element and the third element and remove them, but not the
    first element of the nested array, assigning `[''two'',''three'',''four'',''three'',[''one'',''three'',''four'']`
    to the `remove_string` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have an array as a second variable, it will iterate through each element
    in that array, removing them as if they had been presented directly, as in our
    previous example. In this example, it will remove `one` as per the previous example
    and then perform the searches for matching strings of `three` and `four`, removing
    the fourth, fifth, and sixth elements while assigning `[''two'',[''one'',''three'',''four'']]`
    to the `remove_array` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When a nested array is used as the second variable, it will match any elements
    with the same array and remove them. So, in this example, the `remove_nested_array`
    variable will be assigned `[''one'',''two'',''one'',''three'',''four'',''three'']`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As with concatenation, hashes must be placed in an array; otherwise, they will
    remove any matching element of a translated nested array.
  prefs: []
  type: TYPE_NORMAL
- en: Splat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Splats are different from the other operators as they are used to make an array
    provide comma-separated lists as an argument in a function call. This is true
    for both case and selector statements. Using array splats will be covered in detail
    in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123) and [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194).
  prefs: []
  type: TYPE_NORMAL
- en: Array data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When setting the data type of a parameter to an array, the capitalized `Array`
    keyword must be used with a data type for elements of the array, the minimum size
    of the array, and the maximum size of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The defaults for data types are data, which will be covered in the *Abstract
    data types, including Sensitive* section of this chapter, but this means that
    numbers (both integers and floats), strings, Booleans, and regular expressions,
    as well as arrays and hashes of these types apply. If you select a more specific
    data type, such as `String`, it will expect every element in the array to contain
    a string. In the *Abstract data types, including Sensitive* section, other mixed
    types will be covered that provide more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum size is 0, while the maximum size is infinite.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the `database` class could accept a variable of `db_uids`, where
    at least one element is expected in the array but could contain up to six elements.
    The `user_names` variable can be an empty array or up to five elements but most
    only contain strings. Finally, the `extra_flags` variable is an array with default
    values, so it can be an empty array up to an infinite size with the contents matched
    against data types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Assigning hashes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hashes are written as comma-spaced key-value pairs separated by `=>` and the
    list is surrounded by curl braces, `{ }`. A trailing comma can be added after
    the last pair, but this is not a recommended style by this book. For example,
    the following hash pairs could be declined to assign the `make` key with the `skoda`
    string, the `model` key with the `rapid` string, and the `year` key with the `2014`
    integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For style purposes, a new line is often taken with each key to ensure the start
    of the keys line up and the arrows line up. Taking a final new line for the closing
    curly brace and lining it up with the opening curly brace is what this book recommends
    when writing arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Hash keys and values can be any type, but it rarely makes sense for the keys
    to be anything but strings. Just like arrays, hashes are variables in Puppet and
    can only be assigned once and not manipulated unless a new hash is assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Puppet can only serialize string hash keys into a catalog. Therefore, you cannot
    assign a hash with non-string keys to a resource attribute or class parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing hash values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly to arrays, hash values can be accessed using square brackets with
    the key value to access. As an example, the following would print the `rapid`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Nested hashes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with arrays, by declaring a hash within a hash, a nested hash can be created,
    which can be accessed with chained keys. The following example shows a variable
    package list containing the `packages` and `services` keys. The `packages` key
    contains the `httpd` key, with a string value of `latest`, and the `cowsay` key,
    with a float value of `4.0`. The `services` key contains the `httpd` key with
    a string value of `running` and the `nginx` key with a string value of `stopped`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To print both of the nested `httpd` keys, a `notify` resource can be declared,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Hash operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two operators for hashes – merging (`+`), which can assign a new hash
    by adding key pairs to an existing hash, and removal (`-`), which can assign a
    new hash by removing key pairs from an existing hash.
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Merging is performed by taking a hash variable, a `+` symbol, and a hash or
    an array with an even number of values. Note that this is done while looking to
    add a new key; if a key already exists, it will not be added. In the following
    example, merging a hash with the `database` key with an `oracle` string and a
    `version` key with an integer of `11` with the `app_web` hash with a `web_server`
    key with a string of `httpd` and a `version` key with a value of `12` will result
    in the `combined_app` variable containing the `database` key and value and the
    `web_server` key and value. However, it will ignore the `app_web` key version
    as a key already existed in `app_db`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Removal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The removal operator takes a hash variable, a `–` symbol, and a hash, an array
    of keys, or a single string key. If giving a hash, the values in the hash will
    not matter as the removal is simply removing any matching keys. In the following
    example, a hash of `software_versions` with the `oracle` key and an integer of
    `11`, the `httpd` key and a value of `12`, and the `cowsay` key with a value of
    `9` can be seen. When a single key is removed to create the `no_cowsay` variable,
    the key-value pair of `cowsay` and `9` is removed. When `only_cowsay` is assigned,
    the values of `oracle` and `httpd` in the hash to be removed do not matter and
    it will simply remove the key and value. For the `only_oracle` variable, removing
    an array will make the removal operator run through each matching key and remove
    matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Hash data type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The hash data type accepts an optional key type and value type; if a key type
    is specified, a value type must be specified. A minimum size and maximum size
    can be specified for how many key pairs there should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the following class has a `tunables` parameter, which must contain
    a hash with `1` to `10` key-value pairs of strings and integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Mixing hashes and arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the value of a hash key value or an array value can be any data type,
    nesting can be performed. Care should be taken not to overcomplicate the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows the `server_cmdb` hash containing a hash of `nfs_share_servers`,
    with the `prod` and `dev` keys containing arrays of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the first `prod` array’s third value, `prdnfs02`, the following call
    could be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Lab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To practice what we’ve covered, write a class that takes an array of packages
    and installs the packages with a hash-defining standard parameter for installing
    the provider and version. Remember to declare the class with variables, as per
    the previous lab. As an example, you could install the latest version of the RubyGems
    webrick, puma, and sinatra. The suggested solution can be found at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/packages_array_hash_paramters.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/packages_array_hash_paramters.pp).
  prefs: []
  type: TYPE_NORMAL
- en: Abstract data types, including Sensitive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstract data types give you the flexibility to mix the core data types for
    parameter enforcement and particular patterns, as well as provide some more advanced
    features in terms of parameter checking. There are a large number of abstract
    types, so this section will cover the most commonly used ones. Other types can
    be found at [https://github.com/puppetlabs/puppet-specifications/blob/master/language/types_values_variables.md](https://github.com/puppetlabs/puppet-specifications/blob/master/language/types_values_variables.md)
    and [https://www.puppet.com/docs/puppet/8/lang_data_abstract.html#variant-data-type](https://www.puppet.com/docs/puppet/8/lang_data_abstract.html#variant-data-type).
  prefs: []
  type: TYPE_NORMAL
- en: Prefixes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although not Puppet terminology, the types we’ll review will be described as
    prefixes, where a type is prefixed in front of another type with no options.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Sensitive` data type is used to mark strings as sensitive, which means
    the value will be displayed in plain text in the code and the catalog, but not
    in any Puppet reports or logs. By prefixing the `Sensitive` keyword to parameters
    and assignments with brackets, the strings’ contents are made sensitive. This
    affects both string types and resources that can contain strings or can be converted
    into strings. In the following example, we are showing a string, a string in an
    array, and an array that can be assigned. The output will print `[value redacted]`
    over the section that has been marked as sensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'When the value must be used in code, the `unwrap` function allows us to view
    the sensitive value. This example shows how it could be unwrapped to print with
    a `notify` resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This is purely an example and would defeat the purpose of hiding a value from
    logging and reporting; more likely, it would be passed to another resource. Resources
    such as user-recognized sensitive values for attributes such as `password` do
    not need to be unwrapped, but resources such as `exec` do not interpolate, so
    the values must be unwrapped. To avoid leaking data resources such as `exec`,
    which cannot interpolate, you can wrap it as `Sensitive` to ensure no part is
    exposed in logging. The following example shows passing the sensitive string to
    `user` and passing the sensitive string as a password to a `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If only the unwrap is performed when running Puppet with `debug`, the command
    and password would be fully visible.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B18492_07.xhtml#_idTextAnchor194), we will cover templates,
    including how to use sensitive values. However, as of Puppet 7.0 and 6.20, you
    no longer need to unwrap sensitive values before using them in templates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Securing data fully from end to end will be discussed in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233).
  prefs: []
  type: TYPE_NORMAL
- en: '`Enum` and more advanced pattern data type patterns, which will be covered
    in the next section, will not work with `Sensitive` and should be avoided. Here,
    you should only use basic types such as `string`.'
  prefs: []
  type: TYPE_NORMAL
- en: Optional
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Optional` data type allows `undef` to be used as an acceptable input for
    a data type, in addition to the types allowed by the data type it prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to allow an `Integer` parameter or `undef` to be assigned to the
    `oracle_uid` variable, simply add the `Optional` keyword in front of the `Integer`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The `notundef` type has the opposite effect but is of much more limited and
    exceptional use.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pattern types allow for combinations of types, such as regular expressions or
    specific choices of strings, to be enforced on attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Enum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Enum` data type allows you to enumerate strings, allowing multiple options
    to be used on a `class` parameter. The following code declares `Enum`, followed
    by an array of strings as options with a minimum of one string or more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following example shows how to use this in a class called `regional` with
    a parameter of `uk_region` accepting one of the available UK regions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Variant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Variant` data type allows you to combine any other data types as an array.
    The following code uses the `Variant` keyword and declares the list of allowed
    types on a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the following class accepts Booleans of `true` and `false` or
    the `true` or `false` strings for the `create_user_home` variable. It will also
    take a string or an array of strings for the `user_names` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Pattern` data type is similar to `Variant` but is a way of providing a
    list of regular expressions where the parameter can match any of them. The syntax
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are declaring with the `Pattern` keyword, followed by an array of
    `regexp` types. For example, the following defined type, `server_access`, takes
    a hostname that must have a string starting with `edi`, `gla`, or `abe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Arrays and hashes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will cover the various arrays and hashes types.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the previous section, we discussed that the array type could have one type
    declared for all of its content. Tuple allows any number of types to be used at
    specific indexes within an array and optional minimum and maximum sizes. The minimum
    size, if smaller than the number of types assigned, makes those types optional,
    while a maximum size allows for the last type to be repeated if the maximum size
    is greater than the number of types declared. A maximum size requires a minimum
    size to be declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide an example of this, let’s consider three variables: `user_declaration`,
    `calculation`, and `file_download`. The `user_declaration` variable requires a
    string for the username, an integer for the UID, and at least one string up to
    eight characters in length, which represents the groups that a user can be assigned
    to. The `calculation` variable requires an integer, a float, and an integer. The
    `file_download` variable requires a URI and a string, and, optionally, an integer.
    Please note that the integer is optional and is not required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Struct
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Struct` provides a similar type to `Tuple` for hashes. In the `Hash` data
    type, a single key type and value type was declared, while a struct allows for
    a particular order string keys with the option to have `optional` or `undef` and
    value types to be declared. Unlike `Tuple`, there is no minimum or maximum size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate how the use of optional keys and values can affect variable assignments,
    let’s consider three examples: `config_file`, `application_binary`, and `application_startup`.
    The `config_file` variable requires key pairs, including the `mode` key with a
    string value of either `file` or `link`, and a `path` key with a string value.
    The `application_binary` variable is similar to `config_file`, but it allows for
    an optional `owner` key with a string value. If present, the `owner` key must
    have a string value. The `application_startup` variable requires an `owner` key
    that can either be undefined or a string. Additionally, the value for each key
    must match the expected data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Parent data types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following data types allow you to group multiple data types into a single
    parameter. Using them directly can make code shorter and clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Any`: The `Any` type matches any Puppet data type, making it useful when the
    exact data type is unknown or does not matter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collection`: The `Collection` type matches any array or hash data type, making
    it useful when an array or hash can have multiple data types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Scalar`: The `Scalar` data type matches strings, Booleans, regular expressions,
    and numerics. It is useful when a single value with any of these data types is
    required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Data`: The `Data` type matches scalar, undefs, and arrays containing values
    that match data, and hashes with keys matching scalars and values that match data.
    It is useful when complex data structures are required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Numeric`: The `Numeric` type matches float and integer data types, which is
    useful when a numerical value is required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing our work on the `all_grafana` class, create an `all_grafana_data_types`
    class and add to it so that it accepts a `file_options` parameter. This must have
    a name but can optionally have a mode, a user, and a group as a hash. Ensure each
    of those resources has restricted data types. Add a Grafana user and a sensitive
    parameter password that is passed to the user.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve class assignment, write a class declaration before you assign the
    class some variables. When you run `bolt` against your manifest, it will include
    your variables. The solutions are available at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp).
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Puppet, a scope is a level of code that has limited access to variables and
    default settings for resources. The three levels of scope are top scope, node
    scope, and local scope. Top scope variables reflect variables that are declared
    globally, most commonly in the `site.pp` manifest file. Node scope variables are
    assigned in node definitions, which are typically also made in `site.pp` or via
    an `site.pp` manifest file within a Puppet environment to make them globally available
    to all nodes. Alternatively, variables can be declared in a node definition in
    `site.pp` or the ENC to be made available at the node level for a particular server
    or group of servers. `site.pp` is a special manifest file in Puppet that contains
    the main configuration for a Puppet environment. A resource default is a default
    setting for a resource, which can be overridden in a more specific scope, such
    as node scope or local scope. The full use of `site.pp`, ENC, and node definitions
    will be explained in detail in [*Chapter 10*](B18492_10.xhtml#_idTextAnchor252).
  prefs: []
  type: TYPE_NORMAL
- en: When accessing a variable, by default, the server will access the lowest level
    first and essentially override variables of the same name at higher levels. Other
    local scopes can be accessed by using the namespace but cannot be assigned values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how these concepts work together in a single Puppet manifest
    file. We can define a global variable called `''global''` with a string value
    of `''world''`, and a node definition that, by default, assigns all nodes a variable
    called `''node''` with a string value of `''mynode''`. The node definition includes
    two classes, `''local''` and `''also_local''`. In the `''local''` class, we assign
    a variable called `''global''` with a string value of `''override''`, which has
    a local scope and overrides the global value. We will use two notify resources
    to demonstrate how variable scope works. The first notify resource prints `''Print
    override''`, showing that the `''global''` local variable has overridden the global
    value. The second notify resource uses the `::` syntax to reference the global
    variable, so it prints `''Print world''`. The third notify resource prints `''Print
    node''` because there are no local variables with that name. In the `''also_local''`
    class, we define a new variable called `''another_global''` with a string value
    of `''another world''`. The first `notify` resource in this class uses the directly-accessed
    variable to print `''Print another override''`. The second `notify` resource uses
    the `::` syntax to reference the global variable and prints `''Print another world''`
    because no local variable called `''global''` is declared. A `notify` resource
    is a Puppet resource type that simply logs a message to the console or system
    log. It’s commonly used for debugging or informational purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Resource titles or references to resources are not limited by scope as they
    must be unique to the whole catalog. As shown in the preceding example, the `notify`
    resources that were used in the `also_local` class had their titles adjusted so
    that they contained `another`. This helps us avoid resource title clashes when
    the variables are interpolated. Otherwise, both the `local` and `also_local` classes
    would have contained `notify` resources called `Print override` and `Print world`
    and would fail to compile with duplicate resources.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed, the `also_local` class can call the `global` variable from the
    `local` class but cannot assign it to that local scope.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that Puppet variables are different from those in
    normal procedural languages as they can only be assigned once. We saw that certain
    words are reserved and cannot be used in naming variables. We also saw that Puppet
    variables can be interpolated, depending on how and where strings are placed.
  prefs: []
  type: TYPE_NORMAL
- en: We covered various core data types and how they can be used to both restrict
    parameters and assign variables. We also looked at `undef` and Booleans, which
    need to be carefully managed when translating values to get the expected results.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we looked at arrays and hashes and how to assign them. Although they can’t
    be changed, we learned how operators can manipulate them into new assignments.
    We also covered how arrays and hashes can be nested and mixed as hashes of arrays
    and arrays of hashes.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we looked at abstract data types and how they apply restrictions to parameters
    more flexibly with the `Sensitive` type, which provides scoped protection for
    logs and reporting.
  prefs: []
  type: TYPE_NORMAL
- en: After, we reviewed how Puppet variables can be declared at different scopes
    and how variables can be shared/seen in different scopes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover facts and functions. We will look at the
    system profiling tool, Facter, the information it gathers, and how it can be customized
    to gather user-specific data on system profiles. Functions provide Ruby code plugins,
    allowing code to be run at compile time, which can perform actions such as data
    manipulation or affect the catalog run. We will cover built-in functions and functions
    from the standard `lib` module, from Puppet Forge, which can be used to manipulate
    data types into the variables we discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
