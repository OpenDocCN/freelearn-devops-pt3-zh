- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Troubleshooting and the Road Ahead with GitLab
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitLab 故障排除与未来展望
- en: By now, we have covered the end-to-end use of GitLab CI/CD for planning, building,
    testing, and shipping software. You should hopefully be familiar with the vocabulary
    of GitLab CI/CD pipelines and Runner infrastructure, and you should also have
    the confidence to develop and deploy basic applications with GitLab.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了 GitLab CI/CD 从规划、构建、测试到交付软件的端到端使用过程。你应该对 GitLab CI/CD 流水线和 Runner
    基础设施的术语有所了解，并且有信心使用 GitLab 开发和部署基本应用程序。
- en: CI/CD occupies a constantly shifting space in the software industry. The best
    practices and tools of the trade today may very well be obsolete five years from
    now, if not earlier. We have made a conscious effort in this book to maintain
    a balanced focus between concepts and tooling. The goal is to preserve relevance
    by emphasizing CI/CD and DevOps fundamentals, while still offering you a chance
    to practice and follow along, even if the syntax and some of the tools change
    over the next several years.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 在软件行业中占据着一个不断变化的空间。今天的最佳实践和工具在五年后可能已经过时，甚至更早。本书中我们有意识地努力保持在概念和工具之间的平衡。我们的目标是通过强调
    CI/CD 和 DevOps 基础知识来保持内容的相关性，同时即便语法和一些工具在未来几年有所变化，依然为你提供实践和跟随的机会。
- en: The purpose of this final chapter is to synthesize what we’ve learned and guide
    you toward the next steps in your DevOps journey. We will first discuss some common
    troubleshooting scenarios and “gotchas” that you might encounter when working
    with CI/CD. Next, we’ll discuss using GitLab CI/CD in an operations capacity,
    applying software development workflows and version control to your infrastructure.
    Finally, we will discuss how the industry is likely to change going forward, and
    summarize key takeaways from this book.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是综合我们所学的内容，并引导你迈向 DevOps 旅程的下一步。我们将首先讨论一些常见的故障排除场景和可能遇到的“陷阱”，这些问题通常出现在使用
    CI/CD 时。接下来，我们将讨论如何在运维领域使用 GitLab CI/CD，将软件开发工作流和版本控制应用于基础设施。最后，我们将讨论行业未来的变化趋势，并总结本书的关键要点。
- en: 'Here is how we’ll cover the topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将按照以下方式覆盖这些主题：
- en: Troubleshooting and best practices for common pipeline problems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见流水线问题的故障排除与最佳实践
- en: Managing your operational infrastructure using GitOps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitOps 管理你的运维基础设施
- en: Future industry trends
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来行业趋势
- en: Conclusion and next steps
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结论与下一步
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in previous chapters, an account on a GitLab instance (SaaS or self-managed)
    is recommended. Some of the content in this chapter is more conceptual than example-based,
    but access to **Infrastructure-as-Code** (**IaC**) tooling such as Terraform and
    Ansible is recommended if you wish to practice the concepts discussed in the *Managing
    your operational infrastructure using GitOps* section. In that case, an account
    in a cloud service provider (such as AWS or Microsoft Azure) would be recommended
    for infrastructure provisioning and configuration management using your chosen
    IaC tool.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，建议在 GitLab 实例（SaaS 或自托管）上拥有一个帐户。本章中的一些内容更偏向于概念性讨论，而非基于实例的内容，但如果你希望实践
    *使用 GitOps 管理运维基础设施* 部分讨论的概念，建议使用 **基础设施即代码**（**IaC**）工具，如 Terraform 和 Ansible。如果是这种情况，建议在云服务提供商（如
    AWS 或 Microsoft Azure）中注册一个账户，以便使用你选择的 IaC 工具进行基础设施的配置与管理。
- en: We will now turn to identifying and troubleshooting common issues when working
    with GitLab CI/CD.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将识别并排除在使用 GitLab CI/CD 时常见的问题。
- en: Troubleshooting and best practices for common pipeline problems
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见流水线问题的故障排除与最佳实践
- en: Problems encountered in GitLab CI/CD pipelines tend to fall into two broad categories.
    The first category is errors or unexpected behavior caused by the syntax and logic
    in `.gitlab-ci.yml`, the primary CI/CD configuration file. The second category
    involves limitations or misconfigurations in the runner infrastructure used to
    run CI/CD jobs. We will address each of these categories in turn.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab CI/CD 流水线中遇到的问题大致可以分为两类。第一类是由 `.gitlab-ci.yml` 文件中的语法和逻辑引起的错误或意外行为，这是主要的
    CI/CD 配置文件。第二类涉及用于运行 CI/CD 作业的 Runner 基础设施中的限制或配置错误。我们将依次解决这两类问题。
- en: Troubleshooting CI/CD syntax and logic
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排查 CI/CD 语法和逻辑问题
- en: When errors in GitLab CI/CD can be narrowed down to the content of `.gitlab-ci.yml`,
    the first step in troubleshooting is to identify whether the issue is faulty or
    unsupported syntax, or misconfiguration (or misunderstanding) of an otherwise
    valid YAML file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当 GitLab CI/CD 的错误可以归结为 `.gitlab-ci.yml` 文件内容时，故障排除的第一步是确定问题是由于语法错误或不支持的语法，还是有效
    YAML 文件的配置错误（或误解）。
- en: Syntax errors in .gitlab-ci.yml
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .gitlab-ci.yml 中的语法错误
- en: 'One of the easiest cases to troubleshoot (and therefore a good place to check
    for problems first) is syntax or formatting errors in `.gitlab-ci.yml`. A typical
    example is errors caused by omitting required keywords. GitLab CI/CD at minimum
    requires at least one stage (defined using the `stages` keyword), each job must
    be assigned to a stage, and then each job must do something (generally defined
    using the `script` or `trigger` keywords). The example that follows shows a very
    basic configuration that defines two stages and two jobs. However, the `compile_assets`
    job lacks a stage assignment. And the `build` stage, therefore, does not have
    at least one job assigned to it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易排查的情况之一（因此也是首先检查问题的好地方）是 `.gitlab-ci.yml` 中的语法或格式错误。一个典型的例子是由于遗漏必需的关键字而导致的错误。GitLab
    CI/CD 至少要求至少有一个阶段（使用 `stages` 关键字定义），每个作业必须分配到一个阶段，然后每个作业必须执行某些操作（通常使用 `script`
    或 `trigger` 关键字定义）。以下示例展示了一个非常基础的配置，定义了两个阶段和两个作业。然而，`compile_assets` 作业缺少阶段分配。因此，`build`
    阶段没有至少一个作业分配给它：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Figure 12**.1* shows the pipeline error that we see if we navigate to **CI/CD**
    | **Pipelines**:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12**.1* 显示了我们如果导航到 **CI/CD** | **Pipelines** 时看到的管道错误：'
- en: '![Figure 12.1 – Configuration error message shown on the pipelines page](img/B18073_12_1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 显示在管道页面上的配置错误信息](img/B18073_12_1.jpg)'
- en: Figure 12.1 – Configuration error message shown on the pipelines page
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 显示在管道页面上的配置错误信息
- en: Notice that GitLab does not even attempt to run the pipeline (that is, assign
    jobs to runners) when there is a YAML syntax error. We see the error mentions
    that the stage for the `compile_assets` job does not exist.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当出现 YAML 语法错误时，GitLab 甚至不会尝试运行管道（即，不会将作业分配给执行者）。我们看到错误信息提到 `compile_assets`
    作业的阶段不存在。
- en: Default Stage Assignments for Jobs
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作业的默认阶段分配
- en: The error shown in *Figure 12**.1* is actually a bit nuanced. Technically, if
    a CI/CD job is not explicitly assigned to a stage in the config, GitLab will automatically
    assign it to the `test` stage. However, we did not define a `test` stage in this
    example. Therefore, GitLab is reporting that the “chosen” stage (to which GitLab
    would otherwise assign the `compile_assets` job) does not exist, as we only defined
    `build` and `deploy` stages.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12**.1* 中显示的错误实际上有些微妙。严格来说，如果 CI/CD 作业没有在配置中显式分配到某个阶段，GitLab 会自动将其分配到 `test`
    阶段。然而，在这个示例中，我们没有定义 `test` 阶段。因此，GitLab 报告“选择的”阶段（即 GitLab 本应将 `compile_assets`
    作业分配到的阶段）不存在，因为我们只定义了 `build` 和 `deploy` 阶段。'
- en: 'GitLab will also produce an error if the configuration does not follow the
    correct YAML formatting. Let’s attempt to fix the previous error by adding the
    `compile_assets` job to the `build` stage:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置不符合正确的 YAML 格式，GitLab 也会产生错误。我们尝试通过将 `compile_assets` 作业添加到 `build` 阶段来修复之前的错误：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we look at the pipeline graph again, we see another error, more generic
    this time, saying that the configuration does not have valid YAML syntax (see
    *Figure 12**.2*). Despite the vagueness of the error, GitLab does include a link
    to a CI linter that can help identify where the problem might be:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次查看管道图时，我们看到另一个错误，这次是更通用的错误，指出配置没有有效的 YAML 语法（见 *图 12**.2*）。尽管错误信息比较模糊，但
    GitLab 确实包含了一个 CI 语法检查工具的链接，可以帮助找出问题所在：
- en: '![Figure 12.2 – Generic syntax error message for CI/CD pipeline](img/B18073_12_2.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – CI/CD 管道的通用语法错误信息](img/B18073_12_2.jpg)'
- en: Figure 12.2 – Generic syntax error message for CI/CD pipeline
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – CI/CD 管道的通用语法错误信息
- en: Following the link takes us to a tool called `.gitlab-ci.yml` file. In this
    case, *Figure 12**.3* shows an error description referencing an unknown mapping
    value. Ultimately, the issue lies in the indentation requirements for YAML. The
    `stage` keyword must be indented at least two spaces so that it is a valid element
    in the `compile_assets` job definition.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随链接会带我们到一个叫做 `.gitlab-ci.yml` 文件的工具。在这种情况下，*图 12**.3* 显示了一个错误描述，提到一个未知的映射值。最终，问题出在
    YAML 的缩进要求上。`stage` 关键字必须至少缩进两个空格，才能成为 `compile_assets` 作业定义中的有效元素。
- en: '![Figure 12.3 – Pipeline Editor showing an invalid CI/CD configuration](img/B18073_12_3.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 显示无效 CI/CD 配置的 Pipeline 编辑器](img/B18073_12_3.jpg)'
- en: Figure 12.3 – Pipeline Editor showing an invalid CI/CD configuration
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 显示无效 CI/CD 配置的 Pipeline 编辑器
- en: 'After proper indentation, *Figure 12**.4* now shows the Pipeline Editor describing
    valid CI/CD syntax. GitLab will now create a functioning pipeline from this configuration:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确缩进后，*图 12.4* 现在显示了描述有效 CI/CD 语法的 Pipeline 编辑器。GitLab 现在将根据此配置创建一个可运行的管道：
- en: '![Figure 12.4 – Pipeline Editor showing a valid CI/CD configuration](img/B18073_12_4.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 显示有效 CI/CD 配置的 Pipeline 编辑器](img/B18073_12_4.jpg)'
- en: Figure 12.4 – Pipeline Editor showing a valid CI/CD configuration
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 显示有效 CI/CD 配置的 Pipeline 编辑器
- en: Thus, a primary takeaway for CI/CD syntax issues is to take advantage of the
    Pipeline Editor so that you can check for logical and stylistic errors in your
    CI/CD configuration in real time. The editor is valuable for identifying typos,
    omitted required keywords, and YAML formatting issues.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于 CI/CD 语法问题的主要建议是利用 Pipeline 编辑器，这样您可以实时检查 CI/CD 配置中的逻辑和风格错误。编辑器对于识别拼写错误、遗漏的必需关键字和
    YAML 格式问题非常有价值。
- en: CI/CD configuration logic and job order
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CI/CD 配置逻辑和作业顺序
- en: Another key area of CI/CD troubleshooting is understanding the logic of your
    job definitions and order. As your pipelines get advanced, your `.gitlab-ci.yml`
    file might start to be filled with the `rules` keyword governing how jobs run,
    and your primary configuration might call other configurations as templates or
    downstream pipelines.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 排错的另一个关键领域是理解作业定义和顺序的逻辑。随着管道的复杂化，您的 `.gitlab-ci.yml` 文件可能会开始充满 `rules`
    关键字，用于管理作业的执行方式，且主配置可能会调用其他配置作为模板或下游管道。
- en: 'Consider the following CI/CD configuration:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下 CI/CD 配置：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we have a mix of logical keywords and job ordering in the configuration.
    The `test_app` job uses the `rules` keyword so that it never runs on the `main`
    branch; otherwise, it runs on all other branches. Meanwhile, the `deploy_app`
    job uses the `only` keyword to specify it only runs on the `main` branch (and
    no other branches). Finally, the `deploy_app` job needs the `build_app` job to
    pass before it runs on the `main` branch, and the `static_tests` job runs independently
    on feature branches without waiting for any other jobs (such as `build_app`).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的配置中混合了逻辑关键字和作业顺序。`test_app` 作业使用 `rules` 关键字，以确保它在 `main` 分支上从不执行；否则，它会在所有其他分支上运行。与此同时，`deploy_app`
    作业使用 `only` 关键字，指定它只在 `main` 分支上执行（而不是其他分支）。最后，`deploy_app` 作业需要 `build_app` 作业先通过，才会在
    `main` 分支上运行，而 `static_tests` 作业则在功能分支上独立运行，无需等待其他作业（如 `build_app`）。
- en: 'As your pipelines grow, the mix of logic and different CI/CD variables can
    be difficult to parse. There are some features in the GitLab UI that can help
    you keep your job logic and order straight. The **Job dependencies** (see *Figure
    12**.5*) and **Needs** tabs in **CI/CD** | **Pipelines** | **Pipeline ID** allow
    you to show which jobs are dependent on other jobs:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 随着管道的增长，逻辑和不同 CI/CD 变量的混合可能会变得难以解析。在 GitLab 用户界面中有一些功能可以帮助您理清作业的逻辑和顺序。**作业依赖**（见
    *图 12.5*）和 **Needs** 标签在 **CI/CD** | **Pipelines** | **Pipeline ID** 中，允许您显示哪些作业依赖于其他作业：
- en: '![Figure 12.5 – Pipeline Editor showing a valid CI/CD configuration](img/B18073_12_5.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 显示有效 CI/CD 配置的 Pipeline 编辑器](img/B18073_12_5.jpg)'
- en: Figure 12.5 – Pipeline Editor showing a valid CI/CD configuration
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 显示有效 CI/CD 配置的 Pipeline 编辑器
- en: 'The Pipeline Editor also has a `main`) branch:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Pipeline 编辑器还具有 `main` 分支：
- en: '![Figure 12.6 – Pipeline validation in Pipeline Editor](img/B18073_12_6.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – 在 Pipeline 编辑器中进行管道验证](img/B18073_12_6.jpg)'
- en: Figure 12.6 – Pipeline validation in Pipeline Editor
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – 在 Pipeline 编辑器中进行管道验证
- en: We heavily encourage you to make use of these features to organize and visualize
    your pipelines during development and deployment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您在开发和部署过程中使用这些功能，以组织和可视化您的管道。
- en: Troubleshooting pipeline operation and runner assignment
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排错管道操作和 Runner 分配
- en: Aside from syntax and logic errors, it is also important to take note of the
    runners used for CI/CD execution, and ensure your pipeline configurations can
    be supported by your runner infrastructure. Examples of potential problems that
    can arise include mismanagement of runner tags and lack of or misconfigured container
    support.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了语法和逻辑错误，注意用于 CI/CD 执行的 Runner 也是很重要的，确保您的管道配置能够得到 Runner 基础设施的支持。可能出现的潜在问题包括
    Runner 标签管理不当以及缺少或配置错误的容器支持。
- en: Properly managing runner tags
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确管理运行器标签
- en: The `tags` CI/CD keyword (not to be confused with tagged Git commits) tells
    GitLab to only assign jobs to runners that include the same tags. There are a
    couple of considerations needed to ensure that CI/CD job tags are properly understood
    and used.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags` CI/CD 关键字（不要与已标记的 Git 提交混淆）告诉 GitLab 只将任务分配给包含相同标签的运行器。为了确保 CI/CD 任务标签被正确理解和使用，需考虑以下几个方面。'
- en: 'When multiple tags are specified in a CI/CD job, that means GitLab will only
    assign a job to a runner that features all of those tags. For example, the following
    job will only be assigned to a runner that has the `ubuntu` tag, the `python3`
    tag, and the `amd64` tag:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 CI/CD 任务中指定多个标签时，这意味着 GitLab 只会将任务分配给同时拥有所有这些标签的运行器。例如，以下任务将仅分配给拥有 `ubuntu`
    标签、`python3` 标签和 `amd64` 标签的运行器：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: On the other hand, the runner picking up the job can also have other descriptive
    tags associated with it, as long as those include at minimum the `ubuntu`, `python3`,
    and `amd64` tags. Check the runner’s assigned tags under **Settings** | **CI/CD**
    | **Runners** if the job is not being picked up by the expected runner. Remember
    that different runners may be configured in different parts of GitLab – that is,
    at the project, group, or instance level.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，接收任务的运行器也可以具有其他描述性标签，只要这些标签至少包括 `ubuntu`、`python3` 和 `amd64` 标签。如果任务没有被预期的运行器接收，请检查运行器的分配标签，在
    **设置** | **CI/CD** | **运行器** 中查看。如果不同的运行器配置在 GitLab 的不同部分——即项目、组或实例级别，记住这一点。
- en: Managing containerized CI/CD pipelines
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理容器化的 CI/CD 流水线
- en: 'Container-based environments such as Docker and Kubernetes are ever more frequently
    used by software teams for development, testing, and deployment. The `image` keyword
    is a critical keyword in a CI/CD job for specifying the type of Docker container
    in which a job must run. However, much is dependent on the proper execution of
    container-based CI/CD jobs, correct configuration syntax aside. Consider the following
    job definition:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基于容器的环境，如 Docker 和 Kubernetes，越来越频繁地被软件团队用于开发、测试和部署。`image` 关键字是 CI/CD 任务中的关键字，用于指定任务必须运行的
    Docker 容器类型。然而，容器化 CI/CD 任务的正确执行有许多依赖因素，除正确的配置语法外，还需要考虑其他问题。请看以下任务定义：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The job’s instructions are to start web services inside a container launched
    from a Node.js Docker image with a supporting Postgres database running alongside.
    Let’s think about what the job requires in order to successfully execute:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的指令是在从 Node.js Docker 镜像启动的容器内启动 Web 服务，同时运行一个支持的 Postgres 数据库。让我们思考任务成功执行所需的条件：
- en: Runners in the environment that support Docker containers.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 Docker 容器的环境中的运行器。
- en: Non-container runners won’t inadvertently pick up the job.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非容器运行器不会无意间接收任务。
- en: The runner has network connectivity to a container registry such as Docker Hub
    to pull down the base images.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行器可以连接到像 Docker Hub 这样的容器注册表，以拉取基础镜像。
- en: This is just one simple example that requires developers to think about the
    infrastructure their jobs use for execution. One way to solve the second listed
    point, non-container runners picking up jobs, is to define a CI/CD tag specifically
    for container-based runners and include that tag in any jobs that use the `image`
    keyword.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的例子，要求开发者思考他们的任务执行所使用的基础设施。解决第二个问题（非容器运行器接收任务）的一种方法是为基于容器的运行器专门定义一个 CI/CD
    标签，并在任何使用 `image` 关键字的任务中包含该标签。
- en: Needing to manage operational infrastructure alongside application logic can
    be intimidating for developers. In the next section, we will introduce the concept
    of GitOps to help unify development and operations under a best-practice workflow.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 需要同时管理操作基础设施和应用程序逻辑可能会让开发者感到有些吃力。在接下来的部分，我们将介绍 GitOps 的概念，以帮助将开发与运维统一到最佳实践的工作流中。
- en: Managing your operational infrastructure using GitOps
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitOps 管理你的操作基础设施
- en: Development cannot be divorced from the infrastructure executing the code. We’ve
    seen this clearly as we’ve journeyed from using GitLab as a source code management
    tool to defining CI/CD pipelines to define how our source code is built and deployed,
    with runners (infrastructure) as an essential component of CI/CD.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 开发不能脱离执行代码的基础设施。我们已经清晰地看到，从将 GitLab 用作源代码管理工具，到定义 CI/CD 流水线来定义源代码如何构建和部署，再到运行器（基础设施）作为
    CI/CD 的一个重要组成部分的过程中，基础设施的重要性。
- en: DevOps properly conceptualized is a culture unifying development and operations.
    How, then, can we incorporate configuring and managing our operational infrastructure
    into the GitLab flow already used and understood by developers? The answer lies
    in implementing **GitOps**. GitOps is a development practice that falls under
    DevOps, which encourages using a similar iterative change management model already
    used by development teams. As the term suggests, Git is an essential part of the
    workflow. Infrastructure should be under version control, just like application
    source code. Changes to infrastructure are then made by contributing changes to
    the code base, which in turn triggers CI/CD pipelines updating our environments
    with the committed changes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正确理解的 DevOps 是一种将开发和运维统一起来的文化。那么，我们如何将配置和管理我们的操作基础设施纳入到开发人员已经使用并理解的 GitLab 流程中呢？答案在于实施
    **GitOps**。GitOps 是一种属于 DevOps 的开发实践，鼓励使用与开发团队已经使用的相似的迭代变更管理模型。正如这个术语所暗示的那样，Git
    是工作流的核心部分。基础设施应该像应用程序源代码一样，受到版本控制。对基础设施的更改是通过对代码库进行修改来实现的，这反过来会触发 CI/CD 管道，更新我们的环境以适应这些提交的更改。
- en: GitOps Means Generally Putting Infrastructure Under Software Version Control
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps 通常意味着将基础设施纳入软件版本控制之下
- en: The GitOps described in this chapter is broader than the specific GitOps workflow
    for Kubernetes clusters that we previously discussed. Here, GitOps simply means
    applying Git development workflows to any manner of infrastructure management.
    This chapter uses Terraform and Ansible as reference examples that can be cross-applied
    to many different configuration management tools.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的 GitOps 比我们之前讨论的 Kubernetes 集群的特定 GitOps 工作流要广泛。在这里，GitOps 仅仅意味着将 Git
    开发工作流应用于任何形式的基础设施管理。本章使用 Terraform 和 Ansible 作为参考示例，这些示例可以跨多个不同的配置管理工具进行应用。
- en: 'Recall *Figure 3**.10* from [*Chapter 3*](B18073_03.xhtml#_idTextAnchor061)
    (shown again here), when we introduced GitLab flow as an iterative branching model
    for developers to make changes in a structured yet efficient way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下来自 [*第 3 章*](B18073_03.xhtml#_idTextAnchor061)的 *图 3.10*（这里再次展示），当时我们介绍了
    GitLab 流程作为一种迭代分支模型，让开发人员以结构化且高效的方式进行更改：
- en: '![Figure 12.7 – Major steps in GitLab flow](img/B18073_12_7.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – GitLab 流程中的主要步骤](img/B18073_12_7.jpg)'
- en: Figure 12.7 – Major steps in GitLab flow
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – GitLab 流程中的主要步骤
- en: A core motivation of this workflow is removing friction from the development
    process. Textual changes to files in a Git-versioned code base trigger automated
    pipeline building, testing, and deploying to appropriate environments. Reviews
    and approvals are baked into the merge request feature, ensuring all our changes
    are intentional, and version control ensures we can roll back as required.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这一工作流的核心动机是消除开发过程中的摩擦。对 Git 版本化代码库中的文件进行文本更改，会触发自动化管道的构建、测试和部署到相应环境。审查和批准已经集成到合并请求功能中，确保我们的所有更改都是有意的，而版本控制确保我们可以在需要时回滚。
- en: How, then, do we apply this model to infrastructure management? Just as developers
    use programming languages to engineer applications, the industry now has a plethora
    of text-based tools that can be used to describe, provision, and configure an
    operational environment. These tools are described as infrastructure as code because
    they are designed to put infrastructure (servers, networking, storage, databases,
    identity, and access) under a similar programmatic model as traditional software
    applications.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何将这个模型应用于基础设施管理呢？就像开发人员使用编程语言来开发应用程序一样，现今行业中有大量基于文本的工具，可以用于描述、提供和配置操作环境。这些工具被称为“基础设施即代码”，因为它们旨在将基础设施（如服务器、网络、存储、数据库、身份和访问控制）置于与传统软件应用程序相似的编程模型之下。
- en: IaC is a quickly evolving field, where new tools are constantly being supplanted
    by newer tools. It can be difficult to decide which software to introduce in this
    kind of book due to rapid innovation threatening to render today’s common tooling
    obsolete. However, as of this writing, we’ve seen a couple of IaC tools widely
    used for GitOps with GitLab. We present them here with the understanding that
    in infrastructure tooling, the state of the art is rapidly changing. That said,
    the tools we see frequently used are **Terraform** for infrastructure provisioning
    and **Ansible** for configuration management.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施即代码（IaC）是一个快速发展的领域，新的工具不断取代旧的工具。由于快速的创新可能使当今常见的工具过时，决定在此类书籍中介绍哪种软件可能会很困难。然而，截止到本文写作时，我们已经看到一些
    IaC 工具在 GitOps 和 GitLab 中被广泛使用。我们在这里展示它们，并理解在基础设施工具中，技术状态正在迅速变化。话虽如此，我们经常看到的工具是**Terraform**用于基础设施配置和**Ansible**用于配置管理。
- en: Using Terraform to deploy and update infrastructure state
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Terraform 部署和更新基础设施状态
- en: Terraform is an IaC tool used to describe how your infrastructure should look.
    The core project is open source, with enterprise versions developed and sold by
    HashiCorp. Terraform includes a language and syntax for describing infrastructure
    state, as well as a set of command-line tooling for validating and updating the
    said infrastructure. The configuration model used is *declarative*. We describe
    how our compute, networking, storage, and so on should look, and the software
    performs the minimum necessary changes so that our infrastructure reflects the
    configuration.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一个 IaC 工具，用于描述你的基础设施应如何呈现。核心项目是开源的，企业版本由 HashiCorp 开发并销售。Terraform
    包括一种语言和语法来描述基础设施状态，以及一套命令行工具，用于验证和更新该基础设施。使用的配置模型是*声明式的*。我们描述我们的计算、网络、存储等应如何呈现，软件则执行必要的最小更改，以使我们的基础设施反映该配置。
- en: 'Let’s look at a very basic example where we use Terraform to provision an object
    storage resource in AWS. Terraform has you describe your configuration in state
    files that end with the extension `.tf`. The details of Terraform syntax are well
    outside the scope of this book, but the following syntax shows how an S3 bucket
    might be configured in AWS. This “code” might be stored in a file called `bucket.tf`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个非常基础的示例，使用 Terraform 在 AWS 中配置一个对象存储资源。Terraform 要求你在以 `.tf` 结尾的状态文件中描述配置。Terraform
    语法的细节超出了本书的范围，但以下语法展示了如何在 AWS 中配置一个 S3 桶。这个“代码”可能会被存储在名为 `bucket.tf` 的文件中：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This simple state file specifies an S3 bucket resource in AWS with a name and
    access permissions. It is then up to Terraform to “make it happen.” In the context
    of GitOps with GitLab, the “making it happen” takes place via a CI/CD pipeline.
    The pipeline will run the necessary Terraform commands to initialize, validate,
    and apply the configuration to your AWS account.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的状态文件在 AWS 中指定了一个 S3 桶资源，包括名称和访问权限。接下来，由 Terraform 来“实现这一目标”。在 GitOps 和
    GitLab 的背景下，"实现这一目标"是通过 CI/CD 管道完成的。该管道将运行必要的 Terraform 命令来初始化、验证并将配置应用到你的 AWS
    账户中。
- en: Installing and configuring Terraform can take a bit of work. Thankfully, GitLab
    packages Terraform’s tooling in a Docker image that can be launched using the
    `image` keyword in `.gitlab-ci.yml`. GitLab maintains a public example project
    with a sample `.gitlab-ci.yml` file ([https://gitlab.com/gitlab-org/configure/examples/gitlab-terraform-aws/-/blob/master/.gitlab-ci.yml](https://gitlab.com/gitlab-org/configure/examples/gitlab-terraform-aws/-/blob/master/.gitlab-ci.yml))
    containing the relevant jobs and commands for applying or updating a Terraform
    configuration in AWS. We recommend exploring this page and testing the examples
    in your own AWS account. Notice how the `prepare`, `validate`, `build`, and `deploy`
    stages and accompanying jobs are conceptually similar to the `build`, `test`,
    and `deploy` stages in typical application development.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 安装和配置 Terraform 可能需要一些工作。幸运的是，GitLab 将 Terraform 的工具封装在一个 Docker 镜像中，可以通过 `.gitlab-ci.yml`
    中的 `image` 关键字来启动。GitLab 维护了一个公共示例项目，里面有一个示例 `.gitlab-ci.yml` 文件（[https://gitlab.com/gitlab-org/configure/examples/gitlab-terraform-aws/-/blob/master/.gitlab-ci.yml](https://gitlab.com/gitlab-org/configure/examples/gitlab-terraform-aws/-/blob/master/.gitlab-ci.yml)），该文件包含了应用或更新
    AWS 中 Terraform 配置的相关作业和命令。我们建议你浏览这个页面，并在你自己的 AWS 账户中测试这些示例。注意，`prepare`、`validate`、`build`
    和 `deploy` 阶段及其相关作业在概念上类似于典型应用开发中的 `build`、`test` 和 `deploy` 阶段。
- en: Terraform is a tool primarily used to deploy or provision infrastructure. The
    second tool we will discuss is primarily used to configure the resources that
    have been provisioned.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一个主要用于部署或配置基础设施的工具。我们将讨论的第二个工具，主要用于配置已部署的资源。
- en: Using Ansible to manage resource configurations
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ansible 管理资源配置
- en: 'Ansible is also an open source IaC tool, with paid versions offered by Red
    Hat. Like Terraform, Ansible is used by declaring resource configurations in files,
    whose contents are then translated into configuration changes by running commands.
    These Ansible resource configuration files are called **playbooks** and are written
    in YAML format. The content of an extremely basic playbook that installs and starts
    Apache might look like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 也是一个开源的 IaC 工具，Red Hat 提供了付费版本。与 Terraform 类似，Ansible 通过在文件中声明资源配置来使用，文件内容随后通过运行命令转化为配置变更。这些
    Ansible 资源配置文件称为 **playbooks**，并且采用 YAML 格式编写。一个极其基础的 playbook 内容，安装并启动 Apache，可能如下所示：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Like Terraform, we use a declarative syntax to describe how our environment
    should look, and rely on the tool (in this case Ansible) to make it so. Here,
    we specify that a collection of hosts called `web` should have the `apache2` package
    installed, and the corresponding service should be enabled and started. Ansible
    would then connect to the hosts in question, and once connected, install and start
    `apache2`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Terraform 一样，我们使用声明性语法来描述我们的环境应该是什么样的，并依赖工具（在本例中为 Ansible）来实现这一目标。在这里，我们指定一个名为
    `web` 的主机集合应该安装 `apache2` 包，并且相应的服务应该被启用并启动。然后，Ansible 会连接到相关主机，并在连接后安装并启动 `apache2`。
- en: 'Also like Terraform, we would define CI/CD jobs that run the tool’s commands
    to apply the configuration change. In the case of Ansible, GitLab does not have
    an official Docker image with Ansible tooling. So we might instead tell GitLab
    to use a runner that we know is an Ansible host to run our playbook:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 同样像 Terraform 一样，我们会定义 CI/CD 作业，运行工具的命令以应用配置更改。在 Ansible 的情况下，GitLab 没有官方的带有
    Ansible 工具的 Docker 镜像。因此，我们可能会告诉 GitLab 使用一个我们知道是 Ansible 主机的 runner 来运行我们的 playbook：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding job is assigned to a runner with the `ansible` tag (which we may
    assume is a runner with Ansible installed and configured). The job script then
    runs the playbook and might also pass in credentials using CI/CD variables so
    that Ansible can authenticate to the servers it is configuring.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 上述作业被分配给一个带有 `ansible` 标签的 runner（我们可以假设这是一个已安装并配置了 Ansible 的 runner）。作业脚本随后会运行
    playbook，并可能通过 CI/CD 变量传递凭据，以便 Ansible 可以对它所配置的服务器进行身份验证。
- en: For more details about using Ansible with GitLab, including interpreting and
    parsing CI/CD job output when Ansible commands are run, we refer you to this article
    ([https://about.gitlab.com/blog/2019/07/01/using-ansible-and-gitlab-as-infrastructure-for-code/](https://about.gitlab.com/blog/2019/07/01/using-ansible-and-gitlab-as-infrastructure-for-code/))
    published by GitLab as a more in-depth reference. Please also refer to the official
    Terraform and Ansible docs sites for further details on setup and system requirements.
    Ultimately, the goal of this section has been to introduce you to GitOps concepts
    as a paradigm for incorporating IaC tools into the CI/CD workflows we have learned
    so far.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关将 Ansible 与 GitLab 一起使用的更多细节，包括在运行 Ansible 命令时如何解释和解析 CI/CD 作业输出，我们推荐您参考 GitLab
    发布的这篇文章（[https://about.gitlab.com/blog/2019/07/01/using-ansible-and-gitlab-as-infrastructure-for-code/](https://about.gitlab.com/blog/2019/07/01/using-ansible-and-gitlab-as-infrastructure-for-code/)），作为更深入的参考。请同时参考官方的
    Terraform 和 Ansible 文档站点，以获取有关设置和系统要求的更多详细信息。最终，本节的目标是向您介绍 GitOps 概念，作为将 IaC 工具整合到我们迄今为止学习的
    CI/CD 工作流中的一种范式。
- en: Future industry trends
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 未来行业趋势
- en: It goes without saying that learning anything new comes with the expectation
    that the knowledge will remain relevant in the future. Looking forward, continuous
    integration and delivery are well positioned to persist as critical practices
    in the software landscape, while continuing to undergo evolutionary changes. We
    can identify three likely ways the software development life cycle will change
    in the coming years. Those trends are increased automation, increased abstraction,
    and reduced development cycle time. We can also expect that GitLab as a platform
    will continue to play an important role. The concepts, examples, and tools presented
    in the previous chapters will serve as a good foundation to be a more productive
    developer right now while providing the confidence needed to adapt as the industry
    inevitably shifts.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，学习任何新事物时，都有一个期望，那就是知识将来仍然相关。展望未来，持续集成和持续交付在软件领域中有望作为关键实践持续存在，并将继续经历演变变化。我们可以识别出未来几年软件开发生命周期可能发生变化的三种趋势。它们是：自动化的增加、抽象化的增加和开发周期时间的缩短。我们还可以预期
    GitLab 作为平台将继续发挥重要作用。前几章中展示的概念、示例和工具将为你现在成为更高效的开发者打下坚实的基础，同时也提供适应行业不可避免变化所需的信心。
- en: Automation will create more software at a larger scale
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化将以更大规模创造更多软件
- en: Ask any organization today what is the most expensive part of operating, and
    they will likely respond that it’s the humans. Skilled human workers, which includes
    technologists, are particularly pricey. Talented engineers are hard to find, harder
    to replace, and expensive to keep. Moreover, those same engineers have designed
    software and tooling to make their own jobs easier and more productive. Organizations
    are now leveraging that tooling so that they can create and deploy more software
    using fewer people.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问任何一个组织什么是运营中最昂贵的部分，他们很可能会回答是人力。熟练的人工劳动力，包括技术人员，尤其昂贵。优秀的工程师难以找到，更难以替代，且留住他们非常昂贵。此外，这些工程师们已经设计了软件和工具，使得他们自己的工作更加轻松高效。组织们现在正在利用这些工具，以便用更少的人力创造和部署更多的软件。
- en: Think about the teams of manual quality assurance testers that companies employed
    20 or even 10 years ago. Now consider the role that tools like GitLab play in
    allowing a single developer to automate the process of releasing software, from
    conceptualization to deployment. Moreover, cloud service providers now offer almost
    limitless amounts of infrastructure to any developer with a credit card—dedicated
    teams for racking and stacking servers are no longer required.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 想想 20 年前甚至 10 年前，公司所雇佣的手工质量保证测试团队。现在，考虑像 GitLab 这样的工具在允许单个开发人员自动化软件发布过程（从概念化到部署）中所起的作用。而且，现在云服务提供商几乎为任何拥有信用卡的开发人员提供无限量的基础设施——不再需要专门的团队来进行服务器的安装和管理。
- en: Yet, predictions of the singularity aside, humans aren’t going anywhere anytime
    soon. The prevalence of automation requires people who can understand and maintain
    that tooling. The more you can speak the language of automation and the platforms
    such as GitLab powering the trend, the more equipped you will be to contribute
    to the automation revolution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了奇点的预测之外，人类在短期内不会去哪里。自动化的普及需要能够理解和维护这些工具的人。你能说懂自动化的语言，以及像 GitLab 这样推动这一趋势的平台，你就能更好地参与到自动化革命中。
- en: Abstraction will lead to everything-as-code business models
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象化将引领万物皆代码的商业模型
- en: In 2011, Marc Andreessen wrote his now-famous article titled *Why Software Is
    Eating the World* ([https://a16z.com/2011/08/20/why-software-is-eating-the-world/](https://a16z.com/2011/08/20/why-software-is-eating-the-world/)).
    Andreessen predicted that the next generation of internet companies was leading
    a broad economic shift in which software becomes the language and engine of most,
    if not all, industries. Ten years later, in 2021, Jon Eckhardt wrote a follow-up
    article called *Software Is Eating the Software That’s Eating the World* ([https://eiexchange.com/content/software-is-eating-the-software-thats-eating-the-world](https://eiexchange.com/content/software-is-eating-the-software-thats-eating-the-world)).
    Eckhardt recognized that not only have traditional industries been disrupted by
    software, but there is a whole generation of new tooling disrupting existing software
    models. This tooling can be thought of as powerful, easier-to-use programs that
    allow developers to work at a higher layer of abstraction. That is, developers
    can focus on the business logic while the tool handles the finer details.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，Marc Andreessen写下了他那篇如今广为人知的文章《*为何软件正在吞噬这个世界*》([https://a16z.com/2011/08/20/why-software-is-eating-the-world/](https://a16z.com/2011/08/20/why-software-is-eating-the-world/))。Andreessen预测，下一代互联网公司正在引领一场广泛的经济变革，在这一变革中，软件将成为大多数，甚至所有行业的语言和引擎。十年后的2021年，Jon
    Eckhardt写了一篇后续文章，标题为《*软件正在吞噬吞噬世界的软件*》([https://eiexchange.com/content/software-is-eating-the-software-thats-eating-the-world](https://eiexchange.com/content/software-is-eating-the-software-thats-eating-the-world))。Eckhardt认识到，不仅传统行业被软件颠覆，而且一代新的工具也在颠覆现有的软件模型。这些工具可以被看作是强大且更易使用的程序，使得开发者能够在更高的抽象层次上工作。也就是说，开发者可以专注于业务逻辑，而工具则负责处理更细微的细节。
- en: A good example of increased abstraction is how infrastructure has changed over
    the past 30 years. The industry has moved from mainframes to the server model.
    It then moved to virtual machines, so we can start to view operating systems as
    flexible, software-defined resources on a shared host. Then, configuration management
    helped take care of maintaining our IT resources so that we could focus more on
    the “what” and less on the “how.” Then, cloud services took off so that no one
    needed to set foot in a data center. And now, additional tools, such as containers
    and functions, allow developers to focus solely on their code without even needing
    to think about the computers and networks it may be running on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一个增加抽象层次的好例子是过去30年基础设施的变化。行业从大型主机转向了服务器模型。接着，又转向了虚拟机，因此我们可以开始将操作系统视为灵活的软件定义资源，运行在共享主机上。然后，配置管理帮助我们维护IT资源，从而使我们能够更多地关注“做什么”，而不必过多关注“怎么做”。之后，云服务迅速发展，以至于没人需要亲自踏入数据中心。现在，像容器和函数这样的额外工具，使开发者能够专注于他们的代码，而无需考虑它可能运行的计算机和网络。
- en: We expect this abstraction trend to continue. Like automation, we by no means
    anticipate that humans will be rendered irrelevant. Rather, we expect increased
    consolidation and specialization. Code will always be running on someone’s computer,
    somewhere, and we’ll need infrastructure experts to build and maintain those environments.
    But we also expect tools like GitLab to continue to proliferate, offering self-documenting,
    programmatic models that offer observability into all layers of the business.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计这一抽象化趋势将会持续下去。像自动化一样，我们完全不认为人类会变得不再重要。相反，我们预期将会有更多的整合和专业化。代码总会在某人的计算机上运行，无论在哪个地方，我们都需要基础设施专家来构建和维护这些环境。但我们也预计像GitLab这样的工具将继续普及，提供自文档化的程序化模型，能够观察到业务的所有层次。
- en: Reduced cycle time will help teams release better software faster
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少周期时间将帮助团队更快发布更好的软件
- en: The DevOps philosophy is primarily cultural, but it also represents a system
    of work inspired by the lean manufacturing revolution. Building on the trends
    of automation and abstraction, combined with project management methodologies
    such as Agile and Scrum, teams are now developing software in such a way that
    they release early and often, incorporating small improvements, and rolling back
    as needed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps哲学主要是文化层面的，但它也代表着一种受精益制造革命启发的工作系统。基于自动化和抽象趋势，并结合如敏捷和Scrum等项目管理方法论，团队现在以一种方式开发软件，即早期频繁发布，融入小的改进，并在需要时回滚。
- en: Books such as *The Lean Startup* by Eric Ries have introduced the language for
    this development model, and tooling has proliferated that allows developers to
    build, test, and release software in a very fast but controlled way. GitLab is
    one of these core platforms. Source code management and version control ensure
    continuous integration into a shared code base, and pipelines allow for a common
    set of build, test, and deploy tasks after every small commit. This allows for
    rapid, iterative development that can constantly adapt to meet business needs.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 像Eric Ries的*《精益创业》*这样的书籍引入了这一开发模型的语言，许多工具也应运而生，允许开发人员以非常快速但受控的方式构建、测试和发布软件。GitLab就是这些核心平台之一。源代码管理和版本控制确保了与共享代码库的持续集成，管道则在每次小规模提交后，允许执行一套共同的构建、测试和部署任务。这使得快速、迭代式的开发成为可能，并能够不断适应业务需求。
- en: The combination of automation, abstraction, and smaller release cycles will
    require developers to be comfortable with iterative approaches to project management
    and design. Don’t be afraid of failure, as rapid small changes will inevitably
    cause some broken or buggy code. Adopt a mindset of continuous improvement, focusing
    on developing better software rather than perfect software.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化、抽象化以及更小的发布周期的结合将要求开发人员适应迭代式的项目管理和设计方法。不要害怕失败，因为快速的小变更不可避免地会导致一些代码出现问题或有缺陷。采用持续改进的思维方式，专注于开发更好的软件，而不是追求完美的软件。
- en: Conclusion and next steps
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论与下一步
- en: This book has guided you through using GitLab as a platform to manage your software
    development life cycle. After discussing the state of the industry before DevOps
    emerged as a culture and methodology, you were then guided through the basics
    of Git version control and GitLab’s project management components. Then, GitLab
    CI/CD pipelines were introduced as the central feature for organizing, designing,
    and automating your development workflow.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本书引导你通过使用GitLab作为平台来管理你的软件开发生命周期。在讨论了DevOps作为一种文化和方法论出现之前行业的现状后，你接着学习了Git版本控制和GitLab的项目管理组件的基础知识。然后，GitLab
    CI/CD管道被介绍为组织、设计和自动化开发工作流的核心功能。
- en: 'You learned that GitLab CI/CD comprises three components: the text-based pipeline
    configuration file, the runners that execute pipeline tasks, and the main GitLab
    application that coordinates between the configuration and the runner agents.
    We then walked through how to leverage pipelines to verify, secure, package, and
    deploy your code. You learned that you can use GitLab CI/CD as a unified tool
    to perform these often-disparate steps in the software life cycle.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你了解到，GitLab CI/CD包含三个组件：基于文本的管道配置文件、执行管道任务的runner，以及协调配置与runner代理之间的GitLab主应用程序。接着，我们展示了如何利用管道来验证、加固、打包和部署代码。你了解到，你可以将GitLab
    CI/CD作为一个统一的工具，执行软件生命周期中这些通常是离散的步骤。
- en: After covering the supported CI/CD features and workflows, we moved to some
    advanced topics and best practices. You learned how to improve pipeline speed
    and maintainability, and how you can leverage GitLab CI/CD in other workflows
    that might not be immediately obvious.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论完支持的CI/CD特性和工作流后，我们转向了一些高级话题和最佳实践。你学到了如何提高管道的速度和可维护性，以及如何将GitLab CI/CD应用于其他可能并不立即显现的工作流中。
- en: Finally, [*Chapter 11*](B18073_11.xhtml#_idTextAnchor268) introduced you to
    an end-to-end example using all the concepts and features previously covered.
    That chapter’s objective is to show a basic but real use case of GitLab supporting
    all steps in the workflow of planning, building, and deploying an application.
    We then concluded with this chapter, offering some final troubleshooting tips,
    guidelines for next-gen infrastructure management with GitLab, and a look at where
    the industry is likely to go in the coming years.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[*第11章*](B18073_11.xhtml#_idTextAnchor268)向你介绍了一个端到端的示例，使用了之前讨论过的所有概念和功能。该章节的目标是展示一个基础但真实的GitLab使用案例，支持规划、构建和部署应用程序的整个工作流。我们随后以这一章作为总结，提供了一些最终的故障排除技巧、使用GitLab进行下一代基础设施管理的指南，并展望了未来几年行业可能的发展方向。
- en: We hope your journey with GitLab, CI/CD, and DevOps doesn’t end with the conclusion
    of this book. GitLab itself is open core, and GitLab the company is transparent
    in how it intends to steward and evolve the software over time. We encourage you
    to continue following GitLab’s evolution and product roadmap by keeping tabs on
    the core product’s issue-tracking system and referring to the product’s online
    handbook pages, which document the category directions for each of GitLab’s features.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你与 GitLab、CI/CD 和 DevOps 的旅程不会随着本书的结束而告一段落。GitLab 本身是开源核心，而 GitLab 公司在软件的管理和演进方面也保持透明。我们鼓励你继续关注
    GitLab 的演变和产品路线图，通过关注核心产品的 issue 跟踪系统，并参考产品的在线手册页面，这些页面记录了 GitLab 各项功能的类别发展方向。
- en: Ultimately, as technologists, we know that learning never stops. We hope this
    book was helpful in familiarizing you with GitLab as a software platform, the
    problems it’s designed to solve, and how you can use it to meet the challenges
    faced in your own organization. We wish you the best as you continue your DevOps
    journey.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，作为技术人员，我们知道学习永无止境。我们希望本书能帮助你了解 GitLab 作为一个软件平台，它所要解决的问题，以及你如何使用它来应对自己组织中的挑战。我们祝愿你在继续你的
    DevOps 旅程时一切顺利。
