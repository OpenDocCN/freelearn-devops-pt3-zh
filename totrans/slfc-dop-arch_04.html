<html><head></head><body>
		<div id="_idContainer019">
			<h1 class="chapter-number" id="_idParaDest-83"><a id="_idTextAnchor099"/>4</h1>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor100"/>Testing Your Changes</h1>
			<p>One of the core tenets of DevOps is the ability to deliver robust changes that stand up to scrutiny, have fewer defects, and ultimately<a id="_idIndexMarker157"/> reduce the <strong class="bold">Change Failure Rate</strong> (<strong class="bold">CFR</strong>) metric. This can be largely achieved through testing our <span class="No-Break">development changes.</span></p>
			<p>In this chapter, we’ll explore the importance of robustly testing Salesforce changes, the different types of testing that apply to your components, and how to ensure proper testing as part of your <span class="No-Break">DevOps process.</span></p>
			<p>We will be covering the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The importance <span class="No-Break">of testing</span></li>
				<li><span class="No-Break">Apex testing</span></li>
				<li>Testing your <strong class="bold">Lightning Web </strong><span class="No-Break"><strong class="bold">Components</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">LWCs</strong></span><span class="No-Break">)</span></li>
				<li>Testing <span class="No-Break">your flows</span></li>
			</ul>
			<p>By the end of this chapter, you should be well equipped to create and run tests within Salesforce that exercise much of the functionality you implement, whether programmatically or declaratively. This will in turn help you deliver better quality deployments as your DevOps <span class="No-Break">process matures.</span></p>
			<h1 id="_idParaDest-85"><a id="_idTextAnchor101"/>Technical requirements</h1>
			<p>If you want to follow along with the examples in this chapter, as a minimum you will need to have the <span class="No-Break">following installed:</span></p>
			<ul>
				<li>The <span class="No-Break">Salesforce CLI</span></li>
				<li>Visual <span class="No-Break">Studio Code</span></li>
				<li>Salesforce extensions for Visual <span class="No-Break">Studio Code</span></li>
			</ul>
			<p>Additionally, for the <em class="italic">Testing your LWCs</em> section, you will need to install Node.js (which will include <strong class="bold">Node Package </strong><span class="No-Break"><strong class="bold">Manager</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">npm</strong></span><span class="No-Break">)).</span></p>
			<h1 id="_idParaDest-86"><a id="_idTextAnchor102"/>The importance of testing</h1>
			<p>Conventional wisdom<a id="_idIndexMarker158"/> states that the earlier a software bug is found, the easier it is to fix and the less impact and cost it is likely to have. Often referred to <a id="_idIndexMarker159"/>as a <strong class="bold">shift-left</strong> approach—in that given a process diagram moving from left to right in sequence, the further left you deal with an issue, the better—the idea is that by including robust and thorough testing in your DevOps workflow, you stand a much better chance of catching potential issues early. This approach applies not only to functional testing of your Salesforce changes but also to the security aspects of your design and development too—part of what has been dubbed <em class="italic">DevSecOps</em> in the wider <span class="No-Break">IT industry.</span></p>
			<p>If we look at the impact of testing in the context of our DORA metrics discussed in <a href="B19436_02.xhtml#_idTextAnchor032"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, we can easily see that testing directly impacts the CFR metric. Put simply, the more well tested your changes are, the less likely that errors are to be deployed into your later environments. <em class="italic">Test early, test often</em> is a phrase I’ve used across my years in software development to nicely summarize <span class="No-Break">my approach.</span></p>
			<p>When we look at testing in the wider aspect of DevOps, it’s important to consider it in the context of not just the development or delivery phases of the application life cycle, but across every step from design to delivery. As architects, we should be mentally testing the requirements and design long before we get to implement any changes—picking holes and finding flaws is one of the greatest skills of a Salesforce architect. By making sure that a request is valid and its design stands up to scrutiny, with questions satisfactorily answered, you’ve tested the approach well ahead of time. This is considered to be the cheapest time to uncover flaws before developer hours (and thus cost) are spent on a project. It can be thought of as the software development equivalent to the<a id="_idIndexMarker160"/> phrase <em class="italic">measure twice, cut once</em> often quoted in the <span class="No-Break">construction world.</span></p>
			<p>There is an array of different aspects to testing that should be considered as part of your overall application delivery model. We’ll cover some of the ones that are specific to the Salesforce platform’s technology stack here, but to get a holistic view of testing as an architect, you should consider the following types <span class="No-Break">of testing.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor103"/>Integration testing</h2>
			<p>Thorough integration<a id="_idIndexMarker161"/> testing is critical for validating that different components and systems work together as expected. For Salesforce projects, key integrations to test include connections between Salesforce and external databases, third-party web services, interactions between Salesforce products such as Sales Cloud and Service Cloud, and custom Lightning components or <span class="No-Break">other customizations.</span></p>
			<p>Use a combination of automated API and UI testing, <strong class="bold">end-to-end</strong> (<strong class="bold">E2E</strong>) process validation, and manual spot checks to confirm <a id="_idIndexMarker162"/>all integration points consistently function as designed from end to end. Import and export data between systems to check for accuracy and completeness. Where possible, send test requests to web services to validate response handling, or as a fallback, provide mock responses for <span class="No-Break">these requests.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor104"/>Regression testing</h2>
			<p>Regression testing helps verify that existing functionality and integrations continue to work as expected after changes are made. Prioritize regression testing after deploying major updates, new features, or structural changes such as altering permissions or record-sharing rules. By building automated regression test suites that run quickly and frequently, focusing on critical business processes and key integration points most likely to be impacted by changes, you can quickly check and resolve any <span class="No-Break">breaking changes.</span></p>
			<p>Use a combination of automated UI testing, Apex tests to validate logic and handlers, cross-browser testing, and Salesforce API checks for data validation, and integrate regression testing into the deployment pipeline to <span class="No-Break">run automatically.</span></p>
			<p>Regression testing gives confidence that the system remains stable through ongoing enhancements <span class="No-Break">and changes.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor105"/>User acceptance testing</h2>
			<p><strong class="bold">User acceptance testing</strong> (<strong class="bold">UAT</strong>) usually<a id="_idIndexMarker163"/> requires a dedicated Salesforce sandbox with test data, roles, and processes modeled on real usage patterns. Involve real users in UAT, to validate that new features meet business needs before full release. Identify power users across <strong class="bold">business units</strong> (<strong class="bold">BUs</strong>) to <a id="_idIndexMarker164"/>serve as UAT testers who deeply understand needs <span class="No-Break">and workflows.</span></p>
			<p>Be sure to structure formal test plans and reporting to ensure thorough real-world validation. Ahead of the start of your UAT process, you should provide testers with account access, sample data, and clear test scenarios mapped to business <span class="No-Break">use cases.</span></p>
			<p>Track and triage all issues uncovered during UAT, clarifying requirements with users and addressing issues before proceeding to production. It should be noted that in many larger organizations, much of this process is done by either a business analyst or dedicated testing resources, rather than the architect (whose role is more that of overseeing the process and ensuring it is <span class="No-Break">carried out).</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor106"/>Large volume testing</h2>
			<p>Special testing is required to confirm the Salesforce platform can handle large data volumes and heavy user load. Use realistically large datasets in a test org to validate performance and stability at scale. Load the database with maximum expected data sizes, and import representative sample data. Use performance testing tools to simulate peak numbers of concurrent users, identifying governor limits or bottlenecks. Optimize configuration to support caching, indexing, and scalability best practices. Check for degradation over time as data volumes grow, tuning and adding resources as needed. Modeling production-level usage through large volume testing helps validate that the system can support <span class="No-Break">business growth.</span></p>
			<p>In the world of <a id="_idIndexMarker165"/>Salesforce DevOps, the two most common types of testing are unit testing and E2E testing, but as we’ll see shortly, other important tests such as integration tests and regression tests should be considered <span class="No-Break">as well.</span></p>
			<p>Unit testing concentrates on verifying individual and separate functions within an application—these often relate to a specific individual change that you’re developing. It’s important to note that Salesforce enforces a minimum of 75% of Apex test coverage across your entire org for production deployments, and even more important to note is that this is not a guarantee that functionality is correct. A poorly written test can hide or distort actual issues, so unit testing should only be considered a part of your overall testing strategy. Additionally, if you specify a subset of specific test classes to run as part of a production deployment, then every Apex class being deployed needs 75%+ coverage individually rather than the org-wide or even deployment-package-wide average. All the more reason to aim for as high a percentage of coverage <span class="No-Break">as possible.</span></p>
			<p>Unit testing works best when you construct your application from small, testable units instead of monolithic Apex classes, flows, or even objects. Creating brief, quick unit tests that can be effortlessly executed motivates developers to include them in their development, regression <a id="_idIndexMarker166"/>testing, and <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) procedures. As <a id="_idIndexMarker167"/>a result, bugs are detected and <span class="No-Break">resolved earlier.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor107"/>Apex testing</h1>
			<p>Writing Apex code without proper<a id="_idIndexMarker168"/> testing can lead to issues, such as bugs and errors, which can negatively impact the user experience and ultimately harm the overall success of the project. This is where Apex unit testing comes in as a critical part of the development process that helps ensure that the code is functioning as intended, meets requirements, and can handle different scenarios. In this regard, Apex unit testing is essential for creating high-quality, robust, and maintainable code <span class="No-Break">in Salesforce.</span></p>
			<p>These tests should be designed to simulate both positive and negative scenarios. This means the code should not only be tested to ensure that it does what it is supposed to, but also tested to check that it <em class="italic">doesn’t </em>do things it’s not supposed to. Additionally, Apex unit tests should be written to test operations in a single context or a bulkified context, meaning they can test either a single record or multiple records at once. To improve test efficiency and isolate code under test, mocks and stubs can be used to simulate external dependencies, such as web services or database operations. By writing comprehensive unit tests that cover all possible scenarios and using best practices such as mock testing, Salesforce developers can build reliable, maintainable, and <span class="No-Break">scalable applications.</span></p>
			<p>As mentioned earlier, Salesforce enforces a minimum of 75% of unit test coverage of your code, but as good architects, we should always strive to get as close to 100% coverage as possible. The reality is that there will be some corner cases that are not reachable via unit tests—by targeting 100% coverage, these fall into a buffer between this high standard and the required 75%, so we should never have insufficient coverage in a well-written set of <span class="No-Break">unit tests.</span></p>
			<p>To illustrate a simple example of an Apex unit test, first, consider the following Apex class. It contains a static method that calculates the total price of products in a shopping cart. These pro<a id="_idTextAnchor108"/>ducts use a <strong class="source-inline">Product__c</strong> custom object that contains a <strong class="source-inline">Price__c</strong> custom field—the custom object is far simpler than the standard <strong class="source-inline">Product2</strong> object and associated objects for <span class="No-Break">example purposes:</span></p>
			<pre class="source-code">
public class ShoppingCart {
    public static Decimal calculateTotal(List&lt;Product__c&gt; products) {
        Decimal total = 0;
        if (products != null) {
            for (Product__c p : products) {
                if (p.Price__c != null) {
                    total += p.Price__c;
                }
            }
        }
        return total;
    }
}</pre>			<p>An initial attempt at a corresponding unit test class that includes both single and bulkified tests and <a id="_idIndexMarker169"/>covers positive and negative scenarios could look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
@isTest
private class ShoppingCartTest {
    @isTest
    static void SingleProduct() {
        // Create a single product
        Product__c p = new Product__c(Description__c='Product A', 
        Price__c=100);
        insert p;
        // Calculate the total price
        Decimal total = ShoppingCart.calculateTotal(new 
        List&lt;Product__c&gt;{p});
        // Verify that the total is correct
        Assert.areEqual(100, total, 'Total should be 100');
    }
    @isTest
    static void testMultipleProducts() {
        // Create multiple products
        List&lt;Product__c&gt; products = new List&lt;Product__c&gt;{
            new Product__c(Description__c='Product A', Price__c=100),
            new Product__c(Description__c='Product B', Price__c=50)
        };
        insert products;
        // Calculate the total price
        Decimal total = ShoppingCart.calculateTotal(products);
        // Verify that the total is correct
        Assert.areEqual(150, total, 'Total should be 150');
    }
    @isTest
    static void testNullProducts() {
        // Calculate the total price with null products
        Decimal total = ShoppingCart.calculateTotal(null);
        // Verify that the total is zero
        Assert.areEqual(0, total, 'Total should be 0');
    }
    @isTest
    static void testProductsWithoutPrice() {
        // Create a product without a price
        Product__c p = new Product__c(Description__c='Product A');
        insert p;
        // Calculate the total price
        Decimal total = ShoppingCart.calculateTotal(new 
        List&lt;Product__c&gt;{p});
        // Verify that the total is zero
        Assert.areEqual(0, total, 'Total should be 0');
    }
}</pre>			<p>In this example, the<a id="_idIndexMarker170"/> unit test class includes four test methods: <strong class="source-inline">testSingleProduct</strong>, <strong class="source-inline">testMultipleProducts</strong>, <strong class="source-inline">testNullProducts</strong>, and <strong class="source-inline">testProductsWithoutPrice</strong>. The first two methods test the <strong class="source-inline">calculateTotal</strong> method with different numbers of products, while the third and fourth methods test it with null and incomplete product data, respectively. The use of both single and bulkified tests ensures that the code can handle different scenarios and scales well. Additionally, the use of both positive and negative flows helps ensure that the code can handle both expected and unexpected <span class="No-Break">input data.</span></p>
			<p>Although this test class would work, many code scenarios would benefit from a <strong class="source-inline">@testSetup</strong> method, which creates the data used by the test. This data is rolled back at the end of <span class="No-Break">the test.</span></p>
			<p>If we consider the following trigger and corresponding handler class—which is illustrative, not a useful real-world example—we can create a test class for it that makes use of the <strong class="source-inline">@testSetup</strong> annotation. The trigger, handler class, and its test are<a id="_idIndexMarker171"/> <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
trigger ProductTrigger on Product__c (before insert, before update, after insert, after update)
{
  if (trigger.isBefore)
  {
    if (trigger.isInsert)
    {
      //before insert logic
    }
    else if (trigger.isUpdate)
    {
      //before update logic
    }
    }
  else if (trigger.isAfter)
  {
    if(trigger.isInsert)
    {
      //after insert logic
    }
    else if (trigger.isUpdate)
    {
      //after update logic
    }
  }
}
public with sharing class ProductTriggerHandler
  {
    public static void beforeInsert(List&lt;Product__c&gt; products)
  {
    Decimal total = 0.0;
    for(Product__c prod : products)
    {
      total += prod.Price__c;
    }
    System.debug(total);
  }
}
@isTest
public with sharing class ProductTriggerHandlerTest
{
    @TestSetup
    static void setup()
    {
        // Create multiple products
        List&lt;Product__c&gt; products = new List&lt;Product__c&gt;{
            new Product__c(Description__c='Product A', Price__c=100),
            new Product__c(Description__c='Product B', Price__c=50)
        };
        insert products;
    }
    @isTest
    static void testTotal()
    {
        List&lt;Product__c&gt; products = [SELECT Id, Description__c, 
        Price__c from Product__c];
        Decimal total = 0.0;
        test.startTest();
        for(Product__c prod : products)
        {
            total += prod.Price__c;
        }
        Assert.areEqual(150, total, 'Total should be 150');
    }
}</pre>			<p>With this <a id="_idIndexMarker172"/>method, the <strong class="source-inline">@testSetup</strong> annotation is used to create multiple products that are used in the subsequent test methods. This eliminates the need to create duplicate product records in each test method, making the test code more efficient and easier to read. The first two test methods from our original test class now rely on the <strong class="source-inline">@testSetup</strong> method to create products and calculate the total price, while the remaining methods test different scenarios. The use of <strong class="source-inline">@testSetup</strong> helps ensure that the test data is consistent and the tests are <span class="No-Break">more reliable.</span></p>
			<p>We can further improve this test class by making use of the <strong class="source-inline">test.startTest()</strong> and <strong class="source-inline">test.stopTest()</strong> methods. These are used to separate the setup and execution phases of each test method and should be called immediately before and after the line(s) of code that specifically execute the code we wish to test. This ensures that the performance metrics captured by <strong class="source-inline">Limits.get*()</strong> methods and asynchronous operations started by the test method are isolated and not mixed with other operations performed before or after the test as part of preparing the test for execution. The use of <strong class="source-inline">test.startTest()</strong> and <strong class="source-inline">test.stopTest()</strong> also helps to avoid hitting governor limits during test execution, especially when testing bulk <span class="No-Break">data operations.</span></p>
			<p>It’s important to <a id="_idIndexMarker173"/>be thorough and diligent in your Apex unit tests, but as we’ll see in the next section, this should not be the only place that you apply a commitment to quality. We’ll start by looking at how we can <span class="No-Break">test LWCs.</span></p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor109"/>Testing your LWCs</h1>
			<p>While Salesforce<a id="_idIndexMarker174"/> still has more than one approach for developing Lightning components, we’re going to focus on testing LWCs, rather than the older Aura components. Salesforce introduced LWCs in December 2018, with the release of Salesforce’s Spring ’19 version. This was announced in a blog post by Salesforce on December 13, 2018, titled Introducing Lightning Web Components, available <span class="No-Break">at </span><a href="https://developer.salesforce.com/blogs/2018/12/introducing-lightning-web-components"><span class="No-Break">https://developer.salesforce.com/blogs/2018/12/introducing-lightning-web-components</span></a><span class="No-Break">.</span></p>
			<p>When it comes to testing LWCs, we can take advantage of the fact that the architecture of this type of component is based on more common JavaScript standards and an open framework. This allows us to write our unit tests using the popular Jest testing <a id="_idIndexMarker175"/>framework (<a href="https://jestjs.io/">https://jestjs.io/</a>), which is already used in the wider JavaScript community outside of Salesforce too. Jest is itself written in JavaScript and uses the Node.js engine to execute, and npm for installation and to manage <span class="No-Break">its dependencies.</span></p>
			<p>In the Salesforce world, there is a plugin for the SFDX command line called <strong class="source-inline">sfdx-lwc-jest</strong> that makes it easy to add Jest and its dependencies to your <span class="No-Break">Salesforce projects.</span></p>
			<p>If you run the following command in your project directory, it will install the necessary npm tools and the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">salesforce/sfdx-lwc-jest</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
 sf force lightning lwc test setup</pre>			<p>With the capability to run Jest tests set up in your project, you next need to configure some tests for your LWCs. These tests are run locally on your development machine, independently of Salesforce, which makes it a lot easier to both run them at the development stage of your project and to include them as part of any test automation you add in your <span class="No-Break">DevOps pipeline.</span></p>
			<p>If you create an SFDX project using the standard template, it already has all these ready-to-write Jest tests. The <strong class="source-inline">project.json</strong> file is configured, as is <strong class="source-inline">.forceignore</strong>. This also creates a <strong class="source-inline">__tests__</strong> directory and a skeleton test file. However, if you have not created your project from the template, the steps for creating the appropriate structure are detailed next—in most cases, the template will take care of this <span class="No-Break">for you.</span></p>
			<p>Your first task should<a id="_idIndexMarker176"/> be to create a <strong class="source-inline">__tests__</strong> folder under the top-level folder of each component. For example, consider this example LWC <span class="No-Break">folder structure:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer015">
					<img alt="Figure 4.1 – Example LWC folder structure without tests" src="image/Figure_4.1_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Example LWC folder structure without tests</p>
			<p>In this example, adding the required <strong class="source-inline">__tests__</strong> folder would result in a structure <span class="No-Break">like this:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer016">
					<img alt="Figure 4.2 – The same LWC folder structure, with the test folder and file in place" src="image/Figure_4.2_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The same LWC folder structure, with the test folder and file in place</p>
			<p>You should also add a wildcarded path to the <strong class="source-inline">__tests__</strong> folder to your <strong class="source-inline">.forceignore</strong> file in your project since you shouldn’t deploy Jest tests to your Salesforce org—in fact, it will throw an error if you try to do this. Adding the following line to the <strong class="source-inline">.forceignore</strong> file should address <span class="No-Break">this issue:</span></p>
			<p><strong class="source-inline">**/</strong><span class="No-Break"><strong class="source-inline">__tests__/**</strong></span></p>
			<p>Next, you will need to add the following line to the <strong class="source-inline">scripts</strong> section in your project’s <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file:</span></p>
			<p><strong class="source-inline">"</strong><span class="No-Break"><strong class="source-inline">test:unit": "sfdx-lwc-jest"</strong></span></p>
			<p>Your project<a id="_idIndexMarker177"/> is now configured for running Jest tests, and we’ll now look at how to construct those tests for <span class="No-Break">your components.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor110"/>An example Jest test</h2>
			<p>Now that we have <a id="_idIndexMarker178"/>set up the <a id="_idIndexMarker179"/>prerequisites for running the Jest tests, we can look at a lightweight example test for our <strong class="source-inline">teamComponent</strong> component <span class="No-Break">shown previously:</span></p>
			<pre class="source-code">
import { createElement } from 'lwc';
import teamComponent from 'c/teamComponent';
describe('c-team-component', () =&gt; {
    afterEach(() =&gt; {
        // The jsdom instance is shared across test cases in a single 
        // file so reset the DOM
        while (document.body.firstChild) {
            document.body.removeChild(document.body.firstChild);
        }
    });
    it('renders the correct message', () =&gt; {
        const element = createElement('c-team-component', {
            is: teamComponent
        });
        document.body.appendChild(element);
        const pElement = element.shadowRoot.querySelector('p');
        expect(pElement.textContent).toBe('Welcome to the team!');
    });
});</pre>			<p>In this test class, we<a id="_idIndexMarker180"/> import the <strong class="source-inline">createElement</strong> function from LWC to create an instance of the <strong class="source-inline">teamComponent</strong> component, and then we use Jest’s <strong class="source-inline">describe</strong> and <strong class="source-inline">it</strong> functions to define a test case that checks that the component renders the <span class="No-Break">correct message.</span></p>
			<p>The <strong class="source-inline">afterEach</strong> function is used to reset the DOM between test cases, to ensure that each test case starts with a <span class="No-Break">clean slate.</span></p>
			<p>In the <strong class="source-inline">it</strong> function, we create an instance of the <strong class="source-inline">teamComponent</strong> component using <strong class="source-inline">createElement</strong>, add it to the DOM using <strong class="source-inline">document.body.appendChild</strong>, and then use <strong class="source-inline">querySelector</strong> to find the element that contains the message. Finally, we use Jest’s expect function to check that the text content of the <strong class="source-inline">p</strong> element is equal to <em class="italic">Welcome to </em><span class="No-Break"><em class="italic">the team!</em></span><span class="No-Break">.</span></p>
			<p>This is just an example and your test class will likely need to be more complex and cover additional use cases, but this should give you an idea of how to get started with writing<a id="_idIndexMarker181"/> unit tests for LWCs <a id="_idIndexMarker182"/>using Jest. Salesforce Trailhead has more detailed examples of testing your LWCs, including those that make use of <strong class="source-inline">@wire</strong> services. Now that we have our Jest tests written, let’s look at how we run the tests against <span class="No-Break">our code.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor111"/>Running your Jest tests</h2>
			<p>To test an LWC in a <a id="_idIndexMarker183"/>Salesforce<a id="_idIndexMarker184"/> project using Jest, you can follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Navigate to the root directory of your LWC component in <span class="No-Break">your terminal.</span></li>
				<li>Run the <strong class="source-inline">npm run test</strong> command. This will execute the Jest test runner and run any tests in the <strong class="source-inline">__tests__</strong> directory or in the same directory as the LWCs <span class="No-Break">being tested.</span></li>
				<li>The Jest test runner will display the results of the tests in your terminal. If any tests fail, the Jest runner will output detailed information about the <span class="No-Break">test failure.</span></li>
				<li>You can also run individual tests by specifying the name of the test file or test suite that you want to run. For example, you can run a test named <strong class="source-inline">teamComponent.test.js</strong> by running the <strong class="source-inline">npm run test </strong><span class="No-Break"><strong class="source-inline">teamComponent.test.js</strong></span><span class="No-Break"> command.</span></li>
				<li>You can use additional options to customize the behavior of Jest, such as running tests in <strong class="source-inline">watch</strong> mode or generating code coverage reports. You can find more information on Jest options in the <span class="No-Break">Jest documentation.</span></li>
			</ol>
			<p>At this point, we <a id="_idIndexMarker185"/>now have a means<a id="_idIndexMarker186"/> of testing our LWCs, but that’s only part of the puzzle. In the next section, we’ll start exploring how to test the main declarative tool that <span class="No-Break">Salesforce offers—flows.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor112"/>Testing your flows</h1>
			<p>Flows are another<a id="_idIndexMarker187"/> extremely common means of developing complex functionality in Salesforce, and while they fall into the <em class="italic">clicks not code</em> category of Salesforce development, it is just as important to provide them with rigorous testing as it is for <span class="No-Break">code-based solutions.</span></p>
			<p>In Flow Builder, you can test your flow without leaving the interface. The UI contains two buttons for testing your flow: Run and Debug. Let’s look at what <span class="No-Break">they do:</span></p>
			<ul>
				<li>The Run button executes the most recently saved version of the flow that is currently open in <span class="No-Break">the editor.</span></li>
				<li>The Debug button provides additional features beyond Run. In addition to running the flow, Debug allows you to input values for the flow’s input variables and view debug details during the flow’s execution. This allows you to verify how the flow processes data and identify any issues <span class="No-Break">or errors.</span></li>
			</ul>
			<p>Every time a flow runs in Salesforce, it initiates a flow interview. A flow interview is a unique instance of a flow that follows a specific path based on the parameters provided. These parameters can include input variables or components on a screen, which can lead the interview down different paths through the flow and trigger <span class="No-Break">different actions.</span></p>
			<p>By creating flow interviews that cover both positive and negative scenarios, you can test your flow’s criteria, much like you would with Apex testing. However, breaking a flow into smaller tests may be challenging, as a flow interview tests the entire flow rather than just one decision at a time. You may need to create multiple flow interviews to cover all possible paths through <span class="No-Break">the flow.</span></p>
			<p>To simplify testing and ensure comprehensive coverage, it may be beneficial to break up the flow into subflows where possible. This architectural approach can help create more manageable and efficient tests for <span class="No-Break">your flow.</span></p>
			<p>As of the Summer ’22 Salesforce release, it is possible to convert these flow interviews into flow tests. After successfully executing a flow interview in the flow debugger in Salesforce, you will see a <strong class="bold">Convert to Test</strong> action appear in the top-right corner of the page, next to <strong class="bold">Edit Flow</strong>. To convert the debug run to a flow test, click on <strong class="bold">Convert to Test</strong>, and a new test screen will appear in a modal window. You can create up to 200 tests per flow, so it should be possible to create a test for <a id="_idIndexMarker188"/>every path your flow <span class="No-Break">can take:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 4.3 – Creating a new flow test" src="image/Figure_4.3_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Creating a new flow test</p>
			<p>During testing of a flow in Salesforce, each assertion is evaluated to confirm that the flow behaves as intended, as illustrated in the following screenshot. However, it’s important to note that a test can only verify whether a flow element was executed and whether the flow resource values were <span class="No-Break">correctly set:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer018">
					<img alt="Figure 4.4 – Providing assertions for our new test, to validate our flow" src="image/Figure_4.4_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Providing assertions for our new test, to validate our flow</p>
			<p>At the time of writing, there are some important considerations around flow tests that an architect <a id="_idIndexMarker189"/>should consider when assessing them as part of an overall <span class="No-Break">DevOps design:</span></p>
			<ul>
				<li>Flow tests are available only for <span class="No-Break">record-triggered flows</span></li>
				<li>Flow tests don’t support flows that run when a record <span class="No-Break">is deleted</span></li>
				<li>Flow tests don’t support flow paths that <span class="No-Break">run asynchronously</span></li>
				<li>Flow tests cannot be automatically triggered as part of <span class="No-Break">a deployment</span></li>
				<li>Flow tests can be based upon specific record IDs, but this can make the tests fragile since record IDs are not guaranteed to exist in <span class="No-Break">other environments</span></li>
				<li>Flow tests don’t count toward flow test <span class="No-Break">coverage requir<a id="_idTextAnchor113"/>ements</span></li>
				<li>This last point is of particular note because if you want to be able to deploy flows as <strong class="bold">Active</strong>, they need to have test coverage in just the same way that Apex code requires coverage (and at the same minimum level <span class="No-Break">of 75%)</span></li>
			</ul>
			<p>The process for this is less mature than that for code, but as a guide, for active processes and autolaunched flows, there is a requirement that at least one Apex test must achieve the required test coverage percentage of the flow tests. However, it’s important to note that flow test coverage requirements do not apply to flows that <span class="No-Break">include screens.</span></p>
			<p>The lack of maturity in flow testing is largely around the absence of consistency between the flow tests that you can generate in the Flow Builder UI versus the tests required for coverage. Not only do these tests need to be written in code as Apex unit tests, but to see the current state of code coverage for the flows in your org, you need to query the <strong class="source-inline">FlowTestCoverage</strong> object—for example, from the <span class="No-Break">Developer Console.</span></p>
			<p>To determine the test coverage of your flows in Salesforce, you need to consider all active versions, regardless of whether they have test coverage or not, and all inactive versions that are the latest versions and have test coverage. Here are example queries for this purpose—to run them, you will need to ensure the <strong class="bold">Use Tooling API</strong> box is checked in the <span class="No-Break">Developer Console.</span></p>
			<p>First, you need to determine the number of flows (the latest versions of each) that have test coverage, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
SELECT count_distinct(FlowVersionId)
FROM FlowTestCoverage</pre>			<p>Then, get the number of all active versions of flows—with or without test coverage—plus the inactive versions that are the latest versions that have <span class="No-Break">test coverage:</span></p>
			<pre class="source-code">
SELECT count_distinct(Id)
FROM Flow
WHERE Status = 'Active' AND Id NOT IN (
    SELECT FlowVersionId
    FROM FlowTestCoverage )</pre>			<p>To determine the test<a id="_idIndexMarker190"/> coverage percentage for your Salesforce flows, divide the count of the most recent flow versions with test coverage (second script) by the overall sum of active and inactive versions that possess test coverage, incorporating those lacking test coverage as well (initial script). If all this sounds unnecessarily complicated, you’d be right, and we can only hope that this area improves with subsequent <span class="No-Break">Salesforce releases.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor114"/>Summary</h1>
			<p>In this chapter, we looked at the reasons why testing your changes is a core principle of Salesforce DevOps. We also dove into some example tests, showing the differences in how they are constructed, depending on the approach you used to implement your Salesforce functionality—Apex code, LWC, <span class="No-Break">or flows.</span></p>
			<p>Now that we’ve looked at some of the building blocks of architecting a Salesforce DevOps process—culture, version control, and robust testing—in the next chapter, we’ll start to look at how we bring these elements together by looking at some example workflows and scenarios of day-to-day delivery using the SFDX tool and Git. While these tools are one of many approaches to Salesforce DevOps, you’ll benefit from seeing some of the principles we’ve discussed as real-world examples, which will bring a typical workflow <span class="No-Break">to life.</span></p>
		</div>
	</body></html>