- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Networking in Linux
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux中的网络
- en: 'Networking is a complex topic no matter the operating system. Linux, in terms
    of its flexibility, can be very overwhelming regarding the multitude of possibilities
    of configuration, kernel features, and command-line tools that can help us configure
    those options. In this chapter, we will lay the foundation for this topic so that
    you can search for more information on a specific topic in other publications.
    In this chapter, we are going to cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是一个复杂的话题，无论在哪个操作系统上都是如此。就灵活性而言，Linux在配置、内核功能和命令行工具的众多可能性上可能让人感到非常不知所措，这些工具可以帮助我们配置这些选项。在本章中，我们将为这个话题奠定基础，以便您可以在其他出版物中查找有关特定主题的更多信息。在本章中，我们将涵盖以下主题：
- en: Networking in Linux
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux中的网络
- en: ISO/OSI as a networking standard
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ISO/OSI作为网络标准
- en: Firewalls
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防火墙
- en: Advanced topics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级话题
- en: Networking in Linux
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux中的网络
- en: In Linux, networking is implemented in the kernel, which means that it is a
    part of the operating system. The kernel includes several components that work
    together to enable networking, including device drivers, protocol implementations,
    and system calls.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，网络是通过内核实现的，这意味着它是操作系统的一部分。内核包括几个组件，这些组件协同工作以实现网络功能，包括设备驱动程序、协议实现和系统调用。
- en: When a user wants to send or receive data over a network, they can do so using
    any of the networking applications available in Linux, such as `ping`, `traceroute`,
    `telnet`, or `ssh`. These applications use system calls to communicate with the
    kernel and request that data be sent or received over the network.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户想要通过网络发送或接收数据时，他们可以使用Linux中任何可用的网络应用程序，如`ping`、`traceroute`、`telnet`或`ssh`。这些应用程序使用系统调用与内核通信，并请求通过网络发送或接收数据。
- en: The kernel communicates with the network hardware using device drivers, which
    are software programs that allow the kernel to access and control the hardware.
    Different drivers are needed for different types of network hardware, such as
    Ethernet or Wi-Fi.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 内核通过设备驱动程序与网络硬件进行通信，设备驱动程序是软件程序，使得内核能够访问和控制硬件。不同类型的网络硬件需要不同的驱动程序，例如以太网或Wi-Fi。
- en: The kernel also implements several networking protocols, which are rules and
    standards that define how data is formatted and transmitted over the network.
    Common protocols used in Linux include TCP, UDP, and IP (version `4` and version
    `6`).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内核还实现了几个网络协议，这些协议是定义如何在网络上传输和格式化数据的规则和标准。Linux中常用的协议包括TCP、UDP和IP（版本`4`和版本`6`）。
- en: ISO/OSI as a networking standard
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ISO/OSI作为网络标准
- en: The starting point of any discussion about networks always starts with the reference
    model defined by the **International Organization for Standardization/Open Systems
    Interconnection** (**ISO/OSI**). The ISO/OSI reference model is a conceptual model
    that defines a networking framework to implement protocols in seven layers. It
    is a framework that allows us to view communications between systems (computer
    or otherwise) as separate from the actual physical and software structure underlying
    it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络的任何讨论总是从**国际标准化组织/开放系统互联**（**ISO/OSI**）定义的参考模型开始。ISO/OSI参考模型是一个概念模型，定义了一个网络框架，用于在七层中实现协议。它是一个框架，让我们可以将系统（计算机或其他）之间的通信与其实际的物理和软件结构区分开来看。
- en: In Linux, the OSI model is implemented through a series of software components
    that are responsible for performing the functions of each layer. These components
    work together to enable networking capabilities in Linux.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，OSI模型是通过一系列软件组件来实现的，这些组件负责执行每一层的功能。这些组件共同作用，实现Linux中的网络功能。
- en: 'The seven layers of the OSI model that are implemented in Linux are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中实现的OSI模型的七层如下：
- en: Physical
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理层
- en: Data link
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据链路
- en: Network
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络层
- en: Transport
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层
- en: Session
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话层
- en: Presentation
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示层
- en: Application
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层
- en: In a system running in the cloud, you will have access to all the layers that
    are implemented in the Linux kernel. These layers are Network, Transport. Session,
    Presentation, and Application. To debug network connectivity, check statistics,
    and find any other possible issues, Linux has a console tool you can use. Let’s
    go through every layer one by one and investigate what command-line tools we can
    use in Linux to investigate each of them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行在云端的系统中，您将访问到Linux内核中实现的所有层。这些层包括网络层、传输层、会话层、表示层和应用层。为了调试网络连接、检查统计信息并找出任何其他可能的问题，Linux提供了一个控制台工具。让我们逐一查看每一层，研究我们可以在Linux中使用哪些命令行工具来检查它们。
- en: To learn more about the OSI model, you can refer to [https://osi-model.com/](https://osi-model.com/).
    We are going to delve into the layers and explain them in the following subsections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 OSI 模型的信息，可以参考 [https://osi-model.com/](https://osi-model.com/)。我们将在接下来的子节中深入探讨这些层并对其进行解释。
- en: Physical layer
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理层
- en: This layer is responsible for transmitting raw bits over a communication channel
    and is implemented through device drivers that control the network hardware, such
    as Ethernet standards such as `10BASE-T`, `10BASE2`, `10BASE5`, `100BASE-TX`,
    `100BASE-FX`, `100BASE-T`, `1000BASE-T`, and others. We will not look at this
    layer in more detail here as we will focus on software implementation and how
    to interact with it on the Linux console. You can find plenty of information about
    cabling, hardware devices, and networking online.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层负责通过通信通道传输原始比特，并通过设备驱动程序来实现，这些驱动程序控制网络硬件，例如以太网标准，如 `10BASE-T`、`10BASE2`、`10BASE5`、`100BASE-TX`、`100BASE-FX`、`100BASE-T`、`1000BASE-T`
    等。由于我们将专注于软件实现以及如何在 Linux 控制台上与其交互，因此在这里不会进一步讨论这一层。你可以在网上找到大量关于电缆、硬件设备和网络的信息。
- en: Data link layer – MAC, VLAN
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据链路层 – MAC，VLAN
- en: The **data link layer** is responsible for providing a reliable link between
    devices on a network. It’s divided into the **Logical Link Control** (**LLC**)
    sublayer and the **Media Access Control** (**MAC**) sublayer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据链路层**负责在网络上的设备之间提供可靠的链路。它分为**逻辑链路控制**（**LLC**）子层和**媒体访问控制**（**MAC**）子层。'
- en: The data link layer takes the raw data from the network layer (layer 3) and
    converts it into a format that can be transmitted over the physical link. It also
    provides error detection and correction, flow control, and MAC functions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层将来自网络层（第 3 层）的原始数据转换为可以通过物理链路传输的格式。它还提供错误检测和校正、流量控制以及 MAC 功能。
- en: The LLC sublayer provides a consistent interface to the network layer, regardless
    of the type of physical network being used. It also provides flow control and
    error correction services.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: LLC 子层为网络层提供一致的接口，不论使用何种类型的物理网络。它还提供流量控制和错误校正服务。
- en: The MAC sublayer controls access to the physical network and provides addressing
    services. It uses MAC addresses, which are unique identifiers that are assigned
    to each device on a network, to ensure that data is delivered to the correct destination.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: MAC 子层控制对物理网络的访问并提供寻址服务。它使用 MAC 地址，这是分配给网络上每个设备的唯一标识符，确保数据能传送到正确的目的地。
- en: The data link layer also includes the use of protocols such as Ethernet, PPP,
    and Frame Relay to provide communication between devices on a network. It also
    provides a mechanism for flow and error control – for example, it uses a **cyclic
    redundancy check** (**CRC**) for error detection and a sliding window for flow
    control.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层还包括使用协议，如以太网、PPP 和帧中继，以在网络上提供设备间的通信。它还提供流量和错误控制机制—例如，它使用**循环冗余校验**（**CRC**）进行错误检测，并使用滑动窗口进行流量控制。
- en: 'Several Linux command-line tools can be used to debug data link layer problems.
    Here are a few examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个 Linux 命令行工具可用于调试数据链路层问题。以下是一些示例：
- en: '`ifconfig`: This command can be used to view the status of network interfaces
    and their associated IP addresses, netmasks, and MAC addresses. It can also be
    used to configure network interfaces, such as setting an IP address or enabling
    or disabling an interface.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifconfig`：此命令可用于查看网络接口的状态及其相关的 IP 地址、子网掩码和 MAC 地址。它还可以用来配置网络接口，例如设置 IP 地址或启用或禁用接口。'
- en: '`ping`: This command can be used to test the reachability of a host on a network.
    It sends an **Internet Control Message Protocol** (**ICMP**) echo request packet
    to the specified host and waits for an echo reply. If the host responds, it indicates
    that the host is reachable and that the data link layer is functioning properly.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ping`：此命令可用于测试网络中主机的可达性。它向指定主机发送一个**互联网控制消息协议**（**ICMP**）回显请求数据包，并等待回显响应。如果主机响应，则表明主机可达，并且数据链路层工作正常。'
- en: '`traceroute`, `tracepath`, and `mtr`: These commands can be used to trace the
    route that packets take from the source to the destination. They can also be used
    to identify any network hops or devices that may be causing problems. Additionally,
    `tracepath` measures the `mtr`, on the other hand, provides more information about
    network health.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`traceroute`、`tracepath`和`mtr`：这些命令可以用来追踪数据包从源到目的地的路径。它们还可以用来识别任何可能导致问题的网络跳数或设备。此外，`tracepath`可以测量`mtr`，而`mtr`则提供更多关于网络健康的信息。'
- en: '`arp`: This command can be used to view and manipulate the **Address Resolution
    Protocol** (**ARP**) cache. ARP is used to map an IP address to a MAC address
    on a local network. This command can be used to verify that the correct IP-MAC
    address mappings are in the ARP cache.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arp`：此命令可用于查看和操作**地址解析协议**（**ARP**）缓存。ARP用于将IP地址映射到本地网络上的MAC地址。此命令可以用来验证ARP缓存中是否有正确的IP-MAC地址映射。'
- en: '`ethtool`: This command can be used to view and configure advanced settings
    on Ethernet interfaces such as link speed, duplex mode, and auto-negotiation settings.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ethtool`：此命令可用于查看和配置以太网接口的高级设置，如链路速度、双工模式和自动协商设置。'
- en: '`tcpdump`: This command can be used to capture and analyze network packets
    in real time. It can be used to troubleshoot problems such as packet loss, delayed
    packets, and network congestion.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tcpdump`：此命令可用于实时捕获和分析网络数据包。它可以用来排查诸如数据包丢失、延迟包和网络拥堵等问题。'
- en: We will dive deeper into the preceding tools in the next sections of this chapter
    as most of them can be used to look into several different OSI layers at once.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的接下来的部分中深入探讨前述工具，因为大多数工具可以用于同时查看多个OSI层。
- en: Network layer – IPv4 and IPv6
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络层 – IPv4和IPv6
- en: 'Each device on a public (internet) or private (your office or home) network
    has a unique address that is used to identify it and connect to it. When you send
    a request to a website, your device sends a message to the destination server
    using its address. The server then responds by sending a message back to your
    device using its address. This process is how devices communicate with each other
    over the internet. There are two types of addresses we use: IPv6 and IPv4\. `v4`
    (version `4`) and `v6` (version `6`) is the number of addresses you can use.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个公有（互联网）或私有（你的办公室或家里）网络上的设备都有一个唯一地址，用于识别它并与之连接。当你向一个网站发送请求时，你的设备会使用其地址向目标服务器发送消息。服务器随后会使用其地址向你的设备发送消息以响应。这一过程就是设备通过互联网互相通信的方式。我们使用的地址有两种类型：IPv6和IPv4。`v4`（版本`4`）和`v6`（版本`6`）是你可以使用的地址数量。
- en: IPv4 is the most widely used version of IP and there are only about 4.3 billion
    unique addresses available. However, this is not enough to support the increasing
    number of devices that are being connected to the internet. To address this issue,
    a new version of IP called IPv6 was developed to provide a much larger address
    space.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4是最广泛使用的IP版本，但只有大约43亿个唯一地址可用。然而，这些地址不足以支持不断增加的连接到互联网的设备数量。为了解决这个问题，开发了一种新的IP版本——IPv6，提供了更大的地址空间。
- en: IPv4 addresses are 32-bit numbers that are usually represented in a dotted decimal
    notation, with four octets ranging from `0` to `255`. For example, `192.168.0.1`
    or `1.2.3.4` are valid IPv4 addresses.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: IPv4地址是32位数字，通常以点分十进制表示，包含四个范围从`0`到`255`的八位字节。例如，`192.168.0.1`或`1.2.3.4`都是有效的IPv4地址。
- en: IPv6 addresses are 128-bit numbers (between `zero` and `FFFF` in hexadecimal,
    which is equal to the decimal value `65535`), represented in hexadecimal notation
    with eight groups of four hexadecimal digits separated by colons. An example of
    an IPv6 address is `2001:0db8:bad:f00d:0000:dead:beef:7331`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6地址是128位数字（在十六进制中介于`zero`和`FFFF`之间，等于十进制值`65535`），以十六进制表示，采用八组四个十六进制数字，并以冒号分隔。IPv6地址的示例为`2001:0db8:bad:f00d:0000:dead:beef:7331`。
- en: We’re mainly going to focus on IPv4 here as it’s generally easier to understand,
    but similar principles work for IPv6, so it’s going to be easier to reapply what
    we’ll learn later in this chapter to the IPv6 world.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里主要关注IPv4，因为它通常更容易理解，但类似的原则也适用于IPv6，因此稍后我们将在本章中学到的内容更容易重新应用到IPv6环境中。
- en: Subnets, classes, and network masks
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子网、类别和网络掩码
- en: '**Subnets** are pieces of a network that are created by dividing a larger network
    into smaller networks. This is done for several reasons, including security, organization,
    and the efficient use of IP addresses. In public internet networks, every organization
    *owns* a piece of the network – a subnet.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网** 是通过将一个较大的网络划分成更小的网络而创建的网络片段。这么做的原因有很多，包括安全性、组织结构以及高效利用 IP 地址。在公共互联网网络中，每个组织都有自己的一部分网络——一个子网。'
- en: 'When a network is subnetted, the host portion of the IP address (the part of
    the address that identifies a specific device on the network) is divided into
    two parts: one that identifies the subnet and one that identifies the host IPs
    within the subnet. The subnet mask, which is a binary representation that is applied
    to the IP address, is used to determine which part of the IP address identifies
    the subnet and which part identifies the host.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个网络被划分成子网时，IP 地址中的主机部分（标识网络中具体设备的部分）会被分成两部分：一部分标识子网，另一部分标识子网内的主机 IP 地址。子网掩码是应用于
    IP 地址的二进制表示，用于确定 IP 地址中哪一部分标识子网，哪一部分标识主机。
- en: Imagine a network that uses the IP address range `192.168.11.0/24` (or `192.168.11.0/255.255.255.0`
    in decimal form). The `/24` part is a `24`) and `host`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个使用 IP 地址范围 `192.168.11.0/24`（或 `192.168.11.0/255.255.255.0` 的十进制形式）的网络。`/24`
    部分表示 `24` 位网络部分和 `8` 位主机部分。
- en: This means that this particular network has 24 bits (or three numbers from the
    full address) for the `network` portion of the IP address and 8 bits (or one,
    last, number) for the `host` portion. So, for this network, you’ll have an available
    range of `192.168.11.0 - 192.168.11.255`, where `192.168.11.0` is a network address
    and `192.168.11.255` is a broadcast address.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着该网络的 IP 地址有 24 位（或地址中的前三个数字）用于 `网络` 部分，8 位（或最后一个数字）用于 `主机` 部分。所以，对于这个网络，你将有一个可用的地址范围
    `192.168.11.0 - 192.168.11.255`，其中 `192.168.11.0` 是网络地址，`192.168.11.255` 是广播地址。
- en: A **broadcast network address** is a special type of IP address that is used
    to send a message to all hosts on a particular network or subnet. The broadcast
    address is the highest in a network or subnet’s IP address range, and it is used
    in conjunction with the subnet mask to identify the broadcast domain. When a host
    sends a packet to a broadcast address, the packet is delivered to all hosts on
    the same network or subnet. It’s important to note that broadcast packets don’t
    leave the current subnet network – they only work within the local network or
    subnet.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**广播网络地址** 是一种特殊类型的 IP 地址，用于向特定网络或子网中的所有主机发送信息。广播地址是网络或子网 IP 地址范围中的最高地址，并与子网掩码一起使用，以标识广播域。当主机将数据包发送到广播地址时，该数据包将被送到同一网络或子网中的所有主机。需要注意的是，广播数据包不会离开当前的子网网络——它们仅在本地网络或子网内起作用。'
- en: 'Before standardizing CIDR, IP addresses were divided into classes (`A`, `B`,
    and `C`) based on the number of hosts that a network needed to support. These
    classes were defined by the leading bits of the IP address, and each class had
    a different number of bits for the network portion and host portion of the IP
    address. Right now, we’re mainly using CIDRs, but some network addressing remains.
    For example, `10.0.0.0`, `12.0.0.0`, or `15.0.0.0` usually have `255.0.0.0` or
    `/8` network masks. Here are some other networks you could encounter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准化 CIDR 之前，IP 地址根据网络需要支持的主机数量被分为不同的类别（`A`、`B` 和 `C`）。这些类别是根据 IP 地址的前导位来定义的，每个类别有不同数量的位用于网络部分和主机部分。目前我们主要使用
    CIDR，但一些网络地址仍然存在。例如，`10.0.0.0`、`12.0.0.0` 或 `15.0.0.0` 通常具有 `255.0.0.0` 或 `/8`
    网络掩码。以下是你可能会遇到的一些其他网络：
- en: '`10.0.0.0/8`, `12.0.0.0/8`, and `15.0.0.0/8`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10.0.0.0/8`、`12.0.0.0/8` 和 `15.0.0.0/8`'
- en: '`172.16.0.0/16`, `172.17.0.0/16`, and `172.18.0.0/16`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`172.16.0.0/16`、`172.17.0.0/16` 和 `172.18.0.0/16`'
- en: '`192.168.0.0/24`, `192.168.1.0/24`, and `192.168.2.0/24`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.0.0/24`、`192.168.1.0/24` 和 `192.168.2.0/24`'
- en: These examples are not actual networks, but just a representation of how to
    identify the network class by looking at the leading bits of the IP address and
    the subnet mask – it’s not a rule and you could create smaller (or bigger) networks
    within your infrastructure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子并不是实际的网络，而仅仅是通过查看 IP 地址的前导位和子网掩码来识别网络类别的表示——这并不是一种规则，你可以在你的基础设施中创建更小（或更大）的网络。
- en: 'You can find a lot of calculators online that will help you better understand
    how networks address work. Here are some examples:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在网上找到许多计算器，帮助你更好地理解网络地址是如何工作的。这里有一些例子：
- en: '[https://www.calculator.net/ip-subnet-calculator.xhtml](https://www.calculator.net/ip-subnet-calculator.xhtml)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.calculator.net/ip-subnet-calculator.xhtml](https://www.calculator.net/ip-subnet-calculator.xhtml)'
- en: '[https://mxtoolbox.com/subnetcalculator.aspx](https://mxtoolbox.com/subnetcalculator.aspx)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://mxtoolbox.com/subnetcalculator.aspx](https://mxtoolbox.com/subnetcalculator.aspx)'
- en: '[https://www.subnet-calculator.com/cidr.php](https://www.subnet-calculator.com/cidr.php)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.subnet-calculator.com/cidr.php](https://www.subnet-calculator.com/cidr.php)'
- en: Now that we have learned about subnets, classes, and network masks, let’s move
    on to the next subsection.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经学习了子网、类别和网络掩码，那么接下来让我们进入下一个小节。
- en: Network configuration and console tools
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络配置和控制台工具
- en: With the knowledge you’ve gained so far, you can easily check your Linux network
    configuration using some CLI tools that are available in every modern Linux environment.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过你目前所掌握的知识，你可以轻松地使用一些在现代 Linux 环境中都可用的命令行工具来检查你的 Linux 网络配置。
- en: 'Here are some basic console tools to use for network configuration:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些用于网络配置的基本控制台工具：
- en: The `iproute2` package, replacing the `ifconfig` and `route` commands
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iproute2` 包，取代了 `ifconfig` 和 `route` 命令'
- en: '`ifconfig`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ifconfig`'
- en: '`route`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`route`'
- en: '`ip`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip`'
- en: '`netplan`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`netplan`'
- en: Let’s go through the syntax and what’s possible while using these tools.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起了解这些工具的语法以及使用它们时可能实现的功能。
- en: ifconfig
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ifconfig
- en: One of the commands that’s usually available in Linux is `ifconfig`. This tool
    is used to configure network interfaces. It can be used to show the status of
    an interface, assign an IP address to an interface, set the netmask, and set the
    default gateway. `ifconfig` (from the net-tools package) was replaced in recent
    years with the `iproute2` set of tools; the most well-known CLI command from this
    package is `ip`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 中，通常可用的命令之一是`ifconfig`。这个工具用于配置网络接口。它可以用来显示接口的状态、为接口分配 IP 地址、设置网络掩码以及设置默认网关。`ifconfig`（来自
    net-tools 包）在近年来被 `iproute2` 工具集所取代；这个包中最著名的命令是 `ip`。
- en: 'Here’s some example output of the `ifconfig` command:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `ifconfig` 命令的示例输出：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`ifconfig`, when invoked without any additional options, will list all available
    interfaces in our system with some basic information such as interface name (here,
    these are `eth0` and `lo`), the MAC address of the network card (the physical
    address of your device), network configuration (IP address, network mask, and
    broadcast address), received and transmitted packets, and other information. This
    will allow you to check your network status at a glance.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有任何额外选项时，执行 `ifconfig` 会列出系统中所有可用的接口，并显示一些基本信息，如接口名称（这里是 `eth0` 和 `lo`）、网卡的
    MAC 地址（设备的物理地址）、网络配置（IP 地址、网络掩码和广播地址）、接收和发送的包，以及其他信息。这将让你一眼查看网络状态。
- en: The loopback device (named `lo` in the preceding example) is a virtual network
    interface that is used to send network packets to the same host that they were
    sent from. It is also known as the loopback interface and is represented by `lo`
    or `lo0`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 回环设备（在上面的示例中命名为 `lo`）是一个虚拟网络接口，用于将网络数据包发送回同一个发送源的主机。它也被称为回环接口，并由 `lo` 或 `lo0`
    表示。
- en: The primary purpose of the loopback device is to provide a stable and consistent
    way for the host to communicate with itself over the network stack, without having
    to rely on any physical network interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 回环设备的主要作用是为主机提供一种稳定且一致的方式，通过网络栈与自身进行通信，而不需要依赖任何物理网络接口。
- en: The loopback interface is typically used for testing, troubleshooting, and some
    system and application functions, as well as **inter-process communication** (**IPC**)
    between processes running on the same host.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 回环接口通常用于测试、故障排除和一些系统与应用程序功能，以及**进程间通信**（**IPC**），尤其是在同一主机上运行的进程之间。
- en: 'Using `ifconfig` will also allow you to bring some interfaces up and down and
    configure their settings. To persist the configuration, you will need to save
    it to the `/``etc/network/interfaces` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ifconfig` 还可以让你启用或禁用某些接口并配置它们的设置。要使配置保持有效，你需要将其保存到`/etc/network/interfaces`
    文件中：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, we’re setting an automatic loopback device with `eth0`
    and `eth1`. The `eth0` interface has a static network configuration and will be
    also configured, the same as `lo`, when your system boots. The `eth1` interface
    has a dynamic network configuration that’s retrieved by the `allow-hotplug` configuration
    means that this device will be started upon detection by the Linux kernel.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们设置了一个自动回环设备，分别为`eth0`和`eth1`。`eth0`接口具有静态网络配置，并将在系统启动时像`lo`一样进行配置。`eth1`接口具有动态网络配置，它是通过`allow-hotplug`配置获取的，这意味着该设备将在Linux内核检测到后启动。
- en: It’s useful to know that after editing the `/etc/network/interfaces` file, you’ll
    need to use either `ifup` or `ifdown` tools on Debian Linux or Ubuntu Linux, or
    `ifupdown` tools in Alpine Linux. Alternatively, you can restart networking by
    using the `systemctl restart` network on Debian Linux, Ubuntu Linux, or RHEL/CentOS.
    You must use the `rc-service` networking `restart` command on Alpine Linux.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 需要知道的是，在编辑`/etc/network/interfaces`文件后，您需要在Debian Linux或Ubuntu Linux中使用`ifup`或`ifdown`工具，或者在Alpine
    Linux中使用`ifupdown`工具。或者，您可以通过在Debian Linux、Ubuntu Linux或RHEL/CentOS中使用`systemctl
    restart`网络来重启网络。必须在Alpine Linux中使用`rc-service`网络`restart`命令。
- en: 'To manually configure a device using `ifconfig`, you’ll need to run the following
    commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`ifconfig`手动配置设备，您需要运行以下命令：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will configure the `eth0` interface with a `192.168.1.2` IP address for
    the network with a netmask of `255.255.255.0` (or `/24` in CIDR notation).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为`eth0`接口配置一个`192.168.1.2`的IP地址，网络的子网掩码为`255.255.255.0`（或CIDR表示法中的`/24`）。
- en: Instead of using the `ifconfig up` and `ifconfig down` commands, you can also
    use `ifup` and `ifdown` in Debian Linux and Ubuntu Linux systems, respectively,
    or `ifupdown` in Arch Linux systems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在Debian Linux和Ubuntu Linux系统中，您可以使用`ifup`和`ifdown`代替`ifconfig up`和`ifconfig
    down`命令，或者在Arch Linux系统中使用`ifupdown`。
- en: route
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: route
- en: The `route` command is used to view and manipulate the IP routing table. It’s
    used to determine where network packets are sent given the destination IP addresses.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`route`命令用于查看和操作IP路由表。它用于确定网络数据包在给定目标IP地址下的发送位置。'
- en: 'Invoking the `route` command without any options will display the current route
    table in our system:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在不带任何选项的情况下调用`route`命令将显示系统中的当前路由表：
- en: '[PRE3]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To add a new entry to the routing table, use the following command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要向路由表添加新条目，请使用以下命令：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'There can be only one default route. To add a custom route, do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 只能有一个默认路由。要添加自定义路由，请执行以下操作：
- en: '[PRE5]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `del` command deletes an entry from the routing table, similar to the preceding
    example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`del`命令用于从路由表中删除条目，类似于前面的示例：'
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, the `flush` command deletes all entries from the routing table, which
    means you will lose all network connections and if you are connected to a remote
    machine, you won’t be able to work on it anymore.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`flush`命令会删除路由表中的所有条目，这意味着您将失去所有网络连接，如果您连接到远程机器，您将无法再对其进行操作。
- en: There are more possibilities while using the `ifconfig` and `route` commands,
    but as we’ve already stated, both commands got replaced by the `iproute2` package
    (a successor of `iproute`), which includes the `ip` command.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ifconfig`和`route`命令还有更多的可能性，但正如我们之前所说，两个命令都被`iproute2`包（`iproute`的继任者）取代，该包包括`ip`命令。
- en: iproute2
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: iproute2
- en: A more advanced command to manipulate routes and the configuration of network
    devices is `ip`, which can be used to perform a wider range of tasks, such as
    creating and deleting interfaces, adding and removing routes, and displaying network
    statistics.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的命令用于操作路由和网络设备的配置是`ip`，它可以用来执行更广泛的任务，如创建和删除接口、添加和删除路由以及显示网络统计信息。
- en: 'Let’s look at the most common commands you can perform using `iproute2`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看使用`iproute2`时可以执行的最常见命令：
- en: '`ip addr` or `ip a`: This shows information about network interfaces and their
    IP addresses. It also supports subcommands; for instance, the `ip addr add` command
    can be used to add an IP address to an interface, and `ip route add` can be used
    to add a route to the routing table.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip addr`或`ip a`：此命令显示有关网络接口及其IP地址的信息。它还支持子命令；例如，`ip addr add`命令可用于向接口添加IP地址，而`ip
    route add`可用于向路由表中添加路由。'
- en: '`ip link` or `ip l`: This shows information about network interfaces and their
    link-layer settings.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip link`或`ip l`：此命令显示有关网络接口及其链路层设置的信息。'
- en: '`ip route` or `ip r`: This shows the IP routing table.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip route`或`ip r`：此命令显示IP路由表。'
- en: '`ip -s link` (or `ip -s l`): This shows statistics about network interfaces.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip -s link`（或`ip -s l`）：这将显示关于网络接口的统计信息。'
- en: 'The following is the output of running the `ip link` and `ip` `addr` commands:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是运行`ip link`和`ip` `addr`命令的输出：
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Both commands print out very similar information, but `ip addr`, apart from
    providing information about physical interfaces, adds information about network
    configuration. The `ip link` command is being used to control the interface status.
    Similar to how `ifconfig up eth0` was enabling the interface, `ip link set dev
    eth0 up` will do the same.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 两个命令打印出非常相似的信息，但`ip addr`除了提供物理接口的信息外，还添加了有关网络配置的信息。`ip link`命令用于控制接口状态。与`ifconfig
    up eth0`启用接口类似，`ip link set dev eth0 up`也会做同样的事情。
- en: 'To configure a network interface using `iproute2`, you will need to execute
    the following commands:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`iproute2`配置网络接口，你需要执行以下命令：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To set the interface as the default route, use the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要将接口设置为默认路由，请使用以下命令：
- en: '[PRE9]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To check only the `eth0` interface’s status, you’d execute the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅检查`eth0`接口的状态，你可以执行以下命令：
- en: '[PRE10]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: netplan
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: netplan
- en: This tool is a new network configuration tool that was introduced in Ubuntu
    and is supported in Debian. It is a YAML configuration file and can be used to
    manage network interfaces, IP addresses, and other network settings. It was first
    introduced in Ubuntu 17.10 as a replacement for the traditional `/etc/network/interfaces`
    file and has since been adopted by other distributions. such as Debian and Fedora.
    Ubuntu 18.04 and newer versions have `netplan` installed by default. Other distributions,
    such as Debian 10 and Fedora 29 onwards, have also included `netplan` by default.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具是Ubuntu中引入的新网络配置工具，并且在Debian中也得到了支持。它是一个YAML配置文件，可用于管理网络接口、IP地址和其他网络设置。它首次在Ubuntu
    17.10中作为传统`/etc/network/interfaces`文件的替代品被引入，随后也被其他发行版（如Debian和Fedora）采纳。Ubuntu
    18.04及更高版本默认安装了`netplan`，其他发行版如Debian 10和Fedora 29及更高版本也默认包含了`netplan`。
- en: To use Netplan, you will first need to create a configuration file in the `/etc/netplan/`
    directory. The file should have a `.yaml` extension and should be named something
    descriptive, such as `01-eth0.yaml` or `homenetwork.yaml`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Netplan，你首先需要在`/etc/netplan/`目录中创建一个配置文件。该文件应具有`.yaml`扩展名，并且应该命名为具有描述性的名称，如`01-eth0.yaml`或`homenetwork.yaml`。
- en: 'The sample configuration looks like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 样本配置如下所示：
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This configuration defines a single network interface, `eth0`, that uses DHCP
    to obtain an IP address. The `renderer` key tells netplan which network manager
    to use (in this case, `networkd`). The `version` key is used to indicate the version
    of `netplan` being used. `networkd` is a network management daemon that is part
    of the `systemd` system and service manager.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置定义了一个单一的网络接口`eth0`，它使用DHCP获取IP地址。`renderer`键指定了netplan使用的网络管理器（在本例中为`networkd`）。`version`键用于表示正在使用的`netplan`版本。`networkd`是`systemd`系统和服务管理器的一部分，用于网络管理的守护进程。
- en: 'A configuration with a static IP address for the `eth0` interface would look
    like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为`eth0`接口配置静态IP地址的配置文件将如下所示：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This configuration file defines one ethernet interface (`eth0`) with a static
    IP address. This interface also has a gateway and DNS servers defined. Note that
    we’ve used a CIDR notation instead of a decimal one.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置文件定义了一个以太网接口（`eth0`）及其静态IP地址。此接口还定义了网关和DNS服务器。注意，我们使用了CIDR表示法，而不是十进制表示法。
- en: 'Once you saved your configuration, to apply the changes, you can run the following
    command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你保存了配置文件，为了应用更改，可以运行以下命令：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You can also use the following command to check the configuration for syntax
    errors:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用以下命令检查配置文件是否有语法错误：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can check the current status of the network interfaces using the following
    command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令检查网络接口的当前状态：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, if you want to check the network interface’s status without applying
    the configuration, use the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想检查网络接口的状态而不应用配置，可以使用以下命令：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To view logs regarding errors while bringing up network interfaces, you can
    use the `dmesg` command to view kernel messages, including those related to network
    interfaces. You can use `dmesg | grep eth0` to filter logs related to the `eth0`
    interface specifically. Other locations include the `/var/log/messages` file,
    `journalctl` (for example, the `journalctl -u systemd-networkd.service` command),
    and `/var/log/netplan/`, which contains logs generated by `netplan`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看与网络接口启动时的错误相关的日志，可以使用 `dmesg` 命令查看内核消息，包括与网络接口相关的消息。您可以使用 `dmesg | grep eth0`
    来过滤与 `eth0` 接口相关的日志。其他位置包括 `/var/log/messages` 文件，`journalctl`（例如，`journalctl
    -u systemd-networkd.service` 命令），以及包含 `netplan` 生成的日志的 `/var/log/netplan/`。
- en: In day-to-day operations, it’s much more likely you’ll edit the `/etc/network/interfaces`
    file or `netplan` configuration than configure the interface manually, but it’s
    very useful to know how to do it in case you need to temporarily change something
    in the network configuration for testing or debugging issues.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常操作中，编辑 `/etc/network/interfaces` 文件或 `netplan` 配置比手动配置接口更常见，但是知道如何临时更改网络配置以进行测试或调试问题非常有用。
- en: Next, we will cover the transport layer.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍传输层。
- en: Transport layer – TCP and UDP
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输层 – TCP 和 UDP
- en: In the **transport layer** of the OSI model, we focus more on **Transmission
    Control Protocol** (**TCP**) and IP, which are the foundation of the modern internet.
    Additionally, we’ll look into the **User Datagram Protocol** (**UDP**). We talked
    about IP in the *Network layer – IPv4 and IPv6* subsection of this chapter, so
    we’re only going to deepen our knowledge of this protocol a bit here.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OSI 模型的**传输层**中，我们更多地关注**传输控制协议**（**TCP**）和 IP，它们是现代互联网的基础。此外，我们还将深入了解**用户数据报协议**（**UDP**）。我们在本章的*网络层
    – IPv4 和 IPv6* 小节中讨论了 IP，因此这里我们只会稍微加深对该协议的了解。
- en: TCP is used for communication and needs reliable two-way communication between
    services. UDP is a stateless protocol that does not need a constant connection.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 用于通信，需要服务之间可靠的双向通信。UDP 是一种无状态协议，不需要持续连接。
- en: 'A TCP connection is established using a *three-way handshake*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *三次握手* 建立了 TCP 连接：
- en: The client sends a `SYN` (synchronize) packet to the server, to initiate the
    connection.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送一个 `SYN`（同步）包，以初始化连接。
- en: The server receives the `SYN` packet and sends back a `SYN-ACK` (synchronize-acknowledgment)
    packet to the client to confirm that the connection has been established.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收到 `SYN` 包，并向客户端发送一个 `SYN-ACK`（同步-确认）包，以确认连接已建立。
- en: The client receives the `SYN-ACK` packet and sends back an `ACK` (acknowledgment)
    packet to the server to complete the three-way handshake.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端接收到 `SYN-ACK` 包，并向服务器发送一个 `ACK`（确认）包，以完成三次握手。
- en: Once the three-way handshake is completed, the devices can start sending data
    to each other over the established TCP connection.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成三次握手，设备就可以通过已建立的 TCP 连接开始互相发送数据。
- en: The connection for TCP and UDP protocols is initiated by sending packets to
    a port on the server end of the connection. The port number is included in the
    IP packet header, along with the IP address, so that the destination device knows
    which process to send the data to.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 和 UDP 协议的连接是通过向连接的服务器端口发送数据包来初始化的。端口号包含在 IP 数据包头中，与 IP 地址一起，以便目标设备知道将数据发送到哪个进程。
- en: 'A port is an integer ranging from `0` to `65535`. It is used to identify a
    specific process running on a device and to differentiate it from other services.
    The port number is added to the IP address. Thus, if more than one program listens
    for a connection on one IP address, the other side can tell exactly which program
    it wants to talk to. Let’s assume that two processes are running and listening:
    a WWW server and an SSH server. The WWW server will typically listen on ports
    `80` or `443` and the SSH server will listen on port `22`. Let’s assume the system
    has an IP address of `192.168.1.1`. To connect to the SSH server, we would pair
    the IP address with the port address (commonly written as `192.168.1.1:22`). The
    server will know that this incoming connection has to be handled by the SSH process.
    A UDP connection, unlike TCP, doesn’t establish a connection to a server machine.
    Instead, devices can start sending UDP datagrams (**packets**) to each other on
    known ports.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 端口是一个整数，范围从`0`到`65535`。它用于标识设备上运行的特定进程，并与其他服务区分开来。端口号会附加在IP地址后面。因此，如果多个程序在同一IP地址上监听连接，另一端可以准确知道它想要与哪个程序通信。假设有两个进程正在运行并监听：一个WWW服务器和一个SSH服务器。WWW服务器通常会监听`80`或`443`端口，SSH服务器会监听`22`端口。假设系统的IP地址是`192.168.1.1`。要连接到SSH服务器，我们会将IP地址与端口地址配对（通常写作`192.168.1.1:22`）。服务器会知道该传入的连接需要由SSH进程处理。与TCP不同，UDP连接并不会建立与服务器机器的连接。相反，设备可以在已知端口上相互发送UDP数据报（**数据包**）。
- en: When a device sends a UDP datagram, it includes the destination IP address and
    port number in the packet header. The receiving device checks the destination
    IP address and port number in the packet header to determine which process to
    send the data to.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备发送UDP数据报时，它会在数据包头中包含目标IP地址和端口号。接收设备检查数据包头中的目标IP地址和端口号，以确定将数据发送到哪个进程。
- en: Because UDP is connectionless, there is no guarantee that the data will be received
    by the destination device or that it will be received in the order it was sent.
    There is also no error checking or retransmission of lost packets. UDP is typically
    used for services that require a low overhead and fast communication. The most
    well-known service that uses UDP for communication is **Domain Name** **Service**
    (**DNS**).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UDP是无连接的，因此不能保证数据会被目标设备接收，或者接收的顺序与发送的顺序相同。也没有错误检查或丢失数据包的重传。UDP通常用于需要低开销和快速通信的服务。最著名的使用UDP进行通信的服务是**域名系统**（**DNS**）。
- en: 'There are three types of port numbers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 端口号有三种类型：
- en: '`/etc/services` file. These are port numbers that are reserved for specific
    services, such as `HTTP` traffic on `port 80` or DNS traffic on `port 53`.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/services` 文件。这些是为特定服务保留的端口号，例如`HTTP`流量的`80`端口或DNS流量的`53`端口。'
- en: '`1` and `1024`.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1` 和 `1024`。'
- en: '**Ephemeral ports** are port numbers that are used for temporary connections
    and are assigned dynamically by the operating system, such as for TCP connections.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短暂端口**是用于临时连接的端口号，并由操作系统动态分配，例如用于TCP连接。'
- en: There are various tools available for viewing details on TCP and UDP traffic
    on the machine you’re working on. You can also set up a firewall so that you can
    control access to your machine from the network.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种工具可供查看机器上TCP和UDP流量的详细信息。你还可以设置防火墙，以便控制从网络访问你机器的权限。
- en: netstat
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: netstat
- en: To view all TCP connections made from your machine, you can use a `netstat`
    command. It can be used to view a list of open connections, as well as display
    statistics about the network traffic on your system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看从你的机器发起的所有TCP连接，可以使用`netstat`命令。它可以用于查看打开的连接列表，并显示系统网络流量的统计信息。
- en: To view a list of all open connections on your system, you can use the `netstat
    -an` command. This will display a list of all current connections, including the
    local and remote IP addresses and ports, as well as the status of the connection
    (for example, listening, established, and so on).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看系统上所有打开的连接列表，可以使用`netstat -an`命令。这将显示所有当前连接的列表，包括本地和远程IP地址及端口，以及连接状态（例如，监听、已建立等）。
- en: Using `netstat -s`, you can view statistics on each connection on your system.
    This will display a variety of statistics about the network traffic on your system,
    including the number of packets sent and received, the number of errors, and more.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`netstat -s`，你可以查看系统上每个连接的统计信息。这将显示关于系统网络流量的各种统计数据，包括发送和接收的包数量、错误数量等。
- en: To view only the UDP connections using `netstat`, you can use the `netstat -an
    -u` command. This will display a list of all current UDP connections, including
    the local and remote IP addresses and ports, as well as the status of the connection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `netstat` 中的所有 UDP 连接，你可以使用 `netstat -an -u` 命令。它会显示所有当前的 UDP 连接，包括本地和远程的
    IP 地址与端口，以及连接的状态。
- en: Alternatively, you can use the `netstat -an -u | grep "udp" | grep "0.0.0.0:*"`
    command to only show UDP connections that are in a listening state. This command
    filters the output of `netstat -an -u` to show only lines that contain `"UDP"`
    and `"0.0.0.0:*"`, which indicates a listening UDP connection.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用 `netstat -an -u | grep "udp" | grep "0.0.0.0:*"` 命令，只显示处于监听状态的 UDP
    连接。这个命令过滤 `netstat -an -u` 的输出，只显示包含 `"UDP"` 和 `"0.0.0.0:*"` 的行，这表示一个监听中的 UDP
    连接。
- en: You can also use other options, such as `-p` to show the process ID and name
    of the process that owns each connection, `-r` to show the routing table, and
    `-i` to show the statistics for a particular interface.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用其他选项，例如 `-p` 显示每个连接所属进程的进程 ID 和名称，`-r` 显示路由表，`-i` 显示特定接口的统计信息。
- en: tcpdump
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: tcpdump
- en: '`tcpdump` is a command-line packet analyzer that allows you to capture and
    analyze network traffic by displaying packets being transmitted or received over
    a network to which the computer is attached. `tcpdump` can be used to troubleshoot
    network issues, analyze network performance, and monitor network security. You
    can capture packets on a specific interface, filter packets based on various criteria,
    and save the captured packets to a file for later analysis.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`tcpdump` 是一个命令行数据包分析器，允许你通过显示传输或接收的网络数据包来捕获和分析网络流量。`tcpdump` 可以用来排查网络问题、分析网络性能以及监控网络安全。你可以在特定接口上捕获数据包，基于各种标准过滤数据包，并将捕获的包保存到文件中以供后续分析。'
- en: To capture and display all network traffic on the `eth0` interface, you can
    use the `-i` option, followed by the interface name. To capture and display all
    network traffic on the `eth0` interface, you would need to run `sudo tcpdump -``i
    eth0`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获并显示 `eth0` 接口上的所有网络流量，你可以使用 `-i` 选项，后跟接口名称。要捕获并显示 `eth0` 接口上的所有网络流量，你需要运行
    `sudo tcpdump -i eth0`。
- en: You can also save the captured packets to a file for later analysis by using
    the `-w` option – for example, `tcpdump -i eth0 -w all_traffic.pcap`. This will
    save all the captured packets on the `eth0` interface in the file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用 `-w` 选项将捕获的数据包保存到文件中，以便以后分析——例如，`tcpdump -i eth0 -w all_traffic.pcap`。这将把
    `eth0` 接口上捕获的所有数据包保存到文件中。
- en: By default, `tcpdump` captures packets indefinitely.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`tcpdump` 会无限期地捕获数据包。
- en: To capture packets for a specific amount of time, you can use the `-c` option,
    followed by the number of packets to capture – for example, `sudo tcpdump -i eth0
    -c 100`. This command captures and displays `100` packets, then exits.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要捕获特定时间内的数据包，你可以使用 `-c` 选项，后跟要捕获的数据包数量——例如，`sudo tcpdump -i eth0 -c 100`。该命令会捕获并显示
    `100` 个数据包，然后退出。
- en: You can also filter the traffic by using filters such as `port`, `ip`, `host`,
    and so on – for example, `sudo tcpdump -i eth0 'src host 192.168.1.2 and (tcp
    or udp)'`. This filter captures all the packets on the `eth0` interface with a
    source IP address of `192.168.1.2` and is either `TCP` or `UDP`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用像 `port`、`ip`、`host` 等过滤器来筛选流量——例如，`sudo tcpdump -i eth0 'src host 192.168.1.2
    and (tcp or udp)'`。这个过滤器捕获所有源 IP 地址为 `192.168.1.2` 且为 `TCP` 或 `UDP` 的数据包。
- en: To show more advanced use of `tcpdump`, let’s capture only `SYN` packets (see
    all connections being established). You can achieve this by using the `tcp[tcpflags]
    & (tcp-syn) != 0` filter. This filter checks if the `SYN` flag is set in the `TCP`
    header of the packet.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 `tcpdump` 更高级的用法，让我们只捕获 `SYN` 数据包（查看所有正在建立的连接）。你可以通过使用 `tcp[tcpflags] &
    (tcp-syn) != 0` 过滤器来实现。这个过滤器检查数据包的 `TCP` 头部中是否设置了 `SYN` 标志。
- en: 'Here is an example command that captures and displays all `SYN` packets on
    the `eth0` interface:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个命令示例，它捕获并显示 `eth0` 接口上的所有 `SYN` 数据包：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also save the captured packets to a file for later analysis by using
    the `-w` option, like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过使用 `-w` 选项将捕获的数据包保存到文件中，以便后续分析，如下所示：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will save all the captured `SYN` packets in the `syn_packets.pcap` file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把所有捕获的 `SYN` 数据包保存到 `syn_packets.pcap` 文件中。
- en: 'You can also specify a filter with a more complex filter, like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定一个更复杂的过滤器，如下所示：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This filter captures only `SYN` packets that have a source IP address of `192.168.1.2`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过滤器仅捕获源 IP 地址为 `192.168.1.2` 的 `SYN` 数据包。
- en: Wireshark
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Wireshark
- en: 'Another popular tool that’s similar to `tcpdump` is Wireshark. It can be used
    both headless (only in a command line) and via a graphical interface:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类似于`tcpdump`的流行工具是Wireshark。它既可以在无头模式下使用（仅在命令行中），也可以通过图形界面使用：
- en: 'To show all traffic on the `eth0` interface using Wireshark, you can use the
    `sudo wireshark -i eth0` command. This will start Wireshark and listen for traffic
    on the `eth0` interface. You can also use the `-k` flag to start capturing immediately
    and the `-w` flag to write the captured traffic to a file: `sudo wireshark -k
    -i eth0 -``w output_file.pcap`.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用Wireshark显示`eth0`接口上的所有流量，你可以使用`sudo wireshark -i eth0`命令。这将启动Wireshark并监听`eth0`接口上的流量。你还可以使用`-k`标志立即开始捕获，并使用`-w`标志将捕获的流量写入文件：`sudo
    wireshark -k -i eth0 -w output_file.pcap`。
- en: If you’d like to show only `SYN` packets, as we showed in the `tcpdump` example,
    you can run the `sudo wireshark -i eth0 -f "tcp.flags.syn == 1"` command. The
    preceding command uses a filter, `"tcp.flags.syn == 1"`, which says that we want
    to see only `TCP` protocol flags marked as `SYN`. You can also use this filter
    in the GUI version of Wireshark by going to the **Capture** menu, selecting **Options**,
    then entering the filter in the **Capture Filter** field before starting the capture.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想仅显示`SYN`数据包，如同我们在`tcpdump`示例中所展示的那样，你可以运行`sudo wireshark -i eth0 -f "tcp.flags.syn
    == 1"`命令。前面的命令使用了一个过滤器，`"tcp.flags.syn == 1"`，这表示我们只想看到标记为`SYN`的`TCP`协议标志。你也可以在Wireshark的图形界面版本中使用此过滤器，方法是进入**捕获**菜单，选择**选项**，然后在**捕获过滤器**字段中输入过滤器，再开始捕获。
- en: Alternatively, you can apply this filter after capturing the traffic by clicking
    on the `"tcp.flags.syn==1"` in the filter field, and press *Enter*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在捕获流量后，你也可以通过点击过滤字段中的`"tcp.flags.syn==1"`并按*Enter*来应用该过滤器。
- en: ngrep
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ngrep
- en: The next very useful tool that’s similar to `tcpdump` and Wireshark is `ngrep`.
    What differentiates it from other tools we’ve been talking about is that it’s
    much simpler to use, and it allows you to (similar to `grep`) search for strings
    inside network packets.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个非常有用的工具是`ngrep`，它类似于`tcpdump`和Wireshark。与我们之前提到的其他工具不同，它的使用更加简单，而且允许你（类似于`grep`）在网络数据包中搜索字符串。
- en: 'For instance, to monitor `GET HTTP` requests, you can use the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要监视`GET HTTP`请求，你可以使用以下命令：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command will listen on the `eth0` interface and match only `TCP` packets
    on port `80` (the default port for `HTTP`). The `-q` option tells `ngrep` to be
    quiet and not display packet summary information, while `-W` tells `ngrep` to
    print each packet data in separate lines. At this point, we can move to the session
    layer.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在`eth0`接口上监听，并仅匹配`80`端口上的`TCP`数据包（`HTTP`的默认端口）。`-q`选项告诉`ngrep`保持安静，不显示数据包摘要信息，而`-W`则告诉`ngrep`将每个数据包的数据打印在单独的行上。此时，我们可以进入会话层。
- en: Session layer
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话层
- en: The **session layer**, as we’ve already mentioned, is responsible for establishing,
    maintaining, and terminating connections between devices. This means it sets up,
    coordinates, and terminates conversations, exchanges, or connections between the
    applications. The session layer ensures that data is transmitted reliably and
    in the proper sequence by using techniques such as token management and checkpointing.
    It is also responsible for resolving any conflicts that may arise during a session,
    such as when two applications attempt to initiate a session at the same time.
    In a nutshell, the session layer establishes, maintains, and terminates the connections
    between the devices on a network.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**会话层**，正如我们之前提到的，它负责在设备之间建立、维护和终止连接。这意味着它设置、协调和终止应用程序之间的对话、交换或连接。会话层通过使用令牌管理和检查点等技术，确保数据可靠地传输并按正确顺序传送。它还负责解决会话中可能出现的任何冲突，例如当两个应用程序试图同时发起会话时。简而言之，会话层在网络中建立、维护和终止设备之间的连接。'
- en: In other words, the session layer is a glue between the lower layers we’ve already
    covered and the higher layers we will be covering in the next few sections of
    this chapter.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，会话层是我们已经讨论过的下层与接下来几节将要介绍的上层之间的粘合剂。
- en: The best tools to figure out issues with sessions are logs tied to the service
    you’re working with. If you have a problem with an FTP connection, you might want
    to look into logs of your client and/or server running on the machine you manage.
    The tools we covered previously can also help if logs are not enough to understand
    the issue you’re trying to resolve.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 解决会话问题的最佳工具是与你正在使用的服务相关的日志。如果你遇到FTP连接问题，可能需要查看你管理的机器上运行的客户端和/或服务器的日志。如果日志不足以理解你要解决的问题，之前介绍的工具也可以提供帮助。
- en: Presentation layer – SSL and TLS
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表示层 – SSL和TLS
- en: The `ASCII`) or 8-bit (`EBCDIC`) integers. We also handle encryption and compression
    in this layer. The presentation layer also ensures that the data is in the correct
    format for the application to process. It acts as an intermediary between the
    application and the data, allowing the application to be independent of the specific
    format of the data being received.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`ASCII`）或8位（`EBCDIC`）整数。我们还在这一层处理加密和压缩。表示层还确保数据格式正确，便于应用程序处理。它充当应用程序与数据之间的中介，使得应用程序不受接收数据特定格式的影响。'
- en: For this layer, the most common encryption standards, **Secure Sockets Layer**
    (**SSL**) and **Transport Layer Security** (**TLS**) are the ones you might need
    to debug and fix issues with.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这一层，最常见的加密标准是**安全套接字层**（**SSL**）和**传输层安全性**（**TLS**），你可能需要调试和修复这两个协议的问题。
- en: '**TLS** is a widely used protocol for securing communications over a network.
    It is a successor to **SSL** and is used to encrypt and authenticate data transmitted
    over a network, such as the internet.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**TLS**是一个广泛使用的协议，用于确保网络通信的安全性。它是**SSL**的继任者，用于加密和验证通过网络（如互联网）传输的数据。'
- en: TLS works by establishing a secure *tunnel* between two devices, such as a web
    server and a web browser. This tunnel is used to transmit data between the two
    devices in an encrypted format, making it difficult for an attacker to intercept
    and read the data.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: TLS通过在两个设备之间建立一个安全的*tunnel*（隧道）来工作，例如Web服务器和Web浏览器。该隧道用于在两个设备之间以加密格式传输数据，使得攻击者难以拦截和读取数据。
- en: 'The process of establishing a TLS connection involves several steps:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 建立TLS连接的过程包括几个步骤：
- en: '**Handshake**: The client and server exchange information to establish a shared
    understanding of the encryption method and keys that will be used to secure the
    connection.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**握手**：客户端和服务器交换信息，以建立共享的加密方法和密钥，确保连接的安全。'
- en: '**Authentication**: The server authenticates itself to the client by providing
    a digital certificate that contains information about the server’s identity and
    public key. The client can then use this information to verify the server’s identity.'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**认证**：服务器通过提供包含服务器身份和公钥信息的数字证书向客户端进行身份验证。客户端可以使用这些信息验证服务器的身份。'
- en: '**Key exchange**: The client and server exchange public keys to establish a
    shared secret key that will be used to encrypt and decrypt data.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**密钥交换**：客户端和服务器交换公钥，以建立一个共享的秘密密钥，该密钥将用于加密和解密数据。'
- en: '**Data encryption**: Once the shared secret key has been established, the client
    and server can start encrypting data using symmetric encryption algorithms.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据加密**：一旦共享的秘密密钥建立，客户端和服务器就可以使用对称加密算法开始加密数据。'
- en: '**Data transfer**: Data is then transferred over the secure connection, protected
    by the encryption established during the handshake.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**数据传输**：然后，数据通过安全连接进行传输，并通过握手过程中建立的加密保护。'
- en: 'TLS has multiple versions, among which the newest are considered more secure.
    However, older systems might not support the most recent versions. The available
    TLS versions are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: TLS有多个版本，其中最新的版本被认为更为安全。然而，旧系统可能不支持最新版本。可用的TLS版本如下：
- en: '**TLS 1.0**: This was the first version of the protocol, released in 1999.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLS 1.0**：这是该协议的第一个版本，于1999年发布。'
- en: '**TLS 1.1**: This was released in 2006.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLS 1.1**：该版本于2006年发布。'
- en: '**TLS 1.2**: This was released in 2008\. It added support for new cryptographic
    algorithms and made several other security enhancements.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLS 1.2**：该版本于2008年发布，增加了对新加密算法的支持，并做了其他多个安全性增强。'
- en: '**TLS 1.3**: This was released in 2018 and includes the use of forward secrecy,
    which makes it harder for attackers to decrypt captured data.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TLS 1.3**：该版本于2018年发布，采用了前向保密性（forward secrecy），使得攻击者更难解密捕获的数据。'
- en: SSL is a security protocol that is widely used to secure communications over
    a network, such as the internet. It was developed by Netscape in the 1990s and
    was later succeeded by the TLS protocol.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: SSL是一种广泛用于保障网络通信安全的协议，如互联网通信。它由Netscape在1990年代开发，后来被TLS协议所取代。
- en: Like TLS, SSL works by establishing a secure *tunnel* between two devices, such
    as a web server and a web browser. This tunnel is used to transmit data between
    the two devices in an encrypted format, making it difficult for an attacker to
    intercept and read the data. It’s not recommended to use SSL anymore and it’s
    better to use the latest version of TLS, but you might still encounter systems
    using it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 和TLS一样，SSL通过在两个设备之间建立一个安全的*tunnel*（隧道）来工作，比如网页服务器和网页浏览器。这个隧道用于在两个设备之间传输加密格式的数据，使得攻击者很难拦截和读取数据。目前不建议再使用SSL，最好使用最新版本的TLS，但你可能仍然会遇到使用SSL的系统。
- en: 'The best tool to debug issues with both SSL and TLS is the `openssl` command.
    You can use it to test a connection to a server using SSL. For example, you can
    use the following command to test a connection to a server on port (usually, it’s
    `443` as it’s a common port for HTTPS):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 调试SSL和TLS问题的最佳工具是`openssl`命令。你可以用它测试与服务器的SSL连接。例如，你可以使用以下命令测试与服务器在端口（通常是`443`，这是HTTPS的常用端口）的连接：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can use the `openssl` command to check the details of an SSL certificate,
    including the expiration date, the issuing authority, and the public key. For
    example, you can use the following command to check the details of a certificate:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`openssl`命令检查SSL证书的详细信息，包括过期日期、发行机构和公钥。例如，你可以使用以下命令来检查证书的详细信息：
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will allow you to check if the certificates served by your server are valid
    and what you expect them to be. This is much faster than using a web browser.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许你检查服务器提供的证书是否有效，并且是否符合你的预期。这比使用网页浏览器要快得多。
- en: 'Using the `openssl` command, you can also check which ciphers are supported
    by a server. For example, you can use the following command to check the ciphers
    supported by a server:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`openssl`命令，你还可以检查服务器支持哪些加密算法。例如，你可以使用以下命令检查服务器支持的加密算法：
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Additionally, `openssl` has a built-in diagnostic that can detect known vulnerabilities
    that exist in your system:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`openssl`还内置了诊断工具，可以检测系统中已知的漏洞：
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It’s also worth noting that both SSL and TLS use public key encryption. With
    this encryption method, we create two files: a private key and a public key. Together,
    they form a pair. The public key is designed to encrypt data, while the private
    key is designed to decrypt it. The private key should be kept private at all times,
    as its name implies. This method of encryption is based on the mathematical properties
    of large prime numbers, and it is considered to be very secure.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，SSL和TLS都使用公钥加密。在这种加密方法中，我们会创建两个文件：一个私钥和一个公钥。它们共同构成一对。公钥用于加密数据，而私钥用于解密数据。私钥应始终保密，正如它的名字所示。这种加密方法基于大素数的数学特性，被认为是非常安全的。
- en: 'In the case of TLS, public key encryption is used during the *handshake* phase
    to establish a secure connection between the client and the server. The process
    works as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在TLS的情况下，公钥加密在*握手*阶段用于建立客户端与服务器之间的安全连接。这个过程如下：
- en: The server generates a public key and a private key. The public key is sent
    to the client as part of the server’s digital certificate.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器生成公钥和私钥。公钥作为服务器数字证书的一部分发送给客户端。
- en: The client generates a session key, which is used to encrypt data that is sent
    to the server. The server’s public key is used to encrypt the session key. Once
    the server receives the encrypted data, it uses its private key to decrypt it
    and retrieve the session key.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端生成一个会话密钥，用于加密发送到服务器的数据。服务器的公钥用于加密会话密钥。一旦服务器收到加密的数据，它使用私钥解密数据并恢复会话密钥。
- en: Once the session key has been decrypted, it is used to encrypt data that is
    sent between the client and the server.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦会话密钥被解密，它就会用于加密客户端与服务器之间发送的数据。
- en: The next and final layer is the top layer of the OSI model. In the next section,
    which covers the application layer, we’ll cover protocols such as HTTP and FTP,
    which are commonly used for browsing the web and sharing files.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的最后一层是OSI模型的顶层。在接下来的章节中，我们将介绍应用层，涵盖诸如HTTP和FTP等协议，这些协议通常用于浏览网页和共享文件。
- en: Application layer – HTTP and FTP
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用层 – HTTP和FTP
- en: The **application layer** is the seventh and highest layer of the OSI network
    model. It provides the interface between the software application and the network,
    allowing the application to access the network’s communication services. The application
    layer defines protocols and services that are specific to the application, such
    as file transfer (**File Transfer Protocol** (**FTP**)), email (**Simple Mail
    Transfer Protocol** (**SMTP**) and **Internet Message Access Protocol** (**IMAP**)),
    and well-known web services (**Hypertext Transfer** **Protocol** (**HTTP**)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用层**是OSI网络模型的第七层，也是最高层。它提供软件应用程序与网络之间的接口，使得应用程序能够访问网络的通信服务。应用层定义了特定于应用程序的协议和服务，例如文件传输（**文件传输协议**（**FTP**））、电子邮件（**简单邮件传输协议**（**SMTP**）和**互联网消息访问协议**（**IMAP**））以及广泛使用的网络服务（**超文本传输协议**（**HTTP**））。'
- en: Let’s take a closer look at HTTP. This communication protocol is used for transferring
    data on the World Wide Web. It is based on a client-server model, where a web
    browser (the client) sends a request to a web server, and the server sends back
    a response.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看HTTP。这个通信协议用于在万维网上传输数据。它基于客户端-服务器模型，其中Web浏览器（客户端）向Web服务器发送请求，服务器则返回响应。
- en: When a user enters a **Uniform Resource Locator** (**URL**) in their web browser,
    the browser sends an HTTP request to the web server associated with that URL.
    A URL is something you can see in your browser address input field and is usually
    located at the top of the browser window – for example, [https://google.com](https://google.com).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在浏览器中输入**统一资源定位符**（**URL**）时，浏览器会向与该URL关联的网络服务器发送HTTP请求。URL是你在浏览器地址输入框中看到的内容，通常位于浏览器窗口的顶部，例如，[https://google.com](https://google.com)。
- en: The request includes the method (such as `GET`, `POST`, `PUT`, `PATCH`, or `DELETE`),
    which indicates the type of action the browser wants the server to perform, as
    well as any additional information, such as data for a `POST` or `PUT` request.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请求包含方法（如`GET`、`POST`、`PUT`、`PATCH`或`DELETE`），指示浏览器希望服务器执行的操作类型，并可能包含其他信息，如`POST`或`PUT`请求的数据。
- en: The web server then processes the request, after which the server sends back
    an HTTP response, which includes a status code (such as `200` for success or `404`
    for `not found`) and any data requested by the browser, such as the HTML and CSS
    that make up the website.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，网络服务器处理请求，之后服务器会发送回一个HTTP响应，包含状态码（如`200`表示成功或`404`表示`未找到`）以及浏览器请求的任何数据，例如构成网站的HTML和CSS。
- en: Once the browser receives the response, it parses the HTML, CSS, and – very
    often – JavaScript to display the website to the user.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦浏览器收到响应，它会解析HTML、CSS，通常还包括JavaScript，以便将网站显示给用户。
- en: HTTP is a stateless protocol, which means that each request is independent and
    the server does not retain any information about previous requests. However, many
    web applications use cookies or other techniques to maintain state across multiple
    requests.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种无状态协议，这意味着每个请求都是独立的，服务器不会保留任何关于先前请求的信息。然而，许多Web应用程序使用cookies或其他技术来维持多个请求之间的状态。
- en: HTTP version 1.1 introduced new features such as persistent connections, a host
    header field, and byte-serving which, improved the overall performance of the
    protocol and made it more suitable for heavy usage scenarios. The most recent
    version of this protocol is 2.0 and is described in detail by RFC 7540 (https://www.rfc-editor.org/rfc/rfc7540.xhtml),
    which was released in 2015, and updated by RFC 8740 ([https://www.rfc-editor.org/rfc/rfc8740.xhtml](https://www.rfc-editor.org/rfc/rfc8740.xhtml)),
    which was released in 2020.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 1.1版本引入了新特性，如持久连接、主机头字段和字节服务，这些改进提高了协议的整体性能，并使其更适合重负载使用场景。该协议的最新版本是2.0，详细描述在RFC
    7540中（https://www.rfc-editor.org/rfc/rfc7540.xhtml），该版本于2015年发布，并在2020年由RFC 8740（[https://www.rfc-editor.org/rfc/rfc8740.xhtml](https://www.rfc-editor.org/rfc/rfc8740.xhtml)）更新。
- en: To resolve issues with HTTP, you can use any of the tools for debugging network
    problems, such as `tcpdump` or `ngrep`. There are several console and GUI tools
    available you can use for debugging HTTP. The most common are `wget` and `curl`
    for the console and `Postman` or `Fiddler` for the GUI. There will also be debugging
    tools built into your browser, such as Firefox or Chrome Developer Tools.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决 HTTP 问题，您可以使用任何调试网络问题的工具，例如 `tcpdump` 或 `ngrep`。有多种控制台和图形界面工具可供调试 HTTP。最常见的控制台工具是
    `wget` 和 `curl`，图形界面工具包括 `Postman` 或 `Fiddler`。浏览器中也会内置调试工具，例如 Firefox 或 Chrome
    开发者工具。
- en: 'We’re going to focus on console tools right now, so let’s look into `wget`
    first. This tool is intended to download files, but we still can use it to debug
    HTTP. For the first example, we will show detailed information about the request
    and response:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将重点关注控制台工具，因此首先来看看 `wget`。这个工具本用于下载文件，但我们仍然可以用它来调试 HTTP。首先，我们将展示请求和响应的详细信息：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You might need to send an HTTP request with specific headers. To do so, you
    can use the `--``header` option:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要发送带有特定头部的 HTTP 请求。为此，您可以使用 `--header` 选项：
- en: '[PRE26]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`POST` is a special HTTP request – it uses a URL, but it will also require
    some request data as it’s intended to send some data to your system, be it a username
    and password or files. To send an HTTP `POST` request with prepared data, you
    can use the `--post-data` option, like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 是一种特殊的 HTTP 请求——它使用 URL，但也需要一些请求数据，因为它的目的是向您的系统发送数据，无论是用户名和密码还是文件。要发送带有准备数据的
    HTTP `POST` 请求，可以使用 `--post-data` 选项，如下所示：'
- en: '[PRE27]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A more powerful tool for debugging HTTP issues is `curl`. To send an HTTP `GET`
    request and display the response, you can use the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更强大的调试 HTTP 问题的工具是 `curl`。要发送 HTTP `GET` 请求并显示响应，您可以使用以下命令：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To send an HTTP `POST` request and display the response, you can use the `-X
    POST` option and the `-``d` option:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送 HTTP `POST` 请求并显示响应，您可以使用 `-X POST` 选项和 `-d` 选项：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using the `-X` option, you can send other types of requests, such as `PATCH`
    or `DELETE`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-X` 选项，您可以发送其他类型的请求，例如 `PATCH` 或 `DELETE`。
- en: 'To send an HTTP request with specific headers, you can use the `-``H` option:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送带有特定头部的 HTTP 请求，您可以使用 `-H` 选项：
- en: '[PRE30]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To display the response headers only, use the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 若要仅显示响应头部，请使用以下代码：
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also show detailed information about the request and response by using
    the `-v` option, like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用 `-v` 选项显示请求和响应的详细信息，如下所示：
- en: '[PRE32]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By sending different types of requests and analyzing the responses, you can
    use either `wget` or `curl` to debug various HTTP issues, such as connectivity
    problems, response errors, and performance issues. As usual, you can refer to
    the full documentation of both tools to deepen your understanding of how to use
    them.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发送不同类型的请求并分析响应，您可以使用 `wget` 或 `curl` 来调试各种 HTTP 问题，如连接问题、响应错误和性能问题。像往常一样，您可以参考这两个工具的完整文档，以加深对它们使用方法的理解。
- en: In this section, we introduced several network layers, as defined by the ISO/OSI
    standard. Each of them standardizes the functions of different elements of networking
    communication. Next, we are going to discuss firewalls.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 ISO/OSI 标准定义的几层网络层。每一层都标准化了网络通信不同元素的功能。接下来，我们将讨论防火墙。
- en: Firewalls
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防火墙
- en: A **firewall** is a security measure that controls incoming and outgoing network
    traffic based on predefined rules and policies. It is typically placed between
    a protected network and the internet, and its main purpose is to block unauthorized
    access while allowing authorized communication. Firewalls can be hardware-based
    or software-based, and they can use a variety of techniques, such as packet filtering,
    stateful inspection, and application-level filtering, to control network traffic.
    In this section, we’re going to look into a firewall available on Linux systems.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**防火墙** 是一种安全措施，根据预定义的规则和策略控制进出网络流量。它通常放置在受保护的网络和互联网之间，其主要目的是阻止未经授权的访问，同时允许授权的通信。防火墙可以是硬件基础的，也可以是软件基础的，且可以使用多种技术，如数据包过滤、状态检测和应用层过滤等来控制网络流量。在这一部分，我们将介绍一种适用于
    Linux 系统的防火墙。'
- en: To control a Linux firewall, you will need to use `iptables`, `ufw`, `nftables`,
    or `firewalld`. Packet filtering is built into the Linux kernel, so those CLI
    tools will interact with it.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制 Linux 防火墙，您需要使用 `iptables`、`ufw`、`nftables` 或 `firewalld`。数据包过滤已内置在 Linux
    内核中，因此这些命令行工具将与其交互。
- en: iptables
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iptables
- en: '**iptables** is the most verbose tool for controlling a firewall, meaning it
    does not have much abstraction built into it, but it’s important to understand
    the basic concepts so that we can move on to more user-friendly tools.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**iptables** 是控制防火墙的最冗长工具，这意味着它没有太多的抽象，但理解基本概念很重要，这样我们才能继续使用更用户友好的工具。'
- en: As mentioned previously, `iptables` allows you to create rules for filtering
    and manipulating network packets, and it can be used to control incoming and outgoing
    network traffic based on various criteria, such as IP or MAC addresses, ports,
    and protocols.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`iptables` 允许你创建规则来过滤和操作网络数据包，并可以根据各种标准（如 IP 地址、MAC 地址、端口和协议）控制进出网络的流量。
- en: '`iptables` uses several concepts to organize rules and divide them into functional
    parts: tables, chains, rules, and targets. The most general are tables to organize
    the rules.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`iptables` 使用多个概念来组织规则并将其划分为功能部分：表、链、规则和目标。最一般的概念是用表来组织规则。'
- en: 'There are three tables we can use: `filter`, `nat`, and `mangle`. The `filter`
    table is used to filter incoming and outgoing packets, the `nat` table is used
    for `mangle` table is used for advanced packet alteration.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三种表：`filter`、`nat` 和 `mangle`。`filter` 表用于过滤进出数据包，`nat` 表用于网络地址转换，`mangle`
    表用于高级数据包修改。
- en: 'Each table contains a set of chains, which are used to organize the rules.
    The `filter` table, for example, contains three predefined chains: `INPUT`, `OUTPUT`,
    and `FORWARD`. The `INPUT` chain is used for incoming packets, the `OUTPUT` chain
    is used for outgoing packets, and the `FORWARD` chain is used for packets that
    are being forwarded through the network.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每个表包含一组链，用于组织规则。例如，`filter` 表包含三条预定义链：`INPUT`、`OUTPUT` 和 `FORWARD`。`INPUT` 链用于接收的数据包，`OUTPUT`
    链用于发送的数据包，`FORWARD` 链用于转发的数据包。
- en: Each chain contains a set of rules, which are used to match packets and decide
    what to do with them. Each rule has a match condition and an action. For example,
    a rule might match packets coming from a specific IP address and drop them, or
    it might match packets going to a specific port and accept them.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每个链包含一组规则，这些规则用于匹配数据包并决定如何处理它们。每条规则都有一个匹配条件和一个动作。例如，某条规则可能会匹配来自特定 IP 地址的数据包并将其丢弃，或者它可能会匹配发送到特定端口的数据包并允许通过。
- en: Each rule has a target, which is the action that should be taken when the rule’s
    match condition is met. The most common targets are `ACCEPT`, `DROP`, and `REJECT`.
    `ACCEPT` means to allow the packet through the firewall, `DROP` means to discard
    the packet without any feedback to the other end, and `REJECT` means to refuse
    the packet actively so that the remote end will know access is rejected to the
    said port.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每条规则都有一个目标，它是当规则的匹配条件满足时应执行的操作。最常见的目标是 `ACCEPT`、`DROP` 和 `REJECT`。`ACCEPT` 表示允许数据包通过防火墙，`DROP`
    表示丢弃数据包而不向对端反馈任何信息，`REJECT` 表示主动拒绝数据包，使得远端知道该端口的访问已被拒绝。
- en: 'The default table of `iptables` will add rules to the filter table and by default,
    each chain (`INPUT`, `OUTPUT`, and `FORWARD`) has a default policy set to `ACCEPT`.
    You can also create additional tables and direct packets to this table for later
    processing. It’s a good practice to set at least the `FORWARD` and `INPUT` policies
    to `DROP`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`iptables` 的默认表会将规则添加到 `filter` 表中，默认情况下，每个链（`INPUT`、`OUTPUT` 和 `FORWARD`）的默认策略设置为
    `ACCEPT`。你还可以创建额外的表，并将数据包定向到该表进行后续处理。通常的做法是将至少 `FORWARD` 和 `INPUT` 策略设置为 `DROP`：'
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At the same time, we can allow all loopback interface access to `ACCEPT`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们可以允许所有回环接口访问并设置为 `ACCEPT`：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Additionally, all packets that are in the `ESTABLISHED` or `RELATED` state
    should be accepted; otherwise, we will lose all established connections or connections
    that are in the process of being established:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有处于 `ESTABLISHED` 或 `RELATED` 状态的数据包应当被接受，否则我们将失去所有已建立的连接或正在建立中的连接：
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To allow HTTP and HTTPS traffic, we can do the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许 HTTP 和 HTTPS 流量，我们可以执行以下操作：
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It’s a good idea to allow `SSH` traffic so that we can remotely log into this
    machine:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 `SSH` 流量是一个好主意，这样我们可以远程登录到这台机器：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here are some other more commonly used options you can use in `iptables`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些 `iptables` 中常用的其他选项：
- en: '`-A` or `--append`: Appends a rule to the end of a chain'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-A` 或 `--append`：将规则追加到链的末尾'
- en: '`-I` or `--insert`: Inserts a rule at a specific position in a chain'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-I` 或 `--insert`：在链中的特定位置插入一条规则'
- en: '`-D` or `--delete`: Deletes a rule from a chain'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-D` 或 `--delete`：从链中删除一条规则'
- en: '`-P` or `--policy`: Sets the default policy for a chain'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-j` or `--jump`: Specifies the target for a rule'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`s or `--source`: Matches packets based on the source IP address or network'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-d` or `--destination`: Matches packets based on the destination IP address
    or network'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-p` or `--protocol`: Matches packets based on the protocol (for example, TCP,
    UDP, or ICMP)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i` or `--in-interface`: Matches packets based on the incoming interface'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-o` or `--out-interface`: Matches packets based on the outgoing interface'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--sport` or `--source-port`: Matches packets based on the source port'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dport` or `--destination-port`: Matches packets based on the destination
    port'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-m` or `--match`: Adds a match extension, which allows you to match packets
    based on additional criteria such as connection state, packet length, and more'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more features available when dealing with `iptables`, such as
    setting up NAT, interface bonding, TCP multipath, and many more. We will cover
    some of these in the *Advanced topics* section of this chapter.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: nftables
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`iptables`, which is known for its verbosity and lack of built-in abstraction.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '`nftables` employs a logical structure to organize rules that comprises tables,
    chains, rules, and verdicts. Tables serve as the top-level containers for rules
    and are instrumental in categorizing them. `nftables` offers several table types:
    `ip`, `arp`, `ip6`, `bridge`, `inet`, and `netdev`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Within each table, there are chains, which help organize the rules further
    between categories: `filter`, `route`, and `nat`.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Each chain comprises individual rules, which serve as the criteria for matching
    packets and determining subsequent actions. A rule consists of both a matching
    condition and a verdict. For instance, a rule may match packets originating from
    a specific IP address and instruct the firewall to drop them, or it might match
    packets headed for a particular port and dictate acceptance.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set a default policy for incoming and forwarded packets to “drop” (stop
    processing the packet and don’t respond):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Additionally, it’s common practice to allow all loopback interface access:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To ensure established and related connections are permitted, you can run the
    following command:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can run the following command to allow HTTP and HTTPS traffic:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, to enable SSH traffic for remote access, you can use the following
    command:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'These are some frequently used options in `nftables`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '`add`: Appends a rule to the end of a chain'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insert`: Inserts a rule at a specific position in a chain'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: Deletes a rule from a chain'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chain`: Specifies the target for a rule'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ip saddr`: Matches packets based on the source IP address or network'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ip daddr`: Matches packets based on the destination IP address or network'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ip protocol`: Matches packets based on the protocol (for example, TCP, UDP,
    or ICMP)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iifname`: Matches packets based on the incoming interface'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oifname`: Matches packets based on the outgoing interface'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tcp sport`: Matches packets based on the source port'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tcp dport`: Matches packets based on the destination port'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ct state`: Adds a match extension, allowing packet matching based on additional
    criteria such as connection state, packet length, and more'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nftables` is set to be a replacement for `iptables`, but both are frequently
    used in modern systems. Let’s move on to other tools that are more abstract and
    by this, more user-friendly.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: ufw
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ufw` is a frontend for the Linux `iptables` firewall and provides a simple
    and easy-to-use interface for managing it. `ufw` is designed to be easy to use,
    and it automatically sets up the `iptables` rules for you based on the configuration
    options you specify. It’s much more user-friendly and easier to use for more common
    tasks.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start to use `ufw`, you will need to enable it so that all rules
    you add or remove will persist after system reboot. To do just that, run the following
    command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To open TCP ports `80` and `443` using `ufw`, you can use the following commands:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Alternatively, you can open both ports with one command:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once you have opened the ports, you can verify the changes by checking the
    status of `ufw`:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`ufw` is available on all major Linux distributions, including Debian Linux,
    Ubuntu Linux, Arch Linux, and Fedora Linux. However, in some cases, you will need
    to install it as it’s not part of the default system.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: firewalld
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another tool you can use to manage a firewall on Linux is `firewalld`. This
    is a program that was created to streamline the dynamic configuration of firewalls.
    One of the big features of `firewalld` is zones, which allow you to declare different
    levels of trust in interfaces and networks. It is included by default in many
    popular Linux distributions such as Red Hat Enterprise Linux, Fedora, CentOS,
    and Debian. Some other Linux distributions, such as Ubuntu, do not include `firewalld`
    by default but it can be installed and used on those systems as well.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'To open TCP ports `80` and `443` using `firewalld`, you can use the `firewall-cmd`
    command-line tool. Here are the commands to open those ports:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can open both ports with one command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After adding the ports, you need to reload the firewall for the changes to
    take effect:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can also check the status of the ports using the following command:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Whatever tool you use to configure your firewall, it’s always a good idea to
    set default rule policies to `DROP` and only allow the traffic you expect to be
    handled by your system. There are some topics we don’t have much space for in
    this chapter, but it’s useful to know about possibilities when dealing with networking.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover more advanced uses of network features. Some
    are very common (such as port forwarding or NAT), while some are less known. Let’s
    start with well-known features you will most likely encounter very often and then
    make our way down to more advanced and less-known features.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: NAT
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Network Address Translation** (**NAT**) is a technique that involves mapping
    one network to another. The original reason for this was to simplify routing whole
    network segments without changing the address of every host in the packets.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '**Source NAT** (**SNAT**) is a type of NAT that changes the source IP address
    of a packet. It is used to allow hosts on a private network to access the internet
    using a single public IP address.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '**Destination NAT** (**DNAT**) is a type of NAT that changes the destination
    IP address of a packet. It is used to forward incoming traffic to a specific internal
    host based on the destination IP address. This is often used to allow external
    clients to access services running on internal hosts using a public IP address.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up NAT using `iptables`, you can use the following basic commands:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This will enable forwarding, which allows your machine to forward packets from
    one interface to another. This particular command updates the Linux kernel configuration
    on the fly by using the `proc` filesystem. You can achieve the same thing using
    the `sysctl` command:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To configure NAT for a local network such as `192.168.10.0/24`, you will need
    to run the following commands as `root user`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that `eth0` is the interface connected to the internet, and `eth1` is the
    interface connected to the internal network.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: The `MASQUERADE` target is used to implement NAT on a Linux router. When packets
    pass through the router and are sent out to the internet, the `MASQUERADE` target
    changes the source address of the packets to the router’s public IP address. This
    allows devices on the internal network to communicate with devices on the internet
    using the router’s public IP address as a source address, effectively hiding the
    internal network from the internet.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: The `MASQUERADE` target is typically used in the `POSTROUTING` chain of the
    `nat` table and is commonly applied to the interface that is connected to the
    internet. It works only with dynamically assigned IP addresses (DHCP) and it’s
    mostly used in the case of a home router.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Port forwarding
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Port forwarding** is a technique that’s used to direct network traffic from
    one network address and port to another. This can be useful for directing incoming
    traffic to a specific service or application running on a computer or network
    device. This helps with accessing services or applications on a private network
    from a remote location, or for making services or applications running on a private
    network accessible to the public.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, it’s another use of NAT as you will change the destination IP (and
    also port) of the packet that arrived on your machine.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'To forward packets coming into TCP port `80` on the `eth0` interface to internal
    IP `192.168.10.101` on port `8080` using `iptables`, you can use the following
    commands:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We need `MASQUERADE` here as we want to hide the internal IP from the outside.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Interface bonding
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`active-backup`, `balance-rr`, and `802.3ad`. `active-backup` mode means that
    one of the two bonding interfaces is used as a backup when the primary device
    is down. `balance-rr` will use both interfaces simultaneously with a round-robin
    policy. The `802.3ad` bonding creates aggregation groups that share the same technical
    specifications (speed and duplex settings). You can read more about modes and
    bonding settings on the official Linux kernel website: [https://www.kernel.org/doc/Documentation/networking/bonding.txt](https://www.kernel.org/doc/Documentation/networking/bonding.txt%20)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: TCP multipath
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**TCP multipath** refers to using multiple paths to send and receive data between
    two points in a network, rather than just one. This can improve the reliability
    and performance of the network by allowing for failover if one of the paths becomes
    unavailable, and by allowing for load balancing across multiple paths. This can
    be achieved using various techniques, such as by using multiple interfaces on
    a device or by using multiple routing paths through the network.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuring multipath is quite easy with the use of the `iproute2` package.
    To configure multipath on Linux using the `eth0` and `eth1` interfaces, you will
    need to run the following command:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This command creates a new default route that uses both the `eth0` and `eth1`
    interfaces, with a weight of `1`. The IP addresses used in this example (`192.168.1.1`
    and `192.168.2.1`) should be replaced with the actual IP addresses of the next
    hop routers on the `eth0` and `eth1` interfaces.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'When running `ip route show`, you will see that a new multipath route is present.
    To start using it, you will need to change the default route:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You can read more about multipath and how to use it at [https://www.multipath-tcp.org/](https://www.multipath-tcp.org/).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: BGP
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Border Gateway Protocol** (**BGP**) is a routing protocol that’s used to
    distribute routing information within a single **autonomous system** (**AS**)
    or between multiple autonomous systems on the internet. BGP is used to build routing
    tables in routers in the internet backbone, as well as in enterprise networks.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: BGP routers exchange routing information with their neighbors, which can be
    other BGP routers in the same AS or a different AS. When a BGP router receives
    routing information from its neighbors, it uses a set of rules and policies to
    decide which routes to add to its routing table and advertise to its neighbors.
    This allows BGP to support multiple paths to a destination, and to choose the
    best path based on various factors such as distance, cost, or preference.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: BGP is considered a path vector protocol because it exchanges information about
    the complete path to a destination, rather than just the next hop. This allows
    BGP to support advanced features such as routing policy and traffic engineering.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to use BGP on a Linux machine, depending on your specific
    use case and network environment.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '**BIRD** is a routing daemon for Linux that supports BGP and other routing
    protocols. You can configure BIRD so that it acts as a BGP speaker and exchange
    routing information with other BGP routers. BIRD can be installed on most Linux
    distributions and can be configured using a simple configuration file.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '**Quagga** is another open source routing software suite for Linux that supports
    BGP, OSPF, and other routing protocols. You can configure Quagga to act as a BGP
    speaker and exchange routing information with other BGP routers. Quagga can be
    installed on most Linux distributions and can be configured using a command-line
    interface or a configuration file.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '**Free Range Routing** (**FRR**) is a routing software suite for Linux that
    supports BGP, OSPF, and other routing protocols; it’s a fork of Quagga.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about BGP and using BIRD in the following Linux Journal article:
    [https://www.linuxjournal.com/content/linux-advanced-routing-tutorial](https://www.linuxjournal.com/content/linux-advanced-routing-tutorial).'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered basic networking topics that you will probably encounter
    during your work in a DevOps team. This is a starting point and a base to help
    you understand network-related topics when dealing with services running inside
    a container. You will probably also want to expand your knowledge on this topic
    by reading about the IPv6 protocol, which is yet to replace IPv4.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will switch focus to a **version control system** (**VCS**)
    that is mainly used in modern organizations: **Git**.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
