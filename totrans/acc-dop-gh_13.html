<html><head></head><body>
		<div id="_idContainer146">
			<h1 id="_idParaDest-249"><em class="italic"><a id="_idTextAnchor249"/>Chapter 11</em>: Trunk-Based Development</h1>
			<p>One of the capabilities that are highly correlated with accelerated engineering velocity is <strong class="bold">trunk-based development</strong> (also known as <strong class="bold">TBD</strong>). High-performing teams have fewer than three active branches at any time, and their branches have a short lifetime (less than a day) before being merged into the main branch (Forsgren N., Humble, J., and Kim, G. 2018, page 98). Unfortunately, TBD is not a <strong class="source-inline">git</strong> <strong class="bold">workflow</strong> but rather a branching model of choice that has been in use since the 80s. It is not well defined and leaves a lot of room for interpretation, especially when it comes to using it with GitHub. Also, I personally find that only moving to a trunk-based workflow does not increase the performance too much. Only large teams with a highly complex workflow that are already stuck in <strong class="bold">merge hell</strong> really have this high impact. For most teams, it is more a combination of different capabilities such as feature flags and <strong class="bold">continuous integration/continuous deployment</strong> (<strong class="bold">CI/CD</strong>), together with a trunk-based workflow, that makes a big difference.</p>
			<p>In this chapter, I'll explain the benefits of trunk-based workflows. We'll also cover their difference from other branching workflows, and I'll introduce you to what I believe is the best <strong class="source-inline">git</strong> workflow to accelerate your software delivery.</p>
			<p>The chapter covers the following topics:</p>
			<ul>
				<li>Trunk-based development</li>
				<li>Why you should avoid complex branching</li>
				<li>Other <strong class="source-inline">git</strong> workflows</li>
				<li>Accelerating with MyFlow</li>
				<li>Case study</li>
			</ul>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor250"/>Trunk-based development</h1>
			<p>Trunk-based development is a source-control <a id="_idIndexMarker703"/>branching model, where developers merge small and frequent updates to a single branch (often called a <strong class="bold">trunk</strong>, but in <strong class="source-inline">git</strong>, this is <a id="_idIndexMarker704"/>commonly referred to as the <strong class="source-inline">main</strong> branch) and resist any pressure to create<a id="_idIndexMarker705"/> other long-lived development branches (see https://trunkbaseddevelopment.com).</p>
			<p>The base idea is that the main branch is always in a clean state so that any developer, at any time, can create a new branch based upon the main branch that builds successfully.</p>
			<p>To keep the branch in a clean state, developers must take multiple measures to ensure only code that does not break anything is merged back to the main branch, as outlined here:</p>
			<ul>
				<li>Fetch the newest changes from the main branch</li>
				<li>Perform a clean test</li>
				<li>Run all tests</li>
				<li>Have high cohesion with your team (pair programming or code review)</li>
			</ul>
			<p>As you can see, this is predestined <a id="_idIndexMarker706"/>for a protected main branch and <strong class="bold">pull requests</strong> (<strong class="bold">PRs</strong>) with a CI build that has a PR trigger and builds and tests your changes. However, some teams prefer to do these steps manually and directly push to <strong class="source-inline">main</strong> without branch protection. In small, highly cohesive, and co-located teams that practice pair-programming, this can be very effective, but it takes a lot of discipline. In complex environments or in distributed teams that work asynchronously, I would always recommend using branch protection and PRs.</p>
			<h1 id="_idParaDest-251"><a id="_idTextAnchor251"/>Why you should avoid complex branching</h1>
			<p>When we talk about branches, we often use the terms long-lived and short-lived, which refer to time. I find this <a id="_idIndexMarker707"/>somehow misleading. Branches are about changes, and changes can hardly be measured in time. Developers can write 8 hours of code with a lot of refactoring and try to merge that very complex branch in 1 day. This would still be considered short-lived if they measured it in time only. Conversely, if they have a branch with just one line changed—for example, the update of a package that the code depends on—but the branch stays open for 3 weeks as the team must solve some architectural questions regarding the change, from a time perspective it would be long-lived, even if it would be very simple to rebase the changes on top of <strong class="source-inline">main</strong>.</p>
			<p>Time doesn't seem to be the best measure to distinguish good and bad practices for branches; it is a combination of complexity and time.</p>
			<p>The more changes that happen in the base branch from which you created your branch until you try to merge your changes back, the harder it is to merge these changes with changes in your branch. The complexity can come from one very complex merge, or from many developers merging many small changes. To avoid merging, many teams try to finish work on a feature before merging back. This, of course, leads to more complex changes that then make it difficult for the other <a id="_idIndexMarker708"/>features to merge—so-called <strong class="bold">merge hell</strong>—whereby before releasing, all the features have to be integrated into the new release.</p>
			<p>To avoid merge hell, you should pull the latest version of the main branch regularly. As long as you can <a id="_idIndexMarker709"/>merge or rebase without problems, the integration of your branch is not a problem, but if your changes get too complex, it is a problem for the other developers, as they will probably have a problem if you merge your changes back. That's why you should merge your changes before they exceed a certain amount of complexity. The extent of the complexity depends a lot on the code you modify and you would need to consider the following points:</p>
			<ul>
				<li>Are you working with existing code or new code?</li>
				<li>Is the code complex with a lot of dependencies, or is it simple code?</li>
				<li>Are you working with isolated code or code with high cohesion?</li>
				<li>How many people change the code at the same time?</li>
				<li>Is there refactoring of a lot of code at the same time?</li>
			</ul>
			<p>I believe this is why people tend to use time as a measure instead of complexity—there is just no good measure for complexity. So, as a rule of thumb: if you work on a more complex feature, you should at least merge your changes back to the main branch once a day, but if your changes are simple, there is no problem leaving your branch/PR open for a longer time. Remember that it is not about time but complexity!</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor252"/>Other git workflows</h1>
			<p>Before <a id="_idIndexMarker710"/>we have a closer look into what I believe to be the most effective <strong class="source-inline">git</strong> <strong class="bold">workflow</strong> for DevOps teams using GitHub, I want <a id="_idIndexMarker711"/>to make an introduction to the most popular workflows.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor253"/>Gitflow</h2>
			<p><strong class="bold">Gitflow</strong> is still <a id="_idIndexMarker712"/>one of the most popular workflows. It was introduced in 2010 by Vincent Driessen (see https://nvie.com/posts/a-successful-git-branching-model/) and became very popular. <strong class="bold">Gitflow</strong> has a nice poster, and it is a very descriptive introduction <a id="_idIndexMarker713"/>on how to solve problems in <strong class="source-inline">git</strong> such as releasing using tags and working with branches that get deleted after they have been merged (see <em class="italic">Figure 11.1</em>):</p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B17827_11_001.jpg" alt="Figure 11.1 – Gitflow overview&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Gitflow overview</p>
			<p>Gitflow is great if you ship your software every few months to different customers, want to bundle some features to a new major version that is licensed separately, and have to maintain many versions for many years. In 2010, this was the common release flow for nearly all software, but in complex environments, the workflow raises some problems. The workflow is <em class="italic">not</em> trunk-based and has multiple long-lived branches. The integration between these branches can lead to merge hell in complex environments. With the rise of DevOps and CI/CD practices, the workflow got a bad reputation.</p>
			<p>If you want to accelerate your software delivery with DevOps, Gitflow is not the right branching workflow for you! But many of the concepts can be found in other workflows.</p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor254"/>GitHub flow</h2>
			<p><strong class="bold">GitHub flow</strong> focuses a lot on collaboration with PRs. You create a branch with a descriptive name <a id="_idIndexMarker714"/>and make your first changes. Then, you create a PR and collaborate with your reviewers through comments on the code. Once the <a id="_idIndexMarker715"/>PR is ready, it gets shipped to production <em class="italic">before</em> merging it to the main branch (see <em class="italic">Figure 11.2</em>) </p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B17827_11_002.jpg" alt="Figure 11.2 – GitHub flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – GitHub flow</p>
			<p>GitHub flow is trunk-based, and it is very popular. The basic part—without the deployment of PRs—is the base for most other workflows. The problem is the deployment. Deploying each PR to production creates a bottleneck and does not scale very well. GitHub <a id="_idIndexMarker716"/>itself uses ChatOps and deploy trains to solve that issue (Aman Gupta, 2015), but this seems a bit of overkill to me. The idea that only changes that have proven to work in production are merged to <strong class="source-inline">main</strong> is compelling, but it is a goal that basically cannot be reached in complex environments. You would need quite some time to see the changes work isolated in production to really be sure that they did not break anything, but with that time, the bottleneck prevents other teams or team members to merge their changes. I think that in a DevOps <a id="_idIndexMarker717"/>world with the principles of <strong class="bold">fail fast</strong> and <strong class="bold">roll forward</strong>, it's best <a id="_idIndexMarker718"/>to validate PRs in an isolated environment and deploy them to production <em class="italic">after</em> you have merged the PR using the <strong class="source-inline">push</strong> trigger of your main branch. If the changes break production, you still can deploy the last version that worked (<strong class="bold">roll back</strong>), or you fix the error and deploy the fix right away (<strong class="bold">roll forward</strong>). You don't need a clean main branch to perform either of these options.</p>
			<p>Another thing I dislike about GitHub flow is that it is not very explicit about the number of users, branches, and PRs. A feature branch might imply that multiple persons commit to the same feature branch. I don't see this happen often, but just from the documentation, it is not unambiguous.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor255"/>Release flow</h2>
			<p>Release flow is based <a id="_idIndexMarker719"/>upon GitHub flow, but instead of deploying PRs <a id="_idIndexMarker720"/>continuously, it adds one-way release branches. The branches do not get merged back, and bug <a id="_idIndexMarker721"/>fixes follow the <strong class="bold">upstream-first</strong> principle: they get fixed in a branch of <strong class="source-inline">main</strong>, and changes get cherry-picked into a branch of the release branch (Edward Thomson, 2018). This way, it is impossible to forget to apply a bug fix to <strong class="source-inline">main</strong> (see <em class="italic">Figure 11.3</em>):</p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B17827_11_003.jpg" alt="Figure 11.3 – Release flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – Release flow</p>
			<p>Release flow is not CD! Creating releases is still a process that has to be triggered separately. If you have to maintain different versions of your software, release flow is a good way to do it. But if you can, you should try to achieve CD.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor256"/>GitLab flow</h2>
			<p>GitLab flow is <a id="_idIndexMarker722"/>also based <a id="_idIndexMarker723"/>upon GitHub flow. It adds environment branches (such as development, staging, pre-production, and production), and each deployment happens on a merge to these environments (see <em class="italic">Figure 11.4</em>): </p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B17827_11_004.jpg" alt="Figure 11.4 – GitLab environment branches&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – GitLab environment branches</p>
			<p>Since the <a id="_idIndexMarker724"/>changes only flow downstream, you can be sure that all changes are <a id="_idIndexMarker725"/>tested in all environments. GitLab flow also follows the <strong class="bold">upstream-first</strong> principle. If you find a bug in one of the environments, you create a feature<a id="_idIndexMarker726"/> branch of <strong class="source-inline">main</strong> and cherry-pick changes to all environments. Bug fixing works in GitLab flow the same way it works in release flow.</p>
			<p>If you don't have pipelines that support multiple environments—such as GitHub Actions—GitLab flow might provide a nice way to automate your approvals and deployments for your environments. Personally, I don't see the value in having code for environments separated if you perform bug fixes upstream anyway. I prefer to build the code once and then deploy the output to all environments in a sequence. But there might be situations in which this workflow makes sense—for example, for static websites that deploy directly from the repository.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor257"/>Accelerating with MyFlow</h1>
			<p>As you can see, <strong class="source-inline">git</strong> workflows are just a collection of solutions for different use cases. The main difference <a id="_idIndexMarker727"/>is in whether they are trunk-based or not and if they are explicit about some things or not. As I find all workflows lacking something, I created my own workflow: <strong class="bold">MyFlow</strong>.</p>
			<p>MyFlow is a lightweight, trunk-based workflow based on PRs. MyFlow is not a new invention! Many teams already work this way. It is a very natural way to branch and merge if you focus <a id="_idIndexMarker728"/>on collaboration with PRs. I just gave it a name, and I can see people picking it up easily.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor258"/>The main branch</h2>
			<p>Since MyFlow is trunk-based, there is only one main branch called <strong class="source-inline">main</strong>, and it should always <a id="_idIndexMarker729"/>be in a clean state. The <a id="_idIndexMarker730"/>main branch should always build, and it should be possible to release it to production at any time. That's why you should protect <strong class="source-inline">main</strong> with a branch protection rule. A good branch protection rule would include at least the following criteria:</p>
			<ul>
				<li>Require a minimum of two PR reviews before merging</li>
				<li>Dismiss stale PR approvals when new commits are pushed</li>
				<li>Require reviews from code owners</li>
				<li>Require status checks to pass before merging that includes your CI build, test execution, code analysis, and linters</li>
				<li>Include administrators in restrictions</li>
				<li>Permit force pushes</li>
			</ul>
			<p>The more you automate using the CI build, the more likely you can keep your branch in a clean state.</p>
			<p>All other branches are always branched off <strong class="source-inline">main</strong>. Since this is the default branch, you never have to specify a source branch when you create a new one. This simplifies things and removes a source of error.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor259"/>Private topic branches</h2>
			<p>Figure<a id="_idIndexMarker731"/> 11.5 <a id="_idIndexMarker732"/>shows the basic concept of MyFlow:</p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B17827_11_005.jpg" alt="Figure 11.5 – Basics of MyFlow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – Basics of MyFlow</p>
			<p>Private topic branches can be used to work on new features, documentation, bugs, infrastructure, and everything else that is in your repository. They are private, which means <a id="_idIndexMarker733"/>they only belong to one specific user. Other team members can check out the branch to test the solution, but they are not allowed to <a id="_idIndexMarker734"/>directly push changes to this branch. Instead, they must use <strong class="source-inline">suggestions</strong> in PRs to suggest changes to the author of the PR.</p>
			<p>To indicate that branches are private, I recommend a naming convention such as <strong class="source-inline">users/*</strong> or <strong class="source-inline">private/*</strong> that makes this obvious. I also recommend including the <strong class="bold">identifier</strong> (<strong class="bold">ID</strong>) of the issue or bug in the name. This makes it easy to reference it later in the commit message. A good convention would look like this:</p>
			<pre class="source-code">users/<strong class="bold">&lt;username&gt;</strong>/<strong class="bold">&lt;id&gt;</strong>_&lt;topic&gt;</pre>
			<p>To start working on a new topic, you create a new local branch, as follows:</p>
			<p class="source-code">$ git switch -c &lt;branch&gt; main</p>
			<p>You can see an example here:</p>
			<p class="source-code">$ git switch -c users/kaufm/42_new-feature main</p>
			<p class="source-code">&gt; Switched to a new branch 'users/kaufm/42_new-feature'</p>
			<p>Create your first modifications and commit and push them to the server. It does not matter what you modify—you could just add a blank to a file. You can overwrite it later anyway. You can see an example here:</p>
			<p class="source-code">$ git add .</p>
			<p class="source-code">$ git commit</p>
			<p class="source-code">$ git push --set-upstream origin &lt;branch&gt;</p>
			<p>Now, here's <a id="_idIndexMarker735"/>the preceding example with further information:</p>
			<p class="source-code">$ git add .</p>
			<p class="source-code">$ git commit -m "New feature #42"</p>
			<p class="source-code">$ git push --set-upstream origin users/kaufm/42_new-feature</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that I <a id="_idIndexMarker736"/>use GitHub <strong class="bold">command-line interface</strong> (<strong class="bold">GitHub CLI</strong>) (<a href="https://cli.github.com/">https://cli.github.com/</a>) to interact with PRs as I find it easier to read and understand than to use screenshots of the web <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). You can do the same using the web UI.</p>
			<p>Create a PR and mark it as <strong class="source-inline">draft</strong>, as follows: </p>
			<p class="source-code">$ gh pr create --fill --draft</p>
			<p>This way, the <a id="_idIndexMarker737"/>team knows that you are working on that topic. A quick view of a list of open PRs should give you a nice overview of the topics the team currently is working on.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can omit the <strong class="source-inline">-m</strong> argument when committing changes and add a multiline commit message in your default editor. The first line will be the title of the PR; the rest of the message will be the body. You could also set title (<strong class="source-inline">--title</strong> or <strong class="source-inline">-t</strong>) and body (<strong class="source-inline">--body</strong> or <strong class="source-inline">-b</strong>) when creating a PR instead of <strong class="source-inline">--fill</strong>.</p>
			<p>You can now start working on your topic, and you can use the full power of <strong class="source-inline">git</strong>. If you want to add changes to your previous commit, for example, you can do so with the <strong class="source-inline">--amend</strong> option, as follows:</p>
			<p class="source-code">$ git commit --amend</p>
			<p>Or, if you want to combine the last three commits into one single commit, you can run the following command:</p>
			<p class="source-code">$ git reset --soft HEAD~3</p>
			<p class="source-code">$ git commit</p>
			<p>If you want to merge all commits in a branch into one commit, you can run the following command:</p>
			<p class="source-code">$ git reset --soft main</p>
			<p class="source-code">$ git commit</p>
			<p>Or, if you <a id="_idIndexMarker738"/>want complete freedom to rearrange and squash all your commits, you can use interactive rebase, like this:</p>
			<p class="source-code">$ git rebase -i main</p>
			<p>To push <a id="_idIndexMarker739"/>changes to the server, you use the following command:</p>
			<p class="source-code">$ git push origin +&lt;branch&gt;</p>
			<p>Here's the preceding example with the branch name populated:</p>
			<p class="source-code">$ git push origin +users/kaufm/42_new-feature</p>
			<p>Note the <strong class="source-inline">+</strong> plus sign before the branch name. This causes a force push, but only to a specific branch. If you are not messing with your branch history, you can perform a normal <strong class="source-inline">git push</strong> operation, and if your branches are well protected and you know what you are doing, a normal force push might be more convenient, as illustrated here:</p>
			<p class="source-code">$ git push -f</p>
			<p>If you already want help or the opinions of teammates on your code, you can mention them in comments in the PR. If they want to propose changes, they use the <strong class="source-inline">suggestions</strong> feature in PR comments. This way, <em class="italic">you</em> apply the changes, and you can make sure that you have a clean state in your repository before doing so.</p>
			<p>Whenever you feel your work is ready, you change the state of your PR from <strong class="source-inline">draft</strong> to <strong class="source-inline">ready</strong> and activate auto-merge, as follows:</p>
			<p class="source-code">$ gh pr ready</p>
			<p class="source-code">$ gh pr merge --auto --delete-branch --rebase</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that I specified <strong class="source-inline">--rebase</strong> as the merge method. This is a good merge strategy for small teams that like to craft a good and concise commit history. If you prefer <strong class="source-inline">--squash</strong> or <strong class="source-inline">--merge</strong>, adjust your merge strategy accordingly.</p>
			<p>Your reviewers can still create suggestions in their comments, and you can keep collaborating. But once all approvals and all automated checks have completed, the PR will be merged <a id="_idIndexMarker740"/>automatically and the branch gets deleted. Automated checks run on the <strong class="source-inline">pull_request</strong> trigger and can include installing the <a id="_idIndexMarker741"/>application in an isolated environment and running all sorts of tests.</p>
			<p>If your PR has been merged and the branch has been deleted, you clean up your local environment, like this:</p>
			<p class="source-code">$ git switch main</p>
			<p class="source-code">$ git pull --prune</p>
			<p>This will change your current branch to <strong class="source-inline">main</strong>, pull the changed branch from the server, and delete local branches that have been deleted on the server.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor260"/>Releasing</h2>
			<p>Once your changes are merged to <strong class="source-inline">main</strong>, the <strong class="source-inline">push</strong> trigger on <strong class="source-inline">main</strong> will start the deployment <a id="_idIndexMarker742"/>to production, independent of whether you use environments or a ring-based approach.</p>
			<p>If you have <a id="_idIndexMarker743"/>to maintain multiple versions, you can use tags <a id="_idIndexMarker744"/>together with <strong class="bold">GitHub releases</strong> (as I showed you in <a href="B17827_08_Epub.xhtml#_idTextAnchor203"><em class="italic">Chapter 8</em></a>, <em class="italic">Managing Dependencies Using GitHub Packages</em>). Use the <strong class="source-inline">release</strong> trigger in a workflow and deploy the application, and use <strong class="source-inline">GitVersion</strong> to automatically generate your version numbers, as illustrated here:</p>
			<p class="source-code">$ gh release create &lt;tag&gt; --notes "&lt;release notes&gt;"</p>
			<p>Here's an example of this:</p>
			<p class="source-code">$ gh release create v1.1 --notes "Added new feature"</p>
			<p>You can also take advantage of the autogeneration of release notes. Unfortunately, this feature is <a id="_idIndexMarker745"/>not yet available through the CLI. You must create your <a id="_idIndexMarker746"/>release using the UI for that to work.</p>
			<p>As we fix bugs following the <strong class="bold">upstream-first</strong> principle anyway, there is no real benefit in creating a release branch for every release if we don't have to perform a hotfix. The tag that is generated when you create your release works just fine.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor261"/>Hotfix</h2>
			<p>If you have to <a id="_idIndexMarker747"/>provide a hotfix for older releases, you can check out <a id="_idIndexMarker748"/>the tag and create a new hotfix branch, like this:</p>
			<p class="source-code">$ git switch -c &lt;hotfix-branch&gt; &lt;tag&gt;</p>
			<p class="source-code">$ git push --set-upstream origin &lt;branch&gt;</p>
			<p>Here's an example of this:</p>
			<p class="source-code">$ git switch -c hotfix/v1.1.1 v1.1</p>
			<p class="source-code">$ git push --set-upstream origin hotfix/1.1.1</p>
			<p>Now, switch back to <strong class="source-inline">main</strong> and fix the <a id="_idIndexMarker749"/>bug in a <strong class="bold">normal topic branch</strong> (for example, <strong class="source-inline">users/kaufm/666_fix-bug</strong>). Now, <strong class="bold">cherry-pick</strong> the commit with the fix to the hotfix branch, as follows:</p>
			<p class="source-code">$ git switch &lt;hotfix-branch&gt;</p>
			<p class="source-code">$ git cherry-pick &lt;commit SHA&gt;</p>
			<p class="source-code">$ git push</p>
			<p>You can <a id="_idIndexMarker750"/>use the <strong class="bold">secure hash algorithm</strong> (<strong class="bold">SHA</strong>) of the commit you want to cherry-pick. Or you can use the name of the branch if the commit is the tip of the branch, as follows:</p>
			<p class="source-code">$ git switch hotfix/v1.1.1</p>
			<p class="source-code">$ git cherry-pick users/kaufm/42_fix-bug</p>
			<p class="source-code">$ git push</p>
			<p>This will cherry-pick the tip of the topic branch. <em class="italic">Figure 11.6</em> shows how a hotfix for an older release works:</p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B17827_11_006.jpg" alt="Figure 11.6 – Performing hotfixes on older releases&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – Performing hotfixes on older releases</p>
			<p>You could <a id="_idIndexMarker751"/>also merge the fix to <strong class="source-inline">main</strong> first and then cherry-pick <a id="_idIndexMarker752"/>the commit from there. This ensures that the code adheres to all your branch policies.</p>
			<p>You could also cherry-pick into a temporary branch based on the hotfix branch and merge the cherry-picked fix using another PR. This depends on how complex your environment is and how big the differences between the main and hotfix branches are.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor262"/>Automation</h2>
			<p>If you have <a id="_idIndexMarker753"/>a workflow with naming conventions, there are <a id="_idIndexMarker754"/>certain sequences of commands that you use very often. To reduce typos and simplify your workflow, you can automate these using <strong class="source-inline">git</strong> <strong class="bold">aliases</strong>. The best <a id="_idIndexMarker755"/>way to do this is to edit your <strong class="source-inline">.gitconfig</strong> file in the editor of your choice, like this:</p>
			<p class="source-code">$ git config --global --edit</p>
			<p>Add a section, <strong class="source-inline">[alias]</strong>, if it does not exist yet and add an alias, like this:</p>
			<pre class="source-code">[alias]</pre>
			<pre class="source-code">    mfstart = "!f() { \</pre>
			<pre class="source-code">        git switch -c users/$1/$2_$3 &amp;&amp; \</pre>
			<pre class="source-code">        git commit &amp;&amp; \</pre>
			<pre class="source-code">        git push --set-upstream origin users/$1/$2_$3 &amp;&amp; \</pre>
			<pre class="source-code">        gh pr create --fill --draft; \</pre>
			<pre class="source-code">    };f"</pre>
			<p>This alias is called <strong class="source-inline">mfstart</strong> and would <a id="_idIndexMarker756"/>be called specifying the username, issue ID, and topic, as illustrated here:</p>
			<p class="source-code">$ git mfstart kaufm 42 new-feature</p>
			<p>It switches to <a id="_idIndexMarker757"/>a new branch and commits the current changes in the index, pushes them to the server, and creates a PR.</p>
			<p>You can <a id="_idIndexMarker758"/>reference individual arguments (<strong class="source-inline">$1</strong>, <strong class="source-inline">$2</strong>, …) or all arguments using <strong class="source-inline">$@</strong>. If you want to chain commands independent of the exit code, you must terminate a command using <strong class="source-inline">;</strong>. If you want the next command only to execute if the first one was successful, you can use <strong class="source-inline">&amp;&amp;</strong>. Note that you have to end each line with a backslash (<strong class="source-inline">\</strong>). This is also the character you use to escape quotation marks.</p>
			<p>You can add <strong class="source-inline">if</strong> statements to branch your logic, like so:</p>
			<pre class="source-code">mfrelease = "!f() { \</pre>
			<pre class="source-code">    if [[ -z \"$1\" ]]; then \</pre>
			<pre class="source-code">        echo Please specify a name for the tag; \</pre>
			<pre class="source-code">    else \</pre>
			<pre class="source-code">        gh release create $1 --notes $2; \</pre>
			<pre class="source-code">    fi; \</pre>
			<pre class="source-code">};f"</pre>
			<p>Or, you can store values in variables to use them later, as in this example—the current name of the branch your head (<strong class="source-inline">HEAD</strong>) points to:</p>
			<pre class="source-code">mfhotfix = "!f() { \</pre>
			<pre class="source-code">    head=$(git symbolic-ref HEAD --short); \</pre>
			<pre class="source-code">    echo Cherry-pick $head onto hotfix/$1 &amp;&amp; \</pre>
			<pre class="source-code">    git switch -c hotfix/$1 &amp;&amp; \</pre>
			<pre class="source-code">    git push --set-upstream origin hotfix/$1 &amp;&amp; \</pre>
			<pre class="source-code">    git cherry-pick $head &amp;&amp; \</pre>
			<pre class="source-code">    git push; \</pre>
			<pre class="source-code">};f"</pre>
			<p>These are <a id="_idIndexMarker759"/>just examples and the automation depends a lot <a id="_idIndexMarker760"/>on the details of the way you work, but it is a very powerful tool and can help you to become more productive.</p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor263"/>Case study</h1>
			<p>With the<a id="_idIndexMarker761"/> automation of the release process in place, the two pilot teams have already noted a great boost in productivity. Metrics for <strong class="bold">lead time</strong> and <strong class="bold">deployment frequency</strong> have increased significantly.</p>
			<p>The team that used <strong class="source-inline">git</strong> before they moved <a id="_idIndexMarker762"/>from Bitbucket to GitHub followed <strong class="bold">Gitflow</strong> as their branching workflow. Since their web application can be released continuously using <a id="_idIndexMarker763"/>their staged deployment workflow, they move to a <strong class="bold">trunk-based</strong> workflow with PR and private branches and deploy after the merge to the main branch using their CI/CD workflow (<strong class="bold">MyFlow</strong>). To integrate often, they decide to use <strong class="bold">feature flags</strong>. As <a id="_idIndexMarker764"/>the company needs feature management in the cloud and on-premises, they <a id="_idIndexMarker765"/>decide to go with <strong class="bold">Unleash</strong>. The team can <a id="_idIndexMarker766"/>use the <strong class="bold">software-as-a-service</strong> (<strong class="bold">SaaS</strong>) service and can start using it right away without having to wait for an on-premises solution.</p>
			<p>The second team <a id="_idIndexMarker767"/>that migrated from <strong class="bold">Team Foundation Server</strong> (<strong class="bold">TFS</strong>) had been used to a complex branching workflow with a long-living release, service pack, hotfix branches, and a development branch where all features were integrated. As the software is installed on hardware products, multiple releases are stabilized in parallel, and also multiple versions that have to be maintained for years. This means the software cannot be continuously released. The team chooses <strong class="bold">release flow</strong> to manage <a id="_idIndexMarker768"/>releases and hotfixes. For development, they also use private <a id="_idIndexMarker769"/>branches with PRs and a trunk-based approach. As the products are not connected to the internet, the team relies on their configuration system for feature flags. This technique had been used before to enable the testing of new features on hardware. The team now extends it to integrate changes more frequently.</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor264"/>Summary</h1>
			<p><strong class="source-inline">git</strong> workflows are not so different from each other, and most are built on top of others. It is more important to follow the principles of <strong class="bold">fail fast</strong> and <strong class="bold">roll forward</strong> instead of treating a certain workflow like a dogma. All workflows are just a collection of best practices, and you should only take what you need.</p>
			<p>What is important is the size of your changes and the frequency in which you merge them back.</p>
			<p>Always follow these rules:</p>
			<ul>
				<li>Always branch your topic branches of the main branch (<strong class="bold">trunk-based</strong>).</li>
				<li>If you're working on complex features, make sure to commit at least <strong class="bold">once per day</strong> (using feature flags).</li>
				<li>If your changes are simple and you only need to change a few lines of code, you can leave your PR open for a longer time. But check that you don't have too many <strong class="bold">open PRs</strong>.</li>
			</ul>
			<p>With these rules, the workflow you are actually using is not so important. Pick the things that work for you.</p>
			<p>In this chapter, you learned about the benefits of TBD and how you can use it together with <strong class="source-inline">git</strong> workflows to increase your engineering velocity.</p>
			<p>In the next chapter, I will explain how you can use shift-left testing for increased quality and to release with more confidence.</p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor265"/>Further reading</h1>
			<p>You can use the following references from this chapter to get more information on the topics covered:</p>
			<ul>
				<li><em class="italic">Forsgren N.</em>, <em class="italic">Humble, J.</em>, and <em class="italic">Kim, G.</em> (2018). <em class="italic">Accelerate: The Science of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations</em> (1st ed.) [E-book]. IT Revolution Press.</li>
				<li>Trunk-based development: <a href="https://trunkbaseddevelopment.com">https://trunkbaseddevelopment.com</a></li>
				<li>Gitflow: <em class="italic">Vincent Driessen</em> (2010), <em class="italic">A successful Git branching model</em>: <a href="https://nvie.com/posts/a-successful-git-branching-model/">https://nvie.com/posts/a-successful-git-branching-model/</a></li>
				<li><em class="italic">GitLab flow</em>: <a href="https://docs.gitlab.com/ee/topics/gitlab_flow.html">https://docs.gitlab.com/ee/topics/gitlab_flow.html</a></li>
				<li><em class="italic">Edward Thomson</em> (2018). <em class="italic">Release Flow: How We Do Branching on the VSTS Team</em>: <a href="https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/">https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/</a></li>
				<li><em class="italic">Aman Gupta</em> (2015). <em class="italic">Deploying branches to GitHub.com</em>: <a href="https://github.blog/2015-06-02-deploying-branches-to-github-com/">https://github.blog/2015-06-02-deploying-branches-to-github-com/</a> </li>
				<li><em class="italic">GitHub flow</em>: <a href="https://docs.github.com/en/get-started/quickstart/github-flow">https://docs.github.com/en/get-started/quickstart/github-flow</a></li>
				<li>GitHub CLI: <a href="https://cli.github.com/">https://cli.github.com/</a> </li>
			</ul>
		</div>
	</body></html>