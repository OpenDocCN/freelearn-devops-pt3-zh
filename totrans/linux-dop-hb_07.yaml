- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git, Your Doorway to DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is a free and open source **version control system** (**VCS**) that is widely
    used by software developers and teams to track changes to their code base and
    collaborate on projects. It allows multiple people to work on the same code base
    without overwriting each other’s changes, and it keeps a record of every change
    made to the code, making it easy to roll back to a previous version if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Git was created by Linus Torvalds in 2005 for the development of the Linux kernel,
    and it has since become the de facto standard for version control in the software
    industry. It is used by millions of developers worldwide and is supported by a
    large and active open source community.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the most commonly used Git commands and how to
    use them. We will start with the basics of setting up a Git repository and making
    your first commit, and then move on to more advanced topics such as branching
    and merging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic Git commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local versus remote Git repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitFlow and GitHub Flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will need a system with a Bash shell. You will have to
    have the Git command available or be able to install it in this system. We prefer
    Linux or macOS systems, but it is possible to set up Windows to have functional
    Bash and Git. The installation of this environment is beyond the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Git commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many commands that you can use with Git, but some of the most commonly
    used ones include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git config`: This is the command used to configure your local Git environment.
    The configuration can be global; the values will then be kept in your home directory
    in the `.gitconfig` file. The values can only be set per repository, and then
    they will be kept within the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git init`: This initializes a new Git repository. When you run this command
    in a directory, it creates a new `.git` directory in the root of the project,
    which is used to track changes made to the project’s files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git clone`: This creates a local copy of a remote Git repository. When you
    run this command, it creates a new directory with the same name as the repository
    and clones all of the files and their history into that directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git add`: This stages files for commit. When you make changes to a file in
    a Git repository, those changes are not automatically tracked. You must use the
    `git add` command to tell Git to track changes you have made.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git commit`: This saves your changes to the Git repository. When you run this
    command, it opens a text editor for you to write a commit message, which is a
    short description of the changes you have made. After you write the commit message
    and save it, the changes you have made are saved to the repository, and a new
    commit is created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git push`: This sends your local commits to a remote repository. When you
    run this command, it pushes all of your local commits to the remote repository,
    updating the project’s history and making your changes visible to other developers
    working on the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git pull`: This retrieves updates from a remote repository and merges them
    into your local repository. When you run this command, it fetches the latest changes
    from the remote repository and merges them into your local repository, bringing
    your copy of the project up to date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git branch`: This creates, lists, or deletes branches in a Git repository.
    Branches allow you to work on multiple versions of a project simultaneously and
    are often used for feature development or bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git checkout` or `git switch`: This switches between branches or restores
    files in your working directory. When you run this command, it switches your working
    directory to the branch you specify or restores the specified files to their state
    at a previous commit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git merge`: This merges one branch into another. When you run this command,
    it combines the changes made in the specified branch into the current branch,
    creating a new commit that represents the combined changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash`: This temporarily stores changes that you are not ready to commit.
    When you run this command, it saves your changes to a temporary area and restores
    your working directory to the state it was in at the last commit. You can later
    use the `git stash apply` command to restore the stashed changes to your working
    directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the local Git environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before using the Git command, there are at least two options you should set.
    They are your name and your email address. This is done using the `git config`
    command. Ahead, I am going to demonstrate setting up the name of the Git user
    and their email address. We are going to set up the global variables. They will
    be used by default for every repository cloned locally unless set up specifically
    for a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we take a look at the `~/.gitconfig` file, we will see this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are more configuration options, such as default editor, and so on, but
    they are out of scope for this section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a local Git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can start using Git, you need to create a **repository** (also known
    as a **repo**). A repository is a directory where Git stores all the files and
    metadata for a project.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new repository, you can use the `git init` command. This creates
    a new directory with a `.git` subdirectory, which contains all the necessary files
    for the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to create a new repository in the current directory, you can run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new repository in the current directory and sets up the necessary
    files and metadata. Once you have a Git repository set up, you can start adding
    and committing files to it.
  prefs: []
  type: TYPE_NORMAL
- en: To add a file to the repository, you can use the `git add` command. This adds
    the file to the staging area, which is a list of changes that will be included
    in the next commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a file called `main.c` to the staging area, you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add multiple files or directories by separating their names with
    a space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To commit changes in the staging area, you can use the `git commit` command.
    This creates a new commit that includes all changes in the staging area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every commit needs to have a commit message. This is a short description of
    the changes you’re making. To specify a commit message, you can use the `-m` option
    followed by the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `git commit` command without the `-m` option to open a
    text editor where you can write a more detailed commit message.
  prefs: []
  type: TYPE_NORMAL
- en: On every step while working in your Git repository, you can use the `git status`
    command. This is used to view the current state of a Git repository. It shows
    which files have been modified, added, or deleted, and whether they have been
    staged for commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are numerous ways to format a commit message, and almost every project
    has its own convention. In general, a good practice is to add an ID of `issue`
    from the ticketing system, followed by a short description that has 72 characters
    or fewer. The second line should be left empty, and a more detailed description
    follows on line three. Here’s an example of such a commit message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When you run `git status`, it will display a list of modified files, as well
    as any untracked files that are present in the repository. It will also show the
    current branch and the status of the staging area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the output of the `git` `status` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `git status` shows that two files have been modified (`main.py`
    and `__init__.py`) and one file is untracked (`main.py`). It also indicates that
    the current branch is `main` and that the branch is up to date with the `origin/main`
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: '`git status` is a useful tool to understand the current state of your repository
    and to identify which files have been modified and need to be committed. You can
    use it to get a quick overview of changes that have been made and to see which
    files are ready to be committed. You can also use it to see which branch you are
    currently on, and whether you are up to date with the remote repository.'
  prefs: []
  type: TYPE_NORMAL
- en: The `git revert` command is used to undo changes that have been made to a repository.
    It does this by creating a new commit that undoes the changes introduced by a
    previous commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that you have made several commits to your repository,
    and you want to undo the changes introduced by the last commit. You can use the
    `git revert` command to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new commit that undoes the changes introduced by the last
    commit. The commit history of your repository will now look as if the last commit
    never happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `git revert` command to undo the changes introduced by
    a specific commit. To do this, you need to specify the commit hash of the commit
    that you want to revert:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new commit that undoes the changes introduced by the commit
    with the `abc123` hash.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that `git revert` does not delete commits or destroy
    history. Instead, it creates a new commit that undoes the changes introduced by
    a previous commit. This means that the changes are still present in the repository,
    but they are no longer visible in the current state of the branch.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to permanently delete commits, you can use the `git reset` command
    or the `git filter-branch` command. However, these commands can permanently destroy
    history, so you should use them with extreme caution.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to work on our local repository, we can talk about remote
    and local copies of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Local versus remote Git repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Git, a **repository** is a collection of files and their history, as well
    as configuration files that are used to manage the repository. A repository can
    be either local or remote.
  prefs: []
  type: TYPE_NORMAL
- en: A `git init` command or when you clone an existing repository using the `git
    clone` command, you are creating a local repository. Local repositories are useful
    for working on projects when you don’t have an internet connection or when you
    want to keep a copy of the project on your own machine.
  prefs: []
  type: TYPE_NORMAL
- en: A `git push` command, you are updating the remote repository with your local
    changes. Remote repositories are useful for collaborating with other developers,
    as they allow multiple people to work on the same project and share their changes
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Git uses a distributed VCS, which means that each developer has a complete copy
    of the repository on their local machine. This allows developers to work on the
    project locally and push their changes to a remote repository when they are ready
    to share them with others. It also allows developers to collaborate on a project
    even when they are not connected to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: The `git clone` command is used to create a local copy of a remote Git repository.
    When you run this command, it creates a new directory with the same name as the
    repository and clones all of the files and their history into that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of how you might use the `git` `clone` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new directory called `repo` and clone the repository located
    at [https://github.com/user/repo.git](https://github.com/user/repo.git) into that
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify a different name for the local directory by adding it
    as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new directory called `my-local-repo` and clone the repository
    into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a Git hosting service such as GitHub, you can also use a shorthand
    version of the repository URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will clone the repository using the SSH protocol, which requires you to
    have an SSH key configured for your account.
  prefs: []
  type: TYPE_NORMAL
- en: The `git clone` command is a useful way to create a local copy of a remote repository,
    whether you are starting a new project or contributing to an existing one. It
    allows you to work on a project locally and push your changes back to the remote
    repository when you are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with remote repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `git pull` command is used to retrieve updates from a remote repository
    and merge them into your local repository. It is a combination of the `git fetch`
    command, which downloads updates from the remote repository, and the `git merge`
    command, which merges updates into your local repository.
  prefs: []
  type: TYPE_NORMAL
- en: The `git fetch` command downloads updates from the remote repository but does
    not merge them into your local repository. Instead, it stores the updates in a
    temporary area called *remote-tracking branches*. You can use the `git fetch`
    command to update your remote-tracking branches and see which changes are available,
    but you will need to use the `git merge` command to actually incorporate those
    changes into your local repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some common keywords that you might use when working with `git fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`origin`: This is the default name for the remote repository that you cloned
    from. You can use `origin` to specify the remote repository that you want to fetch
    updates from. It’s also possible to change the default name and add multiple remote
    repositories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`main` or `master`: `master` is the name of the default branch in a Git repository.
    `main` is the new default name introduced in the GitHub platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REMOTE_HEAD`: This is a special reference that points to the `head` commit
    of the branch on the remote repository. You can use `REMOTE_HEAD` to fetch updates
    for the branch that is currently checked out on the remote repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HEAD`: This is a special reference that points to the `head` commit of the
    current branch in your local repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of using `git fetch` to update the main branch on the `origin`
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will download updates for the `master` branch on the `origin` repository
    and store them in the `origin/master` remote-tracking branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then use the `git merge` command to merge the updates into your local
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will incorporate the updates from the `origin/master` remote-tracking branch
    into your local `master` branch. In this case, we do not have anything to be merged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the `git pull` command to accomplish both steps
    in a single command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will fetch the updates from the `origin` repository and merge them into
    your local repository unless you’ve configured your Git client, as we suggested
    at the beginning of this chapter—in this case, Git will try to rebase against
    the `main` branch in a remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: '`git rebase` and `git merge` are commands that are both used to integrate changes
    from one branch into another branch. However, they work in slightly different
    ways and have different implications for your repository.'
  prefs: []
  type: TYPE_NORMAL
- en: '`git rebase` is a command that is used to apply a series of commits from one
    branch into another branch. When you run `git rebase`, it looks at commits that
    are present in the target branch but not in the source branch, and applies them
    one by one to the source branch. This has the effect of *replaying* the commits
    from the source branch on top of the target branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine that you have two branches in your repository: `main`
    and `develop`. `main` represents the main development branch, and `develop` represents
    a feature that you are working on. If you make several commits to the `develop`
    branch and then run `git rebase main`, Git will apply those commits to the `main`
    branch one by one, as if you had made them directly on the `main` branch.'
  prefs: []
  type: TYPE_NORMAL
- en: '`git merge`, however, is a command that is used to combine changes from one
    branch into another branch. When you run `git merge`, it looks at changes that
    are present in the source branch and applies them to the target branch in a single
    commit. This has the effect of creating a new commit on the target branch that
    incorporates all changes from the source branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you have the same two branches as in the rebase example: `main`
    and `develop`. If you make several commits to the `develop` branch and then run
    `git merge develop`, Git will create a new commit on the `main` branch that incorporates
    all of the changes from the `develop` branch.'
  prefs: []
  type: TYPE_NORMAL
- en: Both `git rebase` and `git merge` are useful tools for integrating changes from
    one branch into another, but they have different implications for your repository.
    `git rebase` keeps a linear history and avoids unnecessary additional (merge)
    commits, but it can also cause conflicts if the target branch has been modified
    since the source branch was created.
  prefs: []
  type: TYPE_NORMAL
- en: '`git merge` is a more straightforward way to combine changes, but it can create
    a lot of merge commits, which can make the history of the repository more difficult
    to read, even with graphical tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Before merging or rebasing our local repository against a remote version of
    it, it’s useful to check what the differences are between the two. For that purpose,
    we have the `git` `diff` command.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the git diff command?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `git diff` command is used to compare changes that have been made to a repository.
    It shows the differences between two versions of a file or between two branches
    in the repository (local or remote).
  prefs: []
  type: TYPE_NORMAL
- en: Here are some common uses of the `git` `diff` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare the differences between the current state of a file and the most recent
    commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will show the differences between the current state of the file and the
    version that was last committed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare the differences between two commits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will show the differences between the two commits you’ve provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare the differences between a branch and its upstream branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will show the differences between the specified branch and its upstream
    counterpart branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare the differences between the staging area and the most recent commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will show the differences between changes that have been added to the staging
    area and the most recent commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve already added some files to be committed but want to double-check
    before creating a commit, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will show you all the changes to files you’ve performed the `git add` command
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare local and remote branches of the same repository, you will need
    to refer to the remote branch, which can be done by executing `git diff`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`origin/main` refers to a remote branch where the remote repository is named
    as an “origin.”'
  prefs: []
  type: TYPE_NORMAL
- en: '`git diff` is useful for understanding what changed in the Git repository and
    how those changes will be incorporated when you commit them. You can use the various
    options and arguments of the `git diff` command to specify versions of the files
    or branches you want to compare.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we’ve covered comparing changes in your repository, there’s one particular
    case where this is a highly useful skill to have: solving conflicts in your repository
    while rebasing or merging your changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the commit history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git keeps a record of every commit made to a repository, and you can view the
    commit history using the `git log` command. This displays a list of all commits
    in the repository, along with their commit messages and the date they were made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common use cases for the `git log` command include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git log` to view the entire commit history of a repository, including changes
    that have been made and the reasons for those changes. This can be helpful when
    you are working on a project and need to understand how it has evolved over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git log` to view the commit history of the affected files and see which commit
    introduced the bug.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git log` to view the history of the affected files and see what changes might
    have caused the issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a variety of options with `git log` to customize its output and
    filter commits that are displayed. For example, you can use the `--author` option
    to display only commits made by a specific person or the `--since` option to display
    only commits made in the last month.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some examples of using the `git` `log` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the commit history for the current repository, invoke a `git` `log`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the commit history for a specific file by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this command, you can display the commit history for a specific branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will display the commit history for the specified branch, showing only
    the commits that were made on that branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can display the commit history for a range of commits with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will display the commit history for a range of commits between the `hash1`
    commit ID and the `hash2` commit ID, showing only the commits that occurred in
    that range.
  prefs: []
  type: TYPE_NORMAL
- en: '`git log --oneline` will display the commit history in a compact format, showing
    only the commit hash and a message for each commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this command, you can display the commit history with diffs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will display the commit history, along with the diffs for each commit,
    showing the changes that were made in each commit.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few examples of how you can use the `git log` command. You
    can find more information about the available options in the Git documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to look into shortening our Git history before
    merging our changes back to the `main` branch. This is useful if we have a very
    long commit history in our local development branch.
  prefs: []
  type: TYPE_NORMAL
- en: Branching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`git branch` and `git switch` are two commands that are used to manage branches
    in a Git repository.'
  prefs: []
  type: TYPE_NORMAL
- en: '`git branch` is a command that is used to create, list, or delete branches
    in a repository. You can use it to create a new branch by specifying the name
    of the branch as an argument, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new branch called `new-branch` that is based on the current
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `git branch` command with the `-a` option to list all branches
    in the repository, including both local branches and remote-tracking branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `git branch` command with the `-d` option to delete a branch,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will delete the `old branch` but only if it has been already fully merged
    into the upstream branch. If you wish to remove this branch, you can add a `--force`
    option or use the `-D` option, which is an alias to the `--delete --force` Git
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to remove a remote branch, we will need to use the `git push` command
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is a destructive command and can’t be undone, so you should act with caution
    when using it.
  prefs: []
  type: TYPE_NORMAL
- en: '`git switch` is a command that is used to switch between branches in a repository.
    You can use it to switch to a different branch by specifying the name of the branch
    as an argument, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will switch to the `new-branch` branch and make it the current branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `git branch` and `git switch` commands allow you to create new branches,
    list available branches, and switch between branches as needed. In the next section,
    we are going to introduce ways of working with Git, called workflows: `git workflow`
    and `github workflow`.'
  prefs: []
  type: TYPE_NORMAL
- en: Squashing commits using an interactive rebase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To squash commits using `git rebase`, you first need to determine the range
    of commits that you want to squash. This is typically done by specifying the commit
    hash of the first commit in the range and the commit hash of the last commit in
    the range. For example, if you want to squash the last three commits in your repository,
    you could use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This will open an editor window showing a list of the last three commits, along
    with some instructions. Each commit is represented by a line in the file, and
    the line begins with the word `pick`. To squash a commit, you need to change the
    word `pick` to `squash` or `s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of what the file might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To squash the second and third commits into the first commit, you would change
    the file to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: After making the changes, you can save and close the file. Git will then apply
    the changes and present you with another editor window, where you can enter a
    new commit message for the combined commit.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that squashing commits using `git rebase` can be a destructive
    operation, as it permanently alters the commit history of the repository. It is
    generally recommended to use `git rebase` with caution and to make sure that you
    have a backup of your repository before using it.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to undo changes made by a `git rebase` operation, you can use the
    `git rebase --abort` command to discard the changes and restore the repository
    to its previous state.
  prefs: []
  type: TYPE_NORMAL
- en: After successfully squashing commits, you will be able to push it back to a
    remote repository, but only by using the `git push --force` command, which will
    ignore the fact that you just rewrote a commit history of this branch. This is
    a destructive operation and can’t be undone, so again, please double- and triple-check
    before pushing changes with the `--``force` option.
  prefs: []
  type: TYPE_NORMAL
- en: Solving Git conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conflicts can occur when you are trying to merge or rebase branches that have
    conflicting changes. This can happen when the same lines of code have been modified
    in both branches, and Git is unable to automatically resolve the conflicts.
  prefs: []
  type: TYPE_NORMAL
- en: When a conflict occurs during a merge or rebase, Git will mark the conflicting
    lines in the affected files, and you will need to manually resolve the conflicts
    before you can continue.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of how you might resolve a conflict during a merge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `git merge` to merge the two branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Git will detect any conflicts and mark the affected lines in the affected files.
    The conflicting lines will be surrounded by `<<<<<<<`, `=======`, and `>>>>>>>`
    markers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the affected files and resolve the conflicts by choosing which version
    of the code you want to keep. You can keep either the version from the current
    branch (`HEAD`) or the version from the branch that you are merging (`branch-to-merge`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Stage the resolved files using `git add`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue the merge or rebase by running `git rebase --continue` or `git` `merge
    --continue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Resolving conflicts during a merge or rebase can be a tedious process, but it
    is an important part of working with Git. By carefully reviewing conflicting changes
    and choosing the correct version of the code, you can ensure that your repository
    remains consistent and free of errors.
  prefs: []
  type: TYPE_NORMAL
- en: It is also a good idea to regularly synchronize your local copy of the repository
    with the source branch before merging or rebasing, in case you encounter conflicts
    or other issues that you are unable to resolve. This can help you recover from
    any mistakes or accidents that might occur during the process.
  prefs: []
  type: TYPE_NORMAL
- en: There are also amazing graphical tools to solve conflicts in a bit more interactive
    manner. If you’re using an `KDiff3`, `WinMerge`, `Meld`, or one of the other options
    out there.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have explained branches, repositories, local and remote
    repositories, merging, and rebasing. Next, we will look into browsing your repository’s
    historical changes and modifying it.
  prefs: []
  type: TYPE_NORMAL
- en: GitFlow and GitHub Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`develop` and `master`. The `develop` branch is used to develop new features,
    while the `master` branch represents the current production-ready state of the
    code base. There are also several supporting branches, such as `feature`, `release`,
    and `hotfix`, which are used to manage the process of developing, releasing, and
    maintaining software.'
  prefs: []
  type: TYPE_NORMAL
- en: '`master` branch using pull requests. There is no separate `develop` branch,
    and the `master` branch is always considered to be the current production-ready
    version of the code base.'
  prefs: []
  type: TYPE_NORMAL
- en: Another branching model that is very similar is **GitLab Flow**. It’s used to
    manage the development and maintenance of software projects, and it is specifically
    designed to be used with GitLab, a web-based Git repository manager that provides
    **source code management** (**SCM**), **continuous integration** (**CI**), and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: In the GitLab Flow model, all development is done in branches, and new features
    are merged into the `master` branch using merge requests. There is no separate
    `develop` branch, and the `master` branch is always considered to be the current
    production-ready version of the code base. However, GitLab Flow does include some
    additional features and tools, such as the ability to use protected branches and
    merge request approvals, which can help teams enforce development best practices
    and maintain a high level of code quality.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look into configuring Git to our needs using configuration
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Global git configuration – .gitconfig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.gitconfig` file is a configuration file that is used to set global options
    for Git. It is typically located in the user’s `home` directory and can be edited
    using any text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common options that you may want to include in your `.gitconfig` are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user.name` and `user.email`: These options specify the name and email address
    that will be associated with your Git commits. It is important to set these options
    correctly, as they will be used to identify you as the author of the commits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color.ui`: This option enables or disables colored output in Git. You can
    set this option to `auto` to enable colored output when Git is run in a terminal
    that supports it or to `true` or `false` to always enable or disable colored output,
    respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`core.editor`: This option specifies the text editor that Git will use when
    it needs you to enter a commit message or other input. You can set this option
    to the command for your preferred text editor, such as `nano`, `vi`, or `emacs`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge.tool`: This option specifies the tool that Git will use to resolve conflicts
    when merging branches. You can set this option to the command for a visual merge
    tool, such as `kdiff3`, `meld`, or `tkdiff`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push.default`: This option specifies the behavior of the `git push` command
    when you do not specify a branch. You can set this option to `simple`, which pushes
    the current branch to the same name on the remote, or upstream, branch, which
    pushes the current branch to the remote branch that it is tracking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alias.*`: These options allow you to create aliases for Git commands. For
    example, you could set `alias.st` to `status`, which would allow you to use the
    `git st` command instead of `git status`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example `.gitconfig` file making use of the preceding options,
    with some comments after every section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `user` section defines the user and email that will be used as the author
    for every commit. The `color` section enables colors for readability purposes.
    `ui = always` will enable colors always for all output types (machine consumption
    intended or not). Other possible options are `true`, `auto`, `false`, and `never`.
  prefs: []
  type: TYPE_NORMAL
- en: The `alias` section lets you simplify some long commands while working with
    Git. It will create an alias defined on the left-hand side for a Git command,
    which you can add after the equals sign.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re defining the `ci` command as `commit`. After adding this to your `.gitconfig`
    file in your home directory, you will get another Git command: `git ci`, which
    will effectively run the `git commit` command. You can add aliases for all common
    Git commands you use daily. The following command is telling Git where to find
    a default `.``gitignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `push` setting is changing the default push behavior, which will
    require you to specify to which remote branch you’re going to push your local
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By specifying the `current` option, we instruct Git to try to push the local
    branch to a remote branch with exactly the same name as the local branch. Other
    options are set out here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nothing`: Don’t try to push anything.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matching`: Consider all branches remote and local with the same name to be
    a match and push all matches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upstream`: Push the current branch to an upstream branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simple`: This is the default option. It will refuse to push to the upstream
    if the name of the local branch differs from the name of the remote upstream branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When running the `git pull` command, Git will try to integrate remote commits
    into your local branch. By default, it will try to merge upstream, which will
    result in possibly unwanted merge commits. This will change the default behavior
    to `rebase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: See the *Local versus remote Git repositories* section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring some files using a .gitignore configuration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `.gitignore` file is a configuration file that is used to tell Git which files
    or directories to ignore when tracking changes in a repository. This can be useful
    if you have files that are generated by your build process, are specific to your
    local environment, or are otherwise not relevant to the project and do not need
    to be tracked by Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of the types of files and directories that you might
    include in your `.``gitignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*.tmp`, `*.bak`, or `*.``swp` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*.exe`, `*.jar`, `*.war` files and `bin/`, `obj/`, or `dist/` directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_modules/` directory if you are using `npm`, or the `vendor/` directory
    if you are using Composer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`idea/` directory if you are using JetBrains IDEs, or the `.vscode/` directory
    if you are using Visual Studio Code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sensitive information**: Files containing passwords or API keys. We strongly
    advise taking special care to ignore those files to prevent them from being committed
    to the repository. This will save you a lot of headaches and unnecessary risk.
    These days, bots such as GitHub’s *Dependabot* will raise an alert (or even block
    the commit) if some of those sensitive files get into your repositories, but it’s
    better to catch these earlier in the development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example `.gitignore` file that ignores some common types of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: It’s also possible to use wildcards and `.gitignore` files inside directories
    where you need a special rule that it is not desired to be there globally.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can put your site-wide `.gitignore` file inside your home directory
    to make sure you won’t commit any files needed for your local development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is such a powerful tool that it’s hard to fit all its features into a single
    book. In this chapter, we’ve learned the most basic tasks you will need to know
    in your day-to-day work as a DevOps engineer, and you are well equipped to handle
    most of the issues you will encounter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on Docker and containerization, where we
    will put all the skills you’ve gained so far to the test.
  prefs: []
  type: TYPE_NORMAL
