- en: '*Chapter 16*: Loosely Coupled Architecture and Microservices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interestingly, software architecture has a bigger impact on software delivery
    performance than the type of systems that you build. It doesn't matter if your
    product is a cloud service, embedded software that runs on manufactured hardware,
    a consumer app, an enterprise application, or even mainframe software. This has
    basically no impact on engineering performance if your architecture has certain
    characteristics (*Forsgren N., Humble, J., and Kim, G., 2018*). There are high
    and low performers for every system type. But the characteristics of architecture
    are clearly correlated with engineering velocity and make it one of the key accelerators.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I'll give you an overview of loosely coupled systems and how
    you can evolve your software and system design to achieve a high engineering velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Loosely coupled systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evolutionary design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-based architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loosely coupled systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All developers that have worked at least once on a tightly coupled, monolithic
    application know the problems it induces. The communication overhead and the meetings
    needed to perform bigger changes. New bugs that occur after fixing a bug in another
    part of the application. Changes that break functionality from other developers.
    All these problems lead to fear of integrating and deploying and slow down developer
    velocity.
  prefs: []
  type: TYPE_NORMAL
- en: 'When designing your system and software, you should focus on the following
    characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployability**: Can each team release their application independent of other
    applications or teams?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: Can each team do most of their testing without requiring a
    test environment in which multiple independent solutions from other teams must
    be deployed together?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The team size here is a small **two-pizza team** (see [*Chapter 17*](B17827_17_Epub.xhtml#_idTextAnchor342),
    *Empower Your Teams*). If you design your systems for the deployability and testability
    of small teams, it will automatically lead to loosely coupled systems with well-defined
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common architectural pattern for loosely coupled systems is the **microservices**
    pattern, *"an approach to developing a single application as a suite of small
    services, each running in its own process and communicating with lightweight mechanisms,
    often an HTTP resource API"* (*Lewis J. & Fowler M., 2014*).
  prefs: []
  type: TYPE_NORMAL
- en: Microservices evolved out of **Service-Oriented Architecture** (**SOA**) with
    some additional characteristics. Microservices have **decentralized data management**
    – meaning that every service completely owns its own data. Additionally, microservices
    favor lightweight messaging instead of complex protocols or central orchestration
    for interservice communication – **smart endpoints** and **dumb pipes**.
  prefs: []
  type: TYPE_NORMAL
- en: One important characteristic of microservices is often missed – they are built
    around business capabilities. This also defines how small a service should be.
    To define the scope of your services, you must understand the business domain.
    One microservice matches one **bounded context** in **domain-driven design** (*Eric
    Evans, 2003*).
  prefs: []
  type: TYPE_NORMAL
- en: Another characteristic is that microservices are completely and independently
    **deployable** and **testable**. That's the reason why they are associated with
    high engineering velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices have many advantages. They scale very well, as you can scale every
    service independently. They also allow each team to work with its own programming
    languages and data storage solution that best meets its needs. Most importantly,
    they allow teams in big and complex applications to move fast without disrupting
    other teams.
  prefs: []
  type: TYPE_NORMAL
- en: But these advantages come with a cost. Microservice-based applications are complex
    and hard to operate and troubleshoot.
  prefs: []
  type: TYPE_NORMAL
- en: There are many famous microservice-based solutions – for example, Netflix and
    Amazon. They run world-scale services and have an architecture that allows them
    to deploy thousands of times each day.
  prefs: []
  type: TYPE_NORMAL
- en: But there are also many companies that have tried to implement microservices
    and have failed. The number of greenfield projects that fail is especially high.
    The reason for this is often a lack of knowledge of the business domain and the
    wrong definition of the bounded context for each service, especially when the
    application is developed by an external company that has yet to learn the **ubiquitous
    language** of the domain. Another reason is that the complexity of operating the
    service is underestimated.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of implementing microservices, you should focus on the **deployability**
    and **testability** characteristics of your architecture and adjust the solution
    design to your needs. The needs are not constant and evolve over time – and so
    should your architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Evolutionary design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The advantages and disadvantages of certain architectural styles shift for
    various reasons. One is the scale of your application. Another is the knowledge
    of your domain and your customers and the ability to operate at scale. Depending
    on these factors, different architectural styles are better suited for you (see
    *Figure 16.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 16.1 – The advantages and disadvantages shift with scale'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_16_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 16.1 – The advantages and disadvantages shift with scale
  prefs: []
  type: TYPE_NORMAL
- en: Constantly adapting your architecture and system design to your current needs
    is called **evolutionary design**. To start a greenfield product, it's best to
    start with a monolithic approach and one team. This allows you to move fast without
    much overhead. If you scale up and learn more about the domain, you can start
    to modularize your application using the capabilities of your programming language.
    At one point, the complexity and scale will be so high that microservices help
    you to keep your product testable and deployable.
  prefs: []
  type: TYPE_NORMAL
- en: The question is this – how do you arrive at the architecture you need from the
    architecture you have? A complete rewrite is very expensive and risky. The better
    approach is to evolve your design. Martin Fowler calls this the **StranglerFigApplication**
    pattern (*Martin Fowler, 2004*). The strangler fig is a plant that seeds in the
    upper branches of a tree and gradually grows its roots downward over the tree
    until it roots in the soil. The supporting tree is strangled and dies at some
    point – leaving an organic structure that supports itself.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of rewriting your application, you grow a new "strangler fig" application
    around it, letting it grow gradually until the old system is strangled and can
    be shut down.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are other architectural styles besides microservices, monolithic, and
    multi-tier applications – for example, **Event-Driven Architecture** (**EDA**).
    EDA is a pattern around the publication, processing, and persistence of events.
    The backbone is a message broker – for example, **Apache Kafka** – and individual
    services or components can publish events (a **publisher**) or subscribe to events
    (a **subscriber**).
  prefs: []
  type: TYPE_NORMAL
- en: EDA can be a good fit with a microservices-based approach – but it can also
    be used with other architectural styles. It can help you to keep consistency in
    loosely coupled components or services, and it can scale perfectly horizontally
    due to the asynchronous nature of events and is therefore well suited for solutions
    that process big amounts of data in motion, such as IoT solutions that process
    sensor data in near real time.
  prefs: []
  type: TYPE_NORMAL
- en: Especially in cloud-native environments, EDA can help you to move fast and to
    build loosely coupled and global scalable solutions in a very short time.
  prefs: []
  type: TYPE_NORMAL
- en: One pattern that is often used with EDA is **event sourcing**. Instead of persisting
    entities, event sourcing captures all changes to the application state – including
    the entities – as a sequence of events (see *Martin Fowler, 2005*). To retrieve
    an entity, the application must replay all events to get to the latest state.
    Since events are immutable, this provides a perfect audit trail. You can think
    of the event stream as an immutable stream of facts that can be seen as the single
    source of truth. In addition to auditability, event sourcing has many benefits
    in scalability and testability.
  prefs: []
  type: TYPE_NORMAL
- en: Event sourcing is a suitable pattern if you need to capture intent, purpose,
    or reason for your data, when it's vital to avoid conflicting updates, and when
    you must keep a history and frequently roll back changes. Event sourcing works
    very well together with **Command and Query Responsibility Segregation** (**CQRS**)
    – a pattern that separates read and write operations.
  prefs: []
  type: TYPE_NORMAL
- en: But be aware that event sourcing is very complex, and modeling a domain in events
    does not come naturally to most developers. If the aforementioned criteria do
    not suit your product, then event sourcing is probably not a good pattern for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: An architectural style that is more suitable for simple domains is the **Web-Queue-Worker**.
    It's a pattern mainly used with serverless PaaS components, and it consists of
    a web frontend that serves client requests and a worker that performs long-running
    tasks in the background. Frontend and backend are stateless and communicate using
    a message queue. The pattern is normally combined with other cloud services such
    as an identity provider, a database, a Redis cache, and a CDN. Web-Queue-Worker
    is a good pattern to get started with cloud-native applications.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever architectural style you pick, keep it as simple as possible. It's better
    to start simple and evolve your design over time with increasing demands than
    to overengineer and end up with a complex solution that slows you down.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are adopting CI/CD and DevOps practices but you're not accelerating,
    then you should have a close look at your solution architecture as one of the
    key indicators for engineering velocity. Focus on the deployability and testability
    characteristics rather than on the architectural styles.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I gave you an overview of loosely coupled systems' evolutionary
    design, and I introduced some relevant architectural styles and patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll discuss the correlation between your organizational
    structure and your software architecture and how it all comes together in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the references from this chapter that you can also use to get more
    information on the topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Forsgren N., Humble, J., and Kim, G. (2018). *Accelerate: The Science of Lean
    Software and DevOps: Building and Scaling High Performing Technology Organizations*
    (1st ed.) [E-book]. IT Revolution Press.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lewis J. and Fowler M. (2014). *Microservices*: [https://martinfowler.com/articles/microservices.html](https://martinfowler.com/articles/microservices.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Eric Evans (2003). *Domain-Driven Design: Tackling Complexity in the Heart
    of Software*. Addison-Wesley Professional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Martin Fowler (2004). *StranglerFigApplication*: [https://martinfowler.com/bliki/StranglerFigApplication.html](https://martinfowler.com/bliki/StranglerFigApplication.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Michael T. Nygard (2017). *Release It!: Design and Deploy Production-Ready
    Software*. Pragmatic Programmers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Martin Fowler (2005). *Event Sourcing*: [https://martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Lucas Krause (2015). *Microservices: Patterns and Applications – Designing
    fine-grained services by applying patterns* [Kindle Edition].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
