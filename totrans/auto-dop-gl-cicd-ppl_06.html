<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer066">
			<h1 id="_idParaDest-124" class="chapter-number"><a id="_idTextAnchor133"/>6</h1>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor134"/>Verifying Your Code</h1>
			<p>For most projects, the first thing a <strong class="bold">GitLab CI/CD</strong> pipeline should do is <em class="italic">verify the code</em>. Different projects will rely on different tasks to perform this critical step, but they usually involve some combination of checking the code quality and running automated functional tests. As a prerequisite for certain kinds of verification, some projects will need to build their code first. This chapter focuses on building and then verifying <span class="No-Break">your code.</span></p>
			<p>We’ll first discuss whether building the code is necessary, and if so, how to configure a GitLab CI/CD pipeline to carry out that task. Then, we’ll talk about how to use a pipeline to run GitLab’s built-in code quality scanner. Next, we’ll explain how to run automated functional tests within a pipeline. Then, we’ll cover a fascinating variety of automated testing called <strong class="bold">fuzz testing</strong>, which can find problems that traditional automated functional tests might miss. We’ll touch on GitLab’s accessibility testing, which ensures that your code can be used by a wide range of people. Finally, we’ll briefly mention a few other ways that you can verify your code, though we won’t have room to describe them in detail. By the end of the chapter, you’ll have an array of tools at your disposal for making sure your code is well written and does what it’s <span class="No-Break">supposed to.</span></p>
			<p>These are the main topics of <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><a id="_idTextAnchor135"/>Building code in a <span class="No-Break">CI/CD pipeline</span></li>
				<li>Checking code quality in a <span class="No-Break">CI/CD pipeline</span></li>
				<li>Running automated functional tests in a <span class="No-Break">CI/CD pipeline</span></li>
				<li>Fuzz testing in a <span class="No-Break">CI/CD pipeline</span></li>
				<li>Checking accessibility in a <span class="No-Break">CI/CD pipeline</span></li>
				<li>Additional ways to verify <span class="No-Break">your code</span></li>
			</ul>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor136"/>Technical requirements</h1>
			<p>As with the previous chapters, you’ll get the most out of this chapter if you’ve got an account on a GitLab instance (<em class="italic">self-managed</em> or <em class="italic">Software-as-a-Service</em>) that you can log in to and use for practicing and experimenting with the <span class="No-Break">concepts discussed.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor137"/>Building code in a CI/CD pipeline</h1>
			<p>At the risk of oversimplifying some of the mechanics that happen behind the scenes when you run software, we can generally think of <em class="italic">interpreted</em> computer languages such as Python or Ruby as<a id="_idIndexMarker419"/> executing raw source code, whereas <em class="italic">compiled</em> languages such as Java, C, or C# must convert that source code into a runnable form by compiling it, and then execute the compiled version of <span class="No-Break">the program.</span></p>
			<p>This is an important distinction to keep in mind when configuring a pipeline to verify your code because it means that if your project contains any code written in a compiled language (even if it’s only a small portion of your overall project), you probably need to include a build job in your pipeline before any verification jobs take place. We say <em class="italic">probably</em> because some of the jobs that typically run during the verification stage of a pipeline (for example, Code Quality) look directly at source code, whereas others interact with code as it runs. So, if your pipeline only uses verification scans that focus on source code, you can omit the build step no matter what language you’re using. If you want to include automated functional tests or fuzz testing in your pipeline, you <em class="italic">will</em> need to build your code first, so <span class="No-Break">read on!</span></p>
			<p>Every language builds its code in a different way, using different tools. Even within a single language, there are sometimes multiple tools or techniques for building code. Let’s look at two different ways to compile Java code and one way to compile <span class="No-Break">C code.</span></p>
			<p>These examples are meant to give you the big picture of how to build code within a GitLab CI/CD pipeline. They are not meant to be comprehensive examples of all the ways to accomplish this task. There are so many different languages and tools that we can only give you a few bare-bones examples and then let you adapt and expand them to work with your own languages, tools, constraints, <span class="No-Break">and preferences.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor138"/>Compiling Java with javac</h2>
			<p>Outside of simple training applications, real-world Java projects rarely use the <strong class="source-inline">javac</strong> compiler to convert Java<a id="_idIndexMarker420"/> source code (i.e., files with the <strong class="source-inline">.java</strong> extension) into compiled Java classes (i.e., files with the <strong class="source-inline">.class</strong> extension). Using the <strong class="source-inline">javac</strong> tool is effective when you’re only dealing with a few files, but it can become cumbersome<a id="_idIndexMarker421"/> as projects grow in complexity. But just like peanut butter and jelly sandwiches can be a great introduction to cooking even though<a id="_idIndexMarker422"/> they’d never <a id="_idIndexMarker423"/>be served at a formal dinner at Buckingham Palace, <strong class="source-inline">javac</strong> is a great way to introduce new GitLab users to the concept of using CI/CD pipelines to compile <span class="No-Break">Java code.</span></p>
			<h3>Adding your Java application</h3>
			<p>Let’s keep things simple by creating a single <a id="_idIndexMarker424"/>file application and a single Java package called <strong class="source-inline">com.hatsforcats</strong>. You can use GitLab’s Web IDE editor to create a directory called <strong class="source-inline">src/com/hatsforcats</strong> to store your source code. Inside that directory, use the Web IDE to create a file called <strong class="source-inline">Login.java</strong>. Add this trivial Hello World-style Java code to <span class="No-Break">that file:</span></p>
			<pre class="source-code">
package com.hatsforcats;
class Login {
    public static void main(String [] args) {
        System.out.println("Welcome to Hats for Cats!");
    }
}</pre>
			<h3>Configuring your pipeline</h3>
			<p>Now that your <a id="_idIndexMarker425"/>app has been added to the project, it’s time to configure your pipeline. Start with an empty <strong class="source-inline">.gitlab-ci.yml</strong> file in the root of your project’s repository and define a <strong class="source-inline">build</strong> stage for your pipeline using the <span class="No-Break"><strong class="source-inline">stages</strong></span><span class="No-Break"> keyword:</span></p>
			<pre class="source-code">
stages:
    - build</pre>
			<p>Next, you’ll define a pipeline job that lives within the <em class="italic">build</em> stage and runs <strong class="source-inline">javac</strong>. Let’s stipulate a few extra<a id="_idIndexMarker426"/> requirements for <span class="No-Break">this example:</span></p>
			<ul>
				<li>All the Java source files belong to the <strong class="source-inline">com.hatsforcats</strong> <span class="No-Break">Java package.</span></li>
				<li>Your team’s coding standards require you to put all source code within a <strong class="source-inline">src/</strong> directory that lives in the project’s <span class="No-Break">root directory.</span></li>
				<li>Compiled files should end up in a <strong class="source-inline">target/</strong> directory that lives in the project’s <span class="No-Break">root directory.</span></li>
			</ul>
			<p>To compile your code while satisfying these criteria, you’ll need to define a job in <strong class="source-inline">.gitlab-ci.yml</strong> to do the work. Call it something obvious and put it in the <span class="No-Break"><em class="italic">build</em></span><span class="No-Break"> stage:</span></p>
			<pre class="source-code">
compile-java-with-javac:
    stage: build</pre>
			<p>Within that job definition, you’ll want to specify which Docker image the job should run within. The job will need access to the <strong class="source-inline">javac</strong> compiler, so a good image to use is the latest version of <strong class="source-inline">openjdk</strong>. Add this to the job definition (remember to watch <span class="No-Break">your indentation):</span></p>
			<pre class="source-code">
    image: openjdk:latest</pre>
			<p>Finally, the job needs to invoke the Java compiler. Any commands that you list under the <strong class="source-inline">script</strong> keyword will run when the pipeline executes <span class="No-Break">that job:</span></p>
			<pre class="source-code">
    script:
        - javac src/com/hatsforcats/*.java -d target/</pre>
			<p>No doubt you can figure out the syntax of the <strong class="source-inline">javac</strong> command from the requirements given earlier, but if not, feel free to refer to the Java <span class="No-Break">compiler’s documentation.</span></p>
			<p>Believe it or not, that’s all you need in order to compile Java code within a GitLab <span class="No-Break">CI/CD pipeline!</span></p>
			<p>But to demonstrate that the job works as expected, let’s add more lines to the <strong class="source-inline">script</strong> section of the <strong class="source-inline">compile-java-with-javac</strong> job. The first line will show the contents of the <strong class="source-inline">target/</strong> directory after <strong class="source-inline">javac</strong> has worked its magic. If the compiler worked, this command will display the compiled version of your Java source file when the <span class="No-Break">job runs:</span></p>
			<pre class="source-code">
        - ls target/com/hatsforcats</pre>
			<p>The next lines will execute your compiled <strong class="source-inline">Login.class</strong> code to prove that it has compiled correctly. Normally, you <a id="_idIndexMarker427"/>wouldn’t run your code in a job that’s dedicated to building it, but you’re doing it in this case simply to demonstrate that the compile <span class="No-Break">actually happened:</span></p>
			<pre class="source-code">
        - cd target
        - java com.hatsforcats.Login</pre>
			<p>Here’s the complete text of <strong class="source-inline">.gitlab-ci.yml</strong> that you have assembled. If you’re following along, make sure that your version of that file contains exactly <span class="No-Break">this text:</span></p>
			<pre class="source-code">
stages:
    - build
compile-java-with-javac:
    stage: build
    image:openjdk:latest
    script:
        - javac src/com/hatsforcats/*.java -d target/
        - ls target/com/hatsforcats
        - cd target
        - java com.hatsforcats.Login</pre>
			<p>Commit this file and navigate over to the list of pipelines in your project. Zoom in on the pipeline run that was automatically triggered by your commit, zoom in on the <strong class="source-inline">compile-java</strong> job, and see whether you can find text similar to this snippet at the end of the <span class="No-Break">job’s output:</span></p>
			<pre class="source-code">
$ javac src/com/hatsforcats/*.java -d target/
$ ls target/com/hatsforcats
Login.class
$ cd target
$ java com.hatsforcats.Login
Welcome to Hats for Cats!
Cleaning up project directory and file based variables
Job succeeded</pre>
			<p>You can see that the <strong class="source-inline">javac</strong> command ran without emitting any errors, the <strong class="source-inline">ls</strong> command shows a compiled<a id="_idIndexMarker428"/> version of <strong class="source-inline">Login.java</strong>, and the class produced the expected output when it was <span class="No-Break">executed. Success!</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor139"/>Compiling Java with Maven</h2>
			<p>Let’s try a slightly more complicated, albeit <a id="_idIndexMarker429"/>probably more realistic, way of compiling the same Java project you set up in the previous section. Instead of using the Java compiler directly, let’s use <strong class="bold">Maven</strong> to build your code. If you haven’t used<a id="_idIndexMarker430"/> Maven before, it’s a powerful tool for Java projects that manages dependencies, compiles source code into classes, runs automated tests, and performs other tasks. In this example, you’ll use it to convert your <strong class="source-inline">*.java</strong> file into a compiled <strong class="source-inline">*.</strong><span class="No-Break"><strong class="source-inline">class</strong></span><span class="No-Break"> file.</span></p>
			<h3>Configuring Maven</h3>
			<p>Maven is configured via a special file called <strong class="source-inline">pom.xml</strong>. There’s no need to get into the structure or content <a id="_idIndexMarker431"/>of that file here, but if you’re curious about what each section does, the Maven documentation can give you all the details. Copy this bare-bones content into a new <strong class="source-inline">pom.xml</strong> file in your project’s <span class="No-Break">root directory:</span></p>
			<pre class="source-code">
&lt;project&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;groupId&gt;org.hatsforcats&lt;/groupId&gt;
  &lt;artifactId&gt;login&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;properties&gt;
    &lt;maven.compiler.source&gt;17&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;17&lt;/maven.compiler.target&gt;
  &lt;/properties&gt;
&lt;/project&gt;</pre>
			<h3>Adding your Java application</h3>
			<p>If you’re re-using the same<a id="_idIndexMarker432"/> project from the preceding <strong class="source-inline">javac</strong> example, you already have a Java program added to the project’s repository. If you’re using a new project, add this Java code to a new file called <strong class="source-inline">Login.java</strong> in a new <span class="No-Break"><strong class="source-inline">src/com/hatsforcats/</strong></span><span class="No-Break"> directory:</span></p>
			<pre class="source-code">
package com.hatsforcats;
class Login {
    public static void main(String [] args) {
        System.out.println("Welcome to Hats for Cats!");
    }
}</pre>
			<h3>Configuring your pipeline</h3>
			<p>Either make a new <strong class="source-inline">.gitlab-ci.yml</strong> file in your root <a id="_idIndexMarker433"/>directory or replace all the content in your existing <strong class="source-inline">.gitlab-ci.yml</strong> file with this <span class="No-Break">configuration code:</span></p>
			<pre class="source-code">
stages:
  - build
compile-java-with-maven:
  stage: build
  image: maven:latest
  script:
    - mvn compile
    - ls target/classes/com/hatsforcats
    - cd target/classes
    - java com.hatsforcats.Login</pre>
			<p>You’ll notice that the pipeline configuration code for a Maven-powered build is similar to the configuration code for a Java-compiler-powered build, but with a few <span class="No-Break">key differences:</span></p>
			<ul>
				<li>A different value after the <strong class="source-inline">image</strong> keyword means that the GitLab Runner will execute the job within a Maven-based Docker image instead of a Java-based <span class="No-Break">Docker image.</span></li>
				<li>The command to <a id="_idIndexMarker434"/>compile the code uses <strong class="source-inline">mvn</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">javac</strong></span><span class="No-Break">.</span></li>
				<li>Maven puts compiled classes in a different directory than the source code by default, so you don’t have to explicitly tell it to do so like you did with <strong class="source-inline">javac</strong> (although notice that its default directory for compiled files isn’t quite the same as the one you specified <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">javac</strong></span><span class="No-Break">).</span></li>
			</ul>
			<p>After committing this configuration code, you can view the details of the pipeline that is automatically triggered and zoom in on the <strong class="source-inline">compile-java-with-maven</strong> job. You should see something similar to this snippet at the end of <span class="No-Break">the output:</span></p>
			<pre class="source-code">
[INFO] Compiling 1 source file to /builds/cwcowell/hats-for-cats/target/classes
[INFO] ---------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ---------------------------------------------------
[INFO] Total time:  4.069 s
[INFO] Finished at: 2022-04-11T21:22:28Z
[INFO] ---------------------------------------------------
$ ls target/classes/com/hatsforcats
Login.class
$ cd target/classes
$ java com.hatsforcats.Login
Welcome to Hats for Cats!
Cleaning up project directory and file based variables
Job succeeded</pre>
			<p>The Maven-driven compile worked <a id="_idIndexMarker435"/>correctly, the compiled class appears where you expected it to, and the class gives the expected output when you run it. You’ll never need to run the <strong class="source-inline">mvn compile</strong> command <span class="No-Break">manually again!</span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor140"/>Compiling C with Gnu Compiler Collection (GCC)</h2>
			<p>Let’s take a look at building a project based on the <strong class="bold">C</strong> programming language.  Normally, you would use a tool such as<a id="_idIndexMarker436"/> Make to build your C project, just like you use <a id="_idIndexMarker437"/>Maven to build a Java project. But to keep this example as simple as <a id="_idIndexMarker438"/>possible, you’ll rely on the good old GCC to compile some C <span class="No-Break">code directly.</span></p>
			<p>If you’re following along at home, you can either make a new project for your C program, or you can re-use the project that you used for the two earlier <span class="No-Break">Java examples.</span></p>
			<h3>Adding your C application</h3>
			<p>Navigate to your project’s repository in<a id="_idIndexMarker439"/> the GitLab GUI, add a new file at the root directory called <strong class="source-inline">login.c</strong>, and paste this simple C code <span class="No-Break">into it:</span></p>
			<pre class="source-code">
#include &lt;stdio.h&gt;
int main(void) {
    puts("Welcome to Hats for Cats!");
    return 0;
}</pre>
			<h3>Configuring your pipeline</h3>
			<p>Setting up a pipeline to use GCC to compile C code isn’t terribly different from what you saw in the Java examples. Here are the<a id="_idIndexMarker440"/> <span class="No-Break">main differences:</span></p>
			<ul>
				<li>The job runs in a Docker image that includes the <span class="No-Break">GCC tools.</span></li>
				<li>The job definition’s <strong class="source-inline">script</strong> keyword specifies using <strong class="source-inline">gcc</strong> instead of <strong class="source-inline">mvn</strong> or <strong class="source-inline">javac</strong> to build <span class="No-Break">your code.</span></li>
				<li>The job runs the compiled code directly instead of invoking a JVM with the <span class="No-Break"><strong class="source-inline">java</strong></span><span class="No-Break"> command.</span></li>
			</ul>
			<p>The basic CI/CD configuration code for building and running a C program with GCC could look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
stages:
  - build
compile-c:
  stage: build
  image: gcc:latest
  script:
    - gcc login.c -o login
    - ./login</pre>
			<p>To repeat something we said earlier, you normally would not run your code in the same job as you built it—in fact, you might not run it at all in a pipeline. But you’re running it here just to demonstrate that compiling worked <span class="No-Break">as expected.</span></p>
			<p>And here’s a snippet from<a id="_idIndexMarker441"/> the output of this job, showing that your C program compiled and <span class="No-Break">ran correctly:</span></p>
			<pre class="source-code">
$ gcc login.c -o login
$ ./login
Welcome to Hats for Cats!
Cleaning up project directory and file based variables
Job succeeded</pre>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor141"/>Storing built code as artifacts</h2>
			<p>There’s one more keyword you need to know before you can move on to pipeline stages that test the code that you just<a id="_idIndexMarker442"/> built: the <span class="No-Break"><strong class="source-inline">artifacts</strong></span><span class="No-Break"> keyword.</span></p>
			<p>Any files that a pipeline job creates—including compiled versions of files that are generated during a build job—are deleted as soon as the job completes. This is very different from how build tools work on the command line. If you type <strong class="source-inline">javac MyApp.java</strong> in a terminal, the <strong class="source-inline">MyApp.class</strong> file that is generated will stick around on your filesystem until you delete it. But in a GitLab CI/CD pipeline, every job operates in its own, self-contained environment. This means that if you compile some files in a <strong class="source-inline">build-java</strong> job and then try to test them in a <strong class="source-inline">test-java</strong> job that lives in a later stage, the <strong class="source-inline">test-java</strong> job will <em class="italic">not</em> be able to see the files that you so carefully <span class="No-Break">built earlier.</span></p>
			<p>Fortunately, the <strong class="source-inline">artifacts</strong> keyword gives you a workaround. This keyword lets you specify certain files or directories that GitLab should preserve from one job and make available to all later jobs. For example, to preserve the executable <strong class="source-inline">login</strong> file that you generated in the <strong class="source-inline">compile-c</strong> job, you could add these two lines to the bottom of the <strong class="source-inline">compile-c</strong> <span class="No-Break">job definition:</span></p>
			<pre class="source-code">
  artifacts:
    paths:
      - login</pre>
			<p>You can specify more than one file to preserve, and you can specify one or more directories to preserve in addition to any individual files. You can also specify subdirectories or files to exclude from the list of artifacts. For example, to save the entire contents of the directory that Maven puts compiled files in, except for files that start with <strong class="source-inline">Test</strong> that exist in any subdirectory, you could add these lines to the bottom of the <strong class="source-inline">compile-java-with-maven</strong> job <span class="No-Break">from earlier:</span></p>
			<pre class="source-code">
  artifacts:
    paths:
      - target/classes/
    exclude:
      - target/classes/**/Test*</pre>
			<p>The <strong class="source-inline">artifacts</strong> keyword is one of the most important keywords that you’ll use when configuring CI/CD pipelines, and forgetting to use it when it’s needed is a common mistake. If your pipeline isn’t working the way you expect it to, one of the first troubleshooting steps you should try is to check whether you’re specifying artifacts in all of the jobs that generate files that <a id="_idIndexMarker443"/>you want to access in <span class="No-Break">later jobs.</span></p>
			<p>Now that you’ve learned when and how to build your code in a CI/CD pipeline, let’s move on to what is typically the next pipeline step: <em class="italic">checking the quality of </em><span class="No-Break"><em class="italic">your code</em></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor142"/>Checking code quality in a CI/CD pipeline</h1>
			<p>One of the many scanners <a id="_idIndexMarker444"/>that GitLab makes available to CI/CD pipelines is a special feature that makes sure your project’s code adheres to certain quality standards. GitLab <a id="_idIndexMarker445"/>calls this feature, unsurprisingly, <strong class="bold">Code Quality</strong>. If you’ve used any sort of linting tool before, you can think of this feature as a <span class="No-Break">turbocharged linter.</span></p>
			<p>The Code Quality feature relies on an<a id="_idIndexMarker446"/> outside service called <strong class="bold">Code Climate</strong>. Although this service can scan code written in all the major computer languages, it can’t handle every language out there. You can refer to Code Climate’s official documentation to see a list of supported languages, but rest assured that it works just fine with Java, Python, Ruby, JavaScript, and most other commonly <span class="No-Break">used languages.</span></p>
			<p>What sorts of problems does the Code Quality feature look for? The general categories it’s interested in include performance, style, complexity, security, and smells (i.e., patterns that indicate a high<a id="_idIndexMarker447"/> risk of bugs). The exact violations that it detects <a id="_idIndexMarker448"/>vary from language to language, but here are some concrete examples of quality violations it <span class="No-Break">can spot:</span></p>
			<ul>
				<li>Functions that take too <span class="No-Break">many parameters</span></li>
				<li>Functions with too many <span class="No-Break">exit points</span></li>
				<li>Functions or classes that are <span class="No-Break">too long</span></li>
				<li>Overly complex <span class="No-Break">logical expressions</span></li>
				<li>Too much or too little <span class="No-Break">vertical whitespace</span></li>
				<li><span class="No-Break">Duplicated code</span></li>
			</ul>
			<p>In addition, if your computer language has an established set of stylistic conventions—think of the PEP-8 standard in Python, or the Rubocop rule set in Ruby—the Code Quality feature can be configured to include <span class="No-Break">those rules.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor143"/>Enabling Code Quality</h2>
			<p>It couldn’t be easier to add<a id="_idIndexMarker449"/> Code Quality to your <span class="No-Break">CI/CD pipeline:</span></p>
			<ol>
				<li>Make sure your pipeline has a <strong class="source-inline">test</strong> stage defined (hint: it almost certainly already has this stage, so you probably won’t have to <span class="No-Break">do anything).</span></li>
				<li>Include a GitLab-provided template (i.e., a file that contains additional CI/CD configuration code) called <strong class="source-inline">Code-Quality.gitlab-ci.yml</strong>, which adds a Code Quality job to <span class="No-Break">your pipeline.</span></li>
			</ol>
			<p><em class="italic">Step 1</em> will look like this in your project’s <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitlab-ci.yml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
stages:
  - test</pre>
			<p>And <em class="italic">step 2</em> will look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
include:
  template: Code-Quality.gitlab-ci.yml</pre>
			<p>Note that if you had already defined other stages, in <em class="italic">step 1</em>, you would simply add the <strong class="source-inline">test</strong> stage to the existing stages—you wouldn’t delete any existing stages. Similarly, if your pipeline configuration code already includes other templates, in <em class="italic">step 2</em>, you would add this new template to the existing templates instead of <span class="No-Break">replacing them.</span></p>
			<p>The Code Quality feature is smart<a id="_idIndexMarker450"/> enough to detect all of the computer languages used in your GitLab project and run the appropriate scanners for each language. However, it’s important to understand that because these scanners are all developed by different people or teams outside of GitLab, there’s no guarantee that the scanners will find exactly the same problems in all supported languages. For example, the scanner for one language might be especially good at detecting duplicated code snippets, whereas the scanner for a different language might be especially adept at calling out complex code that should <span class="No-Break">be simplified.</span></p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor144"/>Viewing Code Quality results</h2>
			<p>Let’s see a concrete example of Code Quality in <a id="_idIndexMarker451"/>action. Imagine that you have a file called <strong class="source-inline">hats-for-cats.py</strong> in the root directory of your project’s repository, containing <span class="No-Break">this code:</span></p>
			<pre class="source-code">
def register(username, password, phone, city, state, zip):
    # TODO finish this code</pre>
			<p>There are two problems with this code that you would expect Code Quality to catch: the function has too many arguments, and the <strong class="source-inline">TODO</strong> comment should be acted on <span class="No-Break">and removed.</span></p>
			<p>If you enable Code Quality on the project’s pipeline and then run the pipeline, the pipeline details page will include a new tab called <strong class="bold">Code Quality</strong>, which reveals the results of the Code <span class="No-Break">Quality scan:</span></p>
			<div>
				<div id="_idContainer058" class="IMG---Figure">
					<img src="image/Figure_6.01_B18073.jpg" alt="Figure 6.1 – Code Quality results in a pipeline details page" width="674" height="217"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Code Quality results in a pipeline details page</p>
			<p>There’s another place you can see the same<a id="_idIndexMarker452"/> information: in a <strong class="bold">merge request</strong>. However, the report in a merge request differs from the report in a pipeline details page in one important way. Whereas<a id="_idIndexMarker453"/> the pipeline details report shows all the code quality problems found on whatever branch the pipeline ran on, the merge request report shows the difference between code quality problems on the merge request’s source branch and the merge request’s target branch. Since the target branch is almost always your project’s default branch (i.e., main or master), the merge request report shows you whether the work on your source branch is adding new code quality problems or fixing old code quality problems, compared to your stable code base. In other words, it shows whether the commits on your branch are making the project’s code better <span class="No-Break">or worse.</span></p>
			<p>To illustrate this, imagine that you make a branch, make a merge request for that branch, and commit a change to the branch that removes the <strong class="source-inline">TODO</strong> comment and adds a new <strong class="source-inline">FIXME</strong> comment. You’d expect the Code Quality report on the merge request to show that one old problem (<strong class="source-inline">TODO</strong>) has been fixed and one new problem (<strong class="source-inline">FIXME</strong>) has been added. And that’s exactly what appears in the merge <span class="No-Break">request report:</span></p>
			<div>
				<div id="_idContainer059" class="IMG---Figure">
					<img src="image/Figure_6.02_B18073.jpg" alt="Figure 6.2 – Code Quality results in a merge request" width="852" height="205"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Code Quality results in a merge request</p>
			<p>Both report locations—the pipeline details page and the merge request—have an entry for each detected problem. These<a id="_idIndexMarker454"/> entries tell you the name of each problem, the filename, and the line number on which the problem occurred. This should be enough detail to let you decide whether to fix or ignore each code quality problem. You may decide to ignore some problems either as false positives or as genuine problems that are too small to be <span class="No-Break">worth fixing.</span></p>
			<p>Code Quality is one of GitLab’s best and most valuable CI/CD features. It’s such an important tool for keeping your code readable and maintainable that GitLab makes it available on all license tiers of the product, including the Free tier. It’s fast to run, reliable, and effective. There’s really no reason not to use it on all of <span class="No-Break">your projects.</span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor145"/>Running automated functional tests in a CI/CD pipeline</h1>
			<p>One of the most common tasks in a CI/CD pipeline<a id="_idIndexMarker455"/> is running automated functional tests to make sure your code does what it’s supposed to do. For <a id="_idIndexMarker456"/>example, you might want to use the <strong class="source-inline">pytest</strong> framework to run a collection of unit tests written in Python to test your Python-based Hats for Cats app. Let’s see how to do that <span class="No-Break">with GitLab.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you’re not familiar with <strong class="source-inline">pytest</strong>, don’t worry. The syntax for <strong class="source-inline">pytest</strong> unit tests is extremely simple and can be understood by anyone with even a little experience of writing automated tests in <span class="No-Break">any language.</span></p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor146"/>Enabling automated functional tests</h2>
			<p>Imagine that you’ve written<a id="_idIndexMarker457"/> three <strong class="source-inline">pytest</strong>-based unit tests to make sure the Hats for Cats app’s login feature works as expected. You might have a file called <strong class="source-inline">test/test_login.py</strong> with <span class="No-Break">these contents:</span></p>
			<pre class="source-code">
def test_login():
    # add code that tries to log in with good credentials
    assert True
def test_login_bad_password():
    # add code that tries to log in with a bad password
    assert True
def test_login_no_password():
    # add code that tries to log in with no password
    assert False</pre>
			<p>Obviously, these sample tests have placeholder code that forces the first two tests to pass and the third to fail. Real tests would have actual logic that exercises the login feature in various ways, but these simplified examples make GitLab’s automated test feature easier <span class="No-Break">to demonstrate.</span></p>
			<p>To run these automated tests in your pipeline, add a job that triggers them just like you would from the <span class="No-Break">command line:</span></p>
			<pre class="source-code">
unit-tests:
  stage: test
  image: python:3.10
  script:
    - pip install pytest
    - pytest test/</pre>
			<p>This job definition specifies that the job belongs to the <strong class="source-inline">test</strong> stage, and that it must run within a Docker container that has version 3.10 of Python installed. The commands that it runs first install the <strong class="source-inline">pytest</strong> package using the <strong class="source-inline">pip</strong> package manager, and then call the newly installed <strong class="source-inline">pytest</strong> command to run all unit tests that are in the <span class="No-Break"><strong class="source-inline">test/</strong></span><span class="No-Break"> directory.</span></p>
			<p>After adding this job and running<a id="_idIndexMarker458"/> the pipeline, you can inspect the job’s output and see that the tests did indeed run. You can even see the pass/fail results of each test. But the job’s output is hard to parse and a little cryptic. Wouldn’t it be nice if the results of the automated tests showed up in an easy-to-read table somewhere in the GitLab GUI? Fortunately, GitLab can do exactly that. You just need to tweak the job definition a little so that it stores the output of the unit tests in a particular format, and then saves that result file as a GitLab artifact. Adding this code to the end of the existing <strong class="source-inline">unit-tests</strong> job definition will do <span class="No-Break">the trick:</span></p>
			<pre class="source-code">
  artifacts:
    reports:
      junit: unit_test_results.xml
    when: always</pre>
			<p>This code tells GitLab to preserve the <strong class="source-inline">unit_test_results.xml</strong> file produced by the <strong class="source-inline">pytest</strong> framework. It also designates this file as a report that contains test results that are stored in the JUnit format, which is an industry-standard format that GitLab knows how to ingest and display. Finally, it tells GitLab to hold on to this file regardless of whether any of the tests fail. This last step is important because a failing test will cause the whole <strong class="source-inline">unit-tests</strong> job to have a <strong class="bold">failed</strong> status, which would normally cause the artifact to be discarded. But we want to see the results even if—maybe <em class="italic">especially</em> if—any of the <span class="No-Break">tests fail.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor147"/>Viewing automated functional test results</h2>
			<p>After adding the additional code we’ve just <a id="_idIndexMarker459"/>described and running a new pipeline instance, a new tab marked <strong class="bold">Tests</strong> will appear on the pipeline details page. Lo and behold, clicking that tab shows you an overview of how many automated tests passed and how <span class="No-Break">many failed:</span></p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="image/Figure_6.03_B18073.jpg" alt="Figure 6.3 – Overview of automated test results" width="719" height="331"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Overview of automated test results</p>
			<p>This table shows one row per <a id="_idIndexMarker460"/>job that triggers automated tests. Clicking on any row breaks down the results further, so you can see exactly which tests passed <span class="No-Break">or failed:</span></p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="image/Figure_6.04_B18073.jpg" alt="Figure 6.4 – Individual automated test results" width="957" height="444"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Individual automated test results</p>
			<p>As you might expect, the <strong class="bold">View details</strong> button next to each test shows you more information about that test, including the line of code that generated the failed assertion and the history of how<a id="_idIndexMarker461"/> often that test has failed in the past. This information helps you debug your product code—or your test, if that’s where the <span class="No-Break">problem lies.</span></p>
			<div>
				<div id="_idContainer062" class="IMG---Figure">
					<img src="image/Figure_6.05_B18073.jpg" alt="Figure 6.5 – Details of a single automated test" width="468" height="265"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Details of a single automated test</p>
			<p>Looking at functional test results in a pipeline details page shows you all the test results for the code in the branch that the pipeline ran against. Sometimes that’s exactly what you want. Other times, you want to know whether the code on a branch is experiencing any new test failures (or has fixed any failing tests) compared to the code on your project’s default branch. In other words, is the feature branch fixing broken code, is it breaking code that used to work, or is it doing some <span class="No-Break">of each?</span></p>
			<p>Fortunately, the automated functional test report that appears in a merge request shows you exactly this information. Imagine that you’re working on a branch and you manage to fix one test that was failing on the default branch, break one test that was passing on the default branch, introduce one new test that passes, and introduce one new test that fails. The merge request for that branch would present a report that looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/Figure_6.06_B18073.jpg" alt="Figure 6.6 – Merge request’s delta view of automated functional test results" width="1191" height="332"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Merge request’s delta view of automated functional test results</p>
			<p>This shows that two tests are failing, including the old test that you broke on this branch and one of the new tests that you added to this branch. It also shows that one test failed on the default branch but has<a id="_idIndexMarker462"/> been fixed on this branch. The merge request report does not mention the new test you added that is passing, other than to include it in the count of five total tests. This is because you are usually more interested in knowing which tests are failing than in knowing which are passing. If you do want to see the status of all tests—both passing and failing—the <strong class="bold">View full report</strong> button will give you <span class="No-Break">that information.</span></p>
			<p>Running automated tests is often the very first task that a development team configures new pipelines to perform. If you stopped right there, you’d still get a huge amount of value out of GitLab CI/CD pipelines. But there are so many more ways you can verify your code with a pipeline! Let’s look at fuzz <span class="No-Break">testing next.</span></p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor148"/>Fuzz testing in a CI/CD pipeline</h1>
			<p><strong class="bold">Fuzz testing</strong> is an alternative, less traditional way<a id="_idIndexMarker463"/> of finding bugs in your code. Put succinctly, this advanced testing technique sends semi-random data to your code’s functions in an <a id="_idIndexMarker464"/>effort to trigger bugs. Although it takes a little more work to set up than the other scanners, it can pay off by spotting bugs that you probably never would have found using <span class="No-Break">other methods.</span></p>
			<p class="callout-heading">Reminder about GitLab versions and features</p>
			<p class="callout">Fuzz testing, like many other features discussed throughout the book, is only available if you’re using GitLab with an Ultimate license. You can find out whether your license tier includes a particular feature by looking up that feature in the official GitLab documentation. Features are often made available in lower tiers after they’ve been restricted to higher tiers for a <span class="No-Break">few years.</span></p>
			<p>There are two ways of performing fuzz testing<a id="_idIndexMarker465"/> in GitLab: <strong class="bold">coverage-guided fuzz testing</strong> and <strong class="bold">web API fuzz testing</strong>. In this book, we will only discuss the<a id="_idIndexMarker466"/> former, but the two techniques are similar enough that if you <a id="_idIndexMarker467"/>understand one, you’ll easily be able to learn about the other using GitLab’s <a id="_idIndexMarker468"/>documentation. From this point forward, whenever we refer to fuzz testing, we’re talking specifically about the <span class="No-Break">coverage-guided variant.</span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor149"/>The architecture and workflow of fuzz testing</h2>
			<p>There are four architectural components you need to understand in order to use coverage-guided fuzz testing: the <strong class="bold">code under test</strong>, the <strong class="bold">CI/CD job</strong>, the <strong class="bold">fuzz engine</strong>, and the <strong class="bold">fuzz target</strong>. Let’s look<a id="_idIndexMarker469"/> at each component and then see how they all fit together in the fuzz <span class="No-Break">testing workflow.</span></p>
			<h3>The code under test</h3>
			<p>Fuzz testing targets a single function in your code. That<a id="_idIndexMarker470"/> function can be written in any of the languages supported by GitLab’s fuzz tester, and it <a id="_idIndexMarker471"/>can be of any length. It must take at least one parameter, but there’s no upper limit on the number of parameters it expects. The function can call other functions, and if a bug is triggered anywhere within that call stack, the fuzz tester will <span class="No-Break">report it.</span></p>
			<p>Consider this Python function to be your code under test. Imagine that it’s in a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">name_checker.py</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
def is_bob(name: str) -&gt; bool:
  if len(name) == 0:
    return False
return name[0] == 'b' and name[1] == 'o' and name[2] == 'b'</pre>
			<p>This simple function takes a string as a parameter. It immediately returns <strong class="source-inline">False</strong> if the string is empty. Otherwise, it returns <strong class="source-inline">True</strong> if the string is <strong class="source-inline">bob</strong> and <strong class="source-inline">False</strong> if <span class="No-Break">it isn’t.</span></p>
			<p>This is, of course, a terrible algorithm to use for this simple task, but we’ll ask you to restrain your urge to mutter insulting things about the author of this code and play along for the sake of the demo. Just pretend it was written by a terrified intern on his first day on <span class="No-Break">the job.</span></p>
			<p>The intern is not only <a id="_idIndexMarker472"/>awful at designing algorithms, but he’s also not a very good coder. You’ve probably already spotted the function’s obvious bug: it doesn’t validate that the string that’s passed in is at least three characters long. As a consequence, if the string is only one character long and that character is <strong class="source-inline">b</strong>, the function will throw an unexpected <strong class="source-inline">IndexError</strong> when it tries to<a id="_idIndexMarker473"/> read the non-existent second character of the string. Similarly, if the only two characters in the string are <strong class="source-inline">bo</strong>, it will throw an <strong class="source-inline">IndexError</strong> when it tries to read the <span class="No-Break">third character.</span></p>
			<p>It would be easy for the developer or QA team member responsible for writing tests to forget to test these cases. Let’s see whether fuzz testing will save the day by finding <span class="No-Break">this bug.</span></p>
			<h3>A CI/CD job</h3>
			<p>Next, you need to define a job in your <a id="_idIndexMarker474"/>CI/CD pipeline that’s dedicated to fuzz testing the code under test. You can fuzz-test several different <a id="_idIndexMarker475"/>functions in one pipeline, but you’ll need a separate pipeline job for each function to be tested. In this case, your code under test consists of just one function, so you’ll define a single <span class="No-Break">CI/CD job.</span></p>
			<p>Before we get to the job definition, we should explain that the fuzz testing job <em class="italic">must</em> extend a job called <strong class="source-inline">.fuzz_base</strong>, which is defined in a template provided by GitLab. Before defining the job, you’ll need to include that template by adding a new line to the <strong class="source-inline">includes:</strong> section <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">.gitlab-ci.yml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
  - template: Coverage-Fuzzing.gitlab-ci.yml</pre>
			<p>The <strong class="source-inline">.fuzz_base</strong> job that we’ll be extending expects to run in a new stage called <strong class="source-inline">fuzz</strong>, which would have to run after the <strong class="source-inline">build</strong> stage so it can perform fuzz tests on compiled, runnable code. Let’s add that to our list of stages. Assuming that we’ve already defined <strong class="source-inline">build</strong> and <strong class="source-inline">test</strong> stages, the <strong class="source-inline">stages:</strong> section of <strong class="source-inline">.gitlab-ci.yml</strong> would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
stages:
  - build
  - test
  - fuzz</pre>
			<p>Now we’re ready to add <a id="_idIndexMarker476"/>a job definition to <strong class="source-inline">.gitlab-ci.yml</strong> that will <a id="_idIndexMarker477"/>kick off the fuzz test for our code <span class="No-Break">under test:</span></p>
			<pre class="source-code">
fuzz-test-is-bob:
  image: python:latest
  extends: .fuzz_base
  script:
    - pip install --extra-index-url <a href="https://gitlab.com/api/v4/projects/19904939/packages/pypi/simple">https://gitlab.com/api/v4/projects/19904939/packages/pypi/simple</a> pythonfuzz
    - ./gitlab-cov-fuzz run --engine pythonfuzz -- is_bob_fuzz_target.py</pre>
			<p>This job, called <strong class="source-inline">fuzz-test-is-bob</strong>, first specifies that it should run in a Docker image that includes the latest version of Python. This is needed because the fuzz engine, fuzz target, and code under test are all written <span class="No-Break">in Python.</span></p>
			<p>Next, it inherits job configuration details from a parent job called <strong class="source-inline">.fuzz_base</strong>. This parent job is provided by GitLab, and there’s no need for you to know or care what configuration details it provides to <span class="No-Break">your job.</span></p>
			<p>Then your job specifies two commands to run. The first installs a Python-based fuzz engine from a GitLab-hosted package registry. The second runs a binary called <strong class="source-inline">gitlab-cov-fuzz</strong>, pointing it at the correct fuzz engine and fuzz target. This binary is what actually starts up the fuzz test. You’ll get a better sense of how the fuzz test proceeds from there when we look at the entire fuzz test workflow in the <span class="No-Break">next section.</span></p>
			<h3>The fuzz engine</h3>
			<p>The fuzz engine is a GitLab-supplied binary that sends streams of random bytes to the fuzz target. These bytes serve as the <a id="_idIndexMarker478"/>basis for input data that the fuzz target will feed to the code under test—but more on that topic is coming in the <span class="No-Break">next section.</span></p>
			<p>Truth be told, it’s more accurate to call these bytes <em class="italic">semi-random</em> instead of <em class="italic">random</em>. This is because the fuzz<a id="_idIndexMarker479"/> engine looks at which lines of the code under test were exercised by the last round of data and attempts to mutate that data in such a way that when the mutated data serves as the <em class="italic">next</em> set of random bytes, it will exercise different lines in the code under test. So, it’s random, but it’s also influenced by the previously used sets of random data. This is where the term <em class="italic">coverage-guided</em> comes from: the fuzz tester uses code coverage data to influence how it generates the random data to send to the code <span class="No-Break">under test.</span></p>
			<h3>The fuzz target</h3>
			<p>The fuzz target is a small piece of <a id="_idIndexMarker480"/>code that you must write in the same language as the code under test. It serves as a<a id="_idIndexMarker481"/> translator or intermediary between the fuzz engine and the code under test. The fuzz target has <span class="No-Break">two tasks:</span></p>
			<ul>
				<li>Transform the random bytes sent to it by the fuzz engine into the data type that the code under test expects to receive for its input parameter(s). For example, it might need to transform the bytes into an array of integers, a string, or an instance of <span class="No-Break">a class.</span></li>
				<li>Call the function in the code under test, passing it the transformed <span class="No-Break">random bytes.</span></li>
			</ul>
			<p>For this example, the fuzz target needs to convert the random bytes sent by the fuzz engine into a string, and then pass that string to the <strong class="source-inline">is_bob</strong> function in <strong class="source-inline">name_validator.py</strong>. You can call the file that the fuzz target lives in anything you want, but there’s a fair amount of boilerplate that you must include in order to make it callable from by the fuzz engine. Let’s assume that you call your fuzz target file <strong class="source-inline">is_bob_fuzz_target.py</strong> and you include this content in <span class="No-Break">the file:</span></p>
			<pre class="source-code">
from name_checker import is_bob
from pythonfuzz.main import PythonFuzz
@PythonFuzz
def fuzz(random_bytes):
    try:
        random_bytes_as_string = str(random_bytes, 'UTF-8')
        is_bob(random_bytes_as_string)
    except UnicodeDecodeError:
        pass
if __name__ == '__main__':
    fuzz()</pre>
			<p>Let’s look at what’s happening here. The first line makes the code under test available so the fuzz target can pass it <span class="No-Break">random data.</span></p>
			<p>The next two lines declare a <a id="_idIndexMarker482"/>function called <strong class="source-inline">fuzz</strong>, which takes random bytes as input. This is required boilerplate: you have to include <span class="No-Break">these lines.</span></p>
			<p>Next, the fuzz target takes the random bytes that were sent to it by the fuzz engine and tries to transform them into a string, which is the data type that the code under test expects as input. For many (in fact, most!) collections of random bytes that are passed into the fuzz target, this conversion will fail due to at least one of the bytes falling outside the range of values that map to letters, numbers, punctuation, and other symbols. The <strong class="source-inline">try</strong> and <strong class="source-inline">except</strong> lines take care of this problem: if any of the bytes can’t be converted, the fuzz target simply returns without calling the code <span class="No-Break">under test.</span></p>
			<p>If the bytes <em class="italic">are</em> successfully converted into a string, the fuzz target exercises the code under test by passing the newly generated string to the <span class="No-Break"><strong class="source-inline">is_bob</strong></span><span class="No-Break"> function.</span></p>
			<p>The final two lines are more boilerplate that you must include in any Python-based <span class="No-Break">fuzz target.</span></p>
			<p>Remember that the fuzz target must be written in the same language as the code under test. Although the concepts used in non-Python fuzz targets are very similar to what is demonstrated here, the boilerplate and data transformation code will look slightly different in <span class="No-Break">other languages.</span></p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor150"/>A fuzz testing workflow</h2>
			<p>Here’s how the four<a id="_idIndexMarker483"/> components work together to perform fuzz testing whenever you run your <span class="No-Break">project’s pipeline:</span></p>
			<ol>
				<li value="1">The CI/CD job called <strong class="source-inline">fuzz-test-is-bob</strong> triggers as part of the <strong class="source-inline">fuzz</strong> stage. It downloads the <strong class="source-inline">gitlab-cov-fuzz</strong> binary and the Python-based fuzz engine. It then runs the <strong class="source-inline">gitlab-cov-fuzz</strong> binary, pointing it at the Python fuzz engine and the fuzz target that lives <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">is_bob_fuzz_target.py</strong></span><span class="No-Break">.</span></li>
				<li>The fuzz engine generates a series of random bytes and passes them to the <strong class="source-inline">fuzz</strong> function <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">is_bob_fuzz_target.py</strong></span><span class="No-Break">.</span></li>
				<li>The fuzz target transforms the random bytes into a string, since that’s the data type that the <strong class="source-inline">is_bob</strong> function (i.e., the code under test) expects <span class="No-Break">as input.</span></li>
				<li>The fuzz target passes the string <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">is_bob</strong></span><span class="No-Break">.</span></li>
				<li>If <strong class="source-inline">is_bob</strong> handles the random string gracefully—that is, without crashing or throwing any unexpected exceptions—the fuzz engine looks at which lines of code were exercised by the last series of random bytes and generates a new series of random bytes that are designed to exercise different lines in <strong class="source-inline">is_bob</strong>. This cycle continues, with the fuzz engine generating new bytes with each pass through <span class="No-Break">the cycle.</span></li>
				<li>If, on the other hand, the random string causes <strong class="source-inline">is_bob</strong> to crash or throw an unexpected exception, the fuzz engine reports that to the <strong class="source-inline">fuzz-test-is-bob</strong> CI/CD job, which reports that the fuzz test has found a bug in the code under test. Success! Well, success at triggering a <span class="No-Break">failure, anyway.</span></li>
			</ol>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor151"/>Viewing the results of fuzz testing</h2>
			<p>When the fuzz test finds a bug, it displays this<a id="_idIndexMarker484"/> information in <span class="No-Break">three places:</span></p>
			<ul>
				<li>The vulnerability report, which you can navigate to by clicking <strong class="bold">Security &amp; Compliance</strong> | <strong class="bold">Vulnerability Report</strong> in the left navigation pane. This only shows any problems that fuzz testing found on your project’s <span class="No-Break">default branch.</span></li>
				<li>The <strong class="bold">Security</strong> tab on the pipeline details page. This shows any problems that fuzz testing found on whatever branch that pipeline instance <span class="No-Break">ran against.</span></li>
				<li>In a merge request. This shows a <em class="italic">delta</em> between problems that fuzz testing found on the default branch and problems it found on the source branch of the merge request. If nothing has changed between the default branch and the source branch, the<a id="_idIndexMarker485"/> merge request will report that the fuzz test found no problems at all, no matter how many problems actually exist on <span class="No-Break">both branches.</span></li>
			</ul>
			<p>Although the exact bugs reported will vary according to the type of report you’re looking at, the type of details provided by each report will be almost identical. For example, here’s a page from the vulnerability report that presents details about the bug that fuzz testing found in the <strong class="source-inline">is_bob</strong> code <span class="No-Break">under test:</span></p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_6.07_B18073.jpg" alt="Figure 6.7 – Fuzz testing bug report" width="790" height="751"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Fuzz testing bug report</p>
			<p>Notice that this report includes a stack trace showing what error was thrown (<strong class="source-inline">IndexError</strong>), and which line <a id="_idIndexMarker486"/>threw it (the line with the <strong class="source-inline">return</strong> statement). The report also tells you which random bytes—also called a “sample”—triggered the problem. In this case, the fuzz engine generated a single byte: 62. It turns out that 62 in UTF-8 corresponds to the lowercase letter of <strong class="source-inline">b</strong>. If you look at the <strong class="source-inline">is_bob</strong> function in the code under test, you should be able to see exactly why an input string consisting of a single letter, <strong class="source-inline">b</strong>, would expose this bug. Isn’t it satisfying when a complicated system such as the fuzz tester works exactly <span class="No-Break">as expected?</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor152"/>Extra considerations when fuzz testing</h2>
			<p>Compared to the predictable, logical nature of the other ways you can validate your code with GitLab, fuzz testing is like your erratic uncle who shows up to family gatherings wearing mismatched socks and spewing mysterious comments that could be either deeply profound or utter <a id="_idIndexMarker487"/>nonsense, depending on the day. Fuzz testing’s random nature means that its results can be unpredictable. You might run the same fuzz test on the same code under test on 2 different days and find a bug within 10 seconds on the first day, but find nothing after 10 minutes on the second day. You never quite know what fuzz testing will turn up, if anything at all. This isn’t anything to worry about, since a new fuzz testing session will happen every time you run your project’s pipeline; even if it doesn’t find anything today, it might find an important <span class="No-Break">problem tomorrow.</span></p>
			<p>Keeping in mind that fuzz testing increases its chances of finding problems the longer it runs, some teams choose to run it asynchronously rather than as a normal pipeline job that blocks later stages in the pipeline. This technique is beyond the scope of this book, but GitLab’s documentation explains how to set this up if you’d like to experiment <span class="No-Break">with it.</span></p>
			<p>Another way that fuzz testing differs from other tests or scanners is that it stops as soon as it finds a single problem, whereas other tools typically continue to run until they’ve found and reported on every issue they’re capable of unearthing. Again, this is normally not a problem since most projects will run fuzz testing tens, hundreds, or thousands of times over the course of their development. But it’s good to understand that just because fuzz testing found a bug today, it doesn’t mean there are more bugs lurking in your code that it might find on <span class="No-Break">subsequent runs.</span></p>
			<p>Remember that although you can fuzz-test as many functions in your code under test as you’d like, you must create a separate CI/CD job and a separate fuzz target for each function. This can add up to significant overhead when you’re getting fuzz testing off the ground. Fortunately, once everything’s in place and fuzz testing is working as expected, there’s usually no need to change either the jobs or the <span class="No-Break">fuzz targets.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor153"/>Fuzz testing with a corpus</h2>
			<p>Fuzz testing has a special, optional feature that <a id="_idIndexMarker488"/>you can use called a <strong class="bold">corpus</strong>. This is a list of random bytes that the fuzz tester can use for two purposes. First, if a particular series of random bytes caused a bug or crash in the code under test, and then your team fixed that bug, it could be useful for future fuzz tests to send exactly the same random bytes to the code under test to make sure that it hasn’t regressed. In other words, once your team<a id="_idIndexMarker489"/> fixes a bug, it’s a nice safety measure for the fuzz test to make sure that it stays fixed. If you add the troublesome bytes to the corpus, then all future fuzz test runs will use that series of bytes as one of the values sent to the code <span class="No-Break">under test.</span></p>
			<p>The second use of a corpus is to help the fuzz tester find bugs more quickly. When it generates truly random bytes as input to the code under test, it can take a long time to find bugs—if it ever finds them at all. But if you load up the corpus with one or more series of bytes that constitute valid input (i.e., input that the code under test can handle gracefully), then the fuzz test can mutate that valid data and use the mutated data as its next series of input to the code under test. Mutating valid data often results in finding data that triggers bugs far more quickly than relying on truly random bytes as input to the code <span class="No-Break">under test.</span></p>
			<p>Setting up a corpus can be somewhat complicated, especially if you want to make use of a clever GitLab feature that automatically updates the corpus every time the fuzz test finds a bug. The GitLab documentation will lead you through this process if you think a corpus might be useful. We do recommend experimenting with this optional feature because it can hugely increase the power of <span class="No-Break">fuzz testing.</span></p>
			<p>Next, we’ll move on from the powerful and somewhat exotic bug-finding tool of fuzz testing and look at an important but often-overlooked way of checking the quality of your code: <span class="No-Break"><strong class="bold">accessibility testing</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor154"/>Checking accessibility in a CI/CD pipeline</h1>
			<p>Not all applications include <a id="_idIndexMarker490"/>web interfaces, but whenever you do write a web app, we strongly recommend you use your GitLab CI/CD pipeline to make sure your interface is accessible for people with a range of disabilities. Fortunately, GitLab makes it easy to test your website against the <strong class="bold">Web Content Accessibility Guidelines</strong> (<strong class="bold">WCAG</strong>) laid out by the World Wide <span class="No-Break">Web </span><span class="No-Break"><a id="_idIndexMarker491"/></span><span class="No-Break">Consortium.</span></p>
			<p>These guidelines address a wide assortment of characteristics of websites that could cause accessibility problems. Here <a id="_idIndexMarker492"/>are just a few of the things that the <span class="No-Break">WCAG covers:</span></p>
			<ul>
				<li>Pages that require scrolling both vertically <span class="No-Break">and horizontally</span></li>
				<li>HTML heading tags such as <strong class="source-inline">&lt;H1&gt;</strong> that contain <span class="No-Break">no text</span></li>
				<li>Text that doesn’t contrast strongly enough with <span class="No-Break">its background</span></li>
				<li>Images that lack an alternative <span class="No-Break">text description</span></li>
				<li>Button controls that have no name available for <span class="No-Break">screen readers</span></li>
			</ul>
			<p>You might be surprised both at how many accessibility problems this scanner finds in your web interface, and also at how easy it is to fix many of these issues. Don’t feel bad if it finds several accessibility bugs on your site; try pointing the scanner at any popular website and you’ll probably be amazed at the number of basic accessibility violations <span class="No-Break">it exhibits!</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor155"/>Enabling accessibility testing</h2>
			<p>To add accessibility testing to<a id="_idIndexMarker493"/> your pipeline, you first need to create a new stage called <strong class="source-inline">accessibility</strong> in your <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitlab-ci.yml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
stages:
  - accessibility</pre>
			<p>In all likelihood, your project will already have a <strong class="source-inline">stages</strong> section defined, in which case you should just add the new <strong class="source-inline">accessibility</strong> stage to the existing section instead of defining a whole new <strong class="source-inline">stages</strong> section (which would produce a malformed <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitlab-ci.yml</strong></span><span class="No-Break"> file).</span></p>
			<p>Next, include the GitLab-provided template that contains the accessibility-related <span class="No-Break">job definitions:</span></p>
			<pre class="source-code">
include:
  - template: "Verify/Accessibility.gitlab-ci.yml"</pre>
			<p>As we said before, if you’ve already defined an <strong class="source-inline">include</strong> section, simply add this template to it instead of defining a new <span class="No-Break"><strong class="source-inline">include</strong></span><span class="No-Break"> section.</span></p>
			<p>Finally, set a global variable that tells the accessibility scanner which website to inspect. This could be your web app in its production environment or in any pre-production, staging, or review environment. It can also be fun (and instructive) to point the accessibility scanner at any site<a id="_idIndexMarker494"/> on the web, even if it’s not one you own. Here, we’ll point it at a pretend URL where the Hats for Cats website runs <span class="No-Break">in production:</span></p>
			<pre class="source-code">
variables:
    a11y_urls: «https://www.hats-for-cats.com»</pre>
			<p>Once again, if you already have a global <strong class="source-inline">variables</strong> section, simply add this new variable to it instead of creating a second <span class="No-Break"><strong class="source-inline">variables</strong></span><span class="No-Break"> section.</span></p>
			<p>Believe it or not, that’s all you need to do. To get accessibility testing up and running in your pipeline. The accessibility scanner doesn’t offer any other configuration options, which makes it extremely simple to <span class="No-Break">set up.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor156"/>Viewing accessibility testing results</h2>
			<p>The accessibility scanner <a id="_idIndexMarker495"/>doesn’t integrate its results into a GitLab dashboard like you saw with the automated functional test results. But it does generate an easy-to-read HTML page that describes all of the less<a id="_idIndexMarker496"/> severe problems (called <strong class="bold">warnings</strong>) and more severe problems (called <strong class="bold">errors</strong>) <span class="No-Break">it</span><span class="No-Break"><a id="_idIndexMarker497"/></span><span class="No-Break"> finds.</span></p>
			<p>To see this page, run a pipeline with accessibility testing enabled and visit the pipeline details page. You’ll see a job called <strong class="source-inline">a11y</strong>, which is the job that runs the accessibility scanner. Click on that job to see the terminal output from the job. You can ignore that output, but in the <strong class="bold">Job artifacts</strong> pane on the right, you’ll see a button for browsing any artifacts produced by <span class="No-Break">the job:</span></p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_6.08_B18073.jpg" alt="Figure 6.8 – Finding the accessibility scanner’s artifacts" width="965" height="625"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Finding the accessibility scanner’s artifacts</p>
			<p>Clicking this button will show you both JSON and HTML reports generated by the accessibility scanner. These reports both contain the same information about any accessibility violations found on the targeted website. The JSON output can be downloaded, parsed, and integrated into any other dashboard you may have set up. The HTML report is human<a id="_idIndexMarker498"/>-readable within your browser and lets everyone on your team see what accessibility-related work you might want to carve out into issues so it can be tracked <span class="No-Break">and managed.</span></p>
			<p>There’s another way to see the findings of the accessibility scanner, other than by looking at one of its two artifacts. Remember how a merge request’s versions of Code Quality reports and automated functional test reports show the difference between code quality or test results on the default branch and code quality or test results on the merge request’s source branch? The merge request report on accessibility violations works in exactly the <span class="No-Break">same way.</span></p>
			<p>If you have a branch with a corresponding merge request, the merge request will show any accessibility violations that were found on the latest pipeline that was run against that branch, as long as those violations are <em class="italic">not</em> also found on a pipeline run against the default branch at the time the branch was created. In other words, the merge request shows you whether the pipeline’s branch is making your project’s code better (by fixing accessibility problems that were on the default branch) or worse (by adding new accessibility problems<a id="_idIndexMarker499"/> that were not on the default branch). This is a great report to have if you’re working on a feature branch and want to make sure your boss doesn’t yell at you because you’re adding more problems than <span class="No-Break">you’re fixing!</span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor157"/>Additional ways to verify your code</h1>
			<p>We’ve covered some of the most common ways to verify your code. GitLab offers even more features that help you test your code further. We don’t have enough space to cover all of them in detail, but here’s a quick description of three additional methods you can use to test code. Details for enabling and configuring all of these tools are available in the official <span class="No-Break">GitLab documentation.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor158"/>Code coverage</h2>
			<p>Automated functional tests make sure that <a id="_idIndexMarker500"/>your code is doing what it’s supposed to do. Having tests in place is a critical part of every software development project, but it’s easy to get a false sense of confidence from seeing that all your tests are passing if you don’t know how much of your code base those tests cover. After all, having 100 passing tests doesn’t do you much good if all of those tests execute the same 5% of your <span class="No-Break">application’s code.</span></p>
			<p>Code coverage reports give you confidence in the value of your test results. You can configure GitLab to use an appropriate, language-specific code coverage tool to determine exactly which lines of your product code are exercised by your tests. This report is integrated into the GitLab GUI, so it’s easy to tell which lines of code you should target as you write <span class="No-Break">new tests.</span></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor159"/>Browser performance testing</h2>
			<p>Since so many of today’s applications<a id="_idIndexMarker501"/> are run in a browser, and<a id="_idIndexMarker502"/> since browser-based applications are generally much slower than traditional desktop applications, it’s important to keep track of how quickly the various pages of your website load, and to know whether changes you’re making to the code are making those load times better <span class="No-Break">or worse.</span></p>
			<p>GitLab can measure page load times and display the results in merge requests so developers can understand how their proposed code changes affect the performance of their web app. It can even raise a special alert whenever performance degrades beyond a particular user-configurable<a id="_idIndexMarker503"/> threshold. The report lets developers fix any performance-related problems that their code has introduced before their code is merged into the stable <span class="No-Break">code base.</span></p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor160"/>Load performance testing</h2>
			<p>While browser performance testing tells you how quickly the frontend GUI of your web app loads, GitLab’s <strong class="bold">load performance testing</strong> helps <a id="_idIndexMarker504"/>you track the performance of your applications’ backend code. Although this feature can exercise your application in various ways, it’s most commonly used to target your application’s API. For example, it can hammer your application <a id="_idIndexMarker505"/>with tens, hundreds, or thousands of simultaneous calls to one or more of your application’s REST API endpoints, and then monitor how quickly your application responds to those calls. You can also use this tool to perform long-running soak tests to see whether your application develops memory leaks or other problems <span class="No-Break">over time.</span></p>
			<p>The load performance test feature displays its findings in merge requests so developers can understand how any code changes on the branch associated with that merge request affect their applications’ <span class="No-Break">backend performance.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor161"/>Summary</h1>
			<p>Once again, you covered a lot of ground in this chapter. You saw how to build code within a GitLab CI/CD pipeline, using a variety of different methods and languages. This doesn’t cover every possible way you could compile or otherwise build your code—we’ve barely scratched the surface of that topic—but you should have a good idea of the general steps involved regardless of what language or tools you use. You also learned that certain kinds of code verification tools require that you build your code first because they interact with your code as it runs. Other tests don’t require this step because they simply scan your source code without <span class="No-Break">running it.</span></p>
			<p>Next, you saw how to use GitLab’s Code Quality feature within your pipelines to make sure your code follows best practices for coding style, adheres to common coding conventions, avoids unnecessary complexity, and doesn’t exhibit any <em class="italic">code smells</em> that indicate the possible presence of bugs or <span class="No-Break">unexpected behavior.</span></p>
			<p>Then you learned how to integrate automated functional tests into GitLab CI/CD pipelines. You saw not only how to trigger these tests from within a pipeline job but also how to ensure that the results can be seen in two different reports within the GitLab GUI. You also discovered how to use the <em class="italic">delta</em> view of test results within a merge request to learn whether the code on that merge request’s branch is helping or hurting the pass rate of your product’s <span class="No-Break">automated tests.</span></p>
			<p>Next up was fuzz testing, GitLab’s most complicated but perhaps most interesting bug-finding feature. You learned about the four different components that make up the fuzz testing architecture, and you saw how random data flows from one component to the next in an attempt to trip up your code and cause crashes or unexpected exceptions. You became familiar with fuzz testing’s various idiosyncrasies and learned how to accommodate them. Finally, you saw how to use a corpus not only to catch functional regressions in your code but also to speed up fuzz testing and make it more likely to <span class="No-Break">find problems.</span></p>
			<p>The final tool you got to watch in action was GitLab’s accessibility testing feature. This helps you ensure that your web applications are usable by people with a range of disabilities, maximizing your possible <span class="No-Break">user base.</span></p>
			<p>These tools are a great place to start when it comes to validating your software projects, but GitLab offers several additional ways to inspect your code even more thoroughly. You got a lightning-fast tour of the code coverage tool, browser performance testing, and load performance testing. All of this will reward further exploration using GitLab’s official documentation and some experimentation of <span class="No-Break">your own.</span></p>
			<p>Once your code has been verified, you can deploy it to a production environment for customers to use, right? Nope. You first need to make sure it doesn’t contain any security vulnerabilities, which is the topic we’ll explore in the <span class="No-Break">next chapter.</span></p>
		</div>
		<div>
			<div id="_idContainer067" class="IMG---Figure">
			</div>
		</div>
	</div>
</div>
</body></html>