- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Packaging and Deploying Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和部署代码
- en: In the previous chapters, you learned how to use GitLab for source code management,
    as well as to set up CI/CD pipelines that build, test, and perform security scanning
    against the code you’ve checked in. You have hopefully now developed a confident
    understanding of both the infrastructure around GitLab CI/CD and the syntax used
    to author pipelines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，你已经学习了如何使用 GitLab 进行源代码管理，并设置 CI/CD 管道来构建、测试和对已提交的代码进行安全扫描。你现在应该已经自信地理解了
    GitLab CI/CD 周围的基础设施以及用于编写管道的语法。
- en: In this chapter, we will continue our journey through the stages of software
    development, focusing now on packaging and deploying code. We will use a combination
    of GitLab’s built-in features and common industry tools to deploy our code to
    an endpoint or environment. The goal is to answer the question, *how do we make
    the application we have built and tested available to* *our users?*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将继续软件开发阶段的旅程，现在专注于打包和部署代码。我们将结合使用 GitLab 的内置功能和常见的行业工具，将我们的代码部署到端点或环境。目标是回答这个问题，*我们如何使已经构建和测试的应用程序可供我们的用户使用？*
- en: This chapter will introduce new vocabulary, adding to our knowledge of GitLab
    CI/CD syntax. It will also mention, and the examples will use, third-party tools
    such as Docker, as well as cloud service providers such as Google Cloud Platform.
    Since this book’s core focus is on GitLab’s features and we don’t have the space
    for a technical deep dive into every tool that could be used with GitLab, you
    may be unfamiliar with some of the technologies referenced in this chapter. We
    will therefore strive to use industry-standard language, focus on each tool’s
    integration with GitLab, and provide examples that can be replicated without requiring
    further knowledge from the reader. After completing this chapter, you will be
    equipped with the skills needed to use GitLab’s native package and container registry
    features for hosting completed builds. You will also extend your knowledge of
    GitLab CI/CD to include deploying to review and production environments, using
    traditional or cloud-native infrastructures.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍新词汇，扩展我们对 GitLab CI/CD 语法的理解。还会提到并使用第三方工具，如 Docker，以及云服务提供商，如 Google Cloud
    Platform。由于本书的核心重点是 GitLab 的功能，我们没有空间对每个可以与 GitLab 配合使用的工具进行技术性深入探讨，因此你可能对本章中提到的某些技术不太熟悉。因此，我们将尽力使用行业标准语言，重点介绍每个工具与
    GitLab 的集成，并提供可以复制的示例，不要求读者拥有进一步的知识。完成本章后，你将掌握使用 GitLab 原生软件包和容器注册表功能来托管已完成构建所需的技能。你还将扩展对
    GitLab CI/CD 的知识，包括使用传统或云原生基础设施将代码部署到评审和生产环境。
- en: 'Here is how we’ll cover the topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章将涵盖的主题：
- en: Storing code in GitLab’s package registry for later re-use
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码存储在 GitLab 的软件包注册表中，以备后续重用
- en: Storing code in GitLab’s container and package registries for later deployment
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码存储在 GitLab 的容器和软件包注册表中，以备后续部署
- en: Deploying to different environments using GitLab Flow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitLab Flow 部署到不同环境
- en: Deploying to a review app for testing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到评审应用进行测试
- en: Deploying to real-world production environments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到实际生产环境
- en: Deploying to a Kubernetes cluster
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到 Kubernetes 集群
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Like the previous chapters, you’ll get the most out of this chapter if you
    have an account on a GitLab instance (SaaS or self-managed). Moreover, the topics
    and examples in this chapter will increasingly focus on deploying to environments
    that live outside GitLab. The infrastructure tools that are referenced include
    the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与前几章一样，如果你有一个 GitLab 实例账户（SaaS 或自托管），你将能最大限度地从本章中受益。此外，本章的主题和示例将越来越侧重于部署到 GitLab
    之外的环境。提到的基础设施工具包括：
- en: A server hosting GitLab (or GitLab.com)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管 GitLab 的服务器（或 GitLab.com）
- en: Self-hosted runners (or SaaS runners hosted on GitLab.com)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自托管运行器（或托管在 GitLab.com 上的 SaaS 运行器）
- en: Docker (also available on SaaS runners hosted on Gitlab.com)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker（也可在托管在 GitLab.com 上的 SaaS 运行器上使用）
- en: Kubernetes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Cloud platform services (such as Amazon Web Services, Google Cloud Platform,
    or Heroku)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云平台服务（如 Amazon Web Services、Google Cloud Platform 或 Heroku）
- en: If you wish to minimize the amount of tooling you need to install and maintain
    yourself, we recommend using GitLab.com with SaaS runners. We also recommend creating
    an account on a cloud service platform if you wish to practice deploying to live
    or complex infrastructure. Just be aware of the potential charges when using these
    services.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望最小化需要安装和维护的工具量，我们建议使用 GitLab.com 和 SaaS 运行器。如果您希望练习将应用部署到实时或复杂的基础设施，我们也建议在云服务平台上创建一个帐户。只要注意使用这些服务时可能产生的费用。
- en: Storing code in GitLab’s package registry for later re-use
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码存储在 GitLab 的软件包注册表中以供后续重用
- en: As part of the goal of serving as a complete DevOps platform, GitLab includes
    the option to enable package and container registries in each project. The package
    registry supports hosting software packages and language packs in a variety of
    formats, and the container registry serves as a repository of purpose-built container
    images. These features allow teams to conveniently host, organize, and version-control
    completed builds alongside their source code. We will discuss the package and
    container registries in turn.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 作为作为完整 DevOps 平台的目标之一，GitLab 在每个项目中都包含启用软件包和容器注册表的选项。软件包注册表支持以多种格式托管软件包和语言包，容器注册表作为专用容器镜像的仓库。这些功能使团队能够方便地托管、组织和版本控制完成的构建，并与源代码一起使用。我们将依次讨论软件包和容器注册表。
- en: Locating GitLab’s container and package registries
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位 GitLab 的容器和软件包注册表
- en: GitLab projects technically support three types of built-in registries. They
    are package, container, and infrastructure registries that can be used to store
    completed code, whether for use by end users or other software projects. This
    book will focus on the package and container registries; the infrastructure registry
    is a recent addition to GitLab that is specifically for hosting Terraform modules.
    GitLab also supports pushing artifacts to external or third-party registries,
    though that is beyond the scope of what we will cover here.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 项目技术上支持三种内置注册表。它们是软件包、容器和基础设施注册表，可用于存储完成的代码，无论是供终端用户使用还是供其他软件项目使用。本书将重点讨论软件包和容器注册表；基础设施注册表是
    GitLab 最近添加的功能，专门用于托管 Terraform 模块。GitLab 还支持将构件推送到外部或第三方注册表，尽管这超出了我们在此讨论的范围。
- en: '*Figure 8**.1* shows where GitLab’s packages and container registries can be
    found at both the project and group level, under **Packages and registries** in
    the left navigation pane.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.1* 显示了在项目和组级别下，GitLab 的软件包和容器注册表的位置，在左侧导航窗格中的 **软件包和注册表** 下。'
- en: '![Figure 8.1 – Packages and registries in the left sidebar](img/B18073_08_1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 左侧边栏中的软件包和注册表](img/B18073_08_1.jpg)'
- en: Figure 8.1 – Packages and registries in the left sidebar
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 左侧边栏中的软件包和注册表
- en: When you hover over **Packages and registries**, you will see that each of the
    package, container, and infrastructure registries have a dedicated page to navigate
    to, as shown in *Figure 8**.2*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将鼠标悬停在 **软件包和注册表** 上时，你会看到软件包、容器和基础设施注册表都有各自的页面可以导航，如 *图 8.2* 所示。
- en: '![Figure 8.2 – Packages and registries sub-menu items](img/B18073_08_2.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 软件包和注册表子菜单项](img/B18073_08_2.jpg)'
- en: Figure 8.2 – Packages and registries sub-menu items
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 软件包和注册表子菜单项
- en: If we have not yet configured or pushed artifacts to any of the registries,
    we will see an appropriate message when we navigate to the registry page. *Figure
    8**.3* shows the message we see on the **Package Registry** page, along with a
    reference to the GitLab documentation for using the package registry.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们还没有配置或推送任何构件到注册表，当我们访问注册表页面时，会看到一条适当的提示信息。*图 8.3* 显示了我们在 **软件包注册表** 页面上看到的提示信息，并附带了使用软件包注册表的
    GitLab 文档链接。
- en: '![Figure 8.3 – Project package registry with no packages](img/B18073_08_3.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 没有软件包的项目软件包注册表](img/B18073_08_3.jpg)'
- en: Figure 8.3 – Project package registry with no packages
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 没有软件包的项目软件包注册表
- en: '*Figure 8**.4* shows us an unpopulated **Container Registry**. Here, GitLab
    suggests Docker commands we could use to build a containerized version of our
    application that we then push to the container registry.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.4* 向我们展示了一个未填充的 **容器注册表**。在这里，GitLab 提示我们可以使用 Docker 命令构建应用程序的容器化版本，然后将其推送到容器注册表。'
- en: '![Figure 8.4 – Project container registry with no container images](img/B18073_08_4.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 没有容器镜像的项目容器注册表](img/B18073_08_4.jpg)'
- en: Figure 8.4 – Project container registry with no container images
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 没有容器镜像的项目容器注册表
- en: We will soon see that a typical way to push to GitLab’s registries is to configure
    CI/CD jobs that execute commands to build an artifact, authenticate it with the
    registry, and push the artifact to the registry, often using GitLab’s API.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快会看到，将内容推送到 GitLab 注册表的典型方式是配置执行构建工件的命令的 CI/CD 作业，对其进行身份验证并将工件推送到注册表，通常使用
    GitLab 的 API。
- en: Getting started with the package registry
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用软件包注册表
- en: The package registry is enabled by default in GitLab, though it can be disabled
    by GitLab administrators at the instance level. In project settings, you can also
    choose to toggle the package registry feature on or off under **Settings** | **General**
    | **Visibility, project features, permissions**. If **Packages** is toggled off,
    the feature will not be available in the left sidebar. *Figure 8**.5* shows where
    the package registry can be enabled or disabled in the project settings.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab 中，软件包注册表默认启用，尽管管理员可以在实例级别禁用它。在项目设置中，你还可以选择在 **设置** | **常规** | **可见性、项目功能、权限**
    下启用或禁用软件包注册表功能。如果将 **Packages** 选项关闭，则左侧边栏将无法显示该功能。*图 8.5* 显示了在项目设置中启用或禁用软件包注册表的位置。
- en: '![Figure 8.5 – Enabling the package registry in project settings](img/B18073_08_5.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 在项目设置中启用软件包注册表](img/B18073_08_5.jpg)'
- en: Figure 8.5 – Enabling the package registry in project settings
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 在项目设置中启用软件包注册表
- en: 'The question now arises, how do we use the package registry? That is, how do
    we populate it with our software? There are two primary steps to populate the
    package registry: authenticate to the registry, and build and upload packages
    using CI/CD jobs. But before diving into those steps, let’s first list the package
    formats supported by GitLab.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题来了，我们如何使用软件包注册表？也就是说，我们如何将软件填充到其中？填充软件包注册表有两个主要步骤：首先是对注册表进行身份验证，然后是通过 CI/CD
    作业构建并上传软件包。但在深入了解这些步骤之前，我们先列出 GitLab 支持的软件包格式。
- en: Supported package formats
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持的软件包格式
- en: 'As of this writing, the following package manager formats are generally available
    and fully supported in GitLab’s package registry:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 截至本书写作时，以下软件包管理器格式通常可用并已完全支持 GitLab 的软件包注册表：
- en: Generic packages
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用软件包
- en: Maven
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: npm
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: npm
- en: NuGet
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NuGet
- en: PyPI
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyPI
- en: 'The following package formats are either behind a feature flag or have known
    issues with their use:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下软件包格式要么是受功能标志控制，要么使用时存在已知问题：
- en: Composer
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Composer
- en: Conan
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Conan
- en: Debian
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debian
- en: Go
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: Helm
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: Ruby Gems
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ruby Gems
- en: Each package manager has its own configuration format and syntax. To maintain
    consistency, as well as to keep our focus on the concepts underlying GitLab’s
    package, we will show examples using generic package formats. We will start with
    authenticating to GitLab’s package registry.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个软件包管理器都有自己的配置格式和语法。为了保持一致性，并专注于 GitLab 软件包的核心概念，我们将使用通用的软件包格式来展示示例。我们将从对 GitLab
    软件包注册表进行身份验证开始。
- en: Authenticating to the registry
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对注册表进行身份验证
- en: 'We mentioned earlier in this chapter that working with GitLab’s registries
    takes place largely through CI/CD jobs. The actions of authenticating, uploading
    to, and using packages from the package registry should be represented by job
    tasks defined in GitLab CI/CD configurations. In general, you can authenticate
    to GitLab’s package registry with one of the following four types of credentials:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面提到过，使用 GitLab 的注册表主要通过 CI/CD 作业进行。身份验证、上传到注册表和使用注册表中的软件包的操作应该通过 GitLab
    CI/CD 配置中定义的作业任务来表示。一般来说，你可以通过以下四种凭据之一来验证 GitLab 的软件包注册表：
- en: A personal access token, to authenticate with a user’s permissions
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人访问令牌，用于使用用户权限进行身份验证
- en: A project deploy token, for accessing all packages in a project
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目部署令牌，用于访问项目中的所有软件包
- en: A group deploy token, for accessing all packages in all projects in a group
    or its subgroups
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个组部署令牌，用于访问组内或其子组中所有项目的所有软件包
- en: A job token, for accessing packages in the project for which the CI/CD job is
    defined
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个作业令牌，用于访问定义 CI/CD 作业的项目中的软件包
- en: Deploy tokens and job tokens are not tied to users
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 部署令牌和作业令牌与用户无关
- en: Unlike personal access tokens, deploy tokens and job tokens are special kinds
    of GitLab credentials that are not tied to a particular user, but rather can serve
    as an alternative way to authenticate without specifying user credentials. Deploy
    tokens and job tokens are often used to programmatically access a repository,
    or in our case, read and write to the package registry.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与个人访问令牌不同，部署令牌和作业令牌是特殊类型的GitLab凭证，它们与特定用户无关，而是可以作为一种无需指定用户凭证的替代身份验证方式。部署令牌和作业令牌通常用于以编程方式访问代码库，或者在我们的案例中，用于读取和写入包注册表。
- en: In our example, we’ll create a project-level deploy token in the Hats for Cats
    project. *Figure 8**.6* shows where we can create a new deploy token under project
    **Settings** | **Repository** | **Deploy Tokens**. Here, we can give the token
    a human-readable name, an optional expiration date, and an optional username that’s
    specific to the token (if we don’t enter an optional username, GitLab will auto-generate
    one for us).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将在“Hats for Cats”项目中创建一个项目级部署令牌。*图 8.6*显示了我们可以在项目**设置** | **代码库**
    | **部署令牌**下创建新的部署令牌的位置。在这里，我们可以为令牌指定一个易于识别的名称、一个可选的过期日期，以及一个可选的与令牌相关的用户名（如果不输入用户名，GitLab将自动为我们生成一个）。
- en: Finally, we select which permissions we want to grant the token. The permission
    names can appear slightly ambiguous, but `read_registry` and `write_registry`
    refer to reading and writing to the *container* registry only, while `read_package_registry`
    and `write_package_registry` refer to reading and writing to the package registry.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们选择要授予令牌的权限。权限名称可能略显模糊，但`read_registry`和`write_registry`仅指容器注册表的读取和写入，而`read_package_registry`和`write_package_registry`则指包注册表的读取和写入。
- en: '![Figure 8.6 – Creating a new deploy token](img/B18073_08_6.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 创建新的部署令牌](img/B18073_08_6.jpg)'
- en: Figure 8.6 – Creating a new deploy token
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 创建新的部署令牌
- en: Once we create a deploy token, GitLab will provide a password that we’ll need
    to save somewhere safe (see *Figure 8**.7*). We will use the deploy token password
    to authenticate our commands to the package or container registry.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了部署令牌，GitLab将提供一个密码，我们需要将其保存在安全的地方（见*图 8.7*）。我们将使用部署令牌密码对命令进行身份验证，以访问包或容器注册表。
- en: '![Figure 8.7 – Deploy token password](img/B18073_08_7.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 部署令牌密码](img/B18073_08_7.jpg)'
- en: Figure 8.7 – Deploy token password
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 部署令牌密码
- en: Don’t forget to save your deploy token!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了保存您的部署令牌！
- en: Be sure to save the password for the deploy token somewhere safe and secure!
    Once you leave the page, you will not be able to recover the password, as GitLab
    will not persistently store the credential.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要把部署令牌的密码保存在安全的地方！一旦离开页面，您将无法恢复密码，因为GitLab不会永久存储凭证。
- en: After you finish creating the deploy token and saving the password, GitLab will
    show the token and its details under **Active Deploy Tokens**, as shown in *Figure
    8**.8*. A project maintainer or owner can choose to revoke the token if it should
    no longer be used.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 完成创建部署令牌并保存密码后，GitLab将在**活跃的部署令牌**下显示该令牌及其详细信息，如*图 8.8*所示。如果不再需要使用该令牌，项目维护者或所有者可以选择撤销该令牌。
- en: '![Figure 8.8 – Active deploy tokens](img/B18073_08_8.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 活跃的部署令牌](img/B18073_08_8.jpg)'
- en: Figure 8.8 – Active deploy tokens
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 活跃的部署令牌
- en: 'We can now use the token we created to authenticate to the registry. The exact
    syntax we’d use for authentication would depend on our package manager, that is,
    the type of package we are creating or using. In the simplest case, we may include
    our credentials in the header of a `curl` command, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们创建的令牌进行注册表身份验证。我们用于身份验证的确切语法将取决于我们的包管理器，即我们正在创建或使用的包类型。在最简单的情况下，我们可以将凭证包含在`curl`命令的头部，如下所示：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When run in a CI/CD job, the preceding command authenticates to the project’s
    package registry in which the pipeline is running. The authentication credentials
    are provided by the `--user` flag, where we provide the username and password
    (shown as a placeholder here) for our deploy key. The output of the command will
    be to download the `my_app.tar.gz` package.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当在CI/CD作业中运行时，前述命令会对运行管道的项目的包注册表进行身份验证。身份验证凭证由`--user`标志提供，我们在其中提供部署密钥的用户名和密码（这里显示为占位符）。该命令的输出将下载`my_app.tar.gz`包。
- en: Using a deploy key is a programmatic way to pull or download from the registry.
    Downloading package files can also be done via the UI. *Figure 8**.9* shows an
    example of a `stable_releases` package, version 0.0.1, that has been added to
    the package registry.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用部署密钥是一种从注册表拉取或下载的编程方式。下载包文件也可以通过 UI 完成。*图 8.9* 显示了一个 `stable_releases` 包的示例，版本为
    0.0.1，已被添加到包注册表中。
- en: '![Figure 8.9 – Entry in the package registry](img/B18073_08_9.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 包注册表中的条目](img/B18073_08_9.jpg)'
- en: Figure 8.9 – Entry in the package registry
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 包注册表中的条目
- en: If we click on **stable_releases**, we see downloadable application files under
    the **Assets** heading (see *Figure 8**.10*). We see the filenames (and file types
    by their extensions), size, and creation date. Selecting the filename downloads
    the file to your local computer. Under **History**, we see when it was published
    to the registry, which pipeline build pushed the package, which commit launched
    the pipeline, and the package name and version.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击 **stable_releases**，我们可以在 **Assets** 标题下看到可下载的应用文件（见 *图 8.10*）。我们可以看到文件名（通过扩展名可以识别文件类型）、大小和创建日期。选择文件名会将文件下载到本地计算机。在
    **History** 部分，我们可以看到它何时发布到注册表、哪个管道构建推送了包、哪个提交启动了管道，以及包的名称和版本。
- en: '![Figure 8.10 – Package files and build history](img/B18073_08_10.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 包文件和构建历史](img/B18073_08_10.jpg)'
- en: Figure 8.10 – Package files and build history
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 包文件和构建历史
- en: Now that we understand how to authenticate to and access packages in the package
    registry, we will now use CI/CD jobs to build, push, and update packages in the
    registry.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何进行身份验证并访问包注册表中的包，接下来我们将使用 CI/CD 作业来构建、推送和更新注册表中的包。
- en: Building and pushing packages to the package registry
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建和推送包到包注册表
- en: As we’ve mentioned several times already, GitLab recommends using CI/CD jobs
    to build and publish to the registry. Technically, writing to the registry can
    just take place via API calls, so GitLab CI/CD isn’t strictly required. However,
    build and artifact management is well suited to GitLab Flow, and it is helpful
    to have the process standardized in a similar manner to your other software development
    workflows. For that reason, we will create a CI/CD pipeline to build and push
    to the registry.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的几次，GitLab 推荐使用 CI/CD 作业来构建和发布到注册表。从技术上讲，写入注册表可以通过 API 调用进行，因此 GitLab
    CI/CD 并不是严格必要的。然而，构建和产物管理非常适合 GitLab 流程，并且将此过程标准化，与其他软件开发工作流类似，是很有帮助的。出于这个原因，我们将创建一个
    CI/CD 管道来构建并推送到注册表。
- en: The exact job syntax will be dependent on the programming languages and package
    managers you use to build software. The GitLab documentation has specific syntax
    examples for authenticating, reading, and writing to the registry using Python,
    Maven, and other tools. To keep things conceptual, and because we don’t have the
    space to showcase every supported language or tool, we will use generic packages
    as our example, and our commands will be `curl`-style API calls.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 精确的作业语法将取决于您用来构建软件的编程语言和包管理器。GitLab 文档提供了用于使用 Python、Maven 和其他工具进行身份验证、读取和写入注册表的特定语法示例。为了保持概念性，并且因为我们没有空间展示每种受支持的语言或工具，我们将使用通用包作为示例，并且我们的命令将是
    `curl` 风格的 API 调用。
- en: 'A CI/CD configuration may look like the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 CI/CD 配置可能如下所示：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding example `.gitlab-ci.yml` content contains two stages: a `build`
    stage that compiles a C-style application and a `publish` stage that pushes the
    build artifact to the package registry. The `build` stage contains one job that
    builds our code. We then create an archive file containing the completed build
    and supporting files. The archive file is specified as an artifact in the build
    job so that the downstream `publish` job will have access to it.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例 `.gitlab-ci.yml` 内容包含两个阶段：一个 `build` 阶段，它编译一个 C 风格的应用程序，另一个是 `publish`
    阶段，它将构建产物推送到包注册表中。`build` 阶段包含一个作业来构建我们的代码。然后，我们创建一个包含完成的构建和支持文件的归档文件。该归档文件在构建作业中作为产物指定，以便下游的
    `publish` 作业可以访问它。
- en: The `publish_to_registry` job authenticates to the registry and uploads the
    build artifact. Note the presence of some dynamic CI/CD variables in the `curl`
    command (that is, the terms beginning with `CI_`). These variables are a convenient
    way to reference the correct URL and path to the registry in your project. Note
    we also categorize the build as a generic package, part of “stable release” version
    0.0.1.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`publish_to_registry`作业对注册表进行身份验证并上传构建产物。注意`curl`命令中的一些动态CI/CD变量（即以`CI_`开头的术语）。这些变量是引用项目中正确的注册表URL和路径的便捷方式。还要注意，我们将构建分类为通用包，属于“稳定发布”版本0.0.1的一部分。'
- en: 'We might also add a Unix timestamp to distinguish between different builds
    in the registry. We can modify the build job as follows to include a timestamp
    in the artifact filename:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以添加一个Unix时间戳，以区分注册表中的不同构建。我们可以按如下方式修改构建作业，以在产物文件名中包含时间戳：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Figure 8**.11* shows the updated file asset in the registry. Note the timestamp
    in the filename in the `tar` command in the build script. The archive size and
    creation date are also shown. A developer can then click the filename to download
    the archive, which they can then unpack on their local system.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.11* 显示了注册表中更新的文件资产。注意在构建脚本中的`tar`命令文件名中的时间戳。归档文件的大小和创建日期也会显示。开发人员可以点击文件名以下载该归档文件，然后可以在本地系统上解压。'
- en: '![Figure 8.11 – File in the package registry with a timestamp](img/B18073_08_11.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – 带有时间戳的包注册表中的文件](img/B18073_08_11.jpg)'
- en: Figure 8.11 – File in the package registry with a timestamp
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 带有时间戳的包注册表中的文件
- en: Building and pushing packages to the container registry
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建并推送包到容器注册表
- en: GitLab also has a container registry for storing Docker images. Like the package
    registry, Docker images can be created and pushed to the registry with CI/CD jobs.
    Authentication is conceptually similar to the package registry, but you’d use
    container platform tools such as Docker to authenticate, build, push, and pull
    container images.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab还提供了用于存储Docker镜像的容器注册表。与包注册表类似，可以通过CI/CD作业创建并推送Docker镜像到注册表。身份验证的概念与包注册表相似，但你需要使用容器平台工具（如Docker）来进行身份验证、构建、推送和拉取容器镜像。
- en: 'The following Docker command can be used to authenticate to the container registry,
    using our deploy token from earlier. We will use similar Docker commands to also
    build a containerized version of our application and push it to the registry:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Docker命令可用于使用我们之前的部署令牌对容器注册表进行身份验证。我们将使用类似的Docker命令来构建我们应用程序的容器化版本，并将其推送到注册表：
- en: '[PRE3]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our CI/CD job for “containerizing” our application and pushing it to the registry
    might look like the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的CI/CD作业用于“容器化”我们的应用程序并将其推送到注册表，可能如下所示：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let’s explain what is happening in the preceding CI/CD job, step by step:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步解释前述CI/CD作业中发生的事情：
- en: We name the job `publish_to_container_registry` as part of the**publish** stage.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将作业命名为`publish_to_container_registry`，作为**发布**阶段的一部分。
- en: 'We then include two containers in the CI/CD job runtime environment: a container
    with the official Docker tooling (`image: docker:stable`) and a service container
    with “Docker-in-Docker” tooling (`docker:dind`). The latter container type allows
    us to build containers inside our already-containerized CI/CD job environment
    (hence the Docker-*in*-Docker moniker).'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，我们在CI/CD作业的运行时环境中包含两个容器：一个包含官方Docker工具的容器（`image: docker:stable`），以及一个带有“Docker-in-Docker”工具的服务容器（`docker:dind`）。后者容器类型允许我们在已经容器化的CI/CD作业环境中构建容器（因此被称为Docker-*in*-Docker）。'
- en: Next, we define a variable called `IMAGE` that will specify the name of our
    container image, as well as its destination endpoint in the container registry.
    The `IMAGE` variable will be referenced as arguments to the `docker` command.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个名为`IMAGE`的变量，用于指定我们的容器镜像的名称，以及其在容器注册表中的目标端点。`IMAGE`变量将在`docker`命令中作为参数引用。
- en: 'Finally, the script section of our CI/CD job contains three commands:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的CI/CD作业脚本部分包含三个命令：
- en: The first command, `docker login`, authenticates to the container registry using
    our deploy token
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个命令，`docker login`，使用我们的部署令牌对容器注册表进行身份验证。
- en: The second command, `docker build`, builds a containerized version of our application
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个命令，`docker build`，构建我们应用程序的容器化版本。
- en: The final command, `docker push`, then pushes the newly built container image
    to the container registry
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的命令，`docker push`，将新构建的容器镜像推送到容器注册表。
- en: Be careful when building containers with Docker-in-Docker
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Docker-in-Docker构建容器时要小心。
- en: While it’s simple and straightforward, Docker-in-Docker uses the `--docker-privileged`
    flag by default, which can give the service running the containers root access
    to the host machine. If this is a security concern, GitLab also provides instructions
    for using a build tool called **kaniko** to build container images from a Dockerfile.
    See the GitLab documentation for more details.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很简单直接，但Docker-in-Docker默认使用`--docker-privileged`标志，这可能会使运行容器的服务获得对主机机器的root访问权限。如果这是一个安全问题，GitLab还提供了使用名为**kaniko**的构建工具从Dockerfile构建容器镜像的说明。请参阅GitLab文档以获取更多详情。
- en: 'It turns out that if we just add the preceding job to our CI/CD pipeline configuration
    and then run the pipeline, the job will fail. That is because we are missing another
    required component of building a container image. A file in our repository called
    `Dockerfile` is required to act as a “recipe” for how our container image will
    be built and what it should contain. Normally, a Dockerfile will contain instructions
    such as dependencies that should be installed, services that should be started,
    or ports that should be open. In this example, we will keep the Dockerfile extremely
    simple. A very minimal Dockerfile might contain the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现，如果我们仅将前面的任务添加到我们的CI/CD管道配置中并运行管道，那么任务将失败。这是因为我们缺少构建容器镜像的另一个必要组件。我们的代码库中有一个名为`Dockerfile`的文件，它作为容器镜像构建的“食谱”，规定了容器镜像的构建方式及其内容。通常，Dockerfile会包含一些指令，例如应该安装的依赖项、需要启动的服务或需要开放的端口。在这个例子中，我们将Dockerfile保持得非常简单。一个非常简单的Dockerfile可能包含以下内容：
- en: '[PRE5]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding Dockerfile does the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的Dockerfile执行了以下操作：
- en: It uses a minimal Linux distribution called Alpine Linux as the base operating
    system for the container we are building
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用一个名为Alpine Linux的最小化Linux发行版作为我们构建容器的基础操作系统
- en: It creates a directory in the container called `public-app/`
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在容器中创建了一个名为`public-app/`的目录
- en: It puts all our repository files in the `public-app/` directory
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将我们所有的代码库文件放在`public-app/`目录中
- en: It makes `public-app/` the working directory when the container is launched
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在容器启动时将`public-app/`设置为工作目录
- en: '*Figure 8**.12* shows how our project repository might look after we update
    our `.gitlab-ci.yml` file and create the Dockerfile.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.12*显示了在更新`.gitlab-ci.yml`文件并创建Dockerfile后，我们的项目代码库可能的样子。'
- en: '![Figure 8.12 – Our repository with the Dockerfile](img/B18073_08_12.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – 我们的代码库与Dockerfile](img/B18073_08_12.jpg)'
- en: Figure 8.12 – Our repository with the Dockerfile
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 我们的代码库与Dockerfile
- en: Now, when we run a CI/CD pipeline, we can see the Docker commands represented
    in the `publish_to_container_registry` job log, as shown in the following screenshot
    (*Figure 8**.13*). Notice how the output of the `docker build` command shows it
    following the recipe we specified in `Dockerfile`. The job script ends with confirmation
    that the container image was pushed to the project’s container registry.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行CI/CD管道时，可以在`publish_to_container_registry`任务日志中看到Docker命令，如下图所示（*图8**.13*）。注意，`docker
    build`命令的输出显示它遵循我们在`Dockerfile`中指定的食谱。任务脚本最后确认容器镜像已推送到项目的容器注册表。
- en: '![Figure 8.13 – Job log for publishing to the container registry](img/B18073_08_13.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 推送到容器注册表的任务日志](img/B18073_08_13.jpg)'
- en: Figure 8.13 – Job log for publishing to the container registry
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 推送到容器注册表的任务日志
- en: Checking the container registry, we in fact see a reference to the container
    name as we specified in the CI/CD job (*Figure 8**.14*).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 检查容器注册表时，实际上可以看到我们在CI/CD任务中指定的容器名称的引用（*图8**.14*）。
- en: '![Figure 8.14 – Image repository in the container registry](img/B18073_08_14.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – 容器注册表中的镜像库](img/B18073_08_14.jpg)'
- en: Figure 8.14 – Image repository in the container registry
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 容器注册表中的镜像库
- en: If we click on the container name, we can see the builds themselves (*Figure
    8**.15*).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们点击容器名称，就可以看到构建本身（*图8**.15*）。
- en: '![Figure 8.15 – Latest artifact in the project container registry](img/B18073_08_15.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15 – 项目容器注册表中的最新工件](img/B18073_08_15.jpg)'
- en: Figure 8.15 – Latest artifact in the project container registry
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 项目容器注册表中的最新工件
- en: So far, everything we have discussed covers finding, authenticating to, and
    writing to GitLab’s package and container registries. In the next section of this
    chapter, we will actually use and deploy the assets we have created and uploaded.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的内容涵盖了查找、验证以及写入GitLab的包和容器注册表。在本章的下一节中，我们将实际使用和部署我们创建并上传的资产。
- en: Storing code in GitLab’s container and package registries for later deployment
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码存储在 GitLab 的容器和包注册表中，以便以后部署
- en: GitLab’s package and container registries are useful not only for making software
    available for users to download but also for storing packages and libraries for
    use in CI/CD pipelines, or for deployment to an environment. In this section,
    we will discuss how to programmatically interact with the registries via CI/CD
    jobs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 的包和容器注册表不仅有助于将软件提供给用户下载，还用于存储包和库，以便在 CI/CD 管道中使用，或部署到环境中。在本节中，我们将讨论如何通过
    CI/CD 作业以编程方式与注册表进行交互。
- en: Using images from the container registry
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用来自容器注册表的镜像
- en: In the previous section, we built a containerized version of our app and pushed
    the image to GitLab’s container registry. Recall that the CI/CD jobs we used to
    build the container image themselves run in containers, hence the reference to
    terms such as `docker:stable` and `docker:dnd`. In this example, we are pulling
    from a public container registry, that is, Docker Hub.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们构建了一个容器化的应用程序版本，并将镜像推送到 GitLab 的容器注册表。回想一下，我们用来构建容器镜像的 CI/CD 作业本身是在容器中运行的，因此提到了诸如
    `docker:stable` 和 `docker:dnd` 这样的术语。在这个例子中，我们是从公共容器注册表（即 Docker Hub）中拉取镜像。
- en: 'However, we can also pull container images we have pushed to GitLab’s container
    registry and use them as the basis for running our CI/CD jobs. We can use them
    in our pipelines just as we did with public container images, using the `image`
    keyword, like in the following snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以拉取我们推送到 GitLab 容器注册表的容器镜像，并将其作为运行 CI/CD 作业的基础。我们可以像使用公共容器镜像一样，在管道中使用它们，使用
    `image` 关键字，如下片段所示：
- en: '[PRE6]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Figure 8**.16* shows our job output when we pull our container from the local
    registry to run our job.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.16* 显示了当我们从本地注册表拉取容器并运行作业时的作业输出。'
- en: .
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: '![Figure 8.16 – Using a local container in a CI/CD job](img/B18073_08_16.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.16 – 在 CI/CD 作业中使用本地容器](img/B18073_08_16.jpg)'
- en: Figure 8.16 – Using a local container in a CI/CD job
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16 – 在 CI/CD 作业中使用本地容器
- en: Note that the job log shows GitLab pulling the image from the container registry,
    as well as the contents of the container’s filesystem (that is, the files we included
    when we built the container in the first place).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，作业日志显示了 GitLab 从容器注册表中拉取镜像的过程，以及容器文件系统的内容（即我们在第一次构建容器时包含的文件）。
- en: Using packages from the package registry
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包管理器注册表中的包
- en: 'Using packages in the package registry follows a similar theme as publishing
    packages to the registry. The exact step and syntax for pulling from the registry
    will depend on the package type. In general, you’ll be required to specify the
    group and project where the package lives (i.e., the namespace in GitLab), the
    package name, and the package version. Consistent with the example from earlier,
    we might use a CI/CD job to pull down and run a generic package from our registry:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用包管理器注册表中的包遵循与发布包到注册表类似的主题。从注册表拉取包的确切步骤和语法将取决于包的类型。通常，你需要指定包所在的组和项目（即 GitLab
    中的命名空间）、包名以及包版本。与之前的示例一致，我们可能会使用 CI/CD 作业从我们的注册表中拉取并运行一个通用包：
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The job log in *Figure 8**.17* shows the output of authenticating and pulling
    down the package file via GitLab’s API. In this example, the package is then extracted
    from its archive file and run.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.17* 中的作业日志显示了通过 GitLab 的 API 认证并下载包文件的输出。在这个例子中，包被从其压缩文件中提取并运行。'
- en: '![Figure 8.17 – Using the package from the registry in a CI/CD job](img/B18073_08_17.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.17 – 在 CI/CD 作业中使用来自注册表的包](img/B18073_08_17.jpg)'
- en: Figure 8.17 – Using the package from the registry in a CI/CD job
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.17 – 在 CI/CD 作业中使用来自注册表的包
- en: GitLab’s documentation shows different steps to authenticate and download packages
    for different package managers, but the principles remain the same.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 的文档展示了为不同包管理器认证并下载包的不同步骤，但原则保持一致。
- en: Now that we understand how we can publish download packages in the context of
    CI/CD jobs, we will next incorporate these steps into a typical GitLab development
    workflow.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了如何在 CI/CD 作业的背景下发布和下载包，接下来我们将把这些步骤融入到典型的 GitLab 开发工作流中。
- en: Deploying to different environments using GitLab Flow
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitLab Flow 部署到不同的环境
- en: We have so far discussed how to store and use our completed code by publishing
    to and pulling from GitLab’s package and container registries. Now, we will learn
    about some of GitLab’s features for organizing deployments of code to particular
    environments.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何通过GitLab的包和容器注册表发布和拉取我们的完成代码。现在，我们将学习GitLab的一些功能，用于组织将代码部署到特定环境。
- en: GitLab has two terms, **environments** and **deployments**, that are used to
    describe and categorize the location and version of a deployed application. An
    environment is represented by a name and a URL, which serve as organizational
    labels inside GitLab. Whenever an application is deployed to that environment
    via CI/CD, GitLab creates and categorizes it as a new deployment.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab有两个术语，**环境**和**部署**，用于描述和分类已部署应用的位置和版本。环境通过名称和URL表示，作为GitLab中的组织标签。每当应用通过CI/CD部署到该环境时，GitLab会创建并将其分类为新的部署。
- en: 'Environments are created via the `testing`, and the generic app to an environment
    called `production`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 环境是通过`testing`创建的，且该环境将应用部署到名为`production`的通用应用中：
- en: '[PRE8]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Figure 8**.18* shows that environments are represented in the GitLab UI under
    **Deployments** | **Environments**.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.18* 显示了环境在GitLab UI中如何在**部署** | **环境**下进行表示。'
- en: '![Figure 8.18 – Environments in the GitLab UI](img/B18073_08_18.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.18 – GitLab UI中的环境](img/B18073_08_18.jpg)'
- en: Figure 8.18 – Environments in the GitLab UI
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.18 – GitLab UI中的环境
- en: Each environment is updated when a new commit creates a pipeline with a CI/CD
    job deploying to that environment. The GitLab UI shows the commit SHA for the
    latest deployment, the GitLab user who triggered the commit, the branch it was
    triggered on, and the CI/CD job deploying to that environment. The `https://prod.example.com`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个新的提交创建一个CI/CD管道并部署到该环境时，环境就会被更新。GitLab UI会显示最新部署的提交SHA、触发该提交的GitLab用户、触发提交的分支以及部署到该环境的CI/CD作业。(`https://prod.example.com`)。
- en: We can see that by integrating environments into GitLab CI/CD, we can set up
    more advanced workflows, such as using CI/CD keywords like **rules** to ensure
    certain environments are only updated when code changes on certain branches. The
    next section in this chapter will show such an example.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，通过将环境集成到GitLab CI/CD中，我们可以设置更高级的工作流，例如使用CI/CD关键字如**规则**，以确保只有在特定分支上代码更改时，某些环境才会被更新。本章的下一部分将展示这样的示例。
- en: Deploying to a review app for testing
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到审查应用进行测试
- en: GitLab has a feature called a `.gitlab-ci.yml` file that creates a job that
    deploys to a review app environment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab有一个名为`.gitlab-ci.yml`的功能，它创建了一个作业，该作业部署到审查应用环境。
- en: '![Figure 8.19 – Enable Review App](img/B18073_08_19.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.19 – 启用审查应用](img/B18073_08_19.jpg)'
- en: Figure 8.19 – Enable Review App
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.19 – 启用审查应用
- en: There are two key items to note in the job content. The first is the use of
    predefined CI/CD variables to specify the environment name and URL. The name of
    the review environment will be dynamically updated based on the triggering branch,
    and the URL will be updated based on the dynamic environment name. This is useful
    for spinning up temporary ad hoc environments during the development process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在作业内容中有两个关键点需要注意。第一个是使用预定义的CI/CD变量来指定环境名称和URL。审查环境的名称将根据触发的分支动态更新，URL也将根据动态环境名称进行更新。这对于在开发过程中快速启动临时的即席环境非常有用。
- en: The second item to note in the review app CI/CD job is its `only`/`except` keywords.
    The review app environment will *only* be deployed when a pipeline is triggered
    on a Git branch, *except* the main branch. The logic is that a branch represents
    a development line, but the main branch might be a more stable staging or production
    environment that is static rather than dynamic.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查应用CI/CD作业中需要注意的第二个点是其`only`/`except`关键字。审查应用环境*仅*在Git分支上触发管道时才会被部署，*除非*是主分支。其逻辑是，分支代表一个开发线，而主分支可能是一个更稳定的暂存或生产环境，是静态的而非动态的。
- en: One other useful element of review apps is their easy accessibility from a merge
    request. If a merge request pipeline has a review app job defined for the triggering
    branch, a link to the review app’s URL will be accessible from the merge request
    page (see *Figure 8**.20*).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 审查应用的另一个有用元素是它们可以通过合并请求轻松访问。如果合并请求的管道已定义触发分支的审查应用作业，则可以从合并请求页面访问审查应用的URL链接（见*图
    8.20*）。
- en: '![Figure 8.20 – View review app from a merge request](img/B18073_08_20.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.20 – 从合并请求查看审查应用](img/B18073_08_20.jpg)'
- en: Figure 8.20 – View review app from a merge request
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 从合并请求查看评审应用程序
- en: The link to the review environment can also be seen on the CI/CD job log (see
    *Figure 8**.21*).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 CI/CD 作业日志中看到指向评审环境的链接（见*图 8.21*）。
- en: '![Figure 8.21 – Review app CI/CD job log](img/B18073_08_21.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.21 – 评审应用程序 CI/CD 作业日志](img/B18073_08_21.jpg)'
- en: Figure 8.21 – Review app CI/CD job log
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21 – 评审应用程序 CI/CD 作业日志
- en: To summarize, review apps simply extend our understanding of environments to
    include dynamic creation and updates. They are best used to represent rapidly
    changing development environments and are easily accessible for developers and
    reviewers to preview the latest version of their applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，评审应用程序只是扩展了我们对环境的理解，涵盖了动态创建和更新。它们最适合用于表示快速变化的开发环境，且开发人员和评审人员可以轻松访问，用于预览应用程序的最新版本。
- en: Now that we have learned about previewing changes with review apps, let’s finally
    turn to how we might deploy into production.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何通过评审应用程序预览变更，最后让我们来讨论一下如何将应用程序部署到生产环境。
- en: Deploying to real-world production environments
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到实际的生产环境
- en: In the examples presented so far, we have shown that environments are simply
    organizational categories in GitLab with associated names and URLs. In the real
    world, however, environments represent actual infrastructure, be it your computer’s
    or someone else’s. That means recognizing the constraints on the available resources
    and the importance of proper security and access control.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们展示的例子表明，环境仅仅是 GitLab 中的组织类别，具有相关的名称和网址。然而，在现实世界中，环境代表的是实际的基础设施，无论是你自己的计算机还是其他人的计算机。这意味着要认识到可用资源的限制，以及适当的安全性和访问控制的重要性。
- en: In this day and age, it is increasingly common to use cloud service providers
    such as AWS, Microsoft Azure, and Google Cloud Platform for application hosting.
    These services not only outsource the need for infrastructure management but they
    also provide programmatic interfaces for managing your environments.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今时代，使用 AWS、Microsoft Azure 和 Google Cloud Platform 等云服务提供商来托管应用程序变得越来越普遍。这些服务不仅外包了基础设施管理的需求，还提供了用于管理环境的程序化接口。
- en: Moreover, suites of developer tools for managing these resources have accompanied
    the rise of cloud service providers, apart from the cloud vendor-provided tools.
    Software such as Terraform, Ansible, and Chef is available to declaratively manage
    cloud resources. That is, they let you store descriptions of infrastructure as
    text in a Git repository. Thus, similar workflows for infrastructure change management
    can be used as those for managing application development.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着云服务提供商的兴起，管理这些资源的开发工具套件也应运而生，除了云供应商提供的工具外，像 Terraform、Ansible 和 Chef 等软件可以声明式地管理云资源。也就是说，它们让你以文本形式将基础设施的描述存储在
    Git 仓库中。因此，管理基础设施变更的工作流可以与应用程序开发管理的工作流类似。
- en: 'There is more to cloud service utilization than we could possibly cover within
    this one chapter. However, it is worth pointing out how GitLab can assist with
    one of the most important aspects of application environment administration: secret
    management. We’ve already explained the concept of CI/CD variables and how they
    can be used in CI/CD configurations and exported to the environments where jobs
    run. For variables of a sensitive nature, such as deploy keys, GitLab provides
    a special place in group- or project-level settings so that their values are not
    exposed in the project’s repository.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 利用云服务的内容远超本章所能覆盖的范围。不过，值得指出的是 GitLab 如何在应用环境管理的一个重要方面提供帮助：秘密管理。我们已经解释了 CI/CD
    变量的概念，以及它们如何在 CI/CD 配置中使用并导出到作业运行的环境中。对于敏感性质的变量，例如部署密钥，GitLab 在组级或项目级设置中提供了一个特殊的地方，以确保这些值不会暴露在项目的代码库中。
- en: Say, for example, you wish to deploy to an environment hosted in AWS. You will
    be required to provide credentials to authenticate to AWS, generally in the form
    of an AWS access key and a secret key. However, you would not want to directly
    enter those values into your CI/CD deployment scripts, as that leaks your credentials
    into the code base and its version history.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 比如说，你希望部署到 AWS 托管的环境中。你需要提供凭据来验证 AWS，通常是 AWS 访问密钥和秘密密钥的形式。然而，你不希望将这些值直接输入到 CI/CD
    部署脚本中，因为这会将凭据泄露到代码库及其版本历史中。
- en: You can instead navigate to your project’s `.gitlab-ci.yml` file, just like
    any other variable, without having to hardcode their values into the configuration.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像处理其他变量一样，导航到项目的`.gitlab-ci.yml`文件，而无需将其值硬编码到配置中。
- en: '![Figure 8.22 – Project-level CI/CD variables](img/B18073_08_22.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图8.22 – 项目级CI/CD变量](img/B18073_08_22.jpg)'
- en: Figure 8.22 – Project-level CI/CD variables
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 项目级CI/CD变量
- en: Importantly, creating a variable in this way provides some additional gatekeeping
    on its use and exposure. Aside from setting the variable’s name and value, you
    can limit the environments in which it can be used. You can also choose to limit
    the variable to protected branches and tags (that is, branches and tags with restrictions
    on who can contribute to or modify them). And *Figure 8**.23* shows you can also
    mask the variable, meaning that job logs would only display asterisks or **[MASKED]**
    if there were an attempt to leak its value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，以这种方式创建变量为其使用和暴露提供了额外的门控保护。除了设置变量的名称和值外，你还可以限制其可用的环境。你还可以选择将变量限制在受保护的分支和标签中（即，对贡献或修改它们的人有限制的分支和标签）。而*图8.23*显示，你还可以将变量进行屏蔽，这意味着如果有尝试泄漏其值，作业日志中只会显示星号或**[MASKED]**。
- en: '![Figure 8.23 – Project-level CI/CD variable settings](img/B18073_08_23.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图8.23 – 项目级CI/CD变量设置](img/B18073_08_23.jpg)'
- en: Figure 8.23 – Project-level CI/CD variable settings
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 项目级CI/CD变量设置
- en: These explanations only scratch the surface of deployment considerations in
    real-world environments. However, in these security-conscious times, we found
    it best to focus on the key area of secret management to demonstrate how GitLab
    can make the deployment process seamless and secure. In the next and final section,
    we’ll learn about GitLab’s integration with Kubernetes for cloud-native deployments.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这些解释仅仅触及了实际环境中部署考虑的表面。然而，在如今这个高度关注安全的时代，我们发现最好专注于秘密管理这一关键领域，以展示GitLab如何使部署过程既顺畅又安全。在接下来的最后一部分，我们将学习GitLab与Kubernetes的集成，支持云原生部署。
- en: Deploying to a Kubernetes cluster
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到Kubernetes集群
- en: We previously discussed the ubiquity of cloud services as alternatives to self-hosted
    infrastructure. In a similar vein, container orchestration systems such as Kubernetes
    have become increasingly popular as alternatives to the manual management of bare-metal
    servers or container hosts.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论了云服务作为自托管基础设施的替代方案的普遍性。类似地，Kubernetes等容器编排系统也越来越受欢迎，成为手动管理裸金属服务器或容器主机的替代方案。
- en: Deploying to Kubernetes with GitLab CI/CD can be conceptually similar to the
    workflows we have covered thus far. You can set up a GitLab runner with a Kubernetes
    executor, which communicates to the clusters using the Kubernetes API. Alternatively,
    GitLab optionally offers an additional approach called the **GitOps workflow**,
    which is not wholly reliant on CI/CD pipelines. We will summarize each of them
    in turn.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitLab CI/CD部署到Kubernetes在概念上与我们迄今为止讨论的工作流相似。你可以设置一个带有Kubernetes执行器的GitLab
    runner，该执行器通过Kubernetes API与集群进行通信。或者，GitLab还提供了一个名为**GitOps工作流**的附加方法，它并不完全依赖于CI/CD流水线。我们将依次总结它们。
- en: The CI/CD workflow
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD工作流
- en: Using the concepts so far, you can use a normal CI/CD setup to deploy containerized
    applications to Kubernetes. This requires a runner registered with the Kubernetes
    executor. During runner registration, information such as cluster host and authentication
    information is provided. The CI/CD script will then include direct API calls in
    the cluster, specifying commands to build, test, or deploy your code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 利用迄今为止的概念，你可以使用正常的CI/CD设置将容器化应用程序部署到Kubernetes。这需要一个已注册Kubernetes执行器的runner。在runner注册过程中，会提供集群主机和认证信息等内容。然后，CI/CD脚本会包含集群中的直接API调用，指定构建、测试或部署代码的命令。
- en: Because this workflow involves runners sending imperative commands to a Kubernetes
    cluster, we call this a **push-based** workflow. It’s convenient in that there
    are no additional dependencies required to interact with Kubernetes. However,
    we can run into issues if the cluster or deployments have changed in any way outside
    the CI/CD workflow, causing potential problems if the cluster is in a state other
    than what the CI/CD jobs expect.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个工作流涉及runner向Kubernetes集群发送命令，因此我们称之为**基于推送的**工作流。它的方便之处在于无需额外的依赖即可与Kubernetes交互。然而，如果集群或部署在CI/CD工作流之外发生任何变化，可能会遇到问题，导致集群处于与CI/CD作业预期不同的状态，从而产生潜在的问题。
- en: For this reason, GitLab increasingly recommends a different approach to working
    with Kubernetes called a GitOps workflow.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，GitLab 越来越推荐一种与 Kubernetes 合作的不同方法，称为 GitOps 工作流。
- en: A GitOps workflow
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 GitOps 工作流
- en: GitLab provides an alternative method of Kubernetes integration that does not
    use CI/CD directly. Rather, it uses an agent installed on a Kubernetes cluster
    that communicates back to the GitLab instance. These steps can be performed by
    navigating to **Infrastructure** | **Kubernetes clusters** in your project and
    then selecting **Connect a cluster** to follow the provided instructions for creating
    and registering a new agent (see *Figure 8**.24*).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 提供了一种替代的 Kubernetes 集成方法，不直接使用 CI/CD。相反，它使用安装在 Kubernetes 集群上的代理与 GitLab
    实例进行通信。你可以通过导航到**基础设施** | **Kubernetes 集群**，然后选择**连接集群**，按照提供的说明创建并注册新的代理（见*图
    8.24*）。
- en: '![Figure 8.24 – Connecting a Kubernetes cluster to GitLab](img/B18073_08_24.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.24 – 将 Kubernetes 集群连接到 GitLab](img/B18073_08_24.jpg)'
- en: Figure 8.24 – Connecting a Kubernetes cluster to GitLab
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.24 – 将 Kubernetes 集群连接到 GitLab
- en: Once a connection is established, the agent will automatically detect changes
    when configuration and deployment files are updated in the repository and will
    change the cluster state accordingly. This is due to the bidirectional streaming
    between the cluster agent and GitLab server. Essentially, the agent initiates
    all communication to work around any networking restrictions that obstruct the
    Kubernetes cluster (see *Figure 8**.25*).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，代理会在配置和部署文件在代码库中更新时自动检测变化，并相应地更改集群状态。这是由于集群代理与 GitLab 服务器之间的双向流式传输。实际上，代理启动所有通信，以绕过任何妨碍
    Kubernetes 集群的网络限制（见*图 8.25*）。
- en: '![Figure 8.25 – GitLab agent for Kubernetes architecture](img/B18073_08_25.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.25 – GitLab 代理用于 Kubernetes 架构](img/B18073_08_25.jpg)'
- en: Figure 8.25 – GitLab agent for Kubernetes architecture
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.25 – GitLab 代理用于 Kubernetes 架构
- en: GitLab therefore refers to the GitOps workflow as a **pull-based approach**,
    one that is increasingly favored over traditional pushes by CI/CD pipelines.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，GitLab 将 GitOps 工作流称为**拉取式方法**，这种方法正越来越受到 CI/CD 流水线传统推送方法的青睐。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we described various ways of packaging and deploying our code.
    This included making use of GitLab’s package and container registries, CI/CD environments,
    and methods for interacting with cloud-native infrastructure.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们描述了打包和部署代码的各种方式，包括利用 GitLab 的包和容器注册表、CI/CD 环境以及与云原生基础设施交互的方法。
- en: Even if you may not use all of the discussed features or services in your day-to-day
    work, we hope this chapter provided a useful bridge to more practical, real-world
    use cases of GitLab’s features.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你可能在日常工作中不会使用所有讨论的功能或服务，我们希望本章为 GitLab 特性提供了一个有用的桥梁，帮助你理解更多实际、现实世界中的应用场景。
- en: The next chapter will build upon what we’ve learned already. It will also introduce
    advanced features for improving CI/CD speed and performance, increasing developer
    productivity, and optimizing your ability to quickly build and ship software.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在我们已学到的基础上进一步发展。它还将介绍提高 CI/CD 速度和性能的高级功能，提高开发者生产力，并优化快速构建和交付软件的能力。
- en: Part 3 Next Steps for Improving Your Applications with GitLab
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 部分 使用 GitLab 改进应用程序的下一步
- en: This part of the book leads you through advanced CI/CD pipeline topics. These
    include speeding up pipelines using directed acyclic graphs, integrating third-party
    tools into pipelines, using pipelines to spot performance problems in your code,
    and many other topics. You will also get a chance to review everything you’ve
    learned so far with an end-to-end example demonstrating how to use GitLab to take
    a realistic software project through the entire software development life cycle.
    Finally, you’ll learn how to fix common problems with GitLab pipelines and get
    a peek at where GitLab might be going in the future.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的这一部分将带你深入了解高级 CI/CD 流水线主题，包括使用有向无环图加速流水线、将第三方工具集成到流水线中、利用流水线发现代码中的性能问题以及其他许多话题。你还将有机会通过一个端到端的示例，回顾你迄今为止学到的所有内容，展示如何使用
    GitLab 将一个真实的软件项目带入整个软件开发生命周期。最后，你将学习如何解决 GitLab 流水线中常见的问题，并提前了解 GitLab 未来的发展方向。
- en: 'This section comprises the following chapters:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包括以下章节：
- en: '[*Chapter 9*](B18073_09.xhtml#_idTextAnchor227), *Enhancing the Speed and Maintainability
    of CI/CD Pipelines*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 9 章*](B18073_09.xhtml#_idTextAnchor227)，*提高 CI/CD 流水线的速度和可维护性*'
- en: '[*Chapter 10*](B18073_10.xhtml#_idTextAnchor250), *Extending the Reach of CI/CD
    Pipelines*'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B18073_10.xhtml#_idTextAnchor250)，*扩展CI/CD管道的应用范围*'
- en: '[*Chapter 11*](B18073_11.xhtml#_idTextAnchor268), *End-to-End Example*'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B18073_11.xhtml#_idTextAnchor268)，*端到端示例*'
- en: '[*Chapter 12*](B18073_12.xhtml#_idTextAnchor300), *Troubleshooting and the
    Road Ahead with GitLab*'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B18073_12.xhtml#_idTextAnchor300)，*GitLab的故障排除与未来发展*'
