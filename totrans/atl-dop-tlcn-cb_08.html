<html><head></head><body>
		<div id="_idContainer345">
			<h1 class="chapter-number" id="_idParaDest-148"><a id="_idTextAnchor149"/>8</h1>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Deploying with Bitbucket Pipelines</h1>
			<p>In the course of understanding Bitbucket Pipelines, we started with the concept of <strong class="bold">continuous integration</strong> – that is, we<a id="_idIndexMarker524"/> leveraged automation that would perform builds and scanning tests on a commit operation, under the direction of the <span class="No-Break"><strong class="source-inline">bitbucket-pipelines.yml</strong></span><span class="No-Break"> file.</span></p>
			<p>We are now at the deployment stage, where we must take the build we created previously in Bitbucket Pipelines and install it in one of our environments, from testing to staging, and finally, to production. If we extend Bitbucket Pipelines so that it deploys automatically, we must <a id="_idIndexMarker525"/>consider <span class="No-Break"><strong class="bold">continuous deployment</strong></span><span class="No-Break">.</span></p>
			<p>In this chapter, we’ll look at what additions are required in <strong class="source-inline">bitbucket-</strong><strong class="source-inline">pipelines</strong><strong class="source-inline">.yml</strong> to perform continuous deployment. To do so, we will cover the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li><span class="No-Break">Configuring deployments</span></li>
				<li>Pushing artifacts into the <span class="No-Break">Bitbucket repository</span></li>
				<li>Pushing artifacts into artifact <span class="No-Break">repository tools</span></li>
				<li>Deploying artifacts to <span class="No-Break">Bitbucket Downloads</span></li>
				<li>Deploying artifacts using <strong class="bold">Secure Copy </strong><span class="No-Break"><strong class="bold">Protocol</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SCP</strong></span><span class="No-Break">)</span></li>
				<li>Deploying artifacts into AWS <span class="No-Break">S3 buckets</span></li>
				<li>Deploying artifacts to <span class="No-Break">AWS Lambda</span></li>
				<li>Deploying artifacts to <span class="No-Break">Google Cloud</span></li>
				<li>Deploying artifacts to <span class="No-Break">Microsoft Azure</span></li>
				<li>Using Ansible in the <span class="No-Break">deployment stage</span></li>
				<li>Using Terraform in the <span class="No-Break">deployment stage</span></li>
			</ul>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor151"/>Technical requirements</h1>
			<p>Because we are still working with Bitbucket Pipelines, we require a subscription to Bitbucket Cloud. This will also be required for recipes where artifacts end up in the repository or <span class="No-Break">Bitbucket Downloads.</span></p>
			<p>Deploying artifacts to cloud-based environments such as AWS, Google Cloud, and Microsoft Azure requires accounts with privileges to the services being used as targets in this <span class="No-Break">chapter’s recipes.</span></p>
			<p>The sample code for this chapter can be found in the <strong class="source-inline">Chapter8</strong> folder of this book’s GitHub <span class="No-Break">repository </span><a href="https://github.com/PacktPublishing/Atlassian-DevOps-Toolchain-Cookbook/tree/main/Chapter8"><span class="No-Break">https://github.com/PacktPublishing/Atlassian-DevOps-Toolchain-Cookbook/tree/main/Chapter8</span></a></p>
			<p>Now, let’s explore how to ready our builds <span class="No-Break">for deployment.</span></p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor152"/>Configuring deployments</h1>
			<p>While <a id="_idIndexMarker526"/>Bitbucket Pipelines can deploy to many different platforms, the characteristics of a deployment are all the same. This can be advantageous when you’re deploying to a test environment, where you may want to define some runtime testing or package testing, versus the production environment, where the testing has been exhausted and it’s time to release new functionality to the <span class="No-Break">end user.</span></p>
			<p>With this in mind, let’s take a look at what the commonalities are for deployments and how to define them uniformly. After, we’ll learn how to configure deployments for different environments seen in a typical <span class="No-Break">DevSecOps process.</span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Getting ready</h2>
			<p>Before setting up our pipeline, we need to define the environments for deployment. You can use the default environments, which have the <span class="No-Break">following pre-definitions:</span></p>
			<ul>
				<li><span class="No-Break">Test</span></li>
				<li><span class="No-Break">Staging</span></li>
				<li><span class="No-Break">Production</span></li>
			</ul>
			<p>You can also change the names of the environments or configure environment-specific variables for deployment. To set the configurations for your environments, perform the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>In Bitbucket, go <a id="_idIndexMarker527"/>to the repository of interest and select <span class="No-Break"><strong class="bold">Repository settings</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer321">
					<img alt="Figure 8.1 – Selecting Repository Settings" src="image/B21937_08_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Selecting Repository Settings</p>
			<ol>
				<li value="2">In the <strong class="bold">Pipelines</strong> section, select the <span class="No-Break"><strong class="bold">Deployments</strong></span><span class="No-Break"> option.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer322">
					<img alt="Figure 8.2 – Selecting Deployments" src="image/B21937_08_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Selecting Deployments</p>
			<ol>
				<li value="3">The list of <a id="_idIndexMarker528"/>default environments will appear, divided into <strong class="bold">Test</strong>, <strong class="bold">Staging</strong>, and <strong class="bold">Production</strong>. </li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer323">
					<img alt="Figure 8.3 – ﻿Deployment environments" src="image/B21937_08_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Deployment environments</p>
			<ol>
				<li value="4">To change an existing environment, click on the band that represents the environment. It will expand, showing options you can use to change the name and a section<a id="_idIndexMarker529"/> for <span class="No-Break">environment-specific variables.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer324">
					<img alt="Figure 8.4 – ﻿Configuration options for an environment" src="image/B21937_08_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Configuration options for an environment</p>
			<p class="list-inset">To change the name, overwrite the name in the <strong class="bold">Environment name:</strong> field. To add a variable, fill in the <strong class="bold">Name</strong> and <strong class="bold">Value</strong> fields. If the variable is meant to contain a secret such as a password or key, make sure that the <strong class="bold">Secured</strong> checkbox is selected. Finish by clicking the <span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break"> button.</span></p>
			<ol>
				<li value="5">To add a new environment, go to the section that defines the environment type (<strong class="bold">Test</strong>, <strong class="bold">Staging</strong>, or <strong class="bold">Production</strong>) and select the <strong class="bold">add </strong><span class="No-Break"><strong class="bold">environment</strong></span><span class="No-Break"> button.</span></li>
				<li>Fill in the name of the new environment and select the <strong class="bold">Staging </strong><span class="No-Break"><strong class="bold">environments</strong></span><span class="No-Break"> checkbox.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer325">
					<img alt="Figure 8.5 – Adding an environment" src="image/B21937_08_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Adding an environment</p>
			<p>On the free <a id="_idIndexMarker530"/>plan of Bitbucket, you can define 10 environments. On the premium version of Bitbucket, this limit is increased to 100. The premium version of Bitbucket allows you to restrict which branches can deploy to that environment and whether admins alone can perform any deployment on <span class="No-Break">that environment.</span></p>
			<p>Now that we’ve configured our environments, it’s time to configure <span class="No-Break">the deployments.</span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>How to do it…</h2>
			<p>To<a id="_idIndexMarker531"/> define a deployment, we must introduce new keywords and sections to our <strong class="source-inline">bitbucket-pipelines.yml</strong> file. We’ll apply these keywords and sections to stages or steps in <span class="No-Break">our pipeline.</span></p>
			<p>Once we’ve done this, we can define separate deployments, depending on which branch is receiving merges from lower branches. This allows us to continually deploy and test until the final pull request to a main branch, where deployment may happen on the <span class="No-Break">production environment.</span></p>
			<p>Let’s look at performing <span class="No-Break">these deployments.</span></p>
			<h3>Configuring a deployment in bitbucket-pipelines.yml</h3>
			<p>The<a id="_idIndexMarker532"/> deployment instructions are<a id="_idIndexMarker533"/> identified in a stage or step within the <strong class="source-inline">bitbucket-pipelines.yml</strong> file with the <strong class="source-inline">deployment:</strong> keyword, along with the environment that is the target for the deployment step or steps. Let’s learn how to use the <span class="No-Break"><strong class="source-inline">deployment:</strong></span><span class="No-Break"> keyword:</span></p>
			<ol>
				<li>The <strong class="source-inline">deployment:</strong> keyword is used within a step to identify the environment that is being deployed. An example is shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">
pipelines:
  default:
    - step:
        name: Deploy to staging
        deployment: staging
        script:
          - python deploy.py staging_1</pre><p class="list-inset">You can define<a id="_idIndexMarker534"/> multiple steps for deployment, with each step noting the environment. However, Bitbucket requires that the environment types fall within the <span class="No-Break">following order:</span></p><ol><li class="upper-roman"><span class="No-Break">Test environment.</span></li><li class="upper-roman"><span class="No-Break">Staging environments</span></li><li class="upper-roman"><span class="No-Break">Production environments</span></li></ol></li>				<li>If <a id="_idIndexMarker535"/>several steps are required for a deployment, the <strong class="source-inline">deployment:</strong> keyword can be used within the definition of a stage to identify the target environment. An example of this is shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">
pipelines:
   default:
      - stage:
            name: Deploy to Production
            deployment: production
            steps:
                - step:
                   name: Basic deploy first step
                   script:
                         - sh ./deploy1.sh
                - step:
                    name: Basic deploy second step
                    script:
                       - sh ./deploy2.sh</pre></li>				<li>If you want<a id="_idIndexMarker536"/> your deployment <a id="_idIndexMarker537"/>step to be triggered manually, add the <strong class="source-inline">trigger: manual</strong> keyword within your deployment step. This can be seen in the following <span class="No-Break">code snippet:</span><pre class="source-code">
- step:
      name: Deploy to staging
      deployment: staging
      trigger: manual
      script:
         - python stage_deploy.py staging</pre></li>			</ol>
			<p>Once we’ve defined deployment steps or stages in our <strong class="source-inline">bitbucket-pipelines.yml</strong> file, we can monitor the progress and outcome of our deployments in Bitbucket. Let’s examine the process for <span class="No-Break">doing so.</span></p>
			<h3>Monitoring deployments</h3>
			<p>Once you’ve <a id="_idIndexMarker538"/>executed a deployment, you can track its progress or manually execute deployments in the deployment dashboard. Let’s examine the features of the <span class="No-Break">deployment dashboard:</span></p>
			<ol>
				<li>As we saw in the previous recipe, to reach the deployment dashboard, select <strong class="bold">Deployments</strong> from the sidebar at the <span class="No-Break">repository level.</span></li>
				<li>The deployment dashboard will appear to the right of the sidebar. It is divided into the environments defined in the <strong class="source-inline">bitbucket-pipelines.yml</strong> file. Within this environment, there will be a card that exhibits the last successful deployment to <span class="No-Break">that environment.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer326">
					<img alt="Figure 8.6 – Deployments dashboard" src="image/B21937_08_06.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Deployments dashboard</p>
			<ol>
				<li value="3">Click on <a id="_idIndexMarker539"/>the card in an environment to view the details of the <a id="_idIndexMarker540"/>deployment for that environment. The details will include the commit that caused the execution of <strong class="source-inline">bitbucket-pipelines.yml</strong>, a note on the differences between the existing version and the commit, and the push to the associated environment, including deployment history. If Jira and Bitbucket are connected, as we discussed in the <em class="italic">Connecting Bitbucket</em> recipe in <a href="B21937_01.xhtml#_idTextAnchor019"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, you will also see the Jira issue associated with the commit. The following screenshot shows a deployment to the <span class="No-Break"><strong class="bold">Test</strong></span><span class="No-Break"> environment.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer327">
					<img alt="Figure 8.7 – Deployment to the Test environment" src="image/B21937_08_07.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Deployment to the Test environment</p>
			<ol>
				<li value="4">If a deployment is defined to be manually triggered, you will see a <strong class="bold">Promote</strong> button on<a id="_idIndexMarker541"/> the last successful deployment to the lower environment. Click <strong class="bold">Promote</strong> to execute a deployment to the <span class="No-Break">higher environment.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer328">
					<img alt="Figure 8.8 – Promoting a manual deployment to production" src="image/B21937_08_08.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Promoting a manual deployment to production</p>
			<ol>
				<li value="5">You can redeploy the last successful deployment from the deployment dashboard if a deployment fails. The ability to redeploy requires the following conditions to <span class="No-Break">be met:</span><ul><li>An initial deployment step in the pipeline was <span class="No-Break">executed successfully</span></li><li>Deployment permissions are set to allow the redeployment of the step (please note that this is only available in the premium plan <span class="No-Break">of Bitbucket)</span></li><li>Artifacts that are used for deployment <span class="No-Break">can’t expire</span></li></ul></li>
				<li>Once a deployment to a specific environment is engaged, any subsequent deployments from other pipelines to that environment will be paused thanks to <strong class="bold">concurrency control</strong>, which<a id="_idIndexMarker542"/> limits pipeline executions to a single deployment in a given environment. When the original in-progress deployment is complete, you have the following options for <span class="No-Break">paused deployments:</span><ul><li>Rerun the pipeline from <span class="No-Break">the beginning</span></li><li>Resume the pipeline from when it <span class="No-Break">was paused</span></li></ul></li>
			</ol>
			<p>Now that we understand the mechanics of deployment, we can allow deployments to specific environments if a pull request to its associated branch succeeds. Let’s look at how <span class="No-Break">that’s done.</span></p>
			<h3>Deploying from a pull request or branch</h3>
			<p>As you<a id="_idIndexMarker543"/> may recall from the <em class="italic">Conditional execution of pipelines</em> recipe from <a href="B21937_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, you can set up your pipelines to execute different instructions based on which branch is receiving the new commit or if a pull request is being requested. Let’s learn how these different conditions can <span class="No-Break">be established:</span></p>
			<ol>
				<li>A branch pipeline specifies actions to be performed when a push occurs on a specific branch. You can use the <strong class="source-inline">branches:</strong> keyword to describe what actions occur on a branch pipeline. These actions are grouped under the branch name. The following code snippet details various actions, including deployment for other branches, when using the <strong class="source-inline">default:</strong> keyword and separate actions for the <span class="No-Break">staging branch:</span><pre class="source-code">
pipelines:
   default:
     - step:
         script:
           - echo "We do this on all branches except staging"
   branches:
     staging:
       - step:
           deployment: staging
           script:
             - echo "Done on the staging branch"
             - python deploy.py</pre></li>				<li>A pull request pipeline allows you to specify the actions when a pull request is created for a specific branch. These actions are defined on branches underneath the <strong class="source-inline">pull-requests:</strong> keyword. Let’s look at actions that are completed when a pull request occurs on the <span class="No-Break">staging branch:</span><pre class="source-code">
pipelines:
   pull-requests:
     staging/*:
        - step:
            deployment: staging
            script:
              - echo "Test and deploy pre-merge"
              - python deploy.py</pre></li>			</ol>
			<p>With <a id="_idIndexMarker544"/>that, we’ve learned how to easily test and deploy when changes occur on feature branches. Automated deployment to production is possible when a pull request from staging to the production branch <span class="No-Break">is created.</span></p>
			<p>Now that we’ve seen how to configure Bitbucket Pipelines for deployment, we will look at examples of how to perform specific deployments depending on the target. First, we’ll learn how to deploy into the Bitbucket git <span class="No-Break">repository itself.</span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor155"/>Pushing artifacts into the Bitbucket repository</h1>
			<p>Part of <a id="_idIndexMarker545"/>the deployment process may be to take build artifacts and place them in the correct repository. The most convenient repository <a id="_idIndexMarker546"/>to store build artifacts may be Bitbucket itself. This is often discouraged because build artifacts typically consume a large amount of storage and may cause performance issues with the underlying git tool. Nevertheless, we offer this recipe if no <span class="No-Break">alternatives exist.</span></p>
			<p>Let’s learn how to push build artifacts back into a Bitbucket repository as part <span class="No-Break">of deployment.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Getting ready</h2>
			<p>Although <a id="_idIndexMarker547"/>the recommended way to push back<a id="_idIndexMarker548"/> content to the git repository is using HTTP, there may be times when the only way to do this is by using SSH. To do that, you’ll need to set up your credentials. This is true if you have branch permissions enabled on your repository or want to set up an automated account for these actions. An important consideration is that configuring these accounts removes limits on what they <span class="No-Break">can access.</span></p>
			<p>Let’s learn how to create accounts with different <span class="No-Break">authentication methods.</span></p>
			<h3>Using OAuth for authentication</h3>
			<p>You<a id="_idIndexMarker549"/> can use OAuth as the authentication method for accessing the git repository. This involves creating an account and giving that account write access to the main or master branch through branch permissions. Let’s learn how to set up an account <span class="No-Break">with </span><span class="No-Break">OAuth</span><span class="No-Break">:</span></p>
			<ol>
				<li>On your <strong class="bold">Workspace</strong> page in Bitbucket, click on the <strong class="bold">Settings</strong> cog and select <span class="No-Break"><strong class="bold">Workspace settings</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer329">
					<img alt="Figure 8.9 – Selecting Workspace settings" src="image/B21937_08_09.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Selecting Workspace settings</p>
			<ol>
				<li value="2">In the sidebar for <strong class="bold">Workspace settings</strong>, find the <strong class="bold">APPS AND FEATURES</strong> section and select <span class="No-Break"><strong class="bold">OAuth consumers</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer330">
					<img alt="Figure 8.10 – Selecting OAuth consumers" src="image/B21937_08_10.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Selecting OAuth consumers</p>
			<ol>
				<li value="3">On<a id="_idIndexMarker550"/> the <strong class="bold">OAuth consumers</strong> page, click the <strong class="bold">Add </strong><span class="No-Break"><strong class="bold">consumer</strong></span><span class="No-Break"> button:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer331">
					<img alt="Figure 8.11 – Add consumer" src="image/B21937_08_11.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – Add consumer</p>
			<ol>
				<li value="4">On the subsequent page, fill in the <span class="No-Break">following details:</span><ul><li><span class="No-Break"><strong class="bold">Name</strong></span></li><li>Set <strong class="bold">Callback URL</strong> <span class="No-Break">to </span><a href="https://bitbucket.org&#13;"><span class="No-Break">https://bitbucket.org</span></a></li><li>Make sure <strong class="bold">This is a private consumer</strong> <span class="No-Break">is checked</span></li></ul></li>
				<li>For permissions, ensure that both <strong class="bold">Read</strong> and <strong class="bold">Write</strong> permissions are checked under <strong class="bold">Repositories</strong>. Click the <strong class="bold">Save</strong> button to save the <span class="No-Break">OAuth consumer:</span></li>
				<li>Return to the consumer page and find the new consumer you created. Record the key and secret as secure pipeline variables. Use <strong class="source-inline">CLIENT_ID</strong> for the key and <strong class="source-inline">CLIENT_SECRET</strong> for <span class="No-Break">the secret:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer332">
					<img alt="Figure 8.12 – OAuth consumer key and secret" src="image/B21937_08_12.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – OAuth consumer key and secret</p>
			<ol>
				<li value="7">Add<a id="_idIndexMarker551"/> the following code snippet to the <strong class="source-inline">script</strong> section of the <strong class="source-inline">bitbucket-pipelines.yml</strong> file before the git commands to make the changes and commit to the git repository. We assume that your runner has the <strong class="source-inline">curl</strong> and <strong class="source-inline">jq</strong> <span class="No-Break">utilities installed:</span><pre class="source-code">
- &gt;
  export access_token=$(curl -s -X POST -u "${CLIENT_ID}:${CLIENT_SECRET}" \
    https://bitbucket.org/site/oauth2/access_token \
    -d grant_type=client_credentials -d scopes="repository"| jq --raw-output '.access_token')
# Configure git to use the oauth token.
- git remote set-url origin https://x-token-auth:${access_token}@bitbucket.org/${BITBUCKET_REPO_OWNER}/${BITBUCKET_REPO_SLUG}</pre></li>			</ol>
			<p>With that, you’ve configured an OAuth consumer and allowed it to make git commits from <span class="No-Break">Bitbucket Pipelines.</span></p>
			<p>We can also set up SSH keys using the Bitbucket UI. Let’s examine how to <span class="No-Break">do that.</span></p>
			<h3>Creating an SSH key pair for Bitbucket Pipelines</h3>
			<p>For a <a id="_idIndexMarker552"/>given repository, you can create an <a id="_idIndexMarker553"/>SSH key pair and save the public key in Bitbucket so that it can be deployed back to the git repository using SSH. Let’s see how <span class="No-Break">that’s done:</span></p>
			<ol>
				<li>On the repository page, select <strong class="bold">Repository settings</strong> in <span class="No-Break">the sidebar:</span></li>
				<li>In the <strong class="bold">Pipelines</strong> section of the <strong class="bold">Repository settings</strong> sidebar, select <span class="No-Break"><strong class="bold">SSH Keys</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer333">
					<img alt="Figure 8.13 – Selecting SSH Keys" src="image/B21937_08_13.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Selecting SSH Keys</p>
			<ol>
				<li value="3">On the <strong class="bold">SSH Keys</strong> page, select <span class="No-Break"><strong class="bold">Generate keys</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer334">
					<img alt="Figure 8.14 – Generating keys" src="image/B21937_08_14.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – Generating keys</p>
			<ol>
				<li value="4">Copy<a id="_idIndexMarker554"/> the <a id="_idIndexMarker555"/>resulting <span class="No-Break">public key:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer335">
					<img alt="Figure 8.15 – Copying the public key" src="image/B21937_08_15.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Copying the public key</p>
			<ol>
				<li value="5">At this <a id="_idIndexMarker556"/>point, you will need to add the public key to your personal Bitbucket settings. To start, select the <strong class="bold">Settings</strong> cog and click <strong class="bold">Personal </strong><span class="No-Break"><strong class="bold">Bitbucket settings</strong></span><span class="No-Break">:</span></li>
				<li>In <a id="_idIndexMarker557"/>the <strong class="bold">SECURITY</strong> section of the <strong class="bold">Personal settings</strong> sidebar, select <span class="No-Break"><strong class="bold">SSH keys</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer336">
					<img alt="Figure 8.16 – Selecting SSH keys" src="image/B21937_08_16.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Selecting SSH keys</p>
			<ol>
				<li value="7">Select <strong class="bold">Add key</strong> on<a id="_idIndexMarker558"/> the <strong class="bold">SSH </strong><span class="No-Break"><strong class="bold">keys</strong></span><span class="No-Break"> page:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer337">
					<img alt="Figure 8.17 – Add key" src="image/B21937_08_17.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Add key</p>
			<ol>
				<li value="8">In <a id="_idIndexMarker559"/>the <strong class="bold">Add SSH key</strong> modal, paste the public key and select <span class="No-Break"><strong class="bold">Add key</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer338">
					<img alt="Figure 8.18 – Pasting and adding the public key" src="image/B21937_08_18.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – Pasting and adding the public key</p>
			<ol>
				<li value="9">The <a id="_idIndexMarker560"/>following line needs to be added to the <strong class="source-inline">script</strong> section of your <strong class="source-inline">bitbucket-pipelines.yml</strong> file before the git commands so that you can save and commit changes back to the git repository. This line configures git to use SSH. <strong class="source-inline">BITBUCKET_GIT_SSH_ORIGIN</strong> is a default <span class="No-Break">environment variable:</span><pre class="source-code">
<strong class="bold">git remote set-url origin ${BITBUCKET_GIT_SSH_ORIGIN}</strong></pre></li>			</ol>
			<p>With that, you’ve <a id="_idIndexMarker561"/>configured SSH keys to authenticate when you’re pushing a commit back to your <span class="No-Break">git repository.</span></p>
			<p>One final authentication method involves creating an application password and passing that as a secure variable. Let’s examine how to <span class="No-Break">do that.</span></p>
			<h3>Creating an application password</h3>
			<p>Application passwords are personal secrets that you can use securely in Bitbucket for automated <a id="_idIndexMarker562"/>functions. Let’s look at how<a id="_idIndexMarker563"/> to create an <span class="No-Break">application password:</span></p>
			<ol>
				<li>Select the <strong class="bold">Settings</strong> cog and select <strong class="bold">Personal </strong><span class="No-Break"><strong class="bold">Bitbucket settings</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="bold">Access Management</strong> section of the <strong class="bold">Personal settings</strong> sidebar, select <span class="No-Break"><strong class="bold">App passwords</strong></span><span class="No-Break">.</span></li>
				<li>On the <strong class="bold">App passwords</strong> page, select <strong class="bold">Create </strong><span class="No-Break"><strong class="bold">app password</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer339">
					<img alt="Figure 8.19 – Creating an app password" src="image/B21937_08_19.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.19 – Creating an app password</p>
			<ol>
				<li value="4">On the <strong class="bold">Add app password</strong> page, give the app password a name and make sure <strong class="bold">Read</strong> and <strong class="bold">Write</strong> permissions are selected for the <strong class="bold">Repositories</strong> section. Once you’ve done this, <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Create</strong></span><span class="No-Break">:</span></li>
				<li>The app password will appear on a modal. Copy the value and make sure it is in a <span class="No-Break">safe location:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer340">
					<img alt="Figure 8.20 – Generated app password" src="image/B21937_08_20.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.20 – Generated app password</p>
			<p class="list-inset">An example of a safe location is a secured variable. Set the app password as a <strong class="bold">secured repository variable</strong> or <strong class="bold">secured </strong><span class="No-Break"><strong class="bold">workplace variable</strong></span><span class="No-Break">:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer341">
					<img alt="Figure 8.21 – Adding the app password as a secured repository variable" src="image/B21937_08_21.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.21 – Adding the app password as a secured repository variable</p>
			<ol>
				<li value="6">The <a id="_idIndexMarker564"/>following line needs to<a id="_idIndexMarker565"/> be added to the <strong class="source-inline">script</strong> section of your <strong class="source-inline">bitbucket-pipelines.yml</strong> file before the git commands so that you can save and commit changes back to the git repository. This line configures the git remote URL to use the included username and app password <span class="No-Break">for authentication:</span><pre class="source-code">
<strong class="bold">git remote set-url origin https://&lt;your username&gt;:${APP_SECRET}@bitbucket.org/${BITBUCKET_REPO_OWNER}/${BITBUCKET_REPO_SLUG}</strong></pre></li>			</ol>
			<p>With that, we’ve learned how to use several authentication methods when committing changes back to a git repository. Now, let’s look at what needs to be added to do the <span class="No-Break">actual commits.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/>How to do it…</h2>
			<p>If you’re <a id="_idIndexMarker566"/>using <a id="_idIndexMarker567"/>the preconfigured HTTP git origin for pushing changes back to the git repository or have set up authentication using one of the preceding methods, the only thing you need to do is define the script steps for performing<a id="_idIndexMarker568"/> the actual git commits and pushes. Let’s see how <span class="No-Break">that’s done:</span></p>
			<ol>
				<li>To commit changes, add the <strong class="source-inline">git add</strong>, <strong class="source-inline">git commit</strong>, and <strong class="source-inline">git push</strong> commands to the <strong class="source-inline">script</strong> section of your <strong class="source-inline">bitbucket-pipelines.yml</strong> file. Note that regarding the git commit message, you can add <strong class="source-inline">[skip ci]</strong> to avoid an infinite loop of pipeline executions. An example is shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">
pipelines:
   default:
      - step:
          script:
             - git add &lt;changed files&gt;
             - git commit -m "[skip ci] Updates added via Bitbucket Pipelines deploy"
             - git push</pre></li>				<li>If you’re using tags, you can add the <strong class="source-inline">git tag</strong> command to create the new tag. The <a id="_idIndexMarker569"/>code snippet will resemble the following. In this example, the tag will include the build number since we’re referring to the <strong class="source-inline">BITBUCKET_BUILD_NUMBER</strong> <span class="No-Break">predefined variable:</span><pre class="source-code">
pipelines:
   default:
      - step:
          script:
             - git add &lt;changed files&gt;
             - git commit -m "[skip ci] Updates added via Bitbucket Pipelines deploy"
             - git tag -am "Tag for release ${BITBUCKET_BUILD_NUMBER}" release-${BITBUCKET_BUILD_NUMBER}
             - git push</pre></li>			</ol>
			<p>We have <a id="_idIndexMarker570"/>now seen how to use the git repository as a <a id="_idIndexMarker571"/>repository for build artifacts. Admittedly, this method is cumbersome when there are dedicated artifact repository tools available such as Artifactory from JFrog and Nexus from Sonatype. In the next recipe, we’ll learn how to deploy our build artifacts to those tools for storage and <span class="No-Break">tracking purposes.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor158"/>Pushing artifacts into artifact repository tools</h1>
			<p>Artifact repository tools <a id="_idIndexMarker572"/>such as Artifactory<a id="_idIndexMarker573"/> and Nexus allow for configuration management, a discipline where the build artifacts that emerge from a continuous integration pipeline are stored and tracked against the environments where they <span class="No-Break">are applied.</span></p>
			<p>Elementary builds that result in pushes to Artifactory or Nexus can rely on Bitbucket Pipes, which allows you to easily deploy from the <strong class="source-inline">bitbucket-pipelines.yml</strong> file. More complex deployments involving Maven or npm won’t be covered here but we will include references to create those types <span class="No-Break">of deployments.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor159"/>Getting ready</h2>
			<p>When using Pipes for either JFrog Artifactory or Sonatype Nexus, there are a few prerequisite steps that should be defined. We will examine which steps are needed <span class="No-Break">by tool.</span></p>
			<h3>JFrog CLI prerequisites</h3>
			<p>The JFrog Setup CLI <a id="_idIndexMarker574"/>pipe requires connections to the JFrog Platform servers. Let’s look at the steps that are involved in <span class="No-Break">this process:</span></p>
			<ol>
				<li>Ensure the runner is installed with the JFrog CLI. At the time of writing, this should be at version <strong class="source-inline">2.17.0</strong> or later. The following command is for macOS and Linux runners, assuming that <strong class="source-inline">curl</strong> <span class="No-Break">is installed:</span><pre class="source-code">
<strong class="bold">curl -fL "https://getcli.jfrog.io?setup" | sh</strong></pre></li>				<li>If you’re using Windows runners, use the following command. Note that this is <span class="No-Break">using PowerShell:</span><pre class="source-code">
<strong class="bold">powershell "Start-Process -Wait -Verb RunAs powershell '-NoProfile iwr https://releases.jfrog.io/artifactory/jfrog-cli/v2-jf/[RELEASE]/jfrog-cli-windows-amd64/jf.exe -OutFile $env:SYSTEMROOT\system32\jf.exe'" ; jf setup</strong></pre></li>				<li>Use the JFrog CLI to connect to your JFrog Platform servers. To set up the details of your JFrog Platform instances, run the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">jf c add</strong></pre><p class="list-inset">Executing this command prompts you to create a server ID and associate it with the URL for your JFrog platform. It is recommended that you set up a repository variable that maps to the environment variable that’s used by JFrog – that <span class="No-Break">is, </span><span class="No-Break"><strong class="source-inline">JFROG_CLI_SERVER_ID</strong></span><span class="No-Break">.</span></p></li>				<li>At this <a id="_idIndexMarker575"/>point, it may also be convenient to set up Bitbucket secure variables that mirror JFrog environment variables that have names starting with <strong class="source-inline">JF_ENV_</strong> as the key and the server token as the value. You can derive the server token using the following JFrog <span class="No-Break">CLI command:</span><pre class="source-code">
<strong class="bold">jf c export &lt;server ID from previous instruction&gt;</strong></pre></li>			</ol>
			<p>With that, we’ve covered the preliminary setup for the JFrog CLI. Now, let’s examine what’s needed <span class="No-Break">for Nexus.</span></p>
			<h3>Sonatype Nexus prerequisites</h3>
			<p>The pipe for <a id="_idIndexMarker576"/>Sonatype Nexus Publisher requires a few environment variables to be defined. Some variables are mandatory. The variables to be defined <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">FILENAME</strong> (mandatory): This is the path to the file <span class="No-Break">to publish.</span></li>
				<li><strong class="source-inline">ATTRIBUTES</strong> (mandatory): Attributes needed by Nexus Publisher. Component attributes are denoted with <strong class="source-inline">-C</strong>. Asset attributes are denoted <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">-A</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">USERNAME</strong> (mandatory): <span class="No-Break">Nexus username.</span></li>
				<li><strong class="source-inline">PASSWORD</strong> (mandatory): <span class="No-Break">Nexus password.</span></li>
				<li><strong class="source-inline">SERVER_URL</strong> (Mandatory): Nexus <span class="No-Break">server URL.</span></li>
				<li><strong class="source-inline">REPOSITORY</strong>: Repository name in Nexus. The default <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">maven-releases</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">FORMAT</strong>: Artifact format. The default <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">maven2</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Now that our prerequisites are out of the way, let’s look at pushing our artifacts <span class="No-Break">using pipes.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor160"/>How to do it…</h2>
			<p>In the <em class="italic">Connecting to Bitbucket Pipes</em> recipe in <a href="B21937_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, we learned about pipes. Pipes serve as integration points for third-party tools in a <span class="No-Break">Bitbucket pipeline.</span></p>
			<p>At this point, we are ready to connect to either JFrog or Sonatype Nexus through pipes and set up deployment steps. Let’s examine how to do that for <span class="No-Break">each tool.</span></p>
			<h3>Using the JFrog Setup CLI pipe</h3>
			<p>You can <a id="_idIndexMarker577"/>use the JFrog Setup CLI pipe to connect to any JFrog tool on the JFrog Platform, including Artifactory and XRay. Let’s look at the <span class="No-Break">steps involved:</span></p>
			<ol>
				<li>Add the following lines to the <strong class="source-inline">script</strong> section of your <span class="No-Break"><strong class="source-inline">bitbucket-pipelines.yml</strong></span><span class="No-Break"> file:</span><pre class="source-code">
script:
   - pipe: jfrog/jfrog-setup-cli:2.0.0
   - source ./jfrog-setup-cli.sh</pre></li>				<li>Once<a id="_idIndexMarker578"/> the setup lines have been added, you can use any JFrog CLI commands to make changes. The following code snippet is an example of a build that runs several commands to Artifactory using JFrog <span class="No-Break">CLI commands:</span><pre class="source-code">
script:
   - pipe: jfrog/jfrog-setup-cli:2.0.0
   - source ./jfrog-setup-cli.sh
   # Upload artifacts to Artifactory
   - jf rt u file artifacts/
   # Collect environment variables
   - jf rt bce
   # Publish build info
   - jf rt bp</pre></li>			</ol>
			<p>With that, we’ve learned how to connect and communicate with JFrog tools using pipes and JFrog CLI commands. Now, let’s look at the process for Sonatype <span class="No-Break">Nexus Manager.</span></p>
			<h3>Using the Sonatype Nexus Publisher pipe</h3>
			<p>Let’s learn<a id="_idIndexMarker579"/> how to use a pipe to connect to Sonatype <span class="No-Break">Nexus Publisher:</span></p>
			<ol>
				<li>Add the following code snippet to the <strong class="source-inline">script</strong> section of your <strong class="source-inline">bitbucket-pipelines.yml</strong> file. You can fill out the variables in-line or use <span class="No-Break">Bitbucket variables:</span><pre class="source-code">
- pipe: sonatype/nexus-repository-publish:0.0.1
  variables:
    FILENAME: '&lt;string&gt;'
    ATTRIBUTES: '&lt;string&gt;'
    USERNAME: '&lt;string&gt;'
    PASSWORD: '&lt;string&gt;'
    SERVER_URL: '&lt;string&gt;'
    # REPOSITORY: '&lt;string&gt;' # Optional.
    # FORMAT: '&lt;string&gt;' # Optional.</pre></li>				<li>Here’s <a id="_idIndexMarker580"/><span class="No-Break">an example:</span><pre class="source-code">
    - step:
        # set NEXUS_USERNAME and NEXUS_PASSWORD as environment variables
        name: Deploy to Nexus Repository Manager
        deployment: test   # set to test, staging or production
        # trigger: manual  # uncomment to have a manual step
        script:
          - pipe: sonatype/nexus-repository-publish:0.0.1
            variables:
              FILENAME: 'target/myapp-1.0-SNAPSHOT.jar'
              ATTRIBUTES: '-CgroupId=com.example -CartifactId=myapp -Cversion=1.0 -Aextension=jar'
              USERNAME: '$NEXUS_USERNAME'
              PASSWORD: '$NEXUS_PASSWORD'
              SERVER_URL: 'https://nexus.example.com/'</pre></li>			</ol>
			<p>At this point, we’ve seen how easy it is to use pipes for easy deployment. Other examples <a id="_idIndexMarker581"/>in subsequent recipes in this chapter will also show the ease <span class="No-Break">of pipes.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor161"/>See also</h2>
			<p>The following are links to other reference materials if you need to learn more about how to <a id="_idIndexMarker582"/>connect to JFrog or <span class="No-Break">Sonatype Nexus:</span></p>
			<ul>
				<li>JFrog CLI <span class="No-Break">documentation: </span><a href="https://docs.jfrog-applications.jfrog.io/jfrog-applications/jfrog-cli"><span class="No-Break">https://docs.jfrog-applications.jfrog.io/jfrog-applications/jfrog-cli</span></a></li>
				<li>An example of using Bitbucket Pipelines <a id="_idIndexMarker583"/>for a Maven deployment <a id="_idIndexMarker584"/>using <strong class="bold">GNU Privacy Guard</strong> (<strong class="bold">GPG</strong>) and <strong class="bold">Open Source Software Repository Hosting</strong> (<span class="No-Break"><strong class="bold">OSSRH</strong></span><span class="No-Break">): </span><a href="https://bitbucket.org/simpligility/ossrh-pipeline-demo/src/master/"><span class="No-Break">https://bitbucket.org/simpligility/ossrh-pipeline-demo/src/master/</span></a></li>
			</ul>
			<p>Next, we’ll look at several examples of taking build artifacts and installing them on target environments. We’ll begin by looking at various upload processes that can <span class="No-Break">be used.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor162"/>Deploying artifacts to Bitbucket Downloads</h1>
			<p>You can<a id="_idIndexMarker585"/> use Bitbucket itself as a staging area for build artifacts by configuring the Bitbucket Downloads pipe. This allows you to <a id="_idIndexMarker586"/>push build artifacts to Bitbucket Downloads. We’ll examine this process in more detail in <span class="No-Break">this recipe.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor163"/>Getting ready</h2>
			<p>Use of the <strong class="source-inline">bitbucket-upload-file</strong> pipe requires authentication either by username and app password or by access token. We looked at creating app passwords in the <em class="italic">Getting ready</em> section of the <em class="italic">Pushing artifacts into the Bitbucket </em><span class="No-Break"><em class="italic">repository</em></span><span class="No-Break"> recipe.</span></p>
			<p>Access tokens are available at the repository level for all plans of Bitbucket, and they’re available at the project and workspace levels for the Premium plan of Bitbucket. The tokens are only scoped to the repository, project, or workspace for which they were created. These are for single-use functions and are revoked if replacement is needed. Let’s learn how <a id="_idIndexMarker587"/>to create a repository <span class="No-Break">access token:</span></p>
			<ol>
				<li>At the repository level, select <strong class="bold">Repository settings</strong> in <span class="No-Break">the sidebar.</span></li>
				<li>In the <strong class="bold">Repository settings</strong> sidebar, select <strong class="bold">Access tokens</strong> in the <span class="No-Break"><strong class="bold">SECURITY</strong></span><span class="No-Break"> section:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer342">
					<img alt="Figure 8.22 – ﻿Selecting Access tokens" src="image/B21937_08_22.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.22 – Selecting Access tokens</p>
			<ol>
				<li value="3">On the <strong class="bold">Access tokens</strong> page, select <strong class="bold">Create Repository </strong><span class="No-Break"><strong class="bold">Access Token</strong></span><span class="No-Break">:</span></li>
				<li>In <a id="_idIndexMarker588"/>the modal, give the token a name and specify permissions. Bitbucket Pipelines requires <strong class="bold">Read</strong> and <strong class="bold">Write</strong> permissions on <strong class="bold">Repositories</strong>. Click <strong class="bold">Create</strong> when <span class="No-Break">you’re finished:</span></li>
				<li>The next modal will contain the value of the token and useful applications for it. Save the token value by copying it and pasting it in a safe location. This will be the only opportunity you will have to view the <span class="No-Break">token value.</span></li>
				<li>You can place your access token as a secure repository variable. Select <strong class="bold">Repository variables</strong> in the <strong class="bold">Repository settings</strong> sidebar, fill in the key name for the token, and paste the previously copied token value into the <strong class="bold">Value</strong> section. Once you’ve done this, check the <strong class="bold">Secured</strong> checkbox and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Add</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer343">
					<img alt="Figure 8.23 – ﻿Repository variables" src="image/B21937_08_23.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.23 – Repository variables</p>
			<p>Now that <a id="_idIndexMarker589"/>we have established our authentication means, either by username/app password or access token, let’s set up our pipe to <a id="_idIndexMarker590"/><span class="No-Break">Bitbucket Downloads.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor164"/>How to do it…</h2>
			<p>The <strong class="source-inline">bitbucket-upload-file</strong> pipe<a id="_idIndexMarker591"/> is the primary means of deploying files into the Bitbucket Downloads area. Let’s learn how to set up <span class="No-Break">that pipe:</span></p>
			<ol>
				<li>If you want to authenticate using a username and app password, use the following <span class="No-Break">code snippet:</span><pre class="source-code">
script:
  - pipe: atlassian/bitbucket-upload-file:0.7.1
    variables:
      BITBUCKET_USERNAME: $BITBUCKET_USERNAME
      BITBUCKET_APP_PASSWORD: $BITBUCKET_APP_PASSWORD
      FILENAME: 'package.json'</pre></li>				<li>To use the access token instead, replace <strong class="source-inline">BITBUCKET_USERNAME</strong> and <strong class="source-inline">BITBUCKET_APP_PASSWORD</strong> with <strong class="source-inline">BITBUCKET_ACCESS_TOKEN</strong>. This is illustrated in the following <span class="No-Break">code snippet:</span><pre class="source-code">
script:
  - pipe: atlassian/bitbucket-upload-file:0.7.1
    variables:
      BITBUCKET_ACCESS_TOKEN: $BITBUCKET_ACCESS_TOKEN
      FILENAME: 'package.json'</pre></li>				<li>The <strong class="source-inline">FILENAME</strong> pipe <a id="_idIndexMarker592"/>variable can specify multiple files by invoking wildcards. Note that<a id="_idIndexMarker593"/> the limit is 10 files. The following code shows an example of uploading all <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">txt</strong></span><span class="No-Break"> files:</span><pre class="source-code">
script:
  - pipe: atlassian/bitbucket-upload-file:0.7.1
    variables:
      BITBUCKET_USERNAME: $BITBUCKET_USERNAME
      BITBUCKET_APP_PASSWORD: $BITBUCKET_APP_PASSWORD
      FILENAME: '*.txt'</pre></li>				<li>Other optional pipe variables allow you to specify another account and repository where the file will be uploaded. <strong class="source-inline">ACCOUNT</strong> and <strong class="source-inline">REPOSITORY</strong> are illustrated in the following <span class="No-Break">code snippet:</span><pre class="source-code">
script:
  - pipe: atlassian/bitbucket-upload-file:0.7.1
    variables:
      BITBUCKET_USERNAME: $BITBUCKET_USERNAME
      BITBUCKET_APP_PASSWORD: $BITBUCKET_APP_PASSWORD
      FILENAME: 'package.json'
      ACCOUNT: $PROJECT_ACCOUNT
      REPOSITORY: $ALTERNATE_REPO</pre></li>			</ol>
			<p>With that, we’ve learned how to push files to the Bitbucket Downloads area for retrieval. Now, let’s learn how to send build artifacts to <span class="No-Break">target servers.</span></p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Deploying artifacts using SCP</h1>
			<p><strong class="bold">SCP</strong> is a means <a id="_idIndexMarker594"/>of transferring files <a id="_idIndexMarker595"/>between two host computers. This protocol uses SSH as a foundation to securely move files from one computer <span class="No-Break">to another.</span></p>
			<p>Let’s learn<a id="_idIndexMarker596"/> how to transfer a build artifact from Bitbucket Cloud to the remote host <span class="No-Break">using SCP.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor166"/>Getting ready</h2>
			<p>Because the foundation of SCP is SSH, we need to prepare an SSH key and other configurations related to SSH on both Bitbucket and the remote host. Let’s take a look at the <span class="No-Break">necessary steps:</span></p>
			<ol>
				<li>We defined a repository SSH key in the <em class="italic">Getting ready</em> section of the <em class="italic">Pushing artifacts into the Bitbucket repository</em> recipe. We can use this key for transfer to the remote host by copying the public key and placing it in the <strong class="source-inline">~/.ssh/authorized_keys</strong> file. If you have SSH access to the remote host, run the following command from the machine where you generated the key pair. This mandates that the user performing the operation will <span class="No-Break">be you:</span><pre class="source-code">
<strong class="bold">ssh-copy-id -i &lt;public key file to copy&gt; user@host</strong></pre></li>				<li>We also need to update the known hosts on Bitbucket. For the repository, this is located on the same screen we used to create the SSH key. From <strong class="bold">Repository Settings</strong>, select <strong class="bold">SSH Keys</strong>. On the <strong class="bold">SSH Keys</strong> screen, type in the IP address for the remote host and <span class="No-Break">click </span><span class="No-Break"><strong class="bold">Fetch</strong></span><span class="No-Break">.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer344">
					<img alt="Figure 8.24 – ﻿Adding a known remote host" src="image/B21937_08_24.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.24 – Adding a known remote host</p>
			<ol>
				<li value="3">Configure <a id="_idIndexMarker597"/>your remote <a id="_idIndexMarker598"/>host so that it allows SCP/SSH access on your desired port (<strong class="source-inline">22</strong> is the default) and allows access using SSH keys. This step is left for you as an exercise because of the variety of systems and configurations that <span class="No-Break">are available.</span></li>
			</ol>
			<p>Once we have the necessary configurations, it’s time to configure the <span class="No-Break"><strong class="source-inline">bitbucket-pipelines.yml</strong></span><span class="No-Break"> file.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor167"/>How to do it...</h2>
			<p>Now that we’ve configured the SSH keys both on Bitbucket Cloud and the remote host, we can set up Bitbucket Pipelines to make the file transfer process <span class="No-Break">a deployment:</span></p>
			<ol>
				<li>Add the following code snippet to the <strong class="source-inline">script</strong> section of your <strong class="source-inline">bitbucket-pipelines.yml</strong> file. The necessary pipe variables include the user’s name for the remote host, the remote host name, the path on the remote host to deploy files to, and the local path where the build artifacts <span class="No-Break">are located:</span><pre class="source-code">
- pipe: atlassian/scp-deploy:1.5.0
  variables:
    USER: '&lt;string&gt;'
    SERVER: '&lt;string&gt;'
    REMOTE_PATH: '&lt;string&gt;'
    LOCAL_PATH: '&lt;string&gt;'
    # SSH_KEY: '&lt;string&gt;' # Optional.
    # EXTRA_ARGS: '&lt;string&gt;' # Optional.
    # DEBUG: '&lt;boolean&gt;' # Optional.</pre></li>				<li>You <a id="_idIndexMarker599"/>can also add options <a id="_idIndexMarker600"/>using the <strong class="source-inline">EXTRA_ARGS</strong> pipe variable. An example is shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">
script:
  - pipe: atlassian/scp-deploy:1.5.0
    variables:
      USER: 'ec2-user'
      SERVER: '127.0.0.1'
      REMOTE_PATH: '/var/www/build/'
      LOCAL_PATH: 'build/'
      DEBUG: 'false'
      EXTRA_ARGS: ["-P", "8022"]</pre></li>				<li>The <strong class="source-inline">SSH_KEY</strong> pipe variable allows you to define an alternate SSH key. This should be a base64-encoded private key, saved as a secured Bitbucket variable. The following code snippet shows the use of an alternate <span class="No-Break">SSH key:</span><pre class="source-code">
script:
  - pipe: atlassian/scp-deploy:1.5.0
    variables:
      USER: 'ec2-user'
      SERVER: '127.0.0.1'
      REMOTE_PATH: '/var/www/build/'
      LOCAL_PATH: 'build'
      SSH_KEY: $MY_SSH_KEY
      DEBUG: 'true'
      EXTRA_ARGS: ['-o', 'ServerAliveInterval=10']</pre></li>			</ol>
			<p>With <a id="_idIndexMarker601"/>that, we’ve deployed to target <a id="_idIndexMarker602"/>environments using Bitbucket Pipelines. So far, the target environments are physical servers or virtual machines. Next, we’ll learn how to deploy to public <span class="No-Break">cloud environments.</span></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor168"/>Deploying artifacts into AWS S3 buckets</h1>
			<p>In this<a id="_idIndexMarker603"/> recipe, we’re going to look at deploying to AWS. Bitbucket Pipelines has a variety of pipes that can deploy to specific AWS component services, depending on the type of <span class="No-Break">build artifact.</span></p>
			<p>Let’s look at<a id="_idIndexMarker604"/> what’s involved in deploying our build artifact into an AWS S3 bucket. This is a typical use case of deployment using <span class="No-Break">Bitbucket Pipelines.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor169"/>Getting ready</h2>
			<p>When setting up the pipe to deploy to an AWS S3 bucket, the only thing you need to do is set up the <span class="No-Break">following variables:</span></p>
			<ul>
				<li><strong class="source-inline">AWS_ACCESS_KEY_ID</strong>: Your AWS <span class="No-Break">access key.</span></li>
				<li><strong class="source-inline">AWS_SECRET_ACCESS_KEY</strong>: Your AWS secret access key. This should be saved as a <span class="No-Break">secured variable.</span></li>
				<li><strong class="source-inline">AWS_DEFAULT_REGION</strong>: The default AWS region of <span class="No-Break">your resource.</span></li>
			</ul>
			<p>Now that these have been defined, let’s look at setting up <span class="No-Break">the pipe.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/>How to do it…</h2>
			<p>At this point, we need to add our pipe configuration to the <strong class="source-inline">script</strong> section of our <strong class="source-inline">bitbucket-pipelines.yml</strong> file. Let’s take a <span class="No-Break">closer look:</span></p>
			<ol>
				<li>Add <a id="_idIndexMarker605"/>the following code snippet to the <strong class="source-inline">script</strong> section of the <strong class="source-inline">bitbucket-pipelines.yml</strong> file. This will contain the variables that you set in the <em class="italic">Getting ready</em> section incorporated into the <strong class="source-inline">script</strong> section. Here, <strong class="source-inline">S3_BUCKET</strong> defines the destination bucket and <strong class="source-inline">LOCAL_PATH</strong> defines the location of the <span class="No-Break">build artifact:</span><pre class="source-code">
script:
  - pipe: atlassian/aws-s3-deploy:1.6.0
    variables:
      AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
      AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
      AWS_DEFAULT_REGION: 'us-east-1'
      S3_BUCKET: 'my-bucket-name'
      LOCAL_PATH: 'build'</pre></li>				<li>You <a id="_idIndexMarker606"/>can also define a folder inside the bucket by appending the path to the bucket defined in <strong class="source-inline">S3_BUCKET</strong>. This is illustrated in the following <span class="No-Break">code snippet:</span><pre class="source-code">
script:
  - pipe: atlassian/aws-s3-deploy:1.6.0
    variables:
      AWS_ACCESS_KEY_ID: $AWS_ACCESS_KEY_ID
      AWS_SECRET_ACCESS_KEY: $AWS_SECRET_ACCESS_KEY
      AWS_DEFAULT_REGION: 'us-east-1'
      S3_BUCKET: 'my-bucket-name/logs'
      LOCAL_PATH: '$(pwd)'</pre></li>			</ol>
			<p>With that, you’ve seen how easy it is to connect Bitbucket Pipelines so that you can deploy build artifacts to AWS. Let’s examine doing the same thing for <span class="No-Break">Google Cloud.</span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor171"/>Deploying artifacts to Google Cloud</h1>
			<p>Bitbucket Pipelines can make deployments to Google services through the use of pipes that integrate <a id="_idIndexMarker607"/>with these services. The following is the <a id="_idIndexMarker608"/>current list of pipes that connect with <span class="No-Break">Google services:</span></p>
			<ul>
				<li><span class="No-Break">Firebase deploy</span></li>
				<li>Google App <span class="No-Break">Engine Deploy</span></li>
				<li>Google Cloud <span class="No-Break">Storage Deploy</span></li>
				<li><strong class="bold">Google Artifactory Registration</strong> (<strong class="bold">GAR</strong>) <span class="No-Break">push image</span></li>
				<li>Google Kubernetes Engine <span class="No-Break">kubectl run</span></li>
			</ul>
			<p>Let’s take a <a id="_idIndexMarker609"/>closer look at deploying build artifacts using the Google Cloud Storage <span class="No-Break">Deploy pipe.</span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/>How to do it…</h2>
			<p>We can deploy our artifacts to Google Cloud Storage by performing the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>In the <strong class="source-inline">script</strong> portion of the <strong class="source-inline">step</strong> area where you intend to deploy to Google Cloud Storage, copy and paste the <strong class="source-inline">pipe</strong> definition. The definition of the Google Cloud Storage Deploy pipe is shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">
- pipe: atlassian/google-cloud-storage-deploy:2.0.0
  variables:
    KEY_FILE: '&lt;string&gt;'
    BUCKET: '&lt;string&gt;'
    SOURCE: '&lt;string&gt;'
    # GOOGLE_OIDC_CONFIG_FILE: "&lt;string&gt;" # Optional by default. Required for OpenID Connect (OIDC) authentication.
    # PROJECT: "&lt;string&gt;" # Optional by default. Required with GOOGLE_OIDC_CONFIG_FILE.
    # CACHE_CONTROL: '&lt;string&gt;' # Optional. options include no-cache,no-store,max-age=&lt;seconds&gt;, s-maxage=&lt;seconds&gt;, no-transform, public, private
    # CONTENT_DISPOSITION: '&lt;string&gt;' # Optional.
    # CONTENT_ENCODING: '&lt;string&gt;' # Optional.
    # CONTENT_LANGUAGE: '&lt;string&gt;' # Optional.
    # CONTENT_TYPE: '&lt;string&gt;' # Optional.
    # ACL: '&lt;string&gt;' # Optional.  Options include project-private, private, public-read, public-read-write, authenticated-read, bucket-owner-read, bucket-owner-full control
    # STORAGE_CLASS: '&lt;string&gt;' # Optional.  Options include multi-regional, regional, nearline, coldline
    # DEBUG: '&lt;boolean&gt;' # Optional.</pre></li>				<li>Add <a id="_idIndexMarker610"/>the pipe to the <strong class="source-inline">script</strong> section of your <strong class="source-inline">bitbucket-pipelines.yml</strong> file. An example with only the mandatory <a id="_idIndexMarker611"/>pipe variables provided is shown in the following <span class="No-Break">code snippet:</span><pre class="source-code">
script:
  - pipe: atlassian/google-cloud-storage-deploy:2.0.0
    variables:
      KEY_FILE: $KEY_FILE
      BUCKET: 'my-bucket'
      SOURCE: 'myApp.jar'</pre></li>				<li>If needed, continue defining the deployment operation by adding other variables. The following code snippet shows a pipe with more variables <span class="No-Break">filled out:</span><pre class="source-code">
script:
  - pipe: atlassian/google-cloud-storage-deploy:2.0.0
    variables:
      KEY_FILE: $KEY_FILE
      BUCKET: 'my-bucket'
      SOURCE: 'myAppFile.jar'
      CACHE_CONTROL: 'max-age=60'
      CONTENT_DISPOSITION: 'attachment'
      ACL: 'public-read'
      STORAGE_CLASS: 'nearline'</pre></li>			</ol>
			<p>We have<a id="_idIndexMarker612"/> just seen an example of integrating a deployment to <a id="_idIndexMarker613"/>Google Cloud resources using pipes. Now, let’s look at an example of integration with <span class="No-Break">Microsoft Azure.</span></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor173"/>Deploying artifacts to Microsoft Azure</h1>
			<p>Bitbucket Pipelines <a id="_idIndexMarker614"/>can perform deployments to Azure services through the use of pipes that integrate with these services. The <a id="_idIndexMarker615"/>following is the current list of pipes that connect with <span class="No-Break">Microsoft Azure:</span></p>
			<ul>
				<li><span class="No-Break">Azure CLI</span></li>
				<li>Azure Container <span class="No-Break">Apps Deploy</span></li>
				<li>Azure ACR <span class="No-Break">push image</span></li>
				<li>Azure <span class="No-Break">Functions Deploy</span></li>
				<li>Azure Kubernetes <span class="No-Break">Service Deploy</span></li>
				<li>Azure Kubernetes Service <span class="No-Break">Helm Deploy</span></li>
				<li>Azure <span class="No-Break">Storage Deploy</span></li>
				<li>Azure Web Apps <span class="No-Break">Containers Deploy</span></li>
				<li>Azure Web <span class="No-Break">Apps Deploy</span></li>
			</ul>
			<p>Let’s see what’s <a id="_idIndexMarker616"/>needed to use the Azure Functions Deploy pipe as an example of deployment to <span class="No-Break">Microsoft Azure.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor174"/>Getting ready</h2>
			<p>Before we can <a id="_idIndexMarker617"/>use the Azure Functions Deploy pipe to deploy to Microsoft Azure, we need to establish our Azure credentials. Follow these steps to <span class="No-Break">do so:</span></p>
			<ol>
				<li>After installing the Azure CLI on your local machine or using the Azure Cloud Shell, create an Azure secure principal by typing the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">az ad sp create-for-rbac --name &lt;name of your service principal&gt;</strong></pre></li>				<li>The preceding command will return the following output in <span class="No-Break">JSON format:</span><pre class="source-code">
{
  "appId": "myAppId",
  "displayName": "myServicePrincipalName",
  "password": "myServicePrincipalPassword",
  "tenant": "myTentantId"
}</pre></li>				<li>Save the output as repository variables. For instance, you can define the following output as variables in <span class="No-Break">this way:</span><ul><li><span class="No-Break"><strong class="source-inline">appId</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">AZURE_ID</strong></span></li><li><strong class="source-inline">password</strong>: <span class="No-Break"><strong class="source-inline">AZURE_PASSWORD</strong></span><span class="No-Break"> (secured)</span></li><li><span class="No-Break"><strong class="source-inline">tenant</strong></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">AZURE_TENANT</strong></span></li></ul></li>
			</ol>
			<p>Now that we have our secure principal, we can connect to Azure using Bitbucket Pipelines. Let’s learn how to <span class="No-Break">do that.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/>How to do it…</h2>
			<p>Azure Functions Deploy <a id="_idIndexMarker618"/>takes serverless logic <a id="_idIndexMarker619"/>implementations written on your favorite Microsoft development tools, such as Visual Studio, and <a id="_idIndexMarker620"/>packages them to be executed on-demand in Azure. Part of the development process can include deployment through Bitbucket Pipelines. Let’s learn how to deploy functions from the <span class="No-Break"><strong class="source-inline">bitbucket-pipelines.yml</strong></span><span class="No-Break"> file:</span></p>
			<ol>
				<li>Add the following code snippet to the <strong class="source-inline">script</strong> section of <strong class="source-inline">bitbucket-pipelines.yml</strong>. The required parameters include the attributes for the secure principal, the function name, as found in Azure, and the name of the ZIP file that contains the function to be deployed <span class="No-Break">on Azure:</span><pre class="source-code">
script:
  - pipe: atlassian/azure-functions-deploy:2.0.0
    variables:
      AZURE_APP_ID: $AZURE_APP_ID
      AZURE_PASSWORD: $AZURE_PASSWORD
      AZURE_TENANT_ID: $AZURE_TENANT_ID
      FUNCTION_APP_NAME: '&lt;string&gt;'
      ZIP_FILE: '&lt;string&gt;'
      # DEBUG: '&lt;boolean&gt;' # Optional</pre></li>				<li>Continue adding the necessary variables to the pipe definition. A completed example can be <span class="No-Break">seen here:</span><pre class="source-code">
script:
  - pipe: atlassian/azure-functions-deploy:2.0.0
    variables:
      AZURE_APP_ID: $AZURE_APP_ID
      AZURE_PASSWORD: $AZURE_PASSWORD
      AZURE_TENANT_ID: $AZURE_TENANT_ID
      FUNCTION_APP_NAME: 'my-function'
      ZIP_FILE: 'application.zip'</pre></li>			</ol>
			<p>With that, we’ve deployed a serverless function from our local system <span class="No-Break">to Azure.</span></p>
			<p>One aspect of <a id="_idIndexMarker621"/>deployment is <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) or the<a id="_idIndexMarker622"/> use of text-based <a id="_idIndexMarker623"/>configurations to dynamically create needed resources. A popular tool for doing this is Ansible. In the next recipe, we’ll learn how to use Bitbucket Pipelines to execute Ansible playbooks and <span class="No-Break">deploy resources.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor176"/>Using Ansible in the deployment stage</h1>
			<p>Ansible is <a id="_idIndexMarker624"/>a standard tool for performing IaC. With Ansible, you <a id="_idIndexMarker625"/><a id="_idIndexMarker626"/>can configure physical or virtual servers and perform configuration tasks such as installing or upgrading software, setting the necessary parameters, and starting <span class="No-Break">application services.</span></p>
			<p>Ansible is available in its original CLI as well as an integrated graphical user interface for dedicated Ansible application servers <a id="_idIndexMarker627"/>called <strong class="bold">Ansible Tower</strong>. We will look at automating deployment to <span class="No-Break">both interfaces.</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor177"/>Getting ready</h2>
			<p>To execute <a id="_idIndexMarker628"/>Ansible, the following programs must be installed on the runners you plan to use to execute the <span class="No-Break">Bitbucket pipeline:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">python</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">pip</strong></span></li>
			</ul>
			<p>Once they’re installed, we can add Ansible commands to our <span class="No-Break">Bitbucket pipeline.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>How to do it…</h2>
			<p>The original <a id="_idIndexMarker629"/>Ansible application is built on Python and accepts two files as input. Both <a id="_idIndexMarker630"/>of these files are text files in <span class="No-Break">YAML format:</span></p>
			<ul>
				<li><strong class="source-inline">playbook</strong>: This file includes the commands that <span class="No-Break">Ansible runs</span></li>
				<li><strong class="source-inline">Inventory</strong>: This file details the machines and their environments that Ansible applies the <span class="No-Break">playbook against</span></li>
			</ul>
			<p>Let’s learn how to incorporate this in our <span class="No-Break"><strong class="source-inline">bitbucket-pipelines.yml</strong></span><span class="No-Break"> file:</span></p>
			<ol>
				<li>Add the following line to the <strong class="source-inline">script</strong> section of the <strong class="source-inline">bitbucket-pipelines.yml</strong> file. This will <span class="No-Break">install Ansible:</span><pre class="source-code">
<strong class="bold">- pip install ansible==2.17</strong></pre></li>				<li>Once installed, move inside the directory where the playbooks for <span class="No-Break">Ansible reside:</span><pre class="source-code">
<strong class="bold">cd deployment</strong></pre></li>				<li>Add the command to run Ansible. You can use the <strong class="source-inline">-i</strong> flag to denote the <span class="No-Break">inventory file:</span><pre class="source-code">
<strong class="bold">- ansible-playbook -i inventory playbook.yaml</strong></pre></li>				<li>The script should look <span class="No-Break">as follows:</span><pre class="source-code">
script:
   - pip install ansible==2.17
   - cd deployment
   - ansible-playbook -i inventory playbook.yaml</pre></li>			</ol>
			<p>In this recipe, we looked at how to deploy a configuration from Bitbucket Pipelines using the community version of Ansible. The full version from Red Hat features dedicated infrastructure for running the Ansible application that’s controlled by a GUI called Ansible Tower. Next, we’ll learn how to deploy to Ansible Tower using <span class="No-Break">Bitbucket Pipelines.</span></p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>There’s more…</h2>
			<p>Although the <a id="_idIndexMarker631"/>primary means of controlling Ansible Tower jobs is through a GUI, there is a CLI called <strong class="source-inline">tower-cli</strong> that allows you to script <a id="_idIndexMarker632"/>Ansible Tower jobs. Let’s<a id="_idIndexMarker633"/> look at <strong class="source-inline">tower-cli</strong> <span class="No-Break">in action:</span></p>
			<ol>
				<li>Install <strong class="source-inline">tower-cli</strong> in your build environment. You may need to specify an image that has Python, including <strong class="source-inline">pip</strong>. Here, <strong class="source-inline">pip</strong> allows you to <span class="No-Break">install </span><span class="No-Break"><strong class="source-inline">tower-cli</strong></span><span class="No-Break">:</span><pre class="source-code">
image: python:2.7
  pipelines:
   default:
    - step:
        script: # Modify the commands below to build your repository.
            - pip install ansible-tower-cli</pre></li>				<li>Set up the required environment variables. For <strong class="source-inline">tower-cli</strong>, these are <span class="No-Break">as follows:</span><ul><li><strong class="source-inline">host</strong>: <span class="No-Break">Tower host</span></li><li><strong class="source-inline">username</strong>: <span class="No-Break">Tower username</span></li><li><strong class="source-inline">password</strong>: Tower user password (saved as a secure <span class="No-Break">Bitbucket variable)</span></li><li><strong class="source-inline">ID</strong>: ID of the Tower job template <span class="No-Break">to launch</span></li></ul></li>
				<li>Add the following lines to configure the environment variables and run the <span class="No-Break">Ansible job:</span><pre class="source-code">
 - hostval=$(tower-cli config host $host)
 - userval=$(tower-cli config username $username)
 - passwordval=$(tower-cli config password $password)
 - tower-cli config verify_ssl false
 - tower-cli job launch --job-template $ID --monitor</pre></li>			</ol>
			<p>With that, we’ve<a id="_idIndexMarker634"/> triggered an Ansible job located in <a id="_idIndexMarker635"/>Ansible Tower from <span class="No-Break">Bitbucket Pipelines.</span></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/>See also</h2>
			<p>The following documentation for Ansible provides guidance on creating correct <span class="No-Break">Ansible jobs:</span></p>
			<ul>
				<li><a href="https://access.redhat.com/documentation/en-us/red_hat_ansible_automation_platform/2.4"><span class="No-Break">https://access.redhat.com/documentation/en-us/red_hat_ansible_automation_platform/2.4</span></a></li>
				<li><a href="https://docs.ansible.com/ansible/latest/index.html"><span class="No-Break">https://docs.ansible.com/ansible/latest/index.html</span></a></li>
			</ul>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor181"/>Using Terraform in the deployment stage</h1>
			<p>Terraform is another tool that provides IaC capabilities. Its popularity comes from the fact that it is<a id="_idIndexMarker636"/> flexible for outlining instance creation of cloud resources and then implementing those resources to specific cloud platforms using providers that specify the <span class="No-Break">implementation details.</span></p>
			<p>Let’s learn how to deploy to Terraform from <span class="No-Break">Bitbucket Pipelines.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor182"/>Getting ready</h2>
			<p>Terraform<a id="_idIndexMarker637"/> describes the configuration it will <a id="_idIndexMarker638"/>perform in three files, all of which need to be in your <span class="No-Break">Bitbucket repository:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">main.tf</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">variables.tf</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">provider.tf</strong></span></li>
			</ul>
			<p>In addition, any credentials needed by Terraform for configuring the backend platforms, such as AWS or Google Cloud, should be stored as Bitbucket variables, and you should allocate them as secure <span class="No-Break">if necessary.</span></p>
			<p>With these in place, let’s set up <span class="No-Break">our deployment.</span></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor183"/>How to do it…</h2>
			<p>There <a id="_idIndexMarker639"/>are several steps we must take to deploy using <a id="_idIndexMarker640"/>Terraform, encapsulated in three commands. Let’s look at the Terraform commands we need <span class="No-Break">to use:</span></p>
			<ol>
				<li>For the step that defines deployment, use the Terraform Docker image. We’ll cover using Docker images in Bitbucket Pipeline steps in more detail in <a href="B21937_09.xhtml#_idTextAnchor185"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">:</span><pre class="source-code">
 - step:
    image: hashicorp/terraform:full</pre></li>				<li>In the <strong class="source-inline">script</strong> section of the <strong class="source-inline">bitbucket-pipelines.yml</strong> file, enter the following command to <span class="No-Break">initialize Terraform:</span><pre class="source-code">
<strong class="bold"> - terraform init</strong></pre></li>				<li>Add the following line to perform validation. This may not <span class="No-Break">be required:</span><pre class="source-code">
<strong class="bold"> - terraform validate</strong></pre></li>				<li>Add the following line to create the plan in Terraform. The output can be saved using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">out</strong></span><span class="No-Break"> flag:</span><pre class="source-code">
<strong class="bold"> - terraform plan -out=plantf</strong></pre></li>				<li>Add the following line to apply the plan and <span class="No-Break">run Terraform:</span><pre class="source-code">
<strong class="bold"> - terraform apply plantf</strong></pre></li>				<li>The complete <strong class="source-inline">step</strong> should now look <span class="No-Break">as follows:</span><pre class="source-code">
- step:
    image: hashicorp/terraform:full
    script:
      - terraform init
      - terraform validate
      - terraform plan -out=plantf
      - terraform apply plantf</pre></li>			</ol>
			<p>With that, we<a id="_idIndexMarker641"/> performed a deployment in Bitbucket Pipelines <a id="_idIndexMarker642"/>where we invoked Terraform to create <span class="No-Break">our instances.</span></p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor184"/>See also</h2>
			<p>The following resource is beneficial for understanding Terraform – <a href="https://developer.hashicorp.com/terraform/docs"><span class="No-Break">https://developer.hashicorp.com/terraform/docs</span></a><span class="No-Break">.</span></p>
		</div>
	</body></html>