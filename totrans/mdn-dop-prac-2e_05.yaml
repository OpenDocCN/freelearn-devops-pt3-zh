- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Container Orchestration with Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行容器编排
- en: In the previous chapter, we covered creating and managing container images,
    where we discussed container images, Dockerfiles, and their directives and components.
    We also looked at the best practices for writing a Dockerfile and building and
    managing efficient images. We then looked at flattening Docker images and investigated
    in detail distroless images to improve container security. Finally, we created
    a private Docker registry.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了创建和管理容器镜像的内容，讨论了容器镜像、Dockerfile及其指令和组件。我们还讨论了编写Dockerfile的最佳实践，以及如何构建和管理高效的镜像。接着，我们探讨了扁平化Docker镜像，并详细研究了无发行版镜像，以提高容器安全性。最后，我们创建了一个私有Docker注册中心。
- en: Now, we will deep dive into container orchestration. We will learn how to schedule
    and run containers using the most popular container orchestrator – Kubernetes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入探讨容器编排。我们将学习如何使用最流行的容器编排工具——Kubernetes，来调度和运行容器。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What is Kubernetes, and why do I need it?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Kubernetes，为什么我需要它？
- en: Kubernetes architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes架构
- en: Installing Kubernetes (Minikube and KinD)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Kubernetes（Minikube和KinD）
- en: Understanding Kubernetes pods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Kubernetes Pod
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we assume you have Docker installed on a Linux machine running
    `sudo` access. You can follow [*Chapter 3*](B19877_03.xhtml#_idTextAnchor220),
    *Containerization with Docker*, for more details on how to do that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已在具有 `sudo` 权限的Linux机器上安装了Docker。您可以参考[*第三章*](B19877_03.xhtml#_idTextAnchor220)，*使用Docker容器化*，获取更多关于如何操作的细节。
- en: 'You will also need to clone the following GitHub repository for some exercises:
    [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要克隆以下GitHub存储库以进行一些练习：[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)。
- en: 'Run the following command to clone the repository into your home directory,
    and `cd` into the `ch5` directory to access the required resources:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将存储库克隆到您的主目录，并使用 `cd` 进入 `ch5` 目录以访问所需的资源：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As the repository contains files with placeholders, you must replace the `<your_dockerhub_user>`
    string with your actual Docker Hub user. Use the following commands to substitute
    the placeholders:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该存储库包含带占位符的文件，因此您必须将 `<your_dockerhub_user>` 字符串替换为您实际的Docker Hub用户名。请使用以下命令来替换占位符：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What is Kubernetes, and why do I need it?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Kubernetes，为什么我需要它？
- en: 'By now, you should understand what containers are and how to build and run
    containers using Docker. However, how we ran containers using Docker was not optimal
    from a production standpoint. Let me give you a few considerations to think about:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该了解容器是什么以及如何使用Docker构建和运行容器。然而，我们使用Docker运行容器的方式从生产角度来看并不理想。让我给你提供一些考虑事项：
- en: As portable containers can run on any Docker machine just fine, multiple containers
    also share server resources to optimize resource consumption. Now, think of a
    microservices application that comprises hundreds of containers. How will you
    choose what machine to run the containers on? What if you want to dynamically
    schedule the containers to another machine based on resource consumption?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于便携式容器可以在任何Docker机器上顺利运行，多个容器还共享服务器资源以优化资源消耗。现在，想象一个由数百个容器组成的微服务应用程序。您将如何选择在哪台机器上运行容器？如果您希望根据资源消耗动态调度容器到另一台机器上呢？
- en: Containers provide horizontal scalability as you can create a copy of the container
    and use a **load balancer** in front of a pool of containers. One way of doing
    this is to decide upfront and deploy the desired number of containers, but that
    isn’t optimal resource utilization. What if I tell you that you need to horizontally
    scale your containers dynamically with traffic – in other words, by creating additional
    container instances to handle the extra load when there is more traffic and reducing
    them when there is less?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器提供了水平扩展能力，因为您可以创建容器的副本，并在一组容器前面使用**负载均衡器**。一种方法是提前决定并部署所需数量的容器，但这不是最优的资源利用方式。如果我告诉你，你需要根据流量动态水平扩展容器——换句话说，当流量增加时，创建额外的容器实例来处理额外的负载，而当流量减少时，减少容器实例呢？
- en: There are container health check reports on the containers’ health. What if
    the container is unhealthy, and you want to auto-heal it? What would happen if
    an entire server goes down and you want to schedule all containers running on
    that server to another?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器有健康检查报告，显示容器的健康状态。如果容器不健康，并且你想让它自动修复该怎么办？如果整个服务器宕机，你希望将该服务器上的所有容器调度到其他地方，会发生什么？
- en: As containers mostly run within a server and can see each other, how would I
    ensure that only the required containers can interact with the other, something
    we usually do with VMs? We cannot compromise on security.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于容器大多运行在服务器内，并且能够彼此看到，那么我如何确保只有必要的容器能够互相交互，这是我们通常在虚拟机中做的事情？我们不能妥协于安全性。
- en: Modern cloud platforms allow us to run autoscaling VMs. How can we utilize that
    from the perspective of containers? For example, if I need just one VM for my
    containers during the night and five during the day, how can I ensure that the
    machines are dynamically allocated when we need them?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代云平台允许我们运行自动扩展的虚拟机（VM）。从容器的角度来看，我们如何利用这一点？例如，如果我在夜间只需要一台虚拟机来容纳我的容器，而白天需要五台，我该如何确保在需要时动态分配这些机器？
- en: How do you manage the networking between multiple containers if they are part
    of a more comprehensive service mesh?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个容器是更广泛服务网格的一部分，你如何管理它们之间的网络连接？
- en: The answer to all these questions is a container orchestrator, and the most
    popular and *de facto* standard for that is Kubernetes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题的答案是一个容器编排工具，而最受欢迎且*事实上的*标准就是 Kubernetes。
- en: Kubernetes is an open source container orchestrator. A bunch of Google engineers
    first developed it and then open sourced it to the **Cloud Native Computing Foundation**
    (**CNCF**). Since then, the buzz around Kubernetes has not subsided, and for an
    excellent reason – Kubernetes with containers has changed the technology mindset
    and how we look at infrastructure entirely. Instead of treating servers as dedicated
    machines to an application or as part of an application, Kubernetes has allowed
    visualizing servers as an entity with a container runtime installed. When we treat
    servers as a standard setup, we can run virtually anything in a cluster of servers.
    So, you don’t have to plan for **high availability** (**HA**), **disaster recovery**
    (**DR**), and other operational aspects for every application on your tech stack.
    Instead, you can cluster all your servers into a single unit – a Kubernetes cluster
    – and containerize all your applications. You can then offload all container management
    functions to Kubernetes. You can run Kubernetes on bare-metal servers, VMs, and
    as a managed service in the cloud through multiple Kubernetes-as-a-Service offerings.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个开源的容器编排工具。一群谷歌工程师最初开发了它，然后将其开源并交给了**云原生计算基金会**（**CNCF**）。从那时起，Kubernetes的热度未曾减退，而且这是有充分理由的——Kubernetes与容器的结合彻底改变了技术思维方式以及我们看待基础设施的方式。Kubernetes不再将服务器视为专门为某个应用程序服务的机器，或者作为应用程序的一部分，而是允许将服务器可视化为一个已安装容器运行时的实体。当我们将服务器视为标准设置时，我们就能在一群服务器的集群中运行几乎任何东西。因此，你不必为技术栈中的每个应用程序单独规划**高可用性**（**HA**）、**灾难恢复**（**DR**）和其他运营方面的问题。相反，你可以将所有服务器聚集成一个单位——Kubernetes
    集群——并将所有应用程序容器化。然后，你可以将所有容器管理功能交给 Kubernetes 来处理。你可以在裸金属服务器、虚拟机（VM）上运行 Kubernetes，或者通过多种
    Kubernetes 作为服务的产品，在云中运行它。
- en: 'Kubernetes solves these problems by providing HA, scalability, and zero downtime
    out of the box. It essentially performs the following functions to provide them:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 通过提供开箱即用的高可用性（HA）、可扩展性和零停机时间来解决这些问题。它基本上执行以下功能来提供这些功能：
- en: '**Provides a centralized control plane for interacting with it**: The API server
    exposes a list of useful APIs that you can interact with to invoke many Kubernetes
    functions. It also provides a Kubernetes command line called **kubectl** to interact
    with the API using simple commands. Having a centralized control plane ensures
    that you can interact with Kubernetes seamlessly.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供集中式控制平面与其交互**：API 服务器暴露了一个有用的 API 列表，你可以通过它调用许多 Kubernetes 功能。它还提供了一个名为
    **kubectl** 的 Kubernetes 命令行工具，方便你使用简单的命令与 API 进行交互。拥有一个集中式控制平面确保了你可以无缝地与 Kubernetes
    进行交互。'
- en: '**Interacts with the container runtime to schedule containers**: When we send
    the request to schedule a container to **kube-apiserver**, Kubernetes decides
    what server to schedule the container based on various factors and then interacts
    with the server’s container runtime through the **kubelet** component.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与容器运行时交互以调度容器**：当我们向**kube-apiserver**发送请求调度容器时，Kubernetes 会根据各种因素决定将容器调度到哪个服务器，然后通过**kubelet**组件与服务器的容器运行时进行交互。'
- en: '**Stores the expected configuration in a key-value data store**: Kubernetes
    applies the cluster’s anticipated configuration and stores that in a key-value
    data store – **etcd**. That way, Kubernetes continuously ensures that the containers
    within the cluster remain in the desired state. If there is any deviation from
    the expected state, Kubernetes will take every action to bring it back to the
    desired configuration. That way, Kubernetes ensures that your containers are up
    and running and healthy.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在键值数据存储中存储期望的配置**：Kubernetes 应用集群的预期配置，并将其存储在键值数据存储中——**etcd**。这样，Kubernetes
    会持续确保集群中的容器保持在期望的状态。如果有任何偏离预期状态的情况，Kubernetes 会采取措施将其恢复到期望的配置。通过这种方式，Kubernetes
    确保你的容器始终正常运行并保持健康。'
- en: '**Provides a network abstraction layer and service discovery**:Kubernetes uses
    a network abstraction layer to allow communication between your containers. Therefore,
    every container is allocated a virtual IP, and Kubernetes ensures a container
    is reachable from another container running on a different server. It provides
    the necessary networking by using an **overlay network** between the servers.
    From the container’s perspective, all containers in the cluster behave as if they
    are running on the same server. Kubernetes also uses a **DNS** to allow communication
    between containers through a domain name. That way, containers can interact with
    each other by using a domain name instead of an IP address to ensure that you
    don’t need to change the configuration if a container is recreated and the IP
    address changes.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供网络抽象层和服务发现**：Kubernetes 使用网络抽象层来允许容器之间的通信。因此，每个容器都会分配一个虚拟 IP，Kubernetes
    确保一个容器可以从运行在不同服务器上的另一个容器访问。它通过在服务器之间使用**覆盖网络**提供必要的网络连接。从容器的角度来看，集群中的所有容器就像是在同一台服务器上运行一样。Kubernetes
    还使用**DNS**来通过域名允许容器之间的通信。这样，容器可以通过使用域名而不是 IP 地址来相互交互，从而确保如果容器被重新创建且 IP 地址发生变化时，你不需要更改配置。'
- en: '**Interacts with the cloud provider**: Kubernetes interacts with the cloud
    provider to commission objects such as **load balancers** and **persistent disks**.
    So, if you tell Kubernetes that your application needs to persist data and define
    a **volume**, Kubernetes will automatically request a disk from your cloud provider
    and mount it to your container wherever it runs. You can also expose your application
    on an external load balancer by requesting Kubernetes. Kubernetes will interact
    with your cloud provider to spin up a load balancer and point it to your containers.
    That way, you can do everything related to containers by merely interacting with
    your Kubernetes API server.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与云提供商交互**：Kubernetes 与云提供商交互，以调度诸如**负载均衡器**和**持久磁盘**等对象。因此，如果你告诉 Kubernetes
    你的应用程序需要持久化数据并定义了一个**卷**，Kubernetes 会自动向你的云提供商请求磁盘，并将其挂载到运行容器的地方。你还可以通过向 Kubernetes
    请求将应用程序暴露在外部负载均衡器上。Kubernetes 会与云提供商交互，启动负载均衡器并将其指向你的容器。通过这种方式，你可以仅通过与 Kubernetes
    API 服务器交互来处理所有与容器相关的事务。'
- en: Kubernetes comprises multiple moving parts that take over each function we’ve
    discussed. Now, let’s look at the Kubernetes architecture to understand each of
    them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 包含多个组件，它们负责处理我们讨论的每个功能。现在，让我们来看看 Kubernetes 的架构，以了解每个组件的作用。
- en: Kubernetes architecture
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 架构
- en: Kubernetes is made of a cluster of nodes. There are two possible roles for nodes
    in Kubernetes – **control plane** nodes and **worker** nodes. The control plane
    nodes control the Kubernetes cluster, scheduling the workloads, listening to requests,
    and other aspects that help run your workloads and make the cluster function.
    They typically form the brain of the cluster.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是由一组节点组成的集群。在 Kubernetes 中，节点有两种可能的角色——**控制平面**节点和**工作**节点。控制平面节点控制
    Kubernetes 集群，调度工作负载、监听请求以及其他帮助运行工作负载和使集群运作的方面。它们通常构成集群的大脑。
- en: On the other hand, the worker nodes are the powerhouses of the Kubernetes cluster
    and provide raw computing for running your container workloads.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，工作节点是 Kubernetes 集群的动力源，为运行容器工作负载提供原始计算能力。
- en: Kubernetes architecture follows the client-server model via an API server. Any
    interaction, including internal interactions between components, happens via the
    Kubernetes API server. Therefore, the Kubernetes API server is known as the brain
    of the Kubernetes control plane.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 架构通过 API 服务器遵循客户端-服务器模型。所有的交互，包括组件之间的内部交互，都通过 Kubernetes API 服务器进行。因此，Kubernetes
    API 服务器被称为 Kubernetes 控制平面的“大脑”。
- en: 'There are other components of Kubernetes as well, but before we delve into
    the details, let’s look at the following diagram to understand the high-level
    Kubernetes architecture:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还有其他组件，但在深入细节之前，让我们通过下面的图表来了解高层次的 Kubernetes 架构：
- en: '![Figure 5.1 – Kubernetes cluster architecture](img/B19877_05_1.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – Kubernetes 集群架构](img/B19877_05_1.jpg)'
- en: Figure 5.1 – Kubernetes cluster architecture
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Kubernetes 集群架构
- en: 'The control plane comprises the following components:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 控制平面包含以下组件：
- en: '**API server**: As discussed previously, the API server exposes a set of APIs
    for external and internal actors to interact with Kubernetes. All interactions
    with Kubernetes happen via the API server, as evident from the preceding diagram.
    If you visualize the Kubernetes cluster as a ship, the API server is the ship’s
    captain.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 服务器**：如前所述，API 服务器暴露了一组 API，供外部和内部参与者与 Kubernetes 进行交互。所有与 Kubernetes
    的交互都通过 API 服务器进行，从前面的图示可以看出。如果将 Kubernetes 集群想象成一艘船，API 服务器就是船长。'
- en: '**Controller manager**: The controller manager is the ship’s executive officer
    and is tasked with ensuring that the captain’s orders are followed in the cluster.
    From a technical perspective, the controller manager reads the current and desired
    states and takes all actions necessary to move the current state to the desired
    state. It contains a set of controllers that interact with the Kubernetes components
    via the API server as and when needed. Some of these are as follows:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器管理器**：控制器管理器是船上的执行官，负责确保船长的命令在集群中得到遵守。从技术角度来看，控制器管理器读取当前状态和目标状态，并采取一切必要的行动将当前状态转变为目标状态。它包含一组控制器，这些控制器根据需要通过
    API 服务器与 Kubernetes 组件进行交互。以下是其中的一些：'
- en: '**Node controller**: This watches for when the node goes down and responds
    by interacting with the **Kube scheduler** via the **Kube API server** to schedule
    the pods to a healthy node.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点控制器**：该控制器监控节点何时宕机，并通过与 **Kube 调度器** 通过 **Kube API 服务器** 进行交互，将 Pods 调度到健康的节点上。'
- en: '**Replication controller**: This ensures that the correct amount of container
    replicas defined by replication controller objects in the cluster exist.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制控制器**：该控制器确保集群中定义的正确数量的容器副本存在。'
- en: '**Endpoints controller**: These assist in providing endpoints to your containers
    via services.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端控制器**：这些控制器帮助通过服务为你的容器提供终端。'
- en: '**Service account and token controllers**: These create default **accounts**
    and **tokens** for new **namespaces**.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务账户和令牌控制器**：这些控制器为新的 **命名空间** 创建默认的 **账户** 和 **令牌**。'
- en: '**Cloud controller manager**: This is an optional controller manager that you
    would run if you run Kubernetes in a public cloud, such as **AWS**, **Azure**,
    or **GCP**. The cloud controller manager interacts with the cloud provider APIs
    to provision resources such as **persistent disks** and **load balancers** that
    you declare in your Kubernetes configuration.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云控制器管理器**：这是一个可选的控制器管理器，若你在公共云上运行 Kubernetes（例如 **AWS**、**Azure** 或 **GCP**），则需要运行此控制器管理器。云控制器管理器与云提供商的
    API 进行交互，来配置你在 Kubernetes 配置中声明的资源，如 **持久磁盘** 和 **负载均衡器**。'
- en: '**etcd**: **etcd** is the log book of the ship. That is where all the details
    about the expected configuration exist. From a technical perspective, this is
    a key-value store where all the desired Kubernetes configuration is stored. The
    controller manager refers to the information in this database to action changes
    in the cluster.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**etcd**：**etcd** 是船的日志簿。这里存储着所有关于预期配置的详细信息。从技术角度来看，这是一个键值存储，存储着所有期望的 Kubernetes
    配置。控制器管理器会参考这个数据库中的信息来执行集群中的更改。'
- en: '**Scheduler**: The schedulers are the boatswain of the ship. They are tasked
    with supervising the process of loading and unloading containers on the ship.
    A Kubernetes scheduler schedules containers in a worker node it finds fit after
    considering the availability of resources to run it, the HA of your application,
    and other aspects.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度器**：调度器就像船只的水手长。它们负责监督容器在船上的装卸过程。Kubernetes 调度器会根据资源的可用性、应用程序的高可用性以及其他因素，在合适的工作节点上调度容器。'
- en: '**kubelet**: kubelets are the seamen of the ship. They carry out the actual
    loading and unloading of containers from a ship. From a technical perspective,
    the kubelet interacts with the underlying container runtime to run containers
    on the scheduler’s instruction. While most Kubernetes components can run as a
    container, the kubelet is the only component that runs as a **systemd** service.
    They usually run on worker nodes, but if you plan to run the control plane components
    as containers instead, the kubelet will also run on the control plane nodes.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubelet**：kubelet 就像船员一样。它们实际执行容器从船上装卸的操作。从技术角度看，kubelet 与底层的容器运行时交互，根据调度器的指令运行容器。虽然大多数
    Kubernetes 组件可以作为容器运行，但 kubelet 是唯一作为 **systemd** 服务运行的组件。它们通常运行在工作节点上，但如果你计划将控制平面组件作为容器运行，那么
    kubelet 也会在控制平面节点上运行。'
- en: '**kube-proxy**: **kube-proxy** runs on each worker node and provides the components
    for your containers to interact with the network components inside and outside
    your cluster. They are vital components that facilitate Kubernetes networking.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-proxy**：**kube-proxy** 在每个工作节点上运行，为容器提供与集群内外网络组件交互的功能。它们是促进 Kubernetes
    网络通信的关键组件。'
- en: Well, that’s a lot of moving parts, but the good news is that tools are available
    to set that up for you, and provisioning a Kubernetes cluster is very simple.
    If you are running on a public cloud, it is only a few clicks away, and you can
    use your cloud’s web UI or CLI to provision it very quickly. You can use **kubeadm**
    for the setup if you have an on-premises installation. The steps are well documented
    and understood and won’t be too much of a hassle.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这涉及很多环节，但好消息是，有现成的工具可以帮助你设置，而部署 Kubernetes 集群非常简单。如果你在公共云上运行，几次点击即可完成，你可以使用云提供商的
    Web UI 或 CLI 来快速部署。如果是本地安装，你可以使用**kubeadm**进行设置。步骤文档完善，易于理解，也不会太麻烦。
- en: For development and your CI/CD environments, you can use **Minikube** or **Kubernetes
    in Docker** (**KinD**). While Minikube can run a single-node Kubernetes cluster
    on your development machine directly by using your machine as the node, it can
    also run a multi-node cluster by running Kubernetes nodes as containers. KinD,
    on the other hand, exclusively runs your nodes as containers on both single-node
    and multi-node configurations. You need a VM with the requisite resources in both
    cases, and you’ll be good to go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发和 CI/CD 环境，你可以使用**Minikube**或**Docker 中的 Kubernetes**（**KinD**）。Minikube
    可以直接在你的开发机器上运行单节点 Kubernetes 集群，将机器作为节点使用；它也可以通过将 Kubernetes 节点作为容器来运行多节点集群。另一方面，KinD
    仅在单节点和多节点配置中将节点作为容器运行。在这两种情况下，你都需要一个具有必要资源的虚拟机，然后就可以开始了。
- en: In the next section, we’ll boot a single-node Kubernetes cluster with Minikube.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将使用 Minikube 启动一个单节点 Kubernetes 集群。
- en: Installing Kubernetes (Minikube and KinD)
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Kubernetes（Minikube 和 KinD）
- en: Now, let’s move on and install Kubernetes for your development environment.
    We will begin with Minikube to get you started quickly and then look into KinD.
    We will then use KinD for the rest of this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行 Kubernetes 的安装。我们将从 Minikube 开始，帮助你快速入门，然后再了解 KinD。接下来，我们将在本章的其余部分使用
    KinD。
- en: Installing Minikube
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Minikube
- en: We will install Minikube in the same Linux machine we used to install Docker
    in [*Chapter 3*](B19877_03.xhtml#_idTextAnchor220), *Containerization with Docker*.
    So, if you haven’t done that, please go to [*Chapter 3*](B19877_03.xhtml#_idTextAnchor220),
    *Containerization with Docker*, and follow the instructions provided to set up
    Docker on your machine.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在与安装 Docker 相同的 Linux 机器上安装 Minikube，参考[*第 3 章*](B19877_03.xhtml#_idTextAnchor220)，*使用
    Docker 进行容器化*。因此，如果你还没有进行该操作，请前往[*第 3 章*](B19877_03.xhtml#_idTextAnchor220)，*使用
    Docker 进行容器化*，并按照提供的说明在你的机器上设置 Docker。
- en: First, we will install **kubectl**. As described previously, kubectl is the
    command-line utility that interacts with the Kubernetes API server. We will use
    kubectl multiple times in this book.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装 **kubectl**。如前所述，kubectl 是与 Kubernetes API 服务器交互的命令行工具。在本书中，我们将多次使用
    kubectl。
- en: 'To download the latest release of kubectl, run the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载最新版本的 kubectl，请运行以下命令：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also download a specific version of kubectl. To do so, use the following
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以下载 kubectl 的特定版本。为此，请使用以下命令：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will stick with the latest release for this chapter. Now, let’s go ahead
    and make the binary executable and then move it to any directory in your system
    `PATH`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用最新版本。现在，让我们继续使二进制文件可执行，然后将其移动到系统的 `PATH` 中的任何目录：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s check whether kubectl has been successfully installed by running
    the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行以下命令检查 kubectl 是否已成功安装：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since kubectl was installed successfully, you must download the `minikube`
    binary and then move it to your system path using the following commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 kubectl 已成功安装，接下来你需要下载 `minikube` 二进制文件，并使用以下命令将其移动到系统路径中：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s install the packages required by Minikube to function correctly
    by running the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行以下命令来安装 Minikube 正常运行所需的包：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can bootstrap a Minikube cluster using the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下命令启动一个 Minikube 集群：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As Minikube is now up and running, we will use the kubectl command-line utility
    to interact with the Kube API server to manage Kubernetes resources. The kubectl
    commands have a standard structure and are self-explanatory in most cases. They
    are structured as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Minikube 现在已经启动并运行，我们将使用 kubectl 命令行工具与 Kube API 服务器交互，以管理 Kubernetes 资源。kubectl
    命令具有标准结构，并且大多数情况下易于理解。其结构如下：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we have the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '`verb`: The action to perform – for example, `get`, `apply`, `delete`, `list`,
    `patch`, `run`, and so on'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`动词`：要执行的操作——例如 `get`（获取）、`apply`（应用）、`delete`（删除）、`list`（列出）、`patch`（修补）、`run`（运行）等'
- en: '`resource type`: The Kubernetes resource to manage, such as `node`, `pod`,
    `deployment`, `service`, and so on'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`资源类型`：要管理的 Kubernetes 资源，例如 `node`（节点）、`pod`（容器组）、`deployment`（部署）、`service`（服务）等'
- en: '`resource name`: The name of the resource to manage'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`资源名称`：要管理的资源的名称'
- en: 'Now, let’s use kubectl to get nodes and check whether our cluster is ready
    to run our containers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 kubectl 获取节点并检查我们的集群是否准备好运行容器：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we can see that it is a single-node Kubernetes cluster running version
    **v1.26.3**. Kubernetes is now up and running!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这是一个运行版本 **v1.26.3** 的单节点 Kubernetes 集群。Kubernetes 现在已经启动并运行！
- en: This setup is excellent for development machines where developers want to deploy
    and test a single component they are working on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置非常适合开发机器，开发人员可以在其上部署并测试他们正在开发的单个组件。
- en: 'To stop the Minikube cluster and delete it from the machine, you can use the
    following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止 Minikube 集群并将其从机器中删除，你可以使用以下命令：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have removed Minikube, let’s look at another exciting tool for creating
    a multi-node Kubernetes cluster.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经移除了 Minikube，接下来让我们看看另一个创建多节点 Kubernetes 集群的有趣工具。
- en: Installing KinD
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 KinD
- en: 'KinD allows you to run a multi-node Kubernetes cluster on a single server that
    runs Docker. We understand that a multi-node Kubernetes cluster requires multiple
    machines, but how can we run a multi-node Kubernetes cluster on a single server?
    The answer is simple: KinD uses a Docker container as a Kubernetes node. So, if
    we need a four-node Kubernetes cluster, KinD will spin up four containers that
    behave like four Kubernetes nodes. It is as simple as that.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: KinD 允许你在运行 Docker 的单个服务器上运行一个多节点的 Kubernetes 集群。我们知道，运行一个多节点的 Kubernetes 集群需要多台机器，但如何在单台服务器上运行一个多节点
    Kubernetes 集群呢？答案很简单：KinD 使用 Docker 容器作为 Kubernetes 节点。因此，如果我们需要一个四节点的 Kubernetes
    集群，KinD 会启动四个容器，它们表现得就像四个 Kubernetes 节点。就这么简单。
- en: While you need Docker to run KinD, KinD internally uses **containerd** as a
    container runtime instead of Docker. Containerd implements the container runtime
    interface; therefore, Kubernetes does not require any specialized components,
    such as **dockershim**, to interact with it. This means that KinD still works
    with Kubernetes since Docker isn’t supported anymore as a Kubernetes container
    runtime.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你需要 Docker 来运行 KinD，但 KinD 内部使用 **containerd** 作为容器运行时，而不是 Docker。Containerd
    实现了容器运行时接口，因此 Kubernetes 不需要任何专门的组件，如 **dockershim**，与其交互。这意味着，KinD 仍然能够与 Kubernetes
    配合使用，因为 Docker 不再被支持作为 Kubernetes 的容器运行时。
- en: As KinD supports a multi-node Kubernetes cluster, you can use it for your development
    activities and also in your CI/CD pipelines. In fact, KinD redefines CI/CD pipelines
    as you don’t require a static Kubernetes environment to test your build. KinD
    is swift to boot up, which means you can integrate the bootstrapping of the KinD
    cluster, run and test your container builds within the cluster, and then destroy
    it all within your CI/CD pipeline. This gives development teams immense power
    and speed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 KinD 支持多节点 Kubernetes 集群，你可以将其用于开发活动，也可以用于 CI/CD 管道。实际上，KinD 重新定义了 CI/CD
    管道，因为你不需要一个静态的 Kubernetes 环境来测试你的构建。KinD 启动速度快，这意味着你可以将 KinD 集群的引导过程集成到 CI/CD
    管道中，在集群内运行并测试你的容器构建，然后将其销毁。这为开发团队提供了巨大的力量和速度。
- en: Important
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Never use KinD in production. Docker in Docker implementations are not very
    secure; therefore, KinD clusters should not exist beyond your dev environments
    and CI/CD pipelines.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在生产环境中使用 KinD。Docker in Docker 的实现并不安全；因此，KinD 集群不应超出你的开发环境和 CI/CD 管道。
- en: 'Bootstrapping KinD is just a few commands away. First, we need to download
    KinD, make it executable, and then move it to the default `PATH` directory using
    the following commands:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 引导 KinD 只需几个命令。首先，我们需要下载 KinD，确保它可执行，然后使用以下命令将其移动到默认的 `PATH` 目录中：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To check whether KinD is installed, we can run the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否已安装 KinD，可以运行以下命令：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s bootstrap a multi-node KinD cluster. First, we need to create a
    KinD `config` file. The KinD `config` file is a simple YAML file where you can
    declare what configuration you want for each node. If we need to bootstrap a single
    control plane and three worker node clusters, we can add the following configuration:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们引导一个多节点的 KinD 集群。首先，我们需要创建一个 KinD `config` 文件。KinD `config` 文件是一个简单的 YAML
    文件，你可以在其中声明每个节点所需的配置。如果我们需要引导一个单控制平面和三个工作节点的集群，可以添加以下配置：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can also have an HA configuration with multiple control planes using multiple
    node items with the control plane role. For now, let’s stick with a single control
    plane, three-worker node configuration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用多个控制平面节点来实现高可用配置，在控制平面角色的节点上使用多个节点项。现在，我们先使用单个控制平面和三个工作节点的配置。
- en: 'To bootstrap your KinD cluster with the preceding configuration, run the following
    command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前述配置引导你的 KinD 集群，请运行以下命令：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With that, our KinD cluster is up and running. Now, let’s list the nodes to
    see for certain by using the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的 KinD 集群已经启动并运行了。现在，让我们使用以下命令列出节点，确认集群状态：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we can see four nodes in the cluster – one control plane and three workers.
    Now that the cluster is ready, we’ll dive deep into Kubernetes and look at some
    of the most frequently used Kubernetes resources in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到集群中有四个节点——一个控制平面和三个工作节点。现在集群已经准备好，我们将在下一个部分深入了解 Kubernetes，并看看一些最常用的
    Kubernetes 资源。
- en: Understanding Kubernetes pods
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 的 pods
- en: Kubernetes pods are the basic building blocks of a Kubernetes application. A
    pod contains one or more containers, and all containers within a pod are always
    scheduled in the same host. Usually, there is a single container within a pod,
    but there are use cases where you need to schedule multiple containers in a single
    pod.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的 pod 是 Kubernetes 应用程序的基本构建块。一个 pod 包含一个或多个容器，所有容器总是会调度到同一主机上。通常，pod
    中只有一个容器，但在某些场景下，你需要在一个 pod 中调度多个容器。
- en: It takes a while to digest why Kubernetes started with the concept of pods in
    the first place instead of using containers, but there are reasons for that, and
    you will appreciate this as you gain more experience with the tool. For now, let’s
    look at a simple example of a pod and how to schedule it in Kubernetes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么 Kubernetes 最初采用 pod 的概念而不是使用容器，可能需要一些时间，但这是有原因的，随着你对工具的使用经验积累，你会理解其中的深意。现在，让我们来看一个简单的
    pod 示例，以及如何在 Kubernetes 中调度它。
- en: Running a pod
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行一个 pod
- en: We will start by running an NGINX container in a pod using simple imperative
    commands. We will then look at how we can do this declaratively.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用简单的命令在 pod 中运行一个 NGINX 容器。然后，我们会看看如何以声明的方式进行操作。
- en: 'To access the resources for this section, `cd` into the following directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，请`cd`到以下目录：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To run a pod with a single NGINX container, execute the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个包含单个 NGINX 容器的 pod，请执行以下命令：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To check whether the pod is running, run the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 pod 是否正在运行，可以运行以下命令：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And that’s it! As we can see, the pod is now running.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！正如我们所看到的，pod 现在正在运行。
- en: 'To delete the pod, you can run the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除 pod，可以运行以下命令：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `kubectl run` command was the imperative way of creating pods, but there’s
    another way of interacting with Kubernetes – by using declarative manifests. `docker
    compose`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl run` 命令是创建 pod 的命令式方式，但与 Kubernetes 交互的另一种方式是使用声明性清单。`docker compose`。'
- en: Tip
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always use the declarative method to create Kubernetes resources in staging
    and production environments. They allow you to store and version your Kubernetes
    configuration in a source code management tool such as Git and enable GitOps.
    You can use imperative methods during development because commands have a quicker
    turnaround than YAML files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在预发布和生产环境中始终使用声明性方法创建 Kubernetes 资源。它们允许您将 Kubernetes 配置存储和版本化在诸如 Git 等源代码管理工具中，并启用
    GitOps。在开发过程中，您可以使用命令式方法，因为命令比 YAML 文件具有更快的周转时间。
- en: 'Let’s look at an example pod manifest, `nginx-pod.yaml`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例 pod 清单，`nginx-pod.yaml`：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s understand the file first. The file contains the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解文件。文件包含以下内容：
- en: '`apiVersion`: This defines the resource version we are trying to define. In
    this case, as it is a pod and a `v1`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`: 这定义了我们正在定义的资源版本。在这种情况下，作为 pod 的版本为 `v1`。'
- en: '`kind`: This defines the kind of resource we want to create – a pod.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`: 这定义了我们要创建的资源类型 – 一个 pod。'
- en: '`metadata`: The `metadata` section defines the name and labels surrounding
    this resource. It helps in uniquely identifying the resource and grouping multiple
    resources using labels.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`: `metadata` 部分定义了围绕此资源的名称和标签。它有助于通过标签唯一标识资源并分组多个资源。'
- en: '`spec`: This is the main section where we define the actual specifications
    for the resource.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`: 这是主要部分，我们在这里定义资源的实际规格。'
- en: '`spec.containers`: This section defines one or more containers that form the
    pod.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers`: 此部分定义形成 pod 的一个或多个容器。'
- en: '`spec.containers.name`: This is the container’s name, which is `nginx-container`
    in this case.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.name`: 这是容器的名称，在本例中为 `nginx-container`。'
- en: '`spec.containers.image`: This is the container image, which is `nginx` in this
    case.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.image`: 这是容器镜像，在本例中是 `nginx`。'
- en: '`spec.containers.imagePullPolicy`: This can be `Always`, `IfNotPresent`, or
    `Never`. If set to `Always`, Kubernetes always pulls the image from the registry.
    If set to `IfNotPresent`, Kubernetes pulls the image only if the image is not
    found on the node where the pod is scheduled. If set to `Never`, Kubernetes will
    never attempt to pull images from the registry and will rely completely on local
    images.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.imagePullPolicy`: 这可以是 `Always`（始终拉取）、`IfNotPresent`（仅在节点上未找到镜像时拉取）、或
    `Never`（从不尝试从注册表拉取镜像并完全依赖本地镜像）。'
- en: '`spec.containers.resources`: This defines the resource requests and limits.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources`: 这定义了资源的请求和限制。'
- en: '`spec.containers.resources.limit`: This defines the resource limits. This is
    the maximum amount of resources that the pod can allocate, and if the resource
    consumption increases beyond it, the pod is evicted.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.limit`: 这定义了资源限制。这是 pod 可以分配的最大资源量，如果资源消耗超出此限制，pod
    将被驱逐。'
- en: '`spec.containers.resources.limit.memory`: This defines the memory limit.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.limit.memory`: 这定义了内存限制。'
- en: '`spec.containers.resources.limit.cpu`: This defines the CPU limit.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.limit.cpu`: 这定义了 CPU 限制。'
- en: '`spec.containers.resources.requests`: This defines the resource requests. This
    is the minimum amount of resources the pod would request during scheduling and
    will not be scheduled on a node that cannot allocate it.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.requests`: 这定义了资源请求。这是在调度期间 pod 需要的最小资源量，如果节点无法分配这些资源，将不会被调度。'
- en: '`spec.containers.resources.requests.memory`: This defines the amount of memory
    to be requested.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.requests.memory`: 这定义了要请求的内存量。'
- en: '`spec.containers.resources.requests.cpu`: This defines the number of CPU cores
    to be requested.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.requests.cpu`: 这定义了要请求的 CPU 核心数量。'
- en: '`spec.restartPolicy`: This defines the restart policy of containers – `Always`,
    `OnFailure`, or `Never`. This is similar to the restart policy on Docker.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.restartPolicy`: 这定义了容器的重启策略 – `Always`（始终重启）、`OnFailure`（失败时重启）、或 `Never`（从不重启）。这与
    Docker 上的重启策略类似。'
- en: There are other settings on the pod manifest, but we will explore these as and
    when we progress.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pod 清单上还有其他设置，但我们将根据进展情况逐步探讨。
- en: Important tips
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Set `imagePullPolicy` to `IfNotPresent` unless you have a strong reason for
    using `Always` or `Never`. This will ensure that your containers boot up quickly
    and you don’t download images unnecessarily.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `imagePullPolicy` 设置为 `IfNotPresent`，除非你有充分的理由使用 `Always` 或 `Never`。这样可以确保你的容器快速启动，并且避免不必要地下载镜像。
- en: Always use resource requests and limits while scheduling pods. These ensure
    that your pod is scheduled in an appropriate node and does not exhaust any existing
    resources. You can also apply a default resource policy at the cluster level to
    ensure that your developers don’t cause any harm if they miss out on this section
    for some reason.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在调度 pod 时，请始终使用资源请求和限制。这确保你的 pod 被调度到适当的节点，并且不会耗尽任何现有资源。你还可以在集群级别应用默认的资源策略，以确保如果开发人员由于某些原因忽略了这一部分，也不会造成任何损害。
- en: 'Let’s apply the manifest using the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令应用清单：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The pod that we created is entirely out of bounds from the host. It runs within
    the container network, and by default, Kubernetes does not allow any pod to be
    exposed to the host network unless we explicitly want to expose it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 pod 完全处于主机网络之外。它运行在容器网络内，默认情况下，Kubernetes 不允许任何 pod 暴露给主机网络，除非我们明确要暴露它。
- en: There are two ways to access the pod – using port forwarding with `kubectl port-forward`,
    or exposing the pod through a `Service` resource.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 pod 有两种方式——使用 `kubectl port-forward` 进行端口转发，或者通过 `Service` 资源暴露 pod。
- en: Using port forwarding
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用端口转发
- en: Before we get into the service side of things, let’s consider using the `port-forward`
    option.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入服务部分之前，让我们考虑一下使用 `port-forward` 选项。
- en: 'To expose the pod using port forwarding, execute the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过端口转发暴露 pod，请执行以下命令：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The prompt is stuck here. This means it has opened a port forwarding session
    and is listening on port `8080`. It will automatically forward the request it
    receives on port `8080` to NGINX port `80`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 提示信息停留在这里。这意味着它已打开端口转发会话，并在端口 `8080` 上监听。它将自动将收到的端口 `8080` 请求转发到 NGINX 的端口 `80`。
- en: 'Open a duplicate Terminal session and `curl` on the preceding address to see
    what we get:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个重复的终端会话，并在前述地址上执行 `curl`，查看我们会得到什么：
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see that it is working as we get the default NGINX response.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它正在工作，因为我们得到了默认的 NGINX 响应。
- en: Now, there are a few things to remember here.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有几点需要记住。
- en: 'When we use HTTP `port-forward`, we are forwarding requests from the client
    machine running `kubectl` to the pod, something similar to what’s shown in the
    following diagram:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 HTTP `port-forward` 时，我们是将请求从运行 `kubectl` 的客户端机器转发到 pod，类似于下图所示的内容：
- en: '![Figure 5.2 – kubectl port-forward](img/B19877_05_2.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – kubectl port-forward](img/B19877_05_2.jpg)'
- en: Figure 5.2 – kubectl port-forward
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – kubectl port-forward
- en: When you run `kubectl` `port-forward`, the `kubectl` client opens a TCP tunnel
    via the Kube API server, and the Kube API server then forwards the connection
    to the correct pod. As the connection between the `kubectl` client and the API
    server is encrypted, it is a very secure way of accessing your pod, but hold your
    horses before deciding to use `kubectl` `port-forward` to expose pods to the outside
    world.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `kubectl` `port-forward` 时，`kubectl` 客户端通过 Kube API 服务器打开一个 TCP 隧道，然后 Kube
    API 服务器将连接转发到正确的 pod。由于 `kubectl` 客户端和 API 服务器之间的连接是加密的，因此这是一种非常安全的访问 pod 的方式，但在决定使用
    `kubectl` `port-forward` 将 pod 暴露给外部世界之前，请三思。
- en: 'There are particular use cases for using `kubectl` `port-forward`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特定的使用场景适合使用 `kubectl` `port-forward`：
- en: For troubleshooting any misbehaving pod.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于故障排除任何行为不正常的 pod。
- en: For accessing an internal Kubernetes service, such as the Kubernetes dashboard
    – that is, when you don’t want to expose the service to the external world but
    only allow Kubernetes admins and users to log into the dashboard. It is assumed
    that only these users will have access to the cluster via `kubectl`.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于访问 Kubernetes 内部服务，例如 Kubernetes 仪表盘——也就是说，当你不希望将服务暴露给外部世界，而只允许 Kubernetes
    管理员和用户登录仪表盘时。假设只有这些用户可以通过 `kubectl` 访问集群。
- en: For anything else, you should use `Service` resources to expose your pod, internally
    or externally. While we will cover the `Service` resource in the next chapter,
    let’s look at a few operations we can perform with a pod.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他任何情况，你应该使用 `Service` 资源来暴露你的 pod，无论是内部还是外部。虽然我们将在下一章中讨论 `Service` 资源，但让我们先看一下可以对
    pod 执行的几个操作。
- en: Troubleshooting pods
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 故障排除 pods
- en: Similar to how we can browse logs from a container using `docker logs`, we can
    browse logs from a container within a Kubernetes pod using the `kubectl logs`
    command. If more than one container runs within the pod, we can specify the container’s
    name using the `-``c` flag.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们使用`docker logs`浏览容器日志的方式，我们可以使用`kubectl logs`命令浏览 Kubernetes pod 中容器的日志。如果
    pod 中运行多个容器，我们可以使用`-c`标志来指定容器的名称。
- en: 'To access the container logs, run the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问容器日志，运行以下命令：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As the pod is running a single container, we need not specify the `-c` flag,
    so instead, you can use the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 pod 只运行一个容器，我们无需指定`-c`标志，因此你可以使用以下命令：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There might be instances where you may want to get a shell to a running container
    and troubleshoot what’s going on within that. We use `docker exec` for that in
    the Docker world. Similarly, we can use `kubectl exec` for that within Kubernetes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有些情况，你可能需要获取运行中容器的 shell 并排查容器内发生了什么。在 Docker 中我们使用`docker exec`来实现这个操作。同样，在
    Kubernetes 中我们可以使用`kubectl exec`来实现这一点。
- en: 'Run the following command to open a shell session with the container:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以打开与容器的 shell 会话：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can even run specific commands without opening a shell session. For example,
    we can perform the preceding operation with a single line, something like the
    following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以在不打开 shell 会话的情况下运行特定命令。例如，我们可以通过一行命令来执行前面的操作，类似以下内容：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`kubectl exec` is an important command that helps us troubleshoot containers.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl exec`是一个重要命令，有助于我们故障排除容器。'
- en: Tip
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you modify files or download packages within the container in `exec` mode,
    they will persist until the current pod is alive. Once the pod is gone, you will
    lose all changes. Therefore, it isn’t a great way of fixing issues. You should
    only diagnose problems using `exec`, bake the correct changes in a new image,
    and then redeploy it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`exec`模式下修改容器中的文件或下载包，这些更改会在当前 pod 存活期间持续有效。一旦 pod 被删除，你将失去所有更改。因此，这并不是解决问题的好方法。你应当只使用`exec`来诊断问题，将正确的更改嵌入到新镜像中，然后重新部署。
- en: When we looked at distroless containers in the previous chapter, they did not
    allow `exec` into the container for security reasons. There are debug images available
    for distroless that will enable you to open a shell session for troubleshooting
    purposes if you wish.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中我们讨论了无发行版容器，它们由于安全原因不允许`exec`进入容器。对于无发行版容器，提供了调试镜像，可以让你打开一个 shell 会话进行故障排除。
- en: Tip
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: By default, a container runs as the root user if you don’t specify the user
    within the Dockerfile while building the image. You can set a `runAsUser` attribute
    within your pod’s security context if you want to run your pod as a specific user,
    but this is not ideal. The best practice is to bake the user within the container
    image.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果在构建镜像时没有在 Dockerfile 中指定用户，容器会以 root 用户运行。如果你想以特定用户运行 pod，可以在 pod 的安全上下文中设置`runAsUser`属性，但这并不是理想的做法。最佳实践是将用户信息嵌入到容器镜像中。
- en: We’ve discussed troubleshooting running containers, but what if the containers
    fail to start for some reason?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何故障排除运行中的容器，但如果容器由于某些原因无法启动怎么办？
- en: 'Let’s look at the following example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看以下示例：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let’s try to get the pod and see for ourselves:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试获取 pod 并亲自查看：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Oops! There is some error now, and the status is `ImagePullBackOff`. Well,
    it seems like there is some issue with the image. While we understand that the
    issue is with the image, we want to understand the real issue, so for further
    information on this, we can describe the pod using the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！现在出现了一些错误，状态是`ImagePullBackOff`。嗯，似乎是镜像出了些问题。虽然我们知道问题出在镜像上，但我们希望了解真正的问题所在，因此，为了进一步了解此问题，我们可以使用以下命令描述
    pod：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, this gives us a wealth of information regarding the pod, and if you look
    at the `events` section, you will find a specific line that tells us what is wrong
    with the pod:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这为我们提供了关于 pod 的大量信息，如果你查看`events`部分，你会找到一行特定信息，告诉我们 pod 出了什么问题：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, this one is telling us that either the repository does not exist, or the
    repository exists but it is private, and hence authorization failed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这条信息告诉我们，要么仓库不存在，要么仓库存在但为私有仓库，因此授权失败。
- en: Tip
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can use `kubectl describe` for most Kubernetes resources. It should be the
    first command you use while troubleshooting issues.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`kubectl describe`来查看大多数 Kubernetes 资源。它应该是你在故障排除时使用的第一个命令。
- en: Since we know that the image does not exist, let’s change the image to a valid
    one. We must delete the pod and recreate it with the correct image to do that.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道该镜像不存在，让我们将镜像更换为有效的镜像。我们必须删除 Pod，并使用正确的镜像重新创建它。
- en: 'To delete the pod, run the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除 Pod，请运行以下命令：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To recreate the pod, run the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新创建 Pod，请运行以下命令：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let’s get the pod; it should run as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取 Pod；它应该按如下方式运行：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The pod is now running since we have fixed the image issue.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经解决了镜像问题，Pod 现在已经在运行。
- en: So far, we’ve managed to run containers using pods, but pods are very powerful
    resources that help you manage containers. Kubernetes pods provide probes to ensure
    your application’s reliability. We’ll have a look at this in the next section.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经能够使用 Pod 运行容器，但 Pod 是非常强大的资源，可以帮助你管理容器。Kubernetes Pod 提供了探针来确保应用程序的可靠性。我们将在下一节中详细介绍这一点。
- en: Ensuring pod reliability
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保 Pod 可靠性
- en: We talked about health checks in [*Chapter 4*](B19877_04.xhtml#_idTextAnchor399),
    *Creating and Managing Container Images*, and I also mentioned that you should
    not use them on the Docker level and instead use the ones provided by your container
    orchestrator. Kubernetes provides three **probes** to monitor your pod’s health
    – the **startup probe**, **liveness probe**, and **readiness probe**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第4章*](B19877_04.xhtml#_idTextAnchor399)《创建和管理容器镜像》中讨论了健康检查，我还提到过你不应该在 Docker
    层面使用健康检查，而应该使用容器编排器提供的健康检查。Kubernetes 提供了三种**探针**来监控你的 Pod 健康状况——**启动探针**、**存活探针**和**就绪探针**。
- en: 'The following diagram depicts all three probes graphically:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了三种探针的图形化表示：
- en: '![Figure 5.3 – Kubernetes probes](img/B19877_05_3.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – Kubernetes 探针](img/B19877_05_3.jpg)'
- en: Figure 5.3 – Kubernetes probes
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – Kubernetes 探针
- en: Let’s look at each one in turn and understand how and when to use them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看每种探针，了解如何使用它们以及何时使用它们。
- en: Startup probe
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动探针
- en: Kubernetes uses **startup probes** to check whether the application has started.
    You can use startup probes on applications that start slow or those you don’t
    know how long it might take to start. While the startup probe is active, it disables
    other probes so that they don’t interfere with its operation. As the application
    has not started until the startup probe reports it, there is no point in having
    any other probes active.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用**启动探针**检查应用程序是否已启动。你可以在启动缓慢的应用程序上使用启动探针，或者在你不知道启动可能需要多长时间的情况下使用它。当启动探针处于活动状态时，它会禁用其他探针，以免它们干扰启动探针的操作。由于应用程序在启动探针报告之前并未启动，因此没有必要让其他探针处于活动状态。
- en: Readiness probe
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 就绪探针
- en: '**Readiness probes** ascertain whether a container is ready to serve requests.
    They differ from startup probes because, unlike the startup probe, which only
    checks whether the application has started, the readiness probe ensures that the
    container can begin to process requests. A pod is ready when all the containers
    of the pod are ready. Readiness probes ensure that no traffic is sent to a pod
    if the pod is not ready. Therefore, it allows for a better user experience.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**就绪探针**用来确认容器是否准备好接受请求。它们与启动探针有所不同，因为就绪探针不仅仅检查应用程序是否已启动，它还确保容器可以开始处理请求。当 Pod
    中的所有容器都准备好时，Pod 才算是就绪。就绪探针确保在 Pod 没有准备好时不会向其发送流量。因此，它可以提供更好的用户体验。'
- en: Liveness probe
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存活探针
- en: '`restartPolicy` field of your pod to `Always` or `OnFailure`, Kubernetes will
    restart the container. Therefore, it improves the service’s reliability by detecting
    deadlocks and ensuring the containers are running instead of just reporting as
    running.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将 Pod 的 `restartPolicy` 字段设置为 `Always` 或 `OnFailure`，Kubernetes 会重新启动容器。因此，通过检测死锁并确保容器正在运行而不仅仅是报告运行状态，它提高了服务的可靠性。
- en: Now, let’s look at an example to understand probes better.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过一个例子来更好地理解探针。
- en: Probes in action
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探针实战
- en: 'Let’s improve the last manifest and add some probes to create the following
    `nginx-probe.yaml` manifest file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改进最后的清单并添加一些探针，以创建以下 `nginx-probe.yaml` 清单文件：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The manifest file contains all three probes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该清单文件包含所有三种探针：
- en: The startup probe checks whether the `/usr/share/nginx/html/index.html` file
    exists. It will continue checking it 30 times at an interval of 10 seconds until
    one of them succeeds. Once it detects the file, the startup probe will stop probing
    further.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动探针检查 `/usr/share/nginx/html/index.html` 文件是否存在。它会以 10 秒的间隔连续检查 30 次，直到其中一次检查成功。一旦检测到文件，启动探针将停止进一步检查。
- en: The readiness probe checks whether there is a listener on port `80` and responds
    with `HTTP 2xx – 3xx on path /`. It waits for 5 seconds initially and then checks
    the pod every 5 seconds. If it gets a `2xx – 3xx` response, it will report the
    container as ready and accept requests.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就绪探针检查端口 `80` 上是否有监听器，并以 `HTTP 2xx – 3xx on path /` 响应。它最初等待 5 秒，然后每 5 秒检查一次
    Pod。如果它收到 `2xx – 3xx` 响应，它会报告容器已就绪并接受请求。
- en: The liveness probe checks whether the pod responds with `HTTP 2xx – 3xx` on
    `port` `80` and `path /`. It waits for 5 seconds initially and probes the container
    every 3 seconds. Suppose, during a check, that it finds the pod not responding
    for `failureThreshold` times (this defaults to `3`). In that case, it will kill
    the container, and the kubelet will take appropriate action based on the pod’s
    `restartPolicy` field.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存活探针检查 Pod 是否在 `port` `80` 上并且 `path /` 路径下响应 `HTTP 2xx – 3xx`。它最初等待 5 秒，然后每
    3 秒检查一次容器。假设在一次检查中，它发现 Pod 未响应`failureThreshold` 次（默认为 `3`）。在这种情况下，它将杀死容器，并且 kubelet
    将根据 Pod 的 `restartPolicy` 字段采取适当的操作。
- en: 'Let’s apply the YAML file and watch the pods come to life by using the following
    command:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们应用 YAML 文件，并使用以下命令查看 Pod 的启动过程：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we can see, the pod is quickly ready from the running state. It takes approximately
    10 seconds for that to happen as the readiness probe kicks in 10 seconds after
    the pod starts. Then, the liveness probe keeps monitoring the health of the pod.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Pod 从运行状态变为就绪状态的过程非常迅速。大约需要 10 秒钟，因为就绪探针在 Pod 启动后的 10 秒开始生效。然后，存活探针继续监控
    Pod 的健康状况。
- en: Now, let’s do something that will break the liveness check. Imagine someone
    getting a shell to the container and deleting some important files. How do you
    think the liveness probe will react? Let’s have a look.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们做一些事情来破坏存活检查。假设有人通过 shell 进入容器并删除了一些重要的文件。你认为存活探针会如何反应？我们来看看。
- en: 'Let’s delete the `/usr/share/nginx/html/index.html` file from the container
    and then check how the container behaves using the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从容器中删除`/usr/share/nginx/html/index.html`文件，然后使用以下命令检查容器的行为：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, while we watch the pod, the initial delete is only detected after 9 seconds.
    That’s because of the liveness probe. It tries for 9 seconds, three times `periodSeconds`,
    since `failureThreshold` defaults to `3`, before declaring the pod as unhealthy
    and killing the container. No sooner does it kill the container than the kubelet
    restarts it as the pod’s `restartPolicy` field is set to `Always`. Then, we see
    the startup and readiness probes kicking in, and soon, the pod gets ready. Therefore,
    no matter what, your pods are reliable and will work even if a part of your application
    is faulty.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们观察 Pod 时，初次删除只有在 9 秒后才被检测到。这是因为存活探针。它尝试了 9 秒钟，也就是三次 `periodSeconds`，因为
    `failureThreshold` 默认为 `3`，才会宣布 Pod 不健康并杀死容器。容器一被杀死，kubelet 就会重新启动它，因为 Pod 的 `restartPolicy`
    字段设置为 `Always`。然后，我们看到启动和就绪探针开始生效，很快，Pod 就变为就绪状态。因此，无论发生什么情况，你的 Pod 都是可靠的，即使你的应用程序的某部分出现故障，它仍然能够正常工作。
- en: Tip
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Using readiness and liveness probes will help provide a better user experience,
    as no requests go to pods that are not ready to process any request. If your application
    does not respond appropriately, it will replace the container. If multiple pods
    are running to serve the request, your service is exceptionally resilient.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用就绪探针和存活探针有助于提供更好的用户体验，因为没有请求会发送到尚未准备好处理任何请求的 Pod。如果你的应用程序没有正确响应，它将替换容器。如果多个
    Pod 正在运行以处理请求，那么你的服务具有极强的弹性。
- en: As we discussed previously, a pod can contain one or more containers. Let’s
    look at some use cases where you might want multiple containers instead of one.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，Pod 可以包含一个或多个容器。让我们来看一些可能需要多个容器而非一个容器的使用场景。
- en: Pod multi-container design patterns
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod 多容器设计模式
- en: You can run multiple containers in pods in two ways – running a container as
    an init container or running a container as a helper container to the main container.
    We’ll explore both approaches in the following subsections.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式在 Pod 中运行多个容器——将容器作为初始化容器运行，或者将容器作为主容器的辅助容器运行。我们将在接下来的子章节中探讨这两种方法。
- en: Init containers
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化容器
- en: '**Init containers** are run before the main container is bootstrapped, so you
    can use them to initialize your container environment before the main container
    takes over. Here are some examples:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化容器**在主容器启动之前运行，因此你可以在主容器接管之前使用它们初始化容器环境。以下是一些示例：'
- en: A directory might require a particular set of ownership or permissions before
    you want to start your container using the non-root user
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用非 root 用户启动容器之前，某些目录可能需要特定的所有权或权限设置
- en: You might want to clone a Git repository before starting the web server
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启动 web 服务器之前，你可能想要克隆一个 Git 仓库
- en: You can add a startup delay
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以添加启动延迟
- en: You can generate configuration dynamically, such as for containers that want
    to dynamically connect to some other pod that it is not aware of during build
    time but should be during runtime
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以动态生成配置，例如针对那些在构建时不知道但在运行时应该知道的容器，它们可能需要动态连接到其他某个 pod。
- en: Tip
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Use init containers only as a last resort, as they hamper the startup time of
    your containers. Try to bake the configuration within your container image or
    customize it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 仅将 init 容器作为最后手段使用，因为它们会拖慢容器的启动时间。尽量在容器镜像内预先配置或定制它。
- en: Now, let’s look at an example to see init containers in action.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个示例，了解 init 容器的实际应用。
- en: 'To access the resources for this section, `cd` into the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此部分的资源，`cd` 进入以下路径：
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let’s serve the `example.com` website from our `nginx` web server. We will get
    the `example.com` web page and save it as `index.html` in the `nginx` default
    HTML directory before starting `nginx`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `nginx` web 服务器提供 `example.com` 网站。在启动 `nginx` 之前，我们将获取 `example.com`
    网页并将其保存为 `index.html` 到 `nginx` 默认的 HTML 目录中。
- en: 'Access the manifest file, `nginx-init.yaml`, which should contain the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 访问清单文件 `nginx-init.yaml`，它应包含以下内容：
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we look at the `spec` section of the manifest file, we’ll see the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看清单文件的 `spec` 部分，我们会看到以下内容：
- en: '`containers`: This section defines one or more containers that form the pod.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers`：此部分定义了一个或多个构成 pod 的容器。'
- en: '`containers.name`: This is the container’s name, which is `nginx-container`
    in this case.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers.name`：这是容器的名称，在这种情况下是 `nginx-container`。'
- en: '`containers.image`: This is the container image, which is `nginx` in this case.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers.image`：这是容器镜像，在这种情况下是 `nginx`。'
- en: '`containers.volumeMounts`: This defines a list of volumes that should be mounted
    to the container. It is similar to the volumes we read about in [*Chapter 4*](B19877_04.xhtml#_idTextAnchor399),
    *Creating and Managing* *Container Images*.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers.volumeMounts`：这定义了应挂载到容器的卷列表。它类似于我们在 [*第4章*](B19877_04.xhtml#_idTextAnchor399)
    中学习的内容，*创建和管理容器镜像*。'
- en: '`containers.volumeMounts.mountPath`: This defines the path to mount the volume
    on, which is `/usr/share/nginx/html` in this case. We will share this volume with
    the init container so that when the init container downloads the `index.html`
    file from `example.com`, this directory will contain the same file.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers.volumeMounts.mountPath`：这定义了挂载卷的路径，在这种情况下是 `/usr/share/nginx/html`。我们将与
    init 容器共享这个卷，以便当 init 容器从 `example.com` 下载 `index.html` 文件时，这个目录中会包含相同的文件。'
- en: '`containers.volumeMounts.name`: This is the name of the volume, which is `html-volume`
    in this case.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`containers.volumeMounts.name`：这是卷的名称，在这种情况下是 `html-volume`。'
- en: '`initContainers`: This section defines one or more init containers that run
    before the main containers.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initContainers`：此部分定义了一个或多个在主容器之前运行的 init 容器。'
- en: '`initContainers.name`: This is the init container’s name, which is `init-nginx`
    in this case.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initContainers.name`：这是 init 容器的名称，在这种情况下是 `init-nginx`。'
- en: '`initContainers.image`: This is the init container image, which is `busybox:1.28`
    in this case.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initContainers.image`：这是 init 容器的镜像，在这种情况下是 `busybox:1.28`。'
- en: '`initContainers.command`: This is the command that the busybox should execute.
    In this case, `''mkdir -p /usr/share/nginx/html && wget -O /usr/share/nginx/html/index.html`
    [http://example.com](http://example.com)`''` will download the content of `example.com`
    to the `/``usr/share/nginx/html` directory.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initContainers.command`：这是 busybox 应执行的命令。在这种情况下，`''mkdir -p /usr/share/nginx/html
    && wget -O /usr/share/nginx/html/index.html [http://example.com](http://example.com)''`
    将下载 `example.com` 的内容到 `/usr/share/nginx/html` 目录。'
- en: '`initContainers.volumeMounts`: We will mount the same volume we defined in
    `nginx-container` on this container. So, anything we save in this volume will
    automatically appear in `nginx-container`.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initContainers.volumeMounts`：我们将在此容器上挂载与 `nginx-container` 中定义的相同的卷。因此，我们在该卷中保存的任何内容都会自动出现在
    `nginx-container` 中。'
- en: '`initContainers.volumeMounts.mountPath`: This defines the path to mount the
    volume on, which is `/usr/share/nginx/html` in this case.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initContainers.volumeMounts.mountPath`：这定义了挂载卷的路径，在这种情况下是 `/usr/share/nginx/html`。'
- en: '`initContainers.volumeMounts.name`: This is the name of the volume, which is
    `html-volume` in this case.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initContainers.volumeMounts.name`：这是卷的名称，在本例中是 `html-volume`。'
- en: '`volumes`: This section defines one or more volumes associated with the pod’s
    containers.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes`：此部分定义了与 Pod 容器相关联的一个或多个卷。'
- en: '`volumes.name`: This is the volume’s name, which is `html-volume` in this case.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes.name`：这是卷的名称，在本例中是 `html-volume`。'
- en: '`volumes.emptyDir`: This defines an `emptyDir` volume. It is similar to a `tmpfs`
    volume in Docker. Therefore, it is not persistent and lasts just for the container’s
    lifetime.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes.emptyDir`：这定义了一个 `emptyDir` 卷。它类似于 Docker 中的 `tmpfs` 卷，因此它不是持久的，只在容器的生命周期内存在。'
- en: 'So, let’s go ahead and apply the manifest and watch the pod come to life using
    the following commands:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们继续应用清单，并使用以下命令观察 Pod 的启动过程：
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Initially, we can see that the `nginx` pod shows a status of `Init:0/1`. This
    means that `0` out of `1` init containers have started initializing. After some
    time, we can see that the pod reports its status, `PodInitializing`, which means
    that the init containers have started running. The pod reports a running status
    once the init containers have run successfully.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，我们可以看到 `nginx` Pod 显示状态为 `Init:0/1`。这意味着 `1` 个初始化容器中有 `0` 个开始初始化。过了一段时间后，我们可以看到
    Pod 报告其状态为 `PodInitializing`，这意味着初始化容器已经开始运行。初始化容器成功运行后，Pod 报告为运行状态。
- en: 'Now, once the pod starts to run, we can port-forward the container from port
    `80` to host port `8080` using the following command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦 Pod 开始运行，我们可以使用以下命令将容器的端口 `80` 转发到主机端口 `8080`：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open a duplicate Terminal and try to `curl` the localhost on port `8080` by
    using the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端窗口，尝试通过以下命令使用 `curl` 访问本地主机的端口 `8080`：
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we can see the example domain response from our web server. This means
    that the init container worked perfectly fine.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到来自我们 web 服务器的示例域响应。这意味着初始化容器工作正常。
- en: As you may have understood by now, the life cycle of init containers ends before
    the primary containers start, and a pod can contain one or more main containers.
    So, let’s look at a few design patterns we can use in the main container.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能已经理解的那样，初始化容器的生命周期在主容器启动之前结束，一个 Pod 可以包含一个或多个主容器。接下来，我们来看看我们可以在主容器中使用的一些设计模式。
- en: The ambassador pattern
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大使模式
- en: The `localhost` everywhere.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`localhost` 在任何地方。'
- en: 'Now, there are two approaches you can take:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以采取两种方法：
- en: You can change the application code and use config maps and secrets (more on
    these later) to inject the database connection details into the environment variable.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以更改应用程序代码，并使用配置映射和机密（稍后会详细介绍）将数据库连接详情注入到环境变量中。
- en: You can keep using the existing code and use a second container as a TCP proxy
    to the Redis database. The TCP proxy will link with the config map and secrets
    and contain the Redis database’s connection details.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以继续使用现有代码，并使用第二个容器作为 Redis 数据库的 TCP 代理。该 TCP 代理将与配置映射和机密连接，并包含 Redis 数据库的连接详情。
- en: Tip
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The ambassador pattern helps developers focus on the application without worrying
    about the configuration details. Consider using it if you want to decouple application
    development from config management.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 大使模式帮助开发人员专注于应用程序，而不必担心配置细节。如果你想将应用程序开发与配置管理解耦，可以考虑使用它。
- en: 'The second approach solves our problem if we wish to do a like-for-like migration.
    We can use config maps to define the environment-specific configuration without
    changing the application code. The following diagram shows this approach:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法解决了我们希望进行完全相同迁移的问题。我们可以使用配置映射来定义特定环境的配置，而无需更改应用程序代码。以下图示展示了这种方法：
- en: '![Figure 5.4 – The ambassador pattern](img/B19877_05_4.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 大使模式](img/B19877_05_4.jpg)'
- en: Figure 5.4 – The ambassador pattern
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 大使模式
- en: Before we delve into the technicalities, let’s understand a config map.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入技术细节之前，我们先了解一下配置映射。
- en: Config map
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置映射
- en: A **config map** contains key-value pairs that we can use for various purposes,
    such as defining environment-specific properties or injecting an external variable
    at container startup or during runtime.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**配置映射** 包含键值对，我们可以用于多种目的，例如定义特定环境的属性，或者在容器启动时或运行时注入外部变量。'
- en: The idea of the config map is to decouple the application with configuration
    and to externalize configuration at a Kubernetes level. It is similar to using
    a properties file, for example, to define the environment-specific configuration.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 配置映射的理念是将应用程序与配置解耦，并在Kubernetes层次上外部化配置。这类似于使用属性文件，例如，定义特定环境的配置。
- en: 'The following diagram explains this beautifully:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表对此进行了很好的解释：
- en: '![Figure 5.5 – Config maps](img/B19877_05_5.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5 – 配置映射](img/B19877_05_5.jpg)'
- en: Figure 5.5 – Config maps
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5 – 配置映射
- en: We will use `ConfigMap` to define the connection properties of the external
    Redis database within the ambassador container.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ConfigMap`在代理容器内定义外部Redis数据库的连接属性。
- en: Example application
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例应用程序
- en: 'We will use the example application we used in [*Chapter 3*](B19877_03.xhtml#_idTextAnchor220),
    *Containerization with Docker*, in the *Deploying a sample application with Docker
    Compose* section. The source code has been replicated into the following directory:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在[*第3章*](B19877_03.xhtml#_idTextAnchor220)中使用的示例应用程序，*使用Docker进行容器化*，以及*使用Docker
    Compose部署示例应用程序*部分。源代码已复制到以下目录：
- en: '[PRE44]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can visualize the `app.py` file of the Flask application, the `requirements.txt`
    file, and the Dockerfile to understand what the application does.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看Flask应用程序的`app.py`文件、`requirements.txt`文件和Dockerfile，以了解该应用程序的功能。
- en: 'Now, let’s build the container using the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令构建容器：
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s push it to our container registry using the following command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令将其推送到我们的容器注册表：
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you may have noticed, the `app.py` code defines the cache as `localhost:6379`.
    We will run an ambassador container on `localhost:6379`. The proxy will tunnel
    the connection to the `redis` pod running elsewhere.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能注意到的，`app.py`代码将缓存定义为`localhost:6379`。我们将在`localhost:6379`上运行一个代理容器。代理将把连接隧道转发到其他地方运行的`redis`
    Pod。
- en: 'First, let’s create the `redis` pod using the following command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令创建`redis` Pod：
- en: '[PRE47]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let’s expose the `redis` pod to the cluster resources via a `Service`
    resource. This will allow any pod within the cluster to communicate with the `redis`
    pod using the `redis` hostname. We will discuss Kubernetes `Service` resources
    in the next chapter in detail:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过`Service`资源将`redis` Pod暴露给集群资源。这将允许集群中的任何Pod通过`redis`主机名与`redis` Pod进行通信。我们将在下一章详细讨论Kubernetes
    `Service`资源：
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Cool! Now that the pod and the `Service` resource are up and running, let’s
    work on the ambassador pattern.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 酷！现在Pod和`Service`资源已经启动并运行，让我们来处理代理模式。
- en: We need to define two config maps first. The first describes the `redis` host
    and port details, while the second defines the template `nginx.conf` file to work
    as a reverse proxy.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要定义两个配置映射。第一个描述`redis`主机和端口信息，第二个定义作为反向代理工作的模板`nginx.conf`文件。
- en: 'The `redis-config-map.yaml` file looks like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis-config-map.yaml`文件如下所示：'
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding YAML file defines a config map called `redis-config` that contains
    `host` and `port` properties. You can have multiple config maps, one for each
    environment.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的YAML文件定义了一个名为`redis-config`的配置映射，其中包含`host`和`port`属性。你可以拥有多个配置映射，每个环境一个。
- en: 'The `nginx-config-map.yaml` file looks as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`nginx-config-map.yaml`文件如下所示：'
- en: '[PRE50]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This config map injects the `nginx.conf` template as a config map value. This
    template defines the configuration of our ambassador pod to listen on `localhost:6379`
    and tunnel the connection to `REDIS_HOST:REDIS_PORT`. As the `REDIS_HOST` and
    `REDIS_PORT` values are placeholders, we must fill these up with the correct values
    that we obtained from the `redis-config` config map. To do that, we can mount
    this file to a volume and then manipulate it. We can use `initContainer` to initialize
    the proxy with the correct configuration.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置映射将`nginx.conf`模板作为配置映射值注入。此模板定义了我们的代理Pod配置，使其监听`localhost:6379`并将连接隧道转发到`REDIS_HOST:REDIS_PORT`。由于`REDIS_HOST`和`REDIS_PORT`值是占位符，我们必须用从`redis-config`配置映射中获得的正确值填充这些占位符。为此，我们可以将此文件挂载到一个卷上，然后进行操作。我们可以使用`initContainer`来使用正确的配置初始化代理。
- en: 'Now, let’s look at the pod configuration manifest, `flask-ambassador.yaml`.
    There are multiple parts of this YAML file. Let’s look at the `containers` section
    first:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们查看Pod配置清单`flask-ambassador.yaml`。该YAML文件包含多个部分。首先，让我们看看`containers`部分：
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This section contains a container called `flask-app` that uses the `<your_dockerhub_user>/flask-redis`
    image that we built in the previous section. The second container is the `nginx-ambassador`
    container that will act as the proxy to `redis`. Therefore, we have mounted the
    `/etc/nginx` directory on a volume. This volume is also mounted on the init container
    to generate the required configuration before `nginx` boots up.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含一个名为`flask-app`的容器，它使用我们在上一节中构建的`<your_dockerhub_user>/flask-redis`镜像。第二个容器是`nginx-ambassador`容器，它将充当代理与`redis`通信。因此，我们已将`/etc/nginx`目录挂载到一个卷中。此卷也挂载在初始化容器中，用于在`nginx`启动之前生成所需的配置。
- en: 'The following is the `initContainers` section:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`initContainers`部分：
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This section defines a `busybox` container – `init-nginx`. The container needs
    to generate the `nginx-ambassador` proxy configuration to communicate with Redis;
    therefore, two environment variables are present. Both environment variables are
    sourced from the `redis-config` config map. Apart from that, we have also mounted
    the `nginx.conf` file from the `nginx-config` config map. The `command` section
    within the init container uses the environment variables to replace placeholders
    within the `nginx.conf` file, after which we get a TCP proxy to the Redis backend.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 本节定义了一个`busybox`容器——`init-nginx`。该容器需要生成与 Redis 通信的`nginx-ambassador`代理配置；因此，存在两个环境变量。这两个环境变量来自`redis-config`配置映射。此外，我们还从`nginx-config`配置映射中挂载了`nginx.conf`文件。初始化容器中的`command`部分使用这些环境变量替换`nginx.conf`文件中的占位符，之后我们就得到了与
    Redis 后端的 TCP 代理。
- en: 'The `volumes` section defines `nginx-volume` as an `emptyDir` volume, and the
    `config` volume is mounted from the `nginx.conf` file present in the `nginx-config`
    config map:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumes`部分将`nginx-volume`定义为一个`emptyDir`卷，并将`config`卷挂载到`nginx.conf`文件，该文件位于`nginx-config`配置映射中：'
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, let’s start applying the YAML files in steps.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始分步应用 YAML 文件。
- en: 'Apply both of the config maps using the following commands:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用两个配置映射：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s apply the pod configuration using the following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用 pod 配置：
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Get the pod to see whether the configuration is correct by using the following
    command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令获取 pod 查看配置是否正确：
- en: '[PRE56]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As the pod is running successfully now, let’s port-forward `5000` to the localhost
    for some tests by using the following command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 pod 现在运行正常，让我们通过以下命令将`5000`端口转发到本地主机以进行一些测试：
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, open a duplicate Terminal and try to `curl` on `localhost:5000` using
    the following command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开一个新的终端，并使用以下命令尝试在`localhost:5000`上进行`curl`测试：
- en: '[PRE58]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we can see, every time we `curl` the application, we get the last visited
    time on our screen. The ambassador pattern is working.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，每次执行`curl`请求时，都会在屏幕上显示最后一次访问时间。Ambassador 模式正在正常工作。
- en: This was a simple example of the ambassador pattern. There are advanced configurations
    you can do to add fine-grained control on how your application should interact
    with the outside world. You can use the ambassador pattern to secure traffic that
    moves from your containers. It also simplifies application development for your
    development team as they need not worry about these nuances. In contrast, the
    operations team can use these containers to manage your environment in a better
    way without stepping on each other’s toes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 Ambassador 模式示例。你可以进行更高级的配置，以细粒度控制你的应用如何与外界交互。你可以使用 Ambassador 模式来保护从容器传输的流量。它还简化了应用开发过程，开发团队无需担心这些细节。而运维团队可以使用这些容器更好地管理环境，而不必互相干扰。
- en: Tip
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As the ambassador pattern adds some overhead as you tunnel connections via a
    proxy, you should only use it if the management benefits outweigh the extra cost
    you incur because of the ambassador container.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Ambassador 模式通过代理隧道连接会增加一些开销，因此只有在管理上的好处超过因使用 Ambassador 容器而产生的额外成本时，才应使用此模式。
- en: Now, let’s look at another multi-container pod pattern – sidecars.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下另一种多容器 pod 模式——sidecar 模式。
- en: The sidecar pattern
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sidecar 模式
- en: '**Sidecars** derive their names from motorcycle sidecars. The sidecar does
    not change the bike’s core functionality and can work perfectly without it. Instead,
    it adds an extra seat, a functionality that helps you give an additional person
    a ride. Similarly, sidecars in a pod are helper containers that provide functionalities
    unrelated to the main container’s core functionality and enhance it instead. Examples
    include logging and monitoring containers. Keeping a separate container for logging
    will help decouple the logging responsibilities from your main container, which
    will help you monitor your application even when the main container goes down
    for some reason.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**旁车**这个名字来源于摩托车的副驾驶厢。旁车并不会改变摩托车的核心功能，而且没有旁车，摩托车也能正常运行。旁车只是增加了一个额外的座位，提供一个功能，帮助你载一个额外的人。类似地，Pod
    中的旁车是提供与主容器核心功能无关的辅助容器，增强主容器的功能。例如，日志记录和监控容器。将日志单独放入一个容器，有助于将日志职责与主容器解耦，从而即使主容器因为某些原因宕机时，你也能继续监控你的应用程序。'
- en: It also helps if there is some issue with the logging code, and instead of the
    entire application going down, only the logging container is impacted. You can
    also use sidecars to keep helper or related containers together with the main
    container since we know containers within the pod share the same machine.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果日志代码出现问题，并且不会导致整个应用程序崩溃，而只是影响日志容器，这时使用这种方式会很有帮助。你还可以使用旁车（sidecar）将辅助或相关容器与主容器放在一起，因为我们知道，同一个
    Pod 内的容器共享同一台机器。
- en: Tip
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Only use multi-container pods if two containers are functionally related and
    work as a unit.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在两个容器功能上有直接关系并且作为一个整体工作时，才使用多容器 Pod。
- en: 'You can also use sidecars to segregate your application with secrets. For example,
    if you are running a web application that needs access to specific passwords to
    operate, it would be best to mount the secrets to a sidecar and let the sidecar
    provide the passwords to the web application via a link. This is because if someone
    gains access to your application container’s filesystem, they cannot get hold
    of your passwords as another container is responsible for sourcing it, as shown
    in the following diagram:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用旁车将应用程序与秘密数据隔离开。例如，如果你正在运行一个需要访问特定密码才能运行的 Web 应用程序，最好将秘密数据挂载到旁车容器上，并通过旁车容器将密码提供给
    Web 应用程序。这是因为如果有人访问了你的应用程序容器的文件系统，他们是无法获取到密码的，因为密码是由另一个容器提供的，具体如下面的图所示：
- en: '![Figure 5.6 – The sidecar pattern](img/B19877_05_6.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 旁车模式](img/B19877_05_6.jpg)'
- en: Figure 5.6 – The sidecar pattern
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 旁车模式
- en: Let’s implement the preceding pattern to understand a sidecar better. We have
    a Flask application that interacts with a Redis sidecar. We will pre-populate
    the Redis sidecar with a secret `foobar`, and we will do that by using the Kubernetes
    secret resource.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现前面的模式来更好地理解旁车。我们有一个与 Redis 旁车交互的 Flask 应用程序。我们将使用 Kubernetes 的 Secret 资源将一个名为
    `foobar` 的秘密预先填充到 Redis 旁车中。
- en: Secrets
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 秘密
- en: '`base64`-encoded instead of `plaintext`. While `base64` encoding does not make
    any difference, and it is as bad as `plaintext` from a security standpoint, you
    should use secrets for sensitive information such as passwords. That is because
    the Kubernetes community will develop a solution to tighten the security around
    secrets in future releases. If you use secrets, you will directly benefit from
    it.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `base64` 编码而不是 `plaintext`。虽然从安全角度来看，`base64` 编码并不会提供比 `plaintext` 更好的保护，但你应当使用秘密存储敏感信息，如密码。因为
    Kubernetes 社区会在未来的版本中开发解决方案，加强对秘密数据的安全保护。如果你使用秘密存储，你将直接受益于这些改进。
- en: Tip
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As a rule of thumb, always use secrets for confidential data, such as API keys
    and passwords, and config maps for non-sensitive configuration data.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，始终使用秘密存储机密数据，如 API 密钥和密码，而配置映射则用于存储非敏感的配置数据。
- en: 'To access the files for this section, go to the following directory:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的文件，请前往以下目录：
- en: '[PRE59]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, let’s move on to the example Flask application.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续看一下示例 Flask 应用程序。
- en: Example application
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例应用程序
- en: The Flask application queries a Redis sidecar for the secret and sends that
    as a response. That is not ideal, as you won’t send secrets back as a response,
    but for this demo, let’s go ahead with that.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 应用程序查询 Redis 旁车以获取密钥并将其作为响应返回。这样做并不理想，因为你不应该将秘密数据作为响应返回，但为了演示的目的，我们就照这样做。
- en: So, first, let’s design our sidecar so that it pre-populates data within the
    container after it starts.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，首先，让我们设计我们的旁车容器，让它在启动后预填充容器内的数据。
- en: 'We need to create a secret named `secret` with a value of `foobar`. Now, `base64-`encode
    the Redis command to set the secret into the cache by running the following command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为 `secret` 的密钥，其值为 `foobar`。现在，通过运行以下命令将 Redis 命令进行 `base64` 编码，将密钥设置到缓存中：
- en: '[PRE60]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that we have the `base64`-encoded secret, we can create a `redis-secret.yaml`
    manifest with the string as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `base64` 编码的密钥，我们可以创建一个名为 `redis-secret.yaml` 的清单，并按照以下字符串创建：
- en: '[PRE61]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we need to build the Redis container so that this secret is created at
    startup. To access the files for this section, go to the following directory:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要构建 Redis 容器，以便在启动时创建此密钥。要访问本节的文件，请转到以下目录：
- en: '[PRE62]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create an `entrypoint.sh` file, as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `entrypoint.sh` 文件，如下所示：
- en: '[PRE63]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The shell script looks for a file, `init.redis`, within the `/redis-master`
    directory and runs the `redis-cli` command on it. This means the cache will be
    pre-populated with the values defined in our secret, provided we mount the secret
    as `/redis-master/init.redis`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本查找 `/redis-master` 目录中的文件 `init.redis`，并在其上运行 `redis-cli` 命令。这意味着缓存将使用我们的密钥中定义的值进行预填充，前提是我们将密钥作为
    `/redis-master/init.redis` 挂载。
- en: 'Then, we must create a Dockerfile that will use this `entrypoint.sh` script,
    as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须创建一个 Dockerfile，该文件将使用这个 `entrypoint.sh` 脚本，如下所示：
- en: '[PRE64]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now that we are ready, we can build and push the code to Docker Hub:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好了，可以构建并将代码推送到 Docker Hub：
- en: '[PRE65]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now that we are ready with the Redis image, we must build the Flask application
    image. To access the files for this section, `cd` into the following directory:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了 Redis 镜像，我们必须构建 Flask 应用程序镜像。要访问本节的文件，请`cd`进入以下目录：
- en: '[PRE66]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let’s look at the `app.py` file first:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先查看 `app.py` 文件：
- en: '[PRE67]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The code is simple – it gets the secret from the cache and returns that in the
    response.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单——它从缓存中获取密钥并将其作为响应返回。
- en: We also created the same Dockerfile that we did in the previous section.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了与上一节相同的 Dockerfile。
- en: 'So, let’s build and push the container image to Docker Hub:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们构建并将容器镜像推送到 Docker Hub：
- en: '[PRE68]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now that our images are ready, let’s look at the pod manifest, `flask-sidecar.yaml`,
    which is present in the `~/``modern-devops/ch5/multi-container-pod/sidecar/` directory:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的镜像准备好了，让我们看看 Pod 清单，`flask-sidecar.yaml`，该清单位于 `~/``modern-devops/ch5/multi-container-pod/sidecar/`
    目录中：
- en: '[PRE69]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The pod defines two containers – `flask-app` and `redis-sidecar`. The `flask-app`
    container runs the Flask application that will interact with `redis-sidecar` for
    the secret. The `redis-sidecar` container has mounted the `secret` volume on `/redis-master`.
    The pod definition also contains a single volume called `secret`, and the volume
    points to the `redis-secret` secret and mounts that as a file, `init.redis`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 定义了两个容器——`flask-app` 和 `redis-sidecar`。`flask-app` 容器运行 Flask 应用程序，该应用程序将与
    `redis-sidecar` 交互以获取密钥。`redis-sidecar` 容器已将 `secret` 卷挂载到 `/redis-master`。Pod
    定义还包含一个名为 `secret` 的单个卷，卷指向 `redis-secret` 密钥，并将其作为文件 `init.redis` 挂载。
- en: So, in the end, we have a file, `/redis-master/init.redis`, and, as we know,
    the `entrypoint.sh` script looks for this file and runs the `redis-cli` command
    to pre-populate the Redis cache with the secret data.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最后，我们有一个文件 `/redis-master/init.redis`，正如我们所知，`entrypoint.sh` 脚本查找此文件并运行 `redis-cli`
    命令，以预填充 Redis 缓存中的秘密数据。
- en: 'Let’s apply the secret first using the following command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用以下命令应用这个密钥：
- en: '[PRE70]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, we can apply the `flask-sidecar.yaml` file using the following command:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令应用 `flask-sidecar.yaml` 文件：
- en: '[PRE71]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, let’s get the pods using the following command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令获取 Pod：
- en: '[PRE72]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As the pod is running, it’s time to port-forward it to the host using the following
    command:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Pod 正在运行，现在是时候使用以下命令将其端口转发到主机：
- en: '[PRE73]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, let’s open a duplicate Terminal, run the `curl localhost:5000` command,
    and see what we get:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开一个重复的终端，运行 `curl localhost:5000` 命令，并看看我们得到了什么：
- en: '[PRE74]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As we can see, we get the secret, `foobar`, in the response. The sidecar is
    working correctly!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们在响应中得到了密钥 `foobar`。边车工作正常！
- en: Now, let’s look at another popular multi-container pod pattern – the adapter
    pattern.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们先看另一个流行的多容器 Pod 模式——适配器模式。
- en: The adapter pattern
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配器模式
- en: 'As its name suggests, the **adapter pattern** helps change something to fit
    a standard, such as cell phones and laptop adapters, which convert our main power
    supply into something our devices can digest. A great example of the adapter pattern
    is transforming log files so that they fit an enterprise standard and feed your
    log analytics solution:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，**适配器模式**有助于将某些事物转换为符合标准的形式，比如手机和笔记本电脑的适配器，它们将我们的主要电源转换为设备可以使用的形式。适配器模式的一个很好的例子是转换日志文件，使其符合企业标准，并将其传输到你的日志分析解决方案中：
- en: '![Figure 5.7 – The adapter pattern](img/B19877_05_7.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 适配器模式](img/B19877_05_7.jpg)'
- en: Figure 5.7 – The adapter pattern
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 适配器模式
- en: 'It helps when you have a heterogeneous solution outputting log files in several
    formats but a single log analytics solution that only accepts messages in a particular
    format. There are two ways of doing this: changing the code for outputting log
    files in a standard format or using an adapter container to execute the transformation.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个异构解决方案输出多种格式的日志文件，但却只有一个日志分析解决方案，它只接受特定格式的消息时，这时就会有所帮助。实现这一目标有两种方法：一种是更改输出日志文件的代码以符合标准格式，另一种是使用适配器容器来执行转换。
- en: Let’s look at the following scenario to understand it further.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下场景进一步理解它。
- en: We have an application that continuously outputs log files without a date at
    the beginning. Our adapter should read the stream of logs and append the timestamp
    as soon as a logline is generated.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个应用程序，它不断输出没有日期前缀的日志文件。我们的适配器应该读取日志流，并在每次生成日志行时添加时间戳。
- en: 'For this, we will use the following pod manifest, `app-adapter.yaml`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用以下的 pod 清单文件，`app-adapter.yaml`：
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The pod contains two containers – the app container, which is a simple Ubuntu
    container that outputs `This is a log line` every 2 seconds, and the log adapter,
    which continuously tails the `app.log` file, adds a timestamp at the beginning
    of the line, and sends the resulting output to `/var/log/out.log`. Both containers
    share the `/var/log` volume, which is mounted as an `emptyDir` volume on both
    containers.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 该 pod 包含两个容器 —— 应用容器，它是一个简单的 Ubuntu 容器，每 2 秒输出一次 `This is a log line`，以及日志适配器容器，它持续地跟踪
    `app.log` 文件，在每一行的开头添加时间戳，并将结果输出到 `/var/log/out.log`。这两个容器共享 `/var/log` 卷，该卷作为
    `emptyDir` 卷挂载在两个容器中。
- en: 'Now, let’s apply this manifest using the following command:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令应用这个清单：
- en: '[PRE76]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let’s wait a while and check whether the pod is running by using the following
    command:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们等一会儿，通过以下命令检查 pod 是否在运行：
- en: '[PRE77]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As the pod is running, we can now get a shell into the log adapter container
    by using the following command:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 当 pod 正在运行时，我们现在可以通过以下命令进入日志适配器容器的 shell：
- en: '[PRE78]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When we get into the shell, we can `cd` into the `/var/log` directory and list
    its contents using the following command:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进入 shell 后，可以通过以下命令`cd`到`/var/log`目录，并列出其中的内容：
- en: '[PRE79]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As we can see, we get `app.log` and `out.log` as two files. Now, let’s use the
    `cat` command to print both of them to see what we get.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们得到了`app.log`和`out.log`这两个文件。现在，让我们使用`cat`命令打印它们，看看会得到什么。
- en: 'First, `cat` the `app.log` file using the following command:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令`cat` `app.log`文件：
- en: '[PRE80]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we can see that a series of log lines are being printed.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一系列的日志行正在被打印。
- en: 'Now, `cat` the `out.log` file to see what we get using the following command:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令`cat` `out.log`文件，看看会得到什么：
- en: '[PRE81]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here, we can see timestamps in front of the log line. This means that the adapter
    pattern is working correctly. You can then export this log file to your log analytics
    tool.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到日志行前面有时间戳。这意味着适配器模式正常工作。然后，你可以将此日志文件导出到你的日志分析工具中。
- en: Summary
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have reached the end of this critical chapter. We’ve covered enough ground
    to get you started with Kubernetes and understand and appreciate the best practices
    surrounding it.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了这一关键章节的内容。我们已经涵盖了足够的内容，能够帮助你入门 Kubernetes，并理解并重视其最佳实践。
- en: We started with Kubernetes and why we need it and then discussed bootstrapping
    a Kubernetes cluster using Minikube and KinD. Then, we looked at the pod resource
    and discussed creating and managing pods, troubleshooting them, ensuring your
    application’s reliability using probes, and multi-container design patterns to
    appreciate why Kubernetes uses pods in the first place instead of containers.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Kubernetes 及其必要性开始，然后讨论了使用 Minikube 和 KinD 引导 Kubernetes 集群。接着，我们了解了 pod
    资源，讨论了如何创建和管理 pod，排除故障，确保应用程序的可靠性（使用探针），以及多容器设计模式，深入理解为什么 Kubernetes 使用 pod 而不是单纯的容器。
- en: In the next chapter, we will deep dive into the advanced aspects of Kubernetes
    by covering controllers, services, ingresses, managing a stateful application,
    and Kubernetes command-line best practices.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨 Kubernetes 的高级方面，涵盖控制器、服务、入口、管理有状态应用程序以及 Kubernetes 命令行最佳实践。
- en: Questions
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答以下问题，测试你对本章的知识掌握情况：
- en: All communication with Kubernetes happens via which of the following?
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与 Kubernetes 的所有通信通过以下哪一项进行？
- en: A. Kubelet
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. Kubelet
- en: B. API server
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. API 服务器
- en: C. Etcd
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Etcd
- en: D. Controller manager
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 控制器管理器
- en: E. Scheduler
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: E. 调度器
- en: Which of the following is responsible for ensuring that the cluster is in the
    desired state?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个负责确保集群处于期望状态？
- en: A. Kubelet
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. Kubelet
- en: B. API server
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. API 服务器
- en: C. Etcd
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Etcd
- en: D. Controller manager
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 控制器管理器
- en: E. Scheduler
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: E. 调度器
- en: Which of the following is responsible for storing the desired state of the cluster?
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个负责存储集群的期望状态？
- en: A. Kubelet
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. Kubelet
- en: B. API server
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. API 服务器
- en: C. Etcd
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Etcd
- en: D. Controller manager
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 控制器管理器
- en: E. Scheduler
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: E. 调度器
- en: A pod can contain more than one container. (True/False)
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pod 可以包含多个容器。（正确/错误）
- en: You can use port-forwarding for which of the following use cases? (Choose two)
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用端口转发来处理以下哪些使用场景？（选择两项）
- en: A. For troubleshooting a misbehaving pod
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 用于故障排除行为异常的 Pod
- en: B. For exposing a service to the internet
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 用于将服务暴露到互联网
- en: C. For accessing a system service such as the Kubernetes dashboard
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 用于访问系统服务，例如 Kubernetes 仪表盘
- en: Using a combination of which two probes can help you ensure that your application
    is reliable even when your application has some intermittent issues? (Choose two.)
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 结合使用以下哪两种探针可以帮助确保即使应用程序有一些间歇性问题时，它仍然可靠？（选择两项）
- en: A. Startup probe
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 启动探针
- en: B. Liveness probe
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 存活探针
- en: C. Readiness probe
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 就绪探针
- en: We may use KinD in production. (True/False)
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在生产环境中使用 KinD。（正确/错误）
- en: Which of the following multi-container patterns is used as a forward proxy?
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个多容器模式用于作为前向代理？
- en: A. Ambassador
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 使者容器
- en: B. Adapter
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 适配器
- en: C. Sidecar
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 边车容器
- en: D. Init containers
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 初始化容器
- en: Answers
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的答案：
- en: B
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: D
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: D
- en: C
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: 'True'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: A, C
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, C
- en: B, C
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: B, C
- en: 'False'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: A
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A
