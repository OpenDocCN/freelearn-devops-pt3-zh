- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Container Orchestration with Kubernetes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行容器编排
- en: In the previous chapter, we covered creating and managing container images,
    where we discussed container images, Dockerfiles, and their directives and components.
    We also looked at the best practices for writing a Dockerfile and building and
    managing efficient images. We then looked at flattening Docker images and investigated
    in detail distroless images to improve container security. Finally, we created
    a private Docker registry.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了创建和管理容器镜像的内容，讨论了容器镜像、Dockerfile及其指令和组件。我们还讨论了编写Dockerfile的最佳实践，以及如何构建和管理高效的镜像。接着，我们探讨了扁平化Docker镜像，并详细研究了无发行版镜像，以提高容器安全性。最后，我们创建了一个私有Docker注册中心。
- en: Now, we will deep dive into container orchestration. We will learn how to schedule
    and run containers using the most popular container orchestrator – Kubernetes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深入探讨容器编排。我们将学习如何使用最流行的容器编排工具——Kubernetes，来调度和运行容器。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: What is Kubernetes, and why do I need it?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Kubernetes，为什么我需要它？
- en: Kubernetes architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes架构
- en: Installing Kubernetes (Minikube and KinD)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Kubernetes（Minikube和KinD）
- en: Understanding Kubernetes pods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Kubernetes Pod
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we assume you have Docker installed on a Linux machine running
    `sudo` access. You can follow [*Chapter 3*](B19877_03.xhtml#_idTextAnchor220),
    *Containerization with Docker*, for more details on how to do that.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章假设您已在具有 `sudo` 权限的Linux机器上安装了Docker。您可以参考[*第三章*](B19877_03.xhtml#_idTextAnchor220)，*使用Docker容器化*，获取更多关于如何操作的细节。
- en: 'You will also need to clone the following GitHub repository for some exercises:
    [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要克隆以下GitHub存储库以进行一些练习：[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)。
- en: 'Run the following command to clone the repository into your home directory,
    and `cd` into the `ch5` directory to access the required resources:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将存储库克隆到您的主目录，并使用 `cd` 进入 `ch5` 目录以访问所需的资源：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As the repository contains files with placeholders, you must replace the `<your_dockerhub_user>`
    string with your actual Docker Hub user. Use the following commands to substitute
    the placeholders:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该存储库包含带占位符的文件，因此您必须将 `<your_dockerhub_user>` 字符串替换为您实际的Docker Hub用户名。请使用以下命令来替换占位符：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What is Kubernetes, and why do I need it?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Kubernetes，为什么我需要它？
- en: 'By now, you should understand what containers are and how to build and run
    containers using Docker. However, how we ran containers using Docker was not optimal
    from a production standpoint. Let me give you a few considerations to think about:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您应该了解容器是什么以及如何使用Docker构建和运行容器。然而，我们使用Docker运行容器的方式从生产角度来看并不理想。让我给你提供一些考虑事项：
- en: As portable containers can run on any Docker machine just fine, multiple containers
    also share server resources to optimize resource consumption. Now, think of a
    microservices application that comprises hundreds of containers. How will you
    choose what machine to run the containers on? What if you want to dynamically
    schedule the containers to another machine based on resource consumption?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于便携式容器可以在任何Docker机器上顺利运行，多个容器还共享服务器资源以优化资源消耗。现在，想象一个由数百个容器组成的微服务应用程序。您将如何选择在哪台机器上运行容器？如果您希望根据资源消耗动态调度容器到另一台机器上呢？
- en: Containers provide horizontal scalability as you can create a copy of the container
    and use a **load balancer** in front of a pool of containers. One way of doing
    this is to decide upfront and deploy the desired number of containers, but that
    isn’t optimal resource utilization. What if I tell you that you need to horizontally
    scale your containers dynamically with traffic – in other words, by creating additional
    container instances to handle the extra load when there is more traffic and reducing
    them when there is less?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器提供了水平扩展能力，因为您可以创建容器的副本，并在一组容器前面使用**负载均衡器**。一种方法是提前决定并部署所需数量的容器，但这不是最优的资源利用方式。如果我告诉你，你需要根据流量动态水平扩展容器——换句话说，当流量增加时，创建额外的容器实例来处理额外的负载，而当流量减少时，减少容器实例呢？
- en: There are container health check reports on the containers’ health. What if
    the container is unhealthy, and you want to auto-heal it? What would happen if
    an entire server goes down and you want to schedule all containers running on
    that server to another?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器有健康检查报告，显示容器的健康状态。如果容器不健康，并且你想让它自动修复该怎么办？如果整个服务器宕机，你希望将该服务器上的所有容器调度到其他地方，会发生什么？
- en: As containers mostly run within a server and can see each other, how would I
    ensure that only the required containers can interact with the other, something
    we usually do with VMs? We cannot compromise on security.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于容器大多运行在服务器内，并且能够彼此看到，那么我如何确保只有必要的容器能够互相交互，这是我们通常在虚拟机中做的事情？我们不能妥协于安全性。
- en: Modern cloud platforms allow us to run autoscaling VMs. How can we utilize that
    from the perspective of containers? For example, if I need just one VM for my
    containers during the night and five during the day, how can I ensure that the
    machines are dynamically allocated when we need them?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代云平台允许我们运行自动扩展的虚拟机（VM）。从容器的角度来看，我们如何利用这一点？例如，如果我在夜间只需要一台虚拟机来容纳我的容器，而白天需要五台，我该如何确保在需要时动态分配这些机器？
- en: How do you manage the networking between multiple containers if they are part
    of a more comprehensive service mesh?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果多个容器是更广泛服务网格的一部分，你如何管理它们之间的网络连接？
- en: The answer to all these questions is a container orchestrator, and the most
    popular and *de facto* standard for that is Kubernetes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题的答案是一个容器编排工具，而最受欢迎且*事实上的*标准就是 Kubernetes。
- en: Kubernetes is an open source container orchestrator. A bunch of Google engineers
    first developed it and then open sourced it to the **Cloud Native Computing Foundation**
    (**CNCF**). Since then, the buzz around Kubernetes has not subsided, and for an
    excellent reason – Kubernetes with containers has changed the technology mindset
    and how we look at infrastructure entirely. Instead of treating servers as dedicated
    machines to an application or as part of an application, Kubernetes has allowed
    visualizing servers as an entity with a container runtime installed. When we treat
    servers as a standard setup, we can run virtually anything in a cluster of servers.
    So, you don’t have to plan for **high availability** (**HA**), **disaster recovery**
    (**DR**), and other operational aspects for every application on your tech stack.
    Instead, you can cluster all your servers into a single unit – a Kubernetes cluster
    – and containerize all your applications. You can then offload all container management
    functions to Kubernetes. You can run Kubernetes on bare-metal servers, VMs, and
    as a managed service in the cloud through multiple Kubernetes-as-a-Service offerings.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个开源的容器编排工具。一群谷歌工程师最初开发了它，然后将其开源并交给了**云原生计算基金会**（**CNCF**）。从那时起，Kubernetes的热度未曾减退，而且这是有充分理由的——Kubernetes与容器的结合彻底改变了技术思维方式以及我们看待基础设施的方式。Kubernetes不再将服务器视为专门为某个应用程序服务的机器，或者作为应用程序的一部分，而是允许将服务器可视化为一个已安装容器运行时的实体。当我们将服务器视为标准设置时，我们就能在一群服务器的集群中运行几乎任何东西。因此，你不必为技术栈中的每个应用程序单独规划**高可用性**（**HA**）、**灾难恢复**（**DR**）和其他运营方面的问题。相反，你可以将所有服务器聚集成一个单位——Kubernetes
    集群——并将所有应用程序容器化。然后，你可以将所有容器管理功能交给 Kubernetes 来处理。你可以在裸金属服务器、虚拟机（VM）上运行 Kubernetes，或者通过多种
    Kubernetes 作为服务的产品，在云中运行它。
- en: 'Kubernetes solves these problems by providing HA, scalability, and zero downtime
    out of the box. It essentially performs the following functions to provide them:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 通过提供开箱即用的高可用性（HA）、可扩展性和零停机时间来解决这些问题。它基本上执行以下功能来提供这些功能：
- en: '**Provides a centralized control plane for interacting with it**: The API server
    exposes a list of useful APIs that you can interact with to invoke many Kubernetes
    functions. It also provides a Kubernetes command line called **kubectl** to interact
    with the API using simple commands. Having a centralized control plane ensures
    that you can interact with Kubernetes seamlessly.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供集中式控制平面与其交互**：API 服务器暴露了一个有用的 API 列表，你可以通过它调用许多 Kubernetes 功能。它还提供了一个名为
    **kubectl** 的 Kubernetes 命令行工具，方便你使用简单的命令与 API 进行交互。拥有一个集中式控制平面确保了你可以无缝地与 Kubernetes
    进行交互。'
- en: '**Interacts with the container runtime to schedule containers**: When we send
    the request to schedule a container to **kube-apiserver**, Kubernetes decides
    what server to schedule the container based on various factors and then interacts
    with the server’s container runtime through the **kubelet** component.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与容器运行时交互以调度容器**：当我们向**kube-apiserver**发送请求调度容器时，Kubernetes 会根据各种因素决定将容器调度到哪个服务器，然后通过**kubelet**组件与服务器的容器运行时进行交互。'
- en: '**Stores the expected configuration in a key-value data store**: Kubernetes
    applies the cluster’s anticipated configuration and stores that in a key-value
    data store – **etcd**. That way, Kubernetes continuously ensures that the containers
    within the cluster remain in the desired state. If there is any deviation from
    the expected state, Kubernetes will take every action to bring it back to the
    desired configuration. That way, Kubernetes ensures that your containers are up
    and running and healthy.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在键值数据存储中存储期望的配置**：Kubernetes 应用集群的预期配置，并将其存储在键值数据存储中——**etcd**。这样，Kubernetes
    会持续确保集群中的容器保持在期望的状态。如果有任何偏离预期状态的情况，Kubernetes 会采取措施将其恢复到期望的配置。通过这种方式，Kubernetes
    确保你的容器始终正常运行并保持健康。'
- en: '**Provides a network abstraction layer and service discovery**:Kubernetes uses
    a network abstraction layer to allow communication between your containers. Therefore,
    every container is allocated a virtual IP, and Kubernetes ensures a container
    is reachable from another container running on a different server. It provides
    the necessary networking by using an **overlay network** between the servers.
    From the container’s perspective, all containers in the cluster behave as if they
    are running on the same server. Kubernetes also uses a **DNS** to allow communication
    between containers through a domain name. That way, containers can interact with
    each other by using a domain name instead of an IP address to ensure that you
    don’t need to change the configuration if a container is recreated and the IP
    address changes.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供网络抽象层和服务发现**：Kubernetes 使用网络抽象层来允许容器之间的通信。因此，每个容器都会分配一个虚拟 IP，Kubernetes
    确保一个容器可以从运行在不同服务器上的另一个容器访问。它通过在服务器之间使用**覆盖网络**提供必要的网络连接。从容器的角度来看，集群中的所有容器就像是在同一台服务器上运行一样。Kubernetes
    还使用**DNS**来通过域名允许容器之间的通信。这样，容器可以通过使用域名而不是 IP 地址来相互交互，从而确保如果容器被重新创建且 IP 地址发生变化时，你不需要更改配置。'
- en: '**Interacts with the cloud provider**: Kubernetes interacts with the cloud
    provider to commission objects such as **load balancers** and **persistent disks**.
    So, if you tell Kubernetes that your application needs to persist data and define
    a **volume**, Kubernetes will automatically request a disk from your cloud provider
    and mount it to your container wherever it runs. You can also expose your application
    on an external load balancer by requesting Kubernetes. Kubernetes will interact
    with your cloud provider to spin up a load balancer and point it to your containers.
    That way, you can do everything related to containers by merely interacting with
    your Kubernetes API server.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与云提供商交互**：Kubernetes 与云提供商交互，以调度诸如**负载均衡器**和**持久磁盘**等对象。因此，如果你告诉 Kubernetes
    你的应用程序需要持久化数据并定义了一个**卷**，Kubernetes 会自动向你的云提供商请求磁盘，并将其挂载到运行容器的地方。你还可以通过向 Kubernetes
    请求将应用程序暴露在外部负载均衡器上。Kubernetes 会与云提供商交互，启动负载均衡器并将其指向你的容器。通过这种方式，你可以仅通过与 Kubernetes
    API 服务器交互来处理所有与容器相关的事务。'
- en: Kubernetes comprises multiple moving parts that take over each function we’ve
    discussed. Now, let’s look at the Kubernetes architecture to understand each of
    them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 包含多个组件，它们负责处理我们讨论的每个功能。现在，让我们来看看 Kubernetes 的架构，以了解每个组件的作用。
- en: Kubernetes architecture
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 架构
- en: Kubernetes is made of a cluster of nodes. There are two possible roles for nodes
    in Kubernetes – **control plane** nodes and **worker** nodes. The control plane
    nodes control the Kubernetes cluster, scheduling the workloads, listening to requests,
    and other aspects that help run your workloads and make the cluster function.
    They typically form the brain of the cluster.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是由一组节点组成的集群。在 Kubernetes 中，节点有两种可能的角色——**控制平面**节点和**工作**节点。控制平面节点控制
    Kubernetes 集群，调度工作负载、监听请求以及其他帮助运行工作负载和使集群运作的方面。它们通常构成集群的大脑。
- en: On the other hand, the worker nodes are the powerhouses of the Kubernetes cluster
    and provide raw computing for running your container workloads.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes architecture follows the client-server model via an API server. Any
    interaction, including internal interactions between components, happens via the
    Kubernetes API server. Therefore, the Kubernetes API server is known as the brain
    of the Kubernetes control plane.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other components of Kubernetes as well, but before we delve into
    the details, let’s look at the following diagram to understand the high-level
    Kubernetes architecture:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Kubernetes cluster architecture](img/B19877_05_1.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Kubernetes cluster architecture
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The control plane comprises the following components:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**API server**: As discussed previously, the API server exposes a set of APIs
    for external and internal actors to interact with Kubernetes. All interactions
    with Kubernetes happen via the API server, as evident from the preceding diagram.
    If you visualize the Kubernetes cluster as a ship, the API server is the ship’s
    captain.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Controller manager**: The controller manager is the ship’s executive officer
    and is tasked with ensuring that the captain’s orders are followed in the cluster.
    From a technical perspective, the controller manager reads the current and desired
    states and takes all actions necessary to move the current state to the desired
    state. It contains a set of controllers that interact with the Kubernetes components
    via the API server as and when needed. Some of these are as follows:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node controller**: This watches for when the node goes down and responds
    by interacting with the **Kube scheduler** via the **Kube API server** to schedule
    the pods to a healthy node.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replication controller**: This ensures that the correct amount of container
    replicas defined by replication controller objects in the cluster exist.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Endpoints controller**: These assist in providing endpoints to your containers
    via services.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service account and token controllers**: These create default **accounts**
    and **tokens** for new **namespaces**.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cloud controller manager**: This is an optional controller manager that you
    would run if you run Kubernetes in a public cloud, such as **AWS**, **Azure**,
    or **GCP**. The cloud controller manager interacts with the cloud provider APIs
    to provision resources such as **persistent disks** and **load balancers** that
    you declare in your Kubernetes configuration.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**etcd**: **etcd** is the log book of the ship. That is where all the details
    about the expected configuration exist. From a technical perspective, this is
    a key-value store where all the desired Kubernetes configuration is stored. The
    controller manager refers to the information in this database to action changes
    in the cluster.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduler**: The schedulers are the boatswain of the ship. They are tasked
    with supervising the process of loading and unloading containers on the ship.
    A Kubernetes scheduler schedules containers in a worker node it finds fit after
    considering the availability of resources to run it, the HA of your application,
    and other aspects.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度器**：调度器就像船只的水手长。它们负责监督容器在船上的装卸过程。Kubernetes 调度器会根据资源的可用性、应用程序的高可用性以及其他因素，在合适的工作节点上调度容器。'
- en: '**kubelet**: kubelets are the seamen of the ship. They carry out the actual
    loading and unloading of containers from a ship. From a technical perspective,
    the kubelet interacts with the underlying container runtime to run containers
    on the scheduler’s instruction. While most Kubernetes components can run as a
    container, the kubelet is the only component that runs as a **systemd** service.
    They usually run on worker nodes, but if you plan to run the control plane components
    as containers instead, the kubelet will also run on the control plane nodes.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubelet**：kubelet 就像船员一样。它们实际执行容器从船上装卸的操作。从技术角度看，kubelet 与底层的容器运行时交互，根据调度器的指令运行容器。虽然大多数
    Kubernetes 组件可以作为容器运行，但 kubelet 是唯一作为 **systemd** 服务运行的组件。它们通常运行在工作节点上，但如果你计划将控制平面组件作为容器运行，那么
    kubelet 也会在控制平面节点上运行。'
- en: '**kube-proxy**: **kube-proxy** runs on each worker node and provides the components
    for your containers to interact with the network components inside and outside
    your cluster. They are vital components that facilitate Kubernetes networking.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kube-proxy**：**kube-proxy** 在每个工作节点上运行，为容器提供与集群内外网络组件交互的功能。它们是促进 Kubernetes
    网络通信的关键组件。'
- en: Well, that’s a lot of moving parts, but the good news is that tools are available
    to set that up for you, and provisioning a Kubernetes cluster is very simple.
    If you are running on a public cloud, it is only a few clicks away, and you can
    use your cloud’s web UI or CLI to provision it very quickly. You can use **kubeadm**
    for the setup if you have an on-premises installation. The steps are well documented
    and understood and won’t be too much of a hassle.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这涉及很多环节，但好消息是，有现成的工具可以帮助你设置，而部署 Kubernetes 集群非常简单。如果你在公共云上运行，几次点击即可完成，你可以使用云提供商的
    Web UI 或 CLI 来快速部署。如果是本地安装，你可以使用**kubeadm**进行设置。步骤文档完善，易于理解，也不会太麻烦。
- en: For development and your CI/CD environments, you can use **Minikube** or **Kubernetes
    in Docker** (**KinD**). While Minikube can run a single-node Kubernetes cluster
    on your development machine directly by using your machine as the node, it can
    also run a multi-node cluster by running Kubernetes nodes as containers. KinD,
    on the other hand, exclusively runs your nodes as containers on both single-node
    and multi-node configurations. You need a VM with the requisite resources in both
    cases, and you’ll be good to go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发和 CI/CD 环境，你可以使用**Minikube**或**Docker 中的 Kubernetes**（**KinD**）。Minikube
    可以直接在你的开发机器上运行单节点 Kubernetes 集群，将机器作为节点使用；它也可以通过将 Kubernetes 节点作为容器来运行多节点集群。另一方面，KinD
    仅在单节点和多节点配置中将节点作为容器运行。在这两种情况下，你都需要一个具有必要资源的虚拟机，然后就可以开始了。
- en: In the next section, we’ll boot a single-node Kubernetes cluster with Minikube.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将使用 Minikube 启动一个单节点 Kubernetes 集群。
- en: Installing Kubernetes (Minikube and KinD)
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Kubernetes（Minikube 和 KinD）
- en: Now, let’s move on and install Kubernetes for your development environment.
    We will begin with Minikube to get you started quickly and then look into KinD.
    We will then use KinD for the rest of this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行 Kubernetes 的安装。我们将从 Minikube 开始，帮助你快速入门，然后再了解 KinD。接下来，我们将在本章的其余部分使用
    KinD。
- en: Installing Minikube
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Minikube
- en: We will install Minikube in the same Linux machine we used to install Docker
    in [*Chapter 3*](B19877_03.xhtml#_idTextAnchor220), *Containerization with Docker*.
    So, if you haven’t done that, please go to [*Chapter 3*](B19877_03.xhtml#_idTextAnchor220),
    *Containerization with Docker*, and follow the instructions provided to set up
    Docker on your machine.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在与安装 Docker 相同的 Linux 机器上安装 Minikube，参考[*第 3 章*](B19877_03.xhtml#_idTextAnchor220)，*使用
    Docker 进行容器化*。因此，如果你还没有进行该操作，请前往[*第 3 章*](B19877_03.xhtml#_idTextAnchor220)，*使用
    Docker 进行容器化*，并按照提供的说明在你的机器上设置 Docker。
- en: First, we will install **kubectl**. As described previously, kubectl is the
    command-line utility that interacts with the Kubernetes API server. We will use
    kubectl multiple times in this book.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装 **kubectl**。如前所述，kubectl 是与 Kubernetes API 服务器交互的命令行工具。在本书中，我们将多次使用
    kubectl。
- en: 'To download the latest release of kubectl, run the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载最新版本的 kubectl，请运行以下命令：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can also download a specific version of kubectl. To do so, use the following
    command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以下载 kubectl 的特定版本。为此，请使用以下命令：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We will stick with the latest release for this chapter. Now, let’s go ahead
    and make the binary executable and then move it to any directory in your system
    `PATH`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中使用最新版本。现在，让我们继续使二进制文件可执行，然后将其移动到系统的 `PATH` 中的任何目录：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, let’s check whether kubectl has been successfully installed by running
    the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行以下命令检查 kubectl 是否已成功安装：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Since kubectl was installed successfully, you must download the `minikube`
    binary and then move it to your system path using the following commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 kubectl 已成功安装，接下来你需要下载 `minikube` 二进制文件，并使用以下命令将其移动到系统路径中：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s install the packages required by Minikube to function correctly
    by running the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过运行以下命令来安装 Minikube 正常运行所需的包：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can bootstrap a Minikube cluster using the following command:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下命令启动一个 Minikube 集群：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As Minikube is now up and running, we will use the kubectl command-line utility
    to interact with the Kube API server to manage Kubernetes resources. The kubectl
    commands have a standard structure and are self-explanatory in most cases. They
    are structured as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Minikube 现在已经启动并运行，我们将使用 kubectl 命令行工具与 Kube API 服务器交互，以管理 Kubernetes 资源。kubectl
    命令具有标准结构，并且大多数情况下易于理解。其结构如下：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, we have the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有以下内容：
- en: '`verb`: The action to perform – for example, `get`, `apply`, `delete`, `list`,
    `patch`, `run`, and so on'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`动词`：要执行的操作——例如 `get`（获取）、`apply`（应用）、`delete`（删除）、`list`（列出）、`patch`（修补）、`run`（运行）等'
- en: '`resource type`: The Kubernetes resource to manage, such as `node`, `pod`,
    `deployment`, `service`, and so on'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`资源类型`：要管理的 Kubernetes 资源，例如 `node`（节点）、`pod`（容器组）、`deployment`（部署）、`service`（服务）等'
- en: '`resource name`: The name of the resource to manage'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`资源名称`：要管理的资源的名称'
- en: 'Now, let’s use kubectl to get nodes and check whether our cluster is ready
    to run our containers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 kubectl 获取节点并检查我们的集群是否准备好运行容器：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we can see that it is a single-node Kubernetes cluster running version
    **v1.26.3**. Kubernetes is now up and running!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到这是一个运行版本 **v1.26.3** 的单节点 Kubernetes 集群。Kubernetes 现在已经启动并运行！
- en: This setup is excellent for development machines where developers want to deploy
    and test a single component they are working on.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设置非常适合开发机器，开发人员可以在其上部署并测试他们正在开发的单个组件。
- en: 'To stop the Minikube cluster and delete it from the machine, you can use the
    following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止 Minikube 集群并将其从机器中删除，你可以使用以下命令：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have removed Minikube, let’s look at another exciting tool for creating
    a multi-node Kubernetes cluster.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经移除了 Minikube，接下来让我们看看另一个创建多节点 Kubernetes 集群的有趣工具。
- en: Installing KinD
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 KinD
- en: 'KinD allows you to run a multi-node Kubernetes cluster on a single server that
    runs Docker. We understand that a multi-node Kubernetes cluster requires multiple
    machines, but how can we run a multi-node Kubernetes cluster on a single server?
    The answer is simple: KinD uses a Docker container as a Kubernetes node. So, if
    we need a four-node Kubernetes cluster, KinD will spin up four containers that
    behave like four Kubernetes nodes. It is as simple as that.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: KinD 允许你在运行 Docker 的单个服务器上运行一个多节点的 Kubernetes 集群。我们知道，运行一个多节点的 Kubernetes 集群需要多台机器，但如何在单台服务器上运行一个多节点
    Kubernetes 集群呢？答案很简单：KinD 使用 Docker 容器作为 Kubernetes 节点。因此，如果我们需要一个四节点的 Kubernetes
    集群，KinD 会启动四个容器，它们表现得就像四个 Kubernetes 节点。就这么简单。
- en: While you need Docker to run KinD, KinD internally uses **containerd** as a
    container runtime instead of Docker. Containerd implements the container runtime
    interface; therefore, Kubernetes does not require any specialized components,
    such as **dockershim**, to interact with it. This means that KinD still works
    with Kubernetes since Docker isn’t supported anymore as a Kubernetes container
    runtime.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你需要 Docker 来运行 KinD，但 KinD 内部使用 **containerd** 作为容器运行时，而不是 Docker。Containerd
    实现了容器运行时接口，因此 Kubernetes 不需要任何专门的组件，如 **dockershim**，与其交互。这意味着，KinD 仍然能够与 Kubernetes
    配合使用，因为 Docker 不再被支持作为 Kubernetes 的容器运行时。
- en: As KinD supports a multi-node Kubernetes cluster, you can use it for your development
    activities and also in your CI/CD pipelines. In fact, KinD redefines CI/CD pipelines
    as you don’t require a static Kubernetes environment to test your build. KinD
    is swift to boot up, which means you can integrate the bootstrapping of the KinD
    cluster, run and test your container builds within the cluster, and then destroy
    it all within your CI/CD pipeline. This gives development teams immense power
    and speed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 KinD 支持多节点 Kubernetes 集群，你可以将其用于开发活动，也可以用于 CI/CD 管道。实际上，KinD 重新定义了 CI/CD
    管道，因为你不需要一个静态的 Kubernetes 环境来测试你的构建。KinD 启动速度快，这意味着你可以将 KinD 集群的引导过程集成到 CI/CD
    管道中，在集群内运行并测试你的容器构建，然后将其销毁。这为开发团队提供了巨大的力量和速度。
- en: Important
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Never use KinD in production. Docker in Docker implementations are not very
    secure; therefore, KinD clusters should not exist beyond your dev environments
    and CI/CD pipelines.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在生产环境中使用 KinD。Docker in Docker 的实现并不安全；因此，KinD 集群不应超出你的开发环境和 CI/CD 管道。
- en: 'Bootstrapping KinD is just a few commands away. First, we need to download
    KinD, make it executable, and then move it to the default `PATH` directory using
    the following commands:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 引导 KinD 只需几个命令。首先，我们需要下载 KinD，确保它可执行，然后使用以下命令将其移动到默认的 `PATH` 目录中：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To check whether KinD is installed, we can run the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否已安装 KinD，可以运行以下命令：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s bootstrap a multi-node KinD cluster. First, we need to create a
    KinD `config` file. The KinD `config` file is a simple YAML file where you can
    declare what configuration you want for each node. If we need to bootstrap a single
    control plane and three worker node clusters, we can add the following configuration:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们引导一个多节点的 KinD 集群。首先，我们需要创建一个 KinD `config` 文件。KinD `config` 文件是一个简单的 YAML
    文件，你可以在其中声明每个节点所需的配置。如果我们需要引导一个单控制平面和三个工作节点的集群，可以添加以下配置：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can also have an HA configuration with multiple control planes using multiple
    node items with the control plane role. For now, let’s stick with a single control
    plane, three-worker node configuration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用多个控制平面节点来实现高可用配置，在控制平面角色的节点上使用多个节点项。现在，我们先使用单个控制平面和三个工作节点的配置。
- en: 'To bootstrap your KinD cluster with the preceding configuration, run the following
    command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前述配置引导你的 KinD 集群，请运行以下命令：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With that, our KinD cluster is up and running. Now, let’s list the nodes to
    see for certain by using the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们的 KinD 集群已经启动并运行了。现在，让我们使用以下命令列出节点，确认集群状态：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we can see four nodes in the cluster – one control plane and three workers.
    Now that the cluster is ready, we’ll dive deep into Kubernetes and look at some
    of the most frequently used Kubernetes resources in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到集群中有四个节点——一个控制平面和三个工作节点。现在集群已经准备好，我们将在下一个部分深入了解 Kubernetes，并看看一些最常用的
    Kubernetes 资源。
- en: Understanding Kubernetes pods
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Kubernetes 的 pods
- en: Kubernetes pods are the basic building blocks of a Kubernetes application. A
    pod contains one or more containers, and all containers within a pod are always
    scheduled in the same host. Usually, there is a single container within a pod,
    but there are use cases where you need to schedule multiple containers in a single
    pod.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的 pod 是 Kubernetes 应用程序的基本构建块。一个 pod 包含一个或多个容器，所有容器总是会调度到同一主机上。通常，pod
    中只有一个容器，但在某些场景下，你需要在一个 pod 中调度多个容器。
- en: It takes a while to digest why Kubernetes started with the concept of pods in
    the first place instead of using containers, but there are reasons for that, and
    you will appreciate this as you gain more experience with the tool. For now, let’s
    look at a simple example of a pod and how to schedule it in Kubernetes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解为什么 Kubernetes 最初采用 pod 的概念而不是使用容器，可能需要一些时间，但这是有原因的，随着你对工具的使用经验积累，你会理解其中的深意。现在，让我们来看一个简单的
    pod 示例，以及如何在 Kubernetes 中调度它。
- en: Running a pod
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行一个 pod
- en: We will start by running an NGINX container in a pod using simple imperative
    commands. We will then look at how we can do this declaratively.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用简单的命令在 pod 中运行一个 NGINX 容器。然后，我们会看看如何以声明的方式进行操作。
- en: 'To access the resources for this section, `cd` into the following directory:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，请`cd`到以下目录：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To run a pod with a single NGINX container, execute the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个包含单个 NGINX 容器的 pod，请执行以下命令：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To check whether the pod is running, run the following command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 pod 是否正在运行，可以运行以下命令：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: And that’s it! As we can see, the pod is now running.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！正如我们所看到的，pod 现在正在运行。
- en: 'To delete the pod, you can run the following command:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除 pod，可以运行以下命令：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `kubectl run` command was the imperative way of creating pods, but there’s
    another way of interacting with Kubernetes – by using declarative manifests. `docker
    compose`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl run` 命令是创建 pod 的命令式方式，但与 Kubernetes 交互的另一种方式是使用声明性清单。`docker compose`。'
- en: Tip
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always use the declarative method to create Kubernetes resources in staging
    and production environments. They allow you to store and version your Kubernetes
    configuration in a source code management tool such as Git and enable GitOps.
    You can use imperative methods during development because commands have a quicker
    turnaround than YAML files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在预发布和生产环境中始终使用声明性方法创建 Kubernetes 资源。它们允许您将 Kubernetes 配置存储和版本化在诸如 Git 等源代码管理工具中，并启用
    GitOps。在开发过程中，您可以使用命令式方法，因为命令比 YAML 文件具有更快的周转时间。
- en: 'Let’s look at an example pod manifest, `nginx-pod.yaml`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例 pod 清单，`nginx-pod.yaml`：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s understand the file first. The file contains the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解文件。文件包含以下内容：
- en: '`apiVersion`: This defines the resource version we are trying to define. In
    this case, as it is a pod and a `v1`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`: 这定义了我们正在定义的资源版本。在这种情况下，作为 pod 的版本为 `v1`。'
- en: '`kind`: This defines the kind of resource we want to create – a pod.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kind`: 这定义了我们要创建的资源类型 – 一个 pod。'
- en: '`metadata`: The `metadata` section defines the name and labels surrounding
    this resource. It helps in uniquely identifying the resource and grouping multiple
    resources using labels.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`metadata`: `metadata` 部分定义了围绕此资源的名称和标签。它有助于通过标签唯一标识资源并分组多个资源。'
- en: '`spec`: This is the main section where we define the actual specifications
    for the resource.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec`: 这是主要部分，我们在这里定义资源的实际规格。'
- en: '`spec.containers`: This section defines one or more containers that form the
    pod.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers`: 此部分定义形成 pod 的一个或多个容器。'
- en: '`spec.containers.name`: This is the container’s name, which is `nginx-container`
    in this case.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.name`: 这是容器的名称，在本例中为 `nginx-container`。'
- en: '`spec.containers.image`: This is the container image, which is `nginx` in this
    case.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.image`: 这是容器镜像，在本例中是 `nginx`。'
- en: '`spec.containers.imagePullPolicy`: This can be `Always`, `IfNotPresent`, or
    `Never`. If set to `Always`, Kubernetes always pulls the image from the registry.
    If set to `IfNotPresent`, Kubernetes pulls the image only if the image is not
    found on the node where the pod is scheduled. If set to `Never`, Kubernetes will
    never attempt to pull images from the registry and will rely completely on local
    images.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.imagePullPolicy`: 这可以是 `Always`（始终拉取）、`IfNotPresent`（仅在节点上未找到镜像时拉取）、或
    `Never`（从不尝试从注册表拉取镜像并完全依赖本地镜像）。'
- en: '`spec.containers.resources`: This defines the resource requests and limits.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources`: 这定义了资源的请求和限制。'
- en: '`spec.containers.resources.limit`: This defines the resource limits. This is
    the maximum amount of resources that the pod can allocate, and if the resource
    consumption increases beyond it, the pod is evicted.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.limit`: 这定义了资源限制。这是 pod 可以分配的最大资源量，如果资源消耗超出此限制，pod
    将被驱逐。'
- en: '`spec.containers.resources.limit.memory`: This defines the memory limit.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.limit.memory`: 这定义了内存限制。'
- en: '`spec.containers.resources.limit.cpu`: This defines the CPU limit.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.limit.cpu`: 这定义了 CPU 限制。'
- en: '`spec.containers.resources.requests`: This defines the resource requests. This
    is the minimum amount of resources the pod would request during scheduling and
    will not be scheduled on a node that cannot allocate it.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.requests`: 这定义了资源请求。这是在调度期间 pod 需要的最小资源量，如果节点无法分配这些资源，将不会被调度。'
- en: '`spec.containers.resources.requests.memory`: This defines the amount of memory
    to be requested.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.requests.memory`: 这定义了要请求的内存量。'
- en: '`spec.containers.resources.requests.cpu`: This defines the number of CPU cores
    to be requested.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.containers.resources.requests.cpu`: 这定义了要请求的 CPU 核心数量。'
- en: '`spec.restartPolicy`: This defines the restart policy of containers – `Always`,
    `OnFailure`, or `Never`. This is similar to the restart policy on Docker.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec.restartPolicy`: 这定义了容器的重启策略 – `Always`（始终重启）、`OnFailure`（失败时重启）、或 `Never`（从不重启）。这与
    Docker 上的重启策略类似。'
- en: There are other settings on the pod manifest, but we will explore these as and
    when we progress.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pod 清单上还有其他设置，但我们将根据进展情况逐步探讨。
- en: Important tips
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Set `imagePullPolicy` to `IfNotPresent` unless you have a strong reason for
    using `Always` or `Never`. This will ensure that your containers boot up quickly
    and you don’t download images unnecessarily.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Always use resource requests and limits while scheduling pods. These ensure
    that your pod is scheduled in an appropriate node and does not exhaust any existing
    resources. You can also apply a default resource policy at the cluster level to
    ensure that your developers don’t cause any harm if they miss out on this section
    for some reason.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply the manifest using the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The pod that we created is entirely out of bounds from the host. It runs within
    the container network, and by default, Kubernetes does not allow any pod to be
    exposed to the host network unless we explicitly want to expose it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to access the pod – using port forwarding with `kubectl port-forward`,
    or exposing the pod through a `Service` resource.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Using port forwarding
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we get into the service side of things, let’s consider using the `port-forward`
    option.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'To expose the pod using port forwarding, execute the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The prompt is stuck here. This means it has opened a port forwarding session
    and is listening on port `8080`. It will automatically forward the request it
    receives on port `8080` to NGINX port `80`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a duplicate Terminal session and `curl` on the preceding address to see
    what we get:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see that it is working as we get the default NGINX response.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Now, there are a few things to remember here.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use HTTP `port-forward`, we are forwarding requests from the client
    machine running `kubectl` to the pod, something similar to what’s shown in the
    following diagram:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – kubectl port-forward](img/B19877_05_2.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – kubectl port-forward
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: When you run `kubectl` `port-forward`, the `kubectl` client opens a TCP tunnel
    via the Kube API server, and the Kube API server then forwards the connection
    to the correct pod. As the connection between the `kubectl` client and the API
    server is encrypted, it is a very secure way of accessing your pod, but hold your
    horses before deciding to use `kubectl` `port-forward` to expose pods to the outside
    world.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'There are particular use cases for using `kubectl` `port-forward`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: For troubleshooting any misbehaving pod.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For accessing an internal Kubernetes service, such as the Kubernetes dashboard
    – that is, when you don’t want to expose the service to the external world but
    only allow Kubernetes admins and users to log into the dashboard. It is assumed
    that only these users will have access to the cluster via `kubectl`.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For anything else, you should use `Service` resources to expose your pod, internally
    or externally. While we will cover the `Service` resource in the next chapter,
    let’s look at a few operations we can perform with a pod.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting pods
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to how we can browse logs from a container using `docker logs`, we can
    browse logs from a container within a Kubernetes pod using the `kubectl logs`
    command. If more than one container runs within the pod, we can specify the container’s
    name using the `-``c` flag.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the container logs, run the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As the pod is running a single container, we need not specify the `-c` flag,
    so instead, you can use the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There might be instances where you may want to get a shell to a running container
    and troubleshoot what’s going on within that. We use `docker exec` for that in
    the Docker world. Similarly, we can use `kubectl exec` for that within Kubernetes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to open a shell session with the container:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can even run specific commands without opening a shell session. For example,
    we can perform the preceding operation with a single line, something like the
    following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`kubectl exec` is an important command that helps us troubleshoot containers.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: If you modify files or download packages within the container in `exec` mode,
    they will persist until the current pod is alive. Once the pod is gone, you will
    lose all changes. Therefore, it isn’t a great way of fixing issues. You should
    only diagnose problems using `exec`, bake the correct changes in a new image,
    and then redeploy it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: When we looked at distroless containers in the previous chapter, they did not
    allow `exec` into the container for security reasons. There are debug images available
    for distroless that will enable you to open a shell session for troubleshooting
    purposes if you wish.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: By default, a container runs as the root user if you don’t specify the user
    within the Dockerfile while building the image. You can set a `runAsUser` attribute
    within your pod’s security context if you want to run your pod as a specific user,
    but this is not ideal. The best practice is to bake the user within the container
    image.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: We’ve discussed troubleshooting running containers, but what if the containers
    fail to start for some reason?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the following example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, let’s try to get the pod and see for ourselves:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Oops! There is some error now, and the status is `ImagePullBackOff`. Well,
    it seems like there is some issue with the image. While we understand that the
    issue is with the image, we want to understand the real issue, so for further
    information on this, we can describe the pod using the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, this gives us a wealth of information regarding the pod, and if you look
    at the `events` section, you will find a specific line that tells us what is wrong
    with the pod:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So, this one is telling us that either the repository does not exist, or the
    repository exists but it is private, and hence authorization failed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: You can use `kubectl describe` for most Kubernetes resources. It should be the
    first command you use while troubleshooting issues.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Since we know that the image does not exist, let’s change the image to a valid
    one. We must delete the pod and recreate it with the correct image to do that.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete the pod, run the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To recreate the pod, run the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let’s get the pod; it should run as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The pod is now running since we have fixed the image issue.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve managed to run containers using pods, but pods are very powerful
    resources that help you manage containers. Kubernetes pods provide probes to ensure
    your application’s reliability. We’ll have a look at this in the next section.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring pod reliability
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked about health checks in [*Chapter 4*](B19877_04.xhtml#_idTextAnchor399),
    *Creating and Managing Container Images*, and I also mentioned that you should
    not use them on the Docker level and instead use the ones provided by your container
    orchestrator. Kubernetes provides three **probes** to monitor your pod’s health
    – the **startup probe**, **liveness probe**, and **readiness probe**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts all three probes graphically:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Kubernetes probes](img/B19877_05_3.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Kubernetes probes
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at each one in turn and understand how and when to use them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Startup probe
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes uses **startup probes** to check whether the application has started.
    You can use startup probes on applications that start slow or those you don’t
    know how long it might take to start. While the startup probe is active, it disables
    other probes so that they don’t interfere with its operation. As the application
    has not started until the startup probe reports it, there is no point in having
    any other probes active.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Readiness probe
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Readiness probes** ascertain whether a container is ready to serve requests.
    They differ from startup probes because, unlike the startup probe, which only
    checks whether the application has started, the readiness probe ensures that the
    container can begin to process requests. A pod is ready when all the containers
    of the pod are ready. Readiness probes ensure that no traffic is sent to a pod
    if the pod is not ready. Therefore, it allows for a better user experience.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Liveness probe
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`restartPolicy` field of your pod to `Always` or `OnFailure`, Kubernetes will
    restart the container. Therefore, it improves the service’s reliability by detecting
    deadlocks and ensuring the containers are running instead of just reporting as
    running.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at an example to understand probes better.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Probes in action
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s improve the last manifest and add some probes to create the following
    `nginx-probe.yaml` manifest file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The manifest file contains all three probes:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: The startup probe checks whether the `/usr/share/nginx/html/index.html` file
    exists. It will continue checking it 30 times at an interval of 10 seconds until
    one of them succeeds. Once it detects the file, the startup probe will stop probing
    further.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The readiness probe checks whether there is a listener on port `80` and responds
    with `HTTP 2xx – 3xx on path /`. It waits for 5 seconds initially and then checks
    the pod every 5 seconds. If it gets a `2xx – 3xx` response, it will report the
    container as ready and accept requests.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The liveness probe checks whether the pod responds with `HTTP 2xx – 3xx` on
    `port` `80` and `path /`. It waits for 5 seconds initially and probes the container
    every 3 seconds. Suppose, during a check, that it finds the pod not responding
    for `failureThreshold` times (this defaults to `3`). In that case, it will kill
    the container, and the kubelet will take appropriate action based on the pod’s
    `restartPolicy` field.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s apply the YAML file and watch the pods come to life by using the following
    command:'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we can see, the pod is quickly ready from the running state. It takes approximately
    10 seconds for that to happen as the readiness probe kicks in 10 seconds after
    the pod starts. Then, the liveness probe keeps monitoring the health of the pod.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s do something that will break the liveness check. Imagine someone
    getting a shell to the container and deleting some important files. How do you
    think the liveness probe will react? Let’s have a look.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s delete the `/usr/share/nginx/html/index.html` file from the container
    and then check how the container behaves using the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: So, while we watch the pod, the initial delete is only detected after 9 seconds.
    That’s because of the liveness probe. It tries for 9 seconds, three times `periodSeconds`,
    since `failureThreshold` defaults to `3`, before declaring the pod as unhealthy
    and killing the container. No sooner does it kill the container than the kubelet
    restarts it as the pod’s `restartPolicy` field is set to `Always`. Then, we see
    the startup and readiness probes kicking in, and soon, the pod gets ready. Therefore,
    no matter what, your pods are reliable and will work even if a part of your application
    is faulty.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Using readiness and liveness probes will help provide a better user experience,
    as no requests go to pods that are not ready to process any request. If your application
    does not respond appropriately, it will replace the container. If multiple pods
    are running to serve the request, your service is exceptionally resilient.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed previously, a pod can contain one or more containers. Let’s
    look at some use cases where you might want multiple containers instead of one.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Pod multi-container design patterns
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can run multiple containers in pods in two ways – running a container as
    an init container or running a container as a helper container to the main container.
    We’ll explore both approaches in the following subsections.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Init containers
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Init containers** are run before the main container is bootstrapped, so you
    can use them to initialize your container environment before the main container
    takes over. Here are some examples:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: A directory might require a particular set of ownership or permissions before
    you want to start your container using the non-root user
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might want to clone a Git repository before starting the web server
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add a startup delay
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can generate configuration dynamically, such as for containers that want
    to dynamically connect to some other pod that it is not aware of during build
    time but should be during runtime
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Use init containers only as a last resort, as they hamper the startup time of
    your containers. Try to bake the configuration within your container image or
    customize it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at an example to see init containers in action.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the resources for this section, `cd` into the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let’s serve the `example.com` website from our `nginx` web server. We will get
    the `example.com` web page and save it as `index.html` in the `nginx` default
    HTML directory before starting `nginx`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Access the manifest file, `nginx-init.yaml`, which should contain the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we look at the `spec` section of the manifest file, we’ll see the following:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '`containers`: This section defines one or more containers that form the pod.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containers.name`: This is the container’s name, which is `nginx-container`
    in this case.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containers.image`: This is the container image, which is `nginx` in this case.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containers.volumeMounts`: This defines a list of volumes that should be mounted
    to the container. It is similar to the volumes we read about in [*Chapter 4*](B19877_04.xhtml#_idTextAnchor399),
    *Creating and Managing* *Container Images*.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containers.volumeMounts.mountPath`: This defines the path to mount the volume
    on, which is `/usr/share/nginx/html` in this case. We will share this volume with
    the init container so that when the init container downloads the `index.html`
    file from `example.com`, this directory will contain the same file.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`containers.volumeMounts.name`: This is the name of the volume, which is `html-volume`
    in this case.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initContainers`: This section defines one or more init containers that run
    before the main containers.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initContainers.name`: This is the init container’s name, which is `init-nginx`
    in this case.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initContainers.image`: This is the init container image, which is `busybox:1.28`
    in this case.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initContainers.command`: This is the command that the busybox should execute.
    In this case, `''mkdir -p /usr/share/nginx/html && wget -O /usr/share/nginx/html/index.html`
    [http://example.com](http://example.com)`''` will download the content of `example.com`
    to the `/``usr/share/nginx/html` directory.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initContainers.volumeMounts`: We will mount the same volume we defined in
    `nginx-container` on this container. So, anything we save in this volume will
    automatically appear in `nginx-container`.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initContainers.volumeMounts.mountPath`: This defines the path to mount the
    volume on, which is `/usr/share/nginx/html` in this case.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initContainers.volumeMounts.name`: This is the name of the volume, which is
    `html-volume` in this case.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volumes`: This section defines one or more volumes associated with the pod’s
    containers.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volumes.name`: This is the volume’s name, which is `html-volume` in this case.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volumes.emptyDir`: This defines an `emptyDir` volume. It is similar to a `tmpfs`
    volume in Docker. Therefore, it is not persistent and lasts just for the container’s
    lifetime.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let’s go ahead and apply the manifest and watch the pod come to life using
    the following commands:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Initially, we can see that the `nginx` pod shows a status of `Init:0/1`. This
    means that `0` out of `1` init containers have started initializing. After some
    time, we can see that the pod reports its status, `PodInitializing`, which means
    that the init containers have started running. The pod reports a running status
    once the init containers have run successfully.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once the pod starts to run, we can port-forward the container from port
    `80` to host port `8080` using the following command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open a duplicate Terminal and try to `curl` the localhost on port `8080` by
    using the following command:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we can see the example domain response from our web server. This means
    that the init container worked perfectly fine.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: As you may have understood by now, the life cycle of init containers ends before
    the primary containers start, and a pod can contain one or more main containers.
    So, let’s look at a few design patterns we can use in the main container.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: The ambassador pattern
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `localhost` everywhere.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, there are two approaches you can take:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: You can change the application code and use config maps and secrets (more on
    these later) to inject the database connection details into the environment variable.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can keep using the existing code and use a second container as a TCP proxy
    to the Redis database. The TCP proxy will link with the config map and secrets
    and contain the Redis database’s connection details.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: The ambassador pattern helps developers focus on the application without worrying
    about the configuration details. Consider using it if you want to decouple application
    development from config management.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach solves our problem if we wish to do a like-for-like migration.
    We can use config maps to define the environment-specific configuration without
    changing the application code. The following diagram shows this approach:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The ambassador pattern](img/B19877_05_4.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The ambassador pattern
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Before we delve into the technicalities, let’s understand a config map.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Config map
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **config map** contains key-value pairs that we can use for various purposes,
    such as defining environment-specific properties or injecting an external variable
    at container startup or during runtime.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: The idea of the config map is to decouple the application with configuration
    and to externalize configuration at a Kubernetes level. It is similar to using
    a properties file, for example, to define the environment-specific configuration.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains this beautifully:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Config maps](img/B19877_05_5.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Config maps
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: We will use `ConfigMap` to define the connection properties of the external
    Redis database within the ambassador container.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Example application
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We will use the example application we used in [*Chapter 3*](B19877_03.xhtml#_idTextAnchor220),
    *Containerization with Docker*, in the *Deploying a sample application with Docker
    Compose* section. The source code has been replicated into the following directory:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can visualize the `app.py` file of the Flask application, the `requirements.txt`
    file, and the Dockerfile to understand what the application does.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s build the container using the following command:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let’s push it to our container registry using the following command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you may have noticed, the `app.py` code defines the cache as `localhost:6379`.
    We will run an ambassador container on `localhost:6379`. The proxy will tunnel
    the connection to the `redis` pod running elsewhere.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create the `redis` pod using the following command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, let’s expose the `redis` pod to the cluster resources via a `Service`
    resource. This will allow any pod within the cluster to communicate with the `redis`
    pod using the `redis` hostname. We will discuss Kubernetes `Service` resources
    in the next chapter in detail:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Cool! Now that the pod and the `Service` resource are up and running, let’s
    work on the ambassador pattern.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: We need to define two config maps first. The first describes the `redis` host
    and port details, while the second defines the template `nginx.conf` file to work
    as a reverse proxy.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'The `redis-config-map.yaml` file looks like this:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The preceding YAML file defines a config map called `redis-config` that contains
    `host` and `port` properties. You can have multiple config maps, one for each
    environment.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nginx-config-map.yaml` file looks as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This config map injects the `nginx.conf` template as a config map value. This
    template defines the configuration of our ambassador pod to listen on `localhost:6379`
    and tunnel the connection to `REDIS_HOST:REDIS_PORT`. As the `REDIS_HOST` and
    `REDIS_PORT` values are placeholders, we must fill these up with the correct values
    that we obtained from the `redis-config` config map. To do that, we can mount
    this file to a volume and then manipulate it. We can use `initContainer` to initialize
    the proxy with the correct configuration.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at the pod configuration manifest, `flask-ambassador.yaml`.
    There are multiple parts of this YAML file. Let’s look at the `containers` section
    first:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This section contains a container called `flask-app` that uses the `<your_dockerhub_user>/flask-redis`
    image that we built in the previous section. The second container is the `nginx-ambassador`
    container that will act as the proxy to `redis`. Therefore, we have mounted the
    `/etc/nginx` directory on a volume. This volume is also mounted on the init container
    to generate the required configuration before `nginx` boots up.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `initContainers` section:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This section defines a `busybox` container – `init-nginx`. The container needs
    to generate the `nginx-ambassador` proxy configuration to communicate with Redis;
    therefore, two environment variables are present. Both environment variables are
    sourced from the `redis-config` config map. Apart from that, we have also mounted
    the `nginx.conf` file from the `nginx-config` config map. The `command` section
    within the init container uses the environment variables to replace placeholders
    within the `nginx.conf` file, after which we get a TCP proxy to the Redis backend.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'The `volumes` section defines `nginx-volume` as an `emptyDir` volume, and the
    `config` volume is mounted from the `nginx.conf` file present in the `nginx-config`
    config map:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now, let’s start applying the YAML files in steps.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply both of the config maps using the following commands:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let’s apply the pod configuration using the following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Get the pod to see whether the configuration is correct by using the following
    command:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As the pod is running successfully now, let’s port-forward `5000` to the localhost
    for some tests by using the following command:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, open a duplicate Terminal and try to `curl` on `localhost:5000` using
    the following command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we can see, every time we `curl` the application, we get the last visited
    time on our screen. The ambassador pattern is working.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: This was a simple example of the ambassador pattern. There are advanced configurations
    you can do to add fine-grained control on how your application should interact
    with the outside world. You can use the ambassador pattern to secure traffic that
    moves from your containers. It also simplifies application development for your
    development team as they need not worry about these nuances. In contrast, the
    operations team can use these containers to manage your environment in a better
    way without stepping on each other’s toes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: As the ambassador pattern adds some overhead as you tunnel connections via a
    proxy, you should only use it if the management benefits outweigh the extra cost
    you incur because of the ambassador container.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at another multi-container pod pattern – sidecars.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: The sidecar pattern
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sidecars** derive their names from motorcycle sidecars. The sidecar does
    not change the bike’s core functionality and can work perfectly without it. Instead,
    it adds an extra seat, a functionality that helps you give an additional person
    a ride. Similarly, sidecars in a pod are helper containers that provide functionalities
    unrelated to the main container’s core functionality and enhance it instead. Examples
    include logging and monitoring containers. Keeping a separate container for logging
    will help decouple the logging responsibilities from your main container, which
    will help you monitor your application even when the main container goes down
    for some reason.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: It also helps if there is some issue with the logging code, and instead of the
    entire application going down, only the logging container is impacted. You can
    also use sidecars to keep helper or related containers together with the main
    container since we know containers within the pod share the same machine.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Only use multi-container pods if two containers are functionally related and
    work as a unit.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use sidecars to segregate your application with secrets. For example,
    if you are running a web application that needs access to specific passwords to
    operate, it would be best to mount the secrets to a sidecar and let the sidecar
    provide the passwords to the web application via a link. This is because if someone
    gains access to your application container’s filesystem, they cannot get hold
    of your passwords as another container is responsible for sourcing it, as shown
    in the following diagram:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The sidecar pattern](img/B19877_05_6.jpg)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – The sidecar pattern
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement the preceding pattern to understand a sidecar better. We have
    a Flask application that interacts with a Redis sidecar. We will pre-populate
    the Redis sidecar with a secret `foobar`, and we will do that by using the Kubernetes
    secret resource.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Secrets
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`base64`-encoded instead of `plaintext`. While `base64` encoding does not make
    any difference, and it is as bad as `plaintext` from a security standpoint, you
    should use secrets for sensitive information such as passwords. That is because
    the Kubernetes community will develop a solution to tighten the security around
    secrets in future releases. If you use secrets, you will directly benefit from
    it.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, always use secrets for confidential data, such as API keys
    and passwords, and config maps for non-sensitive configuration data.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the files for this section, go to the following directory:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now, let’s move on to the example Flask application.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Example application
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Flask application queries a Redis sidecar for the secret and sends that
    as a response. That is not ideal, as you won’t send secrets back as a response,
    but for this demo, let’s go ahead with that.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: So, first, let’s design our sidecar so that it pre-populates data within the
    container after it starts.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a secret named `secret` with a value of `foobar`. Now, `base64-`encode
    the Redis command to set the secret into the cache by running the following command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now that we have the `base64`-encoded secret, we can create a `redis-secret.yaml`
    manifest with the string as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we need to build the Redis container so that this secret is created at
    startup. To access the files for this section, go to the following directory:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Create an `entrypoint.sh` file, as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The shell script looks for a file, `init.redis`, within the `/redis-master`
    directory and runs the `redis-cli` command on it. This means the cache will be
    pre-populated with the values defined in our secret, provided we mount the secret
    as `/redis-master/init.redis`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we must create a Dockerfile that will use this `entrypoint.sh` script,
    as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now that we are ready, we can build and push the code to Docker Hub:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now that we are ready with the Redis image, we must build the Flask application
    image. To access the files for this section, `cd` into the following directory:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let’s look at the `app.py` file first:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The code is simple – it gets the secret from the cache and returns that in the
    response.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: We also created the same Dockerfile that we did in the previous section.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s build and push the container image to Docker Hub:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now that our images are ready, let’s look at the pod manifest, `flask-sidecar.yaml`,
    which is present in the `~/``modern-devops/ch5/multi-container-pod/sidecar/` directory:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The pod defines two containers – `flask-app` and `redis-sidecar`. The `flask-app`
    container runs the Flask application that will interact with `redis-sidecar` for
    the secret. The `redis-sidecar` container has mounted the `secret` volume on `/redis-master`.
    The pod definition also contains a single volume called `secret`, and the volume
    points to the `redis-secret` secret and mounts that as a file, `init.redis`.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: So, in the end, we have a file, `/redis-master/init.redis`, and, as we know,
    the `entrypoint.sh` script looks for this file and runs the `redis-cli` command
    to pre-populate the Redis cache with the secret data.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s apply the secret first using the following command:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then, we can apply the `flask-sidecar.yaml` file using the following command:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, let’s get the pods using the following command:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As the pod is running, it’s time to port-forward it to the host using the following
    command:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, let’s open a duplicate Terminal, run the `curl localhost:5000` command,
    and see what we get:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As we can see, we get the secret, `foobar`, in the response. The sidecar is
    working correctly!
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at another popular multi-container pod pattern – the adapter
    pattern.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The adapter pattern
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As its name suggests, the **adapter pattern** helps change something to fit
    a standard, such as cell phones and laptop adapters, which convert our main power
    supply into something our devices can digest. A great example of the adapter pattern
    is transforming log files so that they fit an enterprise standard and feed your
    log analytics solution:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The adapter pattern](img/B19877_05_7.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – The adapter pattern
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'It helps when you have a heterogeneous solution outputting log files in several
    formats but a single log analytics solution that only accepts messages in a particular
    format. There are two ways of doing this: changing the code for outputting log
    files in a standard format or using an adapter container to execute the transformation.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the following scenario to understand it further.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: We have an application that continuously outputs log files without a date at
    the beginning. Our adapter should read the stream of logs and append the timestamp
    as soon as a logline is generated.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we will use the following pod manifest, `app-adapter.yaml`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The pod contains two containers – the app container, which is a simple Ubuntu
    container that outputs `This is a log line` every 2 seconds, and the log adapter,
    which continuously tails the `app.log` file, adds a timestamp at the beginning
    of the line, and sends the resulting output to `/var/log/out.log`. Both containers
    share the `/var/log` volume, which is mounted as an `emptyDir` volume on both
    containers.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s apply this manifest using the following command:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let’s wait a while and check whether the pod is running by using the following
    command:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'As the pod is running, we can now get a shell into the log adapter container
    by using the following command:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When we get into the shell, we can `cd` into the `/var/log` directory and list
    its contents using the following command:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: As we can see, we get `app.log` and `out.log` as two files. Now, let’s use the
    `cat` command to print both of them to see what we get.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'First, `cat` the `app.log` file using the following command:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here, we can see that a series of log lines are being printed.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `cat` the `out.log` file to see what we get using the following command:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here, we can see timestamps in front of the log line. This means that the adapter
    pattern is working correctly. You can then export this log file to your log analytics
    tool.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the end of this critical chapter. We’ve covered enough ground
    to get you started with Kubernetes and understand and appreciate the best practices
    surrounding it.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: We started with Kubernetes and why we need it and then discussed bootstrapping
    a Kubernetes cluster using Minikube and KinD. Then, we looked at the pod resource
    and discussed creating and managing pods, troubleshooting them, ensuring your
    application’s reliability using probes, and multi-container design patterns to
    appreciate why Kubernetes uses pods in the first place instead of containers.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will deep dive into the advanced aspects of Kubernetes
    by covering controllers, services, ingresses, managing a stateful application,
    and Kubernetes command-line best practices.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-424
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: All communication with Kubernetes happens via which of the following?
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Kubelet
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. API server
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Etcd
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Controller manager
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: E. Scheduler
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following is responsible for ensuring that the cluster is in the
    desired state?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Kubelet
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. API server
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Etcd
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Controller manager
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: E. Scheduler
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following is responsible for storing the desired state of the cluster?
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Kubelet
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. API server
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Etcd
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Controller manager
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: E. Scheduler
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A pod can contain more than one container. (True/False)
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use port-forwarding for which of the following use cases? (Choose two)
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. For troubleshooting a misbehaving pod
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. For exposing a service to the internet
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. For accessing a system service such as the Kubernetes dashboard
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using a combination of which two probes can help you ensure that your application
    is reliable even when your application has some intermittent issues? (Choose two.)
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Startup probe
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Liveness probe
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Readiness probe
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We may use KinD in production. (True/False)
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following multi-container patterns is used as a forward proxy?
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Ambassador
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Adapter
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Sidecar
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Init containers
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Answers
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: B
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: D
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A, C
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B, C
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
