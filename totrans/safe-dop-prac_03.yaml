- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation for Efficiency and Quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of the factors in the CALMR (Culture, Automation, Lean Flow, Measuring, Recovery)
    approach, automation is the one most associated with the DevOps approach. A great
    deal of energy is devoted by DevOps practitioners to keeping current on trends
    in technology for environments and tooling. These tools, with different functions,
    are tied together to form a toolchain or pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: We start our look at different types of tools in our pipeline by looking at
    the foundational tool types every pipeline needs. This includes Agile project
    management, version control systems, and review/documentation tools.
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) tools stem from build management utilities.
    We will examine tools that create builds and other types of tools that run when
    a build is executed. These include automated testing tools, packaging tools, and
    artifact repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: An extension of CI is the deployment of build packages to staging and production
    environments. We will examine the tool types used in **Continuous Deployment**
    (**CD**), including configuration management, **Infrastructure as Code** (**IaC**),
    and vulnerability scanning tools.
  prefs: []
  type: TYPE_NORMAL
- en: Automation still relies on people. We will have a look at the ways development
    teams and operations teams can align to create the necessary automation and environments
    using DevOps topologies.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll see how people create the automation for the Continuous Delivery
    Pipeline in SAFe® by examining what the system team does in the **Agile Release**
    **Train** (**ART**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, the following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines and toolchains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps topologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipelines and toolchains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A toolchain is the set of tools used in DevOps practices in the product development
    life cycle. The classic representation of the toolchain used in DevOps is an infinity
    loop, broken up into a number of functions. Each function or stage is enhanced
    by automation. A representation of this infinity loop, created by Kharnagy, and
    licensed under the Creative Commons Attribution ShareAlike license, is shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – DevOps toolchain ](img/B18756_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – DevOps toolchain
  prefs: []
  type: TYPE_NORMAL
- en: 'If we separate the ends of this infinity loop, we see the basis of our pipeline.
    The pipeline orchestrates the operation of all the stages with the exception of
    the monitoring stage. This begins our look at each pipeline stage, as shown in
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – DevOps pipeline](img/B18756_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – DevOps pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin our examination of the pipeline by looking at the activities whose
    artifacts set the pipeline in motion: plan and create. These foundational steps
    are illustrated in *Figure 3**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Pipeline foundations](img/B18756_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Pipeline foundations
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start our examination of the CI/CD pipeline by looking at foundational
    tools. We will look at tools that can assist with planning in our value stream
    and monitoring the progress of the overall development process. We’ll also examine
    the tools that act as repositories for the code, tests, configuration scripts,
    and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Planning with Agile project management tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To look at where we are from request to release, we need to find a way to understand
    what we must do, and what the progress is of those steps. There are a large variety
    of methods to achieve this, from physical Kanban boards to Excel spreadsheets.
    As teams deal with remote and geographically distributed ways of working, Agile
    project management tools are a popular method for doing this.
  prefs: []
  type: TYPE_NORMAL
- en: Agile project management tools allow for the creation and update of work items.
    Progress on the work items is displayed on either a Kanban board or a list of
    issues. Recording the work items and their progress allows for easy collection
    of progress metrics, such as lead time.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, work items can be linked to branches in version control and executions
    in a CI/CD pipeline tool. This allows for a trail of when a change was released
    throughout the entire pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Leading Agile project management tools include Jira and Trello, both by Atlassian,
    Azure DevOps by Microsoft, Digital.ai Agility (formerly known as VersionOne),
    IBM Engineering Work Management (formerly known as IBM Team Concert), and Broadcom
    Rally. In addition, many version control tools such as GitHub and GitLab include
    Agile project management functions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating code and documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Version control has been an important part of software development since the
    1990s. With version control, multiple developers can work on the same code base
    without fear of deleting each other’s changes. To accomplish this, developers
    create a branch that contains their changes. When the time comes to share these
    changes, they merge the changes back into a shared branch where any differences
    are resolved. Merges can also be effective points for other developers to review
    any code changes going to the shared branch.
  prefs: []
  type: TYPE_NORMAL
- en: These days, code is not the only artifact kept in version control. Testing scripts
    used for automated testing can be kept in version control. Text files that are
    used for configuring staging and production environments are also kept in version
    control. In short, anything that is text that refers to any change or release
    is kept in version control. As we saw in [*Chapter 1*](B18756_01.xhtml#_idTextAnchor014),
    *Introducing SAFe® and DevOps*, when looking at Flickr, a common version control
    system between Dev and Ops is best.
  prefs: []
  type: TYPE_NORMAL
- en: The most prevalent version control system for code is Git, invented by Linus
    Torvalds, which was used as the repository for the Linux operating system. Git
    is a distributed version control system that allows copies of the entire repository
    to be easily replicated, even to developers. Even with the ease of replication,
    there are Git hosting solutions available that allow organizations to centralize
    the repositories to an *origin*. The most popular Git hosting products include
    Bitbucket by Atlassian, GitHub, GitLab, and Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation is another important artifact created for product development.
    **Non-Functional Requirements** (**NFRs**) may be detailed in specifications,
    architecture may be specified in terms of models and diagrams, and **user interface/user
    experience** (**UI/UX**) guidelines may be depicted as wireframes and sketches.
    These initial designs may start from planning and continue in the iterative learning
    cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Document repositories and wiki software are used to store requirements specifications,
    architectural models, UI wireframes, and product and user documentation. Popular
    repositories include Confluence from Atlassian and GitLab Pages.
  prefs: []
  type: TYPE_NORMAL
- en: Once changes have been added to the repository in version control, the work
    of the CI/CD pipeline can begin. Let’s take a look at the activities that make
    up continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When code changes are ready, automation can begin building the necessary packages
    for use in staging and production environments. As part of the build process,
    tests can be run to determine the correct function as well as security. When testing
    indicates correct and secure functionality, a package is created and stored in
    artifact repositories based on the technology used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the pipeline is illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Pipeline: Continuous integration](img/B18756_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4 – Pipeline: Continuous integration'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how the CI portion of the pipeline manages a build, executes the
    initial-level testing, and packages the build. We will begin with a definition
    of continuous integration, continuous delivery, and continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration versus continuous delivery versus continuous deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will see that continuous integration captures the activities that can be
    automatically run once a change has been committed to the version control system.
    Code, including any changes, can be compiled or packaged to a form computers can
    use. Tests are run after the build step to ensure no bugs or security vulnerabilities
    have been introduced. Notifications can be created upon success or failure. Upon
    success, the code changes can be merged with the existing code base. We will examine
    these steps in detail when we look at the continuous integration stage of the
    Continuous Delivery Pipeline in [*Chapter 11*](B18756_11.xhtml#_idTextAnchor244),
    *Continuous Integration of* *Solution Development*.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery takes the continuous integration steps further by allowing
    the newly-merged changes to be packaged and delivered to a staging environment,
    a test environment that is as similar to production as possible, or to production.
    Once delivered to the environment, further tests can be run to verify the correctness
    of new features or to perform a deeper security scan. The success of these tests
    allows the organization to release the changes when they’re ready. Detailed steps
    outlining continuous delivery (labeled as continuous deployment) will be listed
    in [*Chapter 12*](B18756_12.xhtml#_idTextAnchor268), *Continuous Deployment* *to
    Production*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuous deployment is continuous delivery with one further step: when the
    tests are complete in the production environment, the new features are automatically
    released to allow customers to use them immediately.'
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether your final stop in automation is continuous integration,
    continuous delivery, or you completely automate a release through continuous deployment,
    you will typically use the same tool to establish your pipeline. Let’s look at
    that category of tools now.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestrating the change
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pipeline orchestration tools (commonly referred to as CI/CD tools) begin as
    build management tools. These tools execute build scripts and perform additional
    actions when triggered manually or automatically when a commit occurs in the version
    control system.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier versions of CI/CD tools maintained the jobs to be done as part of the
    UI. CI/CD tools today allow jobs to be defined through a text file using YAML
    or other formats.
  prefs: []
  type: TYPE_NORMAL
- en: The power of the CI/CD tools lies in their flexibility. Easy integration with
    other tools to perform other functions, such as automated testing and deployment,
    has enabled overall success in the DevOps movement. Scalability in execution through
    the incorporation of agent software in worker nodes is another important factor,
    allowing jobs to be created in any environment.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD tools can be set up in *on-premises* environments, on private clouds,
    or as **Software-as-a-Service** (**SaaS**) products. The most popular CI/CD tool
    for on-premises or private cloud environments continues to be Jenkins, an open
    source project that started as Hudson. Other popular tools include CircleCI and
    Bamboo from Atlassian. Many Git hosting products have rolled out CI/CD pipeline
    extensions as part of their system, including GitLab, GitHub Actions on GitHub,
    Azure DevOps, and Bitbucket Pipelines on Bitbucket Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying quality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By far, one of the most important functions a pipeline can do is set up and
    execute automated testing. Automated testing is gaining attention due to the *shift-left*
    philosophy with the realization that the earlier and more often you do testing,
    the better the quality of the finished product. The DevSecOps movement advocates
    for earlier and more frequent automated testing as a way of establishing *continuous
    security*. Early testing can be done without requiring the code to be executed
    in an environment either through simulated inputs and evaluating outputs or through
    an examination of the code.
  prefs: []
  type: TYPE_NORMAL
- en: These *first-level* tests are known as unit tests and static analyses. Let’s
    take a detailed look at them now.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests (test-driven development)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unit tests are scripts written to verify that functions in code produce the
    desired output when given simulated input. Unit test frameworks such as JUnit
    and NUnit are specific to the language used to create the code. Unit tests can
    run directly from the pipeline as a defined stage.
  prefs: []
  type: TYPE_NORMAL
- en: Test management software can also be used to execute unit tests. Each unit test
    is saved as a test case in the test management software, and the results are recorded.
    Test management software can also set up an integration to Agile project management
    tools to record defects when tests fail.
  prefs: []
  type: TYPE_NORMAL
- en: Popular test management software includes Engineering Test Management from IBM,
    XRay from XBlend, and Zephyr from SmartBear.
  prefs: []
  type: TYPE_NORMAL
- en: Static analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Static analysis is the examination of code without executing it. Typically,
    tools are used to analyze and audit the code. Static analysis has other names
    depending on the expected outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: Linting is a static analysis done with a specific tool (lint). Linting examines
    code looking for possible code errors and can be used to enforce coding standards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static application security testing** (**SAST**) is static analysis applied
    to searching for possible security vulnerabilities in code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency scanning looks at the dependencies of libraries called by code to
    review whether known security vulnerabilities exist.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: License scanning looks at the dependencies called by code to review the type
    of open source licensing the libraries use. This helps keep the organization compliant
    with the types of open source licenses used and if attribution and distribution
    of changes are required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tooling that can perform the analysis described, including SAST, includes SonarQube
    from SonarSource, Snyk, Coverity from Synopsys, mend.io (formerly WhiteSource),
    Klocwork offered by Perforce, as well as GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging for deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the first level of the tests pass, the pipeline can then prepare the code
    changes. Packaging the changes is dependent upon several factors, including the
    language and the technology used for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Artifact repository tools allow for version control of large package images.
    These may pose problems with storage on the version control software mentioned
    previously because these artifacts are large binary files. These binary images
    may range from standard packages such as WAR files in Java or NPM images in Node.js,
    to **virtual machine** (**VM**) images. The popularity of Docker as a deployment
    technology has created a need to identify and version control Docker images in
    private repositories, resulting in additional capabilities for artifact repository
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Popular artifact repository tools include Artifactory by JFrog and Nexus by
    Sonatype. In addition, GitLab and Azure DevOps include the ability to act as an
    artifact repository for binary images.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During the continuous integration phase of the pipeline, we saw the last step
    as the packaging of changes into a binary image. Continuous deployment continues
    from that step to the application of that image into testing and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Automation may play a role in adding or updating resources in these environments.
    IaC tools allow the configuration of these resources.
  prefs: []
  type: TYPE_NORMAL
- en: Now that code changes are in an environment, testing can be done in further
    detail to find problems with quality and security. Here, the tests may also look
    at how changes affect the performance and validation of the desired changes.
  prefs: []
  type: TYPE_NORMAL
- en: As changes are added to environments, we need to be aware of the effects of
    these changes. To that end, we will measure the performance of the overall environment
    including the storage and analysis of logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The continuous deployment stage is illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Pipeline: Continuous deployment](img/B18756_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5 – Pipeline: Continuous deployment'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at these activities carried out in the environments. We may need
    to configure the environment to set up new features. Then comes the actual deployment
    of changes into the environment. Finally, more and deeper testing can be performed
    in the environment to ensure the correct function, security, and value.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring environments with IaC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, changes may involve creating new resources in an environment. Part of
    the configurations in configuration management tools may invoke other tools that
    allow the automatic creation of resources. The creation of these resources is
    guided by a script, often in YAML format. Due to the reliance on these scripts,
    the tools are described as IaC.
  prefs: []
  type: TYPE_NORMAL
- en: The emergence of public cloud environments, such as **Amazon Web Services**
    (**AWS**), Azure from Microsoft, and Google Cloud Platform, has introduced tools
    associated with each cloud environment. The most notable of these is CloudFormation,
    which works with AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Other vendors offer IaC tools that are more flexible, working in a variety of
    physical servers, private cloud, and public cloud environments. The most notable
    of these is Terraform by Hashicorp.
  prefs: []
  type: TYPE_NORMAL
- en: Releasing with configuration management and feature flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuration management tools are responsible for identifying and setting the
    configuration of development and production environments. A pipeline can invoke
    the configuration management tool to introduce a build package that has passed
    the continuous integration stage.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, configuration management tools specified the configuration for physical
    (bare metal) servers or VM images. They have grown to include Docker containers
    and Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptions of configurations are often specified in terms of the desired configuration
    state but do not elaborate on the necessary steps to achieve the desired state.
    This helps to achieve idempotence in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Popular configuration management tools include Chef by Progress Chef, Puppet,
    and Ansible by Red Hat. Ansible has an advantage over both Chef and Puppet in
    that it connects to the environment resources through **Secure Shell** (**SSH**),
    which removes the need to install agent software on the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Release visibility with feature flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even as code changes make their way into production environments, those changes
    may not be visible to the end users or affect existing functionality. This may
    be due to code switches or *feature flags* that prevent the visibility of the
    code changes. This allows for a gradual rollout of changes, such as canary deployments.
    This also allows for a quick reversion to the previous state by deactivating the
    applicable feature flags.
  prefs: []
  type: TYPE_NORMAL
- en: Popular feature flag tools include LaunchDarkly, Flagsmith, and CloudBees Feature
    Management.
  prefs: []
  type: TYPE_NORMAL
- en: Additional verification through advanced testing in the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that changes are built, packaged, and placed in environments, testing can
    work on deeper levels. Test inputs can be placed in the environment to determine
    whether the code works as expected, whether any vulnerabilities are introduced,
    and whether the system behaves as expected.
  prefs: []
  type: TYPE_NORMAL
- en: These types of tests that measure correct functionality, security, and acceptance
    are described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Functional and UI testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functional testing is most concerned with code correctness. It exists primarily
    to see whether the coding works and meets the base requirements. Typically, functional
    tests go beyond the individual code functions, which would have been tested during
    unit testing. Specific types of functional testing are used in the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sanity testing** is running a small set of functional tests to verify code
    features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Smoke testing** usually involves running short, high-level functional tests
    to gain confidence in a new build or a new deployment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression testing** is a more extensive execution of functional tests to
    verify that new code features work with the existing system functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated tools for functional testing depend upon the language the coding features
    are written in, the environment the code will be deployed in, and the technology
    platform (web versus mobile versus other). A cross-section of popular tools includes
    UFT by Micro Focus, Worksoft Certify, and Tricentis Tosca.
  prefs: []
  type: TYPE_NORMAL
- en: UI testing is functional testing for graphical UIs. This ensures that elements
    such as buttons and fields on a web page connect to the correct underlying code
    functions and ensures the correctness of those code functions.
  prefs: []
  type: TYPE_NORMAL
- en: Many popular UI testing tools are based on Selenium, a platform that captures
    actions performed on a web page in scripts that can be repeated by automation.
    Such tools include TestComplete and CrossBrowserTesting by SmartBear and Sauce
    Labs.
  prefs: []
  type: TYPE_NORMAL
- en: Load/performance testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performance testing, such as load testing, is not designed to measure correct
    functionality. Rather, the goal of performance testing is to verify any NFRs such
    as reliability and scalability. We want to see how the system, including any new
    code changes, can handle increased demand for its resources by flooding the system
    with a large number of system requests, such as logins and form evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: Popular tools for performance testing include LoadRunner from Micro Focus and
    JMeter for traditional applications and Sauce Performance from Sauce Labs for
    web and mobile application performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic application security testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Dynamic application security testing** (**DAST**) continues the emphasis
    on security in DevSecOps. With DAST, automated tests continue security scanning
    by performing simulated attacks on the environment for web applications to find
    vulnerabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: A leading DAST scanner is OWASP Zed Attack Proxy, which is used by GitLab to
    provide DAST scanning functionality on its pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: IaC scanning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Additional tests for DevSecOps continue with the ability to scan the IaC files
    to discover whether there are any misconfigurations or security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Leading tools such as Snyk and GitLab can scan for multiple IaC tools, including
    Ansible, Terraform, Dockerfiles, and configuration services for public clouds,
    such as CloudFormation, Google Deployment Manager, and **Azure Resource** **Manager**
    (**ARM**).
  prefs: []
  type: TYPE_NORMAL
- en: Container scanning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Containers are a technology where an application and any needed libraries are
    encapsulated as a virtual image. This virtual image can be an extension of base
    resources that represent the functions provided by an operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is the technology used to implement containers. Developers define the
    application and libraries in Docker images. The image can be placed in a repository
    where it can be pulled and executed in any environment by Docker Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Container scanning allows the Docker image and dependent images to be scanned
    to look for security vulnerabilities. Tools that can implement container scanning
    include GitLab and Snyk.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests (behavior-driven development)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Acceptance tests are test scripts written in a business-readable language called
    Gherkin. Each test is composed of three main clauses, each starting with a keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**: This clause describes the initial conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When**: This clause describes the input for the test'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then**: This clause describes the desired behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cucumber is the tool that executes Gherkin tests. Cucumber is available in an
    open source version and paid versions are available in CucumberStudio and Cucumber
    for Jira. All versions are supported by SmartBear.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now leave tools that are part of the pipeline to tools that are run continuously.
    Ongoing evaluation of staging and production environments is done by tools independent
    of the pipeline. These tools perform the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance monitoring/reporting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Stability is the key goal for operations. To that end, they will monitor the
    health of the environment by collecting metrics that can indicate the health of
    key components. This may include the following metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popular tools for monitoring include Prometheus for collecting metrics and Grafana
    for displaying the metrics on a dashboard. If the environment is on a public cloud,
    CloudWatch is available on AWS, and Azure Monitor is available on Azure. Cloud-based
    **monitoring-as-a-service** (**MaaS**) products can consolidate monitoring from
    multiple environments and sources. Such products include Datadog and New Relic.
  prefs: []
  type: TYPE_NORMAL
- en: Log collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another aspect of monitoring comes from collecting log messages created by the
    system and applications. The messages may provide context for issues when problems
    arise in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Logs from different systems, different system components, and different applications
    are collected into one source using log aggregation tools. These tools include
    a search capability to filter by an important keyword when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Log aggregation tools can be a software application that resides on-premises
    or in a private cloud, a feature available on public clouds, or a **SaaS** product.
    Popular log aggregation tools include the combination of Elasticsearch, Logstash,
    and Kibana (an ELK stack) for collection and analytics in on-premises/private
    cloud environments. Log collection is part of the AWS CloudWatch service. Splunk
    and Datadog are popular SaaS-based products that perform log aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: Alerting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When problems arise, it is important to notify the key people in a timely fashion.
    Alert tools can provide multiple channels for notification, including emails,
    SMS messages, and IM chat messages. They may also provide a tolerance mechanism
    to prevent too many alert messages to operations personnel and *alert fatigue*
    from occurring. These tools can also create issues for incident management so
    that **IT service management** (**ITSM**) processes are followed.
  prefs: []
  type: TYPE_NORMAL
- en: Leading alerting tools include PagerDuty and Opsgenie by Atlassian.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve talked about the technology involved in creating the automation
    that is part of DevOps. Let’s focus our attention now on people, in terms of who
    can be responsible for installing and configuring such automation as the CI/CD
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps topologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the growing list of tools and technologies available to Dev and Ops, it
    may be difficult to figure out where the responsibilities lie in moving toward
    a DevOps approach. Who is responsible for creating the CI/CD pipeline? What do
    we consider databases? How do we deploy into production?
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2013, Matthew Skelton initially described three team *anti-types* to avoid
    and five possible team structures. Additional contributions have increased the
    number of anti-types to eight and the number of beneficial team structures to
    nine. The following list shows the anti-types and they are elaborated here at
    [https://web.devopstopologies.com](https://web.devopstopologies.com):'
  prefs: []
  type: TYPE_NORMAL
- en: Dev and Ops Silos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permanent DevOps Team Silo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dev Doesn’t Need Ops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps as the Dev Tools Team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rebranded Sysadmins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ops Embedded in Dev Team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dev and DBA Silos
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake SRE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 9 DevOps topologies from that site are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Dev and Ops collaboration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This structure is considered the ideal DevOps approach, where Dev and Ops are
    working together and have smooth collaboration. Implementing this structure likely
    requires a large organizational culture change toward a generative culture.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.6 – Dev and Ops collaboration (\uFEFFdiagram based on work at devopstopologies.com\
    \ – licensed under CC BY-SA)](img/B18756_03_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Dev and Ops collaboration (diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)
  prefs: []
  type: TYPE_NORMAL
- en: Fully shared Ops responsibilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some organizations with a single web-based product, such as Netflix or Facebook,
    may be able to take the Dev and Ops collaboration model shown previously and integrate
    Ops more fully. In this model, there is very little separation between Dev and
    Ops. Because of this, everyone is focused on the mission.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Fully shared Ops responsibilities (Diagram based on work at
    devopstopologies.com – licensed under CC BY-SA)](img/B18756_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Fully shared Ops responsibilities (Diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)
  prefs: []
  type: TYPE_NORMAL
- en: Ops as infrastructure as a service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There may be some organizations that have a more traditional Ops department.
    Also, some organizations may deploy applications to public cloud environments
    such as AWS or Azure. In either case, a small subset of the Dev department may
    treat operations *as a service* and set up tooling for deployment, metrics, provisioning,
    and monitoring of those resources. In this model, there is no direct collaboration
    with Operations.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.8 – Ops as infrastructure as a service (\uFEFFdiagram based on work\
    \ at devopstopologies.com – licensed under CC BY-SA)](img/B18756_03_08.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Ops as infrastructure as a service (diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)
  prefs: []
  type: TYPE_NORMAL
- en: DevOps as an external service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some smaller teams and organizations may not have the manpower or experience
    to move toward a DevOps approach. In that case, they may contract an external
    vendor to create the test environments and automation and configure the monitoring.
    The DevOps vendors may also train Dev and Ops to move to a different model, such
    as Dev and Ops collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – DevOps as an external service (Diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)](img/B18756_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – DevOps as an external service (Diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)
  prefs: []
  type: TYPE_NORMAL
- en: DevOps team (with expiration date)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There may be situations where having a dedicated DevOps team works. The idea
    is that the DevOps team can act as a *bridge* for both Dev and Ops teams. The
    DevOps team can instruct developers on working with infrastructure and can instruct
    operations personnel on Agile development. At some point, the DevOps team will
    disband, allowing Dev and Ops to collaborate in the Dev and Ops collaboration
    model.
  prefs: []
  type: TYPE_NORMAL
- en: The danger exists when the DevOps team does not disband, instead forming a separate
    silo. This is actually one of the identified anti-types (DevOps Team Silo) mentioned
    on the DevOps topologies website.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.10 – DevOps team with expiration date (\uFEFFdiagram based on work\
    \ at devopstopologies.com – licensed under CC BY-SA)](img/B18756_03_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – DevOps team with expiration date (diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)
  prefs: []
  type: TYPE_NORMAL
- en: DevOps advocacy team
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DevOps advocacy team acts as a facilitator between Dev and Ops if the two
    departments tend to drift apart. Unlike the DevOps team with an expiration date,
    this DevOps team is kept on an ongoing basis, ensuring both Dev and Ops follow
    current DevOps practices.
  prefs: []
  type: TYPE_NORMAL
- en: Like the DevOps team with an expiration date, a DevOps advocacy team runs the
    risk of turning into a DevOps Team Silo.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – DevOps advocacy team (Diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)](img/B18756_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – DevOps advocacy team (Diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)
  prefs: []
  type: TYPE_NORMAL
- en: SRE team
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As far back as 2004, Google has used its software engineers as operations personnel.
    These **site reliability engineers** (**SREs**) handle the support of production
    environments, mostly by developing software to keep the resources and services
    running. SREs accept the application from Dev, but only if Dev provides enough
    evidence in the form of logs and metrics that it meets a quality threshold. If
    the code does not meet this standard, SREs can reject the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.12– SRE team (\uFEFFdiagram based on work at devopstopologies.com\
    \ – licensed under CC BY-SA)](img/B18756_03_12.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12– SRE team (diagram based on work at devopstopologies.com – licensed
    under CC BY-SA)
  prefs: []
  type: TYPE_NORMAL
- en: Container-driven collaboration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because containers abstract many of the infrastructure details, most collaboration
    between Dev and Ops is not necessary. In this case, a container-based deployment
    may be accepted by Ops most of the time if there is a sound engineering culture.
    If not monitored closely, there is a risk of changing to an anti-type where Ops
    is expected to deploy anything from Dev without question.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.13 – Container-driven collaboration (\uFEFFdiagram based on work\
    \ at devopstopologies.com – licensed under CC BY-SA)](img/B18756_03_13.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Container-driven collaboration (diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)
  prefs: []
  type: TYPE_NORMAL
- en: Dev and DBA collaboration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the applications an organization develops rely on one or more central databases,
    the collaboration between developers and the **database administrators** (**DBAs**)
    may be crucial. To enable that collaboration, the database developers in Dev work
    closely with the DBAs in operations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Dev and DBA collaboration (Diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)](img/B18756_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Dev and DBA collaboration (Diagram based on work at devopstopologies.com
    – licensed under CC BY-SA)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen possible configurations for organizing the team responsible
    for the CI/CD pipeline, let’s take a close look at such a team on the ART: the
    system team.'
  prefs: []
  type: TYPE_NORMAL
- en: The system team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The system team is the team on the ART that is responsible for the tooling and
    automation of the Continuous Delivery Pipeline. They work with the other teams
    on the ART to help in delivering valuable solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The system team may follow one of several DevOps topologies. The system team
    may be set up as a DevOps team with an expiration date. They will set up the Continuous
    Delivery Pipeline and instruct the Dev and Ops personnel on its use before disbanding.
    Another model for the system team may be being set up as a DevOps advocacy team.
  prefs: []
  type: TYPE_NORMAL
- en: As custodians of the automation and development process, they have deep responsibilities
    to the other teams on the ART. These responsibilities are described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Building infrastructure for solution development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The system team will often be responsible for setting up the pre-build, continuous
    integration, and continuous deployment portions of the CI/CD pipeline and integrating
    the technology so it’s a seamless part of the Continuous Delivery Pipeline. They
    strive to apply automation as much as possible. This may also involve close collaboration
    with other teams, so they may visit other teams’ events.
  prefs: []
  type: TYPE_NORMAL
- en: Spearheading solution integration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As part of maintaining the CI phase, the system team may be involved in determining
    the build process after a change has been committed to version control. They will
    maintain the proper build scripts and CI configuration files. If build automation
    is not yet available, they may be the team performing build and integration activities.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up end-to-end testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To support the other teams, the system team may help the testers with the creation
    and optimization of automated tests. They may also work with the other teams to
    aggregate separate tests into well-defined test suites for different types of
    testing, such as smoke testing.
  prefs: []
  type: TYPE_NORMAL
- en: Assisting with demos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ART integrates the work from all its teams and demonstrates the working
    state of the solution at a given point in time. This integration and demonstration
    is called the *system demo* and happens at a regular cadence.
  prefs: []
  type: TYPE_NORMAL
- en: As maintainers of the Continuous Delivery Pipeline, the system team is there
    to ensure that technical environments work for all teams so that the system demo
    is seamless.
  prefs: []
  type: TYPE_NORMAL
- en: Facilitating the release
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the system team has a holistic view of the process, they may be called
    upon to verify that deployments to production and final release are valid.
  prefs: []
  type: TYPE_NORMAL
- en: The system team can be considered the *DevOps* team for the ART. It may follow
    one of the DevOps topologies as a way of collaborating with the other Agile teams.
    Its responsibilities primarily involve configuring the automation, but it may
    assist the Agile teams in other ways as the entire ART endeavors to deliver value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automation plays a key role in DevOps. We looked at the important tools that
    make up a DevOps toolchain, especially those parts of the toolchain that are orchestrated
    from building and testing to deployment, creating the CI/CD pipeline or *the pipeline*.
  prefs: []
  type: TYPE_NORMAL
- en: CI typically includes activities that happen to code changes after they have
    been committed to version control. This may include preliminary testing, and upon
    passing, they may be built together and packaged into an artifact based on language
    and technology.
  prefs: []
  type: TYPE_NORMAL
- en: CD continues from where CI leaves off by taking the build artifacts and applying
    them to testing or production environments. Here, environments will be reconfigured,
    possibly with new resources. Additional testing will be performed to ensure security,
    correctness, and validation of anticipated value.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps topologies outline possible models of collaboration between Dev and Ops
    teams with the possible inclusion of people specializing in DevOps. Some of the
    topologies are not long-lasting, lest they turn into *anti-types* that stifle
    collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: In SAFe, the system team performs as the DevOps team on the ART. That team is
    responsible for constructing and maintaining the Continuous Delivery Pipeline
    for the other teams on the ART.
  prefs: []
  type: TYPE_NORMAL
- en: Automation does allow the ART or any DevOps team to deliver faster, but not
    if the development process is not optimized for Lean flow. In the next chapter,
    we will examine the practices from the Lean thinking movement that enable flow.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge of the concepts in this chapter by answering these questions.
  prefs: []
  type: TYPE_NORMAL
- en: What tests are examples of static analysis (pick two)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Linting
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: DAST
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Dependency scanning
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Acceptance tests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What allows code changes to be hidden in production until *turned on*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Version control
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Feature flags
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitoring includes activities such as performance monitoring, alerting, and
    what?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load testing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Version control
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Log collection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The original formulation of DevOps topologies, including three anti-types and
    five types: [https://blog.matthewskelton.net/2013/10/22/what-team-structure-is-right-for-devops-to-flourish/](https://blog.matthewskelton.net/2013/10/22/what-team-structure-is-right-for-devops-to-flourish/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'The updated formulation of DevOps topologies: [https://web.devopstopologies.com](https://web.devopstopologies.com'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*Team Topologies: Organizing Business and Technology Teams for Fast Flow* by
    Matthew Skelton and Manuel Pais – the evolution of DevOps topologies to look at
    topologies for all kinds of teams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
