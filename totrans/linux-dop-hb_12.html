<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer032">
<h1 class="chapter-number" id="_idParaDest-250"><a id="_idTextAnchor365"/><a id="_idTextAnchor366"/>12</h1>
<h1 id="_idParaDest-251"><a id="_idTextAnchor367"/>Leveraging Infrastructure as Code<a id="_idTextAnchor368"/></h1>
<p>In today’s digital landscape, managing and deploying infrastructure is a complex and time-consuming process. Traditionally, infrastructure deployment involves manually configuring each server, network, and storage device. This process is not only time-consuming but also prone to errors and inconsistencies. <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) solutions<a id="_idIndexMarker1075"/> provide an automated way to manage and deploy infrastructure. IaC solutions allow developers to treat infrastructure as code, enabling them to define, manage, and provision infrastructure in the same way they do <span class="No-Break">with code.</span></p>
<p>In this chapter, we will explore IaC solutions, with a focus on Terraform. <strong class="bold">Terraform</strong> is an <a id="_idIndexMarker1076"/>open source IaC tool that enables developers to define, manage, and provision infrastructure across multiple cloud providers and on-premises data centers. HashiCorp, the owner of Terraform and many other automation tools, changed the license<a id="_idIndexMarker1077"/> from <strong class="bold">Mozilla Public License</strong> (<strong class="bold">MPL</strong>) version <strong class="source-inline">2.0</strong> to <strong class="bold">Business Source License</strong> (<strong class="bold">BSL</strong>) version <strong class="source-inline">1.1</strong>. BSL allows <a id="_idIndexMarker1078"/>you to use Terraform freely and you can access its source code, so there is no change for the <span class="No-Break">end users.</span></p>
<p>With Terraform, developers can write code to define their infrastructure requirements, and Terraform will handle the provisioning and configuration of the required resources. Terraform has gained popularity in recent years due to its simplicity, flexibility, and support for multiple cloud providers. In the following sections, we will discuss the key features and benefits of Terraform, as well as how to use it to provision infrastructure on popular <span class="No-Break">cloud providers.</span></p>
<p>We will learn about the following topics in <span class="No-Break">this chapter:</span></p>
<ul>
<li>What <span class="No-Break">is IaC?</span></li>
<li>IaC versus Configuration <span class="No-Break">as Code</span></li>
<li>IaC projects <span class="No-Break">worth knowing</span></li>
<li><span class="No-Break">Terraform</span></li>
<li>HCL <span class="No-Break">in depth</span></li>
<li>Terraform examples <span class="No-Break">with <a id="_idTextAnchor369"/>AWS</span></li>
</ul>
<h1 id="_idParaDest-252">Technical requirements</h1>
<p>For this chapter, you will need a system capable of running Terraform. Terraform is a single binary program written in the Go programming language. Its installation is straightforward and is explained on the HashiCorp Terraform project page (<a href="https://developer.hashicorp.com/terraform/downloads">https://developer.hashicorp.com/terraform/downloads</a>). HashiCorp is the company behind Terraform and other cloud management tools that have become de facto standards in the DevOps world. You will also need an AWS account. AWS provides a Free Tier of services for a limited time. We are using services that have free tiers at the time of writing this book. Before you run the examples, please consult the AWS Free Tier listing to avoid <span class="No-Break">unnecessary cos<a id="_idTextAnchor370"/>ts.</span></p>
<h1 id="_idParaDest-253">What is IaC?</h1>
<p>IaC is a<a id="_idIndexMarker1079"/> software development practice that involves defining and managing infrastructure through code. In essence, it means that infrastructure is treated as if it were a piece of software, and is managed through the same processes and tools. IaC solutions enable developers to define, provision, and manage infrastructure using code, instead of manually configuring servers, networks, and storage devices. This approach to infrastructure management is highly automated, scalable, and efficient, allowing organizations to reduce deployment times and improve consistency <span class="No-Break">and reliability.</span></p>
<p>IaC solutions come in different forms, including configuration management tools, provisioning tools, and <a id="_idIndexMarker1080"/>cloud orchestration tools. Configuration management tools, such as <strong class="bold">Ansible</strong> and <strong class="bold">Chef</strong>, are <a id="_idIndexMarker1081"/>used to manage the configuration of individual servers or groups of servers. Provisioning tools, such as Terraform and <strong class="bold">CloudFormation</strong>, are<a id="_idIndexMarker1082"/> used to provision and configure infrastructure resources. Cloud orchestration tools, such<a id="_idIndexMarker1083"/> as <strong class="bold">Kubernetes</strong> and <strong class="bold">OpenShift</strong>, are<a id="_idIndexMarker1084"/> used to manage containerized applications and their associated infrastructure. Regardless of the specific tool used, IaC solutions offer several benefits, including repeatability <span class="No-Break">and con<a id="_idTextAnchor371"/>sistency.</span></p>
<h1 id="_idParaDest-254">IaC versus Configuration as Code</h1>
<p>You<a id="_idIndexMarker1085"/> might be <a id="_idIndexMarker1086"/>wondering, didn’t we just cover this in <a href="B18197_11.xhtml#_idTextAnchor325"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, when we spoke about Ansible? The answer is no, we didn’t. There’s a very distinctive difference between IaC and <strong class="bold">Configuration as Code</strong> (<strong class="bold">CaC</strong>). IaC tools are concerned with exactly that: infrastructure. This means networking, DNS names, routes, and servers (VM or physical) up to the installation of the operating system. CaC is concerned with what lives inside the operating system. People try to use one tool for everything, so you’ll see modules for Ansible that can configure switches and routers, but the tool shines best where it is intended to be used. Nobody is going to die if you mix these two, but your life will become <span class="No-Break">more<a id="_idTextAnchor372"/> difficult.</span></p>
<h1 id="_idParaDest-255">IaC projects worth knowing</h1>
<p>Since the <a id="_idIndexMarker1087"/>rise of the public cloud, especially AWS, the need for a repeatable and reliable way of setting up an infrastructure and configuring cloud services started to grow as well. Since then, a lot of tools have come to be and more of them are being developed. In this section, we will review the most popular and innovative tool<a id="_idTextAnchor373"/>s <span class="No-Break">out there.</span></p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor374"/>AWS CloudFormation</h2>
<p>AWS CloudFormation<a id="_idIndexMarker1088"/> is a popular IaC tool offered by <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>) to automate the provisioning of AWS resources. It was first released in 2011 and has since become a widely used tool for managing infrastructure in <span class="No-Break">the cloud.</span></p>
<p>CloudFormation <a id="_idIndexMarker1089"/>allows you to define the infrastructure in a declarative language, such as YAML or JSON, and then create, update, or delete stacks of resources based on those definitions. This allows for consistent and reproducible infrastructure deployments, as well as easy rollback and version control. It’s not all sparkles and rainbows, though – at times, you might find yourself stuck in a rollback loop after making an untested change. For example, let’s say you’re changing your AWS Lambda environment version. Unfortunately, it failed as the version you’re currently using is no longer supported. So, it is now stuck at rolling back and it’s in an <strong class="source-inline">UPDATE_ROLLBACK_FAILED</strong> state. You will need to resolve the issue by hand as there is no automated way of <span class="No-Break">doing that.</span></p>
<p>CloudFormation<a id="_idIndexMarker1090"/> integrates with other AWS services, such as AWS <strong class="bold">Identity and Access Management</strong> (<strong class="bold">IAM</strong>), AWS <strong class="bold">Elastic Load Balancing</strong> (<strong class="bold">ELB</strong>), and <a id="_idIndexMarker1091"/>AWS Auto Scaling, to enable the creation of complex architectures <span class="No-Break">with ease.</span></p>
<p>Here’s an <a id="_idIndexMarker1092"/>example CloudFormation stack written in YAML that creates an EC2 instance called <strong class="source-inline">t4g.small</strong> in a public subnet in the <span class="No-Break">default VPC:</span></p>
<pre class="source-code">
AWSTemplateFormatVersion: '2010-09-09'
Parameters:
  KeyName:
    Type: AWS::EC2::KeyPair::KeyName
    Default: admin-key
  InstanceType:
    Type: String
    Default: t4g.small
  SSHCIDR:
    Type: String
    MinLength: 9
    MaxLength: 18
    Default: 0.0.0.0/0
    AllowedPattern: (\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})
  LatestAmiId:
    Type:  'AWS::SSM::Parameter::Value&lt;AWS::EC2::Image::Id&gt;'
    Default: '/aws/service/canonical/ubuntu/server/jammy/stable/current/amd6/hvm/ebs-gp2/ami-id'
Resources:
  EC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref 'InstanceType'
      SecurityGroups: [!Ref 'InstanceSecurityGroup']
      KeyName: !Ref 'KeyName'
      ImageId: !Ref 'LatestAmiId'
  InstanceSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH access
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 22
        ToPort: 22
        CidrIp: !Ref 'SSHCIDR'
Outputs:
  InstanceId:
    Description: InstanceId of the newly created EC2 instance
    Value: !Ref 'EC2Instance'
  PublicDNS:
    Description: Public DNSName of the newly created EC2 instance
    Value: !GetAtt [EC2Instance, PublicDnsName]
  PublicIP:
    Description: Public IP address of the newly created EC2 instance
    Value: !GetAtt [EC2Instance, PublicIp]</pre>
<p>In this<a id="_idIndexMarker1093"/> stack, we’re creating two resources: an EC2 instance and a security group attached to this instance. The CloudFormation stack can get <span class="No-Break">four parameters:</span></p>
<ul>
<li><strong class="source-inline">KeyName</strong>: The SSH key name that was already created inside the AWS EC2 service. This defaults <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">admin-key</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">InstanceType</strong>: The type of the instance we want to start with. It defaults <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">t4g.small</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">SSHCIDR</strong>: The <strong class="bold">Classless Inter-Domain Routing</strong> (<strong class="bold">CIDR</strong>) of IP address(es) that <a id="_idIndexMarker1094"/>can connect to this machine via port <strong class="source-inline">22</strong>. This defaults to <strong class="source-inline">0.0.0.0/0</strong>. Here, we’re validating the provided input against the regular expression and the length of <span class="No-Break">the variable.</span></li>
<li><strong class="source-inline">LatestAmiId</strong>: The AMI ID to use as a base system to start the EC2 instance. This defaults to the latest AMI of Ubuntu <span class="No-Break">Linux </span><span class="No-Break"><strong class="source-inline">22.04</strong></span><span class="No-Break">.</span></li>
</ul>
<p>Next, there’s a <strong class="source-inline">Resources</strong> section. Here, the EC2 instance is created using the <strong class="source-inline">AWS::EC2::Instance</strong> resource type and the security group is created with the <span class="No-Break"><strong class="source-inline">AWS::EC2::SecurityGroup</strong></span><span class="No-Break"> resource.</span></p>
<p>The final section is called <strong class="source-inline">Outputs</strong>; here, we can reveal IDs and other properties of the resources created. Here, we’re exposing the instance ID, its public DNS name, and its public <span class="No-Break">IP address.</span></p>
<p>It’s possible to use these output values as input for another CloudFormation stack, which will make the YAML files of your CloudFormation code considerably smaller and <a id="_idTextAnchor375"/>easier <span class="No-Break">to maintain.</span></p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor376"/>AWS Cloud Development Kit</h2>
<p>AWS <strong class="bold">Cloud Development Kit</strong> (<strong class="bold">CDK</strong>) is<a id="_idIndexMarker1095"/> an open <a id="_idIndexMarker1096"/>source software development framework that’s used to define cloud infrastructure in code. With CDK, developers can write code in familiar programming languages such as TypeScript, Python, Java, C#, and JavaScript to create and manage cloud resources <span class="No-Break">on AWS.</span></p>
<p>AWS CDK <a id="_idIndexMarker1097"/>was first released in July 2018 as an open source project by AWS. It was designed to simplify the process of building and deploying cloud infrastructure by allowing developers to use their existing programming language skills and tools. With CDK, developers can define IaC and take advantage of the benefits of version control, automated testing, and <strong class="bold">continuous integration</strong>/<strong class="bold">continuous deployment</strong> (<strong class="bold">CI</strong>/<strong class="bold">CD</strong>) pipelines. Since<a id="_idIndexMarker1098"/> its release, CDK has become a popular choice for building infrastructure on AWS, and it continues to receive updates and new features to <span class="No-Break">this day.</span></p>
<p>Here’s an example of some AWS CDK Python code that creates an <span class="No-Break">EC2 instance:</span></p>
<pre class="source-code">
from aws_cdk import core
import aws_cdk.aws_ec2 as ec2
class MyStack(core.Stack):
    def __init__(self, scope: core.Construct, id: str, **kwargs) -&gt; None:
        super().__init__(scope, id, **kwargs)
        # VPC
        vpc = ec2.Vpc(self, "VPC",
            nat_gateways=0,
            subnet_configuration=[ec2.SubnetConfiguration(name="public",subnet_type=ec2.SubnetType.PUBLIC)]
            )
        # Get AMI
        amzn_linux = ec2.MachineImage.latest_amazon_linux(
            generation=ec2.AmazonLinuxGeneration.AMAZON_LINUX_2,
            edition=ec2.AmazonLinuxEdition.STANDARD,
            virtualization=ec2.AmazonLinuxVirt.HVM,
            storage=ec2.AmazonLinuxStorage.GENERAL_PURPOSE
            )
        # Create an EC2 instance
        instance = ec2.Instance(self, "Instance",
            instance_type=ec2.InstanceType("t4g.small"),
            machine_image=amzn_linux,
            vpc = vpc
        )</pre>
<p>This code<a id="_idIndexMarker1099"/> creates a new VPC and an EC2 instance with an instance type of <strong class="source-inline">t4g.small</strong> with Amazon Linux installed as the operating system. Note that you will need to have AWS CDK installed and conf<a id="_idTextAnchor377"/>igured to run <span class="No-Break">this code.</span></p>
<h2 id="_idParaDest-258"><a id="_idTextAnchor378"/>Terraform</h2>
<p>Terraform<a id="_idIndexMarker1100"/> is a<a id="_idIndexMarker1101"/> popular open source tool that’s used for infrastructure automation, specifically for creating, managing, and provisioning cloud resources. It enables developers to define their IaC and automates the deployment of their infrastructure across multiple cloud platforms. With Terraform, users can write declarative configuration files in a simple and intuitive language that can be versioned, shared, and reused. This approach to infrastructure management ensures consistency and scalability and reduces the risk of manual errors. Terraform supports a wide range of cloud providers, including AWS, Azure, Google Cloud, and more, making it a popular choice for organizations with complex cloud <span class="No-Break">infrastructure needs.</span></p>
<p>Terraform<a id="_idIndexMarker1102"/> was created by HashiCorp, a company founded in 2012 by Mitchell Hashimoto and Armon Dadgar. The company is known for developing popular open source tools for infrastructure automation, including Vagrant, Consul, Nomad, and Vault. Terraform was first released in July 2014 and has since become one of the most widely adopted IaC tools in the industry. HashiCorp continues to maintain and develop Terraform, with <a id="_idIndexMarker1103"/>regular releases and updates that address new cloud provider features, security vulnerabilities, and community feedback. The tool has a large and active community of contributors, which has helped to further enhance its functionality and support for new <span class="No-Break">use cases.</span></p>
<p>Terraform is also a main topic for this chapter, so we will dig into the code and its internals in <a id="_idTextAnchor379"/>the <em class="italic">Terraform</em> <span class="No-Break">section later.</span></p>
<h2 id="_idParaDest-259"><a id="_idTextAnchor380"/>Cloud Development Kit for Terraform</h2>
<p><strong class="bold">Cloud Development Kit for Terraform</strong> (<strong class="bold">CDKTF</strong>) is an open source software development<a id="_idIndexMarker1104"/> framework for <a id="_idIndexMarker1105"/>defining cloud infrastructure in code. It allows users to define infrastructure using familiar programming languages, such as TypeScript, JavaScript, Python, and C#. This provides developers with more flexibility and control over their infrastructure as they can leverage their existing programming skills and tools to define complex infrastructure. CDKTF was first released in 2019 as a collaboration between AWS and HashiCorp. Since then, it has gained popularity as a powerful tool for defining and deploying infrastructure <span class="No-Break">using Terraform.</span></p>
<p>CDKTF supports a wide range of programming languages, making it easy for developers to use their preferred language. It uses constructs, which are reusable building blocks that represent AWS resources, to create infrastructure. Users can define constructs for each resource they want to create, which can be combined to form a more complex infrastructure. This allows users to define their infrastructure in a modular and reusable way, which simplifies the process of creating and maintaining infrastructure <span class="No-Break">over time.</span></p>
<p>Here is the example code for creating an EC2 instance in AWS using CDKTF <span class="No-Break">in Python:</span></p>
<pre class="source-code">
from constructs import Construct
from cdktf import App, TerraformStack
from imports.aws import AwsProvider, Instance, SecurityGroup
class MyStack(TerraformStack):
    def __init__(self, scope: Construct, ns: str):
        super().__init__(scope, ns)
        # Configure AWS provider
        aws_provider = AwsProvider(self, 'aws', region='us-east-1')
        # Create a security group
        security_group = SecurityGroup(self, 'web-server-sg',
            name='web-server-sg',
            ingress=[
                {
                    'from_port': 22,
                    'to_port': 22,
                    'protocol': 'tcp',
                    'cidr_blocks': ['0.0.0.0/0'],
                },
                {
                    'from_port': 80,
                    'to_port': 80,
                    'protocol': 'tcp',
                    'cidr_blocks': ['0.0.0.0/0'],
                },
            ],
        )
        # Create an EC2 instance
        Instance(self, 'web-server',
            ami='ami-0c55b159cbfafe1f0',
            instance_type='t4g.small',
            security_groups=[security_group.id],
            user_data="""
                #!/bin/bash
                echo "Hello, DevOps People!" &gt; index.xhtml
                nohup python -m SimpleHTTPServer 80 &amp;
            """
        )
app = App()
MyStack(app, "my-stack")
app.synth()</pre>
<p>The <a id="_idIndexMarker1106"/>constructs, App, and<a id="_idIndexMarker1107"/> <strong class="source-inline">TerraformStack</strong> classes are imported from the <strong class="source-inline">cdktf</strong> package, while the AWS resources are imported from the <strong class="source-inline">imports.aws</strong> module. The preceding code creates an EC2 instance with a security group and a basic user data script that starts a simple HTTP server. The resulting infrastructure can be deployed using the <strong class="source-inline">cdktf deploy</strong> command, which generates Terraform configuration files and executes the <span class="No-Break">Terraform CLI.</span></p>
<p>You can read more <a id="_idIndexMarker1108"/>about CDKTF <span class="No-Break">at </span><a href="https://developer.hashicorp.com/terraform/cdktf"><span class="No-Break">https://develop<span id="_idTextAnchor381"/>er.hashicorp.com/terraform/cdktf</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-260"><a id="_idTextAnchor382"/>Pulumi</h2>
<p><strong class="bold">Pulumi</strong> is an <a id="_idIndexMarker1109"/>open source IaC tool that allows developers to build, deploy, and <a id="_idIndexMarker1110"/>manage cloud infrastructure using familiar programming languages. Unlike traditional IaC tools that rely on declarative languages such as YAML or JSON, Pulumi uses real programming languages, such as Python, TypeScript, Go, and .NET, to define and manage infrastructure. This enables developers to leverage their existing skills and experience to create infrastructure using the same tools and processes they use for building applications. With Pulumi, developers can create, test, and deploy infrastructure changes just like they do with code changes – that is, by using version control and <span class="No-Break">CI/CD tools.</span></p>
<p>The first release of Pulumi was in May 2018 and aimed to simplify the process of managing cloud infrastructure. Pulumi was founded by Joe Duffy, a former Microsoft engineer who previously worked on the development of the .NET runtime and compiler. Duffy saw an opportunity to use programming languages to manage infrastructure, providing a more flexible and powerful approach than traditional IaC tools. Since its release, Pulumi has gained popularity among developers, particularly those who work in cloud-native environments or who use multiple <span class="No-Break">cloud providers.</span></p>
<p>Pulumi supports a variety of programming languages, including Python, TypeScript, Go, .NET, and Node.js. Pulumi also provides a rich set of libraries and tools for working with cloud resources, including support for popular cloud providers such as AWS, Azure, Google Cloud, and Kubernetes. Additionally, Pulumi provides integrations with popular CI/CD tools, such as Jenkins, CircleCI, and GitLab, enabling developers to easily incorporate infrastructure changes into their <span class="No-Break">existing workflows.</span></p>
<p>Here’s an example of Pulumi code in Python that creates an AWS <span class="No-Break">EC2 instance:</span></p>
<pre class="source-code">
import pulumi
from pulumi_aws import ec2
# Create a new security group for the EC2 instance
web_server_sg = ec2.SecurityGroup('web-server-sg',
    ingress=[
        ec2.SecurityGroupIngressArgs(
            protocol='tcp',
            from_port=22,
            to_port=22,
            cidr_blocks=['0.0.0.0/0'],
        ),
    ],
)
# Create the EC2 instance
web_server = ec2.Instance('web-server',
    instance_type='t4g.small',
    ami='ami-06dd92ecc74fdfb36', # Ubuntu 22.04 LTS
    security_groups=[web_server_sg.name],
    tags={
        'Name': 'web-server',
        'Environment': 'production',
    },
)
# Export the instance public IP address
pulumi.export('public_ip', web_server.public_ip)</pre>
<p>This code defines an AWS security group that allows inbound traffic on port <strong class="source-inline">22</strong> (SSH), and then creates an EC2 instance of the <strong class="source-inline">t4g.small</strong> instance type, using an<a id="_idIndexMarker1111"/> Ubuntu 22.04 LTS AMI. The instance is associated with the security group we created earlier and is tagged with a name and environment. Finally, the public IP address of the instance is exported as a Pulumi stack output, which can be used by other resources in the stack or accessed by <span class="No-Break">the user.</span></p>
<p>In this section, we introduced several IaC solutions: CDK, CDKTF, Terraform, and Pulumi. Some of them<a id="_idIndexMarker1112"/> are targeted at one cloud provider, and some of them allow us to configure different <span class="No-Break">cloud environments.</span></p>
<p>In the next section, we will get back to Terraform to explore what makes it tick and learn how to use IaC in practice. This will give us a foundation to quickly understand other solutions, inc<a id="_idTextAnchor383"/>luding the CDKs we <span class="No-Break">mentioned earlier.</span></p>
<h1 id="_idParaDest-261">Terraform</h1>
<p>In this section, we are going to introduce Terraform, one of the most widely used IaC solutions in <span class="No-Break">the wild.</span></p>
<p>Terraform is<a id="_idIndexMarker1113"/> an IaC tool developed by HashiCorp. The rationale behind using it is similar to using Ansible to configure your systems: infrastructure configuration is kept in text files. They are not YAML, as with Ansible; instead, they are written in a special configuration language<a id="_idIndexMarker1114"/> developed by HashiCorp: <strong class="bold">HashiCorp Configuration Language</strong> (<strong class="bold">HCL</strong>). Text files are easily versioned, which means that infrastructure changes can be stored in a version control system such <span class="No-Break">as Git.</span></p>
<p>Actions performed by Terraform are more complicated than those you’ve seen in Ansible. A single HCL statement can mean setting up a whole bunch of virtual servers and routes between them. So, while Terraform is also declarative like Ansible, it is higher level than other tools. Also, contrary to Ansible, Terraform is state-aware. Ansible has a list of actions to perform and on each run, it checks which actions have already been applied. Terraform, on the other hand, records the last achieved state of the system and each time it is executed, it ensures the system will be as it is in <span class="No-Break">the code.</span></p>
<p>To achieve this, Terraform creates and maintains a state file. It is a text file with the <strong class="source-inline">.tfstate</strong> extension that records the last known state of the infrastructure that the tool is aware of. The state file is versioned internally; Terraform maintains a special counter that allows it to know whether the file is the latest one. The state file is essential for Terraform to work properly. You should never corrupt or lose the state file. If you lose this file, Terraform will try to create things that already exist and maybe delete things it <span class="No-Break">should not.</span></p>
<p>There are <a id="_idIndexMarker1115"/>several ways to ensure the state file is safe. One of them is to store it in an object store (such as S3) that’s been properly configured so that the state file cannot be deleted. For improved security, you can ensure that the file is versioned, which means that the storage will keep old copies of the file for <span class="No-Break">eventual reuse.</span></p>
<p>There is one important thing to be aware of related to <strong class="source-inline">.tfstate</strong>: it will contain all information related to your infrastructure, as well as plaintext passwords, logins, access keys, and such. It is crucial to keep the file secret and exclude it from commits to version control systems (in Git, add it to the <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitignore</strong></span><span class="No-Break"> file).</span></p>
<p>The code is developed in text files with the <strong class="source-inline">.tf</strong> extension. Contrary to Ansible, again, the order in which you place directives in the files is not important. Before execution, Terraform analyzes all <strong class="source-inline">.tf</strong> files in the current directory, creates a graph of dependencies between configuration elements, and orders them properly. It is a common occurrence that code is broken down into smaller <strong class="source-inline">.tf</strong> files that group related configuration directives. However, nothing is stopping you from keeping them all in one huge file, though it will quickly become too big for <span class="No-Break">comfortable use.</span></p>
<p>Even though you are free to name your files as you wish, so long as their extension is <strong class="source-inline">.tf</strong>, there are best practices to <span class="No-Break">be observed:</span></p>
<ul>
<li><strong class="source-inline">main.tf</strong>: This is the main file where you develop your configuration code. It will contain the resources, modules, and other <span class="No-Break">important information.</span></li>
<li><strong class="source-inline">variables.tf</strong>: This file will contain declarations of all the variables you wish to use in the <span class="No-Break"><strong class="source-inline">main.tf</strong></span><span class="No-Break"> file.</span></li>
<li><strong class="source-inline">outputs.tf</strong>: If the resources in your <strong class="source-inline">main.tf</strong> file produce any outputs, they are <span class="No-Break">declared here.</span></li>
<li><strong class="source-inline">versions.tf</strong>: This file declares the required versions of the Terraform binary itself and providers. It is good practice to declare the lowest versions known to work properly with <span class="No-Break">your code.</span></li>
<li><strong class="source-inline">providers.tf</strong>: If any of the providers need additional configuration, you would place them in <span class="No-Break">this file.</span></li>
<li><strong class="source-inline">backend.tf</strong>: This file contains the configuration for where Terraform should store the state file. The state file is an integral part of IaC in Terraform. We will talk about this in more depth in the <em class="italic">Terraform </em><span class="No-Break"><em class="italic">state</em></span><span class="No-Break"> subsection.</span></li>
</ul>
<p>The heavy<a id="_idIndexMarker1116"/> lifting in Ansible is done by Python programs called modules. In Terraform, it is done by <a id="_idIndexMarker1117"/>providers. <strong class="bold">Providers</strong> are small Golang programs that consume the configuration plan prepared by Terraform, connect with services (the cloud, devices, and more) through said services’ APIs, and execute the configuration. You can think of them as plugins. Providers deliver a set of resource types and, eventually, the data sources required to write configuration for the API that the provider connects to. The official explanation is that providers “<em class="italic">are a logical abstraction of an upstream API.</em>” Providers are usually published on Terraform Registry, which is a public repository of plugins maintained by HashiCorp. You can use separate registries, but providers published on Terraform Registry are known to be tested and trusted to work properly. Each provider published on this registry has extensive documentation with well-commented examples. Whenever you are using a new provider, you should visit the <a id="_idIndexMarker1118"/>registry (<a href="https://registry.terraform.io/">https://registry.terraform.io/</a>). An example of a provider is AWS. This provider exposes a very extensive number of resources that you would use to interact with AWS services to provision and configure them. Remember: the configuration is limited to infrastructure. You can couple Terraform (to provision VMs, for example) with Ansible (to install software and configure it within the VM) for a <span class="No-Break">full experience.</span></p>
<p>Let’s look at an <a id="_idIndexMarker1119"/>example of an AWS provider from the Terraform Registry AWS provider <span class="No-Break">documentation (</span><a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs"><span class="No-Break">https://registry.terraform.io/providers/hashicorp/aws/latest/docs</span></a><span class="No-Break">):</span></p>
<pre class="source-code">
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws" version = "~&gt; 4.0"
    }
  }
}
# Configure the AWS Provider
provider "aws" {
  region = "us-east-1"
}
# Create a VPC
resource "aws_vpc" "example" {
  cidr_block = "10.0.0.0/16"
}</pre>
<p>In the <a id="_idIndexMarker1120"/>preceding snippet, we declare that we require the AWS provider that will be downloaded from Terraform Registry. Its version should be no lower than <strong class="source-inline">4.0</strong>. Then, we configure the region that we are going to use (<strong class="source-inline">us-east-1</strong>). Finally, we create a virtual private<a id="_idIndexMarker1121"/> network (<strong class="bold">virtual private cloud</strong> (<strong class="bold">VPC</strong>)) and declare an IP block <span class="No-Break">for it.</span></p>
<p>The set of <strong class="source-inline">.tf</strong> files in a single directory is called a <strong class="bold">module</strong>. If you run Terraform commands in the directory where<a id="_idTextAnchor384"/> <a id="_idIndexMarker1122"/>module files lie, it is called a <span class="No-Break"><strong class="bold">root module</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor385"/>Terraform modules</h2>
<p>One of the <a id="_idIndexMarker1123"/>key concepts in Terraform is the module. A Terraform module is a collection of resources and their dependencies that can be used to build a specific component of your infrastructure. Modules provide a way to organize your code and make it reusable across multiple projects. They can be shared with other users and teams, and even published to a public registry such as <span class="No-Break">Terraform Registry.</span></p>
<p>When working with Terraform, it’s important to ensure that you are using compatible versions of your infrastructure provider. Providers are responsible for managing the resources in your cloud environment, and different versions may have different features or behaviors. To avoid unexpected changes to your infrastructure, you can pin the version of a provider that you are using in your Terraform configuration. This can be done by specifying a version constraint in the provider block, using the Terraform version constraint syntax. When you run Terraform, it will download and use the specified <a id="_idIndexMarker1124"/>version of the provider, ensuring that your infrastructure remains consistent <span class="No-Break">and predictable.</span></p>
<p>Here’s an example <strong class="source-inline">versions.tf</strong> file that pins the AWS provider to the latest version and requires at least version 1.0.0 <span class="No-Break">of Terraform:</span></p>
<pre class="source-code">
terraform {
  required_providers {
    aws = "&gt;= 3.0.0"
  }
  required_version = "&gt;= 1.0.0"
}</pre>
<p>In this example, we are using the <strong class="source-inline">required_providers</strong> block to specify that we require at least version 3.0.0 of the AWS provider. By using the <strong class="source-inline">&gt;=</strong> operator, we allow Terraform to use any version of the provider that is equal to or greater than 3.0.0, including the <span class="No-Break">latest version.</span></p>
<p>Terraform will automatically download and use the latest version of the provider when we run <strong class="source-inline">terraform init</strong>. This command will also update or download other modules you might be using within the main one (or a root module). However, using a lot of modules that are using other modules is discouraged as it can cause dependency conflicts (for example, some old modules might require AWS provider version 1.23 when a root module requires version 3.0 or newer). We will get back to the CLI later in this chapter in the <em class="italic">Terraform </em><span class="No-Break"><em class="italic">CLI</em></span><span class="No-Break"> subsection.</span></p>
<p>To refer to another module, you can use the <strong class="source-inline">module</strong> code block. Let’s say we have a simple module in the <strong class="source-inline">./module/aws_ec2</strong> directory relative to the root module. The <strong class="source-inline">aws_ec2</strong> module expects to be fed with the <strong class="source-inline">ami</strong>, <strong class="source-inline">subnet</strong>, <strong class="source-inline">vpc</strong>, and <span class="No-Break"><strong class="source-inline">security_group</strong></span><span class="No-Break"> variables:</span></p>
<pre class="source-code">
module "aws_ec2_instance" {
  source = "./modules/aws_ec2"
  ami            = "ami-06dd92ecc74fdfb36"
  subnet_id      = "subnet-12345678"
  vpc_id         = "vpc-12345678"
  security_group = "sg-12345678"
}</pre>
<p>If a module<a id="_idIndexMarker1125"/> exposes some outputs (variables you can use as input for a resource or other module), you can refer to them with <strong class="source-inline">module.NAME.OUTPUT_NAME</strong>. In this case, we could expose the ID of the EC2 instance, so you could refer to it with the <span class="No-Break">name </span><span class="No-Break"><strong class="source-inline">module.aws_ec2_instance.instance_id</strong></span><span class="No-Break">.</span></p>
<p>There are several other ways to specify the source argument when referring to a module in Terraform than using a <span class="No-Break">local path:</span></p>
<ul>
<li>The module can be stored and retrieved from a <span class="No-Break">Git repository:</span><pre class="source-code">
module "example" {</pre><pre class="source-code">
  source = "git::https://github.com/example-org/example-module.git"</pre><pre class="source-code">
}</pre><p class="list-inset">With a Git repository, you’re also able to refer to a commit ID, branch, <span class="No-Break">or tag:</span></p><pre class="source-code">
module "example" {</pre><pre class="source-code">
  source = "git::https://github.com/example-org/example-module.git?ref=branch_name"</pre><pre class="source-code">
}</pre><p class="list-inset">For the private repository, you will want to use SSH instead of HTTPS to clone <span class="No-Break">it locally:</span></p><pre class="source-code">
module "example" {</pre><pre class="source-code">
  source = "git::ssh://github.com/example-org/example-module.git?ref=branch_name"</pre><pre class="source-code">
}</pre></li>
<li>The module can be published and retrieved from <span class="No-Break">Terraform Registry:</span><pre class="source-code">
module "example" {</pre><pre class="source-code">
  source = "hashicorp/example-module/aws"</pre><pre class="source-code">
}</pre><p class="list-inset">In this case, you can specify a module version with the version property, <span class="No-Break">like so:</span></p><pre class="source-code">
module "example" {</pre><pre class="source-code">
  source = "hashicorp/example-module/aws"</pre><pre class="source-code">
  version = "1.0.0"</pre><pre class="source-code">
}</pre></li>
<li>The <a id="_idIndexMarker1126"/>module can be stored and retrieved from an <span class="No-Break">S3 bucket:</span><pre class="source-code">
module "example" {</pre><pre class="source-code">
  source = "s3::https://s3-eu-cental-1.amazonaws.com/example-bucket/example-module.zip"</pre><pre class="source-code">
}</pre></li>
</ul>
<p>You can find other possible sources in the official <span class="No-Break">documentation: </span><a href="https://developer.hashicorp.com/terraform/language/modules/sources"><span class="No-Break">https://develope<span id="_idTextAnchor386"/>r.hashicorp.com/terraform/language/modules/sources</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor387"/>Terraform state</h2>
<p>One of the <a id="_idIndexMarker1127"/>essential concepts of Terraform is the state file. It is a JSON file that describes the current state of your infrastructure. This file is used to keep track of the resources that Terraform has created, updated, or deleted, and it also stores the configurations for <span class="No-Break">each resource.</span></p>
<p>The purpose of the state file is to enable Terraform to manage your infrastructure consistently and reliably. By keeping track of the resources that Terraform has created or modified, the state file ensures that subsequent runs of Terraform will know the current state of your infrastructure and can make changes accordingly. Without the state file, Terraform would not know which resources are currently deployed and would be unable to make informed decisions about how to proceed with <span class="No-Break">subsequent changes.</span></p>
<p>The state file is also used as a source of truth for Terraform’s <strong class="source-inline">plan</strong> and <strong class="source-inline">apply</strong> operations. When you run <strong class="source-inline">terraform plan</strong> or <strong class="source-inline">terraform apply</strong>, Terraform will compare the current state of your infrastructure with the desired state, as defined in your Terraform code. The state file is used to determine what changes need to be made to bring your <a id="_idIndexMarker1128"/>infrastructure into the desired state. Overall, the state file is a crucial component of Terraform’s infrastructure management capabilities and enables Terraform to ensure the consistency and reliability of <span class="No-Break">your infrastructure.</span></p>
<p>While the Terraform state file is a critical component of the tool, there are some downsides and challenges associated with <span class="No-Break">using it.</span></p>
<p>The state file is a centralized file that is used to store information about your infrastructure. While this can be convenient, it can also create issues when working in a team setting, especially if multiple users are making changes to the same infrastructure concurrently. This can lead to conflicts and make it challenging to keep the state file up to date. It’s mitigated by the use of the distributed locking mechanism. In AWS environments, it’s simply a DynamoDB table with a lock entry with a state of <strong class="source-inline">0</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
<p>Another downside of Terraform state is that the state file contains sensitive information about your infrastructure, such as passwords, keys, and IP addresses. Therefore, it’s essential to protect the state file from unauthorized access. If the state file is compromised, an attacker could potentially gain access to your infrastructure or sensitive data. Inside AWS, the state file is usually kept in an S3 bucket, which is necessary with enabled encryption and blocked <span class="No-Break">public access.</span></p>
<p>The state file can become large and unwieldy over time, especially if you’re managing a large infrastructure with many resources. This can make it challenging to manage and maintain the state file, which can lead to errors <span class="No-Break">and inconsistencies.</span></p>
<p>The next challenge we may encounter with state files is that Terraform state files are version-specific. This means that you must use the same version of Terraform to manage the state file as you did to create it. This can create issues when upgrading to a newer version of Terraform as you may need to migrate the state file to the <span class="No-Break">new format.</span></p>
<p>Finally, Terraform’s state file has some limitations, such as the inability to manage external resources or the difficulty of handling complex dependencies between resources. This can create challenges when working with certain types of infrastructure or when dealing with <span class="No-Break">complex deployments.</span></p>
<p>Another feature that comes with the state file is enforcing the configuration of the resources Terraform manages. If someone makes a manual change, you will see it on the next <strong class="source-inline">terraform plan</strong> or <strong class="source-inline">terraform apply</strong> and those changes will be <span class="No-Break">rolled back.</span></p>
<p>With all that in mind, Terraform is<a id="_idIndexMarker1129"/> still one of the best solutions out there and most of these challenges can easily be mitigated when planning <span class="No-Break">our infrastructure.</span></p>
<p>Here’s an example <strong class="source-inline">backend.tf</strong> file that configures Terraform to use an S3 bucket named <strong class="source-inline">state-files</strong> for storing the state file and a DynamoDB table named <strong class="source-inline">terraform</strong> for <span class="No-Break">state locking:</span></p>
<pre class="source-code">
terraform {
  backend "s3" {
    bucket         = "state-files"
    key            = "terraform.tfstate"
    region         = "eu-central-1"
    dynamodb_table = "terraform"
  }
}</pre>
<p>In this configuration, the backend block specifies that we want to use the <strong class="source-inline">s3</strong> backend type, which is designed to store the state file in an S3 bucket. The <strong class="source-inline">bucket</strong> parameter specifies the name of the bucket where the state file should be stored, and the <strong class="source-inline">key</strong> parameter specifies the name of the state file within <span class="No-Break">the bucket.</span></p>
<p>The <strong class="source-inline">region</strong> parameter specifies the AWS region where the bucket is located. You should set this to the region that makes the most sense for your <span class="No-Break">use case.</span></p>
<p>Finally, the <strong class="source-inline">dynamodb_table</strong> parameter specifies the name of the DynamoDB table that will be used for state locking. This is an important feature of the S3 backend as it ensures that only one user at a time can make changes to <span class="No-Break">the infrastructure.</span></p>
<p>Here’s an example of the Terraform <span class="No-Break">state file:</span></p>
<pre class="source-code">
{
    "version": 3,
    "serial": 1,
    "lineage": "f763e45d-ba6f-9951-3498-cf5927bc35c7",
    "backend": {
        "type": "s3",
        "config": {
            "access_key": null,
            "acl": null,
            "assume_role_policy": null,
            "bucket": "terraform-states",
            "dynamodb_endpoint": null,
            "dynamodb_table": "terraform-state-lock",
            "encrypt": true,
            "endpoint": null,
            "external_id": null,
            "force_path_style": null,
            "iam_endpoint": null,
            "key": "staging/terraform.tfstate",
            "kms_key_id": null,
            "lock_table": null,
            "max_retries": null,
            "profile": null,
            "region": "eu-central-1",
            "role_arn": null,
            "secret_key": null,
            "session_name": null,
            "shared_credentials_file": null,
            "skip_credentials_validation": null,
            "skip_get_ec2_platforms": null,
            "skip_metadata_api_check": null,
            "skip_region_validation": null,
            "skip_requesting_account_id": null,
            "sse_customer_key": null,
            "sts_endpoint": null,
            "token": null,
            "workspace_key_prefix": null
        },
        "hash": 1619020936
    },
    "modules": [
        {
            "path": [
                "root"
            ],
            "outputs": {},
            "resources": {},
            "depends_on": []
        }
    ]
}</pre>
<p>By using<a id="_idIndexMarker1130"/> the S3 backend with DynamoDB state locking, you can ensure that your Terraform deployments are safe and consistent, even in a team environment where multiple users may be making changes to the same <span class="No-Break">infrastructure concurrently.</span></p>
<p>In the next subsection, we will discuss how to use the Terraform CL<a id="_idTextAnchor388"/>I and interact with our infrastructure and <span class="No-Break">state files.</span></p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor389"/>Terraform CLI</h2>
<p>The core <a id="_idIndexMarker1131"/>of Terraform is its command-line tool called, aptly, <strong class="source-inline">terraform</strong>. We linked the guide for installation when introducing Terraform to you. While there are tools to automate the workflow that remove the necessity of using the CLI, the use of the tool is simple and there is a lot of useful knowledge to be gained from working with it. In this section, we are going to introduce the most<a id="_idTextAnchor390"/> common options and workflows for the <span class="No-Break"><strong class="source-inline">terraform</strong></span><span class="No-Break"> command.</span></p>
<h3>Initializing the work environment</h3>
<p>The<a id="_idIndexMarker1132"/> very first subcommand of <strong class="source-inline">terraform</strong> you will use is <strong class="source-inline">terraform init</strong>. After you write your first portion of the <strong class="source-inline">main.tf</strong> file (if you follow the proposed module structure), you will run <strong class="source-inline">terraform init</strong> to download the required plugins and create some important directories and <span class="No-Break">helper files.</span></p>
<p>Let’s consider a portion of the first piece of code we <span class="No-Break">used previously:</span></p>
<pre class="source-code">
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws" version = "~&gt; 4.0"
    }
  }
}</pre>
<p>This code informs Terraform about the required plugin to be downloaded and its minimum version. Now, let’s run the <strong class="source-inline">terraform </strong><span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ terraform init
Initializing the backend...
Initializing provider plugins...
- Finding latest version of hashicorp/aws...
- Installing hashicorp/aws v4.58.0...
- Installed hashicorp/aws v4.58.0 (signed by HashiCorp)
Terraform has been successfully initialized!</pre>
<p>We <a id="_idIndexMarker1133"/>have shortened the output for brevity, but the most important part is there. You will see Terraform telling you what actions have been performed. The backend is the storage area for keeping the <strong class="source-inline">.tfstate</strong> file. If you don’t specify a storage area, the <strong class="source-inline">.tfstate</strong> file will be saved into <strong class="source-inline">terraform.tfstate</strong> in the local directory. There’s also a new subdirectory called <strong class="source-inline">.terraform</strong> where required plugins were installed. Finally, a <strong class="source-inline">.terraform.lock.hcl</strong> file exists, where Terraform records the versions of the providers that have been used so that you can keep them for <span class="No-Break">compatibility reasons.</span></p>
<p>The <strong class="source-inline">terraform init</strong> command is a safe command. You can r<a id="_idTextAnchor391"/>un it as many times as you wish; it won’t <span class="No-Break">break anything.</span></p>
<h3>Planning changes</h3>
<p>The next command <a id="_idIndexMarker1134"/>to run would be <strong class="source-inline">terraform fmt</strong>. This command formats your <strong class="source-inline">.tf</strong> files according to the best practices in place. Using it increases the readability and maintainability of your code, making all source files adhere to the same formatting strategy in all Terraform projects you will see. Running <strong class="source-inline">terraform fmt</strong> on our example will yield the <span class="No-Break">following output:</span></p>
<pre class="console">
admin@myhome:~$ terraform fmt
│ Error: Missing attribute separator
│
│   on main.tf line 4, in terraform:
│    3:     aws = {
│    4:       source = "hashicorp/aws" version = "~&gt; 4.0"
│
│ Expected a newline or comma to mark the beginning of the next attribute.</pre>
<p>You <a id="_idIndexMarker1135"/>will notice that <strong class="source-inline">fmt</strong> caught a glaring error in my <strong class="source-inline">main.tf</strong> file. It is not only a readability issue; it may also introduce errors in code interpretation with some providers. I have put two attributes on one line. Editing it so that it looks like this fixes <span class="No-Break">the issue:</span></p>
<pre class="source-code">
terraform {
  required_providers {
    aws = {
      source = "hashicorp/aws"
      version = "~&gt; 4.0"
    }
  }
}</pre>
<p>With this change, <strong class="source-inline">fmt</strong> is satisfied and we can proceed to the <span class="No-Break">next step.</span></p>
<p>The plan of action is built by using the <strong class="source-inline">terraform plan</strong> command. It takes the last known recorded state of your infrastructure (<strong class="source-inline">terraform.tfstate</strong>), compares it to the code in the directory, and prepares steps to make them match. Running <strong class="source-inline">terraform plan</strong> with our preceding example code yields the <span class="No-Break">following output:</span></p>
<pre class="console">
admin@myhome:~$ terraform plan
No changes. Your infrastructure matches the configuration.
Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed.</pre>
<p>Since<a id="_idIndexMarker1136"/> we have not introduced any code that would create any resource, Terraform informed us that no changes <span class="No-Break">are planned.</span></p>
<p>This, however, is not very interesting. Therefore, we are going to show you something that will create some resources <span class="No-Break">in AWS.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">Before you follow this example, please consult your liability for the Free Tier services in AWS. Running these examples can incur a cost and neither the authors of this guide nor the publisher can claim any responsibility for them if they <span class="No-Break">do occur.</span></p>
<p>If you want to follow these examples, you will need to have an AWS account (which is free at the time of writing this book). Then, you will need to create a role and generate <strong class="source-inline">AWS_ACCESS_KEY_ID</strong> and <strong class="source-inline">AWS_SECRET_ACCESS_KEY</strong>. Doing so is outside the scope of <span class="No-Break">this chapter.</span></p>
<p>We have edited the preceding example slightly. The <strong class="source-inline">required_providers</strong> block has been moved to <strong class="source-inline">providers.tf</strong>. We have also added another provider block there. The file looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~&gt; 4.0"
    }
  }
}
provider "aws" {
  region = "us-west-2"
}</pre>
<p>Notice that the new block is configuring a new provider resource called <strong class="source-inline">aws</strong>. The name (<strong class="source-inline">aws</strong>) is actually up to us and could be anything. Remember to give meaningful names, ones that will help you understand the code later on. We have provided a bare minimum of configuration for this provider, which is specifying a region where our resource will <span class="No-Break">be started.</span></p>
<p>We do<a id="_idIndexMarker1137"/> the actual work in the newly created empty <span class="No-Break"><strong class="source-inline">main.tf</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
resource "aws_instance" "vm_example" {
  ami           = "ami-830c94e3"
  instance_type = "t2.micro"
  tags = {
    Name = "DevOpsGuideTerraformExample"
}</pre>
<p>Here, we inform Terraform that we want to create a new resource of the <strong class="source-inline">aws_instance</strong> type. We are calling it <strong class="source-inline">vm_example</strong>. Next, we tell the tool to use a VM image (AMI) called <strong class="source-inline">ami-830c94e3</strong>. The instance’s type (how much RAM it is going to have, how many CPU cores, how big the system drive is, and more) is <strong class="source-inline">t2.micro</strong>. Finally, we add a tag that can help us identify and search for <span class="No-Break">this instance.</span></p>
<p>Let’s call <strong class="source-inline">terraform plan</strong> and <span class="No-Break">apply it:</span></p>
<pre class="console">
admin@myhome:~$ terraform plan
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create
Terraform will perform the following actions:
  # aws_instance.vm_example will be created
  + resource "aws_instance" "vm_example" {
      + ami                                  = "ami-830c94e3"
[...]
      + tags                                 = {
          + "Name" = "DevOpsGuideTerraformExample"
        }
      + tags_all                             = {
          + "Name" = "DevOpsGuideTerraformExample"
        }
      + tenancy                              = (known after apply)
[...]
      + vpc_security_group_ids               = (known after apply)
    }
Plan: 1 to add, 0 to change, 0 to destroy.
────────────────────────────────────────────────────────────────────</pre>
<p class="callout-heading">Note</p>
<p class="callout">You didn’t use the <strong class="source-inline">-out</strong> option to save this plan, so Terraform can’t guarantee to take exactly these actions if you run <strong class="source-inline">terraform </strong><span class="No-Break"><strong class="source-inline">apply</strong></span><span class="No-Break"> now.</span></p>
<p>We’ve <a id="_idIndexMarker1138"/>cut out a lot of the output from the plan. However, you can see that it differs from the previous example. Terraform noticed that we don’t have a VM with the specified parameters (remember, it compares to the <strong class="source-inline">.tfstate</strong> file). So, it is going to create one. We can always see the summary on the line starting with <strong class="source-inline">Plan</strong>. In the plan, all attributes starting with <strong class="source-inline">+</strong> (plus sign) will be created. Everything starting with <strong class="source-inline">-</strong> (minus sign) will be destroyed and everything with <strong class="source-inline">~</strong> (tilde) in front of it will <span class="No-Break">be modified.</span></p>
<p>Be cautious with Terraform when changing attributes of already created resources. More often than not, it will treat it as something new, especially if you change names. This will result in destroying the VM with the old name and creating<a id="_idTextAnchor392"/> a new one with a new name. This is probably not what <span class="No-Break">you want.</span></p>
<h3>Applying changes</h3>
<p>The<a id="_idIndexMarker1139"/> plan is being implemented by calling <strong class="source-inline">terraform apply</strong>. This command will introduce changes to your environment if your <strong class="source-inline">.tf</strong> files differ from your <strong class="source-inline">.tfstate</strong> file. Also, if your actual running infrastructure differs from your <strong class="source-inline">.tfstate</strong> file, <strong class="source-inline">terraform apply</strong> will do its best to re-align the live infrastructure with the Terraform <span class="No-Break">state file:</span></p>
<pre class="console">
admin@myhome:~$ terraform apply
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create
Terraform will perform the following actions:
  # aws_instance.vm_example will be created
  + resource "aws_instance" "vm_example" {
      + ami                                  = "ami-830c94e3"
[...]
      + subnet_id                            = (known after apply)
      + tags                                 = {
          + "Name" = "DevOpsGuideTerraformExample"
        }
      + tags_all                             = {
          + "Name" = "DevOpsGuideTerraformExample"
        }
      + tenancy                              = (known after apply)
[...]
      + vpc_security_group_ids               = (known after apply)
    }
Plan: 1 to add, 0 to change, 0 to destroy.
Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.
  Enter a value: yes
aws_instance.vm_example: Creating...
aws_instance.vm_example: Still creating... [10s elapsed]
aws_instance.vm_example: Still creating... [20s elapsed]
aws_instance.vm_example: Still creating... [30s elapsed]
aws_instance.vm_example: Still creating... [40s elapsed]
[...]
aws_instance.vm_example: Still creating... [1m20s elapsed]
aws_instance.vm_example: Creation complete after 1m29s [id=i-0a8bee7070b7129e5]
Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</pre>
<p>Again, a lot<a id="_idIndexMarker1140"/> of the output has been cut out <span class="No-Break">for brevity.</span></p>
<p>The <strong class="source-inline">terraform apply</strong> command created a plan again. We can avoid this by recording <strong class="source-inline">terraform plan</strong> into a file and later feeding the file to the <span class="No-Break"><strong class="source-inline">apply</strong></span><span class="No-Break"> step.</span></p>
<p>The interesting part is the confirmation step, where Terraform asks you to type in <strong class="source-inline">yes</strong> before it proceeds. Then, it is going to print out a summary of performed actions every 10 seconds. After you’ve spent some time working with Terraform, you will usually guess whether the action was successful by the time it takes it <span class="No-Break">to finish.</span></p>
<p>In the AWS console, in the <strong class="bold">Instances</strong> menu, we can observe that the VM has <span class="No-Break">been created:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<img alt="Figure 12.1 – New VM instances created via Terraform" height="356" src="image/B18197_12_01.jpg" width="1406"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – New VM instances created via Terraform</p>
<p>We can delete all the infrastructure we have just created by running <span class="No-Break"><strong class="source-inline">terraform destroy</strong></span><span class="No-Break">.</span></p>
<p>An interesting<a id="_idIndexMarker1141"/> thing to note is that at no point in our workflow have we told Terraform what files it should interpret. This is because, as mentioned previously, it will read all <strong class="source-inline">.tf</strong> files in the current directory and create a proper plan <span class="No-Break">of execution.</span></p>
<p>If you are interested in seeing the hierarchy of steps, Terraform provides the <strong class="source-inline">terraform graph</strong> command, which will print it out <span class="No-Break">for you:</span></p>
<pre class="console">
admin@myhome:~$ terraform graph
digraph {
     compound = "true"
     newrank = "true"
     subgraph "root" {
          "[root] aws_instance.vm_example (expand)" [label = "aws_instance.vm_example", shape = "box"]
          "[root] provider[\"registry.terraform.io/hashicorp/aws\"]" [label = "provider[\"registry.terraform.io/hashicorp/aws\"]", shape = "diamond"]
          "[root] aws_instance.vm_example (expand)" -&gt; "[root] provider[\"registry.terraform.io/hashicorp/aws\"]"
          "[root] provider[\"registry.terraform.io/hashicorp/aws\"] (close)" -&gt; "[root] aws_instance.vm_example (expand)"
          "[root] root" -&gt; "[root] provider[\"registry.terraform.io/hashicorp/aws\"] (close)"
     }
}</pre>
<p>There are tools out there that can create<a id="_idTextAnchor393"/> a nice visual representation of the graph produced <span class="No-Break">by Terraform.</span></p>
<h3>Modifying Terraform state</h3>
<p>Occasionally, there’s a<a id="_idIndexMarker1142"/> need to modify the resources in the state file. In the older versions of Terraform, this had to be done manually and was error-prone. Thankfully, Terraform developers added some CLI commands that could help us <span class="No-Break">with that.</span></p>
<p>The most useful commands are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">Terraform state rm</strong>: This <a id="_idIndexMarker1143"/>command removes the resource from the state. This is useful when we’ve removed the resource manually and from the Terraform code but it persists in <span class="No-Break">the state.</span></li>
<li><strong class="source-inline">terraform state mv</strong>: This<a id="_idIndexMarker1144"/> command changes the name of the resource. This is useful when we change the resource name to prevent the removal and creation of a new resource, which often isn’t the <span class="No-Break">desired behavio<a id="_idTextAnchor394"/>r</span></li>
<li><strong class="source-inline">terraform taint</strong>: This command<a id="_idIndexMarker1145"/> forces the resource to <span class="No-Break">be recreated.</span></li>
</ul>
<h3>Importing existing resources</h3>
<p>Importing <a id="_idIndexMarker1146"/>existing resources into Terraform allows you to include those resources in your Terraform state, which is a snapshot of the resources managed <span class="No-Break">by Terraform.</span></p>
<p>The <strong class="source-inline">terraform import</strong> command <a id="_idIndexMarker1147"/>is used to add an existing resource to your Terraform state. This command maps the existing resource to a configuration block in your Terraform code, which allows you to manage the resource <span class="No-Break">using Terraform.</span></p>
<p>The syntax for the <strong class="source-inline">terraform import</strong> command is <span class="No-Break">as follows:</span></p>
<pre class="console">
terraform import [options] resource_in_code resource_identifier</pre>
<p>The two important arguments for the <strong class="source-inline">terraform import</strong> command are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">resource_in_code</strong>: The address of the resource in your <span class="No-Break">Terraform code</span></li>
<li><strong class="source-inline">resource_identifier</strong>: The unique identifier of the resource you want <span class="No-Break">to import</span></li>
</ul>
<p>For example, let’s say you have an existing AWS S3 bucket with an <strong class="bold">Amazon Resource Names</strong> (<strong class="bold">ARN</strong>) of <strong class="source-inline">arn:aws:s3:::devopsy-bucket</strong>. To import this resource into your Terraform state, you can run the <span class="No-Break">following command:</span></p>
<pre class="console">
terraform import aws_s3_bucket.devopsy_bucket arn:aws:s3:::devopsy-bucket</pre>
<p>Importing resources <a id="_idIndexMarker1148"/>is useful when you have pre-existing infrastructure that you want to manage using Terraform. This is often the case when you are starting to use Terraform on an existing project or when you have resources that were created outside of Terraform. Importing resources allows you to bring those resources under Terraform management, so you can use Terraform to make changes to them in <span class="No-Break">the future.</span></p>
<p>Not all resources can be imported into Terraform. The resource you intend to import must have a unique identifier that Terraform can use to locate it in the remote service. Additionally, th<a id="_idTextAnchor395"/>e resource must be supported by the provider you are using <span class="No-Break">in Terraform.</span></p>
<h3>Workspaces</h3>
<p>Terraform<a id="_idIndexMarker1149"/> has a notion of a workspace. A <strong class="bold">workspace</strong> is similar<a id="_idIndexMarker1150"/> to the version of the state. Workspaces allow you to store different states for the same code. To be able to use workspaces, you have to store your state file in a backend that supports them. The list of backends that support workspaces is quite long and covers the most popular <span class="No-Break">cloud providers.</span></p>
<p>These workspaces are available in <strong class="source-inline">.tf</strong> files via the <strong class="source-inline">${terraform.workspace}</strong> sequence. Along with conditional expressions, this allows you to create varying environments. For example, you can use different IP addresses, depending on the workspace, allowing you to specify testing and <span class="No-Break">production environments.</span></p>
<p>There is always one workspace present: <strong class="source-inline">default</strong>. It can’t be removed. Workspace manipulation can be done using the <strong class="source-inline">terraform </strong><span class="No-Break"><strong class="source-inline">workspace</strong></span><span class="No-Break"> command.</span></p>
<p>We can easily inspect what workspaces we have and which one is active using the <strong class="source-inline">terraform </strong><span class="No-Break"><strong class="source-inline">list</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ terraform workspace list
* default</pre>
<p>The one with an asterisk in front of it is the current one. If we’re only interested in seeing the current workspace and not the whole list, we can run the <strong class="source-inline">terraform </strong><span class="No-Break"><strong class="source-inline">show</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ terraform workspace show
default</pre>
<p>Each <a id="_idIndexMarker1151"/>workspace will have a state file. Let’s experiment: we will create a new workspace called <strong class="source-inline">testing</strong> and apply Terraform to the <span class="No-Break">testing workspace.</span></p>
<p>First, we must call <strong class="source-inline">terraform workspace new</strong> to create <span class="No-Break">the workspace:</span></p>
<pre class="console">
admin@myhome:~$ terraform workspace new testing
Created and switched to workspace "testing"!
You're now on a new, empty workspace. Workspaces isolate their state,
so if you run "terraform plan" Terraform will not see any existing state
for this configuration.</pre>
<p>Now, we must confirm that we are actually in the new workspace and run <strong class="source-inline">terraform apply</strong> in it using our <span class="No-Break">previous example:</span></p>
<pre class="console">
admin@myhome:~$ terraform apply
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create
Terraform will perform the following actions:
  # aws_instance.vm_example will be created
  + resource "aws_instance" "vm_example" {
      + ami                                  = "ami-830c94e3"
[...]
Plan: 1 to add, 0 to change, 0 to destroy.
Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.
  Enter a value: yes
aws_instance.vm_example: Creating...
aws_instance.vm_example: Still creating... [10s elapsed]
aws_instance.vm_example: Still creating... [20s elapsed]
aws_instance.vm_example: Still creating... [30s elapsed]
aws_instance.vm_example: Still creating... [40s elapsed]
aws_instance.vm_example: Still creating... [50s elapsed]
aws_instance.vm_example: Creation complete after 57s [id=i-06cf29fde369218e2]
Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</pre>
<p>As you can see, we successfully created the VM. However, when we change the workspace back to the default one, suddenly, Terraform will want to create <span class="No-Break">it again:</span></p>
<pre class="console">
admin@myhome:~$ terraform workspace switch default
Switched to workspace "default".
admin@myhome:~$ terraform apply
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create
Terraform will perform the following actions:
  # aws_instance.vm_example will be created
  + resource "aws_instance" "vm_example" {
[...]</pre>
<p>Even though<a id="_idIndexMarker1152"/> the creation of the resource was successful, Terraform will want to create it anew. When we inspect the directory where our <strong class="source-inline">.tf</strong> files live, we will spot the <strong class="source-inline">.tfstate</strong> file that is connected to the default workspace and a new directory called <strong class="source-inline">terraform.tfstate.d/</strong> where <strong class="source-inline">.tfstate</strong> files are stored, each in its own subdirectory named aptly after the workspace. So, for the testing workspace, the state file will be stored <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">terraform.tfstate.d/testing</strong></span><span class="No-Break">:</span></p>
<pre class="console">
admin@myhome:~$ ll
total 40
-rw-r--r--  1 trochej  staff   159B Mar 21 13:11 main.tf
-rw-r--r--  1 trochej  staff   158B Mar 21 12:27 providers.tf
-rw-r--r--  1 trochej  staff   4.4K Mar 21 21:17 terraform.tfstate
-rw-r--r--  1 trochej  staff   180B Mar 21 21:15 terraform.tfstate.backup
drwxr-xr-x  3 trochej  staff    96B Mar 21 21:07 terraform.tfstate.d
admin@myhome:~$ ll terraform.tfstate.d
total 0
drwxr-xr-x  3 trochej  staff    96B Mar 21 21:20 testing
admin@myhome:~$ ll terraform.tfstate.d/testing
total 8
-rw-r--r--  1 trochej  staff   180B Mar 21 21:18 terraform.tfstate</pre>
<p>How can<a id="_idIndexMarker1153"/> we use this to our advantage in Terraform code? As we have mentioned, there’s a special sequence (let’s call it a variable) that will be expanded to the name of the current workspace in <span class="No-Break">our code:</span></p>
<pre class="source-code">
resource "aws_instance" "vm_example" {
  ami           = "ami-830c94e3"
  instance_type = terraform.workspace == "default" ? "t2.micro" : "t2.nano"
  tags = {
    Name = "DevOpsGuideTerraformExample"
}</pre>
<p>With this small change (if <strong class="source-inline">terraform.workspace</strong> is the default, then the instance will be <strong class="source-inline">t2.micro</strong>; otherwise, it will be <strong class="source-inline">t2.nano</strong>) we have introduced a conditional change related to the workspace we start the <span class="No-Break">VM in.</span></p>
<p>Let’s quickly confirm this with <span class="No-Break"><strong class="source-inline">terraform plan</strong></span><span class="No-Break">:</span></p>
<pre class="console">
admin@myhome:~$ terraform workspace show
default
admin@myhome:~$ terraform plan | grep instance_type
      + instance_type                        = "t2.micro"
admin@myhome:~$ terraform workspace select testing
Switched to workspace "testing".
admin@myhome:~$ terraform plan | grep instance_type
      + instance_type                        = "t2.nano"</pre>
<p>As shown<a id="_idIndexMarker1154"/> in the preceding output, depending on the workspace we select, different types of an instance will <span class="No-Break">be created.</span></p>
<p>In this section, we dived deep into the Terraform IaC tool. We explained what providers and modules are, as well as the role of the state file. We also demonstrated simple Terraform configuration and its interaction with the <span class="No-Break">AWS cloud.</span></p>
<p>In the next section, we are going to cover the HashiCorp Configuration Language (HCL)<a id="_idTextAnchor396"/> in more detail, which was created specifically to write <span class="No-Break">those configurations.</span></p>
<h1 id="_idParaDest-265">HCL in depth</h1>
<p>HCL is a<a id="_idIndexMarker1155"/> configuration language that’s used by several HashiCorp tools, including Terraform, to define and <span class="No-Break">manage IaC.</span></p>
<p>HCL is designed to be easy to read and write for both humans and machines. It uses a simple syntax that is similar to JSON but with a more relaxed structure and support for comments. HCL files typically have an <strong class="source-inline">.hcl</strong> or <strong class="source-inline">.tf</strong> <span class="No-Break">file extension.</span></p>
<p>HCL uses curly braces to define blocks of code, and each block has a label that identifies its type. Within each block, we define attributes using a <strong class="source-inline">key-value</strong> syntax, where the key is the attribute name and the value is the attribute value. We can also d<a id="_idTextAnchor397"/>efine objects using curly braces, as shown in the example with the <span class="No-Break"><strong class="source-inline">tags</strong></span><span class="No-Break"> object.</span></p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor398"/>Variables</h2>
<p>In HCL, variables<a id="_idIndexMarker1156"/> are defined using the <strong class="source-inline">variable</strong> block. Here’s an example of how to define a variable <span class="No-Break">in HCL:</span></p>
<pre class="source-code">
variable "region" {
  type = string
  default = "eu-central-1"
}</pre>
<p>In this example, we define a variable named <strong class="source-inline">region</strong> of the <strong class="source-inline">string</strong> type and a default value of <strong class="source-inline">us-west-2</strong>. We can reference this variable later in our code using the <strong class="source-inline">${</strong><span class="No-Break"><strong class="source-inline">var.region}</strong></span><span class="No-Break"> syntax.</span></p>
<p>HCL supports several data types for variables, including <strong class="source-inline">string</strong>, <strong class="source-inline">number</strong>, <strong class="source-inline">boolean</strong>, <strong class="source-inline">list</strong>, <strong class="source-inline">map</strong>, and <strong class="source-inline">object</strong>. We can also specify a description for the variable using the <strong class="source-inline">description</strong> argument in the <span class="No-Break"><strong class="source-inline">variable</strong></span><span class="No-Break"> block.</span></p>
<p>Variables can be assigned values in a variety of ways, including through default values, command-line arguments, or environment variables. When using Terraform, we can also define variables in a separate file and pass them in during execution using a <strong class="source-inline">.tfvars</strong> file extension (for example, <strong class="source-inline">variables.tfvars</strong>) or through <span class="No-Break">command-line arguments.</span></p>
<p>Once variables have been defined, they can’t be changed, but HCL also allows local variables that can be defined within the <strong class="source-inline">locals</strong> block. Local variables are useful for simplifying complex expressions or calculations within a module or resource block as they allow us to break down the logic into smaller, more manageable pieces. They can also make it easier to maintain our code as we can define local variables for values that may change frequently or need to be updated across multiple resources <span class="No-Break">or modules.</span></p>
<p>Here’s an example <strong class="source-inline">locals</strong> block that defines the <strong class="bold">availability zones</strong> (<strong class="bold">AZ</strong>) in the <strong class="source-inline">eu-central-1</strong> region and generates subnets in <span class="No-Break">every AZ:</span></p>
<pre class="source-code">
locals {
  azs         = ["eu-central-1a", "eu-central-1b", "eu-central-1c"]
  cidr_block  = "10.0.0.0/16"
  subnet_bits = 8
  subnets     = {
    for idx, az in local.azs : az =&gt; {
      name       = "${var.environment}-subnet-${idx}"
      cidr_block = cidrsubnet(local.cidr_block, local.subnet_bits, idx)
      availability_zone = az
    }
  }
}</pre>
<p>In this<a id="_idIndexMarker1157"/> example, we define a <strong class="source-inline">locals</strong> block that includes the <span class="No-Break">following variables:</span></p>
<ul>
<li><strong class="source-inline">azs</strong>: A list of the availability zones in the <span class="No-Break"><strong class="source-inline">eu-central-1</strong></span><span class="No-Break"> region</span></li>
<li><strong class="source-inline">cidr_block</strong>: The CIDR block for <span class="No-Break">the VPC</span></li>
<li><strong class="source-inline">subnet_bits</strong>: The number of bits to allocate for subnets within the <span class="No-Break">CIDR block</span></li>
<li><strong class="source-inline">subnets</strong>: A map that generates subnets for each availability zone in the <strong class="source-inline">azs</strong> list using a <span class="No-Break"><strong class="source-inline">for</strong></span><span class="No-Break"> expression</span></li>
</ul>
<p>The <strong class="source-inline">for</strong> expression in the <strong class="source-inline">subnets</strong> map generates a subnet for each availability zone in the <strong class="source-inline">azs</strong> list. The subnet’s name includes the environment variable (which can be passed in as a variable) and the index of the availability zone in the list. The <strong class="source-inline">cidrsubnet</strong> function is used to calculate the CIDR block for each subnet based on the <strong class="source-inline">cidr_block</strong> variable and the <span class="No-Break"><strong class="source-inline">subnet_bits</strong></span><span class="No-Break"> variable.</span></p>
<p>The resulting <strong class="source-inline">subnets</strong> map will contain a key-value pair for each availability zone in the <strong class="source-inline">azs</strong> list, where the key is the availability zone name and the<a id="_idTextAnchor399"/> value is a map that includes the subnet name, CIDR block, and <span class="No-Break">availability zone.</span></p>
<h2 id="_idParaDest-267"><a id="_idTextAnchor400"/>Comments</h2>
<p>Comments <a id="_idIndexMarker1158"/>in HCL can be written in two ways: single-line and multi-line comments. Single-line comments begin with the <strong class="source-inline">#</strong> symbol and continue until the end of the line. Multi-line comments, on the other hand, start with <strong class="source-inline">/*</strong> and end with <strong class="source-inline">*/</strong>. Multi-line comments can span multiple lines and are often used to provide longer explanations or temporarily disable sections <span class="No-Break">of code.</span></p>
<p>The following is an example of a <span class="No-Break">single-line comment:</span></p>
<pre class="source-code">
# This is a single-line comment in HCL</pre>
<p>The following is an<a id="_idIndexMarker1159"/> example of a <span class="No-Break">multi-line comment:</span></p>
<pre class="source-code">
/*
This is a multi-line comment in HCL
It can span multiple lines and is often<a id="_idTextAnchor401"/> used
to provide longer explanations or to temporarily disable sections of code.
*/</pre>
<h2 id="_idParaDest-268"><a id="_idTextAnchor402"/>Terraform meta-arguments</h2>
<p>In <a id="_idIndexMarker1160"/>Terraform, <strong class="bold">meta-arguments</strong> are special arguments that can be used to modify the behavior of resource blocks. They are called meta-arguments because they apply to the resource block as a whole, rather than to specific attributes within <span class="No-Break">the block.</span></p>
<p>Meta-arguments <a id="_idIndexMarker1161"/>are used to configure things such as the number of instances of a resource to create (<strong class="source-inline">count</strong>), the <a id="_idTextAnchor403"/>names of resources (<strong class="source-inline">name</strong>), the dependencies between resources (<strong class="source-inline">depends_on</strong>), <span class="No-Break">and more.</span></p>
<h3>count</h3>
<p><strong class="source-inline">count</strong> allows<a id="_idIndexMarker1162"/> you to create multiple instances of a resource based on a numeric value. This can be useful for creating multiple instances of a resource, such as EC2 instances in AWS, without having to repeat the entire block <span class="No-Break">of code.</span></p>
<p>For example, let’s say you want to create three EC2 instances in your AWS account. Instead of creating three separate <strong class="source-inline">aws_ec2_instance</strong> resource blocks, you can use the <strong class="source-inline">count</strong> meta-argument to create multiple instances of the same block. Here’s <span class="No-Break">an example:</span></p>
<pre class="source-code">
resource "aws_ec2_instance" "example" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  count         = 3
}</pre>
<p>In this example, we’re<a id="_idIndexMarker1163"/> creating three EC2 instances using the same <strong class="source-inline">ami</strong> and <strong class="source-inline">instance_type</strong>. The <strong class="source-inline">count</strong> meta-argument is set to <strong class="source-inline">3</strong>, which means that Terraform will create 3 instances of the <strong class="source-inline">aws_ec2_instance</strong> resource block. Each instance will be given a unique identifier, such as <strong class="source-inline">aws<a id="_idTextAnchor404"/>_ec2_instance.example[0]</strong>, <strong class="source-inline">aws_ec2_instance.example[1]</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">aws_ec2_instance.example[2]</strong></span><span class="No-Break">.</span></p>
<h3>for_each</h3>
<p>The <strong class="source-inline">for_each</strong> meta-argument <a id="_idIndexMarker1164"/>is similar to the <strong class="source-inline">count</strong> meta-argument in that it allows you to create multiple instances of a resource. However, <strong class="source-inline">for_each</strong> is more flexible than <strong class="source-inline">count</strong> because it allows you to create instances based on a map or set of values, rather than just a <span class="No-Break">numeric value.</span></p>
<p>For example, let’s say you have a map of AWS security groups that you want to create in your Terraform code. Instead of creating multiple <strong class="source-inline">aws_security_group</strong> resource blocks, you can use <strong class="source-inline">for_each</strong> to create them all in a single block. Here’s <span class="No-Break">an example:</span></p>
<pre class="source-code">
variable "security_groups" {
  type = map(object({
    name        = string
    description = string
    ingress     = list(object({
      from_port   = number
      to_port     = number
      protocol    = string
      cidr_blocks = list(string)
    }))
  }))
}
resource "aws_security_group" "example" {
  for_each = var.security_groups
  name_prefix = each.value.name
  description = each.value.description
  ingress {
    from_port   = each.value.ingress[0].from_port
    to_port     = each.value.ingress[0].to_port
    protocol    = each.value.ingress[0].protocol
    cidr_blocks = each.value.ingress[0].cidr_blocks
  }
}</pre>
<p>In this<a id="_idIndexMarker1165"/> example, we’re using the <strong class="source-inline">for_each</strong> meta-argument to create multiple instances of the <strong class="source-inline">aws_security_group</strong> resource block based on the <strong class="source-inline">security_groups</strong> variable, which is a map of objects. Each instance will have a unique identifier based on the key of the map. We’re also using the <strong class="source-inline">name_prefix</strong> attribute to set the name of each security group, and the <strong class="source-inline">description</strong> attribute to set the description. Finally, we’re using the <strong class="source-inline">ingress</strong> block to define the inbound traffic rules for each <span class="No-Break">security group.</span></p>
<p>Using <strong class="source-inline">for_each</strong> can<a id="_idIndexMarker1166"/> simplify your Terraform code and make it more reusable, especially when you’re dealing with maps or sets of values. However, it’s important to be aware of any potential dependencies between inst<a id="_idTextAnchor405"/>ances and to make sure that your code is properly structured to handle <span class="No-Break">multiple instances.</span></p>
<h3>lifecycle</h3>
<p>The <strong class="source-inline">lifecycle</strong> meta-argument is used to define custom behavior for creating, updating, and<a id="_idIndexMarker1167"/> deleting resources. It allows you to control the life cycle of a resource and its dependencies in a more fine-grained manner than the <span class="No-Break">default behavior.</span></p>
<p>The <strong class="source-inline">lifecycle</strong> meta-argument <a id="_idIndexMarker1168"/>can be used to define the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker1169"/></span><span class="No-Break"> attributes:</span></p>
<ul>
<li><strong class="source-inline">create_before_destroy</strong>: If set to <strong class="source-inline">true</strong>, Terraform will create the new resource before destroying the old one, which can prevent downtime in <span class="No-Break">some cases.</span></li>
<li><strong class="source-inline">prevent_destroy</strong>: If set to <strong class="source-inline">true</strong>, Terraform will prevent the resource from being destroyed. This can be useful for protecting critical resources from <span class="No-Break">accidental deletion.</span></li>
<li><strong class="source-inline">ignore_changes</strong>: A list of attribute names that Terraform should ignore when determining whether a resource needs to <span class="No-Break">be updated.</span></li>
<li><strong class="source-inline">replace_triggered_by</strong>: A list of dependencies that will cause the resource to <span class="No-Break">be recreated.</span></li>
</ul>
<p>Here’s an example of using the <strong class="source-inline">lifecycle</strong> meta-argument to prevent the destruction of an <span class="No-Break">S3 bucket:</span></p>
<pre class="source-code">
resource "aws_s3_bucket" "example" {
  bucket = "example-bucket"
  acl    = "private"
  lifecycle {
    prevent_destroy = true
  }
}</pre>
<p>In this example, the <strong class="source-inline">lifecycle</strong> block is used to set the <strong class="source-inline">prevent_destroy</strong> attribute to <strong class="source-inline">true</strong>, which means that Terraform will prevent the <strong class="source-inline">aws_s3_bucket</strong> resource from being des<a id="_idTextAnchor406"/>troyed. This can be useful for protecting critical resources from being <span class="No-Break">accidentally deleted.</span></p>
<h3>depends_on</h3>
<p>The <strong class="source-inline">depends_on</strong> meta-argument<a id="_idIndexMarker1170"/> is used to define dependencies between resources. It allows you to specify that one resource depends on another resource, which means that Terraform will create the dependent resource after the resource it depends on has <span class="No-Break">been created.</span></p>
<p>However, it’s important to note that in most cases, Terraform can create a dependency tree automatically by analyzing your resource configurations. This means that using <strong class="source-inline">depends_on</strong> should be avoided unless absolutely necessary as it can lead to dependency cycles that can cause errors and make your Terraform code harder <span class="No-Break">to manage.</span></p>
<p>If you do need to use <strong class="source-inline">depends_on</strong>, it’s important to be aware of the potential for dependency cycles and to structure your code in a way that avoids them. This might involve splitting your resources into smaller modules or using other techniques to reduce complexity and avoid <span class="No-Break">circular dependencies.</span></p>
<p>Here’s an example of using <strong class="source-inline">depends_on</strong> to specify a dependency between an EC2 instance and a <span class="No-Break">security group:</span></p>
<pre class="source-code">
resource "aws_security_group" "example" {
  name_prefix = "example"
  ingress {
    from_port = 22
    to_port   = 22
    protocol  = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}
resource "aws_instance" "example" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
  depends_on = [aws_security_group.example]
}</pre>
<p>In this<a id="_idIndexMarker1171"/> example, we’re using <strong class="source-inline">depends_on</strong> to specify that the <strong class="source-inline">aws_instance</strong> resource depends on the <strong class="source-inline">aws_security_group</strong> resource. This means that Terraform will create the security group before creating <span class="No-Break">the instance.</span></p>
<p>You can find out more about the HCL lang<a id="_idTextAnchor407"/>uage by reading the official <span class="No-Break">documentation: </span><a href="https://developer.hashicorp.com/terraform/language"><span class="No-Break">https://developer.hashicorp.com/terraform/language</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-269">Terraform examples with AWS</h1>
<p>In this <a id="_idIndexMarker1172"/>section, we will create two sample modules to demonstrate how you would go about creating one and what you will need to consider when choosing the way it is supposed to create resources. The module we are going to create will be able to create one or more EC2 instances, a security group attached to it, and other needed resources, such as an instance <a id="_idTextAnchor408"/>profile. It will do almost everything we went through in <a href="B18197_10.xhtml#_idTextAnchor282"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, but with the use of the <span class="No-Break">AWS CLI.</span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor409"/>EC2 instance module</h2>
<p>Let’s create<a id="_idIndexMarker1173"/> a module that will be able<a id="_idIndexMarker1174"/> to create EC2 instances. Consider the following <span class="No-Break">directory structure:</span></p>
<pre class="source-code">
├── aws
│   └── eu-central-1
└── modules</pre>
<p>The <strong class="source-inline">modules</strong> directory is where we will put all our modules, <strong class="source-inline">aws</strong> is where we will keep our AWS infrastructure, and <strong class="source-inline">eu-central-1</strong> is the code of the infrastructure for the Frankfurt AWS region. So, let’s go ahead and start with creating the EC2 module. Let’s create a directory to hold it and the basic files we will need, as we <span class="No-Break">described earlier:</span></p>
<pre class="console">
admin@myhome:~$ cd modules
admin@myhome:~/modules$ mkdir aws_ec2
admin@myhome:~/modules$ cd aws_ec2
admin@myhome:~/modules/aws_ec2$ touch versions.tf main.tf variables.tf outputs.tf providers.tf
admin@myhome:~/modules/aws_ec2$ ls -l
total 0
-rw-r--r--  1 admin  admin  0 Mar 16 13:02 main.tf
-rw-r--r--  1 admin  admin  0 Mar 16 13:02 outputs.tf
-rw-r--r--  1 admin  admin  0 Mar 16 13:02 providers.tf
-rw-r--r--  1 admin  admin  0 Mar 16 13:02 variables.tf
-rw-r--r--  1 admin  admin  0 Mar 16 13:02 versions.tf
admin@myhome:~/modules/aws_ec2$</pre>
<p>Notice<a id="_idIndexMarker1175"/> that we didn’t create the backend configuration file. This is because the backend will be configured in the root module instead. Modules don’t have state files as the resources created by the module will be using the state file from the root (or in other words, main) module. Let’s start configuring providers. In this case, we will only need the AWS provider at this moment. In our example, we will use the <span class="No-Break"><strong class="source-inline">eu-central-1</strong></span><span class="No-Break"> region:</span></p>
<pre class="source-code">
provider "aws" {
  region = "eu-central-1"
}</pre>
<p>Next, let’s <a id="_idIndexMarker1176"/>configure the versions of Terraform and the AWS provider we will use in the <span class="No-Break"><strong class="source-inline">versions.tf</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
terraform {
  required_version = "&gt;= 1.0.0"
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "&gt;= 3.0.0"
    }
  }
}</pre>
<p>In this<a id="_idIndexMarker1177"/> example, the <strong class="source-inline">required_version</strong> attribute is set to <strong class="source-inline">&gt;= 1.0.0</strong> to require Terraform version 1.0.0 or greater. The <strong class="source-inline">required_providers</strong> attribute is used to specify the AWS provider, with the <strong class="source-inline">source</strong> attribute set to <strong class="source-inline">hashicorp/aws</strong> and the <strong class="source-inline">version</strong> attribute set to <strong class="source-inline">&gt;= 3.0.0</strong> to require the latest version of the <span class="No-Break">AWS provider.</span></p>
<p>Now, we can do more interesting things, such as adding an actual <strong class="source-inline">aws_instance</strong> resource. For that, we will start filling the variables this <span class="No-Break">resource needs:</span></p>
<pre class="source-code">
resource "aws_instance" "test_instance" {
  ami           = "ami-1234567890"
  instance_type = "t3.micro"
  tags = {
    Name = "TestInstance"
  }
}</pre>
<p>After saving all changes to the module files, we can go back to the <strong class="source-inline">aws/eu-central-1</strong> directory <a id="_idIndexMarker1178"/>and create a similar set of files as in <span class="No-Break">the module:</span></p>
<pre class="console">
admin@myhome:~/modules/aws_ec2$ cd ../../aws/eu-central-1
admin@myhome:~/aws/eu-central-1$ touch versions.tf main.tf variables.tf providers.tf
admin@myhome:~/aws/eu-central-1$ ls -l
total 0
-rw-r--r--  1 admin  admin  0 Mar 16 13:02 main.tf
-rw-r--r--  1 admin  admin  0 Mar 16 13:02 providers.tf
-rw-r--r--  1 admin  admin  0 Mar 16 13:02 variables.tf
-rw-r--r--  1 admin  admin  0 Mar 16 13:02 versions.tf
admin@myhome:~/aws/eu-central-1$</pre>
<p>This time, we<a id="_idIndexMarker1179"/> will only need <strong class="source-inline">main.ft</strong>, <strong class="source-inline">providers.tf</strong>, <strong class="source-inline">variables.tf</strong>, and <strong class="source-inline">versions.tf</strong>. To simplify things, we can just copy the contents of the providers and the <span class="No-Break">versions files:</span></p>
<pre class="console">
admin@myhome:~/aws/eu-central-1$ cp ../../modules/aws_ec2/providers.tf .
admin@myhome:~/aws/eu-central-1$ cp ../../modules/aws_ec2/versions.tf .</pre>
<p>Now, we can focus on the <strong class="source-inline">main.tf</strong> file, where we’re going to try and use our first version of the module. The <strong class="source-inline">main.tf</strong> file will look <span class="No-Break">like this:</span></p>
<pre class="source-code">
module "test_instance" {
  source = "../../modules/aws_ec2"
}</pre>
<p>The module we’ve created doesn’t require any variables, so this is all we need in <span class="No-Break">this file.</span></p>
<p>Since this is our<a id="_idIndexMarker1180"/> root module, we will also need to configure the location of the Terraform state file. For simplicity, we will use a local state file, but in real life, we recommend using an S3 bucket with a distributed lock configured. If there is no backend block, Terraform will create a local file. We’re ready to test our module (the output has been shortened <span class="No-Break">for brevity):</span></p>
<pre class="console">
admin@myhome:~/aws/eu-central-1$ terraform init
Initializing modules...
- test_instance in ../../modules/aws_ec2
Initializing the backend...
Terraform has been successfully initialized!
You may now begin working with Terraform. Try running "terraform plan" to see
any changes that are required for your infrastructure. All Terraform commands
should now work.
If you ever set or change modules or backend configuration for Terraform,
rerun this command to reinitialize your working directory. If you forget, other
commands will detect it and remind you to do so if necessary.</pre>
<p>Once <a id="_idIndexMarker1181"/>you’ve run <strong class="source-inline">terraform init</strong> (you only have to rerun it if you update modules or backend configuration), you <a id="_idIndexMarker1182"/>can execute <strong class="source-inline">terraform plan</strong> to see what changes have to <span class="No-Break">be applied:</span></p>
<pre class="console">
admin@myhome:~/aws/eu-central-1$ terraform plan
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create
Terraform will perform the following actions:
  # module.test_instance.aws_instance.test_instance will be created
  + resource "aws_instance" "test_instance" {
      + ami                                  = "ami-1234567890"
# Some of the output removed for readability
Plan: 1 to add, 0 to change, 0 to destroy.
─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</pre>
<p class="callout-heading">Note</p>
<p class="callout">You didn’t use the <strong class="source-inline">-out</strong> option to save this plan, so Terraform can’t guarantee it will take exactly these actions if you run <strong class="source-inline">terraform </strong><span class="No-Break"><strong class="source-inline">apply</strong></span><span class="No-Break"> now.</span></p>
<p>With <a id="_idIndexMarker1183"/>this plan, Terraform confirmed that our module will create an EC2 instance for us. Unfortunately, this plan is not ideal as it doesn’t check whether the AMI actually exists, or whether the subnet is there. Those errors will come up when we run <strong class="source-inline">terraform apply</strong>. The AMI we’ve provided, for instance, is bogus, so Terraform will fail in creating the instance. Let’s get back to the module and improve it by <a id="_idIndexMarker1184"/>automatically getting a correct Ubuntu Linux AMI. For this, the Terraform AWS provider provides a data resource. This special resource enables us to <em class="italic">ask</em> AWS for various resources through their API. Let’s add an AMI data resource to the <strong class="source-inline">modules</strong> directory’s <span class="No-Break"><strong class="source-inline">main.tf</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
data "aws_ami" "ubuntu" {
  most_recent = true
  owners = ["099720109477"] # Canonical
  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"]
  }
}
resource "aws_instance" "test_instance" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = "t3.micro"
  tags = {
    Name = "TestInstance"
  }
}</pre>
<p>The <strong class="source-inline">(aws_ami)</strong> block<a id="_idIndexMarker1185"/> of code uses the <strong class="source-inline">aws_ami</strong> data source to fetch the latest Ubuntu AMI owned by Canonical from the AWS Marketplace. It does this by setting the <strong class="source-inline">most_recent</strong> parameter to <strong class="source-inline">true</strong> and filtering the results using the <strong class="source-inline">name</strong> attribute of the AMI. It looks for an AMI with a specific name <span class="No-Break">pattern: </span><span class="No-Break"><strong class="source-inline">ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*</strong></span><span class="No-Break">.</span></p>
<p>The second block <a id="_idIndexMarker1186"/>of code creates an AWS EC2 instance using the AMI that was fetched in the first block of code. It sets the instance type to <strong class="source-inline">t3.micro</strong>, which is a small instance type that’s suitable for <span class="No-Break">testing purposes.</span></p>
<p>It also adds a tag to the EC2 instance with a key called <strong class="source-inline">Name</strong> and a value called <strong class="source-inline">TestInstance</strong> so that it can easily be identified in the AWS <span class="No-Break">Management Console.</span></p>
<p>You can read more about the <strong class="source-inline">aws_ami</strong> data resource in the <span class="No-Break">documentation: </span><a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ami"><span class="No-Break">https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ami</span></a><span class="No-Break">.</span></p>
<p>After making this modification, we can run <strong class="source-inline">terraform plan</strong> and see whether <span class="No-Break">something changes:</span></p>
<pre class="console">
admin@myhome:~/aws/eu-central-1$ terraform plan
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create
Terraform will perform the following actions:
  # module.test_instance.aws_instance.test_instance will be created
  + resource "aws_instance" "test_instance" {
      + ami                                  = "ami-050096f31d010b533"
# Rest of the output removed for readability</pre>
<p>The plan<a id="_idIndexMarker1187"/> succeeded and it seems it found a recent AMI for Ubuntu Linux 22.04. There are a few other issues we’ll need to consider if we want to make sure we’ll be able to connect to this new EC2 instance. Of <a id="_idIndexMarker1188"/>course, it will be created if we apply the changes, but we don’t have a way to connect to it. First, let’s connect the EC2 instance to the correct network: we will use a default VPC and a public subnet, which will allow us to connect to this <span class="No-Break">instance directly.</span></p>
<p>To figure out the ID of the<a id="_idIndexMarker1189"/> default VPC and a public subnet, once again, we will use a <span class="No-Break">data resource:</span></p>
<ul>
<li><strong class="bold">VPC </strong><span class="No-Break"><strong class="bold">documentation</strong></span><span class="No-Break">: </span><a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/vpc%20"><span class="No-Break">https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/vpc</span></a></li>
<li><strong class="bold">Subnet </strong><span class="No-Break"><strong class="bold">documentation</strong></span><span class="No-Break">: </span><a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/subnets%20"><span class="No-Break">https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/subnets</span></a></li>
</ul>
<p>The question is whether<a id="_idIndexMarker1190"/> we want to automatically put all created instances in a default VPC (and a public subnet) or not. Usually, the answer to this question is <em class="italic">no</em>. In that case, we will need to add some variables to be passed to <span class="No-Break">this module.</span></p>
<p>Let’s add <a id="_idIndexMarker1191"/>another file to the root module, in which we will put all the data resources, <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">data.tf</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
data "aws_vpc" "default" {
  filter {
    name   = "isDefault"
    values = ["true"]
  }
}
data "aws_subnets" "public" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
  filter {
    name   = "map-public-ip-on-launch"
    values = ["true"]
  }
}</pre>
<p>Now, we can create<a id="_idIndexMarker1192"/> an input variable in our module. Go back to the <strong class="source-inline">modules/aws_ec2</strong> directory and edit the <span class="No-Break"><strong class="source-inline">variables.tf</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
variable "public_subnet_id" {
  description = "Subnet ID we will run our EC2 instance"
  type        = string
}</pre>
<p>Now, when<a id="_idIndexMarker1193"/> you run <strong class="source-inline">terraform plan</strong>, you will see the <span class="No-Break">following error:</span></p>
<pre class="console">
│ Error: Missing required argument
│
│   on main.tf line 1, in module "test_instance":
│    1: module "test_instance" {
│
│ The argument "public_subnet_id" is required, but no definition was found.</pre>
<p>Here, we’ve created a mandatory variable we will need to provide to the module. Let’s do so by editing the <strong class="source-inline">main.tf</strong> file in our root module (the <span class="No-Break"><strong class="source-inline">aws/eu-central-1</strong></span><span class="No-Break"> directory):</span></p>
<pre class="source-code">
module "test_instance" {
  source = "../../modules/aws_ec2"
  public_subnet_id = data.aws_subnets.public.ids[0]
}</pre>
<p>Notice <strong class="source-inline">data.aws_subnets.public.ids[0]</strong>. We’ve used a list notation, where we’re choosing<a id="_idIndexMarker1194"/> the first element of the list (which is a string since the module expects it to be). This is because there are multiple subnets and <strong class="source-inline">aws_subnets</strong> returned a list of those subnets <span class="No-Break">for us.</span></p>
<p>Running a plan again should give us one resource to be added. Great! Now, our instance will get a public IP address we can connect to. But we’re still missing a firewall rule that will allow us to connect to port <strong class="source-inline">22</strong> (SSH). Let’s create<a id="_idIndexMarker1195"/> a <strong class="bold">security </strong><span class="No-Break"><strong class="bold">group</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SG</strong></span><span class="No-Break">).</span></p>
<p>Again, we could decide to create an SG in the root module, which would allow us to modify it without changing the EC2 module. Alternatively, we could add an SG inside the EC2 module, which would mean that the module would have full control over it, but it would lack some flexibility. It’s also possible to create a module that would do both: attach an SG injected from the root module and, at the same time, use an SG predefined in the module, but this is outside the scope of this chapter. In this case, we’re going to create an SG inside the module for <span class="No-Break">simplicity’s sake.</span></p>
<p>To create <a id="_idIndexMarker1196"/>an SG, we will use the <strong class="source-inline">aws_security_group</strong> resource, which requires a VPC ID. There are two possibilities: we will need to introduce another variable to our EC2 module, or we will use another data resource to automatically get the VPC ID from the provided subnet. This time, a more elegant solution would be to use data resources. Let’s add it to <strong class="source-inline">main.tf</strong> in <span class="No-Break">our module:</span></p>
<pre class="source-code">
data "aws_subnet" "current" {
  id = var.public_subnet_id
}</pre>
<p>With that in place, we<a id="_idIndexMarker1197"/> will be able to add an <span class="No-Break">SG now:</span></p>
<pre class="source-code">
resource "aws_security_group" "allow_ssh" {
  name        = "TestInstanceSG"
  description = "Allow SSH traffic"
  vpc_id      = data.aws_subnet.current.vpc_id
  ingress {
    description      = "SSH from the Internet"
    from_port        = 22
    to_port          = 22
    protocol         = "tcp"
    cidr_blocks      = ["0.0.0.0/0"]
  }
  egress {
    from_port        = 0
    to_port          = 0
    protocol         = "-1"
    cidr_blocks      = ["0.0.0.0/0"]
    ipv6_cidr_blocks = ["::/0"]
  }
  tags = {
    Name = "TestInstanceSG"
  }
}</pre>
<p>The <a id="_idIndexMarker1198"/>preceding code creates an AWS SG that allows SSH traffic to the EC2 instance we <span class="No-Break">created earlier.</span></p>
<p>The <strong class="source-inline">aws_security_group</strong> resource is used to create an SG for the EC2 instance. It sets the name of the SG to <strong class="source-inline">TestInstanceSG</strong> and provides a <span class="No-Break">brief description.</span></p>
<p>The <strong class="source-inline">vpc_id</strong> attribute<a id="_idIndexMarker1199"/> is set to the VPC ID of the current subnet. It uses the <strong class="source-inline">aws_subnet</strong> data source called <strong class="source-inline">current</strong> to fetch the current subnet’s <span class="No-Break">VPC ID.</span></p>
<p>The <strong class="source-inline">ingress</strong> block defines the inbound rules for the security group. In this case, it allows SSH traffic from any IP address (<strong class="source-inline">0.0.0.0/0</strong>) by specifying <strong class="source-inline">from_port</strong>, <strong class="source-inline">to_port</strong>, <strong class="source-inline">protocol</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">cidr_blocks</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">egress</strong> block defines the outbound rules for the security group. In this case, it allows all outbound traffic by specifying <strong class="source-inline">from_port</strong>, <strong class="source-inline">to_port</strong>, <strong class="source-inline">protocol</strong>, and <strong class="source-inline">cidr_blocks</strong>. It also allows all IPv6 traffic by <span class="No-Break">specifying </span><span class="No-Break"><strong class="source-inline">ipv6_cidr_blocks</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">tags</strong> attribute sets a tag for the SG with a key called <strong class="source-inline">Name</strong> and a value called <strong class="source-inline">TestInstanceSG</strong> so that it can be easily identified in the AWS <span class="No-Break">Management Console.</span></p>
<p>Now, we’re ready to attach this SG to our instance. We will need to use the <strong class="source-inline">security_groups</strong> option for the <span class="No-Break"><strong class="source-inline">aws_instance</strong></span><span class="No-Break"> resource:</span></p>
<pre class="source-code">
resource "aws_instance" "test_instance" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = "t3.micro"
  security_groups = [aws_security_group.allow_ssh.id]
  tags = {
    Name = "TestInstance"
  }
}</pre>
<p>Now, after running <strong class="source-inline">terraform plan</strong>, you will see two resources to <span class="No-Break">be added:</span></p>
<pre class="console">
Plan: 2 to add, 0 to change, 0 to destroy.</pre>
<p>At this<a id="_idIndexMarker1200"/> point, we need to add our public SSH key to AWS and configure EC2 to use it for a default Ubuntu Linux user (<strong class="source-inline">ubuntu</strong>). Assuming<a id="_idIndexMarker1201"/> you have already generated your SSH key, we will create a variable with said key, create a resource that will make the key available for the EC2 instance, and finally, add it to the <span class="No-Break">instance configuration.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">In some AWS regions, it’s required to use an old RSA key format. Whenever available, we recommend the newest format according to up-to-date recommendations. At the time of writing this book, it’s recommended to use the <span class="No-Break"><strong class="source-inline">ED25519</strong></span><span class="No-Break"> key.</span></p>
<p>Let’s add a variable to the <span class="No-Break">root module:</span></p>
<pre class="source-code">
variable "ssh_key" {
  description = "SSH key attached to the instance"
  type = string
  default = "ssh-rsa AAASomeRSAKEY""
}</pre>
<p>Let’s add a similar one for the <span class="No-Break">EC2 module:</span></p>
<pre class="source-code">
variable "ssh_key" {
  description = "SSH key attached to the instance"
  type = string
}</pre>
<p>This<a id="_idIndexMarker1202"/> one is without the default value to make this variable required for every module in use. Now, let’s add the key to AWS inside the EC2 <span class="No-Break">module (</span><span class="No-Break"><strong class="source-inline">main.tf</strong></span><span class="No-Break">):</span></p>
<pre class="source-code">
resource "aws_key_pair" "deployer" {
  key_name   = "ssh_deployer_key"
  public_key = var.ssh_key
}</pre>
<p>Then, we can <a id="_idIndexMarker1203"/>use it in the <span class="No-Break"><strong class="source-inline">aws_instance</strong></span><span class="No-Break"> resource:</span></p>
<pre class="source-code">
resource "aws_instance" "test_instance" {
  ami           = data.aws_ami.ubuntu.id
  instance_type = "t3.micro"
  security_groups = [aws_security_group.allow_ssh.id]
  key_name = aws_key_pair.deployer.key_name
  tags = {
    Name = "TestInstance"
  }
}</pre>
<p>We will need to use the new variable inside the root module <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.tf</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
module "test_instance" {
  source = "../../modules/aws_ec2"
  public_subnet_id = data.aws_subnets.public.ids[0]
  ssh_key          = var.ssh_key
}</pre>
<p>Finally, running <strong class="source-inline">terraform plan</strong> will give us <span class="No-Break">three resources:</span></p>
<pre class="console">
Plan: 3 to add, 0 to change, 0 to destroy.</pre>
<p>Great! Running <strong class="source-inline">terraform apply</strong> and accepting any changes will deploy the EC2 instance in a public subnet with our key. However, we still won’t know the IP address for the instance unless we go to the AWS console and check <span class="No-Break">it manually.</span></p>
<p>To get<a id="_idIndexMarker1204"/> this information, we will need to export these <a id="_idIndexMarker1205"/>variables from the EC2 module and then once again in the root module. For this, we have another code block called <strong class="source-inline">output</strong>. Its syntax is very similar to the <strong class="source-inline">variable</strong> syntax, but additionally, you can mark the <strong class="source-inline">output</strong> variable as sensitive so that it’s not shown by default when running <strong class="source-inline">terraform plan</strong> or <strong class="source-inline">terraform </strong><span class="No-Break"><strong class="source-inline">apply</strong></span><span class="No-Break"> commands.</span></p>
<p>Let’s define outputs showing us the public IP address of the EC2 instance. In the EC2 module in the <strong class="source-inline">outputs.tf</strong> file, place the <span class="No-Break">following code:</span></p>
<pre class="source-code">
output "instance_public_ip" {
  value       = aws_instance.test_instance.public_ip
  description = "Public IP address of the EC2 instance"
}</pre>
<p>In the root module, create the <strong class="source-inline">outputs.tf</strong> file and put the following <span class="No-Break">code there:</span></p>
<pre class="source-code">
output "instance_public_ip" {
  value       = module.test_instance.instance_public_ip
  description = "Public IP address of the instance"
}</pre>
<p>Now, when you run <strong class="source-inline">terraform plan</strong>, you will see a change in <span class="No-Break">the output:</span></p>
<pre class="console">
Plan: 3 to add, 0 to change, 0 to destroy.
Changes to Outputs:
  + instance_public_ip = (known after apply)</pre>
<p>This way, we’ve created <a id="_idIndexMarker1206"/>a simple module by creating a single EC2 instance. If we run <strong class="source-inline">terraform apply</strong>, the instance will <a id="_idIndexMarker1207"/>be created and the output will show us the <span class="No-Break">IP address.</span></p>
<p>From here, the next steps would involve adding more functionality to the module, adding the ability to create mor<a id="_idTextAnchor410"/>e than one instance with the <strong class="source-inline">count</strong> meta-argument, or creating a set of different EC2 instances by using the <span class="No-Break"><strong class="source-inline">for_each</strong></span><span class="No-Break"> meta-argument.</span></p>
<h1 id="_idParaDest-271">Summary</h1>
<p>In this chapter, we introduced the concept of IaC. We explained why it is an important method of managing and developing your infrastructure. We also introduced some tools that are quite popular in this way of working. As a tool of choice, we explained Terraform – probably the most widely <span class="No-Break">used one.</span></p>
<p>In the next chapter, we are going to show you how y<a id="_idTextAnchor411"/>ou can leverage some online tools and automation to build pipelines for <strong class="bold">CI</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">CD</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-272">Exercises</h1>
<p>Try out the following exercises to test what you’ve learned in <span class="No-Break">this chapter:</span></p>
<ol>
<li>Create a module that will create an S3 bucket with enabled <span class="No-Break">server-side encryption.</span></li>
<li>Add an instance profile to the module we’ve created using the same IAM policy that we used in <a href="B18197_10.xhtml#_idTextAnchor282"><span class="No-Break"><em class="italic">Chapter 10</em></span></a><span class="No-Break">.</span></li>
<li>Use the <strong class="source-inline">count</strong> meta-argument to create <span class="No-Break">two instances.</span></li>
</ol>
</div>
</div></body></html>