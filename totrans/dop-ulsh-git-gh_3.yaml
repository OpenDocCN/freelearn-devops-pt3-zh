- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Git Usage for Team Collaboration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we move on to the aspect of actual collaboration. In this chapter, we will
    delve into various collaboration practices that you will want to adopt. You will
    learn how to organize your commit history, manage complex branches, and resolve
    conflicts during merges. The goal of this chapter is to help you become wonderfully
    in control of this branch flow team collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the focus is not just on getting the job done but also on doing it in
    a way that enhances teamwork. Recognize that there is a thoughtful strategy behind
    managing an entire code base to maximize the teams’ productivity and impact. Different
    strategies are employed based on the type of products or projects, the team size,
    and its maturity. Before we plunge into the Git commands, it is crucial to comprehend
    this underlying strategy—branching strategies.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s get started on making your collaboration seamless and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Branching strategy for team collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ways to apply your changes on a branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating conflicts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering better collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration instructions for proceeding with this section can be found in
    the following GitHub repository link. Please make sure Git and SSH tools are installed.
    For Windows users, it is recommended to use PowerShell. I also encourage you to
    get the most up-to-date information written about the different commands and environments.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub](https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub)'
  prefs: []
  type: TYPE_NORMAL
- en: Branching strategies for team collaboration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of team collaboration, commits act as the essential building blocks.
    These commits link together to form a chronological history, a record of your
    project’s evolution. This history is organized and maintained through branches.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can engineers and teams knit this history into a cohesive meaningful
    narrative? The branching strategy is the answer to this question. The branching
    strategy is a development strategy for effectively managing branches in Git to
    enable smooth collaboration and service delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Why a branching strategy is important
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A well-crafted branching strategy is not just nice to have; it is crucial in
    a team development environment. Your branching strategy has a ripple effect on
    your DevOps processes, affecting deployment units and workflow efficiency. The
    ability to collaborate smoothly depends not only on good communication within
    the team but also impacts the speed at which your product evolves. This ties back
    into all the elements we have covered in the previous chapters, such as the frequency
    and methodology of your CI/CD tests. In essence, your branching strategy is pivotal
    in removing organizational friction, which is the ultimate aim of DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some reasons why a well-thought-out branching strategy is non-negotiable:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolation of changes**: It allows individual team members to work on distinct
    features or bugs without interfering with each other’s work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk mitigation**: A branching strategy safeguards the main (often called
    master) branch from being destabilized by untested or volatile code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facilitates collaboration**: With a good branching strategy, multiple team
    members can work on different branches in parallel, thereby increasing overall
    team efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the context of DevOps, a branching strategy also does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated testing integration**: A branching strategy can be designed to
    trigger automated tests at various stages. This ensures that only well-tested
    code is merged back into the main branch, aiding in continuous integration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplifies deployment**: A well-organized branch structure can streamline
    the deployment process, making it easier to move code from development environments
    to staging and finally to production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhances developer experience**: It improves the overall **Developer Experience**
    (**DX**) by making collaboration more transparent and efficient, a key strategy
    for successful DevOps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment-specific branches**: Having branches dedicated to particular
    environments (development, staging, production, etc.) allows for smoother and
    more controlled deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhances security**: By establishing clear boundaries between branches, a
    branching strategy can enhance security by controlling access to sensitive code
    and ensuring that changes undergo proper review and approval processes before
    being merged into critical environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branch strategy and branch policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the landscape of software development and DevOps, the terms **branching strategy**
    and **branching policy** might appear synonymous. While they are frequently mistaken
    for one another, it is vital to recognize that a branching strategy is a more
    expansive concept that encompasses a branching policy.
  prefs: []
  type: TYPE_NORMAL
- en: A branching strategy is a comprehensive plan that outlines how branches are
    managed, created, and integrated within your development workflow. It encapsulates
    more than just the technical aspects of handling branches. It also involves contextual
    variables such as the size of your organization, the culture within your team,
    and the specific requirements of your project or product.
  prefs: []
  type: TYPE_NORMAL
- en: Branching policies, on the other hand, are more specific sets of rules or guidelines
    for branch management. These often form the backbone of a branching strategy,
    serving as templates to be customized according to your specific needs. Sometimes,
    policies such as **Git Flow** or **GitHub Flow**, which we will discover in this
    chapter, are used as the names of strategies for development. They should be considered
    as types of branching policies. Renowned software thought leader Martin Fowler
    discusses these items not as strategies themselves but rather under the *Looking
    at some branching policies* section in his article *Patterns for Managing Source
    Code* *Branches* ([https://martinfowler.com/articles/branching-patterns.html](https://martinfowler.com/articles/branching-patterns.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when establishing a branching approach, it is crucial to choose a
    branching policy that serves as a foundation. This policy should then be customized
    to align with your organization’s unique needs and objectives to effectively mitigate
    friction in development processes and accelerate software releases. This tailored
    approach ensures that your branching strategy not only optimizes workflow but
    also integrates seamlessly with the cultural and organizational aspects of your
    team.
  prefs: []
  type: TYPE_NORMAL
- en: Smaller and frequent versus larger and less frequent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many branching policies in existence. Companies often coin specific
    branching policy names and publish them as best practices, such as **GitHub Flow**.
    Fundamentally, all branching strategies map to one of two principles: make smaller
    changes frequently or make larger changes occasionally.'
  prefs: []
  type: TYPE_NORMAL
- en: For smaller teams, naturally, the friction in integrating changes and pushing
    releases quickly is less. But in larger organizations, with larger products or
    a lengthy approval process, the friction inevitably increases. More conflicts
    arise, and more checks are needed to prevent them.
  prefs: []
  type: TYPE_NORMAL
- en: However, allowing these challenges to slow down your development process can
    adversely affect the timeliness of your product or project releases, ultimately
    impacting business success.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, various companies have devised a multitude of branching strategies
    to mitigate these issues. Most of them are extensions of existing practices, designed
    to reduce friction within the constraints of an organization or product, aiming
    for faster releases.
  prefs: []
  type: TYPE_NORMAL
- en: It is crucial to understand that no branching strategy serves as a one-size-fits-all
    solution. The base strategy often gets selected depending on the team’s composition
    and culture, and from there, customizations are made to fit specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section introduces the branch policies trunk-based development, Git Flow,
    and GitHub Flow, each mapped as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Branching policies mapping](img/B21203_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Branching policies mapping
  prefs: []
  type: TYPE_NORMAL
- en: '**Trunk-based development** is renowned for integrating smaller, frequent changes
    directly into the main branch. In contrast, Git Flow is known for a strategy that
    integrates larger changes less frequently. Both have their pros and cons, and
    your choice between them often boils down to your team’s specific requirements
    and workflows.'
  prefs: []
  type: TYPE_NORMAL
- en: For larger organizations aiming to release a higher volume of changes more frequently
    with reduced friction, GitHub Flow serves as an excellent representative. These
    strategies are essentially designed to adapt the core principles of frequent,
    small changes to fit the complexity and scale of larger enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: Policies such as GitHub Flow are built under the influence of Git Flow, but
    many companies nowadays use GitHub Flow as a template upon which they build their
    own customized branching policies.
  prefs: []
  type: TYPE_NORMAL
- en: Types of branch policies branch policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now then, let’s look at a typical branch policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section introduces three typical branching policies:'
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git Flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider each in terms of how frequently your team or organization needs to
    release and how large your product and project are.
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Trunk-based development** (**TBD**) is a software development approach where
    developers work in short-lived branches, typically less than a day, or directly
    off a single branch called the **trunk** or the mainline. The key principle is
    to minimize the lifespan of branches to promote frequent integrations and to avoid
    the pitfalls of long-lived feature branches, such as merge conflicts and diverging
    codebases.'
  prefs: []
  type: TYPE_NORMAL
- en: In TBD, the trunk is always in working and healthy condition, and it should
    always be in a deployable state. Developers take a small chunk of a feature or
    task and work on it, aiming to merge it back into the trunk as soon as possible.
    If a feature is not yet ready for production, **feature flags** can be used to
    hide these functionalities until they are complete, allowing the code to be merged
    without affecting the end users. Release practices such as feature flags are covered
    in [*Chapter 5*](B21203_05.xhtml#_idTextAnchor109).
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the figure, in the TBD, many short-lived branches are created, and
    they are merged into the mainline.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Trunk-based development](img/B21203_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Trunk-based development
  prefs: []
  type: TYPE_NORMAL
- en: Since integration happens frequently, it is crucial to have a robust suite of
    automated tests to run every time code is merged into the trunk. This ensures
    that the code base remains stable and deployable at all times. **Continuous Integration**
    (**CI**) tools are commonly used in conjunction with TBD to automate the testing
    and build processes, ensuring that the trunk is always in a good state.
  prefs: []
  type: TYPE_NORMAL
- en: To accommodate hotfixes that provide urgent fixes, developers may create short-lived
    branches that are immediately merged back into the trunk upon completion. This
    ensures that critical issues can be addressed quickly without jeopardizing the
    stability of the mainline.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of TBD is its simplicity and focus on producing a
    clean, deployable code base. Encouraging frequent merges reduces the likelihood
    of merge conflicts and keeps all developers aligned with the latest version of
    the code. This is particularly beneficial in a DevOps culture that prioritizes
    quick iterations and rapid delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the pros and cons of trunk-based development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frequent integration**: Because code is merged frequently, merge conflicts
    are less likely and easier to resolve'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast feedback loop**: Integrating changes often helps in identifying issues
    earlier in the development process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified workflow**: Without a proliferation of long-lived feature branches,
    the development workflow is simplified, making it easier to manage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Risk of instability**: If not properly tested, frequent merges can lead to
    unstable code getting into the mainline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Not ideal for large features**: For very large or disruptive changes, this
    approach can cause problems, as those changes might destabilize the mainline for
    an extended period'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, TBD is all about rapid integrations, keeping the trunk always deployable,
    and employing automated testing to maintain code quality. It aligns well with
    Agile and DevOps methodologies, aiming to remove friction and improve developer
    experience by streamlining the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Git Flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git Flow is a branching policy mainly aimed at robust project versioning and
    is particularly well-suited for projects that have a scheduled release cycle.
    It introduces a structured approach involving multiple types of branches, including
    `feature`, `release`, `develop`, and `hotfix`, alongside the `main` (or `master`)
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Git Flow](img/B21203_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Git Flow
  prefs: []
  type: TYPE_NORMAL
- en: In Git Flow, development begins by branching off a `develop` branch from `main`.
    The `develop` branch serves as the integration branch for features and is where
    all developers’ branches get merged. When you are set to work on a new feature
    or a bug, you branch off a `feature` branch from `develop`. This isolated environment
    allows you to work without affecting the broader code base.
  prefs: []
  type: TYPE_NORMAL
- en: As the feature progresses, incremental changes are committed to this `feature`
    branch. Once the feature is complete and tested, it gets merged back into the
    `develop` branch. For release preparation, a `release` branch is created from
    the `develop` branch. This branch is where any final minor bug fixes or documentation
    updates occur. Once everything is ready, the `release` branch is merged into `main`
    and tagged with a version number. Simultaneously, it should also be merged back
    into `develop` to ensure that future releases also have these changes. For immediate,
    critical fixes, a `hotfix` branch may be created directly off the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: Git Flow provides a rigid structure that can be beneficial for large projects
    with multiple developers, requiring a balance of stability and new features. It
    ensures that development processes are separate but parallel, allowing for project
    history to be more legible and revertible.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the pros and cons of the Git Flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Structured workflow**: It’s suitable for projects that have scheduled release
    cycles'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Isolation**: Feature branches allow developers to work in isolation, making
    it easier to manage complex features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hotfix support**: The dedicated hotfix branches make it easy to quickly patch
    production releases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complexity**: For smaller teams or projects, Git Flow may introduce unnecessary
    complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delayed Integration**: As feature branches are long-lived, this could lead
    to merge conflicts or bugs that are discovered late in the development process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, Git Flow provides a model for more complex projects, ensuring that
    the code base remains organized and that releases are well managed. It is especially
    useful for larger teams where coordination and release planning are critical.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub Flow is a simplified workflow that encourages continuous delivery practices.
    It consists of just the mainline and short-lived feature branches. The main principle
    is to branch off, develop a new feature, submit a pull request, and review the
    code before deploying. Pull request is an invention by GitHub and is a method
    for developers to notify team members that they have completed a feature or fix,
    which is then reviewed and discussed before being merged into the main branch
    of a code base. It will be covered in [*Chapter 4*](B21203_04.xhtml#_idTextAnchor077).
  prefs: []
  type: TYPE_NORMAL
- en: 'The GitHub Flow is simple, but the context is not confined to Git alone. Note
    the inclusion of GitHub processes such as pull requests and approvals, as shown
    in the figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – GitHub Flow](img/B21203_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – GitHub Flow
  prefs: []
  type: TYPE_NORMAL
- en: It begins with creating a new, descriptive branch off the default repository
    branch, serving as a safe environment for making changes without affecting the
    main code base. Changes are committed and pushed to this remote branch. When ready,
    a detailed pull request is created for team reviews, often linked to related issues
    for context. Reviews might include questions, suggestions, or line-specific comments.
    Subsequent commits addressing feedback are automatically added to the pull request.
    After approval, the pull request is merged into the default branch, making your
    contributions part of the main code base. Depending on settings, resolving merge
    conflicts or meeting approval criteria may be required. Post-merge, the working
    branch is deleted but the commit history and discussions remain accessible for
    future reference.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, GitHub Flow fosters collaboration, transparency, and incremental
    development, offering a flexible yet structured approach for team projects.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the pros and cons of the GitHub Flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**: GitHub Flow offers a straightforward approach with a single
    mainline and short-lived feature branches, making it accessible and easy to manage,
    even for newcomers. This simplicity streamlines development, allowing for a focus
    on productivity rather than complex branching strategies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster deployment**: By encouraging continuous integration and delivery,
    GitHub Flow enables teams to release updates more frequently. This rapid deployment
    cycle allows for immediate feedback and quicker iteration, reducing the time from
    development to market.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced collaboration**: The pull request mechanism central to GitHub Flow
    fosters transparent code reviews and collaboration. It allows every team member
    to contribute to discussions, ensuring code quality and collective ownership of
    the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform compatibility considerations**: Adopting GitHub Flow enhances collaboration
    and efficiency, particularly on GitHub where it is fully supported. However, when
    integrating with different platforms, it might necessitate supplementary tools
    or adjustments to harness its full potential, ensuring seamless project management
    across diverse environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptability for complex projects:** While GitHub Flow offers a streamlined,
    straightforward approach conducive to rapid deployment and continuous delivery,
    larger teams working on multifaceted projects may encounter challenges. This workflow’s
    emphasis on simplicity and single mainline development can sometimes limit the
    granularity of control over multiple simultaneous developments or the nuanced
    handling of various project timelines. For instance, in projects requiring extensive
    integration testing or coordination across multiple sub-teams, the need for additional
    branch management strategies or more robust release planning mechanisms becomes
    apparent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branch naming conventions – Discover the best practices for naming branches
    in Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the realm of Git and DevOps, naming is a crucial aspect of effective team
    collaboration and code management. A clear, descriptive name can make a world
    of difference when you are navigating through a sea of branches, trying to understand
    their specific functions, ownership, and lifecycle status. Establishing a coherent
    branching naming convention is an integral part of an effective branching strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s delve into the best practices for naming branches in Git, aiming to remove
    organizational friction and accelerate releases. A well-defined naming convention
    allows engineers to instantly understand the purpose of a branch, whether it is
    for a feature, a bug fix, a hotfix, or an experimental endeavor. This clarity
    is vital when a team is sifting through dozens, or even hundreds, of branches.
    Naming conventions set the stage for a more transparent, efficient, and streamlined
    workflow, making it easier for everyone on the DevOps team to collaborate.
  prefs: []
  type: TYPE_NORMAL
- en: Branch naming guidelines and examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following are the main guidelines and examples for naming each topic. Please
    note that these are only examples, and each team can have very different naming
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s some general guidance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-`), underscores (`_`), or slashes (`/`) to separate words. Slashes are especially
    used as a separator when dealing with topics such as hotfixes and features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lowercase names**: While Git is case-sensitive, sticking to lowercase letters
    helps maintain consistency and avoids confusion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Make it descriptive but short**: The name should give an instant idea of
    what the branch is about while remaining as succinct as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are examples of names for each branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '`feature/`, followed by a brief description. An example would be `feature/user
    authentication`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bugfix/`, followed by a short descriptor. For example, `bugfix/login-error`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hotfix/`. For example, `hotfix/xyz-security-vulnerability`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`release/` as a prefix. An example would be `release/v1.2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contextual naming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While these categories offer a good starting point, you may also consider adding
    more contextual information to the branch name. For example, you could append
    the issue number at the end (`feature/123-user-authentication`) or include the
    name of the person responsible for the branch (`feature/teamxyz-authentication`).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we recognized that a solid branching strategy stands as the
    backbone of any collaborative development project. We have explored the significance
    of branch strategies in maintaining a stable code base while facilitating continuous
    integration and delivery. Whether it is adopting the small and frequent commits
    of TBD, the structured roles of Git Flow, or the simplicity of GitHub Flow, the
    right strategy is paramount to a team’s success.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, these conventions should align with your broader branching strategy
    and policy and be adapted to the size of your team and the project and your organization’s
    unique constraints and goals. A well-chosen naming convention will reinforce the
    effectiveness of your branching policy, aiding in the quest to mitigate friction
    and accelerate releases. By adhering to a well-defined naming convention, you
    empower your team to work more efficiently and foster a culture of clarity and
    accountability.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, you will learn how to bring together disparate lines
    of development while maintaining the integrity and history of your code. Let’s
    move forward with confidence, ready to merge our knowledge of branching into the
    practical skills of Git merging.
  prefs: []
  type: TYPE_NORMAL
- en: Ways to apply your changes on a branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have delved into the intricacies of branch management and workflows
    in DevOps, you are likely starting to see the big picture. You have come to understand
    how your individual commits contribute to the overall development stream. The
    next step in this journey is *to connect the dots*—more specifically, consider
    how the code you have written gets merged into the mainline.
  prefs: []
  type: TYPE_NORMAL
- en: The code base is a living, collaborative environment; it holds a history of
    contributions from various team members. In a fast-paced environment, it may be
    tempting to rush through commits or push large chunks of changes all at once to
    meet deadlines. However, when merging, it is crucial to consider how your changes
    contribute to a consistent, understandable, and stable shared environment. This
    consideration becomes particularly vital in a DevOps culture, where the objective
    is not just rapid deployment but also frictionless collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will explore various tactics and best practices
    for executing successful merges in Git, particularly tailored to the needs and
    challenges that arise in a DevOps setting.
  prefs: []
  type: TYPE_NORMAL
- en: Merging vs rebasing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Git offers two main techniques for integrating these changes: merging and rebasing.
    While they serve the same ultimate purpose—bringing different strands of code
    together—they have distinct operational nuances. Before diving into various actual
    commands, let’s distinguish between merging and rebasing.'
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Merging takes the content of a source branch and integrates it with a target
    branch. This new commit will have two parent commits, preserving the independent
    histories of the branches being merged. Merging can be cumbersome because it keeps
    the history from the various branches as it is, but it is also good in terms of
    flexibility during integration when various people are working on a project at
    the same time. Mainly, there are two types of merge options: **non-fast-forward
    merge**, which creates a new merge commit to log the merge, and **fast-forward
    merge**, which does not create a merge commit. There is also the squash function—an
    option that compresses multiple commits into a single commit for merging.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On platforms such as GitHub, the default setting is for merge commits to be
    made like in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Merging example (non-fast-forward)](img/B21203_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Merging example (non-fast-forward)
  prefs: []
  type: TYPE_NORMAL
- en: Here are the pros and cons of merging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: '**History preservation**: Merging keeps the history of both branches, offering
    a detailed log'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: It is usually easier for beginners to understand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branch isolation**: Individual branches can continue to make separate changes
    without affecting the merge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex log**: While preserving history, merges can lead to a complicated
    and cluttered log history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of linearity**: The project history becomes non-linear, making it challenging
    to navigate the commit history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rebasing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rebasing is the process of moving or combining a sequence of commits to a new
    base commit. It essentially takes the changes made in a feature branch and replays
    them on top of another branch. Instead of creating a new commit, as is the case
    with merging, rebasing rewrites the commit history to produce a linear succession
    of commits. The great thing about rebasing is the linearity of its history. When
    looking back in time, it is easy to follow the flow of what happened in the mainline
    branch, which is very good in terms of bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you master rebasing, you can contribute to a noise-free history:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Rebasing](img/B21203_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Rebasing
  prefs: []
  type: TYPE_NORMAL
- en: Here are the pros and cons of rebasing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cleaner history**: Rebasing results in a much cleaner, linear project history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eliminates Noise**: It removes unnecessary merge commits that appear when
    performing the git merge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simpler Debugging**: With a cleaner history, debugging becomes easier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared Branch Risk**: Rebasing can be destructive; it can be risky on shared
    branches because it rewrites commit history'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**: Rebasing can be more complicated to understand and execute
    correctly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both techniques have their pros and cons. Merging preserves the original branch
    history but can lead to a complicated log. Rebasing offers a cleaner, more linear
    project history but carries risks, especially when working on a shared branch.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring different ways to merge in Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s dive into the practical steps. We will explore the process of merging
    two branches, offering hands-on experience to help you better understand each
    method. In this section, we will cover some of the most commonly used methods
    to merge branches, enabling you to make informed decisions based on your project
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: git merge --ff – Keeping it straight
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s dig into the practical aspects now. This section focuses on a common default
    behavior in Git merging called `--ff` as a command option. We will go through
    the process, ensuring you understand how it works and when to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Fast-forward merging is one of the simplest ways to integrate branches in Git.
    In essence, a fast-forward merge moves the tip of the targeted branch to the latest
    commit on the source branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'With fast-forward merges, when looking at the history, nothing actually appears
    to have changed, as shown in the following figure. That is the benefit of fast-forward
    merging. HEAD is moving without fail and merging can be done smoothly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Fast-forward merging](img/B21203_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Fast-forward merging
  prefs: []
  type: TYPE_NORMAL
- en: In Git, a fast-forward merge is possible when there are no new commits on the
    base (or target) branch that occurred after the feature branch was created. Essentially,
    it eliminates the need for a new commit to join the branches, keeping your project
    history linear.
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for fast-forward merging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the context of this guide, assume you have a `main` branch and an `add-description`
    branch. The `add-description` branch has derived from the `main` and you are planning
    to merge the feature back into `master`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, your repository structure would resemble the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – git merge –ff (1)](img/B21203_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – git merge –ff (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s proceed to merge these branches by switching back to the `main`
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, your repository history would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – git merge –ff (2)](img/B21203_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – git merge –ff (2)
  prefs: []
  type: TYPE_NORMAL
- en: Why fast-forward merges are preferred in DevOps and team collaboration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Behind the scenes, a fast-forward merge merely moves HEAD, the pointer, to the
    latest commit. Moreover, fast-forward merges do not create a new merge commit,
    keeping the Git history clean and linear. This makes it a simple and efficient
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fast-forward merges are often preferred in team collaboration for a few reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**: They keep the git history linear, which makes it easier to
    follow'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transparency**: With a straightforward history, it is easier to track changes,
    debug issues, and understand the sequence of feature integrations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: Fast-forward merges eliminate the need for an extra merge commit,
    simplifying code reviews'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, keep in mind that fast-forward merges are not always possible. You
    can use this way when you are developing with just yourself or when doing simple
    development, but in most development, there are many things going on in parallel.
    When simultaneous changes occur in the master and feature branches, a non-fast-forward
    merge, which is sometimes called a three-way merge, may be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: git merge --no-ff – Preserving branch history
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Non-fast-forward merges, commonly invoked with the `--no-ff` flag, offer an
    alternative merging strategy that differs from the fast-forward merges we discussed
    earlier. Unlike fast-forward merges, which move the tip of the targeted branch
    to the latest commit of the source branch, non-fast-forward merges generate a
    new merge commit. This new commit has two parent commits: one from the source
    branch and one from the target branch.'
  prefs: []
  type: TYPE_NORMAL
- en: Non-fast-forward merges can embed context into the merge commit so that it is
    possible to look back later to see why this merge was performed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Non-fast-forward merging](img/B21203_03_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Non-fast-forward merging
  prefs: []
  type: TYPE_NORMAL
- en: This approach keeps track of the fact that a feature branch was merged into
    the main branch, preserving the context in which past commits were made.
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for non-fast-forward merging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s assume you are working with a `main` branch and `add-feature` branch.
    The following are the steps to perform a non-fast-forward merge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now the `commit` log is as shown in *Figure 3**.11*. What you did so far is
    the same as what you did in the `git merge --``ff` section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – git merge --no-ff (1)](img/B21203_03_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – git merge --no-ff (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s switch back to `main` and perform a **non-fast-forward** merge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following edit message will appear in the terminal. Edit the commit message
    and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'After the edit, let’s see the log now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Your repository history will show a new merge commit indicating where the `add-feature`
    branch was integrated into the `main` branch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – git merge --no-ff (2)](img/B21203_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – git merge --no-ff (2)
  prefs: []
  type: TYPE_NORMAL
- en: Why use non-fast-forward merges in DevOps and team collaboration?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Non-fast-forward merges offer benefits that can be valuable in various DevOps
    and team collaboration scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context preservation**: Generating a new commit during the merging process
    preserves not just the code but the history and context as well. This clear record
    of integration makes it much easier to understand when and how changes from different
    branches were combined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-ff` offers invaluable transparency, providing a clear record of who made
    what changes, when they made them, and why. This is particularly beneficial in
    larger teams and complex projects where it is crucial to understand the flow of
    contributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While merge commits can provide rich context and history, they can also clutter
    the Git history if overused or poorly documented. It is important for teams to
    consider their merging strategy carefully and make concerted efforts to maintain
    a clean shared repository.
  prefs: []
  type: TYPE_NORMAL
- en: git merge --squash – Squashing complexity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `git merge --squash` option provides a different merging technique that
    offers both clarity and tidiness. While fast-forward and non-fast-forward merges
    are excellent for tracking branch histories, there might be cases where you want
    to condense your `feature` branch changes into a single commit before merging.
    That’s where `git merge --``squash` shines.
  prefs: []
  type: TYPE_NORMAL
- en: In a squashed merge, all changes from the source (or feature) branch are combined
    into a single commit on the target (or main) branch. This action effectively condenses
    the feature branch history into one commit while merging, offering a clean, easy-to-follow
    Git history. This leaves the changes in an uncommitted state, allowing you to
    modify the differences before finalizing the commit.
  prefs: []
  type: TYPE_NORMAL
- en: While teams are committed to maintaining a clean shared repository, individual
    development branches often become cluttered with various trial-and-error attempts.
    Squash merges contribute to preserving the cleanliness of the main code base by
    preventing these messy, experimental logs from infiltrating the production history.
  prefs: []
  type: TYPE_NORMAL
- en: The squash merge, as shown in the following figure, is in some ways the cleanest
    merge, and it has a lot of benefits. However, keep in mind that it is a way of
    incorporating changes that lose the previous change history and the commit history
    of other companies. This will be mentioned later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Squash merging](img/B21203_03_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Squash merging
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for squash merging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s say you have a `main` branch and an `add-multiple-features` branch. To
    perform a squash merge, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the branches should look like those in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – git merge --squash (1)](img/B21203_03_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – git merge --squash (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s switch back to the mainline and perform a `squash` merge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The commits are then squashed and become a single commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – git merge --squash (2)](img/B21203_03_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – git merge --squash (2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, Git will add uncommitted changes to the `main` branch. It is time to
    complete the merge process. To complete the merge, you need to commit those uncommitted
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will combine all the changes from the `add-multiple-features` branch into
    a single new commit on the `main` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – git merge --squash (3)](img/B21203_03_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – git merge --squash (3)
  prefs: []
  type: TYPE_NORMAL
- en: Why use squash merges in DevOps and team collaboration?
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Squash merges offer a unique set of benefits for DevOps and collaborative development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomic changes**: A squashed merge creates a single commit that contains
    all the feature changes, making it easier to roll back if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced noise**: Squash merges eliminate the clutter of many small, perhaps
    experimental, commits from the main branch. This makes for a cleaner log history
    that’s easier to read and understand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategic commit messages**: Squashing allows you to create a comprehensive
    commit message that can encapsulate the purpose and impact of a feature more effectively
    than a series of smaller commits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it is worth noting that while squash merges can simplify history, they
    can also obfuscate it. Individual commits from the feature branch are lost in
    the main branch, making it hard to understand the development context of each
    separate change. Use this merge strategy judiciously and understand its impact
    on your development history.
  prefs: []
  type: TYPE_NORMAL
- en: The ethics and pitfalls of squash merging
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Squashing someone else’s commits can sometimes be problematic.
  prefs: []
  type: TYPE_NORMAL
- en: The `git merge --squash` command is a powerful tool for consolidating multiple
    commits into a single one. While this function keeps your commit history clean
    and manageable, it raises ethical and practical issues when used on commits made
    by others.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to be aware of the following concerns in team collaboration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorship misattribution**: By default, the person who performs the squash
    becomes the author of the consolidated commit, effectively erasing the original
    contributors’ history. This could demotivate team members by not recognizing their
    contributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**History alteration**: The command alters the commit history, which could
    be considered disrespectful to the original author’s work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If maintaining the integrity of individual commits is important, consider using
    a standard merge. This may result in a messier history, but it preserves the work
    and recognition of all contributors.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `git rebase` command offers more control over the commit history,
    which is useful for cleaning up or rearranging your own work without affecting
    others.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore this command next.
  prefs: []
  type: TYPE_NORMAL
- en: git rebase – Rewriting for clarity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rebasing is another powerful technique in Git that differs significantly from
    merging. The primary difference between merging and rebasing is how they integrate
    changes. While `git merge` integrates changes from one branch into another, `git
    rebase` moves or combines a sequence of commits to a new base commit.
  prefs: []
  type: TYPE_NORMAL
- en: In the team collaboration context, rebasing is used to maintain a linear project
    history, which simplifies debugging and makes code reviews easier. However, rebase
    comes with its share of complexities and pitfalls and is generally best used in
    specific circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into the hands-on tutorial, let’s understand how `git rebase`
    works at a high level. The primary utility of rebasing is to place the changes
    from the `feature` branch on top of another branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Rebasing (1)](img/B21203_03_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Rebasing (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'After rebasing `feature` onto `main`, your branch might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Rebasing (2)](img/B21203_03_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Rebasing (2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can merge back to main, at which point a fast-forward merge can
    be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Rebasing (3)](img/B21203_03_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Rebasing (3)
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for git rebase
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s take a practical example with a `main` branch and a `new-feature` branch.
    Here’s how to perform rebase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, your branch history may look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – git rebase (1)](img/B21203_03_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – git rebase (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say new commits have been added to `main` while you were working
    on `new-feature`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Your commit graph now diverges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – git rebase (2)](img/B21203_03_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – git rebase (2)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, rebase `new-feature` onto `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s check what it looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, your branches will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – git rebase (3)](img/B21203_03_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – git rebase (3)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to merge and complete the `git` `rebase` process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When a fast-forward merge is performed, the HEADs of the `main` and `new-feature`
    branches will be the corresponding commits, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – git rebase (4)](img/B21203_03_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – git rebase (4)
  prefs: []
  type: TYPE_NORMAL
- en: Why rebasing is powerful in DevOps and team collaboration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The primary advantage of rebasing in a DevOps culture is that it results in
    a much cleaner project history than merging. Cleaner histories are easier to debug
    and simpler to understand, and they make more logical sense to developers who
    join the project at a later time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear history**: It is easier to understand than the non-linear history
    created by git merge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified debugging**: With a cleaner history, tracking down when a particular
    bug was introduced becomes easier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code hygiene**: Rebasing encourages you to squash fixup commits or split
    larger commits, making your changes more understandable compared to the other
    developers’'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cautions and pitfalls of git rebase
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are golden rules to follow: *do not rebase public (team) branches*. One
    such cardinal rule is to avoid rebasing public branches. Rebasing can be a great
    tool for cleaning up a feature branch, but when done on branches that are publicly
    available, it can become a disaster.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the things to consider when you use `git rebase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conflicts for collaborators**: Imagine that you have rebased a public branch
    and pushed the changes. Other developers who have already pulled the old version
    of the branch now have a divergent history. When they try to push their changes,
    Git will reject the push, forcing them to reconcile the histories. This creates
    extra work and increases the chance of merge conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex merges**: After a public branch has been rebased and the history
    altered, merging it with other branches can become a real challenge. Because Git
    uses the commit history to determine how to integrate changes, modifying that
    history can make merging far more complicated than it needs to be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loss of context**: Rebasing can squash commits together or change their order,
    which may result in a loss of context for those changes. This makes debugging
    more difficult and can complicate the task of understanding the development process
    that led to the current code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rebasing can be complex and risky, especially for inexperienced developers.
    In worst-case scenarios, you may have to resolve many conflicts, leading to errors
    and bugs if not done carefully.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding and using `git merge` and `git rebase`, you can handle pretty
    much any situation that requires combining different lines of development. Each
    has its place in a Git command, and understanding when to use each one is the
    key to maintaining a clean and understandable code base—something that is highly
    valuable in the world of DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: git cherry-pick – Picking specific commits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most flexible tools in the Git commands is the `git cherry-pick`
    command. While the previous merge methods were mainly used for integrating entire
    branches, `git cherry-pick` allows you to select specific commits from one branch
    and apply them to another branch. This method can be incredibly useful when you
    need to apply just a few specific changes without taking all the modifications
    from a different branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have two branches, `main` and `feature`. You realize that one or
    two commits from the `feature` branch should be moved to `main`, but you are not
    ready to merge the entire branch. The `git cherry-pick` command allows you to
    do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Cherry-picking (1)](img/B21203_03_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 – Cherry-picking (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can cherry-pick the changes from a specific commit in the `feature` branch
    and apply them to `main`. This action will create a new commit on the `main` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Cherry-picking (2)](img/B21203_03_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25 – Cherry-picking (2)
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for cherry-picking
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s go over the practical steps for cherry-picking changes and merging
    them into a branch. Each commit adds a file to each of them. Let’s take some of
    those commits and merge them into `main`. First, we add the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the branches look like those in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – git cherry-pick (1)](img/B21203_03_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26 – git cherry-pick (1)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s only pick the `a80e8ad` commit and put it on the `main` branch.
    Please replace the hash value in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have successfully cherry-picked the commit, a new commit will be
    added to your current branch (`main` in this example) and it will include the
    changes from the cherry-picked commit. Note that the new commit has the same changes
    but a different commit hash value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – git cherry-pick (2)](img/B21203_03_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.27 – git cherry-pick (2)
  prefs: []
  type: TYPE_NORMAL
- en: Why cherry-pick is useful in DevOps and team collaboration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Team development requires flexible development. `git cherry-pick` is a useful
    command in collaborative coding environments, allowing teams to selectively integrate
    changes and maintain code integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what value `cherry-pick` can offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selective integration**: It allows specific bug fixes or features to be moved
    into production without having to move all changes from a development branch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy reversion**: If something goes wrong, you only need to revert a small
    change rather than an entire branch merge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clean history**: Keeps your Git history tidy by only including relevant commits,
    making it easier to read and understand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git cherry-pick` offers a high level of precision for integrating changes
    between branches. It allows you to select exactly which commits to include, providing
    granular control over your project history. This makes it an invaluable tool for
    any DevOps engineer aiming for a flexible and efficient version control workflow.'
  prefs: []
  type: TYPE_NORMAL
- en: After exploring the various merging strategies in Git, you might be asking yourself,
    “*Which method should I use?*” The answer, as with most things in engineering,
    is, “*It depends.*” Several factors come into play when determining which Git
    merge strategy best suits your needs. Additionally, it is worth noting that you
    do not have to stick to a single method; you can vary your approach depending
    on the situation. Understanding these factors can help you make an informed decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the following factors to see how you should choose:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Project complexity**: Complex projects with multiple contributors and parallel
    development lines may require a more consistent merging approach to minimize conflicts.
    Platforms such as GitHub allow you to set merge strategies for your projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git merge` can reduce the chances of mistakes. However, if the majority of
    the team is experienced, you may want to leverage the benefits of `rebase` to
    maintain a cleaner Git history while also facilitating smoother communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Desired cleanliness of Git history**: If a clean, linear Git history is of
    utmost importance to you, then opting for fast-forward merges or rebasing might
    be the best route. On the other hand, if you value detailed documentation of your
    project’s development process, a non-fast-forward merge would be a better choice
    for maintaining a comprehensive record of changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you move forward, let the knowledge from this section guide you in choosing
    the appropriate merge approach for your projects. Practice with real-world scenarios
    to gain confidence. Remember, there is no one-size-fits-all answer in Git—flexibility
    and adaptability are your allies
  prefs: []
  type: TYPE_NORMAL
- en: Navigating conflicts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a collaborative development environment, conflicts are not just possible—they
    are inevitable. When multiple developers are working on the same code base, or
    even the same files, there is a good chance that changes will overlap, leading
    to conflicts. Navigating and resolving these conflicts is crucial for maintaining
    a smooth and efficient DevOps workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Why conflict happens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conflicts generally occur when two branches have changes in the same line or
    section of a file and are then attempted to be merged. Git, as sophisticated as
    it is, can not decide which change to take precedence. The key to efficiently
    resolving these conflicts is understanding why they occur and being proactive
    in preventing them when possible.
  prefs: []
  type: TYPE_NORMAL
- en: How to merge conflicts in Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the basics. Conflict resolution in Git usually involves manual
    intervention. Here is how to go about it:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify conflicts. Use `git status` to see which files are conflicted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine the conflicted files. Open them up and look for the conflict markers
    (`<<<<<<<`, `=======`, and `>>>>>>>`). These markers delineate the changes from
    the different branches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Resolve the conflicts. Choose which changes to keep. You can keep the changes
    from one branch, mix both, or even add something entirely new.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the resolved files. After resolving, you need to add the files to the
    staging area and commit them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to resolve merge conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Merge conflicts are inevitable in a collaborative development environment. The
    key is knowing how to resolve them efficiently. There are several patterns you
    can follow, depending on the nature of the conflict.
  prefs: []
  type: TYPE_NORMAL
- en: When there is a definitive version to retain
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have merged two branches and want to fully accept one version over the
    other, you can opt to use `git checkout --ours` or `git` `checkout --theirs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`checkout --ours`: Use this command to keep the files from your branch when
    a merge conflict arises:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git checkout --theirs -- <file-path>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After running one of these commands, you will need to add the updated files
    to the staging area and then commit them.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to evaluate both versions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In cases where it is not clear which version should take precedence, a more
    nuanced approach is required.
  prefs: []
  type: TYPE_NORMAL
- en: '**Review the code**: Open the conflicting files in a text editor to manually
    inspect the clashing lines of code. Decide which parts to keep and edit the files
    accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication**: If necessary, consult with your teammates to decide which
    changes should be kept. This can be done through in-person discussions, virtual
    meetings, or code review tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run tests**: Once you have resolved the conflicts manually, it is crucial
    to run tests to ensure that the code base is still stable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commit the changes**: After successful testing, stage the resolved files
    and commit them to your repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By carefully handling merge conflicts, you can help maintain a clean code base
    and foster better communication within your team.
  prefs: []
  type: TYPE_NORMAL
- en: Useful commands for supporting merge activities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Merging is an activity that comes with its own set of challenges. Having the
    right set of tools and commands at your disposal can make the process smoother
    and less error-prone. In this section, there are some useful Git commands that
    can help you effectively manage your merges.
  prefs: []
  type: TYPE_NORMAL
- en: git diff – Spot the difference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `git diff` command is an essential tool for identifying the differences
    between two sets of code. It helps you see what exactly has changed between two
    branches or two commits, making it much easier to resolve conflicts when they
    arise.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compare the current branch to a target branch like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command displays a line-by-line comparison of the changes between `feature-branch`
    and `main`. You can also focus on specific files or even specific lines of code,
    which makes it a flexible tool for spotting differences at various granularities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Git does not have a built-in dry-run option for `git merge`, you can
    simulate a merge to see what will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This command sequence attempts to merge changes from develop into your current
    branch but stops just before committing them. You can then use `git diff --cached`
    to view the staged changes. If the merge is not what you expected, you can simply
    abort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: git mergetool – A simplified guide tooling to visual conflict resolution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you run into a merge conflict that’s challenging to resolve manually, or
    if you are more comfortable with a graphical interface, Git’s built-in `git mergetool`
    can come to your rescue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following items can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kdiff3`, `meld`, and `vimdiff`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global configuration**: Set your chosen tool as the default for all your
    Git repositories with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command opens your chosen graphical tool and displays the conflicting changes
    side by side. This interface simplifies the process of understanding conflicts
    and deciding which changes to keep. This setting allows you to specify not only
    command line tools but also modern tools such as Visual Studio Code to resolve
    merges graphically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By following these straightforward steps, you can resolve complex merge conflicts
    in a more intuitive way, making the process accessible for team members of all
    skill levels.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, conflict resolution is an essential skill for any engineer. While
    conflicts can be complex and challenging, knowing how to navigate them efficiently
    can make your development workflow much smoother. It is not just about resolving
    the conflicts themselves but understanding the underlying issues that lead to
    them. This nuanced approach is crucial for fostering better communication and
    collaboration within your development team.
  prefs: []
  type: TYPE_NORMAL
- en: As team development progresses, projects become more complex. Conflicts are
    inevitable. Conflict is a great opportunity to help your team to improve its collaboration
    skills. You should not be afraid of conflicts, and you should also learn how to
    communicate best for your team by solving them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering better collaboration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have discussed how to handle merges and resolve conflicts in
    Git. We have seen that you can clean up your local changes with `git merge --squash`
    or adjust commit history with `git rebase`. While it is great to keep your workspace
    neat, the ideal scenario is to maintain a clean code base, especially when you
    push to a shared environment. Next, let’s talk about the commands that enable
    you to be an excellent collaborator, whether you are an individual contributor
    or a team leader managing the main shared branch.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling back time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any collaborative project, mistakes are inevitable. Even if it was not a
    mistake, there will be many times you will want to rewind and go back in time.
    Whether it is a bad commit that breaks the build or a feature that did not pan
    out as expected, the ability to roll back changes is crucial. Two commands that
    are indispensable for this are `git reset` and `git revert`.
  prefs: []
  type: TYPE_NORMAL
- en: git reset – Rolling back changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `git reset` command allows you to *rewind* your Git history, essentially
    moving HEAD and, optionally, the working directory to a specific commit. This
    is incredibly powerful but should be used cautiously. There are several different
    ways to use `git reset`. Know them so that you can organize your environment efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Soft reset**: This keeps your working directory and index intact but moves
    HEAD. This command is used when you want to leave the index working tree untouched
    and only undo the commit:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 3.28 – git reset --soft](img/B21203_03_028.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.28 – git reset --soft
  prefs: []
  type: TYPE_NORMAL
- en: '`git add` and `git commit`. File changes will remain; this is the default when
    no options are specified with `git reset`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 3.29 – git reset --mixed](img/B21203_03_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.29 – git reset --mixed
  prefs: []
  type: TYPE_NORMAL
- en: '**Hard reset**: This resets the index and working directory, permanently deleting
    uncommitted changes. It deletes all changes to commits, indexes, and files, so
    all the changes themselves do not remain with you. If you want to delete everything,
    this is the way to do it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 3.30 – git reset --hard](img/B21203_03_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.30 – git reset --hard
  prefs: []
  type: TYPE_NORMAL
- en: git revert – Undoing without rewriting history
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike `git reset`, which alters commit history, `git revert` creates a new
    commit that undoes the changes made by a previous commit. This is extremely useful
    in a shared environment where rewriting history is highly discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: '`git revert` creates a reverse commit as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.31 – git-revert creates a commit to cancel the commit](img/B21203_03_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.31 – git-revert creates a commit to cancel the commit
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will undo the changes made by the commit with the specified hash
    and create a new commit to record this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are cases when you can use `git revert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git revert` does not rewrite history, it is safe to use on shared branches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git revert` is a clean way to remove it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git revert` operation as part of your rollback strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s learn about some additional advanced `git` `revert` options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reverting multiple commits**: You can revert a range of commits by specifying
    a commit range:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: git revert -n <commit_hash>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note the caret (`^`) symbol. This means the oldest commit in the range of commits
    to revert is included.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering `git revert` is crucial for any developer or DevOps professional.
    It provides a safe mechanism for undoing changes, enabling better collaboration
    and more reliable code.
  prefs: []
  type: TYPE_NORMAL
- en: git checkout – More than just branch hopping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous discussions, we have touched on the `git checkout` command mainly
    in the context of switching between branches. While this is certainly one of its
    primary functions, it is crucial to understand that `git checkout` is a multi-purpose
    tool that can operate at the granularity of individual files or directories as
    well. In this section, let’s expand our understanding of `git checkout` and see
    how it plays a vital role in efficient collaboration and error correction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a refresher on the basic command for switching branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you only need to restore a single file to a previous state? `git
    checkout` has got you covered. If you have made changes to a file but have not
    committed yet and you decide you want to undo those changes, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will discard changes in your working directory and revert the file back
    to the state of the last commit. Sometimes, you might want to partially apply
    changes from another branch to your current working branch. git checkout can also
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This command will check out a specific file from another branch into your current
    working branch, allowing you to mix and match code as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It offers versatility in team collaboration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick rollbacks**: If something goes wrong in the production, you can quickly
    check out the specific files from a stable branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selective feature testing**: Before merging a new feature, you can check
    out only the files relevant to that feature for testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy error correction**: Mistakes happen all the time. The ability to check
    out individual files makes it easier to correct them without affecting other parts
    of the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using `git checkout` on files will discard changes. Make sure this is what you
    intend to do. If you are experimenting, it is a good idea to commit your changes
    often. That way, you can easily revert back to a specific commit if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the full range of `git checkout` capabilities can significantly
    enhance your workflow and collaboration efficiency. Whether you are working alone
    or as part of a team, the ability to manipulate not just branches but also individual
    files grants you a higher degree of control and adaptability in your team collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your working environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the realm of team development, your individual workspace is your personal
    lab—a space where you can innovate, debug, and test freely without affecting the
    broader project. Managing this space efficiently is crucial, and Git offers a
    set of powerful commands to help you do just that. In this section, we will explore
    three essential Git commands—`git clean`, `git stash`, and `.gitignore`—that can
    easily keep your workspace clean.
  prefs: []
  type: TYPE_NORMAL
- en: git clean – A fresh start
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `git clean` command offers a quick way to clear your working directory
    of untracked files and directories, essentially providing a clean slate. This
    can be especially useful before or after executing a merge, or when you want to
    remove any clutter that does not need to be version-controlled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: git stash – Pause and resume work effortlessly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`git stash` is an invaluable tool for temporarily stashing away changes that
    you have made but are not yet ready to commit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, multitasking is often the name of the game. Whether you are
    interrupted by an urgent bug fix or need to switch context temporarily, `git stash`
    comes to the rescue. This command allows you to save your current changes without
    making a formal commit, giving you the freedom to switch tasks and then return
    to where you left off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, here is a rundown of common `git stash` commands that can significantly
    enhance your workspace management:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git stash`: This stashes your changes, leaving your working directory clean.
    Untracked files are not stashed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash save "Your Comment"`: This stashes your changes and allows you to
    attach a comment. This is useful for identifying stashes later with `git` `stash
    list`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash list`: This displays a list of all your stashed changes. If you
    used `git stash save`, you will see your comments here, making it easier to identify
    each stash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash apply`: This restores the most recently stashed changes to your
    working directory. The stash remains in the `git` `stash list`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash apply [stash@{n}]`: This restores a specific stash based on its
    index number, which you can find using `git` `stash list`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash drop`: This deletes a specific stash from the stash list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash drop [stash@{n}]`: This deletes a specific stash based on its index
    number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash clear`: This deletes all stashes, clearing your `stash list`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .gitignore – Personalize what gets shared
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working on complex projects, your local environment may generate files
    such as logs or contain personal configuration settings—things you do not want
    to share with the rest of the team. The `.gitignore` file enables you to specify
    which files and folders should be ignored during a `git add`, ensuring they remain
    exclusive to your local environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a `.``gitignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Who did what? Great ways to help you debug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git has a couple of typical ways to analyze the past. `git blame` and `git bisect`
    are useful to remember because they are easy to use to go back and debug who made
    what changes.
  prefs: []
  type: TYPE_NORMAL
- en: git blame – Who did what?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working in a shared code base, there may be instances where you need to
    understand the history of specific lines of code. The `git blame` command provides
    a breakdown of a file, annotating each line to show the last person who modified
    it and what commit it belongs to. This helps in identifying the responsible parties
    for particular changes, which is useful for debugging, refactoring, or simply
    understanding why a particular piece of code exists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-L` option allows you to specify the lines of output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: It is essential to highlight that the aim of `git blame` is not to single out
    individuals for errors or questionable decisions. In any collaborative setting—especially
    in DevOps where teamwork is paramount—it is crucial to remember that mistakes
    are a collective responsibility. Everyone can err; what is important is how the
    team collaborates to fix those errors. From a psychosocial safety perspective,
    using `git blame` should be approached as a way to enhance team communication
    and identify areas for improvement rather than as a mechanism for casting blame.
  prefs: []
  type: TYPE_NORMAL
- en: git bisect – Efficient bug hunting in commit ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Debugging can often feel like looking for a needle in a haystack, especially
    in large codebases with a long history of commits. In the realm of DevOps, where
    rapid deployment cycles are the norm, a bug introduced in any of the numerous
    changes can wreak havoc. This is where `git bisect` comes into play, serving as
    a powerful tool for isolating the specific commit that introduced a bug.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git bisect` command performs a binary search through your commit history
    to find the commit that introduced the bug. The process begins by marking a known
    good commit and a known bad commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Git will then automatically check out a commit halfway between the good and
    bad commits. You test this commit and then mark it as either good or bad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Git will continue this process, narrowing down the range of commits until it
    identifies the culprit. Once you find the problematic commit, it is easier to
    understand what went wrong and to devise a fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In DevOps, where the speed of identifying and resolving issues is crucial for
    maintaining operational excellence, `git bisect` becomes an invaluable tool. It
    integrates well into a DevOps toolchain, allowing for automated testing and facilitating
    quicker rollbacks and patches. By efficiently pinpointing errors, it enhances
    the team’s ability to collaborate on solutions, underscoring the essential DevOps
    principles of rapid feedback and continuous improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning excellence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the DevOps ecosystem, **CI/CD** make everything incremental. Yet, it is essential
    to have concrete versions of your software to serve as milestones. These versions
    are not just markers in time; they indicate the stability, new features, and overall
    health of your code base. They also facilitate smoother rollbacks and make it
    easier to isolate issues.
  prefs: []
  type: TYPE_NORMAL
- en: What is semantic versioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Semantic versioning is a versioning scheme designed to convey specific meanings
    about the underlying changes with each new release. The format consists of three
    numbers separated by dots (e.g., 2.4.4). Each number has a particular significance
    related to backward compatibility and the types of changes introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging in Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tagging becomes a cornerstone of effective version control within a DevOps environment.
    By marking specific points in your repository’s history, you can create anchors
    that serve as stable release points or significant milestones. These tagged versions
    form the basis for your CI/CD pipelines, ensuring consistent and reliable deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your tags more informative, consider annotating them with useful metadata
    and context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The commits you tag should typically represent stable release points or crucial
    milestones. These are the commits where all the automated tests have passed, features
    are complete, and the code has undergone peer review. In essence, they are your
    *production-ready* commits.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tag a specific commit, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Git tagging and semantic versioning are not just technical procedures but strategic
    actions. They ensure that everyone is on the same page regarding what is being
    deployed and what it can do.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have equipped ourselves with the knowledge to roll back
    time in our repositories, understanding when and how to use `git reset`, `git
    revert`, and `git checkout`. These powerful commands ensure that we can gracefully
    undo changes, correct course, and maintain a clean project history—all essential
    for a collaborative setting. Organizing your working environment with `git clean`,
    `git stash`, and the right `.gitignore` settings offers you a pristine workspace
    where focus and clarity replace clutter and chaos. This clean slate is not just
    about personal preference; it is about setting a standard for the team and ensuring
    that only intentional changes make their way into the shared repository.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating these techniques into your routine not only prepares you for better
    personal performance but also strengthens the whole team.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved deep into the nuances of branch strategies, the intricacies
    of merging and rebasing, and the art of navigating conflicts with the goal of
    mastering better collaboration within your teams. From understanding why a branching
    strategy is crucial to aligning branch naming with organizational objectives,
    we have laid out the groundwork for you to build a robust workflow.
  prefs: []
  type: TYPE_NORMAL
- en: We explored the various branching models, such as trunk-based development, Git
    Flow, and GitHub Flow, highlighting their unique benefits and scenarios where
    they fit best. The discussion around merge approaches provided insight into the
    tools at your disposal for maintaining a clean and informative project history
    while also addressing the sometimes daunting task of conflict resolution.
  prefs: []
  type: TYPE_NORMAL
- en: As you close this chapter, remember that the path to mastering Git is ongoing.
    Encourage yourself to discover more and to practice these skills through your
    development work with confidence. Embrace the challenges and the learning opportunities
    they bring and continue to grow as a developer. Git is not just a tool; it is
    a companion in your DevOps journey that enhances the developer’s experience by
    removing friction and fostering a culture of collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: GitHub Excellence and CI/CD Fundamentals'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part highlights GitHub’s role in DevOps, expanding its use beyond just
    code hosting. It discusses GitHub’s features that enhance team collaboration and
    the transition to modern DevOps practices. Additionally, it delves into GitHub
    Actions, focusing on workflow optimization, advanced deployment methods such as
    blue-green and canary deployments, and feature release strategies. This provides
    an in-depth understanding of GitHub’s capabilities in continuous integration and
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B21203_04.xhtml#_idTextAnchor077), *Elevating Team Collaboration
    with GitHub*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21203_05.xhtml#_idTextAnchor109), *Driving CI/CD with GitHub*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
