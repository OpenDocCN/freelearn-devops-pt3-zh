- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Advanced Git Usage for Team Collaboration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Git用法用于团队协作
- en: Now, we move on to the aspect of actual collaboration. In this chapter, we will
    delve into various collaboration practices that you will want to adopt. You will
    learn how to organize your commit history, manage complex branches, and resolve
    conflicts during merges. The goal of this chapter is to help you become wonderfully
    in control of this branch flow team collaboration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入实际协作的部分。在本章中，我们将深入探讨你希望采用的各种协作实践。你将学习如何组织提交历史、管理复杂的分支，并在合并时解决冲突。本章的目标是帮助你能够很好地控制这种分支流的团队协作。
- en: Here, the focus is not just on getting the job done but also on doing it in
    a way that enhances teamwork. Recognize that there is a thoughtful strategy behind
    managing an entire code base to maximize the teams’ productivity and impact. Different
    strategies are employed based on the type of products or projects, the team size,
    and its maturity. Before we plunge into the Git commands, it is crucial to comprehend
    this underlying strategy—branching strategies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，重点不仅仅是完成工作，而是以一种能增强团队合作的方式来完成。要认识到，管理整个代码库背后有一套深思熟虑的策略，旨在最大化团队的生产力和影响力。根据产品或项目的类型、团队的规模及其成熟度，会采用不同的策略。在我们深入Git命令之前，理解这个基础策略——分支策略，是至关重要的。
- en: So, let’s get started on making your collaboration seamless and efficient.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始让你的协作变得更加顺畅高效吧。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Branching strategy for team collaboration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队协作的分支策略
- en: Ways to apply your changes on a branch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分支上应用变更的方法
- en: Navigating conflicts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理冲突
- en: Mastering better collaboration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握更好的协作
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Configuration instructions for proceeding with this section can be found in
    the following GitHub repository link. Please make sure Git and SSH tools are installed.
    For Windows users, it is recommended to use PowerShell. I also encourage you to
    get the most up-to-date information written about the different commands and environments.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 继续本部分的配置说明可以在以下GitHub仓库链接中找到。请确保已安装Git和SSH工具。对于Windows用户，建议使用PowerShell。我也鼓励你获取关于不同命令和环境的最新信息。
- en: '[https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub](https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub](https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub)'
- en: Branching strategies for team collaboration
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队协作的分支策略
- en: In the realm of team collaboration, commits act as the essential building blocks.
    These commits link together to form a chronological history, a record of your
    project’s evolution. This history is organized and maintained through branches.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队协作的领域中，提交是至关重要的构建块。这些提交链接在一起，形成一个按时间顺序排列的历史记录，记录了你的项目的演变。这一历史记录通过分支进行组织和维护。
- en: So, how can engineers and teams knit this history into a cohesive meaningful
    narrative? The branching strategy is the answer to this question. The branching
    strategy is a development strategy for effectively managing branches in Git to
    enable smooth collaboration and service delivery.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，工程师和团队如何将这些历史记录编织成一个连贯有意义的叙事呢？分支策略就是这个问题的答案。分支策略是一个有效管理Git中分支的开发策略，它能够促进顺畅的协作和服务交付。
- en: Why a branching strategy is important
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么分支策略很重要
- en: A well-crafted branching strategy is not just nice to have; it is crucial in
    a team development environment. Your branching strategy has a ripple effect on
    your DevOps processes, affecting deployment units and workflow efficiency. The
    ability to collaborate smoothly depends not only on good communication within
    the team but also impacts the speed at which your product evolves. This ties back
    into all the elements we have covered in the previous chapters, such as the frequency
    and methodology of your CI/CD tests. In essence, your branching strategy is pivotal
    in removing organizational friction, which is the ultimate aim of DevOps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个精心设计的分支策略不仅仅是锦上添花；它在团队开发环境中至关重要。你的分支策略会对你的DevOps流程产生连锁反应，影响部署单元和工作流效率。顺利协作的能力不仅依赖于团队内部的良好沟通，还会影响你的产品发展速度。这与我们在前几章中覆盖的所有元素相关，例如CI/CD测试的频率和方法论。本质上，你的分支策略在消除组织摩擦方面至关重要，而这正是DevOps的最终目标。
- en: 'Here are some reasons why a well-thought-out branching strategy is non-negotiable:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为什么深思熟虑的分支策略是不可妥协的原因：
- en: '**Isolation of changes**: It allows individual team members to work on distinct
    features or bugs without interfering with each other’s work.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更隔离**：它允许单独的团队成员在不干扰彼此工作的情况下，处理不同的功能或缺陷。'
- en: '**Risk mitigation**: A branching strategy safeguards the main (often called
    master) branch from being destabilized by untested or volatile code.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险缓解**：分支策略可以保护主分支（通常称为master分支）不被未经测试或不稳定的代码破坏。'
- en: '**Facilitates collaboration**: With a good branching strategy, multiple team
    members can work on different branches in parallel, thereby increasing overall
    team efficiency.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进协作**：通过良好的分支策略，多个团队成员可以并行在不同的分支上工作，从而提高团队的整体效率。'
- en: 'In the context of DevOps, a branching strategy also does the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevOps的背景下，分支策略还具有以下功能：
- en: '**Automated testing integration**: A branching strategy can be designed to
    trigger automated tests at various stages. This ensures that only well-tested
    code is merged back into the main branch, aiding in continuous integration.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化测试集成**：分支策略可以设计为在不同阶段触发自动化测试。这样可以确保只有经过充分测试的代码才能合并回主分支，从而支持持续集成。'
- en: '**Simplifies deployment**: A well-organized branch structure can streamline
    the deployment process, making it easier to move code from development environments
    to staging and finally to production.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化部署**：一个组织良好的分支结构可以简化部署过程，使得代码更容易从开发环境移至暂存环境，最终到生产环境。'
- en: '**Enhances developer experience**: It improves the overall **Developer Experience**
    (**DX**) by making collaboration more transparent and efficient, a key strategy
    for successful DevOps.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强开发者体验**：通过提高协作的透明度和效率，它改善了整体的**开发者体验**（**DX**），这是成功DevOps的关键策略。'
- en: '**Environment-specific branches**: Having branches dedicated to particular
    environments (development, staging, production, etc.) allows for smoother and
    more controlled deployments.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定环境的分支**：为特定环境（开发、暂存、生产等）设置分支，有助于实现更加平滑和可控的部署。'
- en: '**Enhances security**: By establishing clear boundaries between branches, a
    branching strategy can enhance security by controlling access to sensitive code
    and ensuring that changes undergo proper review and approval processes before
    being merged into critical environments.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强安全性**：通过在分支之间建立清晰的边界，分支策略可以通过控制对敏感代码的访问，并确保在合并到关键环境之前，所有更改都经过适当的审查和批准，从而增强安全性。'
- en: Branch strategy and branch policy
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支策略与分支政策
- en: In the landscape of software development and DevOps, the terms **branching strategy**
    and **branching policy** might appear synonymous. While they are frequently mistaken
    for one another, it is vital to recognize that a branching strategy is a more
    expansive concept that encompasses a branching policy.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发和DevOps领域，**分支策略**和**分支政策**这两个术语可能看起来是同义的。虽然它们经常被混淆，但必须认识到，分支策略是一个更广泛的概念，涵盖了分支政策。
- en: A branching strategy is a comprehensive plan that outlines how branches are
    managed, created, and integrated within your development workflow. It encapsulates
    more than just the technical aspects of handling branches. It also involves contextual
    variables such as the size of your organization, the culture within your team,
    and the specific requirements of your project or product.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 分支策略是一个全面的计划，概述了如何在开发工作流中管理、创建和集成分支。它不仅仅涉及处理分支的技术方面，还包括组织的规模、团队文化以及项目或产品的具体需求等背景变量。
- en: Branching policies, on the other hand, are more specific sets of rules or guidelines
    for branch management. These often form the backbone of a branching strategy,
    serving as templates to be customized according to your specific needs. Sometimes,
    policies such as **Git Flow** or **GitHub Flow**, which we will discover in this
    chapter, are used as the names of strategies for development. They should be considered
    as types of branching policies. Renowned software thought leader Martin Fowler
    discusses these items not as strategies themselves but rather under the *Looking
    at some branching policies* section in his article *Patterns for Managing Source
    Code* *Branches* ([https://martinfowler.com/articles/branching-patterns.html](https://martinfowler.com/articles/branching-patterns.html)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 分支策略，另一方面，是一组更为具体的规则或指南，用于分支管理。这些规则通常构成分支策略的骨架，作为模板，根据具体需求进行定制。有时，像**Git Flow**或**GitHub
    Flow**这样的策略名称（我们将在本章中介绍）被用作开发策略的名称。它们应该被视为分支策略的一种类型。著名的软件思想领袖马丁·福勒在他的文章《源代码分支模式管理》（*Patterns
    for Managing Source Code* *Branches*）中并未将这些视为策略本身，而是在*观察一些分支策略*部分进行讨论，具体内容请参见他的文章([https://martinfowler.com/articles/branching-patterns.html](https://martinfowler.com/articles/branching-patterns.html))。
- en: Therefore, when establishing a branching approach, it is crucial to choose a
    branching policy that serves as a foundation. This policy should then be customized
    to align with your organization’s unique needs and objectives to effectively mitigate
    friction in development processes and accelerate software releases. This tailored
    approach ensures that your branching strategy not only optimizes workflow but
    also integrates seamlessly with the cultural and organizational aspects of your
    team.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在建立分支方法时，选择一个作为基础的分支策略至关重要。这个策略应根据组织的独特需求和目标进行定制，以有效减少开发过程中的摩擦并加速软件发布。这种定制化的方法确保了分支策略不仅优化了工作流程，还与团队的文化和组织方面无缝融合。
- en: Smaller and frequent versus larger and less frequent
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 较小且频繁的修改 vs 较大且不频繁的修改
- en: 'There are many branching policies in existence. Companies often coin specific
    branching policy names and publish them as best practices, such as **GitHub Flow**.
    Fundamentally, all branching strategies map to one of two principles: make smaller
    changes frequently or make larger changes occasionally.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前存在许多分支策略。公司通常会创造特定的分支策略名称，并将其发布为最佳实践，如**GitHub Flow**。从根本上讲，所有的分支策略都可以映射到两个原则之一：频繁地进行较小的修改，或者偶尔进行较大的修改。
- en: For smaller teams, naturally, the friction in integrating changes and pushing
    releases quickly is less. But in larger organizations, with larger products or
    a lengthy approval process, the friction inevitably increases. More conflicts
    arise, and more checks are needed to prevent them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型团队来说，集成变更和快速发布的摩擦自然较小。但在大型组织中，尤其是涉及大型产品或冗长审批过程时，摩擦不可避免地增加。更多的冲突出现，需要更多的检查来防止这些冲突。
- en: However, allowing these challenges to slow down your development process can
    adversely affect the timeliness of your product or project releases, ultimately
    impacting business success.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，允许这些挑战拖慢开发过程可能会对产品或项目发布的及时性产生不利影响，最终影响业务的成功。
- en: Over time, various companies have devised a multitude of branching strategies
    to mitigate these issues. Most of them are extensions of existing practices, designed
    to reduce friction within the constraints of an organization or product, aiming
    for faster releases.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，许多公司设计了各种分支策略来缓解这些问题。它们中的大多数都是现有实践的扩展，旨在减少组织或产品限制内的摩擦，目标是加速发布。
- en: It is crucial to understand that no branching strategy serves as a one-size-fits-all
    solution. The base strategy often gets selected depending on the team’s composition
    and culture, and from there, customizations are made to fit specific needs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，没有任何一种分支策略是适用于所有情况的“万能解”。基础策略通常是根据团队的组成和文化来选择的，然后根据具体需求进行定制。
- en: 'This section introduces the branch policies trunk-based development, Git Flow,
    and GitHub Flow, each mapped as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了基于主干的开发、Git Flow 和 GitHub Flow 这三种分支策略，它们的映射如下：
- en: '![Figure 3.1 – Branching policies mapping](img/B21203_03_001.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 分支策略映射](img/B21203_03_001.jpg)'
- en: Figure 3.1 – Branching policies mapping
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 分支策略映射
- en: '**Trunk-based development** is renowned for integrating smaller, frequent changes
    directly into the main branch. In contrast, Git Flow is known for a strategy that
    integrates larger changes less frequently. Both have their pros and cons, and
    your choice between them often boils down to your team’s specific requirements
    and workflows.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于主干的开发**以将较小、频繁的更改直接集成到主分支中而闻名。与此相对，Git Flow因其较少频繁地集成较大更改的策略而著名。两者各有优缺点，选择其中之一通常取决于团队的具体需求和工作流程。'
- en: For larger organizations aiming to release a higher volume of changes more frequently
    with reduced friction, GitHub Flow serves as an excellent representative. These
    strategies are essentially designed to adapt the core principles of frequent,
    small changes to fit the complexity and scale of larger enterprises.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些希望更频繁地发布更多更改并减少摩擦的大型组织，GitHub Flow 是一个很好的代表。这些策略基本上是将频繁小规模更改的核心原则适应大型企业的复杂性和规模。
- en: Policies such as GitHub Flow are built under the influence of Git Flow, but
    many companies nowadays use GitHub Flow as a template upon which they build their
    own customized branching policies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 像GitHub Flow这样的策略是在Git Flow的影响下构建的，但现在许多公司使用GitHub Flow作为模板，在此基础上构建他们自己的定制化分支策略。
- en: Types of branch policies branch policies
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支策略的类型
- en: Now then, let’s look at a typical branch policy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个典型的分支策略。
- en: 'This section introduces three typical branching policies:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍三种典型的分支策略：
- en: Trunk-based development
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: Git Flow
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git Flow
- en: GitHub Flow
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Flow
- en: Consider each in terms of how frequently your team or organization needs to
    release and how large your product and project are.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑根据您的团队或组织需要发布的频率以及您的产品和项目的规模来分析每种情况。
- en: Trunk-based development
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: '**Trunk-based development** (**TBD**) is a software development approach where
    developers work in short-lived branches, typically less than a day, or directly
    off a single branch called the **trunk** or the mainline. The key principle is
    to minimize the lifespan of branches to promote frequent integrations and to avoid
    the pitfalls of long-lived feature branches, such as merge conflicts and diverging
    codebases.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于主干的开发**（**TBD**）是一种软件开发方法，在这种方法中，开发人员在短生命周期的分支上工作，通常不超过一天，或者直接从一个名为**主干**或主线的单一分支上工作。其关键原则是尽量缩短分支的生命周期，以促进频繁的集成，并避免长期存在的特性分支所带来的问题，如合并冲突和代码库分歧。'
- en: In TBD, the trunk is always in working and healthy condition, and it should
    always be in a deployable state. Developers take a small chunk of a feature or
    task and work on it, aiming to merge it back into the trunk as soon as possible.
    If a feature is not yet ready for production, **feature flags** can be used to
    hide these functionalities until they are complete, allowing the code to be merged
    without affecting the end users. Release practices such as feature flags are covered
    in [*Chapter 5*](B21203_05.xhtml#_idTextAnchor109).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在TBD中，主干始终保持工作状态并且健康，应该始终处于可部署状态。开发人员会选择一个小的功能或任务块进行开发，并尽快将其合并回主干。如果某个功能尚未准备好发布，可以使用**功能标志**来隐藏这些功能，直到它们完成为止，这样代码就可以合并而不影响最终用户。像功能标志这样的发布实践将在[*第5章*](B21203_05.xhtml#_idTextAnchor109)中讨论。
- en: As shown in the figure, in the TBD, many short-lived branches are created, and
    they are merged into the mainline.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，在TBD中，创建了许多短生命周期的分支，并将它们合并到主线中。
- en: '![Figure 3.2 – Trunk-based development](img/B21203_03_002.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 基于主干的开发](img/B21203_03_002.jpg)'
- en: Figure 3.2 – Trunk-based development
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 基于主干的开发
- en: Since integration happens frequently, it is crucial to have a robust suite of
    automated tests to run every time code is merged into the trunk. This ensures
    that the code base remains stable and deployable at all times. **Continuous Integration**
    (**CI**) tools are commonly used in conjunction with TBD to automate the testing
    and build processes, ensuring that the trunk is always in a good state.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集成发生得很频繁，因此必须拥有一个强大的自动化测试套件，在每次代码合并到主干时进行运行。这确保了代码库始终保持稳定和可部署。**持续集成**（**CI**）工具通常与TBD一起使用，以自动化测试和构建过程，确保主干始终保持良好状态。
- en: To accommodate hotfixes that provide urgent fixes, developers may create short-lived
    branches that are immediately merged back into the trunk upon completion. This
    ensures that critical issues can be addressed quickly without jeopardizing the
    stability of the mainline.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理提供紧急修复的 hotfix，开发者可能会创建短生命周期的分支，这些分支在完成后立即合并回主干。这确保了能够迅速解决关键问题，而不会危及主干的稳定性。
- en: One of the main advantages of TBD is its simplicity and focus on producing a
    clean, deployable code base. Encouraging frequent merges reduces the likelihood
    of merge conflicts and keeps all developers aligned with the latest version of
    the code. This is particularly beneficial in a DevOps culture that prioritizes
    quick iterations and rapid delivery.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: TBD 的主要优点之一是它的简单性和专注于生成清晰、可部署的代码库。鼓励频繁的合并减少了合并冲突的可能性，并使所有开发者保持与最新版本代码的一致性。这在优先考虑快速迭代和快速交付的
    DevOps 文化中尤为重要。
- en: Here are the pros and cons of trunk-based development.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于主干开发的优缺点。
- en: 'Pros:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Frequent integration**: Because code is merged frequently, merge conflicts
    are less likely and easier to resolve'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频繁集成**：由于代码频繁合并，合并冲突的可能性较小，且更容易解决'
- en: '**Fast feedback loop**: Integrating changes often helps in identifying issues
    earlier in the development process'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速反馈循环**：频繁集成变更有助于在开发过程中尽早发现问题'
- en: '**Simplified workflow**: Without a proliferation of long-lived feature branches,
    the development workflow is simplified, making it easier to manage'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化的工作流程**：没有大量长生命周期的功能分支，开发工作流程得以简化，管理起来更容易'
- en: 'Cons:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Risk of instability**: If not properly tested, frequent merges can lead to
    unstable code getting into the mainline'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不稳定的风险**：如果没有经过适当的测试，频繁的合并可能会导致不稳定的代码进入主干'
- en: '**Not ideal for large features**: For very large or disruptive changes, this
    approach can cause problems, as those changes might destabilize the mainline for
    an extended period'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适合大型功能**：对于非常大的或破坏性更强的变更，这种方法可能会导致问题，因为这些变更可能会使主干在较长时间内不稳定'
- en: In summary, TBD is all about rapid integrations, keeping the trunk always deployable,
    and employing automated testing to maintain code quality. It aligns well with
    Agile and DevOps methodologies, aiming to remove friction and improve developer
    experience by streamlining the development process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，TBD（基于主干开发）注重快速集成，始终保持主干可部署，并通过自动化测试保持代码质量。它与敏捷开发和 DevOps 方法论非常契合，旨在通过简化开发过程来消除摩擦并改善开发者体验。
- en: Git Flow
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git Flow
- en: Git Flow is a branching policy mainly aimed at robust project versioning and
    is particularly well-suited for projects that have a scheduled release cycle.
    It introduces a structured approach involving multiple types of branches, including
    `feature`, `release`, `develop`, and `hotfix`, alongside the `main` (or `master`)
    branch.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Git Flow 是一种主要针对健壮的项目版本控制的分支策略，特别适合有定期发布周期的项目。它引入了一种结构化的方法，涉及多种类型的分支，包括 `feature`、`release`、`develop`
    和 `hotfix`，以及 `main`（或 `master`）分支。
- en: '![Figure 3.3 – Git Flow](img/B21203_03_003.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – Git Flow](img/B21203_03_003.jpg)'
- en: Figure 3.3 – Git Flow
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Git Flow
- en: In Git Flow, development begins by branching off a `develop` branch from `main`.
    The `develop` branch serves as the integration branch for features and is where
    all developers’ branches get merged. When you are set to work on a new feature
    or a bug, you branch off a `feature` branch from `develop`. This isolated environment
    allows you to work without affecting the broader code base.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git Flow 中，开发工作从 `main` 分支创建一个 `develop` 分支开始。`develop` 分支作为功能集成的分支，是所有开发者的分支合并的地方。当你准备开发一个新功能或修复一个
    bug 时，你会从 `develop` 分支创建一个 `feature` 分支。这个隔离的环境使你能够在不影响整个代码库的情况下进行工作。
- en: As the feature progresses, incremental changes are committed to this `feature`
    branch. Once the feature is complete and tested, it gets merged back into the
    `develop` branch. For release preparation, a `release` branch is created from
    the `develop` branch. This branch is where any final minor bug fixes or documentation
    updates occur. Once everything is ready, the `release` branch is merged into `main`
    and tagged with a version number. Simultaneously, it should also be merged back
    into `develop` to ensure that future releases also have these changes. For immediate,
    critical fixes, a `hotfix` branch may be created directly off the main branch.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随着功能的进展，增量更改会提交到这个 `feature` 分支。一旦功能完成并经过测试，它会被合并回 `develop` 分支。为了准备发布，会从 `develop`
    分支创建一个 `release` 分支。这个分支用于进行最后的小错误修复或文档更新。一切准备就绪后，`release` 分支将合并到 `main` 并标记版本号。同时，它也应该被合并回
    `develop`，以确保未来的发布也包含这些更改。对于紧急的修复，可以直接从主分支创建一个 `hotfix` 分支。
- en: Git Flow provides a rigid structure that can be beneficial for large projects
    with multiple developers, requiring a balance of stability and new features. It
    ensures that development processes are separate but parallel, allowing for project
    history to be more legible and revertible.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Git Flow 提供了一个严格的结构，对于需要平衡稳定性和新特性的多个开发者的大型项目非常有益。它确保了开发过程是分开的但平行进行，使项目历史更易于理解和回退。
- en: Here are the pros and cons of the Git Flow.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Git Flow 的优缺点。
- en: 'Pros:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Structured workflow**: It’s suitable for projects that have scheduled release
    cycles'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化工作流程**：适用于有计划发布周期的项目'
- en: '**Isolation**: Feature branches allow developers to work in isolation, making
    it easier to manage complex features'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：功能分支允许开发者在隔离的环境中工作，使得管理复杂功能变得更加容易'
- en: '**Hotfix support**: The dedicated hotfix branches make it easy to quickly patch
    production releases'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热修复支持**：专用的热修复分支使得快速修复生产版本变得更加容易'
- en: 'Cons:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Complexity**: For smaller teams or projects, Git Flow may introduce unnecessary
    complexity'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：对于较小的团队或项目，Git Flow 可能引入不必要的复杂性'
- en: '**Delayed Integration**: As feature branches are long-lived, this could lead
    to merge conflicts or bugs that are discovered late in the development process'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟集成**：由于功能分支生命周期较长，这可能导致合并冲突或在开发过程中发现的错误'
- en: In summary, Git Flow provides a model for more complex projects, ensuring that
    the code base remains organized and that releases are well managed. It is especially
    useful for larger teams where coordination and release planning are critical.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Git Flow 为更复杂的项目提供了一种模型，确保代码库保持有序，并且发布管理得当。它特别适用于大型团队，其中协调和发布规划至关重要。
- en: GitHub Flow
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitHub Flow
- en: GitHub Flow is a simplified workflow that encourages continuous delivery practices.
    It consists of just the mainline and short-lived feature branches. The main principle
    is to branch off, develop a new feature, submit a pull request, and review the
    code before deploying. Pull request is an invention by GitHub and is a method
    for developers to notify team members that they have completed a feature or fix,
    which is then reviewed and discussed before being merged into the main branch
    of a code base. It will be covered in [*Chapter 4*](B21203_04.xhtml#_idTextAnchor077).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Flow 是一种简化的工作流程，鼓励持续交付实践。它只包括主线和短期存在的功能分支。其主要原则是分支、开发新功能、提交拉取请求、审核代码后再进行部署。拉取请求是
    GitHub 的发明，是开发者通知团队成员他们已完成一个功能或修复的方式，随后该功能或修复会被审核和讨论，合并到代码库的主分支中。详细内容请参考 [*第 4
    章*](B21203_04.xhtml#_idTextAnchor077)。
- en: 'The GitHub Flow is simple, but the context is not confined to Git alone. Note
    the inclusion of GitHub processes such as pull requests and approvals, as shown
    in the figure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Flow 很简单，但其背景不仅仅限于 Git。注意，图中包含了 GitHub 流程，如拉取请求和批准：
- en: '![Figure 3.4 – GitHub Flow](img/B21203_03_004.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – GitHub Flow](img/B21203_03_004.jpg)'
- en: Figure 3.4 – GitHub Flow
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – GitHub Flow
- en: It begins with creating a new, descriptive branch off the default repository
    branch, serving as a safe environment for making changes without affecting the
    main code base. Changes are committed and pushed to this remote branch. When ready,
    a detailed pull request is created for team reviews, often linked to related issues
    for context. Reviews might include questions, suggestions, or line-specific comments.
    Subsequent commits addressing feedback are automatically added to the pull request.
    After approval, the pull request is merged into the default branch, making your
    contributions part of the main code base. Depending on settings, resolving merge
    conflicts or meeting approval criteria may be required. Post-merge, the working
    branch is deleted but the commit history and discussions remain accessible for
    future reference.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它从创建一个新的描述性分支开始，该分支从默认的代码库分支派生，为修改提供一个安全的环境，不会影响主代码库。所有修改都提交并推送到这个远程分支。当准备好时，创建一个详细的拉取请求供团队审查，通常会与相关问题链接，以提供上下文。审查可能包括问题、建议或特定行的评论。针对反馈的后续提交会自动添加到拉取请求中。批准后，拉取请求会被合并到默认分支，将你的贡献并入主代码库。根据设置，可能需要解决合并冲突或满足批准标准。合并后，工作分支会被删除，但提交历史和讨论仍然可以访问，供日后参考。
- en: In essence, GitHub Flow fosters collaboration, transparency, and incremental
    development, offering a flexible yet structured approach for team projects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，GitHub Flow 促进了协作、透明性和增量开发，为团队项目提供了一种灵活而结构化的方式。
- en: Here are the pros and cons of the GitHub Flow.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 GitHub Flow 的优缺点。
- en: 'Pros:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Simplicity**: GitHub Flow offers a straightforward approach with a single
    mainline and short-lived feature branches, making it accessible and easy to manage,
    even for newcomers. This simplicity streamlines development, allowing for a focus
    on productivity rather than complex branching strategies.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**：GitHub Flow 提供了一种简单的方式，只有一个主分支和短生命周期的特性分支，即使是新手也容易上手和管理。这种简洁性简化了开发过程，让开发者可以专注于提高生产力，而不是复杂的分支策略。'
- en: '**Faster deployment**: By encouraging continuous integration and delivery,
    GitHub Flow enables teams to release updates more frequently. This rapid deployment
    cycle allows for immediate feedback and quicker iteration, reducing the time from
    development to market.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的部署**：通过鼓励持续集成和交付，GitHub Flow 使团队能够更频繁地发布更新。这种快速的部署周期能让团队及时获得反馈并进行更快的迭代，减少从开发到市场的时间。'
- en: '**Enhanced collaboration**: The pull request mechanism central to GitHub Flow
    fosters transparent code reviews and collaboration. It allows every team member
    to contribute to discussions, ensuring code quality and collective ownership of
    the project.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的协作性**：GitHub Flow 中心的拉取请求机制促进了透明的代码审查和协作。它允许每个团队成员参与讨论，确保代码质量并共同拥有项目。'
- en: 'Cons:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Platform compatibility considerations**: Adopting GitHub Flow enhances collaboration
    and efficiency, particularly on GitHub where it is fully supported. However, when
    integrating with different platforms, it might necessitate supplementary tools
    or adjustments to harness its full potential, ensuring seamless project management
    across diverse environments.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台兼容性考虑**：采用 GitHub Flow 可增强协作与效率，特别是在 GitHub 上完全支持的情况下。然而，在与不同平台集成时，可能需要额外的工具或调整，以充分利用其潜力，确保在多种环境下无缝的项目管理。'
- en: '**Adaptability for complex projects:** While GitHub Flow offers a streamlined,
    straightforward approach conducive to rapid deployment and continuous delivery,
    larger teams working on multifaceted projects may encounter challenges. This workflow’s
    emphasis on simplicity and single mainline development can sometimes limit the
    granularity of control over multiple simultaneous developments or the nuanced
    handling of various project timelines. For instance, in projects requiring extensive
    integration testing or coordination across multiple sub-teams, the need for additional
    branch management strategies or more robust release planning mechanisms becomes
    apparent.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应复杂项目的能力**：尽管 GitHub Flow 提供了一种简化、直接的方式，适合快速部署和持续交付，但在多团队协作、处理复杂项目时可能会遇到挑战。这种工作流注重简洁性和单一主分支开发，有时会限制对多个同时进行的开发任务或不同项目时间表的精细控制。例如，对于需要广泛集成测试或多个子团队之间协调的项目，可能需要额外的分支管理策略或更强大的发布规划机制。'
- en: Branch naming conventions – Discover the best practices for naming branches
    in Git
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支命名规范 – 了解 Git 中命名分支的最佳实践
- en: In the realm of Git and DevOps, naming is a crucial aspect of effective team
    collaboration and code management. A clear, descriptive name can make a world
    of difference when you are navigating through a sea of branches, trying to understand
    their specific functions, ownership, and lifecycle status. Establishing a coherent
    branching naming convention is an integral part of an effective branching strategy.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 和 DevOps 的领域中，命名是有效团队协作和代码管理的关键因素。当你在一堆分支中浏览时，一个清晰且具有描述性的名称能带来天壤之别，帮助你理解它们的具体功能、归属以及生命周期状态。建立一致的分支命名规范是有效分支策略的一个重要组成部分。
- en: Let’s delve into the best practices for naming branches in Git, aiming to remove
    organizational friction and accelerate releases. A well-defined naming convention
    allows engineers to instantly understand the purpose of a branch, whether it is
    for a feature, a bug fix, a hotfix, or an experimental endeavor. This clarity
    is vital when a team is sifting through dozens, or even hundreds, of branches.
    Naming conventions set the stage for a more transparent, efficient, and streamlined
    workflow, making it easier for everyone on the DevOps team to collaborate.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨在 Git 中命名分支的最佳实践，旨在减少组织内的摩擦并加速发布。一个明确定义的命名规范使得工程师可以立刻理解一个分支的目的，无论它是为了某个功能、修复漏洞、热修复，还是一个实验性的尝试。在团队需要筛选数十个甚至数百个分支时，这种清晰度至关重要。命名规范为更透明、高效和精简的工作流程奠定了基础，使
    DevOps 团队的每个人都能更轻松地进行协作。
- en: Branch naming guidelines and examples
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支命名规范和示例
- en: The following are the main guidelines and examples for naming each topic. Please
    note that these are only examples, and each team can have very different naming
    conventions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为每个主题命名的主要规范和示例。请注意，这些只是示例，每个团队的命名规范可能会有所不同。
- en: 'Here’s some general guidance:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些通用的指导原则：
- en: '`-`), underscores (`_`), or slashes (`/`) to separate words. Slashes are especially
    used as a separator when dealing with topics such as hotfixes and features.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用破折号 (`-`)、下划线 (`_`) 或斜杠 (`/`) 来分隔单词。斜杠尤其常用于分隔热修复和功能等主题。
- en: '**Lowercase names**: While Git is case-sensitive, sticking to lowercase letters
    helps maintain consistency and avoids confusion.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小写名称**：虽然 Git 区分大小写，但坚持使用小写字母有助于保持一致性并避免混淆。'
- en: '**Make it descriptive but short**: The name should give an instant idea of
    what the branch is about while remaining as succinct as possible.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁但富有描述性**：分支名称应该能够立刻让人理解该分支的内容，同时尽可能简洁。'
- en: 'Here are examples of names for each branch:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个分支名称的示例：
- en: '`feature/`, followed by a brief description. An example would be `feature/user
    authentication`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feature/`，后跟简短描述。一个例子是 `feature/user authentication`。'
- en: '`bugfix/`, followed by a short descriptor. For example, `bugfix/login-error`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bugfix/`，后跟简短描述。例如，`bugfix/login-error`。'
- en: '`hotfix/`. For example, `hotfix/xyz-security-vulnerability`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hotfix/`。例如，`hotfix/xyz-security-vulnerability`。'
- en: '`release/` as a prefix. An example would be `release/v1.2`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release/` 作为前缀。一个例子是 `release/v1.2`。'
- en: Contextual naming
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文命名
- en: While these categories offer a good starting point, you may also consider adding
    more contextual information to the branch name. For example, you could append
    the issue number at the end (`feature/123-user-authentication`) or include the
    name of the person responsible for the branch (`feature/teamxyz-authentication`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些分类提供了一个很好的起点，你也可以考虑在分支名称中加入更多的上下文信息。例如，你可以在末尾附加问题编号（如`feature/123-user-authentication`），或者包括负责该分支的人员姓名（如`feature/teamxyz-authentication`）。
- en: In this section, we recognized that a solid branching strategy stands as the
    backbone of any collaborative development project. We have explored the significance
    of branch strategies in maintaining a stable code base while facilitating continuous
    integration and delivery. Whether it is adopting the small and frequent commits
    of TBD, the structured roles of Git Flow, or the simplicity of GitHub Flow, the
    right strategy is paramount to a team’s success.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们认识到，一个稳固的分支策略是任何协作开发项目的支柱。我们已经探讨了分支策略在维持稳定的代码库同时促进持续集成和交付方面的重要性。无论是采纳
    TBD 的小而频繁提交、Git Flow 的结构化角色，还是 GitHub Flow 的简易性，正确的策略对于团队的成功至关重要。
- en: Remember, these conventions should align with your broader branching strategy
    and policy and be adapted to the size of your team and the project and your organization’s
    unique constraints and goals. A well-chosen naming convention will reinforce the
    effectiveness of your branching policy, aiding in the quest to mitigate friction
    and accelerate releases. By adhering to a well-defined naming convention, you
    empower your team to work more efficiently and foster a culture of clarity and
    accountability.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些约定应该与您更广泛的分支策略和政策保持一致，并根据您的团队规模、项目以及组织的独特约束和目标进行调整。一个精心选择的命名约定将有助于强化分支政策的有效性，帮助减少摩擦并加速发布。通过遵循明确的命名约定，您能够让团队更加高效地工作，并促进清晰和责任感的文化。
- en: In the upcoming section, you will learn how to bring together disparate lines
    of development while maintaining the integrity and history of your code. Let’s
    move forward with confidence, ready to merge our knowledge of branching into the
    practical skills of Git merging.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将学习如何将不同的开发线合并在一起，同时保持代码的完整性和历史记录。让我们带着信心继续前进，将分支的知识与 Git 合并的实际技能相结合。
- en: Ways to apply your changes on a branch
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在分支上应用更改
- en: Now that you have delved into the intricacies of branch management and workflows
    in DevOps, you are likely starting to see the big picture. You have come to understand
    how your individual commits contribute to the overall development stream. The
    next step in this journey is *to connect the dots*—more specifically, consider
    how the code you have written gets merged into the mainline.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经深入了解了 DevOps 中分支管理和工作流的复杂性，可能已经开始看到全局。您已理解您的个人提交如何为整体开发流做出贡献。接下来的步骤是*连接各个点*——更具体地说，考虑您编写的代码如何被合并到主干中。
- en: The code base is a living, collaborative environment; it holds a history of
    contributions from various team members. In a fast-paced environment, it may be
    tempting to rush through commits or push large chunks of changes all at once to
    meet deadlines. However, when merging, it is crucial to consider how your changes
    contribute to a consistent, understandable, and stable shared environment. This
    consideration becomes particularly vital in a DevOps culture, where the objective
    is not just rapid deployment but also frictionless collaboration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库是一个充满活力的协作环境，记录了各种团队成员的贡献历史。在快速发展的环境中，我们可能会因为赶进度而急于提交或一次性推送大量的更改。然而，在合并时，必须考虑到这些更改如何有助于维持一致、可理解且稳定的共享环境。特别是在
    DevOps 文化中，这一点尤为重要，因为目标不仅仅是快速部署，还包括无摩擦的协作。
- en: In the upcoming sections, we will explore various tactics and best practices
    for executing successful merges in Git, particularly tailored to the needs and
    challenges that arise in a DevOps setting.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨在 Git 中执行成功合并的各种策略和最佳实践，特别是针对 DevOps 环境中出现的需求和挑战。
- en: Merging vs rebasing
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并与重基（Merging vs rebasing）
- en: 'Git offers two main techniques for integrating these changes: merging and rebasing.
    While they serve the same ultimate purpose—bringing different strands of code
    together—they have distinct operational nuances. Before diving into various actual
    commands, let’s distinguish between merging and rebasing.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Git 提供了两种主要的技术来集成这些变化：合并（merging）和重基（rebasing）。虽然它们的最终目的是相同的——将不同的代码分支合并在一起——但它们在操作上有明显的差异。在深入了解实际命令之前，让我们先区分合并和重基。
- en: Merging
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并（Merging）
- en: 'Merging takes the content of a source branch and integrates it with a target
    branch. This new commit will have two parent commits, preserving the independent
    histories of the branches being merged. Merging can be cumbersome because it keeps
    the history from the various branches as it is, but it is also good in terms of
    flexibility during integration when various people are working on a project at
    the same time. Mainly, there are two types of merge options: **non-fast-forward
    merge**, which creates a new merge commit to log the merge, and **fast-forward
    merge**, which does not create a merge commit. There is also the squash function—an
    option that compresses multiple commits into a single commit for merging.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 合并会将源分支的内容与目标分支集成在一起。这个新提交将拥有两个父提交，保留被合并分支的独立历史。合并可能会显得繁琐，因为它保留了各个分支的历史，但在多人同时参与项目时，它在集成过程中提供了灵活性。主要有两种合并方式：**非快进合并**（non-fast-forward
    merge），这种方式会创建一个新的合并提交来记录合并过程；以及**快进合并**（fast-forward merge），这种方式则不创建合并提交。还有一个叫做
    squash 的功能——它可以将多个提交压缩成一个提交进行合并。
- en: 'On platforms such as GitHub, the default setting is for merge commits to be
    made like in the following figure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Merging example (non-fast-forward)](img/B21203_03_005.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Merging example (non-fast-forward)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Here are the pros and cons of merging.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**History preservation**: Merging keeps the history of both branches, offering
    a detailed log'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplicity**: It is usually easier for beginners to understand'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branch isolation**: Individual branches can continue to make separate changes
    without affecting the merge'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex log**: While preserving history, merges can lead to a complicated
    and cluttered log history'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of linearity**: The project history becomes non-linear, making it challenging
    to navigate the commit history'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rebasing
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rebasing is the process of moving or combining a sequence of commits to a new
    base commit. It essentially takes the changes made in a feature branch and replays
    them on top of another branch. Instead of creating a new commit, as is the case
    with merging, rebasing rewrites the commit history to produce a linear succession
    of commits. The great thing about rebasing is the linearity of its history. When
    looking back in time, it is easy to follow the flow of what happened in the mainline
    branch, which is very good in terms of bug fixes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you master rebasing, you can contribute to a noise-free history:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Rebasing](img/B21203_03_006.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Rebasing
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Here are the pros and cons of rebasing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**Cleaner history**: Rebasing results in a much cleaner, linear project history'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eliminates Noise**: It removes unnecessary merge commits that appear when
    performing the git merge'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simpler Debugging**: With a cleaner history, debugging becomes easier'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cons:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '**Shared Branch Risk**: Rebasing can be destructive; it can be risky on shared
    branches because it rewrites commit history'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complexity**: Rebasing can be more complicated to understand and execute
    correctly'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both techniques have their pros and cons. Merging preserves the original branch
    history but can lead to a complicated log. Rebasing offers a cleaner, more linear
    project history but carries risks, especially when working on a shared branch.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Exploring different ways to merge in Git
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s dive into the practical steps. We will explore the process of merging
    two branches, offering hands-on experience to help you better understand each
    method. In this section, we will cover some of the most commonly used methods
    to merge branches, enabling you to make informed decisions based on your project
    needs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: git merge --ff – Keeping it straight
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s dig into the practical aspects now. This section focuses on a common default
    behavior in Git merging called `--ff` as a command option. We will go through
    the process, ensuring you understand how it works and when to use it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Fast-forward merging is one of the simplest ways to integrate branches in Git.
    In essence, a fast-forward merge moves the tip of the targeted branch to the latest
    commit on the source branch.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'With fast-forward merges, when looking at the history, nothing actually appears
    to have changed, as shown in the following figure. That is the benefit of fast-forward
    merging. HEAD is moving without fail and merging can be done smoothly:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Fast-forward merging](img/B21203_03_007.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Fast-forward merging
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: In Git, a fast-forward merge is possible when there are no new commits on the
    base (or target) branch that occurred after the feature branch was created. Essentially,
    it eliminates the need for a new commit to join the branches, keeping your project
    history linear.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for fast-forward merging
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For the context of this guide, assume you have a `main` branch and an `add-description`
    branch. The `add-description` branch has derived from the `main` and you are planning
    to merge the feature back into `master`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At this point, your repository structure would resemble the following diagram:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – git merge –ff (1)](img/B21203_03_008.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – git merge –ff (1)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s proceed to merge these branches by switching back to the `main`
    branch:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, your repository history would look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – git merge –ff (2)](img/B21203_03_009.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – git merge –ff (2)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Why fast-forward merges are preferred in DevOps and team collaboration
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Behind the scenes, a fast-forward merge merely moves HEAD, the pointer, to the
    latest commit. Moreover, fast-forward merges do not create a new merge commit,
    keeping the Git history clean and linear. This makes it a simple and efficient
    operation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Fast-forward merges are often preferred in team collaboration for a few reasons:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**: They keep the git history linear, which makes it easier to
    follow'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transparency**: With a straightforward history, it is easier to track changes,
    debug issues, and understand the sequence of feature integrations'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficiency**: Fast-forward merges eliminate the need for an extra merge commit,
    simplifying code reviews'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, keep in mind that fast-forward merges are not always possible. You
    can use this way when you are developing with just yourself or when doing simple
    development, but in most development, there are many things going on in parallel.
    When simultaneous changes occur in the master and feature branches, a non-fast-forward
    merge, which is sometimes called a three-way merge, may be necessary.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: git merge --no-ff – Preserving branch history
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Non-fast-forward merges, commonly invoked with the `--no-ff` flag, offer an
    alternative merging strategy that differs from the fast-forward merges we discussed
    earlier. Unlike fast-forward merges, which move the tip of the targeted branch
    to the latest commit of the source branch, non-fast-forward merges generate a
    new merge commit. This new commit has two parent commits: one from the source
    branch and one from the target branch.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Non-fast-forward merges can embed context into the merge commit so that it is
    possible to look back later to see why this merge was performed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Non-fast-forward merging](img/B21203_03_010.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Non-fast-forward merging
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: This approach keeps track of the fact that a feature branch was merged into
    the main branch, preserving the context in which past commits were made.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for non-fast-forward merging
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s assume you are working with a `main` branch and `add-feature` branch.
    The following are the steps to perform a non-fast-forward merge:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now the `commit` log is as shown in *Figure 3**.11*. What you did so far is
    the same as what you did in the `git merge --``ff` section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – git merge --no-ff (1)](img/B21203_03_011.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – git merge --no-ff (1)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s switch back to `main` and perform a **non-fast-forward** merge:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following edit message will appear in the terminal. Edit the commit message
    and save it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the edit, let’s see the log now:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your repository history will show a new merge commit indicating where the `add-feature`
    branch was integrated into the `main` branch.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – git merge --no-ff (2)](img/B21203_03_012.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – git merge --no-ff (2)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Why use non-fast-forward merges in DevOps and team collaboration?
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Non-fast-forward merges offer benefits that can be valuable in various DevOps
    and team collaboration scenarios:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '**Context preservation**: Generating a new commit during the merging process
    preserves not just the code but the history and context as well. This clear record
    of integration makes it much easier to understand when and how changes from different
    branches were combined.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-ff` offers invaluable transparency, providing a clear record of who made
    what changes, when they made them, and why. This is particularly beneficial in
    larger teams and complex projects where it is crucial to understand the flow of
    contributions.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While merge commits can provide rich context and history, they can also clutter
    the Git history if overused or poorly documented. It is important for teams to
    consider their merging strategy carefully and make concerted efforts to maintain
    a clean shared repository.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: git merge --squash – Squashing complexity
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `git merge --squash` option provides a different merging technique that
    offers both clarity and tidiness. While fast-forward and non-fast-forward merges
    are excellent for tracking branch histories, there might be cases where you want
    to condense your `feature` branch changes into a single commit before merging.
    That’s where `git merge --``squash` shines.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In a squashed merge, all changes from the source (or feature) branch are combined
    into a single commit on the target (or main) branch. This action effectively condenses
    the feature branch history into one commit while merging, offering a clean, easy-to-follow
    Git history. This leaves the changes in an uncommitted state, allowing you to
    modify the differences before finalizing the commit.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: While teams are committed to maintaining a clean shared repository, individual
    development branches often become cluttered with various trial-and-error attempts.
    Squash merges contribute to preserving the cleanliness of the main code base by
    preventing these messy, experimental logs from infiltrating the production history.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The squash merge, as shown in the following figure, is in some ways the cleanest
    merge, and it has a lot of benefits. However, keep in mind that it is a way of
    incorporating changes that lose the previous change history and the commit history
    of other companies. This will be mentioned later in this section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Squash merging](img/B21203_03_013.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Squash merging
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for squash merging
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s say you have a `main` branch and an `add-multiple-features` branch. To
    perform a squash merge, do the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now the branches should look like those in the following figure:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – git merge --squash (1)](img/B21203_03_014.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – git merge --squash (1)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s switch back to the mainline and perform a `squash` merge:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The commits are then squashed and become a single commit:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – git merge --squash (2)](img/B21203_03_015.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – git merge --squash (2)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, Git will add uncommitted changes to the `main` branch. It is time to
    complete the merge process. To complete the merge, you need to commit those uncommitted
    changes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will combine all the changes from the `add-multiple-features` branch into
    a single new commit on the `main` branch:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – git merge --squash (3)](img/B21203_03_016.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – git merge --squash (3)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Why use squash merges in DevOps and team collaboration?
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Squash merges offer a unique set of benefits for DevOps and collaborative development:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomic changes**: A squashed merge creates a single commit that contains
    all the feature changes, making it easier to roll back if needed.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced noise**: Squash merges eliminate the clutter of many small, perhaps
    experimental, commits from the main branch. This makes for a cleaner log history
    that’s easier to read and understand.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategic commit messages**: Squashing allows you to create a comprehensive
    commit message that can encapsulate the purpose and impact of a feature more effectively
    than a series of smaller commits.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, it is worth noting that while squash merges can simplify history, they
    can also obfuscate it. Individual commits from the feature branch are lost in
    the main branch, making it hard to understand the development context of each
    separate change. Use this merge strategy judiciously and understand its impact
    on your development history.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: The ethics and pitfalls of squash merging
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Squashing someone else’s commits can sometimes be problematic.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: The `git merge --squash` command is a powerful tool for consolidating multiple
    commits into a single one. While this function keeps your commit history clean
    and manageable, it raises ethical and practical issues when used on commits made
    by others.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to be aware of the following concerns in team collaboration:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**Authorship misattribution**: By default, the person who performs the squash
    becomes the author of the consolidated commit, effectively erasing the original
    contributors’ history. This could demotivate team members by not recognizing their
    contributions.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**History alteration**: The command alters the commit history, which could
    be considered disrespectful to the original author’s work.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If maintaining the integrity of individual commits is important, consider using
    a standard merge. This may result in a messier history, but it preserves the work
    and recognition of all contributors.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `git rebase` command offers more control over the commit history,
    which is useful for cleaning up or rearranging your own work without affecting
    others.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore this command next.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: git rebase – Rewriting for clarity
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rebasing is another powerful technique in Git that differs significantly from
    merging. The primary difference between merging and rebasing is how they integrate
    changes. While `git merge` integrates changes from one branch into another, `git
    rebase` moves or combines a sequence of commits to a new base commit.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In the team collaboration context, rebasing is used to maintain a linear project
    history, which simplifies debugging and makes code reviews easier. However, rebase
    comes with its share of complexities and pitfalls and is generally best used in
    specific circumstances.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into the hands-on tutorial, let’s understand how `git rebase`
    works at a high level. The primary utility of rebasing is to place the changes
    from the `feature` branch on top of another branch.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following branches:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Rebasing (1)](img/B21203_03_017.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Rebasing (1)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'After rebasing `feature` onto `main`, your branch might look like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Rebasing (2)](img/B21203_03_018.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Rebasing (2)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can merge back to main, at which point a fast-forward merge can
    be performed:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.19 – Rebasing (3)](img/B21203_03_019.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: Figure 3.19 – Rebasing (3)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for git rebase
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s take a practical example with a `main` branch and a `new-feature` branch.
    Here’s how to perform rebase:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, your branch history may look something like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.20 – git rebase (1)](img/B21203_03_020.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
- en: Figure 3.20 – git rebase (1)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s say new commits have been added to `main` while you were working
    on `new-feature`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Your commit graph now diverges:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.21 – git rebase (2)](img/B21203_03_021.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: Figure 3.21 – git rebase (2)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, rebase `new-feature` onto `main`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s check what it looks like now:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this, your branches will look as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.22 – git rebase (3)](img/B21203_03_022.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: Figure 3.22 – git rebase (3)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to merge and complete the `git` `rebase` process:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When a fast-forward merge is performed, the HEADs of the `main` and `new-feature`
    branches will be the corresponding commits, as shown:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.23 – git rebase (4)](img/B21203_03_023.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: Figure 3.23 – git rebase (4)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Why rebasing is powerful in DevOps and team collaboration
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The primary advantage of rebasing in a DevOps culture is that it results in
    a much cleaner project history than merging. Cleaner histories are easier to debug
    and simpler to understand, and they make more logical sense to developers who
    join the project at a later time.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear history**: It is easier to understand than the non-linear history
    created by git merge'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified debugging**: With a cleaner history, tracking down when a particular
    bug was introduced becomes easier'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code hygiene**: Rebasing encourages you to squash fixup commits or split
    larger commits, making your changes more understandable compared to the other
    developers’'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cautions and pitfalls of git rebase
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are golden rules to follow: *do not rebase public (team) branches*. One
    such cardinal rule is to avoid rebasing public branches. Rebasing can be a great
    tool for cleaning up a feature branch, but when done on branches that are publicly
    available, it can become a disaster.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the things to consider when you use `git rebase`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '**Conflicts for collaborators**: Imagine that you have rebased a public branch
    and pushed the changes. Other developers who have already pulled the old version
    of the branch now have a divergent history. When they try to push their changes,
    Git will reject the push, forcing them to reconcile the histories. This creates
    extra work and increases the chance of merge conflicts.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex merges**: After a public branch has been rebased and the history
    altered, merging it with other branches can become a real challenge. Because Git
    uses the commit history to determine how to integrate changes, modifying that
    history can make merging far more complicated than it needs to be.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loss of context**: Rebasing can squash commits together or change their order,
    which may result in a loss of context for those changes. This makes debugging
    more difficult and can complicate the task of understanding the development process
    that led to the current code base.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rebasing can be complex and risky, especially for inexperienced developers.
    In worst-case scenarios, you may have to resolve many conflicts, leading to errors
    and bugs if not done carefully.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: By understanding and using `git merge` and `git rebase`, you can handle pretty
    much any situation that requires combining different lines of development. Each
    has its place in a Git command, and understanding when to use each one is the
    key to maintaining a clean and understandable code base—something that is highly
    valuable in the world of DevOps.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: git cherry-pick – Picking specific commits
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most flexible tools in the Git commands is the `git cherry-pick`
    command. While the previous merge methods were mainly used for integrating entire
    branches, `git cherry-pick` allows you to select specific commits from one branch
    and apply them to another branch. This method can be incredibly useful when you
    need to apply just a few specific changes without taking all the modifications
    from a different branch.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have two branches, `main` and `feature`. You realize that one or
    two commits from the `feature` branch should be moved to `main`, but you are not
    ready to merge the entire branch. The `git cherry-pick` command allows you to
    do just that:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.24 – Cherry-picking (1)](img/B21203_03_024.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
- en: Figure 3.24 – Cherry-picking (1)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'You can cherry-pick the changes from a specific commit in the `feature` branch
    and apply them to `main`. This action will create a new commit on the `main` branch:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.25 – Cherry-picking (2)](img/B21203_03_025.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: Figure 3.25 – Cherry-picking (2)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Practical steps for cherry-picking
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s go over the practical steps for cherry-picking changes and merging
    them into a branch. Each commit adds a file to each of them. Let’s take some of
    those commits and merge them into `main`. First, we add the files:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now the branches look like those in the following diagram:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.26 – git cherry-pick (1)](img/B21203_03_026.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
- en: Figure 3.26 – git cherry-pick (1)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s only pick the `a80e8ad` commit and put it on the `main` branch.
    Please replace the hash value in your environment:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After you have successfully cherry-picked the commit, a new commit will be
    added to your current branch (`main` in this example) and it will include the
    changes from the cherry-picked commit. Note that the new commit has the same changes
    but a different commit hash value:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.27 – git cherry-pick (2)](img/B21203_03_027.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: Figure 3.27 – git cherry-pick (2)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Why cherry-pick is useful in DevOps and team collaboration
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Team development requires flexible development. `git cherry-pick` is a useful
    command in collaborative coding environments, allowing teams to selectively integrate
    changes and maintain code integrity.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what value `cherry-pick` can offer:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**Selective integration**: It allows specific bug fixes or features to be moved
    into production without having to move all changes from a development branch'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy reversion**: If something goes wrong, you only need to revert a small
    change rather than an entire branch merge'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clean history**: Keeps your Git history tidy by only including relevant commits,
    making it easier to read and understand'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git cherry-pick` offers a high level of precision for integrating changes
    between branches. It allows you to select exactly which commits to include, providing
    granular control over your project history. This makes it an invaluable tool for
    any DevOps engineer aiming for a flexible and efficient version control workflow.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: After exploring the various merging strategies in Git, you might be asking yourself,
    “*Which method should I use?*” The answer, as with most things in engineering,
    is, “*It depends.*” Several factors come into play when determining which Git
    merge strategy best suits your needs. Additionally, it is worth noting that you
    do not have to stick to a single method; you can vary your approach depending
    on the situation. Understanding these factors can help you make an informed decision.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s check the following factors to see how you should choose:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '**Project complexity**: Complex projects with multiple contributors and parallel
    development lines may require a more consistent merging approach to minimize conflicts.
    Platforms such as GitHub allow you to set merge strategies for your projects.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git merge` can reduce the chances of mistakes. However, if the majority of
    the team is experienced, you may want to leverage the benefits of `rebase` to
    maintain a cleaner Git history while also facilitating smoother communication.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Desired cleanliness of Git history**: If a clean, linear Git history is of
    utmost importance to you, then opting for fast-forward merges or rebasing might
    be the best route. On the other hand, if you value detailed documentation of your
    project’s development process, a non-fast-forward merge would be a better choice
    for maintaining a comprehensive record of changes.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you move forward, let the knowledge from this section guide you in choosing
    the appropriate merge approach for your projects. Practice with real-world scenarios
    to gain confidence. Remember, there is no one-size-fits-all answer in Git—flexibility
    and adaptability are your allies
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Navigating conflicts
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a collaborative development environment, conflicts are not just possible—they
    are inevitable. When multiple developers are working on the same code base, or
    even the same files, there is a good chance that changes will overlap, leading
    to conflicts. Navigating and resolving these conflicts is crucial for maintaining
    a smooth and efficient DevOps workflow.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Why conflict happens
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conflicts generally occur when two branches have changes in the same line or
    section of a file and are then attempted to be merged. Git, as sophisticated as
    it is, can not decide which change to take precedence. The key to efficiently
    resolving these conflicts is understanding why they occur and being proactive
    in preventing them when possible.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: How to merge conflicts in Git
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with the basics. Conflict resolution in Git usually involves manual
    intervention. Here is how to go about it:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Identify conflicts. Use `git status` to see which files are conflicted.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Examine the conflicted files. Open them up and look for the conflict markers
    (`<<<<<<<`, `=======`, and `>>>>>>>`). These markers delineate the changes from
    the different branches:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Resolve the conflicts. Choose which changes to keep. You can keep the changes
    from one branch, mix both, or even add something entirely new.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the resolved files. After resolving, you need to add the files to the
    staging area and commit them.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to resolve merge conflicts
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Merge conflicts are inevitable in a collaborative development environment. The
    key is knowing how to resolve them efficiently. There are several patterns you
    can follow, depending on the nature of the conflict.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: When there is a definitive version to retain
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you have merged two branches and want to fully accept one version over the
    other, you can opt to use `git checkout --ours` or `git` `checkout --theirs`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '`checkout --ours`: Use this command to keep the files from your branch when
    a merge conflict arises:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: $ git checkout --theirs -- <file-path>
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After running one of these commands, you will need to add the updated files
    to the staging area and then commit them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: When you need to evaluate both versions
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In cases where it is not clear which version should take precedence, a more
    nuanced approach is required.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**Review the code**: Open the conflicting files in a text editor to manually
    inspect the clashing lines of code. Decide which parts to keep and edit the files
    accordingly.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication**: If necessary, consult with your teammates to decide which
    changes should be kept. This can be done through in-person discussions, virtual
    meetings, or code review tools.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run tests**: Once you have resolved the conflicts manually, it is crucial
    to run tests to ensure that the code base is still stable.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commit the changes**: After successful testing, stage the resolved files
    and commit them to your repository.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By carefully handling merge conflicts, you can help maintain a clean code base
    and foster better communication within your team.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Useful commands for supporting merge activities
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Merging is an activity that comes with its own set of challenges. Having the
    right set of tools and commands at your disposal can make the process smoother
    and less error-prone. In this section, there are some useful Git commands that
    can help you effectively manage your merges.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: git diff – Spot the difference
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `git diff` command is an essential tool for identifying the differences
    between two sets of code. It helps you see what exactly has changed between two
    branches or two commits, making it much easier to resolve conflicts when they
    arise.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compare the current branch to a target branch like so:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command displays a line-by-line comparison of the changes between `feature-branch`
    and `main`. You can also focus on specific files or even specific lines of code,
    which makes it a flexible tool for spotting differences at various granularities.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Git does not have a built-in dry-run option for `git merge`, you can
    simulate a merge to see what will happen:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This command sequence attempts to merge changes from develop into your current
    branch but stops just before committing them. You can then use `git diff --cached`
    to view the staged changes. If the merge is not what you expected, you can simply
    abort:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: git mergetool – A simplified guide tooling to visual conflict resolution
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you run into a merge conflict that’s challenging to resolve manually, or
    if you are more comfortable with a graphical interface, Git’s built-in `git mergetool`
    can come to your rescue.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'The following items can be set:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '`kdiff3`, `meld`, and `vimdiff`.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global configuration**: Set your chosen tool as the default for all your
    Git repositories with the following command:'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command opens your chosen graphical tool and displays the conflicting changes
    side by side. This interface simplifies the process of understanding conflicts
    and deciding which changes to keep. This setting allows you to specify not only
    command line tools but also modern tools such as Visual Studio Code to resolve
    merges graphically.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By following these straightforward steps, you can resolve complex merge conflicts
    in a more intuitive way, making the process accessible for team members of all
    skill levels.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, conflict resolution is an essential skill for any engineer. While
    conflicts can be complex and challenging, knowing how to navigate them efficiently
    can make your development workflow much smoother. It is not just about resolving
    the conflicts themselves but understanding the underlying issues that lead to
    them. This nuanced approach is crucial for fostering better communication and
    collaboration within your development team.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: As team development progresses, projects become more complex. Conflicts are
    inevitable. Conflict is a great opportunity to help your team to improve its collaboration
    skills. You should not be afraid of conflicts, and you should also learn how to
    communicate best for your team by solving them one by one.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Mastering better collaboration
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have discussed how to handle merges and resolve conflicts in
    Git. We have seen that you can clean up your local changes with `git merge --squash`
    or adjust commit history with `git rebase`. While it is great to keep your workspace
    neat, the ideal scenario is to maintain a clean code base, especially when you
    push to a shared environment. Next, let’s talk about the commands that enable
    you to be an excellent collaborator, whether you are an individual contributor
    or a team leader managing the main shared branch.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Rolling back time
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In any collaborative project, mistakes are inevitable. Even if it was not a
    mistake, there will be many times you will want to rewind and go back in time.
    Whether it is a bad commit that breaks the build or a feature that did not pan
    out as expected, the ability to roll back changes is crucial. Two commands that
    are indispensable for this are `git reset` and `git revert`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: git reset – Rolling back changes
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `git reset` command allows you to *rewind* your Git history, essentially
    moving HEAD and, optionally, the working directory to a specific commit. This
    is incredibly powerful but should be used cautiously. There are several different
    ways to use `git reset`. Know them so that you can organize your environment efficiently:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '**Soft reset**: This keeps your working directory and index intact but moves
    HEAD. This command is used when you want to leave the index working tree untouched
    and only undo the commit:'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Figure 3.28 – git reset --soft](img/B21203_03_028.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: Figure 3.28 – git reset --soft
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '`git add` and `git commit`. File changes will remain; this is the default when
    no options are specified with `git reset`:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Figure 3.29 – git reset --mixed](img/B21203_03_029.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
- en: Figure 3.29 – git reset --mixed
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**Hard reset**: This resets the index and working directory, permanently deleting
    uncommitted changes. It deletes all changes to commits, indexes, and files, so
    all the changes themselves do not remain with you. If you want to delete everything,
    this is the way to do it:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Figure 3.30 – git reset --hard](img/B21203_03_030.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: Figure 3.30 – git reset --hard
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: git revert – Undoing without rewriting history
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike `git reset`, which alters commit history, `git revert` creates a new
    commit that undoes the changes made by a previous commit. This is extremely useful
    in a shared environment where rewriting history is highly discouraged.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '`git revert` creates a reverse commit as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.31 – git-revert creates a commit to cancel the commit](img/B21203_03_031.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
- en: Figure 3.31 – git-revert creates a commit to cancel the commit
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'This command will undo the changes made by the commit with the specified hash
    and create a new commit to record this action:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following are cases when you can use `git revert`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '`git revert` does not rewrite history, it is safe to use on shared branches'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git revert` is a clean way to remove it'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git revert` operation as part of your rollback strategy'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s learn about some additional advanced `git` `revert` options:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '**Reverting multiple commits**: You can revert a range of commits by specifying
    a commit range:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: git revert -n <commit_hash>
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Note the caret (`^`) symbol. This means the oldest commit in the range of commits
    to revert is included.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Mastering `git revert` is crucial for any developer or DevOps professional.
    It provides a safe mechanism for undoing changes, enabling better collaboration
    and more reliable code.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: git checkout – More than just branch hopping
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous discussions, we have touched on the `git checkout` command mainly
    in the context of switching between branches. While this is certainly one of its
    primary functions, it is crucial to understand that `git checkout` is a multi-purpose
    tool that can operate at the granularity of individual files or directories as
    well. In this section, let’s expand our understanding of `git checkout` and see
    how it plays a vital role in efficient collaboration and error correction.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a refresher on the basic command for switching branches:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But what if you only need to restore a single file to a previous state? `git
    checkout` has got you covered. If you have made changes to a file but have not
    committed yet and you decide you want to undo those changes, you can do this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will discard changes in your working directory and revert the file back
    to the state of the last commit. Sometimes, you might want to partially apply
    changes from another branch to your current working branch. git checkout can also
    do this:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command will check out a specific file from another branch into your current
    working branch, allowing you to mix and match code as needed.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'It offers versatility in team collaboration:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick rollbacks**: If something goes wrong in the production, you can quickly
    check out the specific files from a stable branch.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selective feature testing**: Before merging a new feature, you can check
    out only the files relevant to that feature for testing.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy error correction**: Mistakes happen all the time. The ability to check
    out individual files makes it easier to correct them without affecting other parts
    of the code base.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Using `git checkout` on files will discard changes. Make sure this is what you
    intend to do. If you are experimenting, it is a good idea to commit your changes
    often. That way, you can easily revert back to a specific commit if needed.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the full range of `git checkout` capabilities can significantly
    enhance your workflow and collaboration efficiency. Whether you are working alone
    or as part of a team, the ability to manipulate not just branches but also individual
    files grants you a higher degree of control and adaptability in your team collaboration.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your working environment
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the realm of team development, your individual workspace is your personal
    lab—a space where you can innovate, debug, and test freely without affecting the
    broader project. Managing this space efficiently is crucial, and Git offers a
    set of powerful commands to help you do just that. In this section, we will explore
    three essential Git commands—`git clean`, `git stash`, and `.gitignore`—that can
    easily keep your workspace clean.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: git clean – A fresh start
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `git clean` command offers a quick way to clear your working directory
    of untracked files and directories, essentially providing a clean slate. This
    can be especially useful before or after executing a merge, or when you want to
    remove any clutter that does not need to be version-controlled:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: git stash – Pause and resume work effortlessly
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`git stash` is an invaluable tool for temporarily stashing away changes that
    you have made but are not yet ready to commit.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, multitasking is often the name of the game. Whether you are
    interrupted by an urgent bug fix or need to switch context temporarily, `git stash`
    comes to the rescue. This command allows you to save your current changes without
    making a formal commit, giving you the freedom to switch tasks and then return
    to where you left off:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In addition, here is a rundown of common `git stash` commands that can significantly
    enhance your workspace management:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '`git stash`: This stashes your changes, leaving your working directory clean.
    Untracked files are not stashed.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash save "Your Comment"`: This stashes your changes and allows you to
    attach a comment. This is useful for identifying stashes later with `git` `stash
    list`.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash list`: This displays a list of all your stashed changes. If you
    used `git stash save`, you will see your comments here, making it easier to identify
    each stash.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash apply`: This restores the most recently stashed changes to your
    working directory. The stash remains in the `git` `stash list`.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash apply [stash@{n}]`: This restores a specific stash based on its
    index number, which you can find using `git` `stash list`.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash drop`: This deletes a specific stash from the stash list.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash drop [stash@{n}]`: This deletes a specific stash based on its index
    number.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git stash clear`: This deletes all stashes, clearing your `stash list`.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .gitignore – Personalize what gets shared
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working on complex projects, your local environment may generate files
    such as logs or contain personal configuration settings—things you do not want
    to share with the rest of the team. The `.gitignore` file enables you to specify
    which files and folders should be ignored during a `git add`, ensuring they remain
    exclusive to your local environment.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a `.``gitignore` file:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Who did what? Great ways to help you debug
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git has a couple of typical ways to analyze the past. `git blame` and `git bisect`
    are useful to remember because they are easy to use to go back and debug who made
    what changes.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: git blame – Who did what?
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working in a shared code base, there may be instances where you need to
    understand the history of specific lines of code. The `git blame` command provides
    a breakdown of a file, annotating each line to show the last person who modified
    it and what commit it belongs to. This helps in identifying the responsible parties
    for particular changes, which is useful for debugging, refactoring, or simply
    understanding why a particular piece of code exists.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `-L` option allows you to specify the lines of output:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is essential to highlight that the aim of `git blame` is not to single out
    individuals for errors or questionable decisions. In any collaborative setting—especially
    in DevOps where teamwork is paramount—it is crucial to remember that mistakes
    are a collective responsibility. Everyone can err; what is important is how the
    team collaborates to fix those errors. From a psychosocial safety perspective,
    using `git blame` should be approached as a way to enhance team communication
    and identify areas for improvement rather than as a mechanism for casting blame.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: git bisect – Efficient bug hunting in commit ranges
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Debugging can often feel like looking for a needle in a haystack, especially
    in large codebases with a long history of commits. In the realm of DevOps, where
    rapid deployment cycles are the norm, a bug introduced in any of the numerous
    changes can wreak havoc. This is where `git bisect` comes into play, serving as
    a powerful tool for isolating the specific commit that introduced a bug.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git bisect` command performs a binary search through your commit history
    to find the commit that introduced the bug. The process begins by marking a known
    good commit and a known bad commit:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Git will then automatically check out a commit halfway between the good and
    bad commits. You test this commit and then mark it as either good or bad:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Git will continue this process, narrowing down the range of commits until it
    identifies the culprit. Once you find the problematic commit, it is easier to
    understand what went wrong and to devise a fix:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In DevOps, where the speed of identifying and resolving issues is crucial for
    maintaining operational excellence, `git bisect` becomes an invaluable tool. It
    integrates well into a DevOps toolchain, allowing for automated testing and facilitating
    quicker rollbacks and patches. By efficiently pinpointing errors, it enhances
    the team’s ability to collaborate on solutions, underscoring the essential DevOps
    principles of rapid feedback and continuous improvement.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: Versioning excellence
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the DevOps ecosystem, **CI/CD** make everything incremental. Yet, it is essential
    to have concrete versions of your software to serve as milestones. These versions
    are not just markers in time; they indicate the stability, new features, and overall
    health of your code base. They also facilitate smoother rollbacks and make it
    easier to isolate issues.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: What is semantic versioning
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Semantic versioning is a versioning scheme designed to convey specific meanings
    about the underlying changes with each new release. The format consists of three
    numbers separated by dots (e.g., 2.4.4). Each number has a particular significance
    related to backward compatibility and the types of changes introduced.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: Tagging in Git
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tagging becomes a cornerstone of effective version control within a DevOps environment.
    By marking specific points in your repository’s history, you can create anchors
    that serve as stable release points or significant milestones. These tagged versions
    form the basis for your CI/CD pipelines, ensuring consistent and reliable deployments.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your tags more informative, consider annotating them with useful metadata
    and context:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The commits you tag should typically represent stable release points or crucial
    milestones. These are the commits where all the automated tests have passed, features
    are complete, and the code has undergone peer review. In essence, they are your
    *production-ready* commits.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: 'To tag a specific commit, use the following:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Git tagging and semantic versioning are not just technical procedures but strategic
    actions. They ensure that everyone is on the same page regarding what is being
    deployed and what it can do.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have equipped ourselves with the knowledge to roll back
    time in our repositories, understanding when and how to use `git reset`, `git
    revert`, and `git checkout`. These powerful commands ensure that we can gracefully
    undo changes, correct course, and maintain a clean project history—all essential
    for a collaborative setting. Organizing your working environment with `git clean`,
    `git stash`, and the right `.gitignore` settings offers you a pristine workspace
    where focus and clarity replace clutter and chaos. This clean slate is not just
    about personal preference; it is about setting a standard for the team and ensuring
    that only intentional changes make their way into the shared repository.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating these techniques into your routine not only prepares you for better
    personal performance but also strengthens the whole team.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we delved deep into the nuances of branch strategies, the intricacies
    of merging and rebasing, and the art of navigating conflicts with the goal of
    mastering better collaboration within your teams. From understanding why a branching
    strategy is crucial to aligning branch naming with organizational objectives,
    we have laid out the groundwork for you to build a robust workflow.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: We explored the various branching models, such as trunk-based development, Git
    Flow, and GitHub Flow, highlighting their unique benefits and scenarios where
    they fit best. The discussion around merge approaches provided insight into the
    tools at your disposal for maintaining a clean and informative project history
    while also addressing the sometimes daunting task of conflict resolution.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: As you close this chapter, remember that the path to mastering Git is ongoing.
    Encourage yourself to discover more and to practice these skills through your
    development work with confidence. Embrace the challenges and the learning opportunities
    they bring and continue to grow as a developer. Git is not just a tool; it is
    a companion in your DevOps journey that enhances the developer’s experience by
    removing friction and fostering a culture of collaboration.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: GitHub Excellence and CI/CD Fundamentals'
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part highlights GitHub’s role in DevOps, expanding its use beyond just
    code hosting. It discusses GitHub’s features that enhance team collaboration and
    the transition to modern DevOps practices. Additionally, it delves into GitHub
    Actions, focusing on workflow optimization, advanced deployment methods such as
    blue-green and canary deployments, and feature release strategies. This provides
    an in-depth understanding of GitHub’s capabilities in continuous integration and
    deployment.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B21203_04.xhtml#_idTextAnchor077), *Elevating Team Collaboration
    with GitHub*'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21203_05.xhtml#_idTextAnchor109), *Driving CI/CD with GitHub*'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
