- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Advanced Git Usage for Team Collaboration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Git用法用于团队协作
- en: Now, we move on to the aspect of actual collaboration. In this chapter, we will
    delve into various collaboration practices that you will want to adopt. You will
    learn how to organize your commit history, manage complex branches, and resolve
    conflicts during merges. The goal of this chapter is to help you become wonderfully
    in control of this branch flow team collaboration.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入实际协作的部分。在本章中，我们将深入探讨你希望采用的各种协作实践。你将学习如何组织提交历史、管理复杂的分支，并在合并时解决冲突。本章的目标是帮助你能够很好地控制这种分支流的团队协作。
- en: Here, the focus is not just on getting the job done but also on doing it in
    a way that enhances teamwork. Recognize that there is a thoughtful strategy behind
    managing an entire code base to maximize the teams’ productivity and impact. Different
    strategies are employed based on the type of products or projects, the team size,
    and its maturity. Before we plunge into the Git commands, it is crucial to comprehend
    this underlying strategy—branching strategies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，重点不仅仅是完成工作，而是以一种能增强团队合作的方式来完成。要认识到，管理整个代码库背后有一套深思熟虑的策略，旨在最大化团队的生产力和影响力。根据产品或项目的类型、团队的规模及其成熟度，会采用不同的策略。在我们深入Git命令之前，理解这个基础策略——分支策略，是至关重要的。
- en: So, let’s get started on making your collaboration seamless and efficient.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始让你的协作变得更加顺畅高效吧。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Branching strategy for team collaboration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队协作的分支策略
- en: Ways to apply your changes on a branch
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分支上应用变更的方法
- en: Navigating conflicts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理冲突
- en: Mastering better collaboration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握更好的协作
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Configuration instructions for proceeding with this section can be found in
    the following GitHub repository link. Please make sure Git and SSH tools are installed.
    For Windows users, it is recommended to use PowerShell. I also encourage you to
    get the most up-to-date information written about the different commands and environments.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 继续本部分的配置说明可以在以下GitHub仓库链接中找到。请确保已安装Git和SSH工具。对于Windows用户，建议使用PowerShell。我也鼓励你获取关于不同命令和环境的最新信息。
- en: '[https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub](https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub](https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub)'
- en: Branching strategies for team collaboration
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队协作的分支策略
- en: In the realm of team collaboration, commits act as the essential building blocks.
    These commits link together to form a chronological history, a record of your
    project’s evolution. This history is organized and maintained through branches.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队协作的领域中，提交是至关重要的构建块。这些提交链接在一起，形成一个按时间顺序排列的历史记录，记录了你的项目的演变。这一历史记录通过分支进行组织和维护。
- en: So, how can engineers and teams knit this history into a cohesive meaningful
    narrative? The branching strategy is the answer to this question. The branching
    strategy is a development strategy for effectively managing branches in Git to
    enable smooth collaboration and service delivery.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，工程师和团队如何将这些历史记录编织成一个连贯有意义的叙事呢？分支策略就是这个问题的答案。分支策略是一个有效管理Git中分支的开发策略，它能够促进顺畅的协作和服务交付。
- en: Why a branching strategy is important
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么分支策略很重要
- en: A well-crafted branching strategy is not just nice to have; it is crucial in
    a team development environment. Your branching strategy has a ripple effect on
    your DevOps processes, affecting deployment units and workflow efficiency. The
    ability to collaborate smoothly depends not only on good communication within
    the team but also impacts the speed at which your product evolves. This ties back
    into all the elements we have covered in the previous chapters, such as the frequency
    and methodology of your CI/CD tests. In essence, your branching strategy is pivotal
    in removing organizational friction, which is the ultimate aim of DevOps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个精心设计的分支策略不仅仅是锦上添花；它在团队开发环境中至关重要。你的分支策略会对你的DevOps流程产生连锁反应，影响部署单元和工作流效率。顺利协作的能力不仅依赖于团队内部的良好沟通，还会影响你的产品发展速度。这与我们在前几章中覆盖的所有元素相关，例如CI/CD测试的频率和方法论。本质上，你的分支策略在消除组织摩擦方面至关重要，而这正是DevOps的最终目标。
- en: 'Here are some reasons why a well-thought-out branching strategy is non-negotiable:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为什么深思熟虑的分支策略是不可妥协的原因：
- en: '**Isolation of changes**: It allows individual team members to work on distinct
    features or bugs without interfering with each other’s work.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更隔离**：它允许单独的团队成员在不干扰彼此工作的情况下，处理不同的功能或缺陷。'
- en: '**Risk mitigation**: A branching strategy safeguards the main (often called
    master) branch from being destabilized by untested or volatile code.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险缓解**：分支策略可以保护主分支（通常称为master分支）不被未经测试或不稳定的代码破坏。'
- en: '**Facilitates collaboration**: With a good branching strategy, multiple team
    members can work on different branches in parallel, thereby increasing overall
    team efficiency.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进协作**：通过良好的分支策略，多个团队成员可以并行在不同的分支上工作，从而提高团队的整体效率。'
- en: 'In the context of DevOps, a branching strategy also does the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevOps的背景下，分支策略还具有以下功能：
- en: '**Automated testing integration**: A branching strategy can be designed to
    trigger automated tests at various stages. This ensures that only well-tested
    code is merged back into the main branch, aiding in continuous integration.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化测试集成**：分支策略可以设计为在不同阶段触发自动化测试。这样可以确保只有经过充分测试的代码才能合并回主分支，从而支持持续集成。'
- en: '**Simplifies deployment**: A well-organized branch structure can streamline
    the deployment process, making it easier to move code from development environments
    to staging and finally to production.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化部署**：一个组织良好的分支结构可以简化部署过程，使得代码更容易从开发环境移至暂存环境，最终到生产环境。'
- en: '**Enhances developer experience**: It improves the overall **Developer Experience**
    (**DX**) by making collaboration more transparent and efficient, a key strategy
    for successful DevOps.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强开发者体验**：通过提高协作的透明度和效率，它改善了整体的**开发者体验**（**DX**），这是成功DevOps的关键策略。'
- en: '**Environment-specific branches**: Having branches dedicated to particular
    environments (development, staging, production, etc.) allows for smoother and
    more controlled deployments.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定环境的分支**：为特定环境（开发、暂存、生产等）设置分支，有助于实现更加平滑和可控的部署。'
- en: '**Enhances security**: By establishing clear boundaries between branches, a
    branching strategy can enhance security by controlling access to sensitive code
    and ensuring that changes undergo proper review and approval processes before
    being merged into critical environments.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强安全性**：通过在分支之间建立清晰的边界，分支策略可以通过控制对敏感代码的访问，并确保在合并到关键环境之前，所有更改都经过适当的审查和批准，从而增强安全性。'
- en: Branch strategy and branch policy
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支策略与分支政策
- en: In the landscape of software development and DevOps, the terms **branching strategy**
    and **branching policy** might appear synonymous. While they are frequently mistaken
    for one another, it is vital to recognize that a branching strategy is a more
    expansive concept that encompasses a branching policy.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发和DevOps领域，**分支策略**和**分支政策**这两个术语可能看起来是同义的。虽然它们经常被混淆，但必须认识到，分支策略是一个更广泛的概念，涵盖了分支政策。
- en: A branching strategy is a comprehensive plan that outlines how branches are
    managed, created, and integrated within your development workflow. It encapsulates
    more than just the technical aspects of handling branches. It also involves contextual
    variables such as the size of your organization, the culture within your team,
    and the specific requirements of your project or product.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 分支策略是一个全面的计划，概述了如何在开发工作流中管理、创建和集成分支。它不仅仅涉及处理分支的技术方面，还包括组织的规模、团队文化以及项目或产品的具体需求等背景变量。
- en: Branching policies, on the other hand, are more specific sets of rules or guidelines
    for branch management. These often form the backbone of a branching strategy,
    serving as templates to be customized according to your specific needs. Sometimes,
    policies such as **Git Flow** or **GitHub Flow**, which we will discover in this
    chapter, are used as the names of strategies for development. They should be considered
    as types of branching policies. Renowned software thought leader Martin Fowler
    discusses these items not as strategies themselves but rather under the *Looking
    at some branching policies* section in his article *Patterns for Managing Source
    Code* *Branches* ([https://martinfowler.com/articles/branching-patterns.html](https://martinfowler.com/articles/branching-patterns.html)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 分支策略，另一方面，是一组更为具体的规则或指南，用于分支管理。这些规则通常构成分支策略的骨架，作为模板，根据具体需求进行定制。有时，像**Git Flow**或**GitHub
    Flow**这样的策略名称（我们将在本章中介绍）被用作开发策略的名称。它们应该被视为分支策略的一种类型。著名的软件思想领袖马丁·福勒在他的文章《源代码分支模式管理》（*Patterns
    for Managing Source Code* *Branches*）中并未将这些视为策略本身，而是在*观察一些分支策略*部分进行讨论，具体内容请参见他的文章([https://martinfowler.com/articles/branching-patterns.html](https://martinfowler.com/articles/branching-patterns.html))。
- en: Therefore, when establishing a branching approach, it is crucial to choose a
    branching policy that serves as a foundation. This policy should then be customized
    to align with your organization’s unique needs and objectives to effectively mitigate
    friction in development processes and accelerate software releases. This tailored
    approach ensures that your branching strategy not only optimizes workflow but
    also integrates seamlessly with the cultural and organizational aspects of your
    team.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在建立分支方法时，选择一个作为基础的分支策略至关重要。这个策略应根据组织的独特需求和目标进行定制，以有效减少开发过程中的摩擦并加速软件发布。这种定制化的方法确保了分支策略不仅优化了工作流程，还与团队的文化和组织方面无缝融合。
- en: Smaller and frequent versus larger and less frequent
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 较小且频繁的修改 vs 较大且不频繁的修改
- en: 'There are many branching policies in existence. Companies often coin specific
    branching policy names and publish them as best practices, such as **GitHub Flow**.
    Fundamentally, all branching strategies map to one of two principles: make smaller
    changes frequently or make larger changes occasionally.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 目前存在许多分支策略。公司通常会创造特定的分支策略名称，并将其发布为最佳实践，如**GitHub Flow**。从根本上讲，所有的分支策略都可以映射到两个原则之一：频繁地进行较小的修改，或者偶尔进行较大的修改。
- en: For smaller teams, naturally, the friction in integrating changes and pushing
    releases quickly is less. But in larger organizations, with larger products or
    a lengthy approval process, the friction inevitably increases. More conflicts
    arise, and more checks are needed to prevent them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型团队来说，集成变更和快速发布的摩擦自然较小。但在大型组织中，尤其是涉及大型产品或冗长审批过程时，摩擦不可避免地增加。更多的冲突出现，需要更多的检查来防止这些冲突。
- en: However, allowing these challenges to slow down your development process can
    adversely affect the timeliness of your product or project releases, ultimately
    impacting business success.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，允许这些挑战拖慢开发过程可能会对产品或项目发布的及时性产生不利影响，最终影响业务的成功。
- en: Over time, various companies have devised a multitude of branching strategies
    to mitigate these issues. Most of them are extensions of existing practices, designed
    to reduce friction within the constraints of an organization or product, aiming
    for faster releases.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，许多公司设计了各种分支策略来缓解这些问题。它们中的大多数都是现有实践的扩展，旨在减少组织或产品限制内的摩擦，目标是加速发布。
- en: It is crucial to understand that no branching strategy serves as a one-size-fits-all
    solution. The base strategy often gets selected depending on the team’s composition
    and culture, and from there, customizations are made to fit specific needs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 需要理解的是，没有任何一种分支策略是适用于所有情况的“万能解”。基础策略通常是根据团队的组成和文化来选择的，然后根据具体需求进行定制。
- en: 'This section introduces the branch policies trunk-based development, Git Flow,
    and GitHub Flow, each mapped as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了基于主干的开发、Git Flow 和 GitHub Flow 这三种分支策略，它们的映射如下：
- en: '![Figure 3.1 – Branching policies mapping](img/B21203_03_001.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – 分支策略映射](img/B21203_03_001.jpg)'
- en: Figure 3.1 – Branching policies mapping
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – 分支策略映射
- en: '**Trunk-based development** is renowned for integrating smaller, frequent changes
    directly into the main branch. In contrast, Git Flow is known for a strategy that
    integrates larger changes less frequently. Both have their pros and cons, and
    your choice between them often boils down to your team’s specific requirements
    and workflows.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于主干的开发**以将较小、频繁的更改直接集成到主分支中而闻名。与此相对，Git Flow因其较少频繁地集成较大更改的策略而著名。两者各有优缺点，选择其中之一通常取决于团队的具体需求和工作流程。'
- en: For larger organizations aiming to release a higher volume of changes more frequently
    with reduced friction, GitHub Flow serves as an excellent representative. These
    strategies are essentially designed to adapt the core principles of frequent,
    small changes to fit the complexity and scale of larger enterprises.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些希望更频繁地发布更多更改并减少摩擦的大型组织，GitHub Flow 是一个很好的代表。这些策略基本上是将频繁小规模更改的核心原则适应大型企业的复杂性和规模。
- en: Policies such as GitHub Flow are built under the influence of Git Flow, but
    many companies nowadays use GitHub Flow as a template upon which they build their
    own customized branching policies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 像GitHub Flow这样的策略是在Git Flow的影响下构建的，但现在许多公司使用GitHub Flow作为模板，在此基础上构建他们自己的定制化分支策略。
- en: Types of branch policies branch policies
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支策略的类型
- en: Now then, let’s look at a typical branch policy.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个典型的分支策略。
- en: 'This section introduces three typical branching policies:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍三种典型的分支策略：
- en: Trunk-based development
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: Git Flow
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git Flow
- en: GitHub Flow
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub Flow
- en: Consider each in terms of how frequently your team or organization needs to
    release and how large your product and project are.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑根据您的团队或组织需要发布的频率以及您的产品和项目的规模来分析每种情况。
- en: Trunk-based development
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: '**Trunk-based development** (**TBD**) is a software development approach where
    developers work in short-lived branches, typically less than a day, or directly
    off a single branch called the **trunk** or the mainline. The key principle is
    to minimize the lifespan of branches to promote frequent integrations and to avoid
    the pitfalls of long-lived feature branches, such as merge conflicts and diverging
    codebases.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于主干的开发**（**TBD**）是一种软件开发方法，在这种方法中，开发人员在短生命周期的分支上工作，通常不超过一天，或者直接从一个名为**主干**或主线的单一分支上工作。其关键原则是尽量缩短分支的生命周期，以促进频繁的集成，并避免长期存在的特性分支所带来的问题，如合并冲突和代码库分歧。'
- en: In TBD, the trunk is always in working and healthy condition, and it should
    always be in a deployable state. Developers take a small chunk of a feature or
    task and work on it, aiming to merge it back into the trunk as soon as possible.
    If a feature is not yet ready for production, **feature flags** can be used to
    hide these functionalities until they are complete, allowing the code to be merged
    without affecting the end users. Release practices such as feature flags are covered
    in [*Chapter 5*](B21203_05.xhtml#_idTextAnchor109).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在TBD中，主干始终保持工作状态并且健康，应该始终处于可部署状态。开发人员会选择一个小的功能或任务块进行开发，并尽快将其合并回主干。如果某个功能尚未准备好发布，可以使用**功能标志**来隐藏这些功能，直到它们完成为止，这样代码就可以合并而不影响最终用户。像功能标志这样的发布实践将在[*第5章*](B21203_05.xhtml#_idTextAnchor109)中讨论。
- en: As shown in the figure, in the TBD, many short-lived branches are created, and
    they are merged into the mainline.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，在TBD中，创建了许多短生命周期的分支，并将它们合并到主线中。
- en: '![Figure 3.2 – Trunk-based development](img/B21203_03_002.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 基于主干的开发](img/B21203_03_002.jpg)'
- en: Figure 3.2 – Trunk-based development
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 基于主干的开发
- en: Since integration happens frequently, it is crucial to have a robust suite of
    automated tests to run every time code is merged into the trunk. This ensures
    that the code base remains stable and deployable at all times. **Continuous Integration**
    (**CI**) tools are commonly used in conjunction with TBD to automate the testing
    and build processes, ensuring that the trunk is always in a good state.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集成发生得很频繁，因此必须拥有一个强大的自动化测试套件，在每次代码合并到主干时进行运行。这确保了代码库始终保持稳定和可部署。**持续集成**（**CI**）工具通常与TBD一起使用，以自动化测试和构建过程，确保主干始终保持良好状态。
- en: To accommodate hotfixes that provide urgent fixes, developers may create short-lived
    branches that are immediately merged back into the trunk upon completion. This
    ensures that critical issues can be addressed quickly without jeopardizing the
    stability of the mainline.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理提供紧急修复的 hotfix，开发者可能会创建短生命周期的分支，这些分支在完成后立即合并回主干。这确保了能够迅速解决关键问题，而不会危及主干的稳定性。
- en: One of the main advantages of TBD is its simplicity and focus on producing a
    clean, deployable code base. Encouraging frequent merges reduces the likelihood
    of merge conflicts and keeps all developers aligned with the latest version of
    the code. This is particularly beneficial in a DevOps culture that prioritizes
    quick iterations and rapid delivery.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: TBD 的主要优点之一是它的简单性和专注于生成清晰、可部署的代码库。鼓励频繁的合并减少了合并冲突的可能性，并使所有开发者保持与最新版本代码的一致性。这在优先考虑快速迭代和快速交付的
    DevOps 文化中尤为重要。
- en: Here are the pros and cons of trunk-based development.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于主干开发的优缺点。
- en: 'Pros:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Frequent integration**: Because code is merged frequently, merge conflicts
    are less likely and easier to resolve'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频繁集成**：由于代码频繁合并，合并冲突的可能性较小，且更容易解决'
- en: '**Fast feedback loop**: Integrating changes often helps in identifying issues
    earlier in the development process'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速反馈循环**：频繁集成变更有助于在开发过程中尽早发现问题'
- en: '**Simplified workflow**: Without a proliferation of long-lived feature branches,
    the development workflow is simplified, making it easier to manage'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化的工作流程**：没有大量长生命周期的功能分支，开发工作流程得以简化，管理起来更容易'
- en: 'Cons:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Risk of instability**: If not properly tested, frequent merges can lead to
    unstable code getting into the mainline'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不稳定的风险**：如果没有经过适当的测试，频繁的合并可能会导致不稳定的代码进入主干'
- en: '**Not ideal for large features**: For very large or disruptive changes, this
    approach can cause problems, as those changes might destabilize the mainline for
    an extended period'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不适合大型功能**：对于非常大的或破坏性更强的变更，这种方法可能会导致问题，因为这些变更可能会使主干在较长时间内不稳定'
- en: In summary, TBD is all about rapid integrations, keeping the trunk always deployable,
    and employing automated testing to maintain code quality. It aligns well with
    Agile and DevOps methodologies, aiming to remove friction and improve developer
    experience by streamlining the development process.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，TBD（基于主干开发）注重快速集成，始终保持主干可部署，并通过自动化测试保持代码质量。它与敏捷开发和 DevOps 方法论非常契合，旨在通过简化开发过程来消除摩擦并改善开发者体验。
- en: Git Flow
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git Flow
- en: Git Flow is a branching policy mainly aimed at robust project versioning and
    is particularly well-suited for projects that have a scheduled release cycle.
    It introduces a structured approach involving multiple types of branches, including
    `feature`, `release`, `develop`, and `hotfix`, alongside the `main` (or `master`)
    branch.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Git Flow 是一种主要针对健壮的项目版本控制的分支策略，特别适合有定期发布周期的项目。它引入了一种结构化的方法，涉及多种类型的分支，包括 `feature`、`release`、`develop`
    和 `hotfix`，以及 `main`（或 `master`）分支。
- en: '![Figure 3.3 – Git Flow](img/B21203_03_003.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – Git Flow](img/B21203_03_003.jpg)'
- en: Figure 3.3 – Git Flow
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – Git Flow
- en: In Git Flow, development begins by branching off a `develop` branch from `main`.
    The `develop` branch serves as the integration branch for features and is where
    all developers’ branches get merged. When you are set to work on a new feature
    or a bug, you branch off a `feature` branch from `develop`. This isolated environment
    allows you to work without affecting the broader code base.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git Flow 中，开发工作从 `main` 分支创建一个 `develop` 分支开始。`develop` 分支作为功能集成的分支，是所有开发者的分支合并的地方。当你准备开发一个新功能或修复一个
    bug 时，你会从 `develop` 分支创建一个 `feature` 分支。这个隔离的环境使你能够在不影响整个代码库的情况下进行工作。
- en: As the feature progresses, incremental changes are committed to this `feature`
    branch. Once the feature is complete and tested, it gets merged back into the
    `develop` branch. For release preparation, a `release` branch is created from
    the `develop` branch. This branch is where any final minor bug fixes or documentation
    updates occur. Once everything is ready, the `release` branch is merged into `main`
    and tagged with a version number. Simultaneously, it should also be merged back
    into `develop` to ensure that future releases also have these changes. For immediate,
    critical fixes, a `hotfix` branch may be created directly off the main branch.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随着功能的进展，增量更改会提交到这个 `feature` 分支。一旦功能完成并经过测试，它会被合并回 `develop` 分支。为了准备发布，会从 `develop`
    分支创建一个 `release` 分支。这个分支用于进行最后的小错误修复或文档更新。一切准备就绪后，`release` 分支将合并到 `main` 并标记版本号。同时，它也应该被合并回
    `develop`，以确保未来的发布也包含这些更改。对于紧急的修复，可以直接从主分支创建一个 `hotfix` 分支。
- en: Git Flow provides a rigid structure that can be beneficial for large projects
    with multiple developers, requiring a balance of stability and new features. It
    ensures that development processes are separate but parallel, allowing for project
    history to be more legible and revertible.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Git Flow 提供了一个严格的结构，对于需要平衡稳定性和新特性的多个开发者的大型项目非常有益。它确保了开发过程是分开的但平行进行，使项目历史更易于理解和回退。
- en: Here are the pros and cons of the Git Flow.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Git Flow 的优缺点。
- en: 'Pros:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Structured workflow**: It’s suitable for projects that have scheduled release
    cycles'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构化工作流程**：适用于有计划发布周期的项目'
- en: '**Isolation**: Feature branches allow developers to work in isolation, making
    it easier to manage complex features'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：功能分支允许开发者在隔离的环境中工作，使得管理复杂功能变得更加容易'
- en: '**Hotfix support**: The dedicated hotfix branches make it easy to quickly patch
    production releases'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热修复支持**：专用的热修复分支使得快速修复生产版本变得更加容易'
- en: 'Cons:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Complexity**: For smaller teams or projects, Git Flow may introduce unnecessary
    complexity'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：对于较小的团队或项目，Git Flow 可能引入不必要的复杂性'
- en: '**Delayed Integration**: As feature branches are long-lived, this could lead
    to merge conflicts or bugs that are discovered late in the development process'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟集成**：由于功能分支生命周期较长，这可能导致合并冲突或在开发过程中发现的错误'
- en: In summary, Git Flow provides a model for more complex projects, ensuring that
    the code base remains organized and that releases are well managed. It is especially
    useful for larger teams where coordination and release planning are critical.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Git Flow 为更复杂的项目提供了一种模型，确保代码库保持有序，并且发布管理得当。它特别适用于大型团队，其中协调和发布规划至关重要。
- en: GitHub Flow
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitHub Flow
- en: GitHub Flow is a simplified workflow that encourages continuous delivery practices.
    It consists of just the mainline and short-lived feature branches. The main principle
    is to branch off, develop a new feature, submit a pull request, and review the
    code before deploying. Pull request is an invention by GitHub and is a method
    for developers to notify team members that they have completed a feature or fix,
    which is then reviewed and discussed before being merged into the main branch
    of a code base. It will be covered in [*Chapter 4*](B21203_04.xhtml#_idTextAnchor077).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Flow 是一种简化的工作流程，鼓励持续交付实践。它只包括主线和短期存在的功能分支。其主要原则是分支、开发新功能、提交拉取请求、审核代码后再进行部署。拉取请求是
    GitHub 的发明，是开发者通知团队成员他们已完成一个功能或修复的方式，随后该功能或修复会被审核和讨论，合并到代码库的主分支中。详细内容请参考 [*第 4
    章*](B21203_04.xhtml#_idTextAnchor077)。
- en: 'The GitHub Flow is simple, but the context is not confined to Git alone. Note
    the inclusion of GitHub processes such as pull requests and approvals, as shown
    in the figure:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Flow 很简单，但其背景不仅仅限于 Git。注意，图中包含了 GitHub 流程，如拉取请求和批准：
- en: '![Figure 3.4 – GitHub Flow](img/B21203_03_004.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – GitHub Flow](img/B21203_03_004.jpg)'
- en: Figure 3.4 – GitHub Flow
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – GitHub Flow
- en: It begins with creating a new, descriptive branch off the default repository
    branch, serving as a safe environment for making changes without affecting the
    main code base. Changes are committed and pushed to this remote branch. When ready,
    a detailed pull request is created for team reviews, often linked to related issues
    for context. Reviews might include questions, suggestions, or line-specific comments.
    Subsequent commits addressing feedback are automatically added to the pull request.
    After approval, the pull request is merged into the default branch, making your
    contributions part of the main code base. Depending on settings, resolving merge
    conflicts or meeting approval criteria may be required. Post-merge, the working
    branch is deleted but the commit history and discussions remain accessible for
    future reference.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 它从创建一个新的描述性分支开始，该分支从默认的代码库分支派生，为修改提供一个安全的环境，不会影响主代码库。所有修改都提交并推送到这个远程分支。当准备好时，创建一个详细的拉取请求供团队审查，通常会与相关问题链接，以提供上下文。审查可能包括问题、建议或特定行的评论。针对反馈的后续提交会自动添加到拉取请求中。批准后，拉取请求会被合并到默认分支，将你的贡献并入主代码库。根据设置，可能需要解决合并冲突或满足批准标准。合并后，工作分支会被删除，但提交历史和讨论仍然可以访问，供日后参考。
- en: In essence, GitHub Flow fosters collaboration, transparency, and incremental
    development, offering a flexible yet structured approach for team projects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，GitHub Flow 促进了协作、透明性和增量开发，为团队项目提供了一种灵活而结构化的方式。
- en: Here are the pros and cons of the GitHub Flow.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 GitHub Flow 的优缺点。
- en: 'Pros:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Simplicity**: GitHub Flow offers a straightforward approach with a single
    mainline and short-lived feature branches, making it accessible and easy to manage,
    even for newcomers. This simplicity streamlines development, allowing for a focus
    on productivity rather than complex branching strategies.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**：GitHub Flow 提供了一种简单的方式，只有一个主分支和短生命周期的特性分支，即使是新手也容易上手和管理。这种简洁性简化了开发过程，让开发者可以专注于提高生产力，而不是复杂的分支策略。'
- en: '**Faster deployment**: By encouraging continuous integration and delivery,
    GitHub Flow enables teams to release updates more frequently. This rapid deployment
    cycle allows for immediate feedback and quicker iteration, reducing the time from
    development to market.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的部署**：通过鼓励持续集成和交付，GitHub Flow 使团队能够更频繁地发布更新。这种快速的部署周期能让团队及时获得反馈并进行更快的迭代，减少从开发到市场的时间。'
- en: '**Enhanced collaboration**: The pull request mechanism central to GitHub Flow
    fosters transparent code reviews and collaboration. It allows every team member
    to contribute to discussions, ensuring code quality and collective ownership of
    the project.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的协作性**：GitHub Flow 中心的拉取请求机制促进了透明的代码审查和协作。它允许每个团队成员参与讨论，确保代码质量并共同拥有项目。'
- en: 'Cons:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Platform compatibility considerations**: Adopting GitHub Flow enhances collaboration
    and efficiency, particularly on GitHub where it is fully supported. However, when
    integrating with different platforms, it might necessitate supplementary tools
    or adjustments to harness its full potential, ensuring seamless project management
    across diverse environments.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台兼容性考虑**：采用 GitHub Flow 可增强协作与效率，特别是在 GitHub 上完全支持的情况下。然而，在与不同平台集成时，可能需要额外的工具或调整，以充分利用其潜力，确保在多种环境下无缝的项目管理。'
- en: '**Adaptability for complex projects:** While GitHub Flow offers a streamlined,
    straightforward approach conducive to rapid deployment and continuous delivery,
    larger teams working on multifaceted projects may encounter challenges. This workflow’s
    emphasis on simplicity and single mainline development can sometimes limit the
    granularity of control over multiple simultaneous developments or the nuanced
    handling of various project timelines. For instance, in projects requiring extensive
    integration testing or coordination across multiple sub-teams, the need for additional
    branch management strategies or more robust release planning mechanisms becomes
    apparent.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应复杂项目的能力**：尽管 GitHub Flow 提供了一种简化、直接的方式，适合快速部署和持续交付，但在多团队协作、处理复杂项目时可能会遇到挑战。这种工作流注重简洁性和单一主分支开发，有时会限制对多个同时进行的开发任务或不同项目时间表的精细控制。例如，对于需要广泛集成测试或多个子团队之间协调的项目，可能需要额外的分支管理策略或更强大的发布规划机制。'
- en: Branch naming conventions – Discover the best practices for naming branches
    in Git
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支命名规范 – 了解 Git 中命名分支的最佳实践
- en: In the realm of Git and DevOps, naming is a crucial aspect of effective team
    collaboration and code management. A clear, descriptive name can make a world
    of difference when you are navigating through a sea of branches, trying to understand
    their specific functions, ownership, and lifecycle status. Establishing a coherent
    branching naming convention is an integral part of an effective branching strategy.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 和 DevOps 的领域中，命名是有效团队协作和代码管理的关键因素。当你在一堆分支中浏览时，一个清晰且具有描述性的名称能带来天壤之别，帮助你理解它们的具体功能、归属以及生命周期状态。建立一致的分支命名规范是有效分支策略的一个重要组成部分。
- en: Let’s delve into the best practices for naming branches in Git, aiming to remove
    organizational friction and accelerate releases. A well-defined naming convention
    allows engineers to instantly understand the purpose of a branch, whether it is
    for a feature, a bug fix, a hotfix, or an experimental endeavor. This clarity
    is vital when a team is sifting through dozens, or even hundreds, of branches.
    Naming conventions set the stage for a more transparent, efficient, and streamlined
    workflow, making it easier for everyone on the DevOps team to collaborate.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨在 Git 中命名分支的最佳实践，旨在减少组织内的摩擦并加速发布。一个明确定义的命名规范使得工程师可以立刻理解一个分支的目的，无论它是为了某个功能、修复漏洞、热修复，还是一个实验性的尝试。在团队需要筛选数十个甚至数百个分支时，这种清晰度至关重要。命名规范为更透明、高效和精简的工作流程奠定了基础，使
    DevOps 团队的每个人都能更轻松地进行协作。
- en: Branch naming guidelines and examples
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分支命名规范和示例
- en: The following are the main guidelines and examples for naming each topic. Please
    note that these are only examples, and each team can have very different naming
    conventions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为每个主题命名的主要规范和示例。请注意，这些只是示例，每个团队的命名规范可能会有所不同。
- en: 'Here’s some general guidance:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些通用的指导原则：
- en: '`-`), underscores (`_`), or slashes (`/`) to separate words. Slashes are especially
    used as a separator when dealing with topics such as hotfixes and features.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用破折号 (`-`)、下划线 (`_`) 或斜杠 (`/`) 来分隔单词。斜杠尤其常用于分隔热修复和功能等主题。
- en: '**Lowercase names**: While Git is case-sensitive, sticking to lowercase letters
    helps maintain consistency and avoids confusion.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小写名称**：虽然 Git 区分大小写，但坚持使用小写字母有助于保持一致性并避免混淆。'
- en: '**Make it descriptive but short**: The name should give an instant idea of
    what the branch is about while remaining as succinct as possible.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁但富有描述性**：分支名称应该能够立刻让人理解该分支的内容，同时尽可能简洁。'
- en: 'Here are examples of names for each branch:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个分支名称的示例：
- en: '`feature/`, followed by a brief description. An example would be `feature/user
    authentication`.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feature/`，后跟简短描述。一个例子是 `feature/user authentication`。'
- en: '`bugfix/`, followed by a short descriptor. For example, `bugfix/login-error`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bugfix/`，后跟简短描述。例如，`bugfix/login-error`。'
- en: '`hotfix/`. For example, `hotfix/xyz-security-vulnerability`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hotfix/`。例如，`hotfix/xyz-security-vulnerability`。'
- en: '`release/` as a prefix. An example would be `release/v1.2`.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release/` 作为前缀。一个例子是 `release/v1.2`。'
- en: Contextual naming
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文命名
- en: While these categories offer a good starting point, you may also consider adding
    more contextual information to the branch name. For example, you could append
    the issue number at the end (`feature/123-user-authentication`) or include the
    name of the person responsible for the branch (`feature/teamxyz-authentication`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些分类提供了一个很好的起点，你也可以考虑在分支名称中加入更多的上下文信息。例如，你可以在末尾附加问题编号（如`feature/123-user-authentication`），或者包括负责该分支的人员姓名（如`feature/teamxyz-authentication`）。
- en: In this section, we recognized that a solid branching strategy stands as the
    backbone of any collaborative development project. We have explored the significance
    of branch strategies in maintaining a stable code base while facilitating continuous
    integration and delivery. Whether it is adopting the small and frequent commits
    of TBD, the structured roles of Git Flow, or the simplicity of GitHub Flow, the
    right strategy is paramount to a team’s success.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们认识到，一个稳固的分支策略是任何协作开发项目的支柱。我们已经探讨了分支策略在维持稳定的代码库同时促进持续集成和交付方面的重要性。无论是采纳
    TBD 的小而频繁提交、Git Flow 的结构化角色，还是 GitHub Flow 的简易性，正确的策略对于团队的成功至关重要。
- en: Remember, these conventions should align with your broader branching strategy
    and policy and be adapted to the size of your team and the project and your organization’s
    unique constraints and goals. A well-chosen naming convention will reinforce the
    effectiveness of your branching policy, aiding in the quest to mitigate friction
    and accelerate releases. By adhering to a well-defined naming convention, you
    empower your team to work more efficiently and foster a culture of clarity and
    accountability.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些约定应该与您更广泛的分支策略和政策保持一致，并根据您的团队规模、项目以及组织的独特约束和目标进行调整。一个精心选择的命名约定将有助于强化分支政策的有效性，帮助减少摩擦并加速发布。通过遵循明确的命名约定，您能够让团队更加高效地工作，并促进清晰和责任感的文化。
- en: In the upcoming section, you will learn how to bring together disparate lines
    of development while maintaining the integrity and history of your code. Let’s
    move forward with confidence, ready to merge our knowledge of branching into the
    practical skills of Git merging.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将学习如何将不同的开发线合并在一起，同时保持代码的完整性和历史记录。让我们带着信心继续前进，将分支的知识与 Git 合并的实际技能相结合。
- en: Ways to apply your changes on a branch
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在分支上应用更改
- en: Now that you have delved into the intricacies of branch management and workflows
    in DevOps, you are likely starting to see the big picture. You have come to understand
    how your individual commits contribute to the overall development stream. The
    next step in this journey is *to connect the dots*—more specifically, consider
    how the code you have written gets merged into the mainline.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经深入了解了 DevOps 中分支管理和工作流的复杂性，可能已经开始看到全局。您已理解您的个人提交如何为整体开发流做出贡献。接下来的步骤是*连接各个点*——更具体地说，考虑您编写的代码如何被合并到主干中。
- en: The code base is a living, collaborative environment; it holds a history of
    contributions from various team members. In a fast-paced environment, it may be
    tempting to rush through commits or push large chunks of changes all at once to
    meet deadlines. However, when merging, it is crucial to consider how your changes
    contribute to a consistent, understandable, and stable shared environment. This
    consideration becomes particularly vital in a DevOps culture, where the objective
    is not just rapid deployment but also frictionless collaboration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 代码库是一个充满活力的协作环境，记录了各种团队成员的贡献历史。在快速发展的环境中，我们可能会因为赶进度而急于提交或一次性推送大量的更改。然而，在合并时，必须考虑到这些更改如何有助于维持一致、可理解且稳定的共享环境。特别是在
    DevOps 文化中，这一点尤为重要，因为目标不仅仅是快速部署，还包括无摩擦的协作。
- en: In the upcoming sections, we will explore various tactics and best practices
    for executing successful merges in Git, particularly tailored to the needs and
    challenges that arise in a DevOps setting.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将探讨在 Git 中执行成功合并的各种策略和最佳实践，特别是针对 DevOps 环境中出现的需求和挑战。
- en: Merging vs rebasing
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并与重基（Merging vs rebasing）
- en: 'Git offers two main techniques for integrating these changes: merging and rebasing.
    While they serve the same ultimate purpose—bringing different strands of code
    together—they have distinct operational nuances. Before diving into various actual
    commands, let’s distinguish between merging and rebasing.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Git 提供了两种主要的技术来集成这些变化：合并（merging）和重基（rebasing）。虽然它们的最终目的是相同的——将不同的代码分支合并在一起——但它们在操作上有明显的差异。在深入了解实际命令之前，让我们先区分合并和重基。
- en: Merging
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并（Merging）
- en: 'Merging takes the content of a source branch and integrates it with a target
    branch. This new commit will have two parent commits, preserving the independent
    histories of the branches being merged. Merging can be cumbersome because it keeps
    the history from the various branches as it is, but it is also good in terms of
    flexibility during integration when various people are working on a project at
    the same time. Mainly, there are two types of merge options: **non-fast-forward
    merge**, which creates a new merge commit to log the merge, and **fast-forward
    merge**, which does not create a merge commit. There is also the squash function—an
    option that compresses multiple commits into a single commit for merging.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 合并会将源分支的内容与目标分支集成在一起。这个新提交将拥有两个父提交，保留被合并分支的独立历史。合并可能会显得繁琐，因为它保留了各个分支的历史，但在多人同时参与项目时，它在集成过程中提供了灵活性。主要有两种合并方式：**非快进合并**（non-fast-forward
    merge），这种方式会创建一个新的合并提交来记录合并过程；以及**快进合并**（fast-forward merge），这种方式则不创建合并提交。还有一个叫做
    squash 的功能——它可以将多个提交压缩成一个提交进行合并。
- en: 'On platforms such as GitHub, the default setting is for merge commits to be
    made like in the following figure:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 等平台上，默认设置是像下面的图示一样进行合并提交：
- en: '![Figure 3.5 – Merging example (non-fast-forward)](img/B21203_03_005.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 合并示例（非快进）](img/B21203_03_005.jpg)'
- en: Figure 3.5 – Merging example (non-fast-forward)
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 合并示例（非快进）
- en: Here are the pros and cons of merging.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是合并的优缺点。
- en: 'Pros:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**History preservation**: Merging keeps the history of both branches, offering
    a detailed log'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史保存**：合并保留了两个分支的历史，提供了详细的日志'
- en: '**Simplicity**: It is usually easier for beginners to understand'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：通常初学者更容易理解'
- en: '**Branch isolation**: Individual branches can continue to make separate changes
    without affecting the merge'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支隔离**：各个分支可以继续进行独立的更改，而不影响合并'
- en: 'Cons:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Complex log**: While preserving history, merges can lead to a complicated
    and cluttered log history'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的日志**：虽然保留了历史记录，但合并可能导致日志历史复杂且杂乱'
- en: '**Lack of linearity**: The project history becomes non-linear, making it challenging
    to navigate the commit history'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏线性**：项目历史变得非线性，难以浏览提交历史'
- en: Rebasing
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变基
- en: Rebasing is the process of moving or combining a sequence of commits to a new
    base commit. It essentially takes the changes made in a feature branch and replays
    them on top of another branch. Instead of creating a new commit, as is the case
    with merging, rebasing rewrites the commit history to produce a linear succession
    of commits. The great thing about rebasing is the linearity of its history. When
    looking back in time, it is easy to follow the flow of what happened in the mainline
    branch, which is very good in terms of bug fixes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 变基是将一系列提交移动或合并到新的基础提交的过程。它本质上是将功能分支中所做的更改重新播放到另一个分支之上。与合并不同，变基不会创建新的提交，而是重写提交历史，生成一个线性的提交顺序。变基的优点是其历史的线性。回顾历史时，很容易跟随主分支发生的变化，这对于修复
    bug 非常有利。
- en: 'Once you master rebasing, you can contribute to a noise-free history:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦掌握变基，你可以为历史记录做出无噪音的贡献：
- en: '![Figure 3.6 – Rebasing](img/B21203_03_006.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 变基](img/B21203_03_006.jpg)'
- en: Figure 3.6 – Rebasing
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 变基
- en: Here are the pros and cons of rebasing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是变基的优缺点。
- en: 'Pros:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 优点：
- en: '**Cleaner history**: Rebasing results in a much cleaner, linear project history'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更清晰的历史**：变基会生成一个更清晰、线性的项目历史'
- en: '**Eliminates Noise**: It removes unnecessary merge commits that appear when
    performing the git merge'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消除噪音**：它移除了在执行 git merge 时出现的不必要的合并提交'
- en: '**Simpler Debugging**: With a cleaner history, debugging becomes easier'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更简便的调试**：有了更清晰的历史记录，调试变得更容易'
- en: 'Cons:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点：
- en: '**Shared Branch Risk**: Rebasing can be destructive; it can be risky on shared
    branches because it rewrites commit history'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共享分支风险**：变基可能会破坏历史，特别是在共享分支上，因为它会重写提交历史'
- en: '**Complexity**: Rebasing can be more complicated to understand and execute
    correctly'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂性**：变基可能更难理解和正确执行'
- en: Both techniques have their pros and cons. Merging preserves the original branch
    history but can lead to a complicated log. Rebasing offers a cleaner, more linear
    project history but carries risks, especially when working on a shared branch.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 两种技术都有其优缺点。合并保留了原始分支历史，但可能导致日志复杂。变基提供了更清晰、更线性的项目历史，但存在风险，尤其是在共享分支上工作时。
- en: Exploring different ways to merge in Git
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索 Git 中不同的合并方式
- en: Now let’s dive into the practical steps. We will explore the process of merging
    two branches, offering hands-on experience to help you better understand each
    method. In this section, we will cover some of the most commonly used methods
    to merge branches, enabling you to make informed decisions based on your project
    needs.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入实际步骤。我们将探索合并两个分支的过程，提供实践经验帮助你更好地理解每种方法。在本节中，我们将介绍一些最常用的分支合并方法，帮助你根据项目需求做出明智的决策。
- en: git merge --ff – Keeping it straight
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git merge --ff – 保持直线
- en: Let’s dig into the practical aspects now. This section focuses on a common default
    behavior in Git merging called `--ff` as a command option. We will go through
    the process, ensuring you understand how it works and when to use it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们深入探讨实际应用。本节将聚焦于 Git 合并中的一个常见默认行为，称为 `--ff` 命令选项。我们将逐步讲解，确保你理解它的工作原理以及何时使用它。
- en: Fast-forward merging is one of the simplest ways to integrate branches in Git.
    In essence, a fast-forward merge moves the tip of the targeted branch to the latest
    commit on the source branch.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 快速前进合并是 Git 中集成分支的最简单方法之一。本质上，快速前进合并将目标分支的末端移动到源分支的最新提交。
- en: 'With fast-forward merges, when looking at the history, nothing actually appears
    to have changed, as shown in the following figure. That is the benefit of fast-forward
    merging. HEAD is moving without fail and merging can be done smoothly:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用快速前进合并时，在查看历史记录时，实际上什么也没有改变，如下图所示。这就是快速前进合并的好处。HEAD 持续移动，合并可以顺利进行：
- en: '![Figure 3.7 – Fast-forward merging](img/B21203_03_007.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 快速前进合并](img/B21203_03_007.jpg)'
- en: Figure 3.7 – Fast-forward merging
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 快速前进合并
- en: In Git, a fast-forward merge is possible when there are no new commits on the
    base (or target) branch that occurred after the feature branch was created. Essentially,
    it eliminates the need for a new commit to join the branches, keeping your project
    history linear.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 中，当基础（或目标）分支在特性分支创建后没有新的提交时，就可以进行快速前进合并。本质上，它消除了需要新提交来连接分支的需求，从而保持项目历史的线性。
- en: Practical steps for fast-forward merging
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 快速前进合并的实际步骤
- en: 'For the context of this guide, assume you have a `main` branch and an `add-description`
    branch. The `add-description` branch has derived from the `main` and you are planning
    to merge the feature back into `master`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本指南的上下文中，假设你有一个 `main` 分支和一个 `add-description` 分支。`add-description` 分支是从 `main`
    分支派生出来的，你打算将特性合并回 `master`：
- en: '[PRE0]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'At this point, your repository structure would resemble the following diagram:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你的仓库结构应该类似于下图：
- en: '![Figure 3.8 – git merge –ff (1)](img/B21203_03_008.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – git merge –ff (1)](img/B21203_03_008.jpg)'
- en: Figure 3.8 – git merge –ff (1)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – git merge –ff (1)
- en: 'Now, let’s proceed to merge these branches by switching back to the `main`
    branch:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过切换回 `main` 分支来合并这些分支：
- en: '[PRE1]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, your repository history would look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的仓库历史应该如下所示：
- en: '![Figure 3.9 – git merge –ff (2)](img/B21203_03_009.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – git merge –ff (2)](img/B21203_03_009.jpg)'
- en: Figure 3.9 – git merge –ff (2)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – git merge –ff (2)
- en: Why fast-forward merges are preferred in DevOps and team collaboration
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么在 DevOps 和团队协作中更倾向于使用快速前进合并
- en: Behind the scenes, a fast-forward merge merely moves HEAD, the pointer, to the
    latest commit. Moreover, fast-forward merges do not create a new merge commit,
    keeping the Git history clean and linear. This makes it a simple and efficient
    operation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，快速前进合并只是将 HEAD（指针）移动到最新的提交。而且，快速前进合并不会创建新的合并提交，保持 Git 历史的清晰和线性。这使得它成为一种简单且高效的操作。
- en: 'Fast-forward merges are often preferred in team collaboration for a few reasons:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 快速前进合并在团队协作中通常更受欢迎，原因有几个：
- en: '**Simplicity**: They keep the git history linear, which makes it easier to
    follow'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**：它们保持 Git 历史的线性，使得更容易跟踪'
- en: '**Transparency**: With a straightforward history, it is easier to track changes,
    debug issues, and understand the sequence of feature integrations'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明性**：通过清晰的历史记录，更容易追踪变更、调试问题，并理解功能集成的顺序'
- en: '**Efficiency**: Fast-forward merges eliminate the need for an extra merge commit,
    simplifying code reviews'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：快速前进合并消除了额外合并提交的需求，从而简化了代码审查'
- en: However, keep in mind that fast-forward merges are not always possible. You
    can use this way when you are developing with just yourself or when doing simple
    development, but in most development, there are many things going on in parallel.
    When simultaneous changes occur in the master and feature branches, a non-fast-forward
    merge, which is sometimes called a three-way merge, may be necessary.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，快速前进合并并非总是可行的。当你单独开发或进行简单开发时，可以使用这种方式，但在大多数开发中，通常有很多事情并行进行。当主分支和特性分支同时发生变更时，可能需要非快速前进合并，有时也称为三方合并。
- en: git merge --no-ff – Preserving branch history
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git merge --no-ff – 保留分支历史
- en: 'Non-fast-forward merges, commonly invoked with the `--no-ff` flag, offer an
    alternative merging strategy that differs from the fast-forward merges we discussed
    earlier. Unlike fast-forward merges, which move the tip of the targeted branch
    to the latest commit of the source branch, non-fast-forward merges generate a
    new merge commit. This new commit has two parent commits: one from the source
    branch and one from the target branch.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 非快进合并，通常通过`--no-ff`标志来调用，提供了一种与之前讨论的快进合并不同的合并策略。与快进合并不同，快进合并将目标分支的指针移动到源分支的最新提交，而非快进合并会生成一个新的合并提交。这个新的提交有两个父提交：一个来自源分支，一个来自目标分支。
- en: Non-fast-forward merges can embed context into the merge commit so that it is
    possible to look back later to see why this merge was performed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 非快进合并可以将上下文嵌入到合并提交中，以便以后回顾时查看为什么进行此合并。
- en: '![Figure 3.10 – Non-fast-forward merging](img/B21203_03_010.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 非快进合并](img/B21203_03_010.jpg)'
- en: Figure 3.10 – Non-fast-forward merging
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 非快进合并
- en: This approach keeps track of the fact that a feature branch was merged into
    the main branch, preserving the context in which past commits were made.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以追踪特性分支合并到主分支的事实，保留了过去提交时的上下文。
- en: Practical steps for non-fast-forward merging
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 非快进合并的实际步骤
- en: 'Let’s assume you are working with a `main` branch and `add-feature` branch.
    The following are the steps to perform a non-fast-forward merge:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在处理`main`分支和`add-feature`分支。以下是执行非快进合并的步骤：
- en: '[PRE2]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now the `commit` log is as shown in *Figure 3**.11*. What you did so far is
    the same as what you did in the `git merge --``ff` section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`commit`日志如*图 3.11*所示。到目前为止，你所做的与在`git merge --ff`部分所做的相同。
- en: '![Figure 3.11 – git merge --no-ff (1)](img/B21203_03_011.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – git merge --no-ff (1)](img/B21203_03_011.jpg)'
- en: Figure 3.11 – git merge --no-ff (1)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – git merge --no-ff (1)
- en: 'Then, let’s switch back to `main` and perform a **non-fast-forward** merge:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们切换回`main`并执行**非快进**合并：
- en: '[PRE3]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following edit message will appear in the terminal. Edit the commit message
    and save it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下编辑消息将出现在终端中。编辑提交信息并保存：
- en: '[PRE4]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After the edit, let’s see the log now:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑完成后，我们来看看当前的日志：
- en: '[PRE5]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Your repository history will show a new merge commit indicating where the `add-feature`
    branch was integrated into the `main` branch.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你的仓库历史将显示一个新的合并提交，指示`add-feature`分支是如何集成到`main`分支中的。
- en: '![Figure 3.12 – git merge --no-ff (2)](img/B21203_03_012.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – git merge --no-ff (2)](img/B21203_03_012.jpg)'
- en: Figure 3.12 – git merge --no-ff (2)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – git merge --no-ff (2)
- en: Why use non-fast-forward merges in DevOps and team collaboration?
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么在DevOps和团队协作中使用非快进合并？
- en: 'Non-fast-forward merges offer benefits that can be valuable in various DevOps
    and team collaboration scenarios:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 非快进合并提供的好处在各种DevOps和团队协作场景中都可能非常有价值：
- en: '**Context preservation**: Generating a new commit during the merging process
    preserves not just the code but the history and context as well. This clear record
    of integration makes it much easier to understand when and how changes from different
    branches were combined.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文保留**：在合并过程中生成一个新的提交，不仅保留了代码，还保留了历史和上下文。这种清晰的集成记录使得理解不同分支的更改何时以及如何被合并变得更加容易。'
- en: '`--no-ff` offers invaluable transparency, providing a clear record of who made
    what changes, when they made them, and why. This is particularly beneficial in
    larger teams and complex projects where it is crucial to understand the flow of
    contributions.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-ff`提供了无价的透明性，清晰地记录了谁在何时做了什么更改，以及为什么做这些更改。这在较大的团队和复杂项目中尤为重要，能够帮助理解贡献的流动。'
- en: While merge commits can provide rich context and history, they can also clutter
    the Git history if overused or poorly documented. It is important for teams to
    consider their merging strategy carefully and make concerted efforts to maintain
    a clean shared repository.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然合并提交可以提供丰富的上下文和历史记录，但如果过度使用或文档记录不充分，它们也可能会使Git历史记录变得杂乱。团队在选择合并策略时必须谨慎，并努力保持清洁的共享仓库。
- en: git merge --squash – Squashing complexity
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git merge --squash – 压缩复杂性
- en: The `git merge --squash` option provides a different merging technique that
    offers both clarity and tidiness. While fast-forward and non-fast-forward merges
    are excellent for tracking branch histories, there might be cases where you want
    to condense your `feature` branch changes into a single commit before merging.
    That’s where `git merge --``squash` shines.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`git merge --squash` 选项提供了一种不同的合并技术，它兼具清晰性和整洁性。虽然快进和非快进合并非常适合跟踪分支历史，但可能会有一些情况需要在合并之前将
    `feature` 分支的更改浓缩为一个提交。这时，`git merge --squash` 就发挥了作用。'
- en: In a squashed merge, all changes from the source (or feature) branch are combined
    into a single commit on the target (or main) branch. This action effectively condenses
    the feature branch history into one commit while merging, offering a clean, easy-to-follow
    Git history. This leaves the changes in an uncommitted state, allowing you to
    modify the differences before finalizing the commit.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在压缩合并中，源（或功能）分支上的所有更改都会合并为目标（或主）分支上的一个单一提交。此操作有效地将功能分支的历史浓缩为一个提交，同时进行合并，提供了一个干净、易于跟随的
    Git 历史。这使得更改处于未提交状态，允许你在最终提交之前修改差异。
- en: While teams are committed to maintaining a clean shared repository, individual
    development branches often become cluttered with various trial-and-error attempts.
    Squash merges contribute to preserving the cleanliness of the main code base by
    preventing these messy, experimental logs from infiltrating the production history.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管团队致力于保持干净的共享代码库，个别开发分支通常会因为各种尝试和错误而变得杂乱无章。压缩合并有助于通过防止这些杂乱的实验性日志进入生产历史，从而保持主代码库的整洁。
- en: The squash merge, as shown in the following figure, is in some ways the cleanest
    merge, and it has a lot of benefits. However, keep in mind that it is a way of
    incorporating changes that lose the previous change history and the commit history
    of other companies. This will be mentioned later in this section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，压缩合并在某些方面是最干净的合并方式，并且有很多好处。然而，请记住，它是一种合并更改的方式，丢失了之前的更改历史以及其他公司的提交历史。稍后将在本节中提到这一点。
- en: '![Figure 3.13 – Squash merging](img/B21203_03_013.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 压缩合并](img/B21203_03_013.jpg)'
- en: Figure 3.13 – Squash merging
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 压缩合并
- en: Practical steps for squash merging
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 压缩合并的实际步骤
- en: 'Let’s say you have a `main` branch and an `add-multiple-features` branch. To
    perform a squash merge, do the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个`main`分支和一个`add-multiple-features`分支。要执行压缩合并，请执行以下操作：
- en: '[PRE6]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now the branches should look like those in the following figure:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，分支应该像以下图所示：
- en: '![Figure 3.14 – git merge --squash (1)](img/B21203_03_014.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – git merge --squash (1)](img/B21203_03_014.jpg)'
- en: Figure 3.14 – git merge --squash (1)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – git merge --squash (1)
- en: 'Let’s switch back to the mainline and perform a `squash` merge:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们切换回主线并执行一个 `squash` 合并：
- en: '[PRE7]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The commits are then squashed and become a single commit:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些提交将被压缩并成为一个单一的提交：
- en: '![Figure 3.15 – git merge --squash (2)](img/B21203_03_015.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.15 – git merge --squash (2)](img/B21203_03_015.jpg)'
- en: Figure 3.15 – git merge --squash (2)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.15 – git merge --squash (2)
- en: 'Then, Git will add uncommitted changes to the `main` branch. It is time to
    complete the merge process. To complete the merge, you need to commit those uncommitted
    changes:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Git 会将未提交的更改添加到 `main` 分支。此时是完成合并过程的时候了。要完成合并，你需要提交这些未提交的更改：
- en: '[PRE8]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will combine all the changes from the `add-multiple-features` branch into
    a single new commit on the `main` branch:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把 `add-multiple-features` 分支的所有更改合并为 `main` 分支上的一个新提交：
- en: '![Figure 3.16 – git merge --squash (3)](img/B21203_03_016.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.16 – git merge --squash (3)](img/B21203_03_016.jpg)'
- en: Figure 3.16 – git merge --squash (3)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16 – git merge --squash (3)
- en: Why use squash merges in DevOps and team collaboration?
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么在 DevOps 和团队协作中使用压缩合并？
- en: 'Squash merges offer a unique set of benefits for DevOps and collaborative development:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩合并为 DevOps 和协作开发提供了一套独特的好处：
- en: '**Atomic changes**: A squashed merge creates a single commit that contains
    all the feature changes, making it easier to roll back if needed.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性更改**：压缩合并会创建一个包含所有功能更改的单一提交，这样在需要回滚时会更加方便。'
- en: '**Reduced noise**: Squash merges eliminate the clutter of many small, perhaps
    experimental, commits from the main branch. This makes for a cleaner log history
    that’s easier to read and understand.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少噪音**：压缩合并消除了来自主分支的许多小的、可能是实验性的提交的杂乱无章。这使得日志历史更加清晰，便于阅读和理解。'
- en: '**Strategic commit messages**: Squashing allows you to create a comprehensive
    commit message that can encapsulate the purpose and impact of a feature more effectively
    than a series of smaller commits.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**战略性提交信息**：squash 使你能够创建一条综合性的提交信息，比一系列小的提交信息更有效地概括功能的目的和影响。'
- en: However, it is worth noting that while squash merges can simplify history, they
    can also obfuscate it. Individual commits from the feature branch are lost in
    the main branch, making it hard to understand the development context of each
    separate change. Use this merge strategy judiciously and understand its impact
    on your development history.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，虽然 squash 合并可以简化历史，但它也可能会使历史变得模糊。来自功能分支的单独提交会在主分支中丢失，这使得理解每个单独更改的开发背景变得困难。在使用这种合并策略时，要谨慎并了解它对开发历史的影响。
- en: The ethics and pitfalls of squash merging
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: squash 合并的伦理问题与陷阱
- en: Squashing someone else’s commits can sometimes be problematic.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: squash 其他人的提交有时可能会带来问题。
- en: The `git merge --squash` command is a powerful tool for consolidating multiple
    commits into a single one. While this function keeps your commit history clean
    and manageable, it raises ethical and practical issues when used on commits made
    by others.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`git merge --squash` 命令是一个强大的工具，可以将多个提交合并成一个。虽然此功能能保持提交历史的清晰和可管理性，但当用于其他人提交时，它会引发伦理和实际问题。'
- en: 'It is important to be aware of the following concerns in team collaboration:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队协作中，了解以下问题非常重要：
- en: '**Authorship misattribution**: By default, the person who performs the squash
    becomes the author of the consolidated commit, effectively erasing the original
    contributors’ history. This could demotivate team members by not recognizing their
    contributions.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作者归属错误**：默认情况下，执行 squash 的人将成为合并提交的作者，从而有效地抹去原始贡献者的历史。这可能会使团队成员感到沮丧，因为他们的贡献没有得到认可。'
- en: '**History alteration**: The command alters the commit history, which could
    be considered disrespectful to the original author’s work.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史篡改**：该命令会改变提交历史，这可能会被认为是不尊重原作者工作的行为。'
- en: If maintaining the integrity of individual commits is important, consider using
    a standard merge. This may result in a messier history, but it preserves the work
    and recognition of all contributors.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果保持单独提交的完整性很重要，考虑使用标准合并。这可能会导致历史更为复杂，但它能保留所有贡献者的工作和认可。
- en: Additionally, the `git rebase` command offers more control over the commit history,
    which is useful for cleaning up or rearranging your own work without affecting
    others.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`git rebase` 命令提供了对提交历史的更多控制，这对于清理或重新安排自己的工作而不影响他人非常有用。
- en: Let’s explore this command next.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们探索这个命令。
- en: git rebase – Rewriting for clarity
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git rebase – 以便清晰的方式重写
- en: Rebasing is another powerful technique in Git that differs significantly from
    merging. The primary difference between merging and rebasing is how they integrate
    changes. While `git merge` integrates changes from one branch into another, `git
    rebase` moves or combines a sequence of commits to a new base commit.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Rebase 是 Git 中另一种强大的技巧，它与合并有显著的不同。合并和 rebase 之间的主要区别在于它们整合更改的方式。`git merge`
    将一个分支的更改合并到另一个分支，而 `git rebase` 则是将一系列提交移动或合并到新的基础提交上。
- en: In the team collaboration context, rebasing is used to maintain a linear project
    history, which simplifies debugging and makes code reviews easier. However, rebase
    comes with its share of complexities and pitfalls and is generally best used in
    specific circumstances.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队协作的背景下，rebase 用于保持线性的项目历史，这可以简化调试并使代码审查变得更容易。然而，rebase 也有其复杂性和陷阱，通常最好在特定情况下使用。
- en: Before delving into the hands-on tutorial, let’s understand how `git rebase`
    works at a high level. The primary utility of rebasing is to place the changes
    from the `feature` branch on top of another branch.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入实践教程之前，让我们先大致了解一下 `git rebase` 的工作原理。rebase 的主要用途是将 `feature` 分支的更改放到另一个分支的顶部。
- en: 'For example, consider the following branches:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下分支：
- en: '![Figure 3.17 – Rebasing (1)](img/B21203_03_017.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.17 – Rebase (1)](img/B21203_03_017.jpg)'
- en: Figure 3.17 – Rebasing (1)
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17 – Rebase (1)
- en: 'After rebasing `feature` onto `main`, your branch might look like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `feature` 分支 rebase 到 `main` 后，你的分支可能看起来像这样：
- en: '![Figure 3.18 – Rebasing (2)](img/B21203_03_018.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.18 – Rebase (2)](img/B21203_03_018.jpg)'
- en: Figure 3.18 – Rebasing (2)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18 – Rebase (2)
- en: 'Finally, you can merge back to main, at which point a fast-forward merge can
    be performed:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以合并回主分支，此时可以进行快速合并：
- en: '![Figure 3.19 – Rebasing (3)](img/B21203_03_019.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.19 – Rebasing (3)](img/B21203_03_019.jpg)'
- en: Figure 3.19 – Rebasing (3)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.19 – Rebasing (3)
- en: Practical steps for git rebase
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: git rebase的实际步骤
- en: 'Let’s take a practical example with a `main` branch and a `new-feature` branch.
    Here’s how to perform rebase:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个`main`分支和`new-feature`分支为例，来看一下如何进行rebase：
- en: '[PRE9]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this point, your branch history may look something like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你的分支历史可能会像这样：
- en: '![Figure 3.20 – git rebase (1)](img/B21203_03_020.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.20 – git rebase (1)](img/B21203_03_020.jpg)'
- en: Figure 3.20 – git rebase (1)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.20 – git rebase (1)
- en: 'Now, let’s say new commits have been added to `main` while you were working
    on `new-feature`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设在你工作在`new-feature`时，`main`上添加了新的提交：
- en: '[PRE10]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Your commit graph now diverges:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 你的提交图现在已经分叉：
- en: '![Figure 3.21 – git rebase (2)](img/B21203_03_021.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.21 – git rebase (2)](img/B21203_03_021.jpg)'
- en: Figure 3.21 – git rebase (2)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.21 – git rebase (2)
- en: 'Now, rebase `new-feature` onto `main`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`new-feature`分支rebase到`main`分支：
- en: '[PRE11]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s check what it looks like now:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在的情况：
- en: '[PRE12]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After this, your branches will look as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你的分支将如下所示：
- en: '![Figure 3.22 – git rebase (3)](img/B21203_03_022.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.22 – git rebase (3)](img/B21203_03_022.jpg)'
- en: Figure 3.22 – git rebase (3)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – git rebase (3)
- en: 'Now it is time to merge and complete the `git` `rebase` process:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候合并并完成`git` `rebase`过程了：
- en: '[PRE13]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When a fast-forward merge is performed, the HEADs of the `main` and `new-feature`
    branches will be the corresponding commits, as shown:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行快进合并时，`main`和`new-feature`分支的HEAD将是相应的提交，如下所示：
- en: '![Figure 3.23 – git rebase (4)](img/B21203_03_023.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.23 – git rebase (4)](img/B21203_03_023.jpg)'
- en: Figure 3.23 – git rebase (4)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.23 – git rebase (4)
- en: Why rebasing is powerful in DevOps and team collaboration
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么在DevOps和团队协作中，rebase是强大的
- en: The primary advantage of rebasing in a DevOps culture is that it results in
    a much cleaner project history than merging. Cleaner histories are easier to debug
    and simpler to understand, and they make more logical sense to developers who
    join the project at a later time.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevOps文化中，rebase的主要优势是它比合并产生更干净的项目历史。更清晰的历史记录更容易调试，更易理解，并且对于后期加入项目的开发者来说更具逻辑性。
- en: 'Here are some benefits:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些好处：
- en: '**Linear history**: It is easier to understand than the non-linear history
    created by git merge'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性历史**：比git merge创建的非线性历史更容易理解。'
- en: '**Simplified debugging**: With a cleaner history, tracking down when a particular
    bug was introduced becomes easier'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简化调试**：历史记录更干净后，追踪某个特定bug何时被引入变得更容易。'
- en: '**Code hygiene**: Rebasing encourages you to squash fixup commits or split
    larger commits, making your changes more understandable compared to the other
    developers’'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码整洁**：rebase鼓励你合并修复提交或拆分较大的提交，使得你的修改比其他开发者的更容易理解。'
- en: The cautions and pitfalls of git rebase
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: git rebase的注意事项和陷阱
- en: 'There are golden rules to follow: *do not rebase public (team) branches*. One
    such cardinal rule is to avoid rebasing public branches. Rebasing can be a great
    tool for cleaning up a feature branch, but when done on branches that are publicly
    available, it can become a disaster.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些黄金规则需要遵循：*不要rebase公共（团队）分支*。其中一条基本规则是避免对公共分支进行rebase。rebase对于清理功能分支是一个非常好的工具，但在公共分支上使用时，它可能会变成灾难。
- en: 'Here are the things to consider when you use `git rebase`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`git rebase`时需要考虑的事项：
- en: '**Conflicts for collaborators**: Imagine that you have rebased a public branch
    and pushed the changes. Other developers who have already pulled the old version
    of the branch now have a divergent history. When they try to push their changes,
    Git will reject the push, forcing them to reconcile the histories. This creates
    extra work and increases the chance of merge conflicts.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队协作中的冲突**：假设你已经rebase了一个公共分支并推送了更改。其他已经拉取了该分支旧版本的开发者，现在会有一个分叉的历史。当他们尝试推送他们的更改时，Git会拒绝推送，迫使他们合并历史。这会增加额外的工作量并增加合并冲突的可能性。'
- en: '**Complex merges**: After a public branch has been rebased and the history
    altered, merging it with other branches can become a real challenge. Because Git
    uses the commit history to determine how to integrate changes, modifying that
    history can make merging far more complicated than it needs to be.'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复杂的合并**：在公共分支已经rebase并且历史被修改后，将其与其他分支合并可能会变得非常具有挑战性。因为Git使用提交历史来确定如何整合更改，修改历史可能会使合并变得比需要的复杂得多。'
- en: '**Loss of context**: Rebasing can squash commits together or change their order,
    which may result in a loss of context for those changes. This makes debugging
    more difficult and can complicate the task of understanding the development process
    that led to the current code base.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文丢失**：Rebase 可能会将提交合并在一起或更改它们的顺序，这可能导致这些更改的上下文丢失。这会使调试变得更加困难，并且可能使理解导致当前代码库的开发过程变得复杂。'
- en: Rebasing can be complex and risky, especially for inexperienced developers.
    In worst-case scenarios, you may have to resolve many conflicts, leading to errors
    and bugs if not done carefully.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Rebase 可能会很复杂且有风险，特别是对于缺乏经验的开发者来说。在最坏的情况下，你可能需要解决许多冲突，如果不小心处理，可能会导致错误和 bug。
- en: By understanding and using `git merge` and `git rebase`, you can handle pretty
    much any situation that requires combining different lines of development. Each
    has its place in a Git command, and understanding when to use each one is the
    key to maintaining a clean and understandable code base—something that is highly
    valuable in the world of DevOps.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解并使用 `git merge` 和 `git rebase`，你可以处理几乎所有需要合并不同开发线的情况。每个命令在 Git 中都有其适用的场合，理解何时使用哪个命令是保持代码库干净且易于理解的关键——这在
    DevOps 的世界中非常宝贵。
- en: git cherry-pick – Picking specific commits
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git cherry-pick – 选择特定的提交
- en: One of the most flexible tools in the Git commands is the `git cherry-pick`
    command. While the previous merge methods were mainly used for integrating entire
    branches, `git cherry-pick` allows you to select specific commits from one branch
    and apply them to another branch. This method can be incredibly useful when you
    need to apply just a few specific changes without taking all the modifications
    from a different branch.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Git 命令中最灵活的工具之一就是 `git cherry-pick` 命令。虽然之前的合并方法主要用于集成整个分支，`git cherry-pick`
    允许你选择一个分支中的特定提交并将其应用到另一个分支。此方法在你只需要应用几个特定更改而不是将另一个分支的所有修改都带入时非常有用。
- en: 'Imagine you have two branches, `main` and `feature`. You realize that one or
    two commits from the `feature` branch should be moved to `main`, but you are not
    ready to merge the entire branch. The `git cherry-pick` command allows you to
    do just that:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个分支，`main` 和 `feature`。你意识到 `feature` 分支中的一个或两个提交应该被移动到 `main`，但你还不准备合并整个分支。`git
    cherry-pick` 命令正好允许你做到这一点：
- en: '![Figure 3.24 – Cherry-picking (1)](img/B21203_03_024.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.24 – Cherry-picking（1）](img/B21203_03_024.jpg)'
- en: Figure 3.24 – Cherry-picking (1)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.24 – Cherry-picking（1）
- en: 'You can cherry-pick the changes from a specific commit in the `feature` branch
    and apply them to `main`. This action will create a new commit on the `main` branch:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `feature` 分支中某个特定提交的更改 cherry-pick 到 `main` 分支上。此操作将在 `main` 分支上创建一个新的提交：
- en: '![Figure 3.25 – Cherry-picking (2)](img/B21203_03_025.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.25 – Cherry-picking（2）](img/B21203_03_025.jpg)'
- en: Figure 3.25 – Cherry-picking (2)
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.25 – Cherry-picking（2）
- en: Practical steps for cherry-picking
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Cherry-picking 的实际步骤
- en: 'Now let’s go over the practical steps for cherry-picking changes and merging
    them into a branch. Each commit adds a file to each of them. Let’s take some of
    those commits and merge them into `main`. First, we add the files:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看 cherry-pick 更改并将它们合并到分支中的实际步骤。每个提交都会向每个分支添加一个文件。我们将这些提交中的一部分合并到 `main`。首先，我们添加这些文件：
- en: '[PRE14]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now the branches look like those in the following diagram:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些分支看起来像下图所示：
- en: '![Figure 3.26 – git cherry-pick (1)](img/B21203_03_026.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.26 – git cherry-pick（1）](img/B21203_03_026.jpg)'
- en: Figure 3.26 – git cherry-pick (1)
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.26 – git cherry-pick（1）
- en: 'Now, let’s only pick the `a80e8ad` commit and put it on the `main` branch.
    Please replace the hash value in your environment:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们只选择 `a80e8ad` 提交并将其放到 `main` 分支上。请在你的环境中替换哈希值：
- en: '[PRE15]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After you have successfully cherry-picked the commit, a new commit will be
    added to your current branch (`main` in this example) and it will include the
    changes from the cherry-picked commit. Note that the new commit has the same changes
    but a different commit hash value:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在你成功 cherry-pick 该提交后，一个新的提交将被添加到你当前的分支（在此示例中为 `main`），并且该提交将包含 cherry-pick
    提交中的更改。请注意，新的提交包含相同的更改，但有不同的提交哈希值：
- en: '![Figure 3.27 – git cherry-pick (2)](img/B21203_03_027.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.27 – git cherry-pick（2）](img/B21203_03_027.jpg)'
- en: Figure 3.27 – git cherry-pick (2)
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27 – git cherry-pick（2）
- en: Why cherry-pick is useful in DevOps and team collaboration
  id: totrans-313
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么 cherry-pick 在 DevOps 和团队协作中很有用
- en: Team development requires flexible development. `git cherry-pick` is a useful
    command in collaborative coding environments, allowing teams to selectively integrate
    changes and maintain code integrity.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 团队开发需要灵活的开发方式。`git cherry-pick` 是一个在协作编码环境中非常有用的命令，允许团队选择性地整合变更并保持代码的完整性。
- en: 'Let’s see what value `cherry-pick` can offer:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `cherry-pick` 可以提供什么价值：
- en: '**Selective integration**: It allows specific bug fixes or features to be moved
    into production without having to move all changes from a development branch'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择性集成**：它允许特定的 bug 修复或功能被移入生产环境，而不需要将所有开发分支的变更一起移动。'
- en: '**Easy reversion**: If something goes wrong, you only need to revert a small
    change rather than an entire branch merge'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松回退**：如果出现问题，你只需要回退一个小的变更，而不是整个分支合并。'
- en: '**Clean history**: Keeps your Git history tidy by only including relevant commits,
    making it easier to read and understand'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清理历史**：通过仅包含相关的提交，保持 Git 历史的整洁，使其更易于阅读和理解。'
- en: '`git cherry-pick` offers a high level of precision for integrating changes
    between branches. It allows you to select exactly which commits to include, providing
    granular control over your project history. This makes it an invaluable tool for
    any DevOps engineer aiming for a flexible and efficient version control workflow.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`git cherry-pick` 提供了高精度的分支间变更集成方式。它允许你精确选择要包含的提交，提供对项目历史的细粒度控制。这使得它成为任何 DevOps
    工程师在追求灵活且高效的版本控制工作流时的宝贵工具。'
- en: After exploring the various merging strategies in Git, you might be asking yourself,
    “*Which method should I use?*” The answer, as with most things in engineering,
    is, “*It depends.*” Several factors come into play when determining which Git
    merge strategy best suits your needs. Additionally, it is worth noting that you
    do not have to stick to a single method; you can vary your approach depending
    on the situation. Understanding these factors can help you make an informed decision.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了 Git 中的各种合并策略之后，你可能会问自己：“*我应该使用哪种方法？*” 答案就像大多数工程问题一样，“*这取决于情况。*” 有多个因素在决定最适合你需求的
    Git 合并策略时起作用。此外，值得注意的是，你不必坚持使用单一方法；你可以根据情况调整你的方法。理解这些因素可以帮助你做出明智的决定。
- en: 'Let’s check the following factors to see how you should choose:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查以下因素，看看你应该如何选择：
- en: '**Project complexity**: Complex projects with multiple contributors and parallel
    development lines may require a more consistent merging approach to minimize conflicts.
    Platforms such as GitHub allow you to set merge strategies for your projects.'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目复杂性**：具有多个贡献者和并行开发线的复杂项目可能需要更一致的合并方式，以减少冲突。像 GitHub 这样的平台允许你为项目设置合并策略。'
- en: '`git merge` can reduce the chances of mistakes. However, if the majority of
    the team is experienced, you may want to leverage the benefits of `rebase` to
    maintain a cleaner Git history while also facilitating smoother communication.'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git merge` 可以减少错误发生的几率。然而，如果大多数团队成员都有经验，你可能会想利用 `rebase` 的优势，以保持更清晰的 Git 历史，并促进更顺畅的沟通。'
- en: '**Desired cleanliness of Git history**: If a clean, linear Git history is of
    utmost importance to you, then opting for fast-forward merges or rebasing might
    be the best route. On the other hand, if you value detailed documentation of your
    project’s development process, a non-fast-forward merge would be a better choice
    for maintaining a comprehensive record of changes.'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git 历史的期望清晰度**：如果你非常重视清晰、线性的 Git 历史，那么选择快进合并或 rebase 可能是最好的方法。另一方面，如果你更看重项目开发过程的详细记录，那么非快进合并会更适合，能更好地保留变更的全面记录。'
- en: As you move forward, let the knowledge from this section guide you in choosing
    the appropriate merge approach for your projects. Practice with real-world scenarios
    to gain confidence. Remember, there is no one-size-fits-all answer in Git—flexibility
    and adaptability are your allies
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你前进，让这一节中的知识帮助你选择适合你项目的合并方法。通过实际场景练习来增强信心。记住，在 Git 中没有“一刀切”的答案——灵活性和适应性是你最好的盟友。
- en: Navigating conflicts
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决冲突
- en: In a collaborative development environment, conflicts are not just possible—they
    are inevitable. When multiple developers are working on the same code base, or
    even the same files, there is a good chance that changes will overlap, leading
    to conflicts. Navigating and resolving these conflicts is crucial for maintaining
    a smooth and efficient DevOps workflow.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个协作开发环境中，冲突不仅仅是可能的——它们是不可避免的。当多个开发者在相同的代码库上工作，甚至是在相同的文件上进行修改时，很有可能会发生变化重叠，导致冲突。处理和解决这些冲突对于保持顺畅和高效的
    DevOps 工作流程至关重要。
- en: Why conflict happens
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么会发生冲突
- en: Conflicts generally occur when two branches have changes in the same line or
    section of a file and are then attempted to be merged. Git, as sophisticated as
    it is, can not decide which change to take precedence. The key to efficiently
    resolving these conflicts is understanding why they occur and being proactive
    in preventing them when possible.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突通常发生在两个分支对文件的同一行或部分进行更改，然后尝试进行合并时。尽管 Git 非常强大，但它无法判断哪个更改应该优先。高效解决这些冲突的关键是理解冲突发生的原因，并尽可能主动预防它们。
- en: How to merge conflicts in Git
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何解决 Git 中的合并冲突
- en: 'Let’s start with the basics. Conflict resolution in Git usually involves manual
    intervention. Here is how to go about it:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础开始。Git 中的冲突解决通常需要手动干预。以下是如何进行处理的步骤：
- en: Identify conflicts. Use `git status` to see which files are conflicted.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别冲突。使用 `git status` 查看哪些文件发生了冲突。
- en: 'Examine the conflicted files. Open them up and look for the conflict markers
    (`<<<<<<<`, `=======`, and `>>>>>>>`). These markers delineate the changes from
    the different branches:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查发生冲突的文件。打开文件并查找冲突标记（`<<<<<<<`、`=======` 和 `>>>>>>>`）。这些标记区分了来自不同分支的更改：
- en: '[PRE16]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Resolve the conflicts. Choose which changes to keep. You can keep the changes
    from one branch, mix both, or even add something entirely new.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决冲突。选择保留哪些更改。你可以保留某个分支的更改，混合两者的更改，甚至添加全新的内容。
- en: Commit the resolved files. After resolving, you need to add the files to the
    staging area and commit them.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交已解决的文件。解决冲突后，需要将文件添加到暂存区并提交。
- en: How to resolve merge conflicts
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何解决合并冲突
- en: Merge conflicts are inevitable in a collaborative development environment. The
    key is knowing how to resolve them efficiently. There are several patterns you
    can follow, depending on the nature of the conflict.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在协作开发环境中，合并冲突是不可避免的。关键在于知道如何高效地解决它们。根据冲突的性质，你可以遵循几种不同的解决模式。
- en: When there is a definitive version to retain
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当有一个明确的版本需要保留时
- en: 'If you have merged two branches and want to fully accept one version over the
    other, you can opt to use `git checkout --ours` or `git` `checkout --theirs`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经合并了两个分支，并希望完全接受其中一个版本而忽略另一个版本，可以选择使用 `git checkout --ours` 或 `git checkout
    --theirs`：
- en: '`checkout --ours`: Use this command to keep the files from your branch when
    a merge conflict arises:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkout --ours`：当发生合并冲突时，使用此命令保留你分支的文件：'
- en: '[PRE17]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: $ git checkout --theirs -- <file-path>
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: $ git checkout --theirs -- <file-path>
- en: '[PRE18]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After running one of these commands, you will need to add the updated files
    to the staging area and then commit them.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这些命令之一后，你需要将更新后的文件添加到暂存区并提交。
- en: When you need to evaluate both versions
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当你需要评估两个版本时
- en: In cases where it is not clear which version should take precedence, a more
    nuanced approach is required.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不清楚应该优先采用哪个版本，则需要更细致的处理方法。
- en: '**Review the code**: Open the conflicting files in a text editor to manually
    inspect the clashing lines of code. Decide which parts to keep and edit the files
    accordingly.'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审查代码**：在文本编辑器中打开冲突文件，手动检查冲突的代码行。决定保留哪些部分并相应地编辑文件。'
- en: '**Communication**: If necessary, consult with your teammates to decide which
    changes should be kept. This can be done through in-person discussions, virtual
    meetings, or code review tools.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沟通**：如果有必要，与你的团队成员协商，决定保留哪些更改。可以通过面对面的讨论、虚拟会议或代码审查工具进行此操作。'
- en: '**Run tests**: Once you have resolved the conflicts manually, it is crucial
    to run tests to ensure that the code base is still stable.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行测试**：一旦你手动解决了冲突，运行测试是非常重要的，以确保代码库仍然稳定。'
- en: '**Commit the changes**: After successful testing, stage the resolved files
    and commit them to your repository.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提交更改**：在成功测试后，将已解决的文件暂存并提交到你的代码库。'
- en: By carefully handling merge conflicts, you can help maintain a clean code base
    and foster better communication within your team.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 通过小心处理合并冲突，你可以帮助保持干净的代码库，并促进团队内部更好的沟通。
- en: Useful commands for supporting merge activities
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持合并活动的有用命令
- en: Merging is an activity that comes with its own set of challenges. Having the
    right set of tools and commands at your disposal can make the process smoother
    and less error-prone. In this section, there are some useful Git commands that
    can help you effectively manage your merges.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 合并是一个充满挑战的活动。拥有合适的工具和命令可以让这个过程更加顺利，减少出错的机会。在这一节中，我们将介绍一些有用的 Git 命令，帮助你有效管理合并。
- en: git diff – Spot the difference
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git diff – 查找差异
- en: The `git diff` command is an essential tool for identifying the differences
    between two sets of code. It helps you see what exactly has changed between two
    branches or two commits, making it much easier to resolve conflicts when they
    arise.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`git diff` 命令是一个用于识别两组代码差异的关键工具。它帮助你查看两者之间究竟发生了什么更改，使得在冲突出现时更容易解决问题。'
- en: 'You can compare the current branch to a target branch like so:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下方式将当前分支与目标分支进行比较：
- en: '[PRE19]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command displays a line-by-line comparison of the changes between `feature-branch`
    and `main`. You can also focus on specific files or even specific lines of code,
    which makes it a flexible tool for spotting differences at various granularities.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令逐行显示 `feature-branch` 和 `main` 之间的更改对比。你也可以专注于特定的文件，甚至是特定的代码行，这使它成为一个灵活的工具，可以在不同的粒度下发现差异。
- en: 'Although Git does not have a built-in dry-run option for `git merge`, you can
    simulate a merge to see what will happen:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Git 没有内置 `git merge` 的 dry-run 选项，你可以模拟一次合并以查看会发生什么：
- en: '[PRE20]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This command sequence attempts to merge changes from develop into your current
    branch but stops just before committing them. You can then use `git diff --cached`
    to view the staged changes. If the merge is not what you expected, you can simply
    abort:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令序列尝试将 `develop` 的更改合并到当前分支，但会在提交之前停止。你可以使用 `git diff --cached` 查看已暂存的更改。如果合并结果不符合预期，你可以简单地中止：
- en: '[PRE21]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: git mergetool – A simplified guide tooling to visual conflict resolution
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git mergetool – 简化的工具指南，用于可视化冲突解决
- en: When you run into a merge conflict that’s challenging to resolve manually, or
    if you are more comfortable with a graphical interface, Git’s built-in `git mergetool`
    can come to your rescue.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到一个难以手动解决的合并冲突，或者你更喜欢图形界面时，Git 内置的 `git mergetool` 可以帮助你解决问题。
- en: 'The following items can be set:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置以下项：
- en: '`kdiff3`, `meld`, and `vimdiff`.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kdiff3`，`meld`，和 `vimdiff`。'
- en: '**Global configuration**: Set your chosen tool as the default for all your
    Git repositories with the following command:'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局配置**：使用以下命令将你选择的工具设置为所有 Git 仓库的默认工具：'
- en: '[PRE22]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command opens your chosen graphical tool and displays the conflicting changes
    side by side. This interface simplifies the process of understanding conflicts
    and deciding which changes to keep. This setting allows you to specify not only
    command line tools but also modern tools such as Visual Studio Code to resolve
    merges graphically.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该命令打开你选择的图形工具，并并排显示冲突的更改。这个界面简化了理解冲突的过程，并帮助你决定保留哪些更改。这个设置允许你指定不仅是命令行工具，还可以指定像
    Visual Studio Code 这样的现代工具，以图形化方式解决合并。
- en: By following these straightforward steps, you can resolve complex merge conflicts
    in a more intuitive way, making the process accessible for team members of all
    skill levels.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遵循这些简单的步骤，你可以以更直观的方式解决复杂的合并冲突，使这个过程对于所有技能水平的团队成员都变得更加可访问。
- en: In a nutshell, conflict resolution is an essential skill for any engineer. While
    conflicts can be complex and challenging, knowing how to navigate them efficiently
    can make your development workflow much smoother. It is not just about resolving
    the conflicts themselves but understanding the underlying issues that lead to
    them. This nuanced approach is crucial for fostering better communication and
    collaboration within your development team.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，冲突解决是任何工程师必备的技能。尽管冲突可能复杂且具有挑战性，但知道如何高效地解决冲突，可以让你的开发工作流程更加顺畅。这不仅仅是关于解决冲突本身，而是理解导致冲突的根本问题。这种细致的方法对促进团队之间更好的沟通和合作至关重要。
- en: As team development progresses, projects become more complex. Conflicts are
    inevitable. Conflict is a great opportunity to help your team to improve its collaboration
    skills. You should not be afraid of conflicts, and you should also learn how to
    communicate best for your team by solving them one by one.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 随着团队开发的推进，项目变得越来越复杂。冲突是不可避免的。冲突是一个很好的机会，帮助团队提升协作能力。你不应该害怕冲突，应该学会如何通过逐一解决它们来帮助团队进行更好的沟通。
- en: Mastering better collaboration
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精通更好的协作
- en: Up until now, we have discussed how to handle merges and resolve conflicts in
    Git. We have seen that you can clean up your local changes with `git merge --squash`
    or adjust commit history with `git rebase`. While it is great to keep your workspace
    neat, the ideal scenario is to maintain a clean code base, especially when you
    push to a shared environment. Next, let’s talk about the commands that enable
    you to be an excellent collaborator, whether you are an individual contributor
    or a team leader managing the main shared branch.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了如何在 Git 中处理合并并解决冲突。我们已经看到，你可以使用 `git merge --squash` 清理本地更改，或者使用
    `git rebase` 调整提交历史。虽然保持工作区整洁是很好的，但理想的情况是保持代码库的干净，尤其是在推送到共享环境时。接下来，让我们讨论一下可以帮助你成为一个优秀协作者的命令，无论你是个人贡献者还是管理主共享分支的团队领导。
- en: Rolling back time
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚时间
- en: In any collaborative project, mistakes are inevitable. Even if it was not a
    mistake, there will be many times you will want to rewind and go back in time.
    Whether it is a bad commit that breaks the build or a feature that did not pan
    out as expected, the ability to roll back changes is crucial. Two commands that
    are indispensable for this are `git reset` and `git revert`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何协作项目中，错误是不可避免的。即使不是错误，很多时候你也会想要回退并回到过去。无论是一个破坏构建的错误提交，还是一个未能按预期实现的功能，回滚更改的能力至关重要。两个不可或缺的命令就是
    `git reset` 和 `git revert`。
- en: git reset – Rolling back changes
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git reset – 回滚更改
- en: 'The `git reset` command allows you to *rewind* your Git history, essentially
    moving HEAD and, optionally, the working directory to a specific commit. This
    is incredibly powerful but should be used cautiously. There are several different
    ways to use `git reset`. Know them so that you can organize your environment efficiently:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`git reset` 命令允许你*回退* Git 历史，本质上是将 HEAD 和可选的工作目录移动到某个特定的提交。这是一个非常强大的功能，但需要谨慎使用。有几种不同的方式可以使用
    `git reset`。了解它们，以便你能有效地组织你的环境：'
- en: '**Soft reset**: This keeps your working directory and index intact but moves
    HEAD. This command is used when you want to leave the index working tree untouched
    and only undo the commit:'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软重置**：这会保持工作目录和索引不变，但会移动 HEAD。此命令用于当你只想撤销提交，而不影响索引工作树时：'
- en: '[PRE23]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Figure 3.28 – git reset --soft](img/B21203_03_028.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.28 – git reset --soft](img/B21203_03_028.png)'
- en: Figure 3.28 – git reset --soft
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.28 – git reset --soft
- en: '`git add` and `git commit`. File changes will remain; this is the default when
    no options are specified with `git reset`:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git add` 和 `git commit`。文件更改将保持不变；这是在 `git reset` 未指定任何选项时的默认行为：'
- en: '[PRE24]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![Figure 3.29 – git reset --mixed](img/B21203_03_029.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.29 – git reset --mixed](img/B21203_03_029.jpg)'
- en: Figure 3.29 – git reset --mixed
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.29 – git reset --mixed
- en: '**Hard reset**: This resets the index and working directory, permanently deleting
    uncommitted changes. It deletes all changes to commits, indexes, and files, so
    all the changes themselves do not remain with you. If you want to delete everything,
    this is the way to do it:'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬重置**：这会重置索引和工作目录，永久删除未提交的更改。它会删除所有提交、更改和文件，因此所有更改将不再保留。如果你想删除所有内容，这就是方法：'
- en: '[PRE25]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![Figure 3.30 – git reset --hard](img/B21203_03_030.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.30 – git reset --hard](img/B21203_03_030.jpg)'
- en: Figure 3.30 – git reset --hard
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.30 – git reset --hard
- en: git revert – Undoing without rewriting history
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git revert – 在不重写历史的情况下撤销更改
- en: Unlike `git reset`, which alters commit history, `git revert` creates a new
    commit that undoes the changes made by a previous commit. This is extremely useful
    in a shared environment where rewriting history is highly discouraged.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `git reset` 不同，后者会更改提交历史，`git revert` 创建一个新的提交来撤销之前提交所做的更改。这在共享环境中非常有用，因为重写历史是不被鼓励的。
- en: '`git revert` creates a reverse commit as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`git revert` 会创建一个相反的提交，如下所示：'
- en: '![Figure 3.31 – git-revert creates a commit to cancel the commit](img/B21203_03_031.jpg)'
  id: totrans-395
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.31 – git-revert 创建一个提交来取消该提交](img/B21203_03_031.jpg)'
- en: Figure 3.31 – git-revert creates a commit to cancel the commit
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.31 – git-revert 创建一个提交来取消该提交
- en: 'This command will undo the changes made by the commit with the specified hash
    and create a new commit to record this action:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将撤销指定哈希的提交所做的更改，并创建一个新的提交来记录此操作：
- en: '[PRE26]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following are cases when you can use `git revert`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以使用 `git revert` 的情况：
- en: '`git revert` does not rewrite history, it is safe to use on shared branches'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git revert` 不会重写历史，因此在共享分支上使用是安全的'
- en: '`git revert` is a clean way to remove it'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git revert` 是一种干净的删除方法'
- en: '`git revert` operation as part of your rollback strategy'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git revert` 操作作为回滚策略的一部分'
- en: 'Let’s learn about some additional advanced `git` `revert` options:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解一些额外的高级`git revert`选项：
- en: '**Reverting multiple commits**: You can revert a range of commits by specifying
    a commit range:'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回退多个提交**：你可以通过指定提交范围来回退一系列提交：'
- en: '[PRE27]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: git revert -n <commit_hash>
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: git revert -n <commit_hash>
- en: '[PRE28]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note the caret (`^`) symbol. This means the oldest commit in the range of commits
    to revert is included.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意插入符号（`^`）。这意味着回退范围内的最旧提交也会被包括在内。
- en: Mastering `git revert` is crucial for any developer or DevOps professional.
    It provides a safe mechanism for undoing changes, enabling better collaboration
    and more reliable code.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握`git revert`对任何开发者或DevOps专业人员来说都至关重要。它提供了一种安全的机制来撤销更改，促进更好的协作和更可靠的代码。
- en: git checkout – More than just branch hopping
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git checkout – 不只是切换分支
- en: In previous discussions, we have touched on the `git checkout` command mainly
    in the context of switching between branches. While this is certainly one of its
    primary functions, it is crucial to understand that `git checkout` is a multi-purpose
    tool that can operate at the granularity of individual files or directories as
    well. In this section, let’s expand our understanding of `git checkout` and see
    how it plays a vital role in efficient collaboration and error correction.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的讨论中，我们主要在切换分支的上下文中提到了`git checkout`命令。虽然这是它的主要功能之一，但理解`git checkout`是一个多用途工具也至关重要，它不仅可以操作分支，还能在单个文件或目录的粒度上进行操作。在本节中，让我们扩展对`git
    checkout`的理解，看看它如何在高效协作和错误修正中发挥重要作用。
- en: 'Here’s a refresher on the basic command for switching branches:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是切换分支的基本命令回顾：
- en: '[PRE29]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'But what if you only need to restore a single file to a previous state? `git
    checkout` has got you covered. If you have made changes to a file but have not
    committed yet and you decide you want to undo those changes, you can do this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 那如果你只需要恢复一个文件到先前的状态呢？`git checkout`同样能帮你解决。如果你对一个文件进行了更改，但还没有提交，并且决定想要撤销这些更改，你可以这样操作：
- en: '[PRE30]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will discard changes in your working directory and revert the file back
    to the state of the last commit. Sometimes, you might want to partially apply
    changes from another branch to your current working branch. git checkout can also
    do this:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这将丢弃你工作目录中的更改，并将文件恢复到最后一次提交的状态。有时候，你可能只想将另一个分支的部分更改应用到当前工作分支。`git checkout`也能做到这一点：
- en: '[PRE31]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This command will check out a specific file from another branch into your current
    working branch, allowing you to mix and match code as needed.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会将另一个分支中的特定文件检出到你当前的工作分支，让你根据需要混合和匹配代码。
- en: 'It offers versatility in team collaboration:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 它在团队协作中提供了多种灵活性：
- en: '**Quick rollbacks**: If something goes wrong in the production, you can quickly
    check out the specific files from a stable branch.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速回滚**：如果生产环境出现问题，你可以从稳定的分支快速检出特定的文件。'
- en: '**Selective feature testing**: Before merging a new feature, you can check
    out only the files relevant to that feature for testing.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择性功能测试**：在合并新功能之前，你可以只检出与该功能相关的文件进行测试。'
- en: '**Easy error correction**: Mistakes happen all the time. The ability to check
    out individual files makes it easier to correct them without affecting other parts
    of the code base.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松错误修正**：错误是常有的事。能够单独检出文件使得更正错误变得更加容易，而不会影响到代码库中的其他部分。'
- en: Note
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using `git checkout` on files will discard changes. Make sure this is what you
    intend to do. If you are experimenting, it is a good idea to commit your changes
    often. That way, you can easily revert back to a specific commit if needed.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件上使用`git checkout`将会丢弃更改。确保这是你打算执行的操作。如果你正在进行实验，建议经常提交更改。这样，如果需要，你可以轻松回退到某个特定的提交。
- en: Understanding the full range of `git checkout` capabilities can significantly
    enhance your workflow and collaboration efficiency. Whether you are working alone
    or as part of a team, the ability to manipulate not just branches but also individual
    files grants you a higher degree of control and adaptability in your team collaboration.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`git checkout`的完整功能可以显著提升你的工作流程和协作效率。无论你是单独工作还是作为团队的一员，能够操作的不仅仅是分支，还有单个文件，这赋予了你更高的控制力和适应性。
- en: Organizing your working environment
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织你的工作环境
- en: In the realm of team development, your individual workspace is your personal
    lab—a space where you can innovate, debug, and test freely without affecting the
    broader project. Managing this space efficiently is crucial, and Git offers a
    set of powerful commands to help you do just that. In this section, we will explore
    three essential Git commands—`git clean`, `git stash`, and `.gitignore`—that can
    easily keep your workspace clean.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在团队开发中，你的个人工作区就像是一个实验室——一个可以自由创新、调试和测试的空间，而不会影响到整个项目。有效管理这个空间至关重要，Git提供了一组强大的命令，帮助你高效管理。在本节中，我们将探索三种基本的Git命令——`git
    clean`、`git stash`和`.gitignore`——这些命令可以轻松保持你的工作区干净。
- en: git clean – A fresh start
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git clean – 清爽的开始
- en: 'The `git clean` command offers a quick way to clear your working directory
    of untracked files and directories, essentially providing a clean slate. This
    can be especially useful before or after executing a merge, or when you want to
    remove any clutter that does not need to be version-controlled:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clean`命令提供了一种快速清理工作目录中未跟踪文件和目录的方法，基本上提供了一个全新的起点。在执行合并之前或之后，或者当你想清除不需要版本控制的杂物时，这个命令特别有用。'
- en: '[PRE32]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: git stash – Pause and resume work effortlessly
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git stash – 轻松暂停和恢复工作
- en: '`git stash` is an invaluable tool for temporarily stashing away changes that
    you have made but are not yet ready to commit.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`git stash`是一个非常有价值的工具，用于暂时保存你已做的更改，而这些更改还没有准备好提交。'
- en: 'As a developer, multitasking is often the name of the game. Whether you are
    interrupted by an urgent bug fix or need to switch context temporarily, `git stash`
    comes to the rescue. This command allows you to save your current changes without
    making a formal commit, giving you the freedom to switch tasks and then return
    to where you left off:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，多任务处理往往是日常工作的一部分。无论是被紧急的bug修复打断，还是需要暂时切换上下文，`git stash`都能派上用场。此命令让你保存当前的更改，而无需进行正式提交，从而让你有自由切换任务，之后可以轻松回到之前的工作状态：
- en: '[PRE33]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In addition, here is a rundown of common `git stash` commands that can significantly
    enhance your workspace management:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里列出了一些常用的`git stash`命令，这些命令可以显著提升你的工作区管理：
- en: '`git stash`: This stashes your changes, leaving your working directory clean.
    Untracked files are not stashed.'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git stash`：此命令将你的更改保存到stash，使你的工作目录保持干净。未跟踪的文件不会被stash。'
- en: '`git stash save "Your Comment"`: This stashes your changes and allows you to
    attach a comment. This is useful for identifying stashes later with `git` `stash
    list`.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git stash save "Your Comment"`：此命令将你的更改保存到stash，并允许你附加评论。这对于稍后使用`git stash
    list`识别stash非常有用。'
- en: '`git stash list`: This displays a list of all your stashed changes. If you
    used `git stash save`, you will see your comments here, making it easier to identify
    each stash.'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git stash list`：此命令显示你所有已保存的更改的列表。如果你使用了`git stash save`，你将在此看到你的评论，这使得识别每个stash变得更加容易。'
- en: '`git stash apply`: This restores the most recently stashed changes to your
    working directory. The stash remains in the `git` `stash list`.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git stash apply`：此命令将最近保存的更改恢复到你的工作目录。stash仍会保留在`git stash list`中。'
- en: '`git stash apply [stash@{n}]`: This restores a specific stash based on its
    index number, which you can find using `git` `stash list`.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git stash apply [stash@{n}]`：此命令根据索引号恢复特定的stash，你可以通过`git stash list`找到该索引号。'
- en: '`git stash drop`: This deletes a specific stash from the stash list.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git stash drop`：此命令删除stash列表中的特定stash。'
- en: '`git stash drop [stash@{n}]`: This deletes a specific stash based on its index
    number.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git stash drop [stash@{n}]`：此命令根据索引号删除特定的stash。'
- en: '`git stash clear`: This deletes all stashes, clearing your `stash list`.'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git stash clear`：此命令删除所有stash，清空你的`stash list`。'
- en: .gitignore – Personalize what gets shared
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .gitignore – 自定义共享内容
- en: When working on complex projects, your local environment may generate files
    such as logs or contain personal configuration settings—things you do not want
    to share with the rest of the team. The `.gitignore` file enables you to specify
    which files and folders should be ignored during a `git add`, ensuring they remain
    exclusive to your local environment.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理复杂项目时，你的本地环境可能会生成日志文件或包含个人配置设置——这些内容你不希望与团队共享。`.gitignore`文件允许你指定在`git add`期间应该忽略哪些文件和文件夹，从而确保它们只存在于你的本地环境中。
- en: 'This is an example of a `.``gitignore` file:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`.gitignore`文件的示例：
- en: '[PRE34]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Who did what? Great ways to help you debug
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁做了什么？帮助你调试的绝妙方法
- en: Git has a couple of typical ways to analyze the past. `git blame` and `git bisect`
    are useful to remember because they are easy to use to go back and debug who made
    what changes.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: Git 有几种典型的方法来分析过去的情况。`git blame` 和 `git bisect` 是非常实用的工具，记住它们很重要，因为它们易于使用，可以帮助追溯并调试是谁做了什么修改。
- en: git blame – Who did what?
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git blame – 谁做了什么？
- en: When working in a shared code base, there may be instances where you need to
    understand the history of specific lines of code. The `git blame` command provides
    a breakdown of a file, annotating each line to show the last person who modified
    it and what commit it belongs to. This helps in identifying the responsible parties
    for particular changes, which is useful for debugging, refactoring, or simply
    understanding why a particular piece of code exists.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享代码库中工作时，可能会有需要了解特定代码行历史的情况。`git blame` 命令提供了一个文件的分解，注释每一行，显示最后修改它的人员以及该行属于哪个提交。这有助于识别负责特定更改的人员，这对调试、重构或简单理解某段代码存在的原因非常有用。
- en: '[PRE35]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `-L` option allows you to specify the lines of output:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`-L` 选项允许你指定输出的行数：'
- en: '[PRE36]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is essential to highlight that the aim of `git blame` is not to single out
    individuals for errors or questionable decisions. In any collaborative setting—especially
    in DevOps where teamwork is paramount—it is crucial to remember that mistakes
    are a collective responsibility. Everyone can err; what is important is how the
    team collaborates to fix those errors. From a psychosocial safety perspective,
    using `git blame` should be approached as a way to enhance team communication
    and identify areas for improvement rather than as a mechanism for casting blame.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 必须强调的是，`git blame` 的目的是不是为了将错误或可疑决策归咎于个人。在任何协作环境中——尤其是在团队合作至关重要的 DevOps 中——必须记住，错误是集体的责任。每个人都可能犯错；重要的是团队如何合作解决这些错误。从心理安全的角度来看，使用
    `git blame` 应该视为增强团队沟通和识别改进领域的一种方式，而不是用来归咎他人的机制。
- en: git bisect – Efficient bug hunting in commit ranges
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: git bisect – 在提交范围内高效地寻找 bug
- en: Debugging can often feel like looking for a needle in a haystack, especially
    in large codebases with a long history of commits. In the realm of DevOps, where
    rapid deployment cycles are the norm, a bug introduced in any of the numerous
    changes can wreak havoc. This is where `git bisect` comes into play, serving as
    a powerful tool for isolating the specific commit that introduced a bug.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 调试常常感觉像是在大海捞针，尤其是在拥有大量提交历史的大型代码库中。在 DevOps 领域，快速部署周期是常态，而在无数变更中引入的 bug 可能会造成严重后果。此时，`git
    bisect` 就发挥了作用，成为定位引入 bug 的特定提交的强大工具。
- en: 'The `git bisect` command performs a binary search through your commit history
    to find the commit that introduced the bug. The process begins by marking a known
    good commit and a known bad commit:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '`git bisect` 命令通过在提交历史中执行二分查找来找到引入 bug 的提交。该过程从标记一个已知良好的提交和一个已知有问题的提交开始：'
- en: '[PRE37]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Git will then automatically check out a commit halfway between the good and
    bad commits. You test this commit and then mark it as either good or bad:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: Git 然后会自动检查良好提交和有问题提交之间的一个中间提交。你需要测试这个提交，然后将其标记为良好或有问题：
- en: '[PRE38]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Git will continue this process, narrowing down the range of commits until it
    identifies the culprit. Once you find the problematic commit, it is easier to
    understand what went wrong and to devise a fix:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Git 将继续这一过程，逐步缩小提交范围，直到识别出罪魁祸首。一旦找到有问题的提交，就能更容易地理解出了什么问题并制定修复方案：
- en: '[PRE39]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In DevOps, where the speed of identifying and resolving issues is crucial for
    maintaining operational excellence, `git bisect` becomes an invaluable tool. It
    integrates well into a DevOps toolchain, allowing for automated testing and facilitating
    quicker rollbacks and patches. By efficiently pinpointing errors, it enhances
    the team’s ability to collaborate on solutions, underscoring the essential DevOps
    principles of rapid feedback and continuous improvement.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DevOps 中，识别和解决问题的速度对保持卓越的运营至关重要，`git bisect` 成为了一种无价的工具。它能够很好地融入 DevOps 工具链，支持自动化测试，并促进更快速的回滚和修补。通过高效地定位错误，它增强了团队合作解决方案的能力，强调了快速反馈和持续改进这两个
    DevOps 的基本原则。
- en: Versioning excellence
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制的卓越性
- en: In the DevOps ecosystem, **CI/CD** make everything incremental. Yet, it is essential
    to have concrete versions of your software to serve as milestones. These versions
    are not just markers in time; they indicate the stability, new features, and overall
    health of your code base. They also facilitate smoother rollbacks and make it
    easier to isolate issues.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DevOps 生态系统中，**CI/CD**使一切都变得增量化。然而，拥有具体版本的软件作为里程碑仍然至关重要。这些版本不仅是时间的标记；它们表明了代码的稳定性、新功能以及整体健康状态。它们还促进了更顺畅的回滚，并使隔离问题变得更加容易。
- en: What is semantic versioning
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是语义化版本控制
- en: Semantic versioning is a versioning scheme designed to convey specific meanings
    about the underlying changes with each new release. The format consists of three
    numbers separated by dots (e.g., 2.4.4). Each number has a particular significance
    related to backward compatibility and the types of changes introduced.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 语义化版本控制是一种版本控制方案，旨在传达每次新发布所涉及的具体变化含义。其格式由三个数字组成，数字之间用点分隔（例如：2.4.4）。每个数字具有特定的意义，与向后兼容性和引入的更改类型相关。
- en: Tagging in Git
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git 中的标记
- en: Tagging becomes a cornerstone of effective version control within a DevOps environment.
    By marking specific points in your repository’s history, you can create anchors
    that serve as stable release points or significant milestones. These tagged versions
    form the basis for your CI/CD pipelines, ensuring consistent and reliable deployments.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DevOps 环境中，标记成为了有效版本控制的基石。通过标记代码库历史中的特定点，您可以创建作为稳定发布点或重要里程碑的锚点。这些标记版本为您的 CI/CD
    流水线奠定了基础，确保了持续一致和可靠的部署。
- en: 'To make your tags more informative, consider annotating them with useful metadata
    and context:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使标签更具信息性，可以考虑为其添加有用的元数据和上下文：
- en: '[PRE40]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The commits you tag should typically represent stable release points or crucial
    milestones. These are the commits where all the automated tests have passed, features
    are complete, and the code has undergone peer review. In essence, they are your
    *production-ready* commits.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您标记的提交通常应该代表稳定的发布点或关键的里程碑。这些是所有自动化测试通过、功能完成并经过同行评审的提交。从本质上讲，它们是您的*生产就绪*提交。
- en: 'To tag a specific commit, use the following:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 要标记特定的提交，可以使用以下命令：
- en: '[PRE41]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Git tagging and semantic versioning are not just technical procedures but strategic
    actions. They ensure that everyone is on the same page regarding what is being
    deployed and what it can do.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: Git 标记和语义化版本控制不仅是技术操作，还是战略性措施。它们确保每个人都能理解当前部署的内容以及它能执行的功能。
- en: In this section, we have equipped ourselves with the knowledge to roll back
    time in our repositories, understanding when and how to use `git reset`, `git
    revert`, and `git checkout`. These powerful commands ensure that we can gracefully
    undo changes, correct course, and maintain a clean project history—all essential
    for a collaborative setting. Organizing your working environment with `git clean`,
    `git stash`, and the right `.gitignore` settings offers you a pristine workspace
    where focus and clarity replace clutter and chaos. This clean slate is not just
    about personal preference; it is about setting a standard for the team and ensuring
    that only intentional changes make their way into the shared repository.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经掌握了如何在代码库中回溯时间的知识，了解何时以及如何使用`git reset`、`git revert`和`git checkout`。这些强大的命令确保我们能够优雅地撤销更改、纠正方向并保持清晰的项目历史记录——这些对于协作环境至关重要。通过`git
    clean`、`git stash`和正确的`.gitignore`设置来组织工作环境，为您提供一个干净的工作区，在这里，专注和清晰取代了杂乱和混乱。这个干净的工作区不仅仅是个人偏好的体现；它是为团队设定标准，确保只有有意的更改才能进入共享的代码库。
- en: Incorporating these techniques into your routine not only prepares you for better
    personal performance but also strengthens the whole team.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些技巧融入到您的日常工作中，不仅能提升个人表现，还能增强整个团队的协作能力。
- en: Summary
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we delved deep into the nuances of branch strategies, the intricacies
    of merging and rebasing, and the art of navigating conflicts with the goal of
    mastering better collaboration within your teams. From understanding why a branching
    strategy is crucial to aligning branch naming with organizational objectives,
    we have laid out the groundwork for you to build a robust workflow.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了分支策略的细节、合并和变基的复杂性以及如何处理冲突的艺术，目标是掌握团队内部更好的协作。我们从理解为什么分支策略至关重要，到将分支命名与组织目标对齐，为您奠定了构建稳健工作流程的基础。
- en: We explored the various branching models, such as trunk-based development, Git
    Flow, and GitHub Flow, highlighting their unique benefits and scenarios where
    they fit best. The discussion around merge approaches provided insight into the
    tools at your disposal for maintaining a clean and informative project history
    while also addressing the sometimes daunting task of conflict resolution.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索了各种分支模型，如基于主干的开发、Git Flow和GitHub Flow，强调了它们各自独特的优势以及适合的应用场景。关于合并方法的讨论，提供了关于维护干净且富有信息的项目历史的工具，并解决了有时令人头疼的冲突解决问题。
- en: As you close this chapter, remember that the path to mastering Git is ongoing.
    Encourage yourself to discover more and to practice these skills through your
    development work with confidence. Embrace the challenges and the learning opportunities
    they bring and continue to grow as a developer. Git is not just a tool; it is
    a companion in your DevOps journey that enhances the developer’s experience by
    removing friction and fostering a culture of collaboration.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成本章内容时，请记住，掌握Git的道路是不断前行的。鼓励自己去探索更多，并通过自信地在开发工作中练习这些技能。拥抱挑战及其带来的学习机会，继续成长为一名开发者。Git不仅仅是一个工具，它是你在DevOps旅程中的伙伴，通过消除摩擦并促进协作文化，提升开发者的体验。
- en: 'Part 2: GitHub Excellence and CI/CD Fundamentals'
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：GitHub卓越性与CI/CD基础
- en: This part highlights GitHub’s role in DevOps, expanding its use beyond just
    code hosting. It discusses GitHub’s features that enhance team collaboration and
    the transition to modern DevOps practices. Additionally, it delves into GitHub
    Actions, focusing on workflow optimization, advanced deployment methods such as
    blue-green and canary deployments, and feature release strategies. This provides
    an in-depth understanding of GitHub’s capabilities in continuous integration and
    deployment.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分强调了GitHub在DevOps中的作用，扩展了其用途，不仅仅是代码托管。它讨论了GitHub的功能，这些功能增强了团队协作，并促进了向现代DevOps实践的过渡。此外，还深入探讨了GitHub
    Actions，重点关注工作流优化、先进的部署方法，如蓝绿部署和金丝雀发布，以及功能发布策略。这为深入理解GitHub在持续集成和部署中的能力提供了帮助。
- en: 'This part has the following chapters:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 4*](B21203_04.xhtml#_idTextAnchor077), *Elevating Team Collaboration
    with GitHub*'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第4章*](B21203_04.xhtml#_idTextAnchor077)，*通过GitHub提升团队协作*'
- en: '[*Chapter 5*](B21203_05.xhtml#_idTextAnchor109), *Driving CI/CD with GitHub*'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B21203_05.xhtml#_idTextAnchor109)，*通过GitHub驱动CI/CD*'
