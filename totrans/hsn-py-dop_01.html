<html><head></head><body>
		<div id="_idContainer011">
			<h1 id="_idParaDest-15" class="hapter-number"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Introducing DevOps Principles</h1>
			<p class="author-quote">Obey the principles without being bound by them.</p>
			<p class="author-quote">– Bruce Lee</p>
			<p><strong class="bold">DevOps</strong> has numerous definitions, most of which are focused on culture and procedure. If you’ve gotten to the point where you have purchased this book as a part of your journey in the DevOps field, you have probably heard at least about 100 of these definitions. Since this is a book that focuses more on the hands-on, on-the-ground aspect of DevOps, we’ll keep those abstractions and definitions to a minimum, or rather, explain them through actions rather than words <span class="No-Break">whenever possible.</span></p>
			<p>However, since this is a DevOps book, I am obliged to take a shot <span class="No-Break">at this:</span></p>
			<p><em class="itali">DevOps is a series of principles and practices that aims to set a culture that supports the automation of repetitive work and continuous delivery of a product while integrating the software development and IT operation aspects of </em><span class="No-Break"><em class="itali">product delivery.</em></span></p>
			<p>Not bad. It’s probably incomplete, but that’s the nature of the beast, and that is perhaps what makes this definition somewhat appropriate. Any DevOps engineer would tell you that the work is never complete. Its principles are similar in many ways to the Japanese philosophy of <strong class="bold">Ikigai</strong>. It gives the engineers a purpose; an avenue for improvement on their systems which gives them the same thrill as a swordsman honing their skills or an artist painting their masterpiece. Satisfied, yet unsatisfied at the same <span class="No-Break">time. Zen.</span></p>
			<p>Philosophical musings aside, I believe DevOps principles are critical to any modern software team. To work on such teams, it is better to start with the principles as they help explain a lot of how the tools used in DevOps were shaped, how and why software teams are constructed the way they are, and to facilitate DevOps principles. If I had to sum it up in one <span class="No-Break">word: time.</span></p>
			<p>In this chapter, you will learn about the basic principles that define DevOps as a philosophy and a mindset. It is important to think of this just as much as an exercise in ideology as it is in technology. This chapter will give you the context you need to understand why DevOps principles and tools exist and the underlying philosophies <span class="No-Break">behind them.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><span class="No-Break">Exploring automation</span></li>
				<li>Understanding logging <span class="No-Break">and monitoring</span></li>
				<li>Incident and <span class="No-Break">event response</span></li>
				<li>Understanding <span class="No-Break">high availability</span></li>
				<li>Delving into infrastructure as <span class="No-Break">a code</span></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Exploring automation</h1>
			<p>We’re going to start with why <strong class="bold">automation</strong> is needed in life in general and then we’ll move toward a more specific definition that relates to DevOps and other tech team activities. Automation is for the lazy, but many do not realize how hard you must work and how much you must study to truly be lazy. To achieve automation, it requires a mindset, an attitude, a frustration with <span class="No-Break">present circumstances.</span></p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor018"/>Automation and how it relates to the world</h2>
			<p>In Tim Ferris’s book <em class="itali">The 4-Hour Workweek</em>, he has an entire section dedicated to automating the workflow which emphasizes the fact that the principle of automation helps you clean up your life and remove or automate any unnecessary tasks or distractions. DevOps hopes to do something similar but in your professional life. Automation is the primary basis that frees up our time to do other things <span class="No-Break">we want.</span></p>
			<p>One of the things mankind has always tried to automate even further is transportation. We have evolved from walking to horses to cars to planes to self-driving versions of those things. The reason for that is the same reason DevOps became a prominent culture: to <span class="No-Break">save time.</span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor019"/>How automation evolves from the perspective of an operations engineer</h2>
			<p>You may have heard the famous story of the build engineer who automated his entire job down to the second (if you haven’t looked it up, it’s a great read). What he did was he automated any task within the server environment that required his attention for more than 90 seconds (solid DevOps principles from this guy if you ask me). This included automatically texting his wife if he was late, automated rollback of database servers based on a specific e-mail sent by a client’s database administrator, and Secure Shelling into the coffee machine to automatically serve him coffee, further proving my point that most things can <span class="No-Break">be automated.</span></p>
			<p>You don’t need to automate your workspace or your life to this extent if you don’t want to, but here’s the lesson you should take away from this: use automation to save time and prevent yourself from being hassled, because a) your time is precious and b) an automated task does the job perfectly every time if you set it correctly <span class="No-Break">just once.</span></p>
			<p>Let’s take ourselves through the life of a young software engineer named John. Let’s say John is a Flask developer. John has just joined his first big-boy software team and they are producing something already in production with a development and testing environment. John has only worked on <strong class="sour e-inline">localhost:5000</strong> his entire programming journey and knows nothing past that (a lot of entry-level coders don’t). John knows you use Git for version control and that the source code you push up there goes… somewhere. Then it shows up in the application. Here’s John’s journey figuring it out (and then being bored <span class="No-Break">by it):</span></p>
			<ul>
				<li>John gets access to the repository and sets up the code locally. While it’s nothing he’s never done before, he starts <span class="No-Break">contributing code.</span></li>
				<li>A month later, an Operations guy who was managing the deployment of the specific service John was working on leaves. John is asked if he can take over the deployments while they hire a replacement. John, being young and <span class="No-Break">naïve, agrees.</span></li>
				<li>Two months later, with no replacement yet, John has figured out how deployment servers such as Nginx or Apache work and how to copy his code onto a server environment and deploy it in a way that it can reach the public internet (it turns out it was essentially just <strong class="sour e-inline">localhost</strong> in disguise. Who knew?). He may have even been allowed to modify the DNS records all <span class="No-Break">by himself.</span></li>
				<li>Four months later, John is tired, he spends half his time pulling code into the server, solving merge conflicts, restarting the server, and debugging the server. The server is a herd of goats, and he is but one hand with many mouths to feed. It becomes difficult for him to push new features and finish his pre-assigned tasks. This is when he starts wondering if there is a <span class="No-Break">better way.</span></li>
				<li>He learns about bash scripting and runbooks. He learns that you can add triggers to both the repository and the server to perform certain tasks when the code has been updated. He also learns about playbooks that can be run when a common error starts <span class="No-Break">popping up.</span></li>
				<li>Six months later, John has automated practically every part of the deployment and maintenance procedures for the application. It runs itself. The process has made John a better coder as well as he now writes his code with the challenges of deployment and automation <span class="No-Break">in mind.</span></li>
				<li>Eight months later, John has nothing to do. He’s automated all relevant tasks, and he doesn’t need that Ops guy that HR never got back to him about. He is now a <span class="No-Break">DevOps engineer.</span></li>
				<li>His manager asks him why his worklog seems empty. John tells him that DevOps tasks are measured by difficulty and complexity and not work hours. The manager <span class="No-Break">is confused.</span></li>
				<li>Now, at this point, one of two things happens: either the manager listens and John pushes his enterprise toward a DevOps philosophy that will transform it into a modern IT company (there are antiquated IT companies, weird as that may seem), or he leaves for a place that appreciates his talents, which would be pretty easy to do if he markets <span class="No-Break">them correctly.</span></li>
			</ul>
			<p>This may seem like a fantasy, but it’s how many DevOps engineers are forged: in the fires of incompetence. This tale is, however, meant to be more analogous to companies as a whole and whether they transform to use DevOps principles or not. The ones that do become more agile and capable of delivering new features and using resources toward something as opposed to using them just to <span class="No-Break">maintain something.</span></p>
			<p>Automation is born out of a desire to not do the same things differently (usually for the worse) over and over again. This concept is at the heart of DevOps, since the people who automate realize how important it is to have consistency in repetitive tasks and why it is a time and potentially <span class="No-Break">a lifesaver.</span></p>
			<p>But for a task to be reliably done in the same way over and over again, it must be observed so that it can be kept on the correct path. That is where logging and monitoring <span class="No-Break">come in.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor020"/>Understanding logging and monitoring</h1>
			<p>Switching to a more grounded topic, one of the driving principles of DevOps is logging and monitoring instances, endpoints, services, and whatever else you can track and trace. This is necessary because regardless of whatever you do, how clean your code is, or how good your server configuration is, something will fail, go wrong, or just inexplicably stop working altogether. This will happen. It’s a fact of life. It is in fact, <span class="No-Break">Murphy’s law:</span></p>
			<p class="author-quote">Anything that can go wrong will go wrong at the worst possible time.</p>
			<p>Familiarizing yourself with this truth is important for a DevOps engineer. Once you have acknowledged it, then you can deal with it. Logging and monitoring come in because when something <em class="itali">does</em> go wrong, you need the appropriate data to respond to that event, <span class="No-Break">sometimes automatically.</span></p>
			<p>The rest of this section has been laid out in terms of logging, monitoring, and alerts. Each one of these aspects plays an important role in keeping the DevOps train (workload) on the <span class="No-Break">right track.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor021"/>Logging</h2>
			<p>If you are not from a technical background or are new to logging principles, think of logging in <span class="No-Break">this way:</span></p>
			<p><em class="itali">Every day after school, a schoolboy would go to an old woman selling matches and give her money for one matchbox. However, he’d take no matchboxes in return. Then one day, as the boy went about his usual routine, he saw the woman about to speak up and he said, “I know you’re probably wondering why I give you money for the matchbox but don’t take one in return. Would you like me to tell you?” The woman replied, “No, I just wanted to tell you that the price of matches has </em><span class="No-Break"><em class="itali">gone up.”</em></span></p>
			<p>In this case, the woman is the logger, and the boy is the person viewing the log. The woman doesn’t care about the reason. She’s just collecting the data, and when the data changes, she collects the changed data. The boy checks in every day and goes about his routine uninterrupted until something changes in the log. Once the log changes, the boy decides whether to react or not depending on what he would consider to be an <span class="No-Break">appropriate response.</span></p>
			<p>In subsequent chapters, you’ll learn about logs, how to analyze them (usually with Python), and appropriate responses to logs. But at present, all you need to know is that good bookkeeping/logging has built empires because history and the lessons that we learn from it are important. They give us perspective and the appropriate lessons that we need to respond to <span class="No-Break">future events.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor022"/>Monitoring</h2>
			<p>When you look at the title of this section, <em class="itali">Understanding logging and monitoring</em>, some of you might wonder, what’s the difference? Well, that’s valid. It took me a while to figure that out as well. And I believe that it comes down to a couple <span class="No-Break">of things:</span></p>
			<ol>
				<li><strong class="bold">Monitoring</strong> looks at a specific metric (usually generated by logs) and whether or not that metric has passed a certain threshold. However, <strong class="bold">logging</strong> is simply collecting the data without generating any insight or information <span class="No-Break">from it.</span></li>
				<li>Monitoring is active and focuses on the current state of an instance or object that is being monitored, whereas logging is passive and focuses more on the collection of largely <span class="No-Break">historical data.</span></li>
			</ol>
			<p>In many ways, it is like the differences between a transactional database and a data warehouse. One functions on current data while the other is about storing historical data to find trends. Both are intertwined with each other nearly inexorably and thus are usually spoken of together. Now that you have logged and monitored all the data, you might ask yourself, what is it for? The next section will help <span class="No-Break">with that.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor023"/>Alerts</h2>
			<p>You cannot have a conversation about logging and monitoring without bringing up the concept of alerts. A <strong class="bold">logged metric</strong> is monitored by a monitoring service. This service looks at the data produced from the logs and measures it against a threshold that is set for that metric. If the threshold is crossed for a sustained, defined period of time, an <strong class="bold">alert</strong> or alarm <span class="No-Break">is raised.</span></p>
			<p>Most of the time, these alerts or alarms are either connected to a notification system that can inform the necessary personnel regarding the heightened alarm state, or a response system that can automatically trigger a response to <span class="No-Break">the event.</span></p>
			<p>Now that you have learned about the powers of observation and insight that you gain from logging and monitoring, it is time to learn how to wield that power. Let’s find out the actions we should take when we find significant and concerning insights through logging <span class="No-Break">and monitoring.</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor024"/>Incident and event response</h1>
			<p>I’m going to put Murphy’s Law here again because I cannot state <span class="No-Break">this enough:</span></p>
			<p class="author-quote">Anything that can go wrong will go wrong at the worst possible time.</p>
			<p>Dealing with <strong class="bold">incident and event response</strong> involves either a lot of work or zero work. It depends on how prepared you are and how unique the incident or event is. Incident and event response covers a lot of ground from automation and cost control, <span class="No-Break">to cybersecurity.</span></p>
			<p>How a DevOps engineer responds to an event depends on a great number of things. In terms of dealing with clients and customers, a <strong class="bold">Service Level Objective</strong> (<strong class="bold">SLO</strong>) is used when a response is necessary. However, this is largely on production environments and requires the definition of a <strong class="bold">Service Level Indicator</strong> (<strong class="bold">SLI</strong>). It also involves the creation of an error budget to determine the right time to add new features and what the right time is to work on the maintenance of a system. Lower-priority development environments are used to stress test potential production cases and the effectiveness of incident response strategies. These objectives will be further explored in the <em class="itali">Understanding high </em><span class="No-Break"><em class="itali">availability</em></span><span class="No-Break"> section.</span></p>
			<p>If you work on the <strong class="bold">Site Reliability Engineering</strong> (<strong class="bold">SRE</strong>) side of DevOps, then incidents are going to be your bread and butter. A large part of the job description for that role involves having the correct metrics set up so that you can respond to a situation. Many SRE teams are set up these days to have active personnel around the globe who can monitor sites according to their active time zones. The response to the incident itself is done by an <strong class="bold">incident response team</strong> which I will cover in detail in the <span class="No-Break">next section.</span></p>
			<p>Another part of incident response is the understanding of what caused the incident, how long it took to recover, and what could have been done better in the future. This is covered by <strong class="bold">post-mortems</strong>, which usually assist in the creation of a clear, unbiased report that can help with future incidents. The incident response team is responsible for the creation of <span class="No-Break">this document.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor025"/>How to respond to an incident (in life and DevOps)</h2>
			<p>Incidents happen, and the people who are responsible for dealing with these incidents need to handle them. Firefighters have to battle fires, doctors have to treat the sick, and DevOps engineers have to contend with a number of incidents that can occur when running the sites that they manage <span class="No-Break">and deploy.</span></p>
			<p>Now, in life, how would you deal with an incident or something that affects your life or your work that you need to deal with? There’s one approach that I read in a book called <em class="itali">Mental Strength</em> by Iain Stuart Abernathy that I subsequently found everywhere among the DevOps courses and experts that I met: <strong class="bold">Specific, Measurable, Achievable, Realistic, and Time-bound</strong> (<strong class="bold">SMART</strong>). If a solution to a problem has to follow all of these principles, it will have a good chance of working. You can apply this to your own life along with your DevOps journey. It’s all problem-solving, <span class="No-Break">after all.</span></p>
			<p>To define the SMART principle in brief, let’s go over each of the components one <span class="No-Break">by one:</span></p>
			<ul>
				<li>Specific: Know exactly what <span class="No-Break">is happening</span></li>
				<li>Measurable: Measure <span class="No-Break">its impact</span></li>
				<li>Achievable: Think of what your goal is <span class="No-Break">for mitigation</span></li>
				<li>Realistic: Be realistic with your expectations and what you <span class="No-Break">can do</span></li>
				<li>Time-bound: Time is of the essence, so don’t <span class="No-Break">waste it</span></li>
			</ul>
			<p>Here are some common incidents DevOps engineers may have to <span class="No-Break">deal with:</span></p>
			<ul>
				<li>The production website or application <span class="No-Break">goes down</span></li>
				<li>There is a mass spike in traffic suggesting a distributed <span class="No-Break">denial-of-service attack</span></li>
				<li>There is a mass spike in traffic suggesting an influx of new users that will require an upscale <span class="No-Break">in resources</span></li>
				<li>There is an error in building the latest code in the <span class="No-Break">code pipeline</span></li>
				<li>Someone deleted the production database (seriously, this <span class="No-Break">can happen)</span></li>
			</ul>
			<p>Dealing with incidents involves first dividing the incident based on the type of response that can be provided and whether this type of incident has been anticipated and prepared for. If the response is manual, then time isn’t a factor. Usually, this occurs if an incident doesn’t affect the workload but must be addressed, such as a potential anomaly or a data breach. The stakeholders need to be told so that they can make an informed decision on the matter. Automatic responses are for common errors or incidents that you know occur from time to time and have the appropriate response for. For example, if you need to add more computing power or more servers in response to increased traffic or if you have to restart an instance if a certain metric goes awry (this happens quite a bit <span class="No-Break">with Kubernetes).</span></p>
			<p>We deal with these incidents in order to provide the maximum availability possible for any application or site that we manage. This practice of aiming for maximum availability will be covered in the next section on site <span class="No-Break">reliability engineering.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>Site reliability engineering</h2>
			<p>So, <strong class="bold">site reliability engineering</strong> (<strong class="bold">SRE</strong>) is considered a form of DevOps by many and is considered to be separate from DevOps by others. I’m putting this section in here because, regardless of your opinion on the subject, you as a DevOps Engineer will have to deal with the concepts of site reliability, how to maintain it, and how to retain <span class="No-Break">customer trust.</span></p>
			<p>SRE as a concept is more rigid and inflexible than the DevOps philosophy as a whole. It is the evolution of the data center technicians of the past who practically lived in data centers for the course of their careers, maintaining server racks and configurations to ensure whatever product that was being delivered by their servers would continue to be delivered. That was their job: not creating anything new, but finding solutions to maintain their <span class="No-Break">old infrastructure.</span></p>
			<p>SRE is similar, but the engineer has been taken out of the data center and placed inside a remote work desk at an office or their own home. They still live fairly close to their data center or the cloud region containing the resources that they manage, but they differ from their predecessors in a couple <span class="No-Break">of ways:</span></p>
			<ol>
				<li>Their teams are likely scattered across their regions as opposed to being in a <span class="No-Break">singular place.</span></li>
				<li>Their emphasis is now on what we call <em class="itali">predictive maintenance</em>, i.e. they do not wait for something to go wrong <span class="No-Break">to respond.</span></li>
			</ol>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Incident response teams</h2>
			<p>This new trend of SRE also helped produce incident response teams, which can be quickly created from within the ranks of the DevOps team to monitor and deal with an incident. They can do so while communicating with stakeholders to keep them informed about the situation and finding the root cause of the incident. These teams also produce reports that can help the DevOps team deal with and mitigate such potential situations in the future. In a world where an outage of a few minutes can sometimes cause millions of dollars of loss and damage, incident response teams have become a prominent part of any DevOps <span class="No-Break">engineer’s world.</span></p>
			<p>Usually, an incident response team is made up of the <span class="No-Break">following members:</span></p>
			<ul>
				<li><strong class="bold">Incident commander</strong> (<strong class="bold">IC</strong>): An incident commander leads the response to the incident and is responsible for a post-incident <span class="No-Break">response plan</span></li>
				<li><strong class="bold">Communications leader</strong> (<strong class="bold">CL</strong>): A communications leader is the public-facing member of the team who is responsible for communicating the incident and the progress made to mitigate the incident to <span class="No-Break">the stakeholders</span></li>
				<li><strong class="bold">Operations leader</strong> (<strong class="bold">OL</strong>): Sometimes synonymous with the incident commander, the OL leads the technical resolution of the incident by looking at logs, errors, and metrics and figures out a way to bring the site or application <span class="No-Break">back online</span></li>
				<li><strong class="bold">Team members</strong>: Team members under the CL and OL who are coordinated by their respective leaders for whatever purpose they <span class="No-Break">may require</span></li>
			</ul>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B21320_01_01.jpg" alt="Figure 1.1 – A typical incident response team structure"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – A typical incident response team structure</p>
			<p>As you can see in <span class="No-Break"><em class="itali">Figure 1</em></span><em class="itali">.1</em>, the structure<a id="_idIndexMarker000"/> of the incident response team is fairly simple and is usually quite effective in mitigating an incident when such a case arises. But what happens after the incident? Another incident? That’s a possibility and the fact that it’s a possibility is the exact reason we need to gain insight from the current incident. We do this <span class="No-Break">with post-mortems.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor028"/>Post-mortems</h2>
			<p>An incident happens. It affects<a id="_idIndexMarker001"/> business value and the users of the application, and then it goes away or is solved. But what’s to say it doesn’t happen again? What could be done to mitigate it before it even has the chance to happen again? Post-mortems are the answer to all of that. Any good DevOps team will perform a post-mortem after an incident has occurred. This post-mortem will be led by the incident response team that handled <span class="No-Break">the situation.</span></p>
			<p>Post-mortems sound macabre, but they are an essential part of the healing process and improvement of a workload and a DevOps team. They let the DevOps team understand the incident that occurred and how it happened, and they dissect the response made by the response team. Exercises such as these create a solid foundation for faster response times in the future as well as for learning experiences and <span class="No-Break">team growth.</span></p>
			<p>One of the aspects of post-mortems that is constantly emphasized is that they must be blameless, i.e., there mustn’t be any placing of responsibility for the cause of the incident upon an individual. If an incident has occurred, it is the process that must be modified, not the person. This approach creates an environment of openness and makes sure that the results of the post-mortem are factual, objective, <span class="No-Break">and unbiased.</span></p>
			<p>So, you may ask yourself, why go through all of this? The reason is often contractual and obligatory. In a modern technological landscape, things such as these are necessary and expected to deliver value and availability<a id="_idIndexMarker002"/> to the end user. So let’s understand exactly what that <span class="No-Break">availability means.</span></p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor029"/>Understanding high availability</h1>
			<p>I’m not going to state Murphy’s Law<a id="_idIndexMarker003"/> a third time, but understand that it applies here as well. Things will go wrong and they will fall apart. Never forget that. One of the reasons DevOps as a concept and culture became so popular was that its techniques delivered a highly available product with very little downtime, maintenance time, and vulnerability to <span class="No-Break">app-breaking errors.</span></p>
			<p>One of the reasons DevOps succeeds in its mission for high availability is the ability to understand failure, react to failure, and recover from failure. Here’s a famous quote from Werner Vogel, the CTO <span class="No-Break">of Amazon:</span></p>
			<p class="author-quote">Everything fails, all the time.</p>
			<p>This is, in fact, the foundation of the best practice guides, tutorials, and documentation that AWS makes for DevOps operations, and it’s true. Sometimes, things fail because of a mistake that has been made. Sometimes, they fail because of circumstances that are completely out of our control, and sometimes, things fail for no reason. But the point is that things fail, and when they do, DevOps engineers need to deal with those failures. Additionally, they need to figure out how to deal with them as fast as possible with as little disturbance to the customer <span class="No-Break">as possible.</span></p>
			<p>A little advice for people who may have never worked on a solid project before, or at least been the guy facing the guy giving orders: <em class="itali">ask for specifics</em>. It’s one of the tenets of DevOps, Agile, and any other functional strategy and is vital to any sort of working relationship between all the stakeholders and participants of a project. If you tell people exactly what you want, and if you give them metrics that define that thing, it becomes easier to produce it. So, in DevOps, there are metrics and measurements that help define the requirements for the availability of services as well as agreements to maintain <span class="No-Break">those services.</span></p>
			<p>There are a number of acronyms, metrics, and indicators<a id="_idIndexMarker004"/> that are associated with high availability. These are going to be explored in this section and they will help define exactly what high availability means in <span class="No-Break">a workload.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor030"/>SLIs, SLOs, and SLAs</h2>
			<p>Agreements of service, terms of services, contracts, and many other types of agreements are designed so that two parties in agreement with one another can draw out that agreement and are then beholden to it. You need a contract when one party pays another for a service, when two parties exchange services, when one party agrees to a user agreement drawn up by the other party (ever read one of those?), and for a lot of <span class="No-Break">other reasons.</span></p>
			<p>Let’s break down what each of <span class="No-Break">these are:</span></p>
			<ul>
				<li><strong class="bold">Service level indicators</strong> (<strong class="bold">SLIs</strong>): These are metrics that <a id="_idIndexMarker005"/>can be used to numerically define the level of service that is being provided by a product. For instance, if you were to run a website, you could use the uptime (the amount of time the website is available for service) as <span class="No-Break">an SLI.</span></li>
				<li><strong class="bold">Service level objectives</strong> (<strong class="bold">SLOs</strong>): These provide a specific number<a id="_idIndexMarker006"/> to the aforementioned SLIs. That number is an objective that the DevOps team must meet for their client. Going back to the previous example in the SLI definition: if uptime is the SLI, then having an uptime of 99% a month is the SLO. Typically, a month has 30 days, which is 720 hours, so the website should have a minimum uptime of 712.8 hours in that month with a tolerable downtime of <span class="No-Break">7.2 hours.</span></li>
				<li><strong class="bold">Service level agreements</strong> (<strong class="bold">SLAs</strong>): These are contracts that enforce<a id="_idIndexMarker007"/> an SLO. In an SLA, there is a defined SLO (hope you’re keeping up now) for an SLI which must be achieved by the DevOps team. If this SLA is not fulfilled, the party that contracted the DevOps team is entitled to some compensation. Concluding that example, if there is an SLA for that website with an SLO of 99% uptime, then that is defined in the agreement and that is the metric that needs<a id="_idIndexMarker008"/> to be fulfilled by the DevOps team. However, most SLAs have more than <span class="No-Break">one SLO.</span></li>
			</ul>
			<p>To put it simply, SLIs (are measured for) -&gt; SLOs (are defined in) -&gt; <span class="No-Break">SLAs.</span></p>
			<p>One of the more prominent examples of an SLA<a id="_idIndexMarker009"/> that the AWS team likes to show off is the 11 9s (99.999999999%) of durability for Amazon’s <strong class="bold">Secure Storage Service</strong> (<strong class="bold">S3</strong>) (other cloud object storage services do the same as well). This means that any S3 bucket loses one object every 10,000 years. It also has a 99.9% availability for its standard-tier<strong class="bold"> </strong>SLA. This is equivalent to being down for 44 minutes out of a calendar month of <span class="No-Break">30 days.</span></p>
			<p>Now, these three abbreviations are related to availability, but in an ancillary way. The next two abbreviations will be much more focused on what availability actually entails contractually <span class="No-Break">and goal-wise.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>RTOs and RPOs</h2>
			<p>These two abbreviations<a id="_idIndexMarker010"/> are much more availability-focused than the other three. <strong class="bold">Recovery Time Objectives</strong> (<strong class="bold">RTOs</strong>) and <strong class="bold">Recovery Point Objectives</strong> (<strong class="bold">RPOs</strong>) are used as measuring sticks to measure<a id="_idIndexMarker011"/> the borders of availability. If an application fails to fall within its RTO or RPO then it hasn’t fulfilled its guarantee of availability. RTOs and RPOs are largely concerned with recovering operations after a disaster. There are financial, medical, and other critical systems in this world that wouldn’t be able to function if their underlying systems went down for even a few minutes. And given the <em class="itali">everything fails all the time</em> motto, that disaster or failure is <span class="No-Break">not unrealistic.</span></p>
			<p>An RTO is placed on a service when there is a need for a service to constantly be up and the time used in RTO is the amount of time that a service can afford to be offline before it recovers and comes online again. The fulfillment of an RTO is defined in the SLA as the maximum time that a system will be down before it is available again. To be compliant with the SLA that the DevOps has, they must recover the system within that <span class="No-Break">time frame.</span></p>
			<p>Now, you may think this is easy: just turn the thing on and off again, right? Well, in many cases that’ll do the job, but remember that this is not about just doing the job, it’s about doing the job within a set amount <span class="No-Break">of time.</span></p>
			<p>In most cases, when a server goes down, restarting the server will do the trick. But how long does that trick take? If your RTO is five minutes and you take six minutes to restart your server, you have violated your RTO (and in a lot of critical enterprise systems, the RTO is lower than that). This is why, whenever you define RTOs initially, you should do two things: propose for more time than you have and think <span class="No-Break">with automation.</span></p>
			<p>Modern SLAs of 99% (seven hours a month) or even 99.9% (44 minutes a month) are achieved through the removal of human interaction (specifically, hesitation) from the process of recovery. Services automatically recover through constant monitoring of their health so when an instance shows signs of unhealthiness, it can either be corrected or replaced. This concept is what gave rise to the popularity of Kubernetes which in its production form has the best recovery and health check concepts on <span class="No-Break">the market.</span></p>
			<p>RPOs are different in that they are largely related to data and define a specific date or time (point) which the data in a database or instance can be restored from. The RPO is the maximum tolerable difference of time between the present and the date of the backup or recovery point. For example, a database of users on a smaller internal application can have an RPO of one day. But a business-critical application may have an RPO of only a few minutes (<span class="No-Break">if that).</span></p>
			<p>RPOs are maintained through constant backups and replicas of databases. The database in most applications that<a id="_idIndexMarker012"/> you use isn’t the primary database but a <strong class="bold">read replica</strong> that is often placed in a different geographical region. This alleviates the load from the primary database, leaving it open for exclusive use for writing operations. If the database does go down, it can usually be recovered very quickly by promoting one of the read replicas into the new primary. The read will have all of the necessary data, so consistency is usually not a problem. In the event<a id="_idIndexMarker013"/> of a disaster in a data center, such backup and recovery options become<a id="_idIndexMarker014"/> very important for restoring <span class="No-Break">system functions.</span></p>
			<p>Based on these objectives and agreements, we can come up with metrics that can affect team behavior, like our <span class="No-Break">next topic.</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>Error budgets</h2>
			<p>In a team following DevOps principles, error budgets<a id="_idIndexMarker015"/> become a very important part of the direction that the team takes in the future. An error budget is calculated with this formula: <em class="itali">Error budget = 1-SLA (</em><span class="No-Break"><em class="itali">in decimal)</em></span></p>
			<p>What this basically means is that <em class="itali">an error budget is the percentage left over from the SLA</em>. So, if there is an SLA of 99%, then the error budget would be 1%. It is the downtime to our uptime. In this case, the error budget per month would be around 7.2 hours. According to this budget, we can define how our team can progress based on <span class="No-Break">team goals:</span></p>
			<ul>
				<li>If the team’s goal is reliability, then the objective should be to tighten the error budget. Doing this will help the team deliver a higher SLO and gain more trust from their customers. If you tighten an SLO from 99% to 99.9%, you are reducing the tolerable downtime from 7.2 hours to 44 minutes, so you need to ensure that you can deliver on such a promise. Inversely, if you cannot deliver on such an SLO, then you shouldn’t promise it in any sort <span class="No-Break">of agreement.</span></li>
				<li>If the team’s goal is developing new features, then it mustn’t come at the cost of a decreased SLO. If a large amount of the error budget is being consumed every month, then the team should pivot from working on new features to making the system <span class="No-Break">more reliable.</span></li>
			</ul>
			<p>All these statistics exist to help us have metrics that can be used to maintain high availability. But we aren’t the ones who will use them, we will simply configure them to be <span class="No-Break">used automatically.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>How to automate for high availability?</h2>
			<p>Now that you know the rules<a id="_idIndexMarker016"/> of the game, you need to figure out how to work within the rules and deliver on the promises that you have given your customers. To accomplish <a id="_idTextAnchor034"/>this, you simply have to accomplish the things that have been set in your SLAs. Not particularly difficult on a small scale, but we’re not here to <span class="No-Break">think small.</span></p>
			<p>There are some essentials that every DevOps engineer needs to know to accomplish <span class="No-Break">high availability:</span></p>
			<ul>
				<li>Using desired state configurations on virtual machines to prevent <span class="No-Break">state drift</span></li>
				<li>How to properly backup data and recover it quickly in the event of <span class="No-Break">a disaster</span></li>
				<li>How to automate recovery of servers and instances with <span class="No-Break">minimal downtime</span></li>
				<li>How to properly monitor workloads for signs of errors <span class="No-Break">or disruptions</span></li>
				<li>How to succeed, even when <span class="No-Break">you fail</span></li>
			</ul>
			<p>Sounds easy, doesn’t it? Well, in a way it is. All these things are interconnected and woven into the fabric of DevOps and depend upon each other. To recover success from failure is one of the most important skills to learn in life, not just <span class="No-Break">in DevOps.</span></p>
			<p>This concept of failure and recovering<a id="_idIndexMarker017"/> back to a successful state has been taken even further by the DevOps community through the development of tools that maintain the necessary state of the workload <span class="No-Break">through code.</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor035"/>Delving into infrastructure as a code</h1>
			<p>Finally, in a book about Python, we get<a id="_idIndexMarker018"/> to a section about code. So far, I’ve given you a lot of information about what needs to be accomplished but to accomplish the things we want especially in this book, we must have a method, a tool, a weapon, <span class="No-Break">i.e., code.</span></p>
			<p>Now the word “code” scares a lot of people in the tech industry, even developers. It’s weird being afraid of the thing that is under everything you work with. But that’s the reality sometimes. If you, dear reader, are such a person, first off, it’s a brave thing to purchase this book, and secondly, all you are doing is denying yourself the opportunity to solve all the problems you have in the <span class="No-Break">world. Seriously.</span></p>
			<p>Now, the reason is that code is the weapon of choice in almost every situation. It is the solution to all your automation problems, monitoring problems, response problems, contract problems, and maybe other problems that you may have that I don’t know about. And a lot of it requires a minimal amount <span class="No-Break">of code.</span></p>
			<p class="allout-heading">Important note</p>
			<p class="allout">Remember this: the amateur writes no code, the novice writes a lot of code and the expert writes code in a way that it seems like they’ve written nothing at all, so expect a lot of code in <span class="No-Break">this book.</span></p>
			<p>Let me explain further. To maintain the consistency of service required by DevOps, you need something constant; something that your resources can fall back on that they can use to maintain themselves to a standard. You can write code <span class="No-Break">for that.</span></p>
			<p>In addition to that, you need to be able to automate repetitive tasks and tasks that require reactions faster than what a human being can provide. You need to free up your own time while also not wasting your client’s time. You can write code <span class="No-Break">for that.</span></p>
			<p>You also need to be flexible and capable of dynamically creating resources regardless of the change in environment as well as the ability to switch over to backups, failovers, and alternates seamlessly. You can write code <span class="No-Break">for that.</span></p>
			<p><strong class="bold">Infrastructure as code</strong> (<strong class="bold">IaC</strong>) is particularly useful for that last part. In fact, you can use it to encapsulate and formulate the other two as well. IaC is the orchestrator. It gives the cloud services a proverbial <em class="itali">shopping list</em> of things it wants and the configuration it wants them in and in exchange for that, and it gets the exact configuration that was coded <span class="No-Break">on it.</span></p>
			<p>The fact that IaC is a <em class="itali">get-exactly-what-you-want</em> system is a word of caution because as with everything involving computers, it will do <em class="itali">exactly</em> what you want, which means you need to be very specific and precise when using <span class="No-Break">these frameworks.</span></p>
			<p>Let’s look at a little sample<a id="_idIndexMarker019"/> that we will use to demonstrate the concept behind IaC using some simple pseudocode (without any of that <span class="No-Break">pesky syntax).</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor036"/>Pseudocode</h2>
			<p>I’m not going to write <a id="_idIndexMarker020"/>any actual code for IaC in this chapter (you can find that in the chapter dedicated to IaC), I’m just going to give a quick overview of the concept behind IaC using some pseudocode definitions. These will help you understand how singular IaC definitions work in <span class="No-Break">securing resources.</span></p>
			<p>An example pseudocode – to create a virtual machine - broken down into the simplest pieces would be something like <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="sour e-inline">Module Name</strong> (Usually descriptive of the service <span class="No-Break">being deployed)</span><ul><li><strong class="sour e-inline">VM Name</strong> (<span class="No-Break">say </span><span class="No-Break"><strong class="sour e-inline">VM1</strong></span><span class="No-Break">)</span></li><li><strong class="sour e-inline">Resources allocated</strong> (Specifications, or class of VM) (say 1 <span class="No-Break">GB RAM)</span></li><li>Internal networking and IP addresses (<span class="No-Break">in </span><span class="No-Break"><strong class="sour e-inline">VPC1</strong></span><span class="No-Break">)</span></li><li>Tags (say <strong class="sour e-inline">"</strong><span class="No-Break"><strong class="sour e-inline">Department": "Accounting"</strong></span><span class="No-Break">)</span></li></ul></li>
			</ul>
			<p>This example will create a VM named <strong class="sour e-inline">VM1</strong>, with 1 GB of RAM in a VPC or equivalent network named <strong class="sour e-inline">VPC1</strong> with a tag of key <strong class="sour e-inline">Department</strong> with an <strong class="sour e-inline">Accounting</strong> value. Once launched, that is exactly<a id="_idIndexMarker021"/> what will happen. Oops, I needed 2 GB of RAM. What do I <span class="No-Break">do now?</span></p>
			<p>That’s easy, just change <span class="No-Break">your code:</span></p>
			<ul>
				<li><strong class="sour e-inline">Module Name</strong> (Usually descriptive of the service <span class="No-Break">being deployed)</span><ul><li><strong class="sour e-inline">VM Name</strong> (<span class="No-Break">say </span><span class="No-Break"><strong class="sour e-inline">VM1</strong></span><span class="No-Break">)</span></li><li><strong class="sour e-inline">Resources allocated</strong> (Specifications, or class of VM) (now its <span class="No-Break">2GB RAM)</span></li><li>Internal networking and IP addresses (<span class="No-Break">in </span><span class="No-Break"><strong class="sour e-inline">VPC1</strong></span><span class="No-Break">)</span></li><li>Tags (say <strong class="sour e-inline">"</strong><span class="No-Break"><strong class="sour e-inline">Department": "Accounting"</strong></span><span class="No-Break">)</span></li></ul></li>
			</ul>
			<p>And that’s how easy that is. You can see why it’s popular. It is stable enough to be reliable, but flexible enough to be reusable. Now, here are a couple of other pointers that will help you understand how<a id="_idIndexMarker022"/> most IaC <span class="No-Break">templates work:</span></p>
			<ul>
				<li>If you had renamed the VM, it would have been redeployed with the <span class="No-Break">new name</span></li>
				<li>If you had renamed the module, most templates would by default tear down and decommission the old VM in the old module and create a new one <span class="No-Break">from scratch</span></li>
				<li>Changing the network or VPC would logically move the VM to the other network whose network rules it would <span class="No-Break">now follow</span></li>
				<li>Most templates would allow you to loop or iterate over <span class="No-Break">multiple VMs</span></li>
			</ul>
			<p>IaC, man what a concept. It’s a very interesting – and very popular – solution to a common problem. It can solve a lot of DevOps headaches and should be in the arsenal of every <span class="No-Break">DevOps</span><span class="No-Break"><a id="_idIndexMarker023"/></span><span class="No-Break"> engineer.</span></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor037"/>Summary</h1>
			<p>The concept of DevOps is exciting, vast, and has room to get creative. It is a discipline where the world is essentially at your command. Effective DevOps requires effective structure and adaptation of that structure to a challenge as we learned in our <em class="itali">Exploring </em><span class="No-Break"><em class="itali">automation</em></span><span class="No-Break"> section.</span></p>
			<p>But remember, <em class="itali">anything that can go wrong will go wrong</em>, so plan for success but prepare for the fact that failure is a common occurrence. In such cases of failure – as we learned in the sections about monitoring and event response – the ability to recover is what matters, and the speed of that recovery also matters quite often. If an incident to be recovered from is new, it must be reported and understood so that such incidents can be mitigated in <span class="No-Break">the future.</span></p>
			<p>And lastly, as we covered in <em class="itali">Delving into infrastructure as a code</em>, code is your friend. Be nice to your friends and play with them. You’ll learn how to in <span class="No-Break">this book.</span></p>
		</div>
	</body></html>