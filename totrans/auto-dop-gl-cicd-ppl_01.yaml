- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Understanding Life Before DevOps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 DevOps 之前的生活
- en: To appreciate the power of **GitLab CI/CD pipelines** and the **DevOps** method
    of software development, we must understand how software was built before tools
    like GitLab appeared. Although you won’t learn anything practical in this chapter,
    you’ll learn about the world that GitLab CI/CD pipelines grew out of and get a
    clear picture of what problems GitLab CI/CD pipelines solve. Having a grasp of
    these things will set you up to understand why GitLab CI/CD pipelines operate
    the way they do and will open your eyes to the amazing power that they bring to
    the software development life cycle. In short, the best way to understand how
    things are now is to understand how bad they used to be!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 **GitLab CI/CD 管道** 和 **DevOps** 方法的强大功能，我们必须了解在 GitLab 等工具出现之前，软件是如何构建的。尽管在本章你不会学到任何实际操作，但你将了解
    GitLab CI/CD 管道所起源的世界，并清楚地看到它们解决了哪些问题。理解这些内容将帮助你理解 GitLab CI/CD 管道为何如此运作，并使你对它们在软件开发生命周期中带来的强大力量大开眼界。简而言之，理解现在的工作方式，最好的方法就是理解过去的艰难！
- en: This chapter will introduce you to a fictional but realistic web app called
    **Hats for Cats+**, which sells – you guessed it – head coverings for felines.
    You’ll get a quick overview of what’s involved with turning Hats for Cats from
    an idea into a well-written, tested, and deployed web app. You’ll see how these
    tasks would have to be done in a world where GitLab CI/CD pipelines don’t exist
    so that the benefits of GitLab will be even more obvious when you learn about
    them in later chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍一个虚构但真实的网络应用程序，名为**Hats for Cats+**，它销售——你猜对了——猫咪的头饰。你将快速了解如何将“猫咪帽子”从一个创意转变为一个写得好、经过测试并且部署的网络应用程序。你将看到，在没有
    GitLab CI/CD 管道的世界里，这些任务是如何完成的，这样当你在后续章节中学习 GitLab 时，其优势将更加明显。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要主题：
- en: Introducing the Hats for Cats web app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍“猫咪帽子”网络应用
- en: Building and verifying code manually
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动构建和验证代码
- en: Security-testing code manually
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动进行安全测试代码
- en: Packaging and deploying code manually
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动打包和部署代码
- en: Problems with manual software development life cycle practices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动软件开发生命周期实践的问题
- en: Solving problems with DevOps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 DevOps 解决问题
- en: Introducing the Hats for Cats web app
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍“猫咪帽子”网络应用
- en: Hats for Cats is a pretend web app for selling baseball caps, cowboy hats, and
    bowlers for your favorite furry friends. Imagine that it’s a standard online store
    like hundreds or thousands of others that you’ve used. It lets people browse through
    the catalog of hats, put items in a shopping cart, and enter billing and shipping
    information.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “猫咪帽子”是一个虚拟的网络应用，用于销售棒球帽、牛仔帽和礼帽，专为你喜爱的毛茸茸的小伙伴们设计。假设它是一个标准的在线商店，就像你使用过的成百上千个商店一样。它允许人们浏览帽子目录，加入购物车并输入账单和配送信息。
- en: 'The user experience or graphic design of Hats for Cats doesn’t matter for this
    book. The web app framework that it’s based on doesn’t matter. Even the computer
    language that it’s written in doesn’t matter. I’ll say that again because it’s
    an important but possibly surprising point: *this book is language-agnostic*.
    It will include examples in several computer languages, to increase the chances
    that at least some of the examples are in a language that you’re familiar with.
    But whether your apps – or the Hats for Cats web app – are written in Java, JavaScript,
    Python, Ruby, or any other language doesn’t matter. The general GitLab CI/CD principles
    described in this book apply regardless.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不涉及“猫咪帽子”的用户体验或图形设计。它所基于的网络应用框架也不重要，甚至它所使用的编程语言也不重要。我再说一遍，因为这是一个重要但可能让你惊讶的点：*本书不依赖特定语言*。它将包括多种编程语言的示例，以增加你至少能理解某些示例的可能性。但无论你的应用程序——或者是“猫咪帽子”应用——是用
    Java、JavaScript、Python、Ruby 或任何其他语言编写的，都不重要。本书所描述的 GitLab CI/CD 原则适用于所有情况。
- en: What *does* matter are the general steps that you need to take to make sure
    the code is of high quality, behaves as expected, is secure, has adequate performance,
    is packaged sensibly, and is deployed to the right environments at the right times.
    This book focuses on how GitLab CI/CD pipelines can make various steps in the
    **software development life cycle** (**SDLC**) easier, faster, and more reliable.
    It won’t show you how to write the Hats for Cats web app. It will be assumed that
    all the coding happens behind the scenes, after which you’ll be shown how to build,
    verify, secure, package, and release that code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是你需要采取的一般步骤，以确保代码具有高质量、按预期行为运行、安全、性能足够、打包合理，并在正确的时间部署到合适的环境中。本书的重点是 GitLab
    CI/CD 管道如何使软件开发生命周期（**SDLC**）中的各个步骤变得更轻松、更快速且更可靠。它不会教你如何编写“Hats for Cats” web
    应用程序。假设所有编码工作都在后台完成，之后你将学习如何构建、验证、安全性、打包和发布这些代码。
- en: With that in mind, let’s walk through the high-level steps that you’d need to
    follow to get your code ready for users, in a world before GitLab existed. These
    are all the manual equivalents of what GitLab CI/CD pipelines can do for you automatically.
    But understanding the limitations of the manual processes, and the pain and tedium
    involved with following them, will help you understand the real power of GitLab.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这一点，让我们一步步走过你需要遵循的高层次步骤，以便在 GitLab 出现之前将你的代码准备好供用户使用。这些都是 GitLab CI/CD 管道能够自动为你完成的手动等价过程。但理解手动过程的局限性，以及执行这些过程所涉及的痛苦和繁琐，将帮助你理解
    GitLab 的真正强大之处。
- en: Building and verifying code manually
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动构建和验证代码
- en: Before GitLab CI/CD pipelines appeared, you needed to build and verify your
    code manually. This was often a terrible, soul-crushing experience, for reasons
    we’ll discuss here.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab CI/CD 管道出现之前，你需要手动构建和验证代码。这通常是一次糟糕的、让人心力交瘁的体验，原因我们将在这里讨论。
- en: Building code manually
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动构建代码
- en: Building code depends on what language you use. If you use an interpreted language
    such as Python or Ruby, then building might not be necessary at all. But if you’re
    writing in a compiled language, you’d need to build your app by compiling its
    source code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 构建代码取决于你使用的语言。如果你使用的是像 Python 或 Ruby 这样的解释型语言，那么可能根本不需要构建。但是，如果你编写的是编译型语言，那么你需要通过编译源代码来构建你的应用程序。
- en: 'Imagine that you’re using Java. The following are just some of the different
    ways to compile Java source code into executable Java classes:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你正在使用 Java。以下是将 Java 源代码编译成可执行 Java 类的几种不同方式：
- en: You could use the `javac` Java compiler that ships with the Java Development
    Kit
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用随 Java 开发工具包一起提供的 `javac` Java 编译器
- en: You could use the Maven build tool
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Maven 构建工具
- en: You could use the Gradle build tool
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 Gradle 构建工具
- en: 'There are lots of reasons that this manual build process is a tedious, annoying
    chore that most developers would happily leave behind:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多原因说明这个手动构建过程是繁琐且令人烦恼的，大多数开发人员都希望抛弃它：
- en: 'It’s subject to user error: how many times have you forgotten whether you need
    to point `javac` at the top-level package that your classes are in, or at the
    individual class files?'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它容易出错：你有多少次忘记了是否需要将 `javac` 指向你类所在的顶级包，或者指向单独的类文件？
- en: It’s slow, taking anywhere from a few seconds to several minutes, depending
    on how big your application is. That can add up to a lot of downtime.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很慢，可能需要几秒钟到几分钟，具体取决于你的应用程序有多大。这可能会导致大量的停机时间。
- en: It’s easy to forget, causing confusion when you accidentally execute old code
    that doesn’t behave like you thought it would.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它很容易被忘记，导致混乱，当你不小心执行了行为与预期不同的旧代码时。
- en: Badly written code can fail to compile, causing everyone to waste time as the
    build engineer sends the code back to the developers for fixes, and waits for
    those fixes to arrive.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写不当的代码可能无法编译，导致每个人浪费时间，构建工程师将代码返回给开发人员进行修复，并等待修复的到来。
- en: Verifying code manually
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动验证代码
- en: 'Once you’ve built your code, you need to verify that it’s working correctly.
    Testing takes countless shapes and forms, and there are more kinds of tests than
    we could describe in this book. But here are some of the most common forms that
    you may want to subject your code to:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建好了代码，你需要验证它是否正确运行。测试有无数种形式，且测试的种类比我们在本书中能描述的还要多。但这里是一些你可能希望对代码进行的最常见的测试形式：
- en: '![Figure 1.1 – Tests for verifying code](img/B18073_Fig_1.1.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 验证代码的测试](img/B18073_Fig_1.1.jpg)'
- en: Figure 1.1 – Tests for verifying code
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 验证代码的测试
- en: Functional tests
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能测试
- en: 'Does your program do what it’s supposed to? That’s the question that **functional
    tests** answer. Most programming projects begin with a specification that describes
    how the software should behave: given a certain input, what output should it provide?
    The developers are only done with their jobs when the code they write conforms
    to those specs. How do they know that their code conforms? That’s where functional
    tests come in.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序做的事情是否符合预期？这是**功能测试**所要回答的问题。大多数编程项目都从一份描述软件应如何行为的规格说明开始：给定某个输入，应该提供什么输出？开发人员只有在他们编写的代码符合这些规格时，才算完成工作。如何知道代码是否符合规格？这就是功能测试的作用所在。
- en: Just like there are many forms of testing in general, there are many sub-categories
    of testing that, together, make up functional tests.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一般有很多种测试形式一样，也有许多子类别的测试，它们共同构成了功能测试。
- en: '`2 + 2` into a calculator, it had better return `4`! Happy path tests seem
    like the most important kind of tests because they check behavior that users are
    most likely to run into when they use your software. But in fact, you can usually
    cover the most common use cases with just a few happy path tests. The tests that
    cover unusual or unexpected cases tend to be far more numerous.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`2 + 2`输入到计算器，它应该返回`4`！顺畅路径测试看起来像是最重要的测试类型，因为它们检查用户在使用软件时最有可能遇到的行为。但实际上，你通常可以通过少数几个顺畅路径测试来覆盖最常见的用例。那些涵盖不寻常或意外情况的测试通常要多得多。
- en: Speaking of unusual cases, that’s where `56 ÷ 209` (where these values are in
    the middle of the range of values the calculator will accept) than they are to
    enter `0 + 0` or `999,999 – 999,999` (since those values are at the edges of the
    range). Edge -case testing makes sure that input values at the far edges of the
    acceptable spectrum don’t break your software. Can you create a username that
    consists of a single letter? Can you order 9,999 copies of a book? Can you deposit
    1 cent into a bank account? If the specifications say that your software should
    be able to handle these edge cases, you’d better make sure it really can!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 说到不寻常的情况，`56 ÷ 209`（这些值处于计算器可以接受的值范围的中间位置）比输入`0 + 0`或`999,999 – 999,999`（因为这些值位于范围的边界）更具挑战性。边界测试确保在接受范围的最远端的输入值不会导致软件崩溃。你能创建一个由单个字母组成的用户名吗？你能订购9,999本书吗？你能向银行账户存入1美分吗？如果规格说明说你的软件应该能处理这些边界情况，那你最好确保它真的能！
- en: 'If edge -case testing ensures that your software can handle an input value
    that’s right up against the edge of acceptable values, **corner-case testing**
    confirms that your software can handle two or more simultaneous edge cases. Think
    of it as turbocharged edge-case testing that challenges your software by placing
    it in even more uncomfortable (but still valid) situations. For example, does
    your banking app allow you to schedule a withdrawal for the smallest valid amount
    of currency at the farthest valid date in the future? There’s no need to limit
    corner-case testing to two input values: if your software accepts three or ten
    or 100 input values at a time, you’ll need to make sure it works when *every*
    input is pushed all the way to the extreme end of the range of values valid according
    to the specifications.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果边界测试确保你的软件能够处理接近接受范围边缘的输入值，那么**极限测试**则验证软件是否能够处理两个或更多的同时出现的边界情况。可以把它当作加速版的边界测试，挑战你的软件，把它置于更加不舒服（但仍然有效）的情境中。例如，你的银行应用程序是否允许你在最远的有效日期安排提款，且金额为最小有效货币金额？极限测试不仅限于两个输入值：如果你的软件一次接受三个、十个或一百个输入值，你就需要确保它在*每个*输入值都被推到有效范围的极端值时仍然能正常工作。
- en: That handles cases where the software is given valid values. But do you also
    need to make sure it behaves correctly when it receives *invalid* values? Of course
    you do! This form of testing is sometimes called `negative-6` dollars. And your
    currency conversion software should give a sensible error message when you ask
    about an exchange rate on February 31, 2020.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了软件接收有效值的情况。但你是否也需要确保它在接收*无效*值时能正确行为？当然需要！这种测试形式有时被称为`负6`美元。当你查询2020年2月31日的汇率时，你的货币转换软件应该给出一个合理的错误消息。
- en: Since there are usually more ways to enter bad data than good data into an application,
    developers often concentrate on correctly processing *expected* data but fail
    to think through the types of unexpected, malformed, or out-of-range data that
    their users might enter. Programs need to anticipate and gracefully handle *all*
    sorts of data – both good and bad. Writing complete sets of both happy path and
    unhappy path tests is the best way to make sure that the developer has written
    code that behaves well no matter what data a user throws at it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于通常有更多方式将错误数据输入应用程序而非正确数据，开发人员通常专注于正确处理*预期*数据，但未能考虑用户可能输入的意外、格式错误或超出范围的数据类型。程序需要预测并优雅地处理*所有*类型的数据——无论是好数据还是坏数据。编写完整的“顺利路径”和“不顺利路径”测试集是确保开发人员编写的代码无论用户输入什么数据都能表现良好的最佳方法。
- en: 'Those are some of the *kinds of behavior* that involve both valid and invalid
    data that tests can check for. But there’s another dimension that you can use
    to categorize tests: the *size of the code chunk* that a test targets.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些涉及有效数据和无效数据的*行为类型*，测试可以检查这些内容。但是，还有另一个维度可以用来分类测试：测试所针对的*代码块的大小*。
- en: 'In most cases, the smallest piece of code that a test can check is a single
    method or function. For example, you may want to test a function called **alphabetize**
    that takes any number of strings as input and returns those same strings, but
    now in alphabetical order. To test this function, you would probably use a kind
    of test called a **unit test**. It tests a single *unit* of code, where a unit
    in this case is a single function. You could have a collection of several unit
    tests that all cover that function, albeit in different ways:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，测试可以检查的最小代码片段是一个单独的方法或函数。例如，您可能想要测试一个名为**alphabetize**的函数，该函数接受任意数量的字符串作为输入，并返回这些相同的字符串，按字母顺序排列。为了测试这个函数，您可能会使用一种叫做**单元测试**的测试方法。它测试代码的单个*单元*，在这个情况下，一个单元就是一个函数。您可以有多个单元测试集合，每个测试以不同的方式覆盖这个函数：
- en: Some might cover happy paths. For example, they could pass the `dog`, `cat`,
    and `mouse` strings as input.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些测试可能覆盖顺利路径。例如，它们可以传递`dog`、`cat`和`mouse`字符串作为输入。
- en: Some might cover edge or corner cases. For example, they could pass the function
    a single empty string, strings that consist only of digits, or strings that are
    already alphabetized.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些测试可能覆盖边缘或极端情况。例如，它们可以将一个空字符串传递给函数，或者传递仅由数字组成的字符串，或已按字母顺序排列的字符串。
- en: Some might cover unhappy paths. For example, they could pass the function an
    unexpected data type, such as booleans, instead of the expected data type of strings.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些测试可能覆盖不顺利路径。例如，它们可以传递一个意外的数据类型，如布尔值，而不是预期的数据类型字符串。
- en: 'To verify the behavior of bigger pieces of code, you can use **integration
    tests**. These don’t look at single functions, but instead at how groups of functions
    interact with each other. For example, imagine that your currency conversion application
    has four functions:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证较大代码片段的行为，您可以使用**集成测试**。这些测试不会关注单个函数，而是关注函数组之间如何相互作用。例如，假设您的货币转换应用有四个函数：
- en: '`get_input`, which takes input from the user in the form of a source currency,
    a source amount, and a target currency.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_input`，该函数从用户那里获取输入，包括源货币、源金额和目标货币。'
- en: '`convert`, which converts that amount of source currency into the correct amount
    of the target currency.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`convert`，该函数将源货币的金额转换为正确的目标货币金额。'
- en: '`print_output`, which tells the user how much target currency the conversion
    produces.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print_output`，该函数告诉用户转换后产生的目标货币数量。'
- en: '`main`, which is the main entry point to your app. This is the function that
    is called when your app is used. It calls the three other functions and passes
    the output of each function as input to the next.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`，这是您的应用的主要入口点。当使用您的应用时，调用的就是这个函数。它会调用另外三个函数，并将每个函数的输出作为输入传递给下一个函数。'
- en: To make sure these functions play nicely together – that is, to check if they
    *integrate* well – you need integration tests that call `main`, as opposed to
    unit tests that call `get_input`, `convert`, and `print_output`. This lets you
    test at a higher level of abstraction, which is to say a level that gets closer
    to how a real user would use your application. After all, a user isn’t going to
    call `get_input` in isolation. Instead, they will call `main`, which, in turn,
    will call the other three functions and coordinate passing values between them.
    It’s easy to write a function that works as expected on its own, but it’s harder
    to make a collection of functions cooperate to build a larger piece of logic.
    Integration tests spot this type of problem in a way that pure unit tests can’t.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这些功能能够和谐地协同工作——也就是说，检查它们是否*良好集成*——你需要编写集成测试来调用`main`，而不是编写调用`get_input`、`convert`和`print_output`的单元测试。这让你能够在更高的抽象层次上进行测试，也就是更接近真实用户使用应用程序的方式。毕竟，用户不会单独调用`get_input`，他们会调用`main`，而`main`则会调用其他三个函数并协调它们之间的值传递。编写一个独立工作正常的函数很容易，但让多个函数协作构建更大的逻辑则更为困难。集成测试能够发现这种问题，而纯粹的单元测试则无法做到。
- en: 'Testers often think of various sorts of tests as forming a pyramid. According
    to this model, unit tests occupy the wide, low base of the pyramid: they are low-level
    in the sense that they test fundamental pieces of code, and there are many of
    them. Integration tests occupy the middle of the pyramid: they operate at a higher
    level of abstraction than unit tests, and there are fewer of them. At the top
    of the pyramid is a third category of tests, which we’ll talk about next – **user
    tests**:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 测试人员常常将各种测试形式看作一个金字塔。根据这一模型，单元测试占据了金字塔的宽大低端：它们是低级的，因为它们测试的是代码的基本单元，而且数量众多。集成测试则位于金字塔的中间：它们的抽象层次高于单元测试，且数量较少。金字塔的顶部是第三类测试，我们接下来将讨论的——**用户测试**：
- en: '![Figure 1.2 – The test pyramid](img/B18073_Fig_1.2.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 测试金字塔](img/B18073_Fig_1.2.jpg)'
- en: Figure 1.2 – The test pyramid
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 测试金字塔
- en: The final type of test, user tests, simulate a user’s behavior and exercise
    the software the same way a user would. For example, if users interact with a
    foreign exchange app by entering a source currency, an amount of that source currency,
    and a target currency, and then expect to see the output in the form of an amount
    of the target currency, then that’s exactly what a user test will do. This might
    mean that it uses the app’s GUI by clicking on buttons and entering values in
    fields. Or it might mean that it calls the app’s REST API endpoints, passing in
    input values and inspecting the result for the output value. However, it interacts
    with the application and does so in a fashion that’s as similar to a real user
    as possible. As with unit and integration tests, user tests can include happy
    path tests, edge- and corner-case tests, and unhappy path tests to cover all the
    scenarios that the software’s specifications describe, as well as any other scenarios
    that the test designer can concoct.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种测试类型是用户测试，它模拟用户的行为，并以用户的方式使用软件。例如，如果用户通过输入源货币、该源货币的金额和目标货币，然后期望看到目标货币的输出金额，那么这正是用户测试所做的事情。这可能意味着它使用应用程序的图形用户界面（GUI），通过点击按钮和在字段中输入值来操作。或者，它可能通过调用应用程序的REST
    API接口，传入输入值并检查输出结果。然而，它与应用程序进行交互，并且尽可能以最接近真实用户的方式进行。与单元测试和集成测试一样，用户测试可以包括常规路径测试、边缘和极限情况测试，以及异常路径测试，以覆盖软件规格所描述的所有场景，以及测试设计人员可能构思的任何其他场景。
- en: So far, we’ve explained the different purposes of unit, integration, and user
    tests, but we haven’t described another fundamental difference. Unit and integration
    tests are almost always automated. That is, they are computer programs that test
    other computer programs. While user tests are automated whenever possible, there
    are enough difficulties with writing reliable, reproducible tests that interact
    with an application’s GUI that many user tests must be run manually instead. Web
    applications are notoriously hard to test because of unpredictable behavior around
    load times, incomplete page rendering, missing or incompletely loaded CSS files,
    and network congestion. This means that while software development teams often
    attempt to automate user tests of web applications, more often than not, they
    end up with a hybrid of automated and manual user tests. As you may have guessed,
    manual user tests are extraordinarily expensive to run, both in terms of time
    and tester morale.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解释了单元测试、集成测试和用户测试的不同目的，但我们还没有描述另一个基本差异。单元测试和集成测试几乎总是自动化的。也就是说，它们是测试其他计算机程序的计算机程序。虽然用户测试在可能的情况下也是自动化的，但是由于编写可靠且可重现的测试与应用程序
    GUI 交互的困难足够多，因此许多用户测试必须手动运行。Web 应用程序因为在加载时间周围的行为不可预测、页面渲染不完整、缺失或未完全加载的 CSS 文件以及网络拥塞而出名难以测试。这意味着，虽然软件开发团队通常尝试自动化
    Web 应用程序的用户测试，但更常见的情况是他们最终采用自动化与手动用户测试的混合方法。正如您可能已经猜到的那样，手动用户测试在时间和测试人员士气方面成本极高。
- en: Performance tests
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能测试
- en: 'After that high-level tour of functional testing, you may be thinking that
    we’ve covered all the testing bases. But we’re just getting started. Another aspect
    of your application that should probably be tested is its performance: does it
    do what it’s supposed to do quickly enough to keep users from getting frustrated?
    Does it meet performance specifications the developers may have been given before
    they started coding? Is its performance significantly better or worse than the
    performance of its competitors? These are some of the questions that performance
    tests are designed to answer.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在对功能测试进行高级导览之后，您可能会认为我们已经涵盖了所有测试基础。但实际上我们才刚刚开始。您可能还需要测试应用程序的另一个方面：其性能。它是否能够快速执行用户期望的功能，以避免用户感到沮丧？它是否符合开发人员在编码之前所得到的性能规格？它的性能是否明显优于或劣于竞争对手的性能？这些是性能测试旨在回答的一些问题。
- en: '**Performance testing** is notoriously difficult to design and carry out. There
    are so many variables to consider when gauging how quickly your application runs:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能测试**因其设计和执行的复杂性而声名狼藉。在评估应用程序运行速度时需要考虑很多变量：'
- en: What environment should it be running in during the tests? Creating an environment
    identical to the production environment is often prohibitively expensive, but
    what corners can you cut in the test environment that won’t skew the results of
    performance tests too badly?
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试期间应该运行在什么样的环境中？创建与生产环境完全相同的环境通常代价高昂，但在测试环境中可以削减哪些方面而不会严重影响性能测试结果？
- en: What input values should your performance tests use? Depending on the application,
    some input values may take significantly longer to process than others.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的性能测试应使用哪些输入值？根据应用程序的不同，某些输入值的处理时间可能显著长于其他输入值。
- en: If your application is configurable, what configuration settings should you
    use? This is especially important if there is no standard configuration that most
    users settle on.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的应用程序是可配置的，应该使用什么配置设置？如果没有大多数用户都使用的标准配置，则尤其重要。
- en: Even if you can figure out how to design useful performance tests, they often
    take a long time to run and, in some cases, produce inconsistent results. This
    leads teams to rerun performance tests frequently, which causes them to take even
    more time. So, performance tests are among the most critical, and also more expensive,
    of all the test types.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您可以弄清如何设计有用的性能测试，这些测试通常需要很长时间才能运行，并且在某些情况下可能会产生不一致的结果。这导致团队经常重新运行性能测试，这会导致测试所需时间更长。因此，性能测试是所有测试类型中最关键且成本较高的测试之一。
- en: Load tests
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负载测试
- en: Performance tests have a close cousin called **load tests**. Whereas performance
    tests determine how quickly your software can perform one operation (a single
    currency conversion, a single bank deposit, or a single arithmetic problem, for
    example), load tests determine how well your application handles many users interacting
    with it at the same time. Load tests suffer from many of the same design difficulties
    as performance tests and can produce similarly inconsistent results. They can
    be even more expensive to set up since they need a way to simulate hundreds or
    thousands of users.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试有一个密切相关的“亲戚”叫做**负载测试**。性能测试评估的是软件在执行单一操作时的速度（例如单次货币兑换、单次银行存款或单次数学问题），而负载测试评估的是软件在多用户同时交互时的表现。负载测试面临着与性能测试相似的设计难题，可能会产生类似不一致的结果。它们的设置也更加昂贵，因为需要模拟成百上千的用户。
- en: Soak tests
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持续测试
- en: As your application runs for hours or days, does it allocate memory that it
    never reclaims? Does it consume huge amounts of disk space with overzealous logging?
    Does it launch background processes that it never shuts down? If it suffers from
    any of these resource “leaks,” it could lose performance or even crash as it runs
    low on memory, disk space, or dedicated CPU cycles. These problems can be found
    with **soak tests**, which simply exercise your software over an extended period
    while monitoring its stability and performance. It’s probably obvious that soak
    tests are extraordinarily expensive in terms of time and hardware resources to
    run and monitor.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行数小时或数天后，它是否分配了永远不会回收的内存？它是否因为过度记录日志而占用了大量磁盘空间？它是否启动了永远不会关闭的后台进程？如果出现这些资源“泄漏”问题，应用程序可能会因为内存、磁盘空间或CPU周期不足而失去性能，甚至崩溃。这些问题可以通过**持续测试**发现，持续测试是在一段时间内对软件进行持续的测试，同时监控其稳定性和性能。显然，持续测试在时间和硬件资源上非常昂贵，需要大量的投入。
- en: Fuzz tests
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模糊测试
- en: An underutilized but powerful form of testing is called **fuzz testing**. This
    approach sends valid but strange input data into your software to expose bugs
    that traditional functional tests may have missed. Think of it as happy path testing
    while drunk. So, instead of trying to create an account with the username “Sam,”
    try a username that consists of 1,000 letters. Or try to create a username that
    is entirely spaces. Or include Klingon alphabet Unicode characters in a shipping
    address.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一种被低估但非常强大的测试方法叫做**模糊测试**。这种方法会向软件发送有效但异常的数据输入，目的是揭露传统功能测试可能遗漏的错误。可以把它想象成醉酒状态下的正常路径测试。所以，不是尝试用“Sam”作为用户名创建账户，而是尝试用包含1000个字母的用户名，或者尝试创建一个全为空格的用户名，或者在收货地址中包含克林贡字母表的Unicode字符。
- en: 'Fuzz testing introduces a strong element of randomness: the input values it
    sends to your software are either completely randomly generated or are random
    permutations of input values that are known to be unproblematic for your code.
    For example, if your code translates PDF files into HTML files, a fuzz test may
    start by sending slightly tweaked versions of valid, easily handled PDF files,
    and then progress to asking your software to convert purely random strings that
    bear no resemblance to PDF files at all. Because fuzz testing can send many thousands
    of random input values before it stumbles on an input value that causes a crash
    or other bug, fuzz tests must be automated. They are simply too cumbersome to
    run manually.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试引入了强大的随机性：它发送到软件的输入值要么是完全随机生成的，要么是已知不会对代码产生问题的输入值的随机排列。例如，如果你的代码将PDF文件转换成HTML文件，模糊测试可能会从发送稍微调整过的有效PDF文件开始，然后逐步要求软件转换完全随机的字符串，这些字符串与PDF文件完全没有关系。由于模糊测试需要发送成千上万的随机输入值，直到找到一个导致崩溃或其他错误的输入值，因此模糊测试必须自动化进行。手动执行模糊测试实在是太繁琐了。
- en: Static code analysis
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Another strictly automated form of testing is **static code analysis**. Whereas
    the other tests we’ve discussed try to find problems in your code as it runs,
    static code analysis inspects your source code without executing it. It can look
    for a variety of different problems, but in general, it checks to make sure you’re
    conforming to recognized coding best practices and language idioms. These could
    be established by your team, by the developers of the language itself, or by other
    programming authorities.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种严格自动化的测试形式是**静态代码分析**。与我们讨论过的其他测试试图在代码运行时找到问题不同，静态代码分析是在不执行代码的情况下检查你的源代码。它可以查找各种不同的问题，但通常它会检查你是否遵循了公认的编码最佳实践和语言习惯。这些规范可能是由你的团队、语言本身的开发者或其他编程权威制定的。
- en: For example, static code analysis could notice that you declare a variable without
    ever assigning a value to it. Or it could point out that you’ve assigned a value
    to a variable but then never refer to that variable. It can identify unreachable
    code, code that uses coding patterns known to be slower than alternative but functionally
    equivalent patterns, or code that uses whitespace in unorthodox ways. These are
    all practices that may not cause your code to break exactly but could keep your
    code from being as readable, maintainable, or speedy as it could have been.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，静态代码分析可以注意到你声明了一个变量，但从未给它赋值。或者它可能指出你已经给一个变量赋值，但之后从未引用过该变量。它可以识别无法访问的代码、使用已知比其他功能等效模式更慢的编码模式，或者使用不规范的空白字符方式的代码。这些都是可能不会导致代码完全崩溃，但会使你的代码在可读性、可维护性或速度方面远不如预期的做法。
- en: More challenges of verifying code
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证代码的更多挑战
- en: So far, we’ve described just some of the ways that you may want to verify the
    behavior, performance, and quality of your code. But once you’ve finished running
    all these different types of tests, you face the potentially difficult question
    of how to parse, process, and report the results. If you’re lucky, your test tools
    will generate reports in a standard format that you can integrate into an automatically
    updated dashboard. But you’ll likely find yourself using at least one test tool
    or framework that can’t be shoehorned into your normal reporting structure, and
    which needs to be manually scanned, cleaned, and massaged into a format that’s
    easy to read and disseminate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只描述了一些你可能希望验证代码行为、性能和质量的方式。但一旦你完成了所有这些不同类型的测试，你将面临一个可能比较棘手的问题，即如何解析、处理和报告结果。如果你幸运的话，你的测试工具会生成标准格式的报告，你可以将其集成到自动更新的仪表板中。但你很可能会发现自己至少需要使用一个无法嵌入你正常报告结构的测试工具或框架，并且需要手动扫描、清理并调整格式，使其易于阅读和传播。
- en: We’ve already mentioned how performance tests in particular often need to be
    run repeatedly. But in fact, *all* of these types of tests need to be run repeatedly
    to catch regressions or smooth out so-called “flickering” tests, which are tests
    that sometimes pass and sometimes fail, depending on network conditions, server
    loads, or countless other unpredictable factors. This means that the burden of
    either manually running tests, or managing and triggering automated tests, is
    far greater than it appears at first. If you’re going to run tests repeatedly,
    you need to figure out when and how often to do so, you need to make sure the
    right hardware or test environments are available at the right times, and you
    need to be flexible enough to change your testing cadence when conditions change,
    or management asks for more up-to-date results. The point is that testing is tough,
    time-consuming, and error-prone, and all these difficulties are exaggerated every
    time humans need to get involved with making sure the tests happen in the right
    way at the right time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过，特别是性能测试通常需要反复进行。但事实上，*所有*这些类型的测试都需要反复执行，以捕捉回归或平滑所谓的“闪烁”测试，闪烁测试是指根据网络状况、服务器负载或其他无数不可预测因素，有时通过有时失败的测试。这意味着无论是手动执行测试，还是管理和触发自动化测试，所需的工作量远远大于最初看起来的情况。如果你需要反复执行测试，你需要搞清楚何时以及多频繁地进行测试，你需要确保在合适的时间有适当的硬件或测试环境可用，而且你还需要有足够的灵活性来根据条件的变化或管理层要求更为实时的结果时调整你的测试频率。关键是，测试很难、耗时且容易出错，每次需要人工干预以确保测试在正确的时间和正确的方式进行时，这些困难都会被放大。
- en: Even though we’ve just said that tests *should* typically be run and then repeatedly
    rerun, there’s another countervailing force at play. Because executing tests is
    expensive and difficult, there’s a tendency to want to run them as *infrequently*
    as possible. This tendency is encouraged by a common development model that has
    developers building a feature (or sometimes an entire product) and then *throwing
    the code over the wall* to the **Quality Assurance** (**QA**) team for validation.
    This strict division between building the code and testing the code means that
    on many teams, tests are only run at the end of the development cycle – whether
    that’s at the end of a two-week sprint, the end of a year-long project, or somewhere
    in-between.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚才说过测试*应该*通常执行并反复执行，但还有另一个相反的力量在起作用。由于执行测试既昂贵又困难，人们往往倾向于尽可能少地运行测试。这种倾向受到一种常见开发模式的鼓励：即开发者完成一个功能（有时是整个产品）后，再将代码*扔到墙的另一边*交给**质量保证**（**QA**）团队进行验证。代码构建与测试之间的这种严格分工意味着许多团队只会在开发周期的最后阶段才运行测试——无论是在两周的冲刺结束时、一年项目的结束时，还是介于两者之间的某个时刻。
- en: 'The practice of infrequent or delayed testing leads to an enormous problem:
    when the developers turn over a huge batch of code for testing – thousands or
    tens of thousands of lines of code that had been developed by different people
    using different coding styles and idioms over weeks or months – it can be extremely
    hard to diagnose the root cause of any bugs that the tests unearth. This, in turn,
    means that it’s hard to fix those bugs. Just like big haystacks hide needles more
    effectively than small haystacks, large batches of code make it hard to find,
    understand, and correct any bugs that they contain. The longer a development team
    waits before passing code on to the QA team, the bigger this problem becomes.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 不频繁或延迟测试的做法会导致一个巨大的问题：当开发者交付一大批代码进行测试——这些代码是由不同的人在几周或几个月的时间里使用不同的编码风格和习惯开发的，可能有成千上万行——那么诊断测试发现的
    bug 的根本原因会变得极其困难。反过来，这意味着修复这些 bug 也变得困难。就像大草堆比小草堆更能有效地隐藏针一样，大批量的代码让我们很难发现、理解和修正其中的
    bug。开发团队在将代码交给 QA 团队之前等待的时间越长，这个问题就越严重。
- en: This concludes our lightning-fast survey of functional tests, load tests, soak
    tests, fuzz tests, and static code analysis. In addition, we explained some of
    the hidden difficulties involved with running all of these different sorts of
    tests. You might be wondering why we’ve discussed testing at all. The reason is
    that understanding the challenges of testing – getting a feel for how many ways
    there are to verify your code, how important the different forms of tests are,
    how time-consuming it is to set up test environments, how much of a hassle it
    is to manually run non-automatable user tests, how tricky it can be to process
    and report the results, and how tough it can be to find and fix bugs that are
    lurking within a huge bundle of code – is a huge part of understanding how difficult
    software development was before the advent of DevOps. Later in this book, when
    you see how GitLab CI/CD pipelines simplify the process of running different kinds
    of tests and viewing their results, and when you understand how tests that run
    early and often make problems easier to detect and cheaper to fix, you can look
    back at these cumbersome test procedures and feel sympathy for the poor developers
    who had to wade through this part of the SDLC before GitLab existed. Life is much
    better in the GitLab era!
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们快速浏览功能测试、负载测试、浸泡测试、模糊测试和静态代码分析的全部内容。此外，我们还解释了进行这些不同种类测试时所涉及的一些隐藏难题。你可能会想知道我们为什么要讨论测试。原因在于，理解测试的挑战——了解验证代码的方式有多少种，测试的不同形式有多么重要，设置测试环境的时间成本有多高，手动进行无法自动化的用户测试有多麻烦，处理和报告测试结果有多复杂，以及在庞大的代码包中发现并修复潜藏的
    bug 有多么困难——是理解在 DevOps 出现之前软件开发有多艰难的一个重要部分。在本书的后面，你会看到 GitLab CI/CD 管道如何简化运行各种测试并查看其结果的过程，以及当你理解早期和频繁运行的测试如何使问题更容易被发现和更便宜地修复时，你可以回顾这些繁琐的测试程序，并对那些在
    GitLab 出现之前不得不经历这部分 SDLC 的开发者产生同情。GitLab 时代的生活真是好多了！
- en: Security-testing code manually
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动进行安全测试代码
- en: 'We mentioned that functional testing is just one form of testing. Another important
    form is **security testing**. It’s so important and so difficult to get right
    that it’s typically performed by specialized teams that are separate from traditional
    QA departments. There are many ways approaches to security testing, but most boil
    down to one of three categories:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到过功能测试只是测试的一种形式。另一个重要的形式是**安全测试**。它非常重要且非常难以做到完美，因此通常由与传统QA部门分开的专门团队执行。安全测试有许多不同的方法，但大多数都可以归结为以下三类之一：
- en: Inspect source code
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查源代码
- en: Interact with running code
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与运行中的代码互动
- en: Inspect the third-party dependencies used by your project
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查项目使用的第三方依赖
- en: 'Also, there are different kinds of problems that security tests can look for.
    At first glance, some of these problems may not look like they fall under the
    umbrella of security, but they all contribute to potential data loss or manipulation
    of your software by malicious actors:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，安全测试可以查找不同种类的问题。乍一看，这些问题中的一些可能看起来不属于安全问题的范畴，但它们都会导致潜在的数据丢失或软件被恶意操控：
- en: Non-standard coding practices
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非标准编码实践
- en: Unsafe coding practices
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不安全的编码实践
- en: Source code dependencies that contain known vulnerabilities
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 含有已知漏洞的源代码依赖
- en: Let’s look at some specific varieties of security testing and see how they use
    different techniques to look for different sorts of problems.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下安全测试的几种具体类型，看看它们如何使用不同的技术来寻找不同类型的问题。
- en: Static code analysis
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: You can often find unsafe coding practices simply by asking a security expert
    to review your source code. For example, if you ask for user input and then use
    that input to query a database, a wily user might be able to launch a so-called
    *SQL injection attack* by including database commands in their input. Competent
    code reviewers will spot this sort of problem immediately and can often propose
    easy-to-implement solutions.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常可以通过请安全专家审查你的源代码来发现不安全的编码实践。例如，如果你请求用户输入，然后使用该输入查询数据库，聪明的用户可能会通过在输入中加入数据库命令来发起所谓的*SQL注入攻击*。称职的代码审查员会立即发现这种问题，并且通常能提出易于实施的解决方案。
- en: 'For example, the following pseudocode accepts input from the user but doesn’t
    validate the input before using it in a SQL statement. A clever user could enter
    a malicious value such as `Smith OR (0 = 0)` and cause more information to be
    revealed than the developer intended:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下伪代码接受用户输入，但在将其用于SQL语句之前没有验证输入。一个聪明的用户可以输入恶意值，如`Smith OR (0 = 0)`，从而导致暴露出比开发者预期更多的信息：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Code reviews can also identify code that might not be obviously unsafe, but
    that uses non-standard idioms, unusual formatting, or awkward program structure
    that make code harder for other team members (or even the original author) to
    read and maintain. This can indirectly make the code more susceptible to security
    problems in the future, or at the very least make future security problems harder
    for code reviewers to find.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查还可以识别那些可能看起来不明显不安全的代码，但这些代码使用了非标准的习惯用法、异常的格式或尴尬的程序结构，导致代码更难被其他团队成员（甚至原作者）阅读和维护。这可能间接使代码未来更容易遭受安全问题，或者至少使得未来的安全问题更难被代码审查人员发现。
- en: 'For example, the following Python function accepts an unusually large number
    of parameters and then ignores most of them. Both these traits are considered
    to be poor programming practices, even if neither threatens the behavior or security
    of the code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下Python函数接受一个异常多的参数，然后忽略其中大部分。这两种特征都被认为是糟糕的编程实践，即使它们都不会威胁到代码的行为或安全性：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Static code analysis can sometimes happen automatically. Many IDEs offer static
    code analysis as a built-in feature: they draw red warning lines under any non-standard
    or unsafe code they detect. This can be a great help but is best thought of as
    a complement to manual code reviews rather than a full substitute.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析有时会自动进行。许多集成开发环境（IDE）将静态代码分析作为内置功能：它们会在检测到任何非标准或不安全的代码时，在其下方绘制红色警告线。这可能是一个很大的帮助，但最好将其视为对手动代码审查的补充，而不是完全的替代品。
- en: Secret detection
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秘密检测
- en: 'You can think of **secret detection** as a special form of static code analysis.
    There are many types of sensitive data that you want to keep out of your software’s
    source code. It’s not hard to think of examples:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将**秘密检测**视为静态代码分析的一种特殊形式。你希望从软件源代码中排除的敏感数据有很多类型。很容易想到一些例子：
- en: Passwords
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码
- en: Deploy keys
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署密钥
- en: Public SSH or GPG keys
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共SSH或GPG密钥
- en: US Social Security numbers
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美国社会安全号码
- en: Unique personal identification numbers that are used by other countries
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他国家使用的独特个人识别号码
- en: 'Just as static code analysis scans source code to search for programming or
    security problems, secret detection scans source code to find secrets that should
    be removed and stored in a more secure location. For example, the following Java
    code contains a Social Security number that can be seen by anyone with read access
    to the code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 就像静态代码分析扫描源代码以查找编程或安全问题一样，秘密检测扫描源代码以寻找应当删除并存储在更安全位置的秘密。例如，以下 Java 代码包含一个社会安全号码，任何具有读取权限的人都可以看到：
- en: '[PRE2]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Dynamic analysis
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分析
- en: Looking at source code is useful, but there are many categories of software
    defects that are more easily found by interacting with executing code. This interaction
    could take the form of using an application’s GUI just like a human would, sending
    requests to a REST API endpoint, or hitting various URLs of a web app with different
    values in the requests’ query strings.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 查看源代码很有用，但有许多类别的软件缺陷通过与执行中的代码进行交互更容易被发现。这种交互可能表现为像人类一样使用应用程序的 GUI、向 REST API
    端点发送请求，或在 Web 应用程序的不同 URL 上使用不同的请求查询字符串值。
- en: For example, your web server might be configured in such a way as to include
    its version number in the headers of every response. This might seem like harmless
    information, but it can provide clues to malicious actors about which web server-targeted
    exploits are likely to work against your site, and which exploits your web server
    is probably immune to.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您的 Web 服务器可能配置为在每个响应的头部中包含其版本号。这看起来可能是无害的信息，但它可能为恶意攻击者提供有关哪些针对 Web 服务器的漏洞可能对您的站点有效的线索，以及您的
    Web 服务器可能免疫于哪些漏洞。
- en: To take another example, complicated logic in your code might obscure the fact
    that you can trigger an unhandled divide-by-zero error by entering a particular
    set of input values. As discussed earlier, problems like this may not initially
    feel like security risks, but a clever hacker can often find ways to exploit simple
    bugs in ways that expose data, cause data loss, or result in denial-of-service
    attacks.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，您代码中的复杂逻辑可能掩盖了您通过输入一组特定的输入值来触发未处理的除零错误的事实。如前所述，这类问题一开始可能不会被认为是安全风险，但聪明的黑客通常能找到利用简单漏洞的方式，从而暴露数据、导致数据丢失或引发拒绝服务攻击。
- en: 'For example, the following Ruby code could produce a `ZeroDivisionError` instance
    when it runs, which, in turn, could cause the program to crash:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下 Ruby 代码在运行时可能会产生一个 `ZeroDivisionError` 实例，这可能导致程序崩溃：
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Dependency scanning
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖扫描
- en: '**Dependency scanning** is the practice of comparing the names and version
    numbers of each of your product’s dependencies against a database of known vulnerabilities
    and identifying which of those dependencies should be upgraded to a later version
    or removed entirely to improve your software’s security. Virtually every non-trivial
    piece of software written these days relies on tens, hundreds, or thousands of
    third-party, open source libraries. The source code of the most popular libraries
    is pored over by Black Hat hackers looking for possible exploits. These exploits
    are often quickly fixed by the library’s maintainers, but if your project is using
    old, unpatched versions of those libraries, dependency scanning will let you know
    that your code might be vulnerable to those known exploits.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖扫描**是将您产品的每个依赖项的名称和版本号与已知漏洞数据库进行比较，并识别出哪些依赖项应该升级到更高版本或完全删除，以提高软件安全性的实践。如今几乎每一款非平凡的软件都依赖于数十、数百或数千个第三方开源库。这些最受欢迎的库的源代码被黑帽黑客仔细研究，寻找可能的漏洞。这些漏洞通常会被库的维护者迅速修复，但如果您的项目使用的是旧版、未打补丁的库，依赖扫描将告知您，您的代码可能会受到这些已知漏洞的攻击。'
- en: A perfect example of the need for this type of security scanning is in the news
    at the time of writing. Many Java projects rely on an open source Java library
    called Log4j, which provides a convenient way to log informational, warning, or
    error messages. A vulnerability was recently discovered that allows hackers to
    remotely run commands or install malware on any computer Log4j is running on.
    That’s a huge problem! Fortunately, it’s exactly the kind of problem that dependency
    scanning can spot. Any up-to-date dependency scanner will let you know if your
    software has a dependency – either directly or via other dependencies – on an
    unpatched version of Log4j, and will advise you what version of Log4j you should
    upgrade to.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完美的例子，说明了这种类型的安全扫描的必要性，正是当时新闻中的话题。许多 Java 项目依赖于一个名为 Log4j 的开源 Java 库，该库提供了一种便捷的方式来记录信息、警告或错误消息。最近发现了一个漏洞，允许黑客远程执行命令或在任何运行
    Log4j 的计算机上安装恶意软件。这是一个巨大的问题！幸运的是，这正是依赖扫描能够发现的问题。任何更新的依赖扫描工具都会让你知道你的软件是否依赖于未修补版本的
    Log4j，无论是直接依赖还是通过其他依赖关系，并会建议你升级到哪个版本的 Log4j。
- en: Container scanning
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器扫描
- en: These days, many software products are delivered as **Docker** images. The simplest
    possible description of a Docker image is that it is a Linux distribution that
    has your application installed on it and is then packaged in an *image* format
    that can be executed by Docker or similar tools. If you build a Docker image that
    includes an out-of-date version of a Linux distribution that contains security
    vulnerabilities, your application will not be as secure as it could be.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，许多软件产品以**Docker**镜像的形式交付。最简单的描述就是，Docker 镜像是一个已经安装了你的应用程序的 Linux 发行版，并将其打包成一种可以由
    Docker 或类似工具执行的*镜像*格式。如果你构建的 Docker 镜像包含了一个过时的 Linux 发行版，并且该发行版存在安全漏洞，那么你的应用程序将不如它应该有的那样安全。
- en: Container scanning looks at the base Linux image that your *Dockerized* application
    is installed on and checks a database of known security vulnerabilities to see
    if your packaged application might be susceptible to exploits. For example, because
    CentOS 6 stopped being maintained in 2020, the libraries that it includes have
    many severe security vulnerabilities. Container scanning would alert you to this
    problem and suggest that you consider upgrading your application’s Docker image
    to use CentOS 7 or later as a base image.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 容器扫描检查你的*Docker化*应用程序所安装的基础 Linux 镜像，并检查已知安全漏洞的数据库，查看你的打包应用程序是否可能容易受到漏洞攻击。例如，由于
    CentOS 6 在 2020 年停止维护，它包含的许多库存在严重的安全漏洞。容器扫描会提醒你这个问题，并建议你考虑将应用程序的 Docker 镜像升级为使用
    CentOS 7 或更高版本作为基础镜像。
- en: Manual security testing summary
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动安全测试总结
- en: 'With that, we’ve looked at a variety of tests designed to detect security vulnerabilities
    or security-adjacent problems, such as failing to adhere to coding best practices.
    While it may seem like a lot of different steps to go through before you can put
    a simple web app into production, there has never been more ways to steal information
    or shut down a service, and there’s no reason to think that trend will turn around
    any time soon. So, like it or not, responsible developers need to think about
    – and probably implement – all these different security tests:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经讨论了多种旨在检测安全漏洞或安全相关问题的测试方法，例如未遵循编码最佳实践。虽然在将一个简单的 Web 应用投入生产之前可能需要经过很多不同的步骤，但如今窃取信息或关闭服务的方式越来越多，且没有迹象表明这种趋势会很快改变。所以，无论你愿意与否，负责任的开发者都需要考虑并可能实施所有这些不同的安全测试：
- en: '![Figure 1.3 – Some of the many types of security testing](img/B18073_Fig_1.3.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 各种安全测试类型的一部分](img/B18073_Fig_1.3.jpg)'
- en: Figure 1.3 – Some of the many types of security testing
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 各种安全测试类型的一部分
- en: 'Some of these tests must be performed manually. Others have automated tools
    to help. But automated tests are still burdensome: you still have to install security
    testing tools or frameworks, configure testing tools, update test frameworks and
    dependencies, set up and maintain test environments, massage reports, and display
    reports in some integrated fashion. If you try to simplify matters by outsourcing
    some of these tasks to outside companies or **Software-as-a-Service** (**SaaS**)
    tools, you’ll need to learn separate GUIs for each tool, maintain different user
    accounts for each service, manage multiple licenses, and do a host of other tasks
    to keep your tests working smoothly.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有些测试必须手动执行，其他一些则有自动化工具来帮助。但自动化测试依然繁琐：你仍然需要安装安全测试工具或框架，配置测试工具，更新测试框架和依赖项，设置并维护测试环境，处理报告，并以某种集成的方式展示报告。如果你试图通过将其中一些任务外包给外部公司或**软件即服务**（**SaaS**）工具来简化问题，你将需要为每个工具学习不同的图形用户界面（GUI），为每个服务维护不同的用户帐户，管理多个许可证，并进行一系列其他任务，以保持测试的顺利进行。
- en: This section has shown you more ways that life before GitLab was difficult for
    development teams. As you’ll learn in an upcoming chapter, GitLab’s CI/CD pipelines
    replace the awkward, multi-step security testing processes described previously
    with fast, automated security scanners that you configure once and then benefit
    from for as long as you continue to develop your software project. We’ll revisit
    this topic in much more detail later.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了在GitLab出现之前，开发团队在工作中面临的更多困难。正如你将在接下来的章节中学到的，GitLab的CI/CD流水线用快速、自动化的安全扫描工具取代了之前描述的繁琐、多步骤的安全测试过程，配置一次后，你可以在继续开发软件项目的过程中持续受益。我们稍后将更详细地讨论这个话题。
- en: Packaging and deploying code manually
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动打包和部署代码
- en: Now that your software has been built, verified, and is secure, it’s time to
    think about packaging and deploying it. Just like the other steps we’ve discussed,
    this process can be an annoying burden when done manually. How you package an
    application into a deployable state depends not only on the computer language
    it’s written in but also on the build management tool you’re using. For example,
    if you’re using the Maven tool to manage a Java product, you’ll need to run a
    different set of commands than if you’re using the Gradle tool. Packaging Ruby
    code into a Ruby gem requires another, completely different, process. Packaging
    often involves collecting tens, hundreds, or thousands of files, bundling them
    with a language-appropriate tool, double-checking that documentation and license
    files are complete and in the right place, and possibly cryptographically signing
    the packaged code to show that it’s coming from a trusted source.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的软件已经构建完成、验证无误并且安全，接下来是时候考虑如何打包和部署它了。就像我们之前讨论的其他步骤一样，手动进行这一过程时可能会变得很麻烦。如何将应用程序打包成可部署的状态，不仅取决于它所使用的计算机语言，还取决于你使用的构建管理工具。例如，如果你使用Maven工具管理Java产品，你需要运行一组与使用Gradle工具时不同的命令。将Ruby代码打包成Ruby
    gem则需要完全不同的过程。打包通常涉及收集数十个、数百个或成千上万个文件，使用适合该语言的工具将它们打包，再三检查文档和许可证文件是否完整并放置在正确的位置，可能还需要通过加密签名打包的代码，以证明它来自一个可信的源。
- en: 'We’ve already mentioned the task of specifying which license your code is being
    released under. This leads to another kind of testing that needs to be done before
    you can deploy your code to production: **license** **compliance scanning**.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过指定代码发布许可证的任务。这引出了在将代码部署到生产环境之前需要进行的另一种测试：**许可证** **合规性扫描**。
- en: License compliance scanning
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可证合规性扫描
- en: Most open source, third-party libraries are released under a particular software
    license. There are countless licenses that developers can choose from, but the
    bulk of open source libraries use just a handful of them, including the MIT License,
    GNU **General Public License** (**GPL**), and the Apache License. It’s critical
    to know which licenses your dependencies use because you are not legally allowed
    to use dependencies that use licenses that are incompatible with your project’s
    overall license.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开源的第三方库都是根据特定的软件许可证发布的。开发者可以选择的许可证种类繁多，但大多数开源库使用的仅仅是其中几种，包括MIT许可证、GNU **通用公共许可证**（**GPL**）和Apache许可证。了解你的依赖项使用哪些许可证至关重要，因为如果你的项目使用的许可证与某个依赖项的许可证不兼容，那么你就无法合法地使用该依赖项。
- en: What would make two licenses incompatible? Some licenses, such as the Peaceful
    Open Source License, explicitly prohibit the use of the software by the military.
    Another, more common cause of license clashes is between so-called *Copyleft*
    licenses and proprietary licenses. Copyleft licenses such as the GPL stipulate
    that any software that uses libraries covered by the GPL must themselves use the
    GPL license. Copyleft licenses are sometimes called *viral licenses* because they
    pass their license restrictions on to any software that uses dependencies that
    are covered by those types of licenses.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 什么会导致两个许可证不兼容呢？一些许可证，例如《和平开源许可证》，明确禁止军方使用该软件。另一个常见的许可证冲突原因是所谓的*Copyleft*许可证与专有许可证之间的冲突。像GPL这样的Copyleft许可证规定，任何使用了GPL所涵盖库的软件，必须也使用GPL许可证。Copyleft许可证有时被称为*病毒许可证*，因为它们将许可证的限制传递给任何使用了这些许可证所涵盖依赖项的软件。
- en: Since you’re legally required to make sure that your main license is compatible
    with the licenses of any third-party libraries you use, you need to add a license
    scanning step to your packaging and deployment workflow. Whether this is done
    manually or with an automated tool, you must identify and replace any dependencies
    that you’re not allowed to use.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于法律要求你确保主许可证与你使用的任何第三方库的许可证兼容，你需要在打包和部署工作流中添加一个许可证扫描步骤。无论是手动进行还是使用自动化工具，你都必须识别并替换任何你不能使用的依赖项。
- en: Deploying software
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署软件
- en: Once your software has been packaged and you’ve double-checked the licenses
    of your dependencies, you face the hurdle of deploying the code to the right place
    at the right time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的软件已打包完毕，并且你已经仔细检查了依赖项的许可证，你就面临着将代码在正确的时间部署到正确位置的难题。
- en: 'Most development teams have several environments they deploy code to. Every
    organization sets these up differently, but a typical (albeit minimal) environment
    structure might look like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发团队都有多个环境来部署代码。每个组织的设置方式不同，但一个典型（尽管是最小化的）环境结构可能如下所示：
- en: One or more **test environments**.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个**测试环境**。
- en: A **staging environment** or **pre-production** environment that’s configured
    as similarly to the production environment as possible, but usually much smaller
    in scale.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**预发布环境**或**生产前环境**，其配置尽可能与生产环境相似，但通常规模要小得多。
- en: A **production environment**.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产环境**。'
- en: We’ll talk about the use of these different environments in more detail later,
    but for now, you just need to understand how each of these environments is used
    as part of the basic deployment workflow. As code is being developed, it is normally
    deployed to the test environment so that the QA team or *release engineers* can
    make sure it does what it’s supposed to do, and integrates with the existing code
    without causing any problems. As the new code is declared to be ready to add to
    the production code base, it is traditionally deployed to the staging environment
    so that a final round of tests can be made to make sure there are no incompatibilities
    between the new code and the environment in which it will ultimately run. If those
    tests go well, the code is finally deployed to the production environment, where
    real users can benefit from whatever feature, bug fix, or other improvements the
    new code introduced.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会更详细地讨论这些不同环境的使用，但现在你只需要了解每个环境在基本部署工作流程中的作用。当代码开发时，通常会将其部署到测试环境，以便质量保证（QA）团队或*发布工程师*确保它按预期工作，并与现有代码无缝集成，不会引起任何问题。当新代码被宣布准备好添加到生产代码库时，传统上会将其部署到预发布环境，以便进行最终测试，确保新代码与最终运行环境之间没有不兼容的情况。如果这些测试顺利通过，代码最终将部署到生产环境，真实用户可以从新代码带来的功能、修复或其他改进中受益。
- en: As you might imagine, making sure that the right code gets deployed to the right
    environment at the right time is a tricky but critically important job. And deploying
    is just half the battle! The other half is making sure the various environments
    are available and healthy. They must be running on the right types and scale of
    hardware, they must be provisioned with the right user accounts, they must have
    network and security policies configured correctly, and they must have the correct
    versions of operating systems, tools, and other infrastructure software installed.
    Of course, there are maintenance tasks, upgrades, and other system reconfiguration
    jobs that must be planned, carried out, and fixed when they go awry. The mind-boggling
    scope and complexity of these tasks are why big organizations have whole teams
    of release engineers making sure everything works smoothly and frantically troubleshooting
    when it doesn’t.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所想，确保正确的代码在正确的时间被部署到正确的环境中是一项复杂但至关重要的工作。而部署仅仅是战斗的一半！另一半是确保各个环境都可用且健康。它们必须运行在正确类型和规模的硬件上，必须配置正确的用户账户，必须正确设置网络和安全策略，还必须安装正确版本的操作系统、工具和其他基础设施软件。当然，还有维护任务、升级和其他系统重新配置工作，这些都必须计划、执行，并在出错时修复。这些任务的范围和复杂性令人难以置信，这也是大公司拥有完整发布工程师团队的原因，确保一切顺利运行，并在出现问题时紧急排查。
- en: 'This completes our tour through the most common SDLC tasks that happen after
    you’ve checked in the new code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对在你提交新代码后，最常见的SDLC任务的介绍：
- en: Build the code.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建代码。
- en: Verify the code’s functionality, performance, resource usage, and more with
    a variety of tests.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过各种测试验证代码的功能、性能、资源使用等。
- en: Make sure the code doesn’t have security vulnerabilities by using even more
    tests.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用更多的测试，确保代码没有安全漏洞。
- en: Package the code into a deployable format.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码打包成可部署的格式。
- en: Look for and remediate any problems with incompatible licenses.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 寻找并修复任何与许可证不兼容的问题。
- en: Deploy the code to the appropriate environment.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码部署到适当的环境中。
- en: 'By now, you should be sensing a theme: life before GitLab was complicated,
    error-prone, and slow. These adjectives certainly apply to the package, license
    scan, and release tasks that occur near the end of the SDLC. But as you’ll learn
    in more detail in a later chapter, GitLab CI/CD pipelines take care of the most
    burdensome aspects of these jobs for you. By letting the pipeline handle the boring
    and repetitive stuff, you can concentrate on the more creative and satisfying
    parts of writing software.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在，你应该已经感觉到一个主题：在GitLab之前的生活是复杂的、容易出错且缓慢的。这些形容词确实适用于在SDLC接近尾声时发生的软件包、许可证扫描和发布任务。但正如你将在后续章节中详细了解的那样，GitLab
    CI/CD流水线为你处理了这些工作的最繁琐部分。通过让流水线处理那些枯燥和重复的工作，你可以专注于编写软件中更具创意和满足感的部分。
- en: Problems with manual software development life cycle practices
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动软件开发生命周期实践中的问题
- en: 'Now that you have the general picture of what happens to software between the
    time that developers have finished writing it and the time that users can get
    their hands on it, you can start to understand how tough this process can be.
    Many tasks need to happen along this path of delivering secure, working code to
    users:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经对软件在开发者完成编写到用户能够使用之间发生的事情有了大致的了解，你可以开始理解这个过程有多么困难。沿着这条将安全、可工作的代码交付给用户的路径，许多任务需要发生：
- en: '![Figure 1.4 – Major tasks in the SDLC](img/B18073_Fig_1.4.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – SDLC中的主要任务](img/B18073_Fig_1.4.jpg)'
- en: Figure 1.4 – Major tasks in the SDLC
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – SDLC中的主要任务
- en: Some of these tasks are normally done manually, while others can be automated
    either partially or fully. But both approaches have problems associated with them,
    which turn each task into a potential pain point.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务中的一些通常是手动完成的，而其他任务则可以部分或完全自动化。但这两种方法都存在相关问题，使得每个任务都成为潜在的痛点。
- en: 'What are the difficulties of manually performing these tasks? Let’s take a
    look:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 手动执行这些任务有哪些困难？让我们来看看：
- en: '**They take time**. They often take significantly more time than you budget
    for them, even after you’ve had experience manually performing them in the past.
    There are countless ways things can go wrong when performing any of these tasks,
    all of which require time-consuming troubleshooting and remediation. Even when
    everything goes right, there is simply a lot of work involved with each of these
    tasks. And remember the 1979 law proposed by physicist Douglas Hofstadter: *It
    always takes longer than you expect, even when you take into account* *Hofstadter’s
    Law*.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们需要时间**。即使你过去有过手动执行它们的经验，它们通常也比你预期的花费更多的时间。执行这些任务时可能出错的方式有无数种，而每种错误都需要耗时的故障排除和修复。即使一切顺利，每个任务本身也涉及大量的工作。记住物理学家道格拉斯·霍夫施塔特在1979年提出的定律：*即使你考虑到*
    *霍夫施塔特定律*，它总是比你预期的要花费更长的时间。'
- en: '**They are error-prone**. Because you’re relying on humans to perform them
    – humans who might be tired, bored, or distracted – they’re all susceptible to
    misconfigurations, data entry mistakes, or steps that have been forgotten or applied
    in the wrong order, to name just a few ways human error can lead to things going
    wrong.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们容易出错**。因为你依赖的是人类来执行这些任务——而这些人类可能疲惫、无聊或分心——因此它们容易出现配置错误、数据输入错误，或者某些步骤被遗忘或顺序错误，仅举几例，人的错误可能导致任务失败。'
- en: '**They are tough on employee morale**. Nobody likes doing routine, repetitive
    work, especially when the stakes are high and you must get it right. The prospect
    of running through a standard 2-hour set of manual tests for the 20th time in
    2 weeks has caused many a QA engineer to wonder if maybe software wasn’t the smartest
    career choice for them after all.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们对员工士气有害**。没有人喜欢做例行的重复性工作，尤其是当任务至关重要并且必须做对的时候。每两周第20次执行标准的两小时手动测试，许多QA工程师都曾怀疑，自己是不是当初选择了错误的职业道路。'
- en: '**They have a high potential for miscommunication or misreporting**. When a
    manual tester has finished running their stultifying 2-hour test suite, do they
    have enough brain cells left to accurately record what worked and what didn’t?
    All that testing is pointless if we can’t rely on the results being recorded accurately,
    but anyone who has executed a difficult manual test plan knows how many ambiguities
    there can be in the results, how many unexpected conditions there can be to potentially
    skew the tests, and how hard it can be to know how to explain these factors to
    the people who rely on that reporting. And that’s not even factoring in the very
    large possibility of simply recording results incorrectly, even when they’re unambiguous.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它们有很高的沟通或报告错误的潜力**。当手动测试人员完成了他们枯燥的两小时测试套件后，他们是否还能剩下足够的脑细胞准确记录哪些工作了，哪些没工作？如果我们无法依赖结果准确记录，那么所有的测试都是没有意义的，但任何执行过复杂手动测试计划的人都知道，结果中可能存在多少不确定性，可能会有多少意外情况扭曲测试结果，而要知道如何向依赖这些报告的人解释这些因素是多么困难。更不用说即使结果毫不含糊，仅仅是记录错误的结果的可能性有多大了。'
- en: For all these reasons, you can see how expensive – in terms of time, money,
    and employee goodwill – manual tasks are likely to be.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 出于所有这些原因，你可以看出，手动任务在时间、金钱和员工善意方面的开销是多么巨大
- en: 'But if some of the tasks we’ve described can be automated, would that eliminate
    the problems that we face with manual tasks? Well, it would solve some problems.
    But adding a series of automation tools to the SDLC would introduce a whole new
    set of problems. Consider all the extra effort and expense involved with doing
    so and all the tasks that building custom toolchains entail:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们所描述的一些任务能够自动化，是否能消除我们在手动任务中面临的问题？嗯，这将解决一些问题。但将一系列自动化工具添加到SDLC中，也会引入一整套新的问题。考虑到这样做所涉及的额外努力和费用，以及构建自定义工具链所需要承担的所有任务：
- en: Researching and selecting tools for each automatable task.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究和选择适用于每个可自动化任务的工具
- en: Buying and renewing licenses for each tool
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购买和续订每个工具的许可证
- en: Choosing a hosting solution for each tool
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个工具选择托管解决方案
- en: Provisioning users for each tool
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个工具配置用户
- en: Learning different GUIs for each tool
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习每个工具的不同图形用户界面（GUI）
- en: Managing databases and other infrastructure for each tool
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理每个工具的数据库和其他基础设施
- en: Integrating each tool with other tools in the SDLC
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个工具与SDLC中的其他工具进行集成
- en: Figuring out how to display the status and results of each tool in a central
    location if that’s even possible
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，弄清楚如何在一个集中位置显示每个工具的状态和结果
- en: Deal with tools that are buggy, that become deprecated, or that become less
    compelling as better alternatives appear on the market
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理那些有缺陷、被弃用或随着市场上更好替代品的出现而变得不那么吸引人的工具
- en: 'Even after all the problems of manual or automated tasks are handled, there’s
    one big problem that’s unavoidable for teams that use this model: *it’s a sequential
    workflow*. Steps happen one after another. One team writes the software, then
    *throws the code over the wall* to another team that builds the software. That
    team, in turn, tosses the code to a third team that’s responsible for validating
    the software. When they’re done, they generally send it to yet another group of
    engineers who do security testing. Finally, a release team gets ahold of it so
    that they can deploy the code to the right place. There are plenty of ways this
    process can deviate from this basic description, but the fundamental concept of
    doing one step at a time, passing the code to the next step only after the earlier
    steps are complete, is a trait that many, many software development teams’ workflows
    shared.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 即使手动或自动化任务的问题得到处理，使用这种模式的团队仍然面临一个无法避免的重大问题：*它是一个顺序工作流*。步骤是一个接一个地进行的。一支团队编写软件，然后*把代码扔到墙那边*，交给另一支负责构建软件的团队。那支团队又将代码交给负责验证软件的第三支团队。当他们完成后，他们通常会将代码交给另一个安全测试小组。最后，发布团队会接手代码，确保它被部署到正确的位置。这个过程可能会有很多偏离基本描述的方式，但一个接一个地执行步骤，在前面的步骤完成后才将代码传递给下一个步骤，这个特征是许多软件开发团队的工作流共有的特点。
- en: So far, it might not be obvious why sequential workflows pose a problem, so
    let’s spell it out. Because of the difficulty of executing these steps manually,
    or the hassles of keeping automated steps running smoothly and reliably across
    multiple tools, this workflow typically happens only sporadically. How often the
    code gets run through these steps varies from team to team, but the time and expense
    involved means that code changes typically stack up over days, weeks, or sometimes
    even months before they get built, validated, secured, and deployed properly.
    And that, in turn, means that *problems detected during this process are expensive
    to fix*. If a functional test fails, a security test detects a vulnerability,
    or an integration test reveals that the code doesn’t play well together once it’s
    all deployed to the same environment, identifying what code is causing the problem
    is like finding a needle in a very large haystack. If 5,000 lines of code across
    25 classes have changed, 16 dependencies have been upgraded to more recent versions,
    the Java version has changed from version 16 to version 17, and the test environment
    is running on a different version of Ubuntu, those are a whole lot of variables
    to investigate when you’re tracking down the source of the problem and figuring
    out how to fix it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，可能还不太明显为什么顺序工作流会带来问题，所以让我们详细说明一下。由于手动执行这些步骤的困难，或者保持自动化步骤在多个工具中顺利且可靠运行的麻烦，这种工作流通常只是偶尔发生。代码通过这些步骤的执行频率因团队而异，但涉及的时间和费用意味着代码更改通常会在几天、几周，甚至有时几个月后才被正确地构建、验证、加固和部署。而这反过来意味着，*在这个过程中检测到的问题修复成本高昂*。如果功能测试失败，安全测试检测到漏洞，或者集成测试显示代码在所有部署到同一环境后无法协同工作，确定是哪个代码导致了问题，就像在一个巨大的干草堆中找针一样。如果5,000行代码跨越25个类发生了变化，16个依赖被升级到了更新的版本，Java版本从16升级到17，而且测试环境运行的是不同版本的Ubuntu，那么在追踪问题源并找出解决方法时，有这么多的变量需要调查。
- en: 'At this point, you know enough about traditional, pre-DevOps software development
    that we can summarize the biggest problem it faces in one sentence: *sequential
    workflows that involve manual tasks or automated tasks performed by different
    tools cause development to be slow, releases to be infrequent, and the resulting
    software to be of less high quality than it* *could be*.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，你已经了解了传统的、开发前的软件开发方式，我们可以用一句话总结它面临的最大问题：*涉及手动任务或由不同工具执行的自动化任务的顺序工作流会导致开发变慢，发布不频繁，并且结果软件的质量低于它*
    *本应达到的标准*。
- en: 'But there’s good news: DevOps was invented to solve these problems. And GitLab
    CI/CD pipelines were invented to make DevOps easier to use. We’ll look at both
    of those things next.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不过有个好消息：DevOps的诞生就是为了应对这些问题。而GitLab CI/CD流水线的发明则是为了让DevOps更易于使用。接下来我们将一起探讨这两者。
- en: Solving problems with DevOps
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DevOps解决问题
- en: What do we mean by **DevOps**? Despite the term being used by the software community
    for at least 10 years (the first session of **devopsdays**, which is now the biggest
    DevOps-focused conference, was held in 2009), today, there is no single, standard
    definition that everyone agrees on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的**DevOps**是什么意思？尽管这个术语在软件界已经使用了至少10年（第一个**devopsdays**会议——现在是最大的以DevOps为主题的会议——于2009年举办），但至今仍没有一个所有人都认同的统一标准定义。
- en: 'When GitLab talks about DevOps, it’s referring to a new way of thinking about
    the SDLC, which focuses on four things:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当GitLab谈论DevOps时，它指的是一种重新思考软件开发生命周期（SDLC）的方法，专注于四个方面：
- en: Automation
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化
- en: Collaboration
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协作
- en: Fast feedback
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速反馈
- en: Iterative improvement
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代改进
- en: Let’s look at each of these in more detail.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下每个方面。
- en: The primary focus of DevOps is to **automate** as many software development
    tasks as possible. This removes the challenges associated with manually building,
    testing, securing, and releasing. But this is of limited usefulness if it exchanges
    those challenges for the hassles and expense associated with assembling a collection
    of manual tools. We’ll see how GitLab solves that problem later, but for now,
    just understand that a proper DevOps workflow is fully automated.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps的主要关注点是**自动化**尽可能多的软件开发任务。这可以消除与手动构建、测试、保护和发布相关的挑战。但如果它只是将这些挑战交换为组装一系列手动工具的麻烦和费用，那它的用途就非常有限。我们稍后会看到GitLab如何解决这个问题，但现在只需要理解，一个合适的DevOps工作流是完全自动化的。
- en: By fostering **collaboration** among all the teams involved with writing software,
    and among all the members of each team, DevOps helps dissolve the points of friction
    and potential trouble that happen every time the code is transferred from one
    team to another. If there’s no “wall” to throw the code over – if every step in
    the process is transparent to everyone involved with writing and delivering the
    software – everyone feels committed to the overall quality of the code and feels
    like they’re playing for the same team. Different people still have primary responsibility
    for specific tasks, but the overall culture moves toward joint ownership of the
    code and commonly shared goals.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过促进所有参与编写软件的团队之间的**协作**，以及每个团队成员之间的协作，DevOps有助于消除每次代码从一个团队转移到另一个团队时出现的摩擦点和潜在问题。如果没有“墙”可以把代码抛过去——如果过程中的每个步骤对所有参与编写和交付软件的人都是透明的——那么每个人都会对代码的整体质量感到责任重大，并且觉得自己是同一个团队的一员。不同的人仍然对特定任务负主要责任，但整体文化趋向于代码的共同所有权和共同的目标。
- en: '**Fast feedback** might be the most crucial and revolutionary element of DevOps.
    It can be thought of as the result of two other concepts we talked about previously:
    concurrent workflows and shifting left. When you stop to think about it, those
    two terms boil down to the same thing: do all the building, verifying, and securing
    tasks as soon as possible for each batch of code that developers check in. Do
    them all concurrently instead of sequentially, to ensure that they happen at the
    far left of the software development timeline. And run all these tasks immediately
    for every chunk of new code that’s contributed, no matter how small. By running
    these tasks early and often, you minimize the size of the code changes that are
    tested, which makes it cheaper and easier to troubleshoot any software bugs, configuration
    issues, or security vulnerabilities found by the tests.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速反馈**可能是DevOps最关键和革命性的元素。可以将其视为我们之前讨论的两个概念的结果：并行工作流和左移。当你停下来思考时，这两个术语归结为同一件事：对于每一批开发人员提交的代码，尽早并同时完成所有构建、验证和保护任务。以并行方式而非顺序方式执行它们，以确保它们出现在软件开发时间线的最左端。而且对于每一块新代码，无论多么微小，都要立即运行所有这些任务。通过早期且频繁地运行这些任务，你可以最小化测试的代码变化的大小，这使得排除任何由测试发现的软件漏洞、配置问题或安全漏洞变得更便宜和容易。'
- en: 'If you’re finding and fixing problems quickly, you’ll be able to release your
    software to customers more often. By getting new features and bug fixes to them
    sooner, you’re helping them benefit from the **iterative improvement** of your
    product. By releasing smaller code changes at shorter intervals with a lower risk
    of breaking things and needing to roll back, you’re living up to the catchphrase
    of *making your releases boring.* In this case, boring is a good thing: most customers
    would rather have frequent, small upgrades that pose little risk than infrequent,
    massive changes that have a greater chance of wreaking havoc and needing to be
    reverted.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能快速发现并修复问题，就能够更频繁地将软件发布给客户。通过更早地向他们提供新特性和修复的 bug，你在帮助他们从你产品的**迭代改进**中获益。通过以更短的间隔发布较小的代码更改，这样的发布风险较低，不容易出错，也无需回滚，你就实现了“*让发布变得无聊*”这一口号。在这种情况下，无聊是件好事：大多数客户更愿意接受频繁、小规模的升级，因为它们的风险小，而不愿意接受那些不频繁、巨大改变的升级，后者更有可能造成严重问题并需要回退。
- en: By taking advantage of automation, collaboration, fast feedback, and iterative
    improvement, DevOps practices produce code that’s higher quality, cheaper to develop,
    and delivered more frequently to users.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用自动化、协作、快速反馈和迭代改进，DevOps 实践能够生成更高质量、开发成本更低、且更频繁交付给用户的代码。
- en: How GitLab implements DevOps
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何通过 GitLab 实现 DevOps
- en: GitLab is a tool that enables all the software development tasks we’ve discussed,
    using the DevOps principles we’ve just outlined. The most important trait of GitLab
    is that it’s a *single* tool that unifies all the steps in the SDLC under one
    umbrella.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 是一个可以支持我们讨论的所有软件开发任务的工具，它使用了我们刚刚概述的 DevOps 原则。GitLab 最重要的特点是它是一个*单一*工具，能够将
    SDLC 中的所有步骤统一在一个平台下。
- en: 'Remember how shifting from manual processes to automated processes solved some
    problems but raised a host of new problems associated with automation? GitLab’s
    single-tool approach solves those problems as well. Consider the benefits of having
    the following single, unified toolchain approach:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得从手动过程转向自动化过程时，解决了一些问题，但也带来了与自动化相关的新问题吗？GitLab 的单一工具方法同样解决了这些问题。考虑一下拥有以下统一工具链方法的好处：
- en: One license to buy (unless your team uses the free, feature-limited version
    of GitLab, in which case there are no licenses to buy)
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个许可证需要购买（除非你的团队使用 GitLab 的免费版本，该版本功能受限，在这种情况下不需要购买许可证）
- en: One application to maintain and upgrade
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个应用程序进行维护和升级
- en: One set of user accounts to provision
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一套用户账户进行配置
- en: One database to manage
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据库进行管理
- en: One GUI to learn
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 GUI 需要学习
- en: One place to look – one radar screen, so to speak – to see the reports and statuses
    of *all* your build, validation, security, packaging, and deploy steps
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个查看的地方——可以说是一个雷达屏幕——用来查看*所有*构建、验证、安全、打包和部署步骤的报告和状态
- en: So, GitLab being a single tool solves the problems you get from using disparate
    automation tools. Even better, the fact that it uses a single set of components
    and entities, all of which are aware of and communicate well with each other,
    enables and encourages the collaboration, concurrency, transparency, and shared
    ownership that are such critical aspects of DevOps. Once you have concurrent tasks,
    you get fast feedback. And that, in turn, allows for iterative improvement via
    *boring* releases.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，GitLab 作为一个单一工具，解决了使用不同自动化工具所带来的问题。更重要的是，它使用单一的组件和实体，这些组件和实体相互之间能够良好沟通并且互相了解，这种设计促进并鼓励了
    DevOps 中至关重要的协作、并发、透明度和共享所有权。一旦你拥有并发任务，你就能获得快速反馈。而这又进一步推动了通过*无聊*发布进行迭代改进。
- en: 'The bulk of the rest of this book deals with the technique that GitLab uses
    to put those DevOps principles into practice: **CI/CD pipelines**. We won’t define
    what that term means quite yet, but you’ll learn all about it in future chapters.
    For now, you just need to know that CI/CD pipelines are where the GitLab rubber
    meets the DevOps road: they are how GitLab’s single-tool model performs all the
    building, verification, securing, packaging, and deploying that your code has
    to go through.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的大部分内容将讨论 GitLab 如何运用这些 DevOps 原则进行实践：**CI/CD 流水线**。我们暂时不会定义这个术语的含义，但你将在未来的章节中详细了解它。现在，你只需要知道
    CI/CD 流水线是 GitLab 如何将单一工具模型用于执行所有构建、验证、安全、打包和部署的地方，它们是你代码需要经过的过程。
- en: We’d be remiss not to mention that a large part of GitLab is dedicated to helping
    you plan, assign, and manage work. But that’s separate from the CI/CD pipelines,
    and therefore is beyond the scope of this book. We will touch on ancillary topics
    from time to time, simply because everything in GitLab is so interrelated that
    there’s no way to stay entirely within the boundaries of CI/CD pipelines. But
    most of the rest of this book will explain what GitLab pipelines can do, and how
    to use them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不提的是，GitLab 的一个重要部分是帮助你规划、分配和管理工作。但这与 CI/CD 管道是分开的，因此超出了本书的范围。我们会时不时提及一些相关话题，因为
    GitLab 中的所有内容都是相互关联的，不可能完全局限于 CI/CD 管道的范畴。但本书的大部分内容将解释 GitLab 管道的功能以及如何使用它们。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: People who don’t work for software companies might not realize there’s more
    to writing software than just... *writing software*. After it’s checked in, a
    long and complicated series of steps must be followed to build, verify, secure,
    package, and deploy code before users can get their hands on it. All these steps
    can be done manually, or some of them – under certain conditions – can be automated.
    But both manual and automated approaches to preparing software pose problems.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不从事软件公司工作的人可能不了解，编写软件不仅仅是……*编写软件*。在代码提交后，必须遵循一系列冗长复杂的步骤，包括构建、验证、安全性检查、打包和部署，才能让用户使用这些代码。所有这些步骤都可以手动完成，或者在特定条件下，部分步骤可以自动化。然而，无论是手动方式还是自动化方式，都存在问题。
- en: DevOps is a relatively new approach to accomplishing these steps. It combines
    automation, collaboration, fast feedback, and iterative improvement in a way that
    lets teams make software better, faster, and more cheaply.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 是一种相对较新的方法，用于完成这些步骤。它将自动化、协作、快速反馈和迭代改进结合起来，使团队能够更好、更快、更便宜地开发软件。
- en: GitLab is a DevOps tool that collects all these tasks under one umbrella, allowing
    a software development team to accomplish everything with a single tool, using
    a single GUI, with all the test results and deployment status displayed in a single
    place. Its focus on automation addresses the problems raised by manual processes.
    Its single-tool model addresses the problems raised by automated processes. GitLab
    puts all the DevOps principles into practice through the use of CI/CD pipelines,
    which will be the main focus of the rest of this book.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 是一个 DevOps 工具，它将所有这些任务整合在一个平台下，使得软件开发团队可以通过单一工具、使用单一界面来完成所有任务，所有测试结果和部署状态都显示在一个地方。它专注于自动化，解决了手动流程中出现的问题。它的单一工具模型则解决了自动化流程中出现的问题。GitLab
    通过使用 CI/CD 管道将所有 DevOps 原则付诸实践，这将是本书余下部分的主要内容。
- en: But before we deal with CI/CD pipelines, we need to take a quick, one-chapter
    detour into Git, the tool around which GitLab is built. Without a solid grounding
    in the basics of Git, you’ll likely find many of GitLab’s concepts and terminology
    confusing. So, batten down the hatches, grab a big mug of your favorite caffeinated
    beverage, and let’s jump into Git.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们讨论 CI/CD 管道之前，我们需要快速绕道介绍 Git，这是 GitLab 构建的基础工具。如果没有扎实的 Git 基础，你很可能会觉得 GitLab
    的许多概念和术语令人困惑。因此，准备好，拿起你最喜欢的含咖啡因饮料，让我们一起跳入 Git 的世界吧。
