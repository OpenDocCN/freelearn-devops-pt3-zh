["```\ntype HTTP struct {\n     client *http.Client\n     cb     *gobreaker.CircuitBreaker\n}\nfunc New(client *http.Client) *HTTP {\n     return &HTTP{\n          client: client,\n          cb: gobreaker.NewCircuitBreaker(\n               gobreaker.Settings{\n                    MaxRequests: 1,\n                    Interval:    30 * time.Second,\n                    Timeout:     10 * time.Second,\n                    ReadyToTrip: func(c gobreaker.Counts) bool {\n                         return c.ConsecutiveFailures > 5\n                    },\n               },\n          ),\n     }\n}\nfunc (h *HTTP) Get(req *http.Request) (*http.Response, error) {\n     if _, ok := req.Context().Deadline(); !ok {\n          return nil, fmt.Errorf(\"all requests must have a Context deadline set\")\n     }\n     r, err := h.cb.Execute(\n          func() (interface{}, error) {\n               resp, err := h.client.Do(req)\n               if resp.StatusCode != 200 {\n                    return nil, fmt.Errorf(\"non-200 response code\")\n               }\n               return resp, err\n          },\n     )\n     if err != nil {\n          return nil, err\n     }\n     return r.(*http.Response), nil\n}\n```", "```\ntype HTTP struct {\n     client *http.Client\n}\nfunc New(client *http.Client) *HTTP {\n     return &HTTP{\n          client: client,\n     }\n}\nfunc (h *HTTP) Get(req *http.Request) (*http.Response, error) {\n     if _, ok := req.Context().Deadline(); !ok {\n          return nil, fmt.Errorf(\"all requests must have a Context deadline set\")\n     }\n     var resp *http.Response\n     op := func() error {\n          var err error\n          resp, err = h.client.Do(req)\n          if err != nil {\n               return err\n          }\n          if resp.StatusCode != 200 {\n               return fmt.Errorf(\"non-200 response code\")\n          }\n          return nil\n     }\n     err := backoff.Retry(\n          op, \n          backoff.WithContext(\n               backoff.NewExponentialBackOff(),\n               req.Context(),\n          ),\n     )\n     if err != nil {\n          return nil, err\n     }\n     return resp, nil\n}\n```", "```\nlimit := make(chan struct{}, 3)\n```", "```\ntype Job interface {\n     Validate(job *pb.Job) error\n     Run(ctx context.Context, job *pb.Job) error\n}\n```", "```\ngo\nwg := sync.WaitGroup{}\nfor _, block := range work.Blocks {\n     limit := make(chan struct{}, req.Limit)\n     for _, job := range block.Jobs {\n          job := job\n          limit <- struct{}{}\n          wg.Add()\n          go func() {\n               defer wg.Done()\n               defer func() {\n                    <-limit\n               }()\n               job()\n          }()\n     }\n}\nwg.Wait()\n```", "```\ntype bucket struct {\n     tokens chan struct{}\n}\nfunc newbucket(size, incr int, interval time.Duration) (*bucket, error) {\n     b := bucket{tokens: make(chan struct{}, size)}\n     go func() {\n          for _ = range time.Tick(interval) {\n               for i := 0; i < incr; i++ {\n                    select{\n                    case <-b.tokens:\n                         continue\n                    default:\n                    }\n                    break\n               }\n          }\n     }()\n     return &b, nil\n}\nfunc (b *bucket) token(ctx context.Context) error {\n     select {\n     case <-ctx.Done():\n          return ctx.Err()\n     case b.tokens <-struct{}{}:\n     }\n     return nil\n}\n```", "```\nfunc CopyToFile(content []byte, p string) error {\n     return io.WriteFile(p, content)\n}\n```", "```\nfunc CopyToFile(content []byte, p string) error {\n     if _, ok := os.Stat(p); ok {\n          f, err := os.Open(p)\n          if err != nil {\n               return err\n          }\n          h0 := sha256.New()\n          io.Copy(h0, f)\n          h1 := sha256.New()\n          h1.Write(content)\n          if h0.Sum(nil) == h1.Sum(nil) {\n               return nil\n          }\n     }\n     return io.WriteFile(p, content)\n}\n```", "```\nservice Workflow {\n     rpc Submit(WorkReq) returns (WorkResp) {};\n     rpc Exec(ExecReq) returns (ExecResp) {};\n     rpc Status(StatusReq) returns (StatusResp) {};\n}\n```", "```\nmessage WorkReq {\n     string name = 1;\n     string desc = 2;\n     repeated Block blocks = 3;\n}\nmessage WorkResp {\n     string id = 1;\n}\nmessage Block {\n     string desc = 1;\n     int32 rate_limit = 2;\n     repeated Job jobs = 3;\n}\nmessage Job {\n     string name = 1;\n     map<string, string> args = 2;\n}\n```", "```\nmessage ExecReq {\n     string id = 1;\n}\nmessage ExecResp {}\n```", "```\ntype Settings interface{\n     Validate() error\n}\ntype Policy interface {\n     Run(ctx context.Context, name string, req *pb.WorkReq, settings Settings) error\n}\n```", "```\ntype PolicyArgs struct {\n     Name string\n     Settings Settings\n}\n```", "```\nvar policies = map[string]registration{}\ntype registration struct {\n     Policy Policy\n     Settings Settings\n}\n```", "```\nfunc Run(ctx context.Context, req *pb.WorkReq, args ...PolicyArgs) error {\n     if len(args) == 0 {\n          return nil\n     }\n     var cancel context.CancelFunc\n     ctx, cancel = context.WithCancel(ctx)\n     defer cancel()\n     // Make a deep clone so that no policy is able to make changes.\n     creq := proto.Clone(req).(*pb.WorkReq)\n     runners := make([]func() error, 0, len(args))\n     for _, arg := range args {\n          r, ok := policies[arg.Name]\n          if !ok {\n               return fmt.Errorf(\"policy(%s) does not exist\", arg.Name)\n          }\n          runners = append(\n               runners,\n               func() error {\n                    return r.Policy.Run(ctx, arg.Name, creq, arg.Settings)\n               },\n          )\n     }\n     wg := sync.WaitGroup{}\n     ch := make(chan error, 1)\n     wg.Add(len(runners))\n     for _, r := range runners {\n          r := r\n          go func() {\n               defer wg.Done()\n               if err := r(); err != nil {\n                    select {\n                    case ch <- err:\n                         cancel()\n                    default:\n                    }\n                    return\n               }\n          }()\n     }\n     wg.Wait()\n     select {\n     case err := <-ch:\n          return err\n     default:\n     }\n     if !proto.Equal(req, creq) {\n          return fmt.Errorf(\"a policy tried to modify a request: this is not allowed as it is a security violation\")\n     }\n     return nil\n}\n```", "```\ntype Settings struct { \n    AllowedJobs []string \n}\nfunc (s Settings) Validate() error { \n    for _, n := range s.AllowedJobs { \n        _, err := jobs.GetJob(n) \n        if err != nil { \n            return fmt.Errorf(\"allowed job(%s) is not defined in the proto\") \n        } \n    }\n    return nil \n}\nfunc (s Settings) allowed(name string) bool {\n     for _, jn := range s.AllowedJobs {\n          if jn == name {\n               return true\n          }\n     }\n     return false\n}\n```", "```\ntype Policy struct{}\nfunc New() (Policy, error) {\n     return Policy{}, nil\n}\nfunc (p Policy) Run(ctx context.Context, name string, req *pb.WorkReq, settings policy.Settings) error {\n     const errMsg = \"policy(%s): block(%d)/job(%d) is a type(%s) that is not allowed\"\n     s, ok := settings.(Settings)\n     if !ok {\n          return fmt.Errorf(\"settings were not valid\")\n     }\n     for blockNum, block := range req.Blocks {\n          for jobNum, job := range block.Jobs {\n               if ctx.Err() != nil {\n                    return ctx.Err()\n               }\n               if !s.allowed(job.Name) {\n                    return fmt.Errorf(errMsg, blockNum, jobNum, job.name)\n               }\n          }\n     }\n     return nil\n}\n```", "```\n{\n     \"Name\": \"SatelliteDiskErase\",\n     \"Policies\": [\n          {\n               \"Name\": \"restrictJobTypes\",\n               \"Settings\": {\n                    \"AllowedJobs\": [\n                            \"validateDecom\",\n                            \"diskErase\",\n                            \"sleep\",\n                            \"getTokenFromBucket\"\n                    ]\n               }\n          }\n     ]\n}\n```", "```\n// Status indicates the emergency stop status.\ntype Status string\nconst (\n     Unknown Status = \"\"\n     Go Status = \"go\"\n     Stop Status = \"stop\"\n)\n```", "```\ntype Info struct {\n     // Name is the workflow name.\n     Name string\n     // Status is the emergency stop status.\n     Status Status\n}\n```", "```\nfunc (i Info) validate() error {\n     i.Name = strings.TrimSpace(i.Name)\n     if i.Name == \"\" {\n          return fmt.Errorf(“es.json: rule with empty name”)\n     }\n     switch i.Status {\n     case Go, Stop:\n     default:\n          return fmt.Errorf(\"es.json: rule(%s) has invalid Status(%s), ignored\", i.Name, i.Status)\n     }\n     return nil\n}\n```", "```\nvar Data *Reader\nfunc init() {\n     r, err := newReader()\n     if err != nil {\n          panic(fmt.Sprintf(\"es error: %s\", err))\n     }\n     Data = r\n}\ntype Reader struct {\n     entries atomic.Value // map[string]Info\n     mu          sync.Mutex\n     subscribers map[string][]chan Status\n}\nfunc newReader() (*Reader, error) {...}\nfunc (r *Reader) Subscribe(name string) (chan Status, Cancel){...}\nfunc (r *Reader) Status(name string) Status {...}\n```", "```\ntype Job interface{\n     Run(ctx context.Context)\n}\ntype Work struct {\n     name string\n     jobs []Job\n}\nfunc (w *work) Exec(ctx context.Context) error{\n     esCh, cancelES := es.Data.Subscribe(w.name)\n     defer cancelES() // Stop subscribing\n     if <-esCh != es.Go { // The initial state\n          return fmt.Errorf(\"es in Stop state\")\n     }\n     var cancel context.CancelFunc\n     ctx, cancel = context.WithCancel(ctx)\n     defer cancel()\n     // If we get an emergency stop, cancel our context.\n     // If the context gets cancelled, then just exit.\n     go func() {\n          select {\n          case <-ctx.Done():\n               return\n          case <-esCh:\n               cancel()\n          }\n     }()\n     for _, job := range w.jobs {\n          if err := job(ctx); err != nil {\n               return err\n          }\n     }\n     return nil\n}\n```"]