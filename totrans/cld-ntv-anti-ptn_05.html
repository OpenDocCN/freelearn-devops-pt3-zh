<html><head></head><body>
<div epub:type="chapter" id="_idContainer044">
<h1 class="chapter-number" id="_idParaDest-136"><a id="_idTextAnchor136"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-137"><a id="_idTextAnchor137"/><span class="koboSpan" id="kobo.2.1">Delivering Rapidly and Continuously Without Compromising Security</span></h1>
<p><span class="koboSpan" id="kobo.3.1">So far, we have looked at the organizational changes required for cloud native development. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will start to look at the cultural and development practices that are required for a shift to cloud native. </span><span class="koboSpan" id="kobo.3.3">When shifting to cloud native software development, we’re sold the dream of rapid delivery and secure systems. </span><span class="koboSpan" id="kobo.3.4">However, this can only be achieved in practice with corresponding organizational and cultural change. </span><span class="koboSpan" id="kobo.3.5">Let’s explore how common anti-patterns in our software delivery life cycle can interrupt our journey to becoming a high-performing cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">native organization.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">In this chapter, we’re going to cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">main topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Underestimating the </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">cultural impact</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Frequent change to meet </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">business needs</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.11.1">Guardrails</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.12.1">Shifting left</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.13.1">Self-sufficient teams</span></span></li>
</ul>
<h1 id="_idParaDest-138"><a id="_idTextAnchor138"/><span class="koboSpan" id="kobo.14.1">Underestimating the cultural impact</span></h1>
<p><span class="koboSpan" id="kobo.15.1">Delivering cloud native projects rapidly and securely is primarily a cultural change. </span><span class="koboSpan" id="kobo.15.2">The technical and business process changes required to excel at cloud native delivery support cultural changes. </span><span class="koboSpan" id="kobo.15.3">We need to align the mentality of the team working on the project toward shared ownership of outcomes, breaking down the silos that may be present in the existing delivery process. </span><span class="koboSpan" id="kobo.15.4">The team that produces a change or feature should be responsible for its delivery into the production environment. </span><span class="koboSpan" id="kobo.15.5">This shift is the most fundamental aspect of delivering rapidly. </span><span class="koboSpan" id="kobo.15.6">In this section, we will start by reviewing a typical deployment process that we see often in clients who are just beginning their cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">native journey.</span></span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor139"/><span class="koboSpan" id="kobo.17.1">The siloed model – a long road to production</span></h2>
<p><span class="koboSpan" id="kobo.18.1">Let’s </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.19.1">examine a well-intentioned yet siloed delivery process that is usually the artifact of taking an on-premises approach to releases and applying it to cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">native delivery.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.21.1"><img alt="Figure 5.1 – A typical siloed release process – many touchpoints with little end-to-end ownership" src="image/B22364_05_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.22.1">Figure 5.1 – A typical siloed release process – many touchpoints with little end-to-end ownership</span></p>
<p><span class="koboSpan" id="kobo.23.1">This model works when releases are large, cumbersome processes that take significant effort to deploy, and the consequences of pushing a bad change are complex to recover from. </span><span class="koboSpan" id="kobo.23.2">We might use this model when deploying to a fleet of on-premises customer servers of varying capacity and capability. </span><span class="koboSpan" id="kobo.23.3">In the cloud, these constraints do not exist. </span><span class="koboSpan" id="kobo.23.4">We can make </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.24.1">rapid changes with quick remediation if something goes wrong; a single, unified, homogenous production environment simplifies deployment </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">and remediation.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">Under this model, we heavily scrutinize all code before it reaches our production environment. </span><span class="koboSpan" id="kobo.26.2">However, its rigidity is also its downfall. </span><span class="koboSpan" id="kobo.26.3">When something inevitably goes wrong in one of these stages, the process, more commonly, is that the developer, who has already begun working on the next feature, must drop what they’re doing to create a fix applied at the level of review reached. </span><span class="koboSpan" id="kobo.26.4">It’s unlikely that this last-minute change will go through the review process as the process cannot afford to </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">start over.</span></span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/><span class="koboSpan" id="kobo.28.1">DORA – measuring the road</span></h2>
<p><span class="koboSpan" id="kobo.29.1">“</span><em class="italic"><span class="koboSpan" id="kobo.30.1">If you can’t measure it, you cannot improve it</span></em><span class="koboSpan" id="kobo.31.1">.” </span><span class="koboSpan" id="kobo.31.2">We </span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.32.1">understand that the siloed model is limiting when applied to cloud native software, but as we change our delivery process, how do we know that our changes are shifting our business in the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">right direction?</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Earlier, in </span><a href="B22364_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.35.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.36.1">, we introduced the DORA metrics to measure how well teams perform. </span><span class="koboSpan" id="kobo.36.2">If you are interested in the science behind these metrics, we recommend reading the DORA report or </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Accelerate: The Science of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations</span></em><span class="koboSpan" id="kobo.38.1">. </span><span class="koboSpan" id="kobo.38.2">To recap, these metrics are </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.40.1">Deployment frequency</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">Lead time </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">for changes</span></span></li>
<li><span class="koboSpan" id="kobo.43.1">Change </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">failure rate</span></span></li>
<li><span class="koboSpan" id="kobo.45.1">Time to </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">restore service</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.47.1">If these are the metrics that most accurately predict team performance, we can see that ownership of delivery is </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">not optional.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">Deployment frequency is suboptimal in the siloed configuration as we are tied to such an arduous release process. </span><span class="koboSpan" id="kobo.49.2">This release process also dictates our lead time for changes, as any changes must be aligned with the estimated schedule. </span><span class="koboSpan" id="kobo.49.3">We are also deploying much larger bundles of code at a time so that the chances of one of the features in the deployed bundle causing a change failure is now much higher, as the likelihood is now the sum of the likelihoods of each of the sub-components. </span><span class="koboSpan" id="kobo.49.4">Finally, the time to restore service is also </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.50.1">much greater due to either rolling back a large change or sifting through a large release to find the culprit and apply a hotfix (which is also unlikely to go through the </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">release process).</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Leaving aside the metrics for high-performing teams, we also run into another issue around ownership. </span><span class="koboSpan" id="kobo.52.2">Who owns this change and is responsible for its success? </span><span class="koboSpan" id="kobo.52.3">The developer who wrote it? </span><span class="koboSpan" id="kobo.52.4">The change approval board that approved it? </span><span class="koboSpan" id="kobo.52.5">If it’s a security issue, does ownership lie with the security team? </span><span class="koboSpan" id="kobo.52.6">Siloing the release process also means siloing the ownership; without end-to-end ownership of the process, problems are much harder </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">to fix.</span></span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.54.1">Empowered teams – increasing your speed</span></h2>
<p><span class="koboSpan" id="kobo.55.1">This brings us </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.56.1">back to the concept of empowered teams. </span><span class="koboSpan" id="kobo.56.2">If your team wrote it, you are responsible for its entire journey into production. </span><span class="koboSpan" id="kobo.56.3">Or, more succinctly, “</span><em class="italic"><span class="koboSpan" id="kobo.57.1">You build it, you run it</span></em><span class="koboSpan" id="kobo.58.1">.” </span><span class="koboSpan" id="kobo.58.2">We can’t just throw all of our teams in the deep end and expect them to swim; they need to be supported. </span><span class="koboSpan" id="kobo.58.3">This is where those siloed teams from before come into play. </span><span class="koboSpan" id="kobo.58.4">They shift from being the gatekeepers of the journey toward the production environment to enablers of the dev team to undertake that </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">journey themselves.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.60.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.61.1">Empowering and supporting teams to own their output is the core of rapid and </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">secure delivery.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">Hence, to deliver rapidly without compromising security, the cultural shift is one of the most essential aspects, while also being an aspect that companies fail to target. </span><span class="koboSpan" id="kobo.63.2">For a team to own its output, each must have the skills and capabilities required to deliver a piece of work end to end, either internally through forming cross-functional teams or externally through an enabling team. </span><span class="koboSpan" id="kobo.63.3">Later in this chapter, we will explore ways to approach this from a shift-left and push-down approach. </span><span class="koboSpan" id="kobo.63.4">The key here is not to hand all control over to delivery teams but to ensure they are empowered and supported by those traditionally siloed functions to own </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">their output.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">The easiest way to do this is to provide both the carrot and the stick to the development team. </span><span class="koboSpan" id="kobo.65.2">Enabling teams must produce platforms and artifacts the development team can consume to do their jobs in line with company standards. </span><span class="koboSpan" id="kobo.65.3">This might be in the form of authentication libraries, infrastructure as code patterns, common UI component libraries, and so on. </span><span class="koboSpan" id="kobo.65.4">Then, the enabling team should seek to automate guardrails to enable the developers to ensure that the code they are producing meets the same standards that </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.66.1">had been manually enforced. </span><span class="koboSpan" id="kobo.66.2">This</span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.67.1"> could be through the use of QA testing suites, </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">static application security testing</span></strong><span class="koboSpan" id="kobo.69.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.70.1">SAST</span></strong><span class="koboSpan" id="kobo.71.1">), and automated ticket creation systems for site reliability alarms in the observability platform. </span><span class="koboSpan" id="kobo.71.2">By enabling developers in this way, we empower them to own their output and shift left the responsibility of the </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">deployment process.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.73.1">DevSecOps – the super-highway to production</span></h2>
<p><span class="koboSpan" id="kobo.74.1">Let’s now</span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.75.1"> revisit our </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">deployment model:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.77.1"><img alt="Figure 5.2 – Target state for ownership of deployable artifacts" src="image/B22364_05_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.78.1">Figure 5.2 – Target state for ownership of deployable artifacts</span></p>
<p><span class="koboSpan" id="kobo.79.1">Our other teams have remained in the organization. </span><span class="koboSpan" id="kobo.79.2">Instead, they are maintaining three sets </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">of artifacts:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.81.1">Platform tools</span></strong><span class="koboSpan" id="kobo.82.1">: The</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.83.1"> systems and artifacts that developers consume to produce software artifacts that align with the responsible team’s requirements, such as shared auth libraries, structured logging libraries, or cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">infrastructure modules.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.85.1">Automated pipeline</span></strong><span class="koboSpan" id="kobo.86.1">: This </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.87.1">pipeline codifies each team’s expectations instead of relying on a manual review. </span><span class="koboSpan" id="kobo.87.2">As mentioned earlier, this may include QA automated tests, SAST, or container </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">scanning tools.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.89.1">Observability platform</span></strong><span class="koboSpan" id="kobo.90.1">: This </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.91.1">platform codifies the expectations around the application’s performance and alerts developers for situations outside of normal operating parameters while storing information about </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">these events.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.93.1">The key</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.94.1"> difference here is that instead of the development team interfacing with five different teams to push features out to production, the development team is empowered to own the code they produce and deploy artifacts that meet a baseline standard to production. </span><span class="koboSpan" id="kobo.94.2">They can also see how the artifacts they produce perform through the observability platform. </span><span class="koboSpan" id="kobo.94.3">Hence, we’ve shifted the culture away from gatekeeping to enablement. </span><span class="koboSpan" id="kobo.94.4">This is the crux of DevSecOps, enabling software teams to develop, secure, and operate the code </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">they write.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">The magnitude of this change is typically underestimated in organizations undergoing a cloud native transformation. </span><span class="koboSpan" id="kobo.96.2">People can take offense to being taken off the critical path, considering that they relinquish some power they previously had. </span><span class="koboSpan" id="kobo.96.3">The mindset to install in these teams is that they are no longer at odds with the development team by stopping them from deploying to production but instead are stewards of their specialty for the development teams, producing artifacts and providing insights that help guide the development teams toward their own secure, high-quality, </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">observable artifacts.</span></span></p>
<p><span class="koboSpan" id="kobo.98.1">As a result, development teams become more cross-functional, and team members need to upskill in security, quality assurance, and site reliability engineering under the guidance of these </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">enabling teams.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">We can now see a few distinct advantages of reducing these </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">friction points:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.102.1">Deployment frequency increases as we no longer bundle on a schedule but instead deploy as soon as possible. </span><span class="koboSpan" id="kobo.102.2">This also results in a much shorter change lead time, as once a change is ready and passes our pipeline checks, it can easily be deployed </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">to production.</span></span></li>
<li><span class="koboSpan" id="kobo.104.1">We are now deploying much smaller units of code that often contain only a few features, which decreases the likelihood of the change failing and reduces our change </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">failure rate.</span></span></li>
<li><span class="koboSpan" id="kobo.106.1">We have a</span><a id="_idIndexMarker583"/><span class="koboSpan" id="kobo.107.1"> platform to observe our application, which means that a change that results in an outage can quickly be identified, and a fix can be pushed through the automated pipeline. </span><span class="koboSpan" id="kobo.107.2">This is a key difference as, typically, hotfixes needed to be applied out of band, and we could not afford to run the fix through the whole pipeline. </span><span class="koboSpan" id="kobo.107.3">Instead, the automated pipeline can still be used as the developers do not need to interface with other teams to deploy the rectification. </span><span class="koboSpan" id="kobo.107.4">Hence, we have shifted toward a process of </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">continuous improvement and continuous </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.109.1">delivery</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.110.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.111.1">CI/CD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">).</span></span></li>
</ul>
<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.113.1">Staying on the road</span></h2>
<p><span class="koboSpan" id="kobo.114.1">Another</span><a id="_idIndexMarker584"/><span class="koboSpan" id="kobo.115.1"> fallacy that companies can quickly fall into is the belief that delivering features using DevSecOps and CI/CD principles will result in a large increase in development velocity, which means tighter deadlines. </span><span class="koboSpan" id="kobo.115.2">While it is true that the underlying improvements in the process will translate to the faster delivery of features, focusing solely on delivery timelines will ultimately undermine efficiency gains by the </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">cultural shift.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">If you are migrating from a fixed release schedule with tight deadlines and rigid business processes, it can be tempting to translate that directly into delivery schedules in the new paradigm. </span><span class="koboSpan" id="kobo.117.2">Instead, by decoupling feature work from the release process, we allow our development teams to obsess over output quality and only release features when ready from a multifaceted perspective. </span><span class="koboSpan" id="kobo.117.3">This ensures that we retain our increase in development velocity without compromising on code quality, and this leads us to a sustainable, rather than temporary, increase in </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">development velocity.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Conway’s law states, “</span><em class="italic"><span class="koboSpan" id="kobo.120.1">Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations</span></em><span class="koboSpan" id="kobo.121.1">.” </span><span class="koboSpan" id="kobo.121.2">When we allow our teams to be siloed, we inevitably constrain their output to a particular part of the development/deployment process and their responsibilities and produce a deployment process replicating those teams’ communication pathways. </span><span class="koboSpan" id="kobo.121.3">Therefore, the logical conclusion is that to maintain all of the cultural changes </span><a id="_idIndexMarker585"/><span class="koboSpan" id="kobo.122.1">we have prescribed in this chapter, we must encourage our teams to become self-sufficient. </span><span class="koboSpan" id="kobo.122.2">This enables the automated, independent production of change that </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">we desire.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.124.1">Drawing a new map</span></h2>
<p><span class="koboSpan" id="kobo.125.1">Finally, as we shift to fully cloud native, one of the hardest anti-patterns to break can be the coupling between services and the compute they run on. </span><span class="koboSpan" id="kobo.125.2">New services are cheap to create, maintain, and run. </span><span class="koboSpan" id="kobo.125.3">Hence, we can form bounded service contexts that encapsulate a </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">business domain.</span></span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.127.1">Domain Driven Design</span></em><span class="koboSpan" id="kobo.128.1"> is a </span><a id="_idIndexMarker586"/><span class="koboSpan" id="kobo.129.1">great read in this space; it goes into this topic in great detail. </span><span class="koboSpan" id="kobo.129.2">This allows us to evolve our architecture to meet our business domain needs rather than apply our business needs to our architecture because we installed a particular number of servers. </span><span class="koboSpan" id="kobo.129.3">Later in this book, we will dive into translating your business problems into application code and introduce the concepts of coupling and cohesion. </span><span class="koboSpan" id="kobo.129.4">The key for this chapter is to break the mentality that your architecture must fit into a predefined configuration. </span><span class="koboSpan" id="kobo.129.5">Conway’s law also applies to your architecture, and just as we break down silos in the deployment process, we must also break down silos between development teams to enable us to build the right solution in the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">right place.</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">As we can see, the cultural shift required to create genuinely cloud native solutions can take some organizations by surprise, so it is crucial to consider its magnitude. </span><span class="koboSpan" id="kobo.131.2">The key shift in thinking is about empowering and enabling teams to be self-sufficient and own their delivery from feature inception to running it in production through a cultural change from a siloed ownership and delivery model to a lean ownership model where developers are responsible for the changes they make, supported through DevSecOps enablement. </span><span class="koboSpan" id="kobo.131.3">Empowered development will allow us to deliver change faster, so let’s dive into how to enable frequent atomic changes to meet our </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">business goals.</span></span></p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.133.1">Frequent changes to meet business goals</span></h1>
<p><span class="koboSpan" id="kobo.134.1">In the previous chapter, we introduced the concept of the empowered development team. </span><span class="koboSpan" id="kobo.134.2">We worked on reducing the silos in the release process to allow ownership of the end-to-end release process. </span><span class="koboSpan" id="kobo.134.3">With this process, we can release much more frequently. </span><span class="koboSpan" id="kobo.134.4">Let’s explore the development changes that are enabling us to work under this </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">new paradigm.</span></span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.136.1">Pruning Git branches</span></h2>
<p><span class="koboSpan" id="kobo.137.1">Most</span><a id="_idIndexMarker587"/><span class="koboSpan" id="kobo.138.1"> deployment strategies will be multi-stage. </span><span class="koboSpan" id="kobo.138.2">For example, you may have environments called </span><em class="italic"><span class="koboSpan" id="kobo.139.1">development</span></em><span class="koboSpan" id="kobo.140.1">, </span><em class="italic"><span class="koboSpan" id="kobo.141.1">integration testing</span></em><span class="koboSpan" id="kobo.142.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.143.1">production</span></em><span class="koboSpan" id="kobo.144.1">. </span><span class="koboSpan" id="kobo.144.2">The understanding is that earlier environments have changes deployed first, so we can test our changes before being released to the production environment. </span><span class="koboSpan" id="kobo.144.3">Having multi-stage deployments is a pattern we recommend as it allows for the testing of features, either by the development team or through automated tests against a live environment, before we deploy the changes to production. </span><span class="koboSpan" id="kobo.144.4">With this strategy, adopting a pattern such as Gitflow may be tempting, where each environment is a self-contained branch. </span><span class="koboSpan" id="kobo.144.5">Let’s look at a typical </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">Gitflow implementation.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.146.1"><img alt="Figure 5.3 – Typical Gitflow branching model" src="image/B22364_05_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.147.1">Figure 5.3 – Typical Gitflow branching model</span></p>
<p><span class="koboSpan" id="kobo.148.1">This anti-pattern produces a false sense of security as we assume the changes are thoroughly tested in the lower environments before we push them to higher environments. </span><span class="koboSpan" id="kobo.148.2">However, with more people working on the code base and teams applying hotfixes, each branch’s contents will tend to drift over time. </span><span class="koboSpan" id="kobo.148.3">In the preceding diagram, we can see that we applied a hotfix to production, and the first time we tested our deployed feature alongside the hotfix, it was actually in the production environment. </span><span class="koboSpan" id="kobo.148.4">This uncertainty is the risk we run when maintaining environment-specific code bases. </span><span class="koboSpan" id="kobo.148.5">It </span><a id="_idIndexMarker588"/><span class="koboSpan" id="kobo.149.1">also leans toward a backslide in cultural attitudes, as the temptation to introduce manual checks between environment promotions can be detrimental. </span><span class="koboSpan" id="kobo.149.2">Instead, the principle of a single code base deployed multiple times limits our environmental drift. </span><span class="koboSpan" id="kobo.149.3">An excellent online resource, </span><em class="italic"><span class="koboSpan" id="kobo.150.1">The 12 Factor App</span></em><span class="koboSpan" id="kobo.151.1">, (</span><a href="http://12factor.net"><span class="koboSpan" id="kobo.152.1">12factor.net</span></a><span class="koboSpan" id="kobo.153.1">) adopts</span><a id="_idIndexMarker589"/><span class="koboSpan" id="kobo.154.1"> this as the </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">first factor.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">So, how do we operate a single code base effectively? </span><span class="koboSpan" id="kobo.156.2">Selecting a revision-based branching strategy, such as trunk-based development, is the easiest way to ensure that we operate from a single code base. </span><span class="koboSpan" id="kobo.156.3">Instead of an environment running the latest configuration in an environment branch, we have rules for running the last known correct configuration in a single branch, which we will promote to higher environments on an as-needed basis. </span><span class="koboSpan" id="kobo.156.4">Let’s take a look at the typical trunk-based </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">development model.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.158.1"><img alt="Figure 5.4 – Trunk-based development branching model" src="image/B22364_05_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.159.1">Figure 5.4 – Trunk-based development branching model</span></p>
<p><span class="koboSpan" id="kobo.160.1">In this example, each environment is deployed off the main branch, with lower environments having the most recent changes for testing and higher environments trailing behind on the main branch. </span><span class="koboSpan" id="kobo.160.2">By continuously integrating and deploying, we reduce our change lead time and increase our </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">deployment frequency.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.162.1">Decoupling integration and release</span></h2>
<p><span class="koboSpan" id="kobo.163.1">Now the complexity of promoting each environment is taken care of, we run into a problem not apparent in the branch or code base per environment system. </span><span class="koboSpan" id="kobo.163.2">How do we test or change features in one environment but stop them from blocking other features from deploying in higher environments? </span><span class="koboSpan" id="kobo.163.3">In the previous system, we could cherry-pick commits to promote specific features. </span><span class="koboSpan" id="kobo.163.4">The answer to this is twofold: we want an easy way for developers to test their features before merging them and an easy way to manage merged features in </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">different environments.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">The simplest solution to manage merged features is to decouple the expression of a feature in the end product from its inclusion in the code base. </span><span class="koboSpan" id="kobo.165.2">For example, a feature can be complete and merged but not present in the deployed system. </span><span class="koboSpan" id="kobo.165.3">To achieve this, we use a concept </span><a id="_idIndexMarker590"/><span class="koboSpan" id="kobo.166.1">known as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.167.1">feature flags</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Feature flags allow us to guard specific clauses in our application. </span><span class="koboSpan" id="kobo.169.2">A simple example would be a </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">Download to CSV</span></strong><span class="koboSpan" id="kobo.171.1"> button on a table; we might add the button on the frontend, but we still need to implement the download logic. </span><span class="koboSpan" id="kobo.171.2">Hence, we would surround the rendering of the button with an </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">if</span></strong><span class="koboSpan" id="kobo.173.1"> statement, and if the feature flag is off, then we wouldn’t show the button. </span><span class="koboSpan" id="kobo.173.2">When the development team works on this feature locally, they can turn the feature flag on for testing. </span><span class="koboSpan" id="kobo.173.3">The deployed environments don’t have the feature flag turned on, so we can merge the feature into the main code base without impacting the deployed application. </span><span class="koboSpan" id="kobo.173.4">Once the feature is complete, we can turn the feature on in lower environments to test the feature in an actual environment. </span><span class="koboSpan" id="kobo.173.5">By decoupling the development of a feature from its expression in the end app, we also decouple the release decision for a feature from being technically driven (i.e., the feature is present in the code base and, therefore, it will be present in the deployed application) to a business decision; we can add features </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">on demand.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">To truly decouple</span><a id="_idIndexMarker591"/><span class="koboSpan" id="kobo.176.1"> the feature release decision from the technical implementation, it’s crucial to store feature configuration within the application environment. </span><span class="koboSpan" id="kobo.176.2">In this case, an anti-pattern would be to have files checked into version control called </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">features.prod.yml</span></strong><span class="koboSpan" id="kobo.178.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">features.dev.yml</span></strong><span class="koboSpan" id="kobo.180.1">, as, once again, we are creating checked-in concretions in our </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">The best methodology for feature flagging is to check in a file to version control that defines the feature flags available and their state. </span><span class="koboSpan" id="kobo.182.2">In this file, we prefer to use something other than Booleans for feature flags as they become hard to extend later. </span><span class="koboSpan" id="kobo.182.3">Typically, we rely on enums. </span><span class="koboSpan" id="kobo.182.4">An example enum might consist of values called </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Baseline</span></strong><span class="koboSpan" id="kobo.184.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">Configurable</span></strong><span class="koboSpan" id="kobo.186.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">Off</span></strong><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">In this scenario, </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Baseline</span></strong><span class="koboSpan" id="kobo.190.1"> ensures a feature is on in all environments and is turned on by default when we deploy new environments. </span><span class="koboSpan" id="kobo.190.2">These flags represent mature features that are stable enough to be always on and are safe to use as the basis for new features. </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">Configurable</span></strong><span class="koboSpan" id="kobo.192.1"> flags are features that we want to be able to change the expression of in various environments. </span><span class="koboSpan" id="kobo.192.2">These might indicate</span><a id="_idIndexMarker592"/><span class="koboSpan" id="kobo.193.1"> yet-to-be-released features, features that are undergoing testing, or features that are incomplete but in a usable state. </span><span class="koboSpan" id="kobo.193.2">These features need a way to be either on or off in deployed environments. </span><span class="koboSpan" id="kobo.193.3">We can achieve this through application configuration if the system is small or backed by a database table if the feature list is extensive. </span><span class="koboSpan" id="kobo.193.4">Finally, we have features configured as </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">Off</span></strong><span class="koboSpan" id="kobo.195.1">; these are feature flags that should not be available on any environments but are for features that are a work in progress and need to be able to be </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">expressed locally.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">To address the problem of developers needing to test locally, this is where the advantages of building cloud native software shine. </span><span class="koboSpan" id="kobo.197.2">A common anti-pattern we see is attempting to replicate the cloud in a local environment, and many services do this. </span><span class="koboSpan" id="kobo.197.3">However, there is no substitute for actively running your code in the cloud. </span><span class="koboSpan" id="kobo.197.4">With cloud native software, using principles </span><a id="_idIndexMarker593"/><span class="koboSpan" id="kobo.198.1">such as </span><strong class="bold"><span class="koboSpan" id="kobo.199.1">infrastructure as code</span></strong><span class="koboSpan" id="kobo.200.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.201.1">IaC</span></strong><span class="koboSpan" id="kobo.202.1">) and serverless/managed services, there is no reason why developers cannot spin up an isolated development cloud environment. </span><span class="koboSpan" id="kobo.202.2">This practice allows your developers to truly develop in the cloud. </span><span class="koboSpan" id="kobo.202.3">It also ensures your IaC avoids its anti-patterns, such as hardcoded references, as we regularly create and destroy new environments. </span><span class="koboSpan" id="kobo.202.4">The development team can now also test infrastructure changes independent of deployed environments. </span><span class="koboSpan" id="kobo.202.5">This decoupling feeds into the concept of empowered teams; developers can now control the code that runs, the infrastructure it runs on, and the services it interacts with. </span><span class="koboSpan" id="kobo.202.6">They also gain familiarity with the deployment process and get closer to the ideal of “</span><em class="italic"><span class="koboSpan" id="kobo.203.1">You build it, you run it</span></em><span class="koboSpan" id="kobo.204.1">.” </span><span class="koboSpan" id="kobo.204.2">By allowing our developers to test in the cloud with a blast radius limited to the ephemeral environment they are testing in, we enable much more destructive types of testing. </span><span class="koboSpan" id="kobo.204.3">My load test on my ephemeral environment will not impact your testing on your ephemeral environment. </span><span class="koboSpan" id="kobo.204.4">By allowing this type of comprehensive testing in the pipeline, we reduce our change </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">failure rate.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.206.1">Reversing the inevitable</span></h2>
<p><span class="koboSpan" id="kobo.207.1">No system is perfect, and as we increase the rate at which we deploy, the likelihood of one of those changes going wrong is eventually a certainty. </span><span class="koboSpan" id="kobo.207.2">According to the DORA report, the change failure rate is one of the metrics we should track for organizational performance. </span><span class="koboSpan" id="kobo.207.3">Although we strive to keep this metric as low as possible if a failure occurs, another DORA metric, </span><strong class="bold"><span class="koboSpan" id="kobo.208.1">mean time to restore</span></strong><span class="koboSpan" id="kobo.209.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.210.1">MTTR</span></strong><span class="koboSpan" id="kobo.211.1">), comes into play. </span><span class="koboSpan" id="kobo.211.2">Three key anti-patterns </span><a id="_idIndexMarker594"/><span class="koboSpan" id="kobo.212.1">prevent you from optimizing your MTTR when the cause is a </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">change failure:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.214.1">Mutable artifacts</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.215.1">Destructive changes</span></span></li>
<li><span class="koboSpan" id="kobo.216.1">No reverse definition for </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">a change</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.218.1">The first anti-pattern is</span><a id="_idIndexMarker595"/><span class="koboSpan" id="kobo.219.1"> using </span><strong class="bold"><span class="koboSpan" id="kobo.220.1">mutable artifacts</span></strong><span class="koboSpan" id="kobo.221.1">, and all artifacts produced must be immutable. </span><span class="koboSpan" id="kobo.221.2">When your automated build pipeline produces an artifact as a deployment candidate, we must preserve the artifact throughout subsequent build pipeline runs. </span><span class="koboSpan" id="kobo.221.3">This immutability can be as simple as container versioning in a container registry or having all previous versions of an internal library available for installation at any point. </span><span class="koboSpan" id="kobo.221.4">By having immutable artifacts, it is simple to roll back the system to a known correct configuration. </span><span class="koboSpan" id="kobo.221.5">We can simply deploy an earlier artifact, and then we can triage the fixes in lower environments until we are ready to deploy to </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">production again.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">The second </span><a id="_idIndexMarker596"/><span class="koboSpan" id="kobo.224.1">anti-pattern is </span><strong class="bold"><span class="koboSpan" id="kobo.225.1">destructive changes</span></strong><span class="koboSpan" id="kobo.226.1">. </span><span class="koboSpan" id="kobo.226.2">Deployment of a new version of the system should allow us to roll back to previous instances of the application. </span><span class="koboSpan" id="kobo.226.3">For example, a destructive change would be dropping a database table or dropping a data store. </span><span class="koboSpan" id="kobo.226.4">When we deploy these changes, we can never roll the system back to the last known correct configuration because we have lost the system’s state in the destructive change. </span><span class="koboSpan" id="kobo.226.5">If a destructive change is required, it should go through a deprecation schedule before the final destructive change is applied to ensure that removing the functionality will not impact other </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">application areas.</span></span></p>
<p><span class="koboSpan" id="kobo.228.1">The final </span><a id="_idIndexMarker597"/><span class="koboSpan" id="kobo.229.1">anti-pattern is </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">no reverse definition for a change</span></strong><span class="koboSpan" id="kobo.231.1">. </span><span class="koboSpan" id="kobo.231.2">This anti-pattern primarily applies to stores of application state, such as databases or infrastructure changes. </span><span class="koboSpan" id="kobo.231.3">It is closely related to the second point: a change fundamentally cannot be reversible if it is destructive. </span><span class="koboSpan" id="kobo.231.4">The extension this rule applies is that any change to the system state, architecture, or data must be recoverable. </span><span class="koboSpan" id="kobo.231.5">This functionality exists for some tooling, such as Terraform comparing deployed infrastructure to a state file or a SQL Server project deployed via DACPAC. </span><span class="koboSpan" id="kobo.231.6">In other scenarios, the migration must explicitly define forward and reverse operations, such as through database SQL migrations using a tool such as Flyway or Entity Framework migrations. </span><span class="koboSpan" id="kobo.231.7">The common anti-pattern we see here is that the draft changes contain a detailed upward migration, and no one builds or tests the downward migration. </span><span class="koboSpan" id="kobo.231.8">This strategy means that significant work is often required when we need to roll back a change, as the reverse migration may need time to be created or may be non-functional if </span><a id="_idIndexMarker598"/><span class="koboSpan" id="kobo.232.1">testing is not performed. </span><span class="koboSpan" id="kobo.232.2">This results in high-pressure, high-risk situations where we must craft changes while production is impacted, resulting in corners being cut to “just get it </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">running again.”</span></span></p>
<p><span class="koboSpan" id="kobo.234.1">To summarize this section, complex release processes allow bad practices due to the high barriers between development and production. </span><span class="koboSpan" id="kobo.234.2">We can optimize delivery and increase service uptime by removing those barriers and supporting good practices. </span><span class="koboSpan" id="kobo.234.3">The key is frequent, flagged, well-tested changes that are immutable, non-destructive, and easily reversible when required. </span><span class="koboSpan" id="kobo.234.4">This allows us to develop faster, but we still need to ensure that our developers are doing the right thing, to do so we typically </span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">employ guardrails.</span></span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.236.1">Guardrails</span></h1>
<p><span class="koboSpan" id="kobo.237.1">We’ve talked </span><a id="_idIndexMarker599"/><span class="koboSpan" id="kobo.238.1">about empowering developers to do more and fully own the changes they produce. </span><span class="koboSpan" id="kobo.238.2">However, developers are not the experts; we see this fundamental anti-pattern in adopting the </span><a id="_idIndexMarker600"/><span class="koboSpan" id="kobo.239.1">shift-left mentality. </span><span class="koboSpan" id="kobo.239.2">We should not expect developers to become experts in security, </span><strong class="bold"><span class="koboSpan" id="kobo.240.1">site reliability engineering</span></strong><span class="koboSpan" id="kobo.241.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.242.1">SRE</span></strong><span class="koboSpan" id="kobo.243.1">), DevSecOps, and so on. </span><span class="koboSpan" id="kobo.243.2">Developers will need a passing knowledge of these topics but should be able to deploy with certainty without </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">being experts.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.245.1">Keeping your developers on track</span></h2>
<p><span class="koboSpan" id="kobo.246.1">A common anti-pattern that we see in this space is that because we are shifting responsibility left toward the development team, the development team needs more permissions in the cloud environment to do their job. </span><span class="koboSpan" id="kobo.246.2">The exact opposite is true. </span><span class="koboSpan" id="kobo.246.3">Developers should have a constrained set of permissions to diagnose, inspect, and support the cloud environment. </span><span class="koboSpan" id="kobo.246.4">Instead, the escalation of privilege should occur in the CI/CD pipelines, and this is how we enable our developers by providing tooling with elevated permissions. </span><span class="koboSpan" id="kobo.246.5">By doing this, we ensure that our developers can deploy independently but not outside the confines of the CI/CD environment. </span><span class="koboSpan" id="kobo.246.6">This process limits the chance of environmental drift through manual configuration, which preserves disaster </span><span class="No-Break"><span class="koboSpan" id="kobo.247.1">recovery functions.</span></span></p>
<p><span class="koboSpan" id="kobo.248.1">The primary method of enabling developers to deploy with confidence is to provide guardrails in the deployment process. </span><span class="koboSpan" id="kobo.248.2">These guardrails define an acceptable set of actions a developer can take to achieve their objectives. </span><span class="koboSpan" id="kobo.248.3">For example, an infrastructure guardrail might prevent </span><a id="_idIndexMarker601"/><span class="koboSpan" id="kobo.249.1">a </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">content delivery network</span></strong><span class="koboSpan" id="kobo.251.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.252.1">CDN</span></strong><span class="koboSpan" id="kobo.253.1">) from being deployed </span><a id="_idIndexMarker602"/><span class="koboSpan" id="kobo.254.1">without a </span><strong class="bold"><span class="koboSpan" id="kobo.255.1">web application firewall</span></strong><span class="koboSpan" id="kobo.256.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.257.1">WAF</span></strong><span class="koboSpan" id="kobo.258.1">) in front of it. </span><span class="koboSpan" id="kobo.258.2">A code-level guardrail might avoid the use of insecure hash functions. </span><span class="koboSpan" id="kobo.258.3">In both instances, we prevent changes from meeting a minimum standard when deploying them </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.260.1">We might deploy guardrails to meet regulatory compliance requirements. </span><span class="koboSpan" id="kobo.260.2">For example, a cloud-wide policy that prevents any resources from being deployed in particular regions to support data sovereignty requirements might be employed. </span><span class="koboSpan" id="kobo.260.3">This example would be perfect for </span><a id="_idIndexMarker603"/><span class="koboSpan" id="kobo.261.1">a </span><strong class="bold"><span class="koboSpan" id="kobo.262.1">service control policy</span></strong><span class="koboSpan" id="kobo.263.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.264.1">SCP</span></strong><span class="koboSpan" id="kobo.265.1">) from </span><strong class="bold"><span class="koboSpan" id="kobo.266.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.267.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.268.1">AWS</span></strong><span class="koboSpan" id="kobo.269.1">). </span><span class="koboSpan" id="kobo.269.2">These</span><a id="_idIndexMarker604"/><span class="koboSpan" id="kobo.270.1"> allow us to enforce boundaries of acceptable use at different levels of granularity, from organization-wide to individual accounts. </span><span class="koboSpan" id="kobo.270.2">For example, we lock various accounts to a specific region, and globally, we prevent all accounts from deploying resources in </span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">export-controlled areas.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">An anti-pattern in the security space is mistaking pentesting as a guardrail in the critical deployment path. </span><span class="koboSpan" id="kobo.272.2">Pentesting is a vital security step but should be outside the deployment path. </span><span class="koboSpan" id="kobo.272.3">Instead, it should run alongside the deployment process. </span><span class="koboSpan" id="kobo.272.4">We should automate all steps in the path to deployment. </span><span class="koboSpan" id="kobo.272.5">If you want to test the application security dynamically, consider using a </span><strong class="bold"><span class="koboSpan" id="kobo.273.1">dynamic application security testing</span></strong><span class="koboSpan" id="kobo.274.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.275.1">DAST</span></strong><span class="koboSpan" id="kobo.276.1">) framework on one </span><a id="_idIndexMarker605"/><span class="koboSpan" id="kobo.277.1">of the pre-prod environments as a pre-promotion check. </span><span class="koboSpan" id="kobo.277.2">The essential factor for guardrails is that developers should be able to access guardrail evaluations </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">on demand.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.279.1">Types of guardrail</span></h2>
<p><span class="koboSpan" id="kobo.280.1">We </span><a id="_idIndexMarker606"/><span class="koboSpan" id="kobo.281.1">commonly see two main types of guardrails: preventative </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">and detective.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.283.1">Preventative guardrails</span></strong><span class="koboSpan" id="kobo.284.1"> are</span><a id="_idIndexMarker607"/><span class="koboSpan" id="kobo.285.1"> proactive guardrails that specify the outer bounds of what developers can do; these are punitive, preventing the pipeline from deploying if the guardrails are activated. </span><span class="koboSpan" id="kobo.285.2">This methodology is suitable for applying easily defined heuristics (i.e., our hashing should not be using the MD5 hash algorithm). </span><span class="koboSpan" id="kobo.285.3">The common mistake we see with preventative guardrails is that they typically get </span><a id="_idIndexMarker608"/><span class="koboSpan" id="kobo.286.1">implemented, and then the developers are left to fend for themselves. </span><span class="koboSpan" id="kobo.286.2">If the guardrail fails, they have to go back and fix it. </span><span class="koboSpan" id="kobo.286.3">A better workflow is to have observability into guardrail activation. </span><span class="koboSpan" id="kobo.286.4">These metrics will tell you where developers have the most trouble and allow you to make developers’ lives easier by providing training, libraries of correct implementations, or, even better, an </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">enabling artifact.</span></span></p>
<p><span class="koboSpan" id="kobo.288.1">Next, we</span><a id="_idIndexMarker609"/><span class="koboSpan" id="kobo.289.1"> have </span><strong class="bold"><span class="koboSpan" id="kobo.290.1">detective guardrails</span></strong><span class="koboSpan" id="kobo.291.1">. </span><span class="koboSpan" id="kobo.291.2">These reactive</span><a id="_idIndexMarker610"/><span class="koboSpan" id="kobo.292.1"> guardrails scan your environment for non-compliance, then either raise the issue or take corrective action. </span><span class="koboSpan" id="kobo.292.2">For example, we could enable our developers to deploy storage with public access through a CDN. </span><span class="koboSpan" id="kobo.292.3">However, if we tag particular storage containing PII (personally identifiable information), this tagging process might be out of band with the deployment of the storage itself. </span><span class="koboSpan" id="kobo.292.4">In this case, we could add a detective guardrail that checks for storage with public access, checks whether that storage account has the tag indicating that it contains PII, and then activates the guardrail. </span><span class="koboSpan" id="kobo.292.5">This type of control is typically the least favorable, as it requires an insecure configuration to be present in the environment to detect it instead of evaluating </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">it proactively.</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">A typical driver of guardrails is security. </span><span class="koboSpan" id="kobo.294.2">Several tools exist to perform SAST to pick up common errors and allow the security team to define custom rules they want to look for. </span><span class="koboSpan" id="kobo.294.3">This space has excellent open source tooling (such as Semgrep) and many proprietary solutions. </span><span class="koboSpan" id="kobo.294.4">There is some upfront work to codify the anti-patterns you want to catch, but each codified heuristic is something that the security team no longer needs to review manually. </span><span class="koboSpan" id="kobo.294.5">Many available tools are not limited purely to security heuristics but can also check for anti-patterns such as deeply nested loops or </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">cognitive complexity.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.296.1">The case for guardrail observability</span></h2>
<p><span class="koboSpan" id="kobo.297.1">Building </span><a id="_idIndexMarker611"/><span class="koboSpan" id="kobo.298.1">guardrails is essential, but it is also important to monitor them. </span><span class="koboSpan" id="kobo.298.2">Developers use observability platforms to understand user behavior better and make changes to the applications they build to support it. </span><span class="koboSpan" id="kobo.298.3">We should do the same for our development team, who are effectively our users. </span><span class="koboSpan" id="kobo.298.4">By monitoring our guardrails, we can see the common friction points for our developers and proactively fix common issues. </span><span class="koboSpan" id="kobo.298.5">Let’s imagine our preventative guardrail from before requiring developers to deploy a WAF in front of a CDN. </span><span class="koboSpan" id="kobo.298.6">We might notice that our developers are hitting this guardrail very often, and hence, using the metrics we collect around guardrail activations, we build an enabling artifact. </span><span class="koboSpan" id="kobo.298.7">This artifact allows developers to avoid activating the guardrail and produce more secure artifacts without </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">additional rework.</span></span></p>
<p><span class="koboSpan" id="kobo.300.1">The key to enabling artifacts is to abstract away standard configurations using sensible defaults. </span><span class="koboSpan" id="kobo.300.2">Continuing with our WAF and CDN example, as a security team, we may introduce a default WAF that gets added to every CDN deployment if a developer forgets to specify one explicitly. </span><span class="koboSpan" id="kobo.300.3">If we already have a detective and preventative guardrail for this scenario, the enabling artifact minimizes the number of activations we encounter. </span><span class="koboSpan" id="kobo.300.4">When tracking metrics for these units, we recommend monitoring everything. </span><span class="koboSpan" id="kobo.300.5">Metrics about the enabling artifact tell you how often we activate the default WAF. </span><span class="koboSpan" id="kobo.300.6">These metrics can be helpful to track as they are a great way to measure enabling artifacts’ impact on the </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">development team.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">If enabling</span><a id="_idIndexMarker612"/><span class="koboSpan" id="kobo.303.1"> artifacts are the counterpart of preventative guardrails, the equivalent of detective guardrails is automated remediation. </span><span class="koboSpan" id="kobo.303.2">For our PII tagging solution, we could listen for the guardrail activation event and kick off a process that revokes public access to the bucket. </span><span class="koboSpan" id="kobo.303.3">This enables our system to be secure without outside intervention for simple </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">use cases.</span></span></p>
<p><span class="koboSpan" id="kobo.305.1">So, for a vulnerability or misconfiguration in our application, the preference is to have a sensible default added through an enabling artifact, such as a library or automated pipeline tool, then for cases outside of this to have them caught by preventative guardrails, and finally, if a misconfiguration makes it to production, then automated remediation or a manual process is initiated to </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">rectify it.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">These tools can exist in the pipeline and environment at all times. </span><span class="koboSpan" id="kobo.307.2">The final layer of security in this system should be pentesting, but it’s important to note that this needs to occur asynchronously with the deployment and development of the application. </span><span class="koboSpan" id="kobo.307.3">Ideally, the findings from penetration testing will feed back into our system of guardrails to help us develop new enabling artifacts and preventative/detective controls to stop the issue </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">from resurfacing.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.309.1">Example guardrails</span></h2>
<p><span class="koboSpan" id="kobo.310.1">In cloud </span><a id="_idIndexMarker613"/><span class="koboSpan" id="kobo.311.1">environments, there are unusual ways in which systems interact, as not only are you able to give deployed infrastructure and services the ability to interact with each other but also to interact with the underlying definitions of those resources. </span><span class="koboSpan" id="kobo.311.2">Now, we will go through some common guardrails that are easily applicable. </span><span class="koboSpan" id="kobo.311.3">By no means will this be exhaustive, but it will give you a head start. </span><span class="koboSpan" id="kobo.311.4">For our example, we will </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">use AWS.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">The guardrail examples we will use are </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.315.1">Overprivileged </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">IAM accounts</span></span></li>
<li><span class="koboSpan" id="kobo.317.1">Public </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">S3 buckets</span></span></li>
<li><span class="koboSpan" id="kobo.319.1">Data </span><span class="No-Break"><span class="koboSpan" id="kobo.320.1">sovereignty requirements</span></span></li>
<li><span class="koboSpan" id="kobo.321.1">Publicly accessible remote </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">administration tools</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.323.1">A simple place</span><a id="_idIndexMarker614"/><span class="koboSpan" id="kobo.324.1"> to start would be IAM permissions policies. </span><span class="koboSpan" id="kobo.324.2">I won’t go into detail about the principle of least privilege here, we’ll save that for a later chapter, but it’s common to see overprivileged accounts or roles defined. </span><span class="koboSpan" id="kobo.324.3">Typically, this arises because the user can’t find the correct permissions to perform the actions they require, so they end up assigning a long list of permissions, or wildcard permissions, while trying to make it work. </span><span class="koboSpan" id="kobo.324.4">This is actually a great candidate for all three methods of control discussed earlier; we can build common permissions policies that contain pre-approved policies for completing common tasks, for example, connecting our Lambda functions to a specific DynamoDB table. </span><span class="koboSpan" id="kobo.324.5">We can then also add a preventative control, such as an SCP in our account or organization to forbid access to particular APIs that are not in use. </span><span class="koboSpan" id="kobo.324.6">Finally, we can add a detective control that monitors all our active roles for policies that contain wildcard permissions, and revoke all associated grants and trust policies when one </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">is discovered.</span></span></p>
<p><span class="koboSpan" id="kobo.326.1">Another common misconfiguration that is a good candidate for guardrails is public access to S3 buckets. </span><span class="koboSpan" id="kobo.326.2">Any scenario using public access to an S3 bucket is typically better served through the use of a CloudFront distribution and an origin access identity. </span><span class="koboSpan" id="kobo.326.3">We can build an enabling artifact here in the form of a Terraform module that sets up a default configuration for a bucket and disables public access. </span><span class="koboSpan" id="kobo.326.4">We can build a preventative guardrail that checks our infrastructure plan to prevent this configuration. </span><span class="koboSpan" id="kobo.326.5">Finally, we can build a detective guardrail that scans our deployed infrastructure to ensure that no public buckets exist, and if they do, revoke </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">public access.</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">Many businesses also have the constraint of data sovereignty requirements; data for entities in a region must be stored in that region. </span><span class="koboSpan" id="kobo.328.2">Through the deployment of resources into regions that meet our data sovereignty requirements, we can be compliant. </span><span class="koboSpan" id="kobo.328.3">However, we are not provably compliant, as this approach requires the constant enforcement of a process. </span><span class="koboSpan" id="kobo.328.4">Instead, we can use a preventative control: we can build SCPs that lock resources in an account from being deployed in any region apart from the ones we specify. </span><span class="koboSpan" id="kobo.328.5">This approach must be proactive, as it only applies to new calls to the </span><span class="No-Break"><span class="koboSpan" id="kobo.329.1">AWS API.</span></span></p>
<p><span class="koboSpan" id="kobo.330.1">The last common misconfiguration we see is directly opening remote administration tools to the internet. </span><span class="koboSpan" id="kobo.330.2">For example, your EC2 instances might expose port </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">22</span></strong><span class="koboSpan" id="kobo.332.1"> to allow SSH for your developers, but now the attack surface for those instances just increased by every version</span><a id="_idIndexMarker615"/><span class="koboSpan" id="kobo.333.1"> of SSH those instances are running. </span><span class="koboSpan" id="kobo.333.2">This should be enforced at the network level, and typically, it’s good practice to have a detective guardrail (alongside preventative guard rails) in this instance. </span><span class="koboSpan" id="kobo.333.3">The temptation for a developer to open the SSH port</span><a id="_idIndexMarker616"/><span class="koboSpan" id="kobo.334.1"> in a </span><strong class="bold"><span class="koboSpan" id="kobo.335.1">network access control list</span></strong><span class="koboSpan" id="kobo.336.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.337.1">NACL</span></strong><span class="koboSpan" id="kobo.338.1">) and forget to close it is surprisingly high. </span><span class="koboSpan" id="kobo.338.2">As such, we could create an AWS Config rule to check for open port </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">22</span></strong><span class="koboSpan" id="kobo.340.1"> with unrestricted access and automatically </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">close it.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">Hopefully, through reading this section, you have come to understand the types of guardrails that can be configured and how to enable your developers to best work within the boundaries you set, without impacting their development velocity. </span><span class="koboSpan" id="kobo.342.2">The importance of monitoring your organization’s guardrails has also been discussed, with these metrics providing us with a clear insight into both our security posture and developer experience. </span><span class="koboSpan" id="kobo.342.3">Finally, we have also looked at some common misconfigurations and explored how guardrails and enabling artifacts could mitigate the risk to the business. </span><span class="koboSpan" id="kobo.342.4">So, now we have the tools to enable our developers to securely and safely own their output, let’s look at how we can shift left the responsibility of producing secure artifacts onto our </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">development teams.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.344.1">Shifting left</span></h1>
<p><span class="koboSpan" id="kobo.345.1">We have</span><a id="_idIndexMarker617"/><span class="koboSpan" id="kobo.346.1"> touched on the requirement to shift left the responsibility of producing functional, secure changes to the development team. </span><span class="koboSpan" id="kobo.346.2">The focus so far has been on the externalities of the development team. </span><span class="koboSpan" id="kobo.346.3">This section will be about the effect of shifting left on the development team and the techniques we can use to meet the new expectations imposed upon them. </span><span class="koboSpan" id="kobo.346.4">We recommend reading this chapter if you are a developer, as you will learn some valuable tools, or as part of an external function, as it will allow you to support the development </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">team better.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.348.1">Development as an iterative process</span></h2>
<p><span class="koboSpan" id="kobo.349.1">A common </span><a id="_idIndexMarker618"/><span class="koboSpan" id="kobo.350.1">anti-pattern involves</span><a id="_idIndexMarker619"/><span class="koboSpan" id="kobo.351.1"> invoking </span><strong class="bold"><span class="koboSpan" id="kobo.352.1">quality assurance</span></strong><span class="koboSpan" id="kobo.353.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.354.1">QA</span></strong><span class="koboSpan" id="kobo.355.1">) once a feature is complete in the eyes of the developer rather than a process that takes place iteratively over the software development life cycle. </span><span class="koboSpan" id="kobo.355.2">We spoke earlier about ephemeral environments, which are helpful for a developer to develop their feature in isolation and provide an environment where somebody can test the feature in its incomplete state. </span><span class="koboSpan" id="kobo.355.3">Different companies have different QA functions, which may come from a dedicated QA role or exist as part of the product team. </span><span class="koboSpan" id="kobo.355.4">The key here is that ephemeral environments allow you to involve the QA function much earlier in </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">the process.</span></span></p>
<p><span class="koboSpan" id="kobo.357.1">Another anti-pattern here is using long-lived feature branches with ephemeral environments. </span><span class="koboSpan" id="kobo.357.2">We develop the feature on multiple small branches, each containing a portion of the work required for the entire feature to operate. </span><span class="koboSpan" id="kobo.357.3">The ephemeral environment allows us an alternative deployment with enabled incomplete features. </span><span class="koboSpan" id="kobo.357.4">We establish a fast feedback cycle between developers and the QA process by getting QA involved from the first commit. </span><span class="koboSpan" id="kobo.357.5">Shifting left the QA to be parallel or integrated with the development allows us to mitigate the risk that a significant feature may fail QA once we have completed the feature, requiring significant rework to fix. </span><span class="koboSpan" id="kobo.357.6">It also brings us closer to a no-silo model by fostering collaboration between QA and </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">development functions.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.359.1">Test first, code later</span></h2>
<p><span class="koboSpan" id="kobo.360.1">One of the </span><a id="_idIndexMarker620"/><span class="koboSpan" id="kobo.361.1">anti-patterns that teams typically seem to</span><a id="_idIndexMarker621"/><span class="koboSpan" id="kobo.362.1"> acknowledge but fail to implement correctly is </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">test-driven development</span></strong><span class="koboSpan" id="kobo.364.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.365.1">TDD</span></strong><span class="koboSpan" id="kobo.366.1">) and, by </span><a id="_idIndexMarker622"/><span class="koboSpan" id="kobo.367.1">extension, </span><strong class="bold"><span class="koboSpan" id="kobo.368.1">behavior-driven development</span></strong><span class="koboSpan" id="kobo.369.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.370.1">BDD</span></strong><span class="koboSpan" id="kobo.371.1">). </span><span class="koboSpan" id="kobo.371.2">When asking development teams whether they use TDD or BDD, they usually answer in the affirmative, but when asked when they write their tests, they respond that they write the tests after the code. </span><span class="koboSpan" id="kobo.371.3">Cognitive dissonance aside, true BDD involves defining the behavior of your system and writing a test that can check for compliance with that behavior before actually implementing the system. </span><span class="koboSpan" id="kobo.371.4">Another fallacy that comes into play when implementing BDD is a waterfall-style approach to coding tests, specifying all the edge cases you foresee and writing too many tests upfront. </span><span class="koboSpan" id="kobo.371.5">A lot of system behavior and requirements only emerge through the actual implementation of the system, and writing too many tests up front just hampers this discovery process. </span><span class="koboSpan" id="kobo.371.6">Instead, an excellent approach to use in BDD is the red, green, refactor system. </span><span class="koboSpan" id="kobo.371.7">You define your desired behavior and write simple tests to ensure the system fulfills the desired behavior. </span><span class="koboSpan" id="kobo.371.8">These</span><a id="_idIndexMarker623"/><span class="koboSpan" id="kobo.372.1"> tests will fail (red), and we will then implement a system that passes these tests (green). </span><span class="koboSpan" id="kobo.372.2">Through the design of this system, we then refactor the implementation and the test suite to exhibit the desired behavior accurately and test the emergent behavior of the system. </span><span class="koboSpan" id="kobo.372.3">We must create the initial desired behavior with the product owner to ensure that the desired behavior test accurately reflects the behavior required in the end product. </span><span class="koboSpan" id="kobo.372.4">This process will shift left the desired behavior’s description to a point before we write </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">any code.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">Once we create tests, they should enter the deployment pipeline’s critical path. </span><span class="koboSpan" id="kobo.374.2">This practice ensures that future changes to the system do not prevent it from exhibiting the desired behavior required. </span><span class="koboSpan" id="kobo.374.3">A common anti-pattern that teams can fall into in this stage is failing to trust their tests’ output fully. </span><span class="koboSpan" id="kobo.374.4">In an extreme case, this might look like accepting a certain percentage of failed tests as “par for the course.” </span><span class="koboSpan" id="kobo.374.5">This lack of confidence in the tests undermines the value of the entire test suite, as developers no longer have confidence that their changes do not cause regressions on </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">existing behaviors.</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">The second and more common pattern is the existence of intermittent test failures. </span><span class="koboSpan" id="kobo.376.2">Intermittent failure commonly occurs when tests are not properly isolated, and the side effects of one test may influence the result of another test. </span><span class="koboSpan" id="kobo.376.3">Typically, in this scenario, the developers rerun the pipeline until the intermittent test passes. </span><span class="koboSpan" id="kobo.376.4">This behavior is counterproductive for two reasons: firstly, we’re increasing the time developers are waiting for pipeline executions to finish, and secondly, we have a failing test that we are ignoring. </span><span class="koboSpan" id="kobo.376.5">In this scenario, rather than putting up with the inconvenience of multiple pipeline runs, we should be adequately reestablishing the boundaries of our tests and creating a new test that checks for regression of the intermittent behavior. </span><span class="koboSpan" id="kobo.376.6">By vigorously enforcing these test suites, we shift left the responsibilities of detecting and rectifying regressions to the developer responsible for the regression as part of their development process rather than waiting for the regression to become apparent in the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">end product.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.378.1">Shared ownership of output</span></h2>
<p><span class="koboSpan" id="kobo.379.1">Consider</span><a id="_idIndexMarker624"/><span class="koboSpan" id="kobo.380.1"> Fred Brooks’s famous quote: “</span><em class="italic"><span class="koboSpan" id="kobo.381.1">What one programmer can do in one month, two programmers can do in two months</span></em><span class="koboSpan" id="kobo.382.1">.” </span><span class="koboSpan" id="kobo.382.2">While tongue-in-cheek, the sentiment holds when we program in isolation. </span><span class="koboSpan" id="kobo.382.3">The increased communication channels and distribution of knowledge can make the development process more demanding, which leads us to our third common</span><a id="_idIndexMarker625"/><span class="koboSpan" id="kobo.383.1"> anti-pattern, </span><strong class="bold"><span class="koboSpan" id="kobo.384.1">isolated development</span></strong><span class="koboSpan" id="kobo.385.1">. </span><span class="koboSpan" id="kobo.385.2">We have seen software teams where they only interact with each other in the daily standup. </span><span class="koboSpan" id="kobo.385.3">This system falls back into our old patterns of slow feedback cycles. </span><span class="koboSpan" id="kobo.385.4">If I have a daily standup and need the output from one other developer on my team to progress my feature, it may be complete 5 minutes after the standup, and I would need to wait until the next day to hear about it. </span><span class="koboSpan" id="kobo.385.5">I’ve seen high-performing development teams on a virtual call all day, splitting off the primary call to pair and mob program as required. </span><span class="koboSpan" id="kobo.385.6">The key differentiator here is that the high-performing team sees their delivery as a shared output rather than an individual output. </span><span class="koboSpan" id="kobo.385.7">This differentiator also needs to be reflected in how we track productivity metrics, which should reflect a team’s productivity, not the individual’s. </span><span class="koboSpan" id="kobo.385.8">Management of the individual is informed by feedback from other team members, as the team is the value we want </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">to optimize.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">Small and regular changes, merged back to the code base, are also crucial from a code review perspective. </span><span class="koboSpan" id="kobo.387.2">Show a developer a 12-line pull request, and they will have plenty of comments. </span><span class="koboSpan" id="kobo.387.3">Show them a 1,200-line pull request, and you’ll likely get zero comments. </span><span class="koboSpan" id="kobo.387.4">Maybe you will get a response of “</span><em class="italic"><span class="koboSpan" id="kobo.388.1">Looks good to me</span></em><span class="koboSpan" id="kobo.389.1">.” </span><span class="koboSpan" id="kobo.389.2">The main enemy of this approach is long-running feature branches. </span><span class="koboSpan" id="kobo.389.3">If you’re not regularly merging code with the main branch, then the reviewer does not stand a chance of understanding the scope of the change. </span><span class="koboSpan" id="kobo.389.4">Development processes that support small, atomic changes are essential here, such as trunk-based development and feature flagging, as discussed earlier in this chapter. </span><span class="koboSpan" id="kobo.389.5">When working toward deadlines, there is typically a tendency to approve pull requests with more relaxed standards to integrate changes in time. </span><span class="koboSpan" id="kobo.389.6">This approach, however, is a false economy. </span><span class="koboSpan" id="kobo.389.7">By approving lax changes, such as code that does not conform to coding standards or code with high cognitive complexity, we are simply robbing ourselves of future velocity and building up technical debt. </span><span class="koboSpan" id="kobo.389.8">The other side of this coin is that when we rigorously enforce coding standards at the pull request stage, we slowly start to see an uplift in the team, and future pull requests from the same team member are less likely to have the same mistakes. </span><span class="koboSpan" id="kobo.389.9">The failure to enforce coding standards is the key to our false economy. </span><span class="koboSpan" id="kobo.389.10">Enforcement versus non-enforcement of the coding standards eventually brings you to an equivalent or increased </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">development velocity.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.391.1">Experimenting and getting feedback early</span></h2>
<p><span class="koboSpan" id="kobo.392.1">We have</span><a id="_idIndexMarker626"/><span class="koboSpan" id="kobo.393.1"> examined the feedback loops in a typical software development business function. </span><span class="koboSpan" id="kobo.393.2">However, you should also look at feedback loops that may be more specific to your business. </span><span class="koboSpan" id="kobo.393.3">An example might be that an order-matching engine from a financial system might require the last six months of data to be fed into the system to ensure it reaches the same target state as the existing engine. </span><span class="koboSpan" id="kobo.393.4">To shift this left, we might use a smaller time range with dummy data that developers can run locally to get instant feedback. </span><span class="koboSpan" id="kobo.393.5">The key to shifting left is identifying these feedback loops and either putting them into the hands of developers directly or enabling developers to interact with the business unit responsible in the early stages of development. </span><span class="koboSpan" id="kobo.393.6">This business process optimization ensures that we are breaking down the chance of a late part of the process coming back with significant changes. </span><span class="koboSpan" id="kobo.393.7">To facilitate this, we recommend mapping out all the parts of the deployment process that occur once a change leaves the hands of a developer and finding the areas where this process experiences the most failures (i.e., requires rework by the developer). </span><span class="koboSpan" id="kobo.393.8">These parts of the process are your best candidates for shifting left. </span><span class="koboSpan" id="kobo.393.9">It’s important to note that, once again, you need metrics on the process to identify these stages, so observability in your deployment process is a significant factor in </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">its efficacy.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">Shifting left also requires the development team to be the source of truth in tackling a feature. </span><span class="koboSpan" id="kobo.395.2">The development team must be allowed to experiment before committing to a solution. </span><span class="koboSpan" id="kobo.395.3">A great way to approach this is through timeboxed technical spikes, possibly multiple in parallel if different approaches need testing for their efficacy. </span><span class="koboSpan" id="kobo.395.4">The crucial factor here is allowing developers to experiment, with the culmination of their work validating an idea or assumption rather than introducing a change or a new feature. </span><span class="koboSpan" id="kobo.395.5">This process is another area where ephemeral environments shine. </span><span class="koboSpan" id="kobo.395.6">Having a consequence-free sandbox to test a proof-of-concept idea allows the development team to, in the words of Mark Zuckerberg, “</span><em class="italic"><span class="koboSpan" id="kobo.396.1">move fast and break things</span></em><span class="koboSpan" id="kobo.397.1">.” </span><span class="koboSpan" id="kobo.397.2">Even though this approach does not aim to produce a tangible outcome, typically, these technical spikes, if successful, will form the basis of a new change or feature. </span><span class="koboSpan" id="kobo.397.3">So, even though the goal was not to create a change, the technical spike often does not result in </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">lost productivity.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.399.1">Building in security from the start</span></h2>
<p><span class="koboSpan" id="kobo.400.1">The</span><a id="_idIndexMarker627"/><span class="koboSpan" id="kobo.401.1"> final requirement of the shift-left methodology is ensuring that security is part of the cloud native solution from the inception of the changes. </span><span class="koboSpan" id="kobo.401.2">Developers must all be conscious of the effects of their decisions on the overall solution security posture. </span><span class="koboSpan" id="kobo.401.3">Developers do not need to be security experts. </span><span class="koboSpan" id="kobo.401.4">Instead, they must shift their thinking from “</span><em class="italic"><span class="koboSpan" id="kobo.402.1">Does it achieve the required objective?</span></em><span class="koboSpan" id="kobo.403.1">” to consider the new attack surface their changes could provide. </span><span class="koboSpan" id="kobo.403.2">An excellent way to guide a development team that is newly adopting shift-left methodologies into their way of working is to undertake threat modeling of a change as part of the development process. </span><span class="koboSpan" id="kobo.403.3">By shifting into the mindset of an attacker, we can quickly identify threats and put mitigations into place to defend against them. </span><span class="koboSpan" id="kobo.403.4">This exercise is even more effective if the security team is involved in the first few attempts. </span><span class="koboSpan" id="kobo.403.5">While the team’s goal is to become self-sufficient (a topic we will touch on soon), using enabling teams is essential to set a consistent quality </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">across teams.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">By shifting left, we have enabled our developers to produce secure, complete, and production-ready changes. </span><span class="koboSpan" id="kobo.405.2">Using appropriate tooling and business processes has increased the development velocity and given our developers the control and proper safeguards to apply themselves to finding the best solution. </span><span class="koboSpan" id="kobo.405.3">Now we have teams that are expected to own their output, we will next look at how to make these teams </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">truly self-sufficient.</span></span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.407.1">Self-sufficient teams</span></h1>
<p><span class="koboSpan" id="kobo.408.1">With all the</span><a id="_idIndexMarker628"/><span class="koboSpan" id="kobo.409.1"> changes we have made in culture, process, tooling, and delivery, we expect our teams to become self-sufficient change factories. </span><span class="koboSpan" id="kobo.409.2">But how can we adjust our team’s internal structures to ensure that the team can organize and support these new ways </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">of working?</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.411.1">Trifecta leadership</span></h2>
<p><span class="koboSpan" id="kobo.412.1">Spotify </span><a id="_idIndexMarker629"/><span class="koboSpan" id="kobo.413.1">popularized a </span><a id="_idIndexMarker630"/><span class="koboSpan" id="kobo.414.1">model known as the </span><em class="italic"><span class="koboSpan" id="kobo.415.1">Squad Model</span></em><span class="koboSpan" id="kobo.416.1">. </span><span class="koboSpan" id="kobo.416.2">While, typically, it </span><a id="_idIndexMarker631"/><span class="koboSpan" id="kobo.417.1">also ascribes much larger structures beyond the independent squads, we will focus on the structure of the squad itself. </span><span class="koboSpan" id="kobo.417.2">There is valid criticism of the larger model. </span><span class="koboSpan" id="kobo.417.3">However, this does not take away from the validity of the atomic team structure. </span><span class="koboSpan" id="kobo.417.4">The crux of the team is that it is a unit that works on a specific product. </span><span class="koboSpan" id="kobo.417.5">It contains a trio of leaders who orient the squad’s development efforts. </span><span class="koboSpan" id="kobo.417.6">These leaders are the engineering manager, responsible for the team’s technical direction; the product owner, who represents the customer; and the scrum master, who organizes the team’s efforts. </span><span class="koboSpan" id="kobo.417.7">By encapsulating the responsibilities </span><a id="_idIndexMarker632"/><span class="koboSpan" id="kobo.418.1">of a team within the team itself and allowing the team the ability to work across the entire product, we can now scale these squads horizontally without linearly increasing management overhead. </span><span class="koboSpan" id="kobo.418.2">We are now venturing into scalable, agile delivery, which matches well with the requirements for cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">native development.</span></span></p>
<p><span class="koboSpan" id="kobo.420.1">The key to </span><a id="_idIndexMarker633"/><span class="koboSpan" id="kobo.421.1">successfully implementing this format is understanding that while the leadership is a trifecta, there is minimal overlap in actual responsibility. </span><span class="koboSpan" id="kobo.421.2">A common anti-pattern in this space is all developers reporting to the engineering manager. </span><span class="koboSpan" id="kobo.421.3">Developers are the implementers of change, and there is much more nuance to producing change in a system than technical direction. </span><span class="koboSpan" id="kobo.421.4">Instead, developers become stewards of the changes that they are making, understanding the product thinking behind it and the technical direction required to implement it. </span><span class="koboSpan" id="kobo.421.5">A great way to communicate this is through a </span><a id="_idIndexMarker634"/><span class="koboSpan" id="kobo.422.1">concept called </span><em class="italic"><span class="koboSpan" id="kobo.423.1">commander’s intent</span></em><span class="koboSpan" id="kobo.424.1">. </span><span class="koboSpan" id="kobo.424.2">This refers to the abstraction of leadership direction to encompass the goal, allowing for flexibility in our method. </span><span class="koboSpan" id="kobo.424.3">In its original form, the order might require us to move to a particular position on the battlefield, but the intent is to take a specific hill in concert with other units. </span><span class="koboSpan" id="kobo.424.4">If we focus on the </span><em class="italic"><span class="koboSpan" id="kobo.425.1">how</span></em><span class="koboSpan" id="kobo.426.1"> (moving to the positions), we might miss opportunities to accomplish the </span><em class="italic"><span class="koboSpan" id="kobo.427.1">what</span></em><span class="koboSpan" id="kobo.428.1"> (taking </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">the hill).</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Similarly, if we dictate the steps a developer must take to implement a feature, emergent opportunities that are only visible to the implementer might be overlooked. </span><span class="koboSpan" id="kobo.430.2">This situation is where the trifecta leadership and collaborative model of squads is potent. </span><span class="koboSpan" id="kobo.430.3">Not only can we communicate the commander’s intent of a particular change but developers also have local sources of authority to present these new opportunities for </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">strategic direction.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">Previously, I worked in an organization that used a particular framework to attempt to safely scale agile development while retaining complete control over the product teams. </span><span class="koboSpan" id="kobo.432.2">This framework implementation resulted in a misalignment of strategic direction. </span><span class="koboSpan" id="kobo.432.3">In other words, the process did not empower the teams to be self-sufficient and capitalize on opportunities, as the requirement was to surface such opportunities at multiple layers before we could take action. </span><span class="koboSpan" id="kobo.432.4">The self-sufficient team is the antithesis of this paradigm. </span><span class="koboSpan" id="kobo.432.5">Rather than asserting control, we seek to empower and provide strategic direction while enabling </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">strategic opportunity.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.434.1">The topology of your teams</span></h2>
<p><span class="koboSpan" id="kobo.435.1">In their</span><a id="_idIndexMarker635"/><span class="koboSpan" id="kobo.436.1"> seminal work, </span><em class="italic"><span class="koboSpan" id="kobo.437.1">Team Topologies</span></em><span class="koboSpan" id="kobo.438.1">, Matthew Skelton and Manuel Pais identify four types of teams in a DevSecOps-focused organization, </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">as follows:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.440.1">Stream-aligned teams</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.441.1">Enabling teams</span></span></li>
<li><span class="koboSpan" id="kobo.442.1">Complicated </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">subsystem team</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.444.1">Platform team</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.445.1">The stream-aligned team is an expert in a business domain, aligning its output with the strategic direction of that business area. </span><span class="koboSpan" id="kobo.445.2">This team is your organization’s primary type, directly focused on changes that will solve your business’s or its customers’ problems. </span><span class="koboSpan" id="kobo.445.3">Note that the organization of these teams is by business domain, while Conway’s law assumes that these domains will naturally be bounded contexts within our architecture. </span><span class="koboSpan" id="kobo.445.4">We should not constrain the team to own and operate only a particular part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">The enabling team supports the other team types in achieving their goals by providing technical guidance and enabling artifacts to the development team. </span><span class="koboSpan" id="kobo.447.2">For example, a dedicated security team might assist teams with unique security problems in their development process. </span><span class="koboSpan" id="kobo.447.3">It’s important to note that the existence of these teams does not absolve other teams of their responsibilities. </span><span class="koboSpan" id="kobo.447.4">These teams are enhancers, not replacements </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">for self-sufficiency.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">The complicated subsystem team deals with a subsystem that takes deep technical or engineering capability. </span><span class="koboSpan" id="kobo.449.2">This type of team is generally the only time we assign a team to a particular part of your organization’s architecture, and typically, the role of this team is to abstract the complicated subsystem so that other parts of the business can interact with it. </span><span class="koboSpan" id="kobo.449.3">A typical example might be a bank that still has a mainframe; we manage the mainframe with a complicated subsystem team that provides interfaces for other teams to </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">interact with.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">The platform team is the development team for your developers; they build internal products for which your other teams are the consumers. </span><span class="koboSpan" id="kobo.451.2">The platform might consist of standardized build pipelines and guardrails, enabling artifacts and tooling such as Git, ticket management software, and so on. </span><span class="koboSpan" id="kobo.451.3">As we discussed before, your metrics and customer development teams should guide this team’s strategic direction. </span><span class="koboSpan" id="kobo.451.4">These teams have three main modes </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">of operation:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.453.1">Collaboration</span></strong><span class="koboSpan" id="kobo.454.1">: This involves teams working together for some time. </span><span class="koboSpan" id="kobo.454.2">These might be teams with closely related changes in progress, a stream team working with the platform team to develop new tooling, or a team working with a complicated subsystem team to evolve </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">the service.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.456.1">X as a service</span></strong><span class="koboSpan" id="kobo.457.1">: This model typically refers to complicated subsystem teams abstracting away technically complex functionality behind a service that other teams </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">can consume.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.459.1">Facilitating</span></strong><span class="koboSpan" id="kobo.460.1">: This involves teams working together to achieve a particular team’s goals. </span><span class="koboSpan" id="kobo.460.2">For example, the security enabling team might facilitate changes to the authorization logic required by a stream-aligned team. </span><span class="koboSpan" id="kobo.460.3">This mode typically also involves empowering the team to be self-sufficient </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">moving forward.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.462.1">When identifying</span><a id="_idIndexMarker636"/><span class="koboSpan" id="kobo.463.1"> these modes of operation, a few anti-patterns arise. </span><span class="koboSpan" id="kobo.463.2">The most common one is assuming that too many parts of your organization are complicated subsystems. </span><span class="koboSpan" id="kobo.463.3">The critical distinction is that complicated subsystem teams focus on something technically complex. </span><span class="koboSpan" id="kobo.463.4">A complex business domain is not a complicated subsystem. </span><span class="koboSpan" id="kobo.463.5">This method of thinking returns us to the trap of aligning our teams with our existing architecture rather than our business domains and allowing the architecture to grow out of the natural bounded contexts of those </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">emergent domains.</span></span></p>
<p><span class="koboSpan" id="kobo.465.1">When enabling teams need to facilitate the goals of stream-aligned teams, a common mistake they make is to assume that, as the experts in that area, they should just make the required changes. </span><span class="koboSpan" id="kobo.465.2">Fundamentally, to foster team self-sufficiency, the enabling team needs to mentor the stream-aligned team to improve the </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">team’s capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.467.1">Finally, it can be tempting to use the X-as-a-service pattern liberally for things that are the entire organization’s responsibility. </span><span class="koboSpan" id="kobo.467.2">A key example is security. </span><span class="koboSpan" id="kobo.467.3">Security is not a system we can develop in isolation and provide to developers as a service. </span><span class="koboSpan" id="kobo.467.4">It is the responsibility of every member of every team. </span><span class="koboSpan" id="kobo.467.5">We can build our platform tooling and enabling teams to incentivize and foster good security practices. </span><span class="koboSpan" id="kobo.467.6">The purpose of the X-as-a-service mode of interaction is to remove technical responsibility from the service consumers, which is counterproductive in the case </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">of security.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.469.1">Champions and the T-shaped engineer</span></h2>
<p><span class="koboSpan" id="kobo.470.1">As we shift from </span><a id="_idIndexMarker637"/><span class="koboSpan" id="kobo.471.1">a traditional delivery model to a cloud native delivery model, we also broaden the horizon of services we can consume. </span><span class="koboSpan" id="kobo.471.2">Rather than solving business problems in the same ways over</span><a id="_idIndexMarker638"/><span class="koboSpan" id="kobo.472.1"> and over again, we have the opportunity to leverage cloud native services. </span><span class="koboSpan" id="kobo.472.2">However, as we broaden our horizons, inevitably, we must educate our teams on the best practices for these new types of services. </span><span class="koboSpan" id="kobo.472.3">In the traditional model, every developer could understand the architecture and code patterns required. </span><span class="koboSpan" id="kobo.472.4">It is unreasonable to expect all of our team</span><a id="_idIndexMarker639"/><span class="koboSpan" id="kobo.473.1"> to become experts overnight; however, each of our developers will need to acquire a broad knowledge of cloud native services to identify when certain patterns should be used. </span><span class="koboSpan" id="kobo.473.2">This broad knowledge forms the top bar of the T-shaped engineer, a wide but shallow knowledge that is typically acquired through self-learning. </span><span class="koboSpan" id="kobo.473.3">When they use certain patterns repeatedly, they develop a deep understanding of specific implementation idiosyncrasies of the services involved, developing a deep knowledge. </span><span class="koboSpan" id="kobo.473.4">This forms the column of our T-shaped engineer, a deep but tightly scoped expertise. </span><span class="koboSpan" id="kobo.473.5">The idea is that with a few T-shaped engineers on the team, we have a diversity of technical opinions available to guide the technical direction of </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">the team.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">For business-wide, job-zero initiatives, such as security, accessibility, or code quality, we recommend electing champions within the teams to provide self-sufficient teams with the internal capability to meet their goals. </span><span class="koboSpan" id="kobo.475.2">It is then the responsibility of the governing group behind this initiative, which may be an enabling team, to support these champions in developing their field. </span><span class="koboSpan" id="kobo.475.3">This may include supporting self-learning through certification pathways, funding them to attend conferences, and providing internal knowledge-sharing opportunities. </span><span class="koboSpan" id="kobo.475.4">The key here is that the company must invest in its people for the initiative to succeed and yield results. </span><span class="koboSpan" id="kobo.475.5">It is simply not enough to continue business as usual. </span><span class="koboSpan" id="kobo.475.6">In the cloud space, technology and practices evolve rapidly; as a company, to maximize your return on cloud investment, you must invest </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">in people.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">Building cloud native capability within teams takes time; it is important to recognize the need to provide teams with all the tools and opportunities to become self-sufficient. </span><span class="koboSpan" id="kobo.477.2">To achieve this, we explored using a trifecta leadership of the product owner, engineering manager, and scrum master. </span><span class="koboSpan" id="kobo.477.3">We also looked at ways for teams to organize their interactions with each other. </span><span class="koboSpan" id="kobo.477.4">Finally, we looked at how we can grow initiatives in the organization and provide diverse opinions by encouraging T-shaped engineers and </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">champion programs.</span></span></p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.479.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.480.1">Through ownership of output and team empowerment, we have transformed our development teams into genuinely self-sufficient powerhouses. </span><span class="koboSpan" id="kobo.480.2">We have tempered their output with automated processes and guardrails to ensure that they are working within the constraints required by our business. </span><span class="koboSpan" id="kobo.480.3">We have also looked at mitigating the impact any one negative change can have on the overall system. </span><span class="koboSpan" id="kobo.480.4">These atomic changes will form the basis of our new development model going forward. </span><span class="koboSpan" id="kobo.480.5">Next up, we will be looking deeper into maintaining security and compliance in cloud </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">native environments.</span></span></p>
</div>
</body></html>