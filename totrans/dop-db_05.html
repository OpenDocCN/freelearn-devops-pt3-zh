<html><head></head><body>
<div id="_idContainer017">
<h1 class="chapter-number" id="_idParaDest-96"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.2.1">RDBMS with DevOps</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we’ll delve into the intricate yet rewarding relationship between </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">relational database management systems</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">RDBMSs</span></strong><span class="koboSpan" id="kobo.7.1">) and DevOps. </span><span class="koboSpan" id="kobo.7.2">As you traverse this chapter, you will gain a deep understanding of how modern DevOps practices </span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.8.1">can be intertwined with RDBMS to create a streamlined, efficient, and secure IT environment. </span><span class="koboSpan" id="kobo.8.2">This combination offers numerous advantages, and learning how to exploit them is pivotal for any organization aiming to stay competitive in today’s fast-paced </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">digital landscape.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">One of the first critical aspects we will explore is provisioning and configuration management. </span><span class="koboSpan" id="kobo.10.2">Understanding how to automate these tasks for databases in a DevOps culture is essential for rapid deployments and scaling. </span><span class="koboSpan" id="kobo.10.3">You’ll discover how to implement IaC approaches that enable frictionless environment setup and </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">configuration changes.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">Next, we’ll move on to monitoring and alerting, which serve as the eyes and ears of any robust system. </span><span class="koboSpan" id="kobo.12.2">You’ll learn the latest tools and techniques for real-time database monitoring and how to set up automated alerting mechanisms. </span><span class="koboSpan" id="kobo.12.3">This knowledge will allow you to identify and fix issues before they escalate, thus ensuring continuous uptime and </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">operational efficiency.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">Following this, this chapter will guide you through the vital areas of backup and disaster recovery. </span><span class="koboSpan" id="kobo.14.2">Here, you’ll find out how to integrate these critical strategies seamlessly into your DevOps pipeline, ensuring that your data is safe and that your systems are resilient against </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">unforeseen calamities.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">Performance optimization is another key theme. </span><span class="koboSpan" id="kobo.16.2">You’ll learn the best practices for making your RDBMS run as efficiently as possible, from indexing and query optimization to caching and beyond. </span><span class="koboSpan" id="kobo.16.3">We’ll show you how to identify bottlenecks and improve database performance, all within the framework of a </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">DevOps culture.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">Last but not least, we’ll touch upon DevSecOps, the practice that integrates security into DevOps. </span><span class="koboSpan" id="kobo.18.2">You’ll understand why security can’t be an afterthought and how to embed security measures right into your DevOps workflows and </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">RDBMS configurations.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">By addressing these essential components, this chapter will serve as a comprehensive guide to melding RDBMS and DevOps, replete with actionable insights. </span><span class="koboSpan" id="kobo.20.2">For system administrators, database administrators, and DevOps engineers alike, the knowledge you will acquire here will be indispensable in leveraging the full power of integrating RDBMS </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">with DevOps.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">this chapter:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Embracing DevOps</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Provisioning and </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">configuration management</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Monitoring </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">and alerting</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Backup and </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">disaster recovery</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.31.1">Performance optimization</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.32.1">DevSecOps</span></span></li>
</ul>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.33.1">Embracing DevOps</span></h1>
<p><span class="koboSpan" id="kobo.34.1">In a DevOps team, several </span><a id="_idIndexMarker372"/><span class="koboSpan" id="kobo.35.1">activities are involved in managing and maintaining relational databases. </span><span class="koboSpan" id="kobo.35.2">Some of the main activities and challenges include </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.37.1">Provisioning and </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">configuration management</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">Monitoring </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">and alerting</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">Backup and </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">disaster recovery</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.43.1">Performance optimization</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">Security and </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">access management</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.46.1">In the following sections, we will discuss each of these activities in detail and provide examples of how they can be implemented using </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">various tools.</span></span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.48.1">Provisioning and configuration management</span></h2>
<p><span class="koboSpan" id="kobo.49.1">One of the primary activities of a DevOps team is to provision and configure relational databases. </span><span class="koboSpan" id="kobo.49.2">This includes creating database instances, configuring database settings, and managing </span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.50.1">database users and permissions. </span><span class="koboSpan" id="kobo.50.2">Here are some examples of how this can </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">be accomplished:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.52.1">Creating a MySQL database instance </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">using Terraform</span></span></li>
<li><span class="koboSpan" id="kobo.54.1">Configuring PostgreSQL settings using Ansible </span></li>
<li><span class="koboSpan" id="kobo.55.1">Managing Oracle users and permissions </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">using Puppet</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.57.1">Let’s look at these examples </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">in detail.</span></span></p>
<h3><span class="koboSpan" id="kobo.59.1">Creating a MySQL database instance using Terraform</span></h3>
<p><span class="koboSpan" id="kobo.60.1">Creating </span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.61.1">a MySQL database instance in </span><strong class="bold"><span class="koboSpan" id="kobo.62.1">Amazon Web Services</span></strong><span class="koboSpan" id="kobo.63.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.64.1">AWS</span></strong><span class="koboSpan" id="kobo.65.1">) using Terraform </span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.66.1">involves several steps, including setting up the necessary infrastructure, configuring the database, and launching </span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.67.1">the instance. </span><span class="koboSpan" id="kobo.67.2">In this example, we </span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.68.1">will use Terraform to automate the process of creating a MySQL database instance </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">in AWS.</span></span></p>
<h4><span class="koboSpan" id="kobo.70.1">Architecture overview</span></h4>
<p><span class="koboSpan" id="kobo.71.1">The </span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.72.1">architecture we’ll use in this example involves the </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">following components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.74.1">Virtual Private Cloud</span></strong><span class="koboSpan" id="kobo.75.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">VPC</span></strong><span class="koboSpan" id="kobo.77.1">): A VPC is a virtual network that you can configure </span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.78.1">to host your AWS resources. </span><span class="koboSpan" id="kobo.78.2">It provides an isolated environment for your resources and enables you to control </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">network access.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.80.1">Subnet</span></strong><span class="koboSpan" id="kobo.81.1">: A subnet is </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.82.1">a range of IP addresses in your VPC that you can use to launch </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">your resources.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.84.1">Security group</span></strong><span class="koboSpan" id="kobo.85.1">: A security </span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.86.1">group acts as a virtual firewall for your instances to control inbound and outbound traffic. </span><span class="koboSpan" id="kobo.86.2">You can specify rules for inbound and outbound traffic to and from </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">the instances.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.88.1">A Relational Database Service</span></strong><span class="koboSpan" id="kobo.89.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.90.1">RDS</span></strong><span class="koboSpan" id="kobo.91.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">instance</span></strong><span class="koboSpan" id="kobo.93.1">: Amazon RDS is a managed </span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.94.1">database service that makes it easier to set up, operate, and scale a relational database in the cloud. </span><span class="koboSpan" id="kobo.94.2">In this example, we will use RDS to create a MySQL </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">database instance.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.96.1">Terraform is a tool for building, changing, and versioning infrastructure safely and efficiently. </span><span class="koboSpan" id="kobo.96.2">It uses a </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.97.1">declarative approach to </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">Infrastructure as Code</span></strong><span class="koboSpan" id="kobo.99.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.100.1">IaC</span></strong><span class="koboSpan" id="kobo.101.1">), meaning that you define the desired state of your infrastructure and Terraform will figure out how to </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">create it.</span></span></p>
<h4><span class="koboSpan" id="kobo.103.1">Step 1 – setting up the necessary infrastructure</span></h4>
<p><span class="koboSpan" id="kobo.104.1">The first </span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.105.1">step in creating a MySQL database instance using Terraform is to set up the necessary infrastructure. </span><span class="koboSpan" id="kobo.105.2">We will create a VPC, a subnet, and a security group for the RDS instance. </span><span class="koboSpan" id="kobo.105.3">Here’s some example Terraform code for setting up </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">the infrastructure:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.107.1">VPC</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.108.1">
provider "aws" {
  region = "us-west-2"
}
resource "aws_vpc" "example" {
  cidr_block = "10.0.0.0/16"
}
resource "aws_subnet" "example" {
  vpc_id     = aws_vpc.example.id
  cidr_block = "10.0.1.0/24"
}
resource "aws_security_group" "rds" {
  name_prefix = "rds"
  vpc_id      = aws_vpc.example.id
  ingress {
    from_port   = 3306
    to_port     = 3306
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
}</span></pre> <p><span class="koboSpan" id="kobo.109.1">This </span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.110.1">code sets up a VPC with a CIDR block of </span><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">10.0.0.0/16</span></strong><span class="koboSpan" id="kobo.112.1"> and a subnet with a CIDR block of </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">10.0.1.0/24</span></strong><span class="koboSpan" id="kobo.114.1">. </span><span class="koboSpan" id="kobo.114.2">It also creates a security group for the RDS instance with an ingress rule that allows traffic on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">3306</span></strong><span class="koboSpan" id="kobo.116.1"> from any </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">IP address.</span></span></p>
<h4><span class="koboSpan" id="kobo.118.1">Step 2 – configuring the database</span></h4>
<p><span class="koboSpan" id="kobo.119.1">The next </span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.120.1">step is to configure the MySQL database. </span><span class="koboSpan" id="kobo.120.2">We will create a parameter group and a database instance with the necessary settings. </span><span class="koboSpan" id="kobo.120.3">Here’s some example Terraform code for configuring </span><span class="No-Break"><span class="koboSpan" id="kobo.121.1">the database:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.122.1">SQL</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.123.1">
resource "aws_db_parameter_group" "example" {
  name_prefix = "example"
  family      = "mysql5.7"
  parameter {
    name  = "innodb_buffer_pool_size"
    value = "256M"
  }
  parameter {
    name  = "max_connections"
    value = "1000"
  }
}
resource "aws_db_instance" "example" {
  allocated_storage    = 20
  storage_type         = "gp2"
  engine               = "mysql"
  engine_version       = "5.7"
  instance_class       = "db.t2.micro"
  name                 = "example"
  username             = "admin"
  password             = "password"
}</span></pre> <p><span class="koboSpan" id="kobo.124.1">The preceding </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.125.1">code creates a parameter group for the MySQL database instance with two parameters – </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">innodb_buffer_pool_size</span></strong><span class="koboSpan" id="kobo.127.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">max_connections</span></strong><span class="koboSpan" id="kobo.129.1">. </span><span class="koboSpan" id="kobo.129.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">innodb_buffer_pool_size</span></strong><span class="koboSpan" id="kobo.131.1"> parameter sets the size of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">InnoDB</span></strong><span class="koboSpan" id="kobo.133.1"> buffer pool to 256 MB, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">max_connections</span></strong><span class="koboSpan" id="kobo.135.1"> parameter sets the maximum number of connections </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">1000</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">This code </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.140.1">also creates an RDS instance with the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">following configuration:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.142.1">Allocated storage of </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">20 GB</span></span></li>
<li><span class="koboSpan" id="kobo.144.1">A storage type </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">gp2</span></strong></span></li>
<li><span class="koboSpan" id="kobo.147.1">MySQL engine </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">version 5.7</span></span></li>
<li><span class="koboSpan" id="kobo.149.1">An instance class </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">db.t2.micro</span></strong></span></li>
<li><span class="koboSpan" id="kobo.152.1">An instance name </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">example</span></strong></span></li>
<li><span class="koboSpan" id="kobo.155.1">A database username </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">admin</span></strong></span></li>
<li><span class="koboSpan" id="kobo.158.1">A database password </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">password</span></strong></span></li>
</ul>
<h4><span class="koboSpan" id="kobo.161.1">Step 3 – launching the instance</span></h4>
<p><span class="koboSpan" id="kobo.162.1">The final </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.163.1">step is to launch the RDS instance. </span><span class="koboSpan" id="kobo.163.2">Here’s some example Terraform code for launching </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">the instance:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.165.1">RDS</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.166.1">
resource "aws_db_instance" "example" {
  # ... </span><span class="koboSpan" id="kobo.166.2">other configuration ...
</span><span class="koboSpan" id="kobo.166.3">  vpc_security_group_ids = [
    aws_security_group.rds.id,
  ]
  db_subnet_group_name = aws_db_subnet_group.example.name
}
resource "aws_db_subnet_group" "example" {
  name       = "example"
  subnet_ids = [aws_subnet.example.id]
} 
resource "aws_db_instance" "example" {
  # ... </span><span class="koboSpan" id="kobo.166.4">other configuration ...
</span><span class="koboSpan" id="kobo.166.5">  vpc_security_group_ids = [
    aws_security_group.rds.id,
  ]
  db_subnet_group_name = aws_db_subnet_group.example.name
}
resource "aws_db_subnet_group" "example" {
  name       = "example"
  subnet_ids = [aws_subnet.example.id]
}</span></pre> <p><span class="koboSpan" id="kobo.167.1">This code </span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.168.1">launches the RDS instance and associates it with the security group and subnet we created in </span><em class="italic"><span class="koboSpan" id="kobo.169.1">Step 1</span></em><span class="koboSpan" id="kobo.170.1">. </span><span class="koboSpan" id="kobo.170.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">vpc_security_group_ids</span></strong><span class="koboSpan" id="kobo.172.1"> parameter specifies the ID of the security group we created earlier, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">db_subnet_group_name</span></strong><span class="koboSpan" id="kobo.174.1"> parameter specifies the name of the subnet group we created in </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">this step.</span></span></p>
<p><span class="koboSpan" id="kobo.176.1">The subnet group is created to specify the subnet where the database instance will be launched. </span><span class="koboSpan" id="kobo.176.2">In this example, we are only using one subnet, but you can create multiple subnets in different availability zones for high availability and </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">disaster recovery.</span></span></p>
<h4><span class="koboSpan" id="kobo.178.1">Conclusion</span></h4>
<p><span class="koboSpan" id="kobo.179.1">In conclusion, creating a MySQL database instance in AWS using Terraform involves setting up the necessary infrastructure, configuring the database, and launching the instance. </span><span class="koboSpan" id="kobo.179.2">The infrastructure includes a VPC, a subnet, and a security group for the RDS instance. </span><span class="koboSpan" id="kobo.179.3">The database is configured using a parameter group and an RDS instance with the necessary settings. </span><span class="koboSpan" id="kobo.179.4">Finally, the RDS instance is launched and associated with the security group and subnet group. </span><span class="koboSpan" id="kobo.179.5">Terraform simplifies this process by allowing you to automate the creation and management of </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">your IaC.</span></span></p>
<h3><span class="koboSpan" id="kobo.181.1">Configuring PostgreSQL settings using Ansible</span></h3>
<p><span class="koboSpan" id="kobo.182.1">Configuring </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.183.1">PostgreSQL settings using </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.184.1">Ansible in AWS involves automating the configuration of PostgreSQL database settings using Ansible, a popular automation tool. </span><span class="koboSpan" id="kobo.184.2">In this example, we will use Ansible to install PostgreSQL on an EC2 instance in AWS, create a database and user, and configure various settings such as memory allocation, connection settings, </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">and logging.</span></span></p>
<h4><span class="koboSpan" id="kobo.186.1">Architecture overview</span></h4>
<p><span class="koboSpan" id="kobo.187.1">The architecture </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.188.1">used in this example consists of an AWS EC2 instance running Ubuntu 20.04 LTS as the operating system. </span><span class="koboSpan" id="kobo.188.2">Ansible will be used to provision the instance with PostgreSQL, create a database and user, and configure </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">PostgreSQL settings.</span></span></p>
<p><span class="koboSpan" id="kobo.190.1">To get started, we will assume that Ansible is already installed and configured on the local machine. </span><span class="koboSpan" id="kobo.190.2">We will also assume that an AWS EC2 instance has been launched and that we have the necessary credentials to access it </span><span class="No-Break"><span class="koboSpan" id="kobo.191.1">via SSH.</span></span></p>
<h4><span class="koboSpan" id="kobo.192.1">Step 1 – creating an Ansible playbook</span></h4>
<p><span class="koboSpan" id="kobo.193.1">The first </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.194.1">step is to create an Ansible playbook that will define the tasks to be performed. </span><span class="koboSpan" id="kobo.194.2">We will create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">postgres.yml</span></strong><span class="koboSpan" id="kobo.196.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">playbooks</span></strong><span class="koboSpan" id="kobo.198.1"> directory with the </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">following contents:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.200.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.201.1">
- name: Install PostgreSQL
  hosts: db
  become: yes
  become_user: root
  tasks:
    - name: Install PostgreSQL
      apt: name=postgresql state=present
      notify:
        - Restart PostgreSQL
- name: Create database and user
  hosts: db
  become: yes
  become_user: postgres
  tasks:
    - name: Create database
      postgresql_db: name=mydb
    - name: Create user
      postgresql_user: name=myuser password=mypassword priv=ALL db=mydb
- name: Configure PostgreSQL
  hosts: db
  become: yes
  become_user: postgres
  tasks:
    - name: Set shared memory
      lineinfile:
        path: /etc/sysctl.conf
        line: "kernel.shmmax = 134217728"
      notify:
        - Reload sysctl
    - name: Set max connections
      lineinfile:
        path: /etc/postgresql/13/main/postgresql.conf
        regexp: '^max_connections'
        line: "max_connections = 100"
      notify:
        - Restart PostgreSQL
    - name: Set logging settings
      lineinfile:
        path: /etc/postgresql/13/main/postgresql.conf
        regexp: '^log_'
        line: "log_destination = 'csvlog'"
      notify:
        - Restart PostgreSQL
- name: Restart PostgreSQL
  hosts: db
  become: yes
  become_user: postgres
  tasks:
    - name: Restart PostgreSQL
      service: name=postgresql state=restarted
- name: Reload sysctl
  hosts: db
  become: yes
  become_user: root
  tasks:
    - name: Reload sysctl
      command: sysctl -p</span></pre> <p><span class="koboSpan" id="kobo.202.1">This </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.203.1">playbook defines four </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">main tasks:</span></span></p>
<ol>
<li><span class="No-Break"><span class="koboSpan" id="kobo.205.1">Install PostgreSQL.</span></span></li>
<li><span class="koboSpan" id="kobo.206.1">Create a database </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">and user.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.208.1">Configure PostgreSQL.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.209.1">Restart PostgreSQL.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.210.1">The playbook is divided into several sections, each containing a list of tasks to be executed. </span><span class="koboSpan" id="kobo.210.2">Each task specifies the name of the module to be used, the parameters to be passed, and any notifications that should be triggered </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">upon completion.</span></span></p>
<h4><span class="koboSpan" id="kobo.212.1">Step 2 – creating an inventory file</span></h4>
<p><span class="koboSpan" id="kobo.213.1">The next </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.214.1">step is to create an inventory file that defines the hosts that will be targeted by the playbook. </span><span class="koboSpan" id="kobo.214.2">We will create a file called </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">hosts</span></strong><span class="koboSpan" id="kobo.216.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">inventory</span></strong><span class="koboSpan" id="kobo.218.1"> directory with the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">following contents:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.220.1">hosts</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">
[db]
ec2-instance ansible_host=&lt;ec2-instance-ip&gt; ansible_user=ubuntu</span></pre> <p><span class="koboSpan" id="kobo.222.1">This inventory file defines a single host group called </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">db</span></strong><span class="koboSpan" id="kobo.224.1"> that contains the IP address of the EC2 instance and the username to be used for </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">SSH access.</span></span></p>
<h4><span class="koboSpan" id="kobo.226.1">Step 3 – running the playbook</span></h4>
<p><span class="koboSpan" id="kobo.227.1">Now that </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.228.1">we have created the playbook and inventory file, we can run the playbook using the </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">following command:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.230.1">Bash</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.231.1">ansible-playbook -i inventory/hosts playbooks/postgres.yml</span></strong></pre> <p><span class="koboSpan" id="kobo.232.1">This command tells Ansible to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">hosts</span></strong><span class="koboSpan" id="kobo.234.1"> file in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">inventory</span></strong><span class="koboSpan" id="kobo.236.1"> directory and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">postgres.yml</span></strong><span class="koboSpan" id="kobo.238.1"> file in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.239.1">playbooks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.240.1"> directory.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">Upon execution, Ansible will perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">following actions:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.243.1">Install PostgreSQL on the </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">EC2 instance.</span></span></li>
<li><span class="koboSpan" id="kobo.245.1">Create a database called </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">mydb</span></strong><span class="koboSpan" id="kobo.247.1"> and a user called </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">myuser</span></strong><span class="koboSpan" id="kobo.249.1"> with a password </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">mypassword</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.253.1">Set the shared memory </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">134217728</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.257.1">Set the maximum number of connections </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">100</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.260.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.261.1">Configure </span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.262.1">logging to write logs to a </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">CSV file.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.264.1">Restart PostgreSQL.</span></span></li>
</ol>
<h4><span class="koboSpan" id="kobo.265.1">Step 4 – verifying the configuration</span></h4>
<p><span class="koboSpan" id="kobo.266.1">To verify </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.267.1">that the PostgreSQL configuration was successful, we can SSH into the EC2 instance and use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">psql</span></strong><span class="koboSpan" id="kobo.269.1"> command to connect to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">mydb</span></strong><span class="koboSpan" id="kobo.271.1"> database using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">myuser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.273.1"> user:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.274.1">psql -d mydb -U myuser</span></strong></pre> <p><span class="koboSpan" id="kobo.275.1">If the connection is successful, we can run the following command to view the current </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">PostgreSQL settings:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.277.1">PSQL</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.278.1">show all;</span></strong></pre> <p><span class="koboSpan" id="kobo.279.1">This command will display a list of all the current PostgreSQL settings, including the values that we set in the </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">Ansible playbook.</span></span></p>
<h4><span class="koboSpan" id="kobo.281.1">Conclusion</span></h4>
<p><span class="koboSpan" id="kobo.282.1">In conclusion, configuring PostgreSQL settings using Ansible in AWS involves automating the installation, configuration, and management of a PostgreSQL database on an EC2 instance in AWS. </span><span class="koboSpan" id="kobo.282.2">The architecture used in this example consists of an EC2 instance running Ubuntu 20.04 LTS as the operating system, Ansible as the automation tool, and a playbook that defines the tasks to be performed. </span><span class="koboSpan" id="kobo.282.3">By using Ansible to automate the configuration of PostgreSQL, we can reduce the time and effort required to set up and manage a PostgreSQL database, while also ensuring consistency and accuracy in </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">the configuration.</span></span></p>
<h3><span class="koboSpan" id="kobo.284.1">Managing Oracle users and permissions using Puppet</span></h3>
<p><span class="koboSpan" id="kobo.285.1">Managing Oracle users and permissions in AWS using Puppet is a complex process that requires </span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.286.1">a thorough understanding </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.287.1">of both Puppet </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.288.1">and Oracle database management. </span><span class="koboSpan" id="kobo.288.2">This example will cover the architecture used in such a setup and provide some sample code to illustrate </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the implementation.</span></span></p>
<h4><span class="koboSpan" id="kobo.290.1">Architecture overview</span></h4>
<p><span class="koboSpan" id="kobo.291.1">The </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.292.1">architecture used in this example comprises </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">four components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.294.1">AWS EC2 instances</span></strong><span class="koboSpan" id="kobo.295.1">: These are virtual machines that host the Oracle database </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.296.1">and the Puppet master. </span><span class="koboSpan" id="kobo.296.2">The EC2 instances are launched from an </span><strong class="bold"><span class="koboSpan" id="kobo.297.1">Amazon Machine Image</span></strong><span class="koboSpan" id="kobo.298.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.299.1">AMI</span></strong><span class="koboSpan" id="kobo.300.1">) that has an Oracle database and </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">Puppet pre-installed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.302.1">Puppet master</span></strong><span class="koboSpan" id="kobo.303.1">: This is the central point of control for all Puppet agents that are responsible for managing the Oracle database. </span><span class="koboSpan" id="kobo.303.2">The Puppet master contains the Puppet manifests and modules that define the desired state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">Oracle database.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.305.1">Puppet agents</span></strong><span class="koboSpan" id="kobo.306.1">: These are the EC2 instances running the Oracle database that are managed by the Puppet master. </span><span class="koboSpan" id="kobo.306.2">The agents run the Puppet client, which communicates with the Puppet master to retrieve and apply the </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">configuration changes.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.308.1">Oracle database</span></strong><span class="koboSpan" id="kobo.309.1">: This is the database instance that is being managed by Puppet. </span><span class="koboSpan" id="kobo.309.2">The Oracle database is installed on the EC2 instances and is managed using </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">Puppet manifests.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.311.1">Let’s look at an example that demonstrates how to manage Oracle users and permissions using Puppet </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">in AWS.</span></span></p>
<h4><span class="koboSpan" id="kobo.313.1">Step 1 – defining Oracle users and permissions in Puppet manifests</span></h4>
<p><span class="koboSpan" id="kobo.314.1">The </span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.315.1">following Puppet manifest defines a user named </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">user1</span></strong><span class="koboSpan" id="kobo.317.1"> with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">home</span></strong><span class="koboSpan" id="kobo.319.1"> director and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">.profile</span></strong><span class="koboSpan" id="kobo.321.1"> file containing environment variables, and grants the user connect and resource privileges in the </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">Oracle database:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.323.1">Puppet</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.324.1">
class oracle::users {
    user { 'user1':
        ensure     =&gt; present,
        home       =&gt; '/home/user1',
        managehome =&gt; true,
    }
    file { '/home/user1/.profile':
        ensure =&gt; file,
        content =&gt; "export ORACLE_SID=ORCL\nexport ORACLE_HOME=/u01/app/oracle/product/12.2.0/dbhome_1\nexport PATH=$PATH:$ORACLE_HOME/bin\n",
        owner =&gt; 'user1',
        group =&gt; 'dba',
        mode =&gt; '0600',
        require =&gt; User['user1'],
    }
    exec { 'create_user1':
        command =&gt; '/u01/app/oracle/product/12.2.0/dbhome_1/bin/sqlplus / as sysdba &lt;&lt;EOF\nCREATE USER user1 IDENTIFIED BY password;\nGRANT CONNECT, RESOURCE TO user1;\nEXIT;\nEOF\n',
        onlyif  =&gt; '/u01/app/oracle/product/12.2.0/dbhome_1/bin/sqlplus / as sysdba @/tmp/user1_exists.sql | grep -q "0 rows selected"',
        require =&gt; File['/home/user1/.profile'],
    }
}</span></pre> <h4><span class="koboSpan" id="kobo.325.1">Step 2 – assigning the Oracle user manifest to the Oracle database agent node</span></h4>
<p><span class="koboSpan" id="kobo.326.1">The </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.327.1">following Puppet manifest assigns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">oracle::users</span></strong><span class="koboSpan" id="kobo.329.1"> class to the Oracle database agent node named </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">oracle-db-agent</span></strong><span class="koboSpan" id="kobo.331.1">. </span><span class="koboSpan" id="kobo.331.2">This means that the user and permission settings defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.332.1">oracle::users</span></strong><span class="koboSpan" id="kobo.333.1"> class will be applied to the Oracle database on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">oracle-db-agent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.335.1"> node:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.336.1">Puppet</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.337.1">
node 'oracle-db-agent' {
    include oracle::users
}</span></pre> <h4><span class="koboSpan" id="kobo.338.1">Step 3 – running Puppet on the Oracle database agent node</span></h4>
<p><span class="koboSpan" id="kobo.339.1">To </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.340.1">apply the user and permission changes to the Oracle database, run the following command on the Oracle database </span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">agent node:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.342.1">sudo puppet agent -t</span></strong></pre> <p><span class="koboSpan" id="kobo.343.1">This command instructs the Puppet client to retrieve the configuration changes from the Puppet master and apply them to the </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">Oracle database.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">Managing Oracle users and permissions using Puppet in AWS is a powerful and efficient way to manage the database infrastructure. </span><span class="koboSpan" id="kobo.345.2">The architecture used in this example leverages the power of AWS EC2 instances, Puppet, and Oracle database management to automate the process of managing users and permissions. </span><span class="koboSpan" id="kobo.345.3">The provided code examples demonstrate how to use Puppet to manage Oracle users and permissions in AWS, and can be extended to cover other areas of Oracle </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">database management.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">In </span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.348.1">addition to managing users and permissions, Puppet can be used to automate other database administration tasks such as database configuration, backups, and monitoring. </span><span class="koboSpan" id="kobo.348.2">The Puppet manifests and modules can be customized to suit specific database environments and requirements, making it a flexible and powerful tool for managing Oracle databases </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">in AWS.</span></span></p>
<h4><span class="koboSpan" id="kobo.350.1">Conclusion</span></h4>
<p><span class="koboSpan" id="kobo.351.1">In summary, using Puppet to manage Oracle users and permissions in AWS involves defining the desired state of the database in Puppet manifests, assigning the manifests to the appropriate agent nodes, and running Puppet to apply the configuration changes. </span><span class="koboSpan" id="kobo.351.2">The architecture used in this example leverages the power of AWS EC2 instances, Puppet, and Oracle database management to provide a robust and efficient way of managing Oracle databases </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">in AWS.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.353.1">Monitoring and alerting</span></h2>
<p><span class="koboSpan" id="kobo.354.1">Another important activity for a DevOps team is to monitor and alert on the performance </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.355.1">and availability of relational databases. </span><span class="koboSpan" id="kobo.355.2">This includes monitoring database metrics, setting up alarms and notifications, and investigating and resolving issues. </span><span class="koboSpan" id="kobo.355.3">Let’s look at some examples of how this can </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">be accomplished.</span></span></p>
<h3><span class="koboSpan" id="kobo.357.1">Monitoring MySQL metrics using Datadog</span></h3>
<p><span class="koboSpan" id="kobo.358.1">Monitoring </span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.359.1">database </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.360.1">performance is an essential </span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.361.1">aspect of managing any application’s infrastructure. </span><span class="koboSpan" id="kobo.361.2">Datadog is a popular cloud-based monitoring tool that provides insights into system metrics, application metrics, logs, and more. </span><span class="koboSpan" id="kobo.361.3">In this example, we will explore how to monitor </span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.362.1">MySQL metrics using Datadog in </span><strong class="bold"><span class="koboSpan" id="kobo.363.1">Google Cloud </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.364.1">Platform</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.365.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.366.1">GCP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">).</span></span></p>
<h4><span class="koboSpan" id="kobo.368.1">Architecture overview</span></h4>
<p><span class="koboSpan" id="kobo.369.1">The </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.370.1">architecture for monitoring MySQL metrics using Datadog in GCP involves the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">following components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.372.1">MySQL Server</span></strong><span class="koboSpan" id="kobo.373.1">: This is the database server that needs to be monitored. </span><span class="koboSpan" id="kobo.373.2">In this example, we will use a MySQL instance running on a Compute Engine VM </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">in GCP.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.375.1">Datadog Agent</span></strong><span class="koboSpan" id="kobo.376.1">: The Datadog Agent is a lightweight daemon that collects and sends system and application metrics to Datadog. </span><span class="koboSpan" id="kobo.376.2">It is installed on the MySQL server in </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">this example.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.378.1">Datadog API</span></strong><span class="koboSpan" id="kobo.379.1">: The Datadog API is used to create dashboards, alerts, and other monitoring features </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">in Datadog.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.381.1">GCP Stackdriver</span></strong><span class="koboSpan" id="kobo.382.1">: GCP Stackdriver is a monitoring and logging platform provided by Google. </span><span class="koboSpan" id="kobo.382.2">It is used to collect logs and metrics from the </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">MySQL instance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.384.1">Pub/Sub</span></strong><span class="koboSpan" id="kobo.385.1">: Pub/Sub is a messaging service provided by GCP. </span><span class="koboSpan" id="kobo.385.2">It is used to send Stackdriver logs </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">to Datadog.</span></span></li>
</ul>
<h4><span class="koboSpan" id="kobo.387.1">Step 1 – setting up Datadog</span></h4>
<p><span class="koboSpan" id="kobo.388.1">To use </span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.389.1">Datadog for monitoring MySQL metrics, you need to create a Datadog account and set up the Datadog Agent. </span><span class="koboSpan" id="kobo.389.2">The Datadog Agent can be installed on MySQL Server using the </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">following command:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.391.1">Bash</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.392.1">
DD_API_KEY=&lt;YOUR_API_KEY&gt; bash -c "$(curl -L https://raw.githubusercontent.com/DataDog/datadog-agent/master/cmd/agent/install_script.sh)"</span></pre> <p><span class="koboSpan" id="kobo.393.1">Replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">&lt;YOUR_API_KEY&gt;</span></strong><span class="koboSpan" id="kobo.395.1"> with your Datadog </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">API key.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Once the Datadog Agent has been installed, you can configure it to collect MySQL metrics by adding the following to the Datadog Agent configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">file (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">/etc/datadog-agent/datadog.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">):</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.401.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.402.1">
logs:
  - type: file
    path: /var/log/mysql/error.log
    service: mysql
    source: mysql
    sourcecategory: database
    log_processing_rules:
      - type: multi_line
        name: new_log_start_with_date
        pattern: \d{4}\-\d{2}\-\d{2}</span></pre> <p><span class="koboSpan" id="kobo.403.1">This configuration </span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.404.1">tells the Datadog Agent to collect MySQL error logs and send them to Datadog with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">database</span></strong><span class="koboSpan" id="kobo.406.1"> source category. </span></p>
<h4><span class="koboSpan" id="kobo.407.1">Step 2 – setting up Stackdriver</span></h4>
<p><span class="koboSpan" id="kobo.408.1">To collect metrics from the MySQL instance, you need to set up Stackdriver on the Compute </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.409.1">Engine VM. </span><span class="koboSpan" id="kobo.409.2">You can do this by following the instructions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">GCP documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.411.1">Once Stackdriver has been set up, you can create a custom metric for MySQL metrics by adding the following to the MySQL configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.412.1">file (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">/etc/mysql/my.cnf</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">):</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.415.1">INI file</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.416.1">
[mysqld_exporter]
user = root
password = &lt;YOUR_PASSWORD&gt;</span></pre> <p><span class="koboSpan" id="kobo.417.1">Replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">&lt;YOUR_PASSWORD&gt;</span></strong><span class="koboSpan" id="kobo.419.1"> with your MySQL </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">root password.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">This </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.422.1">configuration tells </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">mysqld_exporter</span></strong><span class="koboSpan" id="kobo.424.1"> to expose MySQL metrics for Stackdriver </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">to collect.</span></span></p>
<h4><span class="koboSpan" id="kobo.426.1">Step 3 – sending Stackdriver logs to Datadog</span></h4>
<p><span class="koboSpan" id="kobo.427.1">To send Stackdriver logs to Datadog, you need to set up a Pub/Sub topic and subscription. </span><span class="koboSpan" id="kobo.427.2">You can do this by following the instructions in the </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">GCP documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.429.1">Once the </span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.430.1">Pub/Sub topic and subscription have been set up, you can configure Stackdriver to send logs to Pub/Sub by adding the following to the Stackdriver log </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">sink configuration:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.432.1">Bash</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.433.1">destination: pubsub.googleapis.com/projects/&lt;PROJECT_ID&gt;/topics/&lt;TOPIC_NAME&gt;</span></strong></pre> <p><span class="koboSpan" id="kobo.434.1">Replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.435.1">&lt;PROJECT_ID&gt;</span></strong><span class="koboSpan" id="kobo.436.1"> with your GCP project ID and </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">&lt;TOPIC_NAME&gt;</span></strong><span class="koboSpan" id="kobo.438.1"> with the name of your </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">Pub/Sub topic.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Next, you need to configure Datadog to receive logs from Pub/Sub. </span><span class="koboSpan" id="kobo.440.2">To do this, create a new log pipeline in Datadog and configure it to receive logs from the </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">Pub/Sub subscription.</span></span></p>
<h4><span class="koboSpan" id="kobo.442.1">Step 4 – creating a Datadog dashboard</span></h4>
<p><span class="koboSpan" id="kobo.443.1">With the </span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.444.1">MySQL metrics collected and sent to Datadog, you can now create a dashboard to monitor them. </span><span class="koboSpan" id="kobo.444.2">To create a new dashboard in Datadog, go to the </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">Dashboards</span></strong><span class="koboSpan" id="kobo.446.1"> page and click </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.447.1">New Dashboard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">On the </span><strong class="bold"><span class="koboSpan" id="kobo.450.1">New Dashboard</span></strong><span class="koboSpan" id="kobo.451.1"> page, select a layout and add widgets to display the MySQL metrics you want to monitor. </span><span class="koboSpan" id="kobo.451.2">For example, you can add a MySQL overview widget to display the total number of queries, connections, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">important metrics.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">You can also add widgets to display specific MySQL metrics, such as the number of slow queries or the percentage of </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">CPU usage.</span></span></p>
<h4><span class="koboSpan" id="kobo.455.1">Step 5 – setting up alerts</span></h4>
<p><span class="koboSpan" id="kobo.456.1">In addition to monitoring MySQL metrics with a dashboard, you can also set up alerts to notify you </span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.457.1">when specific metrics exceed a certain threshold. </span><span class="koboSpan" id="kobo.457.2">To create a new alert in Datadog, go to the </span><strong class="bold"><span class="koboSpan" id="kobo.458.1">Alerts</span></strong><span class="koboSpan" id="kobo.459.1"> page and click </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.460.1">New Monitor</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">On the </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">New Monitor</span></strong><span class="koboSpan" id="kobo.464.1"> page, select the MySQL metrics you want to monitor and configure the alert settings, such as the threshold and </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">notification method.</span></span></p>
<p><span class="koboSpan" id="kobo.466.1">For example, you can create an alert to notify you when the number of slow queries exceeds a certain threshold or when the percentage of CPU usage is above a </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">certain level.</span></span></p>
<h4><span class="koboSpan" id="kobo.468.1">Conclusion</span></h4>
<p><span class="koboSpan" id="kobo.469.1">In this example, we explored how to monitor MySQL metrics using Datadog in GCP. </span><span class="koboSpan" id="kobo.469.2">By setting up the Datadog Agent, Stackdriver, Pub/Sub, and a Datadog dashboard, we were able to collect, visualize, and monitor MySQL metrics with ease. </span><span class="koboSpan" id="kobo.469.3">With alerts set up, we can also receive notifications when important metrics exceed a certain threshold, allowing us to quickly identify and resolve any issues with the </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">MySQL instance.</span></span></p>
<h3><span class="koboSpan" id="kobo.471.1">Setting up PostgreSQL alarms using Prometheus</span></h3>
<p><span class="koboSpan" id="kobo.472.1">PostgreSQL </span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.473.1">is a powerful open source RDBMS. </span><span class="koboSpan" id="kobo.473.2">Prometheus is a monitoring and alerting </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.474.1">toolkit that collects metrics from </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.475.1">monitored targets, stores them, and makes them available for querying and alerting. </span><span class="koboSpan" id="kobo.475.2">GCP provides a scalable infrastructure for deploying and </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">managing applications.</span></span></p>
<h4><span class="koboSpan" id="kobo.477.1">Architecture overview</span></h4>
<p><span class="koboSpan" id="kobo.478.1">To set </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.479.1">up PostgreSQL alarms using Prometheus in GCP, we will follow the </span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">following architecture:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.481.1">Deploy PostgreSQL on GCP</span></strong><span class="koboSpan" id="kobo.482.1">: We will deploy PostgreSQL on GCP using Google Cloud SQL, a managed SQL database service that makes it easy to set up, manage, and administer </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">PostgreSQL databases.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.484.1">Export PostgreSQL metrics</span></strong><span class="koboSpan" id="kobo.485.1">: We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.487.1"> extension to export PostgreSQL metrics to Prometheus. </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.489.1"> is an open source </span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.490.1">PostgreSQL extension that exports PostgreSQL metrics in the </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">Prometheus format.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.492.1">Collect PostgreSQL metrics</span></strong><span class="koboSpan" id="kobo.493.1">: We will use Prometheus to collect PostgreSQL metrics from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.494.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.495.1"> extension. </span><span class="koboSpan" id="kobo.495.2">Prometheus can scrape metrics from targets using HTTP(S) endpoints. </span><span class="koboSpan" id="kobo.495.3">We will expose the PostgreSQL metrics using an </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">HTTP endpoint.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.497.1">Set up Prometheus alerts</span></strong><span class="koboSpan" id="kobo.498.1">: We will use Prometheus to set up alerts based on the collected PostgreSQL metrics. </span><span class="koboSpan" id="kobo.498.2">Prometheus alerts are rules that specify conditions for triggering an alert. </span><span class="koboSpan" id="kobo.498.3">When an alert is triggered, Prometheus sends a notification to an </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">alert manager.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.500.1">Send alerts to a notification channel</span></strong><span class="koboSpan" id="kobo.501.1">: We will use Alertmanager to send alerts to a notification channel, such as email </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">or Slack.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.503.1">Here’s the step-by-step guide on how to set up PostgreSQL alarms using Prometheus </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">in GCP.</span></span></p>
<h4><span class="koboSpan" id="kobo.505.1">Step 1 – deploying PostgreSQL on GCP</span></h4>
<p><span class="koboSpan" id="kobo.506.1">We will </span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.507.1">use Google Cloud SQL to deploy PostgreSQL on GCP. </span><span class="koboSpan" id="kobo.507.2">Follow these steps to deploy PostgreSQL </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">on GCP:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.509.1">Create a new Cloud SQL instance in the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">GCP console.</span></span></li>
<li><span class="koboSpan" id="kobo.511.1">Choose PostgreSQL as the </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">database engine.</span></span></li>
<li><span class="koboSpan" id="kobo.513.1">Choose the desired region and configure </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">the instance.</span></span></li>
<li><span class="koboSpan" id="kobo.515.1">Create a new user and database for </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">the application.</span></span></li>
<li><span class="koboSpan" id="kobo.517.1">Set up the connection to the </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">PostgreSQL instance.</span></span></li>
</ol>
<h4><span class="koboSpan" id="kobo.519.1">Step 2 – exporting PostgreSQL metrics</span></h4>
<p><span class="koboSpan" id="kobo.520.1">We will </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.521.1">use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.523.1"> extension to export PostgreSQL metrics to Prometheus. </span><span class="koboSpan" id="kobo.523.2">Follow these steps to export </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">PostgreSQL metrics:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.525.1">Install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.527.1"> extension on the </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">PostgreSQL instance.</span></span></li>
<li><span class="koboSpan" id="kobo.529.1">Enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.531.1"> extension in the </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">PostgreSQL instance.</span></span></li>
<li><span class="koboSpan" id="kobo.533.1">Configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.535.1"> extension to expose the PostgreSQL metrics using an </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">HTTP endpoint.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.537.1">Here’s an example of how to enable the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">pg_prometheus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.539.1"> extension:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.540.1">SQL</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">
CREATE EXTENSION pg_prometheus;</span></pre> <p><span class="koboSpan" id="kobo.542.1">Here’s an example of how to configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.544.1"> extension to expose the </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">PostgreSQL metrics:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.546.1">
pg_prometheus.listen_addresses = 'localhost'
pg_prometheus.port = 9187</span></pre> <h4><span class="koboSpan" id="kobo.547.1">Step 3 – collecting PostgreSQL metrics</span></h4>
<p><span class="koboSpan" id="kobo.548.1">We will </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.549.1">use Prometheus to collect PostgreSQL metrics from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.550.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.551.1"> extension. </span><span class="koboSpan" id="kobo.551.2">Follow these steps to collect </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">PostgreSQL metrics:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.553.1">Install Prometheus </span><span class="No-Break"><span class="koboSpan" id="kobo.554.1">on GCP.</span></span></li>
<li><span class="koboSpan" id="kobo.555.1">Configure Prometheus to scrape metrics from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.557.1"> extension using an </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">HTTP endpoint.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.559.1">Here’s an example of how to configure Prometheus to scrape metrics from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">pg_prometheus</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1"> extension:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.562.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.563.1">
scrape_configs:
  - job_name: 'postgresql'
    scrape_interval: 10s
    static_configs:
      - targets: ['localhost:9187']</span></pre> <h4><span class="koboSpan" id="kobo.564.1">Step 4 – setting up Prometheus alerts</span></h4>
<p><span class="koboSpan" id="kobo.565.1">We will </span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.566.1">use Prometheus to set up alerts based on the collected PostgreSQL metrics. </span><span class="koboSpan" id="kobo.566.2">Follow these steps to set up </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">Prometheus alerts:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.568.1">Define alert rules </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">in Prometheus.</span></span></li>
<li><span class="koboSpan" id="kobo.570.1">Reload the Prometheus configuration to apply the new </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">alert rules.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.572.1">Here’s an example of how to define an alert rule </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">in Prometheus:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.574.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.575.1">
groups:
  - name: 'PostgreSQL alerts'
    rules:
      - alert: High CPU usage
        expr: postgresql_cpu_usage &gt; sum(rate(postgresql_cpu_usage[5m])) by (instance) &gt; 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: High CPU usage on PostgreSQL {{ $labels.instance }}
          description: '{{ $labels.instance }} has high CPU usage ({{ $value }}).'</span></pre> <p><span class="koboSpan" id="kobo.576.1">In this example, we are defining an alert rule named </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">High CPU usage</span></strong><span class="koboSpan" id="kobo.578.1"> that triggers a warning </span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.579.1">when the sum of the rate of CPU usage for PostgreSQL instances is greater than 80% over a 5-minute window. </span><span class="koboSpan" id="kobo.579.2">The alert has a severity label of </span><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">warning</span></strong><span class="koboSpan" id="kobo.581.1"> and includes annotations for the alert summary </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">and description.</span></span></p>
<p><span class="koboSpan" id="kobo.583.1">To reload the Prometheus configuration, run the </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">following command:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.585.1">Bash</span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.586.1">curl -X POST http://localhost:9090/-/reload</span></strong></pre> <h4><span class="koboSpan" id="kobo.587.1">Step 5 – sending alerts to a notification channel</span></h4>
<p><span class="koboSpan" id="kobo.588.1">We will </span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.589.1">use Alertmanager to send alerts to a notification channel, such as email or Slack. </span><span class="koboSpan" id="kobo.589.2">Follow these steps to set </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">up Alertmanager:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.591.1">Install Alertmanager </span><span class="No-Break"><span class="koboSpan" id="kobo.592.1">on GCP.</span></span></li>
<li><span class="koboSpan" id="kobo.593.1">Configure Alertmanager to send alerts to a </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">notification channel.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.595.1">Here’s an example of how to configure Alertmanager to send alerts to an </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">email address:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.597.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.598.1">
route:
  group_by: ['alertname', 'severity']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 12h
  routes:
    - match:
        severity: warning
      receiver: email-alerts
receivers:
  - name: email-alerts
    email_configs:
      - to: 'youremail@example.com'
        from: 'alertmanager@example.com'
        smarthost: smtp.gmail.com:587
        auth_username: 'youremail@example.com'
        auth_password: 'yourpassword'
        starttls_require: true</span></pre> <p><span class="koboSpan" id="kobo.599.1">In this </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.600.1">example, we are configuring Alertmanager to send alerts with a severity label of </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">warning</span></strong><span class="koboSpan" id="kobo.602.1"> to an email address. </span><span class="koboSpan" id="kobo.602.2">We are specifying the email address to send the alerts to, as well as the email address and credentials to use </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">for authentication.</span></span></p>
<h4><span class="koboSpan" id="kobo.604.1">Conclusion</span></h4>
<p><span class="koboSpan" id="kobo.605.1">In conclusion, setting up PostgreSQL alarms using Prometheus in GCP requires deploying PostgreSQL on GCP, exporting PostgreSQL metrics using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">pg_prometheus</span></strong><span class="koboSpan" id="kobo.607.1"> extension, collecting PostgreSQL metrics using Prometheus, setting up Prometheus alerts based on the collected PostgreSQL metrics, and sending alerts to a notification channel using Alertmanager. </span><span class="koboSpan" id="kobo.607.2">With this architecture, you can monitor and alert on PostgreSQL metrics in real time, ensuring the availability and performance of your </span><span class="No-Break"><span class="koboSpan" id="kobo.608.1">PostgreSQL database.</span></span></p>
<h3><span class="koboSpan" id="kobo.609.1">Investigating Oracle Database issues using Jenkins</span></h3>
<p><span class="koboSpan" id="kobo.610.1">Investigating Oracle Database issues can be a challenging task for database administrators. </span><span class="koboSpan" id="kobo.610.2">It involves monitoring and analyzing the database’s performance, identifying </span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.611.1">bottlenecks, and taking corrective actions to optimize the system. </span><span class="koboSpan" id="kobo.611.2">One way to automate this process is by using Jenkins, an open source automation server that enables developers to automate tasks related to building, testing, and </span><span class="No-Break"><span class="koboSpan" id="kobo.612.1">deploying software.</span></span></p>
<p><span class="koboSpan" id="kobo.613.1">In this example, we will explore how to use Jenkins to investigate Oracle Database issues by setting up a Jenkins pipeline that performs the </span><span class="No-Break"><span class="koboSpan" id="kobo.614.1">following tasks:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.615.1">Connects to Oracle Database </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">using JDBC</span></span></li>
<li><span class="koboSpan" id="kobo.617.1">Executes a SQL query to retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">performance data</span></span></li>
<li><span class="koboSpan" id="kobo.619.1">Analyzes the data and generates </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">a report</span></span></li>
<li><span class="koboSpan" id="kobo.621.1">Sends an email notification to the database administrator if any issues </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">are found</span></span></li>
</ol>
<h3><span class="koboSpan" id="kobo.623.1">Architecture</span></h3>
<p><span class="koboSpan" id="kobo.624.1">The </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.625.1">architecture of the solution involves </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">several components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.627.1">Jenkins server</span></strong><span class="koboSpan" id="kobo.628.1">: This is where the Jenkins pipeline is executed. </span><span class="koboSpan" id="kobo.628.2">It runs on a separate machine from Oracle Database to avoid interfering with the </span><span class="No-Break"><span class="koboSpan" id="kobo.629.1">database’s performance.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.630.1">Oracle Database</span></strong><span class="koboSpan" id="kobo.631.1">: This is the database being monitored for </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">performance issues.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.633.1">JDBC driver</span></strong><span class="koboSpan" id="kobo.634.1">: This is the driver that’s used by the pipeline to connect to the </span><span class="No-Break"><span class="koboSpan" id="kobo.635.1">Oracle Database.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.636.1">SQL query</span></strong><span class="koboSpan" id="kobo.637.1">: This is the query that’s executed by the pipeline to retrieve performance data from </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">the database.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.639.1">Python script</span></strong><span class="koboSpan" id="kobo.640.1">: This is a script that analyzes the data retrieved by the SQL query and generates </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">a report.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.642.1">Email server</span></strong><span class="koboSpan" id="kobo.643.1">: This is the server that’s used by the pipeline to send email notifications to the </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">database administrator.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.645.1">The pipeline </span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.646.1">is triggered either manually or automatically by a scheduler. </span><span class="koboSpan" id="kobo.646.2">When it runs, it first connects to Oracle Database using the JDBC driver. </span><span class="koboSpan" id="kobo.646.3">Then, it executes the SQL query to retrieve performance data. </span><span class="koboSpan" id="kobo.646.4">The data is then analyzed by the Python script, which generates a report. </span><span class="koboSpan" id="kobo.646.5">If any issues are found, the pipeline sends an email notification to the </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">database administrator.</span></span></p>
<h4><span class="koboSpan" id="kobo.648.1">Jenkins pipeline code</span></h4>
<p><span class="koboSpan" id="kobo.649.1">The Jenkins </span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.650.1">pipeline code is written in Groovy, a scripting language that runs on Java Virtual Machine. </span><span class="koboSpan" id="kobo.650.2">Here is an example of what the code might </span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">look like:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.652.1">Groovy</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.653.1">
pipeline {
  agent any
  stages {
    stage('Connect to Oracle Database') {
      steps {
        script {
          def jdbcUrl = 'jdbc:oracle:thin:@localhost:1521:orcl'
          def dbUser = 'system'
          def dbPassword = 'oracle'
          
          def driver = Class.forName('oracle.jdbc.driver.OracleDriver').newInstance()
          DriverManager.registerDriver(driver)
          
          def conn = DriverManager.getConnection(jdbcUrl, dbUser, dbPassword)
          // Save connection for later stages
          env.DB_CONN = conn
        }
      }
    }
    
    stage('Retrieve Performance Data') {
      steps {
        script {
          def sqlQuery = 'SELECT * FROM performance_data'
          
          def stmt = env.DB_CONN.createStatement()
          def rs = stmt.executeQuery(sqlQuery)
          // Save result set for later stages
          env.PERF_DATA = rs
        }
      }
    }
    
    stage('Generate Performance Report') {
      steps {
        script {
          def perfData = env.PERF_DATA
          def report = generateReport(perfData)
          // Save report for later stages
          env.REPORT = report
        }
      }
    }
    
    stage('Send Email Notification') {
      steps {
        script {
          def report = env.REPORT
          if (report.hasIssues()) {
            sendEmailNotification(report)
          }
        }
      }
    }
  }
  
  post {
    always {
      script {
        // Close the database connection
        env.DB_CONN.close()
      }
    }
  }
}</span></pre> <p><span class="koboSpan" id="kobo.654.1">This pipeline consists of four stages, each of which has one or more steps. </span><span class="koboSpan" id="kobo.654.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">agent any</span></strong><span class="koboSpan" id="kobo.656.1"> directive specifies that the pipeline can run on any available </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">agent (machine).</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">The first stage, </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">Connect to Oracle Database</span></strong><span class="koboSpan" id="kobo.660.1">, sets up the JDBC connection to Oracle Database. </span><span class="koboSpan" id="kobo.660.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">jdbcUrl</span></strong><span class="koboSpan" id="kobo.662.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">dbUser</span></strong><span class="koboSpan" id="kobo.664.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">dbPassword</span></strong><span class="koboSpan" id="kobo.666.1"> variables are used to specify the connection details. </span><span class="koboSpan" id="kobo.666.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.667.1">DriverManager</span></strong><span class="koboSpan" id="kobo.668.1"> class is used to register the JDBC driver and </span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.669.1">obtain a connection to the database. </span><span class="koboSpan" id="kobo.669.2">The resulting connection object is saved as an environment variable for later stages </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.671.1">The second stage, </span><strong class="source-inline"><span class="koboSpan" id="kobo.672.1">Retrieve Performance Data</span></strong><span class="koboSpan" id="kobo.673.1">, executes a SQL query to retrieve performance data from the database. </span><span class="koboSpan" id="kobo.673.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">sqlQuery</span></strong><span class="koboSpan" id="kobo.675.1"> variable specifies the query to be executed. </span><span class="koboSpan" id="kobo.675.2">The resulting result set is saved as an environment variable for later stages </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">The third stage, </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">Generate Performance Report</span></strong><span class="koboSpan" id="kobo.679.1">, uses a Python script to analyze the performance data and generate a report. </span><span class="koboSpan" id="kobo.679.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">perfData</span></strong><span class="koboSpan" id="kobo.681.1"> variable is used to pass the result set to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">generateReport</span></strong><span class="koboSpan" id="kobo.683.1"> function. </span><span class="koboSpan" id="kobo.683.2">The resulting report is saved as an environment variable for later stages </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">The final stage, </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">Send Email Notification</span></strong><span class="koboSpan" id="kobo.687.1">, checks if the report has any issues and sends an email notification to the database administrator if it does. </span><span class="koboSpan" id="kobo.687.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">hasIssues</span></strong><span class="koboSpan" id="kobo.689.1"> function is used to determine if the report has any issues. </span><span class="koboSpan" id="kobo.689.2">If it does, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">sendEmailNotification</span></strong><span class="koboSpan" id="kobo.691.1"> function is called to send an </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">email notification.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">post</span></strong><span class="koboSpan" id="kobo.695.1"> section contains a cleanup step that always runs, regardless of the outcome of the pipeline. </span><span class="koboSpan" id="kobo.695.2">In this case, it closes the database connection that was opened in the </span><span class="No-Break"><span class="koboSpan" id="kobo.696.1">first stage.</span></span></p>
<h4><span class="koboSpan" id="kobo.697.1">Python script</span></h4>
<p><span class="koboSpan" id="kobo.698.1">The Python script </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.699.1">that’s used to analyze the performance data and generate a report might look </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">like this:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.701.1">Python</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.702.1">
import pandas as pd
def generateReport(perfData):
  df = pd.DataFrame(perfData, columns=['timestamp', 'cpu_usage', 'memory_usage', 'disk_usage'])
  df['timestamp'] = pd.to_datetime(df['timestamp'])
  df.set_index('timestamp', inplace=True)
  
  report = {}
  
  # Check CPU usage
  cpuMax = df['cpu_usage'].max()
  if cpuMax &gt; 90:
    report['cpu'] = f"CPU usage is {cpuMax}%, which is higher than the recommended maximum of 90%."
</span><span class="koboSpan" id="kobo.702.2">  
  # Check memory usage
  memMax = df['memory_usage'].max()
  if memMax &gt; 80:
    report['memory'] = f"Memory usage is {memMax}%, which is higher than the recommended maximum of 80%."
</span><span class="koboSpan" id="kobo.702.3">  
  # Check disk usage
  diskMax = df['disk_usage'].max()
  if diskMax &gt; 70:
    report['disk'] = f"Disk usage is {diskMax}%, which is higher than the recommended maximum of 70%."
</span><span class="koboSpan" id="kobo.702.4">  
  return report</span></pre> <p><span class="koboSpan" id="kobo.703.1">This script uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">pandas</span></strong><span class="koboSpan" id="kobo.705.1"> library to load the performance data into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">DataFrame</span></strong><span class="koboSpan" id="kobo.707.1"> object. </span><span class="koboSpan" id="kobo.707.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">timestamp</span></strong><span class="koboSpan" id="kobo.709.1"> column is converted into a datetime object and used as the index. </span><span class="koboSpan" id="kobo.709.2">The script </span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.710.1">then analyzes the data and generates a report if any issues are found. </span><span class="koboSpan" id="kobo.710.2">In this example, the script checks for high CPU, memory, and </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">disk usage.</span></span></p>
<h4><span class="koboSpan" id="kobo.712.1">Email notification</span></h4>
<p><span class="koboSpan" id="kobo.713.1">The email notification </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.714.1">is sent using the Jenkins Email Extension plugin, which allows emails to be sent with customizable content and attachments. </span><span class="koboSpan" id="kobo.714.2">Here is an example of what the email notification might </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">look like:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.716.1">Groovy</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.717.1">
def sendEmailNotification(report) {
  emailext body: reportToString(report),
    recipientProviders: [
      [$class: 'DevelopersRecipientProvider']
    ],
    subject: 'Oracle Database Performance Issues',
    attachmentsPattern: '**/*.csv'
}
def reportToString(report) {
  if (report.empty) {
    return "No performance issues found."
</span><span class="koboSpan" id="kobo.717.2">  } else {
    StringBuilder sb = new StringBuilder()
    for (entry in report.entrySet()) {
      sb.append(entry.getValue()).sb.append("\n\n")
    }
    return sb.toString()
  }
}</span></pre> <p><span class="koboSpan" id="kobo.718.1">This code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">emailext</span></strong><span class="koboSpan" id="kobo.720.1"> function to send an email notification to the developer’s recipient provider, which is defined in the Jenkins configuration. </span><span class="koboSpan" id="kobo.720.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">subject</span></strong><span class="koboSpan" id="kobo.722.1"> parameter specifies the subject of the email, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">attachmentsPattern</span></strong><span class="koboSpan" id="kobo.724.1"> parameter specifies a file pattern that matches the CSV report file generated by the </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">Python script.</span></span></p>
<p><span class="koboSpan" id="kobo.726.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.727.1">reportToString</span></strong><span class="koboSpan" id="kobo.728.1"> function is used to convert the report generated by the Python script into a string that can be used as the body of the email. </span><span class="koboSpan" id="kobo.728.2">If no issues are found, it returns a message indicating that no performance issues were found. </span><span class="koboSpan" id="kobo.728.3">If issues are found, it formats the report as a list of </span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">bullet points.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">In this example, we have seen how Jenkins can be used to automate the process of investigating Oracle Database issues. </span><span class="koboSpan" id="kobo.730.2">The pipeline connects to the database using JDBC, retrieves performance data using a SQL query, analyzes the data using a Python script, and sends email </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.731.1">notifications to the database administrator if any issues are found. </span><span class="koboSpan" id="kobo.731.2">The architecture consists of several components, including the Jenkins server, the Oracle Database, the JDBC driver, the SQL query, the Python script, and the email server. </span><span class="koboSpan" id="kobo.731.3">The pipeline code is written in Groovy, and the email notification is sent using the Jenkins Email Extension plugin. </span><span class="koboSpan" id="kobo.731.4">By automating this process, database administrators can save time and improve the performance of their </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">Oracle databases.</span></span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.733.1">Backup and disaster recovery</span></h2>
<p><span class="koboSpan" id="kobo.734.1">Ensuring that </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.735.1">relational databases are backed up and can be recovered in the event of a disaster is another critical activity for a DevOps team. </span><span class="koboSpan" id="kobo.735.2">This includes setting up backup and recovery processes, testing backups, and performing disaster recovery exercises. </span><span class="koboSpan" id="kobo.735.3">Let’s look at examples of how this can </span><span class="No-Break"><span class="koboSpan" id="kobo.736.1">be accomplished.</span></span></p>
<h3><span class="koboSpan" id="kobo.737.1">Creating MySQL backups using Ansible</span></h3>
<p><span class="koboSpan" id="kobo.738.1">Before we dive into the technical details and code, let’s discuss the architecture that we’ll be </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.739.1">using in this example. </span><span class="koboSpan" id="kobo.739.2">The basic architecture consists of three components: the MySQL database, the backup server, and the </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">Ansible controller.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">The MySQL database is the data source that we want to back up. </span><span class="koboSpan" id="kobo.741.2">We assume that it’s already installed and configured properly on its </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">own server.</span></span></p>
<p><span class="koboSpan" id="kobo.743.1">The backup server is where we’ll store the backup files. </span><span class="koboSpan" id="kobo.743.2">It should have enough disk space to accommodate </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">the backups.</span></span></p>
<p><span class="koboSpan" id="kobo.745.1">The Ansible controller is the machine from which we’ll execute Ansible playbooks. </span><span class="koboSpan" id="kobo.745.2">This machine should have Ansible installed and configured to connect to the MySQL database server and the </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">backup server.</span></span></p>
<p><span class="koboSpan" id="kobo.747.1">With this architecture in place, we can proceed to create a playbook that performs </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">MySQL backups.</span></span></p>
<p><span class="koboSpan" id="kobo.749.1">Here is an example playbook that you </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">can use:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.751.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.752.1">
---
- name: Create MySQL backups
  hosts: mysql_servers
  become: yes
  vars:
    backup_dir: "/var/backups/mysql"
    mysql_user: "backupuser"
    mysql_password: "backuppassword"
    mysql_databases:
      - "db1"
      - "db2"
  tasks:
    - name: Create backup directory
      file:
        path: "{{ backup_dir }}"
        state: directory
        owner: root
        group: root
        mode: 0700
    - name: Create MySQL backup
      mysql_db_backup:
        login_user: "{{ mysql_user }}"
        login_password: "{{ mysql_password }}"
        db: "{{ item }}"
        backup_dir: "{{ backup_dir }}"
        backup_type: "database"
      with_items: "{{ mysql_databases }}"
    - name: Compress backup files
      command: "tar -czvf {{ item }}.tar.gz {{ item }}/"
      args:
        chdir: "{{ backup_dir }}"
      with_items: "{{ mysql_databases }}"</span></pre> <p><span class="koboSpan" id="kobo.753.1">Let’s go through this playbook step </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">by step:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.755.1">The first section defines some basic information about the playbook. </span></li>
<li><span class="koboSpan" id="kobo.756.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">hosts</span></strong><span class="koboSpan" id="kobo.758.1"> variable specifies the hosts that we want to run the playbook on. </span><span class="koboSpan" id="kobo.758.2">In this case, we assume that we have a group called </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">mysql_servers</span></strong><span class="koboSpan" id="kobo.760.1"> that contains the MySQL </span><span class="No-Break"><span class="koboSpan" id="kobo.761.1">database server(s).</span></span></li>
<li><span class="koboSpan" id="kobo.762.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.763.1">become</span></strong><span class="koboSpan" id="kobo.764.1"> variable tells Ansible to run the playbook as the </span><span class="No-Break"><span class="koboSpan" id="kobo.765.1">root user.</span></span></li>
<li><span class="koboSpan" id="kobo.766.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">vars</span></strong><span class="koboSpan" id="kobo.768.1"> section defines some variables that we’ll use later in the playbook. </span></li>
<li><span class="koboSpan" id="kobo.769.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.770.1">backup_dir</span></strong><span class="koboSpan" id="kobo.771.1"> variable specifies the directory where we want to store the backups. </span></li>
<li><span class="koboSpan" id="kobo.772.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">mysql_user</span></strong><span class="koboSpan" id="kobo.774.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">mysql_password</span></strong><span class="koboSpan" id="kobo.776.1"> variables specify the username and password that Ansible will use to connect to the MySQL database. </span></li>
<li><span class="koboSpan" id="kobo.777.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.778.1">mysql_databases</span></strong><span class="koboSpan" id="kobo.779.1"> variable lists the databases that we want to </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">back up.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.781.1">The first task creates the backup directory if it doesn’t already exist. </span><span class="koboSpan" id="kobo.781.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">file</span></strong><span class="koboSpan" id="kobo.783.1"> module </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.784.1">to create the directory with the </span><span class="No-Break"><span class="koboSpan" id="kobo.785.1">appropriate permissions.</span></span></p>
<p><span class="koboSpan" id="kobo.786.1">The second task performs the actual backup. </span><span class="koboSpan" id="kobo.786.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">mysql_db_backup</span></strong><span class="koboSpan" id="kobo.788.1"> module to connect to the MySQL database and create a backup of each database in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">mysql_databases</span></strong><span class="koboSpan" id="kobo.790.1"> variable. </span><span class="koboSpan" id="kobo.790.2">We specify the backup directory using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.791.1">backup_dir</span></strong><span class="koboSpan" id="kobo.792.1"> variable, and we set the backup type </span><span class="No-Break"><span class="koboSpan" id="kobo.793.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.794.1">database</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.796.1">The third task compresses the backup files using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">tar</span></strong><span class="koboSpan" id="kobo.798.1"> command. </span><span class="koboSpan" id="kobo.798.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">command</span></strong><span class="koboSpan" id="kobo.800.1"> module to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">tar</span></strong><span class="koboSpan" id="kobo.802.1"> command with the appropriate arguments. </span><span class="koboSpan" id="kobo.802.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.803.1">chdir</span></strong><span class="koboSpan" id="kobo.804.1"> argument tells </span><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">tar</span></strong><span class="koboSpan" id="kobo.806.1"> to change to the backup directory before compressing the files. </span><span class="koboSpan" id="kobo.806.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.807.1">with_items</span></strong><span class="koboSpan" id="kobo.808.1"> variable to loop over each database in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">mysql_databases</span></strong><span class="koboSpan" id="kobo.810.1"> variable and compress the corresponding </span><span class="No-Break"><span class="koboSpan" id="kobo.811.1">backup file.</span></span></p>
<p><span class="koboSpan" id="kobo.812.1">Now that we have a playbook, we need to create an inventory file that tells Ansible about our servers. </span><span class="koboSpan" id="kobo.812.2">Here is an example </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">inventory file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.814.1">Inventory</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.815.1">
[mysql_servers]
mysql.example.com
[backup_servers]
backup.example.com</span></pre> <p><span class="koboSpan" id="kobo.816.1">In this example, we have one MySQL database server called </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">mysql.example.com</span></strong><span class="koboSpan" id="kobo.818.1"> and </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.819.1">one backup server called </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">backup.example.com</span></strong><span class="koboSpan" id="kobo.821.1">. </span><span class="koboSpan" id="kobo.821.2">You can modify this file to match your own server names and </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">IP addresses.</span></span></p>
<p><span class="koboSpan" id="kobo.823.1">Next, we need to create a configuration file for Ansible. </span><span class="koboSpan" id="kobo.823.2">Here is an example </span><span class="No-Break"><span class="koboSpan" id="kobo.824.1">configuration file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.825.1">Configuration file</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.826.1">
[defaults]
inventory = /path/to/inventory/file
remote_user = root</span></pre> <p><span class="koboSpan" id="kobo.827.1">This file specifies the location of our inventory file and sets the remote user </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.829.1">root</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.830.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.831.1">Now that we have our playbook, inventory file, and configuration file, we can run the playbook using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">ansible-playbook</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.833.1"> command:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.834.1">ansible-playbook backup_mysql.yml</span></strong></pre> <p><span class="koboSpan" id="kobo.835.1">This command tells Ansible to run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">backup_mysql.yml</span></strong><span class="koboSpan" id="kobo.837.1"> playbook. </span><span class="koboSpan" id="kobo.837.2">Ansible will connect to the MySQL database server and back up the databases specified in the playbook. </span><span class="koboSpan" id="kobo.837.3">The backups will be stored on the backup server in the directory specified in </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">the playbook.</span></span></p>
<p><span class="koboSpan" id="kobo.839.1">Overall, this example architecture and playbook should be sufficient for creating MySQL backups using Ansible. </span><span class="koboSpan" id="kobo.839.2">Of course, you can modify the playbook to match your own needs and specifications. </span><span class="koboSpan" id="kobo.839.3">For example, you might want to modify the backup retention policy, add email notifications, or include additional databases in the backup. </span><span class="koboSpan" id="kobo.839.4">With Ansible’s flexibility and powerful modules, the possibilities </span><span class="No-Break"><span class="koboSpan" id="kobo.840.1">are endless!</span></span></p>
<h3><span class="koboSpan" id="kobo.841.1">Testing PostgreSQL backups using Chef</span></h3>
<p><span class="koboSpan" id="kobo.842.1">Testing backups is an essential part of any database administration task. </span><span class="koboSpan" id="kobo.842.2">One way to automate </span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.843.1">this process is by using Chef, a popular configuration management tool, to create recipes that test the integrity of PostgreSQL backups. </span><span class="koboSpan" id="kobo.843.2">In this example, we will walk through a deep technical example of how to test PostgreSQL backups </span><span class="No-Break"><span class="koboSpan" id="kobo.844.1">using Chef.</span></span></p>
<p><span class="koboSpan" id="kobo.845.1">First, let’s consider the architecture used in this example. </span><span class="koboSpan" id="kobo.845.2">We will use Chef to automate the testing of PostgreSQL backups stored in AWS S3 buckets. </span><span class="koboSpan" id="kobo.845.3">Our Chef recipe will run a series of checks to ensure that the backups are valid and can be used to restore the database in the event of </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">a disaster.</span></span></p>
<p><span class="koboSpan" id="kobo.847.1">The following diagram illustrates the high-level architecture used in </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">this example:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.849.1">Lua</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.850.1">
    +--------------------------+
    |  PostgreSQL Production   |
    +--------------------------+
                 |
        +-----------------+
        |  pg_dump Backup  |
        +-----------------+
                 |
        +-----------------+
        |   S3 Bucket     |
        +-----------------+
                 |
        +-----------------+
        |   Chef Server   |
        +-----------------+
                 |
        +-----------------+
        |   Chef Client   |
        +-----------------+
                 |
        +-----------------+
        |     Results     |
        +-----------------+</span></pre> <p><span class="koboSpan" id="kobo.851.1">In this architecture, we have a PostgreSQL production database that is backed up using </span><strong class="source-inline"><span class="koboSpan" id="kobo.852.1">pg_dump</span></strong><span class="koboSpan" id="kobo.853.1">. </span><span class="koboSpan" id="kobo.853.2">The backups are stored in an S3 bucket, which is accessible by a Chef server. </span><span class="koboSpan" id="kobo.853.3">A Chef client is configured to run the backup testing recipe, which checks the integrity of the backups and reports the results to the Chef server. </span><span class="koboSpan" id="kobo.853.4">The results are then available for analysis </span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">and action.</span></span></p>
<p><span class="koboSpan" id="kobo.855.1">Now, let’s take a closer look at the Chef recipe that we will use to test our </span><span class="No-Break"><span class="koboSpan" id="kobo.856.1">PostgreSQL backups.</span></span></p>
<p><span class="koboSpan" id="kobo.857.1">We </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.858.1">will start by creating a new Chef cookbook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">postgresql-backup-testing</span></strong><span class="koboSpan" id="kobo.860.1">. </span><span class="koboSpan" id="kobo.860.2">Inside this cookbook, we will create a recipe called </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">default.rb</span></strong><span class="koboSpan" id="kobo.862.1">. </span><span class="koboSpan" id="kobo.862.2">This recipe will perform the </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">following steps:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.864.1">Install the</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.865.1">aws-sdk-s3</span></strong> <strong class="bold"><span class="koboSpan" id="kobo.866.1">gem</span></strong><span class="koboSpan" id="kobo.867.1">: We will use this gem to interact with the S3 bucket that contains </span><span class="No-Break"><span class="koboSpan" id="kobo.868.1">our backups.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.869.1">Download the latest backup from the S3 bucket</span></strong><span class="koboSpan" id="kobo.870.1">: We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">aws-sdk-s3</span></strong><span class="koboSpan" id="kobo.872.1"> gem to download the latest backup file from the </span><span class="No-Break"><span class="koboSpan" id="kobo.873.1">S3 bucket.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.874.1">Verify the integrity of the backup</span></strong><span class="koboSpan" id="kobo.875.1">: We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">pg_restore</span></strong><span class="koboSpan" id="kobo.877.1"> command to verify the integrity of the backup file. </span><span class="koboSpan" id="kobo.877.2">This command will check that the backup file is valid and can be used to restore </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">the database.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.879.1">Report the results to the Chef server</span></strong><span class="koboSpan" id="kobo.880.1">: We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">chef_handler</span></strong><span class="koboSpan" id="kobo.882.1"> gem to report the results of the backup testing to the </span><span class="No-Break"><span class="koboSpan" id="kobo.883.1">Chef server.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.884.1">Here’s </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.885.1">the code for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.886.1">default.rb</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.887.1"> recipe:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.888.1">Ruby</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.889.1">
# Install the aws-sdk-s3 gem
chef_gem 'aws-sdk-s3' do
  compile_time true
end
# Download the latest backup from the S3 bucket
s3 = Aws::S3::Client.new(region: 'us-west-2')
bucket_name = 'my-backup-bucket'
backup_prefix = 'postgresql-backups/'
latest_backup = s3.list_objects_v2(bucket: bucket_name, prefix: backup_prefix).contents.sort_by(&amp;:last_modified).last.key
local_backup_path = "/tmp/#{File.basename(latest_backup)}"
FileUtils.mkdir_p(File.dirname(local_backup_path))
File.open(local_backup_path, 'wb') do |file|
  s3.get_object(bucket: bucket_name, key: latest_backup) do |chunk|
    file.write(chunk)
  end
end</span></pre> <p><span class="koboSpan" id="kobo.890.1">Next, we will verify the integrity of the backup using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">pg_restore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.892.1"> command:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.893.1">Ruby</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.894.1">
# Verify the integrity of the backup
cmd = "pg_restore --list #{local_backup_path} &gt; /dev/null"
system(cmd)
if $?.exitstatus != 0
  Chef::Log.error("Backup file #{local_backup_path} is invalid!")
  raise "Backup file #{local_backup_path} is invalid!"
</span><span class="koboSpan" id="kobo.894.2">else
  Chef::Log.info("Backup file #{local_backup_path} is valid.")
end</span></pre> <p><span class="koboSpan" id="kobo.895.1">In this code, we run the </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">pg_restore --list</span></strong><span class="koboSpan" id="kobo.897.1"> command on the backup file to check that </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.898.1">it is valid. </span><span class="koboSpan" id="kobo.898.2">If the command returns a non-zero exit status, we log an error and raise an exception. </span><span class="koboSpan" id="kobo.898.3">Otherwise, we log a </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">success message.</span></span></p>
<p><span class="koboSpan" id="kobo.900.1">Finally, we will report the results of the backup testing to the Chef server using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">chef_handler</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.902.1"> gem:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.903.1">Ruby</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.904.1">
# Report the results to the Chef server
chef_gem 'chef-handler-sns' do
  compile_time true
end
require 'chef/handler/sns'
Chef::Config[:s3_backup_test_topic_arn] = 'arn:aws:sns:us-west-2:123456789012:s3-backup-test-results'
Chef::Config[:s3_backup_test_subject] = "PostgreSQL backup test results for #{node['hostname']}"
Chef::Config[:s3_backup_test_body] = "Backup file #{local_backup_path} is valid."
</span><span class="koboSpan" id="kobo.904.2">Chef::Config[:s3_backup_test_aws_access_key_id] = 'my-access-key'
Chef::Config[:s3_backup_test_aws_secret_access_key] = 'my-secret-key'
Chef::Config[:s3_backup_test_aws_region] = 'us-west-2'
chef_handler 'Chef::Handler::SNS' do
  source 'chef/handler/sns'
  arguments [Chef::Config[:s3_backup_test_topic_arn], {
    subject: Chef::Config[:s3_backup_test_subject],
    message: Chef::Config[:s3_backup_test_body],
    access_key_id: Chef::Config[:s3_backup_test_aws_access_key_id],
    secret_access_key: Chef::Config[:s3_backup_test_aws_secret_access_key],
    region: Chef::Config[:s3_backup_test_aws_region],
  }]
  action :enable
end</span></pre> <p><span class="koboSpan" id="kobo.905.1">In this </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.906.1">code, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">chef-handler-sns</span></strong><span class="koboSpan" id="kobo.908.1"> gem to create an SNS topic and publish the results of the backup testing to that topic. </span><span class="koboSpan" id="kobo.908.2">We set various configuration variables, such as the topic ARN and the access keys, and then enable the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">Chef::Handler::SNS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.910.1"> handler.</span></span></p>
<p><span class="koboSpan" id="kobo.911.1">With this recipe in place, we can now run it on our Chef client to test the integrity of our PostgreSQL backups. </span><span class="koboSpan" id="kobo.911.2">The results will be reported to the Chef server, where we can analyze them and take appropriate action </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">if necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">In summary, using Chef to test PostgreSQL backups stored in AWS S3 buckets is a powerful </span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.914.1">way to automate an essential task in database administration. </span><span class="koboSpan" id="kobo.914.2">By creating a Chef recipe that checks the integrity of the backups and reports the results to the Chef server, we can ensure that our backups are always valid and ready to use in the event of </span><span class="No-Break"><span class="koboSpan" id="kobo.915.1">a disaster.</span></span></p>
<h3><span class="koboSpan" id="kobo.916.1">Performing Oracle disaster recovery exercises using Puppet</span></h3>
<p><span class="koboSpan" id="kobo.917.1">Oracle databases are critical to the operation of many organizations. </span><span class="koboSpan" id="kobo.917.2">When a disaster occurs, restoring a database to a previous state is often necessary to minimize downtime </span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.918.1">and prevent data loss. </span><span class="koboSpan" id="kobo.918.2">Disaster recovery exercises are important </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.919.1">to ensure </span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.920.1">that databases can be restored quickly and accurately in the event of </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">a disaster.</span></span></p>
<p><span class="koboSpan" id="kobo.922.1">Puppet is </span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.923.1">an open source configuration management tool that can be used to automate disaster recovery exercises for Oracle databases. </span><span class="koboSpan" id="kobo.923.2">In this example, we will demonstrate how to use Puppet to automate the disaster recovery exercise process for an </span><span class="No-Break"><span class="koboSpan" id="kobo.924.1">Oracle database.</span></span></p>
<h4><span class="koboSpan" id="kobo.925.1">Architecture</span></h4>
<p><span class="koboSpan" id="kobo.926.1">The architecture </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.927.1">used in this example consists of three components: the production database server, the disaster recovery database server, and the Puppet </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">master server.</span></span></p>
<p><span class="koboSpan" id="kobo.929.1">The production database server is where the Oracle database is hosted and is responsible for serving production workloads. </span><span class="koboSpan" id="kobo.929.2">The disaster recovery database server is a standby database that is used to restore the production database in the event of a disaster. </span><span class="koboSpan" id="kobo.929.3">The Puppet master server is responsible for managing the Puppet agents running on both the production and disaster </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">recovery servers.</span></span></p>
<p><span class="koboSpan" id="kobo.931.1">To automate the disaster recovery exercise process, we will use Puppet to do </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.933.1">Stop the production </span><span class="No-Break"><span class="koboSpan" id="kobo.934.1">database server.</span></span></li>
<li><span class="koboSpan" id="kobo.935.1">Create a backup of the </span><span class="No-Break"><span class="koboSpan" id="kobo.936.1">production database.</span></span></li>
<li><span class="koboSpan" id="kobo.937.1">Copy the backup to the disaster recovery </span><span class="No-Break"><span class="koboSpan" id="kobo.938.1">database server.</span></span></li>
<li><span class="koboSpan" id="kobo.939.1">Restore </span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.940.1">the backup on the disaster recovery </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">database server.</span></span></li>
<li><span class="koboSpan" id="kobo.942.1">Test the disaster </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">recovery process.</span></span></li>
<li><span class="koboSpan" id="kobo.944.1">Start the production database </span><span class="No-Break"><span class="koboSpan" id="kobo.945.1">server again.</span></span></li>
</ol>
<h4><span class="koboSpan" id="kobo.946.1">Puppet modules</span></h4>
<p><span class="koboSpan" id="kobo.947.1">To perform </span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.948.1">these tasks, we will create two Puppet modules: one for the production server and one for the disaster </span><span class="No-Break"><span class="koboSpan" id="kobo.949.1">recovery server.</span></span></p>
<p><span class="koboSpan" id="kobo.950.1">The production server module will contain the following </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">Puppet manifests:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.952.1">A manifest to stop the production </span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">database server</span></span></li>
<li><span class="koboSpan" id="kobo.954.1">A manifest to create a backup of the </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">production database</span></span></li>
<li><span class="koboSpan" id="kobo.956.1">A manifest to copy the backup to the disaster recovery </span><span class="No-Break"><span class="koboSpan" id="kobo.957.1">database server</span></span></li>
<li><span class="koboSpan" id="kobo.958.1">A manifest to start the production database </span><span class="No-Break"><span class="koboSpan" id="kobo.959.1">server again</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.960.1">The disaster recovery server module will contain the following </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">Puppet manifests:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.962.1">A manifest to stop the disaster recovery </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">database server</span></span></li>
<li><span class="koboSpan" id="kobo.964.1">A manifest to restore the backup on the disaster recovery </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">database server</span></span></li>
<li><span class="koboSpan" id="kobo.966.1">A manifest to start the disaster recovery database </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">server again</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.968.1">Here is an example of the Puppet manifest for stopping the production </span><span class="No-Break"><span class="koboSpan" id="kobo.969.1">database server:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.970.1">Puppet</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.971.1">
class oracle_production {
  service { 'oracle':
    ensure =&gt; stopped,
  }
}</span></pre> <p><span class="koboSpan" id="kobo.972.1">This manifest stops the Oracle service running on the </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">production server.</span></span></p>
<p><span class="koboSpan" id="kobo.974.1">Here is </span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.975.1">an example of the Puppet manifest for creating a backup of the </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">production database:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.977.1">Puppet</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.978.1">
class oracle_production {
  exec { 'backup':
    command =&gt; '/usr/local/bin/backup.sh',
  }
}</span></pre> <p><span class="koboSpan" id="kobo.979.1">This manifest executes a backup script that creates a backup of the </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">production database.</span></span></p>
<p><span class="koboSpan" id="kobo.981.1">Here is an example of the Puppet manifest for copying the backup to the disaster </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">recovery server:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.983.1">Puppet</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.984.1">
class oracle_production {
  file { '/mnt/backups':
    ensure =&gt; directory,
  }
  file { '/mnt/backups/backup.tar.gz':
    source =&gt; '/path/to/backup.tar.gz',
  }
  exec { 'copy_backup':
    command =&gt; '/usr/bin/scp /mnt/backups/backup.tar.gz user@disaster-recovery:/mnt/backups/',
  }
}</span></pre> <p><span class="koboSpan" id="kobo.985.1">This </span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.986.1">manifest creates a directory for backups, copies the backup to that directory, and then uses SCP to copy the backup to the disaster </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">recovery server.</span></span></p>
<p><span class="koboSpan" id="kobo.988.1">In this example, we have shown how to use Puppet to automate the disaster recovery exercise process for an Oracle database. </span><span class="koboSpan" id="kobo.988.2">By using Puppet to automate these tasks, we can ensure that the disaster recovery process is tested regularly and that the database can be restored quickly and accurately in the event of </span><span class="No-Break"><span class="koboSpan" id="kobo.989.1">a disaster.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.990.1">Performance optimization</span></h2>
<p><span class="koboSpan" id="kobo.991.1">Optimizing </span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.992.1">the performance of relational databases is another important activity for a DevOps team. </span><span class="koboSpan" id="kobo.992.2">This includes tuning database settings, optimizing queries, and identifying and resolving performance bottlenecks. </span><span class="koboSpan" id="kobo.992.3">Some examples of how this can be accomplished are covered in the </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">following sections.</span></span></p>
<h3><span class="koboSpan" id="kobo.994.1">Tuning MySQL settings using Terraform</span></h3>
<p><span class="koboSpan" id="kobo.995.1">In </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.996.1">this example, we </span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.997.1">will use Terraform to provision </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.998.1">a MySQL instance on AWS and configure some of its settings. </span><span class="koboSpan" id="kobo.998.2">We will use the AWS RDS service to provision a MySQL instance, and then use Terraform to configure some of the settings. </span><span class="koboSpan" id="kobo.998.3">Specifically, we will set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">innodb_buffer_pool_size</span></strong><span class="koboSpan" id="kobo.1000.1"> parameter to optimize the use of memory, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">max_connections</span></strong><span class="koboSpan" id="kobo.1002.1"> setting to control the maximum number of </span><span class="No-Break"><span class="koboSpan" id="kobo.1003.1">concurrent connections.</span></span></p>
<h4><span class="koboSpan" id="kobo.1004.1">Code example</span></h4>
<p><span class="koboSpan" id="kobo.1005.1">First, we will </span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.1006.1">define our AWS provider and RDS instance resources in the Terraform </span><span class="No-Break"><span class="koboSpan" id="kobo.1007.1">configuration file:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1008.1">SQL</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1009.1">
provider "aws" {
  region = "us-west-2"
}
resource "aws_db_instance" "mysql" {
  allocated_storage    = 100
  engine               = "mysql"
  engine_version       = "5.7"
  instance_class       = "db.t2.micro"
  name                 = "mydb"
  username             = "admin"
  password             = "password"
  parameter_group_name = "default.mysql5.7"
}</span></pre> <p><span class="koboSpan" id="kobo.1010.1">In this code, we are specifying the region for the AWS provider and then defining our RDS instance resource. </span><span class="koboSpan" id="kobo.1010.2">We are specifying the storage allocation, engine and version, instance class, and other configuration options. </span><span class="koboSpan" id="kobo.1010.3">We are also specifying a default parameter group that includes some </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">MySQL settings.</span></span></p>
<p><span class="koboSpan" id="kobo.1012.1">Next, we will define a custom parameter group that includes our desired </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">MySQL settings:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1014.1">SQL</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1015.1">
resource "aws_db_parameter_group" "mysql" {
  name_prefix = "mysql-"
  family      = "mysql5.7"
  parameter {
    name  = "innodb_buffer_pool_size"
    value = "5368709120" # 5 GB
  }
  parameter {
    name  = "max_connections"
    value = "100"
  }
}</span></pre> <p><span class="koboSpan" id="kobo.1016.1">In this code, we are </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.1017.1">defining a new parameter group that includes two settings: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">innodb_buffer_pool_size</span></strong><span class="koboSpan" id="kobo.1019.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1020.1">max_connections</span></strong><span class="koboSpan" id="kobo.1021.1">. </span><span class="koboSpan" id="kobo.1021.2">We are setting </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">innodb_buffer_pool_size</span></strong><span class="koboSpan" id="kobo.1023.1"> to 5 GB and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">max_connections</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1025.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1026.1">100</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1027.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1028.1">Finally, we will associate our RDS instance with the custom </span><span class="No-Break"><span class="koboSpan" id="kobo.1029.1">parameter group:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1030.1">RDS</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1031.1">
resource "aws_rds_cluster_instance" "mysql" {
  count              = 1
  identifier         = "mydb-${count.index + 1}"
  db_subnet_group_name = "${aws_db_subnet_group.mysql.name}"
  cluster_identifier   = "${aws_rds_cluster.mysql.id}"
  instance_class       = "db.t2.micro"
  engine               = "mysql"
  engine_version       = "5.7"
  db_parameter_group_name = "${aws_db_parameter_group.mysql.name}"
}</span></pre> <p><span class="koboSpan" id="kobo.1032.1">In this code, we are creating an RDS instance and associating it with the custom parameter group we created earlier. </span><span class="koboSpan" id="kobo.1032.2">We are also specifying the instance class, engine and version, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1">configuration options.</span></span></p>
<p><span class="koboSpan" id="kobo.1034.1">This example demonstrates how Terraform can be used to provision and configure a MySQL instance on AWS, including tuning some of its settings for optimal performance. </span><span class="koboSpan" id="kobo.1034.2">By using IaC, we can easily manage and update our MySQL settings as needed, and ensure that our instance is always </span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1">configured correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.1036.1">Let’s take </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.1037.1">a closer look at the specific settings we configured in </span><span class="No-Break"><span class="koboSpan" id="kobo.1038.1">this example:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1039.1">innodb_buffer_pool_size</span></strong><span class="koboSpan" id="kobo.1040.1">: This setting controls the size of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1041.1">InnoDB</span></strong><span class="koboSpan" id="kobo.1042.1"> buffer pool, which is where </span><strong class="source-inline"><span class="koboSpan" id="kobo.1043.1">InnoDB</span></strong><span class="koboSpan" id="kobo.1044.1"> stores data and indexes. </span><span class="koboSpan" id="kobo.1044.2">By increasing the buffer pool size, we can improve query performance by reducing the need for disk I/O. </span><span class="koboSpan" id="kobo.1044.3">The value we set here (5 GB) is just an example; the appropriate value will depend on the amount of available memory and the size of </span><span class="No-Break"><span class="koboSpan" id="kobo.1045.1">the database.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1046.1">max_connections</span></strong><span class="koboSpan" id="kobo.1047.1">: This setting controls the maximum number of concurrent connections to the MySQL instance. </span><span class="koboSpan" id="kobo.1047.2">By limiting the number of connections, we can avoid overloading the server and ensure that each connection has sufficient resources. </span><span class="koboSpan" id="kobo.1047.3">Again, the value we set here (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1048.1">100</span></strong><span class="koboSpan" id="kobo.1049.1">) is just an example; the appropriate value will depend on the usage patterns of </span><span class="No-Break"><span class="koboSpan" id="kobo.1050.1">the application.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1051.1">It’s worth noting that many other MySQL settings can be tuned for optimal performance, depending on the specific workload and hardware configuration. </span><span class="koboSpan" id="kobo.1051.2">In addition to using Terraform to configure these settings, there are many other tools and techniques available for monitoring and optimizing MySQL performance, including profiling, query optimization, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1052.1">hardware upgrades.</span></span></p>
<p><span class="koboSpan" id="kobo.1053.1">In summary, we have shown how Terraform can be used to provision and configure a MySQL instance on AWS, including tuning some of its settings for optimal performance. </span><span class="koboSpan" id="kobo.1053.2">While this example is relatively simple, it demonstrates the power of IaC and the flexibility of cloud-based services such as AWS RDS. </span><span class="koboSpan" id="kobo.1053.3">By using Terraform to manage our MySQL settings, we can ensure that our database is always configured correctly and optimized for our </span><span class="No-Break"><span class="koboSpan" id="kobo.1054.1">specific workload.</span></span></p>
<h3><span class="koboSpan" id="kobo.1055.1">Optimizing PostgreSQL queries using Ansible</span></h3>
<p><span class="koboSpan" id="kobo.1056.1">PostgreSQL is a powerful open source RDBMS that is widely used by developers and enterprises </span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.1057.1">for storing and managing large amounts of data. </span><span class="koboSpan" id="kobo.1057.2">One of the key challenges in working with PostgreSQL is optimizing the performance of SQL queries, which can be complex </span><span class="No-Break"><span class="koboSpan" id="kobo.1058.1">and time-consuming.</span></span></p>
<p><span class="koboSpan" id="kobo.1059.1">Ansible is </span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.1060.1">an open source automation </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.1061.1">tool that can be used to manage and automate various IT infrastructure tasks, including provisioning, configuration management, and application deployment. </span><span class="koboSpan" id="kobo.1061.2">In this example, we will explore how Ansible can be used to optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">PostgreSQL queries.</span></span></p>
<p><span class="koboSpan" id="kobo.1063.1">The architecture used in this example includes a PostgreSQL database server and an Ansible control machine. </span><span class="koboSpan" id="kobo.1063.2">The control machine is used to manage the configuration and deployment of the PostgreSQL server, as well as to run automated optimization tasks on </span><span class="No-Break"><span class="koboSpan" id="kobo.1064.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.1065.1">The PostgreSQL server is installed on a dedicated server or virtual machine, and the Ansible control machine is installed on a separate machine. </span><span class="koboSpan" id="kobo.1065.2">The control machine communicates with the PostgreSQL server using SSH, and the Ansible playbook is used to configure and optimize </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">the database.</span></span></p>
<h4><span class="koboSpan" id="kobo.1067.1">Example code</span></h4>
<p><span class="koboSpan" id="kobo.1068.1">The following </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.1069.1">example code demonstrates how Ansible can be used to optimize PostgreSQL queries using a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">of techniques:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1071.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1072.1">
---
- name: Optimize PostgreSQL Queries
  hosts: dbserver
  become: yes
  vars:
    database_name: mydatabase
    database_user: myuser
    database_password: mypassword
  tasks:
    - name: Install PostgreSQL client
      apt:
        name: postgresql-client
        state: present
    - name: Check query execution time
      shell: |
        psql -d {{ database_name }} -U {{ database_user }} -c "EXPLAIN ANALYZE SELECT * FROM mytable WHERE id = 1234;"
      register: query_output
    - name: Show query plan
      debug:
        var: query_output.stdout_lines
    - name: Create index on id column
      shell: |
        psql -d {{ database_name }} -U {{ database_user }} -c "CREATE INDEX ON mytable (id);"
    - name: Check query execution time with index
      shell: |
        psql -d {{ database_name }} -U {{ database_user }} -c "EXPLAIN ANALYZE SELECT * FROM mytable WHERE id = 1234;"
      register: query_output_index
    - name: Show optimized query plan
      debug:
        var: query_output_index.stdout_lines
    - name: Vacuum analyze the table
      shell: |
        psql -d {{ database_name }} -U {{ database_user }} -c "VACUUM ANALYZE mytable;"
    - name: Show table statistics
      shell: |
        psql -d {{ database_name }} -U {{ database_user }} -c "SELECT relname, n_live_tup, n_dead_tup, last_vacuum, last_autovacuum, last_analyze, last_autoanalyze FROM pg_stat_user_tables WHERE relname = 'mytable';"
      register: table_stats
    - name: Show table statistics output
      debug:
        var: table_stats.stdout_lines</span></pre> <p><span class="koboSpan" id="kobo.1073.1">In this example, the Ansible playbook includes several tasks that are used to optimize a PostgreSQL query. </span><span class="koboSpan" id="kobo.1073.2">The first task installs the PostgreSQL client on the Ansible control machine. </span><span class="koboSpan" id="kobo.1073.3">The second task executes the query and registers </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">the output.</span></span></p>
<p><span class="koboSpan" id="kobo.1075.1">The third task shows the query plan to help identify potential optimization opportunities. </span><span class="koboSpan" id="kobo.1075.2">The fourth task creates an index on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1076.1">id</span></strong><span class="koboSpan" id="kobo.1077.1"> column to improve query performance. </span><span class="koboSpan" id="kobo.1077.2">The fifth task checks the query execution time with the index and registers </span><span class="No-Break"><span class="koboSpan" id="kobo.1078.1">the output.</span></span></p>
<p><span class="koboSpan" id="kobo.1079.1">The sixth task vacuums and analyzes the table to reclaim space and update statistics. </span><span class="koboSpan" id="kobo.1079.2">The seventh task shows the table statistics, including the number of live and dead tuples, and the last vacuum and </span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">analyze timestamps.</span></span></p>
<p><span class="koboSpan" id="kobo.1081.1">Overall, this Ansible playbook demonstrates how various optimization techniques can be used to improve </span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.1082.1">the performance of PostgreSQL queries. </span><span class="koboSpan" id="kobo.1082.2">By creating an index on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">id</span></strong><span class="koboSpan" id="kobo.1084.1"> column, the query execution time is significantly reduced. </span><span class="koboSpan" id="kobo.1084.2">Additionally, vacuuming and analyzing the table helps to reclaim space and update statistics, which can further improve </span><span class="No-Break"><span class="koboSpan" id="kobo.1085.1">query performance.</span></span></p>
<p><span class="koboSpan" id="kobo.1086.1">Utilizing Ansible to optimize PostgreSQL queries can help automate the optimization process and save time and effort for developers and administrators. </span><span class="koboSpan" id="kobo.1086.2">By implementing various optimization techniques such as index creation, query planning, and table vacuuming, it is possible to improve the performance of SQL queries and ensure that PostgreSQL databases are running at </span><span class="No-Break"><span class="koboSpan" id="kobo.1087.1">optimal levels.</span></span></p>
<h3><span class="koboSpan" id="kobo.1088.1">Identifying Oracle performance issues using Datadog</span></h3>
<p><span class="koboSpan" id="kobo.1089.1">Oracle database is one of the most widely used relational database management systems </span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.1090.1">in the world, powering many mission-critical applications. </span><span class="koboSpan" id="kobo.1090.2">However, ensuring that an Oracle database is performing optimally can be a challenging task. </span><span class="koboSpan" id="kobo.1090.3">In this article, we will explore how Datadog, a popular monitoring and observability platform, can be used to identify performance issues in an </span><span class="No-Break"><span class="koboSpan" id="kobo.1091.1">Oracle database.</span></span></p>
<p><span class="koboSpan" id="kobo.1092.1">Before </span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.1093.1">we dive into the technical </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.1094.1">details, let’s briefly discuss the architecture used in this example. </span><span class="koboSpan" id="kobo.1094.2">Datadog is a cloud-based monitoring and observability platform that collects data from various sources, such as servers, databases, and applications, and provides real-time insights and alerts. </span><span class="koboSpan" id="kobo.1094.3">In this example, we will use Datadog’s Oracle integration to collect metrics from an Oracle database. </span><span class="koboSpan" id="kobo.1094.4">The Oracle </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.1095.1">integration uses Oracle’s </span><strong class="bold"><span class="koboSpan" id="kobo.1096.1">Dynamic Performance Views</span></strong><span class="koboSpan" id="kobo.1097.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1098.1">DPV</span></strong><span class="koboSpan" id="kobo.1099.1">) to collect a wide range of performance metrics, such as CPU usage, memory usage, and disk I/O. </span><span class="koboSpan" id="kobo.1099.2">These metrics are then sent to Datadog, where they can be visualized, analyzed, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">alerted on.</span></span></p>
<p><span class="koboSpan" id="kobo.1101.1">Now that we understand the architecture, let’s move on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">technical details.</span></span></p>
<h4><span class="koboSpan" id="kobo.1103.1">Identifying performance issues</span></h4>
<p><span class="koboSpan" id="kobo.1104.1">The first step in identifying performance issues is to understand what to look for. </span><span class="koboSpan" id="kobo.1104.2">Some common </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.1105.1">performance issues in Oracle databases include slow queries, high CPU usage, high memory usage, and slow I/O. </span><span class="koboSpan" id="kobo.1105.2">Let’s take a closer look at each of these issues and how they can be identified </span><span class="No-Break"><span class="koboSpan" id="kobo.1106.1">using Datadog.</span></span></p>
<h4><span class="koboSpan" id="kobo.1107.1">Slow queries</span></h4>
<p><span class="koboSpan" id="kobo.1108.1">Slow queries </span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.1109.1">are one of the most common performance issues in databases. </span><span class="koboSpan" id="kobo.1109.2">They can be caused by a variety of factors, such as suboptimal query plans, missing indexes, or inefficient SQL. </span><span class="koboSpan" id="kobo.1109.3">Datadog’s Oracle integration provides several metrics that can help identify slow queries, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">the following:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1111.1">oracle.sql.query.elapsed_time</span></strong><span class="koboSpan" id="kobo.1112.1">: The total elapsed time for executing SQL statements in </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">the database</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">oracle.sql.query.cpu_time</span></strong><span class="koboSpan" id="kobo.1115.1">: The CPU time used by SQL statements in </span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">the database</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1117.1">oracle.sql.query.buffer_gets</span></strong><span class="koboSpan" id="kobo.1118.1">: The number of buffers that are required by SQL statements in </span><span class="No-Break"><span class="koboSpan" id="kobo.1119.1">the database</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1120.1">By monitoring these metrics over time, it is possible to identify queries that are consistently slow or that have a sudden spike </span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">in performance.</span></span></p>
<h4><span class="koboSpan" id="kobo.1122.1">High CPU usage</span></h4>
<p><span class="koboSpan" id="kobo.1123.1">High CPU usage </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.1124.1">can be an indication of inefficient queries, too many active sessions, or insufficient hardware resources. </span><span class="koboSpan" id="kobo.1124.2">Datadog’s Oracle integration provides several metrics that can help identify high </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">CPU usage:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">oracle.cpu.usage</span></strong><span class="koboSpan" id="kobo.1127.1">: The percentage of CPU usage taken up by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1128.1">Oracle database</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">oracle.process.cpu.usage</span></strong><span class="koboSpan" id="kobo.1130.1">: The percentage of CPU usage taken up by </span><span class="No-Break"><span class="koboSpan" id="kobo.1131.1">Oracle processes</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1132.1">By monitoring </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.1133.1">these metrics over time, it is possible to identify periods of high CPU usage and correlate them with specific events </span><span class="No-Break"><span class="koboSpan" id="kobo.1134.1">or queries.</span></span></p>
<h4><span class="koboSpan" id="kobo.1135.1">High memory usage</span></h4>
<p><span class="koboSpan" id="kobo.1136.1">High memory </span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.1137.1">usage can be an indication of inefficient queries, too many open connections, or insufficient memory resources. </span><span class="koboSpan" id="kobo.1137.2">Datadog’s Oracle integration provides several metrics that can help identify high </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">memory usage:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1139.1">oracle.memory.sga.used</span></strong><span class="koboSpan" id="kobo.1140.1">: The amount of SGA memory used by </span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1">the database</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">oracle.memory.pga.used</span></strong><span class="koboSpan" id="kobo.1143.1">: The amount of PGA memory used by </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">the database</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1145.1">By monitoring these metrics over time, it is possible to identify periods of high memory usage and correlate them with specific events </span><span class="No-Break"><span class="koboSpan" id="kobo.1146.1">or queries.</span></span></p>
<h4><span class="koboSpan" id="kobo.1147.1">Slow I/O</span></h4>
<p><span class="koboSpan" id="kobo.1148.1">Slow I/O can </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.1149.1">be caused by a variety of factors, such as slow disks, high disk usage, or inefficient queries. </span><span class="koboSpan" id="kobo.1149.2">Datadog’s Oracle integration provides several metrics that can help identify </span><span class="No-Break"><span class="koboSpan" id="kobo.1150.1">slow I/O:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">oracle.disk.reads</span></strong><span class="koboSpan" id="kobo.1152.1">: The number of disk reads performed by </span><span class="No-Break"><span class="koboSpan" id="kobo.1153.1">the database</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1154.1">oracle.disk.writes</span></strong><span class="koboSpan" id="kobo.1155.1">: The number of disk writes performed by </span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">the database</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1157.1">oracle.disk.read.time</span></strong><span class="koboSpan" id="kobo.1158.1">: The amount of time spent on disk reads by </span><span class="No-Break"><span class="koboSpan" id="kobo.1159.1">the database</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">oracle.disk.write.time</span></strong><span class="koboSpan" id="kobo.1161.1">: The amount of time spent on disk writes by </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">the database</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1163.1">By monitoring </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.1164.1">these metrics over time, it is possible to identify periods of slow I/O and correlate them with specific events </span><span class="No-Break"><span class="koboSpan" id="kobo.1165.1">or queries.</span></span></p>
<h4><span class="koboSpan" id="kobo.1166.1">Alerting</span></h4>
<p><span class="koboSpan" id="kobo.1167.1">Once performance issues have been identified, it is important to be notified immediately </span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.1168.1">when they occur. </span><span class="koboSpan" id="kobo.1168.2">Datadog provides a powerful alerting system that can be configured to send alerts via email, Slack, PagerDuty, or other channels. </span><span class="koboSpan" id="kobo.1168.3">Alerts can be triggered based on a variety </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">of conditions:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1170.1">A threshold being crossed for a </span><span class="No-Break"><span class="koboSpan" id="kobo.1171.1">particular metric.</span></span></li>
<li><span class="koboSpan" id="kobo.1172.1">A metric exhibiting anomalous behavior compared to its </span><span class="No-Break"><span class="koboSpan" id="kobo.1173.1">historical values</span></span></li>
<li><span class="koboSpan" id="kobo.1174.1">A metric exhibiting anomalous behavior compared to other </span><span class="No-Break"><span class="koboSpan" id="kobo.1175.1">related metrics</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1176.1">For example, an alert could be configured to trigger if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">oracle.cpu.usage</span></strong><span class="koboSpan" id="kobo.1178.1"> metric exceeds a certain threshold for more than 5 minutes. </span><span class="koboSpan" id="kobo.1178.2">This would allow operations teams to respond quickly and investigate the cause of the high </span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">CPU usage.</span></span></p>
<p><span class="koboSpan" id="kobo.1180.1">In this section, we explored how Datadog’s Oracle integration can be used to identify performance issues in an Oracle database. </span><span class="koboSpan" id="kobo.1180.2">By monitoring metrics such as query performance, CPU usage, memory usage, and I/O performance, it is possible to quickly identify and resolve issues that can impact the performance and availability of critical applications. </span><span class="koboSpan" id="kobo.1180.3">With Datadog’s powerful alerting system, operations teams can be notified immediately when performance issues occur, allowing them to respond quickly and minimize the impact </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">on users.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.1182.1">DevSecOps</span></h2>
<p><span class="koboSpan" id="kobo.1183.1">Finally, ensuring the </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.1184.1">security and access management of relational databases is an important activity for a DevOps team. </span><span class="koboSpan" id="kobo.1184.2">This includes setting up authentication and authorization mechanisms, managing database users and permissions, and securing database connections. </span><span class="koboSpan" id="kobo.1184.3">Let’s look at some examples of how this can </span><span class="No-Break"><span class="koboSpan" id="kobo.1185.1">be accomplished.</span></span></p>
<h3><span class="koboSpan" id="kobo.1186.1">Securing MySQL connections using Ansible</span></h3>
<p><span class="koboSpan" id="kobo.1187.1">Securing MySQL connections is a crucial step in ensuring the confidentiality, integrity, and availability </span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.1188.1">of data stored in </span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.1189.1">MySQL databases. </span><span class="koboSpan" id="kobo.1189.2">Ansible is a powerful tool that allows for the automation of various IT tasks, including the deployment </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.1190.1">and configuration of security measures for MySQL connections. </span><span class="koboSpan" id="kobo.1190.2">In this example, we will explore how to use Ansible to secure MySQL connections by configuring SSL/TLS encryption and </span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">mutual authentication.</span></span></p>
<p><span class="koboSpan" id="kobo.1192.1">The architecture </span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.1193.1">for securing MySQL connections using Ansible involves the </span><span class="No-Break"><span class="koboSpan" id="kobo.1194.1">following components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1195.1">Ansible control machine</span></strong><span class="koboSpan" id="kobo.1196.1">: This is the machine where Ansible is installed and from where the configuration tasks </span><span class="No-Break"><span class="koboSpan" id="kobo.1197.1">are executed</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1198.1">MySQL server</span></strong><span class="koboSpan" id="kobo.1199.1">: This is the machine that hosts the MySQL database and where SSL/TLS encryption and mutual authentication will </span><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">be configured</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1201.1">Ansible-managed nodes</span></strong><span class="koboSpan" id="kobo.1202.1">: These are the machines that will be managed by Ansible to configure the </span><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">MySQL server</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1204.1">OpenSSL</span></strong><span class="koboSpan" id="kobo.1205.1">: OpenSSL is a library that provides cryptographic functions that will be used to generate SSL/TLS certificates </span><span class="No-Break"><span class="koboSpan" id="kobo.1206.1">and keys</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1207.1">Certbot</span></strong><span class="koboSpan" id="kobo.1208.1">: Certbot is a tool that automates the process of obtaining and renewing SSL/TLS certificates from </span><span class="No-Break"><span class="koboSpan" id="kobo.1209.1">Let’s Encrypt</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1210.1">The Ansible </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.1211.1">playbook for securing MySQL connections involves the </span><span class="No-Break"><span class="koboSpan" id="kobo.1212.1">following tasks:</span></span></p>
<ol>
<li><strong class="bold"><span class="koboSpan" id="kobo.1213.1">Installing the necessary packages</span></strong><span class="koboSpan" id="kobo.1214.1">: The first task is to install the necessary packages on MySQL Server to support SSL/TLS encryption and mutual authentication. </span><span class="koboSpan" id="kobo.1214.2">This includes installing OpenSSL </span><span class="No-Break"><span class="koboSpan" id="kobo.1215.1">and Certbot:</span></span></li>
</ol>
<p class="SC---Heading_list" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1216.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1217.1">
- name: Install packages
  become: true
  apt:
    name:
      - openssl
      - python3-certbot
      - python3-certbot-apache
    state: present</span></pre> <ol>
<li value="2"><strong class="bold"><span class="koboSpan" id="kobo.1218.1">Generating SSL/TLS certificates and keys</span></strong><span class="koboSpan" id="kobo.1219.1">: The next task is to generate SSL/TLS certificates </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.1220.1">and keys using OpenSSL. </span><span class="koboSpan" id="kobo.1220.2">This involves creating a self-signed CA certificate, a server certificate signed by the CA, and a client certificate signed by </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">the CA:</span></span></li>
</ol>
<p class="SC---Heading_list" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1222.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1223.1">
- name: Generate SSL/TLS certificates and keys
  become: true
  openssl_certificate:
    path: /etc/mysql/ssl/ca.pem
    privatekey_path: /etc/mysql/ssl/ca.key
    common_name: "My CA"
    owner: root
    group: root
    mode: 0600
    self_signed: yes
    type: CA
  register: ca_cert
- openssl_certificate:
    path: /etc/mysql/ssl/server.pem
    privatekey_path: /etc/mysql/ssl/server.key
    common_name: "{{ inventory_hostname }}"
    owner: root
    group: root
    mode: 0600
    ca_path: /etc/mysql/ssl/ca.pem
    ca_privatekey_path: /etc/mysql/ssl/ca.key
    ca_common_name: "My CA"
    type: server
  register: server_cert
- openssl_certificate:
    path: /etc/mysql/ssl/client.pem
    privatekey_path: /etc/mysql/ssl/client.key
    common_name: "MySQL Client"
    owner: root
    group: root
    mode: 0600
    ca_path: /etc/mysql/ssl/ca.pem
    ca_privatekey_path: /etc/mysql/ssl/ca.key
    ca_common_name: "My CA"
    type: client
  register: client_cert</span></pre> <ol>
<li value="3"><strong class="bold"><span class="koboSpan" id="kobo.1224.1">Configuring MySQL to use SSL/TLS encryption and mutual authentication</span></strong><span class="koboSpan" id="kobo.1225.1">: The next task is to configure MySQL to use SSL/TLS encryption and mutual authentication. </span><span class="koboSpan" id="kobo.1225.2">This involves adding the SSL/TLS configuration options to </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.1226.1">the MySQL configuration file and setting the necessary permissions for the SSL/TLS certificates </span><span class="No-Break"><span class="koboSpan" id="kobo.1227.1">and keys:</span></span></li>
</ol>
<p class="SC---Heading_list" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1228.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1229.1">
- name: Configure MySQL to use SSL/TLS encryption and mutual authentication
  become: true
  template:
    src: templates/my.cnf.j2
    dest: /etc/mysql/my.cnf
  notify: restart mysql
- name: Set permissions for SSL/TLS certificates and keys
  become: true
  file:
    path: "{{ item.path }}"
    owner: root
    group: root
    mode: 0600
  with_items:
    - "{{ ca_cert }}"
    - "{{ server_cert }}"
    - "{{ client_cert }}"</span></pre> <ol>
<li value="4"><strong class="bold"><span class="koboSpan" id="kobo.1230.1">Obtaining and renewing SSL/TLS certificates with Certbot</span></strong><span class="koboSpan" id="kobo.1231.1">: The final task is to </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.1232.1">configure Certbot to obtain and renew SSL/TLS certificates from Let’s Encrypt. </span><span class="koboSpan" id="kobo.1232.2">This involves configuring the Certbot Apache plugin and running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1233.1">Certbot</span></strong><span class="koboSpan" id="kobo.1234.1"> command to obtain the </span><span class="No-Break"><span class="koboSpan" id="kobo.1235.1">initial certificate:</span></span></li>
</ol>
<p class="SC---Heading_list" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1236.1">YAML</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1237.1">
- name: Configure Certbot to obtain and renew SSL/TLS certificates
  become: true
  template:
    src: templates/certbot.ini.j2
    dest: /etc/letsencrypt/cli.ini
- name: Obtain SSL/TLS certificate from Let's Encrypt
  become: true
  shell: certbot certonly --non-interactive --agree-tos --email admin@example.com --apache --domain example.com --domain www.example.com</span></pre> <p><span class="koboSpan" id="kobo.1238.1">In this example, we saw how to use Ansible to secure MySQL connections by configuring SSL/TLS encryption and mutual authentication. </span><span class="koboSpan" id="kobo.1238.2">We also saw how to use OpenSSL to generate SSL/TLS certificates and keys, and how to use Certbot to obtain and renew SSL/TLS certificates from Let’s Encrypt. </span><span class="koboSpan" id="kobo.1238.3">By following these steps, you can ensure that your MySQL connections are secure and that your data is protected from </span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1">unauthorized access.</span></span></p>
<h3><span class="koboSpan" id="kobo.1240.1">Managing PostgreSQL users and permissions using Chef</span></h3>
<p><span class="koboSpan" id="kobo.1241.1">PostgreSQL </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.1242.1">is a popular </span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.1243.1">open source RDBMS </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.1244.1">that is widely used for building applications. </span><span class="koboSpan" id="kobo.1244.2">Chef is a popular configuration management tool that is used to automate the deployment and management of applications and infrastructure. </span><span class="koboSpan" id="kobo.1244.3">In this example, we will look at how Chef can be used to manage PostgreSQL users </span><span class="No-Break"><span class="koboSpan" id="kobo.1245.1">and permissions.</span></span></p>
<p><span class="koboSpan" id="kobo.1246.1">The architecture used in this example consists of three </span><span class="No-Break"><span class="koboSpan" id="kobo.1247.1">main components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1248.1">Chef workstation</span></strong><span class="koboSpan" id="kobo.1249.1">: This is </span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.1250.1">the machine on which Chef is installed and from where Chef recipes and cookbooks </span><span class="No-Break"><span class="koboSpan" id="kobo.1251.1">are managed</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1252.1">Chef server</span></strong><span class="koboSpan" id="kobo.1253.1">: This is </span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.1254.1">the central repository where Chef clients register themselves and from where they retrieve the </span><span class="No-Break"><span class="koboSpan" id="kobo.1255.1">configuration data</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1256.1">PostgreSQL server</span></strong><span class="koboSpan" id="kobo.1257.1">: This is </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.1258.1">the machine on which PostgreSQL is installed and where the database </span><span class="No-Break"><span class="koboSpan" id="kobo.1259.1">is hosted</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1260.1">In this architecture, Chef is used to manage the configuration of the PostgreSQL server. </span><span class="koboSpan" id="kobo.1260.2">The Chef workstation is used to author and manage the Chef cookbooks and recipes. </span><span class="koboSpan" id="kobo.1260.3">The Chef server is used to store the configuration data and the PostgreSQL server is managed by the </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">Chef client.</span></span></p>
<h4><span class="koboSpan" id="kobo.1262.1">Managing PostgreSQL users and permissions</span></h4>
<p><span class="koboSpan" id="kobo.1263.1">PostgreSQL </span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.1264.1">uses a role-based authentication system to manage users and permissions. </span><span class="koboSpan" id="kobo.1264.2">In this example, we will look at how Chef can be used to manage PostgreSQL users and </span><span class="No-Break"><span class="koboSpan" id="kobo.1265.1">their permissions.</span></span></p>
<h4><span class="koboSpan" id="kobo.1266.1">Step 1 – installing PostgreSQL on the server</span></h4>
<p><span class="koboSpan" id="kobo.1267.1">Before we </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.1268.1">can manage PostgreSQL users and permissions, we need to ensure that PostgreSQL is installed on the server. </span><span class="koboSpan" id="kobo.1268.2">This can be done using Chef by writing a recipe that installs PostgreSQL on </span><span class="No-Break"><span class="koboSpan" id="kobo.1269.1">the server:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1270.1">Chef</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1271.1">
# Recipe to install PostgreSQL on the server
#
package 'postgresql'</span></pre> <h4><span class="koboSpan" id="kobo.1272.1">Step 2 – creating a PostgreSQL user</span></h4>
<p><span class="koboSpan" id="kobo.1273.1">To create </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.1274.1">a PostgreSQL user, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">psql</span></strong><span class="koboSpan" id="kobo.1276.1"> command-line tool. </span><span class="koboSpan" id="kobo.1276.2">In Chef, we can execute shell commands using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">execute</span></strong><span class="koboSpan" id="kobo.1278.1"> resource. </span><span class="koboSpan" id="kobo.1278.2">The following code snippet shows how to create a PostgreSQL user </span><span class="No-Break"><span class="koboSpan" id="kobo.1279.1">using Chef:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1280.1">Chef</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1281.1">
# Recipe to create a PostgreSQL user
#
execute 'create_postgres_user' do
  user 'postgres'
  command "psql -c \"CREATE USER #{node['postgresql']['user']} WITH PASSWORD #{node['postgresql']['password']};\""
end</span></pre> <p><span class="koboSpan" id="kobo.1282.1">In this code snippet, we are executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1283.1">psql</span></strong><span class="koboSpan" id="kobo.1284.1"> command to create a PostgreSQL user. </span><span class="koboSpan" id="kobo.1284.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">user</span></strong><span class="koboSpan" id="kobo.1286.1"> parameter is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">postgres</span></strong><span class="koboSpan" id="kobo.1288.1">, which is the default user for PostgreSQL. </span><span class="koboSpan" id="kobo.1288.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1289.1">command</span></strong><span class="koboSpan" id="kobo.1290.1"> parameter is set to the SQL statement that creates the user. </span><span class="koboSpan" id="kobo.1290.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">node[‘postgresql’][‘user’]</span></strong><span class="koboSpan" id="kobo.1292.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">node[‘postgresql’][‘password’]</span></strong><span class="koboSpan" id="kobo.1294.1"> attributes are used to set the username and password for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1295.1">PostgreSQL user.</span></span></p>
<h4><span class="koboSpan" id="kobo.1296.1">Step 3 – granting permissions to the user</span></h4>
<p><span class="koboSpan" id="kobo.1297.1">Once the </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.1298.1">user has been created, we can grant them permissions using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1299.1">GRANT</span></strong><span class="koboSpan" id="kobo.1300.1"> command. </span><span class="koboSpan" id="kobo.1300.2">In Chef, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">execute</span></strong><span class="koboSpan" id="kobo.1302.1"> resource to execute the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">GRANT</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1304.1"> command:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1305.1">Chef</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1306.1">
# Recipe to grant permissions to a PostgreSQL user
#
execute 'grant_postgres_user_permissions' do
  user 'postgres'
  command "psql -c \"GRANT ALL PRIVILEGES ON DATABASE #{node['postgresql']['database']} TO #{node['postgresql']['user']};\""
end</span></pre> <p><span class="koboSpan" id="kobo.1307.1">In this </span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.1308.1">code snippet, we are executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">psql</span></strong><span class="koboSpan" id="kobo.1310.1"> command to grant permissions to the PostgreSQL user. </span><span class="koboSpan" id="kobo.1310.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">user</span></strong><span class="koboSpan" id="kobo.1312.1"> parameter is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">postgres</span></strong><span class="koboSpan" id="kobo.1314.1">, which is the default user for PostgreSQL. </span><span class="koboSpan" id="kobo.1314.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">command</span></strong><span class="koboSpan" id="kobo.1316.1"> parameter is set to the SQL statement that grants permissions to the user. </span><span class="koboSpan" id="kobo.1316.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1317.1">node[‘postgresql’][‘database’]</span></strong><span class="koboSpan" id="kobo.1318.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1319.1">node[‘postgresql’][‘user’]</span></strong><span class="koboSpan" id="kobo.1320.1"> attributes are used to set the name of the database and the name of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">user, respectively.</span></span></p>
<h4><span class="koboSpan" id="kobo.1322.1">Step 4 – revoking permissions from the user</span></h4>
<p><span class="koboSpan" id="kobo.1323.1">If we want </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.1324.1">to revoke permissions from a PostgreSQL user, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1325.1">REVOKE</span></strong><span class="koboSpan" id="kobo.1326.1"> command. </span><span class="koboSpan" id="kobo.1326.2">In Chef, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">execute</span></strong><span class="koboSpan" id="kobo.1328.1"> resource to execute the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">REVOKE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1330.1"> command:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1331.1">Chef</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1332.1">
# Recipe to revoke permissions from a PostgreSQL user
#
execute 'revoke_postgres_user_permissions' do
  user 'postgres'
  command "psql -c \"REVOKE ALL PRIVILEGES ON DATABASE #{node['postgresql']['database']} FROM #{node['postgresql']['user']};\""
end</span></pre> <p><span class="koboSpan" id="kobo.1333.1">In this code snippet, we are executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">psql</span></strong><span class="koboSpan" id="kobo.1335.1"> command to revoke permissions from the PostgreSQL user. </span><span class="koboSpan" id="kobo.1335.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1336.1">user</span></strong><span class="koboSpan" id="kobo.1337.1"> parameter is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1338.1">postgres</span></strong><span class="koboSpan" id="kobo.1339.1">, which is the default user for PostgreSQL. </span><span class="koboSpan" id="kobo.1339.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">command</span></strong><span class="koboSpan" id="kobo.1341.1"> parameter is set to the SQL statement that revokes permissions from the user. </span><span class="koboSpan" id="kobo.1341.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1342.1">node[‘postgresql’][‘database’]</span></strong><span class="koboSpan" id="kobo.1343.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">node[‘postgresql’][‘user’]</span></strong><span class="koboSpan" id="kobo.1345.1"> attributes are used to set the name of the database and the name of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1346.1">user, respectively.</span></span></p>
<h4><span class="koboSpan" id="kobo.1347.1">Step 5 – deleting the user</span></h4>
<p><span class="koboSpan" id="kobo.1348.1">To delete </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.1349.1">a PostgreSQL user, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1350.1">DROP ROLE</span></strong><span class="koboSpan" id="kobo.1351.1"> command. </span><span class="koboSpan" id="kobo.1351.2">In Chef, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1352.1">execute</span></strong><span class="koboSpan" id="kobo.1353.1"> resource to execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1354.1">DROP </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">ROLE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1356.1"> command:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1357.1">Chef</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1358.1">
# Recipe to delete a PostgreSQL user
#
execute 'delete_postgres_user' do
  user 'postgres'
  command "psql -c \"DROP ROLE IF EXISTS #{node['postgresql']['user']};\""
end</span></pre> <p><span class="koboSpan" id="kobo.1359.1">In this code snippet, we are executing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1360.1">psql</span></strong><span class="koboSpan" id="kobo.1361.1"> command to delete the PostgreSQL user. </span><span class="koboSpan" id="kobo.1361.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1362.1">user</span></strong><span class="koboSpan" id="kobo.1363.1"> parameter is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">postgres</span></strong><span class="koboSpan" id="kobo.1365.1">, which is the default user for PostgreSQL. </span><span class="koboSpan" id="kobo.1365.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1366.1">command</span></strong><span class="koboSpan" id="kobo.1367.1"> parameter is set to the SQL statement that deletes the user. </span><span class="koboSpan" id="kobo.1367.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1368.1">node[‘postgresql’][‘user’]</span></strong><span class="koboSpan" id="kobo.1369.1"> attribute is used to set the name of </span><span class="No-Break"><span class="koboSpan" id="kobo.1370.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.1371.1">In this example, we looked at how Chef can be used to manage PostgreSQL users and their permissions. </span><span class="koboSpan" id="kobo.1371.2">We saw how to create a PostgreSQL user, grant permissions to the user, revoke permissions from the user, and delete the user. </span><span class="koboSpan" id="kobo.1371.3">Chef provides a powerful and flexible way to manage PostgreSQL users and permissions, and this example demonstrates how this can be achieved using Chef recipes </span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1">and resources.</span></span></p>
<h3><span class="koboSpan" id="kobo.1373.1">Securing Oracle databases using Puppet</span></h3>
<p><span class="koboSpan" id="kobo.1374.1">Securing </span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.1375.1">Oracle databases is critical for </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.1376.1">organizations as databases contain </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.1377.1">sensitive information and are often targeted by attackers. </span><span class="koboSpan" id="kobo.1377.2">Puppet is a popular configuration management tool that can be used to automate the process of securing Oracle databases. </span><span class="koboSpan" id="kobo.1377.3">In this example, we will discuss the architecture used to secure Oracle databases using Puppet and provide sample code to demonstrate </span><span class="No-Break"><span class="koboSpan" id="kobo.1378.1">the process.</span></span></p>
<p><span class="koboSpan" id="kobo.1379.1">The architecture </span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.1380.1">that’s used to secure </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.1381.1">Oracle databases using Puppet </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.1382.1">involves several components, including Puppet itself, the Oracle database, and the server hosting the database. </span><span class="koboSpan" id="kobo.1382.2">The following is </span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.1383.1">a high-level overview of </span><span class="No-Break"><span class="koboSpan" id="kobo.1384.1">the architecture:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1385.1">Puppet master</span></strong><span class="koboSpan" id="kobo.1386.1">: The Puppet master is the central server that manages and controls the configuration of the Oracle database servers. </span><span class="koboSpan" id="kobo.1386.2">It contains the Puppet code that defines the desired state of the Oracle </span><span class="No-Break"><span class="koboSpan" id="kobo.1387.1">database servers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1388.1">Puppet agent</span></strong><span class="koboSpan" id="kobo.1389.1">: The Puppet agent is installed on the Oracle database servers and communicates with the Puppet master to retrieve configuration data and apply it to </span><span class="No-Break"><span class="koboSpan" id="kobo.1390.1">the servers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1391.1">Oracle database</span></strong><span class="koboSpan" id="kobo.1392.1">: The Oracle database is the system being secured. </span><span class="koboSpan" id="kobo.1392.2">It runs on one or more servers and stores data in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1393.1">structured format.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1394.1">Server</span></strong><span class="koboSpan" id="kobo.1395.1">: The server is the physical or virtual machine that hosts the Oracle database. </span><span class="koboSpan" id="kobo.1395.2">It runs the operating system and provides the resources required by </span><span class="No-Break"><span class="koboSpan" id="kobo.1396.1">the database.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1397.1">Now, let’s take a look at how we can use Puppet to secure an </span><span class="No-Break"><span class="koboSpan" id="kobo.1398.1">Oracle database.</span></span></p>
<h4><span class="koboSpan" id="kobo.1399.1">Step 1 – installing the Puppet agent</span></h4>
<p><span class="koboSpan" id="kobo.1400.1">The first </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.1401.1">step is to install the Puppet agent on the Oracle database server. </span><span class="koboSpan" id="kobo.1401.2">This can be done by following the instructions on the Puppet website. </span><span class="koboSpan" id="kobo.1401.3">Once the agent has been installed, it will automatically communicate with the Puppet master to retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.1402.1">configuration data.</span></span></p>
<h4><span class="koboSpan" id="kobo.1403.1">Step 2 – creating the Puppet manifest</span></h4>
<p><span class="koboSpan" id="kobo.1404.1">The next </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.1405.1">step is to create a Puppet manifest that defines the desired state of the Oracle database server. </span><span class="koboSpan" id="kobo.1405.2">The manifest is written in the Puppet language, which is a declarative language that allows you to define the desired state of </span><span class="No-Break"><span class="koboSpan" id="kobo.1406.1">a system.</span></span></p>
<p><span class="koboSpan" id="kobo.1407.1">Here’s an example of a Puppet manifest that installs the latest security patches </span><span class="No-Break"><span class="koboSpan" id="kobo.1408.1">for Oracle:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1409.1">Puppet</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1410.1">
class oracle_security {
  package { 'oracle_security_patches':
    ensure =&gt; latest,
    provider =&gt; 'yum',
  }
}</span></pre> <p><span class="koboSpan" id="kobo.1411.1">This manifest </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.1412.1">defines a class called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1413.1">oracle_security</span></strong><span class="koboSpan" id="kobo.1414.1"> that installs the latest security patches for Oracle using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1415.1">yum</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1416.1">package provider.</span></span></p>
<h4><span class="koboSpan" id="kobo.1417.1">Step 3 – applying the Puppet manifest</span></h4>
<p><span class="koboSpan" id="kobo.1418.1">Once the </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.1419.1">manifest has been created, it needs to be applied to the Oracle database server using the Puppet agent. </span><span class="koboSpan" id="kobo.1419.2">This can be done by running the following command on </span><span class="No-Break"><span class="koboSpan" id="kobo.1420.1">the server:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1421.1">sudo puppet agent -t</span></strong></pre> <p><span class="koboSpan" id="kobo.1422.1">This command tells the Puppet agent to retrieve the latest configuration data from the Puppet master and apply it to </span><span class="No-Break"><span class="koboSpan" id="kobo.1423.1">the server.</span></span></p>
<h4><span class="koboSpan" id="kobo.1424.1">Step 4 – verifying the configuration</span></h4>
<p><span class="koboSpan" id="kobo.1425.1">Once the </span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.1426.1">manifest has been applied, it’s important to verify that the configuration has been applied correctly. </span><span class="koboSpan" id="kobo.1426.2">This can be done by checking the logs generated by Puppet and verifying that the desired state of the system has </span><span class="No-Break"><span class="koboSpan" id="kobo.1427.1">been achieved.</span></span></p>
<p><span class="koboSpan" id="kobo.1428.1">Here’s an example of a Puppet log that shows that the security patches were </span><span class="No-Break"><span class="koboSpan" id="kobo.1429.1">successfully installed:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1430.1">Bash</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1431.1">
Info: Applying configuration version '1474461465'
Notice: /Stage[main]/Oracle_security/Package[oracle_security_patches]/ensure: ensure changed '1.0.0-1' to '1.1.0-1'</span></pre> <p><span class="koboSpan" id="kobo.1432.1">This log </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.1433.1">shows that Puppet applied the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1434.1">oracle_security_patches</span></strong><span class="koboSpan" id="kobo.1435.1"> package and updated it from version </span><strong class="source-inline"><span class="koboSpan" id="kobo.1436.1">1.0.0-1</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1437.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1438.1">1.1.0-1</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1439.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1440.1">In this example, we discussed how to use Puppet to secure Oracle databases. </span><span class="koboSpan" id="kobo.1440.2">We looked at the architecture that’s used and provided sample code to demonstrate the process. </span><span class="koboSpan" id="kobo.1440.3">By using Puppet to automate the process of securing Oracle databases, organizations can ensure that their databases are always up- to- date with the latest security patches and configuration settings. </span><span class="koboSpan" id="kobo.1440.4">This helps reduce the risk of data breaches and other </span><span class="No-Break"><span class="koboSpan" id="kobo.1441.1">security incidents.</span></span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.1442.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1443.1">In this chapter, we embarked on a journey through the complex yet rewarding world of integrating RDBMS with DevOps. </span><span class="koboSpan" id="kobo.1443.2">As we navigated the intricacies of each section, we gathered invaluable insights that can be directly applied in </span><span class="No-Break"><span class="koboSpan" id="kobo.1444.1">real-world scenarios.</span></span></p>
<p><span class="koboSpan" id="kobo.1445.1">First, we dived into provisioning and configuration management, grasping how automation can simplify these otherwise tedious tasks. </span><span class="koboSpan" id="kobo.1445.2">We came to understand that IaC is not just a trend, but a crucial strategy for rapidly setting up and </span><span class="No-Break"><span class="koboSpan" id="kobo.1446.1">modifying environments.</span></span></p>
<p><span class="koboSpan" id="kobo.1447.1">Next, we explored monitoring and alerting, becoming familiar with the tools and best practices that help with establishing real-time database monitoring and setting up automated alerts. </span><span class="koboSpan" id="kobo.1447.2">The importance of these proactive steps in pre-empting system issues cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.1448.1">be overstated.</span></span></p>
<p><span class="koboSpan" id="kobo.1449.1">We then turned our attention to backup and disaster recovery. </span><span class="koboSpan" id="kobo.1449.2">The importance of integrating solid backup and recovery plans into our DevOps pipeline was highlighted, reinforcing the notion that this is not just a contingency but a </span><span class="No-Break"><span class="koboSpan" id="kobo.1450.1">business imperative.</span></span></p>
<p><span class="koboSpan" id="kobo.1451.1">Our learning curve continued upward as we examined performance optimization. </span><span class="koboSpan" id="kobo.1451.2">We found out how applying these methods can significantly improve system performance while simultaneously reducing </span><span class="No-Break"><span class="koboSpan" id="kobo.1452.1">operational costs.</span></span></p>
<p><span class="koboSpan" id="kobo.1453.1">Finally, this chapter culminated in an enlightening discussion on DevSecOps, which taught us that security is not an afterthought but an integral part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1454.1">DevOps framework.</span></span></p>
<p><span class="koboSpan" id="kobo.1455.1">So, what can we do with these insights? </span><span class="koboSpan" id="kobo.1455.2">Armed with this newfound knowledge, we are now in a position to enhance the efficiency, security, and performance of our systems. </span><span class="koboSpan" id="kobo.1455.3">By putting what we’ve learned into practice, we’re not just adapting to the current landscape; we’re staying ahead of it, granting ourselves and our organizations a </span><span class="No-Break"><span class="koboSpan" id="kobo.1456.1">competitive advantage.</span></span></p>
<p><span class="koboSpan" id="kobo.1457.1">In the next chapter, we will navigate the intricate yet fascinating landscape of integrating non-RDBMSs (NoSQL) </span><span class="No-Break"><span class="koboSpan" id="kobo.1458.1">with DevOps.</span></span></p>
</div>
</body></html>