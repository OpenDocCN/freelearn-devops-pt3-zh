<html><head></head><body>
		<div id="_idContainer031">
			<h1 class="chapter-number" id="_idParaDest-137"><a id="_idTextAnchor159"/>7</h1>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor160"/>CI/CD Automation</h1>
			<p>In this chapter, we’ll learn how to automate our DevOps processes with <strong class="bold">Continuous Integration and Continuous Delivery</strong> (<strong class="bold">CI/CD</strong>). We’ll <a id="_idIndexMarker293"/>also look at some popular tools for <span class="No-Break">achieving this.</span></p>
			<p>By leveraging the power of CI/CD, we can create a more efficient, reliable, and streamlined workflow for our Salesforce development and operations. This approach allows us to quickly react to changes, reduces the risk of deployment failures, and ultimately, helps us deliver <span class="No-Break">better-quality software.</span></p>
			<p>We will cover the following <span class="No-Break">main topics.</span></p>
			<ul>
				<li><strong class="bold">Introduction to CI/CD</strong>: Firstly, we will define CI/CD, explain its benefits, and discuss how it fits into a DevOps strategy. We’ll also highlight the key principles and best practices to follow when <span class="No-Break">implementing CI/CD.</span></li>
				<li><strong class="bold">GitHub Actions</strong>: This section will focus on GitHub Actions, a flexible and powerful CI/CD tool that integrates directly with your GitHub repositories. We’ll explore how to set up workflows, automate tests, and handle deployments, all within the <span class="No-Break">GitHub platform.</span></li>
				<li><strong class="bold">Jenkins</strong>: A longstanding favorite in the CI/CD community, Jenkins is another tool we’ll dive into. We’ll show you how to configure Jenkins for Salesforce projects, create pipelines, and leverage its extensive <span class="No-Break">plugin ecosystem.</span></li>
				<li><strong class="bold">Salesforce-specific tools</strong>: Salesforce offers several tools that can aid in CI/CD, such as <strong class="bold">Salesforce DX</strong> (<strong class="bold">SFDX</strong>) and<a id="_idIndexMarker294"/> the Salesforce CLI. We’ll discuss how to leverage these tools to streamline your CI/CD process and tackle <span class="No-Break">Salesforce-specific challenges.</span></li>
				<li><strong class="bold">Practical use of the CI/CD pipeline</strong>: We’ll finish by looking at the advantages that our newly-built CI/CD pipeline affords us as part of a robust <span class="No-Break">DevOps implementation.</span></li>
			</ul>
			<p>By the end of this chapter, you should have a robust understanding of the role of CI/CD in Salesforce DevOps, the tools available for implementing it, and the steps you can take to begin automating your <span class="No-Break">own processes.</span></p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor161"/>Technical requirements</h1>
			<p>For Jenkins, you’ll need a server that can host the Jenkins software. This could be a physical server, a virtual machine, or a cloud-based server. The specific requirements will depend on the scale of your projects, but as a minimum, you should plan for at least 1 GB of memory, 50 GB of disk space, and a modern CPU. It’s worth noting that, for learning purposes, it is possible to run Jenkins on your local development machine if you want to follow the processes and steps in this book, but for real-world use, as part of your DevOps toolchain, a dedicated hosting solution <span class="No-Break">is recommended.</span></p>
			<p>SFDX and the Salesforce CLI are crucial tools for Salesforce DevOps. To use them, you’ll need to install the Salesforce CLI on your system. If you’ve not already got them in place, you can revisit <a href="B19436_05.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, which covers setting them up <span class="No-Break">in detail.</span></p>
			<p>To implement CI/CD in Salesforce, you’ll need an active Salesforce developer account. If you’re working with a team, you’ll also need an SFDX “hub” organization, where you can create and manage <span class="No-Break">scratch orgs.</span></p>
			<p>A crucial part of CI/CD is version control. GitHub is the most widely used platform and is recommended for its excellent integration with CI/CD tools. You’ll need a GitHub account and a repository for your <span class="No-Break">Salesforce code.</span></p>
			<p>The source code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Salesforce-DevOps-for-Architects/tree/main/Chapter7"><span class="No-Break">https://github.com/PacktPublishing/Salesforce-DevOps-for-Architects/tree/main/Chapter7</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor162"/>Introducing CI/CD</h1>
			<p>The world of software<a id="_idIndexMarker295"/> development has evolved dramatically over the years, with an increasing focus on agility, efficiency, and quality. In this context, CI and CD have emerged as key practices that can drive significant improvements in development workflows. In this section, we will explore the core concepts of CI/CD, their benefits, and their role in a <span class="No-Break">DevOps strategy.</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor163"/>Continuous Integration (CI)</h2>
			<p>CI is a process in <a id="_idIndexMarker296"/>which developers commit their code into a shared repository frequently. Each of these commits can then undergo an automated build and test cycle to identify problems in the early stages of the development life cycle. This CI process helps to reduce integration problems and allows the development team to receive immediate feedback on <span class="No-Break">any issues.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor164"/>Continuous Delivery (CD)</h2>
			<p>CD takes the ideas of CI one <a id="_idIndexMarker297"/>step further. It automates the software release process as far as being ready for production but falls just short of the actual production deployment. This practice ensures that the code and config contained in the repository (usually the main or master branch) are always in a production-ready state, reduces the risk and effort of deployments, and allows teams to deliver updates and improvements to customers more quickly and regularly. The software is deployment-ready after automated testing, but a human decision is required on when to deploy <span class="No-Break">to production.</span></p>
			<p>Together, CI and CD form the backbone of modern DevOps practices. They promote a culture of collaboration, fast feedback cycles, and a focus on high-quality output. Implementing CI/CD can lead to more efficient development processes, fewer bugs reaching production, and a better product for <span class="No-Break">your users.</span></p>
			<p>In the context of Salesforce, CI/CD can bring additional benefits. Salesforce projects often involve multiple developers working on several aspects of a complex system. With CI/CD, you can ensure that changes are integrated and tested frequently, reducing the risk of conflicts and errors. Also, automated deployments can simplify the process of pushing changes to testing, staging, and <span class="No-Break">production environments.</span></p>
			<p>However, it’s important to note that implementing CI/CD is not just a matter of using certain tools or following specific steps. It’s a cultural shift that requires buy-in from the entire team, a focus on automation and testing, and an ongoing commitment to improving your processes. This may involve improving existing testing practices or addressing technical debt and poor architecture – all of which can be prerequisites for properly implementing CI/CD. While these changes can seem daunting, the benefits of adopting CI/CD typically outweigh the effort required. In the following sections, we’ll delve into the specific tools and practices that can help you bring the benefits of CI/CD to your Salesforce projects. Even though the initial effort may be substantial, the payoff from improved automation, testing, and delivery processes is well worth it. With team commitment and a focus on continuous improvement, CI/CD can transform how you build and deliver<a id="_idIndexMarker298"/> <span class="No-Break">on Salesforce.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor165"/>CI/CD pipeline</h2>
			<p>A crucial concept within <a id="_idIndexMarker299"/>the CI/CD landscape is that of a pipeline. A CI/CD pipeline is a series of steps that your changes, whether in the form of code, metadata, or even data, will go through to make their way from development to production. It automates the process of integrating code changes, validating them with tests, and delivering them to the end users. It is usually visualized as a series of stages, each with a specific purpose. When a change is introduced (for example, when a developer pushes code to the repository), it triggers the pipeline, and the change moves through the stages. Let’s look at some of the typical <span class="No-Break">pipeline stages:</span></p>
			<ul>
				<li><strong class="bold">Build stage</strong>: This is where<a id="_idIndexMarker300"/> the code is compiled, dependencies are fetched, and the software is packaged for deployment. For a Salesforce project, this might involve creating a new SFDX scratch org, pushing the code to the org, and running any <span class="No-Break">required scripts.</span></li>
				<li><strong class="bold">Test stage</strong>: Automated tests are run against the build to ensure it behaves as expected. This could include unit tests, integration tests, and functional tests. In a Salesforce context, this must involve running Apex tests and possibly testing other components, such as Visualforce pages or <span class="No-Break">Lightning components.</span></li>
				<li><strong class="bold">Deploy stage</strong>: If the build passes all tests, it can be deployed to a staging environment for further testing, and if it passes there, it can be deployed to the production environment. Salesforce-specific tools such as SFDX and change sets can be used for these deployments. Ultimately, these tools are wrappers around the Metadata API, which remains the sole underlying way to <span class="No-Break">deploy changes.</span></li>
				<li><strong class="bold">Monitor stage</strong>: After deployment, the application is monitored to ensure it’s functioning correctly in the production environment. Any issues that arise can be fed back into the <span class="No-Break">development process.</span></li>
			</ul>
			<p>Each of these stages is typically automated, meaning that the change can progress from one stage to the next without manual intervention, assuming that all<a id="_idTextAnchor166"/> checks pass. This automation is a key benefit of CI/CD pipelines, as it reduces the risk of human error, speeds up the delivery process, and provides quick feedback to the <span class="No-Break">development team.</span></p>
			<p>Each stage is designed to catch different types of issues. For instance, the build stage might catch syntax errors, while the test stage could catch functional bugs, and the monitoring stage could identify performance issues or errors in the live environment. Using tools such as PMD for static code analysis, or other code linters, such as ESLint for your Lightning Web Components, reinforces consistent code style and best practices across the entire development team. With rules encoded into the tools, developers get immediate feedback if they violate conventions. This promotes readable, maintainable code and, of course, can be added to your pipelines to <span class="No-Break">run automatically.</span></p>
			<p>In the context of Salesforce, a CI/CD pipeline can help manage the complexities of developing in a multi-tenant, metadata-driven environment. It allows teams to develop, test, and deploy changes in a controlled, repeatable way, reducing the risks associated with manual deployments<a id="_idIndexMarker301"/> and ensuring high-quality output. In the coming sections, we’ll discuss how to implement such a pipeline using popular tools such as GitHub Actions <span class="No-Break">and Jenkins.</span></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor167"/>GitHub Actions</h1>
			<p>In our journey into<a id="_idIndexMarker302"/> the realm of CI/CD, we encounter various tools that help facilitate these practices. One of these tools, which stands out for its simplicity and tight integration with the GitHub platform, is GitHub Actions. This powerful automation tool allows you to create<a id="_idIndexMarker303"/> custom <strong class="bold">Software Development Life Cycle</strong> (<strong class="bold">SDLC</strong>) workflows directly in your <span class="No-Break">GitHub repository.</span></p>
			<p>GitHub Actions enables you to automate, customize, and execute your software development workflows right in your repository. You can deploy workflows in the same place where you store code and collaborate on projects. This translates into faster, more streamlined development cycles as you can manage CI/CD from within your GitHub projects, without needing to rely on <span class="No-Break">external tools.</span></p>
			<p>In GitHub Actions, workflows, jobs, and actions have a hierarchical relationship, which allows you to organize and structure your CI/CD process. This hierarchy has the <span class="No-Break">following levels:</span></p>
			<ul>
				<li><strong class="bold">Workflow</strong>: A workflow<a id="_idIndexMarker304"/> is the highest level of organization. These automated processes are typically stored in your repository and can be configured for a number of DevOps tasks against your GitHub project, such as building, testing, packaging, or deploying your changes. Workflows consist of one or more job nodes and can be triggered automatically by various events, such as a push or pull request. The <strong class="source-inline">.github/workflows</strong> directory of your repository holds <strong class="source-inline">.yml</strong> or <strong class="source-inline">.yaml</strong> files where workflows <span class="No-Break">are defined.</span></li>
				<li><strong class="bold">Job</strong>: Jobs are the second level of organization within a workflow. Each job will execute in an environment defined by the <strong class="source-inline">runs-on</strong> directive. A single workflow can execute numerous jobs, which, by default, operate concurrently, although you can adjust them to run one after the other. Each job is composed of several steps, each performing specific tasks. These jobs can utilize either the same runner or <span class="No-Break">different ones.</span></li>
				<li><strong class="bold">Step</strong>: Steps represent the most granular level of work within a job. Each step is responsible for executing a single command or action. They can either carry out commands, which are any shell commands, or actions, which are reusable code chunks. These actions could be developed by you, developed by GitHub, or sourced from the community through a <span class="No-Break">public repository.</span></li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer030">
					<img alt="Figure 7.1 – The hierarchical relationship between workflows, jobs, and steps" src="image/Figure_7.1_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The hierarchical relationship between workflows, jobs, and steps</p>
			<p>A step in a job can be either a <a id="_idIndexMarker305"/>command that runs in a shell or an action. In the following example, each step in the job either runs a command in a shell (such as <strong class="source-inline">npm install sfdx-cli --global</strong>) or uses an action (such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">actions/checkout@v2</strong></span><span class="No-Break">).</span></p>
			<p>GitHub Actions provides more than just the ability to establish CI/CD pipelines. It also allows for the automation of a broad spectrum of tasks, such as issue triaging and package publishing. This makes it a multifaceted tool essential for any <span class="No-Break">developer’s toolkit.</span></p>
			<p>For Salesforce developers and architects, tasks can be automated using GitHub Actions, such as running Apex tests, deploying code to scratch orgs, and promoting changes to staging and production environments. In the following sections, we’ll delve deeper into how to set up and use<a id="_idIndexMarker306"/> GitHub Actions for <span class="No-Break">Salesforce CI/CD.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor168"/>GitHub workflows in action</h2>
			<p>Let’s start by looking at a <a id="_idIndexMarker307"/>real-world example of a Git workflow and then walk through what it is doing. Consider the GitHub workflow <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
name: Salesforce CI
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]</pre>			<p>This GitHub workflow is initiated whenever push or pull request events occur on the main branch. We then need to define the job(s) within <span class="No-Break">the workflow:</span></p>
			<pre class="source-code">
jobs:
  deploy:
    runs-on: ubuntu-latest</pre>			<p>In this instance, we have defined a singular job named <strong class="source-inline">deploy</strong>, which executes in an <strong class="source-inline">ubuntu-latest</strong> environment. The <strong class="source-inline">runs-on:</strong> field in a GitHub Actions workflow configures the kind of machine that the job will be run on. This field can assume a variety of values, which, in turn, determine the type of runner used for the execution of <span class="No-Break">the job.</span></p>
			<p>A runner is a server equipped with the GitHub Actions runner application, tasked with executing jobs. The <strong class="source-inline">ubuntu-latest</strong> value indicates that the job should run on the latest stable Ubuntu virtual machine hosted <span class="No-Break">by GitHub.</span></p>
			<p>Next, we will define the steps that the job should execute. Firstly, we do some preparation by checking out the code in our repository and installing the Salesforce CLI to run additional steps with <span class="No-Break">the code:</span></p>
			<pre class="source-code">
  steps:
      - name: Checkout
        uses: actions/checkout@v2
       - name: Install Salesforce CLI
        run: |
              wget https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-x64.tar.xz
              mkdir ~/sfdx
              tar xJf sfdx-linux-x64.tar.xz -C ~/sfdx --strip-components 1
              echo "$HOME/sfdx/bin" &gt;&gt; $GITHUB_PATH
              ~/sfdx/bin/sfdx version</pre>			<p>The first step uses <strong class="source-inline">actions/checkout@v2</strong> to check out the source code of the current repository. With <a id="_idIndexMarker308"/>GitHub Actions, it’s possible to utilize actions that are contained in your own repository, in a public repository, or within a Docker container image in GitHub’s own collection of published images. The <strong class="source-inline">uses:</strong> keyword in your GitHub Actions workflow is used to specify <span class="No-Break">these actions.</span></p>
			<p>In this case, <strong class="source-inline">actions/checkout@v2</strong> refers to the checkout a<a id="_idTextAnchor169"/>ction from the <strong class="source-inline">actions</strong> repository, and <strong class="source-inline">v2</strong> is the tag of the version you want to use. This checkout action checks out your repository under <strong class="source-inline">$GITHUB_WORKSPACE</strong>, so your workflow can <span class="No-Break">access it.</span></p>
			<p>By specifying <strong class="source-inline">v2</strong>, you are instructing the workflow to use the second major version of the checkout action. This version could include new features, changes, or bug fixes compared to the previous version (<strong class="source-inline">v1</strong>). The maintainers of the action define these versions according to semantic <span class="No-Break">versioning rules.</span></p>
			<p>It’s good practice to specify a version (instead of using the default branch, usually <strong class="source-inline">main</strong> or <strong class="source-inline">master</strong>) to protect your workflows from potential breaking changes introduced into <span class="No-Break">those branches.</span></p>
			<p>The second step is to install the Salesforce CLI globally. The Salesforce CLI is used to authenticate with your Salesforce org and run your Apex unit tests. However, the Salesforce CLI isn’t pre-installed on GitHub’s virtual environments, so you need to install it in <span class="No-Break">your workflow.</span></p>
			<p>The Salesforce CLI has two main distribution methods – as a binary executable file and as a Node.js package installed through npm. We chose to use the binary distribution in our script, as the npm installation can run into permissions issues when trying to add extra plugins. The npm package requires Node.js and needs to be installed globally, which typically requires sudo permissions. Using sudo can lead to filesystem permission problems down the line. The binary distribution avoids these problems, which is why we opted for that method. The Node.js npm package is also available, but we avoided it due to the potential permission<a id="_idIndexMarker309"/> issues when adding plugins. Now, we can move on to the next step in <span class="No-Break">our job:</span></p>
			<pre class="source-code">
# The URL is stored in the Github Secret named DEVHUB_SFDX_URL
# so here we store the URL into a text file
      - name: 'Populate auth file with SFDX_URL secret of integration org'
        shell: bash
        run: |
                echo ${{ secrets.DEVHUB_SFDX_URL}} &gt; ./DEVHUB_SFDX_URL.txt</pre>			<p>In the preceding step, we are making use of GitHub’s per-repository secrets to retrieve a stored value and copying that value into a temporary file <em class="italic">only for the life cycle of this job</em>. The file contains an SFDX authorization URL, which allows the job to connect to our Salesforce Developer Hub <span class="No-Break">org easily.</span></p>
			<p>There are three choices available to create this authentication file. The simplest approach involves redirecting the output of the <strong class="source-inline">sf org display --verbose --json</strong> command to a file. As an illustration, consider the scenario of utilizing an org that you have <span class="No-Break">already authorized:</span></p>
			<pre class="source-code">
sf org display -o &lt;OrgUsername&gt; --verbose --json &gt; authFile.json</pre>			<p>Inside the resulting JSON file, you can find the URL stored in the <strong class="source-inline">sfdxAuthUrl</strong> property within a results object. Please note that the <strong class="source-inline">force:org:display --verbose</strong> command only displays the refresh token for orgs authorized with the web server flow, not the JWT <span class="No-Break">bearer flow.</span></p>
			<p>Additionally, you have the option to generate a JSON file with a top-level property called <strong class="source-inline">sfdxAuthUrl</strong>, which contains the authentication URL. Alternatively, you can create a plain text file that solely includes the URL without any <span class="No-Break">additional content.</span></p>
			<p>The SFDX authorization URL follows <span class="No-Break">this format:</span></p>
			<p><span class="No-Break"><strong class="source-inline">force://&lt;clientId&gt;:&lt;clientSecret&gt;:&lt;refreshToken&gt;@&lt;instanceUrl&gt;</strong></span></p>
			<p>The URL uses <strong class="source-inline">force://</strong> instead of http:// or <strong class="source-inline">https://</strong>, and <strong class="source-inline">instanceUrl</strong> does not include <strong class="source-inline">https://</strong>. It is just the <span class="No-Break">domain name.</span></p>
			<p>The next step authenticates with the Salesforce org using the newly created file, which contains the authorization<a id="_idIndexMarker310"/> URL, and gives it the <span class="No-Break">alias </span><span class="No-Break"><strong class="source-inline">HubOrg</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
- name: Authenticate to Salesforce
        run: |
           sf auth sfdxurl store -f DEVHUB_SFDX_URL.txt -a HubOrg</pre>			<p>Having authenticated our Dev Hub, we are now able to automatically generate a new scratch org for our testing needs and transfer our code <span class="No-Break">into it:</span></p>
			<pre class="source-code">
- name: Create A New Scratch Org
        run: |
           sf org create scratch --target-dev-hub HubOrg --set-default --definition-file config/project-scratch-def.json --alias ciorg --wait=10
      - name: Push changes to new Scratch Org
        run: |
           sf project deploy start --target-org ciorg</pre>			<p>With this new scratch org in place, with the <strong class="source-inline">ciorg</strong> alias, we can execute our <span class="No-Break">Apex tests:</span></p>
			<pre class="source-code">
- name: Run all Apex tests
        run: |
           sf apex run test -o ciorg -l RunLocalTests -r tap -d test-results</pre>			<p>Finally, we delete the scratch org when we’ve finished. This is an important step, since Salesforce enforces limits on how many active scratch orgs you can have in each <span class="No-Break">Dev Hub:</span></p>
			<pre class="source-code">
- name: Delete scratch org
        run: |
           sf org delete scratch --target-org ciorg --no-prompt</pre>			<p>Each step within a job operates in its own distinct context. However, using GitHub workflow syntax, these individual steps can be orchestrated to interact and cooperate with each other. The<a id="_idIndexMarker311"/> workflow configuration provides the ability to establish dependencies between steps, such as specifying that a step must wait for the successful completion of another before it starts. It also allows one step to utilize the output from another, among other interactions. This flexible configuration enables complex automated processes to be built from a collection of <span class="No-Break">individual steps.</span></p>
			<p>GitHub Actions provides a versatile platform for tailoring your CI/CD pipeline when working with SFDX. With its capability to run a wide array of tasks, from executing shell commands to running scripts or even third-party software, GitHub Actions can be uniquely customized to fit your <span class="No-Break">specific needs.</span></p>
			<p>This adaptability is also applicable to SFDX, where you can utilize GitHub Actions to automate numerous tasks. These can include executing unit tests, deploying code to various environments, and even overseeing data migration. By leveraging the power of GitHub Actions, you can create an efficient, reliable, and automated CI/CD pipeline that enhances the development and deployment process for your <span class="No-Break">SFDX projects.</span></p>
			<p>While the preceding steps will provide you with a basic automated workflow for using GitHub Actions for your Salesforce CI/CD needs, you can extend it with more automated testing, static code analysis, approval processes, and more. You find extensive documentation and tutorials in the official GitHub Actions documentation <span class="No-Break">at </span><a href="https://docs.github.com/en/actions/learn-github-actions"><span class="No-Break">https://docs.github.com/en/actions/learn-github-actions</span></a><span class="No-Break">.</span></p>
			<p>If you want an alternative approach to your CI/CD, you could instead look at Jenkins. It has a considerable number of plugins available, can be self-hosted to give you more control of your<a id="_idIndexMarker312"/> implementation, and has a more intuitive UI to set up and manage your pipeline. In the next section, we’ll look at Jenkins in a little <span class="No-Break">more detail.</span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor170"/>Jenkins</h1>
			<p>Jenkins is an open source automation<a id="_idIndexMarker313"/> server that has solidified its place as an essential tool in the DevOps communit<a id="_idTextAnchor171"/>y. It has been a go-to choice for many organizations due to its extensive feature set, its plugin ecosystem, and the high degree of flexibility and control <span class="No-Break">it offers.</span></p>
			<p>Jenkins is engineered to manage a range of DevOps activities and processes, from a straightforward CI server to a comprehensive CD hub, accommodating any kind of project, regardless of the size or complexity. It allows you to automate the different stages of your delivery pipeline, providing continuous feedback to the project team about the health of <span class="No-Break">their project.</span></p>
			<p>One of the significant advantages of Jenkins is its extensibility through plugins. With over 1,000 plugins in the Update Center, Jenk<a id="_idTextAnchor172"/>ins integrates with practically every tool in the CI/CD toolchain. You can use it to build, test, and deliver code in any language, to any platform. This extensibility makes Jenkins a versatile tool that can adapt to a wide range of <span class="No-Break">project needs.</span></p>
			<p>Jenkins uses a distributed architecture that can easily scale as your needs grow. You can set up Jenkins to distribute work across multiple machines, enabling projects to build, test, and deploy faster. This distributed nature of Jenkins is particularly beneficial for large and <span class="No-Break">complex projects.</span></p>
			<p>Much like GitHub Actions, Jenkins can be configured to handle tasks such as running Apex tests, creating and managing SFDX scratch orgs, and deploying metadata to various Salesforce environments. Jenkins can also be integrated with version control systems, such as Git, enhancing its capabilities within a Salesforce <span class="No-Break">CI/CD pipeline.</span></p>
			<p>The first part of setting up a Jenkins CI/CD pipeline for Salesforce is the installation of Jenkins itself. This varies slightly depending on your operating system. Jenkins is a Java-based application, so it runs on any platform that supports Java. It’s advisable to always ensure that your system packages are up to date before starting any <span class="No-Break">new installations.</span></p>
			<p>If you’re running Ubuntu Linux, the process begins with updating your system packages via the <strong class="source-inline">apt update</strong> and <strong class="source-inline">apt upgrade</strong> commands run in your terminal. You then need to install Java, as Jenkins requires it to run. The OpenJDK package is a good option and can be installed with <strong class="source-inline">apt install openjdk-17-jdk</strong>. At the time of writing, JDK 20 is the most recent version of the Java SE platform. However, JDK 17 LTS holds the status of being the most <a id="_idIndexMarker314"/>up-to-date <strong class="bold">Long-Term Support</strong> (<strong class="bold">LTS</strong>) release for the Java <span class="No-Break">SE platform.</span></p>
			<p>Next, you should add the Jenkins repository to your sources list, which is a prerequisite for the Jenkins installation. You can accomplish this by fetching the Jenkins repository key with the <strong class="source-inline">wget</strong> command <a id="_idIndexMarker315"/>and adding it to your system’s software repository list. The key is required to authenticate and ensure that packages installed on your system are from a trusted source. You can download the Jenkins repository key directly from Jenkins’ own servers with the following <strong class="source-inline">wget</strong> command in <span class="No-Break">your terminal:</span></p>
			<pre class="source-code">
wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add –</pre>			<p>The <strong class="source-inline">-q</strong> option tells <strong class="source-inline">wget</strong> to operate quietly, meaning it won’t output progress information. The <strong class="source-inline">-O -</strong> option tells it to write the downloaded content to standard output, represented by <strong class="source-inline">-</strong>. This content is then piped, using the <strong class="source-inline">|</strong> symbol, into the <strong class="source-inline">sudo apt-key add -</strong> command, which adds the key to your system’s list of <span class="No-Break">trusted keys.</span></p>
			<p>Next, you need to add the Jenkins repository to your system’s software repository list. This is done by appending the Jenkins repository URL to the list of repositories stored in the <strong class="source-inline">/etc/apt/sources.list.d/</strong> directory. You can do this with the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
echo deb http://pkg.jenkins.io/debian-stable binary/ | sudo tee /etc/apt/sources.list.d/jenkins.list</pre>			<p>The <strong class="source-inline">echo</strong> command prints its argument, in this case, the Jenkins repository URL and the type of packages to use (binary). This output is piped into the <strong class="source-inline">sudo tee</strong> command. The <strong class="source-inline">tee</strong> command is used to append the input it receives to a file, in this case, the <strong class="source-inline">jenkins.list</strong> file in the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">etc/apt/sources.list.d/</strong></span><span class="No-Break"> directory.</span></p>
			<p>Once these commands have been run, your system’s package manager is set up to install Jenkins and keep it updated. The next step would be to update the package list with <strong class="source-inline">sudo apt update</strong>, and then you can proceed with installing Jenkins via <strong class="source-inline">sudo apt </strong><span class="No-Break"><strong class="source-inline">install jenkins</strong></span><span class="No-Break">.</span></p>
			<p>For macOS users, you’ll first need to install Homebrew, a package manager that simplifies the installation of software on macOS. Once Homebrew is installed, you can use it to install OpenJDK, and then Jenkins itself. Just like with Ubuntu, once Jenkins is installed, you should start the service and make sure it’s set to start automatically when the <span class="No-Break">system boots.</span></p>
			<p>On Windows, the process is slightly different. You’ll need to download the Jenkins WAR file directly from the Jenkins website and have the latest version of JDK installed from Oracle’s website. After setting up the <strong class="source-inline">JAVA_HOME</strong> environment variable, you can run Jenkins by navigating to the directory where the Jenkins WAR file is stored and using the <strong class="source-inline">java -</strong><span class="No-Break"><strong class="source-inline">jar</strong></span><span class="No-Break"> command.</span></p>
			<p>In all three cases, once Jenkins is running, you can access the Jenkins dashboard by navigating to http://localhost:8080 in a web browser. You’ll be guided through the rest of the setup <a id="_idIndexMarker316"/>process, which includes setting up an admin user and configuring <span class="No-Break">security settings.</span></p>
			<p>After Jenkins is installed and running, you’ll need to prepare it for SFDX. SFDX comprises a suite of tools designed to enhance and simplify all stages of the development and deployment process. It requires the Salesforce CLI, so you’ll need to install that on the same machine as Jenkins. We covered the installation of the Salesforce CLI earlier, in <a href="B19436_05.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, if you need a reminder of <span class="No-Break">the process.</span></p>
			<p>Once the Salesforce CLI is installed, you’ll need to ensure Jenkins can interact with it. This is done by adding the path to the Salesforce CLI in the Jenkins system configuration settings. You can navigate to these settings via the <strong class="bold">Manage Jenkins</strong> | <strong class="bold">Configure System</strong> menu on the <span class="No-Break">Jenkins dashboard.</span></p>
			<p>Jenkins operates by using plugins for specific tasks and integrations. For SFDX, the key plugins you need to install are the Pipeline plugin, the Git plugin, and, depending on your choice of version control solution, either the GitHub plugin, the Bitbucket plugin, or any plugins that may be specific to your Git provider. In this example, we’re going to focus on the GitHub option. The Pipeline plugin enables the creation of CD pipelines in Jenkins, while the Git and GitHub plugins enable Jenkins to interact with <span class="No-Break">Git repositories.</span></p>
			<p>These plugins can be installed via the <strong class="bold">Manage Plugins </strong>menu in the Jenkins dashboard. After they’re installed, Jenkins will be able to interact with SFDX and pull code from a GitHub repository, forming the basis of your <span class="No-Break">CI/CD pipeline.</span></p>
			<p>The addition of Git support via the plugin enables Jenkins to monitor a Git repository for changes, pull those changes when they occur, and then take certain actions based on those changes. Jenkins achieves this by using webhooks and polling. Webhooks are triggers that are sent from GitHub to Jenkins when a change occurs, while polling means Jenkins will periodically ask GitHub whether there has been <span class="No-Break">a change.</span></p>
			<p>To set up a webhook, you’ll need to navigate to your repository on GitHub, go to the <strong class="bold">Settings</strong> tab, and then go to the <strong class="bold">Webhooks</strong> menu. From there, you can add a new webhook, with the payload URL pointing to your Jenkins instance followed by <strong class="source-inline">/github-webhook/</strong> (e.g., <a href="http://your-jenkins-url/github-webhook/">http://your-jenkins-url/github-webhook/</a>). Make sure <strong class="bold">Content Type</strong> is set to <strong class="source-inline">application/json</strong> and the events you are interested in are selected (such as <strong class="source-inline">Just the </strong><span class="No-Break"><strong class="source-inline">push event</strong></span><span class="No-Break">).</span></p>
			<p>If webhooks are not <a id="_idIndexMarker317"/>an option due to network restrictions, you can opt to have Jenkins periodically poll GitHub for changes. This is done through the <strong class="bold">Poll SCM </strong>option in the <span class="No-Break">job configuration.</span></p>
			<p>The actions that Jenkins takes in response to detected changes are defined in a <strong class="bold">Jenkinsfile</strong>, which <a id="_idIndexMarker318"/>contains all the stages of your Jenkins pipeline. It’s checked into source control, providing an easy way to version it and allowing it to be shared across <span class="No-Break">multiple jobs.</span></p>
			<p>A basic Jenkinsfile for a CI/CD workflow – pulling changes, running unit tests, checking whether they pass, and then deploying to the next environment if they do – might look something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
#!groovy
node
{
    def SF_CONSUMER_KEY = env.CONNECTED_APP_CONSUMER_KEY_DH
    def SERVER_KEY_CREDENTALS_ID = env.JWT_CRED_ID_DH
    def TEST_LEVEL = 'RunAllTestsInOrg'
    def SF_INSTANCE_URL = env.SFDC_HOST_DH
    def SF_USERNAME = env.HUB_ORG_DH
    def sfd<a id="_idTextAnchor173"/>xcli = tool 'sf'</pre>			<p>In this first section, we set up some variables. As we’re referencing credentials, it’s recommended that you don’t hardcode them into the Jenkinsfile but, instead, pull them from environment variables on the server that is running Jenkins. Once these are set up, we can start with the first stage of our pipeline, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
    stage('Pull changes')
    {
            echo 'Pulling changes from the repository'
            checkout scm
    }</pre>			<p>This first stage of the pipeline simply pulls the latest changes from our source control, ready for Jenkins to work with. In the next section of the file, we can wrap everything else with the set of credentials we wish to use for interacting with Salesforce, so that all the stages contained<a id="_idIndexMarker319"/> inside the code block use the same details. These credentials are supplied in the<a id="_idIndexMarker320"/> form of a <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) file and then added to the configuration with a reference to that file – instructions on creating this, as well as a connected app within Salesforce, can be found in the official documentation <span class="No-Break">at </span><a href="https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ci_jenkins_config_env.htm"><span class="No-Break">https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ci_jenkins_config_env.htm</span></a><span class="No-Break">:</span></p>
			<pre class="source-code">
    withCredentials([file(credentialsId: SERVER_KEY_CREDENTALS_ID, variable: 'jwt_key_file')])</pre>			<p>With these credentials in place, we can do a similar thing with the working environment, so that all commands run in the context of the code we just retrieved from <span class="No-Break">source control:</span></p>
			<pre class="source-code">
    {
        withEnv(["HOME=${env.WORKSPACE}"])</pre>			<p>Now that we have our build environment in place, we can start moving the code to our Salesforce environment. In this first step, shown as follows, we use our credentials to authenticate to our SFDX <span class="No-Break">Dev Hub:</span></p>
			<pre class="source-code">
        {
            stage('Auth to Salesforce')
            {
                    echo 'Authenticating to Salesforce'
                     rc = bat returnStatus: true, script: "\"${toolbelt}\\sfdx\" force auth jwt grant -i ${SF_CONSUMER_KEY} --username ${SF_USERNAME} -f \"${jwt_key_file}\" -d -r ${SF_INSTANCE_URL} -a HubOrg"
                    if (rc != 0) { error 'hub org authorization failed' }
                    println rc
            }</pre>			<p>Once our Dev Hub is<a id="_idIndexMarker321"/> authenticated, we are able to create a new scratch org for our code testing, <span class="No-Break">as shown:</span></p>
			<pre class="source-code">
            stage('Create scratch org')
            {
                        echo 'Creating scratch org'
                        script
                        {
                             rc = bat returnStatus: true, script: "\"${toolbelt}\\sf\" org create scratch --target-dev-hub HubOrg --set-default --definition-file config/project-scratch-def.json --alias ciorg --wait=10"
                            if (rc != 0)
                            {
                                error 'Salesforce test scratch org creation failed.'
                            }
                            println rc
                        }
            }</pre>			<p>We can now push our<a id="_idIndexMarker322"/> changes to the newly created scratch org in the next stage, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
            stage('Push To Test Scratch Org')
            {
                echo 'Pushing changes to test scratch org'
                    script
                    {
                         rc = bat returnStatus: true, script: "\"${toolbelt}\\sf\" project deploy start --target-org ciorg"
                        if (rc != 0)
                        {
                            error 'Salesforce push to test scratch org failed.'
                        }
                        println rc
                    }
            }</pre>			<p>At this point, we have a freshly created scratch org populated with our latest changes. We can use this to run the full suite of unit tests and ensure our tests pass, with another section in our CI/CD pipeline, <span class="No-Break">as</span><span class="No-Break"><a id="_idIndexMarker323"/></span><span class="No-Break"> follows:</span></p>
			<pre class="source-code">
            stage('Run tests in scratch org')
            {
                echo 'Running tests in scratch org at test level ${TEST_LEVEL}'
                    script
                    {
                        rc = bat returnStatus: true, script: "\"${sfdxcli}\\sf\" apex run test -o ciorg -l ${TEST_LEVEL} -r tap -d test-results"
                        if (rc != 0)
                        {
                            error 'Salesforce test run failed.'
                        }
                        println rc
                    }
            }</pre>			<p>Finally, we tidy up by deleting the scratch org – this helps preserve the number of active scratch orgs governor limit in our Salesforce <span class="No-Break">dev hub:</span></p>
			<pre class="source-code">
            stage('Delete scratch org')
            {
                echo 'Deleting scratch org'
                    script
                    {
                         rc = bat returnStatus: true, script: "\"${toolbelt}\\sf\" org delete scratch --target-org ciorg --no-prompt"
                        if (rc != 0)
                        {
                            error 'Salesforce test scratch org deletion failed.'
                        }
                        println rc
                    }
            }
        }
    }
}</pre>			<p>This Jenkinsfile uses a declarative pipeline syntax, which has a more rigid structure than the scripted pipeline syntax. It begins with the node keyword, indicating the start of <span class="No-Break">the pipeline.</span></p>
			<p>Each stage contains one or more steps to be performed. As you can see, this structure is like that of GitHub Actions, which we covered in the <span class="No-Break">previous section.</span></p>
			<p>The <strong class="source-inline">checkout scm</strong> command is a built-in Jenkins command that fetches the source code from the repository defined in the <span class="No-Break">Jenkins job.</span></p>
			<p>The various other steps run commands in the Salesforce CLI. This is a very basic example; a real-world Jenkinsfile would be more complex. For example, you might want to add error handling, send notifications based on the job result, or add stages for things such as code analysis or integration testing. It’s worth noting that Jenkins, while enormously powerful, is more complex than setting up GitHub Actions, and it’s worth spending time getting<a id="_idIndexMarker324"/> familiar with the tool and how Jenkinsfiles work in more detail.  The official Jenkins website at <a href="https://jenkins.io">https://jenkins.io</a> has a wealth of material to guide you, not least of which is the Jenkins Handbook – <a href="https://www.jenkins.io/doc/book/"><span class="No-Break">https://www.jenkins.io/doc/book/</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor174"/>Salesforce-specific tools</h1>
			<p>In the world of<a id="_idIndexMarker325"/> Salesforce development, there is an essential need for tools specifically designed to accommodate Salesforce’s unique architecture and development paradigm. Two of these tools that hold particular importance are SFDX and the Salesforce CLI, acting as central figures in the Salesforce development process and enhancing the efficiency of <span class="No-Break">CI/CD pipelines.</span></p>
			<p>SFDX, which is an approach to Salesforce development supported by a suite of development tools provided by Salesforce, not only fosters source-driven development but also facilitates team collaboration and orchestrates testing and deployment continuously. It’s built with an ecosystem-centric approach, ensuring seamless integration with other tools within the DevOps landscape. The Salesforce CLI, a fundamental component of SFDX, serves as a command-line tool that allows the scripting of a multitude of tasks across Salesforce orgs, ranging from creating scratch orgs and managing data to executing <span class="No-Break">Apex code.</span></p>
			<p>The real potential of SFDX and the Salesforce CLI unfolds when integrated with external CI/CD tools such as Jenkins and GitHub Actions. These tools, although powerful, lack an innate understanding of Salesforce’s metadata-driven and multi-tenant architecture. That’s precisely where SFDX and the CLI step in, bridging the gap between these external tools and the <span class="No-Break">Salesforce-specific tasks.</span></p>
			<p>Imagine a scenario where a developer pushes code to a GitHub repository. GitHub Actions could initiate a workflow, leveraging the Salesforce CLI to create a new scratch org, push the updated code, and execute Apex tests. Similarly, Jenkins can incorporate Salesforce CLI commands within its build steps, enabling it to handle tasks such as creating and managing scratch orgs or <span class="No-Break">deploying metadata.</span></p>
			<p>Beyond triggering actions and facilitating workflows, SFDX and the Salesforce CLI also enforce best practices in Salesforce development. SFDX’s source-driven approach encourages developers to rely on version control systems as the source of truth. The Salesforce CLI, with its broad command range, promotes automation, thereby reducing errors and enhancing the quality of your Salesforce <span class="No-Break">code base.</span></p>
			<p>Both SFDX and the Salesforce CLI are continuously updated by Salesforce. They remain tightly integrated with Salesforce’s own development, always staying aligned with the latest Salesforce features and improvements. Therefore, by incorporating these tools into your CI/CD pipeline, you are not just addressing today’s needs but are also poised to harness future advancements in <span class="No-Break">Salesforce development.</span></p>
			<p>SFDX and the Salesforce CLI serve as invaluable tools in constructing an efficient and effective CI/CD pipeline for Salesforce. They provide the critical link between the Salesforce platform and external CI/CD tools such as Jenkins and GitHub Actions, enabling them to handle Salesforce-specific tasks. By capitalizing on these tools, you can build a robust, automated, and future-proof CI/CD pipeline, revolutionizing your Salesforce development <a id="_idIndexMarker326"/>process, reducing manual effort, minimizing errors, and <span class="No-Break">accelerating delivery.</span></p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor175"/>Practical use of the CI/CD pipeline</h1>
			<p>Once an automated <a id="_idIndexMarker327"/>CI/CD pipeline is in place for Salesforce development, new disciplines and practices can emerge to take full advantage of its capabilities. The most immediate benefit is the real-time visibility that the pipeline dashboard provides into the health of the entire process. Build statuses, test results, deployment records, and other key indicators can be monitored to quickly identify pipeline failures and rapidly troubleshoot any issues before they become <span class="No-Break">major problems.</span></p>
			<p>Increased visibility facilitates practices such as incorporating quality gates into the process. Required standards such as code coverage thresholds can be enforced, ensuring quality before releases. With CI, developers gain the confidence to merge code frequently into a shared mainline repository, promoting effective <span class="No-Break">trunk-based development.</span></p>
			<p>Another major advantage is how the pipeline tightens and shortens feedback loops. Automated testing and rapid build/deploy cycles mean developers get near-instant feedback on any changes. Issues can be identified and fixed immediately, before more work <span class="No-Break">piles up.</span></p>
			<p>Automation also reduces risk when releasing frequently. Advanced teams can implement automated rollback procedures to instantly reverse bad deployments directly from the pipeline. Of course, data from pipeline metrics can be analyzed to find opportunities for tuning – key indicators such as lead time, deployment frequency, and change failure rate reveal areas for <span class="No-Break">continuous improvement.</span></p>
			<p>With the new visibility and automation the pipeline facilitates, developers are freed from tedious manual quality checks to focus their energy on writing great code. They can release faster with confidence, knowing automation is handling testing, quality enforcement, and promotion up the pipeline behind the scenes. This allows teams to fully leverage modern<a id="_idIndexMarker328"/> development practices that <span class="No-Break">increase agility.</span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor176"/>Summary</h1>
			<p>In this chapter, we’ve explored a couple of solutions to implement a Salesforce CI/CD pipeline, using freely available tools. In looking at the setup for both GitHub Actions and Jenkins, we saw that the fundamental steps of the pipeline are the same, but with differences in the <span class="No-Break">specific implementation.</span></p>
			<p>We’ve also seen that these tools depend heavily on the Salesforce CLI tool and the SFDX approach to managing your metadata, to carry out the steps that make up the CI/CD pipeline. Of course, the use of SFDX is not mandatory – anything that leverages the Metadata API could be used instead, but it’s worth noting that building the necessary scripts to manage this entire process represents a significant development and maintenance effort by whoever is responsible for managing your DevOps toolchain. This can be mitigated by adopting DevOps solutions and platforms that are designed to work specifically with Salesforce only. We’ll cover some of the options on the market in <span class="No-Break">later chapters.</span></p>
			<p>In the next chapter, we’ll continue to round out our overall DevOps implementation by looking at ticketing systems, which allow for better management of work items and not only help bring a clearer picture of progress on your development changes but also contribute to breaking those changes up into smaller units of work, which lends itself to the DevOps principle of releasing early <span class="No-Break">and often.</span></p>
		</div>
	</body></html>