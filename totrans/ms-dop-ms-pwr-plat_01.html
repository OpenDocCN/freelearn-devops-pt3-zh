<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/><st c="0">1</st></h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/><st c="2">Mastering DevOps and ALM for Efficient Software Development</st></h1>
			<p><st c="61">Software development practices and methodologies have evolved a lot since the first program was written on punch cards. </st><st c="182">Nowadays, every business process in every industry vertical runs on software and we cannot even imagine our life without applications, as they are used in almost every interaction with our world. </st><st c="378">Digital transformation has been accelerated during the pandemic and the demand to create more applications has risen to a level that cannot be fulfilled exclusively by traditional software development tools and frameworks. </st><st c="601">Today, every organization is a software development company regardless of its industry thanks to the global </st><span class="No-Break"><st c="709">digital transformation.</st></span></p>
			<p><st c="732">In this chapter, we will</st><a id="_idIndexMarker000"/><st c="757"> explore </st><strong class="bold"><st c="766">Application Life Cycle Management</st></strong><st c="799"> (</st><strong class="bold"><st c="801">ALM</st></strong><st c="804">) in the context of software development. </st><st c="847">We begin with an overview of </st><strong class="bold"><st c="876">Software Development Life Cycle </st></strong><st c="908">(</st><strong class="bold"><st c="909">SDLC</st></strong><st c="913">), followed </st><a id="_idIndexMarker001"/><st c="926">by a discussion of various software development methodologies. </st><st c="989">We will then delve into the concept of ALM, examining it from the perspective of the SDLC and the journey from requirement engineering through development and testing to production and maintenance. </st><st c="1187">This knowledge is crucial as it equips us with the understanding needed to effectively manage and streamline the process of planning, creating, testing, and deploying an application of any kind. </st><st c="1382">We will also explore the origin of the Lean concept, a philosophy that emphasizes creating value for customers and eliminating waste and that originated in the car </st><span class="No-Break"><st c="1546">manufacturing industry.</st></span></p>
			<p><st c="1569">We will then introduce the Agile manifesto and the Scrum methodology, which are key frameworks in modern software development practices. </st><st c="1707">We will further learn about DevOps-enabled architecture, including various design patterns and non-functional requirements such</st><a id="_idIndexMarker002"/><st c="1834"> as testability and deployability. </st><st c="1869">We will also cover </st><strong class="bold"><st c="1888">Continuous Integration</st></strong><st c="1910"> (</st><strong class="bold"><st c="1912">CI</st></strong><st c="1914">) and </st><strong class="bold"><st c="1921">Continuous Deployment</st></strong><st c="1942"> (</st><strong class="bold"><st c="1944">CD</st></strong><st c="1946">), two </st><a id="_idIndexMarker003"/><st c="1954">practices that automate the stages of app production. </st><st c="2008">Finally, we will discuss the </st><a id="_idIndexMarker004"/><st c="2037">concepts of </st><strong class="bold"><st c="2049">Release Trains</st></strong><st c="2063"> and </st><strong class="bold"><st c="2068">release cycles</st></strong><st c="2082">, which </st><a id="_idIndexMarker005"/><st c="2090">are strategies for managing the release of new features in a coordinated and predictable manner. </st><st c="2187">This knowledge will help us streamline the development processes and improve </st><span class="No-Break"><st c="2264">product quality.</st></span></p>
			<p><st c="2280">By the end of this chapter, we will have gained familiarity with state-of-the-art application development processes, and patterns, as well as cutting-edge DevOps (bringing </st><strong class="bold"><st c="2453">dev</st></strong><st c="2456"> and </st><strong class="bold"><st c="2461">ops</st></strong><st c="2464"> teams</st><a id="_idIndexMarker006"/><st c="2470"> together to continuously deliver value to our customers) and </st><a id="_idIndexMarker007"/><span class="No-Break"><st c="2532">ALM practices.</st></span></p>
			<p><st c="2546">In this chapter, we’re going to cover the following </st><span class="No-Break"><st c="2599">main topics:</st></span></p>
			<ul>
				<li><st c="2611">SDLC – what it is </st><span class="No-Break"><st c="2630">all about</st></span></li>
				<li><st c="2639">Overview of Software </st><span class="No-Break"><st c="2661">development methodo</st><a id="_idTextAnchor016"/><st c="2680">logies</st></span></li>
				<li><st c="2687">What </st><span class="No-Break"><st c="2693">is ALM?</st></span></li>
				<li><st c="2700">Lean principles, the Agile manifesto, and </st><span class="No-Break"><st c="2743">Scrum methodology</st></span></li>
				<li><st c="2760">DevOps-enabled </st><span class="No-Break"><st c="2776">architecture patterns</st></span></li>
				<li><st c="2797">CI </st><span class="No-Break"><st c="2801">and CD</st></span></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/><st c="2807">SDLC – what it is all about</st></h1>
			<p><st c="2835">SDLC, which is</st><a id="_idIndexMarker008"/><st c="2850"> sometimes also referred to as </st><a id="_idIndexMarker009"/><st c="2881">the </st><strong class="bold"><st c="2885">software development process</st></strong><st c="2913">, is the systematic methodology used to produce quality software cost-effectively. </st><st c="2996">We can use several methodologies developed in the last few decades to develop or modify </st><span class="No-Break"><st c="3084">computer systems.</st></span></p>
			<p><st c="3101">Originally, the concept was created in the 1960s. </st><st c="3152">Its main goal was to establish a repeatable, auditable, and, at that time, sequential software development process that covered the steps from the ideation of the application to the delivery of the final solution by targeting corporate mainframes. </st><st c="3400">Since then, many enhancements, innovations, and inventions have been implemented starting with the introduction of object-oriented programming languages through DevOps and DevSecOps practices to cloud-native architectures, which led to newer and newer SDLC methodologies. </st><st c="3672">As a result of the continuous process improvement, most modern software development methodologies follow Agile </st><span class="No-Break"><st c="3783">principles nowadays.</st></span></p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor018"/><st c="3803">Phases</st></h2>
			<p><st c="3810">Regardless of the selected software development methodology, the stages (phases) of the software development process are </st><span class="No-Break"><st c="3932">the same:</st></span></p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B22208_01_001.jpg" alt="Figure 1.1 –  The software development phases"/><st c="3941"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="4030">Figure 1.1 –  The software development phases</st></p>
			<p><st c="4074">Let us discover </st><span class="No-Break"><st c="4091">these phases:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="4104">Requirement analysis</st></strong><st c="4125"> or </st><a id="_idIndexMarker010"/><st c="4129">requirement engineering is the step in which the development team collects customer requirements and objectives. </st><st c="4242">The development team works closely with customer representatives to identify the key features of the solution. </st><st c="4353">In this phase, requirements are also analyzed, meaning that needs are validated and documented unambiguously. </st><st c="4463">This phase also covers identifying the non-functional requirements of the system, such as performance, resource needs, or availability expectations. </st><st c="4612">It is a crucial step to ensure that the final product meets the customer’s needs </st><span class="No-Break"><st c="4693">and expectations.</st></span></li>
				<li><st c="4710">The </st><strong class="bold"><st c="4715">planning and design phase</st></strong><st c="4740"> is </st><a id="_idIndexMarker011"/><st c="4744">the one in which the development team creates the project plan with cadence and key deliverables. </st><st c="4842">This process usually ends </st><a id="_idIndexMarker012"/><st c="4868">with a </st><strong class="bold"><st c="4875">Work Breakdown Structure</st></strong><st c="4899"> (</st><strong class="bold"><st c="4901">WBS</st></strong><st c="4904">). </st><st c="4908">The development team then assigns milestones to different parts of the WBS to be able to track the progress at a higher level. </st><st c="5035">A milestone frequently signifies the completion of contractual obligations, leading to financial settlements. </st><st c="5145">In this </st><a id="_idIndexMarker013"/><st c="5153">phase, the team also designs software architecture and </st><strong class="bold"><st c="5208">User Experience</st></strong><st c="5223"> (</st><strong class="bold"><st c="5225">UX</st></strong><st c="5227">). </st><st c="5231">Wireframes for the UI and prototypes for architecture are frequently used to get more input for effort estimations. </st><st c="5347">Another practice to calculate the effort and complexity of the tasks in WBS is to play</st><a id="_idIndexMarker014"/><st c="5433"> so-called </st><strong class="bold"><st c="5444">planning poker</st></strong><st c="5458">. Team members use cards with numbers to assign values to tasks separately. </st><st c="5534">At the end, poker team members reveal their cards and discuss the results until they reach </st><span class="No-Break"><st c="5625">a consensus.</st></span></li>
				<li><st c="5637">The </st><strong class="bold"><st c="5642">development phase</st></strong><st c="5659"> is </st><a id="_idIndexMarker015"/><st c="5663">essentially the coding part. </st><st c="5692">The team implements the application, writes the unit tests, and debugs the code. </st><st c="5773">Traditional methodologies view the development phase as solely for writing code. </st><st c="5854">In contrast, Agile approaches eliminate this separation and incorporate testing and deployment earlier in the process. </st><st c="5973">They do it so that they can repeat the coding-testing-deployment cycle many times in an iterative way. </st><st c="6076">In addition, these modern approaches foster collaboration between development teams and client representatives by providing access to the working software at the end of </st><span class="No-Break"><st c="6245">every iteration.</st></span></li>
				<li><st c="6261">The </st><strong class="bold"><st c="6266">test and quality assurance phase</st></strong><st c="6298"> is </st><a id="_idIndexMarker016"/><st c="6302">about creating different levels of tests for the application. </st><st c="6364">The development team writes and executes integration tests, system tests, end-to-end tests, performance tests, and other non-functional tests, such as resource usage or chaos tests, to validate the system against the defined requirements. </st><st c="6603">In the past, there were dedicated test teams whose main duty was to provide these tests and to ensure that the software meets the customer’s requirements. </st><st c="6758">When </st><a id="_idIndexMarker017"/><st c="6763">the validation passed, the software was ready to deliver </st><span class="No-Break"><st c="6820">to production.</st></span></li>
				<li><st c="6834">The </st><strong class="bold"><st c="6839">deployment phase</st></strong><st c="6855"> is the </st><a id="_idIndexMarker018"/><st c="6863">step in which the development team deploys the solution into the client’s environment. </st><st c="6950">It involves not just installing the system but also configuring it and migrating data from previous solutions in some cases. </st><st c="7075">Deployment can target on-premises or cloud infrastructure. </st><st c="7134">Nowadays, this process is fully automated. </st><st c="7177">The development team conducts user training if needed and hands over the documentation (user manuals) to the </st><span class="No-Break"><st c="7286">customer, too.</st></span></li>
				<li><st c="7300">The </st><strong class="bold"><st c="7305">maintenance phase</st></strong><st c="7322"> is </st><a id="_idIndexMarker019"/><st c="7326">about monitoring the solution in a production environment. </st><st c="7385">Based on the results and customer feedback, the development team provides updates, upgrades, bug fixes, security patches, and even new features. </st><st c="7530">This phase is sometimes referred to as a support period and customers pay additional fees to get those services from </st><a id="_idTextAnchor019"/><span class="No-Break"><st c="7647">development teams.</st></span></li>
			</ul>
			<p class="callout-heading"><st c="7665">Application runtime platform</st></p>
			<p class="callout"><st c="7694">Low-code/no-code platforms</st><a id="_idIndexMarker020"/><st c="7721"> are </st><a id="_idIndexMarker021"/><st c="7726">application runtime platforms</st><a id="_idIndexMarker022"/><st c="7755"> that enable professional developer teams to develop applications of any kind. </st><st c="7834">Since this application development is fully identical to any other custom application development, the same SDLC methodologies can be applied to these low-code or </st><span class="No-Break"><st c="7997">no-code applications.</st></span></p>
			<p><st c="8018">Depending on the software development project, an organization can apply different approaches to their work, from following fixed guidelines to adapting to changing situations. </st><st c="8196">However, in all scenarios, the aforementioned phases are the same. </st><st c="8263">In the next section, we will learn about the </st><span class="No-Break"><st c="8308">most-used methodologies.</st></span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor020"/><st c="8332">Methodologies</st></h2>
			<p><st c="8346">As we have seen, the SDLC describes the main phases of the software development process, focusing on the question of </st><em class="italic"><st c="8464">why</st></em><st c="8467">, but it does not define </st><em class="italic"><st c="8492">what</st></em><st c="8496"> or </st><em class="italic"><st c="8500">how</st></em><st c="8503"> we should implement those phases. </st><st c="8538">The methodologies tell us what we should deliver and how we should work in those phases </st><span class="No-Break"><st c="8626">in detail.</st></span></p>
			<p><st c="8636">By examining the following two distinct methodologies, we can better understand what each aims to define for software </st><span class="No-Break"><st c="8755">development projects:</st></span></p>
			<ul>
				<li><st c="8776">The Scrum</st><a id="_idIndexMarker023"/><st c="8786"> framework iterates through all the phases of SDLC from requirement analysis, planning, development, testing, and deployment to maintenance every </st><span class="No-Break"><st c="8932">2-4 weeks</st></span></li>
				<li><st c="8941">The waterfall methodology</st><a id="_idIndexMarker024"/><st c="8967"> only goes through the SDLC phases once in a sequential way and it takes several months or sometimes </st><span class="No-Break"><st c="9068">even years</st></span></li>
			</ul>
			<p><st c="9078">Some of the major methodologies include the following, in </st><span class="No-Break"><st c="9137">chronological order:</st></span></p>
			<ul>
				<li><span class="No-Break"><st c="9157">Waterfall</st></span></li>
				<li><span class="No-Break"><st c="9167">V-model</st></span></li>
				<li><span class="No-Break"><st c="9175">XP</st></span></li>
				<li><st c="9178">Iterative and </st><span class="No-Break"><st c="9193">incremental development</st></span></li>
				<li><span class="No-Break"><st c="9216">Agile (Scrum)</st></span></li>
			</ul>
			<p><st c="9230">In the next sections, we will learn more about these frameworks and methodologies, and how they could be applied to low-code/no-code platforms, such as Microsoft </st><span class="No-Break"><st c="9393">Power Platform.</st></span></p>
			<h3><st c="9408">Waterfall</st></h3>
			<p><st c="9418">This is the oldest software </st><a id="_idIndexMarker025"/><st c="9447">development process that defines the software</st><a id="_idIndexMarker026"/><st c="9492"> development phases sequentially </st><span class="No-Break"><st c="9525">and rigorously.</st></span></p>
			<p><st c="9540">It is very often criticized for its rigidity and sequential method. </st><st c="9609">As we will see, all upcoming methodologies have tried to improve on this original approach in different ways, but it has also some advantages foremost in software development projects, such as writing kernel drivers or programming mission-critical applications, such as nuclear plant software. </st><st c="9903">The following figure visualizes those development phases in the waterfall model that were discussed earlier in </st><span class="No-Break"><st c="10014">this chapter:</st></span></p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B22208_01_002.jpg" alt="Figure 1.2 – The waterfall model"/><st c="10027"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="10129">Figure 1.2 – The waterfall model</st></p>
			<p><st c="10161">The</st><a id="_idIndexMarker027"/><st c="10165"> phases, requirement analysis, planning and design, development, testing and </st><a id="_idIndexMarker028"/><st c="10242">quality assurance, deployment, and maintenance, are equivalent to the phases described earlier in this chapter. </st><st c="10354">The difference is the sequential execution order of </st><span class="No-Break"><st c="10406">those phases.</st></span></p>
			<p><st c="10419">The pros of this model are </st><span class="No-Break"><st c="10447">as follows:</st></span></p>
			<ul>
				<li><st c="10458">It is a</st><a id="_idIndexMarker029"/><st c="10466"> preferred methodology for mission- or </st><span class="No-Break"><st c="10505">business-critical projects.</st></span></li>
				<li><st c="10532">It is preferred when </st><em class="italic"><st c="10554">repetitive</st></em><st c="10564"> application development is required. </st><st c="10602">This occurs when projects are highly similar, such as developing kiosk applications or writing embedded software. </st><st c="10716">In these cases, the requirements and customer expectations are well understood, and no changes </st><span class="No-Break"><st c="10811">are anticipated.</st></span></li>
				<li><st c="10827">Project </st><a id="_idIndexMarker030"/><st c="10836">milestones and deadlines are </st><span class="No-Break"><st c="10865">clearly defined.</st></span></li>
			</ul>
			<p><st c="10881">The cons</st><a id="_idIndexMarker031"/><st c="10890"> are </st><span class="No-Break"><st c="10895">as follows:</st></span></p>
			<ul>
				<li><st c="10906">Big upfront </st><span class="No-Break"><st c="10919">design cost</st></span></li>
				<li><st c="10930">Customer expectations cannot be considered after </st><span class="No-Break"><st c="10980">requirement analysis</st></span></li>
				<li><st c="11000">Time-to-market is huge; it is measured in years and can result in </st><span class="No-Break"><st c="11067">outdated deliveries</st></span></li>
				<li><st c="11086">Testing </st><a id="_idIndexMarker032"/><st c="11095">does not take </st><a id="_idIndexMarker033"/><st c="11109">place until the end of </st><span class="No-Break"><st c="11132">the SDLC</st></span></li>
			</ul>
			<p><st c="11140">In spite of the aforementioned cons, even in low-code/no-code platforms, we can use this methodology to create our applications using the foundation provided by </st><span class="No-Break"><st c="11302">the platform.</st></span></p>
			<h3><st c="11315">V-model</st></h3>
			<p><st c="11323">This model is an </st><a id="_idIndexMarker034"/><st c="11341">enhancement of </st><a id="_idIndexMarker035"/><st c="11356">the previous one to improve the </st><a id="_idIndexMarker036"/><st c="11388">time-to-market </st><strong class="bold"><st c="11403">Key Performance Indicator</st></strong><st c="11428"> (</st><strong class="bold"><st c="11430">KPI</st></strong><st c="11433">) with high software quality by introducing parallel activities in </st><span class="No-Break"><st c="11501">the process.</st></span></p>
			<p><st c="11513">The following figure shows the process </st><span class="No-Break"><st c="11553">in detail:</st></span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B22208_01_003.jpg" alt="Figure 1.3 – A V-model"/><st c="11563"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="11693">Figure 1.3 – A V-model</st></p>
			<p><st c="11715">Everything</st><a id="_idIndexMarker037"/><st c="11726"> starts with the decomposition of the requirements (the domain space) into modules or components that can be implemented separately. </st><st c="11859">The </st><a id="_idIndexMarker038"/><st c="11863">V-model expects modular architecture, but not necessarily loosely coupled architectures in which those components are considered subsystems of the large system design. </st><st c="12031">Low-code/no-code platforms, such as Microsoft Power Platform, provide built-in tools for testing and validation, which can help developers ensure that their applications meet the requirements and function as intended. </st><st c="12249">In a low-code/no-code environment, the V-model can be realized by following a structured development process that includes requirements analysis, design, development, testing, and deployment. </st><st c="12441">Each phase of the process can be completed using the tools and features provided by the low-code/no-code platform, allowing developers to build, test, and deploy their applications in a streamlined and </st><span class="No-Break"><st c="12643">efficient manner.</st></span></p>
			<p><st c="12660">There is a corresponding V-model definition for US government institutions as part of the US Government Standard. </st><st c="12775">It is more detailed and stricter than the original V-model definition to fulfill the US </st><span class="No-Break"><st c="12863">government’s requirements.</st></span></p>
			<p><st c="12889">The pros are </st><span class="No-Break"><st c="12903">as follows:</st></span></p>
			<ul>
				<li><st c="12914">Faster </st><a id="_idIndexMarker039"/><st c="12922">time-to-market with higher </st><span class="No-Break"><st c="12949">overall velocity</st></span></li>
				<li><st c="12965">Built-in </st><span class="No-Break"><st c="12975">quality assurance</st></span></li>
			</ul>
			<p><st c="12992">The cons</st><a id="_idIndexMarker040"/><st c="13001"> are </st><span class="No-Break"><st c="13006">as follows:</st></span></p>
			<ul>
				<li><st c="13017">It is still a </st><span class="No-Break"><st c="13032">rigid process</st></span></li>
				<li><st c="13045">Requirement </st><a id="_idIndexMarker041"/><st c="13058">changes can hardly </st><span class="No-Break"><st c="13077">be managed</st></span></li>
			</ul>
			<h3><st c="13087">Extreme programming</st></h3>
			<p><strong class="bold"><st c="13107">Extreme Programming</st></strong><st c="13127"> (</st><strong class="bold"><st c="13129">XP</st></strong><st c="13131">) as</st><a id="_idIndexMarker042"/><st c="13136"> a software development methodology emphasizes</st><a id="_idIndexMarker043"/><st c="13182"> the need to accelerate the reaction time of the development team to customers’ changing requirements – which is expected in any software development project – by maintaining high </st><span class="No-Break"><st c="13362">software quality.</st></span></p>
			<p><st c="13379">This methodology </st><a id="_idIndexMarker044"/><st c="13397">has become famous because of some paradigm shifts, such as introducing </st><strong class="bold"><st c="13468">pair programming</st></strong><st c="13484"> and strict code reviews, as well as thriving bare minimum </st><a id="_idIndexMarker045"/><st c="13543">architecture solutions, which are called </st><strong class="bold"><st c="13584">Minimum Viable Products</st></strong><st c="13607"> (</st><strong class="bold"><st c="13609">MVPs</st></strong><st c="13613">). </st><st c="13617">Pair programming techniques mean that two developers work together to write the same code. </st><st c="13708">One developer writes the lines, while the other reviews every piece of new code on the fly. </st><st c="13800">The two developers switch between these activities (who writes and who reviews) very often, but eventually, they will work on the same activity in the WBS. </st><st c="13956">The MVP is the bare minimum product, which may have technical debts and architecture violations, that can already demonstrate the features requested by customers or identified by the field. </st><st c="14146">MVPs are used to collect feedback from customers or </st><span class="No-Break"><st c="14198">contractual partners.</st></span></p>
			<p><st c="14219">The goal of an </st><a id="_idIndexMarker046"/><st c="14235">MVP is to test the product’s core assumptions and to evaluate that it has a market fit, that is, that it is valuable to customers. </st><st c="14366">In XP, it is common practice to keep those MVPs as they are and not to do more than expected. </st><st c="14460">The main principles of XP are </st><span class="No-Break"><st c="14490">as follows:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="14501">Customer involvement</st></strong><st c="14522">: XP </st><a id="_idIndexMarker047"/><st c="14528">emphasizes close collaboration between the development team and </st><span class="No-Break"><st c="14592">the customer</st></span></li>
				<li><strong class="bold"><st c="14604">Frequent releases</st></strong><st c="14622">: XP </st><a id="_idIndexMarker048"/><st c="14628">advocates for releasing working software frequently, even if it’s </st><span class="No-Break"><st c="14694">not feature-complete</st></span></li>
				<li><strong class="bold"><st c="14714">Pair programming</st></strong><st c="14731">: XP </st><a id="_idIndexMarker049"/><st c="14737">encourages developers to work in pairs, with one person writing the code and the other </st><span class="No-Break"><st c="14824">reviewing it</st></span></li>
				<li><strong class="bold"><st c="14836">Test-driven development</st></strong><st c="14860">: XP emphasizes creating tests before implementing business logic to </st><a id="_idIndexMarker050"/><st c="14930">ensure that the code meets </st><span class="No-Break"><st c="14957">the requirements</st></span></li>
				<li><strong class="bold"><st c="14973">CI</st></strong><st c="14976">: XP</st><a id="_idIndexMarker051"/><st c="14981"> encourages integrating code changes frequently to catch integration </st><span class="No-Break"><st c="15050">issues early</st></span></li>
			</ul>
			<p><st c="15062">While it is</st><a id="_idIndexMarker052"/><st c="15074"> not specifically designed for low-code/no-code platforms, many of the principles of XP can be applied to development on </st><span class="No-Break"><st c="15195">these platforms.</st></span></p>
			<p class="callout-heading"><st c="15211">XP and low-code/no-code platforms</st></p>
			<p class="callout"><st c="15245">Microsoft Power Platform supports some of these principles as the market leader in low-code/no-code platforms. </st><st c="15357">Even pair programming (the co-authoring feature of PowerApps canvas applications with a YAML-based code editor), test-driven development for canvas apps, and CI are fully adapted </st><span class="No-Break"><st c="15536">into PowerApps.</st></span></p>
			<p><st c="15551">The </st><a id="_idIndexMarker053"/><st c="15556">pros are </st><span class="No-Break"><st c="15565">as follows:</st></span></p>
			<ul>
				<li><st c="15576">It promotes teamwork and collaboration, which can lead to more effective problem-solving </st><span class="No-Break"><st c="15666">and decision-making</st></span></li>
				<li><st c="15685">It emphasizes customer satisfaction, which ensures that the customer gets what they need, that is, that the product exactly meets </st><span class="No-Break"><st c="15816">their expectations</st></span></li>
				<li><st c="15834">It allows for flexibility and adaptability, as changes and new requirements can be incorporated into the development process as </st><span class="No-Break"><st c="15963">they arise</st></span></li>
				<li><st c="15973">It encourages</st><a id="_idIndexMarker054"/><st c="15987"> frequent communication and feedback, which can help identify and address problems early in the </st><span class="No-Break"><st c="16083">development process</st></span></li>
			</ul>
			<p><st c="16102">The </st><a id="_idIndexMarker055"/><st c="16107">cons are </st><span class="No-Break"><st c="16116">as follows:</st></span></p>
			<ul>
				<li><st c="16127">Bare minimum architectural solutions increase overall </st><span class="No-Break"><st c="16182">technical debt</st></span></li>
				<li><st c="16196">It can be challenging to implement in organizations with rigid hierarchies or cultures that do not value teamwork </st><span class="No-Break"><st c="16311">and collaboration</st></span></li>
				<li><st c="16328">It can be difficult to accurately estimate the time and resources required for each iteration, which can make project </st><a id="_idIndexMarker056"/><st c="16447">planning and management </st><span class="No-Break"><st c="16471">more difficult</st></span></li>
			</ul>
			<h3><st c="16485">Iterative and incremental development</st></h3>
			<p><st c="16523">In software development, there are two equally important objectives: </st><strong class="bold"><st c="16593">velocity</st></strong><st c="16601"> and </st><strong class="bold"><st c="16606">quality</st></strong><st c="16613">. We have already seen </st><a id="_idIndexMarker057"/><st c="16636">how </st><a id="_idIndexMarker058"/><st c="16640">quality is built into the processes in the previous methodologies. </st><st c="16707">However, quality means deceleration because it requires time and effort from development teams that could otherwise be spent on creating new features and requirements. </st><st c="16875">That’s why the software industry has introduced the term velocity. </st><st c="16942">Velocity is defined by the number of features (story points) that a team can deliver in a period. </st><st c="17040">This is one of the major KPIs of almost every SDLC methodology and was one of the main drivers that created the incremental and </st><span class="No-Break"><st c="17168">iterative approaches.</st></span></p>
			<p><strong class="bold"><st c="17189">Iterative and incremental development</st></strong><st c="17227"> is </st><a id="_idIndexMarker059"/><st c="17231">a software development methodology that emphasizes breaking down the development process into small, manageable chunks and </st><a id="_idIndexMarker060"/><st c="17354">delivering working software in each iteration. </st><st c="17401">This approach allows for flexibility and adaptability, as changes and new requirements can be incorporated into the development process as </st><span class="No-Break"><st c="17540">they arise.</st></span></p>
			<p><st c="17551">Low-code platforms, such as Microsoft Power Platform, can be used to support iterative and incremental development. </st><st c="17668">These platforms provide building blocks that enable developers to quickly build and deploy applications without the need for extensive coding. </st><st c="17811">This makes it possible to deliver working software quickly and iteratively, allowing for frequent feedback and adaptation. </st><st c="17934">In an iterative and incremental development process using a low-code platform, developers can work on small, manageable chunks of functionality, building and deploying them as they go. </st><st c="18119">This allows for frequent feedback from end users and enables developers to incorporate changes and new requirements into the development process as they arise. </st><st c="18279">The visual development environment provided by low-code platforms makes it easy to make changes and add new functionality, allowing developers to quickly adapt to </st><span class="No-Break"><st c="18442">changing requirements.</st></span></p>
			<p><st c="18464">The pros are</st><a id="_idIndexMarker061"/> <span class="No-Break"><st c="18477">as follows:</st></span></p>
			<ul>
				<li><st c="18489">It allows for </st><a id="_idIndexMarker062"/><st c="18504">early feedback and validation from end users, which ensures that the product exactly meets </st><span class="No-Break"><st c="18595">their expectations</st></span></li>
				<li><st c="18613">It enables developers to incorporate changes and new requirements into the development process as they arise, allowing for greater flexibility </st><span class="No-Break"><st c="18757">and adaptability</st></span></li>
				<li><st c="18773">It reduces the risk of project failure, as problems can be identified and addressed early in the </st><span class="No-Break"><st c="18871">development process</st></span></li>
				<li><st c="18890">It allows</st><a id="_idIndexMarker063"/><st c="18900"> for the delivery of working software quickly and iteratively, providing value to end users and stakeholders early in the </st><span class="No-Break"><st c="19022">development process</st></span></li>
			</ul>
			<p><st c="19041">The cons are </st><span class="No-Break"><st c="19055">as follows:</st></span></p>
			<ul>
				<li><st c="19066">It can </st><a id="_idIndexMarker064"/><st c="19074">be challenging to accurately estimate the time and resources required for each iteration, which can make project planning and management </st><span class="No-Break"><st c="19211">more difficult</st></span></li>
				<li><st c="19225">It requires a high level of collaboration and communication between </st><span class="No-Break"><st c="19294">team members</st></span></li>
				<li><st c="19306">It can be difficult to maintain a consistent vision and direction for the project, as changes and new requirements </st><a id="_idIndexMarker065"/><st c="19422">are incorporated</st><a id="_idIndexMarker066"/><st c="19438"> into the </st><span class="No-Break"><st c="19448">development process</st></span></li>
			</ul>
			<h3><st c="19467">Rapid application development</st></h3>
			<p><strong class="bold"><st c="19497">Rapid Application Development</st></strong><st c="19527"> (</st><strong class="bold"><st c="19529">RAD</st></strong><st c="19532">) was</st><a id="_idIndexMarker067"/><st c="19538"> originally developed as</st><a id="_idIndexMarker068"/><st c="19562"> an alternative approach to the waterfall model and, as its name states, it is about striving for speed and velocity in the software development life cycle. </st><st c="19719">It was officially introduced by James Martin in 1991. </st><st c="19773">The RAD approach emphasizes the swift development of applications through iterative releases and continuous client feedback. </st><st c="19898">By applying agile methodologies and rapid prototyping, RAD ensures software usability, responsiveness to user feedback, and timely delivery. </st><st c="20039">The process-driven nature of RAD, with its focus on </st><strong class="bold"><st c="20091">testing prototypes</st></strong><st c="20109"> and making </st><a id="_idIndexMarker069"/><st c="20121">quick adjustments, enables the delivery of the expected product in a </st><span class="No-Break"><st c="20190">shorter timeframe.</st></span></p>
			<p><st c="20208">Low-code or no-code platforms, such as Microsoft Power Platform, are ideal tools for RAD, since on top of the existing building blocks – such as software components and packages in traditional software development – developers can easily add their customizations and focus on the value </st><span class="No-Break"><st c="20495">creation process.</st></span></p>
			<p><st c="20512">The pros </st><a id="_idIndexMarker070"/><st c="20522">are </st><span class="No-Break"><st c="20526">as </st></span><span class="No-Break"><a id="_idIndexMarker071"/></span><span class="No-Break"><st c="20529">follows:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="20537">Shortened development time and higher team velocity</st></strong><st c="20589">: The RAD approach focuses on rapid prototyping and iterative releases, which can significantly reduce the </st><span class="No-Break"><st c="20697">development time.</st></span></li>
				<li><strong class="bold"><st c="20714">Flexibility and adaptability</st></strong><st c="20743">: The RAD approach allows for changes to be made during the development process, making it more flexible and adaptable to the changing needs of </st><span class="No-Break"><st c="20888">the project.</st></span></li>
				<li><strong class="bold"><st c="20900">Easier risk management</st></strong><st c="20923">: By breaking down the development process into smaller, manageable chunks, issues can be identified and addressed early in the development process, reducing the likelihood of </st><span class="No-Break"><st c="21100">major setbacks.</st></span></li>
				<li><strong class="bold"><st c="21115">Less custom code and shorter testing times</st></strong><st c="21158">: The RAD approach relies on the use of pre-built components and code generation tools, which can reduce the amount of manual </st><span class="No-Break"><st c="21285">coding required.</st></span></li>
				<li><strong class="bold"><st c="21301">Real-time user feedback</st></strong><st c="21325">: The RAD approach allows customers to provide feedback to developers at any time since the development iterations are very fast, and they </st><a id="_idIndexMarker072"/><st c="21465">always produce working software in </st><span class="No-Break"><st c="21500">the end.</st></span></li>
			</ul>
			<p><st c="21508">The cons</st><a id="_idIndexMarker073"/><st c="21517"> are </st><span class="No-Break"><st c="21522">as follows:</st></span></p>
			<ul>
				<li><st c="21533">It may not be applicable to large, complex projects that require detailed planning and design. </st><st c="21629">RAD relies on the reuse of software components, which can limit the flexibility and customization of the </st><span class="No-Break"><st c="21734">final product.</st></span></li>
				<li><st c="21748">RAD may result in a lower-quality product, as the focus on rapid development may lead to shortcuts being taken and compromises being made in the </st><span class="No-Break"><st c="21894">development process.</st></span></li>
				<li><st c="21914">RAD may not be suitable for projects with strict requirements for security, reliability, and performance, as the rapid development process may not allow for thorough testing</st><a id="_idIndexMarker074"/> <span class="No-Break"><st c="22088">and optimization.</st></span></li>
			</ul>
			<p><st c="22106">These disadvantages</st><a id="_idIndexMarker075"/><st c="22126"> are relevant to custom software development projects because the testing prototypes (MVPs) and technical debts are hard-coded into the process. </st><st c="22271">Nowadays, RAD tools provide frameworks and reusable packages in public repositories to support professional developer teams to gain all the benefits of </st><span class="No-Break"><st c="22423">rapid development.</st></span></p>
			<p class="callout-heading"><st c="22441">RAD prosperity</st></p>
			<p class="callout"><st c="22456">Due to the digital transformation demand of enterprises, the world is facing traditional long development timelines and software developer shortages, which means that approximately 4 million developers will be missing from the market by 2025 according to the IDC. </st><st c="22721">Low-code/no-code platforms embrace this opportunity to provide RAD tools for </st><span class="No-Break"><st c="22798">professional developers.</st></span></p>
			<h3><st c="22822">Agile</st></h3>
			<p><st c="22828">Agile</st><a id="_idIndexMarker076"/><st c="22834"> principles emphasize</st><a id="_idIndexMarker077"/><st c="22855"> flexibility, collaboration, and customer satisfaction. </st><em class="italic"><st c="22911">“The only constant is the change”</st></em><st c="22944">, </st><em class="italic"><st c="22946">“test and fail fast”</st></em><st c="22966">, </st><em class="italic"><st c="22968">“individuals and collaboration over processes”</st></em><st c="23014">, and </st><em class="italic"><st c="23020">“a customer-first mindset”</st></em><st c="23046"> are the most widely heard phrases on the topic of the agile </st><span class="No-Break"><st c="23107">development process.</st></span></p>
			<p class="callout-heading"><st c="23127">RAD versus Agile</st></p>
			<p class="callout"><st c="23144">Although the RAD and agile methodologies share some similarities, there are key differences in their approach. </st><st c="23256">RAD</st><a id="_idIndexMarker078"/><st c="23259"> prioritizes the development of prototypes to gather user</st><a id="_idIndexMarker079"/><st c="23316"> feedback, while agile divides the project into smaller features that are delivered incrementally through a series of sprints throughout the </st><span class="No-Break"><st c="23457">development cycle.</st></span></p>
			<p><st c="23475">In the software development life cycle, agile is an iterative approach that focuses on delivering working software frequently with a high level of adaptability to changing requirements. </st><st c="23662">Agile development teams work closely with customers and stakeholders to prioritize features and requirements. </st><st c="23772">They use techniques such as CI, automated testing, and frequent releases to ensure that the software is always in a </st><span class="No-Break"><st c="23888">working state.</st></span></p>
			<p><st c="23902">In an agile development process using a low-code platform, developers can work closely with end users to gather feedback and incorporate changes into the development process as they arise. </st><st c="24092">The visual development environment provided by low-code platforms makes it easy to make changes and add new functionality, allowing developers to quickly adapt to </st><span class="No-Break"><st c="24255">changing requirements.</st></span></p>
			<p><st c="24277">The</st><a id="_idIndexMarker080"/><st c="24281"> pros are </st><span class="No-Break"><st c="24291">as follows:</st></span></p>
			<ul>
				<li><st c="24302">Agile </st><a id="_idIndexMarker081"/><st c="24309">development allows for early feedback and validation from end users, which can help ensure that the final product meets </st><span class="No-Break"><st c="24429">expectations exactly</st></span></li>
				<li><st c="24449">It enables developers to incorporate changes and new requirements into the development process as they arise, allowing for greater flexibility </st><span class="No-Break"><st c="24593">and adaptability</st></span></li>
				<li><st c="24609">It reduces the risk of project failure since issues and risks can be recognized and targeted early in the </st><span class="No-Break"><st c="24716">development process</st></span></li>
				<li><st c="24735">It allows for the delivery of working software quickly and iteratively, providing value to end </st><a id="_idIndexMarker082"/><st c="24831">users and stakeholders early in the </st><span class="No-Break"><st c="24867">development process</st></span></li>
			</ul>
			<p><st c="24886">The cons are </st><a id="_idIndexMarker083"/><span class="No-Break"><st c="24900">as follows:</st></span></p>
			<ul>
				<li><st c="24911">It can be challenging to accurately estimate the time and resources required for each iteration, which can make project planning and management </st><span class="No-Break"><st c="25056">more difficult</st></span></li>
				<li><st c="25070">It requires a high level of collaboration and communication between team members, which can be challenging to achieve in some </st><span class="No-Break"><st c="25197">organizational cultures</st></span></li>
				<li><st c="25220">It can be difficult to maintain a consistent vision and direction for the project, as changes and new requirements are incorporated into the </st><span class="No-Break"><st c="25362">development process</st></span></li>
			</ul>
			<p><st c="25381">One way to comprehend the concept of agile is by comparing it to another SDLC methodology, such as the V-model method. </st><st c="25501">In the V-model approach, the scope of the product is predetermined, while time and resources are adjustable. </st><st c="25610">Organizations using the V-method will increase the number of programmers and extend schedules to deliver the product they have planned to release. </st><st c="25757">On the other hand, in the agile approach, the product’s scope is</st><a id="_idIndexMarker084"/><st c="25821"> adaptable, while resources and time are fixed. </st><st c="25869">Agile teams pledge to deliver software on time with their current team. </st><st c="25941">The product that they deliver is a flexible combination of what they have discovered the customer wants and what they can create within the given </st><span class="No-Break"><st c="26087">time frame.</st></span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor021"/><st c="26098">Agile, Scrum, and Lean</st></h1>
			<p><st c="26121">There have been other concepts, ideas, and perceptions that have significantly influenced the software industry in the last decades. </st><st c="26255">Some of the approaches have been adapted from other industries, such as the Lean management from the Toyota Production System, and others have been created by key members of the software industry. </st><st c="26452">We will discuss these approaches shortly to understand how DevOps and DevSecOps have become the next major step in the </st><span class="No-Break"><st c="26571">software industry.</st></span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/><st c="26589">The Agile manifesto</st></h2>
			<p><st c="26609">We have already discussed Agile</st><a id="_idIndexMarker085"/><st c="26641"> as an SDLC methodology because this umbrella term can be applied directly to the software development phase as well as mapped to the entire software development organization </st><span class="No-Break"><st c="26816">and beyond.</st></span></p>
			<p><st c="26827">The </st><strong class="bold"><st c="26832">Agile manifesto</st></strong><st c="26847"> was </st><a id="_idIndexMarker086"/><st c="26852">created in 2001 by a group of software developers who were looking for a better way to develop software. </st><st c="26957">They came up with four core values and twelve principles that have since become the foundation of the Agile movement. </st><st c="27075">The four core </st><a id="_idIndexMarker087"/><st c="27089">values of the Agile Manifesto are </st><span class="No-Break"><st c="27123">as follows:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="27134">Individuals and interactions</st></strong><st c="27163"> over processes </st><span class="No-Break"><st c="27179">and tools</st></span></li>
				<li><strong class="bold"><st c="27188">Working software</st></strong><st c="27205"> over </st><span class="No-Break"><st c="27211">comprehensive documentation</st></span></li>
				<li><strong class="bold"><st c="27238">Customer collaboration</st></strong><st c="27261"> over </st><span class="No-Break"><st c="27267">contract negotiation</st></span></li>
				<li><strong class="bold"><st c="27287">Responding to change</st></strong><st c="27308"> over </st><a id="_idIndexMarker088"/><st c="27314">following </st><span class="No-Break"><st c="27324">a plan</st></span></li>
			</ul>
			<p><st c="27330">These values and principles have been widely adopted by software development teams and have helped to improve the effectiveness and efficiency of software </st><span class="No-Break"><st c="27486">development processes.</st></span></p>
			<p><st c="27508">Agile, as</st><a id="_idIndexMarker089"/><st c="27518"> an umbrella term, is a broad concept that encompasses a variety of methodologies including Lean, Scrum, Kanban, </st><span class="No-Break"><st c="27631">and others.</st></span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/><st c="27642">Lean management</st></h2>
			<p><st c="27658">Lean management, developed </st><a id="_idIndexMarker090"/><st c="27686">by Taiichi Ohno, the creator of the Toyota Production System, is a methodology that focuses on creating value for customers by optimizing resources, reducing waste (</st><em class="italic"><st c="27851">muda</st></em><st c="27856"> in Japanese), and continuously improving processes. </st><st c="27909">Ohno’s goal was to reduce the time between car order and </st><span class="No-Break"><st c="27966">car delivery:</st></span></p>
			<p class="author-quote"><st c="27979">“All we are doing is looking at the timeline from the moment a customer gives us an order to the point when we collect the cash. </st><st c="28109">We are reducing that timeline by removing the nonvalue-added wastes” – Taiichi Ohno</st></p>
			<p><st c="28192">The principles of lean management include </st><span class="No-Break"><st c="28235">the following:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="28249">Value</st></strong><st c="28255">: Identify </st><a id="_idIndexMarker091"/><st c="28267">what the customer values and concentrate on delivering it </st><span class="No-Break"><st c="28325">to them</st></span></li>
				<li><strong class="bold"><st c="28332">Value stream</st></strong><st c="28345">: Identify </st><a id="_idIndexMarker092"/><st c="28357">all the steps in the value stream for the product or service and remove any steps that do not </st><span class="No-Break"><st c="28451">create value</st></span></li>
				<li><strong class="bold"><st c="28463">Flow</st></strong><st c="28468">: Ensure that </st><a id="_idIndexMarker093"/><st c="28483">the value-creating steps flow smoothly and continuously toward </st><span class="No-Break"><st c="28546">the customer</st></span></li>
				<li><strong class="bold"><st c="28558">Pull</st></strong><st c="28563">: Let customer </st><a id="_idIndexMarker094"/><st c="28579">demand pull the product or service through the value stream rather than pushing it based </st><span class="No-Break"><st c="28668">on forecasts</st></span></li>
				<li><strong class="bold"><st c="28680">Perfection</st></strong><st c="28691">: Continuously </st><a id="_idIndexMarker095"/><st c="28707">pursue improvements to identify and eliminate waste from the processes (strive </st><span class="No-Break"><st c="28786">for perfection)</st></span></li>
			</ul>
			<p><st c="28801">Any type of organization</st><a id="_idIndexMarker096"/><st c="28826"> can apply these principles and processes to improve efficiency, minimize costs, and improve customer satisfaction. </st><st c="28942">Other industry sectors, such as accounting, have also applied lean principles. </st><st c="29021">It’s no surprise that the software industry has adopted this concept, viewing itself as a software manufacturing factory and applying the </st><span class="No-Break"><st c="29159">analogy accordingly.</st></span></p>
			<p><strong class="bold"><st c="29179">Value stream</st></strong><st c="29192"> and </st><strong class="bold"><st c="29197">value stream analysis</st></strong><st c="29218"> are</st><a id="_idIndexMarker097"/><st c="29222"> the most relevant areas that provide a tool for any </st><a id="_idIndexMarker098"/><st c="29275">organization to understand, visualize, and improve their value </st><span class="No-Break"><st c="29338">creation processes.</st></span></p>
			<p><st c="29357">The following figure represents a hypothetical software development organization and how it reacts to customer requests. </st><strong class="bold"><st c="29479">Lead Time</st></strong><st c="29488"> (</st><strong class="bold"><st c="29490">LT</st></strong><st c="29492">) is the time spent between entering the stage and closing the </st><a id="_idIndexMarker099"/><st c="29556">stage, whereas </st><strong class="bold"><st c="29571">Process Time</st></strong><st c="29583"> (</st><strong class="bold"><st c="29585">PT</st></strong><st c="29587">) is the time </st><a id="_idIndexMarker100"/><st c="29602">spent on real work </st><span class="No-Break"><st c="29621">or activity:</st></span></p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B22208_01_004.jpg" alt="Figure 1.4 – Value stream analysis in practice"/><st c="29633"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="30055">Figure 1.4 – Value stream analysis in practice</st></p>
			<p><st c="30101">Customer requests go through different teams (accounts, business analysis, engineering, and ops) with different LTs and PTs until they reach production. </st><st c="30255">This hypothetical organization can improve its efficiency by reducing the LTs spent on each phase and by accelerating </st><span class="No-Break"><st c="30373">the PTs.</st></span></p>
			<p><st c="30381">It is obvious that low-code/no-code platforms, such as Microsoft Power Platform, can significantly decrease </st><a id="_idIndexMarker101"/><st c="30490">not just the PT but also the overall LT of any application development project. </st><st c="30570">They can do this by using the pre-baked building blocks, such as front-end visuals, business logic components, and data access layers, to reduce the overall development, testing, and deployment costs of </st><span class="No-Break"><st c="30773">custom applications.</st></span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor024"/><st c="30793">Scrum</st></h2>
			<p><st c="30799">Scrum </st><a id="_idIndexMarker102"/><st c="30806">is a framework derived from the general agile principles that are often used in software development. </st><st c="30908">This is one of the most widespread Agile methodologies. </st><st c="30964">As we discussed earlier, Agile is an umbrella term that we can apply to SDLC methodology, project management, and organization in many ways. </st><st c="31105">Scrum is a specific implementation of Agile with its own roles, events, artifacts, </st><span class="No-Break"><st c="31188">and rules.</st></span></p>
			<p><st c="31198">Scrum is an agile </st><a id="_idIndexMarker103"/><st c="31217">framework that operates on the values of transparency, assessment, and adjustment. </st><st c="31300">It uses an iterative and incremental methodology to enhance predictability and manage risks. </st><st c="31393">Scrum teams deliver functional software in brief, time-bound iterations known as sprints, while constantly evaluating and adjusting their processes to improve both the product and their workflow. </st><st c="31589">The following figure shows the process of incremental planning </st><span class="No-Break"><st c="31652">and delivery:</st></span></p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B22208_01_005.jpg" alt="Figure 1.5 – The scrum process"/><st c="31665"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31762">Figure 1.5 – The scrum process</st></p>
			<p><st c="31792">Autonomous scrum teams decide which backlog items they will work on in the given sprint based on customer priorities and team velocity. </st><st c="31929">Those backlog items will be moved from the product backlog to the spring backlog. </st><st c="32011">A sprint</st><a id="_idIndexMarker104"/><st c="32019"> usually takes 2-4 weeks and at the end of every sprint, scrum teams can deliver a potentially </st><span class="No-Break"><st c="32114">shippable product.</st></span></p>
			<p><st c="32132">The Scrum</st><a id="_idIndexMarker105"/><st c="32142"> framework defines three main</st><a id="_idIndexMarker106"/><st c="32171"> roles: the </st><strong class="bold"><st c="32183">product owner</st></strong><st c="32196">, the </st><strong class="bold"><st c="32202">Scrum master</st></strong><st c="32214">, and </st><a id="_idIndexMarker107"/><st c="32220">the </st><strong class="bold"><st c="32224">development team</st></strong><st c="32240">. The </st><strong class="bold"><st c="32246">product owner</st></strong><st c="32259"> is </st><a id="_idIndexMarker108"/><st c="32263">responsible for maximizing the value of the product and representing the stakeholders (the customer). </st><st c="32365">The </st><strong class="bold"><st c="32369">Scrum master</st></strong><st c="32381"> is</st><a id="_idIndexMarker109"/><st c="32384"> responsible for promoting and supporting Scrum, orchestrating the well-known ceremonies, and encouraging everyone to abide by Scrum rules and values. </st><st c="32535">The </st><strong class="bold"><st c="32539">development team</st></strong><st c="32555"> is a</st><a id="_idIndexMarker110"/><st c="32560"> self-organizing and cross-functional team responsible for delivering a potentially shippable product at the end of </st><span class="No-Break"><st c="32676">each sprint.</st></span></p>
			<p><st c="32688">Scrum has several ceremonies or events that are used to plan, review, and improve the process. </st><st c="32784">These</st><a id="_idIndexMarker111"/><st c="32789"> include </st><strong class="bold"><st c="32798">sprint planning</st></strong><st c="32813">, </st><strong class="bold"><st c="32815">daily Scrum</st></strong><st c="32826">, </st><strong class="bold"><st c="32828">sprint review</st></strong><st c="32841">, and </st><strong class="bold"><st c="32847">sprint retrospective</st></strong><st c="32867">. Sprint planning is used to plan the work for the upcoming </st><a id="_idIndexMarker112"/><st c="32927">sprint. </st><st c="32935">The </st><a id="_idIndexMarker113"/><st c="32939">daily Scrum is a short daily meeting used to synchronize the work of the development team. </st><st c="33030">The sprint review is scheduled at the end of the current </st><a id="_idIndexMarker114"/><st c="33087">sprint to review the backlog items completed and shift the uncompleted ones to the next sprint. </st><st c="33183">The sprint retrospective is organized after the sprint review to discuss questions such as “what went well?”, “what could have been done better?”, and “how could we improve as a team?”. </st><st c="33369">As a result, the team can find potential improvements and plan them for the </st><span class="No-Break"><st c="33445">next sprint.</st></span></p>
			<p><st c="33457">Scrum </st><a id="_idIndexMarker115"/><st c="33464">framework is easily applicable to low-code/no-code platforms since these provide an ecosystem that guarantees shippable products (applications) at the end of every sprint with the roles and ceremonies defined by </st><span class="No-Break"><st c="33676">the framework.</st></span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor025"/><st c="33690">What is ALM?</st></h1>
			<p><st c="33703">There are many </st><a id="_idIndexMarker116"/><st c="33719">books and articles about ALM and, having a look at the definitions, one thing is common in all of them: ALM is broader than the SDLC and covers the entire life cycle of an application from ideation through development </st><span class="No-Break"><st c="33937">to discontinuity.</st></span></p>
			<p><st c="33954">Per definition, ALM refers to the management of a computer program’s entire life cycle, including governance, development, maintenance, and discontinuity. </st><st c="34110">It involves a wide range of activities, such as requirements management, software architecture, and </st><span class="No-Break"><st c="34210">project management.</st></span></p>
			<p><st c="34229">The SDLC is a component of ALM that provides a detailed description of the application development phase. </st><st c="34336">ALM can involve multiple iterations of the SDLC during an application’s life cycle, that is, multiple methodologies such as Agile and V-model can be applied in different phases. </st><st c="34514">ALM continues after development and first release until the application is no </st><span class="No-Break"><st c="34592">longer used.</st></span></p>
			<p><st c="34604">ALM has brought several disciplines and roles together. </st><st c="34661">It includes project management, change management, requirements management, software architecture, CI, development, CD, testing, release management, and maintenance. </st><st c="34827">These disciplines were managed separately in the past and organizations – before establishing ALM – were much more siloed. </st><st c="34950">Internal processes were prioritized over collaboration and communication among different roles and units within </st><span class="No-Break"><st c="35062">the organization.</st></span></p>
			<p><st c="35079">These days, ALM tools offer a standardized platform for communication and collaboration among software development teams and associated departments, such as project management, business analysis, testing, and IT ops. </st><st c="35297">These tools can also streamline the process of software development and delivery </st><span class="No-Break"><st c="35378">through automation.</st></span></p>
			<p><st c="35397">Modern integrated </st><a id="_idIndexMarker117"/><st c="35416">ALM tools, such as Azure DevOps Services, GitHub, or GitLab, support </st><span class="No-Break"><st c="35485">the following:</st></span></p>
			<ul>
				<li><span class="No-Break"><st c="35499">Requirement engineering</st></span></li>
				<li><st c="35523">Project management – including planning </st><span class="No-Break"><st c="35564">and tracking</st></span></li>
				<li><st c="35576">Bug- and </st><span class="No-Break"><st c="35586">issue tracking</st></span></li>
				<li><st c="35600">Version </st><span class="No-Break"><st c="35609">control system</st></span></li>
				<li><st c="35623">Build – </st><span class="No-Break"><st c="35632">CI</st></span></li>
				<li><span class="No-Break"><st c="35634">Automated testing</st></span></li>
				<li><st c="35652">Release – </st><span class="No-Break"><st c="35663">CD</st></span></li>
				<li><st c="35665">Monitoring applications in production and learning from usage patterns, telemetry logs, </st><span class="No-Break"><st c="35754">and failures</st></span></li>
			</ul>
			<p><st c="35766">The following figure shows the main areas of ALM and how these different disciplines work together in a </st><span class="No-Break"><st c="35871">cyclic way:</st></span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B22208_01_006.jpg" alt="Figure 1.6 – The main areas of ALM"/><st c="35882"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="35934">Figure 1.6 – The main areas of ALM</st></p>
			<p><st c="35968">ALM can easily be</st><a id="_idIndexMarker118"/><st c="35986"> applied to low-code/no-code platforms since they are designed to be modern application runtime platforms hosting and executing hundreds or even thousands of applications created by </st><span class="No-Break"><st c="36168">professional developers.</st></span></p>
			<p><st c="36192">In the next chapters, we will learn how ALM disciplines can be realized in conjunction with Microsoft </st><span class="No-Break"><st c="36295">Power Platform.</st></span></p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor026"/><st c="36310">CI and CD</st></h1>
			<p><st c="36320">CI and CD are widely used </st><a id="_idIndexMarker119"/><st c="36347">processes and tools in modern software development and ALM practices. </st><st c="36417">The CI pipeline (workflow) is for compiling the source code and generating the binaries using build agents, whereas the CD pipeline takes those binaries and deploys them, the entire solution with its configuration to different environments, like dev, test, </st><span class="No-Break"><st c="36674">or production.</st></span></p>
			<p><st c="36688">CI is sometimes referred to as </st><a id="_idIndexMarker120"/><st c="36720">CI builds because it eventually does the official compilation of source code on dedicated build machines (sometimes they are just Docker containers). </st><st c="36870">During CI builds, unit tests are also executed; those tests require no orchestration of the application and run in the millisecond range. </st><st c="37008">CI is one of the greatest processes to assure software quality and to avoid the regression of our applications. </st><st c="37120">In the case of large development projects, it is also very common to create </st><strong class="bold"><st c="37196">build farms</st></strong><st c="37207"> consisting </st><a id="_idIndexMarker121"/><st c="37219">of hundreds of build machines to generate deliverables or packages on every </st><span class="No-Break"><st c="37295">code change.</st></span></p>
			<p><st c="37307">There are two CD terms in practice. </st><strong class="bold"><st c="37344">Continuous delivery</st></strong><st c="37363"> means that the application is ready to be delivered all the </st><a id="_idIndexMarker122"/><st c="37424">time, but the deployment is not automated. </st><st c="37467">Typical examples for continuous delivery are to create a Docker image after compiling the code, or to create an installer to the generated binaries. </st><strong class="bold"><st c="37616">Continuous deployment</st></strong><st c="37637"> takes </st><a id="_idIndexMarker123"/><st c="37644">an additional step and automates the deployment process to target environments. </st><st c="37724">In this book, the CD acronym refers to this latter definition. </st><st c="37787">It is important to note that the CD process transfers the same version of the application throughout to different environments with quality gates established at each stage. </st><st c="37960">The following figure shows a typical </st><span class="No-Break"><st c="37997">CD process:</st></span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B22208_01_007.jpg" alt="Figure 1.7 – CD with quality gates"/><st c="38008"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="38141">Figure 1.7 – CD with quality gates</st></p>
			<p><st c="38175">After the successful compilation of source code during CI, the generated binary packages go through the deployment pipeline. </st><st c="38301">The deployment pipeline delivers these packages to the environments (dev, UAT, and prod) in a fully automated way and validates and verifies the changes by executing </st><span class="No-Break"><st c="38467">automated tests.</st></span></p>
			<p><st c="38483">At organizations with highly matured DevOps practices, it is usual that CD takes place very often, sometimes tens or even hundreds of times per day, to deliver parts of the solutions directly </st><span class="No-Break"><st c="38676">to production.</st></span></p>
			<p><st c="38690">As part of the deployment process, CD workflows are usually used to implement the deployment strategy of the developed application. </st><st c="38823">There are several deployment strategies that can be used to release new versions of </st><span class="No-Break"><st c="38907">an application:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="38922">Basic deployment</st></strong><st c="38939"> is the simplest </st><a id="_idIndexMarker124"/><st c="38956">deployment strategy, whereby</st><a id="_idIndexMarker125"/><st c="38984"> the new version of the application is deployed to the production environment, replacing the old version. </st><st c="39090">This approach is straightforward, but it can result in downtime and does not provide an easy way to roll back to the previous version if something </st><span class="No-Break"><st c="39237">goes wrong.</st></span></li>
				<li><strong class="bold"><st c="39248">Blue-green deployment</st></strong><st c="39270"> involves having two identical production environments. </st><st c="39326">One runs the </st><a id="_idIndexMarker126"/><st c="39339">old version of the</st><a id="_idIndexMarker127"/><st c="39357"> application (blue) and one runs the new version (green). </st><st c="39415">Once the new version has been tested and is ready for release, traffic is gradually shifted from the blue environment to the green environment. </st><st c="39559">This approach allows for easy rollback if something goes wrong, as traffic can simply be shifted back to the </st><span class="No-Break"><st c="39668">blue environment.</st></span></li>
				<li><strong class="bold"><st c="39685">Canary deployment</st></strong><st c="39703"> is similar </st><a id="_idIndexMarker128"/><st c="39715">to blue-green </st><a id="_idIndexMarker129"/><st c="39729">deployment, but instead of shifting all traffic at once, only a small percentage of traffic is initially directed to the new version of the application. </st><st c="39882">This allows for testing the new version with real users and real traffic before fully releasing it. </st><st c="39982">If everything goes well, traffic is gradually shifted to the new version until it is handling </st><span class="No-Break"><st c="40076">all traffic.</st></span></li>
				<li><strong class="bold"><st c="40088">A/B testing</st></strong><st c="40100"> is a </st><a id="_idIndexMarker130"/><st c="40106">deployment strategy that is often used to test new</st><a id="_idIndexMarker131"/><st c="40156"> features or changes to an application. </st><st c="40196">It involves running two versions of the application simultaneously, with some users being directed to the old version and some to the </st><span class="No-Break"><st c="40330">new version.</st></span></li>
				<li><strong class="bold"><st c="40342">Rolling deployment</st></strong><st c="40361"> is a</st><a id="_idIndexMarker132"/><st c="40366"> strategy whereby the new version of the application is gradually rolled out to the production environment. </st><st c="40474">This is</st><a id="_idIndexMarker133"/><st c="40481"> done by updating a subset of servers or instances at a time, while the rest of the servers or instances continue to run the old version of the application. </st><st c="40638">Once the update is complete and verified to be working correctly, the next subset of servers or instances is updated, and so on, until all servers or instances are running the new version of </st><span class="No-Break"><st c="40829">the application.</st></span></li>
			</ul>
			<p><st c="40845">Modern ALM tools, such as Azure DevOps Services, GitHub, or GitLab, provide end-to-end support for CI/CD pipelines and workflows and automate everything after code has been committed to </st><span class="No-Break"><st c="41032">Git repositories.</st></span></p>
			<p><st c="41049">In cloud-native microservice architecture using Kubernetes orchestrator to host and scale highly distributed services, a so-called </st><strong class="bold"><st c="41181">pull</st></strong><st c="41185"> model</st><a id="_idIndexMarker134"/><st c="41191"> is widely adapted to deploy the latest version to production. </st><st c="41254">This approach is</st><a id="_idIndexMarker135"/><st c="41270"> called </st><strong class="bold"><st c="41278">GitOps</st></strong><st c="41284">. Tools such as ArgoCD</st><a id="_idIndexMarker136"/><st c="41306"> or FluxCD</st><a id="_idIndexMarker137"/><st c="41316"> run inside the Kubernetes cluster and when changes or commits happen in a monitored Git repository, those tools deploy the updates inside the cluster with zero downtime rollouts. </st><st c="41496">In low-code or no-code platforms, this approach is just partially applicable in scenarios in which the pull model itself can be considered, such as getting configuration data from a central repository or leveraging the use of </st><span class="No-Break"><st c="41722">feature flags.</st></span></p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor027"/><st c="41736">DevOps-enabled architecture patterns</st></h1>
			<p><st c="41773">DevOps</st><a id="_idIndexMarker138"/><st c="41780"> is one of the shift-left approaches that we have seen in the software industry. </st><st c="41861">It brings operational teams (ops) close to developer teams (devs) to enable and accelerate the continuous value delivery to our customers. </st><st c="42000">It means a mindset and cultural change for people; it requires processes and tools to transform an organization into a </st><span class="No-Break"><st c="42119">DevOps one.</st></span></p>
			<p><st c="42130">“You build it, you run it” is one of the most impressive quotes that describes how developers and operations teams need to come together and form one diverse team to cover the end-to-end repetitive process from coding through deployment to operations. </st><st c="42383">Ops becomes part of the team. </st><st c="42413">This shift-left approach increases the overall productivity of organizations. </st><st c="42491">DevOps is a paradigm shift and a cultural change at the organizational level to improve collaboration between development and operations teams, and to enhance the efficiency and quality of software production. </st><st c="42701">An approach to reviving the </st><strong class="bold"><st c="42729">day 0 company</st></strong><st c="42742"> mindset, often</st><a id="_idIndexMarker139"/><st c="42757"> called </st><a id="_idIndexMarker140"/><st c="42765">a </st><strong class="bold"><st c="42767">startup mentality</st></strong><st c="42784">, involves defining essential rules, processes, and safeguards that enterprise customers in regulated industries need to implement and uphold. </st><st c="42927">Being agile and value-oriented at scale mean to get rid of any waste that is not part of the value creation process. </st><st c="43044">DevOps also brings another benefit for enterprises, namely to maintain only one version of the developed product: the version that runs </st><span class="No-Break"><st c="43180">in production.</st></span></p>
			<p><st c="43194">In addition, DevOps expects advanced monitoring of the software in production to not operate services blindfolded. </st><st c="43310">Gathering telemetry data, traces, and callstacks in case of failure is crucial to know how the developed </st><a id="_idIndexMarker141"/><st c="43415">service or component is used. </st><strong class="bold"><st c="43445">Application Performance Monitoring</st></strong><st c="43479"> (</st><strong class="bold"><st c="43481">APM</st></strong><st c="43484">) tools, such as </st><a id="_idIndexMarker142"/><st c="43502">Azure Application Insights, can be used to monitor and proactively notice performance degradation before </st><span class="No-Break"><st c="43607">outages happen.</st></span></p>
			<p><st c="43622">DevOps </st><a id="_idIndexMarker143"/><st c="43630">teams also emphasize that solutions should create </st><strong class="bold"><st c="43680">zero downtime deployment</st></strong><st c="43704">-capable </st><a id="_idIndexMarker144"/><st c="43714">production environments. </st><st c="43739">Orchestrators and application runtimes such as Kubernetes</st><a id="_idIndexMarker145"/><st c="43796"> support this approach by design with </st><span class="No-Break"><st c="43834">rolling deployments.</st></span></p>
			<p><st c="43854">In highly mature DevOps teams the </st><a id="_idIndexMarker146"/><st c="43889">concept of </st><strong class="bold"><st c="43900">rolling forward</st></strong><st c="43915"> is also widely used. </st><st c="43937">Rolling forward means that if issues or errors are encountered during deployments in production, then the team produces fixes for them and rolls that version out. </st><st c="44100">Rolling back</st><a id="_idIndexMarker147"/><st c="44112"> to the previous version is not </st><span class="No-Break"><st c="44144">considered anymore.</st></span></p>
			<p><st c="44163">DevOps has also defined new roles in the software development industry. </st><st c="44236">One of them is the </st><strong class="bold"><st c="44255">Directly Responsible Individual</st></strong><st c="44286"> (</st><strong class="bold"><st c="44288">DRI</st></strong><st c="44291">) role, which </st><a id="_idIndexMarker148"/><st c="44306">is also known </st><a id="_idIndexMarker149"/><st c="44320">as Google’s </st><strong class="bold"><st c="44332">Sheriff</st></strong><st c="44339"> or Facebook’s </st><strong class="bold"><st c="44354">Designated Response Individual</st></strong><st c="44384">. The </st><a id="_idIndexMarker150"/><st c="44390">DRI is responsible for incident management, service availability, and service health. </st><st c="44476">They are the single point of contact during the sprint, both internally and externally. </st><st c="44564">They communicate with customers, newspapers, and other media if outage with high or medium impact encounters. </st><st c="44674">This has dramatically improved the overall customer experience. </st><st c="44738">On the other hand, they also provide information to other DevOps teams internally during </st><span class="No-Break"><st c="44827">service incidents.</st></span></p>
			<p><st c="44845">Highly mature DevOps teams and their team members can even work in different roles in every sprint. </st><st c="44946">For instance, the DRI role is rotated in the team in every sprint. </st><st c="45013">This leads to huge benefits for the team members: after a few sprints, everybody in the team can build up expert knowledge in every discipline (coding, testing, and operating </st><span class="No-Break"><st c="45188">the services).</st></span></p>
			<p><st c="45202">DevOps also assumes highly automated processes. </st><st c="45251">There are engineering teams at large IT companies that follow the principle of automating everything. </st><st c="45353">The rule of thumb is: if we only need to do it once, we can do it manually, but if we need to repeat it even once again, we are responsible for creating the automation scripts </st><span class="No-Break"><st c="45529">for it.</st></span></p>
			<p><st c="45536">Any architecture addresses</st><a id="_idIndexMarker151"/><st c="45563"> so-called </st><strong class="bold"><st c="45574">-ilities</st></strong><st c="45582">, which are non-functional requirements, such as auditability, availability, compatibility, composability, configurability, accessibility, adaptability, affordability, customizability, demonstrability, deployability, durability, usability, extensibility, flexibility, interoperability, manageability, portability, predictability, recoverability, reliability, repeatability, reusability, scalability, serviceability, sociability, simplicity, testability, sustainability, traceability, reproducibility, and </st><span class="No-Break"><st c="46087">so on.</st></span></p>
			<p class="callout-heading"><st c="46093">Power Platform and the -ilities</st></p>
			<p class="callout"><st c="46125">Power Platform components</st><a id="_idIndexMarker152"/><st c="46151"> have been designed in such a way that most of these abilities are available out of the box. </st><st c="46244">As Power Platform solution architects, we don’t need to care about requirements, such as auditability, availability, reusability, and so on because these are provided</st><a id="_idIndexMarker153"/><st c="46410"> by the underlying application runtime as a </st><strong class="bold"><st c="46454">Software-as-a-Service</st></strong><st c="46475"> (</st><span class="No-Break"><strong class="bold"><st c="46477">SaaS</st></strong></span><span class="No-Break"><st c="46481">) offering.</st></span></p>
			<p><st c="46493">There are two very important ones </st><span class="No-Break"><st c="46528">for DevOps:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="46539">Deployability</st></strong><st c="46553"> refers</st><a id="_idIndexMarker154"/><st c="46560"> to the ability to easily and reliably deploy new versions of an application to the </st><span class="No-Break"><st c="46644">production environment</st></span></li>
				<li><strong class="bold"><st c="46666">Testability</st></strong><st c="46678"> refers to</st><a id="_idIndexMarker155"/><st c="46688"> the ease with which a system or its components can be tested to ensure that they meet the specified requirements and </st><span class="No-Break"><st c="46806">function correctly</st></span></li>
			</ul>
			<p><st c="46824">These two </st><strong class="bold"><st c="46835">abilities</st></strong><st c="46844"> make it possible for developers to change any place in the code base and to easily and reliably deploy new versions. </st><st c="46962">The ideal DevOps architecture is based on loosely coupled services (not necessarily microservices) that can be deployed in different release cycles to production. </st><st c="47125">The application and its components are designed to support various deployment strategies, such as basic deployment, blue-green deployment, canary deployment, A/B testing, and rolling deployment, as </st><span class="No-Break"><st c="47323">mentioned earlier.</st></span></p>
			<p><st c="47341">The following figure shows a monolith architecture-based deployment versus a modern </st><span class="No-Break"><st c="47426">microservices-based approach:</st></span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B22208_01_008.jpg" alt="Figure 1.8 – Monolith versus loosely coupled services and release"/><st c="47455"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="47541">Figure 1.8 – Monolith versus loosely coupled services and release</st></p>
			<p><st c="47606">In monoliths, although</st><a id="_idIndexMarker156"/><st c="47629"> the teams work on different parts of the software, the release can happen only once together containing the changes of all services. </st><st c="47763">If Service A developed by Team A breaks the release, then the changes by Team B and Team C cannot reach production either. </st><st c="47886">On the other hand, if the underlying software architecture is based on loosely coupled services (e.g., OpenAPI-specified REST API endpoints), then the services developed by the different teams can be deployed to production in parallel. </st><st c="48122">Deployment</st><a id="_idIndexMarker157"/><st c="48132"> failures have only local impacts reducing the </st><strong class="bold"><st c="48179">blast radius</st></strong> <span class="No-Break"><st c="48191">in production.</st></span></p>
			<p class="callout-heading"><st c="48206">ALM and DevOps</st></p>
			<p class="callout"><st c="48221">ALM</st><a id="_idIndexMarker158"/><st c="48225"> is a broader concept that includes all aspects of software development, while DevOps focuses specifically on the collaboration between development and operations teams to improve the efficiency of the software development process. </st><st c="48457">DevOps can be seen as a part of ALM, as it helps to streamline the development, testing, and deployment of </st><span class="No-Break"><st c="48564">software applications.</st></span></p>
			<p><st c="48586">If large engineering organizations need to run agile at an enterprise scale based on DevOps practices, the </st><strong class="bold"><st c="48694">Scaled Agile Framework</st></strong><st c="48716"> (</st><strong class="bold"><st c="48718">SAFe</st></strong><st c="48722">) provides</st><a id="_idIndexMarker159"/><st c="48733"> the </st><span class="No-Break"><st c="48738">right structure.</st></span></p>
			<p><st c="48754">SAFe is a</st><a id="_idIndexMarker160"/><st c="48764"> framework of patterns and practices for implementing agile principles at an enterprise scale. </st><st c="48859">It defines roles and responsibilities in detail and provides exact instructions on how to plan and manage work at such a scale through the value creation process. </st><st c="49022">SAFe is designed to implement agile practices across large teams and business units and it makes it possible to gain a portfolio-level overview of those agile </st><span class="No-Break"><st c="49181">teams’ progress.</st></span></p>
			<p><st c="49197">SAFe is based on seven core competencies of business agility, which include Lean-Agile leadership, team and technical agility, Agile product delivery, enterprise solution delivery, Lean portfolio management, organizational agility, and continuous learning culture. </st><st c="49463">These competencies are designed to help organizations achieve their business goals and deliver value to </st><span class="No-Break"><st c="49567">their customers.</st></span></p>
			<p><st c="49583">SAFe also includes the concept of </st><a id="_idIndexMarker161"/><st c="49618">an </st><strong class="bold"><st c="49621">Agile Release Train</st></strong><st c="49640">, which is a cross-functional team of agile teams that plans, builds, and delivers software in a synchronized cadence. </st><st c="49759">In this approach, the </st><strong class="bold"><st c="49781">Release Train</st></strong><st c="49794"> is responsible for coordinating the deployment of new versions of </st><a id="_idIndexMarker162"/><st c="49861">the application using the deployment strategies supported by the DevOps architecture. </st><st c="49947">This allows for a smooth and efficient release process, while also ensuring that the application is continuously delivered to users with high quality and reliability. </st><st c="50114">SAFe can be implemented in Azure Boards in Azure DevOps Services by customizing our work item tracking experience to support features, epics, release trains, and </st><span class="No-Break"><st c="50276">multiple backlogs.</st></span></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor028"/><st c="50294">Summary</st></h1>
			<p><st c="50302">In this chapter, we explored the most significant breakthroughs in the software industry, delving into various SDLC methodologies, the Agile manifesto, Lean management, the Scrum Framework, ALM, and DevOps practices. </st><st c="50520">We became acquainted with the patterns and practices that define modern application development and architecture. </st><st c="50634">These skills and lessons are fundamental to software development and are essential concepts that every engineer should be </st><span class="No-Break"><st c="50756">familiar with.</st></span></p>
			<p><st c="50770">As we have concluded, modern application development adheres to DevOps principles, utilizing ALM tools and disciplines to maximize value. </st><st c="50909">Modern application architecture is based on loosely coupled services or microservices and supports two crucial patterns: deployability </st><span class="No-Break"><st c="51044">and testability.</st></span></p>
			<p><st c="51060">In the subsequent chapters, we will discover how these modern application development patterns and practices can be applied to the Microsoft Power Platform and how DevOps and ALM can be implemented for the </st><span class="No-Break"><st c="51267">Power Platform.</st></span></p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor029"/><st c="51282">Further reading</st></h1>
			<ul>
				<li><st c="51298">Geoffrey Elliott (2004)</st><em class="italic"><st c="51322">. Global Business Information Technology: an integrated systems approach. </st></em><st c="51396">Pearson </st><span class="No-Break"><st c="51404">Education</st></span><span class="No-Break"><em class="italic"><st c="51413">: </st></em></span><a href="https://www.amazon.com/Global-Business-Information-Technology-integrated/dp/0321270126"><span class="No-Break"><st c="51416">https://www.amazon.com/Global-Business-Information-Technology-integrated/dp/0321270126</st></span></a></li>
				<li><st c="51502">Everatt, G.D.; McLeod, R Jr (2007)</st><em class="italic"><st c="51537">. “</st></em><a href="B22208_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><st c="51540">Chapter 2</st></em></span></a><em class="italic"><st c="51550">: The Software Development Life Cycle”. </st><st c="51591">Software Testing: Testing Across the Entire Software Development Life Cycle. </st></em><st c="51668">John Wiley &amp; </st><span class="No-Break"><st c="51681">Sons</st></span><span class="No-Break"><em class="italic"><st c="51685">: </st></em></span><strong class="source-inline"><a href="https://tinyurl.com/uw2r7c8r"><st c="51688">https://dahlan.unimal.ac.id/files/ebooks/2007%20[McLeod_R.]_Software_Testing_Testing_Across_the_E.pdf</st></a></strong></li>
				<li><st c="51789">V-Model: </st><em class="italic"><st c="51799">US Dept of Transportation, Federal Highway Administration. </st><st c="51858">Systems Engineering Guidebook for </st></em><span class="No-Break"><em class="italic"><st c="51892">ITS</st></em></span><span class="No-Break"><st c="51895">: </st></span><a href="https://www.fhwa.dot.gov/cadiv/segb/index.cfm"><span class="No-Break"><st c="51898">https://www.fhwa.dot.gov/cadiv/segb/index.cfm</st></span></a></li>
				<li><st c="51943">Power Apps </st><span class="No-Break"><st c="51955">RAD: </st></span><span class="No-Break"><a href="https://powerapps.microsoft.com/en-us/rapid-application-development-rad/"><st c="51960">https://powerapps.microsoft.com/en-us/rapid-application-development-rad/</st></a></span></li>
				<li><st c="52032">ALM: DAVID CHAPPELL (2008):</st><em class="italic"><st c="52060"> WHAT IS APPLICATION LIFECYCLE MANAGEMENT?</st></em><st c="52102">: </st><a href="https://aws.amazon.com/what-is/application-lifecycle-management/"><span class="No-Break"><st c="52105">https://aws.amazon.com/what-is/application-lifecycle-management/</st></span></a></li>
				<li><st c="52169">Lean Management: </st><em class="italic"><st c="52187">Taiichi Ohno: Toyota Production </st></em><span class="No-Break"><em class="italic"><st c="52219">System: </st></em></span><a href="https://www.amazon.com/Toyota-Production-System-Beyond-Large-Scale/dp/0915299143"><span class="No-Break"><st c="52227">https://www.amazon.com/Toyota-Production-System-Beyond-Large-Scale/dp/0915299143</st></span></a></li>
				<li><span class="No-Break"><st c="52307">DevOps: </st></span><a href="https://learn.microsoft.com/en-us/devops/what-is-devops"><span class="No-Break"><st c="52316">https://learn.microsoft.com/en-us/devops/what-is-devops</st></span></a></li>
				<li><st c="52371">McKinsey &amp; Company</st><em class="italic"><st c="52390">: Driving business outcomes through Developer Velocity </st></em><span class="No-Break"><em class="italic"><st c="52446">2020: </st></em></span><a href="https://www.mckinsey.com/industries/technology-media-and-telecommunications/our-insights/developer-velocity-how-software-excellence-fuels-business-performance#/"><span class="No-Break"><st c="52452">https://www.mckinsey.com/industries/technology-media-and-telecommunications/our-insights/developer-velocity-how-software-excellence-fuels-business-performance#/</st></span></a></li>
				<li><st c="52612">DRI </st><span class="No-Break"><st c="52617">role: </st></span><a href="https://www.microsoft.com/insidetrack/blog/rotating-devops-role-improves-engineering-service-quality/"><span class="No-Break"><st c="52623">https://www.microsoft.com/insidetrack/blog/rotating-devops-role-improves-engineering-service-quality/</st></span></a></li>
				<li><span class="No-Break"><st c="52724">SAFe: </st></span><a href="https://scaledagileframework.com/agile-release-train/"><span class="No-Break"><st c="52731">https://scaledagileframework.com/agile-release-train/</st></span></a></li>
			</ul>
		</div>
	<div id="charCountTotal" value="52784"/></body></html>