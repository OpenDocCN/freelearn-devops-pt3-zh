<html><head></head><body>
		<div id="_idContainer028">
			<h1 class="chapter-number" id="_idParaDest-97"><a id="_idTextAnchor115"/>5</h1>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor116"/>Day-to-Day Delivery with SFDX</h1>
			<p>In this chapter, we’ll see how we can apply what we’ve learned so far, using the SFDX suite of tools together with Visual Studio Code and Git, to manage our change delivery. It will by no means be the definitive way to do Salesforce DevOps and assumes starting a brand-new project from scratch, but it will show some common tasks <span class="No-Break">and principles.</span></p>
			<p>We will be covering the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Setting up the tools and <span class="No-Break">your project</span></li>
				<li>The change lifecycle with Git <span class="No-Break">and SFDX</span></li>
				<li>Sandboxes versus <span class="No-Break">scratch orgs</span></li>
			</ul>
			<p>By the end of the chapter, you should be able to replicate a simple workflow in your own Salesforce orgs for picking up an item of work from a ticketing system such as Jira or Asana, creating a new feature branch for it, using SFDX and VS Code to make your changes, and checking the code back in again. This is the most straightforward approach to DevOps and will give you the solid practical foundations <span class="No-Break">you need.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor117"/>Technical requirements</h1>
			<p>If you want to follow along with the examples in this chapter, as a minimum, you will need to have the <span class="No-Break">following installed:</span></p>
			<ul>
				<li>The <span class="No-Break">Salesforce CLI</span></li>
				<li><span class="No-Break">VS Code</span></li>
				<li>The Salesforce extensions for <span class="No-Break">VS Code</span></li>
			</ul>
			<p>You will also need a GitHub account (<a href="https://github.com/">https://github.com/</a>) in which to create a new Git repository and Git installed on your local <span class="No-Break">machine (</span><a href="https://git-scm.com/"><span class="No-Break">https://git-scm.com/</span></a><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor118"/>Setting up the tools and your project</h1>
			<p>While in most real-world scenarios, it’s highly likely that both your tools and your project would already be set up and ready for development on an existing implementation, we’re going to cover setting up everything from scratch so that if you want to follow along with the example workflow, you could potentially do so from a fresh Developer Edition <span class="No-Break">Salesforce org.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor119"/>The Salesforce CLI</h2>
			<p>The Salesforce CLI is the <a id="_idIndexMarker191"/>primary tool for interacting with your Salesforce org from your development tools and is fundamental to automating processes for CI/CD <span class="No-Break">as well.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer020">
					<img alt="Figure 5.1 – Overview of the Salesforce CLI download page" src="image/Figure_5.1_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Overview of the Salesforce CLI download page</p>
			<p>To install the Salesforce CLI on Windows, macOS, or Linux, follow the instructions for the required <span class="No-Break">operating system.</span></p>
			<h3>Windows</h3>
			<ol>
				<li>Go<a id="_idIndexMarker192"/> to the Salesforce CLI<a id="_idIndexMarker193"/> download<a id="_idIndexMarker194"/> <span class="No-Break">page: </span><a href="https://developer.salesforce.com/tools/sfdxcli"><span class="No-Break">https://developer.salesforce.com/tools/sfdxcli</span></a><span class="No-Break">.</span></li>
				<li>Click on the <strong class="bold">Windows Installer</strong> link to download the installer <span class="No-Break">for Windows.</span></li>
				<li>Run the downloaded executable file (<strong class="source-inline">.exe</strong>) to start the <span class="No-Break">installation process.</span></li>
				<li>Follow the installation wizard, accept the license agreement, and choose the desired settings. The default settings are usually sufficient for <span class="No-Break">most users.</span></li>
				<li>Complete the installation process by clicking <strong class="bold">Install</strong> and <span class="No-Break">then </span><span class="No-Break"><strong class="bold">Finish</strong></span><span class="No-Break">.</span></li>
				<li>Open Command Prompt or PowerShell and type <strong class="source-inline">sfdx --version</strong> to verify the installation. If the installation was successful, you should see the installed Salesforce <span class="No-Break">CLI version.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer021">
					<img alt="Figure 5.2 – Checking the installation of the Salesforce CLI on Windows" src="image/Figure_5.2_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Checking the installation of the Salesforce CLI on Windows</p>
			<h3>macOS</h3>
			<ol>
				<li value="1">Go to the <a id="_idIndexMarker195"/>Salesforce CLI<a id="_idIndexMarker196"/> download <a id="_idIndexMarker197"/><span class="No-Break">page: </span><a href="https://developer.salesforce.com/tools/sfdxcli"><span class="No-Break">https://developer.salesforce.com/tools/sfdxcli</span></a><span class="No-Break">.</span></li>
				<li>Click on the <strong class="bold">MacOS Installer</strong> link to download the installer for macOS that’s appropriate for the type of Mac <span class="No-Break">you have.</span></li>
				<li>Open the downloaded <strong class="source-inline">.pkg</strong> file to start the <span class="No-Break">installation process.</span></li>
				<li>Follow the installation wizard, accept the license agreement, and choose the desired settings. The default settings are usually sufficient for <span class="No-Break">most users.</span></li>
				<li>Complete the installation process by clicking <strong class="bold">Install</strong> and <span class="No-Break">then </span><span class="No-Break"><strong class="bold">Close</strong></span><span class="No-Break">.</span></li>
				<li>Open <a id="_idIndexMarker198"/>Terminal and type <strong class="source-inline">sfdx --version</strong> to verify the installation. If the installation was successful, you should see the installed <a id="_idIndexMarker199"/>Salesforce <span class="No-Break">CLI version.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer022">
					<img alt="Figure 5.3 – Checking the successful installation of the Salesforce CLI on macOS" src="image/Figure_5.3_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Checking the successful installation of the Salesforce CLI on macOS</p>
			<h3>Linux</h3>
			<p>The<a id="_idIndexMarker200"/> Salesforce CLI for Linux is available as a tarball. You can<a id="_idIndexMarker201"/> find the download<a id="_idIndexMarker202"/> URL for the tarball that matches your system <span class="No-Break">architecture here.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Architecture</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Manifest file</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">x64</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-x64.tar.xz"><span class="No-Break">https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-x64.tar.xz</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Arm</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-arm.tar.xz"><span class="No-Break">https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-arm.tar.xz</span></a></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – Manifest files for the Linux installation packages</p>
			<ol>
				<li>To download one of these tarballs, use the <strong class="source-inline">wget</strong> command. For example, for the x64 platform, <span class="No-Break">use this:</span><pre class="source-code">
<strong class="bold">wget https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-x64.tar.xz</strong></pre></li>				<li>Create a directory <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">sfdx</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">mkdir ~/sfdx</strong></pre></li>				<li>Extract the contents of the tarball version <span class="No-Break">you downloaded:</span></li>
			</ol>
			<p><strong class="source-inline">tar xJf sfdx-linux-x64.tar.xz -C ~/sfdx --</strong><span class="No-Break"><strong class="source-inline">strip-components 1</strong></span></p>
			<p>The <strong class="source-inline">-C</strong> flag extracts the contents into the <strong class="source-inline">sfdx</strong> directory, while <strong class="source-inline">--strip-components 1</strong> removes the root <span class="No-Break">path component.</span></p>
			<ol>
				<li value="4">Modify your PATH environment variable to incorporate the Salesforce CLI <strong class="source-inline">bin</strong> directory. For instance, to configure it for your ongoing Terminal session, use the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">export PATH=~/sfdx/bin:$PATH</strong></pre></li>				<li>To permanently update your PATH, add the relevant entry to your shell’s configuration file. For example, if you are using the Bash shell, include this line in either your <strong class="source-inline">~/.bashrc</strong> or <strong class="source-inline">~/.</strong><span class="No-Break"><strong class="source-inline">bash_profile</strong></span><span class="No-Break"> file:</span><pre class="source-code">
<strong class="bold">PATH=~/sfdx/bin:$PATH</strong></pre></li>				<li>Open <a id="_idIndexMarker203"/> Terminal and type <strong class="source-inline">sfdx --version</strong> to verify <a id="_idIndexMarker204"/>the installation. If the installation was successful, you should see the installed Salesforce <span class="No-Break">CLI version.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer023">
					<img alt="Figure 5.4 – Verifying the installation of the CLI" src="image/Figure_5.4_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Verifying the installation of the CLI</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor120"/>Git</h2>
			<p>To install Git<a id="_idIndexMarker205"/> on Windows, macOS, or Ubuntu Linux, follow the instructions here for the appropriate operating system. For other Linux distributions, you may need to search for the appropriate documentation for your package <span class="No-Break">management system.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer024">
					<img alt="Figure 5.5 – The Git client download page" src="image/Figure_5.5_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The Git client download page</p>
			<h3>Windows</h3>
			<ol>
				<li>Download the <a id="_idIndexMarker206"/>Git for Windows installer<a id="_idIndexMarker207"/> from the <span class="No-Break">official </span><span class="No-Break"><a id="_idIndexMarker208"/></span><span class="No-Break">website:</span></li>
			</ol>
			<p><a href="https://git-scm.com/download/win"><span class="No-Break">https://git-scm.com/download/win</span></a></p>
			<ol>
				<li value="2">Run the downloaded executable file (<strong class="source-inline">.exe</strong>) to start the <span class="No-Break">installation process.</span></li>
				<li>Follow the installation wizard, choosing the desired settings. The default settings are usually sufficient for <span class="No-Break">most users.</span></li>
				<li>Complete the installation process by clicking <strong class="bold">Install </strong>and <span class="No-Break">then </span><span class="No-Break"><strong class="bold">Finish</strong></span><span class="No-Break">.</span></li>
				<li>To verify the installation, open the Git Bash terminal by searching for it in the <strong class="bold">Start</strong> menu or using the context menu in a folder by right-clicking and selecting <strong class="bold">Git </strong><span class="No-Break"><strong class="bold">Bash Here</strong></span><span class="No-Break">.</span></li>
				<li>In the Git Bash<a id="_idIndexMarker209"/> terminal, type <strong class="source-inline">git --version</strong> and press <em class="italic">Enter</em>. If the installation was <a id="_idIndexMarker210"/>successful, you should see the installed <span class="No-Break">Git version.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer025">
					<img alt="Figure 5.6 – Confirming the successful installation of Git for Windows" src="image/Figure_5.6_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Confirming the successful installation of Git for Windows</p>
			<h3>macOS</h3>
			<ol>
				<li value="1">Check whether <a id="_idIndexMarker211"/>Git<a id="_idIndexMarker212"/> is already installed by opening the Terminal app and typing <strong class="source-inline">git --version</strong>. If Git is installed, you’ll see the version number. If not, proceed to the <span class="No-Break">next step.</span></li>
				<li>Install <strong class="bold">Homebrew</strong>, a package manager for macOS, by following the instructions on the official<a id="_idIndexMarker213"/> <span class="No-Break">website: </span><a href="https://brew.sh/"><span class="No-Break">https://brew.sh/</span></a><span class="No-Break">.</span></li>
				<li>Once Homebrew is installed, open Terminal and type <strong class="source-inline">brew </strong><span class="No-Break"><strong class="source-inline">install git</strong></span><span class="No-Break">.</span></li>
				<li>Wait for the installation process <span class="No-Break">to complete.</span></li>
				<li>Verify the installation by typing <strong class="source-inline">git --version</strong> in Terminal. If the installation was successful, you should see the installed <span class="No-Break">Git version.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer026">
					<img alt="Figure 5.7 – Confirming the successful installation of Git on macOS" src="image/Figure_5.7_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Confirming the successful installation of Git on macOS</p>
			<h3>Ubuntu Linux</h3>
			<ol>
				<li value="1">Open<a id="_idIndexMarker214"/> Terminal <a id="_idIndexMarker215"/> (<em class="italic">Ctrl + Alt + </em><span class="No-Break"><em class="italic">T</em></span><span class="No-Break">).</span></li>
				<li>Update the package list by typing <strong class="source-inline">sudo apt update</strong> and <span class="No-Break">pressing </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
				<li>Install Git by typing <strong class="source-inline">sudo apt install git</strong> and <span class="No-Break">pressing </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
				<li>Confirm the installation by typing <strong class="source-inline">Y</strong> when prompted and <span class="No-Break">pressing </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li>
				<li>Wait for the installation process <span class="No-Break">to complete.</span></li>
				<li>Verify the installation by typing <strong class="source-inline">git --version</strong> in the Terminal. If the installation was successful, you should see the installed <span class="No-Break">Git version.</span></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer027">
					<img alt="Figure 5.8 – Confirming the successful installation of Git on Linux" src="image/Figure_5.8_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Confirming the successful installation of Git on Linux</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor121"/>VS Code and extensions</h2>
			<p>Microsoft VS Code<a id="_idIndexMarker216"/> is available for Windows, macOS, and Linux systems. The installer can be obtained from <a href="https://code.visualstudio.com/download">https://code.visualstudio.com/download</a> – simply follow the instructions for your <span class="No-Break">operating system.</span></p>
			<p>More important to Salesforce development using VS Code are the extensions that allow integration with both Git and SFDX right from within <span class="No-Break">the IDE:</span></p>
			<ol>
				<li>Open <span class="No-Break">VS Code.</span></li>
				<li>Click the extensions view icon on the sidebar or press <em class="italic">Ctrl + Shift + X</em> (Windows/Linux) or <em class="italic">Cmd + Shift + X</em> (Mac) to open the <span class="No-Break"><strong class="bold">Extensions </strong></span><span class="No-Break">panel.</span></li>
				<li>Search for <strong class="source-inline">Salesforce Extension Pack</strong> in the <span class="No-Break">search bar.</span></li>
				<li>Click the <strong class="bold">Install</strong> button on <strong class="bold">Salesforce Extension Pack</strong> by Salesforce. This will install a collection of <a id="_idIndexMarker217"/>extensions, including Salesforce CLI Integration, Apex, Aura Components, Lightning Web Components, <span class="No-Break">and more.</span></li>
			</ol>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor122"/>Creating a new SFDX project and connecting it to your Salesforce org</h2>
			<p>Now that we have all the<a id="_idIndexMarker218"/> required tools installed, we can start getting a project together <a id="_idIndexMarker219"/>on which to work. We will create a new SFDX project from within VS Code and connect it to our Salesforce environment. We’ll also connect it to our Git source control so that we can truly work in a source-driven way. Let’s look at the steps needed to connect <span class="No-Break">everything together:</span></p>
			<ol>
				<li>Set up an SFDX project using the <span class="No-Break">Command Palette:</span><ol><li>Open the Command Palette with <em class="italic">Ctrl + Shift + P</em> (Windows/Linux) or <em class="italic">Cmd + Shift + </em><span class="No-Break"><em class="italic">P</em></span><span class="No-Break"> (Mac).</span></li><li>Type <strong class="source-inline">SFDX: Create Project</strong> and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li><li>Choose <strong class="bold">Standard</strong> as the project template and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li><li>Enter a desired name for your project and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li><li>Choose a folder to store your SFDX project and press <em class="italic">Enter</em>. This will generate a new SFDX project structure in the <span class="No-Break">specified folder.</span></li></ol></li>
				<li>Set the default org for your project using the <span class="No-Break">Command Palette:</span><ol><li>Open the Command Palette with <em class="italic">Ctrl + Shift + P</em> (Windows/Linux) or <em class="italic">Cmd + Shift + </em><span class="No-Break"><em class="italic">P</em></span><span class="No-Break"> (Mac).</span></li><li>Type <strong class="source-inline">SFDX</strong>, then set a default org and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></li><li>Choose an alias to use when authenticating with your <span class="No-Break">Salesforce org.</span></li></ol></li>
			</ol>
			<p>Now you have installed and set up the VS Code extensions for Salesforce using the Command Palette and are ready to start developing <span class="No-Break">Salesforce applications.</span></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor123"/>The change lifecycle with Git and SFDX</h1>
			<p>In many organizations, teams <a id="_idIndexMarker220"/>make use of workflow management systems such as Jira<a id="_idIndexMarker221"/> or Asana<a id="_idIndexMarker222"/> to capture, refine, and assign work items for development teams. In this example, we’re going to assume that Jira is in use, but this is purely for illustrative purposes to replicate a reasonably typical real-world scenario. It is definitely not essential to use Jira, or any equivalent system, to follow these examples. We will be looking at ticketing systems in more detail in <a href="B19436_08.xhtml#_idTextAnchor177"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor124"/>Getting a Git repository to work with</h2>
			<p>In <a href="B19436_03.xhtml#_idTextAnchor046"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we looked at some of the <a id="_idIndexMarker223"/>most common Git operations and their corresponding commands. In most real-world scenarios, you are likely to have a pre-existing repository to work with. However, there may be scenarios where you are starting a project with Git for the first time, so let’s look at the main ways to prepare Git <span class="No-Break">for work:</span></p>
			<ol>
				<li><strong class="source-inline">git init</strong> will <a id="_idIndexMarker224"/>create a brand-new local repository on your machine to work with. At this point, there is no equivalent remote repository. You can refer back to <a href="B19436_03.xhtml#_idTextAnchor046"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> if you need a reminder of how to connect one, for example, <span class="No-Break">on GitHub.</span></li>
				<li><strong class="source-inline">git clone</strong> will<a id="_idIndexMarker225"/> create a copy of a remote repository on your local machine – including the version history and all the branches and commits it contains. It will create the correct directory structure for you, ready to <span class="No-Break">work with.</span></li>
				<li><strong class="source-inline">git checkout</strong> is <a id="_idIndexMarker226"/>used to switch branches within an existing repository. When you use this command, your local working folder will be updated to reflect the contents of <span class="No-Break">that branch.</span></li>
			</ol>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor125"/>Getting the latest changes from the main branch</h2>
			<p>Obtaining the latest <a id="_idIndexMarker227"/>main branch changes before development ensures a current code base, minimizes merge conflicts, and streamlines the integration of new features <span class="No-Break">or fixes:</span></p>
			<ol>
				<li>In VS Code, click the <strong class="bold">Source Control</strong> icon in the <span class="No-Break">left sidebar.</span></li>
				<li>Click the <strong class="bold">...</strong> (ellipsis) button at the top and choose <strong class="bold">Pull</strong> to fetch and merge the latest changes from the <span class="No-Break">main branch.</span></li>
			</ol>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor126"/>Creating a new feature branch</h2>
			<p>The feature branch model<a id="_idIndexMarker228"/> is a simple<a id="_idIndexMarker229"/> Git-based development approach, ideal for beginners. It maintains up-to-date metadata on the main branch, which should always be release-ready. Definitions of what constitutes “release-ready” or “production-ready” can vary wildly and largely depend on the level of testing applied, both of individual changes and the overall holistic view of your production system and any integrations it may have. For the purposes of demonstrating a workflow here, we shall significantly simplify our definition to mean that changes have had functional testing in your development org, any code reviews (both automated and manual) have been carried out, and a pull reque<a id="_idTextAnchor127"/>st has <span class="No-Break">been approved.</span></p>
			<p>Developers create new branches from the main for features or fixes, merging them back upon completion. Short-lived feature branches minimize merge conflicts and promote tidiness. Smaller deliverables reduce feedback cycle length. To create the feature branch from within VS Code, complete the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>In the <strong class="bold">Source Control</strong> panel, click the branch icon at the bottom-left corner of <span class="No-Break">the window.</span></li>
				<li>Type in the name of the new feature branch (e.g., <strong class="source-inline">feature/JIRA-1234</strong>) and press <em class="italic">Enter</em> to create and switch to the <span class="No-Break">new branch.</span></li>
			</ol>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor128"/>Working on your changes</h2>
			<p>You should now be able to<a id="_idIndexMarker230"/> start your development work against your feature branch. This can be a combination of configuration work in the connected Salesforce org or code-based development in the <span class="No-Break">Salesforce IDE.</span></p>
			<p>The Salesforce extensions for VS Code simplify moving your metadata changes back and forth between your local machine and your development org. Many of the underlying Salesforce CLI commands are available in either the Org Browser, the Command Palette, or as context-sensitive menu options when right-clicking <span class="No-Break">on files.</span></p>
			<h3>Retrieving metadata</h3>
			<ol>
				<li>Open the Org Browser in the side panel in VS Code (you can find it with an icon that resembles <span class="No-Break">a cloud).</span></li>
				<li>If it’s your first time using the Org Browser, or if the metadata for your org has changed, click the refresh icon to retrieve the metadata from <span class="No-Break">your org.</span></li>
				<li>The Org Browser displays a list of metadata types. You can click the arrow next to a metadata type to expand it and see the individual components of <span class="No-Break">that type.</span></li>
				<li>To retrieve a metadata component, click the cloud download icon next to the component’s name. This retrieves the component and adds it to your <span class="No-Break">local project.</span></li>
			</ol>
			<h3>Deploying metadata</h3>
			<ol>
				<li value="1">Navigate to the files or folders you want to deploy in your local <span class="No-Break">project structure.</span></li>
				<li>Right-click on the <span class="No-Break">selected items.</span></li>
				<li>From the context menu, choose the <strong class="bold">SFDX: Deploy Source to Org </strong>command. This deploys the metadata to <span class="No-Break">your org.</span></li>
				<li>Note that the Org Browser does not directly facilitate deployment, but the standard deployment commands in the Salesforce extensions for VS Code are <span class="No-Break">used instead.</span></li>
			</ol>
			<p>Once your <a id="_idIndexMarker231"/>development is complete, test your changes in Salesforce using scratch orgs or sandboxes, as appropriate. We will be looking at the differences between the two types of Salesforce development environments later in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor129"/>Committing your changes</h2>
			<p>The two-step process of<a id="_idIndexMarker232"/> committing changes involves first staging the alterations and then executing the commit. Staging selects modifications for a commit while committing records the staged changes as a new snapshot in the local repository, maintaining development history. You can complete the staging and committing of your changes <span class="No-Break">like so:</span></p>
			<ol>
				<li>In the <strong class="bold">Source Control</strong> panel, review the changes you <span class="No-Break">have made.</span></li>
				<li>Stage the changes by clicking the <strong class="bold">+</strong> icon next to each changed file or by clicking the <strong class="bold">+</strong> icon next to <strong class="bold">CHANGES</strong> to stage <span class="No-Break">all changes.</span></li>
				<li>Enter a meaningful commit message describing the changes related to the Jira ticket (e.g., “<strong class="source-inline">JIRA-1234: Implemented </strong><span class="No-Break"><strong class="source-inline">new feature</strong></span><span class="No-Break">”).</span></li>
				<li>Click the checkmark icon at the top to commit the changes to your <span class="No-Break">feature branch.</span></li>
			</ol>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor130"/>Pushing your feature branch to the remote repository</h2>
			<p>Once our changes are<a id="_idIndexMarker233"/> added to Git locally, we can then move those changes up to the remote repository <span class="No-Break">as follows:</span></p>
			<ol>
				<li>In the <strong class="bold">Source Control</strong> panel, click the <strong class="bold">...</strong> (ellipsis) button at the top and <span class="No-Break">choose </span><span class="No-Break"><strong class="bold">Push</strong></span><span class="No-Break">.</span></li>
				<li>If prompted, select your<a id="_idIndexMarker234"/> feature branch (e.g., “<strong class="source-inline">feature/JIRA-1234</strong>”) to push it to the <span class="No-Break">remote repository.</span></li>
			</ol>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor131"/>Creating a pull request</h2>
			<p>Creating a pull<a id="_idIndexMarker235"/> request in Git is a collaborative process where a developer proposes merging their changes from one branch into another, often from a feature branch into the main branch. This allows for code review, discussion, and potential modifications before integrating the changes. This is also the stage in which automated checks are carried out, such as running tests and static analysis, and this makes pull requests a useful tool for solo developers, not just <span class="No-Break">multi-person teams.</span></p>
			<p>To create the pull request via GitHub, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Open your browser and navigate to your repository <span class="No-Break">on GitHub.</span></li>
				<li>Click the <strong class="bold">Compare &amp; pull request</strong> button next to your recently <span class="No-Break">pushed branch.</span></li>
				<li>Review the changes, and add any additional information or context related to the <span class="No-Break">Jira ticket.</span></li>
				<li>Assign the appropriate reviewers and click <strong class="bold">Create </strong><span class="No-Break"><strong class="bold">pull request</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Alternatively, if you have the <strong class="source-inline">GitHub Pull Requests and Issues</strong> extension installed in VS Code, you can create your new pull request from within the VS Code IDE <span class="No-Break">as follows:</span></p>
			<ol>
				<li>Open the VS Code Command Palette by pressing <em class="italic">Ctrl + Shift + P</em> (Windows or Linux) or <em class="italic">Cmd + Shift + </em><span class="No-Break"><em class="italic">P</em></span><span class="No-Break"> (macOS).</span></li>
				<li>Type <strong class="source-inline">Github: Create Pull Request</strong> and select the option from the list <span class="No-Break">that appears.</span></li>
				<li>Select the base and compare branches for your <span class="No-Break">pull request.</span></li>
				<li>Enter a title and description for your <span class="No-Break">pull request.</span></li>
				<li>Review your changes and make any <span class="No-Break">necessary adjustments.</span></li>
				<li>Click the <strong class="bold">Create Pull Request</strong> button to <a id="_idIndexMarker236"/>submit your <span class="No-Break">pull request.</span></li>
			</ol>
			<h2 id="_idParaDest-113">Addressing feedback a<a id="_idTextAnchor132"/>nd updating the pull request</h2>
			<p>Quite often, there<a id="_idIndexMarker237"/> can be feedback and changes <a id="_idIndexMarker238"/>required to your pull request during the review process. This is a normal part of the review process and helps to deliver quality releases to production by capturing changes early. Thankfully, addressing these changes is as easy as your original commits to Git were – let’s look at the <span class="No-Break">steps required:</span></p>
			<ol>
				<li>If changes are requested during the review process, make the necessary updates in <span class="No-Break">VS Code.</span></li>
				<li>Commit and push the changes to the feature branch in the same way as you did for the original commit of <span class="No-Break">your changes.</span></li>
				<li>The pull request will automatically update with your <span class="No-Break">new changes.</span></li>
			</ol>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor133"/>Merging the pull request</h2>
			<p>Once we reach the<a id="_idIndexMarker239"/> stage where our pull request has been approved and any required changes are complete, we can safely merge it into our upstream branch, <span class="No-Break">like so:</span></p>
			<ol>
				<li>Once the pull request has been approved, click the <strong class="bold">Merge pull request</strong> button <span class="No-Break">in GitHub.</span></li>
				<li>Delete the feature branch if it is no longer needed, either on GitHub or in <span class="No-Break">VS Code.</span></li>
			</ol>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor134"/>Updating your local main branch</h2>
			<p>All that remains for us to do now is to<a id="_idIndexMarker240"/> refresh our local copy of the main branch to ensure we have all the latest changes and everything is correctly in sync. The following steps will <span class="No-Break">achieve this:</span></p>
			<ol>
				<li>In VS Code, switch back to the main branch by clicking the branch icon at the bottom-left corner and <span class="No-Break">selecting </span><span class="No-Break"><strong class="bold">main</strong></span><span class="No-Break">.</span></li>
				<li>Pull the latest <a id="_idIndexMarker241"/>changes exactly as you did at the start of <span class="No-Break">the process.</span></li>
			</ol>
			<p>We have now completed a typical lifecycle of developing a Salesforce feature using SFDX and Git. This represents the most basic DevOps workflow – and in many teams, it can remain as simple <span class="No-Break">as that.</span></p>
			<p>In the next section, we’re going to look at some subtle differences between the most common Salesforce development environments – sandboxes and scratch orgs – and see the use cases <span class="No-Break">for each.</span></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor135"/>Sandboxes versus scratch orgs</h1>
			<p>Scratch orgs<a id="_idIndexMarker242"/> and Salesforce developer <a id="_idIndexMarker243"/>sandboxes serve similar purposes in providing environments for development and testing; however, they differ in several key aspects, which we will <span class="No-Break">discuss here.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor136"/>Sandboxes</h2>
			<p>Salesforce sandboxes<a id="_idIndexMarker244"/> are a copy of your Salesforce environment, including metadata and customizations. Sandboxes are typically used for testing and development purposes such as creating and testing new features, integrating with other systems, or replicating production issues. Developers can use sandboxes to test new features or customizations without affecting the production environment. Sandboxes can also be used for training<a id="_idIndexMarker245"/> and <strong class="bold">user acceptance testing</strong> (<strong class="bold">UAT</strong>) to ensure that changes are thoroughly tested before deployment. Additionally, sandboxes can be used for integration testing, disaster recovery, and as a backup in case of data loss or <span class="No-Break">system failure.</span></p>
			<p>Salesforce sandboxes are used for development and testing, and four different types are available, each with different features, purposes, refresh cycles, and <span class="No-Break">storage limits:</span></p>
			<ul>
				<li>The Full Copy sandbox<a id="_idIndexMarker246"/> is a complete copy of your production <a id="_idIndexMarker247"/>environment, including all metadata and data. It is typically used for testing and development purposes that require a full replica of the production environment, such as performance<a id="_idIndexMarker248"/> testing, <strong class="bold">UAT</strong>, and training. However, you should be aware that these sandboxes can only be refreshed from production every 29 days. Full Copy sandboxes also don’t support source tracking, so they are not suited for being your primary development environment <span class="No-Break">for SFDX.</span></li>
				<li>The Partial Copy sandbox<a id="_idIndexMarker249"/> includes a subset of your production environment data, as <a id="_idIndexMarker250"/>well as all metadata. It is typically used for testing and development purposes that require a smaller dataset than a Full Copy, such as feature development or regression testing. This type of sandbox is not provided as standard and is an additional license cost from Salesforce. Unlike the Full Copy sandbox, Partial Copy sandboxes can be refreshed every five days, but like the Full Copy sandboxes, they don’t support <span class="No-Break">source tracking.</span></li>
				<li>The Developer sandbox<a id="_idIndexMarker251"/> is a dedicated environment for individual developers <a id="_idIndexMarker252"/>or small teams. It includes all metadata but no data. It is typically used for individual feature development or testing. Most orgs will have far more Developer sandboxes available than the Full Copy or Partial Copy ones (usually limited to one of each unless you purchase additional ones). They can be refreshed daily but don’t bring across any data, and have a much smaller <span class="No-Break">data capacity.</span></li>
				<li>The Developer Pro sandbox<a id="_idIndexMarker253"/> is similar to a Developer sandbox but has a <a id="_idIndexMarker254"/>larger storage capacity. It is typically used for more complex development and testing tasks, such as integrations or <span class="No-Break">app development.</span></li>
			</ul>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor137"/>Scratch orgs</h2>
			<p>Scratch orgs are<a id="_idIndexMarker255"/> disposable, temporary environments that can be quickly created and deleted. They are primarily used for agile development, such as building and testing new features in a short amount <span class="No-Break">of time.</span></p>
			<p>The lifespan of a scratch org is inherently temporary, with a maximum duration of 30 days. This ephemeral nature encourages developers to follow a source-driven development approach, where the version control system serves as the single source of truth. In contrast, Developer sandboxes<a id="_idIndexMarker256"/> are more persistent environments that may exist for extended periods, making it easier for developers to unintentionally accumulate outdated or unused code <span class="No-Break">and configurations.</span></p>
			<p>Scratch orgs are designed to be lightweight and rapidly configurable. They can be created and customized with specific features, settings, and data needed for a particular project by adjusting the scratch org definition file. This makes it easy for developers to create multiple scratch orgs tailored to different projects or tasks. On the other hand, Developer sandboxes are created as a copy of the production environment, including all customizations and a subset of the data, which can make them less cumbersome and time-consuming to set up <span class="No-Break">and configure.</span></p>
			<p>By default, when a scratch org is created, it doesn’t have any connection to the features or metadata enabled in your production org. It’s created according to a generic template with a base set of features. This means that the newly created scratch org won’t reflect your production org’s specific characteristics or customization, which can be challenging if you’re developing and testing features tied to those specific settings <span class="No-Break">or metadata.</span></p>
			<p>To overcome this, Salesforce introduced the concept of a definition file. A definition file is a JSON file that specifies the shape of the scratch org or the characteristics that you want the scratch org to have. It can define preferences for features, settings, and editions. For example, the definition file might include instructions to enable certain Salesforce features, such as Einstein Analytics or <span class="No-Break">person accounts.</span></p>
			<p>Creating a definition file manually allows you to tailor your scratch org to match your production environment. However, manually creating a definition file that exactly matches a complex production org can be time-consuming and <span class="No-Break">potentially error-prone.</span></p>
			<p>To help with this, Salesforce has introduced the concept of an org shape. An org shape<a id="_idIndexMarker257"/> is essentially a snapshot of your production org’s features and settings, which you can use as a template when creating scratch orgs. By using an org shape, you can quickly and accurately recreate the environment of your production org in a scratch org without having to manually specify all the settings in a <span class="No-Break">definition file.</span></p>
			<p>The preceding combination of being short-lived, lightweight, and configurable means that scratch orgs are more conducive to <a id="_idIndexMarker258"/>supporting <strong class="bold">continuous integration and continuous delivery</strong> (<strong class="bold">CI/CD</strong>) processes. The disposable nature of scratch orgs allows developers to rapidly create, test, and destroy environments as needed, enabling seamless integration into CI/CD pipelines. Developer sandboxes, with their longer lifespan and more complex setup, may not be as well suited for such <span class="No-Break">automated workflows.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor138"/>Summary</h1>
			<p>In this chapter, we covered an end-to-end lifecycle of using the standard stack of Salesforce and source control tools. Let’s recap what that <span class="No-Break">process entailed.</span></p>
			<p>We looked at how to initialize or clone a Git repository to the local machine, ensuring we had the latest version of the code base. Using VS Code, we were able to easily access and manage the source code, as well as run SFDX commands within the integrated terminal or from the built-in Command Palette within VS Code and the Salesforce <span class="No-Break">extensions pack.</span></p>
			<p>Before starting the development process, we created a new branch in the Git repository to represent the specific feature or task we were working on. This branch is typically named according to the associated Jira ticket to maintain traceability and organization. Once the feature branch was created, we switched to the new branch and started implementing the <span class="No-Break">required changes.</span></p>
			<p>As part of the development process, we made use of SFDX tools to create, retrieve, and deploy metadata components. Although we used a sandbox environment in our example, we could also have leveraged scratch orgs – temporary Salesforce environments – to test and iterate on our changes before finalizing the code. Throughout this process, we committed our changes to the feature branch, providing clear and concise commit messages to maintain a <span class="No-Break">comprehensive history.</span></p>
			<p>Once the development was complete and the changes were thoroughly tested, we pushed the feature branch to the remote Git repository. At this point, we were then ready to create a pull request to merge the feature branch into the main branch. The pull request serves as an opportunity for team members to review the changes, provide feedback, and suggest improvements. It also acts as a quality assurance measure to ensure that the code base remains stable and maintains the desired level <span class="No-Break">of quality.</span></p>
			<p>Upon receiving approval from the team, we could then merge the feature branch into the main branch using the pull request. The main branch was then ready to be deployed to a staging or production environment for further testing <span class="No-Break">and validation.</span></p>
			<p>Once the deployment was successful, the feature branch could be deleted, both locally and on the remote repository, to maintain a clean and organized <span class="No-Break">code base.</span></p>
			<p>The use of pull requests, Jira ticket-based feature branches, and the collaborative review process ensures a high-quality, traceable, and maintainable code base throughout the Salesforce <span class="No-Break">development lifecycle.</span></p>
			<p>This entire workflow was achieved with freely available tools and provided the simplest entry point to a Salesforce DevOps process. As your needs grow, it will become more important to look at the power of automation, especially in the context <span class="No-Break">of CI/CD.</span></p>
			<p>We will look at CI/CD in more detail in <a href="B19436_07.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>. Ahead of that, though, in the next chapter, we’ll take another approach to Salesforce change management by looking <span class="No-Break">at packaging.</span></p>
		</div>
	</body></html>