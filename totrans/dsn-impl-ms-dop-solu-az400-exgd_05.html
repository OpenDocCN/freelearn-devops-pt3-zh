<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer061">
<h1 class="chapter-number" id="_idParaDest-93"><a id="_idTextAnchor177"/>5</h1>
<h1 id="_idParaDest-94"><a id="_idTextAnchor178"/><a id="_idTextAnchor179"/><a id="_idTextAnchor180"/>Moving to Continuous Integration</h1>
<p>After setting up source control for your organization and deciding on a branching and merging strategy that supports parallel work, you are ready to move on to continuous integration. Continuous integration<a id="_idIndexMarker369"/> is a method where every developer takes their work and integrates it with the work of others, and then verifies the quality of the combined work. The value of this is an increase in quality early on in the pipeline. This reduces the risk of error later on when merging code changes and reduces the number of bugs that are found in production, thereby reducing costs and protecting your reputation.</p>
<p>Continuous integration is only possible when you have the proper setup with the necessary tools. In this chapter, you will learn how to use Azure DevOps pipelines to set up continuous integration.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Introducing continuous integration</li>
<li>Creating a build definition </li>
<li>Running a build</li>
<li>Working with YAML pipelines</li>
<li>Agents and agent queues</li>
<li>Automate <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) builds using GitHub Actions<a id="_idTextAnchor181"/></li>
<li>Other tools<a id="_idTextAnchor182"/></li>
</ul>
<h1 id="_idParaDest-95"><a id="_idTextAnchor183"/>Technical requirements</h1>
<p>To go through the examples that are covered in this chapter, you will need the following:</p>
<ul>
<li>An Azure DevOps organization</li>
<li>Git command-line tools</li>
<li>A code editor such as Visual Studio Code <a id="_idTextAnchor184"/><a id="_idTextAnchor185"/><a id="_idTextAnchor186"/></li>
</ul>
<h1 id="_idParaDest-96"><a id="_idTextAnchor187"/>Introducing continuous integration</h1>
<p><strong class="bold">Continuous integration</strong> is<a id="_idIndexMarker370"/> a methodology where you integrate your own changes with those of all of the other developers in your project and test whether the combined code still works as expected. This way, you create a fast loop that provides you with feedback on your work.</p>
<p>When working with extensive branching strategies for isolating code changes, it is not uncommon for one or more developers to work for days, weeks, or even months on an isolated branch. While this is great for making sure that their changes do not disrupt others, continuous integration is a great way to make sure that there won’t be merge issues later. If you have ever had to merge weeks or months of work back into the main branch, you will know how much work is involved and how often this results in bugs or other issues.</p>
<p>To prevent this, developers should make it a habit to integrate their changes with those of all the other developers at least once a day. Here, integrating means at least merging, compiling, and running unit tests. This way, there is a constant stream of feedback on the quality of the developer’s changes, and since this feedback is combined, it is a great way to prevent merge issues later.</p>
<p>Continuous integration also enables you to embed other concerns in your pipeline to automatically preserve the quality of your code. Static code analysis, unit testing, and security scanning are three prime examples of this. These topics are discussed in later chapters, but a good continuous integration pipeline is the basis for these practices.</p>
<p>In the rest of this chapter, you will learn about the technical means to set up continuous integration using Azure Pipelines. But first, let’s look at a common misconception and the four pillars of continuous integration.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">While an automated continuous integration build is an important ingredient for performing continuous integration, continuous integration entails more than just having a build pipeline. The important thing to remember is that continuous integration is a process where every developer integrates their work with that of their colleagues at least daily. Then, the integrated sources are compiled and tested. The value comes from compiling and testing the integrated work, not the isolated work<a id="_idTextAnchor188"/><a id="_idTextAnchor189"/><a id="_idTextAnchor190"/>.</p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor191"/>The four pillars of continuous integration</h2>
<p>There are four<a id="_idIndexMarker371"/> pillars that underpin the successful adoption of continuous integration:</p>
<ul>
<li><strong class="bold">A version control system</strong>: Used for<a id="_idIndexMarker372"/> storing all of the changes made to a system since its inception. Version control systems were discussed in the previous chapter.</li>
<li><strong class="bold">A package management system</strong>: Used to <a id="_idIndexMarker373"/>store the binary packages that you use in your own application and the packages that you create. This will be discussed in detail in <a href="B18655_07.xhtml#_idTextAnchor453"><em class="italic">Chapter 7</em></a>, <em class="italic">Dependency Management</em>.</li>
<li><strong class="bold">A continuous integration system</strong>: A <a id="_idIndexMarker374"/>system that can pull the changes of all developers together – several times a day – and create one integrated source version. This can be done using Azure DevOps pipelines.</li>
<li><strong class="bold">An automated build process</strong>: Used to<a id="_idIndexMarker375"/> compile and test the combined sources. We will look at how to implement this process using <a id="_idIndexMarker376"/>Azure DevOps pipelines.</li>
</ul>
<p>Continuous integration and automated builds can be set up in Azure DevOps. T<a id="_idTextAnchor192"/>he next section explains how to set both up in Azure <a id="_idTextAnchor193"/>DevOps.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor194"/>Creating a build definition in Azure DevOps</h1>
<p>The<a id="_idIndexMarker377"/> main way to perform continuous integration is by <a id="_idIndexMarker378"/>using a continuous integration build. In Azure DevOps, builds can be configured as part of the Azure Pipelines offering. There are currently two approaches available for creating a build definition:</p>
<ul>
<li>Via the<a id="_idIndexMarker379"/> visual <a id="_idIndexMarker380"/>designer (also called <strong class="bold">classic builds and releases</strong>)</li>
<li>Through <strong class="bold">Yet Another Markup Language</strong> (<strong class="bold">YAML</strong>) files (also called YAML pipelines or <a id="_idIndexMarker381"/>multistage pipelines)</li>
</ul>
<p>The rest of this section will focus on the visual designer. The following section, <em class="italic">YAML build definitions</em>, will go into more detail about YAML pipelines. Both approaches support roughly the same capabilities, although there are some differences. Some features that are available in classic builds and releases are not (yet) available in YAML build definitions. Also, some new features are only provided to YAML pipelines.</p>
<p>If you have no <a id="_idIndexMarker382"/>experience with pipelines, the<a id="_idIndexMarker383"/> classic editor is a good way to get familiar with the workings of continuous integration/continuous development pipelines before moving on to YAML pipelines. Almost all of the concepts in classic builds translate to YAML builds as well.</p>
<p>In the following sections, we will start by building a classic b<a id="_idTextAnchor195"/><a id="_idTextAnchor196"/><a id="_idTextAnchor197"/>uild pipeline.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor198"/>Connecting to source control</h2>
<p>To<a id="_idIndexMarker384"/> get started with a build definition, follow these simple steps:</p>
<ol>
<li>Open the <strong class="bold">Pipelines</strong> menu.</li>
<li>From this menu, click on <strong class="bold">Builds</strong>. Here, you will be presented with a button to create a new build. After clicking on this button, a new view for creating a build will open, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer039">
<img alt="Figure 5.1 – Source code repository options for pipelines  " height="515" src="image/B18655_05_01.jpg" width="605"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Source code repository options for pipelines </p>
<ol>
<li value="3">You <a id="_idIndexMarker385"/>will then be guided to the new YAML experience, but you can still opt to go back by choosing the classic editor.</li>
</ol>
<p>After choosing the classic editor, you can configure how to connect to the source control. The classical editor<a id="_idIndexMarker386"/> is the editor that is visible in all of the screenshots in the following sections.</p>
<p>Many source control systems are supported. If you are working with a hosted Git repository, pick your specific product, if available, and only choose <strong class="bold">Other Git</strong> if your product is not available; currently, <strong class="bold">GitHub</strong>, <strong class="bold">GitHub Enterprise Server</strong>, and <strong class="bold">Bitbucket Cloud</strong> are supported. The reason for this is that continuous integration using <strong class="bold">Other Git</strong> works by using a polling model, where all the specific products use their known integration Webhooks. The following example works with a Git repository that is in the same Azure DevO<a id="_idTextAnchor199"/>ps organization.</p>
<p>When you select the <strong class="bold">Pipeline</strong> header, you can set the name of the build definition and select an agent pool that the phases will run on by default. Agents take care of the actual execution of your tasks and will be looked at in more detail in the <em class="italic">Agents and agent queues</em> section of this chapter.</p>
<p>Below the <strong class="bold">Pipeline</strong> header, you can see the chronological layout of your build definition. First up is downloading sources. Here, you can once again choose to connect to a source control system. You can also specify more advanced settings that relate to<a id="_idTextAnchor200"/> the way sources are fetched, such as whether to clean the build directory first, select a bran<a id="_idTextAnchor201"/>ch, or add tags.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor202"/>Configuring a job</h2>
<p>Below the source’s node, you can add one or more jobs that will perform the bulk of the work that you want to perform. Jobs can be added using the ellipsis on the <strong class="bold">Pipeline</strong> header. There are two types of jobs available:</p>
<ul>
<li><strong class="bold">Agentless jobs</strong>: Agentless jobs <a id="_idIndexMarker387"/>can be used to run tasks that do not require an agent. They are run on Azure DevOps Server. </li>
<li><strong class="bold">Agent jobs</strong>: Agent jobs <a id="_idIndexMarker388"/>are used to run tasks that require an agent to run on, which is the case for the bulk of the tasks.</li>
</ul>
<p>Some examples of agentless tasks<a id="_idIndexMarker389"/> are as follows:</p>
<ul>
<li>Waiting for manual approval before continuing</li>
<li>Inserting a delay before proceeding</li>
<li>Calling a REST API </li>
<li>Calling an Azure function</li>
</ul>
<p>The main benefit of an <a id="_idIndexMarker390"/>agentless job is that it does not keep an agent occupied while running. This frees the agent up to do other work, meaning that you need fewer agents, which can save costs. Also, the number of agents that you can use concurrently is governed by the number of parallel pipelines that you have bought in Azure DevOps. Limiting the number of agent jobs will save<a id="_idTextAnchor203"/> money here as well.</p>
<p>Let’s go over the <a id="_idIndexMarker391"/>process of configuring a job:</p>
<ol>
<li value="1">Select any job. You will see the view shown in the following screenshot. In this view, you can change the name of the job and, for agent jobs, override the agent pool to execute this job on:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 5.2 – Add/update jobs for the pipeline " height="884" src="image/B18655_05_02.jpg" width="1334"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Add/update jobs for the pipeline</p>
<ol>
<li value="2">Next, specify which<a id="_idIndexMarker392"/> agent pool to use for running the job. Here, it also specifies the demands that you have of the agent that will execute this job. Demands will be discussed in the <em class="italic">Agents and agent queues</em> sec<a id="_idTextAnchor204"/>tion of this chapter.</li>
<li>As part of the execution plan for an agent, you can specify <strong class="bold">Parallelism</strong> and choose one of three options:<ul><li><strong class="bold">None</strong>: This will just execute all the tasks you add to the agent job one after another on the same agent.</li><li><strong class="bold">Multi-configuration</strong>: Here, you can specify a series of variables that determine the number of variations of the build to run. This is useful if you want to create, for example, x86 and x64 builds from the same code.</li><li><strong class="bold">Multi-agent</strong>: Here, you can specify the number of agents that will run the same tasks in parallel.</li></ul></li>
<li>Next, you can specify one or more dependencies. These are the other jobs that need to be completed before the selected job runs.</li>
<li>Also, for any job, you can specify how to cope with errors in previous jobs by telling it to continue or stop.</li>
</ol>
<p>As an alternative to <em class="italic">step 3</em> and <em class="italic">step 4</em>, you can also specify a custom expression to specify whether a job should run. This expression should evaluate to a Boolean and support rudimentary operations, such as <strong class="source-inline">or()</strong>, <strong class="source-inline">and()</strong>, or <strong class="source-inline">eq()</strong>. The following is an example condition:</p>
<pre class="source-code">
and(succeeded(), ne(variables['Build.SourceBranch'], 'refs/heads/main'))</pre>
<p>This condition specifies that <a id="_idIndexMarker393"/>the job will only run when all previous jobs have succeeded and the build is not started from the main branch. A link to a detailed description of the conditions syntax is included at the end of this chapter.</p>
<p>Agentless jobs have fewer options available than agent jobs. For example, it is not possible to execute the same build for multiple variab<a id="_idTextAnchor205"/><a id="_idTextAnchor206"/><a id="_idTextAnchor207"/>le values in parallel.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor208"/>Adding tasks to your job</h2>
<p>After<a id="_idIndexMarker394"/> adding one or more jobs, you can add tasks to a job. Tasks define the <a id="_idIndexMarker395"/>actual work that is to be done during the execution of your build. The following screenshot shows you how to add a task and then configure it:</p>
<ol>
<li value="1">Click on the plus sign next to the job you want to add tasks to:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="Figure 5.3 – Select a task and specify the configuration parameters for the job " height="772" src="image/B18655_05_03.jpg" width="1608"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Select a task and specify the configuration parameters for the job</p>
<ol>
<li value="2">You will then be presented with a task picker, where you can find any task that matches your search input and add one or more tasks by clicking the <strong class="bold">Add</strong> button. A new screen will then open, where you can configure the individual task. The options provided here differ for each task.</li>
<li>There can be multiple versions of a task, and you can switch between the major versions of it. This means that the maintainer can push non-breaking updates and you will receive them <a id="_idIndexMarker396"/>automatically. Major or breaking updates can be pushed with a <a id="_idIndexMarker397"/>new major version number, and you can upgrade them at your own discretion.</li>
</ol>
<p>It is possible to add as many tasks as <a id="_idTextAnchor209"/><a id="_idTextAnchor210"/><a id="_idTextAnchor211"/>needed to a pipeline job.</p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor212"/>Publishing build artifacts</h2>
<p>An important part of a<a id="_idIndexMarker398"/> build definition is its outcomes. Builds are often used to produce one or more artifacts that are later used for the deployment of an application. Examples of artifacts can be executables or installer files. These files need to be made available for use after the execution of the build pipeline has beencompleted.</p>
<p>The <strong class="bold">Publish Build Artifacts</strong> task that is shown in the preceding screenshot is a task that is specifically designed to do this. It allows you to select a file or directory and publish it under an <strong class="bold">artifact name</strong>. The result of this is that the file(s) in the selected path are retained with every execution of the pipeline for manual download or use in a release definition later. Release <a id="_idIndexMarker399"/>definitions will be discussed in <a href="B18655_06.xhtml#_idTextAnchor330"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Continuous Deployment and Release Management</em>.</p>
<p>Next, we’ll learn how to integrate our pipeline with other tool<a id="_idTextAnchor213"/>s and config<a id="_idTextAnchor214"/>ure our service connection.</p>
<h3>Calling other tools</h3>
<p>When building pipelines, we will often need to integrate them with other tools. For source control systems, this is part of the flow when creating a pipeline and you are limited to the built-in options. For tasks, you can create references to any tool or location you want using service connections. An example of a task that uses a service connection to an Azure app service is show<a id="_idTextAnchor215"/>n in the following section.</p>
<p>A service connection<a id="_idIndexMarker400"/> is a pointer to an external system, with a name and series of properties that differ for each type of service connection. Often, you will need to put in a URL to locate the other service and a mechanism for authentication. The following steps will help you configure your service connection:</p>
<ol>
<li value="1">After defining one or<a id="_idIndexMarker401"/> more service connections, you can select the one to use from a drop-down menu:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer042">
<img alt="Figure 5.4 – Use the service connection in the task " height="837" src="image/B18655_05_04.jpg" width="1146"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Use the service connection in the task</p>
<ol>
<li value="2">Service <a id="_idIndexMarker402"/>connections are managed in a central location as project settings. You can access them by going to the management view directly from the task you are currently configuring, as shown in the preceding screenshot. You can also do this by navigating to <strong class="bold">Project Settings</strong> and then to <strong class="bold">Service connections</strong>, as in the following screenshot (see <strong class="bold">2</strong>):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="Figure 5.5 – Service connection dialog " height="844" src="image/B18655_05_05.jpg" width="1181"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5<a id="_idTextAnchor216"/> – Service connection dialog</p>
<ol>
<li value="3">In this view, you<a id="_idIndexMarker403"/> can then either add a new service connection or update an existing service connection (see <strong class="bold">2 </strong>and<strong class="bold"> 3</strong> in the preceding screenshot).</li>
</ol>
<p>By default, service connections are scoped to the project level, meaning they are not available for everyone in the Azure DevOps organization. To e<a id="_idTextAnchor217"/>ncourage the reuse of service connections, Azure has made it possible to share them bet<a id="_idTextAnchor218"/>ween projects since mid-2019.</p>
<h3>Task Marketplace</h3>
<p>A set of frequently used tasks is<a id="_idIndexMarker404"/> built into Azure Pipelines; however, there are even more available using the Visual Studio Marketplace for Azure DevOps. If you are an administrator of the DevOps organization, you can find and install extensions that add tasks here. If you are a regular user, you can find tasks here as well; however, you cannot install them, only request them. Your Azure DevOps administrator will then be notified and can install the extension on your behalf if they approve.</p>
<p>Of course, you can write and distribute extensions w<a id="_idTextAnchor219"/><a id="_idTextAnchor220"/><a id="_idTextAnchor221"/>ith tasks of your own as well.</p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor222"/>Creating variables and variable groups</h2>
<p>When you are configuring your build, there might be values that you need to use more than once. It is often wise to extract these values into variables, rather than just repeating them throughout your tasks.</p>
<p>Variables <a id="_idIndexMarker405"/>can be used to note down values that you do not want to have stored in source control. Values such as passwords and license keys can be safely stored as non-retrievable values when locked down using the lock symbol (see <strong class="bold">1</strong> in the following screenshot). After saving the build definition, these values are encrypted and can only be used by the build that they belong to. </p>
<p>To learn how to work with variables<a id="_idIndexMarker406"/> in Azure Pipelines, go through the following steps:</p>
<ol>
<li value="1">In Azure Pipelines, you can add variables to your build definition by going to the <strong class="bold">Variables</strong> | <strong class="bold">Pipeline variables</strong> tab (see <strong class="bold">3</strong> in the following screenshot). Here, you can enter them as name values, as can be seen in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="Figure 5.6 – Pipeline variables  " height="395" src="image/B18655_05_06.jpg" width="1179"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Pipeline variables </p>
<ol>
<li value="2">Once defined, you can use the variables in the configuration of all tasks in all jobs of the same build. For this, you can use the following notation:<p class="source-code">$(variableName)</p></li>
<li>Finally, you can mark <a id="_idIndexMarker407"/>variables as <strong class="bold">Settable at queue time</strong> (see <strong class="bold">2</strong> in the preceding screenshot), which means that their value can be changed whenever someone queues a new build. An example of a variable for which this is used is the <strong class="source-inline">system.debug</strong> built-in variable. When this variable is set to <strong class="source-inline">true</strong>, there is a verbose debu<a id="_idTextAnchor223"/>g logging included in the build.</li>
</ol>
<p>Next to your own variables, system variables are also defined. These are variables that contain information about the build that is currently running, including version numbers, agent names, build definition details, and the source ver<a id="_idTextAnchor224"/>sion. A link to the full list of system-defined variables is incl<a id="_idTextAnchor225"/>uded at the end of this chapter.</p>
<h3>Variable groups</h3>
<p>As well as creating the<a id="_idIndexMarker408"/> variables that go with a specific build, you can create variable groups. These variable groups can, in turn, be linked to one or more builds. This is an effective way of sharing variables between builds; some examples of these might be the name of your company, trademark texts, and product names. Let’s see how we can work <a id="_idIndexMarker409"/>with variable groups:</p>
<ol>
<li value="1">Access variable groups through the menu by clicking on <strong class="bold">Library</strong> in the <strong class="bold">Pipelines</strong> menu (see <strong class="bold">1</strong> in the following screenshot). This displays a list of the existing variable groups that you can edit, and you can add a new group here as well, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer045">
<img alt="Figure 5.7 – A new variable group  " height="556" src="image/B18655_05_07.jpg" width="721"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">F<a id="_idTextAnchor226"/>igure 5.7 – A new variable group </p>
<ol>
<li value="2">Here, you can work with<a id="_idIndexMarker410"/> variables in the same way that you would with the variables that come with a build. The only differences are highlighted in the following list:<ul><li>You cannot mark variables in a group as settable at queue time.</li><li>You can allow or deny the use of this group in all pipelines. If you deny their use in all pipelines, then only you can use the variable group. You can authorize other users or groups through the <strong class="bold">Security</strong> option (see <strong class="bold">2</strong> in the preceding screenshot).</li><li>You can reference an <a id="_idIndexMarker411"/>Azure key vault for which this variable group will act as a placeholder. After logging into Azure, you can select a key vault and which values that are stored in the key vault you want to be accessible through the variable group.</li></ul></li>
</ol>
<p><strong class="bold">Azure Key Vault</strong> is an<a id="_idIndexMarker412"/> Azure offering that can be used for the secure storage of secrets. Secrets in a key vault are automatically versioned, so older values are not overwritten but replaced by a newer version. In addition to this, you can specify segregated access policies that specify, per user, whether they can read, write, update, or delete values. All these actions are audited in a key vault, so you can also find who has made which change. If you are linking Azure DevOps to a key vault, then a new service principal will be created in your active directory that has access to that key vault. Now, whenever Azure DevOps needs a variable from the variable group, the actual values will be pulled from the key vault.</p>
<p>Variable groups can be linked to the variables of a build under the <strong class="bold">Variable group</strong> tab (refer to the screenshot in <em class="italic">Figure 5.7</em>).</p>
<p>As well as working with variable groups, you can also work with files in the library. You can upload files that are not accessible by other users but that can be used within a build. This is useful for files with private keys, license keys, and other secrets. Refer to this link for more <a id="_idIndexMarker413"/>information: <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops</a>.</p>
<p>Just as you can with variable groups, you can specify<a id="_idTextAnchor227"/> whether each secure file can be used by any bu<a id="_idTextAnchor228"/>ild or authorize specific users only.</p>
<h3>Triggering the build</h3>
<p>The next tab in a build definition <a id="_idIndexMarker414"/>governs what should start or trigger the build. To implement continuous integration, go through the following steps:</p>
<ol>
<li value="1">Click on the <strong class="bold">Triggers</strong> tab and select the first header on the left:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 5.8 – Defining triggers for the pipeline " height="409" src="image/B18655_05_08.jpg" width="965"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8<a id="_idTextAnchor229"/> – Defining triggers for the pipeline</p>
<ol>
<li value="2">Check the <strong class="bold">Enable continuous integration</strong> box. This means that Azure DevOps will track for changes in your repository and queue a new build as soon as a new chance is available.</li>
<li>Next, you can choose whether you want to build every incoming change individually or batch multiple changes when more than one new change comes in while building a change. It is recommended that you build every single change separately if this is feasible.</li>
<li>Along with the <a id="_idIndexMarker415"/>continuous integration trigger, specify one or more branch and path filters. Here, you can specify which branches and files to queue a new build for. You can specify either inclusions or exclusions, depending on your needs. A common example is to limit your build to the main branch. If you have folders named <strong class="source-inline">doc</strong> and <strong class="source-inline">src</strong> in your repository and all your sources are in the latter folder, then it might make sense to limit the trigger to this path.</li>
<li>As well as choosing to have a continuous integration trigger, you can also opt to execute a build on a recurring schedule where you select one or more weekdays and a time.</li>
<li>You can also schedule a build <a id="_idIndexMarker416"/>to run whenever another build completes. This is <a id="_idIndexMarker417"/>called <strong class="bold">chaining</strong> builds.</li>
</ol>
<p>Next, let’s learn how to change the<a id="_idTextAnchor230"/><a id="_idTextAnchor231"/><a id="_idTextAnchor232"/> configurations of our build definition.</p>
<h3>Build options</h3>
<p>You can change the<a id="_idIndexMarker418"/> advanced configuration options for your build definition. These options include a description, the format of the build number, and the automated creation of work items on failures and times. To set this up, go through the following steps:</p>
<ol>
<li value="1">Click on the <strong class="bold">Options</strong> tab. You should arrive at the following screen:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer047">
<img alt="Figure 5.9 – Build options " height="786" src="image/B18655_05_09.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Build options</p>
<ol>
<li value="2">Now, create your build number format. If this field is left empty, then the build number for your application will be set to an ever-increasing number that will increase by one with every build. This number is unique within a team project and counts over all the build definitions. You can also specify a format of your own using the variables available to you. A common approach is to specify a major and minor version number manually and then add an increasing number using a variable. The following example specifies a version of 4.1.xx, where the last part is replaced by a tw<a id="_idTextAnchor233"/>o-digit increasing number:<p class="source-code">4.1($Rev:.rr)</p></li>
<li>On the right, there are advanced (but rarely used) options for specifying the authorization scope for the <strong class="bold">Build job</strong> timeouts for each job in the build definition.</li>
<li>It is also<a id="_idIndexMarker419"/> possible to specify the agent demands that every agent, for every job in the build definition, should fulfill. Again, we will look further at demands in the <em class="italic">Agents <a id="_idTextAnchor234"/>and agent queues</em> section of this chapter.</li>
</ol>
<p>Other options on the left enable<a id="_idTextAnchor235"/> you to suspend the pipeline temporarily.</p>
<h3>Build history</h3>
<p>The <a id="_idIndexMarker420"/>final tab, called <strong class="bold">History</strong>, shows you a list of every change that has been made to the build definition. Build definitions are stored in JSON format, and you can pull up side-by-side comparisons for every change. The comment that you put in when saving a build is also stored here and can be used to provide the rationale for a change. You can revert to an older version of the pipeline as well. </p>
<p>Since builds are an important means of preserving quality, it is important to keep track of who has changed them to ensure that automated quality metrics are not removed.</p>
<p>With this, you are now ready to run your first build. You can directly run it using the <strong class="bold">Save &amp; queue</strong> button that is visible in most of the screenshots in this section. The <em class="italic">Running a build</em> section of this chapter will teach<a id="_idTextAnchor236"/> you how<a id="_idTextAnchor237"/> to work with the results that you obtain.</p>
<h3>Task groups</h3>
<p>When working in a <a id="_idIndexMarker421"/>team or organization that has more than one pipeline, it often doesn’t take long before multiple pipelines that have the same shape emerge. For example, in some companies, all pipelines contain tasks for security scanning, running tests, and calculating the test coverage.</p>
<p>Instead of repeating these tasks everywhere, they can be extracted from an existing pipeline into a task group. Task groups, in turn, can be used within multiple pipelines as if they are tasks themselves. Doing this reduces the effort needed to create a new pipeline or update all the pipelines with a new requirement. Doing this also ensures that all the pipelines using the t<a id="_idTextAnchor238"/>ask group have the same task configuration.</p>
<p>To create a new <a id="_idIndexMarker422"/>task group, open any existing build definition and go through the following steps:</p>
<ol>
<li value="1">Select one or more tasks by clicking on them while holding down <em class="italic">Ctrl</em>, or by using the selectors that appear when hovering the mouse over a task:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Figure 5.10 – Creating a task group " height="1033" src="image/B18655_05_10.jpg" width="1629"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Creating a task group</p>
<ol>
<li value="2">Right-click on the selection and select <strong class="bold">Create task group</strong>.</li>
<li>In the popup that now appears (not shown in the screenshot), choose a name, description, and category for the task group. If any of the selected tasks have a variable value specified, you can now provide a default value and description for these parameters. These parameters will be available within the task group and need to be configured when the task group is used.</li>
<li>After<a id="_idIndexMarker423"/> clicking <strong class="bold">Create</strong> (not shown in the screenshot), the existing build definition is updated by removing the selected tasks and replacing them with the new task group.</li>
</ol>
<p>Adding an already existing task group to a build or release definition is done in precisely the same way as adding regular tasks. Task groups show <a id="_idTextAnchor239"/>up in the same list of tasks to choose from.</p>
<p>A list of all the existing task groups can be found by navigating to the <strong class="bold">Pipelines</strong> menu and then <strong class="bold">Task groups</strong>. To edit an existing task group, select it in the list that is shown, and then select the <strong class="bold">Edit</strong> option. Editing task groups works in precisely the same way as editing a build definition.</p>
<p>This section was all about creating a build <a id="_idTextAnchor240"/>definition and describing how an application should be built. Th<a id="_idTextAnchor241"/>e next section is about executing the build.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor242"/>Running a build</h1>
<p>In this section, you <a id="_idIndexMarker424"/>will learn how to work with the build results and use them to report and generate builds. You will also learn h<a id="_idTextAnchor243"/>ow to run a build with every pull request and report the quality of the changes back<a id="_idTextAnchor244"/> to that pull request to assist the reviewer.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor245"/>Viewing the build results</h2>
<p>While a <a id="_idIndexMarker425"/>build is running, an agent will perform all the configured steps. Azure Pipelines will capture detailed information and logs from all these steps. As you can see in the following screenshot, a build will display a list of all the steps it has executed on the left. Clicking on any of these steps will open a detailed view that displays the<a id="_idTextAnchor246"/> logs per step:</p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 5.11 – Build results " height="744" src="image/B18655_05_11.jpg" width="1309"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Build results</p>
<p>Whenever there<a id="_idIndexMarker426"/> are warnings or erro<a id="_idTextAnchor247"/>rs during the buil<a id="_idTextAnchor248"/>d, they show up in orange or red, respectively.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor249"/>Building a pull request</h2>
<p>After setting up your <a id="_idIndexMarker427"/>build definition and running your first builds, you might also see the first failures coming in – for example, when someone accidentally commits and pushes changes that do not compile or contain unit tests that do not run successfully. You can prevent this by having a build definition run automatically whenever a pull request comes in. To configure this, go through the following steps:</p>
<ol>
<li value="1">Click on <strong class="bold">Policies</strong> under <strong class="bold">Project Settings</strong>. The following screen will open. Click on <strong class="bold">Add build<a id="_idTextAnchor250"/> policy</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 5.12 – Adding a build policy " height="829" src="image/B18655_05_12.jpg" width="1208"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – Adding a build policy</p>
<ol>
<li value="2">Select a build definition that you want to use to validate the pull request.</li>
<li>Next, there will be three more things that you can configure:<ul><li><strong class="bold">Trigger</strong>: When the build definition should start, either automatically or manually. Of course, the real value comes from running a verification build automatically.</li><li><strong class="bold">Policy requirement</strong>: This determines whether a pull request can be completed if the build fails. In other words, this determines whether you can ignore a failing build. It is recommended that you avoid setting this to <strong class="bold">Optional</strong>, if possible.</li><li><strong class="bold">Build expiration</strong>: This<a id="_idIndexMarker428"/> determines how long a positive build result is valid for. The default value is <strong class="bold">12</strong> hours, but you should consider changing this to <strong class="bold">Immediately when main is updated</strong>. The advantage of this is that you cannot merge changes without first running the build against a combination of the current state of the branch that you will merge<a id="_idIndexMarker429"/> to and the proposed changes.</li></ul></li>
</ol>
<p>You can add more than one build policy. If you have a lot of things that you can automatically validate and want to ke<a id="_idTextAnchor251"/>ep automated validation t<a id="_idTextAnchor252"/>imes to a minimum, then this is a good approach.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor253"/>Accessing build artifacts</h2>
<p>As well as <a id="_idIndexMarker430"/>compiling, testing, and validating your source code, builds can also be used to generate what are called <a id="_idIndexMarker431"/><strong class="bold">artifacts</strong>. Artifacts are outputs from a build and can be anything that you want to save and publish from a bui<a id="_idTextAnchor254"/>ld, such as test results and application packages.</p>
<p>An application package<a id="_idIndexMarker432"/> is intended to be an immutable build of a version of your application. This package can later be picked up in a release and deployed to one or more environments:</p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<img alt="Figure 5.13 – Viewing application packages  " height="678" src="image/B18655_05_13.jpg" width="1037"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – Viewing application packages </p>
<p>In the preceding <a id="_idIndexMarker433"/>screenshot, you can see that, as part of the summary of an executed build, there were two artifacts published. Artifacts can be accessed from either the <strong class="bold">Artifacts</strong> drop-down menu in the top-right corner of the screen or from the <strong class="bold">Summary</strong> tab. You can download and explore artifacts from this page, and in the next chapter, you will see how to work with them to set up continuous delivery.</p>
<p>Great! With this, you have learned how to create a definition using the visual designer. But wait – as we mentioned earlier, there is another way of doing this, which is by using YAML f<a id="_idTextAnchor255"/><a id="_idTextAnchor256"/><a id="_idTextAnchor257"/>iles. Let’s see how this works in the next section.</p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor258"/>Working with YAML pipelines</h1>
<p>You have seen how to<a id="_idIndexMarker434"/> create a build definition using the visual designer. A new, alternative approach, which has been available since early 2019, is the use of YAML pipelines. When working with YAML pipelines, you specify your complete build definition in a YAML file and store it in source control, often next to the source code that the build is for.</p>
<p>While both <a id="_idIndexMarker435"/>pipeline systems coexist, using YAML pipelines is now the preferred approach for defining pipelines. This means that it <a id="_idTextAnchor259"/>is very likely t<a id="_idTextAnchor260"/>hat new features will only surface in YAML pipelines.</p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor261"/>The reason for using build definitions as code</h2>
<p>When<a id="_idIndexMarker436"/> you first start working with YAML build definitions, you might find that the learning curve is steeper than it is when working with a visual designer. This might raise the question as to why you would use YAML-defined builds. There are two main advantages that YAML build definitions have over visually designed definitions.</p>
<p>When you are writing your definition in YAML, it can be hosted in source control next to your code. The consequence of this is that all the policies that you have in place for changing source control now automatically apply to your build definition. This means that any change must go through a pull request, be reviewed by a peer, and can be built and verified ahead of time. Enforcing the <strong class="bold">four-eyes principle</strong> on your build definition, as well as your code, increases the<a id="_idIndexMarker437"/> stability of your build process. Of course, it also benefits security and compliance, topics that will be discussed in later chapters.</p>
<p>As well as this increase in security, having the build definition in source control also means that it is available in every branch. This means that it can be changed in every branch to build that specific branch before merging it with the main branch. When working with a visually designed build definition, this single definition is responsible for building not only your main branch but also all the branches that you want to merge through a pull request.</p>
<p>This means that you must do one of the following:</p>
<ul>
<li>Update the build definition for the change that you will merge. However, this will terminate the building of the current state of the main branch.</li>
<li>Merge the change, which will also result in a broken build, since the build definition has not yet been updated.</li>
</ul>
<p>Either option has the risk of allowing faulty changes to flow through the target branch, defeating the purpose of a continuous integration build. With a <a id="_idTextAnchor262"/><a id="_idTextAnchor263"/><a id="_idTextAnchor264"/>build definition per branch, we <a id="_idIndexMarker438"/>eradicate this problem.</p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor265"/>Writing a basic YAML pipeline</h2>
<p>To get started with <a id="_idIndexMarker439"/>YAML builds, there are two things you need to do:</p>
<ol>
<li value="1">First, you need to write your YAML fil<a id="_idTextAnchor266"/>e.</li>
<li>Then, you need to cr<a id="_idTextAnchor267"/>eate a build definition out of it.</li>
</ol>
<p>So, let’s get started.</p>
<h3>Writing the YAML file</h3>
<p>The following code sample <a id="_idIndexMarker440"/>contains an example YAML definition for building a .NET Core application and running unit tests. Save a file with any name – for example, <strong class="source-inline">pipeline.yaml</strong> – in any Git repository in Azure DevOps. Then, it can be used to create a pipeline out of it later on:</p>
<pre class="source-code">
trigger:
- main
pool:
  name: Azure Pipelines 
  vmImage: windows-2019
steps:
-  task: DotNetCoreCLI@2 
   displayName: 'dotnet build' 
   inputs:
       projects: '**/*.csproj'
- task: DotNetCoreCLI@2 
   displayName: 'dotnet test' 
   i<a id="_idTextAnchor268"/>nputs:
       command: test
       projects: '**/*.csproj'</pre>
<p>This YAML example defines a basic pipeline. Every pipeline needs to be triggered in some way. Just as with classic builds, this can be done by connecting the pipeline to a change in a source code repository. The default repository for this is the repository that also contains the YAML definition. The <strong class="bold">trigger</strong> keyword is used to specify a push to which branches should trigger the pipeline. A good starting point is the main branch. As the trigger keyword accepts a list, multiple branches can be specified, and wildcards can be used.</p>
<p>A trigger <a id="_idIndexMarker441"/>is not mandatory, as a pipeline can also be started manually.</p>
<p class="callout-heading">Tip</p>
<p class="callout">There are also alternative options to using the trigger keyword, such as including or excluding one or more <a id="_idIndexMarker442"/>branches, tags, or paths in the repository. These options are described in detail at <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers">https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers</a>.</p>
<p>As well as a trigger, every pipeline contains one or more tasks, just as in classic build definitions. All these tasks need to execute on an agent pool – again, just as in classic build definitions. The <strong class="source-inline">pool</strong> keyword is used to specify a set of key/value pairs that determine which pool the tasks will run on by specifying the name of the pool. When working with the default agents that Microsoft provides, the default name of <strong class="source-inline">Azure Pipelines</strong> can be used. When using this specific pool, a <strong class="bold">Virtual Machine</strong> (<strong class="bold">VM</strong> ) image has to be specified. This determines which operating system and what software is available on the agent that will execute the task.</p>
<p class="callout-heading">Tip</p>
<p class="callout">An up-to-date list of all the VM images<a id="_idIndexMarker443"/> that are available can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent">https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent</a>.</p>
<p>Finally, the definition contains a list of the steps that make up the pipeline itself. These steps correspond one to one with the tasks that you can drag into a classic build pipeline. A task is <a id="_idIndexMarker444"/>added by specifying the name and version – separated by the <strong class="source-inline">@</strong> sign – of the task that you want to run. Next, you can optionally specify a display name for the task. This display name will later be visible in the views that show the results of an executed pipeline. Finally, specify one or more inputs for the task. These inputs relate to the task-specific con<a id="_idTextAnchor269"/><a id="_idTextAnchor270"/><a id="_idTextAnchor271"/>figuration that you have already seen for the visual designer.</p>
<h3>Creating a YAML pipeline</h3>
<p>After saving your <a id="_idIndexMarker445"/>YAML file in a repository, you can create a build definition from it. When creating a new build definition (see the <em class="italic">Creating a build definition</em> section of this chapter), you should go through the following steps:</p>
<ol>
<li value="1">Choose the <strong class="bold">Azure Repos Git YAML</strong> option when the wizard starts.</li>
<li>From here, go through the wizard to select and review the YAML you want to build, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer052">
<img alt="Figure 5.14 – A YAML pipeline for a repository  " height="788" src="image/B18655_05_14.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.14 – A YAML pipeline for a repository </p>
<ol>
<li value="3">Then, locate the repository that contains the YAML file that you want to use as your pipeline.</li>
<li>Next, configure the pipeline by choosing an example YAML file to start from or by referring to an already existing file.</li>
<li>Finally, you can <a id="_idIndexMarker446"/>review the YAML file that you have selected and start a build from it.</li>
</ol>
<p>Your pipeline is saved automatically. Once the pipeline is saved, it can be started, and you can interact wit<a id="_idTextAnchor272"/><a id="_idTextAnchor273"/><a id="_idTextAnchor274"/>h it in the same way as you would with classic build pipelines.</p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor275"/>Multi-job pipelines</h2>
<p>The pipeline you <a id="_idIndexMarker447"/>saw in the previous section does not specify any jobs, as you may recall from the section on classic builds. Instead, it contains a list of tasks under the <strong class="source-inline">steps</strong> keyword. This means that it implicitly contains only a single job. With YAML pipelines, it is also possible to create a definition that contains more than one job. To do this, the following structure can be used:</p>
<pre class="source-code">
trigger:
- main
pool:
    name: Azure Pipelines 
    vmImage: windows-2019
jobs:
- job: job1
  displayName: A pretty name for job1 
  steps:
  - task: DotNetCoreCLI@2
     ...
- job: job2
  displayName: My second job 
  pool:
      name: Azure Pipelines 
      vmImage: ubuntu-18.04
      ...</pre>
<p>Instead of adding the <strong class="source-inline">steps</strong> keyword directly to the pipeline, a list of jobs is created first. Within that list, one or more <strong class="source-inline">job</strong> keywords are added, followed by the name for that job. Next to this technical name, a display name (<strong class="source-inline">displayName</strong>) can be specified for each job.</p>
<p>As the second<a id="_idIndexMarker448"/> job in the preceding example shows, it is also possible to specify which agent pool to use per job. When no pool is specified for a job, the default pool specified at the top of the file is used.</p>
<p class="callout-heading">Tip</p>
<p class="callout">The jobs that are discussed<a id="_idIndexMarker449"/> in this section are called agent jobs. Besides<a id="_idIndexMarker450"/> agent jobs, there are also <a id="_idIndexMarker451"/>server jobs, container jobs, and deployment jobs<a id="_idIndexMarker452"/> available. More information about these types of jobs<a id="_idIndexMarker453"/> can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs">https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs</a>.</p>
<p>By default, all the jobs in a pipeline ru<a id="_idTextAnchor276"/><a id="_idTextAnchor277"/><a id="_idTextAnchor278"/>n in parallel, but there are control options available to change this.</p>
<h3>Control options</h3>
<p>To control<a id="_idIndexMarker454"/> the order of jobs, the <strong class="source-inline">dependsOn</strong> keyword can be used in the definition of a job. This signals that the job can only be started after one or more jobs are completed. Besides this, the <strong class="source-inline">condition</strong> keyword can be used to specify a condition that a job should run under. These two keywords can be combined to realize more complex scenarios, such as the one shown here:</p>
<pre class="source-code">
jobs:
- job: compile 
  steps:
  ...
- job: test 
  dependsOn: compile 
  steps:
  ...
- job: build_schema 
  dependsOn: compile 
  steps:
  ..
- job: report 
  dependsOn:
  - test
  - build_schema
  condition: or(succeeded('test'), succeeded('build_schema')) 
  steps:
  ..</pre>
<p>This pipeline will <a id="_idIndexMarker455"/>start by running the job named <strong class="source-inline">compile</strong>. Once this job completes, the next two jobs, <strong class="source-inline">test</strong> and <strong class="source-inline">build_schema</strong>, will run in parallel, as they both depend on the <strong class="source-inline">compile</strong> task. After both of these tasks complete, the <strong class="source-inline">report</strong> task runs, as it declares a dependency on both the <strong class="source-inline">test</strong> and <strong class="source-inline">build_schema</strong> jobs. Before this job actually starts, the condition is evaluated to determine whether the job should actually run or be skipped.</p>
<p>Conditions can be built using a syntax that is similar to many programming languages. It checks the successful completion of a job using the <strong class="source-inline">succeeded()</strong> and <strong class="source-inline">failed()</strong> functions. There is also support for Boolean operators such as <strong class="source-inline">or()</strong>, <strong class="source-inline">and()</strong>, and <strong class="source-inline">ne()</strong>.</p>
<p>You can combine <a id="_idIndexMarker456"/>the <strong class="source-inline">dependsOn</strong> and <strong class="source-inline">condition</strong> keywords in any way you see fit. The only requirement is tha<a id="_idTextAnchor279"/><a id="_idTextAnchor280"/>t there should be at least one job that does not depend on any other job.</p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor281"/>Variables</h2>
<p>Just like <a id="_idIndexMarker457"/>classic build pipelines, YAML pipelines support the use of variables. Variables can be defined at every level of a YAML pipeline (except for within a task) using the following syntax:</p>
<pre class="source-code">
variables: 
  name: value
  anotherName: otherValue</pre>
<p>Variables can later be retrieved using the syntax that you already know from classic build pipelines – <strong class="source-inline">$(name)</strong> and <strong class="source-inline">$(anotherName)</strong>.</p>
<p>It is also possible to reference existing variable groups from within a YAML pipeline. This is done by using the <strong class="source-inline">group</strong> keyword, instead of specifying the name of a variable. To also retrieve all the variables from a variable group called <strong class="source-inline">myVariableGroup</strong>, you would extend the preceding YAML, as follows:</p>
<pre class="source-code">
variables: 
  name: value
  anotherName: otherValue 
  group: myVariableGroup</pre>
<p>Variables can be<a id="_idTextAnchor282"/> set at every level in a YAML pipeline, but only variables set at the root level can be overridden when queuing a new execution manually. You can learn more here: <a id="_idTextAnchor283"/><a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables">https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables</a>.</p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor284"/>Pipeline artifacts</h2>
<p>Just like classic builds, YAML <a id="_idIndexMarker458"/>pipelines can be used to build and publish artifacts. As the task used to do this is a task like any other, it can be added directly to the list of steps in a job.</p>
<p>However, with the introduction of YAML pipelines, a new type of artifact has become available – the so-called pipeline artifact. This comes with the benefit of improving the speed at which large artifacts can be uploaded and downloaded. When working with classic releases, pipeline artifacts are not automatically downloaded, whereas build artifacts are.</p>
<p>To publish a pipeline artifact, the following YAML can be used in the <strong class="source-inline">steps</strong> keyw<a id="_idTextAnchor285"/>ord of a job:</p>
<pre class="source-code">
steps:
- publish: folder/to/publish 
  artifact: artifactName</pre>
<p>Pipeline ar<a id="_idTextAnchor286"/>tifacts are mainly intended to be downloaded<a id="_idTextAnchor287"/> in multi-stage YAML pipelines, which are also covered in the next chapter.</p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor288"/>Tips for writing YAML pipelines</h2>
<p>Writing YAML pipelines from<a id="_idIndexMarker459"/> scratch can be complicated when you are just getting started. There are two tools available that can help you.</p>
<p>First, there is the option to export YAML from the visual designer. For every task, there is a link with the <strong class="bold">View YAML</strong> title. This opens a small pop-up box that shows you the YAML corresponding to the task and configuration that you currently have open. The same can be done for jobs and, under specific conditions, complete build definitions.</p>
<p>The other tool available fo<a id="_idTextAnchor289"/>r writing YAML is the built-in YAML editor:</p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 5.15 – The YAML editor " height="828" src="image/B18655_05_15.jpg" width="1092"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.15 – The YAML editor</p>
<p>Whenever you <a id="_idIndexMarker460"/>open a YAML build definition, there are two tools available to help you. First, there is autocompletion for every location in your YAML file. This shows you the options available at that point in the file. As well as this, there are snippets available in the task picker on the right. When selecting any of the tasks on the right, you configure them visually and then click the <strong class="bold">Add</strong> button to add the generated YAML to your definition.</p>
<p>These two too<a id="_idTextAnchor290"/>ls aim to bring the ease of the visual designer to the YAML build experience as well, combining the best of both worlds.</p>
<p>Refer to these docs for a complete YAML schema<a id="_idIndexMarker461"/> reference: <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema/?view=azure-pipelines">https://docs.<span id="_idTextAnchor291"/>microsoft.com/en-us/azure/devops/pipelines/yaml-schema/?view=azure-pipelines</a>.</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor292"/>Agents and agent queues</h1>
<p>The build definitions that you have created so far can contain agent jobs, which in turn contain tasks. These tasks are not executed within your Azure DevOps organization directly but are instead executed by agents that run on VMs or in containers. In turn, agents are grouped in agent pools. There are two types of <a id="_idIndexMarker462"/>age<a id="_idTextAnchor293"/>nt pools that you can work with:</p>
<ul>
<li>B<a id="_idTextAnchor294"/>uilt-in agent pools </li>
<li>Self-hosted agent pools</li>
</ul>
<p>Let’s go through them one by one.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor295"/>Built-in agent pools</h2>
<p>Built-in agent pools<a id="_idIndexMarker463"/> are managed by Microsoft and are made available to you as <a id="_idIndexMarker464"/>part of the Azure DevOps product itself. There are different agent pools available, depending on your needs. Pools run different versions of Windows and Visual Studio, and there are also pools available that run Linux (Ubuntu) and macOS.</p>
<p>The disadvantage of these managed pools is that you cannot install extra software on the machines or containers that host the agents if you need to. <a id="_idTextAnchor296"/><a id="_idTextAnchor297"/><a id="_idTextAnchor298"/>This means that, in these cases, you have to create your own private agent pools.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor299"/>Creating a private agent pool</h2>
<p>Private pools <a id="_idIndexMarker465"/>are defined in your Azure DevOps organization and <a id="_idIndexMarker466"/>are provisioned from there to one or more of your team projects. However, you can also create your private pools at the team project level if they are created and provisioned in one go. To do so, go to <strong class="bold">Project Settings</strong> | <strong class="bold">Agent pools</strong>. You should see the following <strong class="bold">Add agent pool</strong> option:</p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="Figure 5.16 – Agent pool settings " height="886" src="image/B18655_05_16.jpg" width="1215"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.16 – Agent pool settings</p>
<p>After giving the<a id="_idIndexMarker467"/> pool a name and determining whether you want to <a id="_idIndexMarker468"/>automatically provide access to all pipel<a id="_idTextAnchor300"/><a id="_idTextAnchor301"/><a id="_idTextAnchor302"/>ines, you can save the pool. After creating the pool, you can add or remove agents.</p>
<h3>Adding and removing agents</h3>
<p>Adding an agent is done in two steps:</p>
<ol>
<li value="1">Download <a id="_idIndexMarker469"/>and extract the agent runtime. You can find the agent runtime by going to the section with the overview of the agent pools and opening the details of any private agent pool. After the details of the pool are opened, click on <strong class="bold">New agent</strong> in the top-right corner:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer055">
<img alt="Figure 5.17 – Adding a new agent " height="808" src="image/B18655_05_17.jpg" width="827"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.17 – Adding a new agent</p>
<ol>
<li value="2">In the dialog <a id="_idIndexMarker470"/>that opens, you can download a ZIP file with the agent and instructions for extracting and installing the agent.</li>
</ol>
<p class="callout-heading">Important Note</p>
<p class="callout">During the configuration phase, you will be prompted to authenticate with your Azure DevOps organization and provide the name of the agent pool you want to install the agent in. While there are x86 and x64 agents available, it is recommended that you work with the x64 agent unless you have a specific reason not to.</p>
<p>To remove <a id="_idIndexMarker471"/>agents from the pool, you can use one of two methods:</p>
<ul>
<li>You can return to the PowerShell command line, just as you did for the installation, and use the following command:<p class="source-code">.\remove.cmd</p></li>
<li>Alternatively, you can also remove agents from the agent pool overview using the <strong class="bold">Agents</strong> tab. Go to <strong class="bold">Project Settings</strong> | <strong class="bold">Agent pools</strong> (see <strong class="bold">1</strong> in the following screenshot) | <strong class="bold">Agents</strong> (see <strong class="bold">2</strong> in the following screenshot), and then select the options button (see <strong class="bold">3</strong> in the following screenshot) on the agent you want to remove. Then,<a id="_idTextAnchor303"/> click <strong class="bold">Delete</strong> (see <strong class="bold">4</strong> in the following screenshot):</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="Figure 5.18 – Deleting an agent " height="571" src="image/B18655_05_18.jpg" width="1006"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.18 – Deleting an agent</p>
<p>In the preceding screenshot, you can see the steps to<a id="_idIndexMarker472"/> remove an agent using the interface. Be aware that this does not clean up the binaries and any files on the host machine; h<a id="_idTextAnchor304"/>owever, if a machine that is hosti<a id="_idTextAnchor305"/>ng an agent breaks down or a VM is removed, this is the only way to remove the agent.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor306"/>Agent selection</h2>
<p>Whenever a build <a id="_idIndexMarker473"/>job starts running, an agent is selected from the pool that will perform the tasks that you have defined in the pipeline. The selection of an agent is done in two steps:</p>
<ol>
<li value="1">Only agents that are part of the selected pool are eligible for running the tasks. This means that when working with private agent pools, it is wise to have multiple agents in a pool. If you then take one agent offline for maintenance, the agent jobs that rely on the agent pool can continue running.</li>
<li>Before an agent job can run, the demands from each job and the tasks it contains are gathered. As you learned in the <em class="italic">Variable groups</em> section, an agent job can specify the demands it has of the agent that it uses. The same goes for tasks – they can also specify demands. To run a job, only agents that meet all of these demands are used. Demands<a id="_idIndexMarker474"/> and capabilities are key/value pairs, where the <a id="_idIndexMarker475"/>value is an integer. Refer to these docs for examples of demands: <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/demands">https://docs.microsoft.com/en-us/azure/devops/pipelines/process/demands</a>.</li>
</ol>
<p>When there <a id="_idTextAnchor307"/><a id="_idTextAnchor308"/><a id="_idTextAnchor309"/>is no eligible agent for a build definition, the build eventually fails after a timeout.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor310"/>Finding agent capabilities</h2>
<p>To find the capabilities that are<a id="_idIndexMarker476"/> available on the individual agents, go through the following steps:</p>
<ol>
<li value="1">Navigate to <strong class="bold">Organization Settings</strong> | <strong class="bold">Agent pools</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="Figure 5.19 – Viewing agent settings " height="1149" src="image/B18655_05_19.jpg" width="1639"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.19 – Viewing agent settings</p>
<ol>
<li value="2">Navigate to the correct agent pool (either hosted or private), then <strong class="bold">Agents</strong>, and then open the agent details (not shown in the preceding screenshot).</li>
<li>Open<a id="_idIndexMarker477"/> the <strong class="bold">Capabilities</strong> tab.</li>
</ol>
<p>Here, you can specify one or more custom capabilities for the agent using the top block, called <strong class="bold">User-defined capabilities</strong>. For self-hosted (private) agents, all the capabilities that were discovered on the machine when you installed the agent are also shown.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor311"/>The benefits of self-hosted agent pools</h2>
<p>Use of Microsoft (cloud)-hosted <a id="_idIndexMarker478"/>agents is a fairly common practice and saves you a lot of time in managing and configuring your build infrastructure. Self-hosted agents have proven to be beneficial on many occasions. Due to the availability of a lot of good documentation, it has become an easy task for administrators to provision and configure a self-hosted agent for use in their pipelines. </p>
<p>The main benefits of using a <a id="_idIndexMarker479"/>self-hosted agent are as follows:</p>
<ul>
<li>Optimizing the cost of your build agents.</li>
<li>Installing additional software as required for your specific build tasks.</li>
<li>Improving the performance of your builds, making them run faster by caching resources, and enabling incremental builds.</li>
<li>The debugging and troubleshooting of build issues are easier. </li>
<li>Allows for <strong class="bold">Virtual Network</strong> (<strong class="bold">Vnet</strong>) integration, and you can securely run your builds behind the firewall.</li>
<li>Accessing other <a id="_idIndexMarker480"/>corporate resources securely using whitelisted IP addresses.</li>
</ul>
<p>In the next <a id="_idTextAnchor312"/><a id="_idTextAnchor313"/>section, we will explore the option to automate CI builds for repositories hosted on GitHub.</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor314"/>Automating CI builds using GitHub Actions</h1>
<p>If you are using<a id="_idIndexMarker481"/> a GitHub repository, you can also automate<a id="_idIndexMarker482"/> your CI builds using GitHub Actions (available as a tab within the repository’s top navigation menu). You can either choose from an existing template workflow (with more than 50  workflows available) or set up a custom workflow of your own:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<img alt="Figure 5.20 – The available options in GitHub Actions " height="1125" src="image/B18655_05_20.jpg" width="1182"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.20 – The available options in GitHub Actions</p>
<p>The <a id="_idIndexMarker483"/>experience of authoring a workflow is<a id="_idIndexMarker484"/> similar to creating a YAML file and saving it within your GitHub repository:</p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<img alt="Figure 5.21 – Editing a YAML file in the GitHub repository " height="913" src="image/B18655_05_21.jpg" width="918"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.21 – Editing a YAML file in the GitHub repository</p>
<p>In the next sections, we will introduce alternative tools that can be used for managing the CI processes. </p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor315"/>Other tools</h1>
<p>There are many tools available besides Azure DevOps. Two other well-known tools are GitLab CI and Jenkins. Some very basic knowledge of these tools will help you to understand how to integrate with them if that is ever necessary. Also, a limited understanding of other tools will help you to quickly understand the concepts and generalize your knowledge of how to work with these other tools.</p>
<p>To highlight how these tools work with the same concepts, both exampl<a id="_idTextAnchor316"/>es in this section ar<a id="_idTextAnchor317"/>e equivalent to the Azure DevOps YAML pipeline in the <em class="italic">Writing a YAML build definition</em> section.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor318"/>GitLab CI</h2>
<p>GitLab offers build <a id="_idIndexMarker485"/>pipelines using the GitLab CI capabilities. GitLab CI is configured by putting a file with the <strong class="source-inline">.gitlab-ci.yml</strong> name in the root of a repository. In this file, you can define one or more stages and jobs, along with the tasks that they should perform. An example YAML file for GitLab CI can appear, as shown in the following example:</p>
<pre class="source-code">
stages:
   - build
   - test
build:
      stage: build
      script: dotnet build **/*.csproj
test:
      stage: test
      script: dotnet test **/*.csproj</pre>
<p>Just as Azure DevOps uses <a id="_idIndexMarker486"/>agent pools with agents, GitLab CI relies on <strong class="bold">runners</strong> to perform the actual wor<a id="_idTextAnchor319"/><a id="_idTextAnchor320"/><a id="_idTextAnchor321"/>k. In GitLab CI, there is currently no support for visually creating or editing your pipelines.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor322"/>Jenkins</h2>
<p>Jenkins<a id="_idIndexMarker487"/> is another tool used to run build pipelines. Complex builds can be run using Jenkins pipelines, which get their work from a Jenkinsfile. A <strong class="bold">Jenkinsfile</strong> is written<a id="_idIndexMarker488"/> in a Jenkins-specific notation, as shown in the following code: </p>
<pre class="source-code">
pipeline {
        agent any 
        stages {
              stage('build') {
              agent any
                    steps {
                          dotnet build **/*.csproj
                    }
              }
              stage('test') { 
                    agent any 
                    steps {
                          dotnet test **/*.csproj
                    }
              }
       }
}</pre>
<p>Jenkins has<a id="_idIndexMarker489"/> limite<a id="_idTextAnchor323"/>d support for visually creating and editing a pipeline. This is referred to as<a id="_idIndexMarker490"/> a freestyle project.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor324"/>Summary</h1>
<p>In this chapter, we looked at continuous integration and learned how it is a combination of your mindset, the processes, and tools used by the development teams. You learned how to create build definitions using Azure Pipelines, using both the graphical designer and YAML, as well as how to run builds. You learned that you can use build pipelines to compile and test your code, as well as report the outcome back to pull requests.</p>
<p>You learned that builds can produce outputs, termed as Artifacts. Artifacts are stored and retained within Azure pipelines and can be used to store reports, but they are also the starting point of deployment pipelines, which you will learn about in the next chapter. You also learned about the infrastructure that you need to run builds – namely, agents and agent pools. Finally, you saw two brief examples of how to run a continuous integration build using GitLab CI and Jenkins, which are two other tools that you can use for build pipelines.</p>
<p>With this knowledge, you are now able to create build pipelines for your projects. You can hook up to source control and produce the builds that you will use in the next chapter to deploy your applications. With this deep knowledge of the underlying structure of tasks, jobs, stages, and pipelines, you can solve complex application-building problems.</p>
<p>In the next chapter, you will continue learning about pipelines but this t<a id="_idTextAnchor325"/>ime, for releases. You will learn how to pick up builds and release them to one or more environments.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor326"/>Questions</h1>
<p>As we conclude, here is a list of questions for you to test your knowledge regarding this chapter’s material. You will find the answers in the <em class="italic">Assessments</em> section of the appendix:</p>
<ol>
<li value="1">True or false?  You achieve continuous integration if you compile all the branches of your project at least daily.</li>
<li>True or false?  A classic build definition is always connected to a source code repository.</li>
<li>True or false?  A YAML pipeline definition is always connected to a source code repository.</li>
<li>Which of the following is needed to call an external tool from an Azure pipeline?<ol><li>An external service definition</li><li>An Azure service connection</li><li>A service connection</li><li>A service locator</li></ol></li>
<li>What are some common reasons for using self-hosted agents? Choose all of the correct answers from the following:<ol><li>Access to closed networks is needed.</li><li>Specific extension tasks need to be available to the agent.</li><li>The number of parallel pipeline executions needs to be larger than 10.</li><li>Specific software needs to be installed in order for the agent to use it.</li></ol></li>
</ol>
<h1 id="_idParaDest-127"><a id="_idTextAnchor327"/>Exercises</h1>
<ul>
<li>Add a folder named <strong class="source-inline">pipelines</strong> under the root directory of the <strong class="source-inline">PacktBookLibrary</strong> repository.</li>
<li>Create a subfolder named <strong class="source-inline">build</strong> under the <strong class="source-inline">pipelines</strong> directory. </li>
<li>Add a build file named <strong class="source-inline">main-ci-build.yml</strong>.</li>
<li>Insert the following code block in the file:<p class="source-code">trigger:</p><p class="source-code">- main</p><p class="source-code">pool:</p><p class="source-code">  vmImage: ubuntu-latest</p><p class="source-code">variables:</p><p class="source-code">  buildConfiguration: 'Release'</p><p class="source-code">steps:</p><p class="source-code">- script: dotnet build --configuration $(buildConfiguration)</p><p class="source-code">  displayName: 'dotnet build $(buildConfiguration)'</p></li>
<li>Save the file and commit your changes to the branch. Push and then raise a pull request to merge your changes with the main branch.</li>
<li>Create a new pipeline in your team project. In the <strong class="bold">Configure your pipeline</strong> step, select the <strong class="bold">Existing Azure Pipelines YAML file</strong> option:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 5.22 – Using an existing pipeline option " height="415" src="image/B18655_05_22.jpg" width="993"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.22 – Using an existing pipeline option</p>
<ul>
<li>When prompted to select the build pipeline, specify the <strong class="source-inline">main-ci-build.yml</strong> file. Click <strong class="bold">Continue</strong> to finish creating your build pipeline. </li>
<li>Run the pipeline job to verify that the build pipeline works. On the pipeline status page, review for any errors and the successful execution of the pipeline job.</li>
</ul>
<p class="callout-heading">Important Note</p>
<p class="callout">The pipeline is composed of tasks to build a .NET Core project. To build other types of code components, make use of<a id="_idTextAnchor328"/> the appropriate task library.</p>
<p>The source code repository for the starter kit can be found here: <a href="https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide">https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide</a></p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor329"/>Further reading</h1>
<ul>
<li>An in-depth definition of continuous integration by Martin Fowler is available at <a href="https://martinfowler.com/articles/continuousIntegration.xhtml">https://martinfowler.com/articles/continuousIntegration.xhtml</a>.</li>
<li>A detailed description of the conditions syntax is available at <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devopstabs=classic">https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devopstabs=classic</a>.</li>
<li>Exercises for practicing with Azure DevOps builds can be found at <a href="https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index">https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index</a>.</li>
<li>You can find the Visual Studio Marketplace for Azure DevOps at <a href="https://marketplace.visualstudio.com/azuredevops">https://marketplace.visualstudio.com/azuredevops</a>.</li>
<li>You can find a detailed description of the Azure Pipelines YAML syntax at <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devopstabs=schema">https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devopstabs=schema</a>.</li>
<li>Details of the pricing of the Azure Pipelines’ hosted and self-hosted agent pools are available at <a href="https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/">https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/</a>.</li>
<li>More information about GitLab CI can be found at <a href="https://about.gitlab.com/product/continuous-integration/">https://about.gitlab.com/product/continuous-integration/</a>.</li>
<li>More information about Jenkins can be found at <a href="https://jenkins.io/">https://jenkins.io/</a>.</li>
<li>Build tasks for .NET Core projects: <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/ecosystems/dotnet-core?view=azure-devops&amp;tabs=dotnetfive%20">https://docs.microsoft.com/en-us/azure/devops/pipelines/ecosystems/dotnet-core?view=azure-devops&amp;tabs=dotnetfive.</a></li>
<li><em class="italic">Develop a web extension</em>: <a href="https://docs.microsoft.com/en-us/azure/devops/extend/get-started/node?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/extend/get-started/node?view=azure-devops</a>.</li>
</ul>
</div>
</div></body></html>