- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Using Ansible for Configuration as Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 实现配置即代码
- en: 'In this chapter, we are going to cover **configuration management** (**CM**),
    **Configuration as Code** (**CaC**), and our tool of choice for it: Ansible.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍 **配置管理**（**CM**）、**配置即代码**（**CaC**）以及我们选择的工具：Ansible。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将覆盖以下主题：
- en: CM systems and CaC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CM 系统与 CaC
- en: Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: Ansible Galaxy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Galaxy
- en: Handling secrets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理机密信息
- en: Ansible Tower and alternatives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Tower 和替代方案
- en: Advanced topics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级话题
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a Linux system that you can access through `ssh`.
    If your main operating system is Windows, you will need another Linux system to
    play the role of the control node. As of now, the Ansible project does not support
    Windows as a control node.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，你需要一个可以通过 `ssh` 访问的 Linux 系统。如果你的主要操作系统是 Windows，你将需要另外一台 Linux 系统来充当控制节点。到目前为止，Ansible
    项目尚不支持 Windows 作为控制节点。
- en: CM systems and CaC
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CM 系统与 CaC
- en: 'Setting up and maintaining a system other than a hobbyist server (and even
    those, maybe, too) poses a serious challenge: how do you ensure that the system
    is installed and configured correctly and according to expectations? When you
    have to install a new server that is identical in configuration, how do you ensure
    that? In the past, a way of doing it was documenting the current configuration
    after the installation process was done. This would be a document describing the
    hardware, operating system, installed software, created users, and configuration
    applied. Any person who wanted to recreate it would have to follow steps to achieve
    the configuration described in the document.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和维护一个非业余服务器的系统（甚至是业余服务器，可能也需要这样做）是一个严峻的挑战：如何确保系统按照预期正确安装和配置？当你需要安装一台与现有配置完全相同的服务器时，如何确保这一点？过去，一种做法是在安装过程完成后记录当前的配置。这将是一份描述硬件、操作系统、已安装软件、创建的用户以及应用的配置的文档。任何想要重建该配置的人，都需要按照文档中的步骤操作以达到描述的配置。
- en: 'The very next logical step is to write shell scripts that achieve the same
    goal with one additional improvement over the manual process: the scripts—properly
    written, tested, and maintained—do not require manual work, except, maybe, the
    initial system installation. But a properly set up environment would take care
    even of this.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的合乎逻辑的步骤是编写 shell 脚本，达到与手动过程相同的目标，但有一个额外的改进：这些脚本——只要编写得当、经过测试并且维护良好——不需要人工操作，除非，可能，在初始系统安装时需要人工干预。但一个正确设置的环境将自动处理这一点。
- en: The scripts, however, also have some defects or deficiencies. One of them is
    the fact that you need to account in your scripts for unfinished execution. This
    could happen for various reasons and would leave the system in a partially configured
    state. Executing the script again would perform all configuration actions from
    the start, sometimes leading to unexpected results. One way to account for incomplete
    runs would be to wrap every configuration action in a check, to see whether it
    had been performed previously. That would lead to the configuration script becoming
    larger and, eventually, evolving into a library of configuration functions and
    check functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些脚本也存在一些缺陷或不足。其一是你需要在脚本中考虑未完成执行的情况。这可能由于各种原因发生，导致系统处于部分配置状态。再次执行脚本时，所有配置操作将从头开始，有时会导致意外结果。应对未完成的执行的一种方式是将每个配置操作都包装在检查中，查看该操作是否之前已执行过。这将导致配置脚本变得更大，最终演变成一个配置函数和检查函数的库。
- en: The task of developing and maintaining such a tool can be daunting and will
    probably require a whole team. Still, the results are probably worth the effort.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和维护这样一个工具的任务可能非常艰巨，并且可能需要一个完整的团队。但最终的结果可能值得付出这些努力。
- en: Writing and maintaining documentation that describes the desired state of the
    system may, at first glance, be simpler and more desirable than the previously
    mentioned method of automating. The script cannot recover from an incomplete execution.
    The best it can do is inform the sysop about failure, log the error, and stop
    gracefully. Manually performed configuration allows the sysop to work around any
    obstacles and inadequacies in the procedure and edit the document to reflect the
    current state on the go.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和维护描述系统期望状态的文档，乍一看可能比前面提到的自动化方法更简单且更具吸引力。脚本无法从未完成的执行中恢复过来。它所能做的最好的事情就是通知系统管理员失败，记录错误并优雅地停止。手动配置允许系统管理员绕过程序中的任何障碍和不足，并实时编辑文档以反映当前状态。
- en: 'Still, a properly developed and tested script turns out to be better. Let us
    enumerate the reasons:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，一个经过良好开发和测试的脚本最终还是更好。让我们列举出一些原因：
- en: If the script executes without an error, it is guaranteed to perform actions
    without a mistake. Time and again, it has been proven that a human is the element
    most prone to errors in IT.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果脚本执行没有出错，保证会执行正确的操作。一次又一次地证明，在IT领域，最容易出错的元素是人类。
- en: If the script exits prematurely, the action of updating it to account for the
    new requirements is a perfect equivalent to updating the documentation.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果脚本提前退出，更新它以满足新需求的行为与更新文档的过程完全相同。
- en: People are known to be pretty bad at maintaining documentation. The Holy Grail
    of programming is self-documenting code, rendering comments unnecessary, thus
    eliminating the risk of comments being out of sync with the code.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 众所周知，人类在维护文档方面很差。编程的圣杯是自文档化代码，使注释变得不再必要，从而消除了注释与代码不同步的风险。
- en: The script can be executed on multiple systems at once, scaling very well, if
    not infinitely. Humans can perform the configuration of one system at a time with
    minimal risk of making a mistake.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本可以在多个系统上同时执行，扩展性非常好，几乎是无限的。而人类只能一次配置一个系统，且犯错的风险较小。
- en: Configuration kept in the form of a script or program benefits from typical
    programming techniques, such as automated testing, dry runs, and static analysis.
    More so, keeping the code in a repository allows us to easily track a history
    of changes and integrate it with ticket-tracking tools.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以脚本或程序形式保存的配置得益于典型的编程技巧，例如自动化测试、演练和静态分析。更重要的是，将代码保存在版本库中让我们能够轻松追踪更改历史，并与问题跟踪工具集成。
- en: Code is unequivocal, which cannot be said about written language. A document
    may leave space for interpretation; a script won’t.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是明确的，而书面语言却不能如此。文档可能留有解释的空间，但脚本不会。
- en: Automating configuration lets you move to other, more interesting tasks, leaving
    the computers to do what they do best—performing repetitive, boring tasks well.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化配置让你可以转向其他更有趣的任务，留给计算机去做它们最擅长的事情——执行重复性且枯燥的任务。
- en: The world of programming and system administration has a tendency to turn small
    projects into larger ones with a vibrant community of developers and users. It
    was only a matter of time before CM systems were born. They take the burden of
    developing and managing portions of the code responsible for configuration actions
    off your shoulders. The CM system developers write the code, test it, and deem
    it stable. What you are left with is an action of writing configuration files
    or directives that tell the system what to do. Most of these systems will be able
    to cover the most popular platforms, allowing you to describe configuration once
    and run it with the same expected results on commercial Unix systems, such as
    AIX or Solaris, as on Linux or Windows.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编程和系统管理的世界倾向于将小项目转变为更大的项目，并且有一个充满活力的开发者和用户社区。CM（配置管理）系统的诞生只是时间问题。它们将开发和管理负责配置操作的代码部分的负担从你肩上移走。CM
    系统的开发者编写代码、测试并认为它稳定。剩下的工作就是编写配置文件或指令，告诉系统应该做什么。这些系统大多数能够覆盖最流行的平台，使你能够只描述一次配置，并在商业Unix系统（如AIX或Solaris）与Linux或Windows上获得相同的预期结果。
- en: 'Configuration files for these systems are easily stored in a version control
    system such as Git. They are easily understandable by a human, which allows for
    simple review by your colleagues. They can be checked for syntax errors by automated
    tools and allow you to concentrate on the most important part of the whole endeavor:
    the configuration.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统的配置文件可以轻松地存储在 Git 等版本控制系统中。它们易于理解，这使得同事可以轻松进行审查。它们可以通过自动化工具检查语法错误，并使你能够专注于整个工作中的最重要部分：配置。
- en: This approach of keeping your configuration as a set of scripts or other data
    instead of a procedure to be followed manually is known as CaC.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将配置保留为一组脚本或其他数据，而不是手动遵循的过程的方法，被称为 CaC。
- en: 'The CaC approach is becoming more important as the number of systems to be
    managed grows and the demand for fast and efficient configuration scales up. In
    the world of DevOps, it is usual practice to set up tens and hundreds of systems
    a day: systems for developers, testers, and production systems to manage new levels
    of demand for the service. Managing it manually would be an impossible task. Well-implemented
    CaC allows to run this task with a click of a button. Thus, developers and testers
    can deploy their own systems without bothering sysops. Your task will be to develop,
    maintain, and test the configuration data.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着需要管理的系统数量不断增加，以及对快速高效配置的需求不断扩大，CaC（配置即代码）方法变得越来越重要。在 DevOps 的世界里，通常需要每天设置数十个或数百个系统：包括开发人员、测试人员和生产系统，以应对服务需求的新水平。手动管理将是一项不可能完成的任务。良好实现的
    CaC 允许通过点击按钮来完成这项任务。因此，开发人员和测试人员可以自行部署系统，而不需要打扰系统运维人员。你的任务将是开发、维护和测试配置数据。
- en: If there is one thing sure in the world of programming, it is that there’s never
    going to be only one solution. The same goes for CM tools.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编程世界里有一件事是可以确定的，那就是永远不会只有一个解决方案。CM 工具也不例外。
- en: Alternatives for Ansible include **SaltStack**, **Chef**, **Puppet**, and **CFEngine**,
    which is the oldest one; its initial release date was 1993, so it’s 30 years old
    as of the time of writing this book. In general, those solutions differentiate
    between each other with a method of enforcing configuration (pull or push) and
    an approach of describing the system’s state (imperative or declarative).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的替代方案包括**SaltStack**、**Chef**、**Puppet** 和 **CFEngine**，后者是最古老的，它的首次发布是在
    1993 年，因此截至本书撰写时已存在 30 年。通常，这些解决方案通过强制配置的方法（拉取或推送）和描述系统状态的方法（命令式或声明式）有所不同。
- en: '**Imperative** means that we describe the state of the server with commands
    for the tool to perform. Imperative programming focuses on describing how a given
    tool operates step by step.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令式**（Imperative）方法意味着我们通过命令描述服务器的状态，让工具执行。命令式编程侧重于一步步描述给定工具的操作方式。'
- en: '**Declarative**, on the other hand, means we focus on what the CaC tool should
    accomplish without specifying all the details of how it should achieve the result.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明式**（Declarative）方法意味着我们关注 CaC 工具应该完成什么，而不是指定它应该如何实现结果的所有细节。'
- en: SaltStack
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SaltStack
- en: '**SaltStack** is an open source CM tool that allows for the management of complex
    IT infrastructure at scale. It enables the automation of routine tasks such as
    package installation, user management, and software configuration, and is designed
    to work across a wide range of operating systems and platforms. SaltStack was
    founded by Thomas Hatch in 2011\. The first release of SaltStack, version 0.8.0,
    was also made in 2011.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**SaltStack** 是一个开源的 CM 工具，允许在大规模的 IT 基础设施中进行管理。它使得日常任务的自动化成为可能，如软件包安装、用户管理和软件配置，并设计用于跨多种操作系统和平台工作。SaltStack
    由 Thomas Hatch 于 2011 年创立。SaltStack 的第一个版本 0.8.0 也发布于 2011 年。'
- en: 'SaltStack works by utilizing a master-slave architecture, where a central salt-master
    communicates with salt-minions running on remote machines to execute commands
    and manage configurations. It operates in a pull method of enforcing configuration:
    minions pull the latest manifest from the master server.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SaltStack 通过利用主从架构工作，其中一个中央的 salt-master 与运行在远程机器上的 salt-minion 进行通信，执行命令并管理配置。它采用拉取方式来强制执行配置：minion
    从主服务器拉取最新的清单。
- en: 'Once the minion is installed and configured, we can use SaltStack to manage
    the server’s configuration. Here’s an example `nginx.sls` file that would install
    and configure `nginx`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 minion 被安装并配置好，我们可以使用 SaltStack 来管理服务器的配置。以下是一个安装并配置 `nginx` 的示例 `nginx.sls`
    文件：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the first line specifies that the `nginx` package should be
    installed on the target server. The next two lines define the configuration file
    for a hypothetical website, `example.com`, which is copied to `/etc/nginx/sites-available/yourdomain.tld.conf`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，第一行指定应该在目标服务器上安装`nginx`包。接下来的两行定义了一个假设网站`example.com`的配置文件，该配置文件将被复制到`/etc/nginx/sites-available/yourdomain.tld.conf`。
- en: 'To apply this state file to a server, we would use the `state.apply` command
    in the SaltStack command-line interface, specifying the name of the state file
    as the argument:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此状态文件应用到服务器，我们需要在SaltStack命令行界面中使用`state.apply`命令，并指定状态文件的名称作为参数：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would send the instructions in the `nginx.sls` file to the salt-minion
    running on the web server machine, which would execute the necessary steps to
    ensure that `nginx` is installed and configured correctly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`nginx.sls`文件中的指令发送到运行在Web服务器上的salt-minion，salt-minion将执行必要的步骤以确保`nginx`正确安装和配置。
- en: Chef
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chef
- en: '**Chef** is a powerful open source CM tool that allows users to automate the
    deployment and management of infrastructure, applications, and services. It was
    first released in 2009 by Opscode, which was later acquired by Chef Software Inc.
    Since then, Chef has been widely adopted by IT professionals and DevOps teams
    to streamline their workflows and reduce the time and effort required for managing
    complex systems.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chef**是一个强大的开源配置管理（CM）工具，允许用户自动化基础设施、应用程序和服务的部署与管理。它最初由Opscode于2009年发布，后被Chef
    Software Inc.收购。从那时起，Chef被IT专业人员和DevOps团队广泛采用，以简化工作流程并减少管理复杂系统所需的时间和精力。'
- en: Chef works by defining the desired state of an infrastructure in a set of code
    files, called cookbooks. A **cookbook** is a collection of recipes that describe
    how to install, configure, and manage a specific piece of software or service.
    Each recipe contains a series of resources, which are pre-built modules that can
    perform specific tasks, such as installing a package or configuring a file. Chef
    uses a declarative approach to CM, meaning that users define what they want the
    system to look like, and Chef takes care of the details of how to get there.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Chef通过在一组代码文件中定义基础设施的期望状态来工作，这些代码文件称为食谱（cookbooks）。**食谱（cookbook）**是描述如何安装、配置和管理特定软件或服务的一组指令。每个食谱包含一系列资源，资源是预构建的模块，可以执行特定任务，例如安装软件包或配置文件。Chef使用声明式的配置管理（CM）方法，意味着用户定义系统的期望状态，而Chef负责处理如何实现该状态的细节。
- en: To install `nginx` using Chef, you would first need to create a cookbook that
    includes a recipe for installing `nginx`. This recipe would use the `package`
    resource to install the `nginx` package and the `service` resource to ensure that
    the `nginx` service is running. You could also use other resources, such as `file`,
    `directory`, or `template`, to configure `nginx`’s settings, depending on your
    requirements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Chef安装`nginx`，你首先需要创建一个包含安装`nginx`食谱的cookbook。这个食谱将使用`package`资源来安装`nginx`包，并使用`service`资源确保`nginx`服务正在运行。根据需求，你还可以使用其他资源，例如`file`、`directory`或`template`，来配置`nginx`的设置。
- en: Once you had created the cookbook, you would upload it to a Chef server, which
    acts as a central repository for cookbooks and their associated metadata. You
    would then use Chef’s command-line tool, called `knife`, to configure the target
    system to use the cookbook. This involves associating the system with a Chef environment,
    which defines the set of cookbooks and their versions that should be applied to
    the system. You would then use the `chef-client` command to run the Chef client
    on the target system, which will download and apply the necessary cookbooks and
    recipes to bring the system into the desired state.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了食谱（cookbook），你需要将其上传到Chef服务器，Chef服务器作为食谱及其相关元数据的中央仓库。然后，你可以使用Chef的命令行工具`knife`来配置目标系统使用该食谱。这涉及将系统与Chef环境关联，Chef环境定义了应应用于系统的食谱及其版本。接下来，你可以使用`chef-client`命令在目标系统上运行Chef客户端，该客户端将下载并应用必要的食谱和配置，以使系统达到所需状态。
- en: 'Here’s an example of installing and configuring `nginx`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是安装和配置`nginx`的示例：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This recipe uses three resources, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱使用了三个资源，如下所示：
- en: '`package`: This installs the `nginx` package using the default package manager
    on the system.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`：使用系统默认的软件包管理器安装`nginx`包。'
- en: '`service`: This starts and enables the `nginx` service so that it will automatically
    start on boot and stay running.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service`：这将启动并启用`nginx`服务，使其在启动时自动启动并保持运行。'
- en: '`template`: This creates a configuration file for `nginx` by generating it
    from a template file. The template file (`nginx-site.erb`) is written in `templates`
    directory of the cookbook. The `notifies` attribute tells Chef to restart the
    `nginx` service if the configuration file changes.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：通过从模板文件生成配置文件，为`nginx`创建一个配置文件。模板文件（`nginx-site.erb`）位于食谱的`templates`目录中。`notifies`属性告诉Chef在配置文件更改时重新启动`nginx`服务。'
- en: Once you have created this recipe in a cookbook, you can use the `knife` command
    to upload the cookbook to a Chef server. You can then use the `chef-client` command
    to apply the recipe to a target system, which will install and configure `nginx`
    according to the recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在食谱中创建了这个食谱，你可以使用`knife`命令将食谱上传到Chef服务器。然后，你可以使用`chef-client`命令将食谱应用于目标系统，按照食谱安装和配置`nginx`。
- en: Puppet
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Puppet
- en: '`2.0`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`2.0`。'
- en: Puppet works by defining the desired state of infrastructure resources in a
    declarative language, known as the Puppet language. Administrators can define
    the configuration of servers, applications, and other infrastructure components
    in Puppet code, which can then be applied consistently across multiple systems.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet通过在声明性语言中定义基础设施资源的期望状态来工作，这种语言被称为Puppet语言。管理员可以在Puppet代码中定义服务器、应用程序和其他基础设施组件的配置，然后将其一致地应用于多个系统。
- en: Puppet consists of a master server and multiple agent nodes. The master server
    acts as a central repository for Puppet code and configuration data, while the
    agent nodes execute the Puppet code and apply the desired state to the system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet由一个主服务器和多个代理节点组成。主服务器充当Puppet代码和配置数据的中央存储库，而代理节点则执行Puppet代码并将期望的状态应用到系统中。
- en: Puppet has a robust ecosystem of modules, which are pre-written Puppet code
    that can be used to configure common infrastructure resources. These modules are
    available in **Puppet Forge**, a public repository of Puppet code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet有一个强大的模块生态系统，这些模块是预先编写的Puppet代码，可以用于配置常见的基础设施资源。这些模块可在**Puppet Forge**中找到，Puppet
    Forge是一个公开的Puppet代码存储库。
- en: 'Here’s an example Puppet manifest that installs `nginx` and creates a configuration
    file similar to what we did with SaltStack and Chef:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例Puppet清单，它安装`nginx`并创建一个类似我们在SaltStack和Chef中所做的配置文件：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once you’ve created a manifest and put it on the Puppet server, it will be picked
    up by the Puppet agent installed on your server and executed. Communication, the
    same as in SaltStack, is being secured by the TLS protocol using the same mechanism
    as the HTTPS servers on the internet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了清单并将其放置在Puppet服务器上，它将被安装在服务器上的Puppet代理拾取并执行。通信方式与SaltStack相同，通过TLS协议确保安全，使用与互联网上的HTTPS服务器相同的机制。
- en: The agent nodes run a Puppet agent process, which connects to the master server
    over TCP port `8140`. The agent sends a **certificate signing request** (**CSR**)
    to the server, which the administrator must approve. Once the CSR is approved,
    the agent is granted access to the server’s Puppet configuration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代理节点运行Puppet代理进程，通过TCP端口`8140`连接到主服务器。代理向服务器发送**证书签名请求**（**CSR**），管理员必须批准此请求。一旦CSR被批准，代理将获得对服务器Puppet配置的访问权限。
- en: When the agent runs, it sends a request to the master server for its configuration.
    The server responds with a catalog of resources that should be applied to the
    node. The catalog is generated based on the Puppet code and manifests stored on
    the server, as well as any external data sources or hierarchies that are configured.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理运行时，它向主服务器发送请求以获取其配置。服务器响应并提供一个资源目录，说明应应用于节点的内容。该目录是根据存储在服务器上的Puppet代码和清单，以及配置的任何外部数据源或层次结构生成的。
- en: The agent then applies the catalog to the node, which involves making any necessary
    changes to the node’s configuration to ensure it matches the desired state defined
    in the catalog. This may involve installing packages, updating configuration files,
    or starting or stopping services.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代理将目录应用到节点，这包括对节点配置进行必要的更改，以确保其与目录中定义的期望状态匹配。这可能包括安装软件包、更新配置文件或启动或停止服务。
- en: The agent sends reports back to the server after applying the catalog, which
    can be used for monitoring and auditing purposes. The server can also use this
    information to detect changes to the node’s configuration that were not made through
    Puppet and to take corrective action if necessary.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代理在应用完目录后将报告发送回服务器，这些报告可用于监控和审计。服务器还可以使用这些信息检测通过Puppet未做的节点配置更改，并在必要时采取纠正措施。
- en: CFEngine
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CFEngine
- en: '**CFEngine** is an open source CM system that allows users to automate the
    deployment, configuration, and maintenance of IT systems. It was founded by Mark
    Burgess in 1993 and has since become a popular tool for managing large-scale IT
    infrastructures. CFEngine is known for its powerful and flexible language for
    describing system configurations and enforcing policies, making it a great choice
    for complex IT environments.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**CFEngine** 是一个开源的配置管理系统，允许用户自动化部署、配置和维护 IT 系统。它由 Mark Burgess 于 1993 年创立，之后成为管理大规模
    IT 基础设施的流行工具。CFEngine 以其强大而灵活的语言来描述系统配置和执行策略而闻名，是处理复杂 IT 环境的理想选择。'
- en: CFEngine’s first release was in 1994, making it one of the oldest CM tools in
    existence. Since then, CFEngine has undergone numerous updates and improvements
    to keep up with changing IT environments and emerging technologies. The latest
    release of CFEngine, version 3.18, includes features such as improved encryption,
    enhanced monitoring capabilities, and better support for cloud infrastructure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CFEngine 的第一次发布是在 1994 年，使其成为现存最古老的配置管理工具之一。此后，CFEngine 经历了许多更新和改进，以适应不断变化的
    IT 环境和新兴技术。CFEngine 最新版本 3.18 包括改进的加密功能、增强的监控能力和对云基础设施的更好支持。
- en: CFEngine has gained popularity over the years due to its robust functionality,
    ease of use, and strong community support. It’s still being used today by many
    organizations and is actively developed, so it is a safe option to manage the
    configuration of your servers using this tool.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，CFEngine 因其强大的功能、易用性和强大的社区支持而广受欢迎。今天，许多组织仍在使用它，并且它仍在积极开发，因此它是一个安全的选择，可以用来管理你的服务器配置。
- en: 'An example CFengine configuration will be presented here. It is, out of necessity,
    only a snipped and not a complete configuration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将展示一个 CFEngine 配置示例。由于需要，它只是一个片段，而非完整配置：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this section, we have explained what CaC is and why it is an important tool
    in the toolbelt of system administrators. We have briefly described the most popular
    tools available to you. In the next section, we will introduce our tool of choice—Ansible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经解释了什么是 CaC，以及为什么它是系统管理员工具箱中的一个重要工具。我们简要描述了你可以使用的最流行的工具。在下一节中，我们将介绍我们首选的工具——Ansible。
- en: Ansible
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible
- en: In this section, we are going to introduce you to **Ansible**, our tool of choice
    when it comes to CaC.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向你介绍 **Ansible**，这是我们在 CaC 方面的首选工具。
- en: Ansible is a tool written for managing the configuration of systems and devices.
    It is written in Python and its source code is freely available to anyone for
    downloading and modification (within the limits of its license, which is Apache
    License `2.0`). The name “Ansible” comes from Ursula K. Le Guin’s book *Rocannon’s
    World* and denotes a device that allows instantaneous communication no matter
    the distance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一款用于管理系统和设备配置的工具。它是用 Python 编写的，源代码可以自由下载和修改（在 Apache License `2.0`
    许可范围内）。名字“Ansible”来源于 Ursula K. Le Guin 的小说 *Rocannon’s World*，指的是一种无论距离多远都能实现瞬时通信的设备。
- en: 'Some interesting characteristics of Ansible are set out here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了 Ansible 一些有趣的特点：
- en: '**Modularity**: Ansible is not a monolithic tool. Rather, it’s a core program
    with each task it knows how to perform written as a separate module—a library,
    if you will. Since this was the design from the start, it produced a clean API
    that anyone can use to write their own modules.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：Ansible 不是一个单体工具。它是一个核心程序，每个它知道如何执行的任务都被写作一个独立的模块——如果你愿意的话，可以把它看作是一个库。由于从一开始就是这种设计，它产生了一个干净的
    API，任何人都可以使用这个 API 来编写自己的模块。'
- en: '**Idempotence**: No matter how many times you perform a configuration, the
    result is always the same. This is one of the most important and fundamental characteristics
    of Ansible. You don’t have to know which actions have been performed. When you
    extend the configuration and run the tool again, it is its job to find out the
    state of the system and only apply new actions.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幂等性**：无论执行多少次配置，结果始终保持不变。这是 Ansible 最重要和最基本的特点之一。你不必知道哪些操作已经执行过。当你扩展配置并再次运行工具时，它的工作是找出系统的状态并仅应用新的操作。'
- en: '**Agentlessness**: Ansible doesn’t install its agent on the configured system.
    That is not to say it doesn’t need anything at all. To execute the Ansible scripts,
    the target system will need some means of connecting to it (most often, the SSH
    server running) and the Python language installed. There are several advantages
    born from this paradigm, including the following:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无代理**：Ansible 不会在配置系统上安装代理。这并不意味着它完全不需要任何东西。为了执行 Ansible 脚本，目标系统需要能够连接到它的一些手段（通常是运行的
    SSH 服务器）以及安装 Python 语言。这个范式带来了几个优势，包括以下几点：'
- en: 'Ansible is not concerned with communication protocol. It uses SSH, but it doesn’t
    implement it, leaving the details to the operating system, SSH server, and client.
    An advantage is that you can freely swap one SSH solution with another for whatever
    reasons, and your Ansible playbooks should work as intended. Also, Ansible doesn’t
    concern itself with securing the SSH configuration. This leaves developers to
    concentrate on what the system is really about: configuring your systems.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 与通信协议无关。它使用 SSH，但并不实现该协议，而是将细节留给操作系统、SSH 服务器和客户端。一个优势是，你可以根据需要自由地将一个
    SSH 解决方案替换为另一个，而你的 Ansible 剧本应该照常工作。此外，Ansible 也不关心 SSH 配置的安全性，这让开发人员可以集中精力处理系统的真正问题：配置你的系统。
- en: The Ansible project does not need to develop and maintain separate programs
    for managed nodes. This not only frees developers from unneeded burdens but also
    limits the possibility of security exploits being discovered and used against
    target machines.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 项目无需为被管理的节点开发和维护独立的程序。这不仅减轻了开发人员的不必要负担，还限制了安全漏洞被发现并用于攻击目标机器的可能性。
- en: In an agent-utilizing solution, if, for any reason, the agent program stops
    working, there is no way to deliver new configurations to the system. SSH servers
    are usually very widely used, and the probability of failure is negligible.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用代理的解决方案中，如果由于任何原因，代理程序停止工作，就无法将新的配置传递到系统中。SSH 服务器通常使用广泛，故障的概率几乎可以忽略不计。
- en: Using SSH as the communication protocol lowers the risk of a firewall blocking
    the communication port for the CM system.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SSH 作为通信协议可以降低防火墙阻止 CM 系统通信端口的风险。
- en: '`nginx` is installed, the proper configuration entry would look like this:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nginx` 已安装，正确的配置项应该如下所示：'
- en: '[PRE5]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The main way of working with Ansible is through writing configuration files
    in a special syntax called YAML. **YAML** is a syntax created specifically for
    configuration files and is loosely based on Python formatting. Indentations play
    a significant role in YAML files. YAML’s home page presents a full cheat sheet
    card ([https://yaml.org/refcard.xhtml](https://yaml.org/refcard.xhtml)) for the
    syntax. However, the most important parts are presented here, as we will be working
    mostly with those files in this chapter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ansible 交互的主要方式是通过编写使用一种叫做 YAML 的特殊语法的配置文件。**YAML** 是一种专为配置文件设计的语法，基于 Python
    的格式化方式。缩进在 YAML 文件中起着重要作用。YAML 的主页提供了完整的备忘单卡片（[https://yaml.org/refcard.xhtml](https://yaml.org/refcard.xhtml)），其中涵盖了该语法。然而，这里将呈现最重要的部分，因为我们在本章中将主要与这些文件打交道：
- en: They are clear text files. This means they can be viewed and edited using the
    simplest editors such as Notepad, Vim, Emacs, or whatever is your favorite tool
    for working with text files.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是明文文件。这意味着可以使用最简单的编辑器（如 Notepad、Vim、Emacs，或任何你喜欢的文本编辑工具）查看和编辑它们。
- en: Indentations are used to denote scope. Tabulators are not permitted for indentations
    and it is customary to use spaces for this purpose.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进用于表示范围。不允许使用制表符进行缩进，通常使用空格来进行缩进。
- en: A new document opens with three hyphens (`-`). One file can have more than one
    document.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新文档以三个短横线（`-`）开头。一个文件可以包含多个文档。
- en: Comments, as in Python, start with a hash (`#`) and continue until the end of
    the line. The comment must be surrounded by whitespace characters; otherwise,
    it will be treated as a literal hash (`#`) within a text.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释与 Python 中相同，以井号（`#`）开始，直到行尾。注释必须被空白字符包围，否则它将被视为文本中的字面井号（`#`）。
- en: Text (strings) can be unquoted, single-quoted (`'`), or double-quoted (`"`).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本（字符串）可以不加引号、单引号（`'`）或双引号（`"`）括起来。
- en: When a list is specified, each member is denoted by a hyphen (`-`) character.
    Each item will be on a separate line. If single-line representation is required,
    the list items can be enclosed in square brackets (`[]`) with entries separated
    by commas (`,`).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定一个列表时，每个成员由一个连字符（`-`）表示。每个项目将占一行。如果需要单行表示，可以将列表项用方括号（`[]`）括起来，并用逗号（`,`）分隔。
- en: Associative arrays are represented by a key-value pair with each key separated
    from the value by a colon and space. If they have to be presented in one line,
    the array is enclosed in curly brackets (`{}`) and pairs are separated by commas
    (`,`).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联数组通过键值对表示，每个键和值之间用冒号和空格分隔。如果必须在一行中呈现，数组将用大括号（`{}`）括起来，键值对之间用逗号（`,`）分隔。
- en: If the preceding rules are not very transparent now, don’t panic. We are going
    to write proper Ansible configuration files, and things will become clear as we
    go.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的规则现在还不太清楚，别担心。我们将编写正确的Ansible配置文件，随着过程的推进，所有问题都会明朗。
- en: 'Ansible divides machines into two groups: the **control node** is the computer
    that stores configuration directives and will connect to the target machines and
    configure them. There can be more than one control node. The target machines are
    called **inventories**. Ansible runs actions against computers in the inventory
    listed. Inventories are often written in an **initialization** (**INI**) format,
    which is simple and easy to follow, as explained here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible将机器分为两组：**控制节点**是存储配置指令的计算机，它将连接到目标机器并进行配置。控制节点可以有多个。目标机器称为**库存**。Ansible将在列出的库存中的计算机上运行操作。库存通常以**初始化**（**INI**）格式编写，这种格式简单易懂，如下所示：
- en: Comments start with a semicolon (`;`)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释以分号（`;`）开头。
- en: Sections are named and the names are enclosed in square brackets (`[]`)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各个部分有名称，并且名称用方括号（`[]`）括起来。
- en: Configuration directives are stored in pairs, each pair on its own line, with
    the key and value separated by an equals sign (`=`)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置指令以键值对的形式存储，每一对独占一行，键和值之间用等号（`=`）分隔。
- en: We will see an example of an inventory file shortly. There is, however, the
    possibility of having so-called dynamic inventories, which are generated automatically
    by means of a script or a system with each run of Ansible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到一个库存文件的例子。然而，也有可能存在所谓的动态库存，它是通过脚本或每次运行Ansible时由系统自动生成的。
- en: The main configuration file that we will be interacting with is called a playbook.
    A **playbook** is an entry point for Ansible. This is where the tool will start
    the execution. Playbooks can include other files (and this is often done).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要交互的主要配置文件称为剧本。**剧本**是Ansible的入口点，工具将从这里开始执行。剧本可以包括其他文件（这通常会这么做）。
- en: 'Target hosts can be broken down into groups based on custom criteria: operating
    system, role within organization, physical location—whatever is required. The
    groups are called **roles**.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 目标主机可以根据自定义标准进行分组：操作系统、组织中的角色、物理位置——任何需要的内容。这样的分组称为**角色**。
- en: A single action that is to be performed is called a **task**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一项要执行的单一操作称为**任务**。
- en: Basics of using Ansible
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible的基础知识
- en: The first thing to do is to install Ansible. This is pretty straightforward
    on all major Linux distributions and can be equally so on macOS. We encourage
    you to figure out the solution for your chosen operating system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是安装Ansible。这在所有主要的Linux发行版上都非常简单，macOS也同样如此。我们建议您根据所选择的操作系统找到相应的解决方案。
- en: 'For Debian-based distributions, the following command should suffice:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Debian的发行版，以下命令应该足够：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For Fedora Linux distributions, you’d run the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Fedora Linux发行版，您可以运行以下命令：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To install the latest version of Ansible, however, we recommend using the Python
    virtual environment and its `pip` tool, like so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要安装最新版本的Ansible，我们建议使用Python虚拟环境及其`pip`工具，如下所示：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we have activated the virtual environment using the
    `venv python3` module. It will create a special `venv` directory that contains
    all important files and libraries that allow us to set up a Python virtual environment.
    Next, we have the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`venv python3`模块激活了虚拟环境。它将创建一个特殊的`venv`目录，其中包含所有重要的文件和库，允许我们设置Python虚拟环境。接下来，我们有以下内容：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code line, we have read a special file that sets the environment
    by configuring the shell. Next, we have this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们读取了一个特殊的文件，该文件通过配置shell来设置环境。接下来，我们有以下内容：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we have upgraded `pip`, a Python package installer.
    In the next step, we are going to actually install Ansible, also using `pip`.
    The output will be shortened for brevity:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们已经升级了 `pip`，一个 Python 包管理器。在下一步中，我们将实际安装 Ansible，也使用 `pip`。为了简洁起见，输出将被缩短：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see in the preceding code, `pip` informs us that Ansible and its
    dependencies were installed successfully.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在上面的代码中看到的，`pip` 告诉我们 Ansible 及其依赖项已成功安装。
- en: Either of those ways of installing Ansible will download and install all the
    packages required to run Ansible on your computer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种安装 Ansible 的方式都将下载并安装运行 Ansible 所需的所有软件包。
- en: 'The simplest command you can run is called ad hoc `ping`. It’s so basic that
    it is one of the most prevalent first uses of Ansible in tutorials and books.
    We are not going to deviate from it. The following command tries to connect to
    a specified host and then prints the result of the trial:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行的最简单命令是所谓的临时 `ping`。它如此基础，以至于它成为了 Ansible 在教程和书籍中最常见的入门用法之一。我们也不打算偏离它。以下命令尝试连接到指定主机，并打印连接结果：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding command, we have told Ansible to run against all hosts in inventory,
    use the `ping` module (`-m ping`), and use an inventory file named `inventory`
    (`-i inventory`). If you don’t specify the inventory file, Ansible will try to
    use `/etc/ansible/hosts`, which is generally a bad idea.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的命令中，我们告诉 Ansible 运行针对清单中的所有主机，使用 `ping` 模块（`-m ping`），并使用名为 `inventory`
    的清单文件（`-i inventory`）。如果你没有指定清单文件，Ansible 将尝试使用 `/etc/ansible/hosts`，但通常这样做不是个好主意。
- en: We will delve into the inventory file in a moment, a few paragraphs ahead.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后的段落中深入探讨清单文件。
- en: A `ping` module (which we can also understand as a `ping` command). It is not,
    however, the same as the OS `ping` command, which sends a specially crafted network
    packet to determine whether a host is up. The Ansible `ping` command will also
    try to log in, to determine whether the credentials are correct.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `ping` 模块（我们也可以理解为一个 `ping` 命令）。然而，它与操作系统中的 `ping` 命令不同，后者发送一个特别制作的网络数据包来判断主机是否在线。而
    Ansible 的 `ping` 命令则会尝试登录，以确定凭证是否正确。
- en: By default, Ansible uses the SSH protocol with a private-public key pair. In
    a normal operation, you don’t want to use password-based authentication, and Ansible
    will choose a key-based one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible 使用 SSH 协议和一对公私密钥。在正常操作中，你通常不想使用基于密码的身份验证，而是会选择基于密钥的身份验证。
- en: Ansible is very good at providing self-explanatory information as a result of
    the execution. The preceding output tells us that Ansible was able to connect
    to all nodes in the inventory (there’s only one), `python3` is installed there,
    and nothing was changed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 在执行结果中非常擅长提供自解释的信息。上面的输出告诉我们，Ansible 成功连接到清单中的所有节点（这里只有一个），`python3`
    已安装，并且没有做任何更改。
- en: 'The inventory file is a simple but powerful tool to list, group, and provide
    variables for managed nodes. Our example inventory file is pasted as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 清单文件是一个简单但强大的工具，用于列出、分组和为被管理的节点提供变量。我们的示例清单文件如下所示：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is two lines. The first one declares a group of nodes called
    `www`. The second declares a node called `hostone`. Since this is not a name resolvable
    by DNS, we have declared its IP address using the `ansible_host` variable. Then,
    we point to the proper `ssh` key file and declare which username should be used
    while logging in (`admin`). There are more things we can define in this file.
    Very detailed information about writing your inventory file can be found in the
    Ansible project documentation ([https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码有两行。第一行声明了一个名为 `www` 的节点组。第二行声明了一个名为 `hostone` 的节点。由于这是一个无法通过 DNS 解析的名称，我们通过
    `ansible_host` 变量声明了它的 IP 地址。然后，我们指定了正确的 `ssh` 密钥文件，并声明了登录时应该使用的用户名（`admin`）。在这个文件中，我们还可以定义更多内容。有关编写清单文件的详细信息，可以参考
    Ansible 项目的文档 ([https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml))。
- en: We are unable to cover all aspects of Ansible and dig deeper into most of the
    features that we are going to use here. Packt Publishing, however, has a very
    good selection of books on Ansible that you may wish to choose if you want to
    deepen your knowledge—for example, *Mastering Ansible, Fourth Edition,* by James
    Freeman and Jesse Keating.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法涵盖Ansible的所有方面，也没有深入探讨我们在这里将使用的大部分功能。然而，Packt出版社有很多很好的Ansible书籍，如果你想深化你的知识，可能会有兴趣选择其中的一些书籍——例如James
    Freeman和Jesse Keating的*《Mastering Ansible，第四版》*。
- en: Tasks
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务（Tasks）
- en: 'Tasks lie at the heart of the Ansible configuration. They are exactly that:
    tasks to be run against managed nodes. Tasks are contained in plays. They can
    be placed there directly (put into a playbook) or indirectly (included via a role).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是Ansible配置的核心。它们正是那些要在托管节点上执行的任务。任务包含在剧本中。它们可以直接放入剧本中（写入剧本文件），也可以间接地通过角色包含。
- en: There’s a special type of task called **handles**. This is a task that will
    be executed only when notified by another task.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊类型的任务叫做**处理（handles）**。这是一个只有在另一个任务通知时才会执行的任务。
- en: Roles
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色（Roles）
- en: 'Ansible’s documentation defines **roles** as “*A limited distribution of reusable
    Ansible content (tasks, handlers, variables, plugins, templates and files) for
    use inside of a play.*” For our purpose, we can think of them as a mechanism to
    group parts of the play. A role can be a type of host we are going to run the
    play against: web server, database server, Kubernetes node, and so on. By breaking
    down playbooks into roles, we can manage separate required tasks more easily and
    efficiently. Not to mention the files containing those become more readable, since
    we limit the number of tasks within and group them by their function.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible的文档将**角色（roles）**定义为“*可重用Ansible内容（任务、处理程序、变量、插件、模板和文件）的一种有限分发，用于剧本内部使用。*”就我们而言，我们可以将它们视为一种将剧本部分进行分组的机制。一个角色可以是我们要执行剧本的主机类型：Web服务器、数据库服务器、Kubernetes节点等等。通过将剧本分解为角色，我们可以更容易、更高效地管理单独的任务。更不用说，这些包含文件的内容也变得更加可读，因为我们限制了其中的任务数量，并按其功能进行分组。
- en: Plays and playbooks
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剧本和剧本集
- en: '**Plays** are the context in which tasks are performed. While plays are somewhat
    of an ephemeral concept, **playbooks** are their physical representations: YAML
    files in which plays are defined.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**剧本（Plays）**是在任务执行的上下文中。虽然剧本是一个有些短暂的概念，**剧本集（playbooks）**是其物理表现：定义剧本的YAML文件。'
- en: 'Let’s look at an example of a playbook. The following playbook will install
    `nginx` and `php` packages on a managed node:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个剧本示例。以下剧本将在托管节点上安装`nginx`和`php`软件包：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line (three dashes) marks the beginning of a new YAML document. The
    next line names the whole playbook. Playbook names should be short but descriptive.
    They are going to end up in logs and debugging information.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行（三个破折号）标志着一个新的YAML文档的开始。下一行是整个剧本的名称。剧本的名称应简短但具有描述性。它们最终会出现在日志和调试信息中。
- en: Next, we inform Ansible that this play should be run against nodes in the inventory
    placed in the `www` group. We also tell Ansible to use `sudo` when executing the
    commands. This is required as all distributions that we cover in our guide require
    root privileges to install and remove packages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通知Ansible该剧本应该在`www`组中的节点上执行。我们还告诉Ansible在执行命令时使用`sudo`。这是必需的，因为我们在本指南中覆盖的所有发行版都需要root权限来安装和删除软件包。
- en: Then, we start the `tasks` section. Each task is given a name, the name of the
    module (command) we are going to use, and the command is given options and arguments.
    As you can see, the indentation declares the scope. If you are familiar with the
    Python programming language, this should be intuitive for you.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始`tasks`部分。每个任务都会被命名，并指定我们将要使用的模块（命令），同时命令会附带选项和参数。如你所见，缩进声明了范围。如果你熟悉Python编程语言，这对你来说应该是直观的。
- en: 'Before we run this playbook, let’s use a very useful tool, `ansible-lint`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这个剧本之前，让我们使用一个非常有用的工具，`ansible-lint`：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I have cut part of the output for brevity, but you can see that the tool printed
    information about violations of YAML syntax and Ansible best practices. Failures
    are types of errors that will stop the execution of the playbook. Warnings are
    just that: the playbook will be executed, but there are some errors that go against
    best practices. Let’s correct our playbook, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁，我已经删除了一部分输出，但你可以看到工具打印了关于YAML语法和Ansible最佳实践违规的信息。失败是会停止剧本执行的错误类型。警告仅仅是警告：剧本将继续执行，但存在一些违反最佳实践的错误。让我们按如下方式修正我们的剧本：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now run the playbook using the `ansible-playbook` command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用`ansible-playbook`命令运行playbook：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding output, we have instructed the `ansible-playbook` command
    to use an inventory file called `inventory` and run a playbook named `install.yaml`.
    The output should be self-explanatory: we are informed of the name of the play
    we run. Then, we see a list of managed nodes that Ansible will try to execute
    action against. Then, we see tasks and a list of nodes that the tasks succeeded
    or failed at. The `nginx` task was a success on `hostone`. However, installing
    `php` failed. Ansible gives us the exact reason for it: there is no `php8` package
    available for our managed node. Sometimes, a resolution is pretty obvious, but
    sometimes it requires a bit of digging around. After checking with our distribution,
    we find out that the actual `php` package available there is `php7.4`. After quickly
    correcting the offending line, we run the playbook again, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们指示`ansible-playbook`命令使用名为`inventory`的清单文件，并运行名为`install.yaml`的playbook。输出应该是自解释的：我们会看到我们运行的play的名称。接下来，我们会看到Ansible将尝试执行操作的受管节点列表。然后，我们看到任务和任务成功或失败的节点列表。`nginx`任务在`hostone`上成功执行。然而，安装`php`失败了。Ansible给出了确切的原因：我们的受管节点上没有`php8`包。有时，解决方案很明显，但有时则需要一些挖掘。经过与我们的发行版检查后，我们发现实际可用的`php`包是`php7.4`。在快速更正有问题的行后，我们再次运行playbook，如下所示：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice the change in the output. First, Ansible tells us that `nginx` on `hostone`
    is okay. This means that Ansible was able to determine that the package was already
    installed, and it took no action. Then, it told us that the `php7.4` installation
    was successful (`changed: [hostone]`) on the `hostone` server.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '注意输出中的变化。首先，Ansible告诉我们`hostone`上的`nginx`是正常的。这意味着Ansible能够确认包已安装，因此没有采取任何行动。接着，它告诉我们`hostone`服务器上的`php7.4`安装成功（`changed:
    [hostone]`）。'
- en: The preceding playbook is short, but we hope it demonstrates the usefulness
    of the tool. Playbooks are executed in a linear manner, from top to bottom.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的playbook很短，但我们希望它能够展示这个工具的有用性。Playbook是以线性方式执行的，从上到下。
- en: 'There’s one problem with our playbook. While it only installs two packages,
    you may be worried about maintainability and readability if you need to install
    tens or hundreds of packages. Having a separate task for each of them is troublesome.
    There’s a solution. You can create a list of items that a given task will be executed
    for—something akin to a loop. Let’s edit the `tasks` part of the playbook, as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的playbook存在一个问题。虽然它只安装了两个包，但如果需要安装数十个甚至上百个包，你可能会担心可维护性和可读性。为每个包单独创建任务是麻烦的。幸好，有解决方案。你可以为给定任务创建一个项目列表，任务将对该列表中的每个项目执行——类似于一个循环。让我们如下编辑playbook的`tasks`部分：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have added two packages to demonstrate a more complete run. Notice the lack
    of a separate task for `php7.4`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个包，以展示一个更完整的运行过程。注意没有为`php7.4`单独创建任务。
- en: 'Before running this play, it is always a good idea to check it with `ansible-lint`.
    Here’s how we can do that:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行这个play之前，最好先用`ansible-lint`检查一下。下面是如何操作：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, after `ansible-lint` gives us the green light, let’s play this playbook:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`ansible-lint`给出绿色信号后，让我们运行这个playbook：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Assume we want to install a page configuration in `nginx`. Ansible is able
    to copy files. We can set it to copy `nginx` virtual server configuration, but
    we only want to restart `nginx` once: at the service setup.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在`nginx`中安装页面配置。Ansible可以复制文件。我们可以设置它来复制`nginx`虚拟服务器配置，但我们只希望在服务设置时重启`nginx`一次。
- en: 'We can do it via `notify` and `handlers`. I’ll paste the whole playbook ahead:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`notify`和`handlers`来实现这一点。我会先粘贴整个playbook：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice the whole new section related to copying files. We also create a `nginx`.
    We have shortened it for brevity’s sake and only to demonstrate a principle.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到与复制文件相关的整个新部分。我们还创建了一个`nginx`。为了简洁起见，我们简化了它，只是为了展示一个原理。
- en: 'The execution of this play yields the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此play后，得到以下输出：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As soon as you start using Ansible in a real production environment, it becomes
    obvious that even with the *looping* technique we demonstrated previously, the
    playbook grows pretty fast and becomes unwieldy. Thankfully, there’s a way to
    break the playbook into smaller files.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你开始在实际生产环境中使用Ansible，就会明显发现，即使使用我们之前展示的*循环*技巧，playbook也会迅速增长并变得难以管理。幸运的是，有一种方法可以将playbook分解成更小的文件。
- en: One of the ways to do it is to segregate tasks into roles. As mentioned earlier,
    a role is a bit of an abstract concept, so the easiest way to think about it is
    to consider it a group. You group tasks depending on the criteria that are relevant
    to you. While the criteria are totally up to you, it is pretty common for roles
    to refer to the type of function a given managed node performs. One managed node
    can perform more than one function, but it still is probably wise to separate
    the functions into their own roles. Thus, the HTTP server would be one role, the
    database server would be another, and the file server would be yet another.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种方法是将任务划分为不同的角色。如前所述，角色是一个抽象的概念，因此最简单的方式是将其视为一个组。你根据对你来说相关的标准将任务分组。虽然标准完全由你决定，但通常情况下，角色会根据给定的受管节点执行的功能类型来命名。一个受管节点可以执行多个功能，但仍然最好将这些功能分开到不同的角色中。因此，HTTP
    服务器将是一个角色，数据库服务器将是另一个角色，文件服务器将是另一个角色。
- en: Roles in Ansible have a predetermined directory structure. There are eight standard
    directories defined, although you only need to create one.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 中的角色有一个预定的目录结构。定义了八个标准目录，尽管你只需要创建其中一个。
- en: 'The following code is copied from the Ansible documentation ([https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_reuse_roles.xhtml](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_reuse_roles.xhtml)):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码摘自 Ansible 文档（[https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_reuse_roles.xhtml](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_reuse_roles.xhtml)）：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `roles` directory exists on the same level as your playbook. The most common
    subdirectories you will probably see are `tasks`, `templates`, `files`, `vars`,
    and `handlers`. Within each subdirectory, Ansible will look for a `main.yml`,
    `main.yaml`, or `main` file (all of them have to be valid YAML files). Their contents
    will be automatically available to the playbook. So, how would this work in practice?
    Within the same directory that our `install.yaml` playbook exists, we will create
    a `roles` directory. Within this directory, we will create another one: `www`.
    Inside that one, we will create directories: `tasks`, `files`, and `handlers`.
    A similar structure will be created with `development` as a role:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`roles` 目录与 playbook 位于同一级别。你可能会看到的最常见子目录是 `tasks`、`templates`、`files`、`vars`
    和 `handlers`。在每个子目录中，Ansible 会查找一个 `main.yml`、`main.yaml` 或 `main` 文件（所有这些文件必须是有效的
    YAML 文件）。它们的内容将自动提供给 playbook。那么，这在实践中是如何工作的呢？在与我们当前 `install.yaml` playbook 同一目录下，我们将创建一个
    `roles` 目录。在该目录下，我们将再创建一个目录：`www`。在这个目录中，我们将创建：`tasks`、`files` 和 `handlers` 目录。我们将为
    `development` 角色创建一个类似的结构：'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `development` role has only tasks subdirectory because we don’t require
    any additional bells and whistles. Why the development role, though? When you
    look back at our current playbook, you’ll notice that we mix up installing things
    for the `www` server and development packages—namely, compilers. It is bad practice,
    even if they will end up on the same physical server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`development` 角色只有任务子目录，因为我们不需要任何额外的附加功能。那么，为什么是开发角色呢？当你回顾我们的当前 playbook 时，你会发现我们将
    `www` 服务器和开发软件包（即编译器）的安装混在一起了。这是一个不好的做法，即使它们最终会安装在同一台物理服务器上。'
- en: 'Thus, we are going to edit our inventory file so that we have two separate
    roles:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将编辑我们的清单文件，以便我们有两个独立的角色：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Both groups contain only one node, which is a bad thing to do overall. We do
    it only for the purpose of this guide. Don’t install compilers and development
    software on your HTTP server, especially on the production one.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 两个组只包含一个节点，这种做法整体上是不好的。我们这样做仅仅是为了本指南的目的。不要在 HTTP 服务器上安装编译器和开发软件，尤其是在生产环境中。
- en: 'Now, we have to move some stuff around within the playbook. The `install.yml`
    file will become much shorter, as we can see here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在 playbook 中移动一些内容。`install.yml` 文件将变得更短，正如我们在这里看到的：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We actually have two plays in this playbook. One of them is for `www` hosts,
    and the other is for `development` hosts. After we give the play a name and list
    host groups that we wish it to run against, we use keyword roles and list actual
    roles to be used. As you can see, Ansible is going to locate the proper roles
    automatically, as long as you adhere to the directory structure explained previously.
    There are ways to include roles directly by specifying their full path, but we’re
    not going to cover them here.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 其实我们在这个 playbook 中有两个 play。一个是针对 `www` 主机的，另一个是针对 `development` 主机的。我们为每个 play
    起个名字，并列出希望它运行的主机组，然后使用关键字 roles 列出实际使用的角色。如你所见，只要你遵循之前解释的目录结构，Ansible 会自动定位到正确的角色。当然，也可以通过指定角色的完整路径直接包含角色，但我们这里不做详细讲解。
- en: 'Now, for the `www` role, we’ll execute the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于 `www` 角色，我们将执行以下代码：
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should notice several changes from the get-go:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始你就应该注意到几个变化：
- en: There is no `tasks` keyword in this document. This is implicit by the fact that
    this is the `main.yaml` file within the `tasks` subdirectory.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这份文档中没有 `tasks` 关键字。这是因为该文件是 `tasks` 子目录中的 `main.yaml` 文件，默认包含任务。
- en: Indentation has been moved left.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进已经向左移动。
- en: There are no handlers here.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里没有 handlers。
- en: We have removed the installation of the `gcc` and `g++` packages.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经移除了 `gcc` 和 `g++` 包的安装。
- en: 'Let’s now see the handlers:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下 handlers：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The overall changes are the same, as noted here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 总体变化如这里所示：
- en: We have removed the `handlers` keyword
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经移除了 `handlers` 关键字
- en: We have moved the indentation to the left
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已将缩进移到左侧
- en: 'Now, let’s see `roles/development/tasks/main.yaml`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下 `roles/development/tasks/main.yaml`：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is very simple. We may have increased the complexity of the directory structure,
    but we have gained the simplicity of tasks and plays. The gains are well worth
    the trade-off, especially when your playbooks grow in size and complexity.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。我们可能增加了目录结构的复杂性，但我们也简化了任务和 play 的编写。当你的 playbook 越来越大，越来越复杂时，这些好处完全值得这个权衡。
- en: 'There are many advantages to using a CaC tool, as outlined here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CaC 工具有许多优势，具体如下：
- en: Configuration can be linted—that is, checked for syntax errors by automation
    tools
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置可以进行 lint 检查——也就是说，可以通过自动化工具检查语法错误
- en: It can be applied infinitely with the same outcomes
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以无限次应用，且结果相同
- en: It can be run on many systems in parallel
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在多个系统上并行运行
- en: It can be kept in a version control system, such as Git, where the history of
    changes and comments for them are stored and can be viewed at any time
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以存放在版本控制系统中，比如 Git，其中保存了变更的历史记录和评论，可以随时查看
- en: It can be run by automation tools, removing the need for a human factor besides
    writing playbooks
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以由自动化工具运行，从而不再需要人工干预，只需编写 playbook 即可
- en: In this subsection, we have shown how to write simple Ansible playbooks. We
    have explained what Ansible is and what the building blocks of the configuration
    scripts are. We have introduced playbooks, roles, and the inventory. There are
    many more things Ansible can do for you. You can manage devices, filesystems,
    users, groups, permissions, networking, and so on. The list of all modules Ansible
    is shipped with out of the box is impressive. You can always check the list at
    [https://docs.ansible.com/ansible/latest/module_plugin_guide/index.xhtml](https://docs.ansible.com/ansible/latest/module_plugin_guide/index.xhtml).
    Remember to check the list for your version of Ansible.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一小节中，我们展示了如何编写简单的 Ansible playbook。我们解释了什么是 Ansible，以及配置脚本的基本组成部分。我们介绍了 playbook、角色和清单。Ansible
    还可以做很多其他事情。你可以管理设备、文件系统、用户、组、权限、网络等等。Ansible 默认自带的所有模块列表令人印象深刻。你可以随时查看这个列表，访问
    [https://docs.ansible.com/ansible/latest/module_plugin_guide/index.xhtml](https://docs.ansible.com/ansible/latest/module_plugin_guide/index.xhtml)。记得查看你所使用的
    Ansible 版本的列表。
- en: 'So, now that we’ve covered installing, configuring, and using Ansible to manage
    your servers (installing software, creating configuration files, and managing
    services), we are ready to look into Ansible Galaxy: community-developed modules
    that increase Ansible’s usefulness.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经介绍了如何安装、配置以及使用 Ansible 来管理你的服务器（安装软件、创建配置文件和管理服务），接下来我们将探讨 Ansible
    Galaxy：一个社区开发的模块，能够提升 Ansible 的实用性。
- en: Ansible Galaxy
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible Galaxy
- en: Ansible is a powerful automation tool that enables users to configure, deploy,
    and manage complex IT infrastructures with ease. However, creating and maintaining
    Ansible playbooks can be time-consuming, especially when working with large-scale
    environments. Fortunately, Ansible Galaxy exists to help streamline this process
    by providing a centralized repository of pre-built roles and playbooks that can
    be easily integrated into an existing Ansible project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个强大的自动化工具，使用户能够轻松配置、部署和管理复杂的IT基础设施。然而，创建和维护Ansible playbook可能会耗费时间，特别是在处理大规模环境时。幸运的是，Ansible
    Galaxy通过提供一个预构建角色和playbook的中心化存储库，来帮助简化这个过程。
- en: '**Ansible Galaxy** is a community-driven platform that hosts an extensive collection
    of Ansible roles and playbooks. These roles and playbooks are submitted by users
    from around the world and are reviewed and curated by Ansible’s maintainers. Ansible
    Galaxy provides a simple, efficient way to find and use pre-built automation content
    that can save users time and effort while ensuring quality and consistency.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible Galaxy**是一个社区驱动的平台，托管着大量的Ansible角色和playbook。这些角色和playbook由全球用户提交，并由Ansible的维护人员进行审查和策划。Ansible
    Galaxy提供了一种简单高效的方法来查找和使用预构建的自动化内容，可以节省用户的时间和精力，同时确保质量和一致性。'
- en: Using Ansible Galaxy, users can quickly find, download, and use pre-built roles
    and playbooks for popular applications, services, and infrastructure components.
    These pre-built components can help speed up deployment times, ensure best practices
    are followed, and reduce the likelihood of errors or inconsistencies. Ansible
    Galaxy can also help users learn from others’ experiences and gain insights into
    the best practices of their peers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Ansible Galaxy，用户可以快速找到、下载和使用流行应用程序、服务和基础设施组件的预构建角色和playbook。这些预构建组件可以帮助加快部署时间，确保遵循最佳实践，并减少错误或不一致性的可能性。Ansible
    Galaxy还可以帮助用户从他人的经验中学习，并获得同行最佳实践的见解。
- en: 'Let’s use one of the Galaxy roles to install the `nginx` web server on our
    `webserver` role. In order to do that, we will need to install the role from Ansible
    Galaxy. First, ensure that Ansible is installed on your system by running the
    following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个Galaxy角色来在我们的`webserver`角色上安装`nginx` web服务器。为了做到这一点，我们需要从Ansible Galaxy安装角色。首先，请确保在系统上安装了Ansible，运行以下命令：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This command will download and install the `nginx` role from Ansible Galaxy.
    By default, all roles installed are placed in the `~/.ansible/roles` directory.
    It’s possible to change that by creating a global Ansible configuration file in
    your home directory: `~/.ansible.cfg`.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将从Ansible Galaxy下载并安装`nginx`角色。默认情况下，所有安装的角色都放置在`~/.ansible/roles`目录中。您可以通过在您的家目录中创建全局Ansible配置文件`~/.ansible.cfg`来更改这一设置。
- en: 'An example of a configuration file changing the `roles_path` directory looks
    like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 更改`roles_path`目录的配置文件示例如下：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A good practice is to pin role version numbers and put this version in a YAML
    file saved in the same Git repository where you will keep your Ansible playbooks.
    To achieve this, let’s create an `ansible_requirements.yml` file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的做法是固定角色版本号，并将该版本保存在与Ansible playbook同一Git存储库中的YAML文件中。为了实现这一点，让我们创建一个`ansible_requirements.yml`文件：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To install the role from Ansible Galaxy using that file, you would run the
    following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该文件从Ansible Galaxy安装角色，您可以运行以下命令：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the role is installed, it can be used in an Ansible playbook by adding
    the following line to the playbook:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 安装角色后，可以通过将以下行添加到playbook中，在Ansible playbook中使用该角色：
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s an example playbook that uses the `nginx` role from Ansible Galaxy to
    install and configure `nginx` on a remote server:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例playbook，使用Ansible Galaxy中的`nginx`角色在远程服务器上安装和配置`nginx`：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this playbook, we specify the `webservers` group as the target hosts and
    use the `nginxinc.nginx` role to install and configure `nginx`. We also define
    a variable called `nginx_sites` that specifies the configuration for a `nginx`
    server block that will be created using a Jinja2 template located in the playbook’s
    `templates` directory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个playbook中，我们将`webservers`组指定为目标主机，并使用`nginxinc.nginx`角色来安装和配置`nginx`。我们还定义了一个名为`nginx_sites`的变量，该变量指定了在playbook的`templates`目录中使用的Jinja2模板来创建一个`nginx`服务器块的配置。
- en: By using Ansible Galaxy and pre-built roles such as `nginxinc.nginx`, users
    can automate complex tasks quickly and reliably, ensuring consistency and reducing
    the risk of errors.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 Ansible Galaxy 和预构建角色，如 `nginxinc.nginx`，用户可以快速而可靠地自动化复杂任务，确保一致性并减少错误的风险。
- en: Handling secrets
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理机密
- en: Protecting secrets such as passwords, tokens, and certificates is crucial in
    any IT infrastructure. These secrets are the keys to accessing sensitive information
    and services, and their exposure can lead to severe security breaches. Therefore,
    it is crucial to keep them safe and secure. Ansible provides several methods for
    managing secrets, such as Ansible Vault, which allows users to encrypt and decrypt
    sensitive data using a password or key file. This feature helps to protect secrets
    and ensures that only authorized users have access to them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 保护诸如密码、令牌和证书等机密在任何 IT 基础设施中都至关重要。这些机密是访问敏感信息和服务的钥匙，它们的泄露可能导致严重的安全漏洞。因此，保持它们的安全至关重要。Ansible
    提供了多种管理机密的方法，例如 Ansible Vault，它允许用户使用密码或密钥文件加密和解密敏感数据。此功能有助于保护机密，并确保只有授权用户才能访问它们。
- en: Saving secrets in a Git repository or any other public place is a significant
    security risk. Such repositories are often accessible to multiple users, some
    of whom may not have the necessary permissions to access sensitive data. Additionally,
    version control systems such as Git retain the history of changes made to files,
    making it possible for secrets to be exposed inadvertently. This could happen
    if a user inadvertently commits secrets to a repository or if a hacker gains access
    to a repository’s commit history. Therefore, it is vital to discourage saving
    secrets in public places to reduce the risk of unauthorized access. Instead, Ansible
    provides secure ways to manage secrets, ensuring that they are encrypted and only
    accessible to authorized users. By doing so, users can be confident that their
    secrets are safe and secure.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 将机密保存在 Git 仓库或任何其他公共地方是一个重大的安全风险。这类仓库通常对多个用户开放，其中一些用户可能没有访问敏感数据的必要权限。此外，像 Git
    这样的版本控制系统会保留文件修改的历史记录，这可能导致机密不小心泄露。如果用户不小心将机密提交到仓库，或者黑客获取了仓库的提交历史，机密就可能会被暴露。因此，必须避免将机密保存到公共地方，以降低未经授权访问的风险。相反，Ansible
    提供了安全的方式来管理机密，确保它们被加密且仅授权用户可访问。这样，用户可以确信他们的机密是安全的。
- en: Ansible Vault
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible Vault
- en: '**Ansible Vault** is a feature provided by Ansible that enables users to encrypt
    and decrypt sensitive data, such as passwords, keys, and certificates. The vault
    creates an encrypted file that can be decrypted only by authorized users, ensuring
    that sensitive data remains secure. The vault can be used to store secrets in
    files, variables, or other sources that are used by Ansible.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible Vault** 是 Ansible 提供的一个功能，允许用户加密和解密敏感数据，如密码、密钥和证书。该保险库创建一个加密文件，只有授权用户才能解密，从而确保敏感数据的安全。保险库可用于存储文件、变量或其他
    Ansible 使用的源中的机密。'
- en: Ansible Vault uses a variety of encryption methods to secure the secrets stored
    within it. By default, Ansible Vault uses AES 256 encryption, a widely accepted
    and secure encryption algorithm. Additionally, Ansible Vault supports other encryption
    algorithms, such as AES 192 and AES 128, providing flexibility in the encryption
    strength used to secure secrets. When encrypting data with Ansible Vault, users
    can choose to encrypt it with a password or with a key file. This ensures that
    only authorized users who possess the password or key file can decrypt the secrets
    stored within the vault.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Vault 使用多种加密方法来保护其中存储的机密。默认情况下，Ansible Vault 使用 AES 256 加密，这是一个广泛接受且安全的加密算法。此外，Ansible
    Vault 还支持其他加密算法，如 AES 192 和 AES 128，为加密强度提供了灵活性。当使用 Ansible Vault 加密数据时，用户可以选择使用密码或密钥文件进行加密。这确保了只有持有密码或密钥文件的授权用户才能解密存储在保险库中的机密。
- en: 'To create a new vault using Ansible Vault, you can use the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Ansible Vault 创建一个新的保险库，可以使用以下命令：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will create a new encrypted vault file called `secrets.yml`. You will
    be prompted to enter a password to encrypt the file. Once you’ve entered the password,
    the vault file will be created and opened in your default editor. Here’s an example
    `secrets.yml` file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为 `secrets.yml` 的新加密保险库文件。系统会提示你输入一个密码来加密文件。一旦输入密码，保险库文件将被创建并在默认编辑器中打开。以下是一个示例
    `secrets.yml` 文件：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To edit this secret file, you’ll need to use the `ansible-vault edit secrets.yml`
    command and type the encryption password afterward.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑这个秘密文件，你需要使用`ansible-vault edit secrets.yml`命令，并在之后输入加密密码。
- en: 'To write an Ansible task that reads the `pgsql_password` secret from the vault,
    you can use the `ansible.builtin.include_vars` module with the `vault_password_file`
    parameter. Here is an example task:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个Ansible任务，从保险库中读取`pgsql_password`秘密，你可以使用`ansible.builtin.include_vars`模块，并指定`vault_password_file`参数。以下是一个示例任务：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this task, we’re using the `include_vars` module to read the variables from
    the `secrets.yml` vault file. The `vault_password_file` parameter specifies the
    location of the file containing the password to decrypt the vault. We then assign
    the value of `secret_pgsql_password` to the `pgsql_password` variable, which can
    be used elsewhere in the playbook.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们使用`include_vars`模块从`secrets.yml`保险库文件中读取变量。`vault_password_file`参数指定包含解密保险库密码的文件位置。然后，我们将`secret_pgsql_password`的值赋给`pgsql_password`变量，可以在剧本的其他地方使用该变量。
- en: Note that the `secret_pgsql_password` variable should be defined in the vault.
    The `secret_` prefix is to indicate that the password was retrieved from the vault.
    Ansible does not differentiate between regular variables or secret variables.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`secret_pgsql_password`变量应该在保险库中定义。`secret_`前缀表示该密码是从保险库中检索的。Ansible不区分常规变量和秘密变量。
- en: 'When you run this playbook with an increased Ansible debug level, you will
    notice that the PostgreSQL password is exposed in the debug output. To prevent
    that, every task dealing with sensitive information can be executed with the `no_log:
    True` option enabled.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '当你以提高的Ansible调试级别运行这个剧本时，你会注意到PostgreSQL密码暴露在调试输出中。为了防止这种情况发生，任何处理敏感信息的任务都可以启用`no_log:
    True`选项来执行。'
- en: SOPS
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SOPS
- en: '**Secrets OPerationS** (**SOPS**) is an open source tool developed by Mozilla
    that allows users to securely store and manage their secrets within various configuration
    files, including Ansible playbooks. SOPS uses a hybrid encryption approach, which
    means that it combines symmetric and asymmetric encryption to ensure maximum security.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**Secrets OPerationS**（**SOPS**）是Mozilla开发的一个开源工具，允许用户在各种配置文件中安全地存储和管理他们的秘密信息，包括Ansible剧本。SOPS采用混合加密方法，即结合了对称加密和非对称加密，以确保最大安全性。'
- en: SOPS encrypts secrets using a master key, which can be either symmetric or asymmetric.
    **Symmetric encryption** uses a password or passphrase to encrypt and decrypt
    secrets, while **asymmetric encryption** uses a pair of keys, one public and one
    private, to encrypt and decrypt secrets. SOPS encrypts the master key using key
    wrapping, a technique that encrypts the key with another key. In SOPS, the key
    that is used for key wrapping is often an AWS **Key Management Service** (**KMS**)
    key, but it can also be a **Pretty Good Privacy** (**PGP**) key or a Google Cloud
    KMS key.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: SOPS使用主密钥加密秘密信息，主密钥可以是对称的或非对称的。**对称加密**使用密码或密码短语来加密和解密秘密，而**非对称加密**使用一对密钥，一个公钥和一个私钥，来加密和解密秘密。SOPS通过密钥包装加密主密钥，密钥包装是一种使用另一个密钥加密密钥的技术。在SOPS中，通常用于密钥包装的密钥是AWS
    **密钥管理服务**（**KMS**）密钥，但也可以是**Pretty Good Privacy**（**PGP**）密钥或Google Cloud KMS密钥。
- en: SOPS integrates seamlessly with Ansible and supports various file formats, including
    YAML, JSON, and INI. It also supports various cloud providers, including AWS,
    Google Cloud, and Azure, making it a versatile tool for managing secrets across
    different environments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: SOPS与Ansible无缝集成，支持多种文件格式，包括YAML、JSON和INI。它还支持多种云提供商，包括AWS、Google Cloud和Azure，使其成为跨不同环境管理秘密的多功能工具。
- en: Here’s an example of how to create a SOPS-encrypted YAML file and load its contents
    into an Ansible playbook using `community.sops.load_vars`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何创建一个SOPS加密的YAML文件并使用`community.sops.load_vars`将其内容加载到Ansible剧本中的示例：
- en: 'First, create a YAML file named `secrets.yaml` with the following content:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`secrets.yaml`的YAML文件，内容如下：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, use SOPS to encrypt the file using the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令通过SOPS加密文件：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will create an encrypted version of the `secrets.yaml` file named `secrets.sops.yaml`.
    It’s safe to remove the `secrets.yaml` plain text file now. The most common mistake
    is leaving these files behind and committing them to the Git repository.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`secrets.sops.yaml`的加密版本的`secrets.yaml`文件。现在可以安全地删除`secrets.yaml`的明文文件。最常见的错误是忘记删除这些文件并将它们提交到Git仓库中。
- en: 'Next, create a new Ansible playbook named `database.yml` with the following
    content:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的Ansible剧本，命名为`database.yml`，并包含以下内容：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, we’re using `community.sops.load_vars` to load the `postgresql_password`
    variable from the encrypted `secrets.sops.yaml` file. The `postgresql_password`
    variable is then passed to the `postgresql_user` task using the `{{ postgresql_password
    }}` Jinja2 syntax.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 `community.sops.load_vars` 从加密的 `secrets.sops.yaml` 文件中加载 `postgresql_password`
    变量。然后，使用 `{{ postgresql_password }}` Jinja2 语法将 `postgresql_password` 变量传递给 `postgresql_user`
    任务。
- en: When you run this playbook with Ansible, it will decrypt the `secrets.sops.yaml`
    file using SOPS and load the `postgresql_password` variable into the `postgresql_password`
    variable in the playbook. This ensures that the password is not stored in plain
    text in the playbook, providing an extra layer of security for your sensitive
    information.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 Ansible 运行这个 playbook 时，它会使用 SOPS 解密 `secrets.sops.yaml` 文件，并将 `postgresql_password`
    变量加载到 playbook 中的 `postgresql_password` 变量中。这确保密码不会以明文形式存储在 playbook 中，为您的敏感信息提供额外的安全层。
- en: 'More information about SOPS is available in its official GitHub repository:
    [https://github.com/mozilla/sops](https://github.com/mozilla/sops).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 SOPS 的更多信息，请参见其官方 GitHub 仓库：[https://github.com/mozilla/sops](https://github.com/mozilla/sops)。
- en: Other solutions
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他解决方案
- en: 'There are several alternatives to Ansible Vault and SOPS that you can use to
    manage your sensitive data securely, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种替代 Ansible Vault 和 SOPS 的解决方案，可以用于安全地管理敏感数据，具体如下：
- en: '**HashiCorp Vault**: An open source tool for securely storing and accessing
    secrets. It provides a service for secure and centralized storage of secrets,
    access control, and auditing.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HashiCorp Vault**：一个开源工具，用于安全地存储和访问秘密。它提供了一种服务，用于安全和集中存储秘密、访问控制和审计。'
- en: '**Blackbox**: A command-line utility that encrypts and decrypts files using
    **GNU Privacy Guard** (**GPG**). It works by creating a separate GPG key for each
    user or team that needs access to the encrypted data.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Blackbox**：一个命令行工具，使用 **GNU Privacy Guard**（**GPG**）加密和解密文件。它通过为每个需要访问加密数据的用户或团队创建一个单独的
    GPG 密钥来工作。'
- en: '**Keywhiz**: Another open source secrets management system that provides a
    simple way to store and distribute secrets securely. It includes a web interface
    for managing secrets and a command-line tool for accessing them.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Keywhiz**：另一个开源的秘密管理系统，提供一种简单的方法来安全地存储和分发秘密。它包括一个用于管理秘密的 Web 界面和一个用于访问秘密的命令行工具。'
- en: '**Azure Key Vault, AWS Secrets Manager, or Google Cloud Secret Manager**: Solutions
    you might want to consider keeping secrets in when dealing with a cloud environment.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure Key Vault, AWS Secrets Manager 或 Google Cloud Secret Manager**：在处理云环境时，您可能想要考虑使用的解决方案来存储秘密。'
- en: This is, of course, not a complete list of all available options.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这不是所有可用选项的完整列表。
- en: In this section, we introduced Ansible Vault and SOPS as means to handle secrets
    such as passwords. In the next section, we will be introducing a graphical frontend
    (GUI) to Ansible.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了 Ansible Vault 和 SOPS 作为处理秘密（如密码）的方法。在下一节中，我们将介绍 Ansible 的图形前端（GUI）。
- en: Ansible Tower and alternatives
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible Tower 和替代方案
- en: '**Ansible Tower** provides a centralized platform for managing Ansible automation
    workflows, making it easier for IT teams to collaborate, share knowledge, and
    maintain their infrastructure. Some of its key features include a web-based interface
    for managing Ansible playbooks, inventories, and job runs, **role-based access
    control** (**RBAC**) for managing user permissions, a built-in dashboard for monitoring
    job status and results, and an API for integrating with other tools and platforms.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible Tower** 提供了一个集中平台，用于管理 Ansible 自动化工作流，使 IT 团队更容易合作、共享知识和维护基础设施。其一些关键功能包括用于管理
    Ansible playbook、库存和作业运行的基于 Web 的界面、用于管理用户权限的 **基于角色的访问控制**（**RBAC**）、内置仪表板用于监控作业状态和结果，以及与其他工具和平台集成的
    API。'
- en: It was first released in 2013 by Ansible, Inc. (now part of Red Hat), and has
    since become one of the most popular tools for automating IT workflows.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 它最早由 Ansible, Inc.（现在是 Red Hat 的一部分）于 2013 年发布，此后成为自动化 IT 工作流的最受欢迎工具之一。
- en: Since its initial release, Ansible Tower has undergone numerous updates and
    enhancements, including support for more complex automation workflows, integration
    with cloud platforms such as AWS and Azure, and improved scalability and performance.
    Ansible Tower is a commercial product shipped by the Red Hat company. The closest
    alternative to Ansible Tower is **Ansible** **WorX** (**AWX**).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 自首次发布以来，Ansible Tower经历了多次更新和增强，包括支持更复杂的自动化工作流、与AWS和Azure等云平台的集成以及改进的可扩展性和性能。Ansible
    Tower是由Red Hat公司发布的商业产品。与Ansible Tower最相似的替代品是**Ansible** **WorX**（**AWX**）。
- en: '**Ansible AWX** is an open source alternative to Ansible Tower, offering many
    of the same features as Tower but with a greater degree of customization and flexibility.
    AWX was first released in 2017 and has since become a popular choice for organizations
    looking to implement Ansible automation at scale without the cost of a commercial
    license.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible AWX**是Ansible Tower的开源替代品，提供与Tower类似的许多功能，但具有更大的定制性和灵活性。AWX于2017年首次发布，并迅速成为寻求在不需要商业许可证的情况下大规模实施Ansible自动化的组织的热门选择。'
- en: One of the primary differences between Ansible Tower and Ansible AWX is their
    licensing model. While Ansible Tower requires a commercial license and is sold
    as part of Red Hat Ansible Automation Platform, Ansible AWX is open source and
    freely available for download from the Ansible website. This means that organizations
    can deploy AWX on their own infrastructure and customize it to their specific
    needs, rather than relying on a pre-built commercial solution.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Tower和Ansible AWX之间的主要区别之一是它们的许可模型。Ansible Tower需要商业许可证，并作为Red Hat Ansible
    Automation Platform的一部分进行销售，而Ansible AWX是开源的，可以从Ansible官网免费下载。这意味着组织可以在自己的基础设施上部署AWX，并根据特定需求进行定制，而无需依赖预构建的商业解决方案。
- en: Feature-wise, Ansible Tower and Ansible AWX are quite similar, with both platforms
    offering a web-based interface for managing Ansible playbooks, inventories, and
    job runs, RBAC for managing user permissions, and a built-in dashboard for monitoring
    job status and results. However, Ansible Tower does offer some additional features
    not found in Ansible AWX, such as native integration with Red Hat Ansible Automation
    Platform, advanced analytics and reporting, and certified modules and collections.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上来看，Ansible Tower和Ansible AWX非常相似，两者都提供基于Web的界面用于管理Ansible剧本、清单和任务运行，RBAC用于管理用户权限，并且具有内置的仪表板来监控任务状态和结果。然而，Ansible
    Tower提供了一些Ansible AWX没有的附加功能，比如与Red Hat Ansible Automation Platform的本地集成、先进的分析和报告功能，以及认证模块和集合。
- en: Another open source alternative to Ansible Tower is **Ansible Semaphore**. Similar
    to Tower, it is a web-based application designed to simplify the management of
    Ansible playbooks and projects. It is an open source, free, and easy-to-use alternative
    to Ansible Tower that allows users to easily automate their infrastructure tasks
    without the need for extensive coding knowledge. The first release of Ansible
    Semaphore was in 2016, and since then it has become a popular choice for those
    who want a simple yet powerful web-based interface for managing their Ansible
    automation workflows.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Ansible Tower的开源替代品是**Ansible Semaphore**。与Tower类似，它是一个基于Web的应用程序，旨在简化Ansible剧本和项目的管理。它是一个开源、免费的、易于使用的Ansible
    Tower替代品，允许用户轻松自动化其基础设施任务，而无需大量的编码知识。Ansible Semaphore的首次发布是在2016年，从那时起，它已成为那些希望获得简单而强大的Web界面的用户的热门选择，用于管理他们的Ansible自动化工作流。
- en: 'You can read more about these alternatives on their respective websites:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在各自的官方网站上了解更多关于这些替代品的信息：
- en: '**Ansible** **Tower**: [https://access.redhat.com/products/ansible-tower-red-hat](https://access.redhat.com/products/ansible-tower-red-hat%20)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible** **Tower**: [https://access.redhat.com/products/ansible-tower-red-hat](https://access.redhat.com/products/ansible-tower-red-hat%20)'
- en: '**Ansible** **AWX**: [https://github.com/ansible/awx](https://github.com/ansible/awx)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible** **AWX**: [https://github.com/ansible/awx](https://github.com/ansible/awx)'
- en: '**Ansible** **Semaphore**: [https://www.ansible-semaphore.com/](https://www.ansible-semaphore.com/)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible** **Semaphore**: [https://www.ansible-semaphore.com/](https://www.ansible-semaphore.com/)'
- en: Advanced topics
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题
- en: In this section, we will show you how to handle advanced Ansible features and
    techniques for debugging and automatically checking your playbooks for possible
    errors.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何处理高级Ansible功能和调试技术，以及如何自动检查剧本中可能存在的错误。
- en: Debugging
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: 'In order to debug issues with your Ansible playbook runs, it is often useful
    to increase the verbosity level to get more detailed output about what Ansible
    is doing. Ansible has four verbosity levels: `-v`, `-vv`, `-vvv`, and `-vvvv`.
    The more `v`s you add, the more verbose the output becomes.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试Ansible剧本运行中的问题，通常将详细程度提高是有用的，以便获得关于Ansible正在执行的操作的更详细输出。Ansible有四个详细程度：`-v`，`-vv`，`-vvv`和`-vvvv`。你添加的`v`越多，输出越详细。
- en: By default, Ansible runs with `-v`, which provides basic information about the
    tasks that are executed. However, if you are experiencing issues with your playbook,
    it may be helpful to increase the verbosity level to get more detailed output.
    For example, using -`vv` will provide additional information about the playbooks,
    roles, and tasks that are being executed, while using `-vvv` will also show the
    tasks that Ansible is skipping.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible以`-v`运行，提供有关执行任务的基本信息。然而，如果你在剧本中遇到问题，增加详细程度可能会有帮助，以便获得更详细的输出。例如，使用`-vv`将提供有关正在执行的剧本、角色和任务的额外信息，而使用`-vvv`还会显示Ansible跳过的任务。
- en: 'To increase the verbosity level of an Ansible playbook run, simply add one
    or more `-v` options to the `ansible-playbook` command. Here’s an example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要提高Ansible剧本运行的详细程度，只需在`ansible-playbook`命令中添加一个或多个`-v`选项。以下是一个示例：
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will run the playbook with verbose output at the `-vvlevel`. If you need
    even more verbose output, you can add extra `-v` options. You can see an example
    here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以`-vv`详细程度运行剧本。如果你需要更详细的输出，可以添加额外的`-v`选项。你可以在这里看到一个示例：
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In addition to using the `-v` options, you can also set the verbosity level
    in your `ansible.cfg` file by adding the following lines:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`-v`选项外，你还可以通过在`ansible.cfg`文件中添加以下行来设置详细程度：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will set the verbosity level to `-vv` for all `ansible-playbook` commands.
    You can change the value to `3` or `4` to increase the verbosity level even further.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为所有`ansible-playbook`命令设置`-vv`的详细程度。你可以将值更改为`3`或`4`，以进一步增加详细程度。
- en: If you need to add some custom communication (such as printing a variable) in
    a verbose mode, you can do it by using the `debug` task.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在详细模式中添加一些自定义通信（例如打印变量），你可以通过使用`debug`任务来实现。
- en: 'Here’s an example playbook that demonstrates how to print out a variable in
    `-vv` `debug` mode:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例剧本，演示了如何在`-vv` `debug`模式下打印一个变量：
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this playbook, we define a `my_variable` variable that holds the `"Hello,
    World!"` string. Then, we use the `debug` module to print out the value of this
    variable using the `msg` parameter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个剧本中，我们定义了一个`my_variable`变量，存储了字符串`"Hello, World!"`。然后，我们使用`debug`模块通过`msg`参数打印出这个变量的值。
- en: 'The `verbosity: 2` line is what enables `debug` mode. This tells Ansible to
    increase the verbosity level to `-vv`, which will show us the output of the `debug`
    module.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`verbosity: 2`这一行启用了`debug`模式。它告诉Ansible将详细程度设置为`-vv`，这样我们就可以看到`debug`模块的输出。'
- en: Linting Ansible playbooks
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ansible剧本代码检查
- en: '**Ansible code linting** is the process of analyzing and verifying the syntax
    and style of Ansible code to ensure that it conforms to best practices and standards.
    The purpose of linting is to catch potential errors or issues before the code
    is executed, which can save time and effort in the long run.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ansible代码检查**是分析和验证Ansible代码语法和风格的过程，确保其符合最佳实践和标准。检查的目的是在代码执行之前捕捉潜在错误或问题，从而节省时间和精力。'
- en: The most common tool used for Ansible code linting is `ansible-lint`. This is
    an open source command-line tool that analyzes Ansible playbooks and roles for
    potential problems and provides suggestions for improvement.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的Ansible代码检查工具是`ansible-lint`。这是一个开源命令行工具，用于分析Ansible剧本和角色，找出潜在问题并提供改进建议。
- en: 'To run `ansible-lint` against a sample playbook, you can execute the following
    command in the terminal:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行`ansible-lint`检查示例剧本，你可以在终端中执行以下命令：
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Assuming the sample playbook is saved as `sample-playbook.yml` in the current
    working directory, its content looks like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 假设示例剧本已保存为`sample-playbook.yml`，并位于当前工作目录中，其内容如下：
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that the output of `ansible-lint` may vary depending on the version of
    Ansible and `ansible-lint` being used, as well as the specific rules enabled.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`ansible-lint`的输出可能会根据所使用的Ansible版本和`ansible-lint`版本以及启用的特定规则而有所不同。
- en: 'As an example, the following is the output of running `ansible-lint` against
    the sample playbook provided:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，以下是运行`ansible-lint`检查提供的示例剧本后的输出：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The output indicates that the playbook contains trailing whitespace on several
    lines, which violates the `ELL0011` rule of `ansible-lint`. The warning messages
    regarding the empty path and version info loading are not critical issues and
    can be safely ignored.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 输出指示 Playbook 的多个行存在行尾空白，违反了 `ansible-lint` 的 `ELL0011` 规则。关于空路径和版本信息加载的警告消息并不是关键问题，可以安全地忽略。
- en: To fix the trailing whitespace issue, simply remove the extra spaces at the
    end of each affected line. Once the issues are fixed, you can rerun `ansible-lint`
    to ensure that there are no further problems with the playbook.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复行尾空白问题，只需删除每个受影响行末尾的额外空格。问题修复后，可以重新运行 `ansible-lint` 来确保 Playbook 没有进一步的问题。
- en: Speeding up SSH connections
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速 SSH 连接
- en: Ansible is an open source automation tool that is widely used to deploy and
    manage IT infrastructure. One of the key features of Ansible is its ability to
    use SSH for secure communication with remote servers. However, using SSH for every
    single task can be time-consuming and can impact performance, especially if you’re
    dealing with a lot of servers. To address this issue, Ansible supports **SSH multiplexing**,
    which allows multiple SSH connections to share a single TCP connection.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一款开源自动化工具，广泛用于部署和管理 IT 基础设施。Ansible 的一个关键特性是能够使用 SSH 与远程服务器进行安全通信。然而，为每个单独任务使用
    SSH 可能会耗费时间并影响性能，特别是在处理大量服务器时。为了解决这个问题，Ansible 支持**SSH 多路复用**，允许多个 SSH 连接共享单个
    TCP 连接。
- en: SSH multiplexing works by reusing the existing SSH connection rather than creating
    a new one for every task. When Ansible establishes an SSH connection to a remote
    server, it opens a TCP socket and creates a control socket for that connection.
    A **control socket** is a special socket that is used to manage the SSH connection.
    When another SSH connection is requested to the same host, Ansible checks whether
    a control socket already exists for that connection. If it does, Ansible reuses
    the existing control socket and creates a new channel within the same SSH connection
    for the new task.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 多路复用通过重用现有的 SSH 连接而不是为每个任务创建新连接来工作。当 Ansible 建立与远程服务器的 SSH 连接时，它打开一个 TCP
    套接字并为该连接创建一个控制套接字。控制套接字是用于管理 SSH 连接的特殊套接字。当请求到同一主机的另一个 SSH 连接时，Ansible 会检查是否已存在该连接的控制套接字。如果存在，则
    Ansible 会重用现有的控制套接字，并在同一 SSH 连接内为新任务创建一个新通道。
- en: The benefits of SSH multiplexing are that it saves time and resources by reducing
    the number of SSH connections that Ansible has to establish. Additionally, it
    can improve the performance of Ansible by reducing the overhead of creating and
    tearing down SSH connections for every task.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 多路复用的好处在于通过减少 Ansible 需要建立的 SSH 连接数量来节省时间和资源。此外，它可以通过减少为每个任务创建和拆除 SSH 连接的开销来提高
    Ansible 的性能。
- en: To enable SSH multiplexing in Ansible, you need to configure the `ControlMaster`
    and `ControlPath` options in the SSH client configuration file. The `ControlMaster`
    option enables the use of SSH multiplexing, while the `ControlPath` option specifies
    the location of the control socket. By default, Ansible uses the `~/.ansible/cp`
    directory to store control sockets. You can also configure the maximum number
    of SSH connections that can be multiplexed simultaneously by setting the `ControlPersist`
    option.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Ansible 中启用 SSH 多路复用，需要在 SSH 客户端配置文件中配置 `ControlMaster` 和 `ControlPath` 选项。`ControlMaster`
    选项启用 SSH 多路复用的使用，而 `ControlPath` 选项指定控制套接字的位置。默认情况下，Ansible 使用 `~/.ansible/cp`
    目录存储控制套接字。您还可以通过设置 `ControlPersist` 选项来配置可以同时复用的最大 SSH 连接数。
- en: 'To customize the SSH multiplexing configuration, you can put SSH options into
    your default Ansible configuration file placed in `~/.ansible.cfg` by adding the
    `[ssh_connection]` section, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义 SSH 多路复用配置，可以通过在 `~/.ansible.cfg` 中添加 `[ssh_connection]` 部分来将 SSH 选项放入默认的
    Ansible 配置文件中，如下所示：
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Make sure to also create a `~/.ssh/multiplexing` directory after adding this
    configuration.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加此配置后，确保还创建了 `~/.ssh/multiplexing` 目录。
- en: The `ControlMaster=auto` option creates a master session automatically, and
    if there is a master session already available, subsequent sessions are automatically
    multiplexed. Setting `ControlPersist=3600` will leave the master connection open
    in the background to accept new connections for `3600` seconds (1 hour).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`ControlMaster=auto` 选项会自动创建一个主会话，如果已经存在主会话，则后续会话将自动进行复用。设置 `ControlPersist=3600`
    将会在后台保持主连接打开，以接受 `3600` 秒（1 小时）内的新连接。'
- en: Dynamic inventory
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态清单
- en: In cloud environments such as AWS, servers can be created and terminated dynamically
    based on demand. Managing these servers manually can be a daunting task, which
    is why automation tools such as Ansible are essential. One of the critical features
    of Ansible that makes it well suited for cloud environments is dynamic inventory.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 等云环境中，服务器可以根据需求动态创建和终止。手动管理这些服务器可能是一个艰巨的任务，这就是为什么自动化工具，如 Ansible，非常重要。Ansible
    的一个关键特性是动态清单，它使其非常适合云环境。
- en: '**Dynamic inventory** is an Ansible feature that enables the automatic discovery
    of hosts (servers) and groups (tags) in a cloud environment. In AWS, Ansible can
    use the **Elastic Compute Cloud** (**EC2**) inventory plugin to query the AWS
    API to retrieve information about EC2 instances and groups.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态清单** 是 Ansible 的一个功能，它支持在云环境中自动发现主机（服务器）和组（标签）。在 AWS 中，Ansible 可以使用 **弹性计算云**（**EC2**）清单插件来查询
    AWS API，获取有关 EC2 实例和组的信息。'
- en: To use dynamic inventory in AWS, you need to configure the EC2 inventory plugin
    in your Ansible configuration.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 AWS 中使用动态清单，你需要在 Ansible 配置中配置 EC2 清单插件。
- en: The `amazon.aws.aws_ec2` inventory plugin is an official Ansible plugin that
    enables dynamic inventory for Amazon EC2 instances. To use this plugin, you need
    to follow the steps set out next.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`amazon.aws.aws_ec2` 库插件是一个官方的 Ansible 插件，它支持 Amazon EC2 实例的动态清单。要使用此插件，你需要按照接下来的步骤操作。'
- en: 'Depending on which version of Ansible you’re using and whether you’ve installed
    full Ansible (not only Ansible Core), you might need to use Ansible Galaxy to
    install an AWS collection plugin, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的 Ansible 版本，以及是否安装了完整的 Ansible（而不仅仅是 Ansible Core），你可能需要使用 Ansible Galaxy
    安装 AWS 集合插件，方法如下：
- en: '[PRE54]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Install the `boto3` and `botocore` libraries on your Ansible control node.
    You can install them using the `pip` package manager, like so:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Ansible 控制节点上安装 `boto3` 和 `botocore` 库。你可以使用 `pip` 包管理器安装它们，方法如下：
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Create an **Identity and Access Management** (**IAM**) user with the necessary
    permissions to access EC2 instances and groups. You can create an IAM user using
    the AWS Management Console or the AWS CLI. Make sure to save the IAM user’s access
    key and secret access key.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个具有必要权限以访问 EC2 实例和组的**身份和访问管理**（**IAM**）用户。你可以使用 AWS 管理控制台或 AWS CLI 创建 IAM
    用户。确保保存 IAM 用户的访问密钥和秘密访问密钥。
- en: 'Create an AWS credentials file (`~/.aws/credentials`) on your Ansible control
    node and add the IAM user’s access key and secret access key, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 Ansible 控制节点上创建一个 AWS 凭证文件（`~/.aws/credentials`），并添加 IAM 用户的访问密钥和秘密访问密钥，如下所示：
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create an Ansible inventory file (`inventory.yml`) in your project directory
    and configure it to use the `amazon.aws.aws_ec2` plugin, like so:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目目录中创建一个 Ansible 清单文件（`inventory.yml`），并配置它使用 `amazon.aws.aws_ec2` 插件，方法如下：
- en: '[PRE57]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here’s a brief explanation of the configuration options:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是配置选项的简要说明：
- en: '`plugin`: Specifies the inventory plugin to use'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plugin`：指定要使用的清单插件'
- en: '`regions`: Specifies the AWS regions to search for instances in'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regions`：指定要搜索实例的 AWS 区域'
- en: '`filters`: Allows you to filter EC2 instances by tags'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filters`：允许你按标签筛选 EC2 实例'
- en: 'Test the inventory by running the following command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令测试清单：
- en: '[PRE58]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This command should output a JSON object that lists all the EC2 instances in
    the specified regions, grouped by their Ansible tags.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应输出一个 JSON 对象，列出指定区域内所有 EC2 实例，并按 Ansible 标签分组。
- en: This way, you won’t have to update your inventory file on every Ansible playbook
    run to make sure you have an up-to-date servers list.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就不需要在每次运行 Ansible 剧本时都更新清单文件，以确保拥有最新的服务器列表。
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have presented you with the Ansible CaC tool. We have explained
    and demonstrated how moving configuration, from tribal knowledge and documents
    (as well as describing steps required to get your system to a desired state) to
    tools that can implement said configuration based on a well-defined syntax brings
    benefits to your organization, such as repeatability, ability to run many configurations
    in parallel, automated tests, and execution.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Ansible CaC 工具。我们已经解释并演示了如何将配置从部落知识和文档（以及描述使系统达到目标状态所需的步骤）转移到能够基于定义良好的语法实现该配置的工具，这为你的组织带来了诸如可重复性、能够并行运行多个配置、自动化测试和执行等好处。
- en: In the next chapter, we are going to introduce you to **Infrastructure as**
    **Code** (**IaC**).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将向你介绍**基础设施即代码**（**IaC**）。
- en: Further reading
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering Ansible, Fourth Edition* by James Freeman and Jesse Keating'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**掌握 Ansible（第四版）** 由 James Freeman 和 Jesse Keating 编写'
- en: '*Ansible Playbook Essentials* by Gourav Shah'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible Playbook 基础** 由 Gourav Shah 编写'
- en: '*Ansible for Real-Life Automation* by Gineesh Madapparambath'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible 实际应用自动化** 由 Gineesh Madapparambath 编写'
