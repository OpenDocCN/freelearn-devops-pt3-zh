- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Using Ansible for Configuration as Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Ansible 实现配置即代码
- en: 'In this chapter, we are going to cover **configuration management** (**CM**),
    **Configuration as Code** (**CaC**), and our tool of choice for it: Ansible.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍 **配置管理**（**CM**）、**配置即代码**（**CaC**）以及我们选择的工具：Ansible。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将覆盖以下主题：
- en: CM systems and CaC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CM 系统与 CaC
- en: Ansible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: Ansible Galaxy
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Galaxy
- en: Handling secrets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理机密信息
- en: Ansible Tower and alternatives
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Tower 和替代方案
- en: Advanced topics
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级话题
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a Linux system that you can access through `ssh`.
    If your main operating system is Windows, you will need another Linux system to
    play the role of the control node. As of now, the Ansible project does not support
    Windows as a control node.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，你需要一个可以通过 `ssh` 访问的 Linux 系统。如果你的主要操作系统是 Windows，你将需要另外一台 Linux 系统来充当控制节点。到目前为止，Ansible
    项目尚不支持 Windows 作为控制节点。
- en: CM systems and CaC
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CM 系统与 CaC
- en: 'Setting up and maintaining a system other than a hobbyist server (and even
    those, maybe, too) poses a serious challenge: how do you ensure that the system
    is installed and configured correctly and according to expectations? When you
    have to install a new server that is identical in configuration, how do you ensure
    that? In the past, a way of doing it was documenting the current configuration
    after the installation process was done. This would be a document describing the
    hardware, operating system, installed software, created users, and configuration
    applied. Any person who wanted to recreate it would have to follow steps to achieve
    the configuration described in the document.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 设置和维护一个非业余服务器的系统（甚至是业余服务器，可能也需要这样做）是一个严峻的挑战：如何确保系统按照预期正确安装和配置？当你需要安装一台与现有配置完全相同的服务器时，如何确保这一点？过去，一种做法是在安装过程完成后记录当前的配置。这将是一份描述硬件、操作系统、已安装软件、创建的用户以及应用的配置的文档。任何想要重建该配置的人，都需要按照文档中的步骤操作以达到描述的配置。
- en: 'The very next logical step is to write shell scripts that achieve the same
    goal with one additional improvement over the manual process: the scripts—properly
    written, tested, and maintained—do not require manual work, except, maybe, the
    initial system installation. But a properly set up environment would take care
    even of this.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的合乎逻辑的步骤是编写 shell 脚本，达到与手动过程相同的目标，但有一个额外的改进：这些脚本——只要编写得当、经过测试并且维护良好——不需要人工操作，除非，可能，在初始系统安装时需要人工干预。但一个正确设置的环境将自动处理这一点。
- en: The scripts, however, also have some defects or deficiencies. One of them is
    the fact that you need to account in your scripts for unfinished execution. This
    could happen for various reasons and would leave the system in a partially configured
    state. Executing the script again would perform all configuration actions from
    the start, sometimes leading to unexpected results. One way to account for incomplete
    runs would be to wrap every configuration action in a check, to see whether it
    had been performed previously. That would lead to the configuration script becoming
    larger and, eventually, evolving into a library of configuration functions and
    check functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些脚本也存在一些缺陷或不足。其一是你需要在脚本中考虑未完成执行的情况。这可能由于各种原因发生，导致系统处于部分配置状态。再次执行脚本时，所有配置操作将从头开始，有时会导致意外结果。应对未完成的执行的一种方式是将每个配置操作都包装在检查中，查看该操作是否之前已执行过。这将导致配置脚本变得更大，最终演变成一个配置函数和检查函数的库。
- en: The task of developing and maintaining such a tool can be daunting and will
    probably require a whole team. Still, the results are probably worth the effort.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 开发和维护这样一个工具的任务可能非常艰巨，并且可能需要一个完整的团队。但最终的结果可能值得付出这些努力。
- en: Writing and maintaining documentation that describes the desired state of the
    system may, at first glance, be simpler and more desirable than the previously
    mentioned method of automating. The script cannot recover from an incomplete execution.
    The best it can do is inform the sysop about failure, log the error, and stop
    gracefully. Manually performed configuration allows the sysop to work around any
    obstacles and inadequacies in the procedure and edit the document to reflect the
    current state on the go.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和维护描述系统期望状态的文档，乍一看可能比前面提到的自动化方法更简单且更具吸引力。脚本无法从未完成的执行中恢复过来。它所能做的最好的事情就是通知系统管理员失败，记录错误并优雅地停止。手动配置允许系统管理员绕过程序中的任何障碍和不足，并实时编辑文档以反映当前状态。
- en: 'Still, a properly developed and tested script turns out to be better. Let us
    enumerate the reasons:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，一个经过良好开发和测试的脚本最终还是更好。让我们列举出一些原因：
- en: If the script executes without an error, it is guaranteed to perform actions
    without a mistake. Time and again, it has been proven that a human is the element
    most prone to errors in IT.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果脚本执行没有出错，保证会执行正确的操作。一次又一次地证明，在IT领域，最容易出错的元素是人类。
- en: If the script exits prematurely, the action of updating it to account for the
    new requirements is a perfect equivalent to updating the documentation.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果脚本提前退出，更新它以满足新需求的行为与更新文档的过程完全相同。
- en: People are known to be pretty bad at maintaining documentation. The Holy Grail
    of programming is self-documenting code, rendering comments unnecessary, thus
    eliminating the risk of comments being out of sync with the code.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 众所周知，人类在维护文档方面很差。编程的圣杯是自文档化代码，使注释变得不再必要，从而消除了注释与代码不同步的风险。
- en: The script can be executed on multiple systems at once, scaling very well, if
    not infinitely. Humans can perform the configuration of one system at a time with
    minimal risk of making a mistake.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本可以在多个系统上同时执行，扩展性非常好，几乎是无限的。而人类只能一次配置一个系统，且犯错的风险较小。
- en: Configuration kept in the form of a script or program benefits from typical
    programming techniques, such as automated testing, dry runs, and static analysis.
    More so, keeping the code in a repository allows us to easily track a history
    of changes and integrate it with ticket-tracking tools.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以脚本或程序形式保存的配置得益于典型的编程技巧，例如自动化测试、演练和静态分析。更重要的是，将代码保存在版本库中让我们能够轻松追踪更改历史，并与问题跟踪工具集成。
- en: Code is unequivocal, which cannot be said about written language. A document
    may leave space for interpretation; a script won’t.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是明确的，而书面语言却不能如此。文档可能留有解释的空间，但脚本不会。
- en: Automating configuration lets you move to other, more interesting tasks, leaving
    the computers to do what they do best—performing repetitive, boring tasks well.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化配置让你可以转向其他更有趣的任务，留给计算机去做它们最擅长的事情——执行重复性且枯燥的任务。
- en: The world of programming and system administration has a tendency to turn small
    projects into larger ones with a vibrant community of developers and users. It
    was only a matter of time before CM systems were born. They take the burden of
    developing and managing portions of the code responsible for configuration actions
    off your shoulders. The CM system developers write the code, test it, and deem
    it stable. What you are left with is an action of writing configuration files
    or directives that tell the system what to do. Most of these systems will be able
    to cover the most popular platforms, allowing you to describe configuration once
    and run it with the same expected results on commercial Unix systems, such as
    AIX or Solaris, as on Linux or Windows.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 编程和系统管理的世界倾向于将小项目转变为更大的项目，并且有一个充满活力的开发者和用户社区。CM（配置管理）系统的诞生只是时间问题。它们将开发和管理负责配置操作的代码部分的负担从你肩上移走。CM
    系统的开发者编写代码、测试并认为它稳定。剩下的工作就是编写配置文件或指令，告诉系统应该做什么。这些系统大多数能够覆盖最流行的平台，使你能够只描述一次配置，并在商业Unix系统（如AIX或Solaris）与Linux或Windows上获得相同的预期结果。
- en: 'Configuration files for these systems are easily stored in a version control
    system such as Git. They are easily understandable by a human, which allows for
    simple review by your colleagues. They can be checked for syntax errors by automated
    tools and allow you to concentrate on the most important part of the whole endeavor:
    the configuration.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些系统的配置文件可以轻松地存储在 Git 等版本控制系统中。它们易于理解，这使得同事可以轻松进行审查。它们可以通过自动化工具检查语法错误，并使你能够专注于整个工作中的最重要部分：配置。
- en: This approach of keeping your configuration as a set of scripts or other data
    instead of a procedure to be followed manually is known as CaC.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将配置保留为一组脚本或其他数据，而不是手动遵循的过程的方法，被称为 CaC。
- en: 'The CaC approach is becoming more important as the number of systems to be
    managed grows and the demand for fast and efficient configuration scales up. In
    the world of DevOps, it is usual practice to set up tens and hundreds of systems
    a day: systems for developers, testers, and production systems to manage new levels
    of demand for the service. Managing it manually would be an impossible task. Well-implemented
    CaC allows to run this task with a click of a button. Thus, developers and testers
    can deploy their own systems without bothering sysops. Your task will be to develop,
    maintain, and test the configuration data.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 随着需要管理的系统数量不断增加，以及对快速高效配置的需求不断扩大，CaC（配置即代码）方法变得越来越重要。在 DevOps 的世界里，通常需要每天设置数十个或数百个系统：包括开发人员、测试人员和生产系统，以应对服务需求的新水平。手动管理将是一项不可能完成的任务。良好实现的
    CaC 允许通过点击按钮来完成这项任务。因此，开发人员和测试人员可以自行部署系统，而不需要打扰系统运维人员。你的任务将是开发、维护和测试配置数据。
- en: If there is one thing sure in the world of programming, it is that there’s never
    going to be only one solution. The same goes for CM tools.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编程世界里有一件事是可以确定的，那就是永远不会只有一个解决方案。CM 工具也不例外。
- en: Alternatives for Ansible include **SaltStack**, **Chef**, **Puppet**, and **CFEngine**,
    which is the oldest one; its initial release date was 1993, so it’s 30 years old
    as of the time of writing this book. In general, those solutions differentiate
    between each other with a method of enforcing configuration (pull or push) and
    an approach of describing the system’s state (imperative or declarative).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的替代方案包括**SaltStack**、**Chef**、**Puppet** 和 **CFEngine**，后者是最古老的，它的首次发布是在
    1993 年，因此截至本书撰写时已存在 30 年。通常，这些解决方案通过强制配置的方法（拉取或推送）和描述系统状态的方法（命令式或声明式）有所不同。
- en: '**Imperative** means that we describe the state of the server with commands
    for the tool to perform. Imperative programming focuses on describing how a given
    tool operates step by step.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令式**（Imperative）方法意味着我们通过命令描述服务器的状态，让工具执行。命令式编程侧重于一步步描述给定工具的操作方式。'
- en: '**Declarative**, on the other hand, means we focus on what the CaC tool should
    accomplish without specifying all the details of how it should achieve the result.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**声明式**（Declarative）方法意味着我们关注 CaC 工具应该完成什么，而不是指定它应该如何实现结果的所有细节。'
- en: SaltStack
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SaltStack
- en: '**SaltStack** is an open source CM tool that allows for the management of complex
    IT infrastructure at scale. It enables the automation of routine tasks such as
    package installation, user management, and software configuration, and is designed
    to work across a wide range of operating systems and platforms. SaltStack was
    founded by Thomas Hatch in 2011\. The first release of SaltStack, version 0.8.0,
    was also made in 2011.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**SaltStack** 是一个开源的 CM 工具，允许在大规模的 IT 基础设施中进行管理。它使得日常任务的自动化成为可能，如软件包安装、用户管理和软件配置，并设计用于跨多种操作系统和平台工作。SaltStack
    由 Thomas Hatch 于 2011 年创立。SaltStack 的第一个版本 0.8.0 也发布于 2011 年。'
- en: 'SaltStack works by utilizing a master-slave architecture, where a central salt-master
    communicates with salt-minions running on remote machines to execute commands
    and manage configurations. It operates in a pull method of enforcing configuration:
    minions pull the latest manifest from the master server.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SaltStack 通过利用主从架构工作，其中一个中央的 salt-master 与运行在远程机器上的 salt-minion 进行通信，执行命令并管理配置。它采用拉取方式来强制执行配置：minion
    从主服务器拉取最新的清单。
- en: 'Once the minion is installed and configured, we can use SaltStack to manage
    the server’s configuration. Here’s an example `nginx.sls` file that would install
    and configure `nginx`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 minion 被安装并配置好，我们可以使用 SaltStack 来管理服务器的配置。以下是一个安装并配置 `nginx` 的示例 `nginx.sls`
    文件：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the first line specifies that the `nginx` package should be
    installed on the target server. The next two lines define the configuration file
    for a hypothetical website, `example.com`, which is copied to `/etc/nginx/sites-available/yourdomain.tld.conf`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，第一行指定应该在目标服务器上安装`nginx`包。接下来的两行定义了一个假设网站`example.com`的配置文件，该配置文件将被复制到`/etc/nginx/sites-available/yourdomain.tld.conf`。
- en: 'To apply this state file to a server, we would use the `state.apply` command
    in the SaltStack command-line interface, specifying the name of the state file
    as the argument:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此状态文件应用到服务器，我们需要在SaltStack命令行界面中使用`state.apply`命令，并指定状态文件的名称作为参数：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This would send the instructions in the `nginx.sls` file to the salt-minion
    running on the web server machine, which would execute the necessary steps to
    ensure that `nginx` is installed and configured correctly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`nginx.sls`文件中的指令发送到运行在Web服务器上的salt-minion，salt-minion将执行必要的步骤以确保`nginx`正确安装和配置。
- en: Chef
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chef
- en: '**Chef** is a powerful open source CM tool that allows users to automate the
    deployment and management of infrastructure, applications, and services. It was
    first released in 2009 by Opscode, which was later acquired by Chef Software Inc.
    Since then, Chef has been widely adopted by IT professionals and DevOps teams
    to streamline their workflows and reduce the time and effort required for managing
    complex systems.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chef**是一个强大的开源配置管理（CM）工具，允许用户自动化基础设施、应用程序和服务的部署与管理。它最初由Opscode于2009年发布，后被Chef
    Software Inc.收购。从那时起，Chef被IT专业人员和DevOps团队广泛采用，以简化工作流程并减少管理复杂系统所需的时间和精力。'
- en: Chef works by defining the desired state of an infrastructure in a set of code
    files, called cookbooks. A **cookbook** is a collection of recipes that describe
    how to install, configure, and manage a specific piece of software or service.
    Each recipe contains a series of resources, which are pre-built modules that can
    perform specific tasks, such as installing a package or configuring a file. Chef
    uses a declarative approach to CM, meaning that users define what they want the
    system to look like, and Chef takes care of the details of how to get there.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Chef通过在一组代码文件中定义基础设施的期望状态来工作，这些代码文件称为食谱（cookbooks）。**食谱（cookbook）**是描述如何安装、配置和管理特定软件或服务的一组指令。每个食谱包含一系列资源，资源是预构建的模块，可以执行特定任务，例如安装软件包或配置文件。Chef使用声明式的配置管理（CM）方法，意味着用户定义系统的期望状态，而Chef负责处理如何实现该状态的细节。
- en: To install `nginx` using Chef, you would first need to create a cookbook that
    includes a recipe for installing `nginx`. This recipe would use the `package`
    resource to install the `nginx` package and the `service` resource to ensure that
    the `nginx` service is running. You could also use other resources, such as `file`,
    `directory`, or `template`, to configure `nginx`’s settings, depending on your
    requirements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Chef安装`nginx`，你首先需要创建一个包含安装`nginx`食谱的cookbook。这个食谱将使用`package`资源来安装`nginx`包，并使用`service`资源确保`nginx`服务正在运行。根据需求，你还可以使用其他资源，例如`file`、`directory`或`template`，来配置`nginx`的设置。
- en: Once you had created the cookbook, you would upload it to a Chef server, which
    acts as a central repository for cookbooks and their associated metadata. You
    would then use Chef’s command-line tool, called `knife`, to configure the target
    system to use the cookbook. This involves associating the system with a Chef environment,
    which defines the set of cookbooks and their versions that should be applied to
    the system. You would then use the `chef-client` command to run the Chef client
    on the target system, which will download and apply the necessary cookbooks and
    recipes to bring the system into the desired state.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了食谱（cookbook），你需要将其上传到Chef服务器，Chef服务器作为食谱及其相关元数据的中央仓库。然后，你可以使用Chef的命令行工具`knife`来配置目标系统使用该食谱。这涉及将系统与Chef环境关联，Chef环境定义了应应用于系统的食谱及其版本。接下来，你可以使用`chef-client`命令在目标系统上运行Chef客户端，该客户端将下载并应用必要的食谱和配置，以使系统达到所需状态。
- en: 'Here’s an example of installing and configuring `nginx`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是安装和配置`nginx`的示例：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This recipe uses three resources, as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱使用了三个资源，如下所示：
- en: '`package`: This installs the `nginx` package using the default package manager
    on the system.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`：使用系统默认的软件包管理器安装`nginx`包。'
- en: '`service`: This starts and enables the `nginx` service so that it will automatically
    start on boot and stay running.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service`：这将启动并启用`nginx`服务，使其在启动时自动启动并保持运行。'
- en: '`template`: This creates a configuration file for `nginx` by generating it
    from a template file. The template file (`nginx-site.erb`) is written in `templates`
    directory of the cookbook. The `notifies` attribute tells Chef to restart the
    `nginx` service if the configuration file changes.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template`：通过从模板文件生成配置文件，为`nginx`创建一个配置文件。模板文件（`nginx-site.erb`）位于食谱的`templates`目录中。`notifies`属性告诉Chef在配置文件更改时重新启动`nginx`服务。'
- en: Once you have created this recipe in a cookbook, you can use the `knife` command
    to upload the cookbook to a Chef server. You can then use the `chef-client` command
    to apply the recipe to a target system, which will install and configure `nginx`
    according to the recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在食谱中创建了这个食谱，你可以使用`knife`命令将食谱上传到Chef服务器。然后，你可以使用`chef-client`命令将食谱应用于目标系统，按照食谱安装和配置`nginx`。
- en: Puppet
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Puppet
- en: '`2.0`.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`2.0`。'
- en: Puppet works by defining the desired state of infrastructure resources in a
    declarative language, known as the Puppet language. Administrators can define
    the configuration of servers, applications, and other infrastructure components
    in Puppet code, which can then be applied consistently across multiple systems.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet通过在声明性语言中定义基础设施资源的期望状态来工作，这种语言被称为Puppet语言。管理员可以在Puppet代码中定义服务器、应用程序和其他基础设施组件的配置，然后将其一致地应用于多个系统。
- en: Puppet consists of a master server and multiple agent nodes. The master server
    acts as a central repository for Puppet code and configuration data, while the
    agent nodes execute the Puppet code and apply the desired state to the system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet由一个主服务器和多个代理节点组成。主服务器充当Puppet代码和配置数据的中央存储库，而代理节点则执行Puppet代码并将期望的状态应用到系统中。
- en: Puppet has a robust ecosystem of modules, which are pre-written Puppet code
    that can be used to configure common infrastructure resources. These modules are
    available in **Puppet Forge**, a public repository of Puppet code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet有一个强大的模块生态系统，这些模块是预先编写的Puppet代码，可以用于配置常见的基础设施资源。这些模块可在**Puppet Forge**中找到，Puppet
    Forge是一个公开的Puppet代码存储库。
- en: 'Here’s an example Puppet manifest that installs `nginx` and creates a configuration
    file similar to what we did with SaltStack and Chef:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例Puppet清单，它安装`nginx`并创建一个类似我们在SaltStack和Chef中所做的配置文件：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once you’ve created a manifest and put it on the Puppet server, it will be picked
    up by the Puppet agent installed on your server and executed. Communication, the
    same as in SaltStack, is being secured by the TLS protocol using the same mechanism
    as the HTTPS servers on the internet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了清单并将其放置在Puppet服务器上，它将被安装在服务器上的Puppet代理拾取并执行。通信方式与SaltStack相同，通过TLS协议确保安全，使用与互联网上的HTTPS服务器相同的机制。
- en: The agent nodes run a Puppet agent process, which connects to the master server
    over TCP port `8140`. The agent sends a **certificate signing request** (**CSR**)
    to the server, which the administrator must approve. Once the CSR is approved,
    the agent is granted access to the server’s Puppet configuration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 代理节点运行Puppet代理进程，通过TCP端口`8140`连接到主服务器。代理向服务器发送**证书签名请求**（**CSR**），管理员必须批准此请求。一旦CSR被批准，代理将获得对服务器Puppet配置的访问权限。
- en: When the agent runs, it sends a request to the master server for its configuration.
    The server responds with a catalog of resources that should be applied to the
    node. The catalog is generated based on the Puppet code and manifests stored on
    the server, as well as any external data sources or hierarchies that are configured.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当代理运行时，它向主服务器发送请求以获取其配置。服务器响应并提供一个资源目录，说明应应用于节点的内容。该目录是根据存储在服务器上的Puppet代码和清单，以及配置的任何外部数据源或层次结构生成的。
- en: The agent then applies the catalog to the node, which involves making any necessary
    changes to the node’s configuration to ensure it matches the desired state defined
    in the catalog. This may involve installing packages, updating configuration files,
    or starting or stopping services.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，代理将目录应用到节点，这包括对节点配置进行必要的更改，以确保其与目录中定义的期望状态匹配。这可能包括安装软件包、更新配置文件或启动或停止服务。
- en: The agent sends reports back to the server after applying the catalog, which
    can be used for monitoring and auditing purposes. The server can also use this
    information to detect changes to the node’s configuration that were not made through
    Puppet and to take corrective action if necessary.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 代理在应用完目录后将报告发送回服务器，这些报告可用于监控和审计。服务器还可以使用这些信息检测通过Puppet未做的节点配置更改，并在必要时采取纠正措施。
- en: CFEngine
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CFEngine
- en: '**CFEngine** is an open source CM system that allows users to automate the
    deployment, configuration, and maintenance of IT systems. It was founded by Mark
    Burgess in 1993 and has since become a popular tool for managing large-scale IT
    infrastructures. CFEngine is known for its powerful and flexible language for
    describing system configurations and enforcing policies, making it a great choice
    for complex IT environments.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**CFEngine** 是一个开源的配置管理系统，允许用户自动化部署、配置和维护 IT 系统。它由 Mark Burgess 于 1993 年创立，之后成为管理大规模
    IT 基础设施的流行工具。CFEngine 以其强大而灵活的语言来描述系统配置和执行策略而闻名，是处理复杂 IT 环境的理想选择。'
- en: CFEngine’s first release was in 1994, making it one of the oldest CM tools in
    existence. Since then, CFEngine has undergone numerous updates and improvements
    to keep up with changing IT environments and emerging technologies. The latest
    release of CFEngine, version 3.18, includes features such as improved encryption,
    enhanced monitoring capabilities, and better support for cloud infrastructure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: CFEngine 的第一次发布是在 1994 年，使其成为现存最古老的配置管理工具之一。此后，CFEngine 经历了许多更新和改进，以适应不断变化的
    IT 环境和新兴技术。CFEngine 最新版本 3.18 包括改进的加密功能、增强的监控能力和对云基础设施的更好支持。
- en: CFEngine has gained popularity over the years due to its robust functionality,
    ease of use, and strong community support. It’s still being used today by many
    organizations and is actively developed, so it is a safe option to manage the
    configuration of your servers using this tool.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，CFEngine 因其强大的功能、易用性和强大的社区支持而广受欢迎。今天，许多组织仍在使用它，并且它仍在积极开发，因此它是一个安全的选择，可以用来管理你的服务器配置。
- en: 'An example CFengine configuration will be presented here. It is, out of necessity,
    only a snipped and not a complete configuration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里将展示一个 CFEngine 配置示例。由于需要，它只是一个片段，而非完整配置：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this section, we have explained what CaC is and why it is an important tool
    in the toolbelt of system administrators. We have briefly described the most popular
    tools available to you. In the next section, we will introduce our tool of choice—Ansible.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经解释了什么是 CaC，以及为什么它是系统管理员工具箱中的一个重要工具。我们简要描述了你可以使用的最流行的工具。在下一节中，我们将介绍我们首选的工具——Ansible。
- en: Ansible
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible
- en: In this section, we are going to introduce you to **Ansible**, our tool of choice
    when it comes to CaC.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向你介绍 **Ansible**，这是我们在 CaC 方面的首选工具。
- en: Ansible is a tool written for managing the configuration of systems and devices.
    It is written in Python and its source code is freely available to anyone for
    downloading and modification (within the limits of its license, which is Apache
    License `2.0`). The name “Ansible” comes from Ursula K. Le Guin’s book *Rocannon’s
    World* and denotes a device that allows instantaneous communication no matter
    the distance.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 是一款用于管理系统和设备配置的工具。它是用 Python 编写的，源代码可以自由下载和修改（在 Apache License `2.0`
    许可范围内）。名字“Ansible”来源于 Ursula K. Le Guin 的小说 *Rocannon’s World*，指的是一种无论距离多远都能实现瞬时通信的设备。
- en: 'Some interesting characteristics of Ansible are set out here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了 Ansible 一些有趣的特点：
- en: '**Modularity**: Ansible is not a monolithic tool. Rather, it’s a core program
    with each task it knows how to perform written as a separate module—a library,
    if you will. Since this was the design from the start, it produced a clean API
    that anyone can use to write their own modules.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：Ansible 不是一个单体工具。它是一个核心程序，每个它知道如何执行的任务都被写作一个独立的模块——如果你愿意的话，可以把它看作是一个库。由于从一开始就是这种设计，它产生了一个干净的
    API，任何人都可以使用这个 API 来编写自己的模块。'
- en: '**Idempotence**: No matter how many times you perform a configuration, the
    result is always the same. This is one of the most important and fundamental characteristics
    of Ansible. You don’t have to know which actions have been performed. When you
    extend the configuration and run the tool again, it is its job to find out the
    state of the system and only apply new actions.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幂等性**：无论执行多少次配置，结果始终保持不变。这是 Ansible 最重要和最基本的特点之一。你不必知道哪些操作已经执行过。当你扩展配置并再次运行工具时，它的工作是找出系统的状态并仅应用新的操作。'
- en: '**Agentlessness**: Ansible doesn’t install its agent on the configured system.
    That is not to say it doesn’t need anything at all. To execute the Ansible scripts,
    the target system will need some means of connecting to it (most often, the SSH
    server running) and the Python language installed. There are several advantages
    born from this paradigm, including the following:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无代理**：Ansible 不会在配置系统上安装代理。这并不意味着它完全不需要任何东西。为了执行 Ansible 脚本，目标系统需要能够连接到它的一些手段（通常是运行的
    SSH 服务器）以及安装 Python 语言。这个范式带来了几个优势，包括以下几点：'
- en: 'Ansible is not concerned with communication protocol. It uses SSH, but it doesn’t
    implement it, leaving the details to the operating system, SSH server, and client.
    An advantage is that you can freely swap one SSH solution with another for whatever
    reasons, and your Ansible playbooks should work as intended. Also, Ansible doesn’t
    concern itself with securing the SSH configuration. This leaves developers to
    concentrate on what the system is really about: configuring your systems.'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 与通信协议无关。它使用 SSH，但并不实现该协议，而是将细节留给操作系统、SSH 服务器和客户端。一个优势是，你可以根据需要自由地将一个
    SSH 解决方案替换为另一个，而你的 Ansible 剧本应该照常工作。此外，Ansible 也不关心 SSH 配置的安全性，这让开发人员可以集中精力处理系统的真正问题：配置你的系统。
- en: The Ansible project does not need to develop and maintain separate programs
    for managed nodes. This not only frees developers from unneeded burdens but also
    limits the possibility of security exploits being discovered and used against
    target machines.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 项目无需为被管理的节点开发和维护独立的程序。这不仅减轻了开发人员的不必要负担，还限制了安全漏洞被发现并用于攻击目标机器的可能性。
- en: In an agent-utilizing solution, if, for any reason, the agent program stops
    working, there is no way to deliver new configurations to the system. SSH servers
    are usually very widely used, and the probability of failure is negligible.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用代理的解决方案中，如果由于任何原因，代理程序停止工作，就无法将新的配置传递到系统中。SSH 服务器通常使用广泛，故障的概率几乎可以忽略不计。
- en: Using SSH as the communication protocol lowers the risk of a firewall blocking
    the communication port for the CM system.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SSH 作为通信协议可以降低防火墙阻止 CM 系统通信端口的风险。
- en: '`nginx` is installed, the proper configuration entry would look like this:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nginx` 已安装，正确的配置项应该如下所示：'
- en: '[PRE5]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The main way of working with Ansible is through writing configuration files
    in a special syntax called YAML. **YAML** is a syntax created specifically for
    configuration files and is loosely based on Python formatting. Indentations play
    a significant role in YAML files. YAML’s home page presents a full cheat sheet
    card ([https://yaml.org/refcard.xhtml](https://yaml.org/refcard.xhtml)) for the
    syntax. However, the most important parts are presented here, as we will be working
    mostly with those files in this chapter:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Ansible 交互的主要方式是通过编写使用一种叫做 YAML 的特殊语法的配置文件。**YAML** 是一种专为配置文件设计的语法，基于 Python
    的格式化方式。缩进在 YAML 文件中起着重要作用。YAML 的主页提供了完整的备忘单卡片（[https://yaml.org/refcard.xhtml](https://yaml.org/refcard.xhtml)），其中涵盖了该语法。然而，这里将呈现最重要的部分，因为我们在本章中将主要与这些文件打交道：
- en: They are clear text files. This means they can be viewed and edited using the
    simplest editors such as Notepad, Vim, Emacs, or whatever is your favorite tool
    for working with text files.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是明文文件。这意味着可以使用最简单的编辑器（如 Notepad、Vim、Emacs，或任何你喜欢的文本编辑工具）查看和编辑它们。
- en: Indentations are used to denote scope. Tabulators are not permitted for indentations
    and it is customary to use spaces for this purpose.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进用于表示范围。不允许使用制表符进行缩进，通常使用空格来进行缩进。
- en: A new document opens with three hyphens (`-`). One file can have more than one
    document.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新文档以三个短横线（`-`）开头。一个文件可以包含多个文档。
- en: Comments, as in Python, start with a hash (`#`) and continue until the end of
    the line. The comment must be surrounded by whitespace characters; otherwise,
    it will be treated as a literal hash (`#`) within a text.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释与 Python 中相同，以井号（`#`）开始，直到行尾。注释必须被空白字符包围，否则它将被视为文本中的字面井号（`#`）。
- en: Text (strings) can be unquoted, single-quoted (`'`), or double-quoted (`"`).
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本（字符串）可以不加引号、单引号（`'`）或双引号（`"`）括起来。
- en: When a list is specified, each member is denoted by a hyphen (`-`) character.
    Each item will be on a separate line. If single-line representation is required,
    the list items can be enclosed in square brackets (`[]`) with entries separated
    by commas (`,`).
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定一个列表时，每个成员由一个连字符（`-`）表示。每个项目将占一行。如果需要单行表示，可以将列表项用方括号（`[]`）括起来，并用逗号（`,`）分隔。
- en: Associative arrays are represented by a key-value pair with each key separated
    from the value by a colon and space. If they have to be presented in one line,
    the array is enclosed in curly brackets (`{}`) and pairs are separated by commas
    (`,`).
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关联数组通过键值对表示，每个键和值之间用冒号和空格分隔。如果必须在一行中呈现，数组将用大括号（`{}`）括起来，键值对之间用逗号（`,`）分隔。
- en: If the preceding rules are not very transparent now, don’t panic. We are going
    to write proper Ansible configuration files, and things will become clear as we
    go.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的规则现在还不太清楚，别担心。我们将编写正确的Ansible配置文件，随着过程的推进，所有问题都会明朗。
- en: 'Ansible divides machines into two groups: the **control node** is the computer
    that stores configuration directives and will connect to the target machines and
    configure them. There can be more than one control node. The target machines are
    called **inventories**. Ansible runs actions against computers in the inventory
    listed. Inventories are often written in an **initialization** (**INI**) format,
    which is simple and easy to follow, as explained here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible将机器分为两组：**控制节点**是存储配置指令的计算机，它将连接到目标机器并进行配置。控制节点可以有多个。目标机器称为**库存**。Ansible将在列出的库存中的计算机上运行操作。库存通常以**初始化**（**INI**）格式编写，这种格式简单易懂，如下所示：
- en: Comments start with a semicolon (`;`)
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释以分号（`;`）开头。
- en: Sections are named and the names are enclosed in square brackets (`[]`)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各个部分有名称，并且名称用方括号（`[]`）括起来。
- en: Configuration directives are stored in pairs, each pair on its own line, with
    the key and value separated by an equals sign (`=`)
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置指令以键值对的形式存储，每一对独占一行，键和值之间用等号（`=`）分隔。
- en: We will see an example of an inventory file shortly. There is, however, the
    possibility of having so-called dynamic inventories, which are generated automatically
    by means of a script or a system with each run of Ansible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到一个库存文件的例子。然而，也有可能存在所谓的动态库存，它是通过脚本或每次运行Ansible时由系统自动生成的。
- en: The main configuration file that we will be interacting with is called a playbook.
    A **playbook** is an entry point for Ansible. This is where the tool will start
    the execution. Playbooks can include other files (and this is often done).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要交互的主要配置文件称为剧本。**剧本**是Ansible的入口点，工具将从这里开始执行。剧本可以包括其他文件（这通常会这么做）。
- en: 'Target hosts can be broken down into groups based on custom criteria: operating
    system, role within organization, physical location—whatever is required. The
    groups are called **roles**.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 目标主机可以根据自定义标准进行分组：操作系统、组织中的角色、物理位置——任何需要的内容。这样的分组称为**角色**。
- en: A single action that is to be performed is called a **task**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一项要执行的单一操作称为**任务**。
- en: Basics of using Ansible
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Ansible的基础知识
- en: The first thing to do is to install Ansible. This is pretty straightforward
    on all major Linux distributions and can be equally so on macOS. We encourage
    you to figure out the solution for your chosen operating system.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是安装Ansible。这在所有主要的Linux发行版上都非常简单，macOS也同样如此。我们建议您根据所选择的操作系统找到相应的解决方案。
- en: 'For Debian-based distributions, the following command should suffice:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于Debian的发行版，以下命令应该足够：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For Fedora Linux distributions, you’d run the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Fedora Linux发行版，您可以运行以下命令：
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To install the latest version of Ansible, however, we recommend using the Python
    virtual environment and its `pip` tool, like so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，要安装最新版本的Ansible，我们建议使用Python虚拟环境及其`pip`工具，如下所示：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we have activated the virtual environment using the
    `venv python3` module. It will create a special `venv` directory that contains
    all important files and libraries that allow us to set up a Python virtual environment.
    Next, we have the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`venv python3`模块激活了虚拟环境。它将创建一个特殊的`venv`目录，其中包含所有重要的文件和库，允许我们设置Python虚拟环境。接下来，我们有以下内容：
- en: '[PRE12]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the preceding code line, we have read a special file that sets the environment
    by configuring the shell. Next, we have this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码行中，我们读取了一个特殊的文件，该文件通过配置shell来设置环境。接下来，我们有以下内容：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code, we have upgraded `pip`, a Python package installer.
    In the next step, we are going to actually install Ansible, also using `pip`.
    The output will be shortened for brevity:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see in the preceding code, `pip` informs us that Ansible and its
    dependencies were installed successfully.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Either of those ways of installing Ansible will download and install all the
    packages required to run Ansible on your computer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest command you can run is called ad hoc `ping`. It’s so basic that
    it is one of the most prevalent first uses of Ansible in tutorials and books.
    We are not going to deviate from it. The following command tries to connect to
    a specified host and then prints the result of the trial:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding command, we have told Ansible to run against all hosts in inventory,
    use the `ping` module (`-m ping`), and use an inventory file named `inventory`
    (`-i inventory`). If you don’t specify the inventory file, Ansible will try to
    use `/etc/ansible/hosts`, which is generally a bad idea.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: We will delve into the inventory file in a moment, a few paragraphs ahead.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: A `ping` module (which we can also understand as a `ping` command). It is not,
    however, the same as the OS `ping` command, which sends a specially crafted network
    packet to determine whether a host is up. The Ansible `ping` command will also
    try to log in, to determine whether the credentials are correct.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: By default, Ansible uses the SSH protocol with a private-public key pair. In
    a normal operation, you don’t want to use password-based authentication, and Ansible
    will choose a key-based one.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is very good at providing self-explanatory information as a result of
    the execution. The preceding output tells us that Ansible was able to connect
    to all nodes in the inventory (there’s only one), `python3` is installed there,
    and nothing was changed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'The inventory file is a simple but powerful tool to list, group, and provide
    variables for managed nodes. Our example inventory file is pasted as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is two lines. The first one declares a group of nodes called
    `www`. The second declares a node called `hostone`. Since this is not a name resolvable
    by DNS, we have declared its IP address using the `ansible_host` variable. Then,
    we point to the proper `ssh` key file and declare which username should be used
    while logging in (`admin`). There are more things we can define in this file.
    Very detailed information about writing your inventory file can be found in the
    Ansible project documentation ([https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml](https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml)).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: We are unable to cover all aspects of Ansible and dig deeper into most of the
    features that we are going to use here. Packt Publishing, however, has a very
    good selection of books on Ansible that you may wish to choose if you want to
    deepen your knowledge—for example, *Mastering Ansible, Fourth Edition,* by James
    Freeman and Jesse Keating.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Tasks lie at the heart of the Ansible configuration. They are exactly that:
    tasks to be run against managed nodes. Tasks are contained in plays. They can
    be placed there directly (put into a playbook) or indirectly (included via a role).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: There’s a special type of task called **handles**. This is a task that will
    be executed only when notified by another task.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible’s documentation defines **roles** as “*A limited distribution of reusable
    Ansible content (tasks, handlers, variables, plugins, templates and files) for
    use inside of a play.*” For our purpose, we can think of them as a mechanism to
    group parts of the play. A role can be a type of host we are going to run the
    play against: web server, database server, Kubernetes node, and so on. By breaking
    down playbooks into roles, we can manage separate required tasks more easily and
    efficiently. Not to mention the files containing those become more readable, since
    we limit the number of tasks within and group them by their function.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Plays and playbooks
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Plays** are the context in which tasks are performed. While plays are somewhat
    of an ephemeral concept, **playbooks** are their physical representations: YAML
    files in which plays are defined.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example of a playbook. The following playbook will install
    `nginx` and `php` packages on a managed node:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The first line (three dashes) marks the beginning of a new YAML document. The
    next line names the whole playbook. Playbook names should be short but descriptive.
    They are going to end up in logs and debugging information.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Next, we inform Ansible that this play should be run against nodes in the inventory
    placed in the `www` group. We also tell Ansible to use `sudo` when executing the
    commands. This is required as all distributions that we cover in our guide require
    root privileges to install and remove packages.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Then, we start the `tasks` section. Each task is given a name, the name of the
    module (command) we are going to use, and the command is given options and arguments.
    As you can see, the indentation declares the scope. If you are familiar with the
    Python programming language, this should be intuitive for you.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we run this playbook, let’s use a very useful tool, `ansible-lint`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'I have cut part of the output for brevity, but you can see that the tool printed
    information about violations of YAML syntax and Ansible best practices. Failures
    are types of errors that will stop the execution of the playbook. Warnings are
    just that: the playbook will be executed, but there are some errors that go against
    best practices. Let’s correct our playbook, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can now run the playbook using the `ansible-playbook` command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding output, we have instructed the `ansible-playbook` command
    to use an inventory file called `inventory` and run a playbook named `install.yaml`.
    The output should be self-explanatory: we are informed of the name of the play
    we run. Then, we see a list of managed nodes that Ansible will try to execute
    action against. Then, we see tasks and a list of nodes that the tasks succeeded
    or failed at. The `nginx` task was a success on `hostone`. However, installing
    `php` failed. Ansible gives us the exact reason for it: there is no `php8` package
    available for our managed node. Sometimes, a resolution is pretty obvious, but
    sometimes it requires a bit of digging around. After checking with our distribution,
    we find out that the actual `php` package available there is `php7.4`. After quickly
    correcting the offending line, we run the playbook again, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice the change in the output. First, Ansible tells us that `nginx` on `hostone`
    is okay. This means that Ansible was able to determine that the package was already
    installed, and it took no action. Then, it told us that the `php7.4` installation
    was successful (`changed: [hostone]`) on the `hostone` server.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The preceding playbook is short, but we hope it demonstrates the usefulness
    of the tool. Playbooks are executed in a linear manner, from top to bottom.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one problem with our playbook. While it only installs two packages,
    you may be worried about maintainability and readability if you need to install
    tens or hundreds of packages. Having a separate task for each of them is troublesome.
    There’s a solution. You can create a list of items that a given task will be executed
    for—something akin to a loop. Let’s edit the `tasks` part of the playbook, as
    follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have added two packages to demonstrate a more complete run. Notice the lack
    of a separate task for `php7.4`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running this play, it is always a good idea to check it with `ansible-lint`.
    Here’s how we can do that:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, after `ansible-lint` gives us the green light, let’s play this playbook:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Assume we want to install a page configuration in `nginx`. Ansible is able
    to copy files. We can set it to copy `nginx` virtual server configuration, but
    we only want to restart `nginx` once: at the service setup.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do it via `notify` and `handlers`. I’ll paste the whole playbook ahead:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice the whole new section related to copying files. We also create a `nginx`.
    We have shortened it for brevity’s sake and only to demonstrate a principle.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of this play yields the following output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As soon as you start using Ansible in a real production environment, it becomes
    obvious that even with the *looping* technique we demonstrated previously, the
    playbook grows pretty fast and becomes unwieldy. Thankfully, there’s a way to
    break the playbook into smaller files.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways to do it is to segregate tasks into roles. As mentioned earlier,
    a role is a bit of an abstract concept, so the easiest way to think about it is
    to consider it a group. You group tasks depending on the criteria that are relevant
    to you. While the criteria are totally up to you, it is pretty common for roles
    to refer to the type of function a given managed node performs. One managed node
    can perform more than one function, but it still is probably wise to separate
    the functions into their own roles. Thus, the HTTP server would be one role, the
    database server would be another, and the file server would be yet another.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Roles in Ansible have a predetermined directory structure. There are eight standard
    directories defined, although you only need to create one.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is copied from the Ansible documentation ([https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_reuse_roles.xhtml](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_reuse_roles.xhtml)):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `roles` directory exists on the same level as your playbook. The most common
    subdirectories you will probably see are `tasks`, `templates`, `files`, `vars`,
    and `handlers`. Within each subdirectory, Ansible will look for a `main.yml`,
    `main.yaml`, or `main` file (all of them have to be valid YAML files). Their contents
    will be automatically available to the playbook. So, how would this work in practice?
    Within the same directory that our `install.yaml` playbook exists, we will create
    a `roles` directory. Within this directory, we will create another one: `www`.
    Inside that one, we will create directories: `tasks`, `files`, and `handlers`.
    A similar structure will be created with `development` as a role:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `development` role has only tasks subdirectory because we don’t require
    any additional bells and whistles. Why the development role, though? When you
    look back at our current playbook, you’ll notice that we mix up installing things
    for the `www` server and development packages—namely, compilers. It is bad practice,
    even if they will end up on the same physical server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we are going to edit our inventory file so that we have two separate
    roles:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Both groups contain only one node, which is a bad thing to do overall. We do
    it only for the purpose of this guide. Don’t install compilers and development
    software on your HTTP server, especially on the production one.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to move some stuff around within the playbook. The `install.yml`
    file will become much shorter, as we can see here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We actually have two plays in this playbook. One of them is for `www` hosts,
    and the other is for `development` hosts. After we give the play a name and list
    host groups that we wish it to run against, we use keyword roles and list actual
    roles to be used. As you can see, Ansible is going to locate the proper roles
    automatically, as long as you adhere to the directory structure explained previously.
    There are ways to include roles directly by specifying their full path, but we’re
    not going to cover them here.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for the `www` role, we’ll execute the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You should notice several changes from the get-go:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: There is no `tasks` keyword in this document. This is implicit by the fact that
    this is the `main.yaml` file within the `tasks` subdirectory.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indentation has been moved left.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are no handlers here.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have removed the installation of the `gcc` and `g++` packages.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s now see the handlers:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The overall changes are the same, as noted here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: We have removed the `handlers` keyword
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have moved the indentation to the left
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s see `roles/development/tasks/main.yaml`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is very simple. We may have increased the complexity of the directory structure,
    but we have gained the simplicity of tasks and plays. The gains are well worth
    the trade-off, especially when your playbooks grow in size and complexity.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many advantages to using a CaC tool, as outlined here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Configuration can be linted—that is, checked for syntax errors by automation
    tools
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be applied infinitely with the same outcomes
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be run on many systems in parallel
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be kept in a version control system, such as Git, where the history of
    changes and comments for them are stored and can be viewed at any time
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be run by automation tools, removing the need for a human factor besides
    writing playbooks
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this subsection, we have shown how to write simple Ansible playbooks. We
    have explained what Ansible is and what the building blocks of the configuration
    scripts are. We have introduced playbooks, roles, and the inventory. There are
    many more things Ansible can do for you. You can manage devices, filesystems,
    users, groups, permissions, networking, and so on. The list of all modules Ansible
    is shipped with out of the box is impressive. You can always check the list at
    [https://docs.ansible.com/ansible/latest/module_plugin_guide/index.xhtml](https://docs.ansible.com/ansible/latest/module_plugin_guide/index.xhtml).
    Remember to check the list for your version of Ansible.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'So, now that we’ve covered installing, configuring, and using Ansible to manage
    your servers (installing software, creating configuration files, and managing
    services), we are ready to look into Ansible Galaxy: community-developed modules
    that increase Ansible’s usefulness.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Galaxy
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a powerful automation tool that enables users to configure, deploy,
    and manage complex IT infrastructures with ease. However, creating and maintaining
    Ansible playbooks can be time-consuming, especially when working with large-scale
    environments. Fortunately, Ansible Galaxy exists to help streamline this process
    by providing a centralized repository of pre-built roles and playbooks that can
    be easily integrated into an existing Ansible project.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '**Ansible Galaxy** is a community-driven platform that hosts an extensive collection
    of Ansible roles and playbooks. These roles and playbooks are submitted by users
    from around the world and are reviewed and curated by Ansible’s maintainers. Ansible
    Galaxy provides a simple, efficient way to find and use pre-built automation content
    that can save users time and effort while ensuring quality and consistency.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible Galaxy, users can quickly find, download, and use pre-built roles
    and playbooks for popular applications, services, and infrastructure components.
    These pre-built components can help speed up deployment times, ensure best practices
    are followed, and reduce the likelihood of errors or inconsistencies. Ansible
    Galaxy can also help users learn from others’ experiences and gain insights into
    the best practices of their peers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use one of the Galaxy roles to install the `nginx` web server on our
    `webserver` role. In order to do that, we will need to install the role from Ansible
    Galaxy. First, ensure that Ansible is installed on your system by running the
    following command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This command will download and install the `nginx` role from Ansible Galaxy.
    By default, all roles installed are placed in the `~/.ansible/roles` directory.
    It’s possible to change that by creating a global Ansible configuration file in
    your home directory: `~/.ansible.cfg`.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a configuration file changing the `roles_path` directory looks
    like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A good practice is to pin role version numbers and put this version in a YAML
    file saved in the same Git repository where you will keep your Ansible playbooks.
    To achieve this, let’s create an `ansible_requirements.yml` file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To install the role from Ansible Galaxy using that file, you would run the
    following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once the role is installed, it can be used in an Ansible playbook by adding
    the following line to the playbook:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s an example playbook that uses the `nginx` role from Ansible Galaxy to
    install and configure `nginx` on a remote server:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In this playbook, we specify the `webservers` group as the target hosts and
    use the `nginxinc.nginx` role to install and configure `nginx`. We also define
    a variable called `nginx_sites` that specifies the configuration for a `nginx`
    server block that will be created using a Jinja2 template located in the playbook’s
    `templates` directory.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: By using Ansible Galaxy and pre-built roles such as `nginxinc.nginx`, users
    can automate complex tasks quickly and reliably, ensuring consistency and reducing
    the risk of errors.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Handling secrets
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Protecting secrets such as passwords, tokens, and certificates is crucial in
    any IT infrastructure. These secrets are the keys to accessing sensitive information
    and services, and their exposure can lead to severe security breaches. Therefore,
    it is crucial to keep them safe and secure. Ansible provides several methods for
    managing secrets, such as Ansible Vault, which allows users to encrypt and decrypt
    sensitive data using a password or key file. This feature helps to protect secrets
    and ensures that only authorized users have access to them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Saving secrets in a Git repository or any other public place is a significant
    security risk. Such repositories are often accessible to multiple users, some
    of whom may not have the necessary permissions to access sensitive data. Additionally,
    version control systems such as Git retain the history of changes made to files,
    making it possible for secrets to be exposed inadvertently. This could happen
    if a user inadvertently commits secrets to a repository or if a hacker gains access
    to a repository’s commit history. Therefore, it is vital to discourage saving
    secrets in public places to reduce the risk of unauthorized access. Instead, Ansible
    provides secure ways to manage secrets, ensuring that they are encrypted and only
    accessible to authorized users. By doing so, users can be confident that their
    secrets are safe and secure.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Vault
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Ansible Vault** is a feature provided by Ansible that enables users to encrypt
    and decrypt sensitive data, such as passwords, keys, and certificates. The vault
    creates an encrypted file that can be decrypted only by authorized users, ensuring
    that sensitive data remains secure. The vault can be used to store secrets in
    files, variables, or other sources that are used by Ansible.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Vault uses a variety of encryption methods to secure the secrets stored
    within it. By default, Ansible Vault uses AES 256 encryption, a widely accepted
    and secure encryption algorithm. Additionally, Ansible Vault supports other encryption
    algorithms, such as AES 192 and AES 128, providing flexibility in the encryption
    strength used to secure secrets. When encrypting data with Ansible Vault, users
    can choose to encrypt it with a password or with a key file. This ensures that
    only authorized users who possess the password or key file can decrypt the secrets
    stored within the vault.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new vault using Ansible Vault, you can use the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will create a new encrypted vault file called `secrets.yml`. You will
    be prompted to enter a password to encrypt the file. Once you’ve entered the password,
    the vault file will be created and opened in your default editor. Here’s an example
    `secrets.yml` file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: To edit this secret file, you’ll need to use the `ansible-vault edit secrets.yml`
    command and type the encryption password afterward.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'To write an Ansible task that reads the `pgsql_password` secret from the vault,
    you can use the `ansible.builtin.include_vars` module with the `vault_password_file`
    parameter. Here is an example task:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this task, we’re using the `include_vars` module to read the variables from
    the `secrets.yml` vault file. The `vault_password_file` parameter specifies the
    location of the file containing the password to decrypt the vault. We then assign
    the value of `secret_pgsql_password` to the `pgsql_password` variable, which can
    be used elsewhere in the playbook.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `secret_pgsql_password` variable should be defined in the vault.
    The `secret_` prefix is to indicate that the password was retrieved from the vault.
    Ansible does not differentiate between regular variables or secret variables.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this playbook with an increased Ansible debug level, you will
    notice that the PostgreSQL password is exposed in the debug output. To prevent
    that, every task dealing with sensitive information can be executed with the `no_log:
    True` option enabled.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: SOPS
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Secrets OPerationS** (**SOPS**) is an open source tool developed by Mozilla
    that allows users to securely store and manage their secrets within various configuration
    files, including Ansible playbooks. SOPS uses a hybrid encryption approach, which
    means that it combines symmetric and asymmetric encryption to ensure maximum security.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: SOPS encrypts secrets using a master key, which can be either symmetric or asymmetric.
    **Symmetric encryption** uses a password or passphrase to encrypt and decrypt
    secrets, while **asymmetric encryption** uses a pair of keys, one public and one
    private, to encrypt and decrypt secrets. SOPS encrypts the master key using key
    wrapping, a technique that encrypts the key with another key. In SOPS, the key
    that is used for key wrapping is often an AWS **Key Management Service** (**KMS**)
    key, but it can also be a **Pretty Good Privacy** (**PGP**) key or a Google Cloud
    KMS key.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: SOPS integrates seamlessly with Ansible and supports various file formats, including
    YAML, JSON, and INI. It also supports various cloud providers, including AWS,
    Google Cloud, and Azure, making it a versatile tool for managing secrets across
    different environments.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of how to create a SOPS-encrypted YAML file and load its contents
    into an Ansible playbook using `community.sops.load_vars`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a YAML file named `secrets.yaml` with the following content:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, use SOPS to encrypt the file using the following command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will create an encrypted version of the `secrets.yaml` file named `secrets.sops.yaml`.
    It’s safe to remove the `secrets.yaml` plain text file now. The most common mistake
    is leaving these files behind and committing them to the Git repository.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new Ansible playbook named `database.yml` with the following
    content:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, we’re using `community.sops.load_vars` to load the `postgresql_password`
    variable from the encrypted `secrets.sops.yaml` file. The `postgresql_password`
    variable is then passed to the `postgresql_user` task using the `{{ postgresql_password
    }}` Jinja2 syntax.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: When you run this playbook with Ansible, it will decrypt the `secrets.sops.yaml`
    file using SOPS and load the `postgresql_password` variable into the `postgresql_password`
    variable in the playbook. This ensures that the password is not stored in plain
    text in the playbook, providing an extra layer of security for your sensitive
    information.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about SOPS is available in its official GitHub repository:
    [https://github.com/mozilla/sops](https://github.com/mozilla/sops).'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Other solutions
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several alternatives to Ansible Vault and SOPS that you can use to
    manage your sensitive data securely, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '**HashiCorp Vault**: An open source tool for securely storing and accessing
    secrets. It provides a service for secure and centralized storage of secrets,
    access control, and auditing.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blackbox**: A command-line utility that encrypts and decrypts files using
    **GNU Privacy Guard** (**GPG**). It works by creating a separate GPG key for each
    user or team that needs access to the encrypted data.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keywhiz**: Another open source secrets management system that provides a
    simple way to store and distribute secrets securely. It includes a web interface
    for managing secrets and a command-line tool for accessing them.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Key Vault, AWS Secrets Manager, or Google Cloud Secret Manager**: Solutions
    you might want to consider keeping secrets in when dealing with a cloud environment.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is, of course, not a complete list of all available options.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced Ansible Vault and SOPS as means to handle secrets
    such as passwords. In the next section, we will be introducing a graphical frontend
    (GUI) to Ansible.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Tower and alternatives
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ansible Tower** provides a centralized platform for managing Ansible automation
    workflows, making it easier for IT teams to collaborate, share knowledge, and
    maintain their infrastructure. Some of its key features include a web-based interface
    for managing Ansible playbooks, inventories, and job runs, **role-based access
    control** (**RBAC**) for managing user permissions, a built-in dashboard for monitoring
    job status and results, and an API for integrating with other tools and platforms.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: It was first released in 2013 by Ansible, Inc. (now part of Red Hat), and has
    since become one of the most popular tools for automating IT workflows.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Since its initial release, Ansible Tower has undergone numerous updates and
    enhancements, including support for more complex automation workflows, integration
    with cloud platforms such as AWS and Azure, and improved scalability and performance.
    Ansible Tower is a commercial product shipped by the Red Hat company. The closest
    alternative to Ansible Tower is **Ansible** **WorX** (**AWX**).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '**Ansible AWX** is an open source alternative to Ansible Tower, offering many
    of the same features as Tower but with a greater degree of customization and flexibility.
    AWX was first released in 2017 and has since become a popular choice for organizations
    looking to implement Ansible automation at scale without the cost of a commercial
    license.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary differences between Ansible Tower and Ansible AWX is their
    licensing model. While Ansible Tower requires a commercial license and is sold
    as part of Red Hat Ansible Automation Platform, Ansible AWX is open source and
    freely available for download from the Ansible website. This means that organizations
    can deploy AWX on their own infrastructure and customize it to their specific
    needs, rather than relying on a pre-built commercial solution.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Feature-wise, Ansible Tower and Ansible AWX are quite similar, with both platforms
    offering a web-based interface for managing Ansible playbooks, inventories, and
    job runs, RBAC for managing user permissions, and a built-in dashboard for monitoring
    job status and results. However, Ansible Tower does offer some additional features
    not found in Ansible AWX, such as native integration with Red Hat Ansible Automation
    Platform, advanced analytics and reporting, and certified modules and collections.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Another open source alternative to Ansible Tower is **Ansible Semaphore**. Similar
    to Tower, it is a web-based application designed to simplify the management of
    Ansible playbooks and projects. It is an open source, free, and easy-to-use alternative
    to Ansible Tower that allows users to easily automate their infrastructure tasks
    without the need for extensive coding knowledge. The first release of Ansible
    Semaphore was in 2016, and since then it has become a popular choice for those
    who want a simple yet powerful web-based interface for managing their Ansible
    automation workflows.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about these alternatives on their respective websites:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '**Ansible** **Tower**: [https://access.redhat.com/products/ansible-tower-red-hat](https://access.redhat.com/products/ansible-tower-red-hat%20)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible** **AWX**: [https://github.com/ansible/awx](https://github.com/ansible/awx)'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible** **Semaphore**: [https://www.ansible-semaphore.com/](https://www.ansible-semaphore.com/)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced topics
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will show you how to handle advanced Ansible features and
    techniques for debugging and automatically checking your playbooks for possible
    errors.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to debug issues with your Ansible playbook runs, it is often useful
    to increase the verbosity level to get more detailed output about what Ansible
    is doing. Ansible has four verbosity levels: `-v`, `-vv`, `-vvv`, and `-vvvv`.
    The more `v`s you add, the more verbose the output becomes.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: By default, Ansible runs with `-v`, which provides basic information about the
    tasks that are executed. However, if you are experiencing issues with your playbook,
    it may be helpful to increase the verbosity level to get more detailed output.
    For example, using -`vv` will provide additional information about the playbooks,
    roles, and tasks that are being executed, while using `-vvv` will also show the
    tasks that Ansible is skipping.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'To increase the verbosity level of an Ansible playbook run, simply add one
    or more `-v` options to the `ansible-playbook` command. Here’s an example:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will run the playbook with verbose output at the `-vvlevel`. If you need
    even more verbose output, you can add extra `-v` options. You can see an example
    here:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In addition to using the `-v` options, you can also set the verbosity level
    in your `ansible.cfg` file by adding the following lines:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will set the verbosity level to `-vv` for all `ansible-playbook` commands.
    You can change the value to `3` or `4` to increase the verbosity level even further.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: If you need to add some custom communication (such as printing a variable) in
    a verbose mode, you can do it by using the `debug` task.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example playbook that demonstrates how to print out a variable in
    `-vv` `debug` mode:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this playbook, we define a `my_variable` variable that holds the `"Hello,
    World!"` string. Then, we use the `debug` module to print out the value of this
    variable using the `msg` parameter.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The `verbosity: 2` line is what enables `debug` mode. This tells Ansible to
    increase the verbosity level to `-vv`, which will show us the output of the `debug`
    module.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Linting Ansible playbooks
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Ansible code linting** is the process of analyzing and verifying the syntax
    and style of Ansible code to ensure that it conforms to best practices and standards.
    The purpose of linting is to catch potential errors or issues before the code
    is executed, which can save time and effort in the long run.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: The most common tool used for Ansible code linting is `ansible-lint`. This is
    an open source command-line tool that analyzes Ansible playbooks and roles for
    potential problems and provides suggestions for improvement.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'To run `ansible-lint` against a sample playbook, you can execute the following
    command in the terminal:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Assuming the sample playbook is saved as `sample-playbook.yml` in the current
    working directory, its content looks like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that the output of `ansible-lint` may vary depending on the version of
    Ansible and `ansible-lint` being used, as well as the specific rules enabled.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following is the output of running `ansible-lint` against
    the sample playbook provided:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The output indicates that the playbook contains trailing whitespace on several
    lines, which violates the `ELL0011` rule of `ansible-lint`. The warning messages
    regarding the empty path and version info loading are not critical issues and
    can be safely ignored.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: To fix the trailing whitespace issue, simply remove the extra spaces at the
    end of each affected line. Once the issues are fixed, you can rerun `ansible-lint`
    to ensure that there are no further problems with the playbook.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up SSH connections
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible is an open source automation tool that is widely used to deploy and
    manage IT infrastructure. One of the key features of Ansible is its ability to
    use SSH for secure communication with remote servers. However, using SSH for every
    single task can be time-consuming and can impact performance, especially if you’re
    dealing with a lot of servers. To address this issue, Ansible supports **SSH multiplexing**,
    which allows multiple SSH connections to share a single TCP connection.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: SSH multiplexing works by reusing the existing SSH connection rather than creating
    a new one for every task. When Ansible establishes an SSH connection to a remote
    server, it opens a TCP socket and creates a control socket for that connection.
    A **control socket** is a special socket that is used to manage the SSH connection.
    When another SSH connection is requested to the same host, Ansible checks whether
    a control socket already exists for that connection. If it does, Ansible reuses
    the existing control socket and creates a new channel within the same SSH connection
    for the new task.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of SSH multiplexing are that it saves time and resources by reducing
    the number of SSH connections that Ansible has to establish. Additionally, it
    can improve the performance of Ansible by reducing the overhead of creating and
    tearing down SSH connections for every task.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: To enable SSH multiplexing in Ansible, you need to configure the `ControlMaster`
    and `ControlPath` options in the SSH client configuration file. The `ControlMaster`
    option enables the use of SSH multiplexing, while the `ControlPath` option specifies
    the location of the control socket. By default, Ansible uses the `~/.ansible/cp`
    directory to store control sockets. You can also configure the maximum number
    of SSH connections that can be multiplexed simultaneously by setting the `ControlPersist`
    option.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'To customize the SSH multiplexing configuration, you can put SSH options into
    your default Ansible configuration file placed in `~/.ansible.cfg` by adding the
    `[ssh_connection]` section, as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Make sure to also create a `~/.ssh/multiplexing` directory after adding this
    configuration.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The `ControlMaster=auto` option creates a master session automatically, and
    if there is a master session already available, subsequent sessions are automatically
    multiplexed. Setting `ControlPersist=3600` will leave the master connection open
    in the background to accept new connections for `3600` seconds (1 hour).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic inventory
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In cloud environments such as AWS, servers can be created and terminated dynamically
    based on demand. Managing these servers manually can be a daunting task, which
    is why automation tools such as Ansible are essential. One of the critical features
    of Ansible that makes it well suited for cloud environments is dynamic inventory.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic inventory** is an Ansible feature that enables the automatic discovery
    of hosts (servers) and groups (tags) in a cloud environment. In AWS, Ansible can
    use the **Elastic Compute Cloud** (**EC2**) inventory plugin to query the AWS
    API to retrieve information about EC2 instances and groups.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: To use dynamic inventory in AWS, you need to configure the EC2 inventory plugin
    in your Ansible configuration.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: The `amazon.aws.aws_ec2` inventory plugin is an official Ansible plugin that
    enables dynamic inventory for Amazon EC2 instances. To use this plugin, you need
    to follow the steps set out next.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on which version of Ansible you’re using and whether you’ve installed
    full Ansible (not only Ansible Core), you might need to use Ansible Galaxy to
    install an AWS collection plugin, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Install the `boto3` and `botocore` libraries on your Ansible control node.
    You can install them using the `pip` package manager, like so:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Create an **Identity and Access Management** (**IAM**) user with the necessary
    permissions to access EC2 instances and groups. You can create an IAM user using
    the AWS Management Console or the AWS CLI. Make sure to save the IAM user’s access
    key and secret access key.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an AWS credentials file (`~/.aws/credentials`) on your Ansible control
    node and add the IAM user’s access key and secret access key, as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Create an Ansible inventory file (`inventory.yml`) in your project directory
    and configure it to use the `amazon.aws.aws_ec2` plugin, like so:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Here’s a brief explanation of the configuration options:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '`plugin`: Specifies the inventory plugin to use'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regions`: Specifies the AWS regions to search for instances in'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filters`: Allows you to filter EC2 instances by tags'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test the inventory by running the following command:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This command should output a JSON object that lists all the EC2 instances in
    the specified regions, grouped by their Ansible tags.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: This way, you won’t have to update your inventory file on every Ansible playbook
    run to make sure you have an up-to-date servers list.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have presented you with the Ansible CaC tool. We have explained
    and demonstrated how moving configuration, from tribal knowledge and documents
    (as well as describing steps required to get your system to a desired state) to
    tools that can implement said configuration based on a well-defined syntax brings
    benefits to your organization, such as repeatability, ability to run many configurations
    in parallel, automated tests, and execution.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to introduce you to **Infrastructure as**
    **Code** (**IaC**).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering Ansible, Fourth Edition* by James Freeman and Jesse Keating'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ansible Playbook Essentials* by Gourav Shah'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ansible for Real-Life Automation* by Gineesh Madapparambath'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
