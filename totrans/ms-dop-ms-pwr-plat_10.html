<html><head></head><body>
		<div id="_idContainer151">
			<h1 id="_idParaDest-158" class="chapter-number"><a id="_idTextAnchor172"/><st c="0">10</st></h1>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor173"/><st c="3">Enabling Pro-Dev Extensibility in Power Platform</st></h1>
			<p><st c="52">This chapter focuses on the capabilities provided by Power Platform to professional developers to extend the experience of business solutions built on top of Power Platform. </st><st c="227">We will take a look at how Power Platform ensures the smooth integration of these extensibility options with ALM/DevOps processes in order to support the software development life cycle of </st><span class="No-Break"><st c="416">these components.</st></span></p>
			<p><st c="433">We will start the chapter by looking into connectors and continue our work on custom connectors. </st><st c="531">In the previous chapter, we showed how pro developers can build web APIs and deploy them to Power Platform directly from Visual Studio; here, we will explore the concept of using the PAC CLI to ensure we enable ALM for custom connectors. </st><st c="769">We will also look into the other aspects of the custom connectors, such as environmental variables and connection references, and explain their role when moving solutions across different </st><span class="No-Break"><st c="957">target environments.</st></span></p>
			<p><st c="977">After that, we will discuss canvas components in Power Apps and the key benefits of using them. </st><st c="1074">From there, we will delve into the Power Platform code components, more specifically the Power Apps component framework. </st><st c="1195">For both canvas components and code components, we will explain the process of including them in the </st><span class="No-Break"><st c="1296">ALM process.</st></span></p>
			<p><st c="1308">We will close this chapter with coverage of Power Pages, how pro developers can extend Power Pages with custom code, and how the ALM process can </st><span class="No-Break"><st c="1454">be implemented.</st></span></p>
			<p><st c="1469">We will cover the following </st><span class="No-Break"><st c="1498">main topics:</st></span></p>
			<ul>
				<li><st c="1510">Enabling the power of integration – </st><span class="No-Break"><st c="1547">connectors</st></span></li>
				<li><st c="1557">Overview of canvas components and the </st><span class="No-Break"><st c="1596">component library</st></span></li>
				<li><st c="1613">Getting to know the </st><span class="No-Break"><st c="1634">code components</st></span></li>
				<li><a id="_idTextAnchor174"/><st c="1649">ALM for </st><span class="No-Break"><st c="1658">Power Pages</st></span></li>
			</ul>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor175"/><st c="1669">Technical requirements</st></h1>
			<p><st c="1692">To follow this chapter, you need </st><span class="No-Break"><st c="1726">the following:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="1740">Power Platform subscription</st></strong><st c="1768">: You can sign up for a Power Platform development plan (</st><a href="https://powerapps.microsoft.com/en-us/developerplan/"><st c="1826">https://powerapps.microsoft.com/en-us/developerplan/</st></a><st c="1879">) if you already have a Microsoft Entra ID work account, or you can join the Microsoft 365 developer </st><span class="No-Break"><st c="1981">program (</st></span><a href="https://developer.microsoft.com/en-us/microsoft-365/dev-program"><span class="No-Break"><st c="1990">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st></span></a><span class="No-Break"><st c="2054">).</st></span></li>
				<li><strong class="bold"><st c="2057">Visual Studio Code</st></strong><st c="2076">: We recommend using Visual Studio Code or Visual Studio with the Power Platform Tools extension, or the IDE of your choice. </st><st c="2202">Visual Studio Code can be found here: </st><a href="https://code.visualstudio.com/"><st c="2240">https://code.visualstudio.com/</st></a><st c="2270">. Visual Studio is also available as a free Community </st><span class="No-Break"><st c="2324">edition: </st></span><a href="https://visualstudio.microsoft.com/vs/community/"><span class="No-Break"><st c="2333">https://visualstudio.microsoft.com/vs/community/</st></span></a><span class="No-Break"><st c="2381">.</st></span></li>
				<li><strong class="bold"><st c="2382">Power Platform CLI</st></strong><st c="2401">: We will be using the PAC CLI inside the command line or terminal. </st><st c="2470">Installation guidance can be found </st><span class="No-Break"><st c="2505">here: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/developer/cli/introduction?tabs=windows"><span class="No-Break"><st c="2511">https://learn.microsoft.com/en-us/power-platform/developer/cli/introduction?tabs=windows</st></span></a><span class="No-Break"><st c="2599">.</st></span></li>
				<li><strong class="bold"><st c="2600">Azure DevOps or GitHub</st></strong><st c="2623">: We can create an Azure DevOps service organization any time </st><em class="italic"><st c="2686">for free</st></em><st c="2694"> (</st><a href="https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates"><st c="2696">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st></a><st c="2778">). </st><st c="2782">We can also create a GitHub handle and public repository (</st><a href="https://github.com/signup"><st c="2840">https://github.com/signup</st></a><st c="2866">), which is also </st><em class="italic"><st c="2884">free</st></em><st c="2888"> for </st><span class="No-Break"><st c="2893">public repositories.</st></span></li>
				<li><strong class="bold"><st c="2913">Node.js</st></strong><st c="2921">: To build PCF code components, you require Node.js. </st><st c="2975">The LTS version is </st><span class="No-Break"><st c="2994">recommended (</st></span><a href="https://nodejs.org/en"><span class="No-Break"><st c="3007">https://nodejs.org/en</st></span></a><span class="No-Break"><st c="3029">).</st></span></li>
				<li><strong class="bold"><st c="3032">.NET build tools</st></strong><st c="3048">: You will need either </st><strong class="source-inline"><st c="3072">msbuild</st></strong><st c="3079"> (part of Visual Studio) or </st><strong class="source-inline"><st c="3107">dotnet build</st></strong><st c="3119"> tools (part of the .NET </st><span class="No-Break"><st c="3144">SDK: </st></span><a href="https://learn.microsoft.com/en-us/dotnet/core/sdk"><span class="No-Break"><st c="3149">https://learn.microsoft.com/en-us/dotnet/core/sdk</st></span></a><span class="No-Break"><st c="3198">).</st></span></li>
			</ul>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor176"/><st c="3201">Enabling the power of the integration – connectors</st></h1>
			<p><st c="3252">This section provides a deeper look into how connectors and custom connectors can be reused across environments with the help of ALM. </st><st c="3387">We will take a look at the concepts of environmental variables and connection references, which are two important concepts for when we plan to scale. </st><st c="3537">We will learn how solutions can be used to wrap connectors for potential reuse across </st><span class="No-Break"><st c="3623">different environments.</st></span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor177"/><st c="3646">Connectors</st></h2>
			<p><st c="3657">We were introduced to </st><a id="_idIndexMarker1248"/><st c="3680">connectors in </st><a href="B22208_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><st c="3694">Chapter 2</st></em></span></a><st c="3703">. Our discussion on connectors so far has covered that connectors enable us to connect to different services and data sources from within our applications, flows, and chatbots. </st><st c="3880">Connectors can be either certified ones, which connect to first- or third-party services, or they can be custom ones. </st><st c="3998">Certified connectors are prebuilt and cannot be changed, whereas custom connectors give us the freedom to create our own connectors to connect to either our own custom services/APIs or other services for which a prebuilt connector does not </st><span class="No-Break"><st c="4238">yet exist.</st></span></p>
			<p><st c="4248">Connectors act as wrappers around sets of API operations, which are categorized as either triggers </st><span class="No-Break"><st c="4348">or actions.</st></span></p>
			<p><strong class="bold"><st c="4359">Triggers</st></strong><st c="4368"> are </st><a id="_idIndexMarker1249"/><st c="4373">operations in a connector that respond to a certain event, for example, a SharePoint list item being created. </st><st c="4483">Two types of triggers exist: polling triggers</st><a id="_idIndexMarker1250"/><st c="4528"> and pushing triggers. </st><strong class="bold"><st c="4551">Polling</st></strong><st c="4558"> triggers </st><a id="_idIndexMarker1251"/><st c="4568">proactively check for changes. </st><st c="4599">They repeatedly, at regular intervals, perform calls of the specified service endpoint to look for new data. </st><strong class="bold"><st c="4708">Pushing</st></strong><st c="4715"> triggers, or webhook triggers, are able to react to external events. </st><st c="4785">When a certain event occurs, the service endpoint notifies the trigger via the </st><span class="No-Break"><st c="4864">callback URL.</st></span></p>
			<p><strong class="bold"><st c="4877">Actions</st></strong><st c="4885"> are</st><a id="_idIndexMarker1252"/><st c="4889"> operations that help us perform methods (retrieve, create, update, and delete) specified in an API definition file. </st><st c="5006">Operations are performed over the data in a service that a connector is connected to, for example, getting all SharePoint lists from </st><span class="No-Break"><st c="5139">a site.</st></span></p>
			<p><st c="5146">We worked with custom connectors in </st><a href="B22208_09.xhtml#_idTextAnchor149"><span class="No-Break"><em class="italic"><st c="5183">Chapter 9</st></em></span></a><st c="5192">. They give us the ability to define our own triggers and actions based on the API operations of </st><span class="No-Break"><st c="5289">our service.</st></span></p>
			<p class="callout-heading"><st c="5301">Microsoft Power Platform’s open source repository</st></p>
			<p class="callout"><st c="5351">Microsoft published an open source repository that allows anyone to review existing certified and custom connectors as well as collaborate by submitting new connectors to the repository. </st><st c="5539">The list of predefined connectors and custom connectors with the corresponding definition files is published in Microsoft’s GitHub repository, which is open to anyone for </st><span class="No-Break"><st c="5710">contributions: </st></span><a href="https://github.com/microsoft/PowerPlatformConnectors/"><span class="No-Break"><st c="5725">https://github.com/microsoft/PowerPlatformConnectors/</st></span></a><span class="No-Break"><st c="5778">.</st></span></p>
			<p class="callout"><st c="5779">Anyone who wants to certify a connector can follow the step-by-step approach, described </st><span class="No-Break"><st c="5868">here: </st></span><a href="https://learn.microsoft.com/en-us/connectors/custom-connectors/submit-certification"><span class="No-Break"><st c="5874">https://learn.microsoft.com/en-us/connectors/custom-connectors/submit-certification</st></span></a><span class="No-Break"><st c="5957">.</st></span></p>
			<p><st c="5958">When planning to deploy applications to different target environments, we must ensure that our connectors utilize connections that exist in the target environments. </st><st c="6124">To be able to switch to the right connection in a target environment in an automated way using pipelines, we recommend using connection references. </st><st c="6272">Let us now take a look at what connection references are and how they can </st><span class="No-Break"><st c="6346">be used.</st></span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor178"/><st c="6354">Connection references</st></h2>
			<p><st c="6376">When a connector is used in an application or flow to run a certain connector operation, a </st><strong class="bold"><st c="6468">connection</st></strong><st c="6478"> for the connector is created in the specific environment. </st><st c="6537">Connections are bound to an environment and store authentication credentials to perform </st><span class="No-Break"><st c="6625">the operation.</st></span></p>
			<p><st c="6639">Since connections are not solution-aware and do not provide an option of decoupling our business solution from the connection, connection references </st><span class="No-Break"><st c="6789">were introduced.</st></span></p>
			<p><strong class="bold"><st c="6805">Connection references</st></strong><st c="6827"> are </st><a id="_idIndexMarker1253"/><st c="6832">solution components that point to a connection for a specific connector. </st><st c="6905">Using connection references allows us to build flexible solutions that enable us to programmatically change the connection information in applications and flows. </st><st c="7067">This simplifies the deployment of our solution to different target environments when using the DevOps approach, as it allows us to connect to resources that are relevant to the </st><span class="No-Break"><st c="7244">target environment.</st></span></p>
			<p><st c="7263">Let’s explore another method for parameterizing solution configuration: </st><span class="No-Break"><st c="7336">environment variables.</st></span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor179"/><st c="7358">Environment variables</st></h2>
			<p><st c="7380">Environment variables act as </st><a id="_idIndexMarker1254"/><st c="7410">configuration parameters for solution components, allowing us to dynamically change configuration values specific to the target environment. </st><st c="7551">Environment variables are well known in traditional application development, where developers use them to decouple the configuration from the application. </st><st c="7706">This allows developers to adapt the application to the target environment without changing the application code. </st><st c="7819">In Power Platform, we follow the same concept to use the application components across different target environments by only changing the environmental variables. </st><st c="7982">This way, we can connect to a data source or set of APIs that is specific to the </st><span class="No-Break"><st c="8063">target environment.</st></span></p>
			<p><st c="8082">Environmental variables are usually stored in the format of key-value pairs, with values stored outside of the</st><a id="_idIndexMarker1255"/><st c="8193"> application source code in a secure location, such as </st><strong class="bold"><st c="8248">Azure App Configuration</st></strong><st c="8271"> or </st><strong class="bold"><st c="8275">Azure Key Vault</st></strong><st c="8290">, so that the values are not easily accessible. </st><st c="8338">During application </st><a id="_idIndexMarker1256"/><st c="8357">runtime or CI/CD pipeline execution, the values are retrieved from these services and </st><span class="No-Break"><st c="8443">used accordingly.</st></span></p>
			<p><st c="8460">Utilizing such an approach allows us to enable one of the DevOps best practices: parameterizing as much as possible to enable the flexibility of our applications. </st><st c="8624">Hardcoding values in the application source code could lead not only to maintenance issues but also to potential </st><span class="No-Break"><st c="8737">security vulnerabilities.</st></span></p>
			<p><st c="8762">In summary, here are some of the </st><a id="_idIndexMarker1257"/><st c="8796">benefits of using </st><span class="No-Break"><st c="8814">environment variables:</st></span></p>
			<ul>
				<li><st c="8836">We can decouple the application from the configuration, allowing us to easily change the configuration values for data sources and other secrets. </st><st c="8983">For example, we can change the connection to the data sources, such as API keys and server URLs, as we deploy our application to different </st><span class="No-Break"><st c="9122">target environments.</st></span></li>
				<li><st c="9142">We can reuse environment variables across other solution components. </st><st c="9212">For example, we can create an environment variable that will be used in both Power Automate and Power Apps, which </st><span class="No-Break"><st c="9326">simplifies configuration.</st></span></li>
				<li><st c="9351">We can improve security by separating the secrets from the solution components and </st><a id="_idIndexMarker1258"/><st c="9435">storing them in a key vault to reduce the risk </st><span class="No-Break"><st c="9482">of misuse.</st></span></li>
			</ul>
			<p><st c="9492">When we add environment variables to our solution, Power Platform automatically creates entries in two Dataverse tables: </st><strong class="bold"><st c="9614">Environment Variable Value</st></strong><st c="9640"> and </st><strong class="bold"><st c="9645">Environment Variable Definition</st></strong><st c="9676">. To use environment variables in Power Apps applications, we should use a lookup function on these two tables and obtain the values based on the names of the environment variables that we create, as seen in the </st><em class="italic"><st c="9888">Introducing feature flags</st></em><st c="9913"> exercise in </st><a href="B22208_08.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic"><st c="9926">Chapter 8</st></em></span></a><st c="9935">. In Power Automate, we are able to access environment variables by using the dynamic </st><span class="No-Break"><st c="10021">content selector.</st></span></p>
			<p><st c="10038">To better understand how we can streamline this operation and follow DevOps best practices, we will take a closer look at this approach through </st><span class="No-Break"><st c="10183">an example.</st></span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor180"/><st c="10194">Example – Decoupling configuration from the application</st></h2>
			<p><st c="10250">In this example, we will be</st><a id="_idIndexMarker1259"/><st c="10278"> utilizing connection references and environment variables to decouple a configuration from our </st><span class="No-Break"><st c="10374">business solution.</st></span></p>
			<p><st c="10392">First, we need to create a solution and add all components that are part of our business solution, including new environment variables and connection references. </st><st c="10555">Then, we will create a deployment settings file, which will decouple the configuration settings from our actual application. </st><st c="10680">This will allow us to configure the values specific to the target environment. </st><st c="10759">We will use the deployment settings file to import the solution to a target environment with the relevant </st><span class="No-Break"><st c="10865">configuration values.</st></span></p>
			<h3><st c="10886">Preparing a solution</st></h3>
			<p><st c="10907">Let us explore the first step of</st><a id="_idIndexMarker1260"/><st c="10940"> preparing the solution with </st><span class="No-Break"><st c="10969">configuration settings:</st></span></p>
			<ol>
				<li><st c="10992">On the Power Apps (</st><a href="https://make.powerapps.com"><st c="11012">https://make.powerapps.com</st></a><st c="11039">) or Power Automate (</st><a href="https://make.powerautomate.com"><st c="11061">https://make.powerautomate.com</st></a><st c="11092">) home page, we can find a </st><strong class="bold"><st c="11120">Solutions</st></strong><st c="11129"> option in the left navigation bar. </st><st c="11165">Selecting it will open a screen with a list of all solutions in the </st><span class="No-Break"><st c="11233">current environment.</st></span></li>
				<li><st c="11253">We either click </st><strong class="bold"><st c="11270">New solution</st></strong><st c="11282"> to create a new solution or select an existing solution from the list and click </st><strong class="bold"><st c="11363">Edit</st></strong><st c="11367"> to edit the </st><span class="No-Break"><st c="11380">existing solution.</st></span><p class="list-inset"><st c="11398">Creating a new solution and importing it to the environment can also be done with the PAC CLI, as we have seen in previous chapters, with the </st><strong class="source-inline"><st c="11541">pac solution init</st></strong><st c="11558"> and </st><strong class="source-inline"><st c="11563">pac solution </st></strong><span class="No-Break"><strong class="source-inline"><st c="11576">import</st></strong></span><span class="No-Break"><st c="11582"> commands.</st></span></p></li>
				<li><st c="11592">Once we are in the solution object explorer, we can add a new connection reference by clicking </st><strong class="bold"><st c="11688">New</st></strong><st c="11691"> | </st><strong class="bold"><st c="11694">More</st></strong><st c="11698"> | </st><span class="No-Break"><strong class="bold"><st c="11701">Connection Reference</st></strong></span><span class="No-Break"><st c="11721">.</st></span><p class="list-inset"><st c="11722">To add an</st><a id="_idIndexMarker1261"/><st c="11732"> existing connection reference, we click on </st><strong class="bold"><st c="11776">Add existing</st></strong><st c="11788"> | </st><strong class="bold"><st c="11791">More</st></strong><st c="11795"> | </st><strong class="bold"><st c="11798">Connection Reference</st></strong><st c="11818">, select the existing connection reference, and click </st><strong class="bold"><st c="11872">Next</st></strong><st c="11876">, as we can see in </st><span class="No-Break"><em class="italic"><st c="11895">Figure 10</st></em></span><em class="italic"><st c="11904">.1. </st></em><st c="11908">This will add any existing components to </st><span class="No-Break"><st c="11949">the </st><a id="_idTextAnchor181"/><a id="_idTextAnchor182"/><st c="11953">solution:</st></span></p></li>
			</ol>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B22208_10_1.jpg" alt="Figure 10.1 – Adding components in the solution object explorer"/><st c="11962"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12421">Figure 10.1 – Adding components in the solution object explorer</st></p>
			<ol>
				<li value="4"><st c="12484">Whenever we are creating new connection references, the </st><strong class="bold"><st c="12541">New Connection Reference</st></strong><st c="12565"> screen will open, as can be seen in </st><span class="No-Break"><em class="italic"><st c="12602">Figure 10</st></em></span><span class="No-Break"><em class="italic"><st c="12611">.2</st></em></span><span class="No-Break"><st c="12613">.</st></span><p class="list-inset"><st c="12614">Here we must provide the </st><strong class="bold"><st c="12640">Display name</st></strong><st c="12652">, </st><strong class="bold"><st c="12654">Name</st></strong><st c="12658">, </st><strong class="bold"><st c="12660">Connector</st></strong><st c="12669"> values, as well as a </st><strong class="bold"><st c="12691">Connection</st></strong><st c="12701"> value for the selected connector. </st><st c="12736">Providing a description is optional but is recommended to have a better understanding of the use of </st><span class="No-Break"><st c="12836">connection references:</st></span></p><ul><li><st c="12858">If there are no connections for a selected connector in the environment, we need to create a new one by selecting </st><strong class="bold"><st c="12973">+ New connection</st></strong><st c="12989">, which opens a new connections screen with a pop-up box for our selected connector. </st><st c="13074">We need to provide all required parameters for the connection and click </st><strong class="bold"><st c="13146">Create</st></strong><st c="13152"> to create </st><span class="No-Break"><st c="13163">a connection.</st></span></li></ul></li>
				<li><st c="13176">Going back</st><a id="_idIndexMarker1262"/><st c="13187"> to the previous </st><strong class="bold"><st c="13204">New Connection Reference</st></strong><st c="13228"> screen, we can now click the </st><strong class="bold"><st c="13258">Refresh</st></strong><st c="13265"> button next to the drop-down list of connections, as can be seen in </st><span class="No-Break"><em class="italic"><st c="13334">Figure 10</st></em></span><em class="italic"><st c="13343">.2</st></em><st c="13345">, which will update the list of connections and show the newly created connection. </st><st c="13428">We can select it and proceed by clicking </st><strong class="bold"><st c="13469">Create</st></strong><st c="13475">, which creates a new component in </st><span class="No-Break"><st c="13510">our</st><a id="_idTextAnchor183"/><a id="_idTextAnchor184"/><st c="13513"> solution.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B22208_10_2.jpg" alt="Figure 10.2 – Creating a new connection reference"/><st c="13523"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="13745">Figure 10.2 – Creating a new connection reference</st></p>
			<ol>
				<li value="6"><st c="13794">To add an </st><a id="_idIndexMarker1263"/><st c="13805">environment variable, we follow similar steps to those mentioned in </st><em class="italic"><st c="13873">step 3</st></em><st c="13879">. This time, we select </st><strong class="bold"><st c="13902">New</st></strong><st c="13905"> | </st><strong class="bold"><st c="13908">More</st></strong><st c="13912"> | </st><span class="No-Break"><strong class="bold"><st c="13915">Environment variable</st></strong></span><span class="No-Break"><st c="13935">.</st></span></li>
				<li><st c="13936">A new screen will appear, which will require us to provide more information about the environment variable, such as </st><strong class="bold"><st c="14053">Display name</st></strong><st c="14065">, </st><strong class="bold"><st c="14067">Name</st></strong><st c="14071">, </st><strong class="bold"><st c="14073">Description</st></strong><st c="14084">, and </st><span class="No-Break"><strong class="bold"><st c="14090">Data Type</st></strong></span><span class="No-Break"><st c="14099">:</st></span><ul><li><strong class="bold"><st c="14101">Data Type</st></strong><st c="14110"> specifies the type of our environment variable. </st><st c="14159">This could be </st><strong class="bold"><st c="14173">Decimal number</st></strong><st c="14187">, </st><strong class="bold"><st c="14189">Yes/No</st></strong><st c="14195">, </st><strong class="bold"><st c="14197">Text</st></strong><st c="14201">, </st><strong class="bold"><st c="14203">Data source</st></strong><st c="14214">, </st><strong class="bold"><st c="14216">Secret</st></strong><st c="14222">, and so on. </st><st c="14235">After selecting a data type, we can configure the default and current value, as can be seen in </st><em class="italic"><st c="14330">Figure 10.3</st></em><st c="14341">. If we are creating an environment variable of type </st><strong class="bold"><st c="14394">Data source</st></strong><st c="14405">, we get the possibility of </st><span class="No-Break"><st c="14433">selecting </st><a id="_idTextAnchor185"/><a id="_idTextAnchor186"/></span><span class="No-Break"><strong class="bold"><st c="14443">Connector</st></strong></span><span class="No-Break"><st c="14452">.</st></span></li></ul></li>
			</ol>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B22208_10_3.jpg" alt="Figure 10.3 – Adding a new environment variable"/><st c="14453"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="14836">Figure 10.3 – Adding a new environment variable</st></p>
			<ul>
				<li><strong class="bold"><st c="14883">Default Value</st></strong><st c="14897"> is not a</st><a id="_idIndexMarker1264"/><st c="14906"> required field; however, it is something that is used when no </st><strong class="bold"><st c="14969">Current Value</st></strong><st c="14982"> setting is configured. </st><strong class="bold"><st c="15006">Current Value</st></strong><st c="15019"> overrides </st><strong class="bold"><st c="15030">Default Value</st></strong><st c="15043"> and is something that is very useful when deploying to different </st><span class="No-Break"><st c="15109">target environments.</st></span></li>
			</ul>
			<p class="list-inset"><st c="15129">Once we have configured the environment variable as needed, we can click </st><strong class="bold"><st c="15203">Save</st></strong><st c="15207"> to store the configuration, which adds a new component to </st><span class="No-Break"><st c="15266">our solution.</st></span></p>
			<p><st c="15279">If we need to add existing environment variables to our solution, we can do so by clicking </st><strong class="bold"><st c="15371">Add existing</st></strong><st c="15383">| </st><strong class="bold"><st c="15386">More</st></strong><st c="15390"> | </st><strong class="bold"><st c="15393">Environment variable</st></strong><st c="15413"> in the solution object explorer, selecting the existing variables from the list, and clicking </st><strong class="bold"><st c="15508">Next</st></strong><st c="15512">. The next screen shows us the selected environment variables, and for each, we have options to select </st><strong class="bold"><st c="15615">Include definition</st></strong><st c="15633"> and </st><strong class="bold"><st c="15638">Include current value</st></strong><st c="15659"> checkboxes. </st><st c="15672">We can review the existing selected </st><a id="_idIndexMarker1265"/><st c="15708">environment variable and click </st><strong class="bold"><st c="15739">Add</st></strong><st c="15742"> to have it added to </st><span class="No-Break"><st c="15763">our solution.</st></span></p>
			<p class="callout-heading"><st c="15776">Current limitations of environment variables</st></p>
			<p class="callout"><st c="15821">There are still some limitations when using environment variables; for example, data source environment variables cannot currently be managed using Microsoft Power Platform Build Tools. </st><st c="16008">Please make sure to review limitations and use environment variables accordingly. </st><st c="16090">Refer to the updated information about the limitations </st><a id="_idIndexMarker1266"/><span class="No-Break"><st c="16145">here: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables"><span class="No-Break"><st c="16151">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables</st></span></a><span class="No-Break"><st c="16236">.</st></span></p>
			<p><st c="16237">Now that we have prepared our solution, we can deploy it to different environments. </st><st c="16322">When importing a solution manually, the import process will check whether any connection already exists in the environment for the defined connection reference. </st><st c="16483">If so, import process will link it to that connection; if not, it will offer us the chance to automatically create and link the connection . </st><st c="16624">Once the connections are configured, the next step allows us to update environment variables with the actual values for the </st><span class="No-Break"><st c="16748">target environment.</st></span></p>
			<p><st c="16767">To decouple the settings and allow our solution to be imported in a more programmatic way, we will take a look at how a deployment settings file can be generated </st><span class="No-Break"><st c="16930">and used.</st></span></p>
			<h3><st c="16939">Building a deployment settings file</st></h3>
			<p><st c="16975">A</st><strong class="bold"><st c="16977"> deployment settings file</st></strong><st c="17002"> is a </st><a id="_idIndexMarker1267"/><st c="17008">JSON-format file that stores the information about the connection references and environment variables that are being used in our solution. </st><st c="17148">This same file will be used during the solution import process with Power Platform Build Tools or the PAC CLI. </st><st c="17259">We touched on it briefly in </st><a href="B22208_08.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic"><st c="17287">Chapter 8</st></em></span></a><span class="No-Break"><st c="17296">:</st></span></p>
			<ol>
				<li><st c="17298">We should</st><a id="_idIndexMarker1268"/><st c="17307"> export our solution or clone it. </st><st c="17341">We need to</st><a id="_idIndexMarker1269"/><st c="17351"> have either a solution ZIP file or an unpacked solution folder to which we can point to generate a settings file. </st><st c="17466">We can do this in </st><span class="No-Break"><st c="17484">two ways:</st></span><ul><li><st c="17493">By selecting the solution, clicking </st><strong class="bold"><st c="17530">Export solution</st></strong><st c="17545">, and downloading the </st><span class="No-Break"><st c="17567">package file</st></span></li><li><st c="17579">By using a PAC CLI command such as </st><strong class="source-inline"><st c="17615">pac solution clone --name &lt;solution-name&gt;</st></strong><st c="17656"> or </st><strong class="source-inline"><st c="17660">pac solution export --name &lt;name&gt;</st></strong><st c="17693">, which means the solution folder will be cloned locally or the solution ZIP file will be </st><span class="No-Break"><st c="17783">downloaded locally</st></span></li></ul></li>
				<li><st c="17801">Now that we</st><a id="_idIndexMarker1270"/><st c="17813"> have exported the solution package </st><a id="_idIndexMarker1271"/><st c="17849">file, we are ready to create the deployment settings file, using the </st><span class="No-Break"><st c="17918">following approach.</st></span><p class="list-inset"><st c="17937">Generating a deployment setting file can be done by using the following PAC </st><span class="No-Break"><st c="18014">CLI command:</st></span></p><pre class="source-code"><st c="18026">
pac solution create-settings --solution-zip &lt;solution-file.zip&gt; --solution-folder &lt;unpacked-solution-folder&gt; --settings-file &lt;JSON-file-name&gt;</st></pre><p class="list-inset"><st c="18168">Pointing to the solution can be done by passing either of the following arguments – the solution ZIP file or the solution folder. </st><st c="18299">Here is an example of this command </st><span class="No-Break"><st c="18334">in practice:</st></span></p><pre class="source-code"><strong class="bold"><st c="18346">pac solution create-settings --solution-zip .\EnvConnRef_1_1_managed.zip</st></strong></pre><p class="list-inset"><st c="18419">This command generates a </st><strong class="source-inline"><st c="18445">deploymentSettings.json</st></strong><st c="18468"> file in the </st><span class="No-Break"><st c="18481">current folder.</st></span></p><p class="list-inset"><st c="18496">An example of the structure of the </st><strong class="source-inline"><st c="18532">deploymentSettings.json</st></strong><st c="18555"> file is present in the </st><a href="B22208_10.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><st c="18579">Chapter 10</st></em></span></a><st c="18589"> folder of this book’s GitHub repository. </st><st c="18631">In the file, we can see the structure of the environment variables and connection references with the </st><span class="No-Break"><st c="18733">respective values.</st></span></p><p class="list-inset"><st c="18751">For each environment variable in the file, there is a </st><strong class="source-inline"><st c="18806">Value</st></strong><st c="18811"> property. </st><st c="18822">Initially, it is an empty string that we update with the value for the target environment. </st><st c="18913">The same should be done for the connection references, where the </st><strong class="source-inline"><st c="18978">ConnectionId</st></strong><st c="18990"> property is initially empty and needs to </st><span class="No-Break"><st c="19032">be provided.</st></span></p><p class="list-inset"><st c="19044">To update the connection reference values, we can use the PAC CLI to connect to the target environment and list all connections. </st><st c="19174">This will allow us to see whether any of the connections for the given connector already exist there. </st><st c="19276">Once we are pointing the PAC CLI at the target environment, we can use the </st><strong class="source-inline"><st c="19351">pac connection list</st></strong><st c="19370"> command to list all connections established in the selected environment. </st><st c="19444">If a connection exists, copy the </st><strong class="source-inline"><st c="19477">Id</st></strong><st c="19479"> value of the connection into the deployment settings file under the right connection reference </st><strong class="source-inline"><st c="19575">ConnectionId</st></strong><st c="19587"> value, as shown in </st><a href="B22208_08.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic"><st c="19607">Chapter 8</st></em></span></a><st c="19616">; otherwise, a create </st><span class="No-Break"><st c="19639">new connection.</st></span></p></li>				<li><st c="19654">Now that we have prepared the deployment settings file for the solution, we can proceed with the solution import process, including the specified deployment settings file. </st><st c="19827">If no environment value or path is provided with the command, the current environment and the current folder structure will be used for the</st><a id="_idIndexMarker1272"/> <span class="No-Break"><st c="19966">solution </st></span><span class="No-Break"><a id="_idIndexMarker1273"/></span><span class="No-Break"><st c="19976">import:</st></span><pre class="source-code"><st c="19983">
pac solution import --path &lt;path_to_zip_file&gt; --settings-file .\deploymentSettings.json</st></pre></li>			</ol>
			<p><st c="20071">The preceding approach presents a programmatic approach for generating a deployment settings file, editing it, and importing the solution to the target environment. </st><st c="20237">To follow the DevOps approach, we can use extra tasks in the pipelines to manage the deployment settings file and deploy to the </st><span class="No-Break"><st c="20365">target environment.</st></span></p>
			<h3><st c="20384">The deployment settings file and the DevOps approach</st></h3>
			<p><st c="20437">In </st><a href="B22208_08.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic"><st c="20441">Chapter 8</st></em></span></a><st c="20450">, we saw how</st><a id="_idIndexMarker1274"/><st c="20462"> the deployment settings</st><a id="_idIndexMarker1275"/><st c="20486"> file can be used within DevOps. </st><st c="20519">In order to keep things automated, we can add an extra task in the pipeline, which will create a deployment settings file and store it in the repository, next to our exported solution. </st><st c="20704">We can do that using the PAC CLI. </st><st c="20738">We have to make sure that when we use the Power Platform Tool Installer task in our export pipeline, we add the PAC CLI to the </st><strong class="source-inline"><st c="20865">PATH</st></strong><st c="20869"> environment variable. </st><st c="20892">The following example shows how it can be done in </st><span class="No-Break"><st c="20942">Azure DevOps:</st></span></p>
			<pre class="source-code"><st c="20955">
- task: PowerPlatformToolInstaller@2
  inputs:
    DefaultVersion: true
    AddToolsToPath: true</st></pre>			<p><st c="21042">To generate a deployment settings file, we will use a </st><strong class="bold"><st c="21097">Command line</st></strong><st c="21109"> task, with a command that we are now </st><span class="No-Break"><st c="21147">familiar with:</st></span></p>
			<pre class="source-code"><st c="21161">
- task: CmdLine@2
  inputs:
    script: |
      echo 'Create Deployment Settings File'
      pac solution create-settings --solution-zip '$(Build.ArtifactStagingDirectory)/$(SolutionName).zip' --settings-file '$(SolutionName).json'</st></pre>			<p><st c="21375">The </st><strong class="source-inline"><st c="21380">git commit</st></strong><st c="21390"> command </st><a id="_idIndexMarker1276"/><st c="21399">that we have as part of our export pipeline will now make sure that this new deployment settings file will be added to our repository. </st><st c="21534">If we are creating an artifact within the export pipeline, we should make sure that we add the deployment settings file to the artifact using a </st><strong class="bold"><st c="21678">Copy files</st></strong><st c="21688"> task in </st><span class="No-Break"><st c="21697">the pipeline.</st></span></p>
			<p><st c="21710">Now that we have</st><a id="_idIndexMarker1277"/><st c="21727"> the deployment settings file in our repository, it is time to update the values in the files. </st><st c="21822">As we do not want to keep any sensitive information in our source code, and these values can be readable, we recommend parameterizing the values for environmental variables and connection IDs for connection references. </st><st c="22041">As an example, in the deployment settings file, we could have values of environment variables written like this: </st><strong class="source-inline"><st c="22154">„Value": „#{ENV_NAME}#"</st></strong><st c="22177">, and values of connection IDs for connection references written like this: </st><strong class="source-inline"><st c="22253">„ConnectionId": „#{CONN_O365OUTLOOK}#</st></strong><st c="22290">. A similar approach was shown in </st><a href="B22208_08.xhtml#_idTextAnchor134"><span class="No-Break"><em class="italic"><st c="22324">Chapter 8</st></em></span></a><span class="No-Break"><st c="22333">.</st></span></p>
			<p><st c="22334">As part of our</st><a id="_idIndexMarker1278"/><st c="22349"> deployment pipeline, where we import the solution to the environment, we can update the values to be correct. </st><st c="22460">We can do that using a task/action in our DevOps pipeline that searches for the tokens with the right prefix and suffix, in our case </st><strong class="source-inline"><st c="22593">#{ … }#</st></strong><st c="22600">, and replaces those tokens with the actual value stored in the variables within the DevOps tool or a secure key vault. </st><st c="22720">As an example, in Azure DevOps and GitHub, we can achieve this with a </st><strong class="bold"><st c="22790">Replace </st></strong><span class="No-Break"><strong class="bold"><st c="22798">tokens</st></strong></span><span class="No-Break"><st c="22804"> task/action.</st></span></p>
			<p><st c="22817">Once the tokens have been replaced with the actual values during the deployment pipeline, the next step is to import the solution using the </st><strong class="bold"><st c="22958">Power Platform Import Solution</st></strong><st c="22988"> task, which is </st><a id="_idIndexMarker1279"/><st c="23004">part of Power Platform Build Tools. </st><st c="23040">This </st><a id="_idIndexMarker1280"/><st c="23045">allows us to reference the deployment settings file when importing the solution. </st><st c="23126">Here, we can see an example of such a task in an Azure </st><span class="No-Break"><st c="23181">DevOps pipeline:</st></span></p>
			<pre class="source-code"><st c="23197">
- task: PowerPlatformImportSolution@2
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: '&lt;PP-SPN&gt;'
    SolutionInputFile: '$(Build.ArtifactStagingDirectory)/$(SolutionName).zip'
    UseDeploymentSettingsFile: true
    DeploymentSettingsFile: '$(SolutionName).json'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'</st></pre>			<p><st c="23509">Now that we have a better understanding of how our solutions can have configuration settings files that make them reusable across environments, this will also help us with building other components, such as canvas components and code components. </st><st c="23756">We will start with canvas components and </st><span class="No-Break"><st c="23797">component libraries.</st></span></p>
			<h1 id="_idParaDest-166"><a id="_idTextAnchor187"/><st c="23817">Overview of canvas components and component libraries</st></h1>
			<p><st c="23871">When developing applications in Power Apps, app makers use various controls for application building blocks. </st><st c="23981">In order to avoid repetition and to build reusable parts of the application that can be used across the same application or across multiple apps, app makers should look to canvas components. </st><st c="24172">This section introduces a canvas component together with a component library and will help you understand their differences and how they fit into the </st><span class="No-Break"><st c="24322">ALM process.</st></span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor188"/><st c="24334">Canvas components</st></h2>
			<p><strong class="bold"><st c="24352">Canvas components</st></strong><st c="24370"> serve as</st><a id="_idIndexMarker1281"/><st c="24379"> individual modular building blocks that encapsulate specific functionality or elements of the user interface. </st><st c="24490">Canvas components are reusable across Power Apps canvas apps and model-driven apps. </st><st c="24574">Not only do these components play a crucial role in creating larger and more complex enterprise-grade applications, but they are also significant when it comes to working in a larger team in a co-development environment, as developers can divide tasks and focus each individual component when building a business solution. </st><st c="24897">An additional benefit of creating canvas components is that they can be updated centrally in one place, with all updates being reflected in all instances within </st><span class="No-Break"><st c="25058">the application.</st></span></p>
			<p><st c="25074">Creating canvas</st><a id="_idIndexMarker1282"/><st c="25090"> components is done inside Power Apps Studio while building a canvas application. </st><st c="25172">In the left navigation bar, under </st><strong class="bold"><st c="25206">Tree view</st></strong><st c="25215">, we can see all the screens and components that are part of our application. </st><st c="25293">Clicking </st><strong class="bold"><st c="25302">Components</st></strong><st c="25312"> allows us to see all existing components as well as create new ones, by clicking </st><strong class="bold"><st c="25394">New component</st></strong><st c="25407">. This creates a blank canvas component to which we can </st><span class="No-Break"><st c="25463">add controls:</st></span></p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B22208_10_4.jpg" alt="Figure 10.4 – Creating a canvas component in Power Apps"/><st c="25476"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="25536">Figure 10.4 – Creating a canvas component in Power Apps</st></p>
			<p><st c="25591">Each component can hold custom properties. </st><st c="25635">Custom properties allow components to either receive values from the application, known as input properties, or send data or state from the component to the app, known as output properties. </st><st c="25825">No matter the property type (input/output), a custom property can hold data of any data type, spanning from traditional data types, such as text and number, to more Power Apps-specific types, such as screen, color, and table. </st><st c="26051">Using custom properties allows the sharing of information between the component and the app host. </st><st c="26149">There is one more setting on the canvas component level, </st><strong class="bold"><st c="26206">Access app scope</st></strong><st c="26222">, and it can be found in the properties of the component itself. </st><st c="26287">It can be turned on or off to allow access to a greater set of information </st><a id="_idIndexMarker1283"/><st c="26362">available within the application, such as global variables, collections, and controls within the application. </st><st c="26472">This is only applicable to the canvas components within the application and not to the components within the component library. </st><st c="26600">We can turn off this setting and feed the information to the component through the </st><span class="No-Break"><st c="26683">custom properties.</st></span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor189"/><st c="26701">Component libraries</st></h2>
			<p><st c="26721">Since canvas components can only be used within one application, in order to reuse the components across applications in the environment, we can create a component library. </st><st c="26895">A </st><strong class="bold"><st c="26897">component library</st></strong><st c="26914"> serves</st><a id="_idIndexMarker1284"/><st c="26921"> as a repository for component definitions. </st><st c="26965">This allows an application to manage dependencies on the components that it utilizes, which means that whenever a component update is available, the app maker will be informed about it. </st><st c="27151">The information about the available update will appear when editing the application in Power Apps Studio or by manually clicking a refresh button to check for the component </st><span class="No-Break"><st c="27324">library updates.</st></span></p>
			<p><st c="27340">Creating a component library is</st><a id="_idIndexMarker1285"/><st c="27372"> different from creating a </st><span class="No-Break"><st c="27399">canvas component:</st></span></p>
			<ol>
				<li><st c="27416">Component libraries can be found by navigating to the Power Apps home screen and selecting </st><strong class="bold"><st c="27508">Component libraries</st></strong><st c="27527"> from the left navigation panel. </st><st c="27560">If you do not see this option in the left navigation panel, click on </st><strong class="bold"><st c="27629">More</st></strong><st c="27633"> | </st><strong class="bold"><st c="27636">Discover all</st></strong><st c="27648">, where you can f</st><a id="_idTextAnchor190"/><st c="27665">ind it under </st><span class="No-Break"><strong class="bold"><st c="27679">App enhancements</st></strong></span><span class="No-Break"><st c="27695">:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B22208_10_5.jpg" alt="Figure 10.5 – Accessing Component libraries"/><st c="27697"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="28983">Figure 10.5 – Accessing Component libraries</st></p>
			<ol>
				<li value="2"><st c="29026">Once we are on the </st><a id="_idIndexMarker1286"/><st c="29046">component libraries screen, we can click on </st><strong class="bold"><st c="29090">+ New component library</st></strong><st c="29113"> to create a blank canvas for adding </st><span class="No-Break"><st c="29150">app components.</st></span></li>
				<li><st c="29165">Here we can import existing components or create new ones by following the same process as with the regular canvas component. </st><st c="29292">Each component that is created or imported in a component library allows makers to make customizations in the target environment. </st><strong class="bold"><st c="29422">Allow customization</st></strong><st c="29441"> is a property of the component inside Power Apps Studio. </st><st c="29499">If customization is allowed, then once the app maker starts making changes to the component in the application, this will break the reference to the component library and create a local copy of the component. </st><st c="29708">In order to maintain control over components and allow component changes only from within the component library, turning off this component setting is a </st><span class="No-Break"><st c="29861">good practice.</st></span></li>
				<li><st c="29875">Once all components are added to the component library, we need to publish the changes. </st><st c="29964">The publishing process is the same as with any other canvas component or canvas app. </st><st c="30049">If the component library is not published, it cannot </st><span class="No-Break"><st c="30102">be reused.</st></span></li>
				<li><st c="30112">Once published, we are ready to reuse the components from the library in our application. </st><st c="30203">To do so, we open our canvas app in Power Apps Studio and, in the left navigation panel, click on </st><strong class="bold"><st c="30301">Insert</st></strong><st c="30307">, which opens an option for adding controls </st><span class="No-Break"><st c="30351">and components.</st></span><p class="list-inset"><st c="30366">We click on the icon that</st><a id="_idIndexMarker1287"/><st c="30392"> represents directory search, which opens an </st><strong class="bold"><st c="30437">Import components</st></strong><st c="30454"> screen. </st><st c="30463">Here we can find our component library and all components that are part of the library. </st><st c="30551">We can select those that we need and </st><span class="No-Break"><st c="30588">click </st></span><span class="No-Break"><strong class="bold"><st c="30594">Import</st></strong></span><span class="No-Break"><st c="30600">:</st></span></p></li>
			</ol>
			<div>
				<div id="_idContainer139" class="IMG---Figure">
					<img src="image/B22208_10_6.jpg" alt="Figure 10.6 – Importing components from a component library"/><st c="30602"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31035">Figure 10.6 – Importing components from a component library</st></p>
			<ol>
				<li value="6"><st c="31094">Components from the component library will appear in the left navigation panel under the </st><strong class="bold"><st c="31184">Insert</st></strong><st c="31190"> option. </st><st c="31199">We can find them in a </st><strong class="bold"><st c="31221">Library components</st></strong><st c="31239"> group, just underneath the </st><strong class="bold"><st c="31267">Custom</st></strong><st c="31273"> category, which holds locally created can</st><a id="_idTextAnchor191"/><st c="31315">vas components, as </st><span class="No-Break"><st c="31335">shown here:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B22208_10_7.jpg" alt="Figure 10.7 – Accessing components from the added component library"/><st c="31346"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31417">Figure 10.7 – Accessing components from the added component library</st></p>
			<p><st c="31484">Now that we have learned how to build canvas components and component libraries that support the reusability of the components across canvas applications in an environment, let’s investigate how we can manage the component library </st><span class="No-Break"><st c="31716">life cycle.</st></span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor192"/><st c="31727">Managing the life cycle of the component library</st></h2>
			<p><st c="31776">As we saw earlier, in </st><a id="_idIndexMarker1288"/><st c="31799">order to reuse components across multiple apps, they need to be added to the component library. </st><st c="31895">Once added to the library, they can be inserted into the application. </st><st c="31965">With that, the application creates a dependency on the selected component from the component library and simplifies our </st><span class="No-Break"><st c="32085">solution management.</st></span></p>
			<p><st c="32105">To deploy our application with a component dependency into a different environment, we have to make sure that the component library exists in the target environment prior to deploying the application. </st><st c="32307">Otherwise, the import solution process will not succeed. </st><st c="32364">It is on us to make sure that the component library is either bundled together with the application inside the solution or moved to the target environment in a separate solution, prior to deploying the application that has a </st><span class="No-Break"><st c="32589">component dependency.</st></span></p>
			<p><st c="32610">We can check whether the application has any dependencies by navigating to </st><strong class="bold"><st c="32686">Solutions</st></strong><st c="32695">, selecting our solution, clicking </st><strong class="bold"><st c="32730">Object</st></strong><st c="32736">, clicking on the three dots next to the name of the application, clicking </st><strong class="bold"><st c="32811">Advanced</st></strong><st c="32819">, and clicking </st><strong class="bold"><st c="32834">Show dependen</st><a id="_idTextAnchor193"/><st c="32847">cies</st></strong><st c="32852">, as shown in </st><span class="No-Break"><em class="italic"><st c="32866">Figure 10</st></em></span><span class="No-Break"><em class="italic"><st c="32875">.8</st></em></span><span class="No-Break"><st c="32877">:</st></span></p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B22208_10_8.jpg" alt="Figure 10.8 – Checking application dependencies"/><st c="32879"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="33489">Figure 10.8 – Checking application dependencies</st></p>
			<p><st c="33536">There we will find a tab</st><a id="_idIndexMarker1289"/><st c="33561"> called </st><strong class="bold"><st c="33569">Uses</st></strong><st c="33573">, which shows which objects are being used by our application. </st><st c="33636">Selecting the three dots next to the name of the component library will redirect us to </st><strong class="bold"><st c="33723">Default Solution</st></strong><st c="33739">. It is important to note that component libraries are placed in the default solution within the environment. </st><st c="33849">This will be the same when we have moved to the target environment, as long as the environment has </st><span class="No-Break"><st c="33948">Dataverse enabled.</st></span></p>
			<p><st c="33966">Adding a component library to the solution where our application resides can be easily achieved by going to our solution, clicking on </st><strong class="bold"><st c="34101">Objects</st></strong><st c="34108">, and either creating a new component library or adding an existing one. </st><st c="34181">Creating a new one is done by clicking </st><strong class="bold"><st c="34220">New</st></strong><st c="34223"> | </st><strong class="bold"><st c="34226">More</st></strong><st c="34230"> | </st><strong class="bold"><st c="34233">Component Library</st></strong><st c="34250">. Adding an existing component library can be done through </st><strong class="bold"><st c="34309">Add existing</st></strong><st c="34321"> | </st><strong class="bold"><st c="34324">More</st></strong><st c="34328"> | </st><strong class="bold"><st c="34331">Component Library</st></strong><st c="34348">. Once the component library is added to the solution, we can enable/disable the option that allows customizations in the target environment. </st><st c="34490">This setting is available inside the solution explorer. </st><st c="34546">We select our component library, click on the three dots next to its name, and then click </st><strong class="bold"><st c="34636">Advanced</st></strong><st c="34644"> | </st><strong class="bold"><st c="34647">Managed properties</st></strong><st c="34665">. This will open a screen for editing the managed properties of the component library. </st><st c="34752">Here we can toggle on or off the option to allow customizations in the </st><span class="No-Break"><st c="34823">target environment:</st></span></p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B22208_10_9.jpg" alt="Figure 10.9 – Enabling/disabling customization in the target environment"/><st c="34842"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="35736">Figure 10.9 – Enabling/disabling customization in the target environment</st></p>
			<p><st c="35808">Once we have added our component library with all components in the solution, we can follow the ALM process that we are already familiar with: export the solution from Power Apps using the export pipeline, followed by an import pipeline to the target environment, with all other relevant steps in between </st><span class="No-Break"><st c="36114">for testing.</st></span></p>
			<p><st c="36126">Should we wish to</st><a id="_idIndexMarker1290"/><st c="36144"> update the component library separately from the application, it makes sense to have a separate pipeline process just for updating the component libraries. </st><st c="36301">We can create a separate solution and add one or more component libraries that we would like to manage the application life cycles of separately. </st><st c="36447">We need to keep in mind that the component library has to be deployed to the target environment prior to importing the solution that has reference to that component library. </st><st c="36621">Once the component is updated, the app maker will be informed about the updates through the component update process (automatically </st><span class="No-Break"><st c="36753">or proactively).</st></span></p>
			<p><st c="36769">Now that we have learned about canvas components and their reusability, we will go further and look what additional customizations are possible with the </st><span class="No-Break"><st c="36923">code components.</st></span></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor194"/><st c="36939">Getting to know code components</st></h1>
			<p><st c="36971">Going one step further in pro-dev extensibility, the </st><strong class="bold"><st c="37025">Power Apps component framework</st></strong><st c="37055"> (</st><strong class="bold"><st c="37057">PCF</st></strong><st c="37060">) allows </st><a id="_idIndexMarker1291"/><st c="37070">professional developers to create code components that enrich the user experience whenever the look and feel of the built-in components is not sufficient. </st><st c="37225">The PCF is such a big topic that it could have its own chapter in this book. </st><st c="37302">In this section, we will try to give you at least an initial understanding of what the PCF is, how the PAC CLI can help us to build code components, and how to perform ALM using </st><span class="No-Break"><st c="37480">DevOps tools.</st></span></p>
			<p><st c="37493">The PCF </st><a id="_idIndexMarker1292"/><st c="37502">is a unified framework that allows developers to build custom code components that are reusable across applications in Power Apps and websites in Power Pages. </st><st c="37661">This opens a great opportunity for organizations to build code components and leverage them across business solutions. </st><st c="37780">Using the PCF, we can develop code components that will include not only information about the visual appearance of the component but also the business logic. </st><st c="37939">This allows us to make applications and websites more appealing and customized to the business problem. </st><st c="38043">The PCF is a successor of HTML web resources, which were used prior to PCF to render custom UI components inside model-driven applications. </st><st c="38183">The PCF is more optimized for performance compared to HTML web resources, making it suitable for complex </st><span class="No-Break"><st c="38288">business solutions.</st></span></p>
			<p class="callout-heading"><st c="38307">Custom pages in model-driven apps</st></p>
			<p class="callout"><st c="38341">Custom pages</st><a id="_idIndexMarker1293"/><st c="38354"> are flexible and powerful type of pages in model-driven apps that enable us to bring the experience from building canvas apps to model-driven apps. </st><st c="38503">We can add canvas and code components to a custom page, which can be shown in a model-driven app as a main page, center dialog screen, or side dialog view. </st><st c="38659">This gives us a great range of flexibility for building the experience of our </st><span class="No-Break"><st c="38737">business application.</st></span></p>
			<p><st c="38758">Currently, we know two types of PCF </st><a id="_idIndexMarker1294"/><st c="38795">components: </st><strong class="bold"><st c="38807">standard</st></strong><st c="38815"> and </st><strong class="bold"><st c="38820">virtual</st></strong><st c="38827">. Both types of components leverage </st><a id="_idIndexMarker1295"/><st c="38863">HTML, CSS, and TypeScript. </st><st c="38890">However, virtual components use two platform-provided libraries, React and Fluent UI. </st><st c="38976">They are added to the parent virtual </st><strong class="bold"><st c="39013">Document Object Model</st></strong><st c="39034"> (</st><strong class="bold"><st c="39036">DOM</st></strong><st c="39039">), which</st><a id="_idIndexMarker1296"/><st c="39048"> means that there is no need to instantiate a React virtual DOM separately with each component. </st><st c="39144">Although React and Fluent UI can be used with standard PCF components, doing so requires the developer to package libraries individually within the components. </st><st c="39304">In the case of virtual components, we are able to use platform-provided libraries, which allows us to improve the performance of our applications using these code components. </st><st c="39479">It is important to note that even if we start with a standard code component, we can later convert it to a </st><span class="No-Break"><st c="39586">virtual component.</st></span></p>
			<p><st c="39604">Depending on how the component will be used, we can differentiate between two types of </st><span class="No-Break"><st c="39692">PCF components:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="39707">Field</st></strong><st c="39713">, where a code component can be bound to a field in </st><span class="No-Break"><st c="39765">a form</st></span></li>
				<li><strong class="bold"><st c="39771">Dataset</st></strong><st c="39779">, which is a code component that is bound to a view, dataset, or collection in a canvas app and works with the rows of data from </st><span class="No-Break"><st c="39908">a dataset</st></span></li>
			</ul>
			<p><st c="39917">Using these two types of PCF components, developers can build custom fields, columns, and views over datasets and dashboards that can replace built-in components in our </st><span class="No-Break"><st c="40087">business applications.</st></span></p>
			<p class="callout-heading"><st c="40109">Community resources for the PCF</st></p>
			<p class="callout"><st c="40141">For those who are willing to learn </st><a id="_idIndexMarker1297"/><st c="40177">more about the PCF and would like to see some examples that the wider community has developed using the PCF, Microsoft offers a set of links (to videos, blogs, and a code component gallery) that can be used for this purpose. </st><st c="40402">For more information, go </st><span class="No-Break"><st c="40427">to: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/developer/component-framework/community-resources"><span class="No-Break"><st c="40431">https://learn.microsoft.com/en-us/power-apps/developer/component-framework/community-resources</st></span></a><span class="No-Break"><st c="40525">.</st></span></p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor195"/><st c="40526">Code component composition</st></h2>
			<p><st c="40553">No matter which control type or kind of component we decide to build, code components consist of three main elements—a manifest file, a component implementation, and </st><span class="No-Break"><st c="40720">resource files.</st></span></p>
			<h3><st c="40735">Manifest file</st></h3>
			<p><st c="40749">A control manifest</st><a id="_idIndexMarker1298"/><st c="40768"> is an XML file that is used to register and manage the code component. </st><st c="40840">The </st><a id="_idIndexMarker1299"/><st c="40844">name of the manifest file </st><span class="No-Break"><st c="40870">is </st></span><span class="No-Break"><strong class="source-inline"><st c="40873">ControlManifest.Input.xml</st></strong></span><span class="No-Break"><st c="40898">.</st></span></p>
			<p><st c="40899">It holds all information about the code component, such as </st><span class="No-Break"><st c="40959">the following:</st></span></p>
			<ul>
				<li><st c="40973">The component </st><span class="No-Break"><st c="40988">metadata information</st></span></li>
				<li><st c="41008">Information about the control type (standard </st><span class="No-Break"><st c="41054">or virtual)</st></span></li>
				<li><st c="41065">Whether any external services are going to be used (which would require </st><span class="No-Break"><st c="41138">premium licensing)</st></span></li>
				<li><st c="41156">Properties that are available </st><span class="No-Break"><st c="41187">for use</st></span></li>
				<li><span class="No-Break"><st c="41194">Used resources</st></span></li>
				<li><st c="41209">Other </st><a id="_idIndexMarker1300"/><st c="41216">metadata and </st><span class="No-Break"><st c="41229">config data</st></span></li>
			</ul>
			<p><st c="41240">The properties available in the code component can then be either manually entered or dynamically set to a value or data from other components in </st><span class="No-Break"><st c="41387">the application.</st></span></p>
			<h3><st c="41403">Component implementation</st></h3>
			<p><st c="41428">Code component logic is</st><a id="_idIndexMarker1301"/><st c="41452"> implemented in a file called </st><strong class="source-inline"><st c="41482">index.ts</st></strong><st c="41490">. Here we are able to place the code that will define the behavior of our code component. </st><st c="41580">This is the place where we can find methods that control the life cycle of our </st><span class="No-Break"><st c="41659">code component.</st></span></p>
			<p><st c="41674">The life cycle of the code component can be divided into four </st><span class="No-Break"><st c="41737">main methods:</st></span></p>
			<ul>
				<li><strong class="source-inline"><st c="41750">init</st></strong><st c="41755">: This method is used to initialize the component instance. </st><st c="41816">This function not only configures the component but can also register any event listeners or add other functionalities for the component to properly behave. </st><st c="41973">This method is required to be implemented in the code </st><span class="No-Break"><st c="42027">implementation file.</st></span></li>
				<li><strong class="source-inline"><st c="42047">updateView</st></strong><st c="42058">: This method gets called when any value in the component’s properties or component metadata changes. </st><st c="42161">It is used to reflect the changes in the component’s UI. </st><st c="42218">This method is required to be implemented in the code </st><span class="No-Break"><st c="42272">implementation file.</st></span></li>
				<li><strong class="source-inline"><st c="42292">getOutputs</st></strong><st c="42303">: This method gets called prior to a component receiving new data. </st><st c="42371">This method is optional in the code </st><span class="No-Break"><st c="42407">implementation file.</st></span></li>
				<li><strong class="source-inline"><st c="42427">destroy</st></strong><st c="42435">: This method gets called when the component is to be removed from the DOM tree. </st><st c="42517">It should be used to perform any cleanup operation and release any memory that the component is using. </st><st c="42620">This method is required to be implemented in the code </st><span class="No-Break"><st c="42674">implementation file.</st></span></li>
			</ul>
			<h3><st c="42694">Resource files</st></h3>
			<p><st c="42709">In the manifest file, one of the </st><a id="_idIndexMarker1302"/><st c="42743">nodes that defines code components is </st><strong class="source-inline"><st c="42781">resources</st></strong><st c="42790">. This node holds the information about the code resource, which is our </st><strong class="source-inline"><st c="42862">index.ts</st></strong><st c="42870"> file, which contains code logic. </st><st c="42904">Next to the </st><strong class="source-inline"><st c="42916">code</st></strong><st c="42920"> resource, we have static files that define the visual appearance of the code component. </st><st c="43009">Here we can find a </st><strong class="bold"><st c="43028">Cascading Style Sheets</st></strong><st c="43050"> (</st><strong class="bold"><st c="43052">CSS</st></strong><st c="43055">) file</st><a id="_idIndexMarker1303"/><st c="43062"> that contains code that controls the visual representation of </st><span class="No-Break"><st c="43125">the component.</st></span></p>
			<p><st c="43139">Since code components can be reused across applications and environments, support for localization is beneficial, as it allows us to share components across applications where there might be other language requirements. </st><st c="43360">The PCF supports localization. </st><st c="43391">Localized strings can be stored in RESX web resource files and registered in the manifest file. </st><st c="43487">Other files, for images, icons, or anything else that is required for the component to work properly, can be added. </st><st c="43603">Files are usually stored in a separate folder structure, registered in the manifest file, and referenced in the </st><span class="No-Break"><st c="43715">code logic.</st></span></p>
			<p><st c="43726">Now that we have learned what the file structure of the code components looks like, let us go ahead and create our simple </st><span class="No-Break"><st c="43849">code component.</st></span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor196"/><st c="43864">Creating your code component</st></h2>
			<p><st c="43893">In this exercise, we will be creating a </st><a id="_idIndexMarker1304"/><st c="43934">virtual (React) control type, since this will be the recommended control type </st><span class="No-Break"><st c="44012">going forward.</st></span></p>
			<h3><st c="44026">Prerequisites</st></h3>
			<p><st c="44040">In order to build the code </st><a id="_idIndexMarker1305"/><st c="44068">component, we need to have installed the tools mentioned in the </st><em class="italic"><st c="44132">Technical </st></em><span class="No-Break"><em class="italic"><st c="44142">requirements</st></em></span><span class="No-Break"><st c="44154"> section.</st></span></p>
			<p><st c="44163">To get the .NET build tools, Visual Studio 2019 or higher (Visual Studio 2022) should be installed. </st><st c="44264">Instead of installing the complete Visual Studio, we can select just the .NET build tools as the workload during the installation wizard. </st><st c="44402">An alternative to this is to install the .NET 8.0 SDK. </st><st c="44457">Currently, .NET 8.0 is the latest long-term </st><span class="No-Break"><st c="44501">support version.</st></span></p>
			<h3><st c="44517">Initializing the project</st></h3>
			<p><st c="44542">First, we need to initialize the </st><a id="_idIndexMarker1306"/><st c="44576">project. </st><st c="44585">For this, we will be using the PAC CLI and its set of commands specific to the PCF. </st><st c="44669">We can achieve this using the </st><span class="No-Break"><st c="44699">following command:</st></span></p>
			<pre class="source-code"><st c="44717">
pac pcf init --name &lt;COMPONENT_NAME&gt; --namespace &lt;COMPONENT_NAMESPACE&gt; --template &lt;COMPONENT_TYPE&gt; --framework &lt;RENDERING_FRAMEWORK&gt; -npm</st></pre>			<p><st c="44855">Two parameters stand out – </st><strong class="source-inline"><st c="44883">template</st></strong><st c="44891"> and </st><strong class="source-inline"><st c="44896">framework</st></strong><st c="44905">. Now, </st><strong class="source-inline"><st c="44912">template</st></strong><st c="44920"> describes whether we will be creating a code component that will be used with fields or datasets. </st><strong class="source-inline"><st c="45019">framework</st></strong><st c="45028"> defines which framework will we be using. </st><st c="45071">If using </st><strong class="source-inline"><st c="45080">React</st></strong><st c="45085">, then this will be marked as a virtual control type; otherwise, it will be a standard control type. </st><st c="45186">If we do not provide a </st><strong class="source-inline"><st c="45209">--run-npm-install</st></strong><st c="45226"> or </st><strong class="source-inline"><st c="45230">--npm</st></strong><st c="45235"> switch in the command, we will need to run the </st><strong class="source-inline"><st c="45283">npm install</st></strong><st c="45294"> command separately, to install the </st><span class="No-Break"><st c="45330">project dependencies.</st></span></p>
			<p><st c="45351">In our example, we used the </st><a id="_idIndexMarker1307"/><st c="45380">following command to initialize the project of a folder structure with some </st><span class="No-Break"><st c="45456">supporting files:</st></span></p>
			<pre class="console"><st c="45473">
pac pcf init --name SimpleReactPCF --namespace SimpleReactNS --template field --framework react -npm</st></pre>			<p><st c="45574">Here is the </st><span class="No-Break"><st c="45587">folder structure:</st></span></p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B22208_10_10.jpg" alt="Figure 10.10 – Folder structure of the PCF initialized project"/><st c="45604"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="45716">Figure 10.10 – Folder structure of the PCF initialized project</st></p>
			<p><st c="45778">Now that we have initialized the project and have files and a folder structure, we can move on to start implementing the </st><span class="No-Break"><st c="45900">code logic.</st></span></p>
			<h3><st c="45911">Implementing the code component</st></h3>
			<p><st c="45943">As we can see in the</st><a id="_idIndexMarker1308"/><st c="45964"> folder structure of our code component, our manifest file is also present in the </st><span class="No-Break"><st c="46046">PCF project.</st></span></p>
			<p><st c="46058">Inside the </st><strong class="source-inline"><st c="46070">ControlManifest.Input.xml</st></strong><st c="46095"> file, we can see the </st><strong class="source-inline"><st c="46117">control</st></strong><st c="46124"> element, which includes information about our code component, including the control type being set </st><span class="No-Break"><st c="46224">to </st></span><span class="No-Break"><strong class="source-inline"><st c="46227">virtual</st></strong></span><span class="No-Break"><st c="46234">:</st></span></p>
			<pre class="console"><st c="46236">
&lt;control namespace="SimpleReactNS" constructor="SimpleReactPCF" version="0.0.1" display-name-key="SimpleReactPCF" description-key="SimpleReactPCF description" </st><strong class="bold"><st c="46396">control-type="virtual"</st></strong><st c="46418"> &gt;</st></pre>			<p><st c="46420">Another part of the manifest file is the </st><strong class="source-inline"><st c="46461">property</st></strong><st c="46469"> node, where we can have multiple properties for our </st><span class="No-Break"><st c="46522">code components.</st></span></p>
			<p><st c="46538">We will change the property from </st><strong class="source-inline"><st c="46572">SingleLine.Text</st></strong><st c="46587"> to a number (</st><strong class="source-inline"><st c="46601">Whole.None</st></strong><st c="46612">) by changing the </st><span class="No-Break"><st c="46631">highlighted property:</st></span></p>
			<pre class="console"><st c="46652">
&lt;property name="sampleProperty" display-name-key="Property_Display_Key" description-key="Property_Desc_Key" </st><strong class="bold"><st c="46761">of-type="Whole.None"</st></strong><st c="46781"> usage="bound" required="true" /&gt;</st></pre>			<p><st c="46814">During this step, extensive coding may be done to develop the PCF component. </st><st c="46892">Making changes to the code of the component requires knowledge of TypeScript </st><span class="No-Break"><st c="46969">and React.</st></span></p>
			<h3><st c="46979">Debugging a developed code component</st></h3>
			<p><st c="47016">With a simple </st><strong class="source-inline"><st c="47031">npm start watch</st></strong><st c="47046"> command, we can run the project in debugging mode, which opens </st><a id="_idIndexMarker1309"/><st c="47110">a browser with our local PCF </st><a id="_idIndexMarker1310"/><st c="47139">test environment. </st><st c="47157">On the right side of the test application, we can see all the configured data properties that are specified in the manifest file, as shown in </st><span class="No-Break"><em class="italic"><st c="47299">Figure 10</st></em></span><em class="italic"><st c="47308">.11</st></em><st c="47311">. Here we can adjust the values of the properties and check whether the state of the code component reflects the </st><span class="No-Break"><st c="47424">desired behavior.</st></span></p>
			<p><st c="47441">Additionally, we</st><a id="_idIndexMarker1311"/><st c="47458"> can use the test environment</st><a id="_idIndexMarker1312"/><st c="47487"> to understand how our code component adjusts to different screen sizes. </st><st c="47560">We can use the </st><strong class="bold"><st c="47575">Form Factor</st></strong><st c="47586"> settings as well as </st><strong class="bold"><st c="47607">Component Container Width</st></strong><st c="47632"> and </st><strong class="bold"><st c="47637">Co</st><a id="_idTextAnchor197"/><a id="_idTextAnchor198"/><st c="47639">mponent Container Height</st></strong><st c="47664"> to adjust the </st><span class="No-Break"><st c="47679">screen size:</st></span></p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B22208_10_11.jpg" alt="Figure 10.11 – The PCF test environment"/><st c="47691"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="47867">Figure 10.11 – The PCF test environment</st></p>
			<h3><st c="47906">Packaging the code component</st></h3>
			<p><st c="47935">Code components can </st><a id="_idIndexMarker1313"/><st c="47956">be added to solutions to enable reusability across environments. </st><st c="48021">If we already have solutions available, we can simply upload the code component to the solution using the </st><strong class="source-inline"><st c="48127">pac pcf push</st></strong><st c="48139"> command, as shown in the next section. </st><st c="48179">In other cases, we can utilize a set of commands to first create a solution and then add a reference to </st><span class="No-Break"><st c="48283">that solution.</st></span></p>
			<p><st c="48297">We will be adding a reference for our code component project to a newly created solution project. </st><st c="48396">The solution project (</st><strong class="source-inline"><st c="48418">cdsproj</st></strong><st c="48426">) can contain multiple code component references, while the code component project can only contain a single code component. </st><st c="48552">Adding references to multiple code components within a single solution project allows us to reference all the code components required for a particular business solution. </st><st c="48723">They can also be packaged together with other solution objects </st><span class="No-Break"><st c="48786">if needed.</st></span></p>
			<p><st c="48796">First, we will initialize a solution using the </st><span class="No-Break"><st c="48844">following command:</st></span></p>
			<pre class="source-code"><st c="48862">
pac solution init</st></pre>			<p><st c="48880">Then we will add a reference to the code </st><span class="No-Break"><st c="48922">component project:</st></span></p>
			<pre class="source-code"><st c="48940">
pac solution add-reference --path &lt;LOCATION_TO_PCFPROJ_FILE&gt;</st></pre>			<p><st c="49001">This will create a reference inside the </st><strong class="source-inline"><st c="49042">.cdsproj</st></strong><st c="49050"> file, </st><span class="No-Break"><st c="49057">like this:</st></span></p>
			<pre class="console"><st c="49067">
  &lt;ItemGroup&gt;
    &lt;ProjectReference Include="..\SamPCF\SamPCF.pcfproj" /&gt;
  &lt;/ItemGroup&gt;</st></pre>			<p><st c="49148">When we are ready to generate a ZIP file from the solution project, we can use </st><span class="No-Break"><st c="49228">the following:</st></span></p>
			<pre class="source-code"><st c="49242">
dotnet build /t:build /restore</st></pre>			<p><st c="49273">This will restore all code component projects that are referenced in the solution project and build the project. </st><st c="49387">The final outcome of the process is a ZIP package artifact that can be imported with the code components solutions. </st><st c="49503">Such a solution can now be imported into the </st><span class="No-Break"><st c="49548">downstream environment.</st></span></p>
			<p><st c="49571">If we have a </st><a id="_idIndexMarker1314"/><st c="49585">business application in another solution that is referencing our code components, we need to make sure that the solution with the code components is deployed to the environment first, before importing the business application that </st><span class="No-Break"><st c="49816">references them.</st></span></p>
			<h3><st c="49832">Importing the solution into Power Platform</st></h3>
			<p><st c="49875">Importing the solution into</st><a id="_idIndexMarker1315"/><st c="49903"> Power Platform (Dataverse) can be done manually using the Power Platform web portal or the </st><strong class="source-inline"><st c="49995">pac pcf push</st></strong><st c="50007"> command. </st><st c="50017">It can also be done automatically using Power Platform Build Tools and the DevOps tool of choice. </st><st c="50115">In the next section, we will take a look at how this can be done automatically. </st><st c="50195">In this section, we will complete the </st><span class="No-Break"><st c="50233">process manually.</st></span></p>
			<p><st c="50250">First, we should make sure that we are in the right Dataverse environment. </st><st c="50326">To select the right environment, we can proceed with </st><strong class="source-inline"><st c="50379">pac env list</st></strong><st c="50391"> and </st><strong class="source-inline"><st c="50396">pac env select -env &lt;ENVIRONMENT_ID&gt;</st></strong><st c="50432">. After confirming the environment, we can proceed with the </st><span class="No-Break"><strong class="source-inline"><st c="50492">push</st></strong></span><span class="No-Break"><st c="50496"> command.</st></span></p>
			<p><st c="50505">It is worth noting that the </st><strong class="source-inline"><st c="50534">pac pcf push</st></strong><st c="50546"> command also has a </st><strong class="source-inline"><st c="50566">-env</st></strong><st c="50570"> setting, which allows us to push to a selected environment if we are operating across </st><span class="No-Break"><st c="50657">multiple environments.</st></span></p>
			<p><st c="50679">As we are</st><a id="_idIndexMarker1316"/><st c="50689"> still in the folder of our code component, we can run the command, in which we can either use a publisher prefix from our environment or the unique name of our solution. </st><st c="50860">In both cases, the PAC CLI will check whether the publisher or solution already exists. </st><st c="50948">If it does, it will use it to push the component – here is </st><span class="No-Break"><st c="51007">one option:</st></span></p>
			<pre class="source-code"><st c="51018">
pac pcf push –solution-unique-name &lt;SOLUTION_NAME&gt;</st></pre>			<p><st c="51069">Here is </st><span class="No-Break"><st c="51078">the other:</st></span></p>
			<pre class="source-code"><st c="51088">
pac pcf push -pp &lt;PUBLISHER_PREFIX&gt;</st></pre>			<p><st c="51124">Without the name of the solution, this code component will be imported to a temporary </st><span class="No-Break"><strong class="source-inline"><st c="51211">PowerAppsTools_&lt;prefix&gt;</st></strong></span><span class="No-Break"><st c="51234"> solution.</st></span></p>
			<h3><st c="51244">Preparing the component for release</st></h3>
			<p><st c="51280">When preparing our</st><a id="_idIndexMarker1317"/><st c="51299"> code component for release to the production environment, we should add the </st><strong class="source-inline"><st c="51376">&lt;PcfBuildMode&gt;production&lt;/PcfBuildMode&gt;</st></strong><st c="51415"> property inside the </st><strong class="source-inline"><st c="51436">pcfproj</st></strong><st c="51443"> file underneath </st><strong class="source-inline"><st c="51460">OutputPath</st></strong><st c="51470">, as in the </st><span class="No-Break"><st c="51482">following example:</st></span></p>
			<pre class="console"><st c="51500">
&lt;PropertyGroup&gt;
    &lt;Name&gt;PCF&lt;/Name&gt;
    &lt;ProjectGuid&gt;e71d2e10-908c-4123-9f29-3283cbd224ab&lt;/ProjectGuid&gt;
    &lt;OutputPath&gt;$(MSBuildThisFileDirectory)out\controls&lt;/OutputPath&gt;
    &lt;PcfBuildMode&gt;production&lt;/PcfBuildMode&gt;
  &lt;/PropertyGroup&gt;</st></pre>			<p><st c="51719">Development mode produces a larger bundle that holds debugging information, which might impact performance in production. </st><st c="51842">This is why the change should be made to the </st><strong class="source-inline"><st c="51887">pcfproj</st></strong><st c="51894"> file before building and deploying </st><span class="No-Break"><st c="51930">to production.</st></span></p>
			<p><st c="51944">Additionally, when </st><a id="_idIndexMarker1318"/><st c="51964">preparing the solution project, </st><strong class="source-inline"><st c="51996">SolutionPackagerType</st></strong><st c="52016">, which is part of </st><strong class="source-inline"><st c="52035">PropertyGroup</st></strong><st c="52048"> in the </st><strong class="source-inline"><st c="52056">cdsproj</st></strong><st c="52063"> file, defines the solution type, stating whether we would like to go for managed, unmanaged, or both </st><span class="No-Break"><st c="52165">solution types:</st></span></p>
			<pre class="console"><st c="52180">
&lt;PropertyGroup&gt;
    &lt;SolutionPackageType&gt;Managed&lt;/SolutionPackageType&gt;
 &lt;/PropertyGroup&gt;</st></pre>			<p><st c="52264">When running the </st><strong class="source-inline"><st c="52282">dotnet build</st></strong><st c="52294"> command, this information will be taken to generate a ZIP file of the defined solution type. </st><st c="52388">When we are preparing for release to production, we can use </st><strong class="source-inline"><st c="52448">dotnet build /p:configuration=Release</st></strong><st c="52485"> to create a release build for the selected </st><span class="No-Break"><st c="52529">solution type.</st></span></p>
			<h3><st c="52543">Adding code components to applications</st></h3>
			<p><st c="52582">Code components can be used across canvas applications, model-driven apps, and websites. </st><st c="52672">The following are some examples of adding components </st><span class="No-Break"><st c="52725">to apps.</st></span></p>
			<h4><st c="52733">Model-driven apps</st></h4>
			<p><st c="52751">Adding components to </st><a id="_idIndexMarker1319"/><st c="52773">model-driven apps</st><a id="_idIndexMarker1320"/><st c="52790"> is </st><span class="No-Break"><st c="52794">very easy:</st></span></p>
			<ol>
				<li><st c="52804">When editing the form, click on </st><strong class="bold"><st c="52837">Components</st></strong><st c="52847"> in the left navigation bar and click </st><strong class="bold"><st c="52885">Get </st></strong><span class="No-Break"><strong class="bold"><st c="52889">more components</st></strong></span><span class="No-Break"><st c="52904">.</st></span></li>
				<li><st c="52905">This will</st><a id="_idIndexMarker1321"/><st c="52915"> open a </st><strong class="bold"><st c="52923">Get more components</st></strong><st c="52942"> sidebar, where newly created code components will appear. </st><st c="53001">Select the </st><a id="_idIndexMarker1322"/><st c="53012">necessary components and click </st><strong class="bold"><st c="53043">Add</st></strong><st c="53046">, as can be seen in </st><span class="No-Break"><em class="italic"><st c="53066">Figure 10</st></em></span><span class="No-Break"><em class="italic"><st c="53075">.12</st></em></span><span class="No-Break"><st c="53078">:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B22208_10_12.jpg" alt="Figure 10.12 – Adding code component to a form in a model-driven app"/><st c="53080"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="53866">Figure 10.12 – Adding code component to a form in a model-driven app</st></p>
			<ol>
				<li value="3"><st c="53934">After adding the code components to the list of components, they appear under the </st><strong class="bold"><st c="54017">More components</st></strong><st c="54032"> group inside the </st><strong class="bold"><st c="54050">Components</st></strong><st c="54060"> option. </st><st c="54069">Simply drag and drop the components to the right places in the form and connect the component values with the </st><span class="No-Break"><st c="54179">correct values.</st></span></li>
			</ol>
			<h4><st c="54194">Canvas apps</st></h4>
			<p><st c="54206">Adding code </st><a id="_idIndexMarker1323"/><st c="54219">components to </st><a id="_idIndexMarker1324"/><st c="54233">canvas applications has to be enabled before it’s possible. </st><st c="54293">The setting for enabling it is currently available in the Power Platform </st><span class="No-Break"><st c="54366">admin center:</st></span></p>
			<ol>
				<li><st c="54379">Go to </st><strong class="bold"><st c="54386">Environments</st></strong><st c="54398">, select the environment, and then click </st><strong class="bold"><st c="54439">Settings</st></strong><st c="54447"> | </st><strong class="bold"><st c="54450">Product</st></strong><st c="54457"> | </st><span class="No-Break"><strong class="bold"><st c="54460">Features</st></strong></span><span class="No-Break"><st c="54468">.</st></span></li>
				<li><st c="54469">Here we will find the </st><strong class="bold"><st c="54492">Power Apps component framework for canvas apps</st></strong><st c="54538"> setting, which is turned off by default. </st><st c="54580">If needed, </st><span class="No-Break"><st c="54591">enable it.</st></span></li>
				<li><st c="54601">Once done, we can</st><a id="_idIndexMarker1325"/><st c="54619"> go to our canvas application and click </st><strong class="bold"><st c="54659">Insert</st></strong><st c="54665"> to see a list of all controls. </st><st c="54697">Then we can proceed to the </st><strong class="bold"><st c="54724">Code</st></strong><st c="54728"> tab, sele</st><a id="_idTextAnchor199"/><st c="54738">ct </st><a id="_idIndexMarker1326"/><st c="54742">the components, and click </st><strong class="bold"><st c="54768">Import</st></strong><st c="54774">, as shown in </st><span class="No-Break"><em class="italic"><st c="54788">Figure 10</st></em></span><span class="No-Break"><em class="italic"><st c="54797">.13</st></em></span><span class="No-Break"><st c="54800">.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/B22208_10_13.jpg" alt="Figure 10.13 – Adding a code component to the canvas app"/><st c="54801"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="55336">Figure 10.13 – Adding a code component to the canvas app</st></p>
			<h4><st c="55392">Power Pages</st></h4>
			<p><st c="55404">Adding code components to </st><a id="_idIndexMarker1327"/><st c="55431">Power Pages</st><a id="_idIndexMarker1328"/><st c="55442"> is similar to the process of doing so for </st><span class="No-Break"><st c="55485">model-driven apps:</st></span></p>
			<ol>
				<li><st c="55503">Your components can be found by going to </st><strong class="bold"><st c="55545">Data</st></strong><st c="55549"> in the left </st><span class="No-Break"><st c="55562">navigation bar.</st></span></li>
				<li><st c="55577">Select the table of choice, click </st><strong class="bold"><st c="55612">Forms</st></strong><st c="55617"> (or </st><strong class="bold"><st c="55622">V</st><a id="_idTextAnchor200"/><st c="55623">iews</st></strong><st c="55627">, depending on the use case), and click </st><strong class="bold"><st c="55667">Get </st></strong><span class="No-Break"><strong class="bold"><st c="55671">more components</st></strong></span><span class="No-Break"><st c="55686">.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/B22208_10_14.jpg" alt="Figure 10.14 – Adding code components in Power Pages"/><st c="55687"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="56268">Figure 10.14 – Adding code components in Power Pages</st></p>
			<ol>
				<li value="3"><st c="56320">This will open a</st><a id="_idIndexMarker1329"/><st c="56337"> sidebar to help you find a custom </st><a id="_idIndexMarker1330"/><st c="56372">code component. </st><st c="56388">Select the one you require and click </st><strong class="bold"><st c="56425">Add</st></strong><st c="56428">, as can be seen in </st><span class="No-Break"><em class="italic"><st c="56448">Figure 10</st></em></span><span class="No-Break"><em class="italic"><st c="56457">.14.</st></em></span></li>
			</ol>
			<p><st c="56461">Now that we have learned how code components are created and added to an application, let’s understand how the application life cycle is managed for </st><span class="No-Break"><st c="56611">these components.</st></span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor201"/><st c="56628">ALM for code components</st></h2>
			<p><st c="56652">As we saw in the </st><a id="_idIndexMarker1331"/><st c="56670">previous section, the development life cycle of a code component consists of the </st><span class="No-Break"><st c="56751">following steps:</st></span></p>
			<ol>
				<li><st c="56767">The initialization of the </st><span class="No-Break"><st c="56794">PCF project</st></span></li>
				<li><st c="56805">Working on the code </st><span class="No-Break"><st c="56826">component’s implementation</st></span></li>
				<li><st c="56852">Testing/local debugging of the developed code component and pushing it to the Power Platform </st><span class="No-Break"><st c="56946">development environment</st></span></li>
				<li><st c="56969">Adding the component project reference to the solution in the </st><span class="No-Break"><st c="57032">development environment</st></span></li>
				<li><st c="57055">Testing the business solution with the included </st><span class="No-Break"><st c="57104">code components</st></span></li>
				<li><st c="57119">Preparing the code component </st><span class="No-Break"><st c="57149">for release</st></span></li>
				<li><st c="57160">Importing the solution to other environments </st><span class="No-Break"><st c="57206">and testing</st></span></li>
			</ol>
			<p><st c="57217">We recommend building automated pipelines by leveraging Power Platform Build Tools in Azure DevOps or GitHub, together with the PAC CLI, to perform these </st><span class="No-Break"><st c="57372">tasks automatically.</st></span></p>
			<p><st c="57392">As with any other development project, when developing code components, it is also recommended that developers use a source code repository, such as GitHub or Azure DevOps, from the beginning, in which to collaborate. </st><st c="57611">Using </st><strong class="source-inline"><st c="57617">pac pcf init</st></strong><st c="57629"> also creates a </st><strong class="source-inline"><st c="57645">.gitignore</st></strong><st c="57655"> file, which instructs the version control system as to which files and folders should be left out since they will be either created or restored during the </st><span class="No-Break"><st c="57811">build process.</st></span></p>
			<p><st c="57825">It is worth noting that when we have a code component in a solution, we can export the solution together with the code component using Power Platform Build Tools or </st><strong class="source-inline"><st c="57991">SolutionPackager /action: Extract</st></strong><st c="58024">, which incrementally exports changes to the solution metadata. </st><st c="58088">When a code component is extracted from a solution package, a </st><strong class="source-inline"><st c="58150">Controls</st></strong><st c="58158"> subfolder will be created for each code component that is included in </st><span class="No-Break"><st c="58229">the solution.</st></span></p>
			<p><st c="58242">Using </st><strong class="source-inline"><st c="58249">pac pcf push</st></strong><st c="58261"> to push a</st><a id="_idIndexMarker1332"/><st c="58271"> code component to an environment, and then using commands such as </st><strong class="source-inline"><st c="58338">msbuild</st></strong><st c="58345"> and </st><strong class="source-inline"><st c="58350">SolutionPackage /action: Pack</st></strong><st c="58379"> to build a solution, allows us to build and repack the solution and make it ready </st><span class="No-Break"><st c="58462">for import.</st></span></p>
			<h3><st c="58473">Solution strategy for code components</st></h3>
			<p><st c="58511">Another consideration</st><a id="_idIndexMarker1333"/><st c="58533"> with code components is the solution strategy. </st><st c="58581">As we have learned, our business applications can have dependencies on various solution components. </st><st c="58681">Power Platform allows us to deploy components together, as part of</st><a id="_idIndexMarker1334"/><st c="58747"> a </st><strong class="bold"><st c="58750">single solution</st></strong><st c="58765">, or separately, in </st><strong class="bold"><st c="58785">segmented solutions</st></strong><st c="58804">, where</st><a id="_idIndexMarker1335"/><st c="58811"> functionalities of our business applications are split between </st><span class="No-Break"><st c="58875">multiple solutions.</st></span></p>
			<p><st c="58894">The segmented approach allows us to be more agile with the development approach of our business solution. </st><st c="59001">Teams can each focus on their own parts of the business solution and can develop and test independently of the final solution. </st><st c="59128">Such an approach allows us to decouple and share code components between multiple applications and across environments. </st><st c="59248">Single solutions have everything in one solution, which means that it is important to follow a good branching strategy if you want to have control over updates to the </st><span class="No-Break"><st c="59415">complete solution.</st></span></p>
			<h3><st c="59433">Versioning and updates to code components</st></h3>
			<p><st c="59475">Whenever we</st><a id="_idIndexMarker1336"/><st c="59487"> deliver changes to our code components that should be </st><a id="_idIndexMarker1337"/><st c="59542">pushed to our business applications, we should make sure that we follow the standard versioning strategy (</st><strong class="source-inline"><st c="59648">MAJOR.MINOR.PATCH</st></strong><st c="59666">), which will ensure that Power Apps applications detect and update dependencies to the </st><span class="No-Break"><st c="59755">latest version.</st></span></p>
			<p><st c="59770">Inside the manifest file (</st><strong class="source-inline"><st c="59797">ControlManifest.Input.Xml</st></strong><st c="59823">), under the </st><strong class="source-inline"><st c="59837">control</st></strong><st c="59844"> element, there is a </st><strong class="source-inline"><st c="59865">version</st></strong><st c="59872"> property that should get at least a </st><strong class="source-inline"><st c="59909">PATCH</st></strong><st c="59914"> version increase whenever an update to a code component is deployed. </st><st c="59984">This will ensure that the change can be detected and that both canvas and model-driven apps will receive the latest version of </st><span class="No-Break"><st c="60111">the component:</st></span></p>
			<pre class="console"><st c="60125">
&lt;control namespace="SimpleReactNS" constructor="SimpleReactPCF" </st><strong class="bold"><st c="60190">version="0.0.1"</st></strong><st c="60205"> display-name-key="SimpleReactPCF" description-key="SimpleReactPCF description" control-type="virtual" &gt;</st></pre>			<p><st c="60309">An increase of the version can be done manually by changing the number in the manifest file, or it can be done automatically with the </st><span class="No-Break"><st c="60444">following command:</st></span></p>
			<pre class="source-code"><st c="60462">
pac pcf version --strategy manifest</st></pre>			<p><st c="60498">There are also other strategies, such as </st><strong class="source-inline"><st c="60540">gittags</st></strong><st c="60547">; however, the manifest strategy is by far the simplest, since it does </st><span class="No-Break"><st c="60619">everything automatically.</st></span></p>
			<p><st c="60644">If we would like to specify the exact value of a version, we can do </st><span class="No-Break"><st c="60713">the following:</st></span></p>
			<pre class="source-code"><st c="60727">
pac pcf version --patchversion &lt;PATCH VERSION&gt;</st></pre>			<p><strong class="source-inline"><st c="60774">MAJOR</st></strong><st c="60780"> and </st><strong class="source-inline"><st c="60785">MINOR</st></strong><st c="60790"> versions</st><a id="_idIndexMarker1338"/><st c="60799"> should be aligned with the version of our</st><a id="_idIndexMarker1339"/><st c="60841"> Dataverse solution. </st><st c="60862">If a significant change is made to a solution, then the </st><strong class="source-inline"><st c="60918">MAJOR</st></strong><st c="60923"> and/or </st><strong class="source-inline"><st c="60931">MINOR</st></strong><st c="60936"> version of the Dataverse solution should be incremented, which should lead also to incrementing the </st><strong class="source-inline"><st c="61037">MAJOR</st></strong><st c="61042"> and/or </st><strong class="source-inline"><st c="61050">MINOR</st></strong><st c="61055"> version of the </st><span class="No-Break"><st c="61071">code component.</st></span></p>
			<p class="callout-heading"><st c="61086">Code component updates for canvas apps</st></p>
			<p class="callout"><st c="61125">In order to update a code component to a newer version inside canvas applications, app makers must open the canvas app in Power Apps Studio and click </st><strong class="bold"><st c="61276">Update</st></strong><st c="61282"> on the </st><strong class="bold"><st c="61290">Update code components</st></strong><st c="61312"> popup. </st><st c="61320">If the update is not done, then the canvas app will continue to use the old version of the </st><span class="No-Break"><st c="61411">code component.</st></span></p>
			<h3><st c="61426">Automated build pipelines for segmented solutions</st></h3>
			<p><st c="61476">To create a code</st><a id="_idIndexMarker1340"/><st c="61493"> component from scratch and keep control over it, we start by creating the code component locally and committing the changes to the </st><span class="No-Break"><st c="61625">Git repository:</st></span></p>
			<ol>
				<li><st c="61640">Using the </st><strong class="source-inline"><st c="61651">pac pcf init</st></strong><st c="61663"> command, we will create a </st><strong class="source-inline"><st c="61690">pcfproj</st></strong><st c="61697"> folder. </st><st c="61706">Once the project is created, we will be committing the changes to the Git repository. </st><st c="61792">Using </st><strong class="source-inline"><st c="61798">pac pcf push</st></strong><st c="61810">, we will deploy our code component to </st><span class="No-Break"><st c="61849">the environment.</st></span></li>
				<li><st c="61865">Separately, we will be creating a solution project using </st><strong class="source-inline"><st c="61923">pac solution init</st></strong><st c="61940">, to create a new blank solution, or </st><strong class="source-inline"><st c="61977">pac solution clone</st></strong><st c="61995">, if we already have a solution that we would like to reuse. </st><st c="62056">The solution is also version-controlled in the </st><span class="No-Break"><st c="62103">Git repository.</st></span></li>
				<li><st c="62118">Next, we need to add a reference to the solution using the </st><strong class="source-inline"><st c="62178">pac solution add-reference</st></strong><st c="62204"> command with the path to our PCF </st><span class="No-Break"><st c="62238">component project.</st></span></li>
				<li><st c="62256">Now we need to update the solution version in </st><strong class="source-inline"><st c="62303">Solution.xml</st></strong><st c="62315"> to reflect the version of the current build. </st><st c="62361">This can be done by formulating the </st><strong class="source-inline"><st c="62397">MAJOR.MINOR.BUILD.REVISION</st></strong><st c="62423"> version with the variables in Azure DevOps/GitHub. </st><st c="62475">For </st><strong class="source-inline"><st c="62479">MAJOR</st></strong><st c="62484">, we can create </st><strong class="source-inline"><st c="62500">$(majorVersion)</st></strong><st c="62515"> variables; for </st><strong class="source-inline"><st c="62531">MINOR</st></strong><st c="62536">, we can create </st><strong class="source-inline"><st c="62552">$(minorVersion)</st></strong><st c="62567"> variables; for </st><strong class="source-inline"><st c="62583">BUILD</st></strong><st c="62588">, we can use the predefined </st><strong class="source-inline"><st c="62616">$(Build.BuildId)</st></strong><st c="62632">; and for </st><strong class="source-inline"><st c="62643">REVISION</st></strong><st c="62651">, we can </st><span class="No-Break"><st c="62660">use </st></span><span class="No-Break"><strong class="source-inline"><st c="62664">$(Rev:r)</st></strong></span><span class="No-Break"><st c="62672">.</st></span></li>
				<li><st c="62673">We will also need to change the version value </st><span class="No-Break"><st c="62720">inside </st></span><span class="No-Break"><strong class="source-inline"><st c="62727">ControlManifest.Input.xml</st></strong></span><span class="No-Break"><st c="62752">.</st></span></li>
				<li><st c="62753">Once the version numbers are updated, we can run a task, as part of our build pipeline, using the </st><strong class="source-inline"><st c="62852">dotnet build /restore /p:configuration=Release</st></strong><st c="62898"> command (or </st><strong class="source-inline"><st c="62911">msbuild</st></strong><st c="62918">, depending on what tools are we using). </st><st c="62959">We </st><a id="_idIndexMarker1341"/><st c="62962">configure the task in a way that means it builds only the </st><strong class="source-inline"><st c="63020">cdsproj</st></strong><st c="63027"> project. </st><st c="63037">We can achieve this by setting the </st><strong class="source-inline"><st c="63072">*.</st></strong><span class="No-Break"><strong class="source-inline"><st c="63074">cdsproj</st></strong></span><span class="No-Break"><st c="63082"> wildcard.</st></span></li>
			</ol>
			<p><st c="63092">Once the build has been completed, we will store the produced ZIP file in the pipeline release artifact using a </st><strong class="bold"><st c="63205">Copy file</st></strong><st c="63214"> task, which can be used for deployment. </st><st c="63255">The deployment process is the same as with other solution </st><span class="No-Break"><st c="63313">import processes.</st></span></p>
			<h3><st c="63330">Automated build pipelines for single mixed solutions</st></h3>
			<p><st c="63383">The single </st><a id="_idIndexMarker1342"/><st c="63395">mixed solutions approach needs to be configured in the solution object explorer, where all the required solution components are added. </st><st c="63530">Then, we utilize </st><strong class="source-inline"><st c="63547">SolutionPackager /action: Extract</st></strong><st c="63580"> to extract the components into the source control system. </st><st c="63639">Just as earlier, we need to update the solution version in </st><strong class="source-inline"><st c="63698">Solution.xml</st></strong><st c="63710"> to reflect the version of the current build. </st><st c="63756">We also need to change the version value </st><span class="No-Break"><st c="63797">inside </st></span><span class="No-Break"><strong class="source-inline"><st c="63804">ControlManifest.Input.xml</st></strong></span><span class="No-Break"><st c="63829">.</st></span></p>
			<p><st c="63830">We will add a task to the pipeline called </st><strong class="bold"><st c="63873">Power Platform </st></strong><span class="No-Break"><strong class="bold"><st c="63888">Tool Installer</st></strong></span><span class="No-Break"><st c="63902">.</st></span></p>
			<p><st c="63903">Next, we will restore </st><strong class="source-inline"><st c="63926">node_modules</st></strong><st c="63938"> using </st><strong class="source-inline"><st c="63945">npm task</st></strong><st c="63953"> with the </st><strong class="source-inline"><st c="63963">npm ci</st></strong><st c="63969"> command. </st><st c="63979">For the production release mode, we will use </st><strong class="source-inline"><st c="64024">npm task</st></strong><st c="64032"> with a custom command parameter: </st><strong class="source-inline"><st c="64066">npm run build -- --buildMode release</st></strong><st c="64102">. The output of the build needs to be stored separately in a folder. </st><st c="64171">Then we will use a </st><strong class="bold"><st c="64190">Power Platform Pack Solution</st></strong><st c="64218"> task or </st><strong class="source-inline"><st c="64227">SolutionPackager /action: Pack</st></strong><st c="64257"> to package the files and collect the</st><a id="_idIndexMarker1343"/><st c="64294"> built solution ZIP in the </st><span class="No-Break"><st c="64321">pipeline artifact.</st></span></p>
			<p class="callout-heading"><st c="64339">More information on ALM for PCF components</st></p>
			<p class="callout"><st c="64382">To support this section, we recommend visiting the documentation on ALM for PCF components</st><a id="_idIndexMarker1344"/> <span class="No-Break"><st c="64473">here: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/developer/component-framework/code-components-alm"><span class="No-Break"><st c="64480">https://learn.microsoft.com/en-us/power-apps/developer/component-framework/code-components-alm</st></span></a><span class="No-Break"><st c="64574">.</st></span></p>
			<p><st c="64575">We have mentioned many times that code components can also be used with Power Pages. </st><st c="64661">Since Power Pages allows developers to extend websites greatly with custom code, it is important to take a look at how we can apply ALM to </st><span class="No-Break"><st c="64800">Power Pages.</st></span></p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor202"/><st c="64812">ALM for Power Pages</st></h1>
			<p><st c="64832">Power Pages allows </st><a id="_idIndexMarker1345"/><st c="64852">app makers and professional developers to build engaging, scalable, and secure websites. </st><st c="64941">Since Power Pages websites are built using the HTML, CSS, JavaScript, and Liquid templating languages, developers can follow common web development practices and use known tools, such as Visual Studio Code. </st><st c="65148">Once changes are made to their websites, developers should follow a process of committing those changes to the repository and applying them to different environments. </st><st c="65315">This section focuses on describing how ALM is applied to Power Pages websites. </st><st c="65394">We will take a look at how Power Platform pipelines enable easier and faster configuration of deployment pipelines and how to use Power Platform Build Tools in Azure DevOps to create the pipelines necessary for exporting and importing solutions into </st><span class="No-Break"><st c="65644">different environments.</st></span></p>
			<p><st c="65667">Power Pages was previously known as Power Apps Portals. </st><st c="65724">The older data model, known also as the standard data model, used custom tables to store the configurations of Power Apps Portals websites. </st><st c="65864">As configurations were stored separately, this prevented us from using solutions as was possible with other Power Platform services. </st><st c="65997">However, in the second half of 2023, Microsoft introduced a new and enhanced data model that was built on system tables, non-config tables, and virtual tables. </st><st c="66157">This new approach allows us to contain website configurations in solutions, which simplifies the </st><span class="No-Break"><st c="66254">ALM approach.</st></span></p>
			<p><st c="66267">Information about each site, including whether it uses the enhanced or standard data model, can be found inside the </st><strong class="bold"><st c="66384">Site details</st></strong><st c="66396"> | </st><strong class="bold"><st c="66399">Data model</st></strong><st c="66409"> setting for each website in Power Pages. </st><st c="66451">The same website information can also be found on </st><strong class="bold"><st c="66501">Power Platform Admin center</st></strong><st c="66528"> | </st><strong class="bold"><st c="66531">Resources</st></strong><st c="66540"> | </st><strong class="bold"><st c="66543">Power Pages sites</st></strong><st c="66560">, where you can select a site and then click </st><strong class="bold"><st c="66605">Manage</st></strong><st c="66611">. The information about the data model is found under </st><span class="No-Break"><strong class="bold"><st c="66665">Site Details</st></strong></span><span class="No-Break"><st c="66677">.</st></span></p>
			<p class="callout-heading"><st c="66678">Migrating from the standard model to the enhanced data model</st></p>
			<p class="callout"><st c="66739">Although all newly created sites in Power Pages use the enhanced data model by default, you might still come across legacy Power Pages websites that are built on the standard data model. </st><st c="66927">Customers who have websites that use the previous data model should consider migrating their websites to the new model. </st><st c="67047">The enhanced data model provides benefits over the standard one, such as faster website provisioning, solution support, </st><span class="No-Break"><st c="67167">and ALM.</st></span></p>
			<p class="callout"><st c="67175">Microsoft has introduced a migration guide that helps customers to migrate from one data model to the </st><span class="No-Break"><st c="67278">other: </st></span><a href="https://learn.microsoft.com/en-us/power-pages/admin/migrate-enhanced-data-model"><span class="No-Break"><st c="67285">https://learn.microsoft.com/en-us/power-pages/admin/migrate-enhanced-data-model</st></span></a><span class="No-Break"><st c="67364">.</st></span></p>
			<p><st c="67365">Now that we’ve had a short introduction to Power Pages, we can take a look at how the PAC CLI can support website life </st><span class="No-Break"><st c="67485">cycle management.</st></span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor203"/><st c="67502">Use of the PAC CLI for Power Pages</st></h2>
			<p><st c="67537">The PAC CLI offers tools for</st><a id="_idIndexMarker1346"/><st c="67566"> managing the configuration of Power Pages websites, which includes downloading and uploading website content from and to </st><span class="No-Break"><st c="67688">Power Pages.</st></span></p>
			<p><st c="67700">There are two specific commands that we will be using in this section. </st><st c="67772">The first one is the </st><strong class="source-inline"><st c="67793">pac pages download</st></strong><st c="67811"> command, which is able to download website content from Dataverse. </st><st c="67879">The other one is the </st><strong class="source-inline"><st c="67900">pac pages upload</st></strong><st c="67916"> command, which can upload website content together with all the manifest files and the deployment profile that is appropriate for the </st><span class="No-Break"><st c="68051">target environment.</st></span></p>
			<p><st c="68070">These two commands support ALM for Power Pages and can be used together in our CI/CD pipelines, wherever we are not using Power Platform </st><span class="No-Break"><st c="68208">Build Tools.</st></span></p>
			<h3><st c="68220">Deployment profiles</st></h3>
			<p><st c="68240">A deployment profile</st><a id="_idIndexMarker1347"/><st c="68261"> is a file in YAML format that holds a set of values and settings</st><a id="_idIndexMarker1348"/><st c="68326"> that are relevant to the target environment. </st><st c="68372">Deployment profiles are used in a similar way as deployment settings files are in Power Apps. </st><st c="68466">It is possible to have a deployment profile file for each target environment that we are deploying a website to. </st><st c="68579">Each of these files contains values that match the configuration settings of the </st><span class="No-Break"><st c="68660">target environment.</st></span></p>
			<p><st c="68679">Deployment profiles should be added in the </st><strong class="source-inline"><st c="68723">deployment-profiles</st></strong><st c="68742"> folder, in the root of the downloaded website folder. </st><st c="68797">A new folder will need to be created if it has not been created yet. </st><st c="68866">There we can add the </st><strong class="source-inline"><st c="68887">&lt;</st></strong><span class="No-Break"><strong class="source-inline"><st c="68888">profileTag&gt;.deployment.yml</st></strong></span><span class="No-Break"><st c="68914"> files.</st></span></p>
			<p><st c="68921">These files will then be used later on, during the upload process, with a </st><strong class="source-inline"><st c="68996">--deploymentProfile </st></strong><span class="No-Break"><strong class="source-inline"><st c="69016">test</st></strong></span><span class="No-Break"><st c="69020"> argument:</st></span></p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/B22208_10_15.jpg" alt="Figure 10.15 – Deployment profiles and manifest files in Power Pages"/><st c="69030"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="69446">Figure 10.15 – Deployment profiles and manifest files in Power Pages</st></p>
			<h3><st c="69514">Manifest files</st></h3>
			<p><st c="69529">When downloading a website from Power Pages, the PAC CLI creates two additional manifest files: an environment </st><a id="_idIndexMarker1349"/><st c="69641">manifest file (</st><strong class="source-inline"><st c="69656">org-url-manifest.yml</st></strong><st c="69677">) and a delete-tracking manifest file (</st><strong class="source-inline"><st c="69717">manifest.yml</st></strong><st c="69730">). </st><st c="69734">Both files are in YAML format and stored with the </st><strong class="source-inline"><st c="69784">.portalconfig</st></strong><st c="69797"> root folder structure of the </st><span class="No-Break"><st c="69827">downloaded website.</st></span></p>
			<p><st c="69846">The environment manifest file is created with the purpose of optimizing the upload process. </st><st c="69939">After each download method is run with the PAC CLI, the download method creates a new manifest file, in case one doesn’t exist yet. </st><st c="70071">If the manifest file exists, it reads the existing manifest file and updates the changes, such as any entries that were removed. </st><st c="70200">When uploading content, only the updated and new entries are uploaded to </st><span class="No-Break"><st c="70273">Power Pages.</st></span></p>
			<p><st c="70285">The environment manifest file is environment-specific, intended mainly for development environments, and it should be added to the </st><strong class="source-inline"><st c="70417">git </st></strong><span class="No-Break"><strong class="source-inline"><st c="70421">ignore</st></strong></span><span class="No-Break"><st c="70427"> list.</st></span></p>
			<p><st c="70433">The </st><a id="_idIndexMarker1350"/><st c="70438">delete-tracking manifest file is used to keep track of entries removed from the environment. </st><st c="70531">Whenever a download method is called, all the deleted entries are added to the delete-tracking manifest file. </st><st c="70641">Once an upload method is called, the method removes the unnecessary entries from Power Pages. </st><st c="70735">This file is important and should be added to the source control system and transferred to the </st><span class="No-Break"><st c="70830">target environment.</st></span></p>
			<h3><st c="70849">Example of using the PAC CLI for Power Pages</st></h3>
			<p><st c="70894">We will take a look at the example</st><a id="_idIndexMarker1351"/><st c="70929"> of using the PAC CLI for the download and upload of Power </st><span class="No-Break"><st c="70988">Pages content:</st></span></p>
			<pre class="source-code"><st c="71002">
# Show all Power Pages websites
pac pages list
# download content of a website with Website Id from Power Pages to a selected location.
</st><st c="71139">pac pages download -id &lt;PAGES_WEB_ID&gt; -p &lt;DOWNLOAD_LOCATION&gt;
# we perform changes to the file and decide to upload the changes, using the deployment profiles.
</st><st c="71298">pac pages upload –path &lt;PATH_LOCATION&gt; --environment &lt;ENVIRONMENT_ID&gt; --deploymentProfile &lt;PROFILETAG&gt;</st></pre>			<h2 id="_idParaDest-176"><a id="_idTextAnchor204"/><st c="71400">Using Power Platform Build Tools with Power Pages</st></h2>
			<p><st c="71450">Power Platform Build Tools</st><a id="_idIndexMarker1352"/><st c="71477"> offers two tasks that we have not yet explored: </st><strong class="bold"><st c="71526">Power Platform Download PAPortal</st></strong><st c="71558"> and </st><strong class="bold"><st c="71563">Power Platform Upload PAPortal</st></strong><st c="71593">. Both tasks are intended to operate with </st><span class="No-Break"><st c="71635">Power Pages.</st></span></p>
			<p><st c="71647">We will first </st><a id="_idIndexMarker1353"/><st c="71662">create an export pipeline that will download the website content and commit everything to the main branch. </st><st c="71769">The following is a snippet of steps with the tasks needed to enable such </st><span class="No-Break"><st c="71842">a pipeline:</st></span></p>
			<pre class="source-code"><st c="71853">
steps:
- task: PowerPlatformToolInstaller@2
  inputs:
    DefaultVersion: true
- task: PowerPlatformDownloadPaportal@2
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: 'PP-DevUS-SPN'
    DownloadPath: 'Portal/'
    WebsiteId: '$(WebsiteID)'
- task: CmdLine@2
  inputs:
    script: |
      echo commit all changes
      git config user.email "&lt;EMAIL@DOMAIN.COM&gt;"
      git config user.name "&lt;USER_NAME&gt;"
      git init
      git checkout -B main
      git add --all
      git commit -m "code commit"
      git push --set-upstream origin main
      git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" push -f origin HEAD:main</st></pre>			<p><st c="72437">After </st><a id="_idIndexMarker1354"/><st c="72444">running the export pipeline, we now have the source code in </st><span class="No-Break"><st c="72504">Azure Repos.</st></span></p>
			<p><st c="72516">As a next step, we should create deployment profiles with the necessary configuration values, as mentioned in the previous section (on creating a </st><strong class="source-inline"><st c="72663">deployment-profiles</st></strong><st c="72682"> folder with corresponding deployment YAML files). </st><st c="72733">The deployment profile files might not change that often, as they might be environment-specific, but it is worth setting them up and updating them when necessary; it is a good practice to use them from the beginning in order to keep the configuration settings separate </st><span class="No-Break"><st c="73002">between environments.</st></span></p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/B22208_10_16.jpg" alt="Figure 10.16 – Deployment profiles in Azure Repos"/><st c="73023"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="73602">Figure 10.16 – Deployment profiles in Azure Repos</st></p>
			<p><st c="73651">Whenever developers have to work on their website, we recommend using a branching strategy and pull request mechanism, in order to keep the main branch protected and always in a </st><span class="No-Break"><st c="73830">deployable state.</st></span></p>
			<p><st c="73847">After the pull request is validated and approved, branches can be merged to the </st><span class="No-Break"><st c="73928">main branch.</st></span></p>
			<p><st c="73940">Merging branches can automatically trigger the deployment pipeline. </st><st c="74009">The following is a snippet of tasks from the </st><span class="No-Break"><st c="74054">deployment pipeline:</st></span></p>
			<pre class="source-code"><st c="74074">
steps:
- task: PowerPlatformToolInstaller@2
  inputs:
    DefaultVersion: true
- task: PowerPlatformUploadPaportal@2
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: 'PP-DevUS-SPN'
    UploadPath: 'Portal/$(WebsiteName)'
    DeploymentProfile: '$(profileTag)'</st></pre>			<p><st c="74336">Here we have two variables, </st><strong class="source-inline"><st c="74365">WebsiteName</st></strong><st c="74376"> and </st><strong class="source-inline"><st c="74381">profileTag</st></strong><st c="74391">. The first is the name of our Power Pages instance as it appears in our Azure Repos; </st><strong class="source-inline"><st c="74477">profileTag</st></strong><st c="74487"> should match the tag of the </st><span class="No-Break"><st c="74516">deployment profile.</st></span></p>
			<p><st c="74535">We should </st><a id="_idIndexMarker1355"/><st c="74546">not forget to perform proper testing of our Power Pages websites in order to validate our work and confirm the rollout to our </st><span class="No-Break"><st c="74672">target environment.</st></span></p>
			<p><st c="74691">We familiarized ourselves with Power Platform pipelines in </st><a href="B22208_05.xhtml#_idTextAnchor089"><span class="No-Break"><em class="italic"><st c="74751">Chapter 5</st></em></span></a><st c="74760">, where we talked about managed pipelines. </st><st c="74803">Let’s take a look at how we can utilize Power Platform pipelines to deploy our Power </st><span class="No-Break"><st c="74888">Pages websites.</st></span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor205"/><st c="74903">Using Power Platform pipelines with Power Pages</st></h2>
			<p><strong class="bold"><st c="74951">Power Platform pipelines</st></strong><st c="74976"> allow </st><a id="_idIndexMarker1356"/><st c="74983">the quick and easy configuration of deployment pipelines that enable organizations to automate the release of a build from the development environment to other environments, such as test </st><span class="No-Break"><st c="75170">and production.</st></span></p>
			<p><st c="75185">In order to</st><a id="_idIndexMarker1357"/><st c="75197"> utilize Power Platform pipelines, all target environments must be enabled as </st><strong class="bold"><st c="75275">Managed Environments</st></strong><st c="75295">, and all environments that are used in pipelines must be Dataverse-enabled. </st><st c="75372">All websites have to be created using the enhanced </st><span class="No-Break"><st c="75423">data model.</st></span></p>
			<p><st c="75434">Once the prerequisites are met, we are able to proceed with deploying our websites to </st><span class="No-Break"><st c="75521">target environments.</st></span></p>
			<p><st c="75541">First, we need to prepare the solution. </st><st c="75582">In Power Apps, we open </st><strong class="bold"><st c="75605">Solutions</st></strong><st c="75614">, where we either create a new solution or open an existing one. </st><st c="75679">Then, we open the solution and add our existing website to the solution by selecting </st><strong class="bold"><st c="75764">Add existing</st></strong><st c="75776"> | </st><strong class="bold"><st c="75779">Site</st></strong><st c="75783">. In the sidebar that opens, we select the website that we would like to add to the solution. </st><st c="75877">Once the solution objects are added to the solution, we can proceed with setting up the pipeline. </st><st c="75975">While still in the newly created solution, we click </st><strong class="bold"><st c="76027">Pipelines</st></strong><st c="76036">, which can be found in the left navigation bar. </st><st c="76085">In </st><strong class="bold"><st c="76088">Pipelines</st></strong><st c="76097">, we can select existing pipelines that the DevOps or IT operations team has created for us in advance, or we can click </st><strong class="bold"><st c="76217">Create new pipeline</st></strong><st c="76236">. The new popup screen allows us to define the deployment pipeline, which will take our solutions from the source to the </st><span class="No-Break"><st c="76357">target environment:</st></span></p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B22208_10_17.jpg" alt="Figure 10.17 – Power Platform pipelines"/><st c="76376"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="77208">Figure 10.17 – Power Platform pipelines</st></p>
			<p><st c="77247">Once the</st><a id="_idIndexMarker1358"/><st c="77256"> pipeline is configured, we can press the </st><strong class="bold"><st c="77298">Deploy here</st></strong><st c="77309"> button and the deployment process </st><span class="No-Break"><st c="77344">will start.</st></span></p>
			<p><st c="77355">This is a more simplified kind of deployment process. </st><st c="77410">Still, it is suitable for many scenarios. </st><st c="77452">It opens the door for app makers who might not be skilled in DevOps processes and CI/CD pipelines but are still aware of the importance of the automated approach of deploying business solutions and keeping </st><span class="No-Break"><st c="77658">environments separate.</st></span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor206"/><st c="77680">Summary</st></h1>
			<p><st c="77688">This chapter continued building on the possibilities that Microsoft Power Platform provides to pro-developers. </st><st c="77800">The platform definitely shouldn’t be taken lightly, even though it is a part of the low-code development toolset. </st><st c="77914">As we have seen, it offers many opportunities for pro-developers to extend the user experience and integrate solutions with complex backend and legacy systems. </st><st c="78074">Now we can see how important it is to form agile fusion teams where pro-developers have the ability to customize solutions using different custom components, in order to deliver on </st><span class="No-Break"><st c="78255">project requirements.</st></span></p>
			<p><st c="78276">We looked at examples of how connection references and environment variables can be used together with the DevOps approach. </st><st c="78401">We continued with a look at canvas components and component libraries. </st><st c="78472">We then covered the Power Apps component framework and code components. </st><st c="78544">All these components can be added to solutions as solution objects, and DevOps pipelines can be used to deploy them securely to other environments as development progresses. </st><st c="78718">We closed this chapter by taking a look at Power Pages ALM. </st><st c="78778">We have investigated how we can use Power Platform Build Tools to support ALM process for our websites, as well as checked a simpler approach using managed pipelines in </st><span class="No-Break"><st c="78947">Power Platform.</st></span></p>
			<p><st c="78962">The next chapter will focus on best practices for managing environments in a governed and secure way and how the IT operations team can describe environments using code. </st><st c="79133">This is a very important part of the DevOps life cycle that we have to address, even though it is not </st><span class="No-Break"><st c="79235">very pro-dev-oriented.</st></span></p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor207"/><st c="79257">Further reading</st></h1>
			<ul>
				<li><st c="79273">Connectors </st><span class="No-Break"><st c="79285">architecture: </st></span><a href="https://learn.microsoft.com/en-us/connectors/connector-architecture"><span class="No-Break"><st c="79299">https://learn.microsoft.com/en-us/connectors/connector-architecture</st></span></a></li>
				<li><st c="79366">Connection </st><span class="No-Break"><st c="79378">references: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/maker/data-platform/create-connection-reference"><span class="No-Break"><st c="79390">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/create-connection-reference</st></span></a></li>
				<li><st c="79482">Environmental </st><span class="No-Break"><st c="79497">variables: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables"><span class="No-Break"><st c="79508">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables</st></span></a></li>
				<li><st c="79593">Component </st><span class="No-Break"><st c="79604">library: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/maker/canvas-apps/component-library"><span class="No-Break"><st c="79613">https://learn.microsoft.com/en-us/power-apps/maker/canvas-apps/component-library</st></span></a></li>
				<li><st c="79693">Power Apps component </st><span class="No-Break"><st c="79715">framework: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/developer/component-framework/overview"><span class="No-Break"><st c="79726">https://learn.microsoft.com/en-us/power-apps/developer/component-framework/overview</st></span></a></li>
				<li><st c="79809">Power Pages </st><span class="No-Break"><st c="79822">ALM: </st></span><a href="https://learn.microsoft.com/en-us/power-pages/configure/portals-alm"><span class="No-Break"><st c="79827">https://learn.microsoft.com/en-us/power-pages/configure/portals-alm</st></span></a></li>
			</ul>
		</div>
	<div id="charCountTotal" value="79894"/></body></html>