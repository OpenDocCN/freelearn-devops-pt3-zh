- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Command-Line Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’re going to dive right into the Linux command line. We will
    explain what makes it so powerful and, by extension, important to every system
    administrator and DevOps person. But more importantly, we will start teaching
    you the most useful commands and a way to use them efficiently. Along the way,
    we will be adding other core Linux concepts, as they will be required to understand
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What a command line is and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why it is so important to feel comfortable working with the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic commands for Linux system administration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not possible to introduce all the commands and tools in a single chapter.
    What follows is our choice of the most basic tools you will need to know. Managing
    the Linux system is a separate book topic on its own. It so happens that Packt
    does have several publications on that.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is highly recommended to have a Linux system installed and ready for use.
    We recommend it to be a virtual machine or a laptop that you can safely reinstall
    from scratch in case something goes horribly wrong. It will let you follow the
    examples in the book and perform any kind of exercise that we give you.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to cover an installation. Every distribution may use its own
    installer, either graphical or text (depending on the distribution and which variant
    you’ve picked). You’ll need to note down or remember the name of your user (conveniently
    called username or login) and password. There are ways to get into the system
    if you have physical access and you don’t know either the login or password, or
    both, but they are way outside of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Our main distribution in the book is Debian. However, you should be alright
    with any of the major ones we covered in the previous chapter, *Choosing the Right
    Linux Distribution*, as long as it isn’t Alpine.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux command line – shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The natural environment for a Linux system administrator is the command line.
    You’ll never hear anyone call it that, however. The correct name is the **shell**,
    and from now on, that’s how we’re going to address it in the book.
  prefs: []
  type: TYPE_NORMAL
- en: The **shell** is a program that accepts input from a user (mostly keyboard strokes,
    but there are other ways, and you can even use a mouse pointer), interprets it,
    and, if it’s a valid command, executes it, providing the user with the result
    or with error information if they’ve made a mistake or if the commands couldn’t
    complete their execution properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to access the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Terminal (screenshot in *Figure 2**.1*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also see the term **console**. There is a difference between the Terminal
    and a console. A **console** is a physical device that lets users interact with
    the computer. It is the physical input (nowadays, mostly keyboard) and output
    (nowadays, a monitor, but in the beginning, the output was printed out). **Terminal**
    is a console emulator, a program that lets users perform the same tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal window in a graphical interface, if you have one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log in remotely over a secure connection from another device (phone, tablet,
    or your computer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shell is a very powerful environment. It may seem cumbersome at first to
    do everything by typing commands, but soon you’ll learn that the more complex
    the task, the more you can do with the shell, more easily than with graphical
    interfaces. Every Linux system administrator worth their salt will know how to
    do tasks in the shell and how to manage the system through it, and I wouldn’t
    risk much by betting that they will prefer the shell to any GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know your shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The shell is a program, and as such, there is not a single shell. Instead, there
    are a number of more or less popular shells that bring forth their own view on
    how things should be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'By far the most popular and default in most Linux distributions is **Bash**
    (**Bourne again shell**). There are other shells you may want to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sh**: The original Steve Bourne shell. It is *the* shell, the very first
    one ever written that we know of. While it lacks many interactive features that
    users came to appreciate from other, more modern shells, *sh* is known for its
    speed of script execution and small size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ksh**: Developed as an evolution of the Bourne shell, it is a superset of
    its predecessor. Thus, all scripts written for *sh* will run in *ksh*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**csh**: The C shell. The name comes from its syntax, which closely follows
    the C programming language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**zsh**: The Z shell. It should be well known to macOS users, as it is a default
    on this operating system. It is a completely modern shell, providing a lot of
    features that you’d expect from it: command history, arithmetic operations, command
    completion, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We won’t trouble you much with shell variants and history. If you are interested
    in how Bash came to be, refer to this Wikipedia article: [https://en.wikipedia.org/wiki/Bash_(Unix_shell)](https://en.wikipedia.org/wiki/Bash_(Unix_shell)).'
  prefs: []
  type: TYPE_NORMAL
- en: In our book, we are working with Bash. As mentioned earlier, it is the default
    shell for most Linux distributions, it offers *sh* compatibility mode, it has
    all the features you’d expect from a modern shell, and the amount of books, articles,
    how-tos, and other material for extending your knowledge about it is staggering.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task that we will be performing is logging in to your shell. Depending
    on your chosen installation method, you may need to power up the local virtual
    machine, your physical machine, or a cloud-based **Virtual Private Server** (**VPS**).
    If you have picked a server installation without a graphical user interface, you
    should see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Login screen](img/B18197_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Login screen
  prefs: []
  type: TYPE_NORMAL
- en: You are presented with a login screen, where you can provide your username and
    password. Once successfully logged in, you are presented with a command prompt,
    which confirms that you’ve just successfully started your shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way the prompt looks is configurable and may be different depending on
    your chosen distribution. There is, however, one thing that will stay the same,
    and we advise you to never change it. In the world of Linux, there are two types
    of users: *normal users* and the *superuser*. While the login for normal users
    can be anything as long as it adheres to the Linux user naming conventions, the
    superuser is called `root` as the username/login and its password next.'
  prefs: []
  type: TYPE_NORMAL
- en: The superuser account is named that way for a reason. In most Linux distributions,
    it’s the omnipotent user. Once logged in as `root`, you can do anything you wish,
    even deleting all files, including the operating system itself.
  prefs: []
  type: TYPE_NORMAL
- en: To help you distinguish between being a normal user and the `root` one, the
    prompt will present you with a clue. While logged in as `root`, your prompt will
    end with the `#` sign. When logged in as a normal user, it will present you with
    `$`.
  prefs: []
  type: TYPE_NORMAL
- en: While we’re at it, the `#` (hash) sign is also a so-called comment sign. If
    you happen to paste a command or type it from the internet, if it starts with
    `#` or `$`, it is your clue as to which type of user should run this command.
    You should omit this sign, especially as `#` in front will prevent the command
    from running.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the sign that ends the prompt, many distributions will prepend
    the username to it, making sure you know which user you are. Given a user admin
    on a Linux system called `myhome`, the default prompt for Debian 11 will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `root` user, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For the record, there are more ways to check your identity, but we will leave
    that for [*Chapter 4*](B18197_04.xhtml#_idTextAnchor063).
  prefs: []
  type: TYPE_NORMAL
- en: I call to thee
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, so good. You have logged in, you know who you are, you can type, and
    you can read. But how do you actually run programs?
  prefs: []
  type: TYPE_NORMAL
- en: In the Linux lingo, running a program is executing it or calling it. Actually,
    **calling** is mostly used when referring to system commands or shell built-in
    commands, and **executing** is used when talking about something that is not a
    part of the distribution—so-called third-party programs or binary.
  prefs: []
  type: TYPE_NORMAL
- en: Before I can tell you how to execute a program or call a command, I’ll have
    to explain a little bit about filesystem structure and a very important system
    variable called `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since it may be your first time, we are going to step back a little bit and
    explain how the filesystem is structured (in other words, how directories are
    organized in typical Linux).
  prefs: []
  type: TYPE_NORMAL
- en: Linux follows the Unix philosophy that states that everything is a file. (There
    are exceptions, but not many.) The consequence is that almost every aspect of
    the operating system is reflected either as a file or a directory. Memory states,
    processes' (running programs) states, logs, binaries, and device drivers all live
    within this structure. This also means that almost every aspect of your Linux
    system can be edited or inspected using just normal text editing tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the directory tree, its structure always starts with a `/` folder, called
    the **root directory**. Every drive, network share, and system directory lives
    in a hierarchy that starts from the root.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of making a network share or local drive available to the system
    or user is called `/home/` directory. You would never be able to tell it when
    browsing the filesystem structure. The only way to tell would be to inspect mounted
    drives and partitions using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are going to elaborate on them in [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050),
    so for now, just know they exist.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the uppermost directory is `/`. We already covered that. The separator
    between folders nested in another folder is also `/`. So `/usr/bin` means a `bin`
    directory that exists in the `usr` directory, and the `usr` directory exists in
    the `/` directory. Simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a very nice command that lets us inspect the directory structure,
    conveniently called `tree`. It may not be present in your system. If so, don’t
    be worried; it’s not so important that you run it rather than go through our explanation.
    In [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050), when we introduce the installation
    of packages, you can revisit and play around. By default, the `tree` command will
    flood your screen with the full hierarchy, making it difficult to read and follow.
    There is an option, however, that lets us limit the depth we will be inspecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are several important concepts to cover here; we won’t be explaining all
    the directories at this time, however. The first time a given folder becomes important,
    in [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050) onward, we will briefly touch
    upon it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the calling of `tree`. You saw my prompt, which tells me I am running
    as user admin, on a system named `myhome` and that I am not a `root` user (*the
    dollar sign at the end*). If you want to run the `tree` command, you will skip
    the prompt. Next is the actual call: `tree` with the `-L` option and number `1`;
    this instructs the program to only print one level of depth. In other words, it
    will not go any deeper into the directories. Finally, the `/` symbol tells the
    program to start printing at the very beginning of the filesystem—the `root` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll notice that some rows have this mysterious arrow pointing from
    one name to another. This denotes a shortcut. There are two types of shortcuts,
    hard and symbolic. Directories can only have a symbolic link. In the preceding
    output, the `/bin` directory is a link to a `/usr/bin` directory. For all intents
    and purposes, they can be treated as one. There are technical and historical reasons
    for the existence of this link. In days past, tools living in `/bin` and `/sbin`
    were used to mount a `/usr` partition and then allow access to `/usr/bin` and
    `/usr/sbin`. Nowadays, this task is handled earlier in the boot process by other
    tools and the requirement is no longer necessary. The structure is kept for backward
    compatibility with tools that may require the existence of both `/bin` and `/sbin`
    directories. More details can be found at [https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.xhtml](https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.xhtml)
    or [https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained](https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained).
  prefs: []
  type: TYPE_NORMAL
- en: Since we already touched on the `/bin` and `/sbin` directory, let’s explain
    the difference. The `/usr/bin` directory contains `/usr/sbin` directory contains
    so-called `root` user. It will also contain binaries for system processes (called
    **daemons**)—programs that run in the background and do important work for the
    running system.
  prefs: []
  type: TYPE_NORMAL
- en: The `/root` directory is the home of the superuser. This is where all its configuration
    files lay.
  prefs: []
  type: TYPE_NORMAL
- en: The interesting one is the `/home` directory. This is where all the user home
    directories exist. When I created my admin user for my home machine, it was placed
    in the `/``home/admin` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of importance to us at this moment will also be the `/etc/` directory. It contains
    all the configuration files for the whole system: the source for online package
    repositories, default shell configuration, system name, processes that start at
    the boot, system users and their passwords, and time-based commands. On a freshly
    installed Debian 11 system, the `/etc/` directory contains about 150 subdirectories
    and files, and each subdirectory may contain more folders inside.'
  prefs: []
  type: TYPE_NORMAL
- en: The `/tmp` folder contains temporary files. They only live when the system is
    booted and will be deleted the moment it is shut down or restarted. The nature
    of those files is often very volatile; they can hop into existence and disappear
    very fast or can be modified very often. It is not uncommon for this directory
    to only exist in the computer’s RAM. It’s the fastest storage device your system
    has and will automatically purge on restart or power off.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, additional drives are mounted under this structure. We
    could have a separate hard drive for home directories. The whole `/home` folder
    may live on it or even on a networked hard disk array. As mentioned, the `/tmp`
    directory is often mounted in the RAM. Sometimes, the `/var` directory (which
    contains things that can change often in the system but are not supposed to be
    purged, such as logs) is mounted on a separate drive. One of the reasons is that
    the contents of `/var`, and especially of `/var/log` (where the system logs live),
    can grow very fast and take all the available space, making accessing the system
    impossible or very tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there are two important and special directories that exist everywhere
    you go:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.`: A single dot means the `.` folder, you’ll end up where you are. It’s useful,
    however, as you’ll see in [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`..`: Two dots mean the directory above us—the `..` folder, you’ll end up one
    level above where you started. Note that for the `/` directory, both `.` and `..`
    mean the same: `/`. You can’t go any higher than the root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know some things about the folder hierarchy, let’s briefly touch
    on executing programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three basic ways to execute a program in a shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PATH` variable (explained in [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/`. When using the absolute path, you have to list all the directories that
    lead to the program, including the leading `/`. An example execution may look
    like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`./`. This shortcut means the `./myprogram` or `./bin/myprogram`. The latter
    would mean: let’s start a program called `myprogram` that is in a `bin` directory
    that is in the current directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To call a program in a directory somewhere else in the system using a relative
    path, we will have to use the two dots, meaning the parent folder. Let’s say you
    are logged in to your home directory, `/home/admin`, and want to execute a program
    in `/opt/some/program/bin`; you’d call `../../opt/some/program/bin/myprogram`.
    The two dots and slash mean moving up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this looks arcane, it is because it is a little bit. Fortunately, everything
    will start coming together as the book progresses.
  prefs: []
  type: TYPE_NORMAL
- en: The command to teach you all commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should get into the habit of searching the internet whenever you have a
    question or problem. Most of the issues you are going to run into are already
    fixed or explained out there. However, there’s one command that can save your
    life—or at least lots of time. You should make another habit of using it often
    – even if you are sure you know the correct syntax, you might just discover a
    better way of completing your task. This command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `man` command is a shorthand for *manual* and it is exactly what it says:
    it is a manual for whatever command you want to learn about. To learn more about
    the `man` command, simply call the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output you’ll see should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'I have cut it for brevity. A well-written `man` page will have several sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is where the name of the command is stated. If the command exists
    under various names, they will all be listed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`synopsis`: This will list possible ways of calling the command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This is the purpose of the command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`examples`: This will show several examples of the command call, to make the
    syntax clearer and give some ideas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: This will show all the available options and their meaning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getting help`: This is how to get a shortened version of the command synopsis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`files`: If the command has configuration files or consumes files known to
    exist in the filesystem, they will be listed here (for `man`, I have listed `/etc/manpath.config`
    and `/usr/share/man`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bugs`: This is where to look for bugs and report new ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`history`: This will show all the current and previous authors of the program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`see also`: These are programs that are in some way tied to the command (for
    `man`: `apropos(1)`, `groff(1)`, `less(1)`, `manpath(1)`, `nroff(1)`, `troff(1)`,
    `whatis(1)`, `zsoelim(1)`, `manpath(5)`, `man(7)`, `catman(8)`, and `mandb(8)`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many commands will contain a lot of additional sections, specific to this program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `man` pages will contain a lot of knowledge, and sometimes the names will
    duplicate. This is where the mysterious numbers in brackets come into play. The
    `man` pages are broken down into sections. To quote the `man` page about `man`:'
  prefs: []
  type: TYPE_NORMAL
- en: Executable programs or shell commands
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: System calls (functions provided by the kernel)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Library calls (functions within program libraries)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Special files (usually found in `/dev`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: File formats and conventions, for example, `/etc/passwd`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Games
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Miscellaneous (including macro packages and conventions), for example, `man(7)`,
    `groff(7)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: System administration commands (usually only for `root`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kernel routines [non-standard]
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s take, for example, `printf`. There are several things that are called
    `printf`. One of them is a library function of the C programming language. Its
    `man` page will live in section `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read about that library function, you have to tell `man` to look into section
    `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Most commands and shell programs have a shorter synopsis called `help`. Usually,
    it can be invoked by running binary with the `-h` or --`help` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I have cut the output for brevity, but you get the drift.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The short options are preceded with one dash while longer ones are preceded
    with two. --`help` is not one long dash but two standard ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `man` and `–help` commands should become your friends even before searching
    online. A lot of questions can be quickly answered just by looking at the `help`
    output. Even if you are a seasoned administrator, you are allowed to forget command
    syntax. There is an online source of endless Linux guides called *The Linux Documentation
    Project*: [https://tldp.org](https://tldp.org). Make it your bookmark.'
  prefs: []
  type: TYPE_NORMAL
- en: Know your environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way your system behaves is controlled by several factors. One of them is
    a set of variables called **environment**. They set things such as what language
    your system is going to use when talking to you, how entries during listing will
    be sorted, where the shell is going to look for executables, and many more. The
    exact set of variables depends on the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full set of all the environment variables that your shell has set can be
    printed using the `env` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you know the variable you want to inspect, you can use the `echo` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when you are using a variable, you have to precede its name with
    a dollar sign, hence `$PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: Where in the PATH am I?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we mentioned `PATH`, let’s talk briefly about it. **Path** can mean two
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A place in the system that leads to something: a binary, a file, or a device'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An environment variable that lists places where the shell is going to look when
    trying to execute a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You already know a little bit about the first kind of path. We explained the
    absolute path and relative path. There is a command that lets you move around,
    and it’s called `cd` (shortcut for `cd` without an argument, it will take you
    to your home directory. If you call it with an argument, it will move you to the
    specified folder, given that it exists, you specified the path properly, and you
    have the right to access it. Let’s see a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking which directory we’re currently in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing directory to `/home/admin/documents/current`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing one directory up from a current level:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the directory to the user home directory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Know your rights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most basic security mechanism in Linux is based on defining a combination
    of rights for a set of entities. The rights are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`read`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`write`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`execute` (read contents when talking about a directory)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the entities are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The owner of the file or directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The group that owns the file or directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the other users and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a crude security system. It’s sufficient for small servers and desktop
    uses but, for more complex setups, it is sometimes too restraining. There are
    other additional systems, such as **Access Control Lists** (**ACLs**), AppArmor,
    SELinux, and more. We are not going to cover them in this book.
  prefs: []
  type: TYPE_NORMAL
- en: With the use of the previous systems, we can still achieve quite a lot regarding
    our system security.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do those rights and ownership work? We use the `ls` command (list files
    and directories):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output is presented in nine columns.
  prefs: []
  type: TYPE_NORMAL
- en: The first column presents the type of the entry and the rights in a concise
    manner, but let’s jump to the third and fourth. Those columns inform us about
    who is the owner of the file and what user group the file belongs to. All files
    and directories must belong to a user and to a group. In the preceding output,
    most of the files belong to the user admin and to the group admin. The exception
    is the `..` directory, which belongs to the `root` user and `root` group. It is
    common to denote this pair in the form `user:group`.
  prefs: []
  type: TYPE_NORMAL
- en: The next columns describe the size (with a directory, it describes the size
    of the entry, not how much space the directory contents take), the date of the
    last change, the time of the last change, and the name of the entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us go back to the first column. It informs us what an owner, a group,
    and all other users in the system are allowed to do with the given file or directory:'
  prefs: []
  type: TYPE_NORMAL
- en: The letter `d` means that we are dealing with a directory. A dash (`–`) means
    it’s a file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next is a group of nine one-letter symbols that denote who can do what with
    the given entry:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first three letters denote what the file or directory owner can do with
    it. `r` means that they can read it, `w` means they can write to it, and `x` means
    they can execute it as a program. In the case of a text file with `x` set, the
    shell will try to run it as a script. The caveat is when we are dealing with a
    directory. `x` means that we can change a current working directory to it. It
    is possible to be able to go into a directory (`x` set) and not be able to see
    what is in it (`r` not set).
  prefs: []
  type: TYPE_NORMAL
- en: The same three letters explain the group rights in the second grouping.
  prefs: []
  type: TYPE_NORMAL
- en: The same set explains all other users’ rights in the third grouping.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding output, `.Bash_history` is a file (it has a dash in the first
    field); the owner of the file (user admin) can read from it and write to it. It
    is possible to be able to write to a file (for example, a log file) but not be
    able to read from it. The file cannot be executed as a script (a dash). The next
    six dashes inform us that neither users assigned to the group admin nor any other
    user or group in the system can do anything with this file.
  prefs: []
  type: TYPE_NORMAL
- en: There is one exception, and it is the `root` user. Without stepping up with
    ACLs and tools such as SELinux, you cannot limit root’s omnipotence in the system.
    Even for a file or directory that has no rights assigned (all dashes), `root`
    has full access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The administration of the ownership and the rights is done by means of two
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chown`: This command allows you to change the ownership of a file or directory.
    The name is a shortcut for *changing owners*. The syntax is quite simple. Let’s
    take this opportunity to exercise a bit with the notation in Linux help:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an unwritten convention that most, if not all, commands’ help adhere
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: Text without any brackets must be typed as shown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything inside `[ ]` brackets is optional. In the `chown` command, the user
    and group are optional, but you must supply at least one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text in `< >` brackets is mandatory but is a placeholder for whatever you will
    have to supply.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brackets `{ }` denote a set of options and you’re supposed to choose one. They
    can be separated by a vertical line, `|`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three dots after an element means this element can be supplied multiple times.
    In the `chown` case, it’s the name of the file or directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a set of ownership changes that I apply to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: I change the ownership from `admin` to `testuser`, but I leave the group unchanged.
    Please note that changing actually requires the use of the `root` account (via
    the `sudo` command, explained in [*Chapter 3*](B18197_03.xhtml#_idTextAnchor050)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I change the ownership back to `admin`, but change the group to `testuser`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, we can see that a successful call to a command produces
    no output (`chown`) unless the output is the purpose of the command (`ls`). This
    is one of the basic rules that Linux follows. In the following output, we can
    see what happens when the command terminates with an error—insufficient rights
    to change the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'One other way to run the `chown` command is to point to a reference file, as
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using the `–reference` option, we point to a file that will be a matrix for
    our changes. This will become more interesting once we move on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '`chmod`: Similar to the `chown` command, `chmod` (short for *change mode*)
    is the one you’ll be looking for to change the rights of the assigned user and
    group:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `chmod` command will accept options, mandatory mode, optionally more modes,
    and a list of files that the change is supposed to be applied to. As with the
    `chown` command, we can specify a reference file that will have its mode copied
    over.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first form, you will specify the mode for either a user, a group, others,
    or all of them using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the following meanings apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '`u`: User, in other words, the owner of the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`: Group that owns the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`o`: Others—all others'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`: All, meaning everyone'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-`: Remove the specified right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`+`: Add the specified right'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`=`: Make the rights exactly as specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s see some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'This adds read and write permissions to the `testfile` file for the file owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This removes the execute right to the `testfile` file for everyone who is not
    the file owner and is not in the group that owns the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the user and the group read and execute rights to the `testfile`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the syntax summary we have pasted, the middle row is interesting. The octal
    mode means that we can specify the mode by means of numbers. This is especially
    useful in scripts, as dealing with numbers is easier. Once you memorize the mode
    numbers, you may find it easier to use the octal `chmod`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for the numeric setting of file mode is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: no rights (`---`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: execute mode (`--x`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: write mode (`-w-`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4`: read mode (`r–`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set the mode on a file or directory, you will use a sum of the rights you
    want to apply, starting with a leading `0`, which will inform `chmod` that you
    are setting octal mode. The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a very important difference between this form and the letter one—you
    must specify the mode for all three types of entities: user, group, and others.
    You cannot omit any of them. This means that you also won’t be using the `-`,
    `+`, or `=` signs. With the octal syntax, the rights will always be exactly as
    specified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To combine the modes, you will add their numbers and use the sum as the final
    specifier. You will find that this is a very elegant solution. There are no two
    identical sums of those numbers (combination of rights). Try it:'
  prefs: []
  type: TYPE_NORMAL
- en: Execute and read is 1 and 2 = 3\. There is no other combination of the modes
    that can result in 3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read and write is 2 and 4 = 6\. Again, no other combination can result in 6.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s try some examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The owner of the file will have read and write access to the file, while the
    group and others will have read access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The owner of the file has all the rights (read, write, and execute), while
    the group and others can read and execute only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The leading `0` in the mode is not obligatory.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered the filesystem, directory structure, and basic file permissions
    related to users and groups. In the next section, we will introduce basic Linux
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with the system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs and scripts lying on a hard drive are just files. The moment they get
    mapped to the memory and start performing their function, they become **processes**.
    At this stage, you can safely assume that anything running in the system is some
    kind of a process.
  prefs: []
  type: TYPE_NORMAL
- en: Process this
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Processes in Linux have several characteristics that you need to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process ID** (**PID**): A system-wide unique numerical identifier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent process ID** (**PPID**): Every single process in the Linux system,
    except process number 1, has a parent. Process number 1 is an *init* process.
    It is the program responsible for starting all the system services. A program
    that starts another program is known as a **parent**. A program started by another
    program is known as a **child**. When you log in to the system, your shell is
    a process too, and it has its PID. When you start a program in that shell, your
    command-line PID will become the parent ID of that program. If a process loses
    its parent (i.e., the parent process terminates without terminating its child),
    then the child process is assigned a new parent: process number 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`S` state, the process went to sleep. It will not, however, accept any interrupts
    and signals. It will only awake when a requested resource becomes available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**T**: We can instruct a program to stop its execution and wait. This is called
    a **stopped state**. Such a process can be brought back to execution with the
    use of a special signal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Z**: Zombie. When a process ends its execution, it informs its parent process
    about that. The same happens when the process is terminated. The parent is responsible
    for removing it from the process table. Until it happens, the process remains
    in a zombie state, also called **defunc**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User**: The owner of the process, or rather, a user with whose system rights
    the process is being executed. If that user cannot do something, the process cannot
    do it either.*   **CPU**: Percentage of the CPU time the process is using, presented
    as a floating-point number between 0.0 and 1.0.*   **MEM**: The memory usage,
    again between 0.0 and 1.0, where 1.0 is 100% of system memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each process has more characteristics than the ones we’ve just covered, but
    those are absolutely essential. Managing processes is a subject for a separate
    chapter, if not an entire book.
  prefs: []
  type: TYPE_NORMAL
- en: The tool to inspect the processes is called `ps`. It seems like a pretty simple
    command at first sight, but in reality, the `man` page shows an incredible amount
    of options. It is important to note that `ps` itself will only print a snapshot
    of the system. It won’t be monitoring and updating its output. You can combine
    `ps` with `watch` or `run top` or `htop` commands to have continuous information
    about the processes and system load.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its simplest form, `ps` will print all processes running with the same user
    ID as the user that calls it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'On my Linux machine, there are only two processes running for my user: the
    Bash shell and the `ps` program itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ps` command has several interesting options that help interrogate the
    system about the running processes. Now, specifying options to `ps` is tricky,
    because it accepts two syntaxes, one with a dash and one without, and some options
    have different meanings depending on the dash. Let me quote the `man` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'I have cut some output for brevity. This distinction may become important once
    you start working with shell scripts, as they may adopt any of the three syntaxes.
    Whenever in doubt, use the dash notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-f`: So-called `PID`, `PPID`, `C`), `STIME`), `TTY`) to which it is attached,
    `TIME`), and the command that started the process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`-e`: All processes of all users:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`-ef`: To see all processes in the long output format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`-ejH`: A nice process tree. The more indented CMDs (the last column of the
    output) are children of the less indented ones:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: There are many more options available, especially to control which fields are
    of interest. We will come back to them in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: There is a command that has a name that can be very misleading, the `kill` command.
    It is used to send so-called signals to the running processes. Signals are a way
    of telling processes to perform a kind of action. One of them actually kills the
    program, terminating it at once, but that’s just one of many.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list existing signals, use the `kill -``l` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, this list is cute, but it tells us nothing. How can we tell what each
    of those signals does? Here’s a bit of detective work. First, since we see those
    in the `kill -l` output, let’s invoke the `man kill` command and see whether there’s
    anything that can explain them to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There is an examples section that shows and describes one signal, but in the
    `SEE ALSO` section, we can see a reference to a `man` page signal in section `7`.
    Let us check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, there’s a nice page with a table listing all signals available to you in
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do you use this `kill` command? Do you have to learn about all these
    signals? The answer is no. There are a handful of signals that you’ll be using.
    And if you forget any, don’t hesitate to `man` them or search the web:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kill -9 PID`: The infamous `SIGKILL`. This terminates the process whose PID
    we have specified abruptly, forcing it to omit any cleanup it may do normally.
    If it has opened file handles, it won’t free them; if it has to write any information
    to a file or synchronize with another program, it won’t do it. This should be
    used sparingly, only when we are sure that we really have to stop a program from
    running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill PID`: If no signal is specified, then by default, `SIGTERM` is sent.
    This tells the program to stop running but gracefully—perform all the exit routines
    and cleanup it needs. If you have to use the `kill` command, this is the preferred
    use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill -1`: The so-called `SIGHUP` signal. It was originally used for detecting
    loss of user connection—hangup of the phone line. Currently, it is often used
    to tell the process to reread its configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of calling `kill` to terminate a process. I have started
    a shell script that does nothing except wait for a keyboard input. I called it
    `sleep.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'First, I used `ps aux` and searched in the output for the `sleep.sh` process,
    just to show you that it’s there. Next, I used `pgrep` to find the PID of my running
    script quickly. I have supplied this PID to the `kill -9` command. In effect,
    `sleep.sh` has been killed. This can be confirmed on another Terminal, where I
    was running `sleep.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Had I simply used `kill`, the output would be different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There is another way of delivering two of all signals to running programs,
    but only if currently executing in the shell we’re logged into in the foreground;
    this means it has the control of the screen and keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: Pressing the *Ctrl* + *C* keys will send `SIGINT` to the program. `SIGINT` tells
    the program that the user has pressed the key combination and it should stop.
    It’s still up to the program how the termination should occur.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pressing the *Ctrl* + *D* keys will send `SIGQUIT`—it is like `SIGINT` but also
    produces a so-called core dump, or a file that can be used in a debugging process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The common way of denoting those combinations in text is `^c` and `^d` (`^`
    for the *Ctrl* key), `ctrl+c` and `ctrl+d` (`ctrl` being a shortcut for the *Ctrl*
    key), and `C-c` and `C-d` (`C` denoting the *Ctrl* key, again).
  prefs: []
  type: TYPE_NORMAL
- en: Looking for something?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times when you need to look for a directory or a file on the filesystem.
    Linux has a set of commands that let you perform this operation. Of them all,
    `find` is the most powerful. To cover all of its abilities would take a lot more
    space than we have. You can look for a file or directory `of both` that have exactly
    the name you specified, that have part of the name that you specified, that have
    been modified at a defined point in time, that are owned by a user or a group,
    and many more scenarios. Additionally, on each file that has been found, an action
    can be performed, such as rename, compress, or search for a word.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we’re looking for a file, `signals.h`, in the `/``usr`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we call `find` itself, then we tell it to start looking at the beginning
    of the filesystem (`/`), and then we tell it to look for a file named `os-release`
    (`-``name os-release`).
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that in the output, which I have cut for brevity, there are
    errors about files to which `find` had no proper rights.
  prefs: []
  type: TYPE_NORMAL
- en: If you are unsure about the case of the name, that is, whether it contains lowercase
    or uppercase letters (remember that Linux is case -sensitive and *OS-Release*
    is not the same file as *os-release*), you can use the `-iname` option instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are sure that what you are looking for is a file, then you can use the
    `-type` `f` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: For a directory option, use `-``type d`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look for files that match a pattern, say filenames that end with `.sh`,
    you’d use a pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The asterisk means any number of any characters. We enclosed it in the quotes
    to avoid problems with the shell interpreting the asterisk before `find` got a
    chance. We will explain all the special signs (called **globs**) and regular expressions
    in the next chapter, *Intermediate Linux*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete all found files, you can use the `-``delete` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform an action on the found file, you can use the `-``exec` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we have used the command called `grep` to look for
    any line that contains the word `debian`, no matter whether uppercase or lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: This leads us to the `grep` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `grep` command is used to look for an occurrence of a pattern inside a file.
    Upon finding this pattern-matching line, it prints it. The `grep` command is similar
    to the `find` command, except its purpose is to search inside the files, while
    `find` only cares for the characteristics of files and directories themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume a text file called `red_fox.txt` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As a side note, `cat` is a command that prints the contents of a specified file
    to the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to find all lines that contain the word `the`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You have probably guessed that the `-i` option means that we don’t care about
    the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait. We can search for alternatives. Let’s say we care for lines that
    contain either `fox` or `dog`. You would use the `-e` option for each word you
    search for or the `-E` option with all the words in single quotes and separated
    by the `|` character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the `-n` option, you’ll get information on which line the match was
    found in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can look for lines that start with a given word or have the specified pattern
    at the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even `grep` all files in a directory hierarchy. The syntax is a bit
    different then: the pattern comes first, and the directory comes at the end. Also,
    you get the name of the file where the match was found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The most power for both `find` and `grep` comes from a concept called **regular
    expressions** (**regex** or **regexp** for short), which have a book of their
    own and can be confusing for new users. We are going to explain them in *Chapters
    3* and *4*. We will, however, be only introducing the most everyday uses of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are looking for a program and want to know its full path, there is a
    command for that, and it is called `whereis`. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `whereis` command will not only print the whole path to the binary but also
    a corresponding `man` page, if it has one installed.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s be manipulative
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four basic operations that can be performed on files and directories:'
  prefs: []
  type: TYPE_NORMAL
- en: Create
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename or move
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each of these operations has a special tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mkdir`: This command has very simple and limited syntax. Basically, you are
    telling it to create a directory with a given name. If you are creating nested
    directories, that is, one folder contains another, all the directories in the
    path must exist. If they don’t, you can create them using the special `-``p` option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you can see that I create a directory test directly
    in my home folder. Next, I try to create a folder, `new`, inside the `something`
    folder. However, the latter doesn’t exist and `mkdir` tells me so and refuses
    to create the new directory. I use the special `-p` option to create a whole path
    to the new directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`mv`: This is a command that is used to move and rename files and directories.
    Again, the syntax is pretty simple, although this command offers a little more
    functionality, such as creating a backup of moved files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To rename a file or directory, we move it from the current name to the new
    one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Check out its `man` page or `help` message to find out more.
  prefs: []
  type: TYPE_NORMAL
- en: '`rm`: This command is more interesting, mainly because it offers safety features.
    With the special `-i` option, you can tell it to always ask you before removing
    the file or directory. Normally, `rm` bails at directories, as in the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: I created a file test inside the `no-test` directory. `rm` refuses to remove
    the folder. I used the `-d` option, which instructs the command to remove empty
    directories. However, it still contains a file. Next, I removed the file and then
    `rm -d` cleanly deleted the `no-test` folder. I could have used the `-r` option,
    which makes the command remove all directories, even if they are not empty.
  prefs: []
  type: TYPE_NORMAL
- en: '`cp`: This command is used for copying files and directories. Note that, as
    with `rm`, `cp` will refuse to copy directories unless instructed with the `-r`
    option. `cp` arguably is the most complex and feature-rich command of all, including
    the ability to back up files, create links (shortcuts) instead of real copies,
    and more. Check out its `man` page. In the following example, I copy a `something`
    directory to a `new` directory. Obviously, I have to use the `-r` option. Next,
    I create an empty file called `file` and copy it to `newfile`. For those, I don’t
    require any options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: You should now understand and be able to use basic command-line commands in
    Linux or a similar system, such as create, copy, and delete files; you can also
    find content inside text files or find files or directories by name. You also
    have an understanding of processes in the system you work on. In the next chapter,
    we will deepen this knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have presented but a fraction of the hundreds of commands that Linux admins
    may use in their work. As mentioned at the beginning of this chapter, the complete
    reference is beyond the scope of this book. What we have learned, however, is
    enough to do basic system use and it builds the base for our next chapter: the
    more advanced Linux administration topics.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Find out how to apply `chown` recursively—it means that our `chown` call should
    step inside a directory and apply the change to all the items within.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out what the `watch` command does. Use it with a `ps` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find out how to remove a directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For all the commands you have learned here, read their `–help` output. Open
    a `man` page and look through it, especially the examples section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can read more about SELinux here: [https://www.packtpub.com/product/selinux-system-administration-second-edition/9781787126954](https://www.packtpub.com/product/selinux-system-administration-second-edition/9781787126954)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a very good publication on Linux systems administration: [https://www.packtpub.com/product/mastering-linux-administration/9781789954272](https://www.packtpub.com/product/mastering-linux-administration/9781789954272)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
