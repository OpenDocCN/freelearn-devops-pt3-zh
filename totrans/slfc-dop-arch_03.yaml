- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: The Value of Source Control
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理的价值
- en: 'As we move toward the technical aspects of Salesforce DevOps, we should start
    by exploring **source control**. In this chapter, we’re going to cover the following
    main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迈向 Salesforce DevOps 的技术细节之前，我们应该从探索**源代码管理**开始。本章将涵盖以下主要内容：
- en: Why source control is vital for the implementation of a DevOps process
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么源代码管理对实施 DevOps 流程至关重要
- en: Fundamental Git operations for managing your changes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理变更的基本 Git 操作
- en: Effective Git branching strategies for successful delivery with source control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功交付的有效 Git 分支策略与源代码管理
- en: Source control, also referred to as **version control**, is the technical backbone
    of modern DevOps, and all other tools and techniques are built upon that solid
    foundation. By tackling this topic first and looking at some of the common tasks
    it entails, you will have a solid foundation for the topics discussed later in
    this book, such as CI/CD automation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理，也称为**版本控制**，是现代 DevOps 的技术支柱，所有其他工具和技术都是建立在这个坚实基础之上的。首先讨论这个话题并了解它的一些常见任务后，你将为本书后续讨论的主题打下坚实的基础，例如
    CI/CD 自动化。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The examples in this chapter all pertain to the **Git** source control system
    and it is recommended that you have it installed if you want to follow along.
    Equally, a Git hosting provider is recommended. Many are available, such as GitHub,
    GitLab, and BitBucket. However, in our examples, we’ll be using GitHub.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例都与**Git**源代码管理系统相关，如果你希望跟随学习，建议你安装 Git。同样，推荐使用 Git 托管服务提供商，市面上有许多选择，如
    GitHub、GitLab 和 BitBucket。然而，在我们的示例中，我们将使用 GitHub。
- en: The importance of source control
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理的重要性
- en: While establishing a DevOps culture is the most important aspect of DevOps from
    a process perspective, as we saw in the previous chapter, it’s fair to say that
    source control is the most important technical aspect. It underpins all the other
    tools and techniques of a mature DevOps process and enables deployments, peer
    review, rollbacks, and automation as part of a CI/CD process. Let’s explore some
    of the advantages afforded by source control and the processes that build upon
    it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从流程角度来看，建立 DevOps 文化是 DevOps 最重要的方面，正如我们在上一章看到的那样，但可以公平地说，源代码管理是最重要的技术方面。它支撑着所有其他工具和技术，推动着成熟的
    DevOps 流程，并支持部署、同行评审、回滚以及作为 CI/CD 过程一部分的自动化。让我们来探索源代码管理及其构建的流程所带来的优势。
- en: Collaboration
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: DevOps is fundamentally a collaborative approach to software development, so
    effective collaboration is vital. Source control enables multiple developers to
    work on the same code base simultaneously while indicating when they could be
    overlapping or overwriting each other’s changes during the development phase.
    Changes are merged later, and when coupled with appropriate reviews, they allow
    for rapid development and fewer defects, since changes are tested and reviewed
    far earlier in the development cycle. Only when manual and automated checks have
    passed does code make it higher up the environments toward production. It’s worth
    noting that production issues are harder to track down and more expensive to deal
    with compared to development environments.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 从根本上是一种协作的软件开发方法，因此有效的协作至关重要。源代码管理使得多个开发者可以同时在同一个代码库上工作，并能够指示他们在开发阶段可能会发生重叠或覆盖彼此的更改。更改稍后会合并，并且当结合适当的审核时，这样的过程能够实现快速开发并减少缺陷，因为变更会在开发周期的早期进行测试和审核。仅当手动和自动检查通过时，代码才会进入更高的环境，最终部署到生产环境。值得注意的是，与开发环境相比，生产环境中的问题更难追踪，并且处理成本更高。
- en: Traceability
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可追溯性
- en: As the importance of good governance grows across all processes and businesses,
    including software development, so does the need to have accountability and audit
    trails of software change. Source control facilitates this with a complete history
    of all changes to your code and configurations, detailing what was changed, by
    whom, and (with diligence around commit messages, comments, and references to
    change management tools such as Jira) why the change occurred. In addition to
    these audit trail benefits, a complete history also helps you find the origin
    of bugs and issues.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 随着良好治理在所有流程和业务中，包括软件开发中的重要性日益增长，软件变更的问责制和审计跟踪的需求也在增加。源代码管理通过记录所有代码和配置的更改历史，帮助实现这一点，详细记录了变更内容、变更人以及（通过提交信息、评论和对如
    Jira 等变更管理工具的引用）为什么发生变更。除了这些审计跟踪的好处之外，完整的历史记录还有助于你找到错误和问题的源头。
- en: Automation
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化
- en: DevOps relies heavily on automation, and source control provides the foundation
    for automating many of the processes involved in software development, such as
    building, testing, and deploying code. For example, with source control, it’s
    possible to automatically build, test, and deploy code to different environments
    every time a change is committed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 在很大程度上依赖于自动化，而源代码管理为自动化软件开发中许多过程提供了基础，例如构建、测试和部署代码。例如，借助源代码管理，每当提交代码更改时，便可以自动构建、测试并将代码部署到不同的环境中。
- en: Continuous integration
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: '**Continuous integration** (**CI**) allows developers to integrate their code
    changes from their development or feature branches into a shared integration branch,
    and then run automated tests to ensure that the changes do not break the existing
    system. This process is made possible by source control as it allows developers
    to easily merge their changes and track conflicts. By adopting this technique
    and regularly integrating changes into the main code, developers can detect issues
    earlier, which makes it easier to fix them.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）允许开发人员将他们在开发分支或功能分支中的代码更改集成到共享的集成分支中，然后运行自动化测试，确保这些更改不会破坏现有系统。这个过程得益于源代码管理，它使开发人员能够轻松合并他们的更改并跟踪冲突。通过采用这种技术并定期将更改集成到主代码中，开发人员可以更早地发现问题，从而更容易修复它们。'
- en: Continuous deployment
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续部署
- en: '**Continuous deployment** (**CD**) is a practice where code changes are automatically
    deployed to production after they pass through the CI process. This process is
    also made possible by source control as it allows the deployment process to be
    automated. This can be accomplished by using general-purpose CI/CD tools such
    as Jenkins, Travis CI, and CircleCI, or with Salesforce-specific tools such as
    DevOps Center, Gearset, or Copado. Regardless of the tool you choose, they can
    be configured to automatically deploy code changes to production when they pass
    through the CI process. This is the reason why CI and CD are usually grouped into
    the CI/CD process.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续部署**（**CD**）是一种实践，当代码更改通过 CI 过程后，它会自动部署到生产环境中。这个过程也得益于源代码管理，它使得部署过程能够实现自动化。这可以通过使用通用的
    CI/CD 工具（如 Jenkins、Travis CI 和 CircleCI）或者 Salesforce 特定的工具（如 DevOps Center、Gearset
    或 Copado）来实现。无论选择哪种工具，它们都可以配置为在代码通过 CI 过程后自动将代码更改部署到生产环境中。这就是为什么 CI 和 CD 通常被归类为
    CI/CD 过程的原因。'
- en: Continuous delivery (also CD)
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续交付（也称为 CD）
- en: 'The other CD you may hear concerning DevOps is **continuous delivery**. Its
    shared initials with continuous deployment often create a lot of confusion. The
    aim of CI/CD is continuous delivery: promptly and dependably delivering enhanced
    value to users. Distinct from continuous integration and continuous deployment,
    which are workflows or specific processes, continuous delivery delineates a working
    culture or methodology. Grounded in a practice of progressive enhancements, continuous
    delivery focuses on diminishing lead times and curtailing the development cycle,
    which includes swift feedback from all parties involved.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会听到的另一个与 DevOps 相关的 CD 是 **持续交付**。它与持续部署共享相同的首字母，常常会引起很多混淆。CI/CD 的目标是持续交付：迅速且可靠地向用户交付增强的价值。与持续集成和持续部署不同，持续交付并非工作流程或具体过程，而是定义一种工作文化或方法论。持续交付基于渐进改进的实践，重点在于缩短交付时间并减少开发周期，其中包括来自各方的快速反馈。
- en: This approach enables Salesforce teams to aid their businesses in responding
    swiftly and more flexibly to evolving priorities and market prospects. Both CI
    and CD are processes that help teams accomplish continuous delivery.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使 Salesforce 团队能够帮助企业迅速且灵活地响应不断变化的优先级和市场前景。CI 和 CD 都是帮助团队实现持续交付的过程。
- en: Rollbacks
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚
- en: Source control allows for easy rollbacks, which lets you revert to a previous
    version of the code base if there are issues with the incoming changes. It is
    important to be able to roll back changes quickly and easily in case of bugs or
    other issues that may arise in the production environment. This is made possible
    by source control as it keeps a history of all the changes that have been made
    to the code base, making it easier to revert to a previous version if needed.
    However, keep in mind that not everything can be reverted in Salesforce. For example,
    if you are trying to revert a commit that contained a record type or a new flow
    and that change was deployed to an org, then you may have issues reverting that
    change. Record types cannot be removed via the Metadata API, and flows require
    you to specify the version number to be removed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制允许轻松回滚，这使得当出现问题时，你可以将代码库恢复到以前的版本。如果生产环境中出现了 bug 或其他问题，能够快速且轻松地回滚更改是非常重要的。版本控制通过保持对所有更改的历史记录，使得在需要时可以轻松回到之前的版本。然而，请记住，并不是所有的内容都可以在
    Salesforce 中回滚。例如，如果你尝试回滚包含记录类型或新流程的提交，并且该更改已经部署到组织中，那么你可能会遇到回滚问题。记录类型无法通过元数据
    API 移除，流程需要你指定版本号才能删除。
- en: Incremental development
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增量开发
- en: Another significant advantage of a source-control-driven approach to development
    and deployment is that it encourages developers to think incrementally – one commit
    at a time. This further supports many of the points covered previously – committing
    changes in smaller incremental chunks has the potential to make it easier to manage
    and merge work done by other team members, reducing the chance of code conflicts.
    It also makes debugging and tracking issues easier since you can compare the current
    version with the previous commit to see the net difference. Finally, it encourages
    better coding standards, in which smaller commits tend to promote more modular,
    decoupled code architecture.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一大源自版本控制驱动的开发和部署方法的显著优势是它鼓励开发人员增量思考——一次提交一个。这进一步支持了之前提到的许多观点——将更改分成更小的增量进行提交，有助于更轻松地管理和合并其他团队成员的工作，减少代码冲突的可能性。它还使调试和跟踪问题变得更容易，因为你可以将当前版本与上一个提交进行比较，以查看两者之间的差异。最后，它鼓励更好的编码标准，因为较小的提交往往会推动更加模块化、解耦的代码架构。
- en: Now that we’ve looked at the many advantages of using source control, and why
    it is so important to a mature DevOps process, let’s look at some of the core
    Git tasks and commands that bring source control to life.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过使用版本控制的许多优势，以及它在成熟的 DevOps 流程中的重要性，接下来我们将了解一些核心的 Git 任务和命令，这些任务和命令将使版本控制发挥作用。
- en: Fundamental Git operations
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的 Git 操作
- en: Before we dive into the sea of Git commands and how they come into play, it’s
    essential to get a firm grasp of the basics of source control.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解 Git 命令及其应用之前，掌握版本控制的基础知识是至关重要的。
- en: Commits
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交
- en: A commit is a snapshot of your project’s files and directories at a specific
    point in time. Every commit is assigned a unique identifier (known as a SHA hash)
    and includes metadata such as the author, timestamp, and a descriptive message
    explaining the changes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 提交是项目文件和目录在特定时间点的快照。每个提交都会分配一个唯一的标识符（称为 SHA 哈希），并包括如作者、时间戳和描述性消息等元数据，用以解释所做的更改。
- en: Commits aren’t just frozen moments in time, though. They’re also part of a larger
    narrative that reflects your project’s evolution. In Git, commits are linked in
    a chain, with each commit referencing its predecessor. This allows you to traverse
    your project’s history, compare versions, or even revert changes when necessary.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，提交不仅仅是静止的时间点。它们还是反映项目演变的一个大叙事的一部分。在 Git 中，提交是按链条链接的，每个提交都引用其前一个提交。这使得你可以遍历项目历史，比较版本，甚至在必要时回滚更改。
- en: Staging
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂存
- en: Before you can commit changes in Git, you need to **stage** them. The staging
    area, also known as the index, is like a preparation zone where you gather and
    organize your changes before making a commit. Staging changes allows you to create
    meaningful, well-organized commits that communicate what you’ve done and why.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在你提交更改之前，需要**暂存**这些更改。暂存区，也称为索引，就像一个准备区，你在提交之前收集和整理更改。暂存更改可以帮助你创建有意义且组织良好的提交，从而清晰地传达你做了什么和为什么这么做。
- en: When you stage a file, you are telling Git that you want to include updates
    to that file in the next commit. However, it is important to note that Git stages
    a file exactly as it is when you stage it. If you continue to make changes to
    a file after staging it, you will need to stage it again to include the latest
    changes in your next commit.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将文件添加到暂存区时，你是在告诉 Git 你希望将该文件的更新包含在下一次提交中。然而，重要的是要注意，Git 会按你暂存该文件时的状态来暂存它。如果你在暂存后继续修改该文件，你需要再次将其暂存，才能将最新的更改包含在下一个提交中。
- en: Repositories
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仓库
- en: A repository, often abbreviated to `git init` command in the directory that
    contains your source code.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库，通常通过 `git init` 命令在包含源代码的目录中创建。
- en: Putting source control into practice
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将源代码控制付诸实践
- en: While this book is not intended to give an *exhaustive* overview of Git’s myriad
    of commands and options, there are a few key operations that make up Git’s typical
    usage.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本书并不打算提供 Git 命令和选项的*详尽*概述，但有一些关键操作构成了 Git 的典型使用方式。
- en: Firstly, it’s important to note the difference between a local repository and
    a remote repository since many Git commands are specifically for moving changes
    between the two.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要注意本地仓库和远程仓库之间的区别，因为许多 Git 命令专门用于在两者之间移动更改。
- en: As the name suggests, a local repository exists on your local development machine
    and can be either a newly initialized repository or one that you have cloned from
    another (usually remote) repository. Operations carried out on this repository
    will remain on your local machine until you push those changes to a remote repository.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如名称所示，本地仓库存在于本地开发机器上，可以是一个新初始化的仓库，或者是你从另一个（通常是远程）仓库克隆过来的仓库。在该仓库上执行的操作将保持在本地机器上，直到你将这些更改推送到远程仓库。
- en: A remote repository is hosted on a remote server – either with a Git hosting
    provider or a physical server, perhaps within your own company’s data center.
    This remote repository serves as the centralized source of truth from which other
    developers can get your changes and vice versa. With this distinction between
    local and remote repositories in mind, let’s start looking at some common Git
    operations and the commands to carry them out.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 远程仓库托管在远程服务器上——可能是使用 Git 托管服务商，或者是公司的物理服务器，可能位于公司自己的数据中心。这个远程仓库作为集中式的“真理来源”，其他开发者可以从中获取你的更改，反之亦然。考虑到本地和远程仓库之间的区别，我们可以开始了解一些常见的
    Git 操作及执行这些操作的命令。
- en: Initializing a new repository
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化新仓库
- en: 'The initial step in any source control workflow is to create a repository in
    which to store your work, and while it is likely you will be working with a repository
    that already exists, creating a new repository can be achieved by running the
    following command in the directory that contains your source code. This will create
    a brand-new empty repository locally, into which you can then start adding files:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 任何源代码控制工作流的初始步骤是创建一个仓库来存储你的工作，虽然你可能会处理一个已经存在的仓库，但通过在包含源代码的目录中运行以下命令，你可以创建一个全新的空仓库，本地创建的仓库，你可以开始在其中添加文件：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Adding new files to the staging area
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将新文件添加到暂存区
- en: By default, Git will consider all files to be untracked and not part of your
    source control. Adding the files (also referred to as “staging” them) indicates
    that they should be included as part of your source control. Staging these files
    is the first part of a two-step process – first, we add files that we intend to
    commit; then, once we are sure everything that should be grouped as a single commit
    has been added, we can proceed to the second step.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Git 会认为所有文件都是未跟踪的，并且不属于源代码控制。添加文件（也叫做“暂存”文件）意味着这些文件应作为源代码控制的一部分。暂存这些文件是一个两步过程的第一步——首先，我们添加那些我们打算提交的文件；然后，一旦我们确认所有应归为一个提交的文件都已添加，我们就可以继续进行第二步。
- en: 'You can add a single file to your local Git repository, like so:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像下面这样将单个文件添加到本地 Git 仓库：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can add all files in the current directory, like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以像下面这样将当前目录中的所有文件添加进去：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this stage, they are not part of your local repository until you commit the
    changes, as shown in the next section. This is where it’s important to note that
    the current directory is not the same as your local repository. Although there
    may be many files in the local directory, they don’t form part of your local repository
    until you add and commit them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，直到你提交更改之前，这些更改不会成为本地仓库的一部分，正如下节所示。在这里需要注意的是，当前目录并不等同于本地仓库。尽管本地目录中可能有许多文件，但在你添加并提交这些文件之前，它们并不会成为本地仓库的一部分。
- en: Checking everything has been added before the commit
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交之前检查所有内容是否已添加
- en: 'While not strictly required, it is recommended to get into the habit of checking
    that everything you wish to commit has been added. This can easily be achieved
    using the `git status` command. In the following example output, we can easily
    see changes that have been added, changes that have been made but not added, and
    files that are not currently being tracked for changes. This last category may
    be because the files have been added to the `.gitignore` file, which, as its name
    suggests, is a list of files and paths that Git should ignore, or they could be
    empty directories:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不是强制要求，但建议养成检查你希望提交的所有内容是否已被添加的习惯。这可以通过使用`git status`命令轻松实现。在以下示例输出中，我们可以清楚地看到已添加的更改、已修改但未添加的更改，以及当前未被追踪的文件。最后一种情况可能是因为这些文件已被添加到`.gitignore`文件中，正如其名称所示，这个文件包含了
    Git 应该忽略的文件和路径，或者它们可能是空目录：
- en: '![Figure 3.1 – Example output of the git status command](img/Figure_3.01_B19436.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – git status 命令的示例输出](img/Figure_3.01_B19436.jpg)'
- en: Figure 3.1 – Example output of the git status command
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – git status 命令的示例输出
- en: Committing changes to the local repository
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交更改到本地仓库
- en: Once you have staged your changes with the `git add` command, you can create
    a snapshot of these modifications in your local repository with the `git commit`
    command. When you commit your changes, it is important to include a descriptive
    message that explains the purpose of the commit. This makes it easier for you
    and your collaborators to understand the version control history.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你使用`git add`命令暂存了更改，你可以使用`git commit`命令将这些修改的快照提交到本地仓库。当你提交更改时，重要的是要包含一个描述性的消息，说明提交的目的。这将使你和你的协作人员更容易理解版本控制历史。
- en: 'Many tools that work with Git, including GitHub, make use of certain formats
    and tags in commit messages. These not only help provide additional context to
    developers but can also drive workflow integrations, such as in bug-tracking tools.
    Writing commit messages in this way involves following certain guidelines to maintain
    readability and effectiveness. A commit message typically includes a header or
    title, the type of commit (such as `feat`, `fix`, `docs`, and so on), an optional
    scope to specify the area of change, and a subject that concisely describes the
    change. It can also contain a detailed explanatory body and a footer referencing
    related issue IDs. The subject and header are often limited to 50 characters and
    the body wraps at 72 characters. The commit message should be clear and concise,
    explaining what the commit does and why. To commit your staged changes with a
    commit message, use the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 许多与 Git 配合使用的工具，包括 GitHub，都会在提交信息中使用某些格式和标签。这些不仅有助于为开发人员提供额外的上下文，还可以驱动工作流集成，例如在错误跟踪工具中。以这种方式编写提交信息需要遵循一定的指南，以保持可读性和有效性。提交信息通常包括一个标题或主题、提交的类型（如`feat`、`fix`、`docs`等）、一个可选的范围来指定变更的区域，以及简洁描述变更的主题。它还可以包含详细的解释性正文和一个引用相关问题
    ID 的页脚。主题和标题通常限制为 50 个字符，正文在 72 个字符处换行。提交信息应简洁明了，解释提交的内容和原因。要通过提交信息提交暂存的更改，请使用以下命令：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can use the `git log` command to view commits made to your repository. By
    default, it will display an SHA-1 checksum, along with the author, date, and commit
    message of each commit. However, there are many options for filtering and searching
    the log, all of which you can find in Git’s built-in documentation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`git log`命令查看提交到仓库的历史记录。默认情况下，它将显示一个 SHA-1 校验和，以及每次提交的作者、日期和提交信息。然而，Git
    提供了许多选项用于过滤和搜索日志，你可以在 Git 的内置文档中找到所有这些选项。
- en: Connecting your remote repository
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接你的远程仓库
- en: 'With our changes committed to our local repository, we need to ensure that
    our remote repository has been connected correctly and is ready to push our changes.
    If it is not already connected, we can use the `git remote` command to connect
    it and provide it with a working alias. Conventionally, this alias is often referred
    to as `origin`, but you can use any name you like. An example of this command
    is shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将更改提交到本地仓库后，我们需要确保远程仓库已正确连接，并且准备好推送我们的更改。如果尚未连接，我们可以使用`git remote`命令将其连接，并为其提供一个工作别名。通常，这个别名被称为`origin`，但你也可以使用任何你喜欢的名称。以下是这个命令的示例：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command connects our remote repository at the URL specified, via the `origin`
    alias.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令通过`origin`别名连接到我们指定URL的远程仓库。
- en: Pushing changes to a remote repository
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将更改推送到远程仓库
- en: Once you’re confident that your local changes are stable and well tested, you
    can use the `git push` command to transfer these updates to the remote repository.
    This ensures that your changes are shared with other collaborators and makes the
    updated code accessible to anyone with access to the repository.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确认本地的更改是稳定且经过充分测试的，你可以使用`git push`命令将这些更新传送到远程仓库。这确保了你的更改能够与其他协作者共享，并使得任何有权限访问该仓库的人都可以访问更新后的代码。
- en: 'To perform a `git push` operation, simply run the following command in your
    terminal or Command Prompt:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行`git push`操作，只需在终端或命令提示符中运行以下命令：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By default, this command pushes your changes to the branch of the remote repository
    that is currently checked out in your local repository. However, you can also
    specify the remote repository and branch you want to push to, if necessary:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，该命令会将更改推送到你本地仓库当前检出的远程仓库分支。但是，如果需要，你也可以指定要推送到的远程仓库和分支：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Merging changes from one branch to another
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从一个分支合并更改到另一个分支
- en: If you’re working with an already existing Git repository, you may be working
    in a separate branch from the main branch – we’ll be looking at a few example
    branching strategies in this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用一个已存在的Git仓库，可能会在与主分支不同的分支上工作——我们将在本章中探讨几种常见的分支策略。
- en: If this is the case, you will eventually need to merge your changes into the
    main branch, which can be achieved with the `git merge` command. This ensures
    that the main branch incorporates the changes in your branch, without conflicts.
    Git will automatically try to merge the changes, but if conflicts arise, you’ll
    have to resolve them manually.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这种情况，你最终需要将更改合并到主分支中，这可以通过`git merge`命令实现。这确保主分支将你的分支中的更改合并进来，且没有冲突。Git会自动尝试合并更改，但如果出现冲突，你将需要手动解决。
- en: 'This manual resolution of conflicts involves going through the files that contain
    conflicts, such as lines of code that have been changed in both branches, and
    deciding which version should be kept as the final output. Git will automatically
    add sections marked with `<<<<<<<`, `=======`, and `>>>>>>>` to indicate where
    these conflicts exist within the file. The following code snippet demonstrates
    a typical example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 手动解决冲突涉及到逐一查看包含冲突的文件，比如两个分支都更改了的代码行，并决定最终应该保留哪个版本。Git会自动在文件中添加`<<<<<<<`、`=======`和`>>>>>>>`标记，表示冲突所在的区域。以下代码片段展示了一个典型的例子：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first marker shows the start of the conflicting lines. The second marker
    acts as a separator between the conflicting versions – everything before the marker
    is in the current branch and everything after it is in the branch to be merged.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个标记表示冲突行的开始。第二个标记作为冲突版本之间的分隔符——标记前的内容属于当前分支，标记后的内容属于待合并的分支。
- en: To resolve the conflict, delete the conflict markers and edit the code so that
    it reflects the intended version you wish to keep. It is important to consider
    the context and intention of the changes. For this reason, it is recommended to
    liaise with the author of the conflicting change wherever possible.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决冲突，删除冲突标记并编辑代码，使其反映你希望保留的版本。考虑更改的上下文和意图非常重要。因此，建议尽可能与冲突更改的作者进行沟通。
- en: Merge strategies
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并策略
- en: 'When it comes to merging changes between branches, it’s worth taking a brief
    look at merge strategies. These are the different approaches used by Git to determine
    how it handles the conflicting changes and merges them, as well as how it manages
    different situations during the merge process. Here are a few examples, although
    there are many more:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理分支之间的更改合并时，值得简要了解一下合并策略。这些是Git用于确定如何处理冲突更改并将其合并的不同方法，同时也是它如何管理合并过程中不同情况的方式。以下是一些例子，虽然还有许多其他策略：
- en: '**Recursive**: The recursive strategy is Git’s default strategy and works for
    most common scenarios. It analyzes the commit history of both branches to determine
    a common starting point before the branches diverged and then applies changes
    from both branches. If it hits a conflict along the way, it will prompt for manual
    intervention.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**递归**：递归策略是Git的默认策略，适用于大多数常见场景。它分析两个分支的提交历史，以确定分支分歧前的共同起点，然后应用两个分支的更改。如果在过程中遇到冲突，它会提示进行手动干预。'
- en: '**Octopus**: The octopus strategy is used to merge multiple branches into a
    single branch. For example, you may want to merge multiple feature branches into
    a single release branch.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**章鱼**：章鱼策略用于将多个分支合并为一个分支。例如，你可能想将多个特性分支合并到一个发布分支中。'
- en: '**Resolve**: The resolve strategy is similar to the recursive strategy, in
    that it will attempt to automatically merge changes and pause for manual intervention
    if conflicts are detected. The difference in this strategy, however, is that it
    doesn’t recursively analyze the commit history.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**解决**：解决策略与递归策略类似，它会尝试自动合并更改，并在检测到冲突时暂停以进行手动干预。然而，这一策略的不同之处在于，它不会递归分析提交历史。'
- en: '**Ours**: The ours strategy is designed to give preference to the branch being
    merged into. Like the other strategies, it will automatically merge where no conflicts
    exist, but in the event of a conflict, it will discard changes from the incoming
    branch and keep the current version. As you might have guessed at this point,
    the opposing strategy, in which the incoming changes are favored, is called the
    **theirs** strategy.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**我们的**：我们的策略旨在优先考虑被合并的分支。与其他策略一样，它会在没有冲突的情况下自动合并，但如果发生冲突，它会丢弃来自进入分支的更改，保留当前版本。正如你可能已经猜到的那样，与此相对的策略是优先考虑进入更改的**他们**策略。'
- en: '**Subtree**: The subtree merge strategy is used to merge changes from a remote
    repository into a subfolder of your current repository. This can be useful for
    very modular projects, or libraries of code that you wish to incorporate into
    larger projects.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子树**：子树合并策略用于将远程仓库的更改合并到当前仓库的子文件夹中。这在非常模块化的项目中或希望将代码库集成到更大项目中的情况中特别有用。'
- en: These strategies are just a glimpse of the available options for merging in
    Git. You have the flexibility to choose the desired merge strategy by utilizing
    command-line options or configuration settings. Which merge strategy you choose
    depends on the specific needs and complexities of your project.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略只是Git中可用的合并选项的一部分。你可以通过使用命令行选项或配置设置来选择所需的合并策略。你选择哪种合并策略取决于项目的具体需求和复杂性。
- en: Creating a new branch
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新分支
- en: As we’ll see in the next section on branching strategies, when you are about
    to start working on a new feature, bug fix, or any other change, it’s a common
    practice to create a new branch, often referred to as a **feature branch**. This
    ensures that your work is isolated from the main branch, which is usually more
    stable and production-ready.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一节关于分支策略中看到的，当你准备开始处理新特性、修复bug或其他更改时，创建一个新分支（通常称为**特性分支**）是一个常见做法。这样可以确保你的工作与主分支隔离，主分支通常更加稳定并且适用于生产环境。
- en: 'To create a new branch, you can use the `git branch` command, followed by the
    desired branch name:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新分支，你可以使用`git branch`命令，后跟所需的分支名称：
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Switching to a different branch
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换到另一个分支
- en: 'To switch to another branch from the current one in use, simply check out that
    branch, like so:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要从当前使用的分支切换到另一个分支，只需检出该分支，如下所示：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Alternatively, you can create a new branch and switch to it with a single command
    using the `-``b` flag:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，你可以使用`-b`标志通过单个命令创建并切换到新分支：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that you’ve created and switched to your new branch, you can start making
    changes to the code base without them affecting the main branch. Once your work
    is complete and has been tested, you can merge your feature branch back into the
    main branch, ensuring a clean and organized version control history.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建并切换到新的分支，你可以开始修改代码库，而不会影响主分支。一旦工作完成并经过测试，你可以将特性分支合并回主分支，从而确保版本控制历史的清晰和有序。
- en: Viewing commit history
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看提交历史
- en: 'The `git log` command allows you to see the history of all commits that make
    up your current branch – this could consist of commits directly to the branch,
    commits merged from other branches, or commits made from the original branch that
    your branch was created from. You can view this history, including any commit
    messages, like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`git log` 命令可以让你查看当前分支的所有提交历史——这包括直接提交到该分支的提交、从其他分支合并过来的提交，或者从创建该分支的原始分支所做的提交。你可以这样查看这些历史记录，包括任何提交消息：'
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Reverting to a previous version of a file
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚到文件的先前版本
- en: 'It is possible to revert a specific file to a previous version, as opposed
    to reverting an entire commit that may contain multiple file changes. Using the
    commit hash from the log shown in the commit history and the name of the file
    you wish to restore from that point in time, you can check out the file, like
    so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将特定文件回滚到先前的版本，而不是回滚包含多个文件更改的整个提交。通过使用提交历史中显示的提交哈希值和你想恢复的文件名，你可以将文件检出，如下所示：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Git rebasing
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git 变基
- en: '**git rebase** is a way to integrate changes from one branch into another.
    It involves replaying the commits from the feature branch on top of the base branch,
    which replaces the feature branch with an updated version that includes all the
    changes from the base branch.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**git rebase** 是一种将一个分支的更改集成到另一个分支的方法。它通过将特性分支的提交重放到基础分支之上，替换特性分支为一个更新版本，该版本包含基础分支的所有更改。'
- en: The main principle behind `git rebase` is to maintain a linear history, which
    makes it easier to understand and follow the changes made to the code over time.
    A linear history means that there are no merge commits (a special type of commit
    when merges are made, to maintain the history of both branches going forward),
    only a straight line of commits.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`git rebase` 的主要原则是保持线性历史，这使得理解和追踪代码随时间变化的更改更加容易。线性历史意味着没有合并提交（合并时创建的一种特殊类型的提交，用以维持两个分支历史的延续），只有一条直线的提交记录。'
- en: '`git rebase` also helps in resolving conflicts that may arise while merging.
    Instead of creating a merge commit, it replays commits one by one on top of the
    base branch, which can make conflicts easier to resolve. It’s important to note
    that `git rebase` modifies the existing commits, and it can cause issues if other
    people have already pulled the feature branch. *Therefore, it’s recommended to
    only use git rebase on branches that haven’t been shared* *with others.*'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`git rebase` 还有助于解决在合并时可能出现的冲突。它不会创建合并提交，而是将提交逐一重放到基础分支之上，这样有助于更容易地解决冲突。需要注意的是，`git
    rebase` 会修改现有的提交，如果其他人已经拉取了特性分支，可能会引发问题。*因此，建议仅在尚未与他人共享的分支上使用 git rebase* *。*'
- en: In summary, `git rebase` is a powerful command that can help keep your Git history
    clean and easy to understand, but it *should be used with caution*. Now that we’ve
    looked at the foundational Git commands and why they are used in our workflow,
    let’s discuss branching strategies.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`git rebase` 是一个强大的命令，可以帮助保持 Git 历史的简洁和易于理解，但*应该谨慎使用*。现在我们已经了解了基础的 Git
    命令及其在工作流中的应用，接下来我们来讨论分支策略。
- en: Effective Salesforce branching strategies
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有效的 Salesforce 分支策略
- en: When developing features in version control, a branching strategy establishes
    guidelines for how branches are utilized and managed. However, there is no single
    strategy that is ideal for every team. The best strategy for your team will depend
    on several factors, such as team size, team structure/complexity, the desired
    release schedule, and the current workflow.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本控制中开发特性时，分支策略为如何使用和管理分支制定了指南。然而，并没有一种适用于所有团队的单一策略。适合你团队的最佳策略将取决于多个因素，比如团队规模、团队结构/复杂性、期望的发布计划和当前的工作流。
- en: For example, larger teams may require a more complex strategy to accommodate
    different roles, while a simpler strategy may be more suitable for smaller teams.
    Additionally, business requirements may dictate a specific release cycle, and
    the branching strategy should be able to accommodate those needs. Furthermore,
    it is important to consider how your current workflow and environment setup (for
    example, the number of sandboxes) may align with the chosen branching strategy.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，较大的团队可能需要更复杂的策略来适应不同的角色，而较简单的策略可能更适合较小的团队。此外，业务需求可能要求特定的发布周期，分支策略应能够满足这些需求。此外，重要的是要考虑您当前的工作流程和环境设置（例如，沙盒的数量）如何与所选择的分支策略保持一致。
- en: Git as a backup
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git 作为备份
- en: The first strategy we can look at is using Git as a lightweight backup of your
    Salesforce metadata. This approach is frequently the initial step teams take when
    they start version-controlling their metadata. They establish one branch per environment
    and begin transferring metadata from their orgs to the branches.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑的第一个策略是使用 Git 作为你的 Salesforce 元数据的轻量级备份。这种方法通常是团队在开始对其元数据进行版本控制时采取的初始步骤。他们为每个环境建立一个分支，并开始将元数据从他们的组织转移到这些分支上。
- en: While this is a good initial approach to getting metadata into Git, the development
    life cycle is not truly source-driven in this way. Version control does not serve
    as the primary source of truth here, but rather as a retrospective record of the
    changes that have already occurred. It is still useful, but to fully reap the
    benefits of Git, it is important to ensure that once changes have been developed,
    they are placed into version control to facilitate a smooth flow between environments.
    Additionally, this model often results in isolated environment branches, where
    changes aren’t exchanged between them in source control. Consequently, transitioning
    from this model to establish source control as the definitive source of truth
    can be challenging. This is primarily because the same file in each organizational
    branch lacks a shared commit history, which can make it difficult for Git to handle
    them.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是将元数据输入 Git 的一个很好的初始方法，但是开发生命周期并非真正源驱动。版本控制在这里不是主要的真实来源，而是对已发生更改的回顾记录。它仍然有用，但为了充分利用
    Git 的好处，重要的是确保一旦开发了更改，就将它们放入版本控制中，以促进在环境之间的平稳流动。此外，这种模型通常会导致孤立的环境分支，在这些分支中，更改不会在源控制中进行交换。因此，从这种模型过渡到建立源控制作为真实来源的模型可能会具有挑战性。这主要是因为每个组织分支中的同一文件缺乏共享的提交历史，这可能会使
    Git 难以处理它们。
- en: For instance, with this workflow, it can be difficult to accommodate parallel
    development streams for multiple features. There are no pull requests in this
    model, which allows you to easily integrate peer review into the workflow.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用这种工作流程，很难适应多个功能的并行开发流。在这种模型中没有拉取请求，这使得您可以轻松地将同行评审集成到工作流程中。
- en: Additionally, because changes are not regularly deployed from version control
    into the environments, there may be less confidence in the ability to roll back
    a release by deploying an older revision from version control.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于不会定期从版本控制中部署更改到环境中，因此可能会对通过从版本控制中部署旧版本来回滚发布的能力缺乏信心。
- en: It is important to remember that version control is primarily designed to assist
    teams in creating, tracking, and deploying new features. It should not be viewed
    as a comprehensive backup of Salesforce environments for disaster recovery purposes,
    as that is the role of backup solutions in a comprehensive DevOps strategy.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，版本控制主要是为了帮助团队创建、跟踪和部署新功能。不能把它视为灾难恢复目的的 Salesforce 环境的全面备份，因为这是综合 DevOps
    策略中备份解决方案的角色。
- en: 'You can see an example of using Git as a backup, and how the branches mirror
    your Salesforce environments, in the following diagram:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下图表中看到使用 Git 作为备份的示例，以及分支如何反映您的 Salesforce 环境：
- en: '![Figure 3.2 – Git as a backup](img/Figure_3.02_B19436.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – Git 作为备份](img/Figure_3.02_B19436.jpg)'
- en: Figure 3.2 – Git as a backup
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – Git 作为备份
- en: Trunk-based development
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: With **trunk-based development** (**TBD**), all developers work on a single
    branch, called the **trunk** or **main**. Feature toggles are used to hide incomplete
    work. Branches are short-lived and are merged back into the main branch as soon
    as possible. While the thought of merging your work into the main branch daily
    (or even multiple times a day) might seem daunting, many teams find that the benefits
    of TBD far outweigh the initial discomfort. Embracing TBD can lead to increased
    collaboration, higher-quality code, and a more streamlined development process.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在**主干开发**（**TBD**）中，所有开发者都在一个单独的分支上工作，这个分支被称为**主干**或**主分支**。功能开关用于隐藏未完成的工作。分支的生命周期较短，并会尽快合并回主分支。尽管每天（甚至一天多次）将工作合并到主分支的想法可能看起来令人畏惧，但许多团队发现，TBD的好处远远超过了最初的不适应。采用TBD可以促进更多的合作、更高质量的代码以及更加简化的开发过程。
- en: 'In TBD, developers create branches for new features or bug fixes, but these
    branches are short-lived. They are merged back into the main branch as soon as
    possible, often within a day. To avoid unfinished features being pushed into production,
    TBD employs feature toggles (also known as feature flags). This allows teams to
    hide features until they are ready for production use. With everyone merging their
    changes into the main branch frequently, CI is necessary. Automated testing ensures
    that the main branch is always in a releasable state. You’ll notice that the diagram
    for this approach (see *Figure 3**.2*) and the feature branch one (see *Figure
    3**.3*), are extremely similar. The fundamental difference between the two strategies
    is that the branches for TBD are much more granular in their scope and short-lived:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在TBD中，开发者为新功能或修复创建分支，但这些分支的生命周期较短。它们会尽快合并回主分支，通常在一天内。为了避免未完成的功能被推送到生产环境，TBD使用功能开关（也叫功能标志）。这使得团队可以隐藏功能，直到它们准备好投入生产使用。由于每个人都频繁将他们的更改合并到主分支中，因此需要持续集成（CI）。自动化测试确保主分支始终处于可发布状态。你会注意到，这种方法的图示（见*图
    3.2*）与功能分支的图示（见*图 3.3*）非常相似。两者之间的根本区别在于，TBD的分支范围更为细化，生命周期也更短：
- en: "![Figure 3.3 – \uFEFFTBD](img/Figure_3.03_B19436.jpg)"
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3 – TBD](img/Figure_3.03_B19436.jpg)'
- en: Figure 3.3 – TBD
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 – TBD
- en: The feature branch model
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能分支模型
- en: The feature branch model is a basic approach that integrates Git into the development
    process, rather than just being used for backup. While some teams may choose more
    complex branching methods, the feature branch model is a good starting point due
    to its simplicity. The master branch is the only long-term, permanent branch.
    When you work on new features or fixes, a separate branch is created from the
    main branch, and once completed, it is merged back into the main branch.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 功能分支模型是一种基本的开发方法，它将Git集成到开发过程中，而不仅仅是用于备份。虽然一些团队可能选择更复杂的分支方法，但由于其简单性，功能分支模型是一个很好的起点。主分支是唯一的长期存在的永久分支。当你在开发新功能或修复时，会从主分支创建一个独立的分支，完成后将其合并回主分支。
- en: In this model, it is best to keep feature branches as short-lived as possible
    and delete them after use for cleanliness. Large features should be divided into
    smaller chunks and implemented one at a time to shorten the feedback cycle and
    decrease the likelihood of merge conflicts. It should be noted that any failure
    in the master branch is a blocker to the whole release process since it relies
    on all the prod-ready testing to happen on each feature branch, which is not always
    realistic.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种模型中，最好将功能分支的生命周期保持尽可能短，并在使用后删除它们以保持清洁。大的功能应该分成更小的块，一次实现一个，以缩短反馈周期并减少合并冲突的可能性。需要注意的是，主分支中的任何失败都会阻碍整个发布过程，因为它依赖于所有生产就绪的测试都在每个功能分支上进行，而这并不总是现实的。
- en: The master branch is typically deployed automatically to a staging environment
    using a CI process, making the latest version readily available for testing. Once
    the version in the staging environment is satisfactory, a deployment from the
    master branch to the production environment releases the changes to the end users.
    As an option, before deploying to production, the changes can be deployed to a
    **User Acceptance Testing** (**UAT**) or **quality assurance** (**QA**) environment
    for further testing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 主分支通常通过CI流程自动部署到预发布环境，使最新版本可供测试。一旦预发布环境中的版本令人满意，就可以从主分支部署到生产环境，将更改发布给最终用户。作为一种选择，在部署到生产环境之前，可以将更改部署到**用户验收测试**（**UAT**）或**质量保证**（**QA**）环境中进行进一步测试。
- en: The following diagram shows a typical feature branch model and how changes in
    that branch are re-integrated into the master branch so that they can be deployed
    in your Salesforce environments.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示显示了一个典型的功能分支模型，以及该分支中的更改如何重新集成到主分支中，以便在你的 Salesforce 环境中部署。
- en: "![Figure 3.4 – The feature br\uFEFFanch model](img/Figure_3.04_B19436.jpg)"
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 功能分支模型](img/Figure_3.04_B19436.jpg)'
- en: Figure 3.4 – The feature branch model
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 功能分支模型
- en: The protected master branch model
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受保护的主分支模型
- en: The protected master branch model is similar to the feature branch model, but
    it includes an additional long-lived branch for integration before merging into
    the master branch. In this model, the master branch is not updated until everything
    has been fully tested and is ready for release. The master branch is a more secure
    source of truth since only work that has been thoroughly tested in UAT is included
    in the branch.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护的主分支模型类似于功能分支模型，但它包括一个额外的长期存在的集成分支，在合并到主分支之前进行集成。在这种模型中，主分支在所有内容完全测试并准备好发布之前不会更新。主分支是一个更安全的真相来源，因为只有在用户验收测试（UAT）中经过彻底测试的工作才会被纳入该分支。
- en: However, one downside of this model is that it is not possible to propagate
    only a subset of changes if some are not ready yet. If some work has been tested
    and approved in UAT, but other work is not ready, it is difficult to selectively
    promote changes to the master branch. Instead, it is necessary to revert features
    that are not yet ready from the release branch. This inflexibility is a major
    concern for many teams, which is why this model is not as popular. If you find
    that you need to selectively promote changes regularly, then you have not selected
    the right branching strategy for your way of working.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模型的一个缺点是，如果某些更改尚未准备好，无法只传播一部分更改。如果某些工作已经在 UAT 中经过测试和批准，而其他工作还未准备好，那么很难选择性地将更改推广到主分支。相反，必须从发布分支中恢复尚未准备好的功能。这种刚性是许多团队关切的主要问题，这也是为什么这种模型不那么流行的原因。如果你发现自己需要定期选择性地推广更改，那么你可能没有为你的工作方式选择合适的分支策略。
- en: 'The following diagram illustrates the protected master branch approach, with
    its separate integration branch for testing changes before they reach production:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了受保护的主分支方法，其中包括一个单独的集成分支，用于在更改进入生产环境之前进行测试：
- en: '![Figure 3.5 – The protected master branch model](img/Figure_3.05_B19436.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 受保护的主分支模型](img/Figure_3.05_B19436.jpg)'
- en: Figure 3.5 – The protected master branch model
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 受保护的主分支模型
- en: The expanded branching model
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展的分支模型
- en: Taking the process of isolating branches a step further, the expanded branching
    model includes several additional long-lived branches that correspond to the integration
    and UAT/QA environments. Instead of merging feature branches directly into the
    master branch, they are first merged into the integration branch. To move changes
    that are ready for release to the next environment in sequence, they are merged
    into the UAT/QA branch, and then into the master branch.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在将分支隔离的过程中，扩展的分支模型包括几个额外的长期存在的分支，这些分支分别对应集成和 UAT/QA 环境。功能分支不会直接合并到主分支，而是先合并到集成分支中。为了将已准备好的更改顺利推进到下一个环境，它们会先合并到
    UAT/QA 分支，然后再合并到主分支。
- en: This approach allows for more precise control over which changes are deployed
    to each environment and allows for isolated evaluations of changes on a per-request
    basis. The expanded branching model is well suited to teams that prioritize gating
    and quality control over frequent releases. However, like every other branching
    strategy we’ve looked at, there are still some important caveats, particularly
    if merge conflicts are encountered. For example, if merge conflicts are found
    during the merge to UAT, then the entirety of the UAT branch will need to be merged
    in to resolve them, which would mean that a subsequent merge to master would bring
    in the whole of the UAT branch too, whether it is ready to be promoted or not.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以更精确地控制哪些更改会被部署到每个环境，并允许对每个请求中的更改进行独立评估。扩展的分支模型非常适合那些更重视门控和质量控制而非频繁发布的团队。然而，像我们之前看到的其他分支策略一样，它也有一些重要的注意事项，特别是当遇到合并冲突时。例如，如果在合并到
    UAT 时发现合并冲突，那么必须将整个 UAT 分支合并，以解决冲突，这意味着随后合并到主分支时，UAT 分支的所有内容都会被带入，无论这些内容是否已经准备好发布。
- en: 'You can see the correlation between branches and Salesforce environments in
    the following diagram:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下图示中看到分支与 Salesforce 环境之间的关联：
- en: '![Figure 3.6 – The expanded branching model](img/Figure_3.06_B19436.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 扩展分支模型](img/Figure_3.06_B19436.jpg)'
- en: Figure 3.6 – The expanded branching model
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 扩展分支模型
- en: Comparing the branching strategies
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较分支策略
- en: 'So, let’s recap and summarize these four approaches:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们回顾并总结这四种方法：
- en: 'Using Git as a backup is pretty self-explanatory: we use it as a mechanism
    to save our metadata off-platform, which allows us to revert changes – although
    this is not easy if the change is several Git commits back and there are deep
    chains of dependencies. It also doesn’t deliver any of the main benefits of a
    source-driven development approach.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Git 用作备份是显而易见的：我们使用它作为一种机制，将我们的元数据保存到平台之外，从而允许我们回滚更改——虽然如果变更距离当前有好几次 Git 提交，并且存在深层依赖关系时，这并不容易。它也未能提供源驱动开发方法的主要优势。
- en: The TBD approach offers an array of advantages that streamline and accelerate
    software development. By promoting frequent integration of short-lived branches,
    it drastically reduces the occurrence of “merge hell,” the oft-dreaded scenario
    of conflicting changes. The visibility of changes is also greatly enhanced as
    most work is carried out on the main branch, facilitating a clearer understanding
    of how alterations impact the project. TBD simplifies the development process
    by eliminating the need to maintain multiple long-lived branches and keeps the
    main branch in a perpetually releasable state, enabling any-time deployment and
    thus, quicker delivery of features.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TBD 方法提供了一系列优势，可以简化并加速软件开发。通过促进短生命周期分支的频繁集成，它大大减少了“合并地狱”现象的发生——即经常让人头痛的冲突变更情况。由于大部分工作都在主分支上进行，变更的可见性也得到了极大的提升，从而使得开发人员可以更清楚地了解变更如何影响项目。TBD
    通过消除维护多个长期分支的需求，简化了开发过程，并使主分支始终处于可发布状态，从而支持随时部署，进而实现更快的功能交付。
- en: The feature branch model is great for teams that rapidly iterate – we use it
    ourselves internally and it allows us to deliver changes daily, or often more
    frequently than that. If your process requires more stage gates and checks along
    the way, this may not work for your longer dev cycles.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特性分支模型非常适合快速迭代的团队——我们内部也在使用该模型，这让我们能够每天交付变更，或者更频繁地交付。如果你的流程需要更多的阶段性检查和验证，那么这种方式可能不适合你的较长开发周期。
- en: The protected master branch model has multiple testing environments and an integration
    branch to support them, which means that your primary master or main branch is
    the source of truth. However, this model still acts as a queue, where items that
    require longer test cycles can hold up other changes until they’re promoted.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护主分支模型有多个测试环境和一个集成分支来支持它们，这意味着你的主分支或主干分支是事实来源。然而，这个模型仍然充当了一个队列，长周期测试的项目可能会阻塞其他变更，直到它们被推进。
- en: The expanded branch model allows for a more asynchronous approach to changes,
    with individual pieces of work that can be moved through the environments. This
    allows for questions in the style of “Bob, where are we with Jira 34533?” to be
    answered accurately in the style of “It’s in UAT awaiting sign-off for release
    to production, Sarah.”
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展分支模型允许更为异步的变更方式，每个独立的工作单元可以在环境中流动。这让类似于“Bob，我们在 Jira 34533 上进展如何？”的问题能够被准确回答，比如“它正在
    UAT 环境中，等待生产发布的签署，Sarah。”
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we looked at the reasons why source control is fundamental
    to the adoption of DevOps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了源代码管理为何对 DevOps 的采用至关重要：
- en: '**Collaboration**: DevOps emphasizes collaboration in software development.
    Source control allows multiple developers to work concurrently on a code base
    without them having to interfere with each other’s changes. By merging and reviewing
    changes later, teams can achieve faster development and reduce defects.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作**：DevOps 强调软件开发中的协作。源代码管理允许多个开发人员并行工作在同一代码库上，而无需干扰彼此的更改。通过在后期合并和审查变更，团队能够实现更快的开发并减少缺陷。'
- en: '**Traceability**: The growing need for governance in software development demands
    accountability and audit trails. Source control provides a comprehensive history
    of code and configuration changes, including details about the who, what, and
    why. This not only aids in auditing but also assists in identifying the origin
    of bugs and issues.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可追溯性**：软件开发中对治理的需求日益增长，这要求具备问责制和审计追踪。源代码管理提供了代码和配置变更的完整历史记录，包括关于谁、什么、为什么的详细信息。这不仅有助于审计，还帮助识别错误和问题的来源。'
- en: '**Automation**: DevOps emphasizes automation, and source control serves as
    a foundation for automating software development processes such as building, testing,
    and deploying code. This allows for the automatic execution of these tasks upon
    committing changes to the code base.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：DevOps 强调自动化，源代码管理作为自动化软件开发过程（如构建、测试和部署代码）的基础。这使得在提交更改到代码库后，可以自动执行这些任务。'
- en: '**Continuous integration**: CI enables developers to frequently merge code
    changes into a shared repository and run automated tests, facilitated by source
    control. This practice helps detect and resolve issues early, streamlining the
    development process.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成**：持续集成（CI）使开发人员能够频繁地将代码更改合并到共享仓库，并运行自动化测试，源代码管理在此过程中提供了便利。这种做法有助于及早发现和解决问题，从而简化开发流程。'
- en: '**Continuous deployment**: CD automatically deploys code changes to production
    after passing CI tests, with source control enabling automation. This integration
    of CI and CD forms the CI/CD pipeline.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续部署**：持续部署（CD）在通过持续集成（CI）测试后，自动将代码更改部署到生产环境，并通过源代码管理实现自动化。这种 CI 和 CD 的集成形成了
    CI/CD 流水线。'
- en: '**Rollbacks**: Source control enables easy rollbacks by maintaining a code
    base history, allowing you to quickly revert to previous versions in case there
    are bugs or issues in the production environment. This ensures you can efficiently
    and reliably handle unexpected problems.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚**：源代码管理通过维护代码库历史记录来简化回滚操作，使您能够在生产环境中出现漏洞或问题时迅速恢复到先前的版本。这确保了您可以高效且可靠地处理意外问题。'
- en: We then explored some typical Git operations that you’re likely to use regularly
    as you work on creating changes to your Salesforce orgs. Finally, we looked at
    some of the common Git branching strategies for Salesforce development, and the
    advantages and disadvantages of each.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了一些您在创建 Salesforce 组织更改时可能会定期使用的典型 Git 操作。最后，我们还讨论了一些适用于 Salesforce
    开发的常见 Git 分支策略，以及每种策略的优缺点。
- en: In the next chapter, we will look at the next fundamental part of a mature Salesforce
    DevOps process – testing your changes effectively to ensure quality deliverables.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨成熟的 Salesforce DevOps 流程中的下一个基本部分——有效地测试您的更改，以确保高质量的交付物。
