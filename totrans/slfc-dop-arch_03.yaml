- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Value of Source Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we move toward the technical aspects of Salesforce DevOps, we should start
    by exploring **source control**. In this chapter, we’re going to cover the following
    main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why source control is vital for the implementation of a DevOps process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fundamental Git operations for managing your changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effective Git branching strategies for successful delivery with source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source control, also referred to as **version control**, is the technical backbone
    of modern DevOps, and all other tools and techniques are built upon that solid
    foundation. By tackling this topic first and looking at some of the common tasks
    it entails, you will have a solid foundation for the topics discussed later in
    this book, such as CI/CD automation.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples in this chapter all pertain to the **Git** source control system
    and it is recommended that you have it installed if you want to follow along.
    Equally, a Git hosting provider is recommended. Many are available, such as GitHub,
    GitLab, and BitBucket. However, in our examples, we’ll be using GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of source control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While establishing a DevOps culture is the most important aspect of DevOps from
    a process perspective, as we saw in the previous chapter, it’s fair to say that
    source control is the most important technical aspect. It underpins all the other
    tools and techniques of a mature DevOps process and enables deployments, peer
    review, rollbacks, and automation as part of a CI/CD process. Let’s explore some
    of the advantages afforded by source control and the processes that build upon
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DevOps is fundamentally a collaborative approach to software development, so
    effective collaboration is vital. Source control enables multiple developers to
    work on the same code base simultaneously while indicating when they could be
    overlapping or overwriting each other’s changes during the development phase.
    Changes are merged later, and when coupled with appropriate reviews, they allow
    for rapid development and fewer defects, since changes are tested and reviewed
    far earlier in the development cycle. Only when manual and automated checks have
    passed does code make it higher up the environments toward production. It’s worth
    noting that production issues are harder to track down and more expensive to deal
    with compared to development environments.
  prefs: []
  type: TYPE_NORMAL
- en: Traceability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the importance of good governance grows across all processes and businesses,
    including software development, so does the need to have accountability and audit
    trails of software change. Source control facilitates this with a complete history
    of all changes to your code and configurations, detailing what was changed, by
    whom, and (with diligence around commit messages, comments, and references to
    change management tools such as Jira) why the change occurred. In addition to
    these audit trail benefits, a complete history also helps you find the origin
    of bugs and issues.
  prefs: []
  type: TYPE_NORMAL
- en: Automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DevOps relies heavily on automation, and source control provides the foundation
    for automating many of the processes involved in software development, such as
    building, testing, and deploying code. For example, with source control, it’s
    possible to automatically build, test, and deploy code to different environments
    every time a change is committed.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**) allows developers to integrate their code
    changes from their development or feature branches into a shared integration branch,
    and then run automated tests to ensure that the changes do not break the existing
    system. This process is made possible by source control as it allows developers
    to easily merge their changes and track conflicts. By adopting this technique
    and regularly integrating changes into the main code, developers can detect issues
    earlier, which makes it easier to fix them.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Continuous deployment** (**CD**) is a practice where code changes are automatically
    deployed to production after they pass through the CI process. This process is
    also made possible by source control as it allows the deployment process to be
    automated. This can be accomplished by using general-purpose CI/CD tools such
    as Jenkins, Travis CI, and CircleCI, or with Salesforce-specific tools such as
    DevOps Center, Gearset, or Copado. Regardless of the tool you choose, they can
    be configured to automatically deploy code changes to production when they pass
    through the CI process. This is the reason why CI and CD are usually grouped into
    the CI/CD process.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery (also CD)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other CD you may hear concerning DevOps is **continuous delivery**. Its
    shared initials with continuous deployment often create a lot of confusion. The
    aim of CI/CD is continuous delivery: promptly and dependably delivering enhanced
    value to users. Distinct from continuous integration and continuous deployment,
    which are workflows or specific processes, continuous delivery delineates a working
    culture or methodology. Grounded in a practice of progressive enhancements, continuous
    delivery focuses on diminishing lead times and curtailing the development cycle,
    which includes swift feedback from all parties involved.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach enables Salesforce teams to aid their businesses in responding
    swiftly and more flexibly to evolving priorities and market prospects. Both CI
    and CD are processes that help teams accomplish continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Rollbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Source control allows for easy rollbacks, which lets you revert to a previous
    version of the code base if there are issues with the incoming changes. It is
    important to be able to roll back changes quickly and easily in case of bugs or
    other issues that may arise in the production environment. This is made possible
    by source control as it keeps a history of all the changes that have been made
    to the code base, making it easier to revert to a previous version if needed.
    However, keep in mind that not everything can be reverted in Salesforce. For example,
    if you are trying to revert a commit that contained a record type or a new flow
    and that change was deployed to an org, then you may have issues reverting that
    change. Record types cannot be removed via the Metadata API, and flows require
    you to specify the version number to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Incremental development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another significant advantage of a source-control-driven approach to development
    and deployment is that it encourages developers to think incrementally – one commit
    at a time. This further supports many of the points covered previously – committing
    changes in smaller incremental chunks has the potential to make it easier to manage
    and merge work done by other team members, reducing the chance of code conflicts.
    It also makes debugging and tracking issues easier since you can compare the current
    version with the previous commit to see the net difference. Finally, it encourages
    better coding standards, in which smaller commits tend to promote more modular,
    decoupled code architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at the many advantages of using source control, and why
    it is so important to a mature DevOps process, let’s look at some of the core
    Git tasks and commands that bring source control to life.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamental Git operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the sea of Git commands and how they come into play, it’s
    essential to get a firm grasp of the basics of source control.
  prefs: []
  type: TYPE_NORMAL
- en: Commits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A commit is a snapshot of your project’s files and directories at a specific
    point in time. Every commit is assigned a unique identifier (known as a SHA hash)
    and includes metadata such as the author, timestamp, and a descriptive message
    explaining the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Commits aren’t just frozen moments in time, though. They’re also part of a larger
    narrative that reflects your project’s evolution. In Git, commits are linked in
    a chain, with each commit referencing its predecessor. This allows you to traverse
    your project’s history, compare versions, or even revert changes when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Staging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can commit changes in Git, you need to **stage** them. The staging
    area, also known as the index, is like a preparation zone where you gather and
    organize your changes before making a commit. Staging changes allows you to create
    meaningful, well-organized commits that communicate what you’ve done and why.
  prefs: []
  type: TYPE_NORMAL
- en: When you stage a file, you are telling Git that you want to include updates
    to that file in the next commit. However, it is important to note that Git stages
    a file exactly as it is when you stage it. If you continue to make changes to
    a file after staging it, you will need to stage it again to include the latest
    changes in your next commit.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A repository, often abbreviated to `git init` command in the directory that
    contains your source code.
  prefs: []
  type: TYPE_NORMAL
- en: Putting source control into practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this book is not intended to give an *exhaustive* overview of Git’s myriad
    of commands and options, there are a few key operations that make up Git’s typical
    usage.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, it’s important to note the difference between a local repository and
    a remote repository since many Git commands are specifically for moving changes
    between the two.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, a local repository exists on your local development machine
    and can be either a newly initialized repository or one that you have cloned from
    another (usually remote) repository. Operations carried out on this repository
    will remain on your local machine until you push those changes to a remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: A remote repository is hosted on a remote server – either with a Git hosting
    provider or a physical server, perhaps within your own company’s data center.
    This remote repository serves as the centralized source of truth from which other
    developers can get your changes and vice versa. With this distinction between
    local and remote repositories in mind, let’s start looking at some common Git
    operations and the commands to carry them out.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a new repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The initial step in any source control workflow is to create a repository in
    which to store your work, and while it is likely you will be working with a repository
    that already exists, creating a new repository can be achieved by running the
    following command in the directory that contains your source code. This will create
    a brand-new empty repository locally, into which you can then start adding files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Adding new files to the staging area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, Git will consider all files to be untracked and not part of your
    source control. Adding the files (also referred to as “staging” them) indicates
    that they should be included as part of your source control. Staging these files
    is the first part of a two-step process – first, we add files that we intend to
    commit; then, once we are sure everything that should be grouped as a single commit
    has been added, we can proceed to the second step.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add a single file to your local Git repository, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can add all files in the current directory, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, they are not part of your local repository until you commit the
    changes, as shown in the next section. This is where it’s important to note that
    the current directory is not the same as your local repository. Although there
    may be many files in the local directory, they don’t form part of your local repository
    until you add and commit them.
  prefs: []
  type: TYPE_NORMAL
- en: Checking everything has been added before the commit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While not strictly required, it is recommended to get into the habit of checking
    that everything you wish to commit has been added. This can easily be achieved
    using the `git status` command. In the following example output, we can easily
    see changes that have been added, changes that have been made but not added, and
    files that are not currently being tracked for changes. This last category may
    be because the files have been added to the `.gitignore` file, which, as its name
    suggests, is a list of files and paths that Git should ignore, or they could be
    empty directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Example output of the git status command](img/Figure_3.01_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Example output of the git status command
  prefs: []
  type: TYPE_NORMAL
- en: Committing changes to the local repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have staged your changes with the `git add` command, you can create
    a snapshot of these modifications in your local repository with the `git commit`
    command. When you commit your changes, it is important to include a descriptive
    message that explains the purpose of the commit. This makes it easier for you
    and your collaborators to understand the version control history.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many tools that work with Git, including GitHub, make use of certain formats
    and tags in commit messages. These not only help provide additional context to
    developers but can also drive workflow integrations, such as in bug-tracking tools.
    Writing commit messages in this way involves following certain guidelines to maintain
    readability and effectiveness. A commit message typically includes a header or
    title, the type of commit (such as `feat`, `fix`, `docs`, and so on), an optional
    scope to specify the area of change, and a subject that concisely describes the
    change. It can also contain a detailed explanatory body and a footer referencing
    related issue IDs. The subject and header are often limited to 50 characters and
    the body wraps at 72 characters. The commit message should be clear and concise,
    explaining what the commit does and why. To commit your staged changes with a
    commit message, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `git log` command to view commits made to your repository. By
    default, it will display an SHA-1 checksum, along with the author, date, and commit
    message of each commit. However, there are many options for filtering and searching
    the log, all of which you can find in Git’s built-in documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting your remote repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our changes committed to our local repository, we need to ensure that
    our remote repository has been connected correctly and is ready to push our changes.
    If it is not already connected, we can use the `git remote` command to connect
    it and provide it with a working alias. Conventionally, this alias is often referred
    to as `origin`, but you can use any name you like. An example of this command
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command connects our remote repository at the URL specified, via the `origin`
    alias.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing changes to a remote repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’re confident that your local changes are stable and well tested, you
    can use the `git push` command to transfer these updates to the remote repository.
    This ensures that your changes are shared with other collaborators and makes the
    updated code accessible to anyone with access to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a `git push` operation, simply run the following command in your
    terminal or Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, this command pushes your changes to the branch of the remote repository
    that is currently checked out in your local repository. However, you can also
    specify the remote repository and branch you want to push to, if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Merging changes from one branch to another
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re working with an already existing Git repository, you may be working
    in a separate branch from the main branch – we’ll be looking at a few example
    branching strategies in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the case, you will eventually need to merge your changes into the
    main branch, which can be achieved with the `git merge` command. This ensures
    that the main branch incorporates the changes in your branch, without conflicts.
    Git will automatically try to merge the changes, but if conflicts arise, you’ll
    have to resolve them manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'This manual resolution of conflicts involves going through the files that contain
    conflicts, such as lines of code that have been changed in both branches, and
    deciding which version should be kept as the final output. Git will automatically
    add sections marked with `<<<<<<<`, `=======`, and `>>>>>>>` to indicate where
    these conflicts exist within the file. The following code snippet demonstrates
    a typical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The first marker shows the start of the conflicting lines. The second marker
    acts as a separator between the conflicting versions – everything before the marker
    is in the current branch and everything after it is in the branch to be merged.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the conflict, delete the conflict markers and edit the code so that
    it reflects the intended version you wish to keep. It is important to consider
    the context and intention of the changes. For this reason, it is recommended to
    liaise with the author of the conflicting change wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Merge strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to merging changes between branches, it’s worth taking a brief
    look at merge strategies. These are the different approaches used by Git to determine
    how it handles the conflicting changes and merges them, as well as how it manages
    different situations during the merge process. Here are a few examples, although
    there are many more:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Recursive**: The recursive strategy is Git’s default strategy and works for
    most common scenarios. It analyzes the commit history of both branches to determine
    a common starting point before the branches diverged and then applies changes
    from both branches. If it hits a conflict along the way, it will prompt for manual
    intervention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Octopus**: The octopus strategy is used to merge multiple branches into a
    single branch. For example, you may want to merge multiple feature branches into
    a single release branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resolve**: The resolve strategy is similar to the recursive strategy, in
    that it will attempt to automatically merge changes and pause for manual intervention
    if conflicts are detected. The difference in this strategy, however, is that it
    doesn’t recursively analyze the commit history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ours**: The ours strategy is designed to give preference to the branch being
    merged into. Like the other strategies, it will automatically merge where no conflicts
    exist, but in the event of a conflict, it will discard changes from the incoming
    branch and keep the current version. As you might have guessed at this point,
    the opposing strategy, in which the incoming changes are favored, is called the
    **theirs** strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtree**: The subtree merge strategy is used to merge changes from a remote
    repository into a subfolder of your current repository. This can be useful for
    very modular projects, or libraries of code that you wish to incorporate into
    larger projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These strategies are just a glimpse of the available options for merging in
    Git. You have the flexibility to choose the desired merge strategy by utilizing
    command-line options or configuration settings. Which merge strategy you choose
    depends on the specific needs and complexities of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ll see in the next section on branching strategies, when you are about
    to start working on a new feature, bug fix, or any other change, it’s a common
    practice to create a new branch, often referred to as a **feature branch**. This
    ensures that your work is isolated from the main branch, which is usually more
    stable and production-ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new branch, you can use the `git branch` command, followed by the
    desired branch name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Switching to a different branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To switch to another branch from the current one in use, simply check out that
    branch, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can create a new branch and switch to it with a single command
    using the `-``b` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve created and switched to your new branch, you can start making
    changes to the code base without them affecting the main branch. Once your work
    is complete and has been tested, you can merge your feature branch back into the
    main branch, ensuring a clean and organized version control history.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing commit history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `git log` command allows you to see the history of all commits that make
    up your current branch – this could consist of commits directly to the branch,
    commits merged from other branches, or commits made from the original branch that
    your branch was created from. You can view this history, including any commit
    messages, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Reverting to a previous version of a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to revert a specific file to a previous version, as opposed
    to reverting an entire commit that may contain multiple file changes. Using the
    commit hash from the log shown in the commit history and the name of the file
    you wish to restore from that point in time, you can check out the file, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Git rebasing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**git rebase** is a way to integrate changes from one branch into another.
    It involves replaying the commits from the feature branch on top of the base branch,
    which replaces the feature branch with an updated version that includes all the
    changes from the base branch.'
  prefs: []
  type: TYPE_NORMAL
- en: The main principle behind `git rebase` is to maintain a linear history, which
    makes it easier to understand and follow the changes made to the code over time.
    A linear history means that there are no merge commits (a special type of commit
    when merges are made, to maintain the history of both branches going forward),
    only a straight line of commits.
  prefs: []
  type: TYPE_NORMAL
- en: '`git rebase` also helps in resolving conflicts that may arise while merging.
    Instead of creating a merge commit, it replays commits one by one on top of the
    base branch, which can make conflicts easier to resolve. It’s important to note
    that `git rebase` modifies the existing commits, and it can cause issues if other
    people have already pulled the feature branch. *Therefore, it’s recommended to
    only use git rebase on branches that haven’t been shared* *with others.*'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, `git rebase` is a powerful command that can help keep your Git history
    clean and easy to understand, but it *should be used with caution*. Now that we’ve
    looked at the foundational Git commands and why they are used in our workflow,
    let’s discuss branching strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Effective Salesforce branching strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing features in version control, a branching strategy establishes
    guidelines for how branches are utilized and managed. However, there is no single
    strategy that is ideal for every team. The best strategy for your team will depend
    on several factors, such as team size, team structure/complexity, the desired
    release schedule, and the current workflow.
  prefs: []
  type: TYPE_NORMAL
- en: For example, larger teams may require a more complex strategy to accommodate
    different roles, while a simpler strategy may be more suitable for smaller teams.
    Additionally, business requirements may dictate a specific release cycle, and
    the branching strategy should be able to accommodate those needs. Furthermore,
    it is important to consider how your current workflow and environment setup (for
    example, the number of sandboxes) may align with the chosen branching strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Git as a backup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first strategy we can look at is using Git as a lightweight backup of your
    Salesforce metadata. This approach is frequently the initial step teams take when
    they start version-controlling their metadata. They establish one branch per environment
    and begin transferring metadata from their orgs to the branches.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a good initial approach to getting metadata into Git, the development
    life cycle is not truly source-driven in this way. Version control does not serve
    as the primary source of truth here, but rather as a retrospective record of the
    changes that have already occurred. It is still useful, but to fully reap the
    benefits of Git, it is important to ensure that once changes have been developed,
    they are placed into version control to facilitate a smooth flow between environments.
    Additionally, this model often results in isolated environment branches, where
    changes aren’t exchanged between them in source control. Consequently, transitioning
    from this model to establish source control as the definitive source of truth
    can be challenging. This is primarily because the same file in each organizational
    branch lacks a shared commit history, which can make it difficult for Git to handle
    them.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, with this workflow, it can be difficult to accommodate parallel
    development streams for multiple features. There are no pull requests in this
    model, which allows you to easily integrate peer review into the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, because changes are not regularly deployed from version control
    into the environments, there may be less confidence in the ability to roll back
    a release by deploying an older revision from version control.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to remember that version control is primarily designed to assist
    teams in creating, tracking, and deploying new features. It should not be viewed
    as a comprehensive backup of Salesforce environments for disaster recovery purposes,
    as that is the role of backup solutions in a comprehensive DevOps strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an example of using Git as a backup, and how the branches mirror
    your Salesforce environments, in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Git as a backup](img/Figure_3.02_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Git as a backup
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With **trunk-based development** (**TBD**), all developers work on a single
    branch, called the **trunk** or **main**. Feature toggles are used to hide incomplete
    work. Branches are short-lived and are merged back into the main branch as soon
    as possible. While the thought of merging your work into the main branch daily
    (or even multiple times a day) might seem daunting, many teams find that the benefits
    of TBD far outweigh the initial discomfort. Embracing TBD can lead to increased
    collaboration, higher-quality code, and a more streamlined development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In TBD, developers create branches for new features or bug fixes, but these
    branches are short-lived. They are merged back into the main branch as soon as
    possible, often within a day. To avoid unfinished features being pushed into production,
    TBD employs feature toggles (also known as feature flags). This allows teams to
    hide features until they are ready for production use. With everyone merging their
    changes into the main branch frequently, CI is necessary. Automated testing ensures
    that the main branch is always in a releasable state. You’ll notice that the diagram
    for this approach (see *Figure 3**.2*) and the feature branch one (see *Figure
    3**.3*), are extremely similar. The fundamental difference between the two strategies
    is that the branches for TBD are much more granular in their scope and short-lived:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.3 – \uFEFFTBD](img/Figure_3.03_B19436.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – TBD
  prefs: []
  type: TYPE_NORMAL
- en: The feature branch model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The feature branch model is a basic approach that integrates Git into the development
    process, rather than just being used for backup. While some teams may choose more
    complex branching methods, the feature branch model is a good starting point due
    to its simplicity. The master branch is the only long-term, permanent branch.
    When you work on new features or fixes, a separate branch is created from the
    main branch, and once completed, it is merged back into the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, it is best to keep feature branches as short-lived as possible
    and delete them after use for cleanliness. Large features should be divided into
    smaller chunks and implemented one at a time to shorten the feedback cycle and
    decrease the likelihood of merge conflicts. It should be noted that any failure
    in the master branch is a blocker to the whole release process since it relies
    on all the prod-ready testing to happen on each feature branch, which is not always
    realistic.
  prefs: []
  type: TYPE_NORMAL
- en: The master branch is typically deployed automatically to a staging environment
    using a CI process, making the latest version readily available for testing. Once
    the version in the staging environment is satisfactory, a deployment from the
    master branch to the production environment releases the changes to the end users.
    As an option, before deploying to production, the changes can be deployed to a
    **User Acceptance Testing** (**UAT**) or **quality assurance** (**QA**) environment
    for further testing.
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows a typical feature branch model and how changes in
    that branch are re-integrated into the master branch so that they can be deployed
    in your Salesforce environments.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.4 – The feature br\uFEFFanch model](img/Figure_3.04_B19436.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The feature branch model
  prefs: []
  type: TYPE_NORMAL
- en: The protected master branch model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The protected master branch model is similar to the feature branch model, but
    it includes an additional long-lived branch for integration before merging into
    the master branch. In this model, the master branch is not updated until everything
    has been fully tested and is ready for release. The master branch is a more secure
    source of truth since only work that has been thoroughly tested in UAT is included
    in the branch.
  prefs: []
  type: TYPE_NORMAL
- en: However, one downside of this model is that it is not possible to propagate
    only a subset of changes if some are not ready yet. If some work has been tested
    and approved in UAT, but other work is not ready, it is difficult to selectively
    promote changes to the master branch. Instead, it is necessary to revert features
    that are not yet ready from the release branch. This inflexibility is a major
    concern for many teams, which is why this model is not as popular. If you find
    that you need to selectively promote changes regularly, then you have not selected
    the right branching strategy for your way of working.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the protected master branch approach, with
    its separate integration branch for testing changes before they reach production:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – The protected master branch model](img/Figure_3.05_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – The protected master branch model
  prefs: []
  type: TYPE_NORMAL
- en: The expanded branching model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Taking the process of isolating branches a step further, the expanded branching
    model includes several additional long-lived branches that correspond to the integration
    and UAT/QA environments. Instead of merging feature branches directly into the
    master branch, they are first merged into the integration branch. To move changes
    that are ready for release to the next environment in sequence, they are merged
    into the UAT/QA branch, and then into the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows for more precise control over which changes are deployed
    to each environment and allows for isolated evaluations of changes on a per-request
    basis. The expanded branching model is well suited to teams that prioritize gating
    and quality control over frequent releases. However, like every other branching
    strategy we’ve looked at, there are still some important caveats, particularly
    if merge conflicts are encountered. For example, if merge conflicts are found
    during the merge to UAT, then the entirety of the UAT branch will need to be merged
    in to resolve them, which would mean that a subsequent merge to master would bring
    in the whole of the UAT branch too, whether it is ready to be promoted or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the correlation between branches and Salesforce environments in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The expanded branching model](img/Figure_3.06_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The expanded branching model
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the branching strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, let’s recap and summarize these four approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Git as a backup is pretty self-explanatory: we use it as a mechanism
    to save our metadata off-platform, which allows us to revert changes – although
    this is not easy if the change is several Git commits back and there are deep
    chains of dependencies. It also doesn’t deliver any of the main benefits of a
    source-driven development approach.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TBD approach offers an array of advantages that streamline and accelerate
    software development. By promoting frequent integration of short-lived branches,
    it drastically reduces the occurrence of “merge hell,” the oft-dreaded scenario
    of conflicting changes. The visibility of changes is also greatly enhanced as
    most work is carried out on the main branch, facilitating a clearer understanding
    of how alterations impact the project. TBD simplifies the development process
    by eliminating the need to maintain multiple long-lived branches and keeps the
    main branch in a perpetually releasable state, enabling any-time deployment and
    thus, quicker delivery of features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The feature branch model is great for teams that rapidly iterate – we use it
    ourselves internally and it allows us to deliver changes daily, or often more
    frequently than that. If your process requires more stage gates and checks along
    the way, this may not work for your longer dev cycles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The protected master branch model has multiple testing environments and an integration
    branch to support them, which means that your primary master or main branch is
    the source of truth. However, this model still acts as a queue, where items that
    require longer test cycles can hold up other changes until they’re promoted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expanded branch model allows for a more asynchronous approach to changes,
    with individual pieces of work that can be moved through the environments. This
    allows for questions in the style of “Bob, where are we with Jira 34533?” to be
    answered accurately in the style of “It’s in UAT awaiting sign-off for release
    to production, Sarah.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at the reasons why source control is fundamental
    to the adoption of DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collaboration**: DevOps emphasizes collaboration in software development.
    Source control allows multiple developers to work concurrently on a code base
    without them having to interfere with each other’s changes. By merging and reviewing
    changes later, teams can achieve faster development and reduce defects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traceability**: The growing need for governance in software development demands
    accountability and audit trails. Source control provides a comprehensive history
    of code and configuration changes, including details about the who, what, and
    why. This not only aids in auditing but also assists in identifying the origin
    of bugs and issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: DevOps emphasizes automation, and source control serves as
    a foundation for automating software development processes such as building, testing,
    and deploying code. This allows for the automatic execution of these tasks upon
    committing changes to the code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous integration**: CI enables developers to frequently merge code
    changes into a shared repository and run automated tests, facilitated by source
    control. This practice helps detect and resolve issues early, streamlining the
    development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous deployment**: CD automatically deploys code changes to production
    after passing CI tests, with source control enabling automation. This integration
    of CI and CD forms the CI/CD pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rollbacks**: Source control enables easy rollbacks by maintaining a code
    base history, allowing you to quickly revert to previous versions in case there
    are bugs or issues in the production environment. This ensures you can efficiently
    and reliably handle unexpected problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then explored some typical Git operations that you’re likely to use regularly
    as you work on creating changes to your Salesforce orgs. Finally, we looked at
    some of the common Git branching strategies for Salesforce development, and the
    advantages and disadvantages of each.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the next fundamental part of a mature Salesforce
    DevOps process – testing your changes effectively to ensure quality deliverables.
  prefs: []
  type: TYPE_NORMAL
