- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Verifying Your Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证你的代码
- en: For most projects, the first thing a **GitLab CI/CD** pipeline should do is
    *verify the code*. Different projects will rely on different tasks to perform
    this critical step, but they usually involve some combination of checking the
    code quality and running automated functional tests. As a prerequisite for certain
    kinds of verification, some projects will need to build their code first. This
    chapter focuses on building and then verifying your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数项目，**GitLab CI/CD**管道应该首先做的事情是*验证代码*。不同的项目会依赖不同的任务来执行这一关键步骤，但通常涉及检查代码质量和运行自动化功能测试的某种组合。作为某些类型验证的先决条件，有些项目需要先构建代码。
    本章将重点介绍构建然后验证代码。
- en: We’ll first discuss whether building the code is necessary, and if so, how to
    configure a GitLab CI/CD pipeline to carry out that task. Then, we’ll talk about
    how to use a pipeline to run GitLab’s built-in code quality scanner. Next, we’ll
    explain how to run automated functional tests within a pipeline. Then, we’ll cover
    a fascinating variety of automated testing called **fuzz testing**, which can
    find problems that traditional automated functional tests might miss. We’ll touch
    on GitLab’s accessibility testing, which ensures that your code can be used by
    a wide range of people. Finally, we’ll briefly mention a few other ways that you
    can verify your code, though we won’t have room to describe them in detail. By
    the end of the chapter, you’ll have an array of tools at your disposal for making
    sure your code is well written and does what it’s supposed to.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论构建代码是否必要，如果必要的话，如何配置GitLab CI/CD管道来执行此任务。接着，我们将讨论如何使用管道运行GitLab内置的代码质量扫描工具。然后，我们将解释如何在管道中运行自动化功能测试。接下来，我们将介绍一种非常有趣的自动化测试，称为**模糊测试**，它可以发现传统自动化功能测试可能遗漏的问题。我们还将涉及GitLab的可访问性测试，确保你的代码能够被广泛的人群使用。最后，我们将简要提及几种其他验证代码的方法，尽管我们没有足够的篇幅来详细描述它们。到本章结束时，你将拥有一系列工具，确保你的代码编写良好且能够按预期执行。
- en: 'These are the main topics of this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要内容包括：
- en: Building code in a CI/CD pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI/CD管道中构建代码
- en: Checking code quality in a CI/CD pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI/CD管道中检查代码质量
- en: Running automated functional tests in a CI/CD pipeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI/CD管道中运行自动化功能测试
- en: Fuzz testing in a CI/CD pipeline
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI/CD管道中进行模糊测试
- en: Checking accessibility in a CI/CD pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI/CD管道中检查可访问性
- en: Additional ways to verify your code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证代码的其他方法
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As with the previous chapters, you’ll get the most out of this chapter if you’ve
    got an account on a GitLab instance (*self-managed* or *Software-as-a-Service*)
    that you can log in to and use for practicing and experimenting with the concepts
    discussed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的章节一样，如果你在一个GitLab实例（*自托管*或*软件即服务*）上有一个帐户，并可以登录并用来练习和实验本章讨论的概念，你将从本章获得最大的收益。
- en: Building code in a CI/CD pipeline
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CI/CD管道中构建代码
- en: At the risk of oversimplifying some of the mechanics that happen behind the
    scenes when you run software, we can generally think of *interpreted* computer
    languages such as Python or Ruby as executing raw source code, whereas *compiled*
    languages such as Java, C, or C# must convert that source code into a runnable
    form by compiling it, and then execute the compiled version of the program.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在简化运行软件时发生的后台机制的风险下，我们可以大致将*解释型*编程语言，如Python或Ruby，视为直接执行原始源代码，而*编译型*语言，如Java、C或C#，则必须通过编译将源代码转换为可运行的形式，然后执行编译后的程序版本。
- en: This is an important distinction to keep in mind when configuring a pipeline
    to verify your code because it means that if your project contains any code written
    in a compiled language (even if it’s only a small portion of your overall project),
    you probably need to include a build job in your pipeline before any verification
    jobs take place. We say *probably* because some of the jobs that typically run
    during the verification stage of a pipeline (for example, Code Quality) look directly
    at source code, whereas others interact with code as it runs. So, if your pipeline
    only uses verification scans that focus on source code, you can omit the build
    step no matter what language you’re using. If you want to include automated functional
    tests or fuzz testing in your pipeline, you *will* need to build your code first,
    so read on!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是配置管道以验证代码时需要牢记的一个重要区别，因为这意味着如果你的项目中包含任何用编译语言编写的代码（即使它只是你整体项目中的一小部分），你可能需要在任何验证任务之前，在管道中包括一个构建任务。我们说*可能*是因为一些通常在管道验证阶段运行的任务（例如，代码质量检查）直接查看源代码，而另一些则与运行中的代码进行交互。所以，如果你的管道只使用关注源代码的验证扫描，无论你使用什么语言，都可以省略构建步骤。如果你希望在管道中包含自动化功能测试或模糊测试，你*需要*先构建你的代码，所以请继续阅读！
- en: Every language builds its code in a different way, using different tools. Even
    within a single language, there are sometimes multiple tools or techniques for
    building code. Let’s look at two different ways to compile Java code and one way
    to compile C code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都有不同的构建方式，使用不同的工具。即使是在同一种语言中，有时也会有多种工具或技术来构建代码。让我们来看两种编译Java代码的方法以及一种编译C代码的方法。
- en: These examples are meant to give you the big picture of how to build code within
    a GitLab CI/CD pipeline. They are not meant to be comprehensive examples of all
    the ways to accomplish this task. There are so many different languages and tools
    that we can only give you a few bare-bones examples and then let you adapt and
    expand them to work with your own languages, tools, constraints, and preferences.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例旨在让你了解如何在GitLab CI/CD管道中构建代码的全貌。它们并非所有实现这一任务方式的全面示例。因为有太多不同的语言和工具，我们只能给出一些基本的示例，然后让你根据自己的语言、工具、约束和偏好进行调整和扩展。
- en: Compiling Java with javac
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用javac编译Java代码
- en: Outside of simple training applications, real-world Java projects rarely use
    the `javac` compiler to convert Java source code (i.e., files with the `.java`
    extension) into compiled Java classes (i.e., files with the `.class` extension).
    Using the `javac` tool is effective when you’re only dealing with a few files,
    but it can become cumbersome as projects grow in complexity. But just like peanut
    butter and jelly sandwiches can be a great introduction to cooking even though
    they’d never be served at a formal dinner at Buckingham Palace, `javac` is a great
    way to introduce new GitLab users to the concept of using CI/CD pipelines to compile
    Java code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的训练应用程序，现实世界中的Java项目很少使用`javac`编译器将Java源代码（即`.java`扩展名的文件）转换为编译后的Java类（即`.class`扩展名的文件）。当你只处理几个文件时，使用`javac`工具是有效的，但随着项目复杂度的增加，这种方法可能变得繁琐。然而，就像花生酱果酱三明治是烹饪入门的好方式，尽管它们永远不会出现在白金汉宫的正式晚宴上，`javac`也是将新GitLab用户引入使用CI/CD管道编译Java代码的好方法。
- en: Adding your Java application
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加你的Java应用程序
- en: 'Let’s keep things simple by creating a single file application and a single
    Java package called `com.hatsforcats`. You can use GitLab’s Web IDE editor to
    create a directory called `src/com/hatsforcats` to store your source code. Inside
    that directory, use the Web IDE to create a file called `Login.java`. Add this
    trivial Hello World-style Java code to that file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保持简单，创建一个单文件应用程序和一个名为`com.hatsforcats`的Java包。你可以使用GitLab的Web IDE编辑器创建一个名为`src/com/hatsforcats`的目录来存储你的源代码。在该目录下，使用Web
    IDE创建一个名为`Login.java`的文件。将以下简单的Hello World风格的Java代码添加到该文件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Configuring your pipeline
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置你的管道
- en: 'Now that your app has been added to the project, it’s time to configure your
    pipeline. Start with an empty `.gitlab-ci.yml` file in the root of your project’s
    repository and define a `build` stage for your pipeline using the `stages` keyword:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的应用已被添加到项目中，是时候配置你的管道了。从项目仓库根目录下的空`.gitlab-ci.yml`文件开始，并使用`stages`关键字为你的管道定义一个`build`阶段：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, you’ll define a pipeline job that lives within the *build* stage and
    runs `javac`. Let’s stipulate a few extra requirements for this example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将定义一个位于*构建*阶段并运行`javac`的管道任务。为了这个例子，让我们设定一些额外的要求：
- en: All the Java source files belong to the `com.hatsforcats` Java package.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的 Java 源代码文件都属于`com.hatsforcats` Java 包。
- en: Your team’s coding standards require you to put all source code within a `src/`
    directory that lives in the project’s root directory.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您团队的编码标准要求将所有源代码放在项目根目录中的`src/`目录下。
- en: Compiled files should end up in a `target/` directory that lives in the project’s
    root directory.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后的文件应保存在项目根目录中的`target/`目录下。
- en: 'To compile your code while satisfying these criteria, you’ll need to define
    a job in `.gitlab-ci.yml` to do the work. Call it something obvious and put it
    in the *build* stage:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在满足这些标准的同时编译代码，您需要在`.gitlab-ci.yml`中定义一个任务来完成这项工作。给它起个明显的名字，并将其放入*build*阶段：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Within that job definition, you’ll want to specify which Docker image the job
    should run within. The job will need access to the `javac` compiler, so a good
    image to use is the latest version of `openjdk`. Add this to the job definition
    (remember to watch your indentation):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在该任务定义中，您需要指定任务运行的 Docker 镜像。任务需要访问`javac`编译器，因此一个好的选择是使用最新版本的`openjdk`。将其添加到任务定义中（记得调整缩进）：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, the job needs to invoke the Java compiler. Any commands that you list
    under the `script` keyword will run when the pipeline executes that job:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任务需要调用 Java 编译器。在`script`关键字下列出的任何命令将在管道执行该任务时运行：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: No doubt you can figure out the syntax of the `javac` command from the requirements
    given earlier, but if not, feel free to refer to the Java compiler’s documentation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，您能根据之前给出的要求理解`javac`命令的语法，但如果不能，随时可以参考 Java 编译器的文档。
- en: Believe it or not, that’s all you need in order to compile Java code within
    a GitLab CI/CD pipeline!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这就是在 GitLab CI/CD 管道中编译 Java 代码所需要的一切！
- en: 'But to demonstrate that the job works as expected, let’s add more lines to
    the `script` section of the `compile-java-with-javac` job. The first line will
    show the contents of the `target/` directory after `javac` has worked its magic.
    If the compiler worked, this command will display the compiled version of your
    Java source file when the job runs:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示任务按预期工作，接下来让我们在`compile-java-with-javac`任务的`script`部分添加更多行。第一行将在`javac`执行完毕后显示`target/`目录的内容。如果编译器工作正常，该命令将在任务运行时显示编译后的
    Java 源文件版本：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next lines will execute your compiled `Login.class` code to prove that
    it has compiled correctly. Normally, you wouldn’t run your code in a job that’s
    dedicated to building it, but you’re doing it in this case simply to demonstrate
    that the compile actually happened:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行将执行您编译后的`Login.class`代码，以证明它已正确编译。通常，您不会在专门构建代码的任务中运行代码，但在这种情况下，您只是为了演示编译确实发生了：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the complete text of `.gitlab-ci.yml` that you have assembled. If you’re
    following along, make sure that your version of that file contains exactly this
    text:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您已经组装好的`.gitlab-ci.yml`完整文本。如果您跟着操作，请确保该文件的版本正好包含以下内容：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Commit this file and navigate over to the list of pipelines in your project.
    Zoom in on the pipeline run that was automatically triggered by your commit, zoom
    in on the `compile-java` job, and see whether you can find text similar to this
    snippet at the end of the job’s output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 提交此文件，并转到项目中的管道列表。缩放到由您的提交自动触发的管道运行，缩放到`compile-java`任务，并查看是否能在任务输出的末尾找到类似于此代码段的文本：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the `javac` command ran without emitting any errors, the `ls`
    command shows a compiled version of `Login.java`, and the class produced the expected
    output when it was executed. Success!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`javac`命令在没有出现错误的情况下运行，`ls`命令显示了编译后的`Login.java`版本，并且该类在执行时产生了预期的输出。成功！
- en: Compiling Java with Maven
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Maven 编译 Java
- en: Let’s try a slightly more complicated, albeit probably more realistic, way of
    compiling the same Java project you set up in the previous section. Instead of
    using the Java compiler directly, let’s use `*.java` file into a compiled `*.``class`
    file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一种稍微复杂一点的方法，尽管它可能更符合实际情况，用来编译您在上一节中设置的相同 Java 项目。我们不直接使用 Java 编译器，而是将`*.java`文件编译成`*.class`文件。
- en: Configuring Maven
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Maven
- en: 'Maven is configured via a special file called `pom.xml`. There’s no need to
    get into the structure or content of that file here, but if you’re curious about
    what each section does, the Maven documentation can give you all the details.
    Copy this bare-bones content into a new `pom.xml` file in your project’s root
    directory:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 通过一个名为`pom.xml`的特殊文件进行配置。这里无需深入讨论该文件的结构或内容，但如果你对每个部分的作用感到好奇，Maven 文档可以为你提供所有细节。将以下简洁的内容复制到你项目根目录中的新`pom.xml`文件中：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding your Java application
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加你的 Java 应用程序
- en: 'If you’re re-using the same project from the preceding `javac` example, you
    already have a Java program added to the project’s repository. If you’re using
    a new project, add this Java code to a new file called `Login.java` in a new `src/com/hatsforcats/`
    directory:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新使用前面 `javac` 示例中的相同项目，你已经将一个 Java 程序添加到项目的仓库中。如果你使用的是新项目，请将以下 Java 代码添加到一个名为`Login.java`的新文件中，并将该文件放置在新的
    `src/com/hatsforcats/` 目录中：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Configuring your pipeline
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置你的管道
- en: 'Either make a new `.gitlab-ci.yml` file in your root directory or replace all
    the content in your existing `.gitlab-ci.yml` file with this configuration code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在根目录下创建一个新的 `.gitlab-ci.yml` 文件，或者用这段配置代码替换你现有的 `.gitlab-ci.yml` 文件中的所有内容：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You’ll notice that the pipeline configuration code for a Maven-powered build
    is similar to the configuration code for a Java-compiler-powered build, but with
    a few key differences:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，Maven 驱动的构建的管道配置代码与 Java 编译器驱动的构建配置代码类似，但有几个关键的不同之处：
- en: A different value after the `image` keyword means that the GitLab Runner will
    execute the job within a Maven-based Docker image instead of a Java-based Docker
    image.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image` 关键字后面的不同值意味着 GitLab Runner 将在基于 Maven 的 Docker 镜像中执行任务，而不是在基于 Java
    的 Docker 镜像中。'
- en: The command to compile the code uses `mvn` instead of `javac`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译代码的命令使用的是 `mvn`，而不是 `javac`。
- en: Maven puts compiled classes in a different directory than the source code by
    default, so you don’t have to explicitly tell it to do so like you did with `javac`
    (although notice that its default directory for compiled files isn’t quite the
    same as the one you specified with `javac`).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Maven 将编译后的类放在与源代码不同的目录中，因此你不需要像使用 `javac` 时那样明确告诉它这么做（尽管请注意，它的默认目录与使用
    `javac` 时指定的目录并不完全相同）。
- en: 'After committing this configuration code, you can view the details of the pipeline
    that is automatically triggered and zoom in on the `compile-java-with-maven` job.
    You should see something similar to this snippet at the end of the output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提交该配置代码后，你可以查看自动触发的管道的详细信息，并放大查看`compile-java-with-maven`任务。你应该会在输出的末尾看到类似于这个片段的内容：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Maven-driven compile worked correctly, the compiled class appears where
    you expected it to, and the class gives the expected output when you run it. You’ll
    never need to run the `mvn compile` command manually again!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 驱动的编译正常工作，编译后的类出现在你预期的位置，运行时该类会输出预期的结果。你将再也不需要手动运行`mvn compile`命令！
- en: Compiling C with Gnu Compiler Collection (GCC)
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Gnu Compiler Collection (GCC) 编译 C 代码
- en: Let’s take a look at building a project based on the **C** programming language.
    Normally, you would use a tool such as Make to build your C project, just like
    you use Maven to build a Java project. But to keep this example as simple as possible,
    you’ll rely on the good old GCC to compile some C code directly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看基于 **C** 编程语言的项目构建。通常，你会使用像 Make 这样的工具来构建 C 项目，就像使用 Maven 构建 Java 项目一样。但为了尽可能简化这个例子，你将依赖于经典的
    GCC 来直接编译一些 C 代码。
- en: If you’re following along at home, you can either make a new project for your
    C program, or you can re-use the project that you used for the two earlier Java
    examples.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在家中跟着做，你可以为你的 C 程序创建一个新项目，或者你也可以重新使用之前为两个 Java 示例使用的项目。
- en: Adding your C application
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加你的 C 应用程序
- en: 'Navigate to your project’s repository in the GitLab GUI, add a new file at
    the root directory called `login.c`, and paste this simple C code into it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab GUI 中导航到你的项目仓库，在根目录添加一个名为`login.c`的新文件，并将这段简单的 C 代码粘贴进去：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Configuring your pipeline
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置你的管道
- en: 'Setting up a pipeline to use GCC to compile C code isn’t terribly different
    from what you saw in the Java examples. Here are the main differences:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个管道以使用 GCC 编译 C 代码与 Java 示例中的设置差别不大。以下是主要区别：
- en: The job runs in a Docker image that includes the GCC tools.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该任务将在包含 GCC 工具的 Docker 镜像中运行。
- en: The job definition’s `script` keyword specifies using `gcc` instead of `mvn`
    or `javac` to build your code.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业定义中的 `script` 关键字指定使用 `gcc` 而不是 `mvn` 或 `javac` 来构建你的代码。
- en: The job runs the compiled code directly instead of invoking a JVM with the `java`
    command.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该作业直接运行已编译的代码，而不是通过 `java` 命令调用 JVM。
- en: 'The basic CI/CD configuration code for building and running a C program with
    GCC could look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行一个使用 GCC 编译的 C 程序的基本 CI/CD 配置代码可能如下所示：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To repeat something we said earlier, you normally would not run your code in
    the same job as you built it—in fact, you might not run it at all in a pipeline.
    But you’re running it here just to demonstrate that compiling worked as expected.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重复我们之前提到的内容，通常你不会在构建代码的同一作业中运行它——实际上，在流水线中你可能根本不运行它。但你在这里运行它仅仅是为了展示编译是否按预期工作。
- en: 'And here’s a snippet from the output of this job, showing that your C program
    compiled and ran correctly:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该作业输出的一个片段，显示你的 C 程序已经正确编译和运行：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Storing built code as artifacts
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将构建的代码作为工件存储
- en: 'There’s one more keyword you need to know before you can move on to pipeline
    stages that test the code that you just built: the `artifacts` keyword.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以继续进行测试你刚刚构建的代码的流水线阶段之前，还有一个你需要了解的关键字：`artifacts` 关键字。
- en: Any files that a pipeline job creates—including compiled versions of files that
    are generated during a build job—are deleted as soon as the job completes. This
    is very different from how build tools work on the command line. If you type `javac
    MyApp.java` in a terminal, the `MyApp.class` file that is generated will stick
    around on your filesystem until you delete it. But in a GitLab CI/CD pipeline,
    every job operates in its own, self-contained environment. This means that if
    you compile some files in a `build-java` job and then try to test them in a `test-java`
    job that lives in a later stage, the `test-java` job will *not* be able to see
    the files that you so carefully built earlier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线作业创建的任何文件——包括在构建作业过程中生成的编译文件——都会在作业完成后立即被删除。这与命令行中的构建工具工作方式非常不同。如果你在终端中输入
    `javac MyApp.java`，生成的 `MyApp.class` 文件会一直保留在你的文件系统中，直到你删除它。但是在 GitLab CI/CD 流水线中，每个作业都在自己的独立环境中运行。这意味着如果你在
    `build-java` 作业中编译了一些文件，然后在后续阶段的 `test-java` 作业中测试它们，`test-java` 作业将*无法*看到你之前精心构建的文件。
- en: 'Fortunately, the `artifacts` keyword gives you a workaround. This keyword lets
    you specify certain files or directories that GitLab should preserve from one
    job and make available to all later jobs. For example, to preserve the executable
    `login` file that you generated in the `compile-c` job, you could add these two
    lines to the bottom of the `compile-c` job definition:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`artifacts` 关键字提供了一个解决方法。这个关键字允许你指定 GitLab 应该从一个作业中保留并在所有后续作业中提供的某些文件或目录。例如，要保留在
    `compile-c` 作业中生成的可执行 `login` 文件，你可以将以下两行添加到 `compile-c` 作业定义的底部：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can specify more than one file to preserve, and you can specify one or
    more directories to preserve in addition to any individual files. You can also
    specify subdirectories or files to exclude from the list of artifacts. For example,
    to save the entire contents of the directory that Maven puts compiled files in,
    except for files that start with `Test` that exist in any subdirectory, you could
    add these lines to the bottom of the `compile-java-with-maven` job from earlier:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定多个文件进行保存，并且除了任何单独的文件外，你还可以指定一个或多个目录进行保存。你还可以指定要从工件列表中排除的子目录或文件。例如，要保存 Maven
    放置编译文件的目录中的所有内容，但排除任何子目录中以 `Test` 开头的文件，你可以将以下代码添加到之前 `compile-java-with-maven`
    作业的底部：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `artifacts` keyword is one of the most important keywords that you’ll use
    when configuring CI/CD pipelines, and forgetting to use it when it’s needed is
    a common mistake. If your pipeline isn’t working the way you expect it to, one
    of the first troubleshooting steps you should try is to check whether you’re specifying
    artifacts in all of the jobs that generate files that you want to access in later
    jobs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`artifacts` 关键字是配置 CI/CD 流水线时最重要的关键字之一，忘记在需要时使用它是一个常见的错误。如果你的流水线没有按照预期工作，应该尝试的第一个故障排除步骤是检查是否在所有生成你想在后续作业中访问的文件的作业中指定了工件。'
- en: 'Now that you’ve learned when and how to build your code in a CI/CD pipeline,
    let’s move on to what is typically the next pipeline step: *checking the quality
    of* *your code*.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了在 CI/CD 流水线中何时以及如何构建代码，接下来让我们继续讨论通常是下一个流水线步骤的内容：*检查你的代码质量*。
- en: Checking code quality in a CI/CD pipeline
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CI/CD 流水线中检查代码质量
- en: One of the many scanners that GitLab makes available to CI/CD pipelines is a
    special feature that makes sure your project’s code adheres to certain quality
    standards. GitLab calls this feature, unsurprisingly, **Code Quality**. If you’ve
    used any sort of linting tool before, you can think of this feature as a turbocharged
    linter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 提供的众多扫描工具之一是一个特殊功能，它确保你的项目代码符合特定的质量标准。GitLab 将这个功能称为，毫不意外的，**代码质量**。如果你之前使用过任何类型的
    linting 工具，可以将这个功能看作是一个加速版的 linter。
- en: The Code Quality feature relies on an outside service called **Code Climate**.
    Although this service can scan code written in all the major computer languages,
    it can’t handle every language out there. You can refer to Code Climate’s official
    documentation to see a list of supported languages, but rest assured that it works
    just fine with Java, Python, Ruby, JavaScript, and most other commonly used languages.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量功能依赖于一个名为 **Code Climate** 的外部服务。虽然该服务可以扫描所有主要计算机语言编写的代码，但它并不能处理所有的语言。你可以参考
    Code Climate 的官方文档，查看支持的语言列表，但可以放心，它与 Java、Python、Ruby、JavaScript 以及大多数其他常用语言完全兼容。
- en: 'What sorts of problems does the Code Quality feature look for? The general
    categories it’s interested in include performance, style, complexity, security,
    and smells (i.e., patterns that indicate a high risk of bugs). The exact violations
    that it detects vary from language to language, but here are some concrete examples
    of quality violations it can spot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量功能查找哪些类型的问题？它关注的主要类别包括性能、风格、复杂性、安全性以及臭味（即，指示高风险错误的模式）。它检测的具体违规行为因语言而异，但以下是一些它能够识别的质量违规实例：
- en: Functions that take too many parameters
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数过多的函数
- en: Functions with too many exit points
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有过多退出点的函数
- en: Functions or classes that are too long
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过长的函数或类
- en: Overly complex logical expressions
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于复杂的逻辑表达式
- en: Too much or too little vertical whitespace
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过多或过少的垂直空白
- en: Duplicated code
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复的代码
- en: In addition, if your computer language has an established set of stylistic conventions—think
    of the PEP-8 standard in Python, or the Rubocop rule set in Ruby—the Code Quality
    feature can be configured to include those rules.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你的编程语言有一套既定的风格规范——比如 Python 的 PEP-8 标准，或者 Ruby 的 Rubocop 规则集——可以将代码质量功能配置为包含这些规则。
- en: Enabling Code Quality
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用代码质量
- en: 'It couldn’t be easier to add Code Quality to your CI/CD pipeline:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Code Quality 添加到 CI/CD 流水线中再简单不过了：
- en: 'Make sure your pipeline has a `test` stage defined (hint: it almost certainly
    already has this stage, so you probably won’t have to do anything).'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的流水线已经定义了 `test` 阶段（提示：它几乎肯定已经有这个阶段了，所以你可能不需要做任何更改）。
- en: Include a GitLab-provided template (i.e., a file that contains additional CI/CD
    configuration code) called `Code-Quality.gitlab-ci.yml`, which adds a Code Quality
    job to your pipeline.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含一个 GitLab 提供的模板（即，包含额外 CI/CD 配置代码的文件），名为 `Code-Quality.gitlab-ci.yml`，它将 Code
    Quality 作业添加到你的流水线中。
- en: '*Step 1* will look like this in your project’s `.``gitlab-ci.yml` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1* 在你项目的 `.gitlab-ci.yml` 文件中看起来是这样的：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And *step 2* will look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 而 *步骤 2* 将是这样的：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that if you had already defined other stages, in *step 1*, you would simply
    add the `test` stage to the existing stages—you wouldn’t delete any existing stages.
    Similarly, if your pipeline configuration code already includes other templates,
    in *step 2*, you would add this new template to the existing templates instead
    of replacing them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你已经定义了其他阶段，在 *步骤 1* 中，你只需将 `test` 阶段添加到现有阶段中——你不会删除任何现有阶段。类似地，如果你的流水线配置代码中已经包含了其他模板，在
    *步骤 2* 中，你应当将这个新模板添加到现有模板中，而不是替换它们。
- en: The Code Quality feature is smart enough to detect all of the computer languages
    used in your GitLab project and run the appropriate scanners for each language.
    However, it’s important to understand that because these scanners are all developed
    by different people or teams outside of GitLab, there’s no guarantee that the
    scanners will find exactly the same problems in all supported languages. For example,
    the scanner for one language might be especially good at detecting duplicated
    code snippets, whereas the scanner for a different language might be especially
    adept at calling out complex code that should be simplified.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量功能足够智能，能够检测到你 GitLab 项目中使用的所有编程语言，并为每种语言运行相应的扫描器。然而，理解这一点非常重要：因为这些扫描器都是由
    GitLab 以外的不同人或团队开发的，所以不能保证这些扫描器在所有支持的语言中都能发现完全相同的问题。例如，某一种语言的扫描器可能特别擅长检测重复的代码片段，而另一种语言的扫描器可能特别擅长发现应该简化的复杂代码。
- en: Viewing Code Quality results
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看代码质量结果
- en: 'Let’s see a concrete example of Code Quality in action. Imagine that you have
    a file called `hats-for-cats.py` in the root directory of your project’s repository,
    containing this code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个具体的代码质量示例。假设你在项目的根目录下有一个名为 `hats-for-cats.py` 的文件，包含以下代码：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are two problems with this code that you would expect Code Quality to
    catch: the function has too many arguments, and the `TODO` comment should be acted
    on and removed.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存在两个你期望代码质量能够捕捉到的问题：该函数的参数太多，并且 `TODO` 注释应该被处理并移除。
- en: 'If you enable Code Quality on the project’s pipeline and then run the pipeline,
    the pipeline details page will include a new tab called **Code Quality**, which
    reveals the results of the Code Quality scan:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在项目的流水线中启用了代码质量功能，然后运行流水线，流水线详情页面将包含一个名为**代码质量**的新标签，显示代码质量扫描的结果：
- en: '![Figure 6.1 – Code Quality results in a pipeline details page](img/Figure_6.01_B18073.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 流水线详情页面中的代码质量结果](img/Figure_6.01_B18073.jpg)'
- en: Figure 6.1 – Code Quality results in a pipeline details page
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 流水线详情页面中的代码质量结果
- en: 'There’s another place you can see the same information: in a **merge request**.
    However, the report in a merge request differs from the report in a pipeline details
    page in one important way. Whereas the pipeline details report shows all the code
    quality problems found on whatever branch the pipeline ran on, the merge request
    report shows the difference between code quality problems on the merge request’s
    source branch and the merge request’s target branch. Since the target branch is
    almost always your project’s default branch (i.e., main or master), the merge
    request report shows you whether the work on your source branch is adding new
    code quality problems or fixing old code quality problems, compared to your stable
    code base. In other words, it shows whether the commits on your branch are making
    the project’s code better or worse.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在另一个地方看到相同的信息：**合并请求**中。然而，合并请求中的报告与流水线详情页面中的报告在一个重要方面有所不同。流水线详情报告显示的是在流水线运行所在分支上发现的所有代码质量问题，而合并请求报告则显示的是合并请求源分支与目标分支之间的代码质量问题差异。由于目标分支几乎总是你项目的默认分支（即，main
    或 master），合并请求报告会告诉你，相比于稳定的代码库，你的源分支上的工作是新增了代码质量问题，还是修复了旧的代码质量问题。换句话说，它展示了你分支上的提交是让项目的代码变得更好，还是更糟。
- en: 'To illustrate this, imagine that you make a branch, make a merge request for
    that branch, and commit a change to the branch that removes the `TODO` comment
    and adds a new `FIXME` comment. You’d expect the Code Quality report on the merge
    request to show that one old problem (`TODO`) has been fixed and one new problem
    (`FIXME`) has been added. And that’s exactly what appears in the merge request
    report:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，假设你创建了一个分支，为该分支创建了一个合并请求，并且提交了一个修改，删除了 `TODO` 注释并添加了一个新的 `FIXME` 注释。你会期望合并请求中的代码质量报告显示，一个旧的问题（`TODO`）已被修复，一个新问题（`FIXME`）被添加了。而这正是合并请求报告中显示的内容：
- en: '![Figure 6.2 – Code Quality results in a merge request](img/Figure_6.02_B18073.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 合并请求中的代码质量结果](img/Figure_6.02_B18073.jpg)'
- en: Figure 6.2 – Code Quality results in a merge request
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 合并请求中的代码质量结果
- en: Both report locations—the pipeline details page and the merge request—have an
    entry for each detected problem. These entries tell you the name of each problem,
    the filename, and the line number on which the problem occurred. This should be
    enough detail to let you decide whether to fix or ignore each code quality problem.
    You may decide to ignore some problems either as false positives or as genuine
    problems that are too small to be worth fixing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 两个报告位置——管道详细信息页面和合并请求——都为每个检测到的问题提供了条目。这些条目会告诉你每个问题的名称、文件名和问题发生的行号。这些信息应该足够让你决定是修复还是忽略每个代码质量问题。你可以决定忽略一些问题，可能是因为它们是假阳性，或者是因为它们是一些过于微小、不值得修复的实际问题。
- en: Code Quality is one of GitLab’s best and most valuable CI/CD features. It’s
    such an important tool for keeping your code readable and maintainable that GitLab
    makes it available on all license tiers of the product, including the Free tier.
    It’s fast to run, reliable, and effective. There’s really no reason not to use
    it on all of your projects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量是GitLab最优秀、最有价值的CI/CD功能之一。它是保持代码可读性和可维护性的一个重要工具，GitLab甚至将其作为产品所有许可层级的标准功能，包括免费版。它运行快速、可靠且高效。实际上没有理由不在所有项目中使用它。
- en: Running automated functional tests in a CI/CD pipeline
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CI/CD管道中运行自动化功能测试
- en: One of the most common tasks in a CI/CD pipeline is running automated functional
    tests to make sure your code does what it’s supposed to do. For example, you might
    want to use the `pytest` framework to run a collection of unit tests written in
    Python to test your Python-based Hats for Cats app. Let’s see how to do that with
    GitLab.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI/CD管道中，最常见的任务之一是运行自动化功能测试，以确保你的代码按预期工作。例如，你可能希望使用`pytest`框架来运行一系列用Python编写的单元测试，测试基于Python的“Hats
    for Cats”应用。让我们看看如何在GitLab中做到这一点。
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re not familiar with `pytest`, don’t worry. The syntax for `pytest` unit
    tests is extremely simple and can be understood by anyone with even a little experience
    of writing automated tests in any language.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉`pytest`，不用担心。`pytest`单元测试的语法非常简单，即使是对编写自动化测试有一点经验的人也能理解。
- en: Enabling automated functional tests
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用自动化功能测试
- en: 'Imagine that you’ve written three `pytest`-based unit tests to make sure the
    Hats for Cats app’s login feature works as expected. You might have a file called
    `test/test_login.py` with these contents:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经编写了三个基于`pytest`的单元测试，以确保“Hats for Cats”应用的登录功能按预期工作。你可能会有一个名为`test/test_login.py`的文件，内容如下：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Obviously, these sample tests have placeholder code that forces the first two
    tests to pass and the third to fail. Real tests would have actual logic that exercises
    the login feature in various ways, but these simplified examples make GitLab’s
    automated test feature easier to demonstrate.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些示例测试包含了占位符代码，强制前两个测试通过，第三个测试失败。实际的测试会有实际的逻辑，以多种方式验证登录功能，但这些简化的示例使得GitLab的自动化测试功能更容易演示。
- en: 'To run these automated tests in your pipeline, add a job that triggers them
    just like you would from the command line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在你的管道中运行这些自动化测试，添加一个作业来触发它们，就像你在命令行中执行一样：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This job definition specifies that the job belongs to the `test` stage, and
    that it must run within a Docker container that has version 3.10 of Python installed.
    The commands that it runs first install the `pytest` package using the `pip` package
    manager, and then call the newly installed `pytest` command to run all unit tests
    that are in the `test/` directory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个作业定义指定该作业属于`test`阶段，并且必须在安装了Python 3.10版本的Docker容器中运行。它首先运行的命令通过`pip`包管理器安装`pytest`包，然后调用新安装的`pytest`命令，运行`test/`目录中的所有单元测试。
- en: 'After adding this job and running the pipeline, you can inspect the job’s output
    and see that the tests did indeed run. You can even see the pass/fail results
    of each test. But the job’s output is hard to parse and a little cryptic. Wouldn’t
    it be nice if the results of the automated tests showed up in an easy-to-read
    table somewhere in the GitLab GUI? Fortunately, GitLab can do exactly that. You
    just need to tweak the job definition a little so that it stores the output of
    the unit tests in a particular format, and then saves that result file as a GitLab
    artifact. Adding this code to the end of the existing `unit-tests` job definition
    will do the trick:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加此任务并运行管道后，你可以检查任务的输出，看到测试确实已经运行。你甚至可以看到每个测试的通过/失败结果。但是，任务的输出很难解析，且有些晦涩。如果自动化测试的结果能以易于阅读的表格形式出现在GitLab的GUI中，那该多好？幸运的是，GitLab确实可以做到这一点。你只需要稍微调整任务定义，以便将单元测试的输出以特定格式存储，然后将该结果文件保存为GitLab的构件。将以下代码添加到现有的`unit-tests`任务定义末尾即可实现：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code tells GitLab to preserve the `unit_test_results.xml` file produced
    by the `pytest` framework. It also designates this file as a report that contains
    test results that are stored in the JUnit format, which is an industry-standard
    format that GitLab knows how to ingest and display. Finally, it tells GitLab to
    hold on to this file regardless of whether any of the tests fail. This last step
    is important because a failing test will cause the whole `unit-tests` job to have
    a **failed** status, which would normally cause the artifact to be discarded.
    But we want to see the results even if—maybe *especially* if—any of the tests
    fail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码指示GitLab保存`pytest`框架生成的`unit_test_results.xml`文件。它还将此文件指定为报告，该报告包含以JUnit格式存储的测试结果，JUnit是GitLab可以读取和显示的行业标准格式。最后，它指示GitLab在测试失败时仍然保留该文件。最后一步很重要，因为一个失败的测试会使整个`unit-tests`任务处于**失败**状态，通常这会导致构件被丢弃。但我们希望看到结果，即使——也许*尤其是*——当其中某些测试失败时。
- en: Viewing automated functional test results
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看自动化功能测试结果
- en: 'After adding the additional code we’ve just described and running a new pipeline
    instance, a new tab marked **Tests** will appear on the pipeline details page.
    Lo and behold, clicking that tab shows you an overview of how many automated tests
    passed and how many failed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加我们刚刚描述的附加代码并运行新的管道实例后，管道详情页面上将出现一个标记为**Tests**的新标签。看看，点击该标签会显示自动化测试的通过和失败概览：
- en: '![Figure 6.3 – Overview of automated test results](img/Figure_6.03_B18073.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 自动化测试结果概览](img/Figure_6.03_B18073.jpg)'
- en: Figure 6.3 – Overview of automated test results
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 自动化测试结果概览
- en: 'This table shows one row per job that triggers automated tests. Clicking on
    any row breaks down the results further, so you can see exactly which tests passed
    or failed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该表格显示了每个触发自动化测试的任务一行。点击任何一行可以进一步细分结果，因此你可以准确看到哪些测试通过或失败：
- en: '![Figure 6.4 – Individual automated test results](img/Figure_6.04_B18073.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 单个自动化测试结果](img/Figure_6.04_B18073.jpg)'
- en: Figure 6.4 – Individual automated test results
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 单个自动化测试结果
- en: As you might expect, the **View details** button next to each test shows you
    more information about that test, including the line of code that generated the
    failed assertion and the history of how often that test has failed in the past.
    This information helps you debug your product code—or your test, if that’s where
    the problem lies.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能预料到的，位于每个测试旁边的**查看详情**按钮会显示该测试的更多信息，包括生成失败断言的代码行，以及该测试过去失败的历史记录。这些信息有助于你调试产品代码——或者如果问题出在测试本身，则调试你的测试代码。
- en: '![Figure 6.5 – Details of a single automated test](img/Figure_6.05_B18073.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 单个自动化测试详情](img/Figure_6.05_B18073.jpg)'
- en: Figure 6.5 – Details of a single automated test
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 单个自动化测试详情
- en: Looking at functional test results in a pipeline details page shows you all
    the test results for the code in the branch that the pipeline ran against. Sometimes
    that’s exactly what you want. Other times, you want to know whether the code on
    a branch is experiencing any new test failures (or has fixed any failing tests)
    compared to the code on your project’s default branch. In other words, is the
    feature branch fixing broken code, is it breaking code that used to work, or is
    it doing some of each?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道详细页面查看功能测试结果，可以看到该管道运行的分支代码的所有测试结果。有时这正是你想要的。其他时候，你可能想知道与项目默认分支上的代码相比，某个分支上的代码是否出现了新的测试失败（或修复了某些失败的测试）。换句话说，功能分支是在修复坏代码，是在破坏曾经有效的代码，还是两者都有？
- en: 'Fortunately, the automated functional test report that appears in a merge request
    shows you exactly this information. Imagine that you’re working on a branch and
    you manage to fix one test that was failing on the default branch, break one test
    that was passing on the default branch, introduce one new test that passes, and
    introduce one new test that fails. The merge request for that branch would present
    a report that looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，出现在合并请求中的自动化功能测试报告正好为你提供了这些信息。假设你正在一个分支上工作，并且你成功修复了默认分支上失败的一个测试，破坏了默认分支上通过的一个测试，添加了一个通过的新测试，并且添加了一个失败的新测试。该分支的合并请求将呈现如下报告：
- en: '![Figure 6.6 – Merge request’s delta view of automated functional test results](img/Figure_6.06_B18073.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 合并请求的自动化功能测试结果的增量视图](img/Figure_6.06_B18073.jpg)'
- en: Figure 6.6 – Merge request’s delta view of automated functional test results
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 合并请求的自动化功能测试结果的增量视图
- en: This shows that two tests are failing, including the old test that you broke
    on this branch and one of the new tests that you added to this branch. It also
    shows that one test failed on the default branch but has been fixed on this branch.
    The merge request report does not mention the new test you added that is passing,
    other than to include it in the count of five total tests. This is because you
    are usually more interested in knowing which tests are failing than in knowing
    which are passing. If you do want to see the status of all tests—both passing
    and failing—the **View full report** button will give you that information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示有两个测试失败，包括你在这个分支上破坏的旧测试和你添加到这个分支上的新测试中的一个。它还显示默认分支上的一个测试失败，但在此分支上已修复。合并请求报告没有提到你添加的通过的新测试，除了在五个总测试的计数中包括它。这是因为你通常更关心的是哪些测试失败，而不是哪些测试通过。如果你确实想查看所有测试的状态——包括通过和失败的测试——**查看完整报告**按钮将为你提供这些信息。
- en: Running automated tests is often the very first task that a development team
    configures new pipelines to perform. If you stopped right there, you’d still get
    a huge amount of value out of GitLab CI/CD pipelines. But there are so many more
    ways you can verify your code with a pipeline! Let’s look at fuzz testing next.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行自动化测试通常是开发团队配置新管道时要执行的第一个任务。如果你仅仅做到这一点，你仍然可以从 GitLab CI/CD 管道中获得巨大的价值。但你可以通过管道验证代码的方式还有很多！接下来让我们看看模糊测试。
- en: Fuzz testing in a CI/CD pipeline
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD 管道中的模糊测试
- en: '**Fuzz testing** is an alternative, less traditional way of finding bugs in
    your code. Put succinctly, this advanced testing technique sends semi-random data
    to your code’s functions in an effort to trigger bugs. Although it takes a little
    more work to set up than the other scanners, it can pay off by spotting bugs that
    you probably never would have found using other methods.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**模糊测试**是一种替代性的、非传统的寻找代码缺陷的方法。简而言之，这种高级测试技术向代码的函数发送半随机数据，试图触发错误。虽然它的设置比其他扫描器需要更多的工作，但通过发现你可能使用其他方法永远找不到的错误，它是值得的。'
- en: Reminder about GitLab versions and features
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 GitLab 版本和功能的提示
- en: Fuzz testing, like many other features discussed throughout the book, is only
    available if you’re using GitLab with an Ultimate license. You can find out whether
    your license tier includes a particular feature by looking up that feature in
    the official GitLab documentation. Features are often made available in lower
    tiers after they’ve been restricted to higher tiers for a few years.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试，就像本书中讨论的许多其他功能一样，只有在你使用 GitLab Ultimate 许可证时才可用。你可以通过查看 GitLab 官方文档中的相关功能，了解你的许可证层级是否包括特定的功能。功能通常会在被高层级限制几年后，才会在较低层级中提供。
- en: 'There are two ways of performing fuzz testing in GitLab: **coverage-guided
    fuzz testing** and **web API fuzz testing**. In this book, we will only discuss
    the former, but the two techniques are similar enough that if you understand one,
    you’ll easily be able to learn about the other using GitLab’s documentation. From
    this point forward, whenever we refer to fuzz testing, we’re talking specifically
    about the coverage-guided variant.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab 中进行模糊测试有两种方式：**覆盖引导的模糊测试**和 **Web API 模糊测试**。在本书中，我们将只讨论前者，但这两种技术足够相似，如果你理解了其中一种，你可以很容易通过
    GitLab 的文档学习另一种。从现在开始，每当我们提到模糊测试时，我们指的就是覆盖引导的变体。
- en: The architecture and workflow of fuzz testing
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊测试的架构和工作流程
- en: 'There are four architectural components you need to understand in order to
    use coverage-guided fuzz testing: the **code under test**, the **CI/CD job**,
    the **fuzz engine**, and the **fuzz target**. Let’s look at each component and
    then see how they all fit together in the fuzz testing workflow.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用覆盖引导的模糊测试，你需要理解四个架构组件：**被测试的代码**、**CI/CD 作业**、**模糊引擎**和 **模糊目标**。让我们看看每个组件，然后再看看它们如何在模糊测试工作流程中协同工作。
- en: The code under test
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 被测试的代码
- en: Fuzz testing targets a single function in your code. That function can be written
    in any of the languages supported by GitLab’s fuzz tester, and it can be of any
    length. It must take at least one parameter, but there’s no upper limit on the
    number of parameters it expects. The function can call other functions, and if
    a bug is triggered anywhere within that call stack, the fuzz tester will report
    it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试针对代码中的单个函数。该函数可以用 GitLab 的模糊测试工具支持的任何语言编写，并且长度不限。它必须至少接受一个参数，但没有参数个数的上限。该函数可以调用其他函数，如果在调用栈中的任何地方触发了
    bug，模糊测试工具会报告它。
- en: 'Consider this Python function to be your code under test. Imagine that it’s
    in a file called `name_checker.py`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑这个 Python 函数作为你测试中的代码。假设它位于名为 `name_checker.py` 的文件中：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This simple function takes a string as a parameter. It immediately returns `False`
    if the string is empty. Otherwise, it returns `True` if the string is `bob` and
    `False` if it isn’t.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的函数将一个字符串作为参数。如果字符串为空，它立即返回 `False`。否则，如果字符串是 `bob`，则返回 `True`，否则返回 `False`。
- en: This is, of course, a terrible algorithm to use for this simple task, but we’ll
    ask you to restrain your urge to mutter insulting things about the author of this
    code and play along for the sake of the demo. Just pretend it was written by a
    terrified intern on his first day on the job.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这对于这个简单任务来说是一个糟糕的算法，但我们会请你抑制住对这段代码作者发泄不满的冲动，为了演示效果配合一下。假装这是一个刚上班的实习生写的，他完全是吓坏了。
- en: 'The intern is not only awful at designing algorithms, but he’s also not a very
    good coder. You’ve probably already spotted the function’s obvious bug: it doesn’t
    validate that the string that’s passed in is at least three characters long. As
    a consequence, if the string is only one character long and that character is
    `b`, the function will throw an unexpected `IndexError` when it tries to read
    the non-existent second character of the string. Similarly, if the only two characters
    in the string are `bo`, it will throw an `IndexError` when it tries to read the
    third character.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这位实习生不仅在设计算法方面很糟糕，而且也不是一个很好的程序员。你可能已经发现了函数的明显 bug：它没有验证传入的字符串是否至少有三个字符。因此，如果字符串只有一个字符且该字符是
    `b`，当函数尝试读取字符串中不存在的第二个字符时，它将抛出一个意外的 `IndexError`。同样，如果字符串中只有两个字符 `bo`，当函数尝试读取第三个字符时，它会抛出
    `IndexError`。
- en: It would be easy for the developer or QA team member responsible for writing
    tests to forget to test these cases. Let’s see whether fuzz testing will save
    the day by finding this bug.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员或 QA 团队负责编写测试用例时，可能会忘记测试这些情况。让我们看看模糊测试是否能通过找到这个 bug 来拯救局面。
- en: A CI/CD job
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个 CI/CD 作业
- en: Next, you need to define a job in your CI/CD pipeline that’s dedicated to fuzz
    testing the code under test. You can fuzz-test several different functions in
    one pipeline, but you’ll need a separate pipeline job for each function to be
    tested. In this case, your code under test consists of just one function, so you’ll
    define a single CI/CD job.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要在 CI/CD 流水线中定义一个专门用于模糊测试被测代码的作业。你可以在一个流水线中模糊测试多个不同的函数，但每个函数需要一个单独的流水线作业来进行测试。在这个例子中，你的被测试代码只有一个函数，因此你只需要定义一个
    CI/CD 作业。
- en: 'Before we get to the job definition, we should explain that the fuzz testing
    job *must* extend a job called `.fuzz_base`, which is defined in a template provided
    by GitLab. Before defining the job, you’ll need to include that template by adding
    a new line to the `includes:` section of `.gitlab-ci.yml`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义作业之前，我们应该解释一下模糊测试作业*必须*扩展一个名为`.fuzz_base`的作业，该作业在GitLab提供的模板中定义。在定义作业之前，您需要通过向`.gitlab-ci.yml`的`includes:`部分添加一行来包含该模板：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `.fuzz_base` job that we’ll be extending expects to run in a new stage
    called `fuzz`, which would have to run after the `build` stage so it can perform
    fuzz tests on compiled, runnable code. Let’s add that to our list of stages. Assuming
    that we’ve already defined `build` and `test` stages, the `stages:` section of
    `.gitlab-ci.yml` would look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展的`.fuzz_base`作业预期在一个名为`fuzz`的新阶段中运行，这个阶段必须在`build`阶段之后运行，以便它可以对已编译的可运行代码执行模糊测试。让我们把它添加到我们的阶段列表中。假设我们已经定义了`build`和`test`阶段，`.gitlab-ci.yml`的`stages:`部分将如下所示：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we’re ready to add a job definition to `.gitlab-ci.yml` that will kick
    off the fuzz test for our code under test:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备在`.gitlab-ci.yml`中添加一个作业定义，用于为我们的测试代码启动模糊测试：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This job, called `fuzz-test-is-bob`, first specifies that it should run in a
    Docker image that includes the latest version of Python. This is needed because
    the fuzz engine, fuzz target, and code under test are all written in Python.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为`fuzz-test-is-bob`的作业首先指定它应该在包含最新版本Python的Docker镜像中运行。这是必要的，因为模糊引擎、模糊目标和测试代码都是用Python编写的。
- en: Next, it inherits job configuration details from a parent job called `.fuzz_base`.
    This parent job is provided by GitLab, and there’s no need for you to know or
    care what configuration details it provides to your job.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它从名为`.fuzz_base`的父作业继承工作配置细节。这个父作业由GitLab提供，你不需要知道或关心它为你的作业提供了哪些配置细节。
- en: Then your job specifies two commands to run. The first installs a Python-based
    fuzz engine from a GitLab-hosted package registry. The second runs a binary called
    `gitlab-cov-fuzz`, pointing it at the correct fuzz engine and fuzz target. This
    binary is what actually starts up the fuzz test. You’ll get a better sense of
    how the fuzz test proceeds from there when we look at the entire fuzz test workflow
    in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您的作业指定了两个要运行的命令。第一个命令从GitLab托管的软件包注册表安装基于Python的模糊引擎。第二个命令运行一个名为`gitlab-cov-fuzz`的二进制文件，将其指向正确的模糊引擎和模糊目标。这个二进制文件实际上启动了模糊测试。当我们在下一节中查看整个模糊测试工作流程时，您将更好地了解模糊测试如何进行。
- en: The fuzz engine
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模糊引擎
- en: The fuzz engine is a GitLab-supplied binary that sends streams of random bytes
    to the fuzz target. These bytes serve as the basis for input data that the fuzz
    target will feed to the code under test—but more on that topic is coming in the
    next section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊引擎是GitLab提供的一个二进制文件，它向模糊目标发送随机字节流。这些字节作为输入数据的基础，模糊目标将把这些数据提供给正在测试的代码——但更多关于这个主题的信息将在下一节中介绍。
- en: 'Truth be told, it’s more accurate to call these bytes *semi-random* instead
    of *random*. This is because the fuzz engine looks at which lines of the code
    under test were exercised by the last round of data and attempts to mutate that
    data in such a way that when the mutated data serves as the *next* set of random
    bytes, it will exercise different lines in the code under test. So, it’s random,
    but it’s also influenced by the previously used sets of random data. This is where
    the term *coverage-guided* comes from: the fuzz tester uses code coverage data
    to influence how it generates the random data to send to the code under test.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 实话实说，将这些字节称为*半随机*比称其为*随机*更准确。这是因为模糊引擎查看了上一轮数据使用的哪些代码行，并试图以这样一种方式变异数据，使得当变异后的数据作为*下一组*随机字节使用时，它将执行测试代码中的不同代码行。因此，它是随机的，但也受先前使用的随机数据集的影响。这就是所谓的*覆盖率引导*的含义：模糊测试器使用代码覆盖数据来影响其如何生成发送给测试代码的随机数据。
- en: The fuzz target
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模糊目标
- en: 'The fuzz target is a small piece of code that you must write in the same language
    as the code under test. It serves as a translator or intermediary between the
    fuzz engine and the code under test. The fuzz target has two tasks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊目标是一小段您必须使用与测试代码相同的语言编写的代码。它充当模糊引擎和测试代码之间的翻译器或中介。模糊目标有两个任务：
- en: Transform the random bytes sent to it by the fuzz engine into the data type
    that the code under test expects to receive for its input parameter(s). For example,
    it might need to transform the bytes into an array of integers, a string, or an
    instance of a class.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模糊引擎发送给它的随机字节转换为待测试代码期望接收的输入参数的数据类型。例如，它可能需要将字节转换为一个整数数组、一个字符串或一个类的实例。
- en: Call the function in the code under test, passing it the transformed random
    bytes.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用待测试代码中的函数，将转换后的随机字节传递给它。
- en: 'For this example, the fuzz target needs to convert the random bytes sent by
    the fuzz engine into a string, and then pass that string to the `is_bob` function
    in `name_validator.py`. You can call the file that the fuzz target lives in anything
    you want, but there’s a fair amount of boilerplate that you must include in order
    to make it callable from by the fuzz engine. Let’s assume that you call your fuzz
    target file `is_bob_fuzz_target.py` and you include this content in the file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，模糊目标需要将模糊引擎发送的随机字节转换为一个字符串，然后将该字符串传递给`name_validator.py`中的`is_bob`函数。你可以将模糊目标所在的文件命名为任何你喜欢的名字，但为了让模糊引擎能够调用它，你必须包含一定量的样板代码。假设你将你的模糊目标文件命名为`is_bob_fuzz_target.py`，并在文件中包含以下内容：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let’s look at what’s happening here. The first line makes the code under test
    available so the fuzz target can pass it random data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。第一行使得待测试的代码可用，以便模糊目标可以将随机数据传递给它。
- en: 'The next two lines declare a function called `fuzz`, which takes random bytes
    as input. This is required boilerplate: you have to include these lines.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行声明了一个名为`fuzz`的函数，它接受随机字节作为输入。这是必需的样板代码：你必须包含这些行。
- en: 'Next, the fuzz target takes the random bytes that were sent to it by the fuzz
    engine and tries to transform them into a string, which is the data type that
    the code under test expects as input. For many (in fact, most!) collections of
    random bytes that are passed into the fuzz target, this conversion will fail due
    to at least one of the bytes falling outside the range of values that map to letters,
    numbers, punctuation, and other symbols. The `try` and `except` lines take care
    of this problem: if any of the bytes can’t be converted, the fuzz target simply
    returns without calling the code under test.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，模糊目标将模糊引擎发送给它的随机字节尝试转换为字符串，这是待测试代码期望作为输入的数据类型。对于许多（实际上是大多数！）传递给模糊目标的随机字节集，由于至少有一个字节超出了映射到字母、数字、标点符号和其他符号的值范围，这种转换将失败。`try`和`except`语句处理了这个问题：如果任何字节无法转换，模糊目标将直接返回，而不会调用待测试的代码。
- en: If the bytes *are* successfully converted into a string, the fuzz target exercises
    the code under test by passing the newly generated string to the `is_bob` function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果字节*成功*地转换为字符串，模糊目标通过将新生成的字符串传递给`is_bob`函数来测试待测试的代码。
- en: The final two lines are more boilerplate that you must include in any Python-based
    fuzz target.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两行是更多的样板代码，任何基于Python的模糊目标都必须包含这些代码。
- en: Remember that the fuzz target must be written in the same language as the code
    under test. Although the concepts used in non-Python fuzz targets are very similar
    to what is demonstrated here, the boilerplate and data transformation code will
    look slightly different in other languages.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，模糊目标必须使用与待测试代码相同的编程语言编写。尽管非Python模糊目标中使用的概念与这里展示的非常相似，但样板代码和数据转换代码在其他语言中可能会有所不同。
- en: A fuzz testing workflow
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个模糊测试工作流
- en: 'Here’s how the four components work together to perform fuzz testing whenever
    you run your project’s pipeline:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这四个组件如何协同工作，每当你运行项目的流水线时执行模糊测试：
- en: The CI/CD job called `fuzz-test-is-bob` triggers as part of the `fuzz` stage.
    It downloads the `gitlab-cov-fuzz` binary and the Python-based fuzz engine. It
    then runs the `gitlab-cov-fuzz` binary, pointing it at the Python fuzz engine
    and the fuzz target that lives in `is_bob_fuzz_target.py`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 名为`fuzz-test-is-bob`的CI/CD作业在`fuzz`阶段触发。它下载`gitlab-cov-fuzz`二进制文件和基于Python的模糊引擎。然后，它运行`gitlab-cov-fuzz`二进制文件，将其指向Python模糊引擎和位于`is_bob_fuzz_target.py`中的模糊目标。
- en: The fuzz engine generates a series of random bytes and passes them to the `fuzz`
    function in `is_bob_fuzz_target.py`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模糊引擎生成一系列随机字节，并将它们传递给`is_bob_fuzz_target.py`中的`fuzz`函数。
- en: The fuzz target transforms the random bytes into a string, since that’s the
    data type that the `is_bob` function (i.e., the code under test) expects as input.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模糊目标将随机字节转换为字符串，因为`is_bob`函数（即待测试代码）期望接收字符串作为输入。
- en: The fuzz target passes the string to `is_bob`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模糊测试目标将字符串传递给`is_bob`。
- en: If `is_bob` handles the random string gracefully—that is, without crashing or
    throwing any unexpected exceptions—the fuzz engine looks at which lines of code
    were exercised by the last series of random bytes and generates a new series of
    random bytes that are designed to exercise different lines in `is_bob`. This cycle
    continues, with the fuzz engine generating new bytes with each pass through the
    cycle.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`is_bob`能够优雅地处理随机字符串——即没有崩溃或抛出任何意外异常——模糊引擎会查看上一系列随机字节所触发的代码行，并生成一系列新的随机字节，旨在触发`is_bob`中不同的代码行。这个过程会持续进行，每次循环时模糊引擎都会生成新的字节。
- en: If, on the other hand, the random string causes `is_bob` to crash or throw an
    unexpected exception, the fuzz engine reports that to the `fuzz-test-is-bob` CI/CD
    job, which reports that the fuzz test has found a bug in the code under test.
    Success! Well, success at triggering a failure, anyway.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，如果随机字符串导致`is_bob`崩溃或抛出意外异常，模糊引擎会将此报告给`fuzz-test-is-bob` CI/CD任务，该任务报告模糊测试在被测试代码中发现了一个错误。成功！当然，至少成功地触发了一个失败。
- en: Viewing the results of fuzz testing
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看模糊测试结果
- en: 'When the fuzz test finds a bug, it displays this information in three places:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当模糊测试发现一个错误时，它会在三个地方显示这些信息：
- en: The vulnerability report, which you can navigate to by clicking **Security &
    Compliance** | **Vulnerability Report** in the left navigation pane. This only
    shows any problems that fuzz testing found on your project’s default branch.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漏洞报告，你可以通过点击左侧导航窗格中的**Security & Compliance** | **Vulnerability Report**访问。此报告仅展示模糊测试在项目的默认分支上发现的问题。
- en: The **Security** tab on the pipeline details page. This shows any problems that
    fuzz testing found on whatever branch that pipeline instance ran against.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道详细信息页面上的**Security**标签。这展示了模糊测试在该管道实例运行的任何分支上发现的问题。
- en: In a merge request. This shows a *delta* between problems that fuzz testing
    found on the default branch and problems it found on the source branch of the
    merge request. If nothing has changed between the default branch and the source
    branch, the merge request will report that the fuzz test found no problems at
    all, no matter how many problems actually exist on both branches.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在合并请求中。这展示了模糊测试在默认分支上发现的问题与在合并请求的源分支上发现的问题之间的*差异*。如果默认分支和源分支之间没有任何变化，合并请求将报告模糊测试未发现任何问题，无论两个分支上实际存在多少问题。
- en: 'Although the exact bugs reported will vary according to the type of report
    you’re looking at, the type of details provided by each report will be almost
    identical. For example, here’s a page from the vulnerability report that presents
    details about the bug that fuzz testing found in the `is_bob` code under test:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管报告的具体错误会根据你查看的报告类型有所不同，但每个报告提供的详细信息类型几乎是相同的。例如，以下是漏洞报告中的一页，展示了模糊测试在被测试的`is_bob`代码中发现的错误的详细信息：
- en: '![Figure 6.7 – Fuzz testing bug report](img/Figure_6.07_B18073.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 模糊测试错误报告](img/Figure_6.07_B18073.jpg)'
- en: Figure 6.7 – Fuzz testing bug report
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 模糊测试错误报告
- en: 'Notice that this report includes a stack trace showing what error was thrown
    (`IndexError`), and which line threw it (the line with the `return` statement).
    The report also tells you which random bytes—also called a “sample”—triggered
    the problem. In this case, the fuzz engine generated a single byte: 62\. It turns
    out that 62 in UTF-8 corresponds to the lowercase letter of `b`. If you look at
    the `is_bob` function in the code under test, you should be able to see exactly
    why an input string consisting of a single letter, `b`, would expose this bug.
    Isn’t it satisfying when a complicated system such as the fuzz tester works exactly
    as expected?'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个报告包含了一个堆栈跟踪，显示了抛出的错误（`IndexError`），以及是哪一行抛出的（带有`return`语句的那一行）。报告还告诉你是哪个随机字节——也叫做“样本”——触发了这个问题。在这种情况下，模糊引擎生成了一个单一的字节：62。事实证明，62在UTF-8中对应字母`b`的小写字母。如果你查看被测试代码中的`is_bob`函数，你应该能够清楚地看到为什么由单个字母`b`组成的输入字符串会暴露这个错误。当像模糊测试器这样复杂的系统按预期准确运行时，是不是感觉特别满足？
- en: Extra considerations when fuzz testing
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊测试时的额外注意事项
- en: Compared to the predictable, logical nature of the other ways you can validate
    your code with GitLab, fuzz testing is like your erratic uncle who shows up to
    family gatherings wearing mismatched socks and spewing mysterious comments that
    could be either deeply profound or utter nonsense, depending on the day. Fuzz
    testing’s random nature means that its results can be unpredictable. You might
    run the same fuzz test on the same code under test on 2 different days and find
    a bug within 10 seconds on the first day, but find nothing after 10 minutes on
    the second day. You never quite know what fuzz testing will turn up, if anything
    at all. This isn’t anything to worry about, since a new fuzz testing session will
    happen every time you run your project’s pipeline; even if it doesn’t find anything
    today, it might find an important problem tomorrow.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与GitLab提供的其他验证代码的方式的可预测、逻辑性相比，模糊测试就像你那个怪异的叔叔，他会穿着不匹配的袜子出现在家庭聚会中，说一些神秘的评论，这些评论可能是深刻的，也可能是完全无稽之谈，这取决于那天的情况。模糊测试的随机性质意味着它的结果是不可预测的。你可能在不同的两天运行相同的模糊测试，第一天在10秒内就发现了一个bug，而第二天运行10分钟后什么也没发现。你永远不知道模糊测试会带来什么，甚至可能什么也没有发现。这不必担心，因为每次运行项目的管道时都会进行新的模糊测试；即使今天没有发现问题，明天也许会找到一个重要的问题。
- en: Keeping in mind that fuzz testing increases its chances of finding problems
    the longer it runs, some teams choose to run it asynchronously rather than as
    a normal pipeline job that blocks later stages in the pipeline. This technique
    is beyond the scope of this book, but GitLab’s documentation explains how to set
    this up if you’d like to experiment with it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，模糊测试运行时间越长，它发现问题的机会就越大，有些团队选择异步运行模糊测试，而不是作为正常的管道作业，这样不会阻塞管道中的后续阶段。这个技术超出了本书的范围，但如果你想尝试，GitLab的文档会解释如何设置。
- en: Another way that fuzz testing differs from other tests or scanners is that it
    stops as soon as it finds a single problem, whereas other tools typically continue
    to run until they’ve found and reported on every issue they’re capable of unearthing.
    Again, this is normally not a problem since most projects will run fuzz testing
    tens, hundreds, or thousands of times over the course of their development. But
    it’s good to understand that just because fuzz testing found a bug today, it doesn’t
    mean there are more bugs lurking in your code that it might find on subsequent
    runs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他测试或扫描工具不同，模糊测试的另一种方式是，它会在发现一个问题后立即停止，而其他工具通常会继续运行，直到找到并报告它们能够挖掘出的所有问题。通常这不是问题，因为大多数项目会在开发过程中运行模糊测试数十次、数百次或数千次。但了解这一点很重要，模糊测试今天发现了一个bug，并不意味着在后续的运行中，代码中还有其他隐藏的bug等待被发现。
- en: Remember that although you can fuzz-test as many functions in your code under
    test as you’d like, you must create a separate CI/CD job and a separate fuzz target
    for each function. This can add up to significant overhead when you’re getting
    fuzz testing off the ground. Fortunately, once everything’s in place and fuzz
    testing is working as expected, there’s usually no need to change either the jobs
    or the fuzz targets.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，虽然你可以对代码中的任何函数进行模糊测试，但每个函数必须创建一个单独的CI/CD作业和一个单独的模糊测试目标。当你开始进行模糊测试时，这可能会增加不少开销。幸运的是，一旦所有设置完毕，模糊测试按预期工作后，通常不需要更改作业或模糊测试目标。
- en: Fuzz testing with a corpus
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带语料库的模糊测试
- en: Fuzz testing has a special, optional feature that you can use called a **corpus**.
    This is a list of random bytes that the fuzz tester can use for two purposes.
    First, if a particular series of random bytes caused a bug or crash in the code
    under test, and then your team fixed that bug, it could be useful for future fuzz
    tests to send exactly the same random bytes to the code under test to make sure
    that it hasn’t regressed. In other words, once your team fixes a bug, it’s a nice
    safety measure for the fuzz test to make sure that it stays fixed. If you add
    the troublesome bytes to the corpus, then all future fuzz test runs will use that
    series of bytes as one of the values sent to the code under test.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试有一个特殊的可选功能，叫做**语料库**。这是一系列随机字节，模糊测试工具可以用来实现两个目的。首先，如果某一系列随机字节在测试代码时导致了bug或崩溃，而你的团队已修复了该bug，那么将这些随机字节用于未来的模糊测试可以确保代码没有回归。换句话说，一旦你的团队修复了bug，将这些有问题的字节加入语料库是一个很好的安全措施，可以确保bug不会复发。如果你将这些有问题的字节加入语料库，那么所有未来的模糊测试运行都将使用这系列字节作为发送到测试代码中的值之一。
- en: The second use of a corpus is to help the fuzz tester find bugs more quickly.
    When it generates truly random bytes as input to the code under test, it can take
    a long time to find bugs—if it ever finds them at all. But if you load up the
    corpus with one or more series of bytes that constitute valid input (i.e., input
    that the code under test can handle gracefully), then the fuzz test can mutate
    that valid data and use the mutated data as its next series of input to the code
    under test. Mutating valid data often results in finding data that triggers bugs
    far more quickly than relying on truly random bytes as input to the code under
    test.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 语料库的第二个用途是帮助模糊测试工具更快地发现bug。当它生成真正随机的字节作为输入并测试代码时，可能需要很长时间才能找到bug——如果能找到的话。但如果你向语料库中加载一个或多个构成有效输入的字节序列（即代码可以优雅处理的输入），那么模糊测试可以改变这些有效数据并将其作为下一组输入传递给代码进行测试。变异有效数据往往能比完全依赖随机字节作为输入更快地找到触发bug的数据。
- en: Setting up a corpus can be somewhat complicated, especially if you want to make
    use of a clever GitLab feature that automatically updates the corpus every time
    the fuzz test finds a bug. The GitLab documentation will lead you through this
    process if you think a corpus might be useful. We do recommend experimenting with
    this optional feature because it can hugely increase the power of fuzz testing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 设置语料库可能有些复杂，特别是如果你想利用 GitLab 的一个巧妙功能，该功能会在每次模糊测试发现 bug 时自动更新语料库。如果你认为语料库可能有用，GitLab
    文档会引导你完成此过程。我们确实建议你尝试这一可选功能，因为它可以大大增强模糊测试的效果。
- en: 'Next, we’ll move on from the powerful and somewhat exotic bug-finding tool
    of fuzz testing and look at an important but often-overlooked way of checking
    the quality of your code: **accessibility testing**.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将从强大且有些特殊的 bug 发现工具——模糊测试，转向一种重要但常被忽视的代码质量检查方式：**可访问性测试**。
- en: Checking accessibility in a CI/CD pipeline
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CI/CD 管道中检查可访问性
- en: Not all applications include web interfaces, but whenever you do write a web
    app, we strongly recommend you use your GitLab CI/CD pipeline to make sure your
    interface is accessible for people with a range of disabilities. Fortunately,
    GitLab makes it easy to test your website against the **Web Content Accessibility
    Guidelines** (**WCAG**) laid out by the World Wide Web Consortium.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有应用程序都包含网页界面，但每当你编写网页应用时，我们强烈建议你使用 GitLab CI/CD 管道来确保你的界面对各种残障人士可访问。幸运的是，GitLab
    使得测试你的网站是否符合**网页内容可访问性指南**（**WCAG**）变得非常简单，WCAG 是由万维网联盟制定的标准。
- en: 'These guidelines address a wide assortment of characteristics of websites that
    could cause accessibility problems. Here are just a few of the things that the
    WCAG covers:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指南涵盖了可能导致可访问性问题的网站特征。以下是 WCAG 涵盖的一些内容：
- en: Pages that require scrolling both vertically and horizontally
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要同时进行纵向和横向滚动的页面
- en: HTML heading tags such as `<H1>` that contain no text
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如 `<H1>` 这样的 HTML 标题标签没有文本内容
- en: Text that doesn’t contrast strongly enough with its background
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本与背景对比度不足
- en: Images that lack an alternative text description
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少替代文本描述的图片
- en: Button controls that have no name available for screen readers
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有可供屏幕阅读器使用的按钮控件名称
- en: You might be surprised both at how many accessibility problems this scanner
    finds in your web interface, and also at how easy it is to fix many of these issues.
    Don’t feel bad if it finds several accessibility bugs on your site; try pointing
    the scanner at any popular website and you’ll probably be amazed at the number
    of basic accessibility violations it exhibits!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对这个扫描工具在你的网页界面中找到的可访问性问题数量感到惊讶，也可能会对修复这些问题的难易程度感到惊讶。如果它在你的网站上发现了几个可访问性bug，不要感到沮丧；试试把扫描工具指向任何一个流行网站，你很可能会惊讶于它展示出来的基本可访问性违规问题的数量！
- en: Enabling accessibility testing
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用可访问性测试
- en: 'To add accessibility testing to your pipeline, you first need to create a new
    stage called `accessibility` in your `.``gitlab-ci.yml` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的管道中添加可访问性测试，首先需要在 `.gitlab-ci.yml` 文件中创建一个名为 `accessibility` 的新阶段：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In all likelihood, your project will already have a `stages` section defined,
    in which case you should just add the new `accessibility` stage to the existing
    section instead of defining a whole new `stages` section (which would produce
    a malformed `.``gitlab-ci.yml` file).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能你的项目已经定义了 `stages` 部分，在这种情况下，你只需将新的 `accessibility` 阶段添加到现有的部分，而不是重新定义整个
    `stages` 部分（这会导致 `.gitlab-ci.yml` 文件格式错误）。
- en: 'Next, include the GitLab-provided template that contains the accessibility-related
    job definitions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，包括由GitLab提供的包含与辅助性工作相关的作业定义的模板：
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we said before, if you’ve already defined an `include` section, simply add
    this template to it instead of defining a new `include` section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，如果您已经定义了一个`include`部分，只需将此模板添加到其中，而不是定义一个新的`include`部分。
- en: 'Finally, set a global variable that tells the accessibility scanner which website
    to inspect. This could be your web app in its production environment or in any
    pre-production, staging, or review environment. It can also be fun (and instructive)
    to point the accessibility scanner at any site on the web, even if it’s not one
    you own. Here, we’ll point it at a pretend URL where the Hats for Cats website
    runs in production:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置一个全局变量，告诉辅助性扫描器要检查哪个网站。这可以是您的Web应用程序在其生产环境中或任何预生产、暂存或审查环境。指向辅助性扫描器的任何网站，即使它不是您拥有的网站，也可能是有趣的（并且有教育意义）。在这里，我们将指向一个假的URL，Hats
    for Cats网站在其生产环境中运行：
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once again, if you already have a global `variables` section, simply add this
    new variable to it instead of creating a second `variables` section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，如果你已经有一个全局`variables`部分，只需将这个新变量添加到其中，而不是创建第二个`variables`部分。
- en: Believe it or not, that’s all you need to do. To get accessibility testing up
    and running in your pipeline. The accessibility scanner doesn’t offer any other
    configuration options, which makes it extremely simple to set up.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这就是你需要做的全部。要在管道中启用辅助性测试，获取辅助性扫描器并运行它。辅助性扫描器没有提供任何其他配置选项，这使得设置非常简单。
- en: Viewing accessibility testing results
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看辅助性测试结果
- en: The accessibility scanner doesn’t integrate its results into a GitLab dashboard
    like you saw with the automated functional test results. But it does generate
    an easy-to-read HTML page that describes all of the less severe problems (called
    **warnings**) and more severe problems (called **errors**) it finds.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助性扫描器不会像您在自动功能测试结果中看到的那样将其结果集成到GitLab仪表板中。但它确实会生成一个易于阅读的HTML页面，描述其发现的所有较轻微问题（称为**警告**）和更严重问题（称为**错误**）。
- en: 'To see this page, run a pipeline with accessibility testing enabled and visit
    the pipeline details page. You’ll see a job called `a11y`, which is the job that
    runs the accessibility scanner. Click on that job to see the terminal output from
    the job. You can ignore that output, but in the **Job artifacts** pane on the
    right, you’ll see a button for browsing any artifacts produced by the job:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此页面，请运行启用辅助性测试的管道并访问管道详细信息页面。您将看到一个名为`a11y`的作业，这是运行辅助性扫描器的作业。单击该作业以查看作业的终端输出。您可以忽略该输出，但在右侧的**作业工件**窗格中，您将看到一个浏览作业产生的任何工件的按钮：
- en: '![Figure 6.8 – Finding the accessibility scanner’s artifacts](img/Figure_6.08_B18073.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 查找辅助性扫描工具的工件](img/Figure_6.08_B18073.jpg)'
- en: Figure 6.8 – Finding the accessibility scanner’s artifacts
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 查找辅助性扫描工具的工件
- en: Clicking this button will show you both JSON and HTML reports generated by the
    accessibility scanner. These reports both contain the same information about any
    accessibility violations found on the targeted website. The JSON output can be
    downloaded, parsed, and integrated into any other dashboard you may have set up.
    The HTML report is human-readable within your browser and lets everyone on your
    team see what accessibility-related work you might want to carve out into issues
    so it can be tracked and managed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 单击此按钮将显示辅助性扫描器生成的JSON和HTML报告。这些报告都包含有关目标网站上发现的任何辅助性违规的相同信息。可以下载JSON输出，解析并集成到您设置的任何其他仪表板中。HTML报告可在浏览器中以人类可读的方式查看，让您的团队成员了解可能需要拆分成问题以进行跟踪和管理的辅助性相关工作。
- en: There’s another way to see the findings of the accessibility scanner, other
    than by looking at one of its two artifacts. Remember how a merge request’s versions
    of Code Quality reports and automated functional test reports show the difference
    between code quality or test results on the default branch and code quality or
    test results on the merge request’s source branch? The merge request report on
    accessibility violations works in exactly the same way.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一种方法可以查看辅助性扫描工具的发现，而不是查看其两个工件之一。记得代码质量报告和自动功能测试报告的合并请求版本展示了默认分支上的代码质量或测试结果与合并请求源分支上的代码质量或测试结果之间的差异吗？辅助性违规的合并请求报告工作方式完全相同。
- en: If you have a branch with a corresponding merge request, the merge request will
    show any accessibility violations that were found on the latest pipeline that
    was run against that branch, as long as those violations are *not* also found
    on a pipeline run against the default branch at the time the branch was created.
    In other words, the merge request shows you whether the pipeline’s branch is making
    your project’s code better (by fixing accessibility problems that were on the
    default branch) or worse (by adding new accessibility problems that were not on
    the default branch). This is a great report to have if you’re working on a feature
    branch and want to make sure your boss doesn’t yell at you because you’re adding
    more problems than you’re fixing!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个与合并请求相对应的分支，合并请求将显示在针对该分支运行的最新管道中发现的任何可访问性违规，前提是这些违规*没有*出现在该分支创建时针对默认分支运行的管道中。换句话说，合并请求会告诉你管道的分支是让你的项目代码变得更好（通过修复默认分支上的可访问性问题），还是更差（通过引入默认分支上没有的新的可访问性问题）。如果你在一个功能分支上工作，并且希望确保你的老板不会因为你增加了比修复更多的问题而责备你，这个报告非常有用！
- en: Additional ways to verify your code
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证代码的其他方法
- en: We’ve covered some of the most common ways to verify your code. GitLab offers
    even more features that help you test your code further. We don’t have enough
    space to cover all of them in detail, but here’s a quick description of three
    additional methods you can use to test code. Details for enabling and configuring
    all of these tools are available in the official GitLab documentation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了一些验证代码的常见方法。GitLab还提供了更多功能，帮助你进一步测试代码。由于篇幅限制，我们无法详细介绍所有方法，但这里简要描述了你可以用来测试代码的三种额外方法。启用和配置这些工具的详细信息，可以在官方的GitLab文档中找到。
- en: Code coverage
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Automated functional tests make sure that your code is doing what it’s supposed
    to do. Having tests in place is a critical part of every software development
    project, but it’s easy to get a false sense of confidence from seeing that all
    your tests are passing if you don’t know how much of your code base those tests
    cover. After all, having 100 passing tests doesn’t do you much good if all of
    those tests execute the same 5% of your application’s code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化功能测试确保你的代码按预期工作。测试的存在是每个软件开发项目的关键部分，但如果你不知道你的测试覆盖了多少代码库，看到所有测试都通过，可能会让你产生一种虚假的信心。毕竟，如果所有测试都执行了应用程序代码的同一个5%，那么即使有100个测试通过，也对你帮助不大。
- en: Code coverage reports give you confidence in the value of your test results.
    You can configure GitLab to use an appropriate, language-specific code coverage
    tool to determine exactly which lines of your product code are exercised by your
    tests. This report is integrated into the GitLab GUI, so it’s easy to tell which
    lines of code you should target as you write new tests.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率报告让你对测试结果的价值有信心。你可以配置GitLab，使用适当的、语言特定的代码覆盖工具来精确确定哪些产品代码行被你的测试执行。这个报告集成在GitLab的图形界面中，所以在编写新测试时，你很容易知道应该关注哪些代码行。
- en: Browser performance testing
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器性能测试
- en: Since so many of today’s applications are run in a browser, and since browser-based
    applications are generally much slower than traditional desktop applications,
    it’s important to keep track of how quickly the various pages of your website
    load, and to know whether changes you’re making to the code are making those load
    times better or worse.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于如今许多应用程序都运行在浏览器中，而且基于浏览器的应用程序通常比传统的桌面应用程序慢得多，因此，跟踪网站各个页面的加载速度非常重要，并且要知道你对代码所做的更改是否使加载时间变得更快或更慢。
- en: GitLab can measure page load times and display the results in merge requests
    so developers can understand how their proposed code changes affect the performance
    of their web app. It can even raise a special alert whenever performance degrades
    beyond a particular user-configurable threshold. The report lets developers fix
    any performance-related problems that their code has introduced before their code
    is merged into the stable code base.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab可以测量页面加载时间，并在合并请求中显示结果，开发人员可以了解他们所提出的代码更改如何影响他们的Web应用性能。它甚至可以在性能下降到特定的用户可配置阈值时，发出特别警报。这个报告让开发人员在代码合并到稳定的代码库之前，修复任何由其代码引入的性能问题。
- en: Load performance testing
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载性能测试
- en: While browser performance testing tells you how quickly the frontend GUI of
    your web app loads, GitLab’s **load performance testing** helps you track the
    performance of your applications’ backend code. Although this feature can exercise
    your application in various ways, it’s most commonly used to target your application’s
    API. For example, it can hammer your application with tens, hundreds, or thousands
    of simultaneous calls to one or more of your application’s REST API endpoints,
    and then monitor how quickly your application responds to those calls. You can
    also use this tool to perform long-running soak tests to see whether your application
    develops memory leaks or other problems over time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然浏览器性能测试可以告诉你网页应用前端 GUI 加载的速度，GitLab 的**负载性能测试**帮助你跟踪应用程序后端代码的性能。尽管这个功能可以以多种方式对你的应用进行测试，但最常见的做法是针对应用程序的
    API。例如，它可以通过数十、数百或数千个并发请求，向一个或多个应用的 REST API 端点发起测试，然后监控应用对这些请求的响应速度。你还可以使用这个工具执行长期的浸泡测试，以检查你的应用是否在长时间运行后出现内存泄漏或其他问题。
- en: The load performance test feature displays its findings in merge requests so
    developers can understand how any code changes on the branch associated with that
    merge request affect their applications’ backend performance.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 负载性能测试功能在合并请求中展示其结果，以便开发人员理解与该合并请求相关的分支上的任何代码变更如何影响其应用程序的后端性能。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Once again, you covered a lot of ground in this chapter. You saw how to build
    code within a GitLab CI/CD pipeline, using a variety of different methods and
    languages. This doesn’t cover every possible way you could compile or otherwise
    build your code—we’ve barely scratched the surface of that topic—but you should
    have a good idea of the general steps involved regardless of what language or
    tools you use. You also learned that certain kinds of code verification tools
    require that you build your code first because they interact with your code as
    it runs. Other tests don’t require this step because they simply scan your source
    code without running it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，在这一章中你覆盖了大量内容。你学会了如何在 GitLab CI/CD 管道中构建代码，使用了多种不同的方法和语言。虽然这并没有涵盖你可以用来编译或构建代码的所有可能方法——我们仅仅触及了这个话题的皮毛——但无论你使用什么语言或工具，你应该对涉及的基本步骤有一个清晰的了解。你还学到了一些代码验证工具需要先构建代码，因为它们会在代码运行时与之交互。其他测试则不需要这一步，因为它们只扫描你的源代码，而不运行它。
- en: Next, you saw how to use GitLab’s Code Quality feature within your pipelines
    to make sure your code follows best practices for coding style, adheres to common
    coding conventions, avoids unnecessary complexity, and doesn’t exhibit any *code
    smells* that indicate the possible presence of bugs or unexpected behavior.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你了解了如何在 GitLab 的管道中使用代码质量功能，以确保你的代码遵循最佳的编码风格实践，遵循常见的编码约定，避免不必要的复杂性，并且没有出现任何*代码异味*，这些异味可能表明存在潜在的错误或异常行为。
- en: Then you learned how to integrate automated functional tests into GitLab CI/CD
    pipelines. You saw not only how to trigger these tests from within a pipeline
    job but also how to ensure that the results can be seen in two different reports
    within the GitLab GUI. You also discovered how to use the *delta* view of test
    results within a merge request to learn whether the code on that merge request’s
    branch is helping or hurting the pass rate of your product’s automated tests.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你学习了如何将自动化功能测试集成到 GitLab CI/CD 管道中。你不仅了解了如何从管道作业中触发这些测试，还学习了如何确保结果可以在 GitLab
    界面的两个不同报告中查看。你还发现了如何使用合并请求中的*增量*视图查看测试结果，以了解该合并请求的分支上的代码是否有助于提高产品自动化测试的通过率，或是降低了通过率。
- en: Next up was fuzz testing, GitLab’s most complicated but perhaps most interesting
    bug-finding feature. You learned about the four different components that make
    up the fuzz testing architecture, and you saw how random data flows from one component
    to the next in an attempt to trip up your code and cause crashes or unexpected
    exceptions. You became familiar with fuzz testing’s various idiosyncrasies and
    learned how to accommodate them. Finally, you saw how to use a corpus not only
    to catch functional regressions in your code but also to speed up fuzz testing
    and make it more likely to find problems.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是模糊测试，GitLab 最复杂但也许是最有趣的找错功能。你了解了构成模糊测试架构的四个不同组件，并看到如何通过这些组件将随机数据传递到下一个组件，试图触发代码错误或导致崩溃或异常。你熟悉了模糊测试的各种独特性，并学会了如何适应它们。最后，你了解了如何使用语料库，不仅可以捕获代码中的功能回归，还能加速模糊测试，并增加找到问题的可能性。
- en: The final tool you got to watch in action was GitLab’s accessibility testing
    feature. This helps you ensure that your web applications are usable by people
    with a range of disabilities, maximizing your possible user base.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你最后看到的工具是 GitLab 的无障碍测试功能。这个功能帮助你确保你的网页应用可以被不同残障人士使用，从而最大化你的潜在用户群体。
- en: These tools are a great place to start when it comes to validating your software
    projects, but GitLab offers several additional ways to inspect your code even
    more thoroughly. You got a lightning-fast tour of the code coverage tool, browser
    performance testing, and load performance testing. All of this will reward further
    exploration using GitLab’s official documentation and some experimentation of
    your own.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具在验证你的软件项目时是一个很好的起点，但 GitLab 提供了几种额外的方法来更深入地检查你的代码。你已经快速了解了代码覆盖工具、浏览器性能测试和负载性能测试。所有这些内容都值得通过使用
    GitLab 的官方文档和你自己的实验进行进一步探索。
- en: Once your code has been verified, you can deploy it to a production environment
    for customers to use, right? Nope. You first need to make sure it doesn’t contain
    any security vulnerabilities, which is the topic we’ll explore in the next chapter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的代码通过验证，你可以将其部署到生产环境供客户使用，对吧？不对。你首先需要确保它不包含任何安全漏洞，这也是我们在下一章中要探讨的内容。
