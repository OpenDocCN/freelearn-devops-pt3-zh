- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Verifying Your Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证你的代码
- en: For most projects, the first thing a **GitLab CI/CD** pipeline should do is
    *verify the code*. Different projects will rely on different tasks to perform
    this critical step, but they usually involve some combination of checking the
    code quality and running automated functional tests. As a prerequisite for certain
    kinds of verification, some projects will need to build their code first. This
    chapter focuses on building and then verifying your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数项目，**GitLab CI/CD**管道应该首先做的事情是*验证代码*。不同的项目会依赖不同的任务来执行这一关键步骤，但通常涉及检查代码质量和运行自动化功能测试的某种组合。作为某些类型验证的先决条件，有些项目需要先构建代码。
    本章将重点介绍构建然后验证代码。
- en: We’ll first discuss whether building the code is necessary, and if so, how to
    configure a GitLab CI/CD pipeline to carry out that task. Then, we’ll talk about
    how to use a pipeline to run GitLab’s built-in code quality scanner. Next, we’ll
    explain how to run automated functional tests within a pipeline. Then, we’ll cover
    a fascinating variety of automated testing called **fuzz testing**, which can
    find problems that traditional automated functional tests might miss. We’ll touch
    on GitLab’s accessibility testing, which ensures that your code can be used by
    a wide range of people. Finally, we’ll briefly mention a few other ways that you
    can verify your code, though we won’t have room to describe them in detail. By
    the end of the chapter, you’ll have an array of tools at your disposal for making
    sure your code is well written and does what it’s supposed to.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论构建代码是否必要，如果必要的话，如何配置GitLab CI/CD管道来执行此任务。接着，我们将讨论如何使用管道运行GitLab内置的代码质量扫描工具。然后，我们将解释如何在管道中运行自动化功能测试。接下来，我们将介绍一种非常有趣的自动化测试，称为**模糊测试**，它可以发现传统自动化功能测试可能遗漏的问题。我们还将涉及GitLab的可访问性测试，确保你的代码能够被广泛的人群使用。最后，我们将简要提及几种其他验证代码的方法，尽管我们没有足够的篇幅来详细描述它们。到本章结束时，你将拥有一系列工具，确保你的代码编写良好且能够按预期执行。
- en: 'These are the main topics of this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要内容包括：
- en: Building code in a CI/CD pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI/CD管道中构建代码
- en: Checking code quality in a CI/CD pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI/CD管道中检查代码质量
- en: Running automated functional tests in a CI/CD pipeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI/CD管道中运行自动化功能测试
- en: Fuzz testing in a CI/CD pipeline
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI/CD管道中进行模糊测试
- en: Checking accessibility in a CI/CD pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI/CD管道中检查可访问性
- en: Additional ways to verify your code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证代码的其他方法
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As with the previous chapters, you’ll get the most out of this chapter if you’ve
    got an account on a GitLab instance (*self-managed* or *Software-as-a-Service*)
    that you can log in to and use for practicing and experimenting with the concepts
    discussed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前的章节一样，如果你在一个GitLab实例（*自托管*或*软件即服务*）上有一个帐户，并可以登录并用来练习和实验本章讨论的概念，你将从本章获得最大的收益。
- en: Building code in a CI/CD pipeline
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CI/CD管道中构建代码
- en: At the risk of oversimplifying some of the mechanics that happen behind the
    scenes when you run software, we can generally think of *interpreted* computer
    languages such as Python or Ruby as executing raw source code, whereas *compiled*
    languages such as Java, C, or C# must convert that source code into a runnable
    form by compiling it, and then execute the compiled version of the program.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在简化运行软件时发生的后台机制的风险下，我们可以大致将*解释型*编程语言，如Python或Ruby，视为直接执行原始源代码，而*编译型*语言，如Java、C或C#，则必须通过编译将源代码转换为可运行的形式，然后执行编译后的程序版本。
- en: This is an important distinction to keep in mind when configuring a pipeline
    to verify your code because it means that if your project contains any code written
    in a compiled language (even if it’s only a small portion of your overall project),
    you probably need to include a build job in your pipeline before any verification
    jobs take place. We say *probably* because some of the jobs that typically run
    during the verification stage of a pipeline (for example, Code Quality) look directly
    at source code, whereas others interact with code as it runs. So, if your pipeline
    only uses verification scans that focus on source code, you can omit the build
    step no matter what language you’re using. If you want to include automated functional
    tests or fuzz testing in your pipeline, you *will* need to build your code first,
    so read on!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是配置管道以验证代码时需要牢记的一个重要区别，因为这意味着如果你的项目中包含任何用编译语言编写的代码（即使它只是你整体项目中的一小部分），你可能需要在任何验证任务之前，在管道中包括一个构建任务。我们说*可能*是因为一些通常在管道验证阶段运行的任务（例如，代码质量检查）直接查看源代码，而另一些则与运行中的代码进行交互。所以，如果你的管道只使用关注源代码的验证扫描，无论你使用什么语言，都可以省略构建步骤。如果你希望在管道中包含自动化功能测试或模糊测试，你*需要*先构建你的代码，所以请继续阅读！
- en: Every language builds its code in a different way, using different tools. Even
    within a single language, there are sometimes multiple tools or techniques for
    building code. Let’s look at two different ways to compile Java code and one way
    to compile C code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每种编程语言都有不同的构建方式，使用不同的工具。即使是在同一种语言中，有时也会有多种工具或技术来构建代码。让我们来看两种编译Java代码的方法以及一种编译C代码的方法。
- en: These examples are meant to give you the big picture of how to build code within
    a GitLab CI/CD pipeline. They are not meant to be comprehensive examples of all
    the ways to accomplish this task. There are so many different languages and tools
    that we can only give you a few bare-bones examples and then let you adapt and
    expand them to work with your own languages, tools, constraints, and preferences.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例旨在让你了解如何在GitLab CI/CD管道中构建代码的全貌。它们并非所有实现这一任务方式的全面示例。因为有太多不同的语言和工具，我们只能给出一些基本的示例，然后让你根据自己的语言、工具、约束和偏好进行调整和扩展。
- en: Compiling Java with javac
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用javac编译Java代码
- en: Outside of simple training applications, real-world Java projects rarely use
    the `javac` compiler to convert Java source code (i.e., files with the `.java`
    extension) into compiled Java classes (i.e., files with the `.class` extension).
    Using the `javac` tool is effective when you’re only dealing with a few files,
    but it can become cumbersome as projects grow in complexity. But just like peanut
    butter and jelly sandwiches can be a great introduction to cooking even though
    they’d never be served at a formal dinner at Buckingham Palace, `javac` is a great
    way to introduce new GitLab users to the concept of using CI/CD pipelines to compile
    Java code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的训练应用程序，现实世界中的Java项目很少使用`javac`编译器将Java源代码（即`.java`扩展名的文件）转换为编译后的Java类（即`.class`扩展名的文件）。当你只处理几个文件时，使用`javac`工具是有效的，但随着项目复杂度的增加，这种方法可能变得繁琐。然而，就像花生酱果酱三明治是烹饪入门的好方式，尽管它们永远不会出现在白金汉宫的正式晚宴上，`javac`也是将新GitLab用户引入使用CI/CD管道编译Java代码的好方法。
- en: Adding your Java application
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加你的Java应用程序
- en: 'Let’s keep things simple by creating a single file application and a single
    Java package called `com.hatsforcats`. You can use GitLab’s Web IDE editor to
    create a directory called `src/com/hatsforcats` to store your source code. Inside
    that directory, use the Web IDE to create a file called `Login.java`. Add this
    trivial Hello World-style Java code to that file:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保持简单，创建一个单文件应用程序和一个名为`com.hatsforcats`的Java包。你可以使用GitLab的Web IDE编辑器创建一个名为`src/com/hatsforcats`的目录来存储你的源代码。在该目录下，使用Web
    IDE创建一个名为`Login.java`的文件。将以下简单的Hello World风格的Java代码添加到该文件：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Configuring your pipeline
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置你的管道
- en: 'Now that your app has been added to the project, it’s time to configure your
    pipeline. Start with an empty `.gitlab-ci.yml` file in the root of your project’s
    repository and define a `build` stage for your pipeline using the `stages` keyword:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的应用已被添加到项目中，是时候配置你的管道了。从项目仓库根目录下的空`.gitlab-ci.yml`文件开始，并使用`stages`关键字为你的管道定义一个`build`阶段：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, you’ll define a pipeline job that lives within the *build* stage and
    runs `javac`. Let’s stipulate a few extra requirements for this example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将定义一个位于*构建*阶段并运行`javac`的管道任务。为了这个例子，让我们设定一些额外的要求：
- en: All the Java source files belong to the `com.hatsforcats` Java package.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的 Java 源代码文件都属于`com.hatsforcats` Java 包。
- en: Your team’s coding standards require you to put all source code within a `src/`
    directory that lives in the project’s root directory.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您团队的编码标准要求将所有源代码放在项目根目录中的`src/`目录下。
- en: Compiled files should end up in a `target/` directory that lives in the project’s
    root directory.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译后的文件应保存在项目根目录中的`target/`目录下。
- en: 'To compile your code while satisfying these criteria, you’ll need to define
    a job in `.gitlab-ci.yml` to do the work. Call it something obvious and put it
    in the *build* stage:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在满足这些标准的同时编译代码，您需要在`.gitlab-ci.yml`中定义一个任务来完成这项工作。给它起个明显的名字，并将其放入*build*阶段：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Within that job definition, you’ll want to specify which Docker image the job
    should run within. The job will need access to the `javac` compiler, so a good
    image to use is the latest version of `openjdk`. Add this to the job definition
    (remember to watch your indentation):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在该任务定义中，您需要指定任务运行的 Docker 镜像。任务需要访问`javac`编译器，因此一个好的选择是使用最新版本的`openjdk`。将其添加到任务定义中（记得调整缩进）：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, the job needs to invoke the Java compiler. Any commands that you list
    under the `script` keyword will run when the pipeline executes that job:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任务需要调用 Java 编译器。在`script`关键字下列出的任何命令将在管道执行该任务时运行：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: No doubt you can figure out the syntax of the `javac` command from the requirements
    given earlier, but if not, feel free to refer to the Java compiler’s documentation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 毋庸置疑，您能根据之前给出的要求理解`javac`命令的语法，但如果不能，随时可以参考 Java 编译器的文档。
- en: Believe it or not, that’s all you need in order to compile Java code within
    a GitLab CI/CD pipeline!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这就是在 GitLab CI/CD 管道中编译 Java 代码所需要的一切！
- en: 'But to demonstrate that the job works as expected, let’s add more lines to
    the `script` section of the `compile-java-with-javac` job. The first line will
    show the contents of the `target/` directory after `javac` has worked its magic.
    If the compiler worked, this command will display the compiled version of your
    Java source file when the job runs:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示任务按预期工作，接下来让我们在`compile-java-with-javac`任务的`script`部分添加更多行。第一行将在`javac`执行完毕后显示`target/`目录的内容。如果编译器工作正常，该命令将在任务运行时显示编译后的
    Java 源文件版本：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next lines will execute your compiled `Login.class` code to prove that
    it has compiled correctly. Normally, you wouldn’t run your code in a job that’s
    dedicated to building it, but you’re doing it in this case simply to demonstrate
    that the compile actually happened:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行将执行您编译后的`Login.class`代码，以证明它已正确编译。通常，您不会在专门构建代码的任务中运行代码，但在这种情况下，您只是为了演示编译确实发生了：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here’s the complete text of `.gitlab-ci.yml` that you have assembled. If you’re
    following along, make sure that your version of that file contains exactly this
    text:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您已经组装好的`.gitlab-ci.yml`完整文本。如果您跟着操作，请确保该文件的版本正好包含以下内容：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Commit this file and navigate over to the list of pipelines in your project.
    Zoom in on the pipeline run that was automatically triggered by your commit, zoom
    in on the `compile-java` job, and see whether you can find text similar to this
    snippet at the end of the job’s output:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 提交此文件，并转到项目中的管道列表。缩放到由您的提交自动触发的管道运行，缩放到`compile-java`任务，并查看是否能在任务输出的末尾找到类似于此代码段的文本：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the `javac` command ran without emitting any errors, the `ls`
    command shows a compiled version of `Login.java`, and the class produced the expected
    output when it was executed. Success!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`javac`命令在没有出现错误的情况下运行，`ls`命令显示了编译后的`Login.java`版本，并且该类在执行时产生了预期的输出。成功！
- en: Compiling Java with Maven
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Maven 编译 Java
- en: Let’s try a slightly more complicated, albeit probably more realistic, way of
    compiling the same Java project you set up in the previous section. Instead of
    using the Java compiler directly, let’s use `*.java` file into a compiled `*.``class`
    file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一种稍微复杂一点的方法，尽管它可能更符合实际情况，用来编译您在上一节中设置的相同 Java 项目。我们不直接使用 Java 编译器，而是将`*.java`文件编译成`*.class`文件。
- en: Configuring Maven
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Maven
- en: 'Maven is configured via a special file called `pom.xml`. There’s no need to
    get into the structure or content of that file here, but if you’re curious about
    what each section does, the Maven documentation can give you all the details.
    Copy this bare-bones content into a new `pom.xml` file in your project’s root
    directory:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 通过一个名为`pom.xml`的特殊文件进行配置。这里无需深入讨论该文件的结构或内容，但如果你对每个部分的作用感到好奇，Maven 文档可以为你提供所有细节。将以下简洁的内容复制到你项目根目录中的新`pom.xml`文件中：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding your Java application
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加你的 Java 应用程序
- en: 'If you’re re-using the same project from the preceding `javac` example, you
    already have a Java program added to the project’s repository. If you’re using
    a new project, add this Java code to a new file called `Login.java` in a new `src/com/hatsforcats/`
    directory:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新使用前面 `javac` 示例中的相同项目，你已经将一个 Java 程序添加到项目的仓库中。如果你使用的是新项目，请将以下 Java 代码添加到一个名为`Login.java`的新文件中，并将该文件放置在新的
    `src/com/hatsforcats/` 目录中：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Configuring your pipeline
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置你的管道
- en: 'Either make a new `.gitlab-ci.yml` file in your root directory or replace all
    the content in your existing `.gitlab-ci.yml` file with this configuration code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在根目录下创建一个新的 `.gitlab-ci.yml` 文件，或者用这段配置代码替换你现有的 `.gitlab-ci.yml` 文件中的所有内容：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You’ll notice that the pipeline configuration code for a Maven-powered build
    is similar to the configuration code for a Java-compiler-powered build, but with
    a few key differences:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，Maven 驱动的构建的管道配置代码与 Java 编译器驱动的构建配置代码类似，但有几个关键的不同之处：
- en: A different value after the `image` keyword means that the GitLab Runner will
    execute the job within a Maven-based Docker image instead of a Java-based Docker
    image.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image` 关键字后面的不同值意味着 GitLab Runner 将在基于 Maven 的 Docker 镜像中执行任务，而不是在基于 Java
    的 Docker 镜像中。'
- en: The command to compile the code uses `mvn` instead of `javac`.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译代码的命令使用的是 `mvn`，而不是 `javac`。
- en: Maven puts compiled classes in a different directory than the source code by
    default, so you don’t have to explicitly tell it to do so like you did with `javac`
    (although notice that its default directory for compiled files isn’t quite the
    same as the one you specified with `javac`).
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Maven 将编译后的类放在与源代码不同的目录中，因此你不需要像使用 `javac` 时那样明确告诉它这么做（尽管请注意，它的默认目录与使用
    `javac` 时指定的目录并不完全相同）。
- en: 'After committing this configuration code, you can view the details of the pipeline
    that is automatically triggered and zoom in on the `compile-java-with-maven` job.
    You should see something similar to this snippet at the end of the output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 提交该配置代码后，你可以查看自动触发的管道的详细信息，并放大查看`compile-java-with-maven`任务。你应该会在输出的末尾看到类似于这个片段的内容：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The Maven-driven compile worked correctly, the compiled class appears where
    you expected it to, and the class gives the expected output when you run it. You’ll
    never need to run the `mvn compile` command manually again!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Maven 驱动的编译正常工作，编译后的类出现在你预期的位置，运行时该类会输出预期的结果。你将再也不需要手动运行`mvn compile`命令！
- en: Compiling C with Gnu Compiler Collection (GCC)
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Gnu Compiler Collection (GCC) 编译 C 代码
- en: Let’s take a look at building a project based on the **C** programming language.
    Normally, you would use a tool such as Make to build your C project, just like
    you use Maven to build a Java project. But to keep this example as simple as possible,
    you’ll rely on the good old GCC to compile some C code directly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看基于 **C** 编程语言的项目构建。通常，你会使用像 Make 这样的工具来构建 C 项目，就像使用 Maven 构建 Java 项目一样。但为了尽可能简化这个例子，你将依赖于经典的
    GCC 来直接编译一些 C 代码。
- en: If you’re following along at home, you can either make a new project for your
    C program, or you can re-use the project that you used for the two earlier Java
    examples.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在家中跟着做，你可以为你的 C 程序创建一个新项目，或者你也可以重新使用之前为两个 Java 示例使用的项目。
- en: Adding your C application
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加你的 C 应用程序
- en: 'Navigate to your project’s repository in the GitLab GUI, add a new file at
    the root directory called `login.c`, and paste this simple C code into it:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab GUI 中导航到你的项目仓库，在根目录添加一个名为`login.c`的新文件，并将这段简单的 C 代码粘贴进去：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Configuring your pipeline
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置你的管道
- en: 'Setting up a pipeline to use GCC to compile C code isn’t terribly different
    from what you saw in the Java examples. Here are the main differences:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个管道以使用 GCC 编译 C 代码与 Java 示例中的设置差别不大。以下是主要区别：
- en: The job runs in a Docker image that includes the GCC tools.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该任务将在包含 GCC 工具的 Docker 镜像中运行。
- en: The job definition’s `script` keyword specifies using `gcc` instead of `mvn`
    or `javac` to build your code.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作业定义中的 `script` 关键字指定使用 `gcc` 而不是 `mvn` 或 `javac` 来构建你的代码。
- en: The job runs the compiled code directly instead of invoking a JVM with the `java`
    command.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该作业直接运行已编译的代码，而不是通过 `java` 命令调用 JVM。
- en: 'The basic CI/CD configuration code for building and running a C program with
    GCC could look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和运行一个使用 GCC 编译的 C 程序的基本 CI/CD 配置代码可能如下所示：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To repeat something we said earlier, you normally would not run your code in
    the same job as you built it—in fact, you might not run it at all in a pipeline.
    But you’re running it here just to demonstrate that compiling worked as expected.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重复我们之前提到的内容，通常你不会在构建代码的同一作业中运行它——实际上，在流水线中你可能根本不运行它。但你在这里运行它仅仅是为了展示编译是否按预期工作。
- en: 'And here’s a snippet from the output of this job, showing that your C program
    compiled and ran correctly:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该作业输出的一个片段，显示你的 C 程序已经正确编译和运行：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Storing built code as artifacts
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将构建的代码作为工件存储
- en: 'There’s one more keyword you need to know before you can move on to pipeline
    stages that test the code that you just built: the `artifacts` keyword.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以继续进行测试你刚刚构建的代码的流水线阶段之前，还有一个你需要了解的关键字：`artifacts` 关键字。
- en: Any files that a pipeline job creates—including compiled versions of files that
    are generated during a build job—are deleted as soon as the job completes. This
    is very different from how build tools work on the command line. If you type `javac
    MyApp.java` in a terminal, the `MyApp.class` file that is generated will stick
    around on your filesystem until you delete it. But in a GitLab CI/CD pipeline,
    every job operates in its own, self-contained environment. This means that if
    you compile some files in a `build-java` job and then try to test them in a `test-java`
    job that lives in a later stage, the `test-java` job will *not* be able to see
    the files that you so carefully built earlier.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线作业创建的任何文件——包括在构建作业过程中生成的编译文件——都会在作业完成后立即被删除。这与命令行中的构建工具工作方式非常不同。如果你在终端中输入
    `javac MyApp.java`，生成的 `MyApp.class` 文件会一直保留在你的文件系统中，直到你删除它。但是在 GitLab CI/CD 流水线中，每个作业都在自己的独立环境中运行。这意味着如果你在
    `build-java` 作业中编译了一些文件，然后在后续阶段的 `test-java` 作业中测试它们，`test-java` 作业将*无法*看到你之前精心构建的文件。
- en: 'Fortunately, the `artifacts` keyword gives you a workaround. This keyword lets
    you specify certain files or directories that GitLab should preserve from one
    job and make available to all later jobs. For example, to preserve the executable
    `login` file that you generated in the `compile-c` job, you could add these two
    lines to the bottom of the `compile-c` job definition:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`artifacts` 关键字提供了一个解决方法。这个关键字允许你指定 GitLab 应该从一个作业中保留并在所有后续作业中提供的某些文件或目录。例如，要保留在
    `compile-c` 作业中生成的可执行 `login` 文件，你可以将以下两行添加到 `compile-c` 作业定义的底部：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can specify more than one file to preserve, and you can specify one or
    more directories to preserve in addition to any individual files. You can also
    specify subdirectories or files to exclude from the list of artifacts. For example,
    to save the entire contents of the directory that Maven puts compiled files in,
    except for files that start with `Test` that exist in any subdirectory, you could
    add these lines to the bottom of the `compile-java-with-maven` job from earlier:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定多个文件进行保存，并且除了任何单独的文件外，你还可以指定一个或多个目录进行保存。你还可以指定要从工件列表中排除的子目录或文件。例如，要保存 Maven
    放置编译文件的目录中的所有内容，但排除任何子目录中以 `Test` 开头的文件，你可以将以下代码添加到之前 `compile-java-with-maven`
    作业的底部：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `artifacts` keyword is one of the most important keywords that you’ll use
    when configuring CI/CD pipelines, and forgetting to use it when it’s needed is
    a common mistake. If your pipeline isn’t working the way you expect it to, one
    of the first troubleshooting steps you should try is to check whether you’re specifying
    artifacts in all of the jobs that generate files that you want to access in later
    jobs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`artifacts` 关键字是配置 CI/CD 流水线时最重要的关键字之一，忘记在需要时使用它是一个常见的错误。如果你的流水线没有按照预期工作，应该尝试的第一个故障排除步骤是检查是否在所有生成你想在后续作业中访问的文件的作业中指定了工件。'
- en: 'Now that you’ve learned when and how to build your code in a CI/CD pipeline,
    let’s move on to what is typically the next pipeline step: *checking the quality
    of* *your code*.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了在 CI/CD 流水线中何时以及如何构建代码，接下来让我们继续讨论通常是下一个流水线步骤的内容：*检查你的代码质量*。
- en: Checking code quality in a CI/CD pipeline
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 CI/CD 流水线中检查代码质量
- en: One of the many scanners that GitLab makes available to CI/CD pipelines is a
    special feature that makes sure your project’s code adheres to certain quality
    standards. GitLab calls this feature, unsurprisingly, **Code Quality**. If you’ve
    used any sort of linting tool before, you can think of this feature as a turbocharged
    linter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 提供的众多扫描工具之一是一个特殊功能，它确保你的项目代码符合特定的质量标准。GitLab 将这个功能称为，毫不意外的，**代码质量**。如果你之前使用过任何类型的
    linting 工具，可以将这个功能看作是一个加速版的 linter。
- en: The Code Quality feature relies on an outside service called **Code Climate**.
    Although this service can scan code written in all the major computer languages,
    it can’t handle every language out there. You can refer to Code Climate’s official
    documentation to see a list of supported languages, but rest assured that it works
    just fine with Java, Python, Ruby, JavaScript, and most other commonly used languages.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量功能依赖于一个名为 **Code Climate** 的外部服务。虽然该服务可以扫描所有主要计算机语言编写的代码，但它并不能处理所有的语言。你可以参考
    Code Climate 的官方文档，查看支持的语言列表，但可以放心，它与 Java、Python、Ruby、JavaScript 以及大多数其他常用语言完全兼容。
- en: 'What sorts of problems does the Code Quality feature look for? The general
    categories it’s interested in include performance, style, complexity, security,
    and smells (i.e., patterns that indicate a high risk of bugs). The exact violations
    that it detects vary from language to language, but here are some concrete examples
    of quality violations it can spot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量功能查找哪些类型的问题？它关注的主要类别包括性能、风格、复杂性、安全性以及臭味（即，指示高风险错误的模式）。它检测的具体违规行为因语言而异，但以下是一些它能够识别的质量违规实例：
- en: Functions that take too many parameters
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数过多的函数
- en: Functions with too many exit points
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有过多退出点的函数
- en: Functions or classes that are too long
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过长的函数或类
- en: Overly complex logical expressions
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过于复杂的逻辑表达式
- en: Too much or too little vertical whitespace
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过多或过少的垂直空白
- en: Duplicated code
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复的代码
- en: In addition, if your computer language has an established set of stylistic conventions—think
    of the PEP-8 standard in Python, or the Rubocop rule set in Ruby—the Code Quality
    feature can be configured to include those rules.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你的编程语言有一套既定的风格规范——比如 Python 的 PEP-8 标准，或者 Ruby 的 Rubocop 规则集——可以将代码质量功能配置为包含这些规则。
- en: Enabling Code Quality
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用代码质量
- en: 'It couldn’t be easier to add Code Quality to your CI/CD pipeline:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Code Quality 添加到 CI/CD 流水线中再简单不过了：
- en: 'Make sure your pipeline has a `test` stage defined (hint: it almost certainly
    already has this stage, so you probably won’t have to do anything).'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你的流水线已经定义了 `test` 阶段（提示：它几乎肯定已经有这个阶段了，所以你可能不需要做任何更改）。
- en: Include a GitLab-provided template (i.e., a file that contains additional CI/CD
    configuration code) called `Code-Quality.gitlab-ci.yml`, which adds a Code Quality
    job to your pipeline.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含一个 GitLab 提供的模板（即，包含额外 CI/CD 配置代码的文件），名为 `Code-Quality.gitlab-ci.yml`，它将 Code
    Quality 作业添加到你的流水线中。
- en: '*Step 1* will look like this in your project’s `.``gitlab-ci.yml` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1* 在你项目的 `.gitlab-ci.yml` 文件中看起来是这样的：'
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And *step 2* will look like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 而 *步骤 2* 将是这样的：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that if you had already defined other stages, in *step 1*, you would simply
    add the `test` stage to the existing stages—you wouldn’t delete any existing stages.
    Similarly, if your pipeline configuration code already includes other templates,
    in *step 2*, you would add this new template to the existing templates instead
    of replacing them.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你已经定义了其他阶段，在 *步骤 1* 中，你只需将 `test` 阶段添加到现有阶段中——你不会删除任何现有阶段。类似地，如果你的流水线配置代码中已经包含了其他模板，在
    *步骤 2* 中，你应当将这个新模板添加到现有模板中，而不是替换它们。
- en: The Code Quality feature is smart enough to detect all of the computer languages
    used in your GitLab project and run the appropriate scanners for each language.
    However, it’s important to understand that because these scanners are all developed
    by different people or teams outside of GitLab, there’s no guarantee that the
    scanners will find exactly the same problems in all supported languages. For example,
    the scanner for one language might be especially good at detecting duplicated
    code snippets, whereas the scanner for a different language might be especially
    adept at calling out complex code that should be simplified.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量功能足够智能，能够检测到你 GitLab 项目中使用的所有编程语言，并为每种语言运行相应的扫描器。然而，理解这一点非常重要：因为这些扫描器都是由
    GitLab 以外的不同人或团队开发的，所以不能保证这些扫描器在所有支持的语言中都能发现完全相同的问题。例如，某一种语言的扫描器可能特别擅长检测重复的代码片段，而另一种语言的扫描器可能特别擅长发现应该简化的复杂代码。
- en: Viewing Code Quality results
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看代码质量结果
- en: 'Let’s see a concrete example of Code Quality in action. Imagine that you have
    a file called `hats-for-cats.py` in the root directory of your project’s repository,
    containing this code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个具体的代码质量示例。假设你在项目的根目录下有一个名为 `hats-for-cats.py` 的文件，包含以下代码：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are two problems with this code that you would expect Code Quality to
    catch: the function has too many arguments, and the `TODO` comment should be acted
    on and removed.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码存在两个你期望代码质量能够捕捉到的问题：该函数的参数太多，并且 `TODO` 注释应该被处理并移除。
- en: 'If you enable Code Quality on the project’s pipeline and then run the pipeline,
    the pipeline details page will include a new tab called **Code Quality**, which
    reveals the results of the Code Quality scan:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在项目的流水线中启用了代码质量功能，然后运行流水线，流水线详情页面将包含一个名为**代码质量**的新标签，显示代码质量扫描的结果：
- en: '![Figure 6.1 – Code Quality results in a pipeline details page](img/Figure_6.01_B18073.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 流水线详情页面中的代码质量结果](img/Figure_6.01_B18073.jpg)'
- en: Figure 6.1 – Code Quality results in a pipeline details page
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 流水线详情页面中的代码质量结果
- en: 'There’s another place you can see the same information: in a **merge request**.
    However, the report in a merge request differs from the report in a pipeline details
    page in one important way. Whereas the pipeline details report shows all the code
    quality problems found on whatever branch the pipeline ran on, the merge request
    report shows the difference between code quality problems on the merge request’s
    source branch and the merge request’s target branch. Since the target branch is
    almost always your project’s default branch (i.e., main or master), the merge
    request report shows you whether the work on your source branch is adding new
    code quality problems or fixing old code quality problems, compared to your stable
    code base. In other words, it shows whether the commits on your branch are making
    the project’s code better or worse.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在另一个地方看到相同的信息：**合并请求**中。然而，合并请求中的报告与流水线详情页面中的报告在一个重要方面有所不同。流水线详情报告显示的是在流水线运行所在分支上发现的所有代码质量问题，而合并请求报告则显示的是合并请求源分支与目标分支之间的代码质量问题差异。由于目标分支几乎总是你项目的默认分支（即，main
    或 master），合并请求报告会告诉你，相比于稳定的代码库，你的源分支上的工作是新增了代码质量问题，还是修复了旧的代码质量问题。换句话说，它展示了你分支上的提交是让项目的代码变得更好，还是更糟。
- en: 'To illustrate this, imagine that you make a branch, make a merge request for
    that branch, and commit a change to the branch that removes the `TODO` comment
    and adds a new `FIXME` comment. You’d expect the Code Quality report on the merge
    request to show that one old problem (`TODO`) has been fixed and one new problem
    (`FIXME`) has been added. And that’s exactly what appears in the merge request
    report:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，假设你创建了一个分支，为该分支创建了一个合并请求，并且提交了一个修改，删除了 `TODO` 注释并添加了一个新的 `FIXME` 注释。你会期望合并请求中的代码质量报告显示，一个旧的问题（`TODO`）已被修复，一个新问题（`FIXME`）被添加了。而这正是合并请求报告中显示的内容：
- en: '![Figure 6.2 – Code Quality results in a merge request](img/Figure_6.02_B18073.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – 合并请求中的代码质量结果](img/Figure_6.02_B18073.jpg)'
- en: Figure 6.2 – Code Quality results in a merge request
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 合并请求中的代码质量结果
- en: Both report locations—the pipeline details page and the merge request—have an
    entry for each detected problem. These entries tell you the name of each problem,
    the filename, and the line number on which the problem occurred. This should be
    enough detail to let you decide whether to fix or ignore each code quality problem.
    You may decide to ignore some problems either as false positives or as genuine
    problems that are too small to be worth fixing.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 两个报告位置——管道详细信息页面和合并请求——都为每个检测到的问题提供了条目。这些条目会告诉你每个问题的名称、文件名和问题发生的行号。这些信息应该足够让你决定是修复还是忽略每个代码质量问题。你可以决定忽略一些问题，可能是因为它们是假阳性，或者是因为它们是一些过于微小、不值得修复的实际问题。
- en: Code Quality is one of GitLab’s best and most valuable CI/CD features. It’s
    such an important tool for keeping your code readable and maintainable that GitLab
    makes it available on all license tiers of the product, including the Free tier.
    It’s fast to run, reliable, and effective. There’s really no reason not to use
    it on all of your projects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量是GitLab最优秀、最有价值的CI/CD功能之一。它是保持代码可读性和可维护性的一个重要工具，GitLab甚至将其作为产品所有许可层级的标准功能，包括免费版。它运行快速、可靠且高效。实际上没有理由不在所有项目中使用它。
- en: Running automated functional tests in a CI/CD pipeline
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在CI/CD管道中运行自动化功能测试
- en: One of the most common tasks in a CI/CD pipeline is running automated functional
    tests to make sure your code does what it’s supposed to do. For example, you might
    want to use the `pytest` framework to run a collection of unit tests written in
    Python to test your Python-based Hats for Cats app. Let’s see how to do that with
    GitLab.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI/CD管道中，最常见的任务之一是运行自动化功能测试，以确保你的代码按预期工作。例如，你可能希望使用`pytest`框架来运行一系列用Python编写的单元测试，测试基于Python的“Hats
    for Cats”应用。让我们看看如何在GitLab中做到这一点。
- en: Note
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re not familiar with `pytest`, don’t worry. The syntax for `pytest` unit
    tests is extremely simple and can be understood by anyone with even a little experience
    of writing automated tests in any language.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不熟悉`pytest`，不用担心。`pytest`单元测试的语法非常简单，即使是对编写自动化测试有一点经验的人也能理解。
- en: Enabling automated functional tests
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用自动化功能测试
- en: 'Imagine that you’ve written three `pytest`-based unit tests to make sure the
    Hats for Cats app’s login feature works as expected. You might have a file called
    `test/test_login.py` with these contents:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经编写了三个基于`pytest`的单元测试，以确保“Hats for Cats”应用的登录功能按预期工作。你可能会有一个名为`test/test_login.py`的文件，内容如下：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Obviously, these sample tests have placeholder code that forces the first two
    tests to pass and the third to fail. Real tests would have actual logic that exercises
    the login feature in various ways, but these simplified examples make GitLab’s
    automated test feature easier to demonstrate.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这些示例测试包含了占位符代码，强制前两个测试通过，第三个测试失败。实际的测试会有实际的逻辑，以多种方式验证登录功能，但这些简化的示例使得GitLab的自动化测试功能更容易演示。
- en: 'To run these automated tests in your pipeline, add a job that triggers them
    just like you would from the command line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在你的管道中运行这些自动化测试，添加一个作业来触发它们，就像你在命令行中执行一样：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This job definition specifies that the job belongs to the `test` stage, and
    that it must run within a Docker container that has version 3.10 of Python installed.
    The commands that it runs first install the `pytest` package using the `pip` package
    manager, and then call the newly installed `pytest` command to run all unit tests
    that are in the `test/` directory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个作业定义指定该作业属于`test`阶段，并且必须在安装了Python 3.10版本的Docker容器中运行。它首先运行的命令通过`pip`包管理器安装`pytest`包，然后调用新安装的`pytest`命令，运行`test/`目录中的所有单元测试。
- en: 'After adding this job and running the pipeline, you can inspect the job’s output
    and see that the tests did indeed run. You can even see the pass/fail results
    of each test. But the job’s output is hard to parse and a little cryptic. Wouldn’t
    it be nice if the results of the automated tests showed up in an easy-to-read
    table somewhere in the GitLab GUI? Fortunately, GitLab can do exactly that. You
    just need to tweak the job definition a little so that it stores the output of
    the unit tests in a particular format, and then saves that result file as a GitLab
    artifact. Adding this code to the end of the existing `unit-tests` job definition
    will do the trick:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code tells GitLab to preserve the `unit_test_results.xml` file produced
    by the `pytest` framework. It also designates this file as a report that contains
    test results that are stored in the JUnit format, which is an industry-standard
    format that GitLab knows how to ingest and display. Finally, it tells GitLab to
    hold on to this file regardless of whether any of the tests fail. This last step
    is important because a failing test will cause the whole `unit-tests` job to have
    a **failed** status, which would normally cause the artifact to be discarded.
    But we want to see the results even if—maybe *especially* if—any of the tests
    fail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Viewing automated functional test results
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After adding the additional code we’ve just described and running a new pipeline
    instance, a new tab marked **Tests** will appear on the pipeline details page.
    Lo and behold, clicking that tab shows you an overview of how many automated tests
    passed and how many failed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Overview of automated test results](img/Figure_6.03_B18073.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Overview of automated test results
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'This table shows one row per job that triggers automated tests. Clicking on
    any row breaks down the results further, so you can see exactly which tests passed
    or failed:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Individual automated test results](img/Figure_6.04_B18073.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Individual automated test results
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, the **View details** button next to each test shows you
    more information about that test, including the line of code that generated the
    failed assertion and the history of how often that test has failed in the past.
    This information helps you debug your product code—or your test, if that’s where
    the problem lies.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Details of a single automated test](img/Figure_6.05_B18073.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Details of a single automated test
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Looking at functional test results in a pipeline details page shows you all
    the test results for the code in the branch that the pipeline ran against. Sometimes
    that’s exactly what you want. Other times, you want to know whether the code on
    a branch is experiencing any new test failures (or has fixed any failing tests)
    compared to the code on your project’s default branch. In other words, is the
    feature branch fixing broken code, is it breaking code that used to work, or is
    it doing some of each?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the automated functional test report that appears in a merge request
    shows you exactly this information. Imagine that you’re working on a branch and
    you manage to fix one test that was failing on the default branch, break one test
    that was passing on the default branch, introduce one new test that passes, and
    introduce one new test that fails. The merge request for that branch would present
    a report that looks like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Merge request’s delta view of automated functional test results](img/Figure_6.06_B18073.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Merge request’s delta view of automated functional test results
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: This shows that two tests are failing, including the old test that you broke
    on this branch and one of the new tests that you added to this branch. It also
    shows that one test failed on the default branch but has been fixed on this branch.
    The merge request report does not mention the new test you added that is passing,
    other than to include it in the count of five total tests. This is because you
    are usually more interested in knowing which tests are failing than in knowing
    which are passing. If you do want to see the status of all tests—both passing
    and failing—the **View full report** button will give you that information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Running automated tests is often the very first task that a development team
    configures new pipelines to perform. If you stopped right there, you’d still get
    a huge amount of value out of GitLab CI/CD pipelines. But there are so many more
    ways you can verify your code with a pipeline! Let’s look at fuzz testing next.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Fuzz testing in a CI/CD pipeline
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Fuzz testing** is an alternative, less traditional way of finding bugs in
    your code. Put succinctly, this advanced testing technique sends semi-random data
    to your code’s functions in an effort to trigger bugs. Although it takes a little
    more work to set up than the other scanners, it can pay off by spotting bugs that
    you probably never would have found using other methods.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Reminder about GitLab versions and features
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Fuzz testing, like many other features discussed throughout the book, is only
    available if you’re using GitLab with an Ultimate license. You can find out whether
    your license tier includes a particular feature by looking up that feature in
    the official GitLab documentation. Features are often made available in lower
    tiers after they’ve been restricted to higher tiers for a few years.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways of performing fuzz testing in GitLab: **coverage-guided
    fuzz testing** and **web API fuzz testing**. In this book, we will only discuss
    the former, but the two techniques are similar enough that if you understand one,
    you’ll easily be able to learn about the other using GitLab’s documentation. From
    this point forward, whenever we refer to fuzz testing, we’re talking specifically
    about the coverage-guided variant.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The architecture and workflow of fuzz testing
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four architectural components you need to understand in order to
    use coverage-guided fuzz testing: the **code under test**, the **CI/CD job**,
    the **fuzz engine**, and the **fuzz target**. Let’s look at each component and
    then see how they all fit together in the fuzz testing workflow.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The code under test
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fuzz testing targets a single function in your code. That function can be written
    in any of the languages supported by GitLab’s fuzz tester, and it can be of any
    length. It must take at least one parameter, but there’s no upper limit on the
    number of parameters it expects. The function can call other functions, and if
    a bug is triggered anywhere within that call stack, the fuzz tester will report
    it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this Python function to be your code under test. Imagine that it’s
    in a file called `name_checker.py`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This simple function takes a string as a parameter. It immediately returns `False`
    if the string is empty. Otherwise, it returns `True` if the string is `bob` and
    `False` if it isn’t.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: This is, of course, a terrible algorithm to use for this simple task, but we’ll
    ask you to restrain your urge to mutter insulting things about the author of this
    code and play along for the sake of the demo. Just pretend it was written by a
    terrified intern on his first day on the job.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The intern is not only awful at designing algorithms, but he’s also not a very
    good coder. You’ve probably already spotted the function’s obvious bug: it doesn’t
    validate that the string that’s passed in is at least three characters long. As
    a consequence, if the string is only one character long and that character is
    `b`, the function will throw an unexpected `IndexError` when it tries to read
    the non-existent second character of the string. Similarly, if the only two characters
    in the string are `bo`, it will throw an `IndexError` when it tries to read the
    third character.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: It would be easy for the developer or QA team member responsible for writing
    tests to forget to test these cases. Let’s see whether fuzz testing will save
    the day by finding this bug.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: A CI/CD job
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, you need to define a job in your CI/CD pipeline that’s dedicated to fuzz
    testing the code under test. You can fuzz-test several different functions in
    one pipeline, but you’ll need a separate pipeline job for each function to be
    tested. In this case, your code under test consists of just one function, so you’ll
    define a single CI/CD job.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get to the job definition, we should explain that the fuzz testing
    job *must* extend a job called `.fuzz_base`, which is defined in a template provided
    by GitLab. Before defining the job, you’ll need to include that template by adding
    a new line to the `includes:` section of `.gitlab-ci.yml`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `.fuzz_base` job that we’ll be extending expects to run in a new stage
    called `fuzz`, which would have to run after the `build` stage so it can perform
    fuzz tests on compiled, runnable code. Let’s add that to our list of stages. Assuming
    that we’ve already defined `build` and `test` stages, the `stages:` section of
    `.gitlab-ci.yml` would look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now we’re ready to add a job definition to `.gitlab-ci.yml` that will kick
    off the fuzz test for our code under test:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This job, called `fuzz-test-is-bob`, first specifies that it should run in a
    Docker image that includes the latest version of Python. This is needed because
    the fuzz engine, fuzz target, and code under test are all written in Python.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Next, it inherits job configuration details from a parent job called `.fuzz_base`.
    This parent job is provided by GitLab, and there’s no need for you to know or
    care what configuration details it provides to your job.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Then your job specifies two commands to run. The first installs a Python-based
    fuzz engine from a GitLab-hosted package registry. The second runs a binary called
    `gitlab-cov-fuzz`, pointing it at the correct fuzz engine and fuzz target. This
    binary is what actually starts up the fuzz test. You’ll get a better sense of
    how the fuzz test proceeds from there when we look at the entire fuzz test workflow
    in the next section.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The fuzz engine
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fuzz engine is a GitLab-supplied binary that sends streams of random bytes
    to the fuzz target. These bytes serve as the basis for input data that the fuzz
    target will feed to the code under test—but more on that topic is coming in the
    next section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Truth be told, it’s more accurate to call these bytes *semi-random* instead
    of *random*. This is because the fuzz engine looks at which lines of the code
    under test were exercised by the last round of data and attempts to mutate that
    data in such a way that when the mutated data serves as the *next* set of random
    bytes, it will exercise different lines in the code under test. So, it’s random,
    but it’s also influenced by the previously used sets of random data. This is where
    the term *coverage-guided* comes from: the fuzz tester uses code coverage data
    to influence how it generates the random data to send to the code under test.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The fuzz target
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The fuzz target is a small piece of code that you must write in the same language
    as the code under test. It serves as a translator or intermediary between the
    fuzz engine and the code under test. The fuzz target has two tasks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Transform the random bytes sent to it by the fuzz engine into the data type
    that the code under test expects to receive for its input parameter(s). For example,
    it might need to transform the bytes into an array of integers, a string, or an
    instance of a class.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the function in the code under test, passing it the transformed random
    bytes.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this example, the fuzz target needs to convert the random bytes sent by
    the fuzz engine into a string, and then pass that string to the `is_bob` function
    in `name_validator.py`. You can call the file that the fuzz target lives in anything
    you want, but there’s a fair amount of boilerplate that you must include in order
    to make it callable from by the fuzz engine. Let’s assume that you call your fuzz
    target file `is_bob_fuzz_target.py` and you include this content in the file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let’s look at what’s happening here. The first line makes the code under test
    available so the fuzz target can pass it random data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines declare a function called `fuzz`, which takes random bytes
    as input. This is required boilerplate: you have to include these lines.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the fuzz target takes the random bytes that were sent to it by the fuzz
    engine and tries to transform them into a string, which is the data type that
    the code under test expects as input. For many (in fact, most!) collections of
    random bytes that are passed into the fuzz target, this conversion will fail due
    to at least one of the bytes falling outside the range of values that map to letters,
    numbers, punctuation, and other symbols. The `try` and `except` lines take care
    of this problem: if any of the bytes can’t be converted, the fuzz target simply
    returns without calling the code under test.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: If the bytes *are* successfully converted into a string, the fuzz target exercises
    the code under test by passing the newly generated string to the `is_bob` function.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The final two lines are more boilerplate that you must include in any Python-based
    fuzz target.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the fuzz target must be written in the same language as the code
    under test. Although the concepts used in non-Python fuzz targets are very similar
    to what is demonstrated here, the boilerplate and data transformation code will
    look slightly different in other languages.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: A fuzz testing workflow
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s how the four components work together to perform fuzz testing whenever
    you run your project’s pipeline:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The CI/CD job called `fuzz-test-is-bob` triggers as part of the `fuzz` stage.
    It downloads the `gitlab-cov-fuzz` binary and the Python-based fuzz engine. It
    then runs the `gitlab-cov-fuzz` binary, pointing it at the Python fuzz engine
    and the fuzz target that lives in `is_bob_fuzz_target.py`.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fuzz engine generates a series of random bytes and passes them to the `fuzz`
    function in `is_bob_fuzz_target.py`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fuzz target transforms the random bytes into a string, since that’s the
    data type that the `is_bob` function (i.e., the code under test) expects as input.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The fuzz target passes the string to `is_bob`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `is_bob` handles the random string gracefully—that is, without crashing or
    throwing any unexpected exceptions—the fuzz engine looks at which lines of code
    were exercised by the last series of random bytes and generates a new series of
    random bytes that are designed to exercise different lines in `is_bob`. This cycle
    continues, with the fuzz engine generating new bytes with each pass through the
    cycle.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If, on the other hand, the random string causes `is_bob` to crash or throw an
    unexpected exception, the fuzz engine reports that to the `fuzz-test-is-bob` CI/CD
    job, which reports that the fuzz test has found a bug in the code under test.
    Success! Well, success at triggering a failure, anyway.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Viewing the results of fuzz testing
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the fuzz test finds a bug, it displays this information in three places:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The vulnerability report, which you can navigate to by clicking **Security &
    Compliance** | **Vulnerability Report** in the left navigation pane. This only
    shows any problems that fuzz testing found on your project’s default branch.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Security** tab on the pipeline details page. This shows any problems that
    fuzz testing found on whatever branch that pipeline instance ran against.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a merge request. This shows a *delta* between problems that fuzz testing
    found on the default branch and problems it found on the source branch of the
    merge request. If nothing has changed between the default branch and the source
    branch, the merge request will report that the fuzz test found no problems at
    all, no matter how many problems actually exist on both branches.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although the exact bugs reported will vary according to the type of report
    you’re looking at, the type of details provided by each report will be almost
    identical. For example, here’s a page from the vulnerability report that presents
    details about the bug that fuzz testing found in the `is_bob` code under test:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Fuzz testing bug report](img/Figure_6.07_B18073.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Fuzz testing bug report
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that this report includes a stack trace showing what error was thrown
    (`IndexError`), and which line threw it (the line with the `return` statement).
    The report also tells you which random bytes—also called a “sample”—triggered
    the problem. In this case, the fuzz engine generated a single byte: 62\. It turns
    out that 62 in UTF-8 corresponds to the lowercase letter of `b`. If you look at
    the `is_bob` function in the code under test, you should be able to see exactly
    why an input string consisting of a single letter, `b`, would expose this bug.
    Isn’t it satisfying when a complicated system such as the fuzz tester works exactly
    as expected?'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Extra considerations when fuzz testing
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to the predictable, logical nature of the other ways you can validate
    your code with GitLab, fuzz testing is like your erratic uncle who shows up to
    family gatherings wearing mismatched socks and spewing mysterious comments that
    could be either deeply profound or utter nonsense, depending on the day. Fuzz
    testing’s random nature means that its results can be unpredictable. You might
    run the same fuzz test on the same code under test on 2 different days and find
    a bug within 10 seconds on the first day, but find nothing after 10 minutes on
    the second day. You never quite know what fuzz testing will turn up, if anything
    at all. This isn’t anything to worry about, since a new fuzz testing session will
    happen every time you run your project’s pipeline; even if it doesn’t find anything
    today, it might find an important problem tomorrow.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Keeping in mind that fuzz testing increases its chances of finding problems
    the longer it runs, some teams choose to run it asynchronously rather than as
    a normal pipeline job that blocks later stages in the pipeline. This technique
    is beyond the scope of this book, but GitLab’s documentation explains how to set
    this up if you’d like to experiment with it.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Another way that fuzz testing differs from other tests or scanners is that it
    stops as soon as it finds a single problem, whereas other tools typically continue
    to run until they’ve found and reported on every issue they’re capable of unearthing.
    Again, this is normally not a problem since most projects will run fuzz testing
    tens, hundreds, or thousands of times over the course of their development. But
    it’s good to understand that just because fuzz testing found a bug today, it doesn’t
    mean there are more bugs lurking in your code that it might find on subsequent
    runs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Remember that although you can fuzz-test as many functions in your code under
    test as you’d like, you must create a separate CI/CD job and a separate fuzz target
    for each function. This can add up to significant overhead when you’re getting
    fuzz testing off the ground. Fortunately, once everything’s in place and fuzz
    testing is working as expected, there’s usually no need to change either the jobs
    or the fuzz targets.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Fuzz testing with a corpus
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fuzz testing has a special, optional feature that you can use called a **corpus**.
    This is a list of random bytes that the fuzz tester can use for two purposes.
    First, if a particular series of random bytes caused a bug or crash in the code
    under test, and then your team fixed that bug, it could be useful for future fuzz
    tests to send exactly the same random bytes to the code under test to make sure
    that it hasn’t regressed. In other words, once your team fixes a bug, it’s a nice
    safety measure for the fuzz test to make sure that it stays fixed. If you add
    the troublesome bytes to the corpus, then all future fuzz test runs will use that
    series of bytes as one of the values sent to the code under test.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: The second use of a corpus is to help the fuzz tester find bugs more quickly.
    When it generates truly random bytes as input to the code under test, it can take
    a long time to find bugs—if it ever finds them at all. But if you load up the
    corpus with one or more series of bytes that constitute valid input (i.e., input
    that the code under test can handle gracefully), then the fuzz test can mutate
    that valid data and use the mutated data as its next series of input to the code
    under test. Mutating valid data often results in finding data that triggers bugs
    far more quickly than relying on truly random bytes as input to the code under
    test.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a corpus can be somewhat complicated, especially if you want to make
    use of a clever GitLab feature that automatically updates the corpus every time
    the fuzz test finds a bug. The GitLab documentation will lead you through this
    process if you think a corpus might be useful. We do recommend experimenting with
    this optional feature because it can hugely increase the power of fuzz testing.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll move on from the powerful and somewhat exotic bug-finding tool
    of fuzz testing and look at an important but often-overlooked way of checking
    the quality of your code: **accessibility testing**.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Checking accessibility in a CI/CD pipeline
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not all applications include web interfaces, but whenever you do write a web
    app, we strongly recommend you use your GitLab CI/CD pipeline to make sure your
    interface is accessible for people with a range of disabilities. Fortunately,
    GitLab makes it easy to test your website against the **Web Content Accessibility
    Guidelines** (**WCAG**) laid out by the World Wide Web Consortium.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'These guidelines address a wide assortment of characteristics of websites that
    could cause accessibility problems. Here are just a few of the things that the
    WCAG covers:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Pages that require scrolling both vertically and horizontally
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML heading tags such as `<H1>` that contain no text
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text that doesn’t contrast strongly enough with its background
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images that lack an alternative text description
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Button controls that have no name available for screen readers
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You might be surprised both at how many accessibility problems this scanner
    finds in your web interface, and also at how easy it is to fix many of these issues.
    Don’t feel bad if it finds several accessibility bugs on your site; try pointing
    the scanner at any popular website and you’ll probably be amazed at the number
    of basic accessibility violations it exhibits!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Enabling accessibility testing
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add accessibility testing to your pipeline, you first need to create a new
    stage called `accessibility` in your `.``gitlab-ci.yml` file:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In all likelihood, your project will already have a `stages` section defined,
    in which case you should just add the new `accessibility` stage to the existing
    section instead of defining a whole new `stages` section (which would produce
    a malformed `.``gitlab-ci.yml` file).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, include the GitLab-provided template that contains the accessibility-related
    job definitions:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we said before, if you’ve already defined an `include` section, simply add
    this template to it instead of defining a new `include` section.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, set a global variable that tells the accessibility scanner which website
    to inspect. This could be your web app in its production environment or in any
    pre-production, staging, or review environment. It can also be fun (and instructive)
    to point the accessibility scanner at any site on the web, even if it’s not one
    you own. Here, we’ll point it at a pretend URL where the Hats for Cats website
    runs in production:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once again, if you already have a global `variables` section, simply add this
    new variable to it instead of creating a second `variables` section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Believe it or not, that’s all you need to do. To get accessibility testing up
    and running in your pipeline. The accessibility scanner doesn’t offer any other
    configuration options, which makes it extremely simple to set up.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Viewing accessibility testing results
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The accessibility scanner doesn’t integrate its results into a GitLab dashboard
    like you saw with the automated functional test results. But it does generate
    an easy-to-read HTML page that describes all of the less severe problems (called
    **warnings**) and more severe problems (called **errors**) it finds.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this page, run a pipeline with accessibility testing enabled and visit
    the pipeline details page. You’ll see a job called `a11y`, which is the job that
    runs the accessibility scanner. Click on that job to see the terminal output from
    the job. You can ignore that output, but in the **Job artifacts** pane on the
    right, you’ll see a button for browsing any artifacts produced by the job:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Finding the accessibility scanner’s artifacts](img/Figure_6.08_B18073.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Finding the accessibility scanner’s artifacts
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Clicking this button will show you both JSON and HTML reports generated by the
    accessibility scanner. These reports both contain the same information about any
    accessibility violations found on the targeted website. The JSON output can be
    downloaded, parsed, and integrated into any other dashboard you may have set up.
    The HTML report is human-readable within your browser and lets everyone on your
    team see what accessibility-related work you might want to carve out into issues
    so it can be tracked and managed.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: There’s another way to see the findings of the accessibility scanner, other
    than by looking at one of its two artifacts. Remember how a merge request’s versions
    of Code Quality reports and automated functional test reports show the difference
    between code quality or test results on the default branch and code quality or
    test results on the merge request’s source branch? The merge request report on
    accessibility violations works in exactly the same way.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: If you have a branch with a corresponding merge request, the merge request will
    show any accessibility violations that were found on the latest pipeline that
    was run against that branch, as long as those violations are *not* also found
    on a pipeline run against the default branch at the time the branch was created.
    In other words, the merge request shows you whether the pipeline’s branch is making
    your project’s code better (by fixing accessibility problems that were on the
    default branch) or worse (by adding new accessibility problems that were not on
    the default branch). This is a great report to have if you’re working on a feature
    branch and want to make sure your boss doesn’t yell at you because you’re adding
    more problems than you’re fixing!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Additional ways to verify your code
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve covered some of the most common ways to verify your code. GitLab offers
    even more features that help you test your code further. We don’t have enough
    space to cover all of them in detail, but here’s a quick description of three
    additional methods you can use to test code. Details for enabling and configuring
    all of these tools are available in the official GitLab documentation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automated functional tests make sure that your code is doing what it’s supposed
    to do. Having tests in place is a critical part of every software development
    project, but it’s easy to get a false sense of confidence from seeing that all
    your tests are passing if you don’t know how much of your code base those tests
    cover. After all, having 100 passing tests doesn’t do you much good if all of
    those tests execute the same 5% of your application’s code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage reports give you confidence in the value of your test results.
    You can configure GitLab to use an appropriate, language-specific code coverage
    tool to determine exactly which lines of your product code are exercised by your
    tests. This report is integrated into the GitLab GUI, so it’s easy to tell which
    lines of code you should target as you write new tests.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Browser performance testing
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since so many of today’s applications are run in a browser, and since browser-based
    applications are generally much slower than traditional desktop applications,
    it’s important to keep track of how quickly the various pages of your website
    load, and to know whether changes you’re making to the code are making those load
    times better or worse.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: GitLab can measure page load times and display the results in merge requests
    so developers can understand how their proposed code changes affect the performance
    of their web app. It can even raise a special alert whenever performance degrades
    beyond a particular user-configurable threshold. The report lets developers fix
    any performance-related problems that their code has introduced before their code
    is merged into the stable code base.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Load performance testing
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While browser performance testing tells you how quickly the frontend GUI of
    your web app loads, GitLab’s **load performance testing** helps you track the
    performance of your applications’ backend code. Although this feature can exercise
    your application in various ways, it’s most commonly used to target your application’s
    API. For example, it can hammer your application with tens, hundreds, or thousands
    of simultaneous calls to one or more of your application’s REST API endpoints,
    and then monitor how quickly your application responds to those calls. You can
    also use this tool to perform long-running soak tests to see whether your application
    develops memory leaks or other problems over time.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The load performance test feature displays its findings in merge requests so
    developers can understand how any code changes on the branch associated with that
    merge request affect their applications’ backend performance.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, you covered a lot of ground in this chapter. You saw how to build
    code within a GitLab CI/CD pipeline, using a variety of different methods and
    languages. This doesn’t cover every possible way you could compile or otherwise
    build your code—we’ve barely scratched the surface of that topic—but you should
    have a good idea of the general steps involved regardless of what language or
    tools you use. You also learned that certain kinds of code verification tools
    require that you build your code first because they interact with your code as
    it runs. Other tests don’t require this step because they simply scan your source
    code without running it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Next, you saw how to use GitLab’s Code Quality feature within your pipelines
    to make sure your code follows best practices for coding style, adheres to common
    coding conventions, avoids unnecessary complexity, and doesn’t exhibit any *code
    smells* that indicate the possible presence of bugs or unexpected behavior.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Then you learned how to integrate automated functional tests into GitLab CI/CD
    pipelines. You saw not only how to trigger these tests from within a pipeline
    job but also how to ensure that the results can be seen in two different reports
    within the GitLab GUI. You also discovered how to use the *delta* view of test
    results within a merge request to learn whether the code on that merge request’s
    branch is helping or hurting the pass rate of your product’s automated tests.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Next up was fuzz testing, GitLab’s most complicated but perhaps most interesting
    bug-finding feature. You learned about the four different components that make
    up the fuzz testing architecture, and you saw how random data flows from one component
    to the next in an attempt to trip up your code and cause crashes or unexpected
    exceptions. You became familiar with fuzz testing’s various idiosyncrasies and
    learned how to accommodate them. Finally, you saw how to use a corpus not only
    to catch functional regressions in your code but also to speed up fuzz testing
    and make it more likely to find problems.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The final tool you got to watch in action was GitLab’s accessibility testing
    feature. This helps you ensure that your web applications are usable by people
    with a range of disabilities, maximizing your possible user base.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: These tools are a great place to start when it comes to validating your software
    projects, but GitLab offers several additional ways to inspect your code even
    more thoroughly. You got a lightning-fast tour of the code coverage tool, browser
    performance testing, and load performance testing. All of this will reward further
    exploration using GitLab’s official documentation and some experimentation of
    your own.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Once your code has been verified, you can deploy it to a production environment
    for customers to use, right? Nope. You first need to make sure it doesn’t contain
    any security vulnerabilities, which is the topic we’ll explore in the next chapter.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
