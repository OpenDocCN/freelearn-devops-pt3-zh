<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer087">
<h1 class="chapter-number" id="_idParaDest-129"><a id="_idTextAnchor330"/>6</h1>
<h1 id="_idParaDest-130"><a id="_idTextAnchor331"/>Implementing Continuous Deployment and Release Management</h1>
<p>In the previous chapter, you learned how to use Azure DevOps pipelines for continuous integration. Due to this, you now know how to pick up a version of your sources and create artifacts that you can deploy. In this chapter, you will learn how to extend this with continuous delivery and continuous deployment practices so that you automatically deploy these artifacts to the servers or platforms that your code is running on.</p>
<p>To do this, we will start by introducing Azure DevOps release definitions so that you can define and run the releases of your application. Next, a series of strategies will be introduced that you can use to perform deployments in a low-risk manner. Doing this makes it possible for you to automate the process of deploying new versions unattended, with a limited risk of incidents occurring. From here, we will shift our attention to automating the creation of release notes. After this, we will introduce Visual Studio App Center, which is used for building, testing, and releasing mobile and desktop applications. Finally, other tools for continuous deployment will be introduced.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Continuous delivery and continuous deployment </li>
<li>Working with Azure DevOps releases</li>
<li>Writing multi-stage <strong class="bold">Yet Another Markup Language</strong> (<strong class="bold">YAML</strong>) pipelines </li>
<li>Implementing continuous deployment strategies </li>
<li>Deploying mobile applications</li>
<li>Automating release notes</li>
<li>Other tools</li>
</ul>
<h1 id="_idParaDest-131"><a id="_idTextAnchor332"/><a id="_idTextAnchor333"/>Technical requirements</h1>
<p>To experiment with the techniques described in this chapter, you might need one or more of the following:</p>
<ul>
<li>An Azure DevOps account for building release definitions and multi-stage YAML pipelines</li>
<li>An App Center account for deploying mobile applications</li>
</ul>
<p><a id="_idTextAnchor334"/>Free trial options are available for both of these.</p>
<h1 id="_idParaDest-132"><a id="_idTextAnchor335"/>Continuous delivery and continuous deployment</h1>
<p>The difference between continuous delivery and continuous deployment is a common source of confusion. Some people think these terms are interchangeable and see them as two synonyms for the same concept, but they have, in fact, two different meanings.</p>
<p>Continuous delivery<a id="_idIndexMarker491"/> is a practice where teams ensure that the artifacts they build are continuously validated and ready to be deployed to a production environment. Often, this is done by deploying the artifacts to a production-like environment, such as acceptance or even a staging environment, and applying a series of tests, such as verification tests, to ensure that an application is working correctly.</p>
<p>Continuous deployment<a id="_idIndexMarker492"/> is a practice where every version that is deployed to a production-like environment and passes all tests and verifications is also deployed to production automatically.</p>
<p>It is a recommended practice to plan for continuous delivery irrespective of whether your team decides to deploy more frequently or not. Deployment and upgrades are dependent on multiple factors, which may change over time. Hence, continuous delivery will be a prerequisite for faster release cycles.</p>
<p>When working with Azure DevOps, Azure Pipelines is the tool of choice for implementing continuous delivery and deployment. This can be done using either the visual classic editor or with multi-stage YAML pipelines, both of which will be discussed in the following section<a id="_idTextAnchor336"/><a id="_idTextAnchor337"/><a id="_idTextAnchor338"/>.</p>
<h1 id="_idParaDest-133"><a id="_idTextAnchor339"/>Working with Azure DevOps releases</h1>
<p>Continuous delivery<a id="_idIndexMarker493"/> and deployment can both be implemented in Azure DevOps by using releases. When creating a new release definition, an outline of the release process is created. This process will often start with an artifact that triggers the creation of a new release. Next, it is possible to define one or more stages that the release can be deployed to. Often, these stages correspond to the different application environments – for example, test and production – but this is not mandatory.</p>
<p>Let’s learn how to create a new release definition and explore the various options we have. First, navigate to <strong class="bold">Pipelines</strong> and choose <strong class="bold">Releases</strong> from the menu. From here, it is possible to start creating a new release pipeline, which will take us to a screen that looks similar to the one shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 6.1 – New release pipeline " height="932" src="image/B18655_06_01.jpg" width="1350"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – New release pipelin<a id="_idTextAnchor340"/>e</p>
<p>On the preceding screen, we can perform the following actions (which are numbered in the preceding screenshot):</p>
<ol>
<li>First, note that, on the left, it is possible to see the outline of the release pipeline with a box. Here, you can select one or more artifacts that can be used in the release pipeline.</li>
<li>To the right of this, there is a box where the different stages of the release can be seen. By default, one stage is created already.</li>
<li>It is possible to pick a template as a starting point for the deployment pipeline for this pre-created stage. Choosing to start with an empty job in this view allows you to craft a custom deployment pipeline from scratch.</li>
</ol>
<p>After choosing a job <a id="_idIndexMarker494"/>template or an empty job to start with, the pane on the right will close, and it will be possible to start editing the release pipeline from left to right, starting with the artifacts.</p>
<p>Once a skeleton release pipeline is visible, the first things you will need to configure are t<a id="_idTextAnchor341"/>he artifacts that the release should work with. This is the subject of the next sectio<a id="_idTextAnchor342"/>n.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor343"/>Creating artifacts and release triggers</h2>
<p>The previous chapter described build definitions and YAML pipelines, which create artifacts. These artifacts<a id="_idIndexMarker495"/> are picked up in releases and form the basis for deploying<a id="_idIndexMarker496"/> an application.</p>
<p>To start editing a<a id="_idIndexMarker497"/> release pipeline, follow these steps:</p>
<ol>
<li value="1">Click on the <strong class="bold">Add an artifact</strong> button to start building the starting point of the release definition. This will open the right-hand pane shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer063">
<img alt="Figure 6.2 – Add an artifact " height="666" src="image/B18655_06_02.jpg" width="1300"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Add an arti<a id="_idTextAnchor344"/>fact</p>
<ol>
<li value="2">In the picker for the project, the current project will be selected by default.</li>
<li>Now, specify the artifacts that the release pipeline should pick up.</li>
<li>After this, the default version to use and the source alias will be automatically selected. The default version can always be overridden when manually starting a release, so <strong class="bold">Latest</strong> is a sensible default.</li>
<li>The source alias is the name of the folder where the artifacts can be located when we add jobs to the release stages at a later date. The default is often fine.</li>
<li>Finish<a id="_idIndexMarker498"/> adding the artifact by clicking<a id="_idTextAnchor345"/> <strong class="bold">Add</strong>.</li>
</ol>
<p>Now that we’ve<a id="_idIndexMarker499"/> specified<a id="_idIndexMarker500"/> the artifacts to work with, it is time to specify when a new release should be created. Let’s learn how to do this:</p>
<ol>
<li value="1">To configure the availability of a new artifact to trigger the release, click on the lightning bolt next to the artifact to open the configuration pane. This can be seen in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer064">
<img alt="Figure 6.3 – Specifying a deployment trigger  " height="640" src="image/B18655_06_03.jpg" width="1492"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Specifying a deployment trigger </p>
<ol>
<li value="2">In this pane, it is possible to create a new release, when one is available, using the top slider. This will expand a new section where you can define one or more filters so that you can specify conditions under which a new artifact should trigger a release.</li>
<li>Click the <strong class="bold">Add</strong> button to start adding a condition.</li>
<li>A common example is to only include artifacts that come from the master branch, as shown in <em class="italic">Figure 6.3</em>.</li>
<li>In addition to artifacts that come from regular builds, it is possible to also allow artifacts that come from pull request builds to start a new release.</li>
<li>Finally, it is <a id="_idIndexMarker501"/>possible to create a new release on a fixed schedule.</li>
</ol>
<p>If no schedule and no trigger are specified, a new release will only be created when someone does so ma<a id="_idTextAnchor346"/><a id="_idTextAnchor347"/><a id="_idTextAnchor348"/>nually.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor349"/>Specifying the stages to deploy the release</h2>
<p>After <a id="_idIndexMarker502"/>specifying the artifacts to release, it is time to <a id="_idIndexMarker503"/>specify one or more stages to deploy the release to. Often, every environment (test, acceptance, and production) will correspond to a stage, but it is also possible to have other stages if the situation calls for it.</p>
<p>Let’s learn how to add a new stage and explore various options. First, click on <strong class="bold">Pipelines</strong> to arrive at the following screen:</p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<img alt="Figure 6.4 – Configuring a stage within a new pipeline " height="453" src="image/B18655_06_04.jpg" width="1190"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Configuring a stage within a new pipeline</p>
<p>Now, complete the following steps:</p>
<ol>
<li value="1">Click the <strong class="bold">Add</strong> button to create a new stage. A stage can be either new or a clone of an existing one.</li>
<li>After selecting an already existing stage, it can be removed using the <strong class="bold">Delete</strong> button on the top right.</li>
<li>Other actions that can be performed on this screen include renaming the stage and designating a stage owner. The owner will be notified when a release is deployed to the environment.</li>
<li>After creating and naming a stage, it is possible to add jobs and tasks to a stage, just like it was possible for<a id="_idIndexMarker504"/> a build pipeline. To do this, click on the link in the box that denotes<a id="_idIndexMarker505"/> the stage.</li>
</ol>
<p>From here on, this works exactly the same as building pipelines. There is only one addition: besides agent jobs and agentless jobs, it is also possible to use deployment group jobs.</p>
<p>These will be discussed in the <em class="italic">Working with deployment groups</em> section later on. But first, let’s understand which stag<a id="_idTextAnchor350"/><a id="_idTextAnchor351"/><a id="_idTextAnchor352"/>es we need.</p>
<h3>Which stages do I need?</h3>
<p>One of the questions that frequently arise when working with releases is, <em class="italic">which stages do I need in my release pipeline?</em> According to the documentation, stages should denote the major divisions of a<a id="_idIndexMarker506"/> release pipeline. When starting out with releases, this often boils down to having one stage per environment in a release pipeline. Appropriate stages include <strong class="bold">test</strong>, <strong class="bold">acceptance</strong>, and <strong class="bold">production</strong>.</p>
<p>When working with releases for a long time, we might incorporate more automation in the pipelines and want to add extra checking stages to them. An example might be a stage <a id="_idIndexMarker507"/>called <strong class="bold">load test</strong>, which is executed in parallel <a id="_idIndexMarker508"/>to the <strong class="bold">test</strong> stage. Another<a id="_idIndexMarker509"/> example might be the introduction of a stage for <strong class="bold">automated UI tests</strong>.</p>
<p>No matter which stages are added, the approach to propagating a release to production should always stay the same. When a release propagates from stage to stage and gets closer to production, this should show that there is confidence in this release, that<a id="_idTextAnchor353"/> it is working correctly, and that it can be promoted <a id="_idTextAnchor354"/>to production.</p>
<h3>Stage triggers, approvals, and gates</h3>
<p>After defining the required stages and adding jobs and tasks to them, it is time to configure when the release to a specific stage should be triggered. The steps for this can be seen in the following <a id="_idIndexMarker510"/>screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<img alt="Figure 6.5 – Post-deployment configuration " height="533" src="image/B18655_06_05.jpg" width="1085"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Post-deployment<a id="_idTextAnchor355"/> configuration</p>
<p>Note that the following steps need to be carried out for every stage individually:</p>
<ol>
<li value="1">To <a id="_idIndexMarker511"/>trigger a release to a specific stage, click on the button with a lightning bolt and a person icon, to the left of the square that denotes the stage.</li>
<li>The first thing to configure here is when a release should propagate to this stage. This can be either upon the availability of the release, after completing another stage, or only upon manual request. The choice you make here will also be reflected in the visual representation of the pipeline.</li>
<li>Separate from the trigger, it is possible to define one or more filters that limit which artifacts will trigger a deployment to the stage. There can be one or more include or exclude branch filters for every artifact.</li>
<li>It is also possible to redeploy on a fixed schedule.</li>
<li>Finally, if the creation of a new release is specified for builds that were started from a pull request, the release can also be allowed to propagate to the current stage using the <strong class="bold">Pull request deployment</strong> slider.</li>
</ol>
<p>Next to these triggers, approvers<a id="_idIndexMarker512"/> and gates<a id="_idIndexMarker513"/> can be added so that you can configure how to handle deployment queue settings. These settings can be accessed from the tabs below <a id="_idIndexMarker514"/>the section for <strong class="bold">Triggers</strong>, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<img alt="Figure 6.6 – Pre-deployment conditions  " height="538" src="image/B18655_06_06.jpg" width="1206"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Pre-deplo<a id="_idTextAnchor356"/>yment conditions </p>
<p>Once the trigger condition has been configured, the next section is about approvers. Here, groups or users are specified. They must give their approval before release to this stage can begin. Multiple people can be added, and if so, an order can be defined that they have to approve, or it can be<a id="_idIndexMarker515"/> specified that a single approval is enough. By scrolling down, you will find the following options:</p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<img alt="Figure 6.7 – Deployment gates " height="532" src="image/B18655_06_07.jpg" width="860"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Deployment gates</p>
<p>The second<a id="_idIndexMarker516"/> tab (on the left) allows you to add one or more gates. Gates are automated checks that have to succeed before the release can continue. Currently, this shows the configuration details for configuring a work item query and a threshold on the number of results – for example, to ensure that there are no open bugs before a release proceeds. There are also gates available that can call in Azure Monitor, Azure Functions, or a RESTful API. This set of gates can be extended using the Azure DevOps extension mechanisms. Some of these extensions also integrate with common change management systems.</p>
<p>The final section (on the right) allows you to configure how to handle a situation where different versions of the release are ready for deployment to the same stage. Here, it is possible to specify how many releases can run in parallel. If there are even more releases coming in, you can queue them up and deploy them one after the other, or only <a id="_idTextAnchor357"/><a id="_idTextAnchor358"/><a id="_idTextAnchor359"/>deploy the latest.</p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor360"/>Working with deployment groups</h2>
<p>Another topic that you<a id="_idIndexMarker517"/> might run into at some point is deploying an application to on-premises servers or servers that are behind a firewall. You may also come across situations where it is necessary to run scripts on all of the machines hosting the application or situations where the target environment does not supply a mechanism for deploying applications.</p>
<p>The approach to performing releases, which was shown in the <em class="italic">Working with Azure DevOps releases</em> section of this chapter, relies on being able to connect to the target machines or services that will host the application. We call these <strong class="bold">push-based deployments</strong>, and this is <a id="_idIndexMarker518"/>not always possible.</p>
<p>When deploying to target machines that cannot be connected to, another approach needs to be taken. This approach is <a id="_idIndexMarker519"/>called <strong class="bold">agent-based deployment</strong>. In an agent-based deployment, an Azure DevOps agent is installed on every machine that the application will be installed on. Next, these agents must be grouped into deployment groups. Once this is done, a <strong class="bold">deployment group job</strong> can be <a id="_idIndexMarker520"/>added to the release.</p>
<p>This is very similar to an agent’s job, except for one thing. In an agent job, the tasks in the job will run on <strong class="bold">one of the agents</strong> against the target machine. In a deployment group job, all of the tasks will run on all of the agents in the release group on the target machines. This difference between both approaches can be seen in the following diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<img alt="Figure 6.8 – Jobs are run on an agent " height="558" src="image/B18655_06_08.jpg" width="1299"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Jobs are run on an agent</p>
<p>When using this approach, it is necessary to have agents on the machines that the application needs to be deployed to. These agents listen to Azure DevOps, and whenever a new release is<a id="_idIndexMarker521"/> requested, they retrieve the work and execute it<a id="_idTextAnchor361"/><a id="_idTextAnchor362"/><a id="_idTextAnchor363"/> on the local machine.</p>
<h3>Managing deployment groups</h3>
<p>Before you can add<a id="_idIndexMarker522"/> a deployment group job to a release pipeline, you need to create a deployment group. To do so, perform the following steps:</p>
<ol>
<li value="1">Navigate to the <strong class="bold">Pipelines</strong> menu.</li>
<li>Open the <strong class="bold">Deployment groups</strong> menu.</li>
<li>Click on <strong class="bold">New</strong> to add a new deployment group.</li>
<li>Enter a deployment group name and description and click <strong class="bold">Create</strong>.</li>
</ol>
<p>Once the new deployment group has been created, a script will appear on the right, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<img alt="Figure 6.9 – Creating a new deployment group " height="516" src="image/B18655_06_09.jpg" width="1419"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Creating a new deployment group</p>
<p>Executing this script on the target machine will install the agent and automatically register that machine as part of the newly created deployment group.</p>
<p>If an application must be deployed to three stages (test, acceptance, and production) using deployment<a id="_idIndexMarker523"/> groups, there will need to be three separate deployment groups, on<a id="_idTextAnchor364"/><a id="_idTextAnchor365"/><a id="_idTextAnchor366"/>e for each environment.</p>
<h3>Creating a release pipeline with a deployment group</h3>
<p>After creating <a id="_idIndexMarker524"/>the necessary deployment group(s), those <a id="_idIndexMarker525"/>can be used in releases from the <strong class="bold">Tasks</strong> view, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<img alt="Figure 6.10 – Specifying the deployment group in the pipeline " height="846" src="image/B18655_06_10.jpg" width="1069"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Specifying the deployment group in the pipeline</p>
<p>To do this, perform the following steps:</p>
<ol>
<li value="1">Add a new deployment group to the pipeline.</li>
<li>Specify which deployment group the job should run on by picking it from the drop-down menu.</li>
<li>Add one or more tasks to<a id="_idIndexMarker526"/> execute the job. The functionality of the user interface is the same <a id="_idIndexMarker527"/>as that for regular agent jobs.</li>
</ol>
<p>Besides the different approaches to executing on all agents in a group instead of one, deployment group jobs behave the s<a id="_idTextAnchor367"/><a id="_idTextAnchor368"/><a id="_idTextAnchor369"/>ame as regular agent jobs.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor370"/>Writing multi-stage YAML pipelines</h1>
<p>In addition to <a id="_idIndexMarker528"/>the visual designer for release definitions, it is also possible to implement continuous deployment using YAML pipelines. When doing so, it is still recommended to differentiate between the build (<strong class="bold">Continuous Integration </strong>(<strong class="bold">CI</strong>)) and release (<strong class="bold">Continuous Deployment</strong> (<strong class="bold">CD</strong>)) phases of a pipeline. The concept of stages is used to make this possible. A YAML pipeline can be divided into one or more stages. A stage can represent an environment such as test, acceptance, or production, but this isn’t always true. If, in an application scenario, it makes sense to add extra stages such as pre-production or staging, you can include additional stages as applicable. It is good practice to publish <strong class="bold">pipeline artifacts</strong> in earlier stages and to consume or <strong class="bold">download artifacts</strong> in later stages.</p>
<p>Multi-stage YAML pipelines are the new default for creating pipelines in Azure DevOps. Since working with YAML pipelines can have a steeper learning curve than working with classic releases, you may find it easier to work with classic releases first and switch to YAML pipelines later. Just like with builds, many of the concepts of cl<a id="_idTextAnchor371"/>assic releases translate to multi-st<a id="_idTextAnchor372"/>age YAML pipelines as well.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor373"/>Adding stages to YAML pipelines</h2>
<p>If no stages are defined in a <a id="_idIndexMarker529"/>YAML pipeline, there is always one<a id="_idIndexMarker530"/> implicit stage that holds all the jobs. To convert a pipeline into a multi-stage pipeline, you need to add the <strong class="source-inline">stages</strong> keyword and a list of stages, as shown in the following code:</p>
<pre class="source-code">
stages:
 - stage: stage1
   displayName: My first stage 
   jobs:
   - job: job1 
     steps:
     - task: DotNetCoreCLI@2 
       displayName: ‘dotnet build’ 
       inputs:
       projects: ‘**/*.csproj’
 <a id="_idTextAnchor374"/>- stage: stage2 
   jobs:
...</pre>
<p>The preceding syntax shows that a list of stages is defined at the top of the YAML file. Each stage starts by defining a name. This name can be used later so that you can refer to this stage.</p>
<p>While <a id="_idIndexMarker531"/>jobs (unless otherwise specified) run in parallel by default, stages <a id="_idIndexMarker532"/>always run sequentially by default. But just like jobs, stages acc<a id="_idTextAnchor375"/>ept the <strong class="source-inline">dependsOn</strong> and <strong class="source-inline">condition</strong> keywords to change the ordering and parallelism, an<a id="_idTextAnchor376"/>d (potentially) to skip stages.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor377"/>Downloading artifacts</h2>
<p>A common use <a id="_idIndexMarker533"/>of multi-stage pipelines is to separate the build stage and the deployment stage. To make this possible, the build stage often publishes one or more pipeline artifacts. This was discussed in <a href="B18655_05.xhtml#_idTextAnchor177"><em class="italic">Chapter 5</em></a>, <em class="italic">Moving to Continuous Integration</em>.</p>
<p>All the artifacts that were published in a previous stage of the current pipeline can be downloaded using a <strong class="source-inline">download</strong> task:</p>
<pre class="source-code">
steps:
 - download: current 
   artifact: artifactName</pre>
<p>It is also possible to download artifacts from another pipeline. To do this, the <strong class="source-inline">current</strong> constant has to be replaced with the name of that pipeline. Pipeline artifacts are downloaded to the <strong class="source-inline">$(Pipeline.Workspace)</strong> directory.</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you want more fine-grained control over downloading pipeline artifacts – for example, over the version of the artifact to use or the location to download the artifact to – you can also use the <strong class="bold">Download Pipeline Artifacts</strong> tasks, which are documented at <a href="https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/tasks/utility/download-pipeline-artifact?view=azure-devops">https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/tasks/utility/download-pipeline-artifact?view=azure-devops</a>.</p>
<p>Publishing and <a id="_idIndexMarker534"/>downloading artifacts within a pipeline ensures that code that is built in the first stage is also the code that is deployed in the second stage – even if the stages run days apart. In essence, each pipeline run builds a local stage of all the artifacts a<a id="_idTextAnchor378"/><a id="_idTextAnchor379"/><a id="_idTextAnchor380"/>ssociated with that specific run.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor381"/>Approvals</h2>
<p>In a multi-stage YAML pipeline, it is<a id="_idIndexMarker535"/> not possible to define approvers as compared to what was possible when creating a classic release pipeline. The reason for this is that the pipeline – <em class="italic">the build and deployment process</em> – is viewed as code. Code is worked on by developers and operators only. Approvals are worked on by, for example, product owners. However, this does not mean that it is impossible to implement approval flows for the progression of a pipeline to the next stage.</p>
<p>To control whether a pipeline is allowed to proceed to a certain stage, the concept of environments needs to be introduced. An environment is defined when we give it a name and a description. One or more approvers can be attached to these environments. Once this is done, jobs can be configured to target such an environment. If there is at least one job in a stage that targets an environment, then that environment is said to be used by the stage. If an approval has been configured on that environment, the deployment to that stage will not continue until the approver has given permission.</p>
<p>To start <a id="_idIndexMarker536"/>working with environments, you’ll need to access the list of environments. This list can be found in the <strong class="bold">Pipelines</strong> menu, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<img alt="Figure 6.11 – Adding a new environment " height="693" src="image/B18655_06_11.jpg" width="913"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figu<a id="_idTextAnchor382"/>re 6.11 – Adding a new environment</p>
<p>To add a new environment, perform the following steps:</p>
<ol>
<li value="1">Open the <strong class="bold">Pipelines</strong> menu and choose <strong class="bold">Environments</strong>.</li>
<li>Select <strong class="bold">New environment</strong> from the top right.</li>
<li>Specify a name and description.</li>
<li>Click <strong class="bold">Create</strong>.</li>
</ol>
<p>It is possible to <a id="_idIndexMarker537"/>associate resources with an environment. Resources that are coupled with an environment can be used in a pipeline if, and only if, that pipeline is also targeting that environment. To protect the resources of an environment, the owner of that environment can add one or more approvers. An example of a configured approver can be seen in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<img alt="Figure 6.12 – Configuring approvers for the environment " height="692" src="image/B18655_06_12.jpg" width="950"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Configuring approvers for the environment</p>
<p>Approvers can be added to an environment as follows:</p>
<ol>
<li value="1">Navigate to the <strong class="bold">Environments</strong> overview pane.</li>
<li>Open<a id="_idTextAnchor383"/> an environment by clicking on it.</li>
<li>Click the top-right menu marked with the three dots and choose <strong class="bold">Approvals and Checks</strong>.</li>
<li>Click the <strong class="bold">Create</strong> button.</li>
<li>Pick a user or group from the list and add extra instructions if needed.</li>
<li>Click the <strong class="bold">Create</strong> button again.</li>
</ol>
<p>Approvals<a id="_idIndexMarker538"/> make it possible for you to control the progression of a pipeline to the next stage if that pipeline targets the correct environment. Targeting an environment is done by specifying a specific type of job – the deployment job. The following YAML shows how to do this:</p>
<pre class="source-code">
jobs:
 - deployment: deploymentJobName 
   displayName: Friendly name 
   strategy:
   runOnce: 
     deploy:
       steps:
       …</pre>
<p>Deployment jobs do not directly contain the steps to execute as an agent job does. Instead, they first must specify an execution strategy for the tasks outlined under the <strong class="source-inline">steps</strong> keyword. At the time of writing, the only strategy supported is <strong class="source-inline">runOnce</strong>. Other strategies are expected to be announced in the future.</p>
<p>At the time of writing, only Kubernetes clusters are supported as environment resources, but more types of resources have been announced for the future.</p>
<p>Now that we know about the technical means for creating release definitions and writing multi-stage YAML pipelines, it is time to look at the different strategies we can use to apply this in practice. These CD <a id="_idTextAnchor384"/>strategies are designed to minimize the risk of deploying new versio<a id="_idTextAnchor385"/>ns of an application automatically.</p>
<h1 id="_idParaDest-141"><a id="_idTextAnchor386"/>Implementing CD strategies</h1>
<p>Before we<a id="_idIndexMarker539"/> deploy an application continuously, it is important to think about the strategy we should use. Just doing deployment after deployment may have more risks associated with it than a business is willing to accept. It is important to think <a id="_idIndexMarker540"/>about how to deal with issues that might occur during or after deployin<a id="_idTextAnchor387"/>g a new version of your application.</p>
<p>There are a few deployment strategies that can be applied to reduce the risks that might come with deployments, all of which will be covered in this section. Please note that it is possible to combine one or more of the following patterns. For example, it is perfectly possible to use a blue-green strategy for every ring <a id="_idTextAnchor388"/>in a ring-based deployment. Also, all deployment strategies <a id="_idIndexMarker541"/>can be c<a id="_idTextAnchor389"/>ombined with the use of feature flags.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor390"/>Blue-green deployments</h2>
<p>Blue-green deployments<a id="_idIndexMarker542"/> is a technique where a new version of an application never gets deployed to the production servers directly. Instead, it gets deployed to another set of servers first. Once this has been done successfully, users are directed to the new deployment.</p>
<p>Let’s assume that an application runs on a total of three hosts by default. A typical setup for blue-green deployment would be two sets of three hosts – the blue group and the green group. In front of these two sets, there is a reverse proxy that functions as a load balancer and redirects the incoming requests to the blue group. The following diagram shows how this works:</p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<img alt="Figure 6.13 – Blue-green deployments " height="433" src="image/B18655_06_13.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Blue-green deployments</p>
<p>To deploy a new version of the application in this situation, it needs to be deployed to the green group of servers. Since these servers are not receiving any traffic from end users, this way of upgrading the servers has no impact on them at all.</p>
<p>After the deployment, the new deployment can be verified to ensure that it was successful and that the application is running correctly. After this verification, the load balancer is reconfigured to redirect traffic to the green group. Now, the new<a id="_idTextAnchor391"/> version of the application is served.</p>
<p>Should there suddenly be any unexpected issues, it is very easy to switch back to the previous deployment by reconfiguring the load balancer back to the blue group. If the deployment is successful and there are no issues, it is possible to start the deployment of the next version by going through the same procedur<a id="_idTextAnchor392"/>e, but now with the roles of t<a id="_idTextAnchor393"/>he green and the blue groups switched.</p>
<h3>Immutable servers</h3>
<p>A variation of the <a id="_idIndexMarker543"/>blue-green deployment pattern is immutable servers. With immutable servers, there is no going back and forth between two groups of servers. Instead, the group of servers that is serving the old version of the application is completely disregarded or removed. Often, this is done after a grace period.</p>
<p>The result of this is that there will still be means to roll back to a previous version – almost instantaneously if the old servers are kept around for a while. The other benefit is that there is now a guarantee that no remains from a previous deployment are being carried over into the newer deployments. Using immutable servers, the change of active servers over time might look as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<img alt="Figure 6.14 – Immutable server deployments " height="206" src="image/B18655_06_14.jpg" width="1045"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – Immutable server deployments</p>
<p>Of course, an approach like this is only feasible when using technologies such as containers or virtual machines. Nobody would expect anyone to <a id="_idTextAnchor394"/>disregard phys<a id="_idTextAnchor395"/>ical servers after every redeployment.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor396"/>Progressive exposure</h2>
<p>Progressive exposure<a id="_idIndexMarker544"/> is a deployment strategy in which the number of users that have access to a new deployment or a new feature is slowly increased over time. The goal of this strategy is to limit the number of users that are experiencing issues when a faulty <a id="_idTextAnchor397"/>release of a feature is made available.</p>
<p>We can also look at this more positively and in line with the CD way of thinking: exposing a new feature to only a few users at first and increasing that number over time allows us to increase the amount of <a id="_idTextAnchor398"/>trust in a new version or feature of an appli<a id="_idTextAnchor399"/>cation before exposing it to all users.</p>
<h3>Canary deployments</h3>
<p>The first <a id="_idIndexMarker545"/>strategy for progressive exposure is to use <a id="_idIndexMarker546"/>canary deployments. In a canary deployment, not all users are routed to the new version immediately – only a limited percentage of the users get access to that version. These users are the canaries and they are monitored very closely. If they experience any issues or if degradation in performance of a service is observed, the new deployment is quickly rolled back.</p>
<p>A typical approach to realizing canary deployments is to use them in combination with blue-green deployments. The difference is that instead of switching all users over at the same time, only a small percentage is moved over to the new version at the start, and then the number of users that are moved over is gradually increased over time. This might look something similar to the following:</p>
<div>
<div class="IMG---Figure" id="_idContainer076">
<img alt="Figure 6.15 – Canary deployments " height="241" src="image/B18655_06_15.jpg" width="1234"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Canary deployments</p>
<p>If a deployment is rolled back because errors have been observed, this is not a fun experience for users. To prevent the same small<a id="_idTextAnchor400"/> group of users from running into issues repeatedly, it might be beneficial to select a di<a id="_idTextAnchor401"/>fferent group of canary users afterward.</p>
<h3>Ring-based deployments</h3>
<p>In a <a id="_idIndexMarker547"/>ring-based environment, there<a id="_idIndexMarker548"/> is not just one production environment – there are multiple. Each production environment serves only a portion of the users. It differs from a canary deployment in that, instead of just two environments, there can be as many as needed. Also, every new version g<a id="_idTextAnchor402"/>oes to all the rings, one after the other.</p>
<p>So, instead of redirecting the users, in a ring-based environment, the new version propagates to the servers used by those users. The new version just keeps propagating from one ring to the next, until they are all done:</p>
<div>
<div class="IMG---Figure" id="_idContainer077">
<img alt="Figure 6.16 – Ring-based deployments " height="123" src="image/B18655_06_16.jpg" width="1238"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Ring-based deployments</p>
<p>Ring-based deployment<a id="_idIndexMarker549"/> architectures are especially suitable for products that <a id="_idIndexMarker550"/>are accessed by customers from all around the world. The different rings can be positioned around the world, thus combining the deployment<a id="_idTextAnchor403"/> benefits with the <a id="_idTextAnchor404"/>added benefit of reduced latency for users.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor405"/>Blue-green versus canary deployments</h2>
<p>While both <a id="_idIndexMarker551"/>approaches are useful in minimizing the<a id="_idIndexMarker552"/> impact on your production workloads, there are some subtle variations that must be remembered when choosing one over the other:</p>
<ul>
<li>You can opt for blue-green deployment only when your production environment has an identical yet redundant secondary instance. Basically, you can upgrade the secondary instance first, and then route the traffic to it. Once satisfied with its working, you can continue with the deployment on your primary instance. This type of setup is similar to what is used during a disaster recovery situation. </li>
<li>If you do not have an extra second instance but are able to partition your primary instance in a way that a subset of the user traffic can be routed to separate physical compute units, you can benefit from using the canary deployment strategy. Canary provides a relatively easier way to activate or deactivate features based on certain criteria to a subset of users of the application. Canary deployment is preferred for right-shift testing strategies, wherein the <a id="_idIndexMarker553"/>performance and<a id="_idIndexMarker554"/> usability of a new feature can be initially verified with a limited load, before rolling it out with the entire user base of the application.</li>
</ul>
<p>In general, both methods require some initial planning and investment to straighten out the processes of deployment. </p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor406"/>Feature flags</h2>
<p>The third form of progressive deployment can be achieved using<a id="_idIndexMarker555"/> feature flags, also called <a id="_idIndexMarker556"/>feature toggles. Whereas canary deployments and ring-based deployments rely on slowly exposing new binaries to an increasing number of users, feature flags are used to slowly expose new features to an increasing number of users. This can be achieved even if they are all sending requests to the same server. Feature flags are generally used to mitigate the risk of releasing new features when upgrading to a new version of the application binaries that contain them. These flags act like a toggle switch whereby providing the ability to system administrators to enable or disable specific features at runtime.</p>
<p>The best example of a feature flag is showing or hiding a button that gives users access to a new feature. Application settings, a database, or an external service are used to keep track of which feature has been enabled for which user. Depending on that setting, the feature is shown or hidden. Examples of such external services include LaunchDarkly, split.io, and Prefab.Cloud.</p>
<p>Microsoft Azure also offers a resource named Azure App Configuration<a id="_idIndexMarker557"/> that can be used for centrally managing your feature flags and other application settings. You can read more about it here: <a href="https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview">https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview</a>.</p>
<p>Other feature flags might toggle bug fixes or performance improvements on or off. This can help to gradually expose these enhancements or fixes to ensure there are no issues. There should be a process in place when introducing feature toggles within the code base. It adds complexity, as the feature must support on-off toggles without having any impact to end users. This process should not only describe adding feature toggles but also how to remove them as soon as possible. An example of such a process can be as follows.</p>
<p>A new feature flag is<a id="_idIndexMarker558"/> introduced by a developer as soon as the business needs to release the feature independently of the deployments that were made by the development team, or for a change that the development team qualifies as high-risk and wants to be able to pull back at any time without redeploying it. Introducing a feature flag means a new database entry or a declaration of a <a id="_idTextAnchor407"/>new setting is applied in the application settings.</p>
<p>After introducing the <a id="_idIndexMarker559"/>feature toggle, the new feature or change is developed and tested. This means that there are one or more <strong class="source-inline">if</strong> statements in the code base that execute different code paths, depending on the state of the feature flag. At this point, the application must maintain two code execution paths until they remove the feature flag again. It is a good practice to separate these two code paths as much as possible using existing engineering practices, such as dependency injection.</p>
<p>While the code is continuously being shipped to users, the feature is not enabled for anyone. Only when the development team is fully satisfied with the change or the product owner feels the time is right for releasing a new feature is the feature flag turned on.</p>
<p>It is important not to stop here. After turning the feature flag on, it should actively be determined whether the feature or change is working properly, and if it is, the feature flag should be removed as soon as possible. This way, the time the two code paths need to be maintained for is as short as possible.</p>
<p>Also, note that besides maintaining an increased number of execution paths, there is now a larger number of paths to test. The impact of this consequence quickly grows if dependencies or exclusions between feature flags are introduced. Feature flags that can only be turned on or off, depending on the state of another feature flag, can be costly, and it is recommended to avoid this.</p>
<p>If implemented properly and removed as soon as possible, the added cost of feature flags is often worth it. As with every engineer<a id="_idTextAnchor408"/>ing practice, start small and evaluate what works in the g<a id="_idTextAnchor409"/>iven context, before adapting the practice at scale.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor410"/>Roll back or fail forward</h2>
<p>No matter which strategy is being used, it is necessary to think about the ability to roll back one or more versions and how long that will take. For example, blue-green deployments give us the ability to go back one version almost instantaneously, if a new version has not been deployed to the non-active servers yet. On the other hand, performing a rollback<a id="_idIndexMarker560"/> in a ring-based deployment will require a full redeployment of the previous version, which will probably take longer and comes with all the risks of deployment. This may even need to b<a id="_idTextAnchor411"/>e done on multiple rings, making it more challenging.</p>
<p>Another approach that can be adopted is <a id="_idIndexMarker561"/>that of failing forward. When adopting this approach, it is stated that there will never be a rollback to a previous version. Instead, when any issue is encountered, this will be addressed by redeploying a new version with the fix of that issue in it. This strategy is gaining traction lately since it saves time, as we don’t have to prepare, test, and practice rollbacks. However, there can be risks involved with this process:</p>
<ul>
<li>There is no guarantee that the fix will be correct. The issue might not be resolved by the newly deployed version or, even worse, the new version might result in transitioning from one issue to another.</li>
<li>Working out a detailed root cause of any issue takes time, just like writing a fix does. The consequence of this might be that the fix might take longer than a rollback would have taken.</li>
</ul>
<p>No matter which approach is taken, consider the consequences and prepare for them.</p>
<p>So far, we have mainly focused on web-<a id="_idTextAnchor412"/>based applications. In the next secti<a id="_idTextAnchor413"/>on, we will shift our attention to mobile applications.</p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor414"/>Deploying mobile applications</h1>
<p>One type of<a id="_idIndexMarker562"/> application that needs a special approach to deployment is a mobile application. These applications are often not downloaded and installed by end users directly and are mostly consumed via an app store on their mobile device.</p>
<p>Visual Studio App Center <a id="_idIndexMarker563"/>is a Microsoft offering that can be used for distributing (deploying) mobile applications to end users via app stores, but also via private distribution lists.</p>
<p>You can discover more about App Center<a id="_idIndexMarker564"/> here: <a href="https://visualstudio.microsoft.com/app-center/">https://visualstudio.microsoft.com/app-center/</a>.</p>
<p>After logging into App Center, you will be taken t<a id="_idTextAnchor415"/>o the following screen:</p>
<div>
<div class="IMG---Figure" id="_idContainer078">
<img alt="Figure 6.17 – Adding a new app " height="812" src="image/B18655_06_17.jpg" width="1161"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – Adding a new app</p>
<p>Here, you can create a new app definition. An app definition should be created for every target operating system of an application. If the same application is going to be deployed to both Android and iOS, at least two apps have to be created.</p>
<p>Creating an <a id="_idIndexMarker565"/>app is done by performing the following steps:</p>
<ol>
<li value="1">Log in to App Center.</li>
<li>Click the blue <strong class="bold">Add new app</strong> button. If there are no existing apps, this button will be in the center of the screen; otherwise, it will be at the top right (hidden under the popup shown in the preceding screenshot).</li>
<li>Enter the name of the app.</li>
<li>Select the type of release.</li>
<li>Select the operating system.</li>
<li>Select the platform to use.</li>
<li>Click <strong class="bold">Add new app</strong> to create the app.</li>
</ol>
<p>Once an app <a id="_idIndexMarker566"/>has been created, it can be connected to the<a id="_idTextAnchor416"/><a id="_idTextAnchor417"/><a id="_idTextAnchor418"/> correct app store and distribution groups can be created.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor419"/>Connecting to the app store</h2>
<p>The app store is the<a id="_idIndexMarker567"/> main mechanism for distributing an application for all mobile platforms. Once a build is delivered to an app store, users can install and use the application. The current list of connections to app stores can be opened using the <strong class="bold">Stores</strong> tab on the left-hand side of <strong class="bold">App Center</strong>. From this list, an individual store connection can be opened, which will take us to a screen similar to the one shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer079">
<img alt="Figure 6.18 – An app store within Visual Studio App Center " height="778" src="image/B18655_06_18.jpg" width="1202"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – An app store within Visual Studio App Center</p>
<p>This view shows a list of all the versions of the application that have been published to the connected store account. This is also where a new version of the application can be selected for publication to the store. This is done using the blue <strong class="bold">Publish to Google Play</strong> button at the top. This will open a popup where you can select the correct release. Y<a id="_idTextAnchor420"/>ou only have to confirm this once to publish this version.</p>
<p>New connections to the store can be created by navigating back to the list of all store connections and clicking the <strong class="bold">Add</strong> button. This will open a wizard where two pieces of information have to be entered:</p>
<ul>
<li><strong class="bold">The type of store connection</strong>: This list is limited to the stores that are available to apps of the type that was chosen when creating the app definition. For example, for iOS, this is limited to the Apple App Store and the Intune Company Portal.</li>
<li><strong class="bold">Connection details</strong>: Often, they include the means of authentication between App Center and the app store.</li>
</ul>
<p>Once the new<a id="_idIndexMarker568"/> connection has been created, it can be found on the list shown previously and can be used to distribute the app.</p>
<p>Another means of distribution<a id="_idTextAnchor421"/> is using dist<a id="_idTextAnchor422"/>ribution groups, which we’ll introduce in the next section.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor423"/>Using distribution groups</h2>
<p>Distribution groups are used to <a id="_idIndexMarker569"/>create named lists of one or more users, often testers or alpha users, that install an application through an invitation, rather than via the app store. Distribution groups can be found in the left-hand menu, under <strong class="bold">Groups</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer080">
<img alt="Figure 6.19 – Distribution groups within Visual Studio App Center " height="776" src="image/B18655_06_19.jpg" width="1255"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure<a id="_idTextAnchor424"/> 6.19 – Distribution groups within Visual Studio App Center</p>
<p>Here, a new group can be added, as follows:</p>
<ol>
<li value="1">Navigate to <strong class="bold">Distribution groups</strong> using the menu on the left.</li>
<li>Click the blue button labeled with a plus (<strong class="bold">+</strong>) sign (hidden under the popup in the preceding screenshot).</li>
<li>Choose a name for the group.</li>
<li>Add one or more members.</li>
<li>Save the <a id="_idIndexMarker570"/>new group.</li>
</ol>
<p>Once a distribution group has<a id="_idTextAnchor425"/> been created, it can be used for pub<a id="_idTextAnchor426"/>lishing releases, which we will discuss in the next section.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor427"/>Publishing an app</h2>
<p>To publish the first or a new <a id="_idIndexMarker571"/>version of an app, it has to be shared with App Center. This can be done using the <strong class="bold">Releases</strong> tab on the left-hand side. When opening up the releases, the following view, detailing all the current releases, will appear. From here, any release can be selected so that you can view the d<a id="_idTextAnchor428"/>etails of it:</p>
<div>
<div class="IMG---Figure" id="_idContainer081">
<img alt="Figure 6.20 – Viewing the releases of an app " height="755" src="image/B18655_06_20.jpg" width="1347"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20 – Viewing the releases of an app</p>
<p>In this view, a list of the most recent releases is shown in the middle column. After selecting an individual release, the details of that version will be shown. This includes its formal version, the store(s) and/or distribution group(s) it has been shared with, and other details.</p>
<p>From here, it is <a id="_idIndexMarker572"/>possible to distribute this specific version to a store connection or distribution group directly using the <strong class="bold">Distribute</strong> bottom at the top right.</p>
<p>From here, a new release can also be created by uploading a new build of the app. To do this, follow these steps:</p>
<ol>
<li value="1">Click on the <strong class="bold">New release</strong> button, which is available from the list of all releases (it might be necessary to close the details of a specific release first). This will open the following view:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer082">
<img alt="Figure 6.21 – Uploading a new build " height="771" src="image/B18655_06_21.jpg" width="1146"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21 – Uploading a new build</p>
<ol>
<li value="2">A new wizard will open, where a build needs to be uploaded. Depending on the type of app, the correct type of file will be requested. After uploading the binaries, click <strong class="bold">Next</strong>.</li>
<li>Now, the release notes have to be filled in. A<a id="_idTextAnchor429"/>fter detailing the changes in this release, click <strong class="bold">Next</strong> again.</li>
<li>Now, it is time to specify where this new build should be distributed. At least one destination – either a distribution group or a store – has to be selected. After <a id="_idIndexMarker573"/>selecting one or more destinations, click <strong class="bold">Next</strong> again.</li>
<li>The final wizard tab will show the selections you’ve made so far. Check the details and click <strong class="bold">Distribute</strong> to complete the creation of a new version and its initial distribution.</li>
</ol>
<p>Often, the same version or release needs to be distributed to other groups or stores over time as well. It is not necessary (nor useful) to create a new release every time. Instead, going to the <strong class="bold">Detail</strong> pages of the new destination store connection or distribution group allows you to publish an existing release to that destination as well.</p>
<p>As an alternative to using <a id="_idTextAnchor430"/>App Center to perform release management this way, it is<a id="_idTextAnchor431"/> also possible to use Azure Pipelines for release management.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor432"/>App Center via Azure Pipelines</h2>
<p>App Center can also be<a id="_idIndexMarker574"/> integrated with Azure Pipelines. If teams are familiar with the release process in Azure Pipelines, it can be sensible to build the app in Azure Pipelines and only use App Center for deployment to stores and distribution groups.</p>
<p>To make this possible, there are tasks available in Azure Pipelines that allow you to upload a release and trigger the deployment of a release to a store or distribution group. That way, release management can be done in Azure Pipelines while the App Center-specific capabilities are still leveraged where applicable.</p>
<p>This section is focused on mobile applications specifically, while the next section will apply to all types of releases. When creating releases is automated and new versions follow each other quickly, it is useful to sta<a id="_idTextAnchor433"/>rt automating the creation and publication of rele<a id="_idTextAnchor434"/>ase notes as well. This will be discussed in the next section.</p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor435"/>Automating release notes</h1>
<p>After automating<a id="_idIndexMarker575"/> the build, releasing an application, and working on increasing the flow of value to end users, many developers find that it becomes harder and harder to keep documentation and release notes up to date. As the amount of releases increases, this becomes more and more work, and e<a id="_idTextAnchor436"/>ventually, the team will fall behind or even give up completely.</p>
<p>To combat this, it is possible to automate the creation and publication of release notes. One way to do this is by using the <em class="italic">Azure DevOps Release Notes Generator</em>. Refer this for more details: <a href="https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/">https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/</a>.</p>
<p>The generator is an Azure Functions application that is available on GitHub. To use the Release Notes Generator, the following needs to be done:</p>
<ol>
<li value="1">Download or clone the function code from GitHub at this link: <a href="https://github.com/Azure-Samples/azure-devops-release-notes">https://github.com/Azure-Samples/azure-devops-release-notes</a>.</li>
<li>Create an Azure App Service Plan, function app, and storage account in Azure.</li>
<li>Create a new Blob Container in the storage account called <strong class="source-inline">releases</strong>.</li>
<li>Compile the function code and deploy it to an Azure App Service.</li>
<li>Create a new Azure DevOps WebHook to call the deployed function whenever a new release is created. (Please refer to the Wiki documentation on GitHub for more detailed instructions.)</li>
</ol>
<p>After setting this up, the generator will run whenever a new release is created. It will then do the following:</p>
<ol>
<li value="1">Query the created release for its name, all associated work items, and all the commits that are new since the previous release</li>
<li>Generate a <a id="_idIndexMarker576"/>Markdown file containing all of this information</li>
<li>Upload that file to the blob container – that is, <strong class="source-inline">releases</strong></li>
</ol>
<p>Of course, the Azure DevOps Release Notes Generator is just one example of automating tasks around releases, and there are other alternatives available as well. Also, many companies create tailored, in-house automation sc<a id="_idTextAnchor437"/>ripts for updating and publishing documentation and other tasks.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor438"/>Other tools</h1>
<p>In addition to Azure DevOps and App Center, there are other tools that can be used for deploying and releasing software. GitLab CI/CD and Jenkins, which were discussed in the previous chapter for executing builds, can also be used for releases. Besides those, Octopus Deploy is <a id="_idTextAnchor439"/><a id="_idTextAnchor440"/><a id="_idTextAnchor441"/>also a commonly used tool that integrates well with Azure DevOps.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor442"/>Octopus Deploy</h2>
<p><strong class="bold">Octopus Deploy</strong> is a<a id="_idIndexMarker577"/> deployment automation tool that is based on the concept of running a series of tasks on one or more target machines.</p>
<p>Octopus reaches these machines through a tentacle (an agent) that is installed on these machines. In Octopus Deploy, it is possible to define applications and environments and assign one or more machines to each of those. To do deployments, execution steps can be defined in a graphical editor, comparable to the visual release editor of Azure DevOps.</p>
<p>One of the main differences is that these steps are not defined per environment, only once per pipeline. Next, it is possible to specify which environments each task should run on. This way, it is easier to see where the deployment to different environments varies.</p>
<p>There is an integration between Azure DevOps and Octopus Deploy available, in the form of a build and release task. Using this integration, you can start a deployment usi<a id="_idTextAnchor443"/>ng Octopus Deploy from an Azure DevOps build or release pipeline.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor444"/>Summary</h1>
<p>In this chapter, you learned about continuous deployment and how you can implement them using Azure DevOps. In addition to the visual release editor, you also learned about multi-stage YAML pipelines, which you can use for releasing your software to multiple stages, all of the way to production. Next, we discussed a series of strategies that you can use for releasing. You now know about blue-green deployments, using immutable servers, and different strategies for progressive exposure. You also learned how to choose between making sure you have rollback capabilities and accepting a fail-forward strategy.</p>
<p>Then, you learned about automating release notes and documentation and how you can generate those automatically as part of your pipeline. After that, you learned about continuous deployment for mobile applications and how that differs from the delivery of web applications. Finally, you learned about the existence of Octopus Deploy, how it operates, and how it integrates with Azure DevOps.</p>
<p>In the next chapter, you will learn about topic dependency management using Azure Artifacts. This can be used to host your own NuGet packages or to host build artifacts when you are using other products for building or<a id="_idTextAnchor445"/><a id="_idTextAnchor446"/> releasing your application, in combination with Azure Pipelines.</p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor447"/>Questions</h1>
<p>As we conclude this chapter, here is a list of questions for you to test your knowledge of this chapter’s material. You will find the answers in the <em class="italic">Assessments</em> section of the <em class="italic">Appendix</em>:</p>
<ol>
<li value="1">True or false: an Azure DevOps Classic release is always triggered by the availability of a new version of an artifact.</li>
<li>Which of the following platforms can App Center publish apps to? (You can choose more than one.)<ol><li>Google Play Store</li><li>Apple App Store</li><li>Microsoft Intune</li></ol></li>
<li>Which of the following techniques use progressive exposure for minimizing the risks of deploying a new version? (You can choose more than one.)<ol><li>Feature toggles</li><li>Ring-based deployments</li><li>Canary deployments</li></ol></li>
<li>True or false: deployment groups can be used for deploying software to on-premises servers when an Azure Pipelines agent is installed on the machine that will be running the software.</li>
<li>What is the advantage of integrating App Center with Azure Pipelines if you have an Azure Pipelines release definition triggering actions in App Center?</li>
</ol>
<h1 id="_idParaDest-157"><a id="_idTextAnchor448"/>Exercises</h1>
<ul>
<li><strong class="bold">Prerequisites</strong>: The exercises in this chapter have a dependency on <a href="B18655_08.xhtml#_idTextAnchor542"><em class="italic">Chapter 8</em></a>, <em class="italic">Implement Infrastructure and Configuration as Code</em>. Please complete the exercises mentioned in that chapter so that you have provisioned the necessary resources in Azure to continue with the build deployment-related pipeline creation. </li>
<li><strong class="bold">Dependency</strong>: Please ensure that a <strong class="bold">Service connections</strong> record has been created for the <strong class="source-inline">PacktBookLibrary</strong> project. This will be used as a service account for deploying resources and builds to Azure:<ul><li>Navigate to <strong class="bold">Project Settings</strong> | <strong class="bold">Service connections</strong> (under <strong class="bold">Pipelines</strong>) and then click on the <strong class="bold">New Service Connection</strong> button. </li><li>Within the <strong class="bold">New service connection</strong> dialog, ensure that the <strong class="bold">Azure Resource Manager</strong> option is selected and then, in the next step, that <strong class="bold">Service Principal (automatic)</strong> is selected.</li><li>Keep scope as <strong class="bold">Subscription</strong> and specify the Service connection name as <strong class="bold">Azure Service Connection</strong>.</li><li>Under <strong class="bold">Security</strong>, check the option to grant access to all pipelines.</li></ul></li>
<li>Create <strong class="bold">Environments</strong> and define approvals:<ul><li>Navigate to <strong class="bold">Pipelines</strong> | <strong class="bold">Environments</strong>, and create three environment records as <strong class="source-inline">DEV</strong>, <strong class="source-inline">TST</strong>, and <strong class="source-inline">PRD</strong>. Don’t add any resources for now: <div class="IMG---Figure" id="_idContainer083"><img alt="Figure 6.22 – Environments for deployment " height="402" src="image/B18655_06_22.jpg" width="706"/></div></li></ul></li>
</ul>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22 – Environments for deployment</p>
<ul>
<li>For each environment entry, configure the approvers for it. The list of approvers should be the members who can approve any activity in their respective owned environment:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer084">
<img alt="Figure 6.23 – Configuring environment settings " height="222" src="image/B18655_06_23.jpg" width="575"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.23 – Configuring environment settings</p>
<ul>
<li>Create <strong class="bold">Variable groups</strong> and specify values for the variables:<ul><li>Navigate to <strong class="bold">Pipelines</strong> | <strong class="bold">Library</strong> | <strong class="bold">Add Variable group</strong>. Add the following set of variables for three different variable groups (one per environment):<ul><li><strong class="source-inline">Environment</strong>: Refers to the name of the environment</li><li><strong class="source-inline">azureSubscription</strong>: Refers to the service connection name to be used</li><li><strong class="source-inline">Webappname</strong>: Refers to the Azure App Service resource name </li><li><strong class="source-inline">Resorucegroup</strong>: Refers to the resource group in which the App Service resource has been provisioned </li><li><strong class="source-inline">Slotname</strong>: Refers to the slot of the App Service that the build has to be deployed to</li></ul></li><li>You should now see three different variable groups:</li></ul></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer085">
<img alt="Figure 6.24 – Variable groups per environment " height="450" src="image/B18655_06_24.jpg" width="511"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.24 – Variable groups per environment</p>
<ul>
<li>Open your code repository for the <strong class="source-inline">PacktBookLibrary</strong> repository and create a subfolder named <strong class="source-inline">deploy</strong> in the <strong class="source-inline">pipelines</strong> directory:<ul><li>Create a file named <strong class="source-inline">template.yaml</strong>. Insert code as per the file present in this directory: <a href="https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide">https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide</a> </li></ul></li>
<li>Place another file named <strong class="source-inline">template.yaml</strong> in the <strong class="source-inline">build</strong> subdirectory:<ul><li>Insert code as per the file present in this directory: <a href="https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide">https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide</a></li></ul></li>
<li>In the <strong class="source-inline">pipelines</strong> directory, create a file named <strong class="source-inline">main-cd-pipeline.yaml</strong>. Insert code as per the file present in this directory: <a href="https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide">https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide</a></li>
<li>Create a CD pipeline to provision the latest build to three different environments:<ul><li>Click on <strong class="bold">Pipelines</strong> | <strong class="bold">New Pipeline</strong>, and then select the repository, set the branch as <strong class="source-inline">main</strong>, set the path as the relative path to <strong class="source-inline">main-cd-pipeline.yaml</strong>, and then save the pipeline under the name <strong class="source-inline">main-cd-pipeline</strong>.</li></ul></li>
<li>Grant permissions to the pipelines to all the variable groups. You should see the following two pipelines now:<div class="IMG---Figure" id="_idContainer086"><img alt="Figure 6.25 – Viewing the pipeline run statuses " height="340" src="image/B18655_06_25.jpg" width="657"/></div></li>
</ul>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.25 – Viewing the pipeline run statuses</p>
<ul>
<li>Run <strong class="source-inline">main-cd-pipeline</strong> <a id="_idTextAnchor449"/>and verify whether the build deployment is succeeding or not.</li>
</ul>
<h1 id="_idParaDest-158"><a id="_idTextAnchor450"/>Further reading</h1>
<ul>
<li>More information on using stages in YAML pipelines can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages">https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages</a>.</li>
<li>More information on the idea of immutable servers can be found at <a href="https://martinfowler.com/bliki/ImmutableServer.xhtml">https://martinfowler.com/bliki/ImmutableServer.xhtml</a>.</li>
<li>More information about LaunchDarkly can be found at <a href="https://launchdarkly.com/">https://launchdarkly.com/</a>.</li>
<li>More details about the build and release extension for integration with Octopus Deploy can be found at <a href="https://marketplace.visualstudio.com/items?itemName=octopusdeploy.octopus-deploy-build-release-tasks">https://marketplace.visualstudio.com/items?itemName=octopusdeploy.octopus-deploy-build-release-tasks</a>.</li>
<li>The Azure DevOps Release Notes Generator can be found at <a href="https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/">https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/</a>.</li>
<li>Some Microsoft hands-on labs for practicing the topics we covered in this chapter can be found at the following links:<ul><li><a href="https://docs.microsoft.com/en-us/learn/modules/create-multi-stage-pipeline/index">https://docs.microsoft.com/en-us/learn/modules/create-multi-stage-pipeline/index</a></li><li><a href="https://docs.microsoft.com/en-us/learn/modules/create-release-pipeline/index">https://docs.microsoft.com/en-us/learn/modules/create-release-pipeline/index</a> and <a href="https://docs.microsoft.com/en-us/learn/modules/manage-release-cadence/index">https://docs.microsoft.com/en-us/learn/modules/manage-release-cadence/index</a></li></ul></li>
</ul>
</div>
<div>
<div id="_idContainer088">
</div>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer089">
<h1 id="_idParaDest-159"><a id="_idTextAnchor451"/>Part 3 – Expanding Your DevOps Pipeline</h1>
<p>In this part, you will learn about other DevOps practices that build upon the strong foundation of <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>)/<strong class="bold">Continuous Delivery</strong> (<strong class="bold">CD</strong>) discussed earlier in <em class="italic">Part 2 , Getting to Continuous Delivery</em>. You will learn about how to establish a robust <strong class="bold">Application Lifecycle Management</strong> (<strong class="bold">ALM</strong>) process to manage your infrastructure in the cloud, as well as streamlined upgrades and migration of your backend databases without incurring any loss of information.    </p>
<p>We will also look at continuous testing practices to understand more about the concept of “shift-left quality.” This involves embedding quality concerns in our pipelines from the start and continuously verifying them, resulting in the faster delivery of a secure and high-quality product.</p>
<p>This part of the book comprises the following chapters:</p>
<ul>
<li><a href="B18655_07.xhtml#_idTextAnchor453"><em class="italic">Chapter 7</em></a>, <a id="_idTextAnchor452"/><em class="italic">Dependency Management</em></li>
<li><a href="B18655_08.xhtml#_idTextAnchor542"><em class="italic">Chapter 8</em></a>, <em class="italic">Implement Infrastructure and Configuration as Code </em></li>
<li><a href="B18655_09.xhtml#_idTextAnchor699"><em class="italic">Chapter 9</em></a>, <em class="italic">Dealing with Databases in DevOps Scenarios</em></li>
<li><a href="B18655_10.xhtml#_idTextAnchor760"><em class="italic">Chapter 10</em></a>, <em class="italic">Integrating Continuous Testing</em></li>
<li><a href="B18655_11.xhtml#_idTextAnchor889"><em class="italic">Chapter 11</em></a>, <em class="italic">Managing</em> <em class="italic">Security and Compliance</em></li>
</ul>
</div>
</div></body></html>