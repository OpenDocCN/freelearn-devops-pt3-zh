- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copado
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will delve into the key features and capabilities of Copado, covering
    its underlying data model and administration. We will examine how Copado addresses
    the challenges of Salesforce development by automating and simplifying tasks such
    as version control, build automation, testing, and deployment. We will also look
    at how Copado integrates with native Salesforce objects for centralized reporting
    and process monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to exploring the technical capabilities of Copado, we will also
    discuss the platform’s strengths and weaknesses; understanding these is crucial
    for organizations considering Copado implementation, as it helps them align their
    expectations and plan their resources effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Copado
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the strengths of Copado
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the weaknesses of Copado
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a comprehensive understanding of Copado
    and its role in Salesforce DevOps. The insights you gain will equip you to make
    informed decisions about leveraging Copado in your own Salesforce environment
    and help you navigate the complexities of Salesforce development with greater
    ease and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Copado
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copado provides an end-to-end platform for developing in **Salesforce** using
    **DevOps** principles and practices. As a native app built on the Salesforce platform,
    Copado aims to address gaps in the core Salesforce product that inhibit effective
    **continuous integration and delivery** (**CI/CD**). This overview will detail
    Copado’s underlying data model, key technical capabilities, and administration
    based on its publicly available documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Copado allows teams to implement DevOps workflows entirely within Salesforce
    without the extensive use of external tools. It integrates version control, build
    automation, testing, and deployment while retaining native reporting and process
    visibility. The platform centers around a core abstraction layer that handles
    much of the complexity of tasks, such as branch management, automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Platform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Copado utilizes a **user-story-centered data model**, that is to say, a deployment
    model centered around user stories, to associate any requirements with specific
    metadata changes. The user story entity relates code to its business purpose and
    scopes for work for incremental delivery. Stories flow through predefined pipelines
    that span the lower development environments up through to production, as is the
    case with other configuration management databases. The following screenshot shows
    a sample pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – An example of a Copado pipeline](img/B19436_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – An example of a Copado pipeline
  prefs: []
  type: TYPE_NORMAL
- en: The Copado platform layers abstraction on top of complex **Git** branching and
    merging operations through the use of a semantic conflict resolution engine. This
    prevents developers from needing to handle merge conflicts and Git commands manually.
    Instead, the platform handles branching in a declarative way by using the pipelines
    flowing from the lower to higher environments.
  prefs: []
  type: TYPE_NORMAL
- en: All user actions within Copado integrate with native Salesforce objects for
    centralized reporting and process monitoring. This retains auditability and visibility
    within the comfortable Salesforce interface that administrators already understand.
    No external dashboards or reports are needed to monitor the DevOps processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Copado’s capabilities cover the entire DevOps lifecycle, from the initial requirements
    through to production deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirement management for user stories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated version control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration, triggering quality gates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Co-ordinated promotion through the environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment pipeline configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Org syncing through back promotion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built-in visibility and reporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together, these aim to provide a comprehensive system for development teams
    to implement agile, iterative DevOps patterns within Salesforce.
  prefs: []
  type: TYPE_NORMAL
- en: Version control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copado integrates Git version control by automatically creating feature branches
    for each user story’s committed metadata components. The exact branch structure
    mirrors the progression of user stories flowing between different Salesforce sandboxes
    and environments defined in the pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows integration with version control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Copado Git integration](img/B19436_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Copado Git integration
  prefs: []
  type: TYPE_NORMAL
- en: Bi-directional deployment and the merging of branches keep all environments
    and sandboxes in sync as changes flow upstream and downstream through testing
    and production. No manual Git operations are required on the part of the developers
    or administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Copado’s conflict detection utilizes semantic analysis for metadata rather than
    just syntactic code reconciliation. This allows it to detect logical conflicts
    between components that may not be mergeable, such as conflicting field-level
    security rules. The platform alerts users to these conflicts early to avoid deployment
    failures.
  prefs: []
  type: TYPE_NORMAL
- en: An administrator can define an organization’s branching strategy and environment
    topology through the pipelines in Copado without needing to know Git internals.
    The complexity is hidden below the abstraction layer.
  prefs: []
  type: TYPE_NORMAL
- en: Build integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous integration is a key capability of Copado. Upon each code check-in
    or commit action, the platform can automatically trigger configured tests, validations,
    and other quality gates. These may include Apex tests, linting, static analysis,
    or any other custom steps.
  prefs: []
  type: TYPE_NORMAL
- en: The output of tests and validations is recorded directly onto related user stories
    within Salesforce for traceability. Developers can see the results immediately
    without a separate CI server. You can retain compliance on code quality through
    native reporting.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party tools, such as **Jira** and **Azure DevOps**, can integrate with
    Copado’s CI pipeline via built-in webhooks or custom **Apex** adapters. Custom
    plugins allow admins to modify and customize Copado’s standard CI/CD process to
    insert custom quality gates. For instance, you could configure a webhook to call
    out to your preferred security scanning tool via its API just before your code
    is deployed to your UAT or production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Copado aims to promote shift-left testing and quality assurance by baking it
    into the commit process automatically. The mandatory gates keep all code checked
    in at a minimum quality bar through consistent, automated enforcement.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within deployment, Copado introduces the concept of promotions for moving user
    stories between environments in the pipelines. Promotions pull metadata changes
    downstream using the pipelines defined through the declarative Copado interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a sample user story:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – A sample Copado user story](img/B19436_13_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – A sample Copado user story
  prefs: []
  type: TYPE_NORMAL
- en: Permission schemes grant the approvals required for progression between pipeline
    stages. Mandatory manual approval gates can ensure that any changes are authorized.
    Copado’s selective rollback capability can also redeploy previous metadata commitments
    (as needed) to rapidly revert production.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: “Stages” are categorized as collections of environments fulfilling similar business
    roles, such as development, testing, production, etc. They provide release managers
    with the ability to organize their pipelines and environments visually and systematically.
    Additionally, stages facilitate the configuration and execution of various functionalities
    when actions are carried out within them. For instance, in scenarios involving
    quality gate rules or automation rules or when using Copado’s **Continuous Delivery**
    and **Deployment** steps, one can choose particular stages at which to apply these
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Connection behaviors configure additional actions, such as automated email notifications,
    that execute on a per-stage basis in the pipelines. For example, you may want
    all production deployments to email a security auditor. Behaviors standardize
    these processes.
  prefs: []
  type: TYPE_NORMAL
- en: Promotions couple code movement with approval and notification policies to avoid
    *shadow IT*, the performance of IT tasks by non-IT staff, and implement compliance.
    Rollback mitigates risk by allowing unsafe changes to be removed from the environment
    automatically if they are found to cause issues.
  prefs: []
  type: TYPE_NORMAL
- en: Environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Copado keeps Salesforce sandboxes in strict transactional sync without repetitive
    and manual refresh operations. Refreshing between lower environments creates significant
    friction in development workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Back promotion** is a process designed to transfer user stories from higher
    to lower environments, serving three main purposes: it ensures synchronization
    across environments by maintaining consistent changes, facilitates the propagation
    of hotfixes from production to the lower environments, and helps reduce merge
    conflicts by recommending the back promotion of changes for streamlined integration.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, back promotions (see callout) automatically merge upstream code changes
    into lower environments on demand. The platform continuously monitors the state
    of each organization for deployment readiness before executing downstream distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Limited canary releases introduce a subset of new metadata to a sandbox before
    complete distribution for incremental rollout. This limits risk and allows testing
    smaller change batches.
  prefs: []
  type: TYPE_NORMAL
- en: Together, these capabilities allow developers to access the latest shared changes
    without refreshing, even as updates continually flow to production. It provides
    a tight inner development loop.
  prefs: []
  type: TYPE_NORMAL
- en: Change management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Change management, in this context, refers to the ability to control any changes
    to user permissions and access; this poses challenges in Salesforce because permissions
    and access controls sit across interconnected metadata entities such as profiles,
    permission sets, and field-level security rules.
  prefs: []
  type: TYPE_NORMAL
- en: Full profile deployment in Copado encapsulates all associated metadata to deploy
    profiles as a single atomic unit. This avoids permissions drifting out of sync
    as changes spread. Similarly, permission sets maintain consistent field-level
    access between environments.
  prefs: []
  type: TYPE_NORMAL
- en: The platform tracks all modifications, attributing them to specific developers,
    user stories, and commitments for complete auditability. You can produce detailed
    reports on modifications to sensitive configurations or attributes, such as the
    record owner.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, change tracking preserves security compliance and configuration
    integrity as changes flow bi-directionally between lower and higher levels. Dependent
    metadata is deployed in a single package, avoiding the fragmentation that can
    come from multiple deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Administration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key goal of Copado is enabling implementation without extensive training or
    specialization. All configurations leverage declarative, point-and-click customization
    similar to the core Salesforce interface. Users already familiar with Salesforce
    will find the tool intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting integrates with Salesforce core objects, such as user stories and
    promotions, to generate process metrics and dashboards for visibility. Prebuilt
    templates ship out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Admins oversee access control, usage policies, and other platform governance
    by using the same tools as the core of Salesforce. Change sets can push policies
    between environments and profiles control access.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the declarative nature of Copado administration keeps the learning
    curve low. Organizations can iteratively refine roles and permissions as practices
    mature without disruption.
  prefs: []
  type: TYPE_NORMAL
- en: Copado provides an extensible platform for implementing the continuous deployment
    of Salesforce applications using practices such as immutable infrastructure and
    infrastructure as code. Its core value comes from the native integration and automated
    handling of deployment complexities inherent to the Salesforce platform.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, Copado aims to eliminate many of the repetitive tasks and barriers
    to implementing modern DevOps practices within Salesforce development. By providing
    version control, CI/CD, and environment management, it allows teams to scale agile
    and iterative development. The consolidation within Salesforce UIs simplifies
    adoption.
  prefs: []
  type: TYPE_NORMAL
- en: Robotic testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Designed to dramatically reduce the time and effort required for developing
    and deploying test cases, **Copado robotic testing** (**CRT**) offers detailed
    analyses of test cases, enhancing the effectiveness of testing processes. As a
    primarily cloud-based solution, it can be accessed via www.robotic.copado.com,
    and it also has the flexibility of being available as an on-premise service. To
    cater to a diverse user base, CRT offers a limited free version, which serves
    as an excellent resource for learning and understanding the framework.
  prefs: []
  type: TYPE_NORMAL
- en: One of the standout features of CRT is its versatility in writing test cases
    for a broad spectrum of applications. This includes web-based applications, mobile
    applications, Salesforce Apps, ServiceNow apps, SAP systems, simple websites,
    and REST APIs. Its dual nature as a low-code and pro-code platform makes it particularly
    accessible; users without extensive knowledge of test scripting languages or frameworks
    can still develop test cases efficiently, thanks to its keyword-driven development
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: CRT further streamlines the testing process with its capability to live test
    and video-stream test case executions. This feature significantly expedites the
    debugging process, allowing for real-time issue identification and resolution.
    Additionally, the framework provides the flexibility to schedule test case executions
    in alignment with organizational policies.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, Copado robotic testing stands out as a comprehensive, flexible,
    and efficient test automation framework suitable for a wide range of applications
    and user expertise levels. Its combination of live testing capabilities, integration
    options, and a structured approach to testing infrastructure makes it a valuable
    tool in the landscape of software development and quality assurance.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the strengths of Copado
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Founded in 2013, Copado has emerged as a leading end-to-end DevOps platform
    tailored for Salesforce development and release management. With substantial growth
    capital from Salesforce Ventures and other investors, Copado offers a comprehensive
    suite of capabilities to support and accelerate Salesforce deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'A key strength of Copado is its deep native integration with the Salesforce
    platform. Copado was originally constructed to solve a big need in the market
    right now: to help underpin the Salesforce DevOps lifecycle.'
  prefs: []
  type: TYPE_NORMAL
- en: By building natively on Salesforce, Copado inherits the security, authentication,
    and other advantages of the platform while maintaining tight integration between
    development and operations. This contrasts with other tools that operate outside
    of Salesforce, leading to potential integration challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Relatedly, Copado’s metadata intelligence gives it an edge in understanding
    dependencies, detecting conflicts, and merging changes within Salesforce environments.
    Copado’s secret sauce is its ability to build (on your behalf) a feature-specific
    branch by converting the one-to-one relationship between your user story in that
    feature-specific branch.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A merge conflict happens when two changes are made in separate environments
    to the same metadata components in a way that can’t be reconciled automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than operating on files, Copado works at the metadata API layer, giving
    it an advantage in merging and deploying changes. This helps address the merge
    conflicts that users commonly encounter with Salesforce metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Copado also shines in providing end-to-end application lifecycle management,
    not just deployment. Its issue tracking, user stories, pipelines, and workflows
    support development teams in planning, co-ordinating, and tracking work from idea
    through to release. Jira tickets, for instance, become Copado user stories, connecting
    development work to downstream release processes. This can accelerate development
    by linking business requirements to developer efforts.
  prefs: []
  type: TYPE_NORMAL
- en: For larger development teams, Copado is difficult to match in terms of functionality
    and integration. It combines the advantages of Salesforce’s platform with Heroku’s
    scalable infrastructure for computationally intensive tasks, such as metadata
    processing. The Heroku architecture eases security audits while providing necessary
    performance. This allows Copado to offer **application lifecycle management**
    (**ALM**), testing, compliance, and other tools not found in most deployment-focused
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the weaknesses of Copado
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Copado has emerged as a robust solution, offering a comprehensive suite of features
    that support all aspects of the Salesforce development lifecycle. However, as
    with any tool, it has its limitations and challenges. This section explores these
    potential weaknesses, providing a balanced view of the platform’s capabilities
    and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key challenges often mentioned in relation to Copado is its complexity.
    The tool offers a wide range of features and capabilities, which can be overwhelming
    for new users. The learning curve associated with effectively leveraging all of
    the tool’s features can be steep, potentially slowing down implementation and
    adoption.
  prefs: []
  type: TYPE_NORMAL
- en: A related issue is the potential difficulty of integrating Copado into existing
    Salesforce and CI/CD ecosystems, particularly those with complex tech stacks.
    Compatibility and seamless integration with various tools may require additional
    configuration and effort, which can be a challenge for teams with limited resources.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, Copado requires ongoing maintenance to keep it aligned with changes
    in Salesforce, your CI/CD pipeline, and your organization’s evolving needs. Managing
    these continuous changes can be time-consuming and may strain resources, especially
    for smaller teams.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential weakness of Copado is the way it handles backend processing.
    Although the use of Heroku for backend processing allows Copado to leverage Heroku’s
    power and speed for metadata retrieval, processing, and deployments, it also has
    a startup cost. If Heroku is being used to deploy metadata from a code repository,
    it has to clone that metadata first, leading to some performance cost for each
    job.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is worth noting that Copado claims to have optimized this process,
    fetching only the minimal amount of history to enable the merge. But even with
    this optimization, the startup cost can still be a potential bottleneck, especially
    for larger deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, while Copado’s use of Salesforce as its user interface and for
    data storage offers some benefits, it also presents some challenges. For instance,
    all logs and other files are stored as attachments in the Salesforce package,
    which can make them difficult to read. Moreover, the UI, being built on Salesforce,
    can look slightly awkward to some users and may not always provide the most intuitive
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, Copado’s notifications about job results are not always obvious,
    which can lead to confusion or missed notifications. This can be particularly
    problematic in a DevOps environment, where timely notifications about deployments,
    tests, and other processes are crucial. See, for instance, the following screenshot
    of a notification that hasn’t been updated properly and, therefore, is marked
    as done but is neither finished nor successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – A stalled Copado notification](img/B19436_13_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – A stalled Copado notification
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, while Copado is undoubtedly a powerful and comprehensive DevOps
    tool for Salesforce, it is not without its challenges. Understanding these potential
    weaknesses is crucial for organizations considering Copado implementation, as
    it allows them to plan for these challenges and ensure they have the necessary
    resources and strategies in place to overcome them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, Copado offers a robust and comprehensive suite of DevOps tools
    specifically designed for Salesforce. By offering deep, native integration with
    Salesforce, it effectively addresses gaps in the platform, automating complex
    tasks such as version control, CI/CD, and environment management.
  prefs: []
  type: TYPE_NORMAL
- en: Its user-story-centered data model and seamless integration with third-party
    tools make it a valuable asset for agile and iterative development. However, like
    any tool, it has its limitations. The complexity and steep learning curve might
    pose challenges for new users. Additionally, the backend processing via Heroku,
    while being powerful, may introduce performance costs for larger deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Despite these potential hurdles, with the right planning and resources, Copado
    can significantly streamline Salesforce development and release management, making
    it a noteworthy consideration for organizations looking to enhance their Salesforce
    DevOps lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: To address the challenges posed by Copado’s complexity and learning curve, a
    strategic approach involving thorough training and resource allocation is essential.
    Organizations can invest in comprehensive training programs for their teams, focusing
    on hands-on experience and real-world scenarios to build proficiency. Utilizing
    Copado’s extensive documentation and community resources can also aid in this
    learning process. Moreover, phased implementation strategies can help teams gradually
    adapt to the tool’s intricacies, starting with basic functionalities and progressively
    moving to more advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: Regarding the performance costs associated with backend processing via Heroku
    for larger deployments, optimizing the configuration and scaling strategies within
    Heroku can mitigate these issues. This might involve leveraging more efficient
    resource allocation, optimizing workflows for better performance, and ensuring
    that the Heroku environment is tailored to the specific needs of the deployment.
    Additionally, regularly monitoring and reviewing the performance metrics can help
    in identifying and addressing any inefficiencies promptly. By tackling these aspects,
    organizations can harness the full potential of Copado, making it a powerful asset
    in their Salesforce DevOps toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: With these measures in place, Copado’s strengths can be fully realized, overcoming
    its initial barriers to offer a streamlined and efficient solution for Salesforce
    development and release management. In moving forward, the next chapter will introduce
    Flosum, another tool in the Salesforce DevOps landscape, and explore its features
    and capabilities.
  prefs: []
  type: TYPE_NORMAL
