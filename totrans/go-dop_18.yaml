- en: 'Chapter 15: Programming the Cloud'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章：编程云
- en: You've probably heard the saying *the cloud is just someone else's computer*.
    While it is somewhat true, it is also wildly off target. Cloud service providers
    offer virtual machines running in their data centers that you can use in exchange
    for money, so in that way, you are using someone else's computer. However, it
    misses the bigger picture of what a cloud service provider is. A cloud service
    provider is a collection of hundreds of application-hosting, data, compliance,
    and computing infrastructure services that run in hundreds of data centers across
    the globe and are exposed through a fully programmable API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听过“*云就是别人家的电脑*”这句话。虽然有一定的道理，但也有些偏离实际。云服务提供商提供的是运行在其数据中心的虚拟机，你可以付费使用，从这个角度看，确实是在使用别人家的电脑。然而，这并没有呈现出云服务提供商的整体面貌。云服务提供商是由数百个应用托管、数据、合规性和计算基础设施服务组成的，这些服务分布在全球数百个数据中心，并通过完全可编程的
    API 进行暴露。
- en: In this chapter, we will learn how to interact with a cloud API using Microsoft
    Azure. We'll start by learning a bit about the nature of the APIs, including how
    they are described and where to find additional documentation about them. We'll
    learn the fundamentals of identity, authentication, and authorization. We'll then
    apply what we have learned in a set of examples using the Azure SDK for Go to
    build cloud infrastructure and utilize other cloud services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用 Microsoft Azure 与云 API 进行交互。我们将从了解 API 的本质开始，包括如何描述 API 以及在哪里找到有关它们的更多文档。接下来，我们将学习身份、身份验证和授权的基础知识。然后，我们将通过使用
    Azure SDK for Go 的一系列示例，应用我们学到的知识，构建云基础设施并利用其他云服务。
- en: By the end of the chapter, you will be equipped with the knowledge to work effectively
    with Microsoft Azure and will have gained the transferable skills to work with
    other cloud service providers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将掌握有效使用 Microsoft Azure 的知识，并获得与其他云服务提供商合作的可转移技能。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What is the cloud?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是云？
- en: Learning the basics of the Azure APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Azure API 的基础知识
- en: Building infrastructure using Azure Resource Manager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure 资源管理器构建基础设施
- en: Using provisioned Azure infrastructure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已配置的 Azure 基础设施
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter will require the following tools:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将需要以下工具：
- en: Go
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go
- en: 'The Azure CLI: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure CLI：[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)
- en: 'Code files downloaded from GitHub: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitHub 下载的代码文件：[https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15)
- en: What is the cloud?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是云？
- en: The scale of capital investment in the Amazon, Microsoft, and Google cloud physical
    computing infrastructure is monumental. Imagine the investment needed to build
    200+ physical data centers with multiple redundant power and cooling systems,
    featuring state-of-the-art physical security. These centers are resilient in the
    face of a natural disaster. Even then, you are just scratching the surface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊、微软和谷歌云物理计算基础设施的资本投资规模是巨大的。试想一下，建设 200 多个物理数据中心，配备多个冗余的电力和冷却系统，并且具备先进的物理安全设施，需要多少投资。这些数据中心在面临自然灾害时仍能保持韧性。即便如此，你也只是在触及冰山一角。
- en: These data centers require one of the largest interconnected networks on the
    planet to link them together. All of that infrastructure won't function without
    vast amounts of power and cooling, preferably from sustainable sources. For example,
    Azure has been carbon-neutral since 2012 and is committed to being carbon-negative
    by 2030\. When people talk about hyper-scale cloud, they are talking about the
    planet-scale operations of these cloud service providers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据中心需要全球最大的互联网络之一将它们连接起来。所有这些基础设施在没有大量电力和冷却的支持下无法运作，最好是来自可持续的能源来源。例如，Azure
    自2012年以来一直实现碳中和，并承诺到2030年实现碳负排放。当人们谈论超大规模云时，他们指的是这些云服务提供商的全球范围运营。
- en: Ever wonder what it would be like to visit one of these data centers? For example,
    to access an Azure data center, there are multiple levels of security you must
    go through. You must first request access to the data center and provide a valid
    business justification. If access is granted, when you arrive at the data center's
    permitter access point, you'd notice the panoply of cameras, tall steel fences,
    and concrete surrounding the perimeter. You'd verify your identity and pass to
    the building entrance. At the building entrance, you'd be greeted by security
    officers who will once again verify who you are using two-factor authentication
    with biometrics. Upon passing biometric scanning, they'd guide you to the specific
    section of the data center where you have been approved to operate. As you proceed
    to the data center floor, you'd pass in and out through a full-body metal detection
    screening to ensure that you don't leave with anything you shouldn't. Security
    at these data centers is taken very seriously.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有想过访问这些数据中心会是怎样的体验？例如，要访问Azure的数据中心，你必须通过多个安全层级。你首先需要申请进入数据中心并提供有效的商业理由。如果获得批准，当你到达数据中心的外围访问点时，你会注意到周围有众多摄像头、高大的钢铁围栏以及混凝土围墙。你需要验证身份，并进入建筑物的入口。在建筑物入口，你会遇到安保人员，他们会再次通过双重身份验证（包括生物识别）来确认你的身份。通过生物识别扫描后，他们会引导你进入数据中心的特定区域。在进入数据中心的过程中，你还需要通过全身金属探测器筛查，确保你没有携带不该带出的物品。这些数据中心的安全措施非常严格。
- en: Still think this sounds like *someone else's computer*?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然觉得这像是*别人的电脑*吗？
- en: The physical infrastructure of cloud service providers is awe-inspiring. However,
    we should change our focus from the scale of cloud service provider operations
    to how cloud services are exposed to developers. As we mentioned initially, cloud
    service providers expose the functions of the cloud through APIs, which developers
    can use to manage infrastructure and applications running on the cloud. We can
    use these APIs to build applications that can leverage hyper-scale cloud infrastructure
    to become planet-scale.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商的物理基础设施令人敬畏。然而，我们应该将焦点从云服务提供商的运营规模转向云服务是如何暴露给开发者的。正如我们最初提到的，云服务提供商通过API暴露云的功能，开发者可以使用这些API来管理运行在云上的基础设施和应用程序。我们可以利用这些API构建应用程序，借助超大规模的云基础设施，使其具备全球规模。
- en: Learning the basics of the Azure APIs
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Azure API的基础知识
- en: Now that we know the path to programming the cloud is through APIs, let's learn
    a bit more about them. It's important to establish some background on how a large
    system of APIs comes together to form a consistent programmatic interface. We
    will also learn where you can find code and documentation when you run into challenges.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，编程云的路径是通过API，让我们深入了解一下这些API。了解如何将大量的API组合在一起，形成一致的编程接口是非常重要的。我们还将学习在遇到挑战时，如何找到相关的代码和文档。
- en: In this section, we are going to discuss how the major clouds define APIs and
    produce **Software Development Kits** (**SDKs**) for programming against the cloud
    APIs. We will learn where to find these SDKs, and where to find documentation
    about the APIs and SDKs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论主要云服务如何定义API，并为云API编程提供**软件开发工具包**（**SDK**）。我们将了解在哪里可以找到这些SDK，以及如何查找API和SDK的文档。
- en: We will also learn about identity, **Role-Based Access Control** (**RBAC**),
    and **resource hierarchy** in Microsoft Azure. Finally, we'll create and log in
    to a free Azure account, which we will use in the subsequent sections to program
    the cloud.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习关于身份、**基于角色的访问控制**（**RBAC**）以及**资源层级**的知识，特别是在微软Azure中。最后，我们将创建并登录一个免费的Azure账户，在后续章节中我们将使用它来进行云编程。
- en: A background on cloud APIs and SDKs
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云API和SDK的背景知识
- en: As we discussed in the previous section, cloud service providers expose APIs
    for management of and access to hundreds of services, spread across a vast number
    of regions. These APIs are commonly implemented using **Representational State
    Transfer** (**REST**) or **Google Remote Procedure Call** (**gRPC**). Within each
    cloud service provider, there is likely an equal number of engineering teams building
    these APIs. It is imperative to provide a consistent representation of resources
    in these APIs so that, when viewed as a whole, each service provides similar behavior.
    Each cloud service provider takes its own approach to this problem. For example,
    at Microsoft Azure, the rule for defining REST APIs is codified by the **Microsoft
    Azure REST API Guidelines** ([https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md)).
    These rules provide guidance to service teams.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中讨论的那样，云服务提供商会暴露用于管理和访问数百个服务的 API，这些服务分布在众多区域内。这些 API 通常采用 **表述性状态转移**
    (**REST**) 或 **谷歌远程过程调用** (**gRPC**) 实现。在每个云服务提供商内部，很可能有同等数量的工程团队负责构建这些 API。为了提供一致的资源表示，至关重要的是这些
    API 在整体上能为每个服务提供相似的行为。每个云服务提供商在解决这个问题时都有自己的方法。例如，在微软 Azure 中，定义 REST API 的规则由
    **微软 Azure REST API 指南**（[https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md)）明确规定。这些规则为服务团队提供了指导。
- en: Developers don't usually use cloud APIs directly via HTTP but rather through
    the use of SDKs. These are collections of libraries that provide access to the
    APIs for a given language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者通常不会直接通过 HTTP 使用云 API，而是通过使用 SDK。这些 SDK 是一组库，提供了对特定编程语言的 API 访问。
- en: For example, Azure ([https://github.com/Azure/azure-sdk-for-go](https://github.com/Azure/azure-sdk-for-go)),
    AWS (https://github.com/aws/aws-sdk-go), and Google ([https://github.com/googleapis/google-api-go-client](https://github.com/googleapis/google-api-go-client))
    all have Go SDKs for their clouds and many other languages. These SDKs do their
    best to eliminate the boilerplate code needed for programmatically accessing clouds'
    APIs, simplifying what the developer needs to write to program against them. Besides
    the documentation published by cloud providers, always remember that GoDocs are
    your friend. For example, the GoDocs for the Azure Blob storage service ([https://github.com/Azure/azure-kusto-go](https://github.com/Azure/azure-kusto-go))
    provide useful information for using the SDK.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Azure ([https://github.com/Azure/azure-sdk-for-go](https://github.com/Azure/azure-sdk-for-go))、AWS
    (https://github.com/aws/aws-sdk-go) 和 Google ([https://github.com/googleapis/google-api-go-client](https://github.com/googleapis/google-api-go-client))
    都为它们的云服务提供了 Go SDK 以及多种其他语言的 SDK。这些 SDK 力求消除访问云 API 所需的样板代码，简化开发者编写与之交互的程序代码。除了云服务提供商发布的文档外，始终记得
    GoDocs 是你的朋友。例如，Azure Blob 存储服务的 GoDocs ([https://github.com/Azure/azure-kusto-go](https://github.com/Azure/azure-kusto-go))
    提供了使用该 SDK 的有用信息。
- en: These SDKs, for the most part, are generated based on machine-readable API specifications.
    When you have hundreds of services and multiple languages, it will not scale well
    to have an enormous number of humans writing SDKs by hand. Each cloud solves this
    problem in its own way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 SDK 大多数是基于机器可读的 API 规范生成的。当你拥有数百个服务和多种编程语言时，依靠大量人工编写 SDK 无法有效扩展。每个云服务提供商都有自己解决这个问题的方法。
- en: For example, Microsoft Azure generates almost all of the Azure API reference
    documentation ([https://docs.microsoft.com/en-us/rest/api/azure/](https://docs.microsoft.com/en-us/rest/api/azure/))
    and SDKs using OpenAPI specifications in the Azure REST API Specs repository ([https://github.com/Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs)).
    The entire process for producing documentation and generating SDKs is hosted on
    GitHub and powered by open source tools such as the AutoRest code generator ([https://github.com/Azure/autorest](https://github.com/Azure/autorest)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，微软 Azure 几乎所有的 Azure API 参考文档（[https://docs.microsoft.com/en-us/rest/api/azure/](https://docs.microsoft.com/en-us/rest/api/azure/)）和
    SDK 都是使用 Azure REST API 规范库中的 OpenAPI 规范生成的（[https://github.com/Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs)）。生成文档和
    SDK 的整个过程托管在 GitHub 上，并由 AutoRest 代码生成器等开源工具提供支持（[https://github.com/Azure/autorest](https://github.com/Azure/autorest)）。
- en: Fun Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 趣味提示
- en: One of this book's authors, David Justice, established this process at Azure
    and had the first commit to the Azure REST API Specs repository ([https://github.com/Azure/azure-rest-api-specs/commit/8c42e6392618a878d5286b8735b99bbde693c0a2](https://github.com/Azure/azure-rest-api-specs/commit/8c42e6392618a878d5286b8735b99bbde693c0a2)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其中一位作者 David Justice 在 Azure 建立了这一过程，并首次提交了 Azure REST API 规格仓库的代码（[https://github.com/Azure/azure-rest-api-specs/commit/8c42e6392618a878d5286b8735b99bbde693c0a2](https://github.com/Azure/azure-rest-api-specs/commit/8c42e6392618a878d5286b8735b99bbde693c0a2)）。
- en: Microsoft Azure identity, RBAC, and resource hierarchy
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Microsoft Azure 身份、RBAC 和资源层次结构
- en: To prepare us for interacting with the Azure API, we need to understand some
    basics – identity, RBAC, and resource hierarchy. **Identity** establishes the
    user, or principal, interacting with the API. RBAC defines what the identity can
    do within the API. The resource hierarchy describes the relationship between the
    resources in the Azure cloud. RBAC roles and rights describe what a principal
    can do with a given resource or resource hierarchy. For example, a user can be
    assigned the contributor rights to an Azure subscription and be able to mutate
    resources within that subscription.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备与 Azure API 进行交互，我们需要了解一些基础知识——身份、RBAC 和资源层次结构。**身份**确定了与 API 交互的用户或主体。RBAC
    定义了身份在 API 内可以做什么。资源层次结构描述了 Azure 云中资源之间的关系。RBAC 角色和权限描述了主体可以对给定的资源或资源层次结构做什么。例如，用户可以被分配
    Azure 订阅的贡献者权限，从而能够修改该订阅中的资源。
- en: Identities in Azure live in **Azure Active Directory** (**AAD**). This is an
    enterprise identity and access management service. It provides single sign-on,
    multifactor authentication, and conditional access, among other features. Identities
    in AAD reside within one or more tenants. Tenants contain multiple identities.
    Identities can be user identities, which represent humans and have interactive
    authentication flows, or they can be service principals, which represent non-human
    identities such as applications that do not have interactive authentication flows.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 中的身份存储在**Azure Active Directory**（**AAD**）中。这是一个企业身份与访问管理服务，提供单点登录、多因素认证和条件访问等功能。AAD
    中的身份存在于一个或多个租户中，租户包含多个身份。身份可以是用户身份，表示人类，并具有交互式身份验证流程，或者可以是服务主体，表示非人类身份，如没有交互式身份验证流程的应用程序。
- en: The root of resources in Azure is an Azure subscription. A subscription is a
    logical container that contains Azure resource groups. Each resource such as a
    virtual machine, storage account or virtual network, resides within a resource
    group. A resource group is a logical entity that associates multiple Azure resources
    so that you can manage them as a single entity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 中资源的根源是 Azure 订阅。订阅是一个逻辑容器，包含 Azure 资源组。每个资源，如虚拟机、存储账户或虚拟网络，都位于某个资源组内。资源组是一个逻辑实体，将多个
    Azure 资源关联在一起，方便你将它们作为一个整体进行管理。
- en: Identities are granted RBAC roles and rights to interact with Azure subscriptions
    and resources alike. You can think of AAD and Azure as separate systems that are
    bound together by RBAC rights and roles. We will not dive deeply into each RBAC
    role or right, but you can find more information about them in the Azure built-in
    roles documentation ([https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles](https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 身份会被授予 RBAC 角色和权限，以便与 Azure 订阅和资源进行交互。你可以将 AAD 和 Azure 看作是两个由 RBAC 权限和角色绑定在一起的独立系统。我们不会深入探讨每个
    RBAC 角色或权限，但你可以在 Azure 内置角色文档中找到更多信息（[https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles](https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles)）。
- en: Now that we have some basic understanding of the cloud we will be working in,
    let's get started.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对将要使用的云环境有了一些基本了解，接下来我们开始吧。
- en: Creating an Azure account and accessing the API
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Azure 账户并访问 API
- en: To run the rest of the examples in this chapter, you will need an Azure account.
    If you do not have an Azure account, you can sign up for a free account with $200
    of Azure credits ([https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章其余的示例，你需要一个 Azure 账户。如果你没有 Azure 账户，你可以注册一个免费账户，并获得 200 美元的 Azure 积分（[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)）。
- en: 'Once you have an account, log in with the Azure CLI:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了账户，使用 Azure CLI 登录：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command will log you into your Azure account and set the default context
    for your primary Azure subscription. By default, when you create an Azure account,
    your identity will be granted the `owner` role in the subscription. The `owner`
    role grants full access to manage all resources, including the ability to assign
    roles in Azure RBAC. To see what subscription is active, run the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将登录到您的 Azure 账户，并为您的主 Azure 订阅设置默认上下文。默认情况下，当您创建 Azure 账户时，您的身份将被授予订阅中的 `owner`
    角色。`owner` 角色授予完全访问权限来管理所有资源，包括在 Azure RBAC 中分配角色的能力。要查看当前活动的订阅，请运行以下命令：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command output shows the name of the subscription and other details
    about the current context of the Azure CLI. In the following command, we will
    use the `az` CLI to directly interact with the Azure API:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出显示了订阅的名称以及当前 Azure CLI 上下文的其他详细信息。在接下来的命令中，我们将使用 `az` CLI 直接与 Azure API
    进行交互：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding command will list the subscriptions your identity has access to
    via RBAC rights. Note that as part of the Azure REST API guidelines, all Azure
    APIs must be used with an `api-version` query parameter. This is enforced to ensure
    that API consumers can always rely on the stability of the request and response
    format for a specified `api-version`. The APIs are updated often, and without
    specifying the `api-version` query parameter of a given API, a consumer would
    possibly be subject to breaking changes in the API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将列出您的身份通过 RBAC 权限访问的订阅。请注意，作为 Azure REST API 指南的一部分，所有 Azure API 必须使用 `api-version`
    查询参数。这是强制性的，确保 API 消费者始终可以依赖于请求和响应格式的稳定性。API 更新频繁，如果没有指定某个 API 的 `api-version`
    查询参数，消费者可能会面临 API 的重大变化。
- en: 'Next, let''s run the same request using the `debug` flag:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `debug` 标志运行相同的请求：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Executing any command with the Azure CLI using `--debug` will output the HTTP
    request details, showing output containing something similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure CLI 执行任何命令时，添加`--debug`标志将输出 HTTP 请求的详细信息，显示类似以下内容的输出：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This output is incredibly useful for seeing what was sent to the Azure API in
    HTTP. Also, note that the URI, `https://management.azure.com/...`, corresponds
    to **Azure Resource Manager** (**ARM**). ARM is a composite service composed of
    resource provider services for each resource in Azure and is responsible for mutating
    resources in it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出对于查看发送到 Azure API 的 HTTP 内容非常有用。另外，注意 URI `https://management.azure.com/...`
    对应于**Azure 资源管理器**（**ARM**）。ARM 是由每个 Azure 资源的资源提供服务组成的复合服务，负责在其中变更资源。
- en: In this section, we learned about how the major clouds define APIs and produce
    SDKs for the APIs. We also learned specifically about Azure identities, RBAC,
    and resource hierarchies. This information may be specific to Azure, but all major
    clouds follow the same pattern. Once you learn how one of the clouds approaches
    **Identity and Access Management** (**IAM**), it's roughly transferable to other
    clouds. Lastly, we signed into an Azure account for use in subsequent sections
    and learned how to directly access the Azure REST API through the Azure CLI.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们了解了主要云平台如何定义 API 并为 API 提供 SDK。我们还特别学习了 Azure 身份、RBAC 和资源层次结构。尽管这些信息可能特定于
    Azure，但所有主要云平台遵循相同的模式。一旦你了解了某个云平台如何处理**身份与访问管理**（**IAM**），它的大致方法也可以迁移到其他云平台。最后，我们登录到
    Azure 账户，供后续章节使用，并学习了如何通过 Azure CLI 直接访问 Azure REST API。
- en: In the next section, we will use the Azure SDK for Go to mutate cloud infrastructure.
    Let's get started on programming the Azure cloud with Go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将使用 Azure SDK for Go 来变更云基础设施。让我们开始用 Go 编程操作 Azure 云。
- en: Building infrastructure using Azure Resource Manager
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure 资源管理器构建基础设施
- en: Cloud APIs are bifurcated into two categories, the management plane and the
    data plane. The management plane is an API that controls the creation, deletion,
    and mutation of infrastructure. The data plane is an API exposed by provisioned
    infrastructure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 云 API 分为两类：管理平面和数据平面。管理平面是一个控制基础设施创建、删除和变更的 API。数据平面是由配置好的基础设施暴露的 API。
- en: For example, the management plane would be used to create a SQL database. The
    data plane for the SQL database resource would be the SQL protocol for manipulating
    data and structure within the database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，管理平面将用于创建 SQL 数据库。SQL 数据库资源的数据平面则是用于操作数据库内数据和结构的 SQL 协议。
- en: The management plane is serviced by the cloud resource API, and the data plane
    is serviced by the API exposed by the provisioned service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 管理平面由云资源 API 提供服务，数据平面由已配置服务暴露的 API 提供服务。
- en: In this section, we will learn how to use the Azure SDK for Go to provision
    infrastructure in Azure. We will learn how to create and destroy resource groups,
    virtual networks, subnets, public IPs, virtual machines, and databases. The goal
    of this section is to build awareness of the Azure Go SDK and how to interact
    with ARM.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Azure Go SDK 在 Azure 中配置基础设施。我们将学习如何创建和销毁资源组、虚拟网络、子网、公有 IP、虚拟机和数据库。本节的目标是让大家熟悉
    Azure Go SDK 以及如何与 ARM 进行交互。
- en: Azure SDK for Go
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure Go SDK
- en: As we discussed in the previous section, cloud SDKs simplify the interaction
    between a given language and a cloud provider's API. In the case of Azure, we
    will be using the Azure SDK for Go ([https://github.com/Azure/azure-sdk-for-go/](https://github.com/Azure/azure-sdk-for-go/))
    to interact with the Azure APIs. Specifically, we'll use the latest edition of
    the SDK ([https://github.com/Azure/azure-sdk-for-go#management-new-releases](https://github.com/Azure/azure-sdk-for-go#management-new-releases)),
    which has been redesigned to follow the Azure design guidelines for Go ([https://azure.github.io/azure-sdk/golang_introduction.html](https://azure.github.io/azure-sdk/golang_introduction.html)).
    For the latest information about packages and docs, be sure to check out the Azure
    SDK Releases page ([https://azure.github.io/azure-sdk/releases/latest/mgmt/go.html](https://azure.github.io/azure-sdk/releases/latest/mgmt/go.html)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中讨论的，云 SDK 简化了指定语言与云服务提供商 API 之间的交互。对于 Azure，我们将使用 Azure Go SDK（[https://github.com/Azure/azure-sdk-for-go/](https://github.com/Azure/azure-sdk-for-go/)）来与
    Azure API 进行交互。具体来说，我们将使用该 SDK 的最新版本（[https://github.com/Azure/azure-sdk-for-go#management-new-releases](https://github.com/Azure/azure-sdk-for-go#management-new-releases)），该版本已经重新设计，以遵循
    Azure 为 Go 语言制定的设计指南（[https://azure.github.io/azure-sdk/golang_introduction.html](https://azure.github.io/azure-sdk/golang_introduction.html)）。有关最新的包和文档信息，请务必查看
    Azure SDK 发布页面（[https://azure.github.io/azure-sdk/releases/latest/mgmt/go.html](https://azure.github.io/azure-sdk/releases/latest/mgmt/go.html)）。
- en: The code for this section is located in the GitHub code folder for this chapter
    [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的代码位于 GitHub 的本章代码文件夹中：[https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15)。
- en: Setting up your local environment
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置本地环境
- en: 'To run the code for this section, you will need to set up a `.env` file. Run
    the following commands from the `./chapter/15` directory of the repository:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本节的代码，您需要设置一个 `.env` 文件。在仓库的 `./chapter/15` 目录下运行以下命令：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will create a `.ssh` directory in `./chapter/15`, generate an SSH
    key pair within that directory, and ensure that proper permissions are set on
    the key pair.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在 `./chapter/15` 中创建一个 `.ssh` 目录，在该目录下生成一个 SSH 密钥对，并确保对该密钥对设置了正确的权限。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding command creates an SSH key that does not have a passphrase. We
    are only using this key pair as an example. You should provide a strong passphrase
    for real-world usage.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会创建一个没有密码的 SSH 密钥。我们仅使用这个密钥对作为示例。在实际使用中，您应该为密钥设置强密码。
- en: 'Next, let''s set up a local `.env` file that we will use to store environmental
    variables used in the examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置一个本地的 `.env` 文件，用于存储示例中使用的环境变量：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, this command will create an`.env` file that contains two environment variables,
    `AZURE_SUBSCRIPTION_ID` and `SSH_PUBLIC_KEY_PATH`. We derive the value for the
    Azure subscription ID from the Azure CLI's current active subscription.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个命令将创建一个 `.env` 文件，文件中包含两个环境变量，`AZURE_SUBSCRIPTION_ID` 和 `SSH_PUBLIC_KEY_PATH`。我们通过
    Azure CLI 的当前活动订阅来推导出 Azure 订阅 ID 的值。
- en: Now that we have set up our local environment, let's build an `cloud-init` provisioning
    script and provide access using SSH via a public IP.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了本地环境，接下来构建一个 `cloud-init` 配置脚本，并通过公有 IP 提供 SSH 访问。
- en: Building an Azure virtual machine
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 Azure 虚拟机
- en: 'Let''s get started by running the example, and then we''ll delve into the code
    for building the infrastructure. To run the example, run the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从运行示例开始，然后再深入研究构建基础设施的代码。要运行示例，请执行以下命令：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After running `go run ./cmd/compute/main.go`, you should see something similar
    to what is shown in the previous command block. As you can see from the output,
    the program built several bits of infrastructure, including an Azure resource
    group, network security group, virtual network, and virtual machine. We'll discuss
    every piece of infrastructure in more detail soon.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `go run ./cmd/compute/main.go` 后，你应该看到与前一个命令块中显示的类似的内容。从输出中可以看到，程序构建了多个基础设施组件，包括一个
    Azure 资源组、网络安全组、虚拟网络和虚拟机。稍后我们将更详细地讨论这些基础设施的每个部分。
- en: As the output states, you can also use SSH to access the virtual machine as
    described in the output. We'll use this to explore the provisioned state of the
    virtual machine to confirm that the `cloud-init` provisioning script ran as expected.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如输出所示，你还可以使用 SSH 访问虚拟机，具体操作见输出内容。我们将使用此方法来检查虚拟机的预配置状态，以确认 `cloud-init` 配置脚本是否按预期运行。
- en: 'If you visit the Azure portal, you should see the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 Azure 门户，应该能看到以下内容：
- en: '![Figure 15.1 – The Azure portal virtual machine infrastructure'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.1 – Azure 门户虚拟机基础设施'
- en: '](img/B17626_15_001.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_15_001.jpg)'
- en: Figure 15.1 – The Azure portal virtual machine infrastructure
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – Azure 门户虚拟机基础设施
- en: In the preceding screenshot, you can see the resource group as well as all of
    the infrastructure created. Next, let's look at the code that provisioned this
    infrastructure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到资源组以及所有已创建的基础设施。接下来，我们来看看为这些基础设施提供服务的代码。
- en: Provisioning Azure infrastructure using Go
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Go 配置 Azure 基础设施
- en: In these examples, you will see how to build Azure API clients, probe for credentials
    for accessing APIs, and mutate infrastructure. Many of these examples use abbreviated
    error-handling behavior to keep the code as concise as possible for illustrative
    purposes. `panic` is not your friend. Please wrap and bubble your errors as appropriate.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，你将看到如何构建 Azure API 客户端，查询用于访问 API 的凭证，并修改基础设施。这些示例中的许多使用了简化的错误处理方式，以使代码尽可能简洁，便于说明。`panic`
    不是你的朋友。请根据需要适当地包装和传递错误。
- en: 'Let''s start with the entry point of `go run ./cmd/compute/main.go` and learn
    how to use Go to provision cloud infrastructure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `go run ./cmd/compute/main.go` 的入口点开始，学习如何使用 Go 来配置云基础设施：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we load environment variables in the local `.env` file
    using `godotenv.Load()`. In `main`, we create a new `VirtualMachineFactory` to
    manage the creation and deletion of Azure infrastructure. Once the infrastructure
    is created in `factory.CreateVirtualMachineStack`, we print the SSH connection
    details and prompt for user confirmation to delete the infrastructure stack.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `godotenv.Load()` 加载本地 `.env` 文件中的环境变量。在 `main` 函数中，我们创建一个新的 `VirtualMachineFactory`
    来管理 Azure 基础设施的创建和删除。基础设施在 `factory.CreateVirtualMachineStack` 中创建后，我们打印出 SSH
    连接详情，并提示用户确认是否删除基础设施堆栈。
- en: 'Next, let''s dive into the VM factory and see what is included in the VM stack:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入了解虚拟机工厂，看看虚拟机堆栈中包含了哪些内容：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code defines the structure of `VirtualMachineFactory`, which is responsible
    for the creation of and access to the Azure SDK API clients. We instantiate those
    clients using the `NewVirtualMachineFactory` func, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了 `VirtualMachineFactory` 的结构，它负责创建和访问 Azure SDK API 客户端。我们使用 `NewVirtualMachineFactory`
    函数来实例化这些客户端，如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code builds a new default Azure identity credential. This credential is
    used to authenticate the client to the Azure APIs. By default, this credential
    will probe multiple sources for an identity to use. The default credential will
    probe for environment variables first, then it will attempt to use an Azure managed
    identity ([https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview](https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview)),
    and finally, it will fall back to using the Azure CLI's user identity. For this
    example, we are relying on the Azure CLI identity to interact with the Azure APIs.
    This is convenient for development but should not be used for a deployed application
    or script. Non-interactive authentication requires either an Azure service principal
    ([https://docs.microsoft.com/en-us/azure/active-directory/develop/app-objects-and-service-principals](https://docs.microsoft.com/en-us/azure/active-directory/develop/app-objects-and-service-principals))
    or an Azure managed identity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码构建了一个新的默认 Azure 身份凭证。该凭证用于验证客户端对 Azure API 的身份。默认情况下，该凭证会检查多个来源以寻找可用的身份。默认凭证首先会检查环境变量，然后尝试使用
    Azure 托管身份（[https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview](https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview)），最后，如果没有找到身份，则会回退到使用
    Azure CLI 的用户身份。对于本示例，我们依赖 Azure CLI 身份与 Azure API 交互。这对开发非常方便，但不应在已部署的应用程序或脚本中使用。非交互式身份验证需要使用
    Azure 服务主体（[https://docs.microsoft.com/en-us/azure/active-directory/develop/app-objects-and-service-principals](https://docs.microsoft.com/en-us/azure/active-directory/develop/app-objects-and-service-principals)）或
    Azure 托管身份。
- en: The VM factory builds each of the Azure API clients using `subscriptionID`,
    the credential, and the `New*` function for each of the clients. `BuildClient()`
    builds each client.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: VM 工厂使用 `subscriptionID`、凭证以及每个客户端的 `New*` 函数构建每个 Azure API 客户端。`BuildClient()`
    构建每个客户端。
- en: 'Now that we know how credentials and the API clients are instantiated, let''s
    dive into the creation of infrastructure in `CreateVirtualMachineStack`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了如何实例化凭证和 API 客户端，接下来让我们深入了解 `CreateVirtualMachineStack` 中的基础设施创建：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we created the idea of a stack – a collection of related
    infrastructure. We created a new stack with a given location, a human-readable
    name, and the contents of the SSH public key path. Subsequently, we created each
    of the Azure resources needed to create a VM with public SSH access.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个堆栈的概念——一组相关的基础设施。我们使用给定的位置、一个人类可读的名称和 SSH 公钥路径的内容创建了一个新的堆栈。随后，我们创建了每个
    Azure 资源，以便为虚拟机提供公共 SSH 访问权限。
- en: 'Let''s explore each of the `create` and `get` funcs in `CreateVirtualMachineStack`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨一下 `CreateVirtualMachineStack` 中的 `create` 和 `get` 函数：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, `createResourceGroup` calls `CreateOrUpdate` on `groupsClient`
    to create an Azure resource group in the specified location. An Azure resource
    group is a logical container for Azure resources. We will use the resource group
    as a container for the rest of our resources.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`createResourceGroup` 在 `groupsClient` 上调用 `CreateOrUpdate`，在指定位置创建一个
    Azure 资源组。Azure 资源组是 Azure 资源的逻辑容器。我们将使用这个资源组作为其余资源的容器。
- en: 'Next, let''s dive into the network security group creation function, `createSecurityGroup`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入了解网络安全组创建函数 `createSecurityGroup`：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we built an Azure network security group, which contains
    a single security rule to allow network traffic on port `22`, enabling SSH access
    for the VM. Note that rather than calling `CreateOrUpdate`, we call `BeginCreateOrUpdate`,
    which issues `PUT` or `PATCH` to the Azure API and starts a long-running operation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们构建了一个 Azure 网络安全组，该安全组包含一个单独的安全规则，允许在端口 `22` 上的网络流量，从而为虚拟机启用 SSH 访问。请注意，我们调用的是
    `BeginCreateOrUpdate`，而不是 `CreateOrUpdate`，后者会向 Azure API 发送 `PUT` 或 `PATCH` 请求，并启动一个长期运行的操作。
- en: A long-running operation in Azure is one that – once the initial mutation is
    accepted –executes until it reaches a terminal state. For example, when creating
    a network security group, the API receives the initial mutation and then starts
    to build the infrastructure. After the infrastructure is ready, the API will indicate
    it is completed through the operation state or the provisioning state. `poller`
    takes care of following the long-running operation to completion. In `HandleErrPoller`,
    we follow the polling to completion and return the final state of the resource.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中，长时间运行的操作是指—在初始变更被接受后—执行直到到达终态。例如，在创建网络安全组时，API接收初始变更，然后开始构建基础设施。基础设施构建完成后，API会通过操作状态或配置状态表示完成。`poller`负责跟踪这个长时间运行的操作直到完成。在`HandleErrPoller`中，我们跟踪轮询直到完成，并返回资源的最终状态。
- en: 'Next, let''s explore the creation of the virtual network via `createVirtualNetwork`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过`createVirtualNetwork`来探讨虚拟网络的创建：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code block, we built an Azure virtual network for our VM. The
    virtual network is set up with a `10.0.0.0/16` `10.0.0.0/24` CIDR. The subnet
    references the network security group we built in the previous code block, which
    causes the rules in the network security group to be enforced on the subnet.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个代码块中，我们为虚拟机构建了一个Azure虚拟网络。该虚拟网络的CIDR设置为`10.0.0.0/16` `10.0.0.0/24`。子网引用了我们在前一个代码块中构建的网络安全组，这导致网络安全组中的规则会被强制执行在子网上。
- en: 'Now that we have built the networking for our VM, let''s build it via `createVirtualMachine`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为虚拟机构建好了网络，接下来让我们通过`createVirtualMachine`来构建虚拟机：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is not much to show for `createVirtualMachine()`. As you can see, the
    same pattern of resource creation through a long-running API invocation is applied
    in this code. The interesting bits are in `linuxVM()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`createVirtualMachine()`并没有太多可展示的内容。如您所见，创建资源的相同模式通过长时间运行的API调用应用在这段代码中。值得注意的是在`linuxVM()`中的一些细节：'
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In `linuxVM`, we specify the location, name, and properties of the VM. In the
    properties, we specify the type of hardware we'd like to provision. In this case,
    we are provisioning a Standard D3v2 (you can read more about it at [https://docs.microsoft.com/en-us/azure/virtual-machines/dv3-dsv3-series](https://docs.microsoft.com/en-us/azure/virtual-machines/dv3-dsv3-series))
    hardware **Stock-Keeping Unit** (**SKU**).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`linuxVM`中，我们指定了虚拟机的位置、名称以及属性。在属性中，我们指定了希望配置的硬件类型。在这种情况下，我们配置的是Standard D3v2（您可以在[https://docs.microsoft.com/en-us/azure/virtual-machines/dv3-dsv3-series](https://docs.microsoft.com/en-us/azure/virtual-machines/dv3-dsv3-series)）硬件**库存单位**（**SKU**）。
- en: 'We also specify our `StorageProfile`, which is used to specify the OS as well
    as the data disks we''d like attached to the VM. In this case, we specify that
    we''d like to run the latest version of Ubuntu 18.04\. Both `NetworkProfile` and
    `OSProfile` are a little too complex to include in this function, so let''s explore
    them individually in the following code block:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还指定了我们的`StorageProfile`，用于指定操作系统以及我们希望附加到虚拟机的数据磁盘。在这个例子中，我们指定了要运行最新版本的Ubuntu
    18.04。由于`NetworkProfile`和`OSProfile`的复杂性太高，无法在此函数中包含，所以我们将在以下代码块中分别探讨它们：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `networkProfile()`, we create `NetworkProfile`, which specifies that the
    VM should have a single network interface using IPv4 and be exposed via a public
    IP. The network interface should be allocated on the subnet that we created in
    `createVirtualNetwork()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`networkProfile()`中，我们创建了`NetworkProfile`，它指定虚拟机应该使用IPv4并通过公共IP进行暴露，同时该虚拟机应只有一个网络接口。网络接口应分配到我们在`createVirtualNetwork()`中创建的子网。
- en: 'Next, let''s explore the `OSProfile` configuration via `linuxOSProfile()` in
    the following code block:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过以下代码块探讨`OSProfile`配置，具体通过`linuxOSProfile()`进行配置：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In `linuxOSProfile`, we create an `OSProfile`, which includes details such as
    the admin username, computer name, and SSH configuration. Take note of the `CustomData`
    field used for specifying the Base64-encoded `cloud-init` YAML, which is used
    to run the initial configuration of the VM.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`linuxOSProfile`中，我们创建了一个`OSProfile`，其中包括了管理员用户名、计算机名以及SSH配置等细节。请注意，`CustomData`字段用于指定Base64编码的`cloud-init`
    YAML，该YAML文件用于执行虚拟机的初始配置。
- en: 'Let''s explore what we are doing in the `cloud-init` YAML:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨一下在`cloud-init` YAML文件中我们正在做什么：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the VM is created, the following `cloud-init` instructions are executed:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦虚拟机（VM）创建完成，以下的`cloud-init`指令将被执行：
- en: First, the packages on the Ubuntu machine are upgraded.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，升级Ubuntu机器上的软件包。
- en: Next, the `nginx` and `golang` packages are installed via the **Advanced Package
    Tool** (**APT**).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`nginx`和`golang`包通过**高级包工具**（**APT**）安装。
- en: Finally, `runcmd echos "hello world"`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`runcmd echos "hello world"`。
- en: '`cloud-init` is super-useful for bootstrapping VMs. If you have not used it
    previously, I highly recommend exploring it further ([https://cloudinit.readthedocs.io/en/latest/](https://cloudinit.readthedocs.io/en/latest/)).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`cloud-init`对于引导虚拟机非常有用。如果你以前没有使用过它，我强烈建议你进一步探索它([https://cloudinit.readthedocs.io/en/latest/](https://cloudinit.readthedocs.io/en/latest/))。'
- en: 'We can verify `cloud-init` executed by accessing the VM using SSH and executing
    commands similar to the following. Remember, your IP address will be different
    than what is shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 SSH 访问虚拟机并执行类似下面的命令来验证`cloud-init`是否执行。记住，你的 IP 地址与这里显示的不同：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, `nginx` and `go` have been installed. You should also see the
    APT mutations and *hello world* in `/var/log/cloud-init-output.log` on the provisioned
    VM.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`nginx`和`go`已经安装。你还应该能在已配置的虚拟机的`/var/log/cloud-init-output.log`中看到 APT
    变更和*hello world*。
- en: You have provisioned and created an Azure VM and related infrastructure! Now,
    let's destroy the entire stack of infrastructure. You should be able to press
    *Enter* in the shell where you are running `go run ./cmd/compute/main.go`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经配置并创建了一个 Azure 虚拟机及相关基础设施！现在，让我们销毁整个基础设施堆栈。你应该能够在运行`go run ./cmd/compute/main.go`的
    shell 中按下*Enter*键。
- en: 'Let''s see what happened when we called `factory.DestroyVirtualMachineStack`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在调用`factory.DestroyVirtualMachineStack`时发生了什么：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In `DestroyVirtualMachineStack`, we simply call `BeginDelete()` on the group's
    client, specifying the resource group name. However, unlike other examples, we
    do not wait for the poller to complete. We send the `DELETE HTTP` request to Azure.
    We do not wait for the infrastructure to be completely deleted; instead, we trust
    that the acceptance of `delete` means that it will eventually reach the deleted
    terminal state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DestroyVirtualMachineStack`中，我们简单地在组的客户端上调用`BeginDelete()`，并指定资源组名称。然而，与其他示例不同，我们并没有等待轮询器完成。我们将`DELETE
    HTTP`请求发送到 Azure。我们不等待基础设施完全删除，而是相信`delete`请求的接受意味着它最终会达到删除的终端状态。
- en: We have now built and cleaned up a stack of infrastructure using the Azure SDK
    for Go. We have learned how to create resource groups, virtual networks, subnets,
    public IPs, and VMs, and how a pattern can be extended to any resource in Azure.
    Additionally, these skills are applicable to each of the major clouds, not just
    Azure. AWS and GCP both have similar concepts and API access patterns.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用 Azure SDK for Go 构建并清理了一堆基础设施。我们学会了如何创建资源组、虚拟网络、子网、公有 IP 和虚拟机，以及如何将这种模式扩展到
    Azure 中的任何资源。此外，这些技能适用于每个主要云平台，不仅仅是 Azure。AWS 和 GCP 也有类似的概念和 API 访问模式。
- en: In the next section, we'll build an Azure Storage account and learn a bit about
    using the data plane of a cloud service by uploading files and then providing
    constrained access to download those files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将构建一个 Azure 存储账户，并通过上传文件然后提供受限访问来下载这些文件，了解如何使用云服务的数据平面。
- en: Using provisioned Azure infrastructure
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用已配置的 Azure 基础设施
- en: In the previous section, we built a stack of computing and networking infrastructure
    to illustrate how to manipulate cloud infrastructure. In this section, we will
    pair a provisioning infrastructure with the Azure control plane and use the infrastructure
    through the provisioned service's data plane.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们构建了一堆计算和网络基础设施来说明如何操作云基础设施。在这一节中，我们将把已配置的基础设施与 Azure 控制平面配对，并通过已配置服务的数据平面使用这些基础设施。
- en: In this section, we are going to build a cloud storage infrastructure. We will
    use Azure Storage to store files and provide constrained access to those files
    via shared access signatures ([https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview)).
    We will learn how to use ARM to fetch account keys and use those keys to provide
    constrained access to storage resources.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将构建一个云存储基础设施。我们将使用 Azure 存储来存储文件，并通过共享访问签名([https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview))为这些文件提供受限访问。我们将学习如何使用
    ARM 获取账户密钥，并使用这些密钥为存储资源提供受限访问。
- en: Building an Azure Storage account
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个 Azure 存储账户
- en: 'Let''s get started by running the example, and then we''ll delve into the code
    for building the infrastructure and using the provisioned storage account. To
    execute the example, run the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过运行示例开始，然后我们将深入研究如何构建基础设施和使用配置的存储账户。要执行示例，请运行以下命令：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see from the previous output, the example creates a resource group
    and a storage account, fetches an account key, and then uploads all of the images
    in `./blobs` to the cloud. Finally, the example prints out URIs for each of the
    images using shared access signatures. If you click on one of those URIs, you
    should be able to download the image we uploaded to the storage account.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在之前的输出中看到的，示例创建了一个资源组和一个存储账户，获取了账户密钥，然后将`./blobs`中的所有图片上传到云端。最后，示例通过共享访问签名打印出每张图片的
    URI。如果你点击其中一个 URI，你应该能够下载我们上传到存储账户中的图片。
- en: What happens when you try to download `img1.jpeg` without the query string –
    for example, using the `https://fallingrain.blob.core.windows.net/jd-imgs/img1.jpeg`
    link? You should get an access denied message.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试在没有查询字符串的情况下下载`img1.jpeg`时会发生什么——例如，使用`https://fallingrain.blob.core.windows.net/jd-imgs/img1.jpeg`链接？你应该会看到访问被拒绝的消息。
- en: Let's see how we can use Azure Storage to upload files and constrain access.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 Azure 存储上传文件并限制访问权限。
- en: Provisioning Azure Storage using Go
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Go 配置 Azure 存储
- en: In this example, we are going to provision an Azure resource group and an Azure
    Storage account. We are using abbreviated error-handling behavior to keep the
    code as concise as possible for illustrative purposes. As I said in the previous
    section, panic is not your friend. Please wrap and bubble your errors as appropriate.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将配置一个 Azure 资源组和一个 Azure 存储账户。为了让代码尽可能简洁以便说明，我们使用了简化的错误处理行为。正如我在上一节所说，panic
    不是你的朋友。请适当包装和抛出错误。
- en: 'Let''s start with the entry point of Go `run ./cmd/storage/main.go`, and learn
    how to use Go to provision the storage account:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Go 的入口点`run ./cmd/storage/main.go`开始，学习如何使用 Go 来配置存储账户：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Similar to the VM infrastructure example in the previous section, we create
    `StorageFactory` using `NewStorageFactory()` and then use it to create and destroy
    the storage stack. In the middle, we call `uploadBlobs()` to upload the image
    files and `printSASUris()` to generate and print shared access signatures for
    each of the uploaded files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于上一节中的虚拟机基础设施示例，我们使用`NewStorageFactory()`创建`StorageFactory`，然后使用它来创建和销毁存储堆栈。在中间，我们调用`uploadBlobs()`上传图片文件，并调用`printSASUris()`为每个上传的文件生成并打印共享访问签名。
- en: 'Let''s start by taking a look at how we provision the storage infrastructure:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看看如何配置存储基础设施：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The storage factory looks similar to `VirtualMachineFactory` from the previous
    section. However, the storage factory only uses the resource group and storage
    clients.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 存储工厂看起来类似于上一节中的`VirtualMachineFactory`。然而，存储工厂只使用资源组和存储客户端。
- en: 'Next, let''s explore `CreateStorageStack()` to see how we create the Azure
    Storage account:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们探索`CreateStorageStack()`，看看我们是如何创建 Azure 存储账户的：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we create a human-readable name for the stack, which
    we will use to name the resource group and the storage account. We then populate
    the stack fields with created resources.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为堆栈创建了一个人类可读的名称，用它来命名资源组和存储账户。然后我们将已创建的资源填充到堆栈字段中。
- en: 'I will not cover `createResourceGroup()`, as it was covered in the previous
    section. However, `createStorageAccount()` and `getPrimaryAccountKey()` are interesting.
    Let''s explore what they do:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我将不会介绍`createResourceGroup()`，因为它已在上一节中讲解过。然而，`createStorageAccount()`和`getPrimaryAccountKey()`很有意思。让我们探讨一下它们的功能：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, `createStorageAccount()` creates a new block blob, with
    premium tier performance, and a locally redundant Azure Storage account. Block
    blobs ([https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs#about-block-blobs](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs#about-block-blobs))
    are optimized for uploading large amounts of data and, as the name implies, are
    broken into blocks of arbitrary size. Locally redundant storage ([https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy#locally-redundant-storage](https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy#locally-redundant-storage))
    means that each block is replicated 3 times within the same data center and is
    guaranteed to provide 99.999999999% (11 nines!) durability over a given year.
    Finally, the premium tier ([https://docs.microsoft.com/en-us/azure/storage/blobs/scalability-targets-premium-block-blobs](https://docs.microsoft.com/en-us/azure/storage/blobs/scalability-targets-premium-block-blobs))
    of Azure Storage indicates that the storage account will be optimized for applications
    that consistently require low latency and high transaction throughput for block
    blob mutations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`createStorageAccount()`创建了一个新的块 blob，具有高级性能层，并且是本地冗余的 Azure 存储帐户。块
    blob ([https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs#about-block-blobs](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs#about-block-blobs))
    优化了大数据量的上传，正如其名称所示，它被分成了任意大小的块。本地冗余存储 ([https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy#locally-redundant-storage](https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy#locally-redundant-storage))
    意味着每个块会在同一个数据中心内复制 3 次，并且在给定的一年内保证提供 99.999999999%（11 个 9！）的耐用性。最后，Azure 存储的高级层级
    ([https://docs.microsoft.com/en-us/azure/storage/blobs/scalability-targets-premium-block-blobs](https://docs.microsoft.com/en-us/azure/storage/blobs/scalability-targets-premium-block-blobs))
    表示存储帐户将针对那些持续需要低延迟和高交易吞吐量的块 blob 变更的应用程序进行优化。
- en: Beyond the configuration of the storage account, provisioning is handled in
    a similar way to the rest of the resources we have provisioned thus far.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储帐户的配置外，其他资源的配置与我们到目前为止配置的资源类似。
- en: 'To generate shared access signatures for uploaded blobs, we need to acquire
    a storage account key that is provisioned when the storage account is created.
    Let''s see how we can request the storage account keys:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成上传 blob 的共享访问签名，我们需要获取一个存储帐户密钥，该密钥是在存储帐户创建时配置的。让我们看看如何请求存储帐户密钥：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this code, we fetch the account keys by calling `ListKeys` on the storage
    client. We return the first account key returned.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们通过在存储客户端上调用`ListKeys`来获取帐户密钥，并返回第一个返回的帐户密钥。
- en: Now that we have provisioned the storage infrastructure and fetched the storage
    account key, we are ready to use the storage service to upload files and provide
    constrained access to the files.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了存储基础设施并获取了存储帐户密钥，我们可以使用存储服务上传文件并提供对文件的受限访问。
- en: Using Azure Storage
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Azure 存储
- en: 'Let''s upload the files in `./blobs` to our storage account with the `uploadBlobs`
    func:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`uploadBlobs`函数将`./blobs`中的文件上传到我们的存储帐户：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, we create a service client to interact with the storage
    service client. With `serviceClient`, we can define a new storage container called
    `jd-imgs`. You can think of a storage container as an entity similar to a directory.
    After specifying the container, we call `create` to request the storage service
    to create the container. Once we have a container, we then iterate over each image
    in the `./blobs` directory and upload them using the block blob client.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个服务客户端来与存储服务客户端进行交互。通过`serviceClient`，我们可以定义一个名为`jd-imgs`的新存储容器。你可以把存储容器看作是一个类似于目录的实体。在指定容器后，我们调用`create`来请求存储服务创建该容器。一旦我们有了容器，我们就可以遍历`./blobs`目录中的每个图像，并使用块
    blob 客户端将它们上传。
- en: 'Until this point, we have been using the Azure CLI identity as our credential
    for interacting with Azure services. However, when we instantiated `serviceClient`,
    we instead began using the Azure Storage account keys to interact with our storage
    account. Let''s take a look at `ServiceClient()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 Azure CLI 身份作为与 Azure 服务交互的凭证。然而，当我们实例化`serviceClient`时，我们开始使用
    Azure 存储帐户密钥与我们的存储帐户进行交互。让我们看看`ServiceClient()`：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we create a new credential using the storage account
    name and the value of the account key. We construct `ServiceClient`, using the
    blob endpoint for the storage account and the newly constructed shared key credential.
    The shared key credential will be used for all clients that derive from the service
    client.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用存储账户名称和账户密钥的值创建了一个新的凭证。我们构建了 `ServiceClient`，使用存储账户的 blob 终结点和新构建的共享密钥凭证。共享密钥凭证将被用于所有从服务客户端派生的客户端。
- en: 'Now that we have uploaded the files as block blobs, let''s see how we can create
    signed URIs to provide constrained access:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将文件上传为块 blob，让我们看看如何创建签名 URI 来提供受限访问：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We construct `ServiceClient` and establish a container client in the preceding
    code block. Then, we iterate over every file within the local `./blobs` directory
    and create a blob client.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码块中构建了 `ServiceClient` 并建立了一个容器客户端。然后，我们遍历本地 `./blobs` 目录中的每个文件，并创建一个
    blob 客户端。
- en: The blob client has a helpful method called `GetSASToken`, which generates a
    shared access token given blob access permissions and a validity time span. In
    our case, we are granting read access that starts immediately and expires in 2
    hours. To create a complete URI to access the blob, we need to combine the blob
    URL and the query string generated by the shared access token. We do that with
    `blobClient.URL()`, `"?"`, and `sasQuery.Encode()`. Now, anyone with the signed
    URI will have access to read the file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: blob 客户端有一个有用的方法，叫做 `GetSASToken`，它会根据 blob 访问权限和有效期生成共享访问令牌。在我们的案例中，我们授予的访问权限是立即生效并在
    2 小时后过期的读取权限。为了创建一个完整的 URI 以访问 blob，我们需要将 blob URL 和共享访问令牌生成的查询字符串组合起来。我们通过 `blobClient.URL()`、`"?"`
    和 `sasQuery.Encode()` 来实现这一点。现在，任何拥有签名 URI 的人都可以访问该文件。
- en: In this final section, we built and used cloud storage infrastructure to store
    files and provide constrained access to those files by using shared access signatures.
    We learned how to fetch account keys and use them to provide constrained access
    to storage resources. Using these skills, you can combine permissions and other
    constraints to tailor access to your needs. Providing constrained access in this
    way is a powerful tool. For example, you can create a write-only URI to a blob
    not yet created, pass the URI to a client, and then have them upload a file without
    having access to any other files in the storage account.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一节中，我们构建并使用了云存储基础设施来存储文件，并通过使用共享访问签名（SAS）提供对这些文件的受限访问。我们学习了如何获取账户密钥，并使用它们来提供对存储资源的受限访问。通过这些技能，你可以结合权限和其他约束来定制访问方式。以这种方式提供受限访问是一个强大的工具。例如，你可以创建一个仅写的
    URI，指向一个尚未创建的 blob，将 URI 传递给客户端，然后让他们上传文件，而无需访问存储账户中的任何其他文件。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Azure Storage is only one service out of hundreds that you can use to build
    applications in the cloud. Each cloud service provider has analogous storage services
    that operate in a similar way. The examples shown in this chapter are specific
    to Microsoft Azure, but they can be easily emulated for other clouds.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 存储仅是你可以用来构建云端应用的数百项服务中的一种。每个云服务提供商都有类似的存储服务，这些服务的操作方式相似。本章中展示的示例特定于 Microsoft
    Azure，但可以轻松地模仿其他云服务。
- en: The Azure Storage example is useful for illustrating the separation between
    the management plane and the data plane of the cloud. If you look closely, you
    can observe a significant similarity in **Create, Read, Update, and Delete** (**CRUD**)
    resource operations using ARM in contrast to interacting with the Azure Storage
    service, container, and blob clients. Resource management is uniform within a
    cloud. The data plane for databases, storage services, and content delivery networks
    is rarely uniform and often exposed through purpose-built APIs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 存储示例有助于说明云管理平面和数据平面之间的区别。如果仔细观察，你会发现 **创建、读取、更新和删除**（**CRUD**）资源操作在使用
    ARM 时与与 Azure 存储服务、容器和 blob 客户端的交互非常相似。云中的资源管理是统一的，而数据库、存储服务和内容分发网络的数据平面则很少统一，通常通过专门构建的
    API 来暴露。
- en: In this chapter, we learned that the cloud is not just someone else's computer.
    The cloud is a planet-scale web of high-security data centers filled with computing,
    networking, and storage hardware. We also learned the fundamentals of identity,
    authentication, and authorization, with specifics drawn from Microsoft Azure.
    We briefly covered Azure RBAC and its relationship with AAD identities. Finally,
    we learned how to provision and use cloud resources using Microsoft Azure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了云不仅仅是“别人的计算机”。云是一个跨越行星规模的高安全性数据中心网络，里面充满了计算、网络和存储硬件。我们还学习了身份、认证和授权的基础知识，并结合了
    Microsoft Azure 的具体实例。我们简要介绍了 Azure RBAC 及其与 AAD 身份的关系。最后，我们学习了如何使用 Microsoft
    Azure 配置和使用云资源。
- en: You should be able to take what you learned here and apply it to provisioning
    and using cloud services to achieve your goals. These skills were focused on Microsoft
    Azure, but the skills learned here are easily transferred to the AWS or Google
    clouds.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够将你在这里学到的知识应用到云服务的配置和使用中，以实现你的目标。这些技能主要集中在 Microsoft Azure，但在这里学到的技能很容易转移到
    AWS 或 Google 云平台。
- en: In the next chapter, we're going to explore what happens when software operates
    in less-than-perfect conditions. We will learn to design for chaos.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨当软件在不完美条件下运行时会发生什么。我们将学习如何为混乱设计。
