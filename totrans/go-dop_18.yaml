- en: 'Chapter 15: Programming the Cloud'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've probably heard the saying *the cloud is just someone else's computer*.
    While it is somewhat true, it is also wildly off target. Cloud service providers
    offer virtual machines running in their data centers that you can use in exchange
    for money, so in that way, you are using someone else's computer. However, it
    misses the bigger picture of what a cloud service provider is. A cloud service
    provider is a collection of hundreds of application-hosting, data, compliance,
    and computing infrastructure services that run in hundreds of data centers across
    the globe and are exposed through a fully programmable API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to interact with a cloud API using Microsoft
    Azure. We'll start by learning a bit about the nature of the APIs, including how
    they are described and where to find additional documentation about them. We'll
    learn the fundamentals of identity, authentication, and authorization. We'll then
    apply what we have learned in a set of examples using the Azure SDK for Go to
    build cloud infrastructure and utilize other cloud services.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be equipped with the knowledge to work effectively
    with Microsoft Azure and will have gained the transferable skills to work with
    other cloud service providers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: What is the cloud?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basics of the Azure APIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building infrastructure using Azure Resource Manager
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using provisioned Azure infrastructure
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will require the following tools:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Go
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Azure CLI: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Code files downloaded from GitHub: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the cloud?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The scale of capital investment in the Amazon, Microsoft, and Google cloud physical
    computing infrastructure is monumental. Imagine the investment needed to build
    200+ physical data centers with multiple redundant power and cooling systems,
    featuring state-of-the-art physical security. These centers are resilient in the
    face of a natural disaster. Even then, you are just scratching the surface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: These data centers require one of the largest interconnected networks on the
    planet to link them together. All of that infrastructure won't function without
    vast amounts of power and cooling, preferably from sustainable sources. For example,
    Azure has been carbon-neutral since 2012 and is committed to being carbon-negative
    by 2030\. When people talk about hyper-scale cloud, they are talking about the
    planet-scale operations of these cloud service providers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Ever wonder what it would be like to visit one of these data centers? For example,
    to access an Azure data center, there are multiple levels of security you must
    go through. You must first request access to the data center and provide a valid
    business justification. If access is granted, when you arrive at the data center's
    permitter access point, you'd notice the panoply of cameras, tall steel fences,
    and concrete surrounding the perimeter. You'd verify your identity and pass to
    the building entrance. At the building entrance, you'd be greeted by security
    officers who will once again verify who you are using two-factor authentication
    with biometrics. Upon passing biometric scanning, they'd guide you to the specific
    section of the data center where you have been approved to operate. As you proceed
    to the data center floor, you'd pass in and out through a full-body metal detection
    screening to ensure that you don't leave with anything you shouldn't. Security
    at these data centers is taken very seriously.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有想过访问这些数据中心会是怎样的体验？例如，要访问Azure的数据中心，你必须通过多个安全层级。你首先需要申请进入数据中心并提供有效的商业理由。如果获得批准，当你到达数据中心的外围访问点时，你会注意到周围有众多摄像头、高大的钢铁围栏以及混凝土围墙。你需要验证身份，并进入建筑物的入口。在建筑物入口，你会遇到安保人员，他们会再次通过双重身份验证（包括生物识别）来确认你的身份。通过生物识别扫描后，他们会引导你进入数据中心的特定区域。在进入数据中心的过程中，你还需要通过全身金属探测器筛查，确保你没有携带不该带出的物品。这些数据中心的安全措施非常严格。
- en: Still think this sounds like *someone else's computer*?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然觉得这像是*别人的电脑*吗？
- en: The physical infrastructure of cloud service providers is awe-inspiring. However,
    we should change our focus from the scale of cloud service provider operations
    to how cloud services are exposed to developers. As we mentioned initially, cloud
    service providers expose the functions of the cloud through APIs, which developers
    can use to manage infrastructure and applications running on the cloud. We can
    use these APIs to build applications that can leverage hyper-scale cloud infrastructure
    to become planet-scale.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商的物理基础设施令人敬畏。然而，我们应该将焦点从云服务提供商的运营规模转向云服务是如何暴露给开发者的。正如我们最初提到的，云服务提供商通过API暴露云的功能，开发者可以使用这些API来管理运行在云上的基础设施和应用程序。我们可以利用这些API构建应用程序，借助超大规模的云基础设施，使其具备全球规模。
- en: Learning the basics of the Azure APIs
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习Azure API的基础知识
- en: Now that we know the path to programming the cloud is through APIs, let's learn
    a bit more about them. It's important to establish some background on how a large
    system of APIs comes together to form a consistent programmatic interface. We
    will also learn where you can find code and documentation when you run into challenges.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，编程云的路径是通过API，让我们深入了解一下这些API。了解如何将大量的API组合在一起，形成一致的编程接口是非常重要的。我们还将学习在遇到挑战时，如何找到相关的代码和文档。
- en: In this section, we are going to discuss how the major clouds define APIs and
    produce **Software Development Kits** (**SDKs**) for programming against the cloud
    APIs. We will learn where to find these SDKs, and where to find documentation
    about the APIs and SDKs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论主要云服务如何定义API，并为云API编程提供**软件开发工具包**（**SDK**）。我们将了解在哪里可以找到这些SDK，以及如何查找API和SDK的文档。
- en: We will also learn about identity, **Role-Based Access Control** (**RBAC**),
    and **resource hierarchy** in Microsoft Azure. Finally, we'll create and log in
    to a free Azure account, which we will use in the subsequent sections to program
    the cloud.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将学习关于身份、**基于角色的访问控制**（**RBAC**）以及**资源层级**的知识，特别是在微软Azure中。最后，我们将创建并登录一个免费的Azure账户，在后续章节中我们将使用它来进行云编程。
- en: A background on cloud APIs and SDKs
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云API和SDK的背景知识
- en: As we discussed in the previous section, cloud service providers expose APIs
    for management of and access to hundreds of services, spread across a vast number
    of regions. These APIs are commonly implemented using **Representational State
    Transfer** (**REST**) or **Google Remote Procedure Call** (**gRPC**). Within each
    cloud service provider, there is likely an equal number of engineering teams building
    these APIs. It is imperative to provide a consistent representation of resources
    in these APIs so that, when viewed as a whole, each service provides similar behavior.
    Each cloud service provider takes its own approach to this problem. For example,
    at Microsoft Azure, the rule for defining REST APIs is codified by the **Microsoft
    Azure REST API Guidelines** ([https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md](https://github.com/microsoft/api-guidelines/blob/vNext/azure/Guidelines.md)).
    These rules provide guidance to service teams.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Developers don't usually use cloud APIs directly via HTTP but rather through
    the use of SDKs. These are collections of libraries that provide access to the
    APIs for a given language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: For example, Azure ([https://github.com/Azure/azure-sdk-for-go](https://github.com/Azure/azure-sdk-for-go)),
    AWS (https://github.com/aws/aws-sdk-go), and Google ([https://github.com/googleapis/google-api-go-client](https://github.com/googleapis/google-api-go-client))
    all have Go SDKs for their clouds and many other languages. These SDKs do their
    best to eliminate the boilerplate code needed for programmatically accessing clouds'
    APIs, simplifying what the developer needs to write to program against them. Besides
    the documentation published by cloud providers, always remember that GoDocs are
    your friend. For example, the GoDocs for the Azure Blob storage service ([https://github.com/Azure/azure-kusto-go](https://github.com/Azure/azure-kusto-go))
    provide useful information for using the SDK.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: These SDKs, for the most part, are generated based on machine-readable API specifications.
    When you have hundreds of services and multiple languages, it will not scale well
    to have an enormous number of humans writing SDKs by hand. Each cloud solves this
    problem in its own way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: For example, Microsoft Azure generates almost all of the Azure API reference
    documentation ([https://docs.microsoft.com/en-us/rest/api/azure/](https://docs.microsoft.com/en-us/rest/api/azure/))
    and SDKs using OpenAPI specifications in the Azure REST API Specs repository ([https://github.com/Azure/azure-rest-api-specs](https://github.com/Azure/azure-rest-api-specs)).
    The entire process for producing documentation and generating SDKs is hosted on
    GitHub and powered by open source tools such as the AutoRest code generator ([https://github.com/Azure/autorest](https://github.com/Azure/autorest)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Fun Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: One of this book's authors, David Justice, established this process at Azure
    and had the first commit to the Azure REST API Specs repository ([https://github.com/Azure/azure-rest-api-specs/commit/8c42e6392618a878d5286b8735b99bbde693c0a2](https://github.com/Azure/azure-rest-api-specs/commit/8c42e6392618a878d5286b8735b99bbde693c0a2)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure identity, RBAC, and resource hierarchy
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare us for interacting with the Azure API, we need to understand some
    basics – identity, RBAC, and resource hierarchy. **Identity** establishes the
    user, or principal, interacting with the API. RBAC defines what the identity can
    do within the API. The resource hierarchy describes the relationship between the
    resources in the Azure cloud. RBAC roles and rights describe what a principal
    can do with a given resource or resource hierarchy. For example, a user can be
    assigned the contributor rights to an Azure subscription and be able to mutate
    resources within that subscription.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Identities in Azure live in **Azure Active Directory** (**AAD**). This is an
    enterprise identity and access management service. It provides single sign-on,
    multifactor authentication, and conditional access, among other features. Identities
    in AAD reside within one or more tenants. Tenants contain multiple identities.
    Identities can be user identities, which represent humans and have interactive
    authentication flows, or they can be service principals, which represent non-human
    identities such as applications that do not have interactive authentication flows.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The root of resources in Azure is an Azure subscription. A subscription is a
    logical container that contains Azure resource groups. Each resource such as a
    virtual machine, storage account or virtual network, resides within a resource
    group. A resource group is a logical entity that associates multiple Azure resources
    so that you can manage them as a single entity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Identities are granted RBAC roles and rights to interact with Azure subscriptions
    and resources alike. You can think of AAD and Azure as separate systems that are
    bound together by RBAC rights and roles. We will not dive deeply into each RBAC
    role or right, but you can find more information about them in the Azure built-in
    roles documentation ([https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles](https://docs.microsoft.com/en-us/azure/role-based-access-control/built-in-roles)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some basic understanding of the cloud we will be working in,
    let's get started.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure account and accessing the API
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run the rest of the examples in this chapter, you will need an Azure account.
    If you do not have an Azure account, you can sign up for a free account with $200
    of Azure credits ([https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have an account, log in with the Azure CLI:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command will log you into your Azure account and set the default context
    for your primary Azure subscription. By default, when you create an Azure account,
    your identity will be granted the `owner` role in the subscription. The `owner`
    role grants full access to manage all resources, including the ability to assign
    roles in Azure RBAC. To see what subscription is active, run the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将登录到您的 Azure 账户，并为您的主 Azure 订阅设置默认上下文。默认情况下，当您创建 Azure 账户时，您的身份将被授予订阅中的 `owner`
    角色。`owner` 角色授予完全访问权限来管理所有资源，包括在 Azure RBAC 中分配角色的能力。要查看当前活动的订阅，请运行以下命令：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The preceding command output shows the name of the subscription and other details
    about the current context of the Azure CLI. In the following command, we will
    use the `az` CLI to directly interact with the Azure API:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出显示了订阅的名称以及当前 Azure CLI 上下文的其他详细信息。在接下来的命令中，我们将使用 `az` CLI 直接与 Azure API
    进行交互：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding command will list the subscriptions your identity has access to
    via RBAC rights. Note that as part of the Azure REST API guidelines, all Azure
    APIs must be used with an `api-version` query parameter. This is enforced to ensure
    that API consumers can always rely on the stability of the request and response
    format for a specified `api-version`. The APIs are updated often, and without
    specifying the `api-version` query parameter of a given API, a consumer would
    possibly be subject to breaking changes in the API.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将列出您的身份通过 RBAC 权限访问的订阅。请注意，作为 Azure REST API 指南的一部分，所有 Azure API 必须使用 `api-version`
    查询参数。这是强制性的，确保 API 消费者始终可以依赖于请求和响应格式的稳定性。API 更新频繁，如果没有指定某个 API 的 `api-version`
    查询参数，消费者可能会面临 API 的重大变化。
- en: 'Next, let''s run the same request using the `debug` flag:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 `debug` 标志运行相同的请求：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Executing any command with the Azure CLI using `--debug` will output the HTTP
    request details, showing output containing something similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Azure CLI 执行任何命令时，添加`--debug`标志将输出 HTTP 请求的详细信息，显示类似以下内容的输出：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This output is incredibly useful for seeing what was sent to the Azure API in
    HTTP. Also, note that the URI, `https://management.azure.com/...`, corresponds
    to **Azure Resource Manager** (**ARM**). ARM is a composite service composed of
    resource provider services for each resource in Azure and is responsible for mutating
    resources in it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该输出对于查看发送到 Azure API 的 HTTP 内容非常有用。另外，注意 URI `https://management.azure.com/...`
    对应于**Azure 资源管理器**（**ARM**）。ARM 是由每个 Azure 资源的资源提供服务组成的复合服务，负责在其中变更资源。
- en: In this section, we learned about how the major clouds define APIs and produce
    SDKs for the APIs. We also learned specifically about Azure identities, RBAC,
    and resource hierarchies. This information may be specific to Azure, but all major
    clouds follow the same pattern. Once you learn how one of the clouds approaches
    **Identity and Access Management** (**IAM**), it's roughly transferable to other
    clouds. Lastly, we signed into an Azure account for use in subsequent sections
    and learned how to directly access the Azure REST API through the Azure CLI.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们了解了主要云平台如何定义 API 并为 API 提供 SDK。我们还特别学习了 Azure 身份、RBAC 和资源层次结构。尽管这些信息可能特定于
    Azure，但所有主要云平台遵循相同的模式。一旦你了解了某个云平台如何处理**身份与访问管理**（**IAM**），它的大致方法也可以迁移到其他云平台。最后，我们登录到
    Azure 账户，供后续章节使用，并学习了如何通过 Azure CLI 直接访问 Azure REST API。
- en: In the next section, we will use the Azure SDK for Go to mutate cloud infrastructure.
    Let's get started on programming the Azure cloud with Go.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将使用 Azure SDK for Go 来变更云基础设施。让我们开始用 Go 编程操作 Azure 云。
- en: Building infrastructure using Azure Resource Manager
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure 资源管理器构建基础设施
- en: Cloud APIs are bifurcated into two categories, the management plane and the
    data plane. The management plane is an API that controls the creation, deletion,
    and mutation of infrastructure. The data plane is an API exposed by provisioned
    infrastructure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 云 API 分为两类：管理平面和数据平面。管理平面是一个控制基础设施创建、删除和变更的 API。数据平面是由配置好的基础设施暴露的 API。
- en: For example, the management plane would be used to create a SQL database. The
    data plane for the SQL database resource would be the SQL protocol for manipulating
    data and structure within the database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，管理平面将用于创建 SQL 数据库。SQL 数据库资源的数据平面则是用于操作数据库内数据和结构的 SQL 协议。
- en: The management plane is serviced by the cloud resource API, and the data plane
    is serviced by the API exposed by the provisioned service.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to use the Azure SDK for Go to provision
    infrastructure in Azure. We will learn how to create and destroy resource groups,
    virtual networks, subnets, public IPs, virtual machines, and databases. The goal
    of this section is to build awareness of the Azure Go SDK and how to interact
    with ARM.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Azure SDK for Go
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in the previous section, cloud SDKs simplify the interaction
    between a given language and a cloud provider's API. In the case of Azure, we
    will be using the Azure SDK for Go ([https://github.com/Azure/azure-sdk-for-go/](https://github.com/Azure/azure-sdk-for-go/))
    to interact with the Azure APIs. Specifically, we'll use the latest edition of
    the SDK ([https://github.com/Azure/azure-sdk-for-go#management-new-releases](https://github.com/Azure/azure-sdk-for-go#management-new-releases)),
    which has been redesigned to follow the Azure design guidelines for Go ([https://azure.github.io/azure-sdk/golang_introduction.html](https://azure.github.io/azure-sdk/golang_introduction.html)).
    For the latest information about packages and docs, be sure to check out the Azure
    SDK Releases page ([https://azure.github.io/azure-sdk/releases/latest/mgmt/go.html](https://azure.github.io/azure-sdk/releases/latest/mgmt/go.html)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The code for this section is located in the GitHub code folder for this chapter
    [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/15).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your local environment
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run the code for this section, you will need to set up a `.env` file. Run
    the following commands from the `./chapter/15` directory of the repository:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will create a `.ssh` directory in `./chapter/15`, generate an SSH
    key pair within that directory, and ensure that proper permissions are set on
    the key pair.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: The preceding command creates an SSH key that does not have a passphrase. We
    are only using this key pair as an example. You should provide a strong passphrase
    for real-world usage.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s set up a local `.env` file that we will use to store environmental
    variables used in the examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, this command will create an`.env` file that contains two environment variables,
    `AZURE_SUBSCRIPTION_ID` and `SSH_PUBLIC_KEY_PATH`. We derive the value for the
    Azure subscription ID from the Azure CLI's current active subscription.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set up our local environment, let's build an `cloud-init` provisioning
    script and provide access using SSH via a public IP.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Building an Azure virtual machine
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started by running the example, and then we''ll delve into the code
    for building the infrastructure. To run the example, run the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After running `go run ./cmd/compute/main.go`, you should see something similar
    to what is shown in the previous command block. As you can see from the output,
    the program built several bits of infrastructure, including an Azure resource
    group, network security group, virtual network, and virtual machine. We'll discuss
    every piece of infrastructure in more detail soon.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `go run ./cmd/compute/main.go` 后，你应该看到与前一个命令块中显示的类似的内容。从输出中可以看到，程序构建了多个基础设施组件，包括一个
    Azure 资源组、网络安全组、虚拟网络和虚拟机。稍后我们将更详细地讨论这些基础设施的每个部分。
- en: As the output states, you can also use SSH to access the virtual machine as
    described in the output. We'll use this to explore the provisioned state of the
    virtual machine to confirm that the `cloud-init` provisioning script ran as expected.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如输出所示，你还可以使用 SSH 访问虚拟机，具体操作见输出内容。我们将使用此方法来检查虚拟机的预配置状态，以确认 `cloud-init` 配置脚本是否按预期运行。
- en: 'If you visit the Azure portal, you should see the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 Azure 门户，应该能看到以下内容：
- en: '![Figure 15.1 – The Azure portal virtual machine infrastructure'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 15.1 – Azure 门户虚拟机基础设施'
- en: '](img/B17626_15_001.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_15_001.jpg)'
- en: Figure 15.1 – The Azure portal virtual machine infrastructure
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – Azure 门户虚拟机基础设施
- en: In the preceding screenshot, you can see the resource group as well as all of
    the infrastructure created. Next, let's look at the code that provisioned this
    infrastructure.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，你可以看到资源组以及所有已创建的基础设施。接下来，我们来看看为这些基础设施提供服务的代码。
- en: Provisioning Azure infrastructure using Go
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Go 配置 Azure 基础设施
- en: In these examples, you will see how to build Azure API clients, probe for credentials
    for accessing APIs, and mutate infrastructure. Many of these examples use abbreviated
    error-handling behavior to keep the code as concise as possible for illustrative
    purposes. `panic` is not your friend. Please wrap and bubble your errors as appropriate.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，你将看到如何构建 Azure API 客户端，查询用于访问 API 的凭证，并修改基础设施。这些示例中的许多使用了简化的错误处理方式，以使代码尽可能简洁，便于说明。`panic`
    不是你的朋友。请根据需要适当地包装和传递错误。
- en: 'Let''s start with the entry point of `go run ./cmd/compute/main.go` and learn
    how to use Go to provision cloud infrastructure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 `go run ./cmd/compute/main.go` 的入口点开始，学习如何使用 Go 来配置云基础设施：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we load environment variables in the local `.env` file
    using `godotenv.Load()`. In `main`, we create a new `VirtualMachineFactory` to
    manage the creation and deletion of Azure infrastructure. Once the infrastructure
    is created in `factory.CreateVirtualMachineStack`, we print the SSH connection
    details and prompt for user confirmation to delete the infrastructure stack.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用 `godotenv.Load()` 加载本地 `.env` 文件中的环境变量。在 `main` 函数中，我们创建一个新的 `VirtualMachineFactory`
    来管理 Azure 基础设施的创建和删除。基础设施在 `factory.CreateVirtualMachineStack` 中创建后，我们打印出 SSH
    连接详情，并提示用户确认是否删除基础设施堆栈。
- en: 'Next, let''s dive into the VM factory and see what is included in the VM stack:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们深入了解虚拟机工厂，看看虚拟机堆栈中包含了哪些内容：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This code defines the structure of `VirtualMachineFactory`, which is responsible
    for the creation of and access to the Azure SDK API clients. We instantiate those
    clients using the `NewVirtualMachineFactory` func, as shown here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了 `VirtualMachineFactory` 的结构，它负责创建和访问 Azure SDK API 客户端。我们使用 `NewVirtualMachineFactory`
    函数来实例化这些客户端，如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code builds a new default Azure identity credential. This credential is
    used to authenticate the client to the Azure APIs. By default, this credential
    will probe multiple sources for an identity to use. The default credential will
    probe for environment variables first, then it will attempt to use an Azure managed
    identity ([https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview](https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview)),
    and finally, it will fall back to using the Azure CLI's user identity. For this
    example, we are relying on the Azure CLI identity to interact with the Azure APIs.
    This is convenient for development but should not be used for a deployed application
    or script. Non-interactive authentication requires either an Azure service principal
    ([https://docs.microsoft.com/en-us/azure/active-directory/develop/app-objects-and-service-principals](https://docs.microsoft.com/en-us/azure/active-directory/develop/app-objects-and-service-principals))
    or an Azure managed identity.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The VM factory builds each of the Azure API clients using `subscriptionID`,
    the credential, and the `New*` function for each of the clients. `BuildClient()`
    builds each client.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how credentials and the API clients are instantiated, let''s
    dive into the creation of infrastructure in `CreateVirtualMachineStack`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, we created the idea of a stack – a collection of related
    infrastructure. We created a new stack with a given location, a human-readable
    name, and the contents of the SSH public key path. Subsequently, we created each
    of the Azure resources needed to create a VM with public SSH access.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore each of the `create` and `get` funcs in `CreateVirtualMachineStack`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, `createResourceGroup` calls `CreateOrUpdate` on `groupsClient`
    to create an Azure resource group in the specified location. An Azure resource
    group is a logical container for Azure resources. We will use the resource group
    as a container for the rest of our resources.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s dive into the network security group creation function, `createSecurityGroup`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding code, we built an Azure network security group, which contains
    a single security rule to allow network traffic on port `22`, enabling SSH access
    for the VM. Note that rather than calling `CreateOrUpdate`, we call `BeginCreateOrUpdate`,
    which issues `PUT` or `PATCH` to the Azure API and starts a long-running operation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: A long-running operation in Azure is one that – once the initial mutation is
    accepted –executes until it reaches a terminal state. For example, when creating
    a network security group, the API receives the initial mutation and then starts
    to build the infrastructure. After the infrastructure is ready, the API will indicate
    it is completed through the operation state or the provisioning state. `poller`
    takes care of following the long-running operation to completion. In `HandleErrPoller`,
    we follow the polling to completion and return the final state of the resource.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s explore the creation of the virtual network via `createVirtualNetwork`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the previous code block, we built an Azure virtual network for our VM. The
    virtual network is set up with a `10.0.0.0/16` `10.0.0.0/24` CIDR. The subnet
    references the network security group we built in the previous code block, which
    causes the rules in the network security group to be enforced on the subnet.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have built the networking for our VM, let''s build it via `createVirtualMachine`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is not much to show for `createVirtualMachine()`. As you can see, the
    same pattern of resource creation through a long-running API invocation is applied
    in this code. The interesting bits are in `linuxVM()`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In `linuxVM`, we specify the location, name, and properties of the VM. In the
    properties, we specify the type of hardware we'd like to provision. In this case,
    we are provisioning a Standard D3v2 (you can read more about it at [https://docs.microsoft.com/en-us/azure/virtual-machines/dv3-dsv3-series](https://docs.microsoft.com/en-us/azure/virtual-machines/dv3-dsv3-series))
    hardware **Stock-Keeping Unit** (**SKU**).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'We also specify our `StorageProfile`, which is used to specify the OS as well
    as the data disks we''d like attached to the VM. In this case, we specify that
    we''d like to run the latest version of Ubuntu 18.04\. Both `NetworkProfile` and
    `OSProfile` are a little too complex to include in this function, so let''s explore
    them individually in the following code block:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In `networkProfile()`, we create `NetworkProfile`, which specifies that the
    VM should have a single network interface using IPv4 and be exposed via a public
    IP. The network interface should be allocated on the subnet that we created in
    `createVirtualNetwork()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s explore the `OSProfile` configuration via `linuxOSProfile()` in
    the following code block:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In `linuxOSProfile`, we create an `OSProfile`, which includes details such as
    the admin username, computer name, and SSH configuration. Take note of the `CustomData`
    field used for specifying the Base64-encoded `cloud-init` YAML, which is used
    to run the initial configuration of the VM.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore what we are doing in the `cloud-init` YAML:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the VM is created, the following `cloud-init` instructions are executed:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: First, the packages on the Ubuntu machine are upgraded.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the `nginx` and `golang` packages are installed via the **Advanced Package
    Tool** (**APT**).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, `runcmd echos "hello world"`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cloud-init` is super-useful for bootstrapping VMs. If you have not used it
    previously, I highly recommend exploring it further ([https://cloudinit.readthedocs.io/en/latest/](https://cloudinit.readthedocs.io/en/latest/)).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify `cloud-init` executed by accessing the VM using SSH and executing
    commands similar to the following. Remember, your IP address will be different
    than what is shown here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, `nginx` and `go` have been installed. You should also see the
    APT mutations and *hello world* in `/var/log/cloud-init-output.log` on the provisioned
    VM.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: You have provisioned and created an Azure VM and related infrastructure! Now,
    let's destroy the entire stack of infrastructure. You should be able to press
    *Enter* in the shell where you are running `go run ./cmd/compute/main.go`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happened when we called `factory.DestroyVirtualMachineStack`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In `DestroyVirtualMachineStack`, we simply call `BeginDelete()` on the group's
    client, specifying the resource group name. However, unlike other examples, we
    do not wait for the poller to complete. We send the `DELETE HTTP` request to Azure.
    We do not wait for the infrastructure to be completely deleted; instead, we trust
    that the acceptance of `delete` means that it will eventually reach the deleted
    terminal state.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We have now built and cleaned up a stack of infrastructure using the Azure SDK
    for Go. We have learned how to create resource groups, virtual networks, subnets,
    public IPs, and VMs, and how a pattern can be extended to any resource in Azure.
    Additionally, these skills are applicable to each of the major clouds, not just
    Azure. AWS and GCP both have similar concepts and API access patterns.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll build an Azure Storage account and learn a bit about
    using the data plane of a cloud service by uploading files and then providing
    constrained access to download those files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Using provisioned Azure infrastructure
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we built a stack of computing and networking infrastructure
    to illustrate how to manipulate cloud infrastructure. In this section, we will
    pair a provisioning infrastructure with the Azure control plane and use the infrastructure
    through the provisioned service's data plane.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to build a cloud storage infrastructure. We will
    use Azure Storage to store files and provide constrained access to those files
    via shared access signatures ([https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview)).
    We will learn how to use ARM to fetch account keys and use those keys to provide
    constrained access to storage resources.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Building an Azure Storage account
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started by running the example, and then we''ll delve into the code
    for building the infrastructure and using the provisioned storage account. To
    execute the example, run the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see from the previous output, the example creates a resource group
    and a storage account, fetches an account key, and then uploads all of the images
    in `./blobs` to the cloud. Finally, the example prints out URIs for each of the
    images using shared access signatures. If you click on one of those URIs, you
    should be able to download the image we uploaded to the storage account.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you try to download `img1.jpeg` without the query string –
    for example, using the `https://fallingrain.blob.core.windows.net/jd-imgs/img1.jpeg`
    link? You should get an access denied message.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can use Azure Storage to upload files and constrain access.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning Azure Storage using Go
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we are going to provision an Azure resource group and an Azure
    Storage account. We are using abbreviated error-handling behavior to keep the
    code as concise as possible for illustrative purposes. As I said in the previous
    section, panic is not your friend. Please wrap and bubble your errors as appropriate.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the entry point of Go `run ./cmd/storage/main.go`, and learn
    how to use Go to provision the storage account:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Similar to the VM infrastructure example in the previous section, we create
    `StorageFactory` using `NewStorageFactory()` and then use it to create and destroy
    the storage stack. In the middle, we call `uploadBlobs()` to upload the image
    files and `printSASUris()` to generate and print shared access signatures for
    each of the uploaded files.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at how we provision the storage infrastructure:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The storage factory looks similar to `VirtualMachineFactory` from the previous
    section. However, the storage factory only uses the resource group and storage
    clients.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s explore `CreateStorageStack()` to see how we create the Azure
    Storage account:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we create a human-readable name for the stack, which
    we will use to name the resource group and the storage account. We then populate
    the stack fields with created resources.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'I will not cover `createResourceGroup()`, as it was covered in the previous
    section. However, `createStorageAccount()` and `getPrimaryAccountKey()` are interesting.
    Let''s explore what they do:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, `createStorageAccount()` creates a new block blob, with
    premium tier performance, and a locally redundant Azure Storage account. Block
    blobs ([https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs#about-block-blobs](https://docs.microsoft.com/en-us/rest/api/storageservices/understanding-block-blobs--append-blobs--and-page-blobs#about-block-blobs))
    are optimized for uploading large amounts of data and, as the name implies, are
    broken into blocks of arbitrary size. Locally redundant storage ([https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy#locally-redundant-storage](https://docs.microsoft.com/en-us/azure/storage/common/storage-redundancy#locally-redundant-storage))
    means that each block is replicated 3 times within the same data center and is
    guaranteed to provide 99.999999999% (11 nines!) durability over a given year.
    Finally, the premium tier ([https://docs.microsoft.com/en-us/azure/storage/blobs/scalability-targets-premium-block-blobs](https://docs.microsoft.com/en-us/azure/storage/blobs/scalability-targets-premium-block-blobs))
    of Azure Storage indicates that the storage account will be optimized for applications
    that consistently require low latency and high transaction throughput for block
    blob mutations.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the configuration of the storage account, provisioning is handled in
    a similar way to the rest of the resources we have provisioned thus far.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate shared access signatures for uploaded blobs, we need to acquire
    a storage account key that is provisioned when the storage account is created.
    Let''s see how we can request the storage account keys:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this code, we fetch the account keys by calling `ListKeys` on the storage
    client. We return the first account key returned.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have provisioned the storage infrastructure and fetched the storage
    account key, we are ready to use the storage service to upload files and provide
    constrained access to the files.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Storage
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s upload the files in `./blobs` to our storage account with the `uploadBlobs`
    func:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, we create a service client to interact with the storage
    service client. With `serviceClient`, we can define a new storage container called
    `jd-imgs`. You can think of a storage container as an entity similar to a directory.
    After specifying the container, we call `create` to request the storage service
    to create the container. Once we have a container, we then iterate over each image
    in the `./blobs` directory and upload them using the block blob client.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Until this point, we have been using the Azure CLI identity as our credential
    for interacting with Azure services. However, when we instantiated `serviceClient`,
    we instead began using the Azure Storage account keys to interact with our storage
    account. Let''s take a look at `ServiceClient()`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, we create a new credential using the storage account
    name and the value of the account key. We construct `ServiceClient`, using the
    blob endpoint for the storage account and the newly constructed shared key credential.
    The shared key credential will be used for all clients that derive from the service
    client.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have uploaded the files as block blobs, let''s see how we can create
    signed URIs to provide constrained access:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We construct `ServiceClient` and establish a container client in the preceding
    code block. Then, we iterate over every file within the local `./blobs` directory
    and create a blob client.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The blob client has a helpful method called `GetSASToken`, which generates a
    shared access token given blob access permissions and a validity time span. In
    our case, we are granting read access that starts immediately and expires in 2
    hours. To create a complete URI to access the blob, we need to combine the blob
    URL and the query string generated by the shared access token. We do that with
    `blobClient.URL()`, `"?"`, and `sasQuery.Encode()`. Now, anyone with the signed
    URI will have access to read the file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: In this final section, we built and used cloud storage infrastructure to store
    files and provide constrained access to those files by using shared access signatures.
    We learned how to fetch account keys and use them to provide constrained access
    to storage resources. Using these skills, you can combine permissions and other
    constraints to tailor access to your needs. Providing constrained access in this
    way is a powerful tool. For example, you can create a write-only URI to a blob
    not yet created, pass the URI to a client, and then have them upload a file without
    having access to any other files in the storage account.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Storage is only one service out of hundreds that you can use to build
    applications in the cloud. Each cloud service provider has analogous storage services
    that operate in a similar way. The examples shown in this chapter are specific
    to Microsoft Azure, but they can be easily emulated for other clouds.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Storage example is useful for illustrating the separation between
    the management plane and the data plane of the cloud. If you look closely, you
    can observe a significant similarity in **Create, Read, Update, and Delete** (**CRUD**)
    resource operations using ARM in contrast to interacting with the Azure Storage
    service, container, and blob clients. Resource management is uniform within a
    cloud. The data plane for databases, storage services, and content delivery networks
    is rarely uniform and often exposed through purpose-built APIs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned that the cloud is not just someone else's computer.
    The cloud is a planet-scale web of high-security data centers filled with computing,
    networking, and storage hardware. We also learned the fundamentals of identity,
    authentication, and authorization, with specifics drawn from Microsoft Azure.
    We briefly covered Azure RBAC and its relationship with AAD identities. Finally,
    we learned how to provision and use cloud resources using Microsoft Azure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: You should be able to take what you learned here and apply it to provisioning
    and using cloud services to achieve your goals. These skills were focused on Microsoft
    Azure, but the skills learned here are easily transferred to the AWS or Google
    clouds.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to explore what happens when software operates
    in less-than-perfect conditions. We will learn to design for chaos.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
