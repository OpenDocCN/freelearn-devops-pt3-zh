- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Simplest Ways to Start Using DevOps in Python Immediately
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things don’t just happen. They are made to happen.
  prefs: []
  type: TYPE_NORMAL
- en: – John F. Kennedy
  prefs: []
  type: TYPE_NORMAL
- en: Over the past couple of chapters, you’ve probably been thinking, all these principles
    and philosophies are fine, but I want to get my hands dirty! If that’s what you
    want, then this is the chapter for you. In this chapter, you will learn how to
    use Python and its libraries to serve the purposes of your workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I’m not suggesting that you switch to Python-based alternatives from what
    you are currently using. In fact, most of the tools and techniques that we are
    about to discuss are meant to be in support of existing infrastructure and methods
    as opposed to a replacement for them.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is meant to give you a good grasp of the possibilities that the
    Python programming language provides DevOps as well as the ways that you can integrate
    it into your pre-existing systems and infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to learn about a few simple implementations of
    Python in different aspects of API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: Making API calls and the different ways that API calls are made
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Python can help analyze, construct, and optimize your workload’s networking
    resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few technical requirements that may need to be fulfilled if you
    want to get the most out of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A GitHub account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Replit account (which has a single sign-on with GitHub)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Hugging Face account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Google account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any computing device with an internet connection and a command line interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to tolerate my writing style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, if you can get those in hand, then you are ready to start your journey
    in this chapter. Let’s get going.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define API calls, let’s start with what an **Application Programming Interface**
    (**API**) is. An API is a software interface that offers your application access
    to functions and processes from other applications. Think of it like this: when
    a user tries to get information from an application, they do so through the **user
    interface** (**UI**). The API has a similar function for software, so you could
    call API the UI of software.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, API calls are made for a number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t want to write the underlying logic for a big feature yourself (trust
    me, a lot of the time, you don’t.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The API gives access to resources that you ordinarily would not have (i.e.,
    creating a Virtual Machine using the API of a cloud provider)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You just want to get some information into your application (public APIs are
    very good for this)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any coding library that you use for code is technically an API. You pull the
    library in and you call it to perform a function for your application. So, you
    can see why the definition of APIs can be confusing sometimes. But the point is
    this: more things are APIs than are not APIs. Everything you see in an app or
    a website comes from APIs.'
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s dive into a couple of examples of how to use APIs to our benefit in
    DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1 – calling a Hugging Face Transformer API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I chose this exercise because it is free, it will introduce you to a lot of
    integral tools and concepts behind APIs, and **Hugging Face APIs** are quite popular,
    so you will get hands-on experience with those. The API that we will be using
    specifically is a transformer that turns a written prompt into an image. It’s
    a great API to learn and find out how APIs in general work. For this lesson, I
    am using a Google Colab notebook, which is a Jupyter Notebook hosted by Google.
    It’s pretty useful when you want to recreate runtimes for certain sections of
    code. It’s like having your own little test section that you can divide into even
    smaller sections if you want to. Let’s make a notebook to further explore our
    Hugging Face API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To open a Colab notebook, you can go to [colab.research.google.com](http://colab.research.google.com)
    and create a new notebook. The end result should be something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Initial notebook created with Google Colab](img/B21320_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Initial notebook created with Google Colab
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is install the correct libraries. These libraries
    contain the functions and modules with which we call our APIs. You can install
    them directly in the notebook if you’d like. We are going to install the `huggingface_hub`
    and `transformers[agents]` libraries. Here is the command for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you put this command in the cell and press play, it will install the libraries
    in your runtime:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Installing required libraries](img/B21320_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Installing required libraries
  prefs: []
  type: TYPE_NORMAL
- en: The next thing that you need to do is log in to `huggingface_hub` using an API
    key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is where the concept of the API key comes from. An API key is like a login
    but for your software. Most companies only allow full access to their APIs through
    the purchase of an API key. A lot of open source projects such as Hugging Face
    have API keys to promote and track user interaction and sometimes upgrade their
    users to a premium version if they want.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To get a Hugging Face API key, you must first go to the [huggingface.co](http://huggingface.co)
    web page and sign up or log in if you’ve already signed up. After doing that,
    go to your profile and then to the **Settings** tab and into the **Access Tokens**
    tab from there. You can generate an access token for use there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 3.3 – Generating an access token for the \uFEFFHugging Face API](img/B21320_03_3.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Generating an access token for the Hugging Face API
  prefs: []
  type: TYPE_NORMAL
- en: 'You can copy this token for use in your next section of code. Here, you import
    the Hugging Face login module for the login API, and you input your key to use
    the API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll get this message if you’ve loaded it correctly. If so, congratulations,
    you successfully called the login API:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Successful login and initialization](img/B21320_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Successful login and initialization
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the fun part. We are going to use the Hugging Face Transformer API
    to take a line of text and turn it into an image. But first, we must import a
    Hugging Face agent using the `HfAgent` API (see the pattern?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `starcoderbase` model for this. Once you run this and get
    the agent, you can simply type in a prompt to generate an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'But remember, if you don’t want to wait half an hour for your image, use the
    GPU runtime by going to the **runtime** tab and selecting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Choosing a GPU for faster image processing](img/B21320_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Choosing a GPU for faster image processing
  prefs: []
  type: TYPE_NORMAL
- en: 'The end product will leave you shocked and satisfied. You’ll get something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Your final result (beautiful, isn’t it?)](img/B21320_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Your final result (beautiful, isn’t it?)
  prefs: []
  type: TYPE_NORMAL
- en: So, we have completed this exercise and successfully called an API that has
    given us a visibly satisfying conclusion. What more could one ask for? Now, if
    only other people could witness the fruits of your labor!
  prefs: []
  type: TYPE_NORMAL
- en: Well, that’s what calling APIs is all about. APIs are meant to be consumed by
    your target audience and so now, we are going to see how we can distribute our
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2 – creating and releasing an API for consumption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deploying applications is one of the most frequent tasks that a DevOps engineer
    might encounter. It is important to have a good, fast deployment, but before that,
    it is important to have a deployment in the first place. Deploying smaller and
    larger applications are alike in a lot of ways. One major way in which they differ
    is the lengths you must go through to maintain availability on larger applications.
    We won’t be discussing that in this section. We will instead just try to get an
    API up for adding two numbers. Like I said, let’s keep it simple and begin creating
    a new **Replit Repl** and start coding in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sign up for an account at [replit.com](http://replit.com). You can create small
    virtual environments for practically every application framework and code base
    there. Once you have signed up, you can create a **Repl**, which is a small virtual
    server, by clicking the **Create** **Repl** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Button to create a Repl](img/B21320_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Button to create a Repl
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have done that, search for and create a Repl with the **Flask** template.
    The name is not relevant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Initializing a Flask Repl](img/B21320_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Initializing a Flask Repl
  prefs: []
  type: TYPE_NORMAL
- en: 'This will give you an IDE that contains boilerplate Flask code that is pre-initialized
    and installed with the basic Flask libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Initial Flask framework](img/B21320_03_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Initial Flask framework
  prefs: []
  type: TYPE_NORMAL
- en: 'Concerning the preceding figure, when you click the `"/"` has already been
    defined. So, if you open the URL in a new tab, you’ll get something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Initial Flask web page](img/B21320_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Initial Flask web page
  prefs: []
  type: TYPE_NORMAL
- en: 'This function just returns a string on a webpage. Typically, APIs are written
    in a JSON format. So, let’s turn this into JSON. In Flask, that is pretty easy.
    You can just pass a variable that is a dictionary in the return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – Writing a simple JSON API in Flask](img/B21320_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – Writing a simple JSON API in Flask
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that’s done, you’ll get a return value in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – JSON API result](img/B21320_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – JSON API result
  prefs: []
  type: TYPE_NORMAL
- en: 'This API, as it is, only returns static values. To have it take user input,
    simply add `request` parameters in the URL itself. Let’s modify our application
    to take two parameters, `num1` and `num2`, which will be added, and their sums
    shown in the JSON return value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Flask API code to add two numbers](img/B21320_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Flask API code to add two numbers
  prefs: []
  type: TYPE_NORMAL
- en: 'The end result requires a URL in the form of `<your_url_here>/?num1=<number>&num2=<number>`.
    The result would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Flask API call to add two numbers](img/B21320_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Flask API call to add two numbers
  prefs: []
  type: TYPE_NORMAL
- en: So, now you have learned how to make an API in Python that adds two numbers
    and deploys the API. That’s a really big step. The only thing that gets exponentially
    more complex in the programming world is business logic. Security and networking
    are important too, but they usually follow a set formula. As long as you can deploy
    your logic to your end user, you’re good.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that you have learned the art of the API, we are going to dive into what
    delivers APIs to their end users. We are diving into networking. Networking is
    such an integral part of DevOps and application development in general that sometimes
    it’s not mentioned at all. So, let’s look at a few useful ways that we can use
    Python on the networking side.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No, this is not about growing your LinkedIn connections, although that’s something
    I’d recommend doing too. Computer networks are essential to the functioning of
    every application these days because they are the only way to deliver constant
    value to the user while keeping them connected to your environment. Almost every
    device these days is connected to a network, which is why understanding the network
    of devices and the network of networks (it’s something called the internet, ever
    heard of it?) is very important.
  prefs: []
  type: TYPE_NORMAL
- en: I am now going to demonstrate two examples of how to use Python for networking
    insights and data collection.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1 – using Scapy to sniff packets and visualize packet size over time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scapy** is a Python library that can be used to replicate, simulate, and
    manipulate the data packets that are sent over a computer network. Scapy is a
    very useful tool in the belt of any developer or DevOps professional.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to use Scapy to collect a list of packets and
    get their timestamps and packet sizes. We are then going to map these onto a chart
    that we make using the **matplotlib library**. You can use the previously mentioned
    Google Colab for this exercise. So, let’s initialize the notebook and start writing
    our code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install the `matplotlib` and `scapy` libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s write the code to use Scapy’s `sniff` module to get a list of packet
    sizes over timestamps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will get a list of the length of the last `100` packets that went through
    your network along with the timestamp and the type of traffic. If you refer to
    the following diagram, the packet sizes are stored in the `packet_sizes` array
    and the timestamps of the packet are stored in the `timestamps` variable:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Sniffing packets in your computing device](img/B21320_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Sniffing packets in your computing device
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now write the code to plot the packet size over time using `matplotlib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will give us a chart with time on the *x*-axis and packet size on the
    *y*-axis:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.16 – Chart of packet size over time](img/B21320_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – Chart of packet size over time
  prefs: []
  type: TYPE_NORMAL
- en: The preceding chart shows a pattern of network activity that seems to involve
    several correlated packets. So, you can see the network analysis library coming
    in handy already.
  prefs: []
  type: TYPE_NORMAL
- en: So, we have now tracked our network activity and generated data insights from
    it using Python. Let’s look at one more network implementation, this time focusing
    on the routing rules that your device (or the device you are running your workload
    on) has.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2 – generating a routing table for your device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Routing tables define the routes that certain web traffic takes within your
    devices. These tables exist in practically every device, and they define the routes
    by which those devices access computer networks. You can use the **netifaces Python
    library** to generate a routing table showing all the available routes and destinations
    that your device contains. The netifaces library in this case is used to collect
    the network interfaces (hence the name *netifaces*) of your operating system.
    You will then parse this information and display it in a tabular form. You can
    once again use Google Colab for this, though for more interesting results, you
    could try running the code locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin the steps to generate a routing table for your device. If you’ve
    been following along so far, you know the first step is installing the library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, write code to generate the routing table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It’s a lot of code, but fairly easy to make sense of. It also provides you
    with detailed information about where the network traffic goes from your network
    interfaces. If you tried it on Colab as I suggested, you’d get something like
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Route table on Colab](img/B21320_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Route table on Colab
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you’ve done it on your personal computer, you might get something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Route table on a personal computer](img/B21320_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Route table on a personal computer
  prefs: []
  type: TYPE_NORMAL
- en: A bit more baggage was added there.
  prefs: []
  type: TYPE_NORMAL
- en: But that is the gist of it, and these are just a couple of ways you can use
    Python to facilitate the networking aspect of DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned a thing or two about the hands-on part of this
    book. You’ve learned about APIs and computer networks, which practically means
    you’re halfway there as far as the Python DevOps implementation goes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, not only did you learn about these important DevOps concepts,
    but you also learned how you can implement them in your DevOps process. You can
    take this code and implement it directly in your DevOps workload right now if
    that benefits you.
  prefs: []
  type: TYPE_NORMAL
- en: These fundamentals that you have learned will help you enhance, monitor, and
    diagnose problems on practically any DevOps workload that you may encounter. In
    the next chapter, we will discuss the creation of resources in a DevOps workload
    and how and where Python can be of assistance in the process.
  prefs: []
  type: TYPE_NORMAL
