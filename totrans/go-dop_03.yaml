- en: 'Chapter 2: Go Language Essentials'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the basics of the Go language. While some
    of the syntax is new in relation to other languages, most of the concepts in that
    chapter are familiar to programmers coming from other languages.
  prefs: []
  type: TYPE_NORMAL
- en: This isn't to say that the way Go uses those concepts doesn't lead to code that
    is easier to read and reason about—it's just that most of it doesn't stand out
    from other languages.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will be discussing the essential parts of Go that make it
    stand out from other languages, from Go's more pragmatic error handling to its
    core concurrency concept, the goroutine, and the newest feature of the Go language,
    generics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main topics that will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Go constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `defer`, `panic`, and `recover`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing goroutines for concurrency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Go's `Context` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Go's testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generics—the new kid on the block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's get the essentials down and get you on your way!
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors in Go
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of you will come from languages that handle *errors* using *exceptions*.
    Go took a different approach, treating errors like our other data types. This
    prevents common problems that exception-based models have, such as exceptions
    escaping up the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go has a built-in error type called `error`. `error` is based on the `interface`
    type, with the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at how we can create an error.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common way to create errors is using either the `errors` package''s
    `New()` method or the `fmt` package''s `Errorf()` method. Use `errors.New()` when
    you don''t need to do variable substitution and `fmt.Errorf()` when you do. You
    can see both methods in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In both the preceding examples, `err` will be of type `error`.
  prefs: []
  type: TYPE_NORMAL
- en: Using an error
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common way to use an error is as the last return value on a function
    or method call. The caller can then test if the returned error is `nil`, indicating
    there is no error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want a function that divides a number, and we want to detect
    if the divisor is zero. In that case, we want to return an error because a computer
    cannot divide a number by zero. This is how it might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example uses Go''s multiple return ability to return two values:
    **the result** and **the error**.'
  prefs: []
  type: TYPE_NORMAL
- en: In our `main` package, we can now divide our numbers and check the returned
    `error` type to see if it is not `nil`. If it is, we know we had an error and
    should ignore the return value. If not, we know the operation completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Creating named errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you want to create errors that indicate a specific type of error—say,
    a network error versus an incorrect argument. This can be done by creating specific
    types of errors using the `var` keyword and `errors.New()` or `fmt.Errorf()`,
    as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `errors` package''s `Is()` function to detect the error type
    and retry on `ErrNetwork` and not on other errors, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`someFunc()` is not defined here. You can view a full example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://play.golang.org/p/iPwwwmIBcAG](https://play.golang.org/p/iPwwwmIBcAG)'
  prefs: []
  type: TYPE_NORMAL
- en: Custom errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because the `error` type is simply an interface, you can implement your own
    custom errors. Here is a more in-depth network error that we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now return a custom network error for something such as an authentication
    failure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we receive an error from a call, we can detect if it was a network error
    using the `errors.As()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also view this here: [https://play.golang.org/p/gZ5AK8-o4zA](https://play.golang.org/p/gZ5AK8-o4zA).'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code detects if the network error is unrecoverable, such as an
    authentication failure. Any other network error is recoverable. If it is not a
    network error, it is unrecoverable.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many times, there is an error chain where we want to `net/http` package. In
    that case, you might want to put information about which REST call you were making
    with the underlying error.
  prefs: []
  type: TYPE_NORMAL
- en: We can **wrap errors** so that not only can we include more specific information,
    but we can also keep the underlying error for extraction later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this using `fmt.Errorf()` with `%w` for variable substitution of our
    error type. Let''s say we want to call `someFunc()` from another function called
    `restCall()` and add more information, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Someone using `restCall()` can detect and extract an `ErrNetwork` using `errors.As()`,
    just as we did before. The following code snippet provides an illustration of
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code extracts the `ErrNetwork` from the wrapped `error` it was
    contained in. This will work no matter how many layers of wrapping the error was
    contained in.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned how Go handles errors and about Go's `error`
    type and how to create basic errors, how to create custom errors, how to detect
    specific error types, and how to wrap/unwrap errors. As good `error` handling
    is the basis of reliable software, this knowledge will be useful in every Go program
    you write.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Go constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Constants** provide values that are set at compile time and cannot change.
    This is in contrast to variables, which store values that can be set at runtime
    and can be altered. This provides types that cannot accidentally be changed by
    a user and are allocated for use in the software on startup, providing some speed
    advantages and safety over variable declarations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Constants can be used to store the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer types (`int`, `int8`, `uint16`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Floating-point types (`float32`/`float64`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will discuss how to **declare constants** and common use
    in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a constant
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constants are declared using the `const` keyword, as illustrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Constants are different from variable types in that they come in two flavors,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Untyped constants**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Typed constants**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is going to seem a little weird because constants store a typed value.
    But if you don't declare the exact type (as in the third example, `num64`, where
    we declared it to be an `int64` type), the constant can be used for any type that
    has the same base type or family of types (such as integers). This is called an
    **untyped constant**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `num` can be used to set the value of an `int8`, `int16`, `int32`,
    `int64`, `uint8`, `uint16`, `uint32`, or `uint64` type. So, the following will
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While we didn't discuss it earlier, that is what happens when we wrote code
    such as `add (3,` `3)`—`3` is actually an untyped constant. If the signature of
    `add` changed to `add(x,` `y` `int64)`, `add(3,` `3)` works because of this property
    of an untyped constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'This extends to any type based on that basic type. Have a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, you will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is because `varHelloWorld` is a `string` type and not a `specialStr` type.
    But the unique properties of an untyped constant allow for `constHelloWorld` to
    satisfy any type based on `string`.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration via constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many languages provide an **enumerated type** that gives a readable name to
    some value that cannot be changed. This is most commonly done for integer constants,
    though you can do this for any type of constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'For integer constants specifically, there is a special `iota` keyword that
    can be used to generate constants. It increments the value by `1` for each constant
    defined in the grouping, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be shortened to have only the first value use `iota`, and the
    following values would also automatically be set. The value can also be set to
    a formula in which `iota` uses a multiplier or other mathematical operation. Here
    is an example of both those concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Enumeration with `iota` is great, as long as the values will never be stored
    on disk or sent to another process that is local or remote. The value of constants
    is controlled by the order of the constants in the code. Here, look what happens
    if we insert `c` into our first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that `d` now has the value of `3`? This would cause serious errors if
    the code needed to read back values that were written to disk and needed to be
    read back in. In cases where these values could be used by another process, it
    is best practice to statically define enumeration values.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerators in Go can be hard to interpret when printed. Maybe you are using
    them for error codes and would prefer to have the constant's name printed when
    printing the *value* to logs or **standard output** (**stdout**). Let's have a
    look at how we can get better output.
  prefs: []
  type: TYPE_NORMAL
- en: Printing enumerators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enumerators are much easier to use when displaying a value as the enumerated
    name instead of the value. This can be done easily when the constant is a string
    such as `const toyota = "toyota"`, but for other more efficient enumerator types
    such as integers, printing the value simply outputs a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go has the concept of code generation built into the tooling. This is a more
    far-reaching subject than we will cover here (read about it here: [https://blog.golang.org/generate](https://blog.golang.org/generate)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we will borrow from the linked document to show how this can be used
    to set up an enumerator to a string value for printing automatically, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This requires the Go `stringer` binary to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: '`//go:generate stringer -type=Pill` is a special syntax that indicates that
    when the `go generate` command is run for this package, it should call the `stringer`
    tool and pass it the `-type=Pill` flag, which indicates to read our package code
    and generate a method that reverses the constants based on type `Pill` to a string.
    This will be placed in a file called `pill_string.go`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before running the command, `fmt.Println(Aspirin)` would print `1`; after, it
    would print `Aspirin`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned how constants can provide non-changeable values
    for use in your code, how you can create enumerators with them, and finally, how
    you can generate textual printed output for enumerators for better logging. In
    the next section, we will explore how to use `defer`, `panic`, and `recover` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using defer, panic, and recover
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern programming languages have a need to provide some method of running routines
    when a section of code ends. This is useful when you need to guarantee a file
    closure or unlock a mutex. In addition, there are times when a program needs to
    stop execution and exit. This can be caused by loss of access to a critical resource,
    a security issue, or another need.
  prefs: []
  type: TYPE_NORMAL
- en: We also require the ability to recover from a premature program exit caused
    by a package that contains code we do not control. This section will cover each
    of the abilities in Go and their interrelations.
  prefs: []
  type: TYPE_NORMAL
- en: defer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `defer` keyword allows you to execute a function when the function that
    contains `defer` exits. If there are multiple `defer` statements, they execute
    last to first.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be useful for debugging, unlocking mutexes, decrementing counters,
    and so on. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see it at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://play.golang.org/p/DaoP9M79E_J](https://play.golang.org/p/DaoP9M79E_J)'
  prefs: []
  type: TYPE_NORMAL
- en: If you run this example, you will notice that our `defer` statements execute
    after the rest of `printStuff()` has run. We use a deferred anonymous function
    to set our named return `value` before exiting. You will see `defer` used frequently
    in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: panic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `panic` keyword is used to cause the execution of the program to stop and
    exit while displaying some text and a stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `panic` is as simple as calling the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`panic` is intended to be used when a program cannot or should not continue
    to execute. This might be because there is a security issue, or on startup, you
    cannot connect to a required data source.'
  prefs: []
  type: TYPE_NORMAL
- en: In most circumstances, a user should return an `error` and not `panic`.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, only use `panic` in the `main` package.
  prefs: []
  type: TYPE_NORMAL
- en: recover
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are rare circumstances in which a program might panic due to an unforeseen
    bug or a package that unnecessarily panics. After more than 10 years of programming
    in Go, I can count on my fingers the number of times I have needed to recover
    from a panic.
  prefs: []
  type: TYPE_NORMAL
- en: '`recover` to prevent a server crash when an RPC call panics and then signals
    the caller of the issue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If, like the RPC framework, you need to catch a panic that is occurring or
    protect against potential panics, you can use the `recover` keyword with the `defer`
    keyword. Here is an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see this here: [https://play.golang.org/p/J8RfjOe1dMh](https://play.golang.org/p/J8RfjOe1dMh).'
  prefs: []
  type: TYPE_NORMAL
- en: This has similarities to other languages' exception types, but you should not
    confuse the two. Go does not intend for you to use `panic`/`defer`/`recover` in
    that way—it will simply cause you problems in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have completed this section, you have learned how to defer the
    execution of a function, cause a panic within the `main` package, how to recover
    from a misbehaving package, and when these should be used. Let''s hop onto the
    next topic relevant to this chapter: *goroutines*.'
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing goroutines for concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the modern era of computers, **concurrency** is the name of the game. In
    the years before 2005 or so, computers used Moore's law to double the speed of
    a single **central processing unit** (**CPU**) every 18 months. Multiple CPU consumer
    systems were rare and there was one core per CPU in the system. Software that
    utilized multiple cores efficiently was rare.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, it became more expensive to increase single-core speed and multi-core
    CPUs have become the norm. Each core on a CPU supports a number of hardware threads
    and **operating systems** (**OSs**) provide OS threads that are mapped to hardware
    threads that are then shared between processes.
  prefs: []
  type: TYPE_NORMAL
- en: Languages can utilize these OS threads to run functions in their language *concurrently*
    instead of *serially* as we have been doing in all of our code so far.
  prefs: []
  type: TYPE_NORMAL
- en: Starting an OS thread is an expensive operation and to fully utilize the thread's
    time requires paying a lot of attention to what you are doing.
  prefs: []
  type: TYPE_NORMAL
- en: Go takes this to another level than most languages with **goroutines**. Go has
    built a runtime scheduler that maps these goroutines onto OS threads and switches
    which routine is running on which thread to optimize CPU utilization.
  prefs: []
  type: TYPE_NORMAL
- en: This produces concurrency that is easy and cheap to use, requiring less mental
    burden on the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a goroutine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go gets its name from the `go` keyword that is used to spawn a goroutine. By
    applying `go` before a function call, you can cause that function to execute concurrently
    with the rest of the code. Here is an example that causes 10 goroutines to be
    created, with each printing out a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look similar to, but not necessarily in the same order as,
    what is shown next. `...` indicates more numbers follow, but have been omitted
    for brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the preceding example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://play.golang.org/p/RBD3yuBA3Gd](https://play.golang.org/p/RBD3yuBA3Gd)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that this panics with an error after running. This is because
    the program will have no running goroutines, which means the program is effectively
    dead. It is killed by Go's deadlock detector. We will handle this more gracefully
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Running this will print out the numbers in random order. Why random? Once you
    are running concurrently, you cannot be sure when a scheduled function will execute.
    At any given moment, there will be between 0 and 10 goroutines executing `fmt.Println(x)`,
    and another one executing `fmt.Println("hello")`. That's right—the `main()` function
    is its own goroutine.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `for` loop ends, `fmt.Println("hello")` will execute. `hello` might
    be printed out before any of the numbers, somewhere in the middle, or after all
    the numbers. This is because they are all executing at the same time like horses
    on a racetrack. We know all the horses will reach the end, but we don't know which
    one will be first.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When doing **concurrent programming**, there is a simple rule: *You can read
    a variable concurrently without synchronization, but a single writer requires
    synchronization.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the most common methods of synchronization in Go:'
  prefs: []
  type: TYPE_NORMAL
- en: The `channel` data type to exchange data between goroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Mutex` and `RWMutex` from the `sync` package to lock data access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitGroup` from the `sync` package to track access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can be used to prevent multiple goroutines from reading and writing to
    variables at the same time. It is undefined what happens if you try to read and
    write to the same variable from multiple goroutines simultaneously (in other words,
    *that is a bad idea*).
  prefs: []
  type: TYPE_NORMAL
- en: 'Reading and writing to the same variable concurrently is called a **data race**.
    Go has a data race detector not covered in this book to uncover these types of
    problems. You can read about it here: [https://golang.org/doc/articles/race_detector](https://golang.org/doc/articles/race_detector).'
  prefs: []
  type: TYPE_NORMAL
- en: WaitGroups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `WaitGroup` is a synchronization counter that only has positive values starting
    at 0\. It is most often used to indicate when some set of tasks is finished before
    executing code that relies on those tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `WaitGroup` has a few methods, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.Add(int)`: Used to add some number to the `WaitGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Done()`: Subtract 1 from the `WaitGroup`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.Wait()`: Block until `WaitGroup` is 0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our previous section on goroutines, we had an example that *panicked* after
    running. This was due to having all goroutines stopped. We used a `select` statement
    (covered in this chapter) to block forever to prevent the program from exiting
    before the goroutines could run, but we can use a `WaitGroup` to wait for our
    goroutines to end and exit gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do it again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see this here: [https://play.golang.org/p/cwA3kC-d3F6](https://play.golang.org/p/cwA3kC-d3F6).'
  prefs: []
  type: TYPE_NORMAL
- en: This example uses a `WaitGroup` to track the number of goroutines that are outstanding.
    We add 1 to `wg` before we launch our goroutine (*do not add it inside the goroutine*).
    When the goroutine exits, the `defer` statement is called, which subtracts 1 from
    the counter.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: A `WaitGroup` can only have positive values. If you call `.Done()` when the
    `WaitGroup` is at 0, it will cause a panic. Because of the way they are used,
    the creators knew that any attempt to reach a negative value would be a critical
    bug that needs to be caught early.
  prefs: []
  type: TYPE_NORMAL
- en: '`wg.Wait()` waits for all the goroutines to finish, and calling `defer wg.Done()`causes
    our counter to decrement until it reaches 0\. At that point, `Wait()` stops blocking
    and the program exits the `main()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If passing a `WaitGroup` in a function or method call, you need to use a `wg
    := &sync.WaitGroup{}` pointer. Otherwise, each function is operating on a copy,
    not the same value. If used in a struct, either the struct or the field holding
    the `WaitGroup` must be a pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Channels** provide a synchronization primitive in which data is inserted
    into a channel by a goroutine and removed by another goroutine. A channel can
    be buffered, meaning it can hold a certain amount of data before blocking, or
    unbuffered, where a sender and receiver must both be present for the data to transfer
    between goroutines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common analogy for a channel is a pipe in which water flows. Water is inserted
    into a pipe and flows out the far side. The amount of water that can be held in
    the pipe is the buffer. Here, you can see a representation of goroutine communication
    using a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Goroutine communication using a channel'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_02_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Goroutine communication using a channel
  prefs: []
  type: TYPE_NORMAL
- en: Channels are used to pass data from one goroutine to another, where the goroutine
    that passed the data stops using it. This allows you to pass *control* from one
    goroutine to another, giving access to a single goroutine at a time. This provides
    synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels are typed, so only data of that type can go into the channel. Because
    channels are a pointer-scoped type such as `map` and `slice`, we use `make()`
    to create them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement creates a channel called `ch` that holds a `string`
    type with a buffer of 1\. Leaving "`,` `1`" off will make it an unbuffered channel.
  prefs: []
  type: TYPE_NORMAL
- en: Sending/receiving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sending to a channel is done with the `<-` syntax. To send a `string` type
    to the preceding channel, we could do the following: `ch <- "word"`. This attempts
    to put the "`word"` string into the `ch` channel. If the channel has an available
    buffer, we continue execution in this goroutine. If the buffer is full, this blocks
    until either buffer becomes available or—in the case of unbuffered channels—a
    goroutine tries to pull from the channel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Receiving is similar using the same syntax but on the opposite side of the
    channel. The goroutine trying to pull from the channel would do this: `str :=
    <-ch`. This assigns the next value on the channel to the `str` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'More commonly when receiving variables, the `for range` syntax is used. This
    allows us to pull all values out of a channel. An example using our preceding
    channel might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Channels can be closed so that no more data will be sent to them. This is done
    with the `close` keyword. To close the preceding channel, we could do `close(ch)`.
    This should *always* be done by the sender. Closing a channel will cause a `for
    range` loop to exit once all values on the channel have been removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use a channel to send words from one goroutine to another, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see the preceding example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://go.dev/play/p/9km80Jz6f26](https://go.dev/play/p/9km80Jz6f26)'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: After a channel is closed, sending a value on a channel will cause a panic.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving from a closed channel will return the zero value of the type the channel
    holds.
  prefs: []
  type: TYPE_NORMAL
- en: A channel can be `nil`. Sending or receiving from a `nil` channel can block
    forever. It is a common bug for developers to forget to initialize channels in
    a struct.
  prefs: []
  type: TYPE_NORMAL
- en: select statements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `select` statement is similar to a `switch` statement but is geared toward
    listening to multiple channels. This allows us to receive and act on multiple
    inputs at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will listen to several channels and execute a `case`
    statement whenever it receives a value on one of them. In the example cases, we
    spin off a goroutine to do something with the value so that we can continue the
    execution of our loop for the next value. If no value is present on the channel,
    this blocks until one is. If values are on more than one channel, `select` uses
    a pseudo-random method to select which case to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With a `select` statement, we sometimes only want to check if a value is on
    a channel, but if it is not, then we want to move on. In those cases, we can use
    a `default` statement. `default` executes if no other case statement can execute
    (versus the previous behavior of waiting for channel data indefinitely). You can
    see an example of this in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`select` has one more use we saw before but it wasn''t explained. `select{}`
    has no case statements and no default statement; therefore, it blocks forever.
    This is often used by servers that want to run forever to prevent the `main()`
    function from exiting, which stops the execution of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: Channels as an event signal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One common use of channels is to use them to send a signal to another goroutine.
    Often, this is an indication to exit a loop or some other execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `select` example from before where we used the `for` loop, the loop
    will continue forever, but we can use a channel to signal that we want to exit,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`printWords()` reads input off of three channels. If the input is on `in1`
    or `in2`, it prints the channel name and what string was sent on the channel.
    If it is the `exit` channel, it prints that it is exiting and returns. When returning,
    `wg` will have `.Done()` called on it, which will decrement the it by 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Here we create all the channels required for `printWords()` and spin `printWords`
    off in a goroutine. We then send input on our input channels and once that is
    completed, we close the `exit` channel to signal there is no further input to
    `printWords`. The `wg.Wait()` call prevents `main()` from exiting until `printWords`
    has exited.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see the preceding example at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://play.golang.org/p/go7Klf5JNQn](https://play.golang.org/p/go7Klf5JNQn)'
  prefs: []
  type: TYPE_NORMAL
- en: '`exit` is used in this example to signal to `printWords()` that we want to
    exit the `for` loop. This is made possible because receiving on a closed channel
    returns the zero value of the type that the channel holds. We use a blank `struct{}`
    instance because it doesn''t cost memory. We do not store the returned value in
    a variable because it is the signal that the channel closed that is important.'
  prefs: []
  type: TYPE_NORMAL
- en: Mutexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `sync` package called `Mutex`.
  prefs: []
  type: TYPE_NORMAL
- en: This is used to protect a variable or set of variables from being accessed by
    multiple goroutines. Remember—if one goroutine tries to write to a value at the
    same time another wants to read or write to that value, the variable must be protected
    by a synchronization primitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will spin off 10 goroutines to add a number to
    a `sum` value. The `sum` value must be protected as we are reading and writing
    from multiple goroutines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see this example at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://play.golang.org/p/mXUk8PCzBI7](https://play.golang.org/p/mXUk8PCzBI7)'
  prefs: []
  type: TYPE_NORMAL
- en: This code uses a Mutex named `mu` that is part of the `sum` struct to control
    access to the `get()` and `add()` methods. As each is locked, only one of those
    may execute at a time. We use the `defer` statement to unlock the Mutex when the
    function exits. This protects us from forgetting to unlock the Mutex when a function
    gets long.
  prefs: []
  type: TYPE_NORMAL
- en: RWMutex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Along with `sync.Mutex` is `sync.RWMutex`. This distinguishes itself by providing
    a read and write lock. Any number of `mu.RLock()` read locks may be held at a
    time, but a single `mu.Lock()` write lock waits for all existing read locks to
    complete (new `Rlock()` attempts block) and then provides the writer with exclusive
    access.
  prefs: []
  type: TYPE_NORMAL
- en: This proves to be faster when there are lots of concurrent readers and writing
    happens infrequently. However, the standard `Mutex` is faster in the generalized
    case because its implementation is less complicated.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have gained basic skills in using goroutines for concurrent
    operations, learned what synchronization is and when you must use it, and learned
    about Go's various methods for synchronization and signaling. Let's dive into
    understanding another type, known as `context`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Go's Context type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go provides a package called `context` that is useful for two purposes, as
    outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a chain of function calls after some event (such as a timeout)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing information through a chain of function calls (such as user information)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `Context` object is usually created in either `main()` or at the point of
    ingestion of some request (such as an RPC or `Context` object is created from
    our background `Context` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `context` package and the `Context` type is an advanced subject, but I want
    to introduce it here as you will see it used throughout the Go ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Context to signal a timeout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Context` is often used to communicate a timer state or to terminate a wait
    condition—for example, when your program is waiting for a network response.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want to call a function to get some data, but we don''t want
    to wait longer than 5 seconds for the call to complete. We can signal this via
    a `Context`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`context.WithTimeout()` creates a new `Context` that will automatically be
    canceled after 5 seconds and a function that will cancel the `Context` (`context.CancelFunc`)
    when called.'
  prefs: []
  type: TYPE_NORMAL
- en: Every `Context` is said to be derived from another `Context`. Here, we derive
    our `ctx` object from `context.Background()`. `context.Background()` is our parent
    `Context`. New `context` objects can be derived from `ctx` forming a chain, and
    those new `Context` objects can have different timeouts.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a `Context` either directly via `cancel()` or with a timeout or deadline
    causes that `Context` and its children to also be canceled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a `Context` that is canceled after 5 seconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls `GatherData()` and passes the `Context`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the call is complete, we cancel the `Context` if not already canceled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, we need to set up `GatherData()` to honor our `Context` cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: Honoring a context when receiving
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we are executing the `GatherData()` function, we need to honor this context.
    There are a few ways to do that with a basic call to `ctx.Err()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`GatherData()` looks at `ctx.Err()` and checks the value to see if it returns
    an error. If so, we know the `Context` has been canceled and simply return.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we derive two new `Context` objects that share the parent of
    `ctx`. If `ctx` is canceled, `localCtx` and `remoteCtx` are canceled. Canceling
    `localCtx` or `remoteCtx` has no effect on `ctx`. In most circumstances, passing
    `ctx` instead of deriving new `Context` objects is done, but we wanted to show
    how you derive new `Context` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '`Context` also supports a `.Done()` method in case you need to check for cancellation
    inside a `select` statement. `.Done()` returns a channel that, if closed, indicates
    cancellation. Using it is simple, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have shown you how you should add `Context` to your functions, let's
    talk about how this works in the standard library and why it is not the same as
    the examples we have shown.
  prefs: []
  type: TYPE_NORMAL
- en: Context in the standard library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `context` package was added in **Go 1.7**, well after the introduction of
    Go's standard library. Unfortunately, this meant that it had to be hacked into
    the standard library packages in order to avoid breaking Go's version 1.0-compatibility
    promise.
  prefs: []
  type: TYPE_NORMAL
- en: This is the one thing added to Go that has added some real ugliness. Previously,
    we showed you how when using `Context` it should be the first argument of a function
    called `ctx`. However, the standard library cannot do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common pattern you will see when using `Context` in the standard library
    will be to add it via a method. Here is an example of using `Context` for `http.Client`
    to fetch `www.golang.org` and print it to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `HTTP` client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `*http.Request (req)` to get the page at [www.golang.org](http://www.golang.org)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create `Context` (`ctx`) and `CancelFunc` (cancel) where the `Context` is cancelled
    after 3 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach `ctx` to `req` to prevent `*http.Request` from taking longer than 3 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `cancel()` to cancel the Context's internal goroutine that is tracking
    the timeout once the `client.Do()` call has completed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So far, we have talked about how to use C`ontext` for cancellation. Now let's
    talk about another use of `Context`—passing values through a call chain.
  prefs: []
  type: TYPE_NORMAL
- en: Context to pass values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Context's other main use is to pass a value through a `Context` to pass values
    that are useful on a per-call basis, not as generalized storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the two best uses for passing values on a `Context`:'
  prefs: []
  type: TYPE_NORMAL
- en: Security information about a user making a call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Telemetry information such as the data types used with *OpenTelemetry*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of security information, you are informing the system who the user
    is, probably with **OpenID Connect** (**OIDC**) information. This allows the call
    stack to make authorization checks.
  prefs: []
  type: TYPE_NORMAL
- en: For telemetry, this allows a service to record information related to this specific
    call to track function execution times, database latency, input, and errors. This
    can be dialed up or down to debug service issues. We discuss telemetry in future
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing a value to a `Context` requires a little care. Values stored in a context
    are key-value pairs, and to prevent overwriting of keys between multiple packages,
    we need to create our own custom key type that can only be implemented by our
    package. In this way, keys from different packages will have different types.
    The code to achieve this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines a type called `key` that is private, which prevents other packages from
    implementing it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines a `claimsKey` constant of type `key`. This is used as the key for a
    value that holds an OIDC `IDToken` claim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewContext()` provides a function that attaches a `Claim` to our `Context`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClaimsFromContext()` provides a function that extracts `Claims` from a `Context`
    and indicates if `Claims` were found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding code might exist in a security package for `Claims` would represent
    user data we have validated. `NewContext()` would allow us to add this information
    to a context in some middleware, and `ClaimsFromContext()` would allow us to extract
    it anywhere in the call chain that was required.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I recommend that all public functions and methods have an initial argument of
    `ctx context.Context`. This allows you to add future-proofing to your public functions/methods/interfaces
    if you need to add capabilities that `Context` provides at a later date, even
    if you aren't using it now.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Future-proofing methods/functions/interfaces is a practice of adding arguments
    and return values that are not used at the moment in order to prevent breaking
    them (and users) at some future date—for example, adding a returned `error` for
    a constructor that cannot currently return an error, but might in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you won't need to handle cancellations (execution is too fast or can't
    be canceled), but something such as adding telemetry might come in handy later.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about Go's `Context` object and how it is used
    to signal cancellation and to pass values through the call stack. You will see
    this used in many of the third-party packages you will use in your code. The final
    topic of this chapter will be about *Go's testing package*. Let's dive right into
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing Go's testing framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Testing** is one of the most important and least loved parts of any language.
    Testing provides a developer with the knowledge that something works as expected.
    I cannot count the times that writing unit tests has proven that a function or
    method did not work the way I expected. This saved countless hours of debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To this end, tests need to have the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to write
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast to execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple to refactor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effortless to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To satisfy these needs, Go tackles tests by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Breaking tests into their own files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing a simple `testing` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a testing methodology called **table-driven tests** (**TDTs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will cover how to write basic tests, Go's standard TDT methodology,
    creating fakes with interfaces, and—finally—some third-party packages that I used
    and others that are popular, but I don't necessarily recommend.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a basic test file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Go tests are contained in package files with a `_test.go` suffix. These files
    have the same package name, and you can include as many test files as needed.
    The usual rule is to write a test file per package file you want to test so that
    there is a 1:1 association for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each test in a test file is a function whose name is prefixed with `Test` and
    has a single argument, `t *testing.T`, with no returns. This is how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`t` is passed by the `go test` command and provides the necessary utilities
    for our tests. The primary methods used are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`t.Error()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Errorf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Fatalf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Log()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t.Logf()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a test is executed, if the test ends without `panic`/`Error`/`Errorf`/`Fatal`/`Fatalf`
    called, the test is considered passed. If any of these are called, then the test
    fails. With `Error`/`Errorf`, the test continues executing and accumulates these
    error messages for the test. With `Fatal`/`Fatalf`, the test fails immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '`Log()`/`Logf()` calls are informative and are only displayed on failure or
    when other flags are passed for a test.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Borrowing from `golang.org` tutorials ([https://golang.org/doc/tutorial/add-a-test](https://golang.org/doc/tutorial/add-a-test)),
    let''s create a simple test for a function called `Greeter()` that takes a name
    as an argument and returns `"Hello [name]"`. The code is illustrated in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also see this example here: [https://play.golang.org/p/vjAhW0hfwHq](https://play.golang.org/p/vjAhW0hfwHq).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the test, we need to simply run `go test` inside the package directory.
    If the test is successful, we should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To show what a failure looks like, I changed `want` to be `Hello Sarah` while
    leaving the name `Bob`, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to include enough information to debug your test. I like to
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If table-driven, the description of the table row executed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What I received (called `got`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What I wanted (called `want`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's talk about Go's preferred style of testing—TDTs.
  prefs: []
  type: TYPE_NORMAL
- en: Table Driven Tests (TDT)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For very simple tests, the preceding methodology works fine, but often, you
    need to test a function for multiple types of success and failure, such as in
    the following scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: What if they send a bad argument?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if the network has a problem and returns an error?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if the data isn't on disk?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a test per condition creates a lot of churns in a test file that is
    harder to read and understand. TDTs to the rescue! A TDT uses the non-named struct
    concept we talked about in [*Chapter 1*](B17626_01.xhtml#_idTextAnchor013), *Go
    Language Basics*. This is the one place where it is common to see them.
  prefs: []
  type: TYPE_NORMAL
- en: The concept is to create a list of structs where each struct entry represents
    a set of test conditions and results that we want to see. We execute each struct
    entry one at a time to test the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s convert our preceding test to a TDT. In this case, there are only two
    expected ways for our `Greet()` function to react, as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: We pass an empty string for `name`, which results in an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything else results in `"Hello"` and the name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s write a TDT that handles both these cases, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This example can also be found at the following link: [https://play.golang.org/p/vYWW-GiyT-M](https://play.golang.org/p/vYWW-GiyT-M).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, TDT tests are longer but have clearly defined test parameters
    and clear error output.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the previous example, this tests that our error condition occurs when
    `name == ""`. Using a TDT is overkill for something so simple but becomes a powerful
    tool in the toolbox when writing tests against more complicated functions in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating fakes with interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tests should generally be hermetic, meaning that tests should not use resources
    that are not located locally on a machine.
  prefs: []
  type: TYPE_NORMAL
- en: If we are testing a client to a REST service, it should not actually call out
    to the REST service. There are integration tests that should test the basic connectivity
    to a test version of a service, but those should be small and rare tests that
    we are not going to cover here.
  prefs: []
  type: TYPE_NORMAL
- en: To test the behaviors of remote resources, we create what are called **fakes**
    using interfaces. Let's write a client that talks to a service via a network client
    to get a user record. We don't want to test the logic of the server (the kind
    of logic we tested previously), but instead, want to test what happens if the
    REST client has an error or we get back the wrong record from the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s say we use a `Fetch` client in a `client` package that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `Fetch` in a function called `Greeter()` to get information we might
    use to change our responses to the person, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is hard to test hermetically because `Fetch` is a concrete type that talks
    to a service. However, we can change this to an interface that `Fetch` implements
    and then use a fake. Firstly, let''s add the interface and change the `Greeter`
    argument, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can pass a `*client.Fetch` instance or we can pass anything else that
    implements `recorder`. Let''s create a fake that implements `recorder` that we
    can cause to return results useful for testing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s integrate this into a TDT, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This example can be found here: [https://play.golang.org/p/fjj2WrbGlKY](https://play.golang.org/p/fjj2WrbGlKY).'
  prefs: []
  type: TYPE_NORMAL
- en: We now are simply faking the response that would come from our real client,
    `Fetch`. In code using `Greeter()`, they can simply pass the real client and in
    our tests, we pass our `fakeRecorder` instance. This allows us to control our
    environment to test that our function handles each type of response in the way
    we expect. This test is missing a test that checks the result when a `Record`
    instance is returned where the `Age` value is set to `< 18`. We leave this as
    an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party testing packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When I''m writing tests, there is really only one tool I reach for: [https://pkg.go.dev/github.com/kylelemons/godebug/pretty?utm_source=godoc](https://pkg.go.dev/github.com/kylelemons/godebug/pretty?utm_source=godoc).'
  prefs: []
  type: TYPE_NORMAL
- en: '`pretty` allows me to easily test if two complicated structs/maps/slices are
    equivalent. Using it in a test is simple, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This outputs a readable format showing what is missing (prepended with `-`)
    and what was received (prepended with `+`). For more control over what is compared,
    the package offers a `Config` type that can be customized.
  prefs: []
  type: TYPE_NORMAL
- en: This code doesn't get updated often because it just works, but Kyle does answer
    bug requests, so the project is still alive.
  prefs: []
  type: TYPE_NORMAL
- en: Many in the Go community use the `github.com/stretchr/testify` set of packages,
    specifically the `assert` and `mock` packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'I list them here because they are popular in the Go community; however, I would
    give the following warnings:'
  prefs: []
  type: TYPE_NORMAL
- en: Using asserts in Go for many years was considered bad practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking frameworks in Go often have terrible corner cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The original authors of Go thought that using asserts was a bad practice for
    the language and unneeded. The current Go team has relaxed this stance. Mocking
    frameworks in Go tend to rely heavily on `interface{}` and have some sharp corner
    cases. I find using mocks results in testing behavior that is not important (call
    order or which calls were executed) versus testing that a given input causes an
    expected output. This is less burdensome and fragile to code changes.
  prefs: []
  type: TYPE_NORMAL
- en: The original mocking framework ([https://github.com/golang/mock](https://github.com/golang/mock))
    was considered unsafe at Google and its use was restricted.
  prefs: []
  type: TYPE_NORMAL
- en: To sum this section up, we have learned about Go's `testing` package, how to
    use that package to write tests, the TDT methodology, and my (*John Doak's*) thoughts
    on third-party testing packages.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an understanding of how to do testing, we are going to look
    at a major addition to Go that was added in version 1.18—generics.
  prefs: []
  type: TYPE_NORMAL
- en: Generics – the new kid on the block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics are a new feature in Go 1.18 that looks to have vast ramifications
    for Go's future. Generics provide a way to represent multiple types with a new
    feature called a `type` parameter to allow functions to operate on multiple types.
  prefs: []
  type: TYPE_NORMAL
- en: This differs from the standard `interface{}` where these types of operations
    always happen at runtime and where you must convert `interface{}` to the concrete
    type to do work.
  prefs: []
  type: TYPE_NORMAL
- en: Generics are a new feature, so we are only going to give a very general overview.
    The Go community and Go authors at this time do not have a set of best practices
    that have been rigorously tested. This comes with experience in using a feature,
    and we are only at the early stages of generics at this time, with more features
    around generics coming in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type parameters can be added to functions or `struct` types to support a generic
    type. However, a key gotcha is that they cannot be used on methods! This is the
    most requested feature; however, it poses certain challenges to the language that
    the language authors are not sure how to deal with (or if they can be dealt with).
  prefs: []
  type: TYPE_NORMAL
- en: 'Type parameters are defined after the function name within brackets. Let''s
    look at a basic one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This creates a function that can sort any of our signed integer types. `I` is
    the type parameter and it is limited to the types listed in the bracket. The `|`
    pipe character acts as an `or` statement saying `I` can be an `int8` or an `int16`
    type, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once `I` is defined, we can use it as a type in our arguments. Our function
    will operate on a slice type of `I`. It should be noted that all values in `I`
    must be the same type; it cannot be a mix of say `int8` and `int64` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how that might work with a simple bubble-sort implementation,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see this example here: [https://go.dev/play/p/jly7i9hz0YT](https://go.dev/play/p/jly7i9hz0YT).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a function that can be used to sort any type of signed integer.
    If we were to do this without generics, it would require an argument of `interface{}`
    that would need to be type switched on the slice type. Then, we would need to
    write functions to handle each type. You can see an example of what that would
    look like here: [https://go.dev/play/p/lqVUk9GQFPX](https://go.dev/play/p/lqVUk9GQFPX).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The other option would be to use runtime reflection using the `reflect` package,
    which is slow and unwieldy. `reflect` is an advanced package that has lots of
    gotchas and should be avoided unless absolutely necessary. Here is an example
    of this method: [https://go.dev/play/p/3euBYL9dcsU](https://go.dev/play/p/3euBYL9dcsU).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the generic version is much simpler to implement and can significantly
    reduce your code base.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how we could make this slightly easier to read using type
    constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Using type constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our last example, `int8 |int16 |int32 |int64` was our type constraint. It
    limited the types that we could use for our `I` value type parameter, but typing
    that all the time is burdensome, so we can also define named type constraints.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the addition of generics is likely to create some confusion.
    Type constraints are made using the `interface` type. Here''s an example of a
    type constraint containing what we had previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use that in our previous code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This reduces the amount of boilerplate we need. It is important to note that
    `SignedInt` is a type constraint and not a type. `I` is a defined type parameter
    that acts as a type. I''ve often found myself writing code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: However, that syntax is incorrect. `SignedInt` here is simply the definition
    of a constraint, not a type to be used. `I` is the type to be used in the generic
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another gotcha is that `SignedInt` can only be used on the exact basic types
    defined here. You might create your own type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do so, you cannot use this as a `SignedInt` type constraint. But not
    to worry—if we want this to work on any type based on signed integers, we can
    change this to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`~` signals that we want to allow any type based on this type.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at how we can write our sort function to handle more than just
    signed integers.
  prefs: []
  type: TYPE_NORMAL
- en: We could do better with constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we are doing here can be applied to more than just signed integers. We
    could make changes to which types we support, and our function would work exactly
    the same on a larger set of slice types.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that a type must have for our function to work is that the type
    must be able to use `>` on two variables that share the same type. That is what
    allows the `if slice[i] > slice[i+1]` statement to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current Go version, as of this writing, does not define a few basic type
    constraints that are planned for a future release. This future package, which
    will likely be called `constraints`, is being developed here: [https://pkg.go.dev/golang.org/x/exp/constraints](https://pkg.go.dev/golang.org/x/exp/constraints).'
  prefs: []
  type: TYPE_NORMAL
- en: 'It includes a type constraint that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We will borrow that here and change our function signature, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our function can sort any type of slice that can be compared using `>
    <`. See it at work here: [https://go.dev/play/p/PwrXXLk5rOT](https://go.dev/play/p/PwrXXLk5rOT).'
  prefs: []
  type: TYPE_NORMAL
- en: Current built-in constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go has two constraints that are currently built in, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`comparable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`any`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comparable` contains all types that support `==` or `!=` operators. This is
    particularly useful when writing generics that use `map` types. The key to a `map`
    type is always the `comparable` type.'
  prefs: []
  type: TYPE_NORMAL
- en: '`any` is an alias for `interface{}`. The Go team has changed all references
    to `interface{}` in the Go standard library to `any`. You may use them interchangeably,
    and `any` as a type constraint allows any type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a function that extracts all keys from a `map` type using
    these constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is running in the playground, so give it a try: [https://go.dev/play/p/h8aKwoTaOLj](https://go.dev/play/p/h8aKwoTaOLj).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at what happens if we do type constraining and we constrain a type
    such as a standard interface by requiring a method.
  prefs: []
  type: TYPE_NORMAL
- en: Type constraints with methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A type constraint can act like a standard interface in that it can require
    methods to be attached to the type. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This type constraint can only be satisfied by a type based on `string` and that
    has the `Print()` method defined.
  prefs: []
  type: TYPE_NORMAL
- en: A key requirement here is that we use `~string` and not `string`. A standard
    `string` type can never have the `Print()` method, and therefore this type constraint
    could never be satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple use of this constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a look at why you might want to add type parameters to struct
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Adding type parameters to struct types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we wrote a generic function for sorting slices called `SortSlice()`,
    but that has some limitations in that it can only handle slices that are based
    on types that meet the constraints in `constraints.Ordered`. Oftentimes, we might
    want to handle slices that might contain types based on `struct`—say, for example,
    this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Our `SortSlice()` function could not handle a `[]Record`, so we need to do something
    different to handle these types of cases.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we want to use Go's built-in `sort.Sort()` function. This
    is a highly optimized sort that uses multiple sorting algorithms, depending on
    slice size.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it, you need a type that implements the `sort.Interface` type. That
    `interface` type is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Before Go generics, you would have needed to implement an adapter type to implement
    these for every type you wanted to sort. For example, here is an adapter to sort
    `[]int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'And you could use it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that running here: [https://go.dev/play/p/Yl6Al9ylEhd](https://go.dev/play/p/Yl6Al9ylEhd).'
  prefs: []
  type: TYPE_NORMAL
- en: You would then need to do this for every other signed type or other types you
    wanted to sort. Imagine doing this for all `int8`, `int16`, `int32`, and `int64`
    signed integer types. You would also need to do that for every other type you
    want to sort.
  prefs: []
  type: TYPE_NORMAL
- en: So, what we want to do is use generics to give us a single adapter type that
    can be used for a slice with any element type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use a `type` parameter on a struct to allow us to create a generic adapter
    so that we can adapt any slice to the `sort.Interface` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to `intAdapter` from before, with two distinctions, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The slice elements are a `T` type parameter that can be any value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a `less` field, which is a function that does the comparison when `Less()`
    is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a function that can implement `func(T, T) bool` for our `Record`
    type. This compares the full name with the last name being considered first. The
    code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use `sortableSlice` to write a generic sort function that uses
    the existing `sort.Sort()` function to sort any slice that we can do comparisons
    on. Here''s the code we need to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is this in action: [https://go.dev/play/p/6Gd7DLgVQ_y](https://go.dev/play/p/6Gd7DLgVQ_y).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that when we create our `sortableSlice` instance, we have `[T]`
    in the syntax. This is used to tell Go what type `T` will be, which in this case
    is the generic `T` type passed in `SortSlice`. If you try to remove `[T]`, you
    will get the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We will talk about this in our next section.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you want to do a generic sort without using the `sort.Sort()`
    function,
  prefs: []
  type: TYPE_NORMAL
- en: 'this can be done with less complication. Here is a generic version of the quicksort
    algorithm that uses generics: [https://go.dev/play/p/gvPl9jHtAS4](https://go.dev/play/p/gvPl9jHtAS4).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will look at calling a generic function when Go cannot infer a type
    for the generic function to use.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the type when calling a generic function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, all the generic cases up until the `sortableSlice` function have allowed
    the Go compiler to infer which type would be used and therefore how to deal with
    invoking the function.
  prefs: []
  type: TYPE_NORMAL
- en: But Go cannot always infer which type it needs to use. We can see in our last
    section where we told `sortableSlice` it would be using the `T` generic type we
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a function that can be used with `SortSlice()` to do our less
    comparison whenever the types are of type `constraints.Ordered`. The code is illustrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: With this, we can call `SortSlice()` and pass in any slice of types contained
    in `constraints.Ordered` and our new `orderedCmp` generic function to sort a slice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give it a try, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Uh oh—Go can''t seem to get that to work, as we receive the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This is because we are passing the function and not invoking the function. Go's
    inference only currently happens by looking at the call types it receives. It
    doesn't infer inside `SortSlice()` where `orderedCmp()` will be called and passed
    a `string` type. So, to use it, we need to tell it which type it will be working
    on when it is called.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, `SortSlice()` doesn't require this because it is being invoked
    directly and can infer that `T` will be a `string` type from looking at the passed
    argument, `strings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using `[string]`, we can give `orderedCmp` a little more information for
    this to work, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that it knows that we will be comparing `string` types, it is ready to
    rock and roll, as you can see here: [https://go.dev/play/p/kd6sylV17Jz](https://go.dev/play/p/kd6sylV17Jz).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to be very verbose, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's take a look at some common gotchas you might run into when trying
    to use generics.
  prefs: []
  type: TYPE_NORMAL
- en: Gotchas to watch for
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are playing with generics, there are a lot of gotchas where the error
    messages are not yet clear. So, let's talk about some of them so that you can
    avoid the mistakes that I've made.
  prefs: []
  type: TYPE_NORMAL
- en: 'First up, impossible type constraints. See if you can spot the problem in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to run this, you would get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because `Values` is incorrectly defined. I forgot to put `|` after
    `int64`. Without that, the constraint says the value must be `int8` or `int16`
    or `int32` or `int64` `string` or `[]byte` type. That is an impossible type, which
    means nothing can implement it. You can see this here: [https://go.dev/play/p/Nxsz4HKxdc4](https://go.dev/play/p/Nxsz4HKxdc4).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next gotcha is instantiation when returning `struct` types that implement
    type parameters. Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'An attempt to compile this code will give you the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'It was not clear to me what the problem was here for a while. It turns out
    that I needed to add the `type` parameter on the return value as well. Here is
    the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: With this change, everything works fine. Try the broken version ([https://go.dev/play/p/EGTr2zd7qZW](https://go.dev/play/p/EGTr2zd7qZW))
    and fix it with the aforementioned change to familiarize yourself.
  prefs: []
  type: TYPE_NORMAL
- en: I expect that we will see better error messages and better detection in our
    development tools in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the basics of generics, let's talk about when you should
    consider using generics.
  prefs: []
  type: TYPE_NORMAL
- en: When to use generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only guideline at this time is taken from the creator of Go''s generics
    feature, Ian Taylor, as presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '"*If you find yourself writing the exact same code multiple times where the
    only difference between the copies is that the code uses different types, consider
    whether you can use a type parameter.*"'
  prefs: []
  type: TYPE_NORMAL
- en: 'I have found this translates to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*If your function needs a switch statement on the generic type, you should
    probably be using standard interfaces instead of generics.*'
  prefs: []
  type: TYPE_NORMAL
- en: To close out on generics, I would leave you with the thought that this is a
    new language feature, and the jury is still out on the best ways for this to be
    used. The best advice I can give is to be reserved in your use of this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the essential parts of the **Go** language.
    This has included handling errors, using Go concurrency, taking advantage of Go's
    testing framework, and an introduction to Go's newest feature, generics. The skills
    acquired in this chapter are essential for all future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: You should now possess the ability to read Go code contained in the rest of
    the book. In addition, this chapter has given you the necessary skills to write
    your own Go code. We will use these skills to manipulate files in the filesystem,
    execute commands on remote machines, and build RPC services that can do a myriad
    of tasks. You will build chatbots in order to do **chat-based operations** (**ChatOps**)
    and write software to extend Kubernetes. The learnings here are truly foundational.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how to setup your Go environment to compile code locally
    on your machine. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
