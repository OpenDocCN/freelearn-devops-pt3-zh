- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Brief Introduction to Release Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new or improved software product is referred to as a **release** in the discipline
    of software engineering. This comprises any and all associated procedures and
    artifacts that are necessary for its development.
  prefs: []
  type: TYPE_NORMAL
- en: A release is the climax of the software development and engineering process,
    and it represents an iteration of the product that is both comprehensive and fully
    functional. Before software products are made available to the general public,
    they will typically go through the alpha and beta testing phases. A release is
    typically reserved for the final, polished version of the software, though it
    can also be used to describe the debut of an alpha or beta version as well. You
    may also encounter the phrases “launches” and “increments” when discussing releases
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Most companies use a system of sequential numbers or letters to label their
    releases. The term **software versioning** describes this naming convention. Each
    organization consistently applies its own internal standard, but **semantic versioning**
    (**semver**) is the common industry-wide standard for how these unique IDs should
    evolve from release to release.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will define release management and learn its cultural significance
    and technical perspective. Further, we’ll review a brief history of release management
    and understand how it evolved over the years. Finally, you’ll look at the standard
    six phases of any release management model. It is important to note that **Waterfall**
    was the original release management standard, but using Waterfall is not obligatory.
    Release management is agnostic of your chosen model and is adaptable to many kinds
    of SDLC models, which we will cover more in [*Chapter 3*](B21803_03.xhtml#_idTextAnchor051).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the main topics that we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is release management, and how did it evolve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dissecting the release management life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is release management, and how did it evolve?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Release management** is a comprehensive set of activities that involve strategic
    planning, conceptualization, scheduling, rigorous testing, seamless deployment,
    and the effective control of a software release. The primary objective of this
    practice is to facilitate the quick delivery of essential application features
    and enhancements to the customer by software development teams while simultaneously
    upholding the integrity, confidentiality, and availability of an established production
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: In the competitive landscape of business and IT, product releases that lack
    quality or features are the quickest way to give your competitor an advantage.
    Modern enterprises are dynamic, and multitudes of changes get completed at varying
    paces. Enterprises need release control and deployment automation to orchestrate
    all of these changes so that the final product delivers the exceptional value
    that their customers expect. Successful release management enhances the frequency
    with which releases are completed and decreases the frequency with which quality
    issues arise for a business. As a result, businesses can provide software more
    quickly while also reducing the associated risks, yielding increased productivity,
    communication, and co-operation.
  prefs: []
  type: TYPE_NORMAL
- en: Because of these enhancements, the team is now able to generate high-quality
    software on a consistent basis in far less time than before, which enables the
    organization to be more responsive to the demands of customers or changes in the
    operational environment. Standardizing and streamlining the development and operations
    process is another benefit of release management. The group establishes release
    controls that can be audited, resulting in a central location from which all releases
    can be retrieved. The maturity of an organization can be further improved by instituting
    a standard, written procedure for all releases to follow. Teams can learn more
    from past releases and apply that knowledge to future iterations if they standardize
    and concentrate on the product.
  prefs: []
  type: TYPE_NORMAL
- en: The improved communication between operations and developers is well-received
    because it results in fewer surprises. Now, cross-functional teams will not have
    to worry about operations being left to **patch and pray** or **fight fires**
    because of missed deadlines after a release has been **thrown over the wall**
    from development. As a result, more time is available for automating business
    processes or fixing incompatibilities in the configurations of integrations in
    the development and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s quickly define some of the key terms that you might come across in the
    course of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Patch and pray**: In software development, a tactic known as “patch and pray”
    refers to the uses of brittle solutions, sometimes known as “patches,” for resolving
    defects or vulnerabilities without solving the deeper, more underlying source
    of the problem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is notorious that organizations employ this technique to make rigorous deadlines,
    give higher priority to other activities, or compensate for lack of resources;
    nonetheless, this strategy might result in long-term technical debt as well as
    significant security concerns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Fight fires**: In the field of computer science, firefighting involves allocating
    resources to solve an unforeseen issue. The word indicates bug hunting rather
    than feature integration. Firefighting may involve adding engineers to fix problems
    with code discovered near a product’s release deadlines during software development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plenty of businesses are ready for firefighting situations, but recurring emergencies
    indicate poor planning or inefficiency and wasted resources that could be used
    elsewhere. Comprehensive **disaster recovery planning** (**DRP**) anticipates
    and perhaps prevents catastrophes, minimizing firefighting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Thrown over the wall**: This is business slang for completing your part of
    a project and then passing it off to the next group. This phrase is usually said
    when there is little communication between two groups or little to no time for
    technical briefings just prior to a new deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a nutshell, release management fosters collaboration amongst departments
    within an IT firm. This allows for more comprehensive improvements to the product
    distribution process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand the meaning of release management, let’s expand on this
    topic. In the sections ahead, we will review the history of release management
    to see how new models emerged over time and how they aligned with contemporary
    software development philosophies of their day. Later, we’ll wrap up this chapter
    by examining the six standard phases that any release management model should
    include.
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of release management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The transition in focus of software engineering from project-based to product-based
    offerings is responsible for the growing importance of release management. From
    the inception of release management, tasks were executed within the framework
    of a project-based development paradigm. In this approach, software developers
    treated each release as an independent project rather than as a product. Once
    the software was finished being developed, it generally signaled the end of the
    developers’ role in the process, and then they would be disbanded.
  prefs: []
  type: TYPE_NORMAL
- en: Over the course of time, the process of software development gradually evolved
    to bear a greater resemblance to the product cycle, wherein products undergo support,
    enhancement, and many relaunches across an extended lifespan. Within this particular
    structure, the primary objective of development was not the release itself, but
    rather, the release served as a demarcation point for the start of support and
    revision activities. Because of this complexity, phase co-ordination has become
    more important than ever. For this reason, modern release management draws ideas
    from business-oriented product management, which includes post-sale support and
    enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution from software to release management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When British computer scientist Tom Kilburn created the first piece of software
    in 1948, he used eight words of working storage and 17 words of instructions,
    for a total of 25 words. Since then, software development processes have advanced
    significantly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In spite of his coworker’s mockery, in 1953, Paul Niquette proposed the concept
    of a computer whose program could be kept separate from the physical components
    of the device. From that point forward, this revolutionized the way that people
    conceived computation:'
  prefs: []
  type: TYPE_NORMAL
- en: When I first said ‘software’ out loud, people around me said, “Huh?” From the
    very beginning I found the word too informal to write and often embarrassing to
    say. Nevertheless, with smirking trepidation I did occasionally feature the word
    ‘software’ in speeches and lectures and media interviews throughout the fifties.
  prefs: []
  type: TYPE_NORMAL
- en: '(Paul Niquette, Introduction: The Software Age).'
  prefs: []
  type: TYPE_NORMAL
- en: In the first half of the twentieth century, when inventions such as the **electronic
    numerical integrator and computer** (**ENIAC**) sped up the development of computing,
    software wasn’t complex enough to require a framework such as the **software development
    life cycle** (**SDLC**). Simple tools such as go-to lines and if/then expressions
    were used in the first software implementations. The requirement for developing
    models eventually led to the SDLC, which, in turn, was inspired by the idea of
    **structured programming**.
  prefs: []
  type: TYPE_NORMAL
- en: Structured programming is a programming paradigm that seeks to enhance the clarity,
    quality, and efficiency of a computer program by employing structured control
    flow components such as selection (if/then/else) and repetition (while and for),
    as well as block structures and subroutines. The emergence of the **ALGOL 58**
    and **ALGOL 60** programming languages in the late 1950s marked a significant
    development in the field. Notably, ALGOL 60 introduced support for block structures
    in 1960, further enhancing its capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The **software development methodology**, commonly referred to as **SDM**, did
    not come into practice until the 1960s. The **systems development life cycle**
    (**SDLC**) can be regarded as the earliest publicized release management methodology
    and framework for constructing mainframes and other analog information systems,
    pre-dating the **software development life cycle**. The primary objective of the
    systems development life cycle is to systematically and meticulously pursue the
    development of information systems. This entails adhering strictly and sequentially
    to each stage of the life cycle, from the initial conception of the idea to the
    final delivery of the system within the specific framework being employed. Notably,
    by switching out systems for software, a new form of SDLC was born. It aspires
    to be the definitive standard in the industry by detailing the inputs, outputs,
    and steps involved in creating and maintaining software systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term **Waterfall** came many years after its formal SDLC specification
    was invented (you can see an illustration of the Six phases of the Waterfall release
    management model in *Figure 3**.2* in [*Chapter 3*](B21803_03.xhtml#_idTextAnchor051)).
    The first known presentation describing the use of Waterfall’s phases in software
    engineering was held by Herbert D. Benington on June 29, 1956, although the term
    Waterfall wasn’t used at the time. The earliest formal, detailed illustration
    of the **Waterfall model** can be traced back to a 1970 essay by Winston W. Royce,
    but the name Waterfall is not used in Royce’s article itself. The phrase Waterfall
    was allegedly first documented in a research piece published in 1976 by Thomas
    E. Bell and T.A. Thayer. By 1985, the **Waterfall release management methodology**
    was codified by the United States Department of Defense in DoD-STD-2167A. The
    DOD’s standards for working with software development contractors stated that
    “*the contractor shall implement a software development cycle that includes the
    following six phases: Software Requirement Analysis, Preliminary Design, Detailed
    Design, Coding and Unit Testing, Integration,* *and Testing*.”'
  prefs: []
  type: TYPE_NORMAL
- en: Beginning with NASA’s Project Mercury in the 1960s, **iterative and incremental
    development** (**IID**) was one of the earliest and closest competitors to Waterfall
    release management. Some of the Mercury team went on to form a new IBM subsidiary
    that was responsible for creating the core avionics software system for the space
    shuttle, which operated from 1977 until 1980\. Over the course of 31 months, the
    team performed 17 iterations of IID, with each iteration lasting about 8 weeks
    on average. They decided against using a Waterfall development approach because
    the requirements for the shuttle program were well-known to shift halfway through
    the creation of the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In his 1986 study, Barry Boehm initially outlined the **spiral model** and
    provided the now-famous diagram, which has been used in numerous subsequent publications
    that discuss it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: The spiral release management model (image credit: static.hlt.bme.hu)](img/B21803_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The spiral release management model (image credit: static.hlt.bme.hu)'
  prefs: []
  type: TYPE_NORMAL
- en: The **IT Infrastructure Library** (**ITIL**) started during the 1980s in response
    to the decentralization of data centers and the use of geographically diversified
    architectures. This behavior resulted in variations in processes and deployments,
    leading to inconsistent or unsatisfactory management of IT services inside enterprises.
    The **Central Computer and Telecommunications Agency** (**CCTA**) of the United
    Kingdom recognized the significance of viewing information technology as a service
    and using consistent procedures across the entirety of the information technology
    service life cycle. As a result of this, the CCTA established the Government Information
    Technology Infrastructure Management methodology. By 1989, CCTA published ITIL
    version 1.
  prefs: []
  type: TYPE_NORMAL
- en: The **V-model** concept emerged concurrently, albeit independently, in Germany
    and the United States during the latter part of the 1980s. The US V-model, which
    was outlined in the 1991 proceedings of the **National Council on Systems Engineering**
    (**NCOSE**), currently known as INCOSE since 1995, was designed specifically for
    satellite systems that encompassed hardware, software, and human interaction.
    The German V-model was initially formulated by IABG, a research and development
    organization located in Ottobrunn, in collaboration with the Federal Office for
    Defense Technology and Procurement in Koblenz. This joint effort was undertaken
    by the Federal Ministry of Defense. In the summer of 1992, the Federal Ministry
    of the Interior assumed control of the civilian public authority’s domain.
  prefs: []
  type: TYPE_NORMAL
- en: Jacobson, Booch, and Rumbaugh (1999) introduced the concept of the **unified
    process** in their book titled *Unified Software Development Process*. This seminal
    work presented the initial discourse of an agile framework for software development.
  prefs: []
  type: TYPE_NORMAL
- en: The inception of the **Agile release model** took place in a renowned resort
    located in Snowbird, Utah, in 2001\. A group of 17 prominent software engineers
    convened to engage in discourse about lightweight development methodologies, subsequently
    culminating in the joint development of the **Manifesto for Agile Software Development**
    (aka. The Agile Manifesto). In 2009, a collective associated with Robert C. Martin,
    co-author of the Agile Manifesto, developed an expansion of software development
    principles known as the **Software Craftsmanship Manifesto**. This manifesto aimed
    to guide the practice of agile software development in accordance with principles
    of professional conduct and mastery.
  prefs: []
  type: TYPE_NORMAL
- en: In 2007, an IT consultant named Patrick Debois established the DevOps methodology
    after realizing that the **development** (**Dev**) and **operations** (**Ops**)
    teams were not co-operating very effectively with one another. Although he has
    always found the gaps and disputes between Dev and Ops uncomfortable, the continual
    switching and back and forth on a large data center migration project where he
    was responsible for testing was particularly frustrating for him. One day, he
    was completely immersed in the flow of Agile software development. The following
    day, he was involved in firefighting and experienced firsthand the uncertainty
    that comes with traditional operations. He was sure there was a more effective
    approach somehow.
  prefs: []
  type: TYPE_NORMAL
- en: Andrew Shafer organized a gathering of **birds of a feather** (**BoF**) the
    next year at the 2008 Agile Conference to discuss **Agile infrastructure**. Andrew
    was under the impression that no one would show up to the meeting, so he decided
    not to attend it himself. When Patrick Debois showed up, he immediately went in
    search of Andrew so that he could discuss Agile infrastructure as the solution
    to making operations as agile as the developers were. This is the point at which
    the DevOps movement began.
  prefs: []
  type: TYPE_NORMAL
- en: At the Velocity conference in 2009, John Allspaw and Paul Hammond gave a presentation
    titled “*10+ deploys per day - Dev and Ops Cooperation at Flickr*,” and after
    that, the concept began to acquire popularity among development teams. This discussion
    opened people’s eyes to the possibilities that may be realized by using these
    early DevOps approaches. Additionally, Patrick organized and presided over the
    first DevOpsDays conference, which took place in Ghent, Belgium, in October 2009\.
    The conference was dubbed *The conference that brings development and operations
    together*. This is where the term **DevOps** was first publicly mentioned. The
    *DevOpsDays conference* is now a regional event that takes place internationally
    on a regular basis in a variety of locales.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you’ll see a timeline of release management history.
    It started in 1953 when the term “software” was coined. From there, you’ll see
    the evolution from Waterfall to DevOps. Ironically or not, you’ll still see both
    of these models being used up until the present day. One thing to notice is how
    fast progress accelerated over time, starting at a rate from decades to only years.
    Knowing where you’ve been is key to understanding how you’ve gotten to where you
    are now. The history of release management has culminated in the creation of DevOps.
    It is vital to know this in order to appreciate why DevOps has grown to be one
    of the most widely adopted release management models in software development history:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Timeline of release management history](img/B21803_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Timeline of release management history'
  prefs: []
  type: TYPE_NORMAL
- en: So far, you’ve learned about the purpose of release management and its history.
    Now you know how new models emerged over time and why they reflected the philosophies
    of the day. Now, let’s wrap up this chapter by examining the six standard phases
    that any release management model should include.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting the release management life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The release management life cycle encompasses various distinct stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: The six standard phases of release management](img/B21803_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: The six standard phases of release management'
  prefs: []
  type: TYPE_NORMAL
- en: The variability of this process is contingent upon the chosen release management
    model, product design, the team, and the organization, as it is all influenced
    by the unique project requirements. Nevertheless, it is essential for organizations
    and teams, regardless of their scale, to adhere to a set of universally applicable
    procedures in order to achieve financial sustainability and provide users with
    high-quality results.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s have a look at what a standard procedure for release management consists
    of.
  prefs: []
  type: TYPE_NORMAL
- en: Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Requests for new features or modifications to current functionality are the
    first steps in the release management process. No promise can be made that any
    and all requests will result in a new release. Each request is analyzed to determine
    if it makes sense, if it can be implemented, and if the current version of the
    application can be modified to accommodate it.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you are starting from scratch or want to improve an already established
    product, knowing what is expected of you is essential. Do not assume that you
    already know what features and functionality your client wants to be included
    in an application or related product. As an example, customers may request that
    you incorporate a new feature into their mobile app. You will need to sit down
    with them to have a meeting in order to fully grasp their needs, desires, and
    motivations.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever your goal is, make sure you understand it thoroughly before proceeding
    to planning and development. If you have any doubts, consult with your team or
    the customer before proceeding in order to come up with an appropriate release
    strategy that meets the need.
  prefs: []
  type: TYPE_NORMAL
- en: Plan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After you have a complete understanding of the requirements for the release,
    the next step is planning. In order to build and release what you intend to do,
    you will need to have thorough planning and preparations that are based on the
    needs of all stakeholders involved. In terms of the technology, the deadline,
    the staff, and the resources, your preparation needs to be reasonable and practical.
    If you are developing a new version of an app for release, for instance, you need
    to test it thoroughly on a wide variety of platforms and devices before releasing
    it to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: Planning is easier if you stay in regular contact with the client. The project
    schedule and expected delivery date of the finished product can be discussed.
    You must not commit to an impossible deadline. When confirming the due date, take
    into account the available resources (money, time, and personnel). In addition,
    it is wise to consider which technologies you will be using before the release
    and plan accordingly. Consider whether your choices are cost-effective, fit your
    budget, and make use of the talents of your staff. Pick tools that will allow
    you to quickly and easily design a high-quality product and get it out to customers.
    Planning also requires the efficient allocation and utilization of available resources
    to prevent waste and ensure the efficient construction of a product.
  prefs: []
  type: TYPE_NORMAL
- en: You have a variety of options available to you for outlining your plan, one
    of which is the use of a release management checklist. The process’s roles and
    responsibilities ought to be outlined in the checklist in something approximating
    chronological order. If your team looks at the checklist, they should easily be
    able to determine what stage they are currently in as well as what their part
    or task in the process is. To create a solid release plan, hold a meeting with
    your development and operations teams to discuss the requirements, obstacles,
    and strategies for overcoming them, including the most efficient means of achieving
    the objective. When in doubt, include your customer in the conversation.
  prefs: []
  type: TYPE_NORMAL
- en: Design and Build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the strategy is complete, the following step is to design and develop
    the product. Plans and strategies developed in response to these specified requirements
    can now be put into action. In order to complete this step, your programmers will
    need to write the code that will eventually be able to convert to the features
    or functionalities that you plan to add to your product.
  prefs: []
  type: TYPE_NORMAL
- en: This stage can repeat itself multiple times over the course of the whole release
    cycle, much like the continuous development strategy in DevOps. After the developer
    has finished writing the code, there is a possibility that it contains a number
    of problems, faults, and defects that need to be tested. Multiple rounds of testing
    will be performed on the code before it is finally accepted. The whole list of
    problems that need to be resolved and optimized should be provided to the developers
    so that they can prioritize their backlog and produce software that performs as
    it was intended. One way to help with this is through the use of bug-tracking
    tools, such as **FindBugs**, **Eslint**, and **Sonarlint**.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated previously, testing code is necessary to guarantee there are no errors
    or defects that could compromise the software’s functionality, speed, or safety.
    Manual testing is better than no testing at all, but automated testing should
    be implemented where possible.
  prefs: []
  type: TYPE_NORMAL
- en: The terms functional testing and non-functional testing are sometimes used incorrectly
    as interchangeable concepts. As mentioned in [*Chapter 1*](B21803_01.xhtml#_idTextAnchor015),
    there are many different types of testing that can be performed, and they all
    usually fall under these two categories. When problems are found, the code is
    then sent back to the developers so that they can fix the issues and resubmit
    the code for further review.
  prefs: []
  type: TYPE_NORMAL
- en: User acceptance testing is the final step before releasing the software product
    to the end users, during which the customer will verify that it meets their needs
    and operates as intended. The next steps are dependent on the user’s acceptance.
    Otherwise, comments from users are used to revise the code, which is then tested
    further before being released.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the software development team has confirmed that the product has been
    developed in accordance with specifications and is bug-free, they will then get
    it ready to be released to the public or deployed for a client.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the QA team will be in charge of carrying out the final tests
    to guarantee that the finished product satisfies all of the product release plan’s
    business requirements and minimal standards. After that, it will be examined by
    the management or the owner of the product to ensure that it may be shipped out.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the documentation that was required to assist other developers
    in comprehending the software and learning how to utilize it has been completed.
    In addition, the teams complete all of the required documentation in order to
    hand off the finished product to the customer. In addition to this, companies
    should think about providing their consumers or staff with training on how to
    utilize the new product so that they can operate with it productively.
  prefs: []
  type: TYPE_NORMAL
- en: Post-deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regardless of whether the release has been developed for internal use or for
    customers, the duties associated with it extend beyond the deployment phase. Irrespective
    of the current efficiency and functionality of the software, regular maintenance
    is necessary to ensure optimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, security problems can arise at any time. When that happens, it
    can have a devastating impact on your company and its reputation. Many different
    things can have an effect on your software, leading to performance issues, crashes,
    security holes, usability problems, and so on. Therefore, even after the software
    has been made available to end users, you should never stop monitoring it. You
    need to set aside some time to investigate the system’s performance, security,
    usability, and stability in order to identify any problems and correct them before
    they can have an impact on users.
  prefs: []
  type: TYPE_NORMAL
- en: From initial conception to final deployment and maintenance, this is what a
    release management process looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have arrived at the end of this chapter let’s quickly revisit the
    main takeaways from this lesson. You now know the meaning of release management
    and its history.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding where you are in your release management process is vital. You
    should approach this from both a quantitative and qualitative perspective. Gathering
    some fundamental data, such as the average release timings, the kinds and priority
    of releases, the number of errors, and the number of delayed releases, is an important
    step in the quantitative analysis process. These are used to determine performance
    baselines as well as the present state of release management. In terms of the
    quality of the information, talk to the people who are involved in the release
    management process, particularly in the areas where development interacts with
    operations, and find out what their thoughts are. They will be able to point out
    realities that are not clearly reflected in the data and statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a regular release cycle leads to the creation of consistency, enabling
    you to gain control over your release management tasks and duties. Instead of
    focusing on trying to establish a culture right from the start, put lightweight
    release processes in place. Because of this, you are able to set up the infrastructure
    for releases at an earlier stage, test it, and make adjustments to it as required.
    Over the course of time, the procedures that are most effective will eventually
    become your organization’s standard. Following the completion of your initial
    research, you will be better positioned to initiate more stringent quality criteria
    and make improvements to efficiency. Eliminating downtime and testing for regressions
    are two ways to reduce the impact that releases have on your users. At that point,
    you can also begin to think about normalizing and automating procedures, such
    as testing and verification, which are both essential steps in the development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: It takes time for a truly collaborative culture of release management to mature,
    and it requires a well-managed infrastructure as a foundation on which to mature.
    You can nurture this culture by making investments in your team and investing
    in release management tools and approaches that enable people to take a holistic
    view of every phase of the release management process. Both of these types of
    investments will help you build a culture of excellence and make work more visible.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes [*Chapter 2*](B21803_02.xhtml#_idTextAnchor036). In this chapter,
    we have learned what release management is from both a cultural and technical
    perspective. Then, we explored a brief history of release management and how the
    various models have originated over time. Finally, you’ve seen the standard six
    phases of release management that any model should have.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B21803_03.xhtml#_idTextAnchor051), we will dive deep into the
    mechanics of the most common release management Models. The significant point
    to make here is that it’s nearly impossible to fully appreciate the meaning of
    DevOps if you aren’t familiar with the release management models that came before
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Which came first, the software development life cycle or the systems development
    life cycle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the systems development life cycle and the software
    development life cycle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What year was the term software first coined, and who coined it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who is credited with drafting the first specification of the Waterfall release
    management model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who is credited with coining the term Waterfall, and what year was it coined?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the six standard phases of any release management model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Who is credited with creating the DevOps methodology?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What year did the first DevOpsDays event take place and where?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What year did structured programming proliferate and become mainstream?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What year was iterative and incremental software development first utilized?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
