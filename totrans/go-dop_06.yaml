- en: 'Chapter 5: Using Common Data Formats'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key skills that a DevOps engineer requires is the ability to manipulate
    data across a variety of storage mediums.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we interacted with the local filesystem to read and stream
    files. That is foundational for the skills we will be learning in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on how to manipulate common data formats that engineers
    commonly use. These formats are used to configure services, structure log data,
    and to export metrics, among the many other uses.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use `struct` field tags to store metadata
    about fields. Also, you will learn how to stream these formats efficiently when
    working with large amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: Unlocking these skills will allow you to engage with services by manipulating
    configuration files, searching through records that might include logs or metrics,
    and outputting data into Excel for reporting purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: CSV files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Popular encoding formats
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will dive into the process of utilizing data in one
    of the oldest formats, CSV.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5)
  prefs: []
  type: TYPE_NORMAL
- en: CSV files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSV is one of the most common data sources that a DevOps engineer can encounter.
  prefs: []
  type: TYPE_NORMAL
- en: This simple format has long been a mainstay in the corporate world as one of
    the easiest ways to export data out of a system for manipulation and back into
    a data store.
  prefs: []
  type: TYPE_NORMAL
- en: Many critical systems at large cloud providers, such as Google's GCP and Microsoft's
    Azure, have critical data sources and systems based on the CSV format. We have
    seen systems such as network modeling and critical data reporting stored in CSV.
  prefs: []
  type: TYPE_NORMAL
- en: Data scientists love CSV for its easy searching and streaming capabilities.
    The added quality of being able to quickly visualize the data in software has
    only added to its appeal.
  prefs: []
  type: TYPE_NORMAL
- en: And, like many other formats, it is human-readable, which allows the data to
    be manipulated by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we are going to focus on importing and exporting CSV data
    using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `strings` package and the `bytes` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `encoding/csv` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we are going to look at importing and exporting data to the popular
    Excel spreadsheet format using `excelize`, which is a popular package for Microsoft
    Excel.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss how we can use simple string/byte manipulation packages to
    read/write CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Basic value separation using the strings package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go provides several packages that you will find useful in the manipulation
    of the `string` and `[]byte` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bytes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These packages offer similar functionality such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions to split data such as `strings.Split()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions to merge data with separators such as `strings.Join()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buffer types that implement the `io` package's interfaces, such as `bytes.Buffer`
    and `strings.Builder`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with CSV files, a developer either streams the data or reads the
    whole file.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers prefer to read an entire file into memory and convert it from
    a `[]byte` type into a `string` type. Strings are easier for developers to understand
    the join and split rules.
  prefs: []
  type: TYPE_NORMAL
- en: However, this causes a copy to be created during conversion, which can be inefficient
    because you have to double the amount of memory used and dedicate some CPU to
    doing the copy. When that is a problem, developers reach for the `bytes` and `bufio`
    packages. These are slightly more difficult to use, but they prevent any unnecessary
    conversion cost.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how we can read an entire file and covert the entries into a structured
    record.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion after reading the whole file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When doing basic CSV manipulation, sometimes, it is easier to simply split
    data using a carriage return and then split the line based on a comma or other
    separator. Let''s say we have a CSV file representing first and last names and
    break that CSV file into records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines a `record` type based on a slice of strings, `[]string`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can check whether a `record` type was valid by calling its `validate()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The record's first name can be retrieved using `first()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The record's last name can be retrieved using `last()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It defines a `readRecs()` function to read a file, called `data.csv`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It reads the entire file into memory and converts it into a string called `content`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`content` is split by the new line character, `\n`, with each entry representing
    a line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It loops through the lines, splitting each line with a comma, `,`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It assigns each return from `Split`, which is a `[]string` type to a `record`
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It compiles all records to a slice of records, `[]record`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can view this code in action at [https://play.golang.org/p/CVgQZzScO8Z](https://play.golang.org/p/CVgQZzScO8Z).
  prefs: []
  type: TYPE_NORMAL
- en: Converting line by line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the file is large and we want to be efficient, we can use the `bufio` and
    `bytes` packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This differs from the previous code in that the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: We read each line, one by one, using `bufio.Scanner` instead of the entire file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scanner.Scan()` reads the next set of content until it sees `\n`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That content can be retrieved using `scanner.Text()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can view this code in action at [https://play.golang.org/p/2JPaNTchaKV](https://play.golang.org/p/2JPaNTchaKV).
  prefs: []
  type: TYPE_NORMAL
- en: With this version, we are still doing a `[]byte` conversion on each line into
    a `string` type. If you are interested in a version that does not do this, please
    refer to [https://play.golang.org/p/RwsTHzM2dPC](https://play.golang.org/p/RwsTHzM2dPC).
  prefs: []
  type: TYPE_NORMAL
- en: Writing records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Writing records to CSV is fairly simple using the methods that we played with
    earlier. If after reading our records, we wanted to sort them and write them back
    to a file, we could accomplish this with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also modify the `record` type to have this new method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can see this running at [https://play.golang.org/p/qBCDAsOSgS6](https://play.golang.org/p/qBCDAsOSgS6).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `writeRecs()` function does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It opens `data-sorted.csv` for writing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sorts the records using `sort.Slice()` from the `sort` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It loops over the records and writes out the CSV file, as generated by the new
    `csv()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `csv()` method does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a `bytes.Buffer` interface, which acts similar to an in-memory file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It loops through each field in the record and writes the field value followed
    by a comma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It writes a carriage return after the content on the CSV line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns the buffer as a `[]bytes` type that now represents a single line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the encoding/csv package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To handle CSV encodings that conform to the RFC 4180 standard, [https://www.rfc-editor.org/rfc/rfc4180.html](https://www.rfc-editor.org/rfc/rfc4180.html),
    the standard library provides the `encoding/csv` package.
  prefs: []
  type: TYPE_NORMAL
- en: Developers should opt to use this package for CSV handling when the CSV conforms
    to this specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'This package provides two types for handling CSVs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Reader` for reading in CSVs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Writer` for writing CSVs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will tackle the same problem as before, but we will utilize
    the `Reader` and `Writer` types.
  prefs: []
  type: TYPE_NORMAL
- en: Reading line by line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the same way as before, we want to read each CSV entry from the file one
    at a time and process it to a `record` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can view this code in action at [https://go.dev/play/p/Sf6A1AbbQAq](https://go.dev/play/p/Sf6A1AbbQAq).
  prefs: []
  type: TYPE_NORMAL
- en: 'This function utilizes our reader to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass the file to our `NewReader()`constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the reader to require two fields per record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove any leading space in a line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read each record and store it in a `[]record` slice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Reader` type has other fields that can change how data is read in. For
    more information, please refer to [https://pkg.go.dev/encoding/csv](https://pkg.go.dev/encoding/csv).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, `Reader` provides a `ReadAll()`method that reads all of the records
    in a single call.
  prefs: []
  type: TYPE_NORMAL
- en: Writing line by line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The companion of the CSV `Reader` type , `Writer`, makes it simple to write
    to a file. Let''s replace the writing part of our previous `writeRecs()`function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the runnable code: [https://play.golang.org/p/7-dLDzI4b3M](https://play.golang.org/p/7-dLDzI4b3M)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It spawns a new `Writer` type that writes to our file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It flushes our content to the file on function exit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It writes each record out as a CSV file, one per line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using excelize when dealing with Excel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft's Excel has been a popular tool for visualizing data since the 1980s.
    While the power of the program has grown, its simplicity has helped to make spreadsheets
    a common tool in most businesses.
  prefs: []
  type: TYPE_NORMAL
- en: While Excel is not CSV, it can import and export data in CSV. For basic usage,
    you can use the `encoding/csv` package detailed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: However, if your organization uses Excel, it can be more helpful to use its
    native format to write the data and supply visual representations of the data.
    `excelize` is a third-party Go package that can help you do that.
  prefs: []
  type: TYPE_NORMAL
- en: The package can be found at [https://github.com/qax-os/excelize/tree/v2](https://github.com/qax-os/excelize/tree/v2).
    Additionally, the official documentation can be found at [https://xuri.me/excelize/](https://xuri.me/excelize/).
  prefs: []
  type: TYPE_NORMAL
- en: There is also an online version of Excel that is part of Microsoft's Office
    365\. You can manipulate spreadsheets directly there; however, I find it easier
    to manipulate the spreadsheet offline and then import it.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in the REST API, you can read about it at [https://docs.microsoft.com/en-us/sharepoint/dev/general-development/excel-services-rest-api](https://docs.microsoft.com/en-us/sharepoint/dev/general-development/excel-services-rest-api).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .xlsx file and adding some data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Excel has a few characteristics that are helpful to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: An Excel file has the `.xlsx` extension.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each `.xlsx` file contains **sheets**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each sheet includes a set of rows and columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `.xlsx` file has a default sheet, called **Sheet1**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The intersection of a row and column is called a **cell**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Columns start with the letter A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rows start with the number 1\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to add some data that represents server data for a fictional fleet
    of devices. This includes the name of the server, the hardware generation, when
    it was acquired, and the CPU vendor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates an Excel spreadsheet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds column labels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds two servers, `slvaa01` and `slvac14`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It saves the Excel file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a `mustParse()`function (used, but not defined above) that converts
    a string representing a date into `time.Time`. In Go, when you see `must` proceeding
    a function name, by convention if the function encounters an error, it will panic.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the runnable code in the repository at [https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/5/excel/simple/excel.go](https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/5/excel/simple/excel.go).
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is the simplest way to add data to a sheet. However, it is not
    very scalable. Let''s create one that is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a `serverSheet` type for managing our Excel sheet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a constructor that adds our column labels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we need something to add the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses a lock to prevent multiple calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It performs very basic data validation checks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds a row and then increments our internal `nextRow` counter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we have a more scalable way to add data to our sheet. Next, let's discuss
    how to summarize data.
  prefs: []
  type: TYPE_NORMAL
- en: Data summarization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two ways to summarize data that is added:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking summaries in our object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excel pivot tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, I am going to use the first method. This method comes with
    several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It is easier to implement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It performs faster calculations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It removes complex calculations from the spreadsheet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it comes with a distinctive disadvantage:'
  prefs: []
  type: TYPE_NORMAL
- en: Data changes do not affect the summary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To track our data summary, let''s add a `struct` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify the `add()` method that we wrote earlier to summarize our table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It looks at our vendor and adds to our summary counters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds a method to write our summaries to the sheet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's discuss how we can add visualizations using this data.
  prefs: []
  type: TYPE_NORMAL
- en: Adding visualizations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the reasons for using Excel over CSV for output is to add visualization
    elements. This allows you to quickly generate reports that users can look at that
    are more appealing than CSV and less intensive to write than web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a chart is done via the `AddChart()`method. `AddChart()`takes in a string
    representing JSON that indicates how to build the chart. In our example, you will
    see a package, called `chart`, that extracts private types from `excelize` used
    to represent the charts and makes them public types. In this way, we can use a
    typed data structure instead of JSON that has been converted into that structure.
    This also allows for the easier discovery of values that you might wish to set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a new 3D pie chart type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It sets the dimensions, title, and legend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It applies the chart values and categories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It marshals the chart's instructions to JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It calls `AddChart` to insert the chart into the sheet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find the runnable code in the following repository: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5/excel/visualization](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/5/excel/visualization)'
  prefs: []
  type: TYPE_NORMAL
- en: So, we have covered the base minimum of using Excel for outputting reports.
    There are many other options, including inserting pictures, pivot tables, and
    advanced formatting directives. And while we wouldn't recommend Excel for data
    input into a system or a data storage format, it can be a useful data output system
    for summaries and viewing data.
  prefs: []
  type: TYPE_NORMAL
- en: Popular encoding formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSV is one of the more basic human-readable encodings that DevOps engineers
    will encounter, but it is by no means the only one. Within the last two decades,
    several new formats have emerged that are used to transfer information or provide
    configuration to applications.
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is a data serialization format that
    was designed to convert JavaScript objects into a textual representation so that
    they could be saved or transferred. This notation, due to its simplicity and clarity,
    has been adopted by almost every language to transfer data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Yet Another Markup Language** (**YAML**) is another data serialization format
    that is often used to store configuration information for a service. YAML is the
    primary configuration language in Kubernetes clusters.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the ways to marshal and unmarshal data from
    Go types into these formats and back into the Go type.
  prefs: []
  type: TYPE_NORMAL
- en: The Go field tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go has a feature called field tags that allow a developer to add string tags
    to `struct` fields. This allows a Go program to inspect the extra metadata regarding
    a field before performing an operation. Tags are key/value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you can see a `struct` type with a field called
    `Last` that has a field tag. The field tag is an inline raw string. Raw strings
    are denoted by backticks. This will produce a tag with a key of `"json"` and a
    value of `"last_name"`.
  prefs: []
  type: TYPE_NORMAL
- en: Go packages can use the `reflect` package to read these tags. These tags allow
    a package to change the behavior of an operation based on the tag data. In this
    example, it tells our JSON encoder package to use `last_name` instead of `Last`
    when writing data to JSON and the reverse when reading data.
  prefs: []
  type: TYPE_NORMAL
- en: This feature is key for packages that handle data marshaling.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the past decade, the JSON format has become the de facto format for data
    encoding to disk and for communicating via RPC to services. No language in the
    cloud space can be successful without supporting JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'A developer might encounter JSON as an application configuration language,
    but it is poorly suited for this task due to the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The lack of multiline strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The inability to have comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pickiness regarding its punctuation (that is, good for machines, and bad
    for humans)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the interchange of data, JSON can be quite useful with only a few downsides,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Schemaless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-binary format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of byte array support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A schema is a definition of a message's content that lives outside code.
  prefs: []
  type: TYPE_NORMAL
- en: Schemaless means there is no strict definition of what a message contains. This
    means that, for every language that is supported, we must create definitions for
    our messages in that language. Formats such as protocol buffers have entered into
    this space to provide a schema that can be used to generate code for any language.
  prefs: []
  type: TYPE_NORMAL
- en: JSON is also a human-readable format. These types of formats are not as efficient
    as binary formats in terms of size and speed. This generally matters when trying
    to scale large services. However, many prefer human-readable formats due to their
    ability to be easily debugged.
  prefs: []
  type: TYPE_NORMAL
- en: JSON's lack of support for byte arrays is also a failing. JSON can still transfer
    raw bytes, but it requires encoding and decoding the bytes using `base64` encoding
    and storing them in JSON's `string` type. This requires an extra level of encoding
    that should be unnecessary. There are several supersets of JSON that are not widely
    supported (such as Binary JSON, or BSON for short) that contain a byte array type.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is delivered to a user in one of several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: As a single message that can contain sub-messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an array of JSON messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a stream of JSON messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON's origins started as a format for simply encoding a JavaScript object for
    transfer. However, as its uses have grown, the need for sending large messages
    or streams of messages became a use case.
  prefs: []
  type: TYPE_NORMAL
- en: Single, large messages can be hard to decode. Generally, JSON decoders are written
    to read the entire message into memory and validate the message's content.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify large sets of messages or streaming content, you might encounter
    a message with brackets,`[]`, surrounding a set of messages or individual messages
    separated with carriage returns. These are not valid JSON as intended, but have
    become de facto standards for handling large sets of data as small, individual
    messages that make up part of a whole stream.
  prefs: []
  type: TYPE_NORMAL
- en: Because JSON is a standard part of the cloud ecosystem, Go has built-in language
    support in the standard library's `encoding/json` package. In the upcoming sections,
    we will detail the most common ways to use the JSON package.
  prefs: []
  type: TYPE_NORMAL
- en: Marshaling and unmarshaling to maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because JSON is schemaless, it is possible to have messages of different types
    in a stream or in files. This is usually undesirable, and it is better to have
    a top-level message that holds these types of messages.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to handle multiple message types or do discovery on a message,
    Go allows you to decode messages into `map[string]interface{}`, where the `string`
    key represents the field name and `interface{}` represents the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine an example of unmarshaling a file into a `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It reads the content of the `data.json` file into variable `b`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates a `map`, called `data`, to store our JSON content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It unmarshals the raw bytes representing the JSON into `data`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It looks up the `user` key in `data`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `user` does not exist, we return an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it does exist, we `type assert` to determine what the value type is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is a string, we return the content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value is not a string, we return an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `map`, we can explore the values in the data to discover a message
    type, `type` `assert` the `interface{}` value to a concrete type, and then use
    the concrete value. Remember that type assertion converts an `interface` variable
    into another `interface` variable or a concrete type such as `string` or `int64`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a `map` is the hardest method of data decoding for JSON. It is only recommended
    in cases where the JSON is unpredictable, and there is no control of the data
    provider. It is usually better to have whatever is providing the data change its
    behavior than decoding in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Marshalling a `map` into JSON is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`json.Marshal` will read our `map` and output valid JSON for the contents.`[]byte`
    fields are automatically `base64` encoded into JSON''s `string` type.'
  prefs: []
  type: TYPE_NORMAL
- en: Marshaling and unmarshaling to structs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The preferred method of JSON decoding is doing so in a Go `struct` type that
    represents the data. Here is an example of how to create a user record struct,
    which we will use to decode a JSON stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code outputs `{"user_name":"John Doak","user":"jdoak","ID":23}`.
    You can find the runnable code at [https://play.golang.org/p/LzoUpOeEN9y](https://play.golang.org/p/LzoUpOeEN9y).
  prefs: []
  type: TYPE_NORMAL
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines a `Record` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses field tags to tell JSON what the output field mapping should be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses a field tag of `-` on `Age` so that it will not be marshaled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates a `Record` type called `rec`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It marshals `rec` to JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It prints the JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that the `Name` field was translated to `user_name` and `User` to `user`.
    The `ID` field was unchanged in the output because we did not use a field tag.
    `Age` was not output because we used a field tag of `-`.
  prefs: []
  type: TYPE_NORMAL
- en: Fields that are private because they start with a lowercase letter cannot be
    exported. This is because the JSON marshaler is in a different package and cannot
    see the private type in this package.
  prefs: []
  type: TYPE_NORMAL
- en: You can read about the field tags that JSON supports in the `encoding/json`
    GoDoc, located under `Marshal()` ([https://pkg.go.dev/encoding/json#Marshal](https://pkg.go.dev/encoding/json#Marshal)).
  prefs: []
  type: TYPE_NORMAL
- en: The JSON package also includes `MarshalIndent()`, which can be used to output
    more readable JSON with line separators between the fields and indentions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decoding data into a `struct` type, such as `Record` earlier, can be done as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This transforms text that represents the JSON into a `Record` type stored in
    the `rec` variable. You can find the runnable code at [https://play.golang.org/p/DD8TrKgTUwE](https://play.golang.org/p/DD8TrKgTUwE).
  prefs: []
  type: TYPE_NORMAL
- en: Marshaling and unmarshaling large messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we might receive a stream of JSON messages or a file that contains
    a list of JSON messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go provides `json.Decoder` to handle a series of messages. Here is an example
    borrowed from the GoDoc, where each message is separated by a carriage return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can view this running code at [https://play.golang.org/p/kqmSvfdK4EG](https://play.golang.org/p/kqmSvfdK4EG).
  prefs: []
  type: TYPE_NORMAL
- en: 'This example does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It defines a `Message` struct.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It wraps the `jsonStream` raw output in an `io.Reader` via `strings.NewReader()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It starts a goroutine that decodes the messages as they are read and puts them
    on a channel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reads all messages that are sent until the output channel is closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It prints out any errors that are encountered.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, this format of streaming will have brackets,`[]`, around the messages
    and use commas as separators between the entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can utilize another feature of the decoder, `dec.Token()`,
    to remove them safely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can view this running code at [https://play.golang.org/p/_PrUVUy4zRv](https://play.golang.org/p/_PrUVUy4zRv).
  prefs: []
  type: TYPE_NORMAL
- en: This code works in the same way, except it removes the outer brackets and requires
    a comma-delimited list instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Encoding data in a stream is very similar to decoding. We can write JSON messages
    into `io.Writer` to output to a stream. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can see this code running at [https://play.golang.org/p/ELICEC4lcax](https://play.golang.org/p/ELICEC4lcax).
  prefs: []
  type: TYPE_NORMAL
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It reads from a `channel` of `Message`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It writes to an `io.Writer`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns a channel that signals when the encoder is done processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an error is returned, it means that the encoder had a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This outputs the JSON as separated values without brackets.
  prefs: []
  type: TYPE_NORMAL
- en: JSON final thoughts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `encoding/json` package has support for other methods of decoding that are
    not covered here. You can mix `map[string]interace{}` into your `struct` types
    and vice versa, or you can decode each field and value individually.
  prefs: []
  type: TYPE_NORMAL
- en: However, the best use cases are those that are straightforward `struct` types
    as a single value or stream of values.
  prefs: []
  type: TYPE_NORMAL
- en: This is why `encoding/json` is my first choice when encoding or decoding JSON
    values. It is not the fastest method, but it is the most flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other third-party libraries that can increase your throughput while
    sacrificing some flexibility. Here is just a small list of packages that you might
    want to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/francoispqt/gojay](https://github.com/francoispqt/gojay)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/goccy/go-json](https://github.com/goccy/go-json)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/github.com/json-iterator/go](https://pkg.go.dev/github.com/json-iterator/go)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pkg.go.dev/github.com/valyala/fastjson](https://pkg.go.dev/github.com/valyala/fastjson)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: YAML encoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: YAML (yet another markup language/YAML Ain't Markup Language) is a language
    that is commonly used to write configurations.
  prefs: []
  type: TYPE_NORMAL
- en: YAML is the default language of services such as Kubernetes to hold configurations,
    and as a DevOps engineer, you are likely to come across it in a variety of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'YAML has a few advantages over JSON for use in configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More flexible for humans, such as unquoted strings and quoted strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiline strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anchors and references to avoid repetition of the same text data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'YAML is often cited as having the following flaws:'
  prefs: []
  type: TYPE_NORMAL
- en: It is schemaless.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The standard is large and some features are confusing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large files can have indention errors that go unnoticed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementations in some languages can accidentally execute code embedded in
    YAML. This can lead to a few security patches in software projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go does not have support in the standard library, but it has a third-party library
    that has become the de facto package for YAML serialization, called `go-yaml`
    (https://github.com/go-yaml/yaml).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's discuss how we can read these YAML files to read our configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Marshaling and unmarshaling to maps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: YAML, like JSON, is schemaless and suffers from the same drawbacks. However,
    unlike JSON, YAML is intended to represent a configuration, so we don't have the
    same need to stream content.
  prefs: []
  type: TYPE_NORMAL
- en: For YAML, the general use case would entail encoding/decoding to a `struct`
    type instead of a `map`. However, if you have a need for message discovery, YAML
    can handle a `map` decode in the same way that we can handle it for JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of unmarshaling a file into a `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a `map` called `data` to store our YAML content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It unmarshals the raw bytes representing the YAML into `data`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It looks up the `user` key in `data`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `user` does not exist, we return an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a more complete example, please refer to [https://play.golang.org/p/wkHkmu47e6V](https://play.golang.org/p/wkHkmu47e6V).
  prefs: []
  type: TYPE_NORMAL
- en: 'Marshalling a `map` into YAML is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `yaml.Marshal()`will read our `map` and output valid YAML for the contents.
  prefs: []
  type: TYPE_NORMAL
- en: Marshaling and unmarshaling to structs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `struct` serialization is the preferred way to handle YAML. As YAML is a
    configuration language, programs must know what fields are available ahead of
    time to set program parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'YAML serialization works in a similar way to JSON serialization, and you will
    find that similarity across most data serialization packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can see this running code at [https://play.golang.org/p/SvJHLKBsdUP](https://play.golang.org/p/SvJHLKBsdUP).
  prefs: []
  type: TYPE_NORMAL
- en: 'This outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It creates a top-level configuration called `Config`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It creates a list of sub-messages called `Job`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It marshals an example into the text representation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unmarshaling is just as easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It takes a YAML config that is represented by data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It converts it into the `Config` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It prints out contained `Job` information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ignores the `whatever` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This code will ignore the unknown `whatever` field. However, in many cases,
    you do not want to ignore a field that could potentially be misspelled. In those
    cases, we can use `UnmarshalStrict()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'That would cause this code to fail with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When using `UnmarshalStrict()`, you must add new field support to your programs
    and deploy them before adding them to your configs, or you will cause old binaries
    to fail.
  prefs: []
  type: TYPE_NORMAL
- en: YAML final thoughts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `github.com/go-yaml/yaml` package has support for other methods of serialization
    that we are not going to cover here. One that is used most often is decoding into
    a `yaml.Node` object in order to preserve comments, then changing the content
    and writing the configuration back out. However, this is relatively uncommon.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you have learned how to use JSON and YAML to read and write
    data in their respective data formats. In the next section, we will look at how
    to interact with SQL data sources that are used to commonly store data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This also ends our chapter on using common data formats. We have covered how
    to read and write with CSV files and Excel reports. Additionally, we have learned
    how to encode and decode data in JSON and YAML formats. This chapter has shown
    how we can decode data in streams while reinforcing ways to concurrently read
    and use data with goroutines.
  prefs: []
  type: TYPE_NORMAL
- en: Your newly acquired skills for JSON will be immediately useful in our next chapter.
    In that chapter, we will look at how to connect to SQL databases and interact
    with RPC services. As REST RPC services and databases such as Postgres can use
    JSON, this skill will come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's jump in!
  prefs: []
  type: TYPE_NORMAL
