- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Relationships, Ordering, and Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be discussing relationships, ordering, and scope in
    Puppet. These topics are often considered complicated because Puppet’s approach
    differs greatly from traditional languages. However, we will show you how to manage
    these aspects effectively and avoid unnecessary complexities.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by discussing Puppet’s approach to relationships and ordering.
    By default, Puppet treats resources as independent and can apply them in any order
    in the catalog. However, where ordering is necessary, we will show you how to
    use metaparameters such as `before`, `after`, `notify`, and `subscribe` to enforce
    ordering and create relationships between resources.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will cover the concept of containment. We will explain that including
    classes are not contained within their calling classes, so relationships/dependencies
    made between classes do not automatically create relationships and dependencies
    with the resources in those classes. To address this, we will introduce the `contain`
    function, which allows you to contain the resources within a class and create
    those relationships.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will discuss scopes and how variables and resource defaults can
    have different visibility depending on where they are in the code and their relative
    scope. We will then provide best practices and pitfalls to ensure that you take
    the simplest path and avoid unnecessary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this chapter will equip you with the knowledge and skills to effectively
    manage relationships, ordering, and scope in Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Relationships and ordering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices and pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All examples and labs in this chapter can be run within your own local dev environment.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships and ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Puppet treats all resources as independent of each other, which
    means they can be applied in any order. This is different from traditional declarative
    code, which runs line by line and executes in the order it is written. One of
    the main advantages of Puppet’s approach is that if a single part of the code
    fails, Puppet will continue to apply all other resources. This eliminates the
    need to stop or have substantial failure handling in place to continue code. As
    a result, Puppet can bring a client server as close to the desired state as possible,
    even if some resources fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s clear that some resources will be dependent on each other, such as a configuration
    file that can only exist after a package has been installed. Puppet provides metaparameters
    to create these dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`before`: The resource should be applied before the named resource(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`require`: The resource should be applied after the named resource(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notify`: The resource should be applied before the named resource(s). The
    named resource refreshes if the resource changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe`: The resource should be applied after the named resource(s). The
    resource refreshes if the named resource changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `before` and `require` metaparameters can be used to enforce a dependency
    relationship. However, it’s important to note that a relationship only needs to
    be applied in one direction. Therefore, there is no need to use both `before`
    and `require` on either side of a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to indicate that the `httpd` package should be installed before
    managing a file, either `before` or `require` can be used, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A dependency chart, also known as a `--graph` option with the `puppet` command
    to produce a dot file that can be used to create a graphic in an appropriate program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 6**.1*, the `require` on the file resource has been removed to produce
    a DAG for the example code:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.1 \uFEFF– A DAG of resource dependencies](img/B18492_06_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – A DAG of resource dependencies
  prefs: []
  type: TYPE_NORMAL
- en: If both the `before` and `require` metaparameters were present, an extra arrow
    would be visible in the DAG, but it would have no effect on the compilation or
    resources applied. It’s worth noting that the starting and finishing classes,
    named `Main`, in the example code reflect that the code is not contained within
    a class and the code is at a global level. This will be discussed further in the
    *Scope* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a DAG, loops are not expected, so the flow of dependencies should only go
    downward. If a third resource, such as a service, is added that should be enforced
    before the `httpd` package after the `/etc/httpd.conf` file, the DAG would look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This would result in a dependency cycle, as illustrated in *Figure 6**.2*. When
    compiled, the code would produce an error, as there would be no way to determine
    the order in which to apply the resources.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.2 \uFEFF– A DAG showing a dependency cycle](img/B18492_06_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – A DAG showing a dependency cycle
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to represent multiple dependencies with an array, which
    can be an array of names either of the same type or of different types. For example,
    if a package were required by two files and two services for `exampleapp`, it
    could be represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, it can be easier to have all the resource dependencies on one side
    rather than on each individual resource.
  prefs: []
  type: TYPE_NORMAL
- en: As was mentioned in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), some Puppet
    types have automatic rules for creating dependencies, which can be found in the
    documentation for the Puppet type under `Autorequires` either online or using
    the Puppet `describe` command. For example, the user type autorequires any group
    under Puppet’s control, that a user resource has as its primary or secondary group.
  prefs: []
  type: TYPE_NORMAL
- en: As well as an ordering concept, Puppet has the `refresh` attribute, so if a
    resource has a dependency on another resource, it will refresh itself. This is
    useful in situations such as when a configuration file is updating and the service
    should restart to reread the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: The `notify` and `subscribe` metaparameters create the same dependency as `before`
    and `require` but add the `refresh` attribute to the dependent resource. Of the
    built-in Puppet types, `service exec` and `package` can be refreshed. If a `notify`
    or `subscribe` metaparameter is used with a resource type incapable of refreshing,
    it will just enforce the dependency and do nothing on a refresh event.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `notify` metaparameter should not be confused with the `notify` resource
    type used to send messages to the agents log.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a `service` resource could use `subscribe` or `notify` from the
    `file` resource so that the service would be dependent on the file being created.
    It would also receive a refresh event if the file was updated and restart the
    service assuming the provider had the capability. As shown in the following code,
    again we show both sides of the dependency, although only one relationship attribute
    should be given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In a DAG diagram, this would be identical to using `before` and `require`, and
    it can use the same resource reference or arrays of resource references.
  prefs: []
  type: TYPE_NORMAL
- en: The default behaviors and parameters of a refresh event for each type are shown
    in *Table 6.1*. Here, we see that by default, a service will use the provider’s
    `restart` variable if it is provided. Otherwise, `hasrestart` can define an `init`
    script or `restart` can define a custom restart script. If no `init` script is
    provided, the service name will be searched for in the process tree, but it is
    strongly advised to provide clear service management scripts.
  prefs: []
  type: TYPE_NORMAL
- en: For the package type, the default behavior is to ignore the `restart` event,
    but the parameter can be set to reinstall the package as the result of a `refresh`
    event.
  prefs: []
  type: TYPE_NORMAL
- en: '`Exec` will rerun its command on a refresh but can be changed to run a different
    `refresh` command or to only run as a result of a `refresh` event.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Default Behavior | Parameter(s) |'
  prefs: []
  type: TYPE_TB
- en: '| `Service` | Restart the service if the provider has a restart feature; otherwise,
    stop and start | hasrestartrestart |'
  prefs: []
  type: TYPE_TB
- en: '| `Package` | Ignore refresh event | reinstall_on_refresh |'
  prefs: []
  type: TYPE_TB
- en: '| `Exec` | Rerun the command | refreshrefresh only |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1– Puppet native type refresh options
  prefs: []
  type: TYPE_NORMAL
- en: Metaparameter dependencies can produce three types of errors. The first is missing
    dependencies, where the resource is not found in the compiled catalog. This should
    normally be investigated for typos or logic, meaning the resource is not included.
    The second type of error is failed dependencies, where an issue with a resource
    means none of its dependencies can be applied. Troubleshooting this resource and
    rerunning Puppet should then allow all dependent resources to be applied. The
    third type of error is the dependency cycle, which we discussed and showed in
    *figure 6.2*, where producing a DAG can help identify where the loop is and fix
    the dependency logic.
  prefs: []
  type: TYPE_NORMAL
- en: Despite having said so far that resources have no order beyond dependencies,
    this is not quite true since Puppet runs in what is known as **manifest order**.
    So, an individual manifest file will be applied in the order it is written unless
    dependencies change that. Although this could allow you not to use dependencies,
    the main purpose is to prevent random compilations causing code to behave differently
    on different servers as it could do if read in at random.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Puppet went through a strange philosophical/purity argument around ordering
    in earlier versions. It was viewed as necessary to break the bad habits of developers
    assuming ordering would be like in other languages, line by line. So, Puppet initially
    chose a random order. This was chaotic and resulted in code that might work in
    your lab but ran in a different order in production and broke.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variation of the dependency metaparameters is chaining arrows, where `before`
    and `require` are represented by `->` and `<-` and `notify` and `subscribe` by
    `~>` and `<~`. They are generally used to show relationships between classes,
    such as to represent a module pattern, which will be seen in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212).
    For example, if we wanted an `install` class to apply before a `config` class
    and then for a `service` class to be applied and refreshed if the `config` class
    was updated, it could be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `include` function is necessary, as discussed in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048),
    to ensure the classes are added to a catalog.
  prefs: []
  type: TYPE_NORMAL
- en: For style purposes, only the right-facing arrows are recommended to be used,
    to make it consistent while reading. While dependency parameters can be used in
    classes and resource declarations and chaining arrows on other resource types,
    it is not recommended to do so to make it clearer to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'In simpler cases, the required function can also be used from within a class
    to create a dependency on other classes. However, no `refresh` or `before` equivalent
    exists, so for styling and consistency, it’s generally easier to use ordering
    arrows. A simple example, using the `require` function to represent that the `install`
    class should applied before the `config` class, would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: What we have just discussed in terms of the approach to class dependency is
    not quite as simple as it may seem because Puppet classes do not actually contain
    other classes. A class will include other classes by default, so the dependencies
    do not cover them. We will now look at what this containment problem means and
    how to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Containment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containment in Puppet means that included classes are not contained in the
    same way as resources in a class; so, when setting up a dependency to a class
    that includes another class via the `include` function or a `class` resource,
    the dependency will only cover the resources. For example, say we created a requirement
    for `class1` to be applied before `class2` and `class2` contained a `package`
    resource and an `include` call to `class3`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, while there might be an assumption that this would ensure `class1` was before
    `class3` but `class1` was before `class2`, it doesn’t, as can be seen in the DAG
    diagram in *Figure 6**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: "![\uFEFFFigure 6.3 – DAG showing lack of containment](img/B18492_06_03.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – DAG showing lack of containment
  prefs: []
  type: TYPE_NORMAL
- en: Remembering back to [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), where the
    `include` function was introduced, this containment is not automatic because we
    may want to include this class in different places for different situations and
    for it only to appear once in the catalog without dependency or containment issues.
  prefs: []
  type: TYPE_NORMAL
- en: To contain a class, the `contain` function is used. Change the `include` line
    to `contain` `examplemodule::class3`, which will change the DAG diagram to contain
    `examplemodule::class3`, as We can see in *Figure 6**.4*.
  prefs: []
  type: TYPE_NORMAL
- en: "![\uFEFFFigure 6.4 – DAG showing the use of the contain function](img/B18492_06_04.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – DAG showing the use of the contain function
  prefs: []
  type: TYPE_NORMAL
- en: 'If a `class` resource is used alongside a `contain` statement, it must appear
    in manifest order after the `class` resource. Failure to do so will cause the
    `class` resource to interpret the `contain` statement as an attempt to declare
    a duplicate resource, resulting in an error. For example, if the following code
    is used, the attribute can be passed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The immediate question to this containment problem might be why not just use
    `contain` for everything? That comes down to the needless and confusing dependencies
    it could create. If our original example were updated to use `contain` instead
    of `class` and we had another class, `anothermodule:class`, which required `examplemodule:class3`
    to be in the catalog, we could add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then, the DAG would look like *Figure 6**.5*. It can be immediately seen that
    we have created needless dependencies just with a small number of classes.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.5 \uFEFF– DAG showing cycle caused \uFEFFby the overuse \uFEFFof\
    \ contain](img/B18492_06_05.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – DAG showing cycle caused by the overuse of contain
  prefs: []
  type: TYPE_NORMAL
- en: 'Worse, it can be easy to create a cyclical dependency. If, for example, the
    `security::default` class were to be included in all application classes, a cyclical
    dependency could be created by a `require` function being used between a class,
    `application2`, requiring the `application1` class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This would produce the DAG shown in *Figure 6**.6*. If only includes were used,
    we would have avoided the need for an unnecessary relationship from the application
    classes to `security::default`:'
  prefs: []
  type: TYPE_NORMAL
- en: "![\uFEFFFigure 6.6 – DAG showing how the over-use of contain causes cyclic\
    \ dependencies](img/B18492_06_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – DAG showing how the over-use of contain causes cyclic dependencies
  prefs: []
  type: TYPE_NORMAL
- en: In the *Best practices and pitfalls* section, we will further discuss how to
    avoid worrying about containment using consistent patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the `contain` function was introduced in Puppet 3.4, there was another
    approach, which you may see in heritage code: using `anchor` resources. This can
    either be done with a specific anchor resource provided by the `stdlib` module
    or any other pair or resources in the class. To ensure that the current class
    contains `examplemodule::class3`, the code using the `anchor` resource directly
    would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if the two package resources, `pdk` and `cowsay`, were in this
    class, they could be borrowed to create a relationship and contain the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The issue with this pattern is that it clutters up the DAG with extra anchor
    resources or unnecessary relationships, which can be confusing. Therefore, if
    you find that anchors are being used, it is recommended that you modernize your
    approach by using the `contain` keyword instead.
  prefs: []
  type: TYPE_NORMAL
- en: Having discussed dependencies and the containment of resources and classes,
    we will now see how variables and resource defaults are scoped across the Puppet
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Puppet terms, scope reflects the location in the code where variables can
    be directly accessed without the use of namespaces and where resource defaults
    can be affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three levels of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top scope**: Any code outside of a class, type, or node definition. Any variable
    or resource declaration in the top scope will be accessible to be read or used
    anywhere.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node scope**: Any code defined in a node definition. Any variables and resource
    defaults in the node scope will be visible to nodes that match the node definition
    at the node and local scope levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local scope**: Any code defined in a class, defined type, or lambda. So,
    any variables and resource defaults defined will only be visible within that specific
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both **External Node Classifiers** (**ENCs**) and node definitions will be discussed
    in [*Chapter 11*](B18492_11.xhtml#_idTextAnchor272). All we need to understand
    for this section is that an ENC is an executable script that returns variables
    and classes to be applied to a host. This script can inject custom logic and data
    by performing various actions, such as performing a database lookup or using AWS
    Lambda. It can also be used to access third-party sources, such as **Configuration
    Management Databases** (**CMDBs**). The variables returned are at the top-scope
    level, while the classes are at the node-scope level. This allows the provided
    variables to be visible anywhere, but only for the classes declared to have access
    to node-scope variables. In contrast, a node definition is a section of code that
    is applied to matching nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Classes have what is known as a named scope, where the name of the class is
    used in the namespace. For example, a variable created in `exampleclass` called
    `test` can be accessed from anywhere via `exampleclass::test`. Variables created
    in the global scope, such as `site.pp`, can be accessed from an empty namespace
    by calling `::variablename`. However, accessing data like this is generally not
    recommended. In [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233), we will show
    how to centrally manage data.
  prefs: []
  type: TYPE_NORMAL
- en: Node-scope definitions and local-scope definitions on lambdas and defined types
    are anonymous and can only be accessed directly by name from where they are visible.
    It is also possible to override higher scope variables by declaring a variable
    in the current scope, such as a class overriding a global variable with its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show this, consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first `notify` would fail to find the local or node variable since it is
    in the global scope, and `testing` would be set to `testing123`. The second `notify`
    would directly access the local namespace, `example`, and print `localtest`. The
    third `notify` would be unable to access the local variable and would print `hello
    world`. The fourth `notify` would again access the local scope via the namespace.
    The final `notify` would be able to access all the variables, and `local` would
    be set to `localtest`. This example shows the flow of variables between scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Resource titles and resource references are unaffected by the scope and can
    be declared in any scope. For example, a resource can declare a dependency for
    any resource in the catalog. However, it is not good practice to rely on accessing
    external variables like this.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices and pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier versions of Puppet, scope, dependencies, and containment were some
    of the most challenging issues, which led to significant problems for newer developers.
    One major solution that largely addressed these issues was the widespread adoption
    of the roles and profiles method, which will be covered in full detail in [*Chapter
    8*](B18492_08.xhtml#_idTextAnchor212). Hiera data will be covered in [*Chapter
    9*](B18492_09.xhtml#_idTextAnchor233).
  prefs: []
  type: TYPE_NORMAL
- en: The roles and profiles method involves grouping single-use component modules
    that perform one independent function well. For instance, a component module could
    install and configure Oracle. The module structure would contain a group of manifests
    with specific purposes, such as installing packages or managing services. This
    simplifies module organization and allows for the easier ordering of classes.
    For example, the `install` class can be applied before the `service` class.
  prefs: []
  type: TYPE_NORMAL
- en: Component modules should function independently of one another and have no direct
    dependencies across modules. The profile layer groups modules together to create
    technology stacks and can put modules in order if necessary. Roles abstract another
    layer up to create business solutions using these technology stacks and can order
    the profiles. In this structure, any global or node data should come from Hiera
    instead of being set in node or global scopes, which reduces code complexity.
    It may feel counterintuitive to developers to avoid setting global variables in
    code, but following this practice is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048), it is advisable
    to avoid using resource collectors/exported resources. However, it is worth noting
    that they can be used as part of chaining arrows. Using them can be risky as it
    may result in unpredictable outcomes and create significant dependency cycles
    that are difficult to map until runtime. Dependencies should always be created
    as required, and you should not rely on manifest ordering for this purpose. Omitting
    these dependencies could significantly reduce code maintainability and create
    complications during future refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: Use chaining arrows for class dependencies and contain them only where necessary,
    as in the roles and profiles method. Avoid enforcing resource defaults globally,
    such as in `site.pp` or node definitions, as this approach makes the code unpredictable
    for everyone, especially when working with multiple application teams who may
    not be aware of these defaults in their own code. In summary, avoid attempting
    overly complex or familiar approaches from other languages and instead follow
    established roles/profiles and Hiera patterns. Review roles/profiles and Hiera
    patterns carefully and refactor any code that does not follow these guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Lab – overview of relationships, ordering, and scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this lab, we will provide some code to review and run to ensure the concepts
    discussed are understood. All the code can be found at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch06](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch06).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_1.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_1.pp)
    currently has no dependencies. To meet the following requirements, the code needs
    to be adjusted accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: The `install` class and all its resources should run before `config` and `service`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `config` class and all its resources should run before `service`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `service` class and all its resources should be refreshed if any resource
    in the `config` class is updated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `httpd` package should be installed before the `exampleapp` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `exampleuser` user should be created after the `examplegroup` group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/etc/exampleapp/` directory should be created after the `exampleuser` user
    and the `examplegroup` group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `/etc/exampleapp/exampleapp.conf` file should be created after the `exampleuser`
    user, the `examplegroup` group, and the `/``etc/exampleapp` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `httpd` service should start before the `exampleapp` service, and the `exampleapp`
    service should refresh if the `httpd` service restarts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to use [https://validate.puppet.com/](https://validate.puppet.com/)
    to check your Puppet code, as you should not rely on manifest ordering alone.
    Additionally, it’s important to remember that some resources have auto-requirement
    behavior. A sample example is provided at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_2.pp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch06/lab6_2.pp).
    Examine the code and see what the `notify` function would print.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed how resources are assumed to be applied in any
    order by default, and how metaparameters such as `before`, `require`, `notify`,
    and `subscribe` can be used to define any required order. We learned that DAGs
    can be used to visualize dependencies between resources, and that dependency cycles
    should be avoided to ensure the catalog can be applied successfully. We also discussed
    how certain resources automatically apply dependencies, such as a user requiring
    its primary group. The `notify` and `subscribe` metaparameters were explained,
    and their use of `refresh` was highlighted as particularly useful for resources
    such as `exec`, `package`, and `service`. This allows for these resources to be
    restarted, reinstalled, or rerun when necessary, such as when a configuration
    file changes. Additionally, we acknowledged that although resources should be
    assumed to have no order, they are in fact applied in the order they are written
    in a manifest to ensure consistency across environments. We also discussed the
    three types of errors that can occur: cyclic, missing dependencies, and dependent
    resource failures.'
  prefs: []
  type: TYPE_NORMAL
- en: After that, we discussed chaining arrows as a variation of metaparameters, allowing
    them to be used between classes. We emphasized that only right-facing arrows should
    be used to comply with the style guide. While metaparameters can be used on classes
    and chaining arrows on resources for consistency and styling, we recommend avoiding
    this practice. Instead, we showed that the `require` function can be used within
    a class that is dependent on another class for relatively simple class dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed the issue of containment, which arises when including classes
    within other classes does not create resource dependencies. This was achieved
    using the `contain` function instead of an `include` function within a class causing
    this class to contain the other classes’ resources and creating the dependencies.
    We discussed how this may bring the temptation to contain all classes, but we
    demonstrated that this would create needless or cyclic dependencies. The older
    anchor pattern was shown since heritage code could still contain this. We highlighted
    that the `anchor` function is no longer a recommended approach and, where found,
    it should be modernized to use the `contain` function.
  prefs: []
  type: TYPE_NORMAL
- en: The scope was shown to affect variables and defaults for resources, where the
    global scope is anything set outside of the class, type, or node definition. The
    node scope is anything in a node definition and the local scope is anything in
    a class, type, or lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for best practice, it is recommended to follow the roles and profiles
    method to ensure consistency in dependencies and ordering. It is also recommended
    to use Hiera instead of complex variable usage and to avoid setting resource defaults
    in the global scope, such as `site.pp` or node definitions. It is important to
    never rely on manifest ordering, use explicit dependencies to ensure consistency.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explore templates, iteration, and conditional statements
    in Puppet. It will demonstrate how Puppet can generate file content by leveraging
    variables, conditions, and text manipulation functions. Additionally, it will
    explain how iterative functions and lambda code sections enable Puppet to loop
    through and manipulate collections of data. Finally, the chapter will cover the
    usage of conditional statements in Puppet to create different configurations based
    on conditional logic.
  prefs: []
  type: TYPE_NORMAL
