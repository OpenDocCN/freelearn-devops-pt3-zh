["```\n/* \ndbURL might look like:\n\"postgres://username:password@localhost:5432/database_name\"\n*/\nconn, err := sql.Open(\"pgx\", dbURL)\nif err != nil {\n     return fmt.Errorf(\"connect to db error: %s\\n\", err)\n}\ndefer conn.Close()\nctx, cancel := context.WithTimeout(\n     context.Background(), \n     2 * time.Second\n)\nif err := conn.PingContext(ctx); err != nil {\n  return err\n}\ncancel()\n```", "```\n_ \"github.com/jackc/pgx/v4/stdlib\"\n```", "```\n\"github.com/jackc/pgx/v4/pgxpool\"\n```", "```\nconn, err := pgxpool.Connect(ctx, dbURL)\nif err != nil {\n     return fmt.Errorf(\"connect to db error: %s\\n\", err)\n}\ndefer conn.Close(ctx)\n```", "```\ntype UserRec struct {\n     User string\n     DisplayName string\n     ID int\n}\nfunc GetUser(ctx context.Context, conn *sql.DB, id int) (UserRec, error) {\n     const query = `SELECT \"User\",\"DisplayName\" FROM users WHERE \"ID\" = $1`\n     u := UserRec{ID: id}\n     err := conn.QueryRowContext(ctx, query, id).Scan(&u)\n     return u, err\n}\n```", "```\ntype Storage struct {\n     conn *sql.DB\n     getUserStmt *sql.Stmt\n}\nfunc NewStorage(ctx context.Context, conn *sql.DB) *Storage\n{\n     return &Storage{\n          getUserStmt: conn.PrepareContext(\n               ctx,\n               `SELECT \"User\",\"DisplayName\" FROM users WHERE \"ID\" = $1`,\n          )\n     }\n}\nfunc (s *Storage) GetUser(ctx context.Context, id int) (UserRec, error) {\n     u := UserRec{ID: id}\n     err := s.getUserStmt.QueryRow(id).Scan(&u)\n     return u, err\n}\n```", "```\nerr = conn.QueryRow(ctx, query).Scan(&u)\nreturn u, err\n```", "```\n/* \nstmt contains `SELECT \"User\",\"DisplayName\",\"ID\" FROM users \nWHERE \"ID\" >= $1 AND \"ID\" < $2`\n*/\nfunc (s *Storage) UsersBetween(ctx context.Context, start, end int) ([]UserRec, error) {\n     recs := []UserRec{}\n     rows, err := s.usersBetweenStmt(ctx, start, end)\n     defer rows.Close()\n     for rows.Next() {\n          rec := UserRec{}\n          if err := rows.Scan(&rec); err != nil {\n               return nil, err\n          }\n          recs = append(recs, rec)\n     }\n     return recs, nil\n}\n```", "```\ntype UserRec struct {\n     User string\n     DisplayName sql.NullString\n     ID int\n}\n```", "```\nfunc (s *Storage) AddUser(ctx context.Context, u UserRec) error {\n     _, err := s.addUserStmt.ExecContext(\n          ctx,\n          u.User,\n          u.DisplayName,\n          u.ID,\n     )\n     return err\n}\nfunc (s *Storage) UpdateDisplayName(ctx context.Context, id int, name string) error {\n     _, err := s.updateDisplayName.ExecContext(\n          ctx,\n          name,\n          id,\n     )\n     return err\n}\n```", "```\nfunc (s *Storage) AddUser(ctx context.Context, u UserRec) error {\n     const stmt = `INSERT INTO users (User,DisplayName,ID)\n     VALUES ($1, $2, $3)`\n     _, err := s.conn.Exec(\n          ctx, \n          stmt, \n          u.User, \n          u.DisplayName, \n          u.ID,\n     )\n    return err \n}\n```", "```\nfunc (s *Storage) AddOrUpdateUser(ctx context.Context, u UserRec) (err error) {\n     const (\n          getStmt = `SELECT \"ID\" FROM users WHERE \"User\" = $1`\n          insertStmt = `INSERT INTO users (User,DisplayName,ID)\n          VALUES ($1, $2, $3)`\n          updateStmt = `UPDATE \"users\" SET \"User\" = $1,\n          \"DisplayName\" = $2 WHERE \"ID\" = 3`\n     )\n     tx, err := s.conn.BeginTx(ctx, &sql.TxOptions{Isolation: sql.LevelSerializable})\n     if err != nil {\n           return err\n     }\n     defer func() {\n          if err != nil {\n               tx.Rollback()\n               return\n          }\n          err = tx.Commit()\n     }()\n     _, err := tx.QueryRowContext(ctx, getStmt, u.User)\n     if err != nil {\n          if err == sql.ErrNoRows {\n               _, err = tx.ExecContext(ctx, insertStmt, u.User, u.DisplayName, u.ID)\n               if err != nil {\n                    return err\n               }\n          }\n          return err\n     }\n     _, err = tx.ExecContext(ctx, updateStmt, u.User, u.DisplayName, u.ID))\n     return err\n}\n```", "```\nfunc (s *Storage) AddOrUpdateUser(ctx context.Context, u UserRec) (err error) {\n     const (\n          getStmt = `SELECT \"ID\" FROM \"users\" WHERE \"ID\" = $1`\n          updateStmt = `UPDATE \"users\" SET \"Data\" = $1 WHERE \"ID\" = $2`\n          addStmt = `INSERT INTO \"users\" (ID,Data) VALUES ($1, $2)`\n     )\n     tx, err := conn.BeginTx(\n          ctx , \n          pgx.TxOptions{\n               IsoLevel: pgx.Serializable,\n               AccessMode: pgx.ReadWrite,\n               DeferableMode: pgx.NotDeferrable,\n          },\n     )\n     defer func() {\n          if err != nil {\n               tx.Rollback()\n               return\n          }\n          err = tx.Commit()\n     }()\n     _, err := tx.QueryRow(ctx, getUserStmt, u.ID)\n     if err != nil {\n          if err == sql.ErrNoRows {\n               _, err = tx.ExecContext(ctx, insertStmt, u.ID, u)\n               if err != nil {\n                    return err\n               }\n          }\n          return err\n     }\n     _, err = tx.Exec(ctx, updateStmt, u.ID, u)\n     return err\n}\n```", "```\ntype UserStorage interface {\n     User(ctx context.Context, id string) (UserRec, error)\n     AddUser(ctx context.Context, u UserRec) error\n     UpdateDisplayName(ctx context.Context, id string, name string) error\n}\n```", "```\ntype getReq struct {\n     Author string `json:\"author\"`\n}\ntype getResp struct {\n     Quote string `json:\"quote\"`\n     Error *Error `json:\"error\"`\n}\n```", "```\ntype Error struct {\n     Code ErrCode\n     Msg string\n}\nfunc (e *Error) Error() string {\n     return fmt.Errorf(\"(code %v): %s\", e.Code, e.Msg)\n}\n```", "```\ntype QOTD struct {\n     addr string\n     client *http.Client\n}\nfunc New(addr string) (*QOTD, error) {\n     if _, _, err := net.SplitHostPort(addr); err != nil {\n          return nil, err\n     }\n     return &QOTD{addr: addr, client: &http.Client{}}\n}\n```", "```\nfunc (q *QOTD) restCall(ctx context.Context, endpoint string, req, resp interface{}) error {\n     if _, ok := ctx.Deadline(); !ok {\n          var cancel context.CancelFunc\n          ctx, cancel = context.WithDeadline(ctx, 2 * time.Second)\n          defer cancel()\n     }\n     b, err := json.Marshal(req)\n     if err != nil {\n          return err\n     }\n     hReq, err := http.NewRequestWithContext(\n          ctx, \n          http.POST, \n          endpoint,\n          bytes.NewBuffer(b), \n     )\n     if err != nil {\n          return err\n     }\n     resp, err := q.client.Do(hReq)\n     if err != nil {\n          return err\n     }\n     b, err := io.ReadAll(resp.Body)\n     if err != nil {\n          return err\n     }\n     return json.Unmarshal(b, resp)\n}\n```", "```\nfunc (q *QOTD) Get(ctx context.Context, author string) (string, error) {\n     const endpoint = `/v1/qotd`\n     resp := getResp{}\n     err := q.restCall(ctx, path.Join(q.addr, endpoint), getReq{Author: author}), &resp)\n     switch {\n     case err != nil:\n          return \"\", err\n     case resp.Error != nil:\n          return \"\", resp.Error\n     }\n     return resp.Quote, nil\n}\n```", "```\ntype server struct {\n     serv *http.Server\n     quotes map[string][]string\n}\n```", "```\nfunc newServer(port int) (*server, error) {\n     s := &server{\n          serv: &http.Server{\n               Addr: \":\" + strconv.Itoa(port),\n          },\n          quotes: map[string][]string{\n               // Add quotes here\n          },\n     }\n     mux := http.NewServeMux()\n     mux.HandleFunc(`/qotd/v1/get`, s.qotdGet)\n     // The muxer implements http.Handler \n     // and we assign it for our server’s URL handling.\n     s.serv.Handler = mux\n     return s, nil\n}\nfunc (s *server) start() error {\n     return s.serv.ListenAndServe()\n}\n```", "```\nfunc (s *server) qotdGet(w http.ResponseWriter, r *http.Request) {\n     req := getReq{}\n     if err := req.fromReader(r.Body); err != nil {\n          http.Error(w, err.Error(), http.StatusBadRequest)\n          return\n     }\n     var quotes []string\n     if req.Author == \"\" {\n          // Map access is random, this will randomly choose a            \t          // set of quotes from an author.\n          for _, quotes = range s.quotes {\n               break\n          }\n     } else {\n          var ok bool\n          quotes, ok = s.quotes[req.Author]\n          if !ok {\n               b, err := json.Marshal(\n                    getResp{\n                         Error: &Error{\n                              Code: UnknownAuthor,\n                              Msg:  fmt.Sprintf(\"Author %q was not found\", req.Author),\n                        },\n                    },\n               )\n               if err != nil {\n                    http.Error(w, err.Error(), http.StatusBadRequest)\n                    return\n               }\n               w.Write(b)\n               return\n          }\n     }\n     i := rand.Intn(len(quotes))\n     b, err := json.Marshal(getResp{Quote: quotes[i]})\n     if err != nil {\n          http.Error(w, err.Error(), http.StatusBadRequest)\n          return\n     }\n     w.Write(b)\n     return\n```", "```\nsyntax = \"proto3\";\npackage qotd;\noption go_package = \"github.com/[repo]/proto/qotd\";\nmessage GetReq {\n        string author = 1;\n}\nmessage GetResp {\n        string author = 1;\n        string quote = 2;\n}\nservice QOTD {\n   rpc GetQOTD(GetReq) returns (GetResp) {};\n}\n```", "```\nbuf config init\n```", "```\nversion: v1\nlint:\n  use:\n    - DEFAULT\nbreaking:\n  use:\n    - FILE\n```", "```\nversion: v1\nplugins:\n  - name: go\n    out: ./\n    opt:\n      - paths=source_relative\n  - name: go-grpc\n    out: ./\n    opt:\n      - paths=source_relative\n```", "```\nbuf build\n```", "```\nbuf generate\n```", "```\npackage client\nimport (\n        \"context\"\n        \"time\"\n        \"google.golang.org/grpc\"\n        pb \"[repo]/grpc/proto\"\n)\ntype Client struct {\n        client pb.QOTDClient\n        conn   *grpc.ClientConn\n}\nfunc New(addr string) (*Client, error) {\n        conn, err := grpc.Dial(addr, grpc.WithInsecure())\n        if err != nil {\n                return nil, err\n        }\n        return &Client{\n                client: pb.NewQOTDClient(conn),\n                conn: conn,\n        }, nil\n}\nfunc (c *Client) QOTD(ctx context.Context, wantAuthor string) (author, quote string, err error) {\n        if _, ok := ctx.Deadline(); !ok {\n                var cancel context.CancelFunc\n                ctx, cancel = context.WithTimeout(ctx, 2 * time.Second)\n                defer cancel()\n        }\n        resp, err := c.client.GetQOTD(ctx, &pb.GetReq{Author: wantAuthor})\n        if err != nil {\n                return \"\", \"\", err\n        }\n        return resp.Author, resp.Quote, nil\n}\n```", "```\npackage server\nimport (\n        \"context\"\n        \"fmt\"\n        \"math/rand\"\n        \"net\"\n        \"sync\"\n        \"google.golang.org/grpc\"\n        \"google.golang.org/grpc/codes\"\n        \"google.golang.org/grpc/status\"\n\n        pb \"[repo]/grpc/proto\"\n)\ntype API struct {\n     pb.UnimplementedQOTDServer\n     addr string\n     quotes map[string][]string\n     mu sync.Mutex\n     grpcServer *grpc.Server\n}\nfunc New(addr string) (*API, error) {\n     var opts []grpc.ServerOption\n     a := &API{\n          addr: addr,\n          quotes: map[string][]string{\n               // Insert your quote mappings here\n          },\n          grpcServer: grpc.NewServer(opts...),\n     }\n     a.grpcServer.RegisterService(&pb.QOTD_ServiceDesc, a)\n     return a, nil\n}\n```", "```\nfunc (a *API) Start() error {\n     a.mu.Lock()\n     defer a.mu.Unlock()\n     lis, err := net.Listen(\"tcp\", a.addr)\n     if err != nil {\n          return err\n     }\n     return a.grpcServer.Serve(lis)\n}\nfunc (a *API) Stop() {\n     a.mu.Lock()\n     defer a.mu.Unlock()\n     a.grpcServer.Stop()\n}\n```", "```\nfunc (a *API) GetQOTD(ctx context.Context, req *pb.GetReq) (*pb.GetResp, error) {\n     var (\n          author string\n          quotes []string\n     )\n     if req.Author == \"\" {\n          for author, quotes = range s.quotes {\n               break\n          }\n     } else {\n          author = req.Author\n          var ok bool\n          quotes, ok = s.quotes[req.Author]\n          if !ok {\n               return nil, status.Error(\n                    codes.NotFound, \n                    fmt.Sprintf(\"author %q not found\", req.author),\n               )\n          }\n     }\n     return &pb.GetResp{\n          Author: author, \n          Quote: quotes[rand.Intn(len(quotes))],\n     }, nil\n}\n```", "```\npackage main\nimport (\n     \"flag\"\n     \"log\"\n     \"github.com/[repo]/internal/server\"\n     pb \"[repo]/proto\"\n)\nvar addr = flag.String(\"addr\", \"127.0.0.1:80\", \"The address to run on.\")\nfunc main() {\n     flag.Parse()\n     s, err := server.New(*addr)\n     if err != nil {\n          panic(err)\n     }\n     done := make(chan error, 1)\n     log.Println(\"Starting server at: \", *addr)\n     go func() {\n          defer close(done)\n          done <-s.Start()\n     }()\n     err <- done\n     log.Println(\"Server exited with error: \", err)\n}\n```", "```\ngo run qotd.go --addr=\"127.0.0.1:2562\"\n```", "```\nStarting server at: 127.0.0.1:2562\n```", "```\npackage main\nimport (\n        \"context\"\n        \"flag\"\n        \"fmt\"\n        \"github.com/devopsforgo/book/book/code/1/4/grpc/client\"\n)\nvar (\n        addr   = flag.String(\"addr\", \"127.0.0.1:80\", \"The address of the server.\")\n        author = flag.String(\"author\", \"\", \"The author whose quote to get\")\n)\nfunc main() {\n        flag.Parse()\n        c, err := client.New(*addr)\n        if err != nil {\n                panic(err)\n        }\n        a, q, err := c.QOTD(context.Background(), *author)\n        if err != nil {\n                panic(err)\n        }\n        fmt.Println(\"Author: \", a)\n        fmt.Printf(\"Quote of the Day: %q\\n\", q)\n}\n```", "```\ngo run qotd.go --addr=\"127.0.0.1:2562\"\n```", "```\nAuthor: [some author]\nQuote: [some quote]\n```"]