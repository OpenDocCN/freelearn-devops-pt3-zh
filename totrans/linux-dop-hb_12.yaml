- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Leveraging Infrastructure as Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用基础设施即代码
- en: In today’s digital landscape, managing and deploying infrastructure is a complex
    and time-consuming process. Traditionally, infrastructure deployment involves
    manually configuring each server, network, and storage device. This process is
    not only time-consuming but also prone to errors and inconsistencies. **Infrastructure
    as Code** (**IaC**) solutions provide an automated way to manage and deploy infrastructure.
    IaC solutions allow developers to treat infrastructure as code, enabling them
    to define, manage, and provision infrastructure in the same way they do with code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的数字化环境中，管理和部署基础设施是一个复杂且耗时的过程。传统上，基础设施部署涉及手动配置每个服务器、网络和存储设备。这个过程不仅耗时，而且容易出错和产生不一致性。**基础设施即代码**（**IaC**）解决方案提供了一种自动化的方式来管理和部署基础设施。IaC
    解决方案使开发人员能够将基础设施视为代码，从而以与代码相同的方式定义、管理和配置基础设施。
- en: In this chapter, we will explore IaC solutions, with a focus on Terraform. `2.0`
    to `1.1`. BSL allows you to use Terraform freely and you can access its source
    code, so there is no change for the end users.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索 IaC 解决方案，重点关注 Terraform。从 `2.0` 到 `1.1`。BSL 允许你自由使用 Terraform，并可以访问其源代码，因此对最终用户没有变化。
- en: With Terraform, developers can write code to define their infrastructure requirements,
    and Terraform will handle the provisioning and configuration of the required resources.
    Terraform has gained popularity in recent years due to its simplicity, flexibility,
    and support for multiple cloud providers. In the following sections, we will discuss
    the key features and benefits of Terraform, as well as how to use it to provision
    infrastructure on popular cloud providers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Terraform，开发人员可以编写代码来定义他们的基础设施需求，而 Terraform 将负责所需资源的配置和部署。近年来，由于其简便性、灵活性以及对多个云服务提供商的支持，Terraform
    变得越来越流行。在接下来的章节中，我们将讨论 Terraform 的主要特性和优势，以及如何使用它在流行的云服务提供商上配置基础设施。
- en: 'We will learn about the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将学习以下内容：
- en: What is IaC?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 IaC？
- en: IaC versus Configuration as Code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IaC 与配置即代码的区别
- en: IaC projects worth knowing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值得了解的 IaC 项目
- en: Terraform
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Terraform
- en: HCL in depth
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解 HCL
- en: Terraform examples with AWS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 AWS 的 Terraform 示例
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a system capable of running Terraform. Terraform
    is a single binary program written in the Go programming language. Its installation
    is straightforward and is explained on the HashiCorp Terraform project page ([https://developer.hashicorp.com/terraform/downloads](https://developer.hashicorp.com/terraform/downloads)).
    HashiCorp is the company behind Terraform and other cloud management tools that
    have become de facto standards in the DevOps world. You will also need an AWS
    account. AWS provides a Free Tier of services for a limited time. We are using
    services that have free tiers at the time of writing this book. Before you run
    the examples, please consult the AWS Free Tier listing to avoid unnecessary costs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您需要一台能够运行 Terraform 的系统。Terraform 是一个用 Go 编程语言编写的单一二进制程序。其安装过程简单易懂，并在 HashiCorp
    Terraform 项目页面上有详细说明（[https://developer.hashicorp.com/terraform/downloads](https://developer.hashicorp.com/terraform/downloads)）。HashiCorp
    是 Terraform 以及其他云管理工具的背后公司，这些工具已成为 DevOps 领域的事实标准。您还需要一个 AWS 账户。AWS 提供有限时间的免费服务。我们使用的服务在写本书时具有免费层。在运行示例之前，请查阅
    AWS 免费层清单，以避免不必要的费用。
- en: What is IaC?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 IaC？
- en: IaC is a software development practice that involves defining and managing infrastructure
    through code. In essence, it means that infrastructure is treated as if it were
    a piece of software, and is managed through the same processes and tools. IaC
    solutions enable developers to define, provision, and manage infrastructure using
    code, instead of manually configuring servers, networks, and storage devices.
    This approach to infrastructure management is highly automated, scalable, and
    efficient, allowing organizations to reduce deployment times and improve consistency
    and reliability.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础设施即代码**（IaC）是一种软件开发实践，它通过代码定义和管理基础设施。实质上，这意味着将基础设施视为软件，并通过相同的流程和工具进行管理。IaC
    解决方案使开发人员能够通过代码定义、配置和管理基础设施，而无需手动配置服务器、网络和存储设备。这种基础设施管理方法高度自动化、可扩展且高效，能够帮助组织减少部署时间，提高一致性和可靠性。'
- en: IaC solutions come in different forms, including configuration management tools,
    provisioning tools, and cloud orchestration tools. Configuration management tools,
    such as **Ansible** and **Chef**, are used to manage the configuration of individual
    servers or groups of servers. Provisioning tools, such as Terraform and **CloudFormation**,
    are used to provision and configure infrastructure resources. Cloud orchestration
    tools, such as **Kubernetes** and **OpenShift**, are used to manage containerized
    applications and their associated infrastructure. Regardless of the specific tool
    used, IaC solutions offer several benefits, including repeatability and consistency.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IaC解决方案有不同的形式，包括配置管理工具、配置工具和云编排工具。配置管理工具，如**Ansible**和**Chef**，用于管理单个服务器或服务器组的配置。配置工具，如Terraform和**CloudFormation**，用于配置和管理基础设施资源。云编排工具，如**Kubernetes**和**OpenShift**，用于管理容器化的应用程序及其相关基础设施。无论使用何种具体工具，IaC解决方案都能提供多个好处，包括可重复性和一致性。
- en: IaC versus Configuration as Code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即代码与配置即代码
- en: 'You might be wondering, didn’t we just cover this in [*Chapter 11*](B18197_11.xhtml#_idTextAnchor325),
    when we spoke about Ansible? The answer is no, we didn’t. There’s a very distinctive
    difference between IaC and **Configuration as Code** (**CaC**). IaC tools are
    concerned with exactly that: infrastructure. This means networking, DNS names,
    routes, and servers (VM or physical) up to the installation of the operating system.
    CaC is concerned with what lives inside the operating system. People try to use
    one tool for everything, so you’ll see modules for Ansible that can configure
    switches and routers, but the tool shines best where it is intended to be used.
    Nobody is going to die if you mix these two, but your life will become more difficult.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，难道我们在[*第11章*](B18197_11.xhtml#_idTextAnchor325)中已经讲过这个内容了吗？我们谈到的是Ansible？答案是否定的，我们并没有讲过。基础设施即代码（IaC）和**配置即代码**（**CaC**）之间有着非常明显的区别。IaC工具关注的正是这一点：基础设施。这意味着网络、DNS名称、路由以及服务器（虚拟机或物理机），一直到操作系统的安装。而CaC关注的是操作系统内部的内容。人们常常试图用一个工具做所有事情，因此你会看到Ansible有一些模块可以配置交换机和路由器，但该工具最擅长的还是它原本设计的用途。如果你把这两者混在一起，虽然不会出什么大问题，但你的工作会变得更加困难。
- en: IaC projects worth knowing
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值得了解的IaC项目
- en: Since the rise of the public cloud, especially AWS, the need for a repeatable
    and reliable way of setting up an infrastructure and configuring cloud services
    started to grow as well. Since then, a lot of tools have come to be and more of
    them are being developed. In this section, we will review the most popular and
    innovative tools out there.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自从公共云的崛起，尤其是AWS之后，对于一种可重复和可靠的方式来设置基础设施并配置云服务的需求也开始增长。从那时起，许多工具应运而生，且越来越多的工具正在开发中。在本节中，我们将回顾一些最流行和最具创新性的工具。
- en: AWS CloudFormation
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS CloudFormation
- en: AWS CloudFormation is a popular IaC tool offered by **Amazon Web Services**
    (**AWS**) to automate the provisioning of AWS resources. It was first released
    in 2011 and has since become a widely used tool for managing infrastructure in
    the cloud.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudFormation是由**Amazon Web Services**（**AWS**）提供的一个流行的IaC工具，用于自动化AWS资源的配置。它首次发布于2011年，并迅速成为云端管理基础设施的广泛使用工具。
- en: CloudFormation allows you to define the infrastructure in a declarative language,
    such as YAML or JSON, and then create, update, or delete stacks of resources based
    on those definitions. This allows for consistent and reproducible infrastructure
    deployments, as well as easy rollback and version control. It’s not all sparkles
    and rainbows, though – at times, you might find yourself stuck in a rollback loop
    after making an untested change. For example, let’s say you’re changing your AWS
    Lambda environment version. Unfortunately, it failed as the version you’re currently
    using is no longer supported. So, it is now stuck at rolling back and it’s in
    an `UPDATE_ROLLBACK_FAILED` state. You will need to resolve the issue by hand
    as there is no automated way of doing that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation允许你使用声明性语言（如YAML或JSON）来定义基础设施，然后根据这些定义创建、更新或删除资源堆栈。这不仅能实现一致且可重复的基础设施部署，还能方便地进行回滚和版本控制。不过，并非所有情况都是一帆风顺的——有时，你可能会在进行未经测试的更改后卡在回滚循环中。例如，假设你正在更改AWS
    Lambda的环境版本。不幸的是，由于你当前使用的版本不再受支持，因此更改失败。现在它被卡在回滚状态，显示为`UPDATE_ROLLBACK_FAILED`。你需要手动解决这个问题，因为没有自动化的方式来处理这一问题。
- en: CloudFormation integrates with other AWS services, such as AWS **Identity and
    Access Management** (**IAM**), AWS **Elastic Load Balancing** (**ELB**), and AWS
    Auto Scaling, to enable the creation of complex architectures with ease.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation与其他AWS服务（如AWS **身份与访问管理**（**IAM**）、AWS **弹性负载均衡**（**ELB**）和AWS自动扩展）集成，轻松实现复杂架构的创建。
- en: 'Here’s an example CloudFormation stack written in YAML that creates an EC2
    instance called `t4g.small` in a public subnet in the default VPC:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个用YAML编写的CloudFormation堆栈示例，它在默认VPC的公共子网中创建一个名为`t4g.small`的EC2实例：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this stack, we’re creating two resources: an EC2 instance and a security
    group attached to this instance. The CloudFormation stack can get four parameters:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个堆栈中，我们创建了两个资源：一个EC2实例和一个附加到该实例的安全组。CloudFormation堆栈可以获取四个参数：
- en: '`KeyName`: The SSH key name that was already created inside the AWS EC2 service.
    This defaults to `admin-key`.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KeyName`：已经在AWS EC2服务中创建的SSH密钥名称。默认值为`admin-key`。'
- en: '`InstanceType`: The type of the instance we want to start with. It defaults
    to `t4g.small`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InstanceType`：我们要启动的实例类型。默认值为`t4g.small`。'
- en: '`SSHCIDR`: The `22`. This defaults to `0.0.0.0/0`. Here, we’re validating the
    provided input against the regular expression and the length of the variable.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SSHCIDR`：`22`。默认值为`0.0.0.0/0`。在这里，我们验证提供的输入是否符合正则表达式，并检查变量的长度。'
- en: '`LatestAmiId`: The AMI ID to use as a base system to start the EC2 instance.
    This defaults to the latest AMI of Ubuntu Linux `22.04`.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LatestAmiId`：用于启动EC2实例的基础系统AMI ID。默认值为Ubuntu Linux `22.04`的最新AMI。'
- en: Next, there’s a `Resources` section. Here, the EC2 instance is created using
    the `AWS::EC2::Instance` resource type and the security group is created with
    the `AWS::EC2::SecurityGroup` resource.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Resources`部分。在这里，EC2实例是使用`AWS::EC2::Instance`资源类型创建的，安全组是使用`AWS::EC2::SecurityGroup`资源创建的。
- en: The final section is called `Outputs`; here, we can reveal IDs and other properties
    of the resources created. Here, we’re exposing the instance ID, its public DNS
    name, and its public IP address.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分称为`Outputs`；在这里，我们可以显示已创建资源的ID和其他属性。在这里，我们公开实例ID、其公共DNS名称和公共IP地址。
- en: It’s possible to use these output values as input for another CloudFormation
    stack, which will make the YAML files of your CloudFormation code considerably
    smaller and easier to maintain.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将这些输出值作为另一个CloudFormation堆栈的输入，这将使CloudFormation代码的YAML文件大大减小，并更易于维护。
- en: AWS Cloud Development Kit
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AWS 云开发工具包
- en: AWS **Cloud Development Kit** (**CDK**) is an open source software development
    framework that’s used to define cloud infrastructure in code. With CDK, developers
    can write code in familiar programming languages such as TypeScript, Python, Java,
    C#, and JavaScript to create and manage cloud resources on AWS.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: AWS **云开发工具包**（**CDK**）是一个开源软件开发框架，用于在代码中定义云基础设施。通过CDK，开发人员可以使用熟悉的编程语言，如TypeScript、Python、Java、C#和JavaScript，来创建和管理AWS上的云资源。
- en: AWS CDK was first released in July 2018 as an open source project by AWS. It
    was designed to simplify the process of building and deploying cloud infrastructure
    by allowing developers to use their existing programming language skills and tools.
    With CDK, developers can define IaC and take advantage of the benefits of version
    control, automated testing, and **continuous integration**/**continuous deployment**
    (**CI**/**CD**) pipelines. Since its release, CDK has become a popular choice
    for building infrastructure on AWS, and it continues to receive updates and new
    features to this day.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CDK于2018年7月首次作为开源项目发布。它旨在简化构建和部署云基础设施的过程，让开发人员能够使用现有的编程语言技能和工具。通过CDK，开发人员可以定义基础设施即代码（IaC），并利用版本控制、自动化测试和**持续集成**/**持续部署**（**CI**/**CD**）管道的好处。自发布以来，CDK已成为在AWS上构建基础设施的流行选择，并持续更新和新增功能。
- en: 'Here’s an example of some AWS CDK Python code that creates an EC2 instance:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些AWS CDK Python代码的示例，用于创建EC2实例：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code creates a new VPC and an EC2 instance with an instance type of `t4g.small`
    with Amazon Linux installed as the operating system. Note that you will need to
    have AWS CDK installed and configured to run this code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个新的VPC和一个EC2实例，实例类型为`t4g.small`，操作系统为安装了Amazon Linux的EC2实例。请注意，运行此代码之前需要先安装并配置AWS
    CDK。
- en: Terraform
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform
- en: Terraform is a popular open source tool that’s used for infrastructure automation,
    specifically for creating, managing, and provisioning cloud resources. It enables
    developers to define their IaC and automates the deployment of their infrastructure
    across multiple cloud platforms. With Terraform, users can write declarative configuration
    files in a simple and intuitive language that can be versioned, shared, and reused.
    This approach to infrastructure management ensures consistency and scalability
    and reduces the risk of manual errors. Terraform supports a wide range of cloud
    providers, including AWS, Azure, Google Cloud, and more, making it a popular choice
    for organizations with complex cloud infrastructure needs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一个流行的开源工具，用于基础设施自动化，特别是用于创建、管理和配置云资源。它使开发者能够定义基础设施即代码（IaC），并自动化在多个云平台上部署基础设施的过程。通过
    Terraform，用户可以编写声明性配置文件，这些文件使用简单直观的语言，可以进行版本管理、共享和重用。这种基础设施管理方式确保了系统的一致性和可扩展性，并减少了手动错误的风险。Terraform
    支持多种云服务提供商，包括 AWS、Azure、Google Cloud 等，这使得它成为拥有复杂云基础设施需求的组织的热门选择。
- en: Terraform was created by HashiCorp, a company founded in 2012 by Mitchell Hashimoto
    and Armon Dadgar. The company is known for developing popular open source tools
    for infrastructure automation, including Vagrant, Consul, Nomad, and Vault. Terraform
    was first released in July 2014 and has since become one of the most widely adopted
    IaC tools in the industry. HashiCorp continues to maintain and develop Terraform,
    with regular releases and updates that address new cloud provider features, security
    vulnerabilities, and community feedback. The tool has a large and active community
    of contributors, which has helped to further enhance its functionality and support
    for new use cases.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 由 HashiCorp 创建，HashiCorp 是由 Mitchell Hashimoto 和 Armon Dadgar 于 2012
    年创立的公司。该公司以开发流行的基础设施自动化开源工具而闻名，包括 Vagrant、Consul、Nomad 和 Vault。Terraform 于 2014
    年 7 月首次发布，随后成为业内最广泛采用的 IaC 工具之一。HashiCorp 继续维护和开发 Terraform，并定期发布更新，解决新的云服务提供商特性、安全漏洞和社区反馈。该工具拥有一个庞大且活跃的贡献者社区，进一步增强了其功能并支持新的使用场景。
- en: Terraform is also a main topic for this chapter, so we will dig into the code
    and its internals in the *Terraform* section later.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 也是本章的一个主要话题，稍后我们将在 *Terraform* 部分深入研究其代码和内部实现。
- en: Cloud Development Kit for Terraform
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform 云开发工具包
- en: '**Cloud Development Kit for Terraform** (**CDKTF**) is an open source software
    development framework for defining cloud infrastructure in code. It allows users
    to define infrastructure using familiar programming languages, such as TypeScript,
    JavaScript, Python, and C#. This provides developers with more flexibility and
    control over their infrastructure as they can leverage their existing programming
    skills and tools to define complex infrastructure. CDKTF was first released in
    2019 as a collaboration between AWS and HashiCorp. Since then, it has gained popularity
    as a powerful tool for defining and deploying infrastructure using Terraform.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**Terraform 云开发工具包**（**CDKTF**）是一个开源软件开发框架，用于以代码形式定义云基础设施。它允许用户使用熟悉的编程语言（如
    TypeScript、JavaScript、Python 和 C#）来定义基础设施。这为开发者提供了更大的灵活性和控制力，因为他们可以利用现有的编程技能和工具来定义复杂的基础设施。CDKTF
    于 2019 年首次发布，是 AWS 和 HashiCorp 的合作成果。从那时起，它作为一个强大的工具，在使用 Terraform 定义和部署基础设施方面获得了广泛的关注。'
- en: CDKTF supports a wide range of programming languages, making it easy for developers
    to use their preferred language. It uses constructs, which are reusable building
    blocks that represent AWS resources, to create infrastructure. Users can define
    constructs for each resource they want to create, which can be combined to form
    a more complex infrastructure. This allows users to define their infrastructure
    in a modular and reusable way, which simplifies the process of creating and maintaining
    infrastructure over time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: CDKTF 支持多种编程语言，使开发者可以轻松使用自己熟悉的语言。它使用构造函数，这些构造函数是可重用的构建块，代表 AWS 资源，用来创建基础设施。用户可以为每个要创建的资源定义构造函数，并将其组合形成更复杂的基础设施。这使得用户能够以模块化和可重用的方式定义基础设施，从而简化了创建和维护基础设施的过程。
- en: 'Here is the example code for creating an EC2 instance in AWS using CDKTF in
    Python:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用 Python 在 AWS 中创建 EC2 实例的 CDKTF 示例代码：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The constructs, App, and `TerraformStack` classes are imported from the `cdktf`
    package, while the AWS resources are imported from the `imports.aws` module. The
    preceding code creates an EC2 instance with a security group and a basic user
    data script that starts a simple HTTP server. The resulting infrastructure can
    be deployed using the `cdktf deploy` command, which generates Terraform configuration
    files and executes the Terraform CLI.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`App` 和 `TerraformStack` 类从 `cdktf` 包导入，而 AWS 资源则从 `imports.aws` 模块导入。上面的代码创建了一个带有安全组的
    EC2 实例，并带有一个基本的用户数据脚本，用于启动一个简单的 HTTP 服务器。生成的基础设施可以使用 `cdktf deploy` 命令进行部署，该命令会生成
    Terraform 配置文件并执行 Terraform CLI。'
- en: You can read more about CDKTF at [https://developer.hashicorp.com/terraform/cdktf](https://developer.hashicorp.com/terraform/cdktf).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://developer.hashicorp.com/terraform/cdktf](https://developer.hashicorp.com/terraform/cdktf)
    阅读更多关于 CDKTF 的信息。
- en: Pulumi
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pulumi
- en: '**Pulumi** is an open source IaC tool that allows developers to build, deploy,
    and manage cloud infrastructure using familiar programming languages. Unlike traditional
    IaC tools that rely on declarative languages such as YAML or JSON, Pulumi uses
    real programming languages, such as Python, TypeScript, Go, and .NET, to define
    and manage infrastructure. This enables developers to leverage their existing
    skills and experience to create infrastructure using the same tools and processes
    they use for building applications. With Pulumi, developers can create, test,
    and deploy infrastructure changes just like they do with code changes – that is,
    by using version control and CI/CD tools.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pulumi** 是一个开源的 IaC 工具，允许开发人员使用熟悉的编程语言构建、部署和管理云基础设施。与依赖声明性语言如 YAML 或 JSON
    的传统 IaC 工具不同，Pulumi 使用真实的编程语言，如 Python、TypeScript、Go 和 .NET，来定义和管理基础设施。这使得开发人员能够利用他们现有的技能和经验，使用构建应用程序时所用的相同工具和流程来创建基础设施。使用
    Pulumi，开发人员可以像进行代码更改一样创建、测试和部署基础设施更改——即通过使用版本控制和 CI/CD 工具。'
- en: The first release of Pulumi was in May 2018 and aimed to simplify the process
    of managing cloud infrastructure. Pulumi was founded by Joe Duffy, a former Microsoft
    engineer who previously worked on the development of the .NET runtime and compiler.
    Duffy saw an opportunity to use programming languages to manage infrastructure,
    providing a more flexible and powerful approach than traditional IaC tools. Since
    its release, Pulumi has gained popularity among developers, particularly those
    who work in cloud-native environments or who use multiple cloud providers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Pulumi 的首次发布是在 2018 年 5 月，旨在简化管理云基础设施的过程。Pulumi 由 Joe Duffy 创立，他是前微软工程师，曾参与
    .NET 运行时和编译器的开发。Duffy 看到了一个机会，利用编程语言来管理基础设施，提供了一种比传统的 IaC 工具更灵活、更强大的方法。自发布以来，Pulumi
    在开发者中获得了广泛的关注，尤其是在云原生环境中工作或使用多个云服务提供商的开发者。
- en: Pulumi supports a variety of programming languages, including Python, TypeScript,
    Go, .NET, and Node.js. Pulumi also provides a rich set of libraries and tools
    for working with cloud resources, including support for popular cloud providers
    such as AWS, Azure, Google Cloud, and Kubernetes. Additionally, Pulumi provides
    integrations with popular CI/CD tools, such as Jenkins, CircleCI, and GitLab,
    enabling developers to easily incorporate infrastructure changes into their existing
    workflows.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Pulumi 支持多种编程语言，包括 Python、TypeScript、Go、.NET 和 Node.js。Pulumi 还提供了一套丰富的库和工具，用于处理云资源，包括对
    AWS、Azure、Google Cloud 和 Kubernetes 等流行云服务提供商的支持。此外，Pulumi 还与流行的 CI/CD 工具集成，如
    Jenkins、CircleCI 和 GitLab，使开发人员能够轻松地将基础设施更改融入现有的工作流程中。
- en: 'Here’s an example of Pulumi code in Python that creates an AWS EC2 instance:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 Pulumi 使用 Python 创建 AWS EC2 实例的示例代码：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This code defines an AWS security group that allows inbound traffic on port
    `22` (SSH), and then creates an EC2 instance of the `t4g.small` instance type,
    using an Ubuntu 22.04 LTS AMI. The instance is associated with the security group
    we created earlier and is tagged with a name and environment. Finally, the public
    IP address of the instance is exported as a Pulumi stack output, which can be
    used by other resources in the stack or accessed by the user.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个 AWS 安全组，允许通过端口 `22`（SSH）进行入站流量，然后创建一个 `t4g.small` 类型的 EC2 实例，使用 Ubuntu
    22.04 LTS AMI。该实例与我们之前创建的安全组关联，并带有名称和环境标签。最后，实例的公共 IP 地址作为 Pulumi 堆栈输出被导出，可以供堆栈中的其他资源使用或由用户访问。
- en: 'In this section, we introduced several IaC solutions: CDK, CDKTF, Terraform,
    and Pulumi. Some of them are targeted at one cloud provider, and some of them
    allow us to configure different cloud environments.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们介绍了几种 IaC 解决方案：CDK、CDKTF、Terraform 和 Pulumi。它们中的一些针对特定的云提供商，而另一些则允许我们配置不同的云环境。
- en: In the next section, we will get back to Terraform to explore what makes it
    tick and learn how to use IaC in practice. This will give us a foundation to quickly
    understand other solutions, including the CDKs we mentioned earlier.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将回到 Terraform，深入探讨它的工作原理，并学习如何在实践中使用基础设施即代码（IaC）。这将为我们快速理解其他解决方案奠定基础，包括我们之前提到的
    CDK。
- en: Terraform
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform
- en: In this section, we are going to introduce Terraform, one of the most widely
    used IaC solutions in the wild.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将介绍 Terraform，这是目前最广泛使用的 IaC 解决方案之一。
- en: 'Terraform is an IaC tool developed by HashiCorp. The rationale behind using
    it is similar to using Ansible to configure your systems: infrastructure configuration
    is kept in text files. They are not YAML, as with Ansible; instead, they are written
    in a special configuration language developed by HashiCorp: **HashiCorp Configuration
    Language** (**HCL**). Text files are easily versioned, which means that infrastructure
    changes can be stored in a version control system such as Git.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 是一个由 HashiCorp 开发的 IaC 工具。使用它的原理类似于使用 Ansible 配置系统：基础设施配置保存在文本文件中。它们不像
    Ansible 那样是 YAML 格式的，而是采用 HashiCorp 开发的特殊配置语言：**HashiCorp 配置语言**（**HCL**）。文本文件容易版本化，这意味着基础设施变更可以存储在如
    Git 之类的版本控制系统中。
- en: Actions performed by Terraform are more complicated than those you’ve seen in
    Ansible. A single HCL statement can mean setting up a whole bunch of virtual servers
    and routes between them. So, while Terraform is also declarative like Ansible,
    it is higher level than other tools. Also, contrary to Ansible, Terraform is state-aware.
    Ansible has a list of actions to perform and on each run, it checks which actions
    have already been applied. Terraform, on the other hand, records the last achieved
    state of the system and each time it is executed, it ensures the system will be
    as it is in the code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 执行的操作比你在 Ansible 中看到的更复杂。一个简单的 HCL 语句可能意味着设置一堆虚拟服务器以及它们之间的路由。因此，尽管
    Terraform 和 Ansible 一样是声明式的，但它比其他工具更高层次。此外，与 Ansible 相反，Terraform 是状态感知的。Ansible
    有一个待执行操作的列表，每次运行时，它会检查哪些操作已经执行。而 Terraform 则记录系统最后一次的状态，并确保每次执行时系统都会与代码中的状态一致。
- en: To achieve this, Terraform creates and maintains a state file. It is a text
    file with the `.tfstate` extension that records the last known state of the infrastructure
    that the tool is aware of. The state file is versioned internally; Terraform maintains
    a special counter that allows it to know whether the file is the latest one. The
    state file is essential for Terraform to work properly. You should never corrupt
    or lose the state file. If you lose this file, Terraform will try to create things
    that already exist and maybe delete things it should not.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，Terraform 创建并维护一个状态文件。它是一个扩展名为`.tfstate`的文本文件，记录了工具所知道的基础设施的最后已知状态。状态文件在内部是有版本控制的；Terraform
    维护一个特殊的计数器，允许它知道文件是否是最新的。状态文件对于 Terraform 正常工作至关重要。你绝不能损坏或丢失状态文件。如果丢失了该文件，Terraform
    会尝试创建已经存在的资源，并可能删除不该删除的内容。
- en: There are several ways to ensure the state file is safe. One of them is to store
    it in an object store (such as S3) that’s been properly configured so that the
    state file cannot be deleted. For improved security, you can ensure that the file
    is versioned, which means that the storage will keep old copies of the file for
    eventual reuse.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以确保状态文件的安全。其中一种方法是将其存储在经过适当配置的对象存储中（例如 S3），这样状态文件就无法被删除。为了增强安全性，您可以确保该文件是有版本控制的，这意味着存储将保留文件的旧副本以供以后使用。
- en: 'There is one important thing to be aware of related to `.tfstate`: it will
    contain all information related to your infrastructure, as well as plaintext passwords,
    logins, access keys, and such. It is crucial to keep the file secret and exclude
    it from commits to version control systems (in Git, add it to the `.``gitignore`
    file).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件关于`.tfstate`的重要事情需要注意：它将包含与您的基础设施相关的所有信息，以及明文密码、登录凭证、访问密钥等。保护该文件的隐私至关重要，并且应将其排除在版本控制系统的提交之外（在
    Git 中，可以将其添加到`.gitignore`文件中）。
- en: The code is developed in text files with the `.tf` extension. Contrary to Ansible,
    again, the order in which you place directives in the files is not important.
    Before execution, Terraform analyzes all `.tf` files in the current directory,
    creates a graph of dependencies between configuration elements, and orders them
    properly. It is a common occurrence that code is broken down into smaller `.tf`
    files that group related configuration directives. However, nothing is stopping
    you from keeping them all in one huge file, though it will quickly become too
    big for comfortable use.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在以`.tf`扩展名的文本文件中开发。与Ansible不同，您在文件中放置指令的顺序并不重要。在执行之前，Terraform会分析当前目录下的所有`.tf`文件，创建配置元素之间的依赖关系图，并正确地排列它们。通常情况下，代码会被分解成更小的`.tf`文件，这些文件将相关的配置指令分组。然而，您也可以将所有代码保存在一个巨大的文件中，尽管它很快会变得庞大，不利于使用。
- en: 'Even though you are free to name your files as you wish, so long as their extension
    is `.tf`, there are best practices to be observed:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以自由命名文件，只要它们的扩展名是`.tf`，但还是有一些最佳实践需要遵守：
- en: '`main.tf`: This is the main file where you develop your configuration code.
    It will contain the resources, modules, and other important information.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main.tf`：这是您开发配置代码的主要文件。它将包含资源、模块和其他重要信息。'
- en: '`variables.tf`: This file will contain declarations of all the variables you
    wish to use in the `main.tf` file.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variables.tf`：此文件将包含您希望在`main.tf`文件中使用的所有变量的声明。'
- en: '`outputs.tf`: If the resources in your `main.tf` file produce any outputs,
    they are declared here.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`outputs.tf`：如果您的`main.tf`文件中的资源产生任何输出，它们将在此处声明。'
- en: '`versions.tf`: This file declares the required versions of the Terraform binary
    itself and providers. It is good practice to declare the lowest versions known
    to work properly with your code.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`versions.tf`：此文件声明Terraform二进制文件本身和提供者所需的版本。最好声明已知能够正常工作的最低版本。'
- en: '`providers.tf`: If any of the providers need additional configuration, you
    would place them in this file.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`providers.tf`：如果任何提供者需要额外的配置，您应该将它们放在这个文件中。'
- en: '`backend.tf`: This file contains the configuration for where Terraform should
    store the state file. The state file is an integral part of IaC in Terraform.
    We will talk about this in more depth in the *Terraform* *state* subsection.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`backend.tf`：此文件包含Terraform应将状态文件存储的位置的配置。状态文件是Terraform中基础设施即代码（IaC）的一个重要组成部分。我们将在*Terraform*
    *状态*小节中更深入地讨论这一点。'
- en: 'The heavy lifting in Ansible is done by Python programs called modules. In
    Terraform, it is done by providers. **Providers** are small Golang programs that
    consume the configuration plan prepared by Terraform, connect with services (the
    cloud, devices, and more) through said services’ APIs, and execute the configuration.
    You can think of them as plugins. Providers deliver a set of resource types and,
    eventually, the data sources required to write configuration for the API that
    the provider connects to. The official explanation is that providers “*are a logical
    abstraction of an upstream API.*” Providers are usually published on Terraform
    Registry, which is a public repository of plugins maintained by HashiCorp. You
    can use separate registries, but providers published on Terraform Registry are
    known to be tested and trusted to work properly. Each provider published on this
    registry has extensive documentation with well-commented examples. Whenever you
    are using a new provider, you should visit the registry ([https://registry.terraform.io/](https://registry.terraform.io/)).
    An example of a provider is AWS. This provider exposes a very extensive number
    of resources that you would use to interact with AWS services to provision and
    configure them. Remember: the configuration is limited to infrastructure. You
    can couple Terraform (to provision VMs, for example) with Ansible (to install
    software and configure it within the VM) for a full experience.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中，重活是由名为模块的 Python 程序完成的。而在 Terraform 中，这项工作是由提供者（**Providers**）完成的。**提供者**是小型的
    Golang 程序，它们消耗由 Terraform 准备的配置计划，通过这些服务的 API 连接云端、设备等服务，并执行配置。你可以把它们看作是插件。提供者提供一组资源类型，并最终提供所需的数据源，以便为提供者所连接的
    API 编写配置。官方解释是，提供者“*是上游 API 的逻辑抽象*”。提供者通常发布在 Terraform Registry 上，这是由 HashiCorp
    维护的公共插件库。你可以使用其他注册表，但发布在 Terraform Registry 上的提供者通常已通过测试并且被信任能够正常工作。每个发布在该注册表上的提供者都有详细的文档和良好注释的示例。每当你使用一个新提供者时，应该访问该注册表（[https://registry.terraform.io/](https://registry.terraform.io/)）。一个例子是
    AWS 提供者。这个提供者公开了大量资源，你可以用来与 AWS 服务交互，以配置和部署它们。记住：配置仅限于基础设施。你可以将 Terraform（例如，用来配置虚拟机）与
    Ansible（用于在虚拟机中安装软件并进行配置）结合，体验完整的工作流。
- en: 'Let’s look at an example of an AWS provider from the Terraform Registry AWS
    provider documentation ([https://registry.terraform.io/providers/hashicorp/aws/latest/docs](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个来自 Terraform Registry AWS 提供者文档的示例（[https://registry.terraform.io/providers/hashicorp/aws/latest/docs](https://registry.terraform.io/providers/hashicorp/aws/latest/docs)）：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding snippet, we declare that we require the AWS provider that will
    be downloaded from Terraform Registry. Its version should be no lower than `4.0`.
    Then, we configure the region that we are going to use (`us-east-1`). Finally,
    we create a virtual private network (**virtual private cloud** (**VPC**)) and
    declare an IP block for it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们声明需要从 Terraform Registry 下载 AWS 提供者。它的版本应该不低于 `4.0`。然后，我们配置要使用的区域（`us-east-1`）。最后，我们创建一个虚拟私有网络（**虚拟私有云**（**VPC**））并为其声明一个
    IP 地址块。
- en: The set of `.tf` files in a single directory is called a **module**. If you
    run Terraform commands in the directory where module files lie, it is called a
    **root module**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 单个目录中的 `.tf` 文件集合称为 **模块**。如果你在包含模块文件的目录中运行 Terraform 命令，那么这个目录就被称为 **根模块**。
- en: Terraform modules
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform 模块
- en: One of the key concepts in Terraform is the module. A Terraform module is a
    collection of resources and their dependencies that can be used to build a specific
    component of your infrastructure. Modules provide a way to organize your code
    and make it reusable across multiple projects. They can be shared with other users
    and teams, and even published to a public registry such as Terraform Registry.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 的一个关键概念是模块。Terraform 模块是一个资源集合及其依赖关系，用于构建基础设施的特定组件。模块提供了一种组织代码的方式，并使其能够在多个项目之间复用。模块可以与其他用户和团队共享，甚至发布到像
    Terraform Registry 这样的公共注册表中。
- en: When working with Terraform, it’s important to ensure that you are using compatible
    versions of your infrastructure provider. Providers are responsible for managing
    the resources in your cloud environment, and different versions may have different
    features or behaviors. To avoid unexpected changes to your infrastructure, you
    can pin the version of a provider that you are using in your Terraform configuration.
    This can be done by specifying a version constraint in the provider block, using
    the Terraform version constraint syntax. When you run Terraform, it will download
    and use the specified version of the provider, ensuring that your infrastructure
    remains consistent and predictable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Terraform时，确保使用兼容的基础设施提供者版本非常重要。提供者负责管理您云环境中的资源，不同版本可能具有不同的功能或行为。为了避免基础设施发生意外变化，您可以在Terraform配置中固定您使用的提供者版本。通过在提供者块中指定版本约束，使用Terraform版本约束语法，您可以实现这一点。当您运行Terraform时，它将下载并使用指定版本的提供者，确保您的基础设施保持一致和可预测。
- en: 'Here’s an example `versions.tf` file that pins the AWS provider to the latest
    version and requires at least version 1.0.0 of Terraform:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例`versions.tf`文件，它将AWS提供者固定到最新版本，并要求至少版本1.0.0的Terraform：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we are using the `required_providers` block to specify that
    we require at least version 3.0.0 of the AWS provider. By using the `>=` operator,
    we allow Terraform to use any version of the provider that is equal to or greater
    than 3.0.0, including the latest version.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`required_providers`块来指定我们至少需要版本3.0.0的AWS提供者。通过使用`>=`操作符，我们允许Terraform使用任何版本的提供者，只要它等于或大于3.0.0，包括最新版本。
- en: Terraform will automatically download and use the latest version of the provider
    when we run `terraform init`. This command will also update or download other
    modules you might be using within the main one (or a root module). However, using
    a lot of modules that are using other modules is discouraged as it can cause dependency
    conflicts (for example, some old modules might require AWS provider version 1.23
    when a root module requires version 3.0 or newer). We will get back to the CLI
    later in this chapter in the *Terraform* *CLI* subsection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`terraform init`时，Terraform将自动下载并使用提供者的最新版本。此命令还会更新或下载您可能在主模块（或根模块）中使用的其他模块。然而，使用大量依赖其他模块的模块是不推荐的，因为这可能会导致依赖冲突（例如，一些旧模块可能需要AWS提供者版本1.23，而根模块需要版本3.0或更高）。我们将在本章的*Terraform*
    *CLI*小节中再次回到命令行界面（CLI）。
- en: 'To refer to another module, you can use the `module` code block. Let’s say
    we have a simple module in the `./module/aws_ec2` directory relative to the root
    module. The `aws_ec2` module expects to be fed with the `ami`, `subnet`, `vpc`,
    and `security_group` variables:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用另一个模块，您可以使用`module`代码块。假设我们在根模块相对路径`./module/aws_ec2`目录中有一个简单的模块。`aws_ec2`模块需要传入`ami`、`subnet`、`vpc`和`security_group`变量：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If a module exposes some outputs (variables you can use as input for a resource
    or other module), you can refer to them with `module.NAME.OUTPUT_NAME`. In this
    case, we could expose the ID of the EC2 instance, so you could refer to it with
    the name `module.aws_ec2_instance.instance_id`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块公开了某些输出（您可以将其用作资源或其他模块的输入），您可以通过`module.NAME.OUTPUT_NAME`来引用它们。在这种情况下，我们可以公开EC2实例的ID，您可以通过名称`module.aws_ec2_instance.instance_id`来引用它。
- en: 'There are several other ways to specify the source argument when referring
    to a module in Terraform than using a local path:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用本地路径外，还有几种其他方法可以指定Terraform中引用模块时的源参数：
- en: 'The module can be stored and retrieved from a Git repository:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模块可以存储在Git仓库中并检索：
- en: '[PRE7]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With a Git repository, you’re also able to refer to a commit ID, branch, or
    tag:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Git仓库时，您还可以引用提交ID、分支或标签：
- en: '[PRE10]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For the private repository, you will want to use SSH instead of HTTPS to clone
    it locally:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于私有仓库，您需要使用SSH而不是HTTPS来将其克隆到本地：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The module can be published and retrieved from Terraform Registry:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模块可以发布并从Terraform注册表中检索：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this case, you can specify a module version with the version property, like
    so:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以使用`version`属性指定模块版本，如下所示：
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The module can be stored and retrieved from an S3 bucket:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模块可以存储在S3桶中并检索：
- en: '[PRE23]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can find other possible sources in the official documentation: [https://developer.hashicorp.com/terraform/language/modules/sources](https://developer.hashicorp.com/terraform/language/modules/sources).'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到其他可能的来源：[https://developer.hashicorp.com/terraform/language/modules/sources](https://developer.hashicorp.com/terraform/language/modules/sources)。
- en: Terraform state
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform状态
- en: One of the essential concepts of Terraform is the state file. It is a JSON file
    that describes the current state of your infrastructure. This file is used to
    keep track of the resources that Terraform has created, updated, or deleted, and
    it also stores the configurations for each resource.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform的一个基本概念是状态文件。它是一个JSON文件，描述了你基础设施的当前状态。这个文件用于跟踪Terraform已创建、更新或删除的资源，并且还存储每个资源的配置。
- en: The purpose of the state file is to enable Terraform to manage your infrastructure
    consistently and reliably. By keeping track of the resources that Terraform has
    created or modified, the state file ensures that subsequent runs of Terraform
    will know the current state of your infrastructure and can make changes accordingly.
    Without the state file, Terraform would not know which resources are currently
    deployed and would be unable to make informed decisions about how to proceed with
    subsequent changes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 状态文件的目的是使Terraform能够一致可靠地管理你的基础设施。通过跟踪Terraform已创建或修改的资源，状态文件确保Terraform的后续运行能够了解基础设施的当前状态，并根据需要进行更改。如果没有状态文件，Terraform将无法知道当前部署了哪些资源，并且无法做出关于如何进行后续更改的明智决策。
- en: The state file is also used as a source of truth for Terraform’s `plan` and
    `apply` operations. When you run `terraform plan` or `terraform apply`, Terraform
    will compare the current state of your infrastructure with the desired state,
    as defined in your Terraform code. The state file is used to determine what changes
    need to be made to bring your infrastructure into the desired state. Overall,
    the state file is a crucial component of Terraform’s infrastructure management
    capabilities and enables Terraform to ensure the consistency and reliability of
    your infrastructure.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 状态文件还被用作Terraform的`plan`和`apply`操作的事实来源。当你运行`terraform plan`或`terraform apply`时，Terraform将当前基础设施的状态与Terraform代码中定义的目标状态进行比较。状态文件用于确定需要进行哪些更改，以使你的基础设施达到所需状态。总体而言，状态文件是Terraform基础设施管理功能的关键组成部分，确保Terraform能够保证基础设施的一致性和可靠性。
- en: While the Terraform state file is a critical component of the tool, there are
    some downsides and challenges associated with using it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Terraform状态文件是该工具的关键组成部分，但使用它也存在一些缺点和挑战。
- en: The state file is a centralized file that is used to store information about
    your infrastructure. While this can be convenient, it can also create issues when
    working in a team setting, especially if multiple users are making changes to
    the same infrastructure concurrently. This can lead to conflicts and make it challenging
    to keep the state file up to date. It’s mitigated by the use of the distributed
    locking mechanism. In AWS environments, it’s simply a DynamoDB table with a lock
    entry with a state of `0` or `1`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 状态文件是一个集中式文件，用于存储有关基础设施的信息。虽然这很方便，但在团队协作时也可能会带来问题，特别是当多个用户同时对同一基础设施进行更改时。这可能会导致冲突，使得保持状态文件的最新状态变得具有挑战性。通过使用分布式锁机制可以缓解这一问题。在AWS环境中，它实际上只是一个DynamoDB表，包含一个状态为`0`或`1`的锁条目。
- en: Another downside of Terraform state is that the state file contains sensitive
    information about your infrastructure, such as passwords, keys, and IP addresses.
    Therefore, it’s essential to protect the state file from unauthorized access.
    If the state file is compromised, an attacker could potentially gain access to
    your infrastructure or sensitive data. Inside AWS, the state file is usually kept
    in an S3 bucket, which is necessary with enabled encryption and blocked public
    access.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform状态的另一个缺点是，状态文件包含有关基础设施的敏感信息，如密码、密钥和IP地址。因此，必须保护状态文件以防止未经授权的访问。如果状态文件被泄露，攻击者可能会获得对基础设施或敏感数据的访问权限。在AWS内部，状态文件通常保存在一个S3桶中，并且需要启用加密并阻止公共访问。
- en: The state file can become large and unwieldy over time, especially if you’re
    managing a large infrastructure with many resources. This can make it challenging
    to manage and maintain the state file, which can lead to errors and inconsistencies.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，状态文件可能会变得庞大且难以管理，尤其是在你管理着大量资源的基础设施时。这可能会使管理和维护状态文件变得具有挑战性，进而导致错误和不一致性。
- en: The next challenge we may encounter with state files is that Terraform state
    files are version-specific. This means that you must use the same version of Terraform
    to manage the state file as you did to create it. This can create issues when
    upgrading to a newer version of Terraform as you may need to migrate the state
    file to the new format.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能遇到的下一个关于状态文件的挑战是，Terraform 状态文件是版本特定的。这意味着你必须使用与创建状态文件时相同版本的 Terraform 来管理该文件。这可能会在升级到新版
    Terraform 时带来问题，因为你可能需要将状态文件迁移到新的格式。
- en: Finally, Terraform’s state file has some limitations, such as the inability
    to manage external resources or the difficulty of handling complex dependencies
    between resources. This can create challenges when working with certain types
    of infrastructure or when dealing with complex deployments.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Terraform 的状态文件有一些局限性，例如无法管理外部资源或处理资源之间复杂依赖关系的困难。这在处理某些类型的基础设施或应对复杂部署时可能会带来挑战。
- en: Another feature that comes with the state file is enforcing the configuration
    of the resources Terraform manages. If someone makes a manual change, you will
    see it on the next `terraform plan` or `terraform apply` and those changes will
    be rolled back.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 状态文件的另一个功能是强制执行 Terraform 管理的资源的配置。如果有人手动进行了更改，你将在下次执行 `terraform plan` 或 `terraform
    apply` 时看到这些更改，并且这些更改将被回滚。
- en: With all that in mind, Terraform is still one of the best solutions out there
    and most of these challenges can easily be mitigated when planning our infrastructure.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，Terraform 仍然是最好的解决方案之一，而且大多数这些挑战在规划基础设施时都可以轻松解决。
- en: 'Here’s an example `backend.tf` file that configures Terraform to use an S3
    bucket named `state-files` for storing the state file and a DynamoDB table named
    `terraform` for state locking:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例 `backend.tf` 文件，配置 Terraform 使用名为 `state-files` 的 S3 存储桶来存储状态文件，并使用名为
    `terraform` 的 DynamoDB 表进行状态锁定：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this configuration, the backend block specifies that we want to use the `s3`
    backend type, which is designed to store the state file in an S3 bucket. The `bucket`
    parameter specifies the name of the bucket where the state file should be stored,
    and the `key` parameter specifies the name of the state file within the bucket.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，后端块指定了我们希望使用 `s3` 后端类型，该类型旨在将状态文件存储在 S3 存储桶中。`bucket` 参数指定了状态文件应存储的存储桶名称，而
    `key` 参数指定了存储桶中状态文件的名称。
- en: The `region` parameter specifies the AWS region where the bucket is located.
    You should set this to the region that makes the most sense for your use case.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`region` 参数指定了存储桶所在的 AWS 区域。你应该将其设置为最符合你使用场景的区域。'
- en: Finally, the `dynamodb_table` parameter specifies the name of the DynamoDB table
    that will be used for state locking. This is an important feature of the S3 backend
    as it ensures that only one user at a time can make changes to the infrastructure.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`dynamodb_table` 参数指定了将用于状态锁定的 DynamoDB 表的名称。这是 S3 后端的一个重要特性，因为它确保一次只有一个用户可以对基础设施进行更改。
- en: 'Here’s an example of the Terraform state file:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Terraform 状态文件的一个示例：
- en: '[PRE27]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: By using the S3 backend with DynamoDB state locking, you can ensure that your
    Terraform deployments are safe and consistent, even in a team environment where
    multiple users may be making changes to the same infrastructure concurrently.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 S3 后端和 DynamoDB 状态锁定，你可以确保 Terraform 部署在团队环境中是安全且一致的，即使多个用户可能同时对相同基础设施进行更改。
- en: In the next subsection, we will discuss how to use the Terraform CLI and interact
    with our infrastructure and state files.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个小节中，我们将讨论如何使用 Terraform CLI 与我们的基础设施和状态文件进行交互。
- en: Terraform CLI
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform CLI
- en: The core of Terraform is its command-line tool called, aptly, `terraform`. We
    linked the guide for installation when introducing Terraform to you. While there
    are tools to automate the workflow that remove the necessity of using the CLI,
    the use of the tool is simple and there is a lot of useful knowledge to be gained
    from working with it. In this section, we are going to introduce the most common
    options and workflows for the `terraform` command.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 的核心是其命令行工具，恰如其分地被称为 `terraform`。我们在介绍 Terraform 时已链接了安装指南。虽然也有工具可以自动化工作流程，省去了使用
    CLI 的必要，但该工具的使用非常简单，并且从与它一起工作中可以获得许多有用的知识。在这一节中，我们将介绍 `terraform` 命令的最常见选项和工作流程。
- en: Initializing the work environment
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化工作环境
- en: The very first subcommand of `terraform` you will use is `terraform init`. After
    you write your first portion of the `main.tf` file (if you follow the proposed
    module structure), you will run `terraform init` to download the required plugins
    and create some important directories and helper files.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用的第一个 `terraform` 子命令是 `terraform init`。在编写完 `main.tf` 文件的第一部分（如果您遵循建议的模块结构）后，您将运行
    `terraform init` 来下载所需的插件并创建一些重要的目录和帮助文件。
- en: 'Let’s consider a portion of the first piece of code we used previously:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下之前使用的第一段代码的一部分：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code informs Terraform about the required plugin to be downloaded and
    its minimum version. Now, let’s run the `terraform` `init` command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉 Terraform 需要下载的插件及其最低版本。现在，让我们运行 `terraform` `init` 命令：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have shortened the output for brevity, but the most important part is there.
    You will see Terraform telling you what actions have been performed. The backend
    is the storage area for keeping the `.tfstate` file. If you don’t specify a storage
    area, the `.tfstate` file will be saved into `terraform.tfstate` in the local
    directory. There’s also a new subdirectory called `.terraform` where required
    plugins were installed. Finally, a `.terraform.lock.hcl` file exists, where Terraform
    records the versions of the providers that have been used so that you can keep
    them for compatibility reasons.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已简化了输出以提高简洁性，但最重要的部分仍然存在。您将看到 Terraform 告诉您已执行了哪些操作。后端是用于存储 `.tfstate` 文件的存储区域。如果您没有指定存储区域，`.tfstate`
    文件将保存在本地目录中的 `terraform.tfstate` 文件中。还有一个新的子目录 `.terraform`，其中安装了所需的插件。最后，存在一个
    `.terraform.lock.hcl` 文件，Terraform 会记录已使用的提供程序版本，以便您可以出于兼容性原因保留这些版本。
- en: The `terraform init` command is a safe command. You can run it as many times
    as you wish; it won’t break anything.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform init` 命令是一个安全命令。您可以根据需要多次运行它；它不会破坏任何内容。'
- en: Planning changes
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规划更改
- en: 'The next command to run would be `terraform fmt`. This command formats your
    `.tf` files according to the best practices in place. Using it increases the readability
    and maintainability of your code, making all source files adhere to the same formatting
    strategy in all Terraform projects you will see. Running `terraform fmt` on our
    example will yield the following output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要运行的命令是 `terraform fmt`。此命令将根据现有的最佳实践格式化您的 `.tf` 文件。使用它可以提高代码的可读性和可维护性，使所有源文件在您将看到的所有
    Terraform 项目中遵循相同的格式化策略。在我们的示例上运行 `terraform fmt` 将产生以下输出：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You will notice that `fmt` caught a glaring error in my `main.tf` file. It
    is not only a readability issue; it may also introduce errors in code interpretation
    with some providers. I have put two attributes on one line. Editing it so that
    it looks like this fixes the issue:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到 `fmt` 在我的 `main.tf` 文件中发现了一个明显的错误。这不仅是一个可读性问题；它还可能在某些提供程序中引入代码解析错误。我将两个属性写在了同一行。将其编辑成如下所示就可以解决问题：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this change, `fmt` is satisfied and we can proceed to the next step.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个更改，`fmt` 满意了，我们可以继续进行下一步。
- en: 'The plan of action is built by using the `terraform plan` command. It takes
    the last known recorded state of your infrastructure (`terraform.tfstate`), compares
    it to the code in the directory, and prepares steps to make them match. Running
    `terraform plan` with our preceding example code yields the following output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `terraform plan` 命令来构建操作计划。它将您基础设施的最后已知记录状态（`terraform.tfstate`）与目录中的代码进行比较，并准备出步骤以使其匹配。在我们之前的示例代码上运行
    `terraform plan` 会产生以下输出：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since we have not introduced any code that would create any resource, Terraform
    informed us that no changes are planned.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有引入任何可以创建资源的代码，Terraform 告知我们没有计划进行任何更改。
- en: This, however, is not very interesting. Therefore, we are going to show you
    something that will create some resources in AWS.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不太有趣。因此，我们将展示一些将在 AWS 中创建资源的内容。
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before you follow this example, please consult your liability for the Free Tier
    services in AWS. Running these examples can incur a cost and neither the authors
    of this guide nor the publisher can claim any responsibility for them if they
    do occur.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在遵循此示例之前，请先了解您在 AWS 免费套餐服务中的责任。运行这些示例可能会产生费用，如果发生费用，本文的作者和出版商不对其承担任何责任。
- en: If you want to follow these examples, you will need to have an AWS account (which
    is free at the time of writing this book). Then, you will need to create a role
    and generate `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`. Doing so is outside
    the scope of this chapter.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟随这些示例，你需要拥有一个 AWS 账户（在写本书时是免费的）。然后，你需要创建一个角色并生成 `AWS_ACCESS_KEY_ID` 和 `AWS_SECRET_ACCESS_KEY`。这样做超出了本章的范围。
- en: 'We have edited the preceding example slightly. The `required_providers` block
    has been moved to `providers.tf`. We have also added another provider block there.
    The file looks like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍微修改了前面的示例。`required_providers` 块已被移动到 `providers.tf` 文件中。我们还在其中添加了另一个提供程序块。文件如下所示：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that the new block is configuring a new provider resource called `aws`.
    The name (`aws`) is actually up to us and could be anything. Remember to give
    meaningful names, ones that will help you understand the code later on. We have
    provided a bare minimum of configuration for this provider, which is specifying
    a region where our resource will be started.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，新的块正在配置一个名为 `aws` 的新提供程序资源。名称（`aws`）实际上由我们决定，可以是任何名称。记得给它们起有意义的名字，能帮助你以后理解代码。我们为这个提供程序提供了最低限度的配置，指定了我们的资源将启动的区域。
- en: 'We do the actual work in the newly created empty `main.tf` file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在新创建的空 `main.tf` 文件中进行实际操作：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we inform Terraform that we want to create a new resource of the `aws_instance`
    type. We are calling it `vm_example`. Next, we tell the tool to use a VM image
    (AMI) called `ami-830c94e3`. The instance’s type (how much RAM it is going to
    have, how many CPU cores, how big the system drive is, and more) is `t2.micro`.
    Finally, we add a tag that can help us identify and search for this instance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉 Terraform 我们想要创建一个新的 `aws_instance` 类型的资源。我们将其命名为 `vm_example`。接下来，我们告诉工具使用名为
    `ami-830c94e3` 的虚拟机镜像（AMI）。该实例的类型（它将拥有多少 RAM、多少 CPU 核心、系统驱动器的大小等等）是 `t2.micro`。最后，我们添加了一个标签，帮助我们识别和查找这个实例。
- en: 'Let’s call `terraform plan` and apply it:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调用 `terraform plan` 并应用它：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You didn’t use the `-out` option to save this plan, so Terraform can’t guarantee
    to take exactly these actions if you run `terraform` `apply` now.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有使用 `-out` 选项来保存这个计划，因此 Terraform 无法保证如果你现在运行 `terraform apply`，它会准确执行这些操作。
- en: We’ve cut out a lot of the output from the plan. However, you can see that it
    differs from the previous example. Terraform noticed that we don’t have a VM with
    the specified parameters (remember, it compares to the `.tfstate` file). So, it
    is going to create one. We can always see the summary on the line starting with
    `Plan`. In the plan, all attributes starting with `+` (plus sign) will be created.
    Everything starting with `-` (minus sign) will be destroyed and everything with
    `~` (tilde) in front of it will be modified.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经省略了计划中的大量输出。然而，你可以看到它与之前的示例有所不同。Terraform 注意到我们没有具有指定参数的虚拟机（记住，它是与 `.tfstate`
    文件进行比较的）。因此，它将创建一个。我们始终可以在以 `Plan` 开头的行中看到摘要。在计划中，所有以 `+`（加号）开头的属性将被创建。所有以 `-`（减号）开头的属性将被销毁，而所有以
    `~`（波浪号）开头的属性将被修改。
- en: Be cautious with Terraform when changing attributes of already created resources.
    More often than not, it will treat it as something new, especially if you change
    names. This will result in destroying the VM with the old name and creating a
    new one with a new name. This is probably not what you want.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在更改已创建资源的属性时要小心使用 Terraform。通常情况下，它会将其视为新资源，特别是当你更改名称时。这将导致销毁旧名称的虚拟机，并创建一个新名称的虚拟机。这可能不是你想要的结果。
- en: Applying changes
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用更改
- en: 'The plan is being implemented by calling `terraform apply`. This command will
    introduce changes to your environment if your `.tf` files differ from your `.tfstate`
    file. Also, if your actual running infrastructure differs from your `.tfstate`
    file, `terraform apply` will do its best to re-align the live infrastructure with
    the Terraform state file:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 计划通过调用 `terraform apply` 来实施。如果你的 `.tf` 文件与 `.tfstate` 文件不同，这个命令将会对你的环境进行更改。此外，如果你的实际运行基础设施与
    `.tfstate` 文件不同，`terraform apply` 将尽最大努力使实时基础设施与 Terraform 状态文件重新对齐：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Again, a lot of the output has been cut out for brevity.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，出于简洁性，很多输出被省略了。
- en: The `terraform apply` command created a plan again. We can avoid this by recording
    `terraform plan` into a file and later feeding the file to the `apply` step.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform apply` 命令再次创建了一个计划。我们可以通过将 `terraform plan` 记录到文件中，然后将文件输入到 `apply`
    步骤中来避免这种情况。'
- en: The interesting part is the confirmation step, where Terraform asks you to type
    in `yes` before it proceeds. Then, it is going to print out a summary of performed
    actions every 10 seconds. After you’ve spent some time working with Terraform,
    you will usually guess whether the action was successful by the time it takes
    it to finish.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的部分是确认步骤，在这个步骤中，Terraform 会要求你输入`yes`才能继续。然后，它将每 10 秒钟打印一次已执行操作的摘要。经过一段时间与
    Terraform 的工作，你通常可以根据操作完成所花费的时间来猜测该操作是否成功。
- en: 'In the AWS console, in the **Instances** menu, we can observe that the VM has
    been created:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 控制台的**实例**菜单中，我们可以看到虚拟机已经创建完成：
- en: '![Figure 12.1 – New VM instances created via Terraform](img/B18197_12_01.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 通过 Terraform 创建的新虚拟机实例](img/B18197_12_01.jpg)'
- en: Figure 12.1 – New VM instances created via Terraform
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 通过 Terraform 创建的新虚拟机实例
- en: We can delete all the infrastructure we have just created by running `terraform
    destroy`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行`terraform destroy`来删除我们刚刚创建的所有基础设施。
- en: An interesting thing to note is that at no point in our workflow have we told
    Terraform what files it should interpret. This is because, as mentioned previously,
    it will read all `.tf` files in the current directory and create a proper plan
    of execution.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的一点是，在我们的工作流程中，我们没有告诉 Terraform 它应该解释哪些文件。这是因为，正如之前提到的，Terraform 会读取当前目录下的所有`.tf`文件，并创建一个正确的执行计划。
- en: 'If you are interested in seeing the hierarchy of steps, Terraform provides
    the `terraform graph` command, which will print it out for you:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣查看步骤的层次结构，Terraform 提供了`terraform graph`命令，它会为你打印出该层次结构：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There are tools out there that can create a nice visual representation of the
    graph produced by Terraform.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些工具可以创建 Terraform 生成的图形的良好可视化表示。
- en: Modifying Terraform state
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改 Terraform 状态
- en: Occasionally, there’s a need to modify the resources in the state file. In the
    older versions of Terraform, this had to be done manually and was error-prone.
    Thankfully, Terraform developers added some CLI commands that could help us with
    that.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，需要修改状态文件中的资源。在 Terraform 的旧版本中，这必须手动完成，并且容易出错。幸运的是，Terraform 开发者添加了一些命令行工具，可以帮助我们完成这项工作。
- en: 'The most useful commands are as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的命令如下：
- en: '`Terraform state rm`: This command removes the resource from the state. This
    is useful when we’ve removed the resource manually and from the Terraform code
    but it persists in the state.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Terraform state rm`：该命令从状态中移除资源。当我们手动删除了资源并从 Terraform 代码中移除它，但它仍然存在于状态中时，这个命令非常有用。'
- en: '`terraform state mv`: This command changes the name of the resource. This is
    useful when we change the resource name to prevent the removal and creation of
    a new resource, which often isn’t the desired behavior'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform state mv`：该命令用于更改资源的名称。这在我们更改资源名称时很有用，以防止删除并创建一个新的资源，这通常不是我们想要的行为。'
- en: '`terraform taint`: This command forces the resource to be recreated.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terraform taint`：该命令强制重新创建资源。'
- en: Importing existing resources
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入现有资源
- en: Importing existing resources into Terraform allows you to include those resources
    in your Terraform state, which is a snapshot of the resources managed by Terraform.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将现有资源导入到 Terraform 中，可以将这些资源纳入到 Terraform 状态中，Terraform 状态是一个由 Terraform 管理的资源快照。
- en: The `terraform import` command is used to add an existing resource to your Terraform
    state. This command maps the existing resource to a configuration block in your
    Terraform code, which allows you to manage the resource using Terraform.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform import`命令用于将现有资源添加到你的 Terraform 状态中。该命令将现有资源映射到 Terraform 代码中的配置块，从而允许你使用
    Terraform 管理该资源。'
- en: 'The syntax for the `terraform import` command is as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform import`命令的语法如下：'
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The two important arguments for the `terraform import` command are as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`terraform import`命令的两个重要参数如下：'
- en: '`resource_in_code`: The address of the resource in your Terraform code'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource_in_code`：在 Terraform 代码中资源的地址。'
- en: '`resource_identifier`: The unique identifier of the resource you want to import'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resource_identifier`：你想导入的资源的唯一标识符。'
- en: 'For example, let’s say you have an existing AWS S3 bucket with an `arn:aws:s3:::devopsy-bucket`.
    To import this resource into your Terraform state, you can run the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设你有一个现有的 AWS S3 存储桶，ARN 为`arn:aws:s3:::devopsy-bucket`。要将这个资源导入到 Terraform
    状态中，可以运行以下命令：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Importing resources is useful when you have pre-existing infrastructure that
    you want to manage using Terraform. This is often the case when you are starting
    to use Terraform on an existing project or when you have resources that were created
    outside of Terraform. Importing resources allows you to bring those resources
    under Terraform management, so you can use Terraform to make changes to them in
    the future.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 导入资源对于你有现有基础设施并希望使用 Terraform 进行管理时非常有用。当你开始在现有项目中使用 Terraform 或者有一些在 Terraform
    之外创建的资源时，通常会遇到这种情况。导入资源可以让你将这些资源纳入 Terraform 管理中，从而将来可以使用 Terraform 对其进行修改。
- en: Not all resources can be imported into Terraform. The resource you intend to
    import must have a unique identifier that Terraform can use to locate it in the
    remote service. Additionally, the resource must be supported by the provider you
    are using in Terraform.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有资源都可以导入到 Terraform 中。你打算导入的资源必须有一个唯一标识符，Terraform 可以利用它在远程服务中找到该资源。此外，资源还必须得到你在
    Terraform 中使用的提供程序的支持。
- en: Workspaces
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作区
- en: Terraform has a notion of a workspace. A **workspace** is similar to the version
    of the state. Workspaces allow you to store different states for the same code.
    To be able to use workspaces, you have to store your state file in a backend that
    supports them. The list of backends that support workspaces is quite long and
    covers the most popular cloud providers.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 有一个工作区的概念。**工作区**类似于状态的版本。工作区允许你为相同的代码存储不同的状态。为了能够使用工作区，必须将状态文件存储在支持工作区的后端中。支持工作区的后端列表非常长，涵盖了大多数流行的云服务提供商。
- en: These workspaces are available in `.tf` files via the `${terraform.workspace}`
    sequence. Along with conditional expressions, this allows you to create varying
    environments. For example, you can use different IP addresses, depending on the
    workspace, allowing you to specify testing and production environments.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工作区可以通过 `.tf` 文件中的 `${terraform.workspace}` 序列来访问。结合条件表达式，这使得你能够创建不同的环境。例如，您可以根据工作区使用不同的
    IP 地址，从而区分测试环境和生产环境。
- en: 'There is always one workspace present: `default`. It can’t be removed. Workspace
    manipulation can be done using the `terraform` `workspace` command.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 总是存在一个工作区：`default`。它无法被删除。工作区操作可以通过 `terraform` `workspace` 命令来完成。
- en: 'We can easily inspect what workspaces we have and which one is active using
    the `terraform` `list` command:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `terraform` `list` 命令轻松查看当前有哪些工作区以及哪个是活动工作区：
- en: '[PRE40]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The one with an asterisk in front of it is the current one. If we’re only interested
    in seeing the current workspace and not the whole list, we can run the `terraform`
    `show` command:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 前面带星号的是当前工作区。如果我们只关心查看当前工作区而不是整个列表，可以运行 `terraform` `show` 命令：
- en: '[PRE41]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Each workspace will have a state file. Let’s experiment: we will create a new
    workspace called `testing` and apply Terraform to the testing workspace.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作区都会有一个状态文件。让我们做个实验：我们将创建一个名为 `testing` 的新工作区，并对测试工作区应用 Terraform。
- en: 'First, we must call `terraform workspace new` to create the workspace:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须调用 `terraform workspace new` 来创建工作区：
- en: '[PRE42]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we must confirm that we are actually in the new workspace and run `terraform
    apply` in it using our previous example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须确认自己确实处于新的工作区中，并使用我们之前的示例在其中运行 `terraform apply`：
- en: '[PRE43]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'As you can see, we successfully created the VM. However, when we change the
    workspace back to the default one, suddenly, Terraform will want to create it
    again:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们成功创建了虚拟机。然而，当我们将工作区切换回默认工作区时，Terraform 又会要求重新创建它：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Even though the creation of the resource was successful, Terraform will want
    to create it anew. When we inspect the directory where our `.tf` files live, we
    will spot the `.tfstate` file that is connected to the default workspace and a
    new directory called `terraform.tfstate.d/` where `.tfstate` files are stored,
    each in its own subdirectory named aptly after the workspace. So, for the testing
    workspace, the state file will be stored in `terraform.tfstate.d/testing`:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 即使资源的创建已经成功，Terraform 仍然会希望重新创建它。当我们检查存放 `.tf` 文件的目录时，我们会发现与默认工作区关联的 `.tfstate`
    文件，以及一个名为 `terraform.tfstate.d/` 的新目录，里面存放着 `.tfstate` 文件，每个文件都会存放在一个以工作区名称命名的子目录中。因此，对于测试工作区，状态文件将存储在
    `terraform.tfstate.d/testing` 中：
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'How can we use this to our advantage in Terraform code? As we have mentioned,
    there’s a special sequence (let’s call it a variable) that will be expanded to
    the name of the current workspace in our code:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在 Terraform 代码中利用这一点呢？正如我们提到的，有一个特殊的序列（我们称之为变量），它会扩展为当前工作区的名称：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this small change (if `terraform.workspace` is the default, then the instance
    will be `t2.micro`; otherwise, it will be `t2.nano`) we have introduced a conditional
    change related to the workspace we start the VM in.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个小的修改（如果 `terraform.workspace` 是默认值，则实例将是 `t2.micro`；否则，它将是 `t2.nano`），我们引入了与启动虚拟机的工作空间相关的条件变化。
- en: 'Let’s quickly confirm this with `terraform plan`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `terraform plan` 快速确认一下：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As shown in the preceding output, depending on the workspace we select, different
    types of an instance will be created.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，取决于我们选择的工作空间，将创建不同类型的实例。
- en: In this section, we dived deep into the Terraform IaC tool. We explained what
    providers and modules are, as well as the role of the state file. We also demonstrated
    simple Terraform configuration and its interaction with the AWS cloud.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们深入探讨了 Terraform IaC 工具。我们解释了提供者和模块的概念，以及状态文件的作用。我们还演示了简单的 Terraform 配置及其与
    AWS 云的互动。
- en: In the next section, we are going to cover the HashiCorp Configuration Language
    (HCL) in more detail, which was created specifically to write those configurations.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地介绍 HashiCorp 配置语言（HCL），它是专门用于编写这些配置的。
- en: HCL in depth
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HCL 深入解析
- en: HCL is a configuration language that’s used by several HashiCorp tools, including
    Terraform, to define and manage IaC.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: HCL 是一种配置语言，由多个 HashiCorp 工具使用，包括 Terraform，用于定义和管理基础设施即代码（IaC）。
- en: HCL is designed to be easy to read and write for both humans and machines. It
    uses a simple syntax that is similar to JSON but with a more relaxed structure
    and support for comments. HCL files typically have an `.hcl` or `.tf` file extension.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: HCL 旨在让人类和机器都能轻松阅读和编写。它使用的语法简单，类似于 JSON，但结构更为宽松，并且支持注释。HCL 文件通常具有 `.hcl` 或 `.tf`
    文件扩展名。
- en: HCL uses curly braces to define blocks of code, and each block has a label that
    identifies its type. Within each block, we define attributes using a `key-value`
    syntax, where the key is the attribute name and the value is the attribute value.
    We can also define objects using curly braces, as shown in the example with the
    `tags` object.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: HCL 使用花括号来定义代码块，每个代码块都有一个标签，用于标识其类型。在每个代码块内，我们使用 `key-value` 语法定义属性，其中键是属性名，值是属性值。我们还可以使用花括号定义对象，如示例中所示的
    `tags` 对象。
- en: Variables
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'In HCL, variables are defined using the `variable` block. Here’s an example
    of how to define a variable in HCL:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HCL 中，变量使用 `variable` 块来定义。以下是如何在 HCL 中定义变量的示例：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this example, we define a variable named `region` of the `string` type and
    a default value of `us-west-2`. We can reference this variable later in our code
    using the `${``var.region}` syntax.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们定义了一个名为 `region` 的变量，类型为 `string`，并指定了默认值 `us-west-2`。我们可以在代码中使用 `${var.region}`
    语法引用该变量。
- en: HCL supports several data types for variables, including `string`, `number`,
    `boolean`, `list`, `map`, and `object`. We can also specify a description for
    the variable using the `description` argument in the `variable` block.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: HCL 支持多种数据类型的变量，包括 `string`、`number`、`boolean`、`list`、`map` 和 `object`。我们还可以使用
    `variable` 块中的 `description` 参数为变量指定描述。
- en: Variables can be assigned values in a variety of ways, including through default
    values, command-line arguments, or environment variables. When using Terraform,
    we can also define variables in a separate file and pass them in during execution
    using a `.tfvars` file extension (for example, `variables.tfvars`) or through
    command-line arguments.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以通过多种方式赋值，包括默认值、命令行参数或环境变量。在使用 Terraform 时，我们还可以在单独的文件中定义变量，并通过 `.tfvars`
    文件扩展名（例如 `variables.tfvars`）或命令行参数在执行过程中传入。
- en: Once variables have been defined, they can’t be changed, but HCL also allows
    local variables that can be defined within the `locals` block. Local variables
    are useful for simplifying complex expressions or calculations within a module
    or resource block as they allow us to break down the logic into smaller, more
    manageable pieces. They can also make it easier to maintain our code as we can
    define local variables for values that may change frequently or need to be updated
    across multiple resources or modules.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了变量，它们就不能更改，但 HCL 还允许在 `locals` 块内定义局部变量。局部变量对于简化模块或资源块中的复杂表达式或计算非常有用，因为它们可以将逻辑分解为更小、更易管理的部分。它们还可以使我们更容易维护代码，因为我们可以为那些可能频繁变化或需要跨多个资源或模块更新的值定义局部变量。
- en: 'Here’s an example `locals` block that defines the `eu-central-1` region and
    generates subnets in every AZ:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个`locals`块示例，它定义了`eu-central-1`区域并在每个AZ中生成子网：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In this example, we define a `locals` block that includes the following variables:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们定义了一个`locals`块，其中包括以下变量：
- en: '`azs`: A list of the availability zones in the `eu-central-1` region'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`azs`：`eu-central-1`区域中的可用区列表'
- en: '`cidr_block`: The CIDR block for the VPC'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cidr_block`：VPC的CIDR块'
- en: '`subnet_bits`: The number of bits to allocate for subnets within the CIDR block'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subnet_bits`：在CIDR块内为子网分配的位数'
- en: '`subnets`: A map that generates subnets for each availability zone in the `azs`
    list using a `for` expression'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subnets`：一个映射，使用`for`表达式为`azs`列表中的每个可用区生成子网'
- en: The `for` expression in the `subnets` map generates a subnet for each availability
    zone in the `azs` list. The subnet’s name includes the environment variable (which
    can be passed in as a variable) and the index of the availability zone in the
    list. The `cidrsubnet` function is used to calculate the CIDR block for each subnet
    based on the `cidr_block` variable and the `subnet_bits` variable.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`subnets`映射中的`for`表达式会为`azs`列表中的每个可用区生成一个子网。子网的名称包括环境变量（可以作为变量传递）和可用区在列表中的索引。`cidrsubnet`函数用于根据`cidr_block`变量和`subnet_bits`变量计算每个子网的CIDR块。'
- en: The resulting `subnets` map will contain a key-value pair for each availability
    zone in the `azs` list, where the key is the availability zone name and the value
    is a map that includes the subnet name, CIDR block, and availability zone.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的`subnets`映射将包含`azs`列表中每个可用区的键值对，其中键是可用区名称，值是一个映射，包含子网名称、CIDR块和可用区。
- en: Comments
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: 'Comments in HCL can be written in two ways: single-line and multi-line comments.
    Single-line comments begin with the `#` symbol and continue until the end of the
    line. Multi-line comments, on the other hand, start with `/*` and end with `*/`.
    Multi-line comments can span multiple lines and are often used to provide longer
    explanations or temporarily disable sections of code.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: HCL中的注释可以通过两种方式编写：单行注释和多行注释。单行注释以`#`符号开头，直到行末。多行注释则以`/*`开头，以`*/`结尾。多行注释可以跨越多行，通常用于提供更长的解释或暂时禁用代码段。
- en: 'The following is an example of a single-line comment:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个单行注释的示例：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following is an example of a multi-line comment:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个多行注释的示例：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Terraform meta-arguments
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform元参数
- en: In Terraform, **meta-arguments** are special arguments that can be used to modify
    the behavior of resource blocks. They are called meta-arguments because they apply
    to the resource block as a whole, rather than to specific attributes within the
    block.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在Terraform中，**元参数**是可以用来修改资源块行为的特殊参数。之所以称其为元参数，是因为它们作用于整个资源块，而不是资源块中的特定属性。
- en: Meta-arguments are used to configure things such as the number of instances
    of a resource to create (`count`), the names of resources (`name`), the dependencies
    between resources (`depends_on`), and more.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 元参数用于配置诸如资源实例数量（`count`）、资源名称（`name`）、资源之间的依赖关系（`depends_on`）等内容。
- en: count
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: count
- en: '`count` allows you to create multiple instances of a resource based on a numeric
    value. This can be useful for creating multiple instances of a resource, such
    as EC2 instances in AWS, without having to repeat the entire block of code.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`允许你基于数字值创建多个资源实例。这在不重复整个代码块的情况下创建多个资源实例（例如AWS中的EC2实例）时非常有用。'
- en: 'For example, let’s say you want to create three EC2 instances in your AWS account.
    Instead of creating three separate `aws_ec2_instance` resource blocks, you can
    use the `count` meta-argument to create multiple instances of the same block.
    Here’s an example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想在AWS账户中创建三个EC2实例。你可以使用`count`元参数来创建多个相同的`aws_ec2_instance`资源块，而不是创建三个单独的资源块。以下是一个示例：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this example, we’re creating three EC2 instances using the same `ami` and
    `instance_type`. The `count` meta-argument is set to `3`, which means that Terraform
    will create 3 instances of the `aws_ec2_instance` resource block. Each instance
    will be given a unique identifier, such as `aws_ec2_instance.example[0]`, `aws_ec2_instance.example[1]`,
    and `aws_ec2_instance.example[2]`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用相同的`ami`和`instance_type`创建三个EC2实例。`count`元参数设置为`3`，意味着Terraform将创建三个`aws_ec2_instance`资源块的实例。每个实例将被赋予唯一的标识符，例如`aws_ec2_instance.example[0]`、`aws_ec2_instance.example[1]`和`aws_ec2_instance.example[2]`。
- en: for_each
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for_each
- en: The `for_each` meta-argument is similar to the `count` meta-argument in that
    it allows you to create multiple instances of a resource. However, `for_each`
    is more flexible than `count` because it allows you to create instances based
    on a map or set of values, rather than just a numeric value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`for_each`元参数类似于`count`元参数，它允许你创建多个资源实例。然而，`for_each`比`count`更灵活，因为它允许你根据一个映射或值集合来创建实例，而不仅仅是基于一个数值。'
- en: 'For example, let’s say you have a map of AWS security groups that you want
    to create in your Terraform code. Instead of creating multiple `aws_security_group`
    resource blocks, you can use `for_each` to create them all in a single block.
    Here’s an example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个AWS安全组的映射，并希望在Terraform代码中创建它们。你可以使用`for_each`在一个块中创建所有安全组，而不是创建多个`aws_security_group`资源块。下面是一个示例：
- en: '[PRE53]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this example, we’re using the `for_each` meta-argument to create multiple
    instances of the `aws_security_group` resource block based on the `security_groups`
    variable, which is a map of objects. Each instance will have a unique identifier
    based on the key of the map. We’re also using the `name_prefix` attribute to set
    the name of each security group, and the `description` attribute to set the description.
    Finally, we’re using the `ingress` block to define the inbound traffic rules for
    each security group.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用`for_each`元参数根据`security_groups`变量（这是一个对象的映射）创建多个`aws_security_group`资源块的实例。每个实例将根据映射的键生成一个唯一的标识符。我们还使用`name_prefix`属性来设置每个安全组的名称，使用`description`属性来设置描述。最后，我们使用`ingress`块定义每个安全组的入站流量规则。
- en: Using `for_each` can simplify your Terraform code and make it more reusable,
    especially when you’re dealing with maps or sets of values. However, it’s important
    to be aware of any potential dependencies between instances and to make sure that
    your code is properly structured to handle multiple instances.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`for_each`可以简化你的Terraform代码，并使其更具可重用性，特别是在处理映射或集合值时。然而，需要注意实例之间可能存在的依赖关系，并确保代码结构能够正确处理多个实例。
- en: lifecycle
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: lifecycle
- en: The `lifecycle` meta-argument is used to define custom behavior for creating,
    updating, and deleting resources. It allows you to control the life cycle of a
    resource and its dependencies in a more fine-grained manner than the default behavior.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`lifecycle`元参数用于定义创建、更新和删除资源的自定义行为。它允许你比默认行为更精细地控制资源及其依赖关系的生命周期。'
- en: 'The `lifecycle` meta-argument can be used to define the following attributes:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`lifecycle`元参数可用于定义以下属性：'
- en: '`create_before_destroy`: If set to `true`, Terraform will create the new resource
    before destroying the old one, which can prevent downtime in some cases.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_before_destroy`：如果设置为`true`，Terraform将在销毁旧资源之前创建新资源，这在某些情况下可以防止停机。'
- en: '`prevent_destroy`: If set to `true`, Terraform will prevent the resource from
    being destroyed. This can be useful for protecting critical resources from accidental
    deletion.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prevent_destroy`：如果设置为`true`，Terraform将防止资源被销毁。这对于保护关键资源免受意外删除非常有用。'
- en: '`ignore_changes`: A list of attribute names that Terraform should ignore when
    determining whether a resource needs to be updated.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_changes`：Terraform在判断是否需要更新资源时，应该忽略的一些属性名称列表。'
- en: '`replace_triggered_by`: A list of dependencies that will cause the resource
    to be recreated.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace_triggered_by`：一个依赖项列表，当这些依赖项发生变化时，资源将被重新创建。'
- en: 'Here’s an example of using the `lifecycle` meta-argument to prevent the destruction
    of an S3 bucket:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用`lifecycle`元参数来防止销毁S3存储桶的示例：
- en: '[PRE54]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this example, the `lifecycle` block is used to set the `prevent_destroy`
    attribute to `true`, which means that Terraform will prevent the `aws_s3_bucket`
    resource from being destroyed. This can be useful for protecting critical resources
    from being accidentally deleted.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`lifecycle`块用于将`prevent_destroy`属性设置为`true`，这意味着Terraform将防止`aws_s3_bucket`资源被销毁。这对于保护关键资源免于被意外删除非常有用。
- en: depends_on
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: depends_on
- en: The `depends_on` meta-argument is used to define dependencies between resources.
    It allows you to specify that one resource depends on another resource, which
    means that Terraform will create the dependent resource after the resource it
    depends on has been created.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`depends_on`元参数用于定义资源之间的依赖关系。它允许你指定一个资源依赖于另一个资源，这意味着Terraform将在依赖的资源创建之后创建依赖资源。'
- en: However, it’s important to note that in most cases, Terraform can create a dependency
    tree automatically by analyzing your resource configurations. This means that
    using `depends_on` should be avoided unless absolutely necessary as it can lead
    to dependency cycles that can cause errors and make your Terraform code harder
    to manage.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意，在大多数情况下，Terraform 可以通过分析你的资源配置自动创建依赖树。这意味着除非绝对必要，否则应避免使用 `depends_on`，因为它可能导致依赖循环，从而引发错误并使你的
    Terraform 代码更难以管理。
- en: If you do need to use `depends_on`, it’s important to be aware of the potential
    for dependency cycles and to structure your code in a way that avoids them. This
    might involve splitting your resources into smaller modules or using other techniques
    to reduce complexity and avoid circular dependencies.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要使用 `depends_on`，那么重要的是要意识到可能出现的依赖循环，并以避免它们的方式来组织代码。这可能涉及将资源拆分成更小的模块，或者使用其他技术来减少复杂性并避免循环依赖。
- en: 'Here’s an example of using `depends_on` to specify a dependency between an
    EC2 instance and a security group:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用 `depends_on` 来指定 EC2 实例与安全组之间依赖关系的示例：
- en: '[PRE55]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this example, we’re using `depends_on` to specify that the `aws_instance`
    resource depends on the `aws_security_group` resource. This means that Terraform
    will create the security group before creating the instance.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用 `depends_on` 来指定 `aws_instance` 资源依赖于 `aws_security_group` 资源。这意味着
    Terraform 会在创建实例之前先创建安全组。
- en: 'You can find out more about the HCL language by reading the official documentation:
    [https://developer.hashicorp.com/terraform/language](https://developer.hashicorp.com/terraform/language).'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过阅读官方文档来了解更多关于 HCL 语言的信息：[https://developer.hashicorp.com/terraform/language](https://developer.hashicorp.com/terraform/language)。
- en: Terraform examples with AWS
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Terraform 与 AWS 示例
- en: In this section, we will create two sample modules to demonstrate how you would
    go about creating one and what you will need to consider when choosing the way
    it is supposed to create resources. The module we are going to create will be
    able to create one or more EC2 instances, a security group attached to it, and
    other needed resources, such as an instance profile. It will do almost everything
    we went through in [*Chapter 10*](B18197_10.xhtml#_idTextAnchor282), but with
    the use of the AWS CLI.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建两个示例模块，以演示如何创建一个模块以及在选择创建资源的方式时需要考虑的事项。我们将要创建的模块将能够创建一个或多个 EC2 实例，一个附加的安全组以及其他所需的资源，如实例配置文件。它将做几乎所有我们在[*第
    10 章*](B18197_10.xhtml#_idTextAnchor282)中讨论的内容，但会使用 AWS CLI。
- en: EC2 instance module
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EC2 实例模块
- en: 'Let’s create a module that will be able to create EC2 instances. Consider the
    following directory structure:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个能够创建 EC2 实例的模块。考虑以下目录结构：
- en: '[PRE56]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `modules` directory is where we will put all our modules, `aws` is where
    we will keep our AWS infrastructure, and `eu-central-1` is the code of the infrastructure
    for the Frankfurt AWS region. So, let’s go ahead and start with creating the EC2
    module. Let’s create a directory to hold it and the basic files we will need,
    as we described earlier:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`modules` 目录是我们放置所有模块的地方，`aws` 是我们存放 AWS 基础设施的地方，`eu-central-1` 是法兰克福 AWS 区域的基础设施代码。因此，让我们开始创建
    EC2 模块。我们先创建一个目录来存放它和我们将需要的基本文件，如前所述：'
- en: '[PRE57]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Notice that we didn’t create the backend configuration file. This is because
    the backend will be configured in the root module instead. Modules don’t have
    state files as the resources created by the module will be using the state file
    from the root (or in other words, main) module. Let’s start configuring providers.
    In this case, we will only need the AWS provider at this moment. In our example,
    we will use the `eu-central-1` region:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有创建后端配置文件。这是因为后端将在根模块中配置。模块没有状态文件，因为由模块创建的资源将使用根（或主）模块的状态文件。让我们开始配置提供程序。在这种情况下，我们此时只需要
    AWS 提供程序。在我们的示例中，我们将使用 `eu-central-1` 区域：
- en: '[PRE58]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, let’s configure the versions of Terraform and the AWS provider we will
    use in the `versions.tf` file:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在 `versions.tf` 文件中配置我们将使用的 Terraform 和 AWS 提供程序的版本：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this example, the `required_version` attribute is set to `>= 1.0.0` to require
    Terraform version 1.0.0 or greater. The `required_providers` attribute is used
    to specify the AWS provider, with the `source` attribute set to `hashicorp/aws`
    and the `version` attribute set to `>= 3.0.0` to require the latest version of
    the AWS provider.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`required_version` 属性设置为 `>= 1.0.0`，要求使用 Terraform 1.0.0 或更高版本。`required_providers`
    属性用于指定 AWS 提供者，`source` 属性设置为 `hashicorp/aws`，并且 `version` 属性设置为 `>= 3.0.0`，要求使用最新版本的
    AWS 提供者。
- en: 'Now, we can do more interesting things, such as adding an actual `aws_instance`
    resource. For that, we will start filling the variables this resource needs:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以做一些更有趣的事情，比如添加一个实际的 `aws_instance` 资源。为此，我们将开始填写这个资源所需的变量：
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'After saving all changes to the module files, we can go back to the `aws/eu-central-1`
    directory and create a similar set of files as in the module:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有模块文件的更改后，我们可以回到 `aws/eu-central-1` 目录，并创建一个与模块中类似的文件集：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This time, we will only need `main.ft`, `providers.tf`, `variables.tf`, and
    `versions.tf`. To simplify things, we can just copy the contents of the providers
    and the versions files:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们只需要 `main.ft`、`providers.tf`、`variables.tf` 和 `versions.tf`。为了简化，我们可以直接复制
    providers 和 versions 文件的内容：
- en: '[PRE62]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, we can focus on the `main.tf` file, where we’re going to try and use our
    first version of the module. The `main.tf` file will look like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以集中精力在 `main.tf` 文件中，在这里我们将尝试使用模块的第一个版本。`main.tf` 文件将如下所示：
- en: '[PRE63]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The module we’ve created doesn’t require any variables, so this is all we need
    in this file.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的模块不需要任何变量，所以在这个文件中这就是我们所需要的全部内容。
- en: 'Since this is our root module, we will also need to configure the location
    of the Terraform state file. For simplicity, we will use a local state file, but
    in real life, we recommend using an S3 bucket with a distributed lock configured.
    If there is no backend block, Terraform will create a local file. We’re ready
    to test our module (the output has been shortened for brevity):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们的根模块，我们还需要配置 Terraform 状态文件的位置。为了简化，我们将使用本地状态文件，但在实际环境中，我们建议使用配置了分布式锁的
    S3 桶。如果没有后端块，Terraform 将创建一个本地文件。我们已经准备好测试我们的模块（输出已缩短以便简洁）：
- en: '[PRE64]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once you’ve run `terraform init` (you only have to rerun it if you update modules
    or backend configuration), you can execute `terraform plan` to see what changes
    have to be applied:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了 `terraform init`（只有在更新模块或后端配置时才需要重新运行），你可以执行 `terraform plan` 来查看需要应用的更改：
- en: '[PRE65]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You didn’t use the `-out` option to save this plan, so Terraform can’t guarantee
    it will take exactly these actions if you run `terraform` `apply` now.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 你没有使用 `-out` 选项保存这个计划，因此如果你现在运行 `terraform apply`，Terraform 无法保证会执行完全相同的操作。
- en: 'With this plan, Terraform confirmed that our module will create an EC2 instance
    for us. Unfortunately, this plan is not ideal as it doesn’t check whether the
    AMI actually exists, or whether the subnet is there. Those errors will come up
    when we run `terraform apply`. The AMI we’ve provided, for instance, is bogus,
    so Terraform will fail in creating the instance. Let’s get back to the module
    and improve it by automatically getting a correct Ubuntu Linux AMI. For this,
    the Terraform AWS provider provides a data resource. This special resource enables
    us to *ask* AWS for various resources through their API. Let’s add an AMI data
    resource to the `modules` directory’s `main.tf` file:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个计划中，Terraform 确认我们的模块将为我们创建一个 EC2 实例。不幸的是，这个计划并不理想，因为它没有检查 AMI 是否实际存在，或者子网是否存在。这些错误将在我们运行
    `terraform apply` 时出现。例如，我们提供的 AMI 是假的，因此 Terraform 在创建实例时会失败。让我们回到模块并改进它，通过自动获取正确的
    Ubuntu Linux AMI。为此，Terraform AWS 提供者提供了一个数据资源。这个特殊资源使我们能够通过其 API *请求* AWS 提供各种资源。让我们在
    `modules` 目录的 `main.tf` 文件中添加一个 AMI 数据资源：
- en: '[PRE66]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `(aws_ami)` block of code uses the `aws_ami` data source to fetch the latest
    Ubuntu AMI owned by Canonical from the AWS Marketplace. It does this by setting
    the `most_recent` parameter to `true` and filtering the results using the `name`
    attribute of the AMI. It looks for an AMI with a specific name pattern: `ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*`.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`(aws_ami)` 代码块使用 `aws_ami` 数据源从 AWS 市场获取 Canonical 所拥有的最新 Ubuntu AMI。它通过将
    `most_recent` 参数设置为 `true`，并使用 AMI 的 `name` 属性来过滤结果。它寻找一个具有特定名称模式的 AMI：`ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*`。'
- en: The second block of code creates an AWS EC2 instance using the AMI that was
    fetched in the first block of code. It sets the instance type to `t3.micro`, which
    is a small instance type that’s suitable for testing purposes.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 第二段代码使用在第一段代码中获取的 AMI 创建了一个 AWS EC2 实例。它将实例类型设置为`t3.micro`，这是一种适合测试目的的小型实例类型。
- en: It also adds a tag to the EC2 instance with a key called `Name` and a value
    called `TestInstance` so that it can easily be identified in the AWS Management
    Console.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 它还为 EC2 实例添加了一个标签，键名为`Name`，值为`TestInstance`，这样它就能在 AWS 管理控制台中轻松识别。
- en: 'You can read more about the `aws_ami` data resource in the documentation: [https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ami](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ami).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在文档中阅读更多关于`aws_ami`数据资源的内容：[https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ami](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/ami)。
- en: 'After making this modification, we can run `terraform plan` and see whether
    something changes:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 做了这个修改后，我们可以运行`terraform plan`并查看是否有所变化：
- en: '[PRE67]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The plan succeeded and it seems it found a recent AMI for Ubuntu Linux 22.04\.
    There are a few other issues we’ll need to consider if we want to make sure we’ll
    be able to connect to this new EC2 instance. Of course, it will be created if
    we apply the changes, but we don’t have a way to connect to it. First, let’s connect
    the EC2 instance to the correct network: we will use a default VPC and a public
    subnet, which will allow us to connect to this instance directly.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 计划成功执行，看起来它找到了一个最近的适用于 Ubuntu Linux 22.04 的 AMI。我们需要考虑一些其他问题，尤其是如果我们想确保能够连接到这个新的
    EC2 实例。 当然，如果我们应用更改，它会被创建，但我们目前没有办法连接到它。首先，让我们将 EC2 实例连接到正确的网络：我们将使用一个默认的 VPC
    和一个公有子网，这样我们就能直接连接到这个实例。
- en: 'To figure out the ID of the default VPC and a public subnet, once again, we
    will use a data resource:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找出默认 VPC 和公有子网的 ID，我们将再次使用数据资源：
- en: '**VPC** **documentation**: [https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/vpc](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/vpc%20)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VPC** **文档**：[https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/vpc](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/vpc)'
- en: '**Subnet** **documentation**: [https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/subnets](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/subnets%20)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子网** **文档**：[https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/subnets](https://registry.terraform.io/providers/hashicorp/aws/latest/docs/data-sources/subnets)'
- en: The question is whether we want to automatically put all created instances in
    a default VPC (and a public subnet) or not. Usually, the answer to this question
    is *no*. In that case, we will need to add some variables to be passed to this
    module.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是我们是否希望将所有创建的实例自动放入默认的 VPC（和公有子网）。通常，这个问题的答案是*否*。在这种情况下，我们需要添加一些变量并将其传递给这个模块。
- en: 'Let’s add another file to the root module, in which we will put all the data
    resources, called `data.tf`:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向根模块中添加另一个文件，在这个文件中放置所有的数据资源，命名为`data.tf`：
- en: '[PRE68]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we can create an input variable in our module. Go back to the `modules/aws_ec2`
    directory and edit the `variables.tf` file:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在模块中创建一个输入变量。返回到`modules/aws_ec2`目录并编辑`variables.tf`文件：
- en: '[PRE69]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, when you run `terraform plan`, you will see the following error:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行`terraform plan`时，你会看到以下错误：
- en: '[PRE70]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Here, we’ve created a mandatory variable we will need to provide to the module.
    Let’s do so by editing the `main.tf` file in our root module (the `aws/eu-central-1`
    directory):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个必需的变量，我们需要将其提供给模块。让我们通过编辑根模块中的`main.tf`文件（`aws/eu-central-1`目录）来完成：
- en: '[PRE71]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Notice `data.aws_subnets.public.ids[0]`. We’ve used a list notation, where we’re
    choosing the first element of the list (which is a string since the module expects
    it to be). This is because there are multiple subnets and `aws_subnets` returned
    a list of those subnets for us.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`data.aws_subnets.public.ids[0]`。我们使用了列表表示法，在这里我们选择了列表中的第一个元素（它是一个字符串，因为模块期望它是字符串）。这是因为有多个子网，`aws_subnets`为我们返回了这些子网的列表。
- en: Running a plan again should give us one resource to be added. Great! Now, our
    instance will get a public IP address we can connect to. But we’re still missing
    a firewall rule that will allow us to connect to port `22` (SSH). Let’s create
    a **security** **group** (**SG**).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行计划应该会给我们添加一个资源。太好了！现在，我们的实例将获得一个可以连接的公网 IP 地址。但我们仍然缺少一个防火墙规则，这个规则允许我们连接到端口`22`（SSH）。让我们创建一个**安全**
    **组**（**SG**）。
- en: 'Again, we could decide to create an SG in the root module, which would allow
    us to modify it without changing the EC2 module. Alternatively, we could add an
    SG inside the EC2 module, which would mean that the module would have full control
    over it, but it would lack some flexibility. It’s also possible to create a module
    that would do both: attach an SG injected from the root module and, at the same
    time, use an SG predefined in the module, but this is outside the scope of this
    chapter. In this case, we’re going to create an SG inside the module for simplicity’s
    sake.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，我们可以选择在根模块中创建一个安全组，这样我们就可以在不更改EC2模块的情况下修改它。或者，我们可以将安全组添加到EC2模块中，这意味着该模块将完全控制它，但会缺少一些灵活性。还可以创建一个同时执行两者的模块：从根模块注入一个安全组并使用模块中预定义的安全组，但这超出了本章的范围。在本例中，为了简化起见，我们将在模块内部创建一个安全组。
- en: 'To create an SG, we will use the `aws_security_group` resource, which requires
    a VPC ID. There are two possibilities: we will need to introduce another variable
    to our EC2 module, or we will use another data resource to automatically get the
    VPC ID from the provided subnet. This time, a more elegant solution would be to
    use data resources. Let’s add it to `main.tf` in our module:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个安全组（SG），我们将使用`aws_security_group`资源，它需要一个VPC ID。有两种可能性：我们需要向EC2模块引入另一个变量，或者使用另一个数据资源从提供的子网自动获取VPC
    ID。这次，采用更优雅的解决方案是使用数据资源。让我们将其添加到模块中的`main.tf`：
- en: '[PRE72]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With that in place, we will be able to add an SG now:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，我们现在可以添加一个安全组了：
- en: '[PRE73]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The preceding code creates an AWS SG that allows SSH traffic to the EC2 instance
    we created earlier.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个允许SSH流量通过的AWS安全组（SG），以连接我们之前创建的EC2实例。
- en: The `aws_security_group` resource is used to create an SG for the EC2 instance.
    It sets the name of the SG to `TestInstanceSG` and provides a brief description.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`aws_security_group`资源用于为EC2实例创建一个安全组。它将安全组的名称设置为`TestInstanceSG`，并提供简短的描述。'
- en: The `vpc_id` attribute is set to the VPC ID of the current subnet. It uses the
    `aws_subnet` data source called `current` to fetch the current subnet’s VPC ID.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`vpc_id`属性被设置为当前子网的VPC ID。它使用名为`current`的`aws_subnet`数据源来获取当前子网的VPC ID。'
- en: The `ingress` block defines the inbound rules for the security group. In this
    case, it allows SSH traffic from any IP address (`0.0.0.0/0`) by specifying `from_port`,
    `to_port`, `protocol`, and `cidr_blocks`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`ingress`块定义了安全组的入站规则。在本例中，它通过指定`from_port`、`to_port`、`protocol`和`cidr_blocks`，允许来自任何IP地址（`0.0.0.0/0`）的SSH流量。'
- en: The `egress` block defines the outbound rules for the security group. In this
    case, it allows all outbound traffic by specifying `from_port`, `to_port`, `protocol`,
    and `cidr_blocks`. It also allows all IPv6 traffic by specifying `ipv6_cidr_blocks`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`egress`块定义了安全组的出站规则。在本例中，它通过指定`from_port`、`to_port`、`protocol`和`cidr_blocks`允许所有出站流量。它还通过指定`ipv6_cidr_blocks`来允许所有IPv6流量。'
- en: The `tags` attribute sets a tag for the SG with a key called `Name` and a value
    called `TestInstanceSG` so that it can be easily identified in the AWS Management
    Console.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags`属性为安全组设置一个标签，键为`Name`，值为`TestInstanceSG`，这样可以方便地在AWS管理控制台中进行识别。'
- en: 'Now, we’re ready to attach this SG to our instance. We will need to use the
    `security_groups` option for the `aws_instance` resource:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备将此安全组附加到我们的实例。我们需要在`aws_instance`资源中使用`security_groups`选项：
- en: '[PRE74]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, after running `terraform plan`, you will see two resources to be added:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行`terraform plan`后，您将看到两个需要添加的资源：
- en: '[PRE75]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: At this point, we need to add our public SSH key to AWS and configure EC2 to
    use it for a default Ubuntu Linux user (`ubuntu`). Assuming you have already generated
    your SSH key, we will create a variable with said key, create a resource that
    will make the key available for the EC2 instance, and finally, add it to the instance
    configuration.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，我们需要将我们的公有SSH密钥添加到AWS并配置EC2使用它作为默认的Ubuntu Linux用户（`ubuntu`）。假设您已经生成了SSH密钥，我们将创建一个包含该密钥的变量，创建一个资源使该密钥可用于EC2实例，最后将其添加到实例配置中。
- en: Important note
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: In some AWS regions, it’s required to use an old RSA key format. Whenever available,
    we recommend the newest format according to up-to-date recommendations. At the
    time of writing this book, it’s recommended to use the `ED25519` key.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些AWS区域中，要求使用旧版RSA密钥格式。只要可用，我们建议根据最新的推荐使用最新的格式。在撰写本书时，推荐使用`ED25519`密钥。
- en: 'Let’s add a variable to the root module:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在根模块中添加一个变量：
- en: '[PRE76]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let’s add a similar one for the EC2 module:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为EC2模块添加一个类似的安全组：
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This one is without the default value to make this variable required for every
    module in use. Now, let’s add the key to AWS inside the EC2 module (`main.tf`):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这是没有默认值的，以使得这个变量对每个模块使用时都是必需的。现在，让我们在EC2模块（`main.tf`）中添加密钥到AWS中：
- en: '[PRE78]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then, we can use it in the `aws_instance` resource:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在`aws_instance`资源中使用它：
- en: '[PRE79]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We will need to use the new variable inside the root module in `main.tf`:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在根模块中的`main.tf`里使用这个新变量：
- en: '[PRE80]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, running `terraform plan` will give us three resources:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行`terraform plan`将给我们显示三个资源：
- en: '[PRE81]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Great! Running `terraform apply` and accepting any changes will deploy the EC2
    instance in a public subnet with our key. However, we still won’t know the IP
    address for the instance unless we go to the AWS console and check it manually.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！运行`terraform apply`并接受任何更改将会在公共子网中部署EC2实例，并使用我们的密钥。但是，除非我们去AWS控制台手动检查，否则我们仍然无法知道实例的IP地址。
- en: To get this information, we will need to export these variables from the EC2
    module and then once again in the root module. For this, we have another code
    block called `output`. Its syntax is very similar to the `variable` syntax, but
    additionally, you can mark the `output` variable as sensitive so that it’s not
    shown by default when running `terraform plan` or `terraform` `apply` commands.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取这些信息，我们需要从EC2模块中导出这些变量，然后再次在根模块中使用。为此，我们有另一个代码块叫`output`。它的语法与`variable`语法非常相似，但你还可以将`output`变量标记为敏感信息，这样在运行`terraform
    plan`或`terraform apply`命令时，默认情况下不会显示它。
- en: 'Let’s define outputs showing us the public IP address of the EC2 instance.
    In the EC2 module in the `outputs.tf` file, place the following code:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义输出，显示EC2实例的公共IP地址。在EC2模块的`outputs.tf`文件中，放入以下代码：
- en: '[PRE82]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In the root module, create the `outputs.tf` file and put the following code
    there:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在根模块中创建`outputs.tf`文件，并在那里放入以下代码：
- en: '[PRE83]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, when you run `terraform plan`, you will see a change in the output:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行`terraform plan`时，你会看到输出结果有所变化：
- en: '[PRE84]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This way, we’ve created a simple module by creating a single EC2 instance. If
    we run `terraform apply`, the instance will be created and the output will show
    us the IP address.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们通过创建一个单独的EC2实例创建了一个简单的模块。如果我们运行`terraform apply`，实例将被创建，并且输出结果会显示我们该实例的IP地址。
- en: From here, the next steps would involve adding more functionality to the module,
    adding the ability to create more than one instance with the `count` meta-argument,
    or creating a set of different EC2 instances by using the `for_each` meta-argument.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，接下来的步骤将涉及为模块添加更多功能，通过使用`count`元参数来创建多个实例，或者通过使用`for_each`元参数来创建一组不同的EC2实例。
- en: Summary
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the concept of IaC. We explained why it is an
    important method of managing and developing your infrastructure. We also introduced
    some tools that are quite popular in this way of working. As a tool of choice,
    we explained Terraform – probably the most widely used one.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了IaC的概念。我们解释了为什么它是管理和开发基础设施的重要方法。我们还介绍了一些在这种工作方式中相当流行的工具。作为首选工具，我们讲解了Terraform——可能是最广泛使用的工具。
- en: In the next chapter, we are going to show you how you can leverage some online
    tools and automation to build pipelines for **CI** and **CD**.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将展示如何利用一些在线工具和自动化来构建**CI**和**CD**的管道。
- en: Exercises
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try out the following exercises to test what you’ve learned in this chapter:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习，测试你在本章中学到的内容：
- en: Create a module that will create an S3 bucket with enabled server-side encryption.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模块，用于创建启用服务器端加密的S3存储桶。
- en: Add an instance profile to the module we’ve created using the same IAM policy
    that we used in [*Chapter 10*](B18197_10.xhtml#_idTextAnchor282).
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向我们创建的模块添加一个实例配置文件，并使用我们在[*第10章*](B18197_10.xhtml#_idTextAnchor282)中使用的相同IAM策略。
- en: Use the `count` meta-argument to create two instances.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`count`元参数创建两个实例。
