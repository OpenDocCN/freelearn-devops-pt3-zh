<html><head></head><body>
<div id="_idContainer041">
<h1 class="chapter-number" id="_idParaDest-95"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-96"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.2.1">Understanding the Basics of CI/CD</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.3.1">Continuous integration and continuous delivery</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.5.1">CI/CD</span></strong><span class="koboSpan" id="kobo.6.1">) is a key strategy of DevOps release</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.7.1"> management. </span><span class="koboSpan" id="kobo.7.2">It automates the majority of manual human intervention that would traditionally be needed in order to produce a new software release or get new code into production. </span><span class="koboSpan" id="kobo.7.3">CI/CD comprises the integration tests, unit tests, regression tests, and the build and deploy phases. </span><span class="koboSpan" id="kobo.7.4">Infrastructure as code can be integrated into the CI/CD process too, automating the provisioning of cloud infrastructure, but can also include provisioning on-premises virtual infrastructure. </span><span class="koboSpan" id="kobo.7.5">With CI/CD pipelines, software development teams can make changes to code that are then automatically tested, pushed out for delivery, and deployed in any environment. </span><span class="koboSpan" id="kobo.7.6">As you can infer, CI/CD dramatically reduces downtime, ensuring that releases happen far quicker, are consistent from release to release, and occur much more frequently as </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">well. </span><span class="koboSpan" id="kobo.8.2">Radical!</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">You can tailor pipelines to accomplish all kinds of tasks, even if they have nothing to do with releasing software. </span><span class="koboSpan" id="kobo.9.2">This could include generating reports for the business unit, turning off unused infrastructure during off-peak hours and starting them again before the next workday, refreshing development databases with data from production, performing automated penetration tests against network infrastructure, automatically rotating IAM keys, SSL certificates, and more! </span><span class="koboSpan" id="kobo.9.3">There’s a lot of great information about CI/CD out there, but for the subject of this book, mentioning it </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">is obligatory.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">In this sixth chapter, you will learn </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">The ABCs </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">of CI/CD</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">What </span><strong class="bold"><span class="koboSpan" id="kobo.16.1">continuous integration</span></strong><span class="koboSpan" id="kobo.17.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.18.1">CI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">) is</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">What </span><strong class="bold"><span class="koboSpan" id="kobo.21.1">continuous delivery</span></strong><span class="koboSpan" id="kobo.22.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.23.1">CD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">) is</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">What continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">testing is</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">The DevOps transformation of </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Capital One</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.29.1">By the end of this chapter, you will have learned the core tenets of CI/CD, the philosophy that gave birth to it, and the basic strategies to implement it. </span><span class="koboSpan" id="kobo.29.2">While this chapter does not delve too deeply into the technical implementation of CI/CD, you will be shown the tactical strategies that will help you achieve success, along with some of the tools that will aid you in </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">getting there.</span></span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.31.1">The ABCs of CI/CD</span></h1>
<p><span class="koboSpan" id="kobo.32.1">CI/CD is the lifeblood of today’s software </span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.33.1">industry, powering the rapid creation and distribution of new programs. </span><span class="koboSpan" id="kobo.33.2">Tools that eliminate bottlenecks in integration and delivery are essential for the smooth operation of any CI/CD pipeline. </span><span class="koboSpan" id="kobo.33.3">Teams need a unified set of technologies to use in order to work collaboratively and efficiently on projects. </span><span class="koboSpan" id="kobo.33.4">Source control, testing tools, infrastructure modification, and monitoring tools are just some of the SDLC elements that can be unified with </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">this framework.</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">With a well-architected CI/CD pipeline, businesses can quickly pivot to new trends in consumer demand and technological advancements. </span><span class="koboSpan" id="kobo.35.2">In contrast, it takes a long time for teams with traditional development strategies to implement customer-requested changes or to incorporate new technologies. </span><span class="koboSpan" id="kobo.35.3">In addition, by the time the company realizes it needs to pivot, consumer demand may have already shifted. </span><span class="koboSpan" id="kobo.35.4">This problem is addressed by DevOps release management because it employs continuous integration and continuous deployment, a slightly more advanced version of continuous delivery, which we will cover in </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">more detail.</span></span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.37.1">What is a CI/CD pipeline?</span></h2>
<p><span class="koboSpan" id="kobo.38.1">A CI/CD pipeline streamlines the process</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.39.1"> of automating software or infrastructure as code delivery, ensuring a smooth transition from source code to production deployment. </span><span class="koboSpan" id="kobo.39.2">Think of it as a sequence of necessary steps for code to </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">be released.</span></span></p>
<p><span class="koboSpan" id="kobo.41.1">CI is an acronym for continuous integration, while CD is an acronym for continuous delivery or deployment. </span><span class="koboSpan" id="kobo.41.2">The concept of a pipeline involves automating the various stages of the delivery workflow, including build, test, delivery, and deployment. </span><span class="koboSpan" id="kobo.41.3">By automating and controlling each phase of the delivery process, all the advantages of using CI/CD pipelines are unlocked. </span><span class="koboSpan" id="kobo.41.4">This helps minimize human error and ensures consistency across </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">each release.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">CI/CD pipelines are often configured as code, and as such are widely</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.44.1"> recognized by the term </span><em class="italic"><span class="koboSpan" id="kobo.45.1">pipeline as co</span><a id="_idTextAnchor099"/><span class="koboSpan" id="kobo.46.1">de</span></em><span class="koboSpan" id="kobo.47.1">. </span><span class="koboSpan" id="kobo.47.2">In order to facilitate pipeline runs, it is common to use a CI server and its corresponding build agents. </span><span class="koboSpan" id="kobo.47.3">Depending on the product you are using, a build</span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.48.1"> agent might be called a </span><em class="italic"><span class="koboSpan" id="kobo.49.1">runner</span></em><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">Usually, build agents appear in the form of virtual machines and can be self-hosted and fully customized and require regular maintenance. </span><span class="koboSpan" id="kobo.50.3">Alternatively, if you are using a commercial SaaS product, you can use CI servers and build agents provided by the SaaS provider, but they may have limitations when it comes to customization and adding software </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">or plugins.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Containers can also be used to facilitate the creation of consistent build environments, reducing the need for maintaining static build agents. </span><span class="koboSpan" id="kobo.52.2">In this scenario, every stage of the CI/CD pipeline can run independently within a container tailored to its specific needs. </span><span class="koboSpan" id="kobo.52.3">Additionally, pipelines can take advantage of the various benefits provided by container orchestration, including immutability and scaling, </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Well-architected CI/CD pipeline infrastructure</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.55.1"> should be designed to accept parameters that produce repeatable outcomes in any number of environments. </span><span class="koboSpan" id="kobo.55.2">They are also adaptable, considering a scenario in which a consumer need exists but is not being met by existing DevOps solutions. </span><span class="koboSpan" id="kobo.55.3">In this scenario, it is possible to quickly identify the solution, conduct an analysis of it, develop it, and deploy it to the application environment in a relatively short time – all without interrupting the normal development flow of </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">Additionally, CI/CD allows the rapid deployment of even minor changes to the final product, in turn allowing faster response times to user requests. </span><span class="koboSpan" id="kobo.57.2">It not only addresses user concerns but also gives them insight into the design and creation process. </span><span class="koboSpan" id="kobo.57.3">Users will notice the product improving over time as updates are rolled out to address bugs and add new functionality. </span><span class="koboSpan" id="kobo.57.4">In contrast to more conventional methods, such as the waterfall model, where users aren’t involved until the very end of the development process, DevOps release management facilitates continuous feedback and refinement throughout a product’s </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">life cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.59.1">Different projects call for different levels of complexity and numbers of steps in the CI/CD pipeline. </span><span class="koboSpan" id="kobo.59.2">One potential pipeline might utilize a multi-stage deployment approach, wherein software is distributed as containers to a Kubernetes cluster spanning multiple cloud environments. </span><span class="koboSpan" id="kobo.59.3">In contrast, another pipeline may adopt a more straightforward approach, involving the construction, testing, and deployment of an app built as a </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">.jar</span></strong><span class="koboSpan" id="kobo.61.1"> file running on a virtual machine and behind a proxy server. </span><span class="koboSpan" id="kobo.61.2">In this example, both of these pipelines share the same goal of automating the software </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">delivery process.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">In essence, the establishment of well-architected CI/CD pipeline infrastructure is essential to fully leverage all the benefits that come with choosing DevOps release management. </span><span class="koboSpan" id="kobo.63.2">In the next section, we’ll dive deeper into the subject of continuous integration. </span><span class="koboSpan" id="kobo.63.3">Topics will include the meaning of CI, selecting</span><a id="_idIndexMarker354"/><span class="koboSpan" id="kobo.64.1"> the right CI tool for your organization, example pipeline syntax, and </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">feature comparisons.</span></span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.66.1">What is continuous integration (CI)?</span></h1>
<p><span class="koboSpan" id="kobo.67.1">Modern software development</span><a id="_idIndexMarker355"/><span class="koboSpan" id="kobo.68.1"> would not be possible without </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">continuous integration</span></strong><span class="koboSpan" id="kobo.70.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.71.1">CI</span></strong><span class="koboSpan" id="kobo.72.1">). </span><span class="koboSpan" id="kobo.72.2">The creation of modern software typically involves the collaboration of numerous developers who are geographically diverse, each of whom focuses on a particular component, feature, or aspect of a product. </span><span class="koboSpan" id="kobo.72.3">In order for you to bring a single, comprehensive product to release, it is necessary to merge all of these code changes. </span><span class="koboSpan" id="kobo.72.4">However, manually merging all of these changes is extremely impractical, and a painful chore, and when developers are working on many updates concurrently, there will inevitably be code changes that conflict with one another. </span><span class="koboSpan" id="kobo.72.5">However, continuous integration incentivizes developers</span><a id="_idIndexMarker356"/><span class="koboSpan" id="kobo.73.1"> to continuously push their code to the same </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">version control system</span></strong><span class="koboSpan" id="kobo.75.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">VCS</span></strong><span class="koboSpan" id="kobo.77.1">), providing a brilliant synergy that solves this problem. </span><span class="koboSpan" id="kobo.77.2">With the use of CI, you can continuously commit, build, and test your team’s code, a vital strategy as a DevOps release manager. </span><span class="koboSpan" id="kobo.77.3">If your team tests new code often, they will catch and fix defects before they get deeply ingrained in </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">the software.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">While there are no hard requirements for what tools can be used in CI, many teams prefer using continuous integration servers such as Jenkins, GitLab CI, or GitHub Actions. </span><span class="koboSpan" id="kobo.79.2">As fresh code changes get submitted, a continuous integration server oversees everything and acts as the arbitrator. </span><span class="koboSpan" id="kobo.79.3">Each time a developer commits their work in the repository, the CI server will automatically run a suite of tests and record the outcomes. </span><span class="koboSpan" id="kobo.79.4">The developer who made the change to the repository will typically get an email with the results shortly after making the change. </span><span class="koboSpan" id="kobo.79.5">This is crucial as it allows the developer to resolve potential issues in the shortest amount </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">of time.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">After changes have been subjected to automated testing, the updated code can receive approval for new builds to be created along with additional testing in QA and pre-production environments. </span><span class="koboSpan" id="kobo.81.2">If all quality checks pass, the code can then be merged into the main branch and a new release is published. </span><span class="koboSpan" id="kobo.81.3">Unit tests and integration tests are usually performed as part of the continuous integration process in order to guarantee that code changes won’t end up resulting in stability issues. </span><span class="koboSpan" id="kobo.81.4">Additionally, CI is a great place to integrate </span><strong class="bold"><span class="koboSpan" id="kobo.82.1">static application security testing</span></strong><span class="koboSpan" id="kobo.83.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.84.1">SAST</span></strong><span class="koboSpan" id="kobo.85.1">), moving application security near the beginning</span><a id="_idIndexMarker357"/><span class="koboSpan" id="kobo.86.1"> of the development cycle. </span><span class="koboSpan" id="kobo.86.2">All of this test automation makes sure that any changes made to the code are adequately vetted before being promoted </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">Another benefit to increasing the commit frequency is that individual contributors can proactively detect and address merge conflicts at an earlier stage, either minimizing their occurrence or preventing them entirely. </span><span class="koboSpan" id="kobo.88.2">Furthermore, integrating smaller increments of work is an effective way to avoid committing a substantial number of changes all at once and encountering mysterious errors; instead, developers will have produced far smaller amounts of code, totaling fewer lines. </span><span class="koboSpan" id="kobo.88.3">This makes the task of identifying and resolving bugs</span><a id="_idIndexMarker358"/><span class="koboSpan" id="kobo.89.1"> and defects in your code significantly more efficient, reducing the time required from many hours to just a </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">few minutes.</span></span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.91.1">Selecting the right CI tool for your operations</span></h2>
<p><span class="koboSpan" id="kobo.92.1">There are numerous choices</span><a id="_idIndexMarker359"/><span class="koboSpan" id="kobo.93.1"> available to you when selecting an appropriate CI/CD tool for your team’s operations. </span><span class="koboSpan" id="kobo.93.2">It is pivotal to assess your own unique requirements and preferences because every tool has its own set of advantages and disadvantages that could impact your success. </span><span class="koboSpan" id="kobo.93.3">Whether you prefer open source options, artificial intelligence capabilities, on-premises solutions, peak scalability, or extensive customization features, you can find the right tool for </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">your needs.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">While evaluating various CI/CD tools for your team, you should consider the following core factors before making your final decision on which one </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">to select:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.97.1">On-premises versus cloud-based</span></strong><span class="koboSpan" id="kobo.98.1">: It’s important to evaluate whether the tool provides cloud-based and/or on-premises (hosted) solutions and select the option that best suits your </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">project requirements.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.100.1">Open source versus closed source</span></strong><span class="koboSpan" id="kobo.101.1">: Consider the compatibility of the CI/CD tool with open source projects and how well it aligns with your </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">project’s objectives.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Testing integration</span></strong><span class="koboSpan" id="kobo.104.1">: It is advisable to select a CI/CD tool that has a user-friendly interface and a configuration that is easy to comprehend, so as to minimize the difficulties associated </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">with setup.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">Ease of setup and configuration</span></strong><span class="koboSpan" id="kobo.107.1">: You should opt for a CI/CD tool with a user-friendly interface and easy-to-understand configuration, reducing </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">setup complexities.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.109.1">Build environment compatibility</span></strong><span class="koboSpan" id="kobo.110.1">: It’s important to consider the compatibility of the tool with your project’s environment and programming languages to </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">streamline integration.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.112.1">Learning curve</span></strong><span class="koboSpan" id="kobo.113.1">: It is advisable to consider the learning curve that developers may face to facilitate the setup and configuration of their build and </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">deployment workflows.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.115.1">Paid plan features</span></strong><span class="koboSpan" id="kobo.116.1">: To cope with project growth, it is advisable to examine both existing and new features offered in paid plans (if any), including allocated daily builds, runtime minutes, quantity of users, and number of private repositories, just to name </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">a few.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.118.1">Version control system compatibility</span></strong><span class="koboSpan" id="kobo.119.1">: Make sure that you verify whether the CI/CD tool can comfortably integrate with your preferred version control system or source control platform for efficient source code management </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">and delivery.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.121.1">Let’s dive deeper into the top three industry-leading CI/CD tools and help you assess which one is right for your enterprise. </span><span class="koboSpan" id="kobo.121.2">To start with, Jenkins is a well-known CI server that has been around for a very long time and offers many plugins with features that newer competitors don’t. </span><span class="koboSpan" id="kobo.121.3">Another</span><a id="_idIndexMarker360"/><span class="koboSpan" id="kobo.122.1"> robust tool that integrates with GitHub repositories elegantly is GitLab CI. </span><span class="koboSpan" id="kobo.122.2">Don’t overlook GitHub Actions, which provides a straightforward and </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">easy-to-understand workflow.</span></span></p>
<h3><span class="koboSpan" id="kobo.124.1">Jenkins</span></h3>
<p><span class="koboSpan" id="kobo.125.1">Jenkins is a well-known and highly customizable</span><a id="_idIndexMarker361"/><span class="koboSpan" id="kobo.126.1"> open source CI/CD tool capable of automating almost anything. </span><span class="koboSpan" id="kobo.126.2">Jenkins was developed using the Java programming language and is open source, released under the MIT license. </span><span class="koboSpan" id="kobo.126.3">The software offers a comprehensive range of features that streamline various tasks, including building, testing, deploying, integrating, and releasing software. </span><span class="koboSpan" id="kobo.126.4">The Jenkins Server (Master) software is compatible with Linux, macOS, Windows, and Unix. </span><span class="koboSpan" id="kobo.126.5">In addition to being installed through native installation packages, Jenkins can be run as a standalone Docker</span><a id="_idIndexMarker362"/><span class="koboSpan" id="kobo.127.1"> container or on any machine that has </span><strong class="bold"><span class="koboSpan" id="kobo.128.1">Java Runtime Environment</span></strong><span class="koboSpan" id="kobo.129.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.130.1">JRE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">) installed.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">The Jenkins Master supervises and coordinates the entire build process, acting as an arbiter. </span><span class="koboSpan" id="kobo.132.2">It serves as the hub for configuration settings, job definitions, and metadata, giving it complete control. </span><span class="koboSpan" id="kobo.132.3">This is where any of a diverse range of plugins can be installed, expanding Jenkins’ features and capabilities, such as integrating with </span><em class="italic"><span class="koboSpan" id="kobo.133.1">Atlassian JIRA</span></em><span class="koboSpan" id="kobo.134.1"> or </span><em class="italic"><span class="koboSpan" id="kobo.135.1">SonarSource SonarQube</span></em><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">In addition, the Jenkins Master provides a web-based interface that is easy to use, allowing users to interact with Jenkins, set up jobs, and keep track of </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">build progress.</span></span></p>
<p><span class="koboSpan" id="kobo.138.1">However, any number of Slave nodes serve as the diligent workers in the system. </span><span class="koboSpan" id="kobo.138.2">They carry out assigned tasks under the direct supervision of the Master. </span><span class="koboSpan" id="kobo.138.3">By distributing tasks to multiple Slaves, the build pipeline can be completed much faster through parallel processing. </span><span class="koboSpan" id="kobo.138.4">Furthermore, Slaves can be configured on different machines, including various Operating Systems and environments. </span><span class="koboSpan" id="kobo.138.5">Thanks to this versatility, Jenkins can meet a diverse range of build and </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">testing needs.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">Additionally, the Jenkins team has developed</span><a id="_idIndexMarker363"/><span class="koboSpan" id="kobo.141.1"> a sub-project called Jenkins X, which focuses on effortlessly running a pipeline in Kubernetes with little to no extra work. </span><span class="koboSpan" id="kobo.141.2">Jenkins X seamlessly combines Helm, Jenkins CI/CD server, Kubernetes, and various other tools to provide a streamlined CI/CD pipeline with pre-established best practices, such as employing GitOps to </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">manage environments.</span></span></p>
<h4><span class="koboSpan" id="kobo.143.1">Jenkins syntax example</span></h4>
<p><span class="koboSpan" id="kobo.144.1">Now, let’s examine an example of a Jenkins</span><a id="_idIndexMarker364"/><span class="koboSpan" id="kobo.145.1"> pipeline to get a practical understanding of its syntax and how it can be configured! </span><span class="koboSpan" id="kobo.145.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">Jenkinsfile</span></strong><span class="koboSpan" id="kobo.147.1"> file, a Docker container image is being built and the resulting artifact gets published to a designated </span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">Docker Registry:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.149.1"><img alt="Figure 6.1: Example Jenkinsfile – pipeline configured to build a Docker image" src="image/B21803_06_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.150.1">Figure 6.1: Example Jenkinsfile – pipeline configured to build a Docker image</span></p>
<h3><span class="koboSpan" id="kobo.151.1">GitLab CI</span></h3>
<p><span class="koboSpan" id="kobo.152.1">Out of all the CI/CD tools available, GitLab CI/CD</span><a id="_idIndexMarker365"/><span class="koboSpan" id="kobo.153.1"> stands out as the latest and most highly regarded option. </span><span class="koboSpan" id="kobo.153.2">This product is a self-hosted continuous integration tool, and the community edition is completely free </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">It includes a range of features such as git repository management, issue tracking, code reviews, wikis, and activity feeds. </span><span class="koboSpan" id="kobo.155.2">Companies often choose to install GitLab CI/CD on-premises and connect it with their organization’s Active Directory and LDAP servers to ensure secure authorization and authentication. </span><span class="koboSpan" id="kobo.155.3">An obvious drawback of utilizing GitLab Community Edition is the absence of any form of customer support. </span><span class="koboSpan" id="kobo.155.4">If you encounter challenges or require assistance with a project, you are unable to submit tickets and request help in the same manner as you would with the other two versions, which are Premium </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">and Ultimate.</span></span></p>
<p><span class="koboSpan" id="kobo.157.1">Upgrading from the Community edition to either the Ultimate or Premium versions grants you access to customer support, along with numerous advantageous security features, such as two-factor authentication, advanced security scanning, and compliance auditing tools for your code. </span><span class="koboSpan" id="kobo.157.2">In addition, you will have access to various auxiliary tools including push rules, DORA metrics</span><a id="_idIndexMarker366"/><span class="koboSpan" id="kobo.158.1"> tracking, burndown charts, Security Scanning IDE integration, and </span><strong class="bold"><span class="koboSpan" id="kobo.159.1">dynamic application security testing</span></strong><span class="koboSpan" id="kobo.160.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.161.1">DAST</span></strong><span class="koboSpan" id="kobo.162.1">) features. </span><span class="koboSpan" id="kobo.162.2">Moreover, you can guarantee that your projects consistently operate without incurring additional risk by utilizing sophisticated monitoring features, such as performance metrics and system </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">health checks.</span></span></p>
<p><span class="koboSpan" id="kobo.164.1">The GitLab server is responsible for detecting trigger events that initiate one or more pipelines. </span><span class="koboSpan" id="kobo.164.2">When a new pipeline begins, the GitLab server determines which jobs (defined in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">.gitlab-ci.yml</span></strong><span class="koboSpan" id="kobo.166.1"> file) should run, skipping some and queuing others, if necessary. </span><span class="koboSpan" id="kobo.166.2">These jobs are then assigned to available runners in the </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">correct sequence.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">The GitLab architecture illustrated</span><a id="_idIndexMarker367"/><span class="koboSpan" id="kobo.169.1"> in the preceding figure is comprised of the </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">following components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.171.1">Commit</span></strong><span class="koboSpan" id="kobo.172.1">: A commit is a record of a change made in the files or code, like what you would find in a </span><span class="No-Break"><span class="koboSpan" id="kobo.173.1">GitHub repository.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.174.1">Jobs</span></strong><span class="koboSpan" id="kobo.175.1">: A job is an individual task that the GitLab pipeline needs to execute, such as deploying an application. </span><span class="koboSpan" id="kobo.175.2">Every task is assigned a name and includes a script. </span><span class="koboSpan" id="kobo.175.3">Every script is executed in sequential order, ensuring that each job is completed before moving on to the </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">next one.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.177.1">Stages</span></strong><span class="koboSpan" id="kobo.178.1">: A stage serves as a clear distinction between different tasks, signifying the progression of a pipeline through each step. </span><span class="koboSpan" id="kobo.178.2">This clarifies the order in which tasks should be executed. </span><span class="koboSpan" id="kobo.178.3">As an illustration, the stages could include test, build, </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">and deploy.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.180.1">Pipeline</span></strong><span class="koboSpan" id="kobo.181.1">: A pipeline is a comprehensive set of stages, with each stage consisting of one or more tasks. </span><span class="koboSpan" id="kobo.181.2">GitLab offers a variety of pipeline options, such as basic, merge, parent-child, and </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">multi-project pipelines.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.183.1">Runners</span></strong><span class="koboSpan" id="kobo.184.1">: A runner is the active component responsible for executing the CI/CD pipeline. </span><span class="koboSpan" id="kobo.184.2">You have the option to set up self-hosted GitLab runners on-premises or utilize the runners provided by GitLab as part of their SaaS product </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">on GitLab.com.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.186.1">GitLab server</span></strong><span class="koboSpan" id="kobo.187.1">: The GitLab server handles the hosting and management of your pipeline configurations. </span><span class="koboSpan" id="kobo.187.2">You can set up your own GitLab server instance on-premises or use the SaaS version</span><a id="_idIndexMarker368"/><span class="koboSpan" id="kobo.188.1"> which is hosted </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">on GitLab.com.</span></span></li>
</ul>
<h4><span class="koboSpan" id="kobo.190.1">GitLab CI syntax example</span></h4>
<p><span class="koboSpan" id="kobo.191.1">Let’s view an example of a GitLab CI/CD pipeline</span><a id="_idIndexMarker369"/><span class="koboSpan" id="kobo.192.1"> to get a practical understanding of its syntax and how it can be configured! </span><span class="koboSpan" id="kobo.192.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">.gitlab-ci.yml</span></strong><span class="koboSpan" id="kobo.194.1"> file, a Docker container image is built and the resulting artifact gets published to a designated </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">Docker Registry:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.196.1"><img alt="Figure 6.2: Example GitLab gitlab-ci.yml file – pipeline configured to build a Docker image" src="image/B21803_06_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.197.1">Figure 6.2: Example GitLab gitlab-ci.yml file – pipeline configured to build a Docker image</span></p>
<h3><span class="koboSpan" id="kobo.198.1">GitHub Actions</span></h3>
<p><span class="koboSpan" id="kobo.199.1">GitHub Actions is a tool used for continuous</span><a id="_idIndexMarker370"/><span class="koboSpan" id="kobo.200.1"> integration and continuous deployment as part of the GitHub flow. </span><span class="koboSpan" id="kobo.200.2">It can be utilized for integrating and deploying code changes to a third-party cloud application platform as well as testing, tracking, and managing code changes. </span><span class="koboSpan" id="kobo.200.3">GitHub Actions is compatible with various third-party CI/CD tools, the Docker container ecosystem, and other </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">automation technologies.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">GitHub Actions seamlessly integrates automation into the software development life cycle on GitHub through event-driven triggers. </span><span class="koboSpan" id="kobo.202.2">These triggers are events that can be specified, ranging from creating a pull request to building a new branch in a repository and much more. </span><span class="koboSpan" id="kobo.202.3">GitHub Actions automations are managed through workflows that are </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">YAML</span></strong><span class="koboSpan" id="kobo.204.1"> files located in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">.github/workflows</span></strong><span class="koboSpan" id="kobo.206.1"> directory of a repository. </span><span class="koboSpan" id="kobo.206.2">These workflows define automated processes and are analogues in concept to a </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">Jenkinsfile</span></strong><span class="koboSpan" id="kobo.208.1"> file in Jenkins or a </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">.gitlab-ci.yml</span></strong><span class="koboSpan" id="kobo.210.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">GitLab CI/CD.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Every workflow consists of several </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">core concepts:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.214.1">Events</span></strong><span class="koboSpan" id="kobo.215.1">: An event is a defined trigger</span><a id="_idIndexMarker371"/><span class="koboSpan" id="kobo.216.1"> that initiates a workflow. </span><span class="koboSpan" id="kobo.216.2">Developers can configure them to search for one or multiple triggers and then adjust them accordingly. </span><span class="koboSpan" id="kobo.216.3">Additionally, they can be configured to execute on specified code branches within a designated repository</span><a id="_idIndexMarker372"/> <span class="No-Break"><span class="koboSpan" id="kobo.217.1">on GitHub.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.218.1">Jobs</span></strong><span class="koboSpan" id="kobo.219.1">: A job consists of a series of sequential</span><a id="_idIndexMarker373"/><span class="koboSpan" id="kobo.220.1"> tasks executed on a single runner. </span><span class="koboSpan" id="kobo.220.2">Each task operates within its own virtual machine (VM) and runs concurrently with other tasks, unless </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">declared otherwise.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.222.1">Steps</span></strong><span class="koboSpan" id="kobo.223.1">: A step is an independent operation</span><a id="_idIndexMarker374"/><span class="koboSpan" id="kobo.224.1"> that executes commands within a job. </span><span class="koboSpan" id="kobo.224.2">These can serve as either an action or a shell command. </span><span class="koboSpan" id="kobo.224.3">Every step in a job is executed on the </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">same runner.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.226.1">Actions</span></strong><span class="koboSpan" id="kobo.227.1">: An action refers to a command</span><a id="_idIndexMarker375"/><span class="koboSpan" id="kobo.228.1"> that is executed on a runner and serves as the fundamental component of GitHub Actions, from which it derives </span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">its name.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.230.1">Runners</span></strong><span class="koboSpan" id="kobo.231.1">: A runner functions as a server</span><a id="_idIndexMarker376"/><span class="koboSpan" id="kobo.232.1"> for GitHub Actions. </span><span class="koboSpan" id="kobo.232.2">The program actively monitors available tasks, executes them concurrently, and provides updates on the progress, logs, and outcomes. </span><span class="koboSpan" id="kobo.232.3">Runners can be hosted either on GitHub or on a localized server that is self-hosted. </span><span class="koboSpan" id="kobo.232.4">GitHub Hosted runners utilize Ubuntu, Linux, Windows, and macOS as their underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">operating systems.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.234.1">The primary advantage of having a GitHub-native CI/CD tool is its simplicity. </span><span class="koboSpan" id="kobo.234.2">If you are already hosting a project on GitHub, you can utilize the built-in CI/CD tool because it fully integrates with your code repositories. </span><span class="koboSpan" id="kobo.234.3">CI/CD pipelines can be quite intricate, involving a wide array of tools for testing applications, integration tests, container platforms, and application</span><a id="_idIndexMarker377"/><span class="koboSpan" id="kobo.235.1"> platforms, among other components. </span><span class="koboSpan" id="kobo.235.2">GitHub Actions streamlines the whole process by offering frictionless integration with NodeJS and Docker. </span><span class="koboSpan" id="kobo.235.3">Notably, it enables you to quickly choose the desired dependency version and effortlessly connect your code to a desired environment and deployment platform of choice. </span><span class="koboSpan" id="kobo.235.4">Unlike other automation tools and features, GitHub Actions goes beyond the typical applications of testing, building, and deploying. </span><span class="koboSpan" id="kobo.235.5">Instead, it offers the flexibility to automate </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">any webhook.</span></span></p>
<h4><span class="koboSpan" id="kobo.237.1">GitHub Actions workflow syntax example</span></h4>
<p><span class="koboSpan" id="kobo.238.1">Now, let’s examine an example</span><a id="_idIndexMarker378"/><span class="koboSpan" id="kobo.239.1"> of a GitHub Actions pipeline to get a practical understanding of its syntax and how it can be configured! </span><span class="koboSpan" id="kobo.239.2">In the GitHub Actions </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">Workflow </span></strong><span class="koboSpan" id="kobo.241.1">file, a Docker container image is being built and the resulting artifact gets published to a designated </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">Docker registry:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.243.1"><img alt="Figure 6.3: Example GitHub Actions workflow – pipeline configured to build a Docker image" src="image/B21803_06_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.244.1">Figure 6.3: Example GitHub Actions workflow – pipeline configured to build a Docker image</span></p>
<p><span class="koboSpan" id="kobo.245.1">Now that we have established a basic understanding of the differences in syntax between these three tools, let’s compare the features of all three </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">CI tools.</span></span></p>
<h3><span class="koboSpan" id="kobo.247.1">A side-by-side feature comparison of all three CI tools</span></h3>
<p><span class="koboSpan" id="kobo.248.1">The following table provides a side-by-side</span><a id="_idIndexMarker379"/><span class="koboSpan" id="kobo.249.1"> comparison of the features and benefits offered by each of these three industry-leading CI tools: Jenkins, GitLab CI/CD, and GitHub Actions. </span><span class="koboSpan" id="kobo.249.2">The information presented is intended to help you evaluate which tool is the best choice for your operations based on your own unique requirements </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">and preferences.</span></span></p>
<table class="No-Table-Style" id="table001">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.251.1">Feature</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.252.1">Jenkins</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.253.1">GitLab CI/CD</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.254.1">GitHub Actions</span></strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.255.1">On-premises (self-hosted)</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.256.1">Yes</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.257.1">Yes</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.258.1">Runners only</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.259.1">Cloud-based</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.260.1">No</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.261.1">Yes</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.262.1">Yes</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.263.1">Open source</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.264.1">Yes</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.265.1">Yes</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.266.1">No</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.267.1">Closed source</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.268.1">No</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.269.1">Yes</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.270.1">Yes</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.271.1">Testing integration</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.272.1">Yes</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.273.1">Yes</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.274.1">Yes</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.275.1">Ease of setup </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">and configuration</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.277.1">Difficult</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.278.1">Moderate</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.279.1">Easy</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.280.1">Build </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">environment compatibility</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.282.1">Linux, Windows, </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">macOS, Unix</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.284.1">Linux, </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">Windows, macOS</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.286.1">Cloud SaaS</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.287.1">Language support</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.288.1">Any </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">contemporary language</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.290.1">C, C++, C#, Go, Java, JavaScript, PHP, Python, Ruby, Scala, TypeScript, </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">and others</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.292.1">C, C++, C#, Java, </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">JavaScript, PHP,</span></span></p>
<p><span class="koboSpan" id="kobo.294.1">Python, Ruby, Scala, </span><span class="No-Break"><span class="koboSpan" id="kobo.295.1">and TypeScript</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.296.1">Learning curve</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.297.1">Difficult</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.298.1">Moderate</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.299.1">Easy</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.300.1">Paid </span><span class="No-Break"><span class="koboSpan" id="kobo.301.1">plan features</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.302.1">No</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.303.1">Yes</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.304.1">Yes</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.305.1">VCS compatibility</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.306.1">Git</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.307.1">Mercurial (hg)</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.308.1">Subversion (svn)</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.309.1">Perforce (p4)</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.310.1">ClearCase</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.311.1">Microsoft TFS</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.312.1">Git</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.313.1">Git</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.314.1">Table 6.1: Feature comparison of Jenkins, GitLab, and GitHub Actions</span></p>
<p><span class="koboSpan" id="kobo.315.1">Code Integration, automated </span><a id="_idIndexMarker380"/><span class="koboSpan" id="kobo.316.1">builds, and integration testing are the three pillars of continuous integration. </span><span class="koboSpan" id="kobo.316.2">The ultimate objective of the continuous integration process is to generate a deployable artifact. </span><span class="koboSpan" id="kobo.316.3">This concludes our examination of continuous integration and CI tools. </span><span class="koboSpan" id="kobo.316.4">In the next section, we’ll discuss the counterpart to continuous integration, </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">continuous delivery.</span></span></p>
<h1 id="_idParaDest-101"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.318.1">What is continuous delivery (CD)?</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.319.1">Continuous delivery</span></strong><span class="koboSpan" id="kobo.320.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.321.1">CD</span></strong><span class="koboSpan" id="kobo.322.1">) refers to the process of automatically</span><a id="_idIndexMarker381"/><span class="koboSpan" id="kobo.323.1"> preparing code changes for release and deployment into a production environment. </span><span class="koboSpan" id="kobo.323.2">Continuous delivery is an essential component of DevOps release management and is often used in concert with continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">integration (CI).</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Even at the tail end of the </span><strong class="bold"><span class="koboSpan" id="kobo.326.1">software development life cycle</span></strong><span class="koboSpan" id="kobo.327.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.328.1">SDLC</span></strong><span class="koboSpan" id="kobo.329.1">), developers can successfully deploy most product</span><a id="_idIndexMarker382"/><span class="koboSpan" id="kobo.330.1"> code versions with </span><a id="_idIndexMarker383"/><span class="koboSpan" id="kobo.331.1">the help of CI/CD pipelines, along with a </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">version control system</span></strong><span class="koboSpan" id="kobo.333.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.334.1">VCS</span></strong><span class="koboSpan" id="kobo.335.1">). </span><span class="koboSpan" id="kobo.335.2">Continuous delivery enables programmers to automatically test code changes using multiple lenses (not just unit testing) before releasing them to customers. </span><span class="koboSpan" id="kobo.335.3">In this way, developers can have faith in the quality of the build artifacts they’re deploying, as they will have been subjected to rigorous testing and found to be in compliance with industry standards. </span><span class="koboSpan" id="kobo.335.4">API testing, load testing, functional and UI testing, integration testing, compliance testing, and others are all examples of appropriate types of testing that you would normally run in </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">this phase.</span></span></p>
<p><span class="koboSpan" id="kobo.337.1">As a result, software developers are empowered to rapidly evaluate for the existence of bugs and defects before a new software release can be permitted access to production environments. </span><span class="koboSpan" id="kobo.337.2">It is notable to mention that continuous delivery often includes the execution of multi-stage deployments, whereby artifacts undergo transitions across different stages, including QA, staging, pre-production, and ultimately production. </span><span class="koboSpan" id="kobo.337.3">Additional testing and verification steps are usually performed at each stage to ensure the reliability and legitimacy of the delivered artifacts. </span><span class="koboSpan" id="kobo.337.4">Post-release validation procedures and deployment monitoring can (and should) be implemented to further bolster the software release’s dependability </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">and resilience.</span></span></p>
<p><span class="koboSpan" id="kobo.339.1">Continuous delivery not only assumes the responsibilities of deploying applications, but also in making configuration modifications, monitoring application performance, and ensuring its ongoing maintenance. </span><span class="koboSpan" id="kobo.339.2">This is where building </span><strong class="bold"><span class="koboSpan" id="kobo.340.1">disaster recovery</span></strong><span class="koboSpan" id="kobo.341.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.342.1">DR</span></strong><span class="koboSpan" id="kobo.343.1">) into the pipeline design</span><a id="_idIndexMarker384"/><span class="koboSpan" id="kobo.344.1"> becomes key. </span><span class="koboSpan" id="kobo.344.2">That is because continuous delivery has the potential to expand its functional scope by including operational duties that may involve tasks</span><a id="_idIndexMarker385"/><span class="koboSpan" id="kobo.345.1"> such as infrastructure</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.346.1"> management. </span><span class="koboSpan" id="kobo.346.2">These tasks can be achieved using the </span><strong class="bold"><span class="koboSpan" id="kobo.347.1">infrastructure as code</span></strong><span class="koboSpan" id="kobo.348.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.349.1">IaC</span></strong><span class="koboSpan" id="kobo.350.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">configuration as code</span></strong><span class="koboSpan" id="kobo.352.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.353.1">CaC</span></strong><span class="koboSpan" id="kobo.354.1">) tools that were made especially for </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">this purpose.</span></span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.356.1">What is infrastructure as code (IaC)?</span></h2>
<p><span class="koboSpan" id="kobo.357.1">In the field of technology, the term infrastructure</span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.358.1"> has typically been associated with physical components such as rackmount servers, networking systems, and data centers. </span><span class="koboSpan" id="kobo.358.2">However, due to the proliferation of the cloud, this infrastructure has evolved beyond its physical constraints, transforming into virtual services and environments that can be rapidly created, modified, and decommissioned. </span><span class="koboSpan" id="kobo.358.3">Managing and provisioning these dynamic resources efficiently and reliably has become a significant challenge in this new era. </span><span class="koboSpan" id="kobo.358.4">This is where the notion of IaC becomes relevant. </span><span class="koboSpan" id="kobo.358.5">IaC tools have become crucial in tackling these challenges by enabling the management of infrastructure through code rather than manual processes. </span><span class="koboSpan" id="kobo.358.6">This method simplifies the act of building and maintaining virtual IT infrastructure, improves consistency, minimizes the risk of mistakes, and enables effortless automation </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">and scalability.</span></span></p>
<p><span class="koboSpan" id="kobo.360.1">It is for this reason that understanding the concept of idempotence is crucial in the context of IaC. </span><span class="koboSpan" id="kobo.360.2">When an IaC deployment is executed, it ensures that the target environment is consistently configured, regardless of its initial state. </span><span class="koboSpan" id="kobo.360.3">This is to say, idempotency can be achieved through two methods: automatically configuring the current target or discarding it and creating a new target environment </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">from scratch.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.362.1">Idempotency</span></p>
<p class="callout"><span class="koboSpan" id="kobo.363.1">Idempotency in data pipelines</span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.364.1"> refers to the ability to execute the same operation multiple times without changing the result beyond the initial application. </span><span class="koboSpan" id="kobo.364.2">This property ensures consistency and reliability, especially in </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">distributed systems.</span></span></p>
<p><span class="koboSpan" id="kobo.366.1">Notably, IaC has emerged as the preeminent solution to address the issue of configuration drift, both in release pipelines and virtualized deployment environments. </span><span class="koboSpan" id="kobo.366.2">Crucially, in the absence of IaC, teams would be required to manually manage environment and deployment configurations individually. </span><span class="koboSpan" id="kobo.366.3">When operating this way, over time, every environment inevitably develops its own distinct configuration that cannot be replicated automatically. </span><span class="koboSpan" id="kobo.366.4">Consequently, deployment issues can arise due to inconsistencies in different environments, such as dev, QA, staging, and production. </span><span class="koboSpan" id="kobo.366.5">Due to the reliance on manual processes, infrastructure administration and maintenance can be challenging, prone to errors, and difficult </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">to monitor.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.368.1">Configuration drift</span></p>
<p class="callout"><span class="koboSpan" id="kobo.369.1">The gradual alteration of an IT system’s configurations</span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.370.1"> over time is known as configuration drift. </span><span class="koboSpan" id="kobo.370.2">Drift most often happens unintentionally when modifications are made to software, hardware, or operating systems without proper documentation or approval. </span><span class="koboSpan" id="kobo.370.3">It can affect the safety and efficiency of a part or the whole of a system. </span><span class="koboSpan" id="kobo.370.4">Application failure, downtime, extended development life cycles, spikes in IT tickets, security vulnerabilities, audit fines, compliance failures, and more are all direct results of </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">configuration drift.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">Conversely, infrastructure as code leverages the advantages of the DevOps methodology and versioning to efficiently define and deploy various components of infrastructure. </span><span class="koboSpan" id="kobo.372.2">This includes networks, virtual machines, load balancers, DNS, serverless deployments, identity access management, and much more. </span><span class="koboSpan" id="kobo.372.3">You can think of IaC as software-defined infrastructure. </span><span class="koboSpan" id="kobo.372.4">Similarly to how the same source code consistently produces binaries with identical capabilities, an IaC model consistently generates the same environment with each deployment. </span><span class="koboSpan" id="kobo.372.5">IaC plays a crucial role in contemporary DevOps practices and is an integral part of continuous delivery. </span><span class="koboSpan" id="kobo.372.6">By utilizing IaC, DevOps teams can collaborate seamlessly using a standardized set of methods and resources to efficiently deploy applications and their corresponding</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.373.1"> infrastructure on a large scale, ensuring speed and reliability. </span><span class="koboSpan" id="kobo.373.2">Perhaps best of all, IaC files can be stored in Git and are </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">easily auditable.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">To accomplish this, IaC streamlines the configuration process and ensures uniformity by using declarative code in formats like YAML, JSON, and </span><strong class="bold"><span class="koboSpan" id="kobo.376.1">HashiCorp configuration language</span></strong><span class="koboSpan" id="kobo.377.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.378.1">HCL</span></strong><span class="koboSpan" id="kobo.379.1">) to represent desired environment</span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.380.1"> states. </span><span class="koboSpan" id="kobo.380.2">Release pipelines consume IaC files and apply the environment descriptions and versioned configuration models to set up target environments that are highly reliable and eliminate the runtime problems that arise from configuration inconsistencies or missing dependencies. </span><span class="koboSpan" id="kobo.380.3">Crucially, this allows the team to make edits to the source code rather than the </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">target directly.</span></span></p>
<p><span class="koboSpan" id="kobo.382.1">There are several popular tools</span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.383.1"> that have been developed to automate these kinds of tasks. </span><span class="koboSpan" id="kobo.383.2">In the following subsections, we’ll take a detailed look at four of the most common ones: Terraform, Pulumi, Ansible, </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">and Puppet.</span></span></p>
<h3><span class="koboSpan" id="kobo.385.1">Terraform</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.386.1">Terraform</span></strong><span class="koboSpan" id="kobo.387.1"> is a powerful infrastructure-as-code tool that allows</span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.388.1"> you to define cloud and on-prem resources using easily comprehended configuration files written in HCL. </span><span class="koboSpan" id="kobo.388.2">These files can be versioned, reused, and shared, making it a convenient choice for managing your infrastructure. </span><span class="koboSpan" id="kobo.388.3">You can apply a streamlined workflow to accurately establish and control your infrastructure at every stage of its </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">life cycle.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">Terraform has been designed to manage a wide range of components, from low-level ones such as computer, storage, and networking resources, to higher-level ones such as DNS entries, Kubernetes clusters, and SaaS features. </span><span class="koboSpan" id="kobo.390.2">Terraform seamlessly integrates with popular continuous integration and deployment systems like GitLab, GitHub Actions, and Jenkins. </span><span class="koboSpan" id="kobo.390.3">With this solution, you can optimize the entire process of deploying and managing your infrastructure, rapidly advancing from code </span><span class="No-Break"><span class="koboSpan" id="kobo.391.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.392.1">Terraform utilizes a plugin-based architecture to seamlessly interface with various cloud providers, including AWS, Google Cloud, and Azure. </span><span class="koboSpan" id="kobo.392.2">Every provider comes with a unique collection of plugins that enable Terraform to effectively handle its resources. </span><span class="koboSpan" id="kobo.392.3">Terraform processes the configuration files written in HCL and generates a dependency graph of the resources that require creation or modification. </span><span class="koboSpan" id="kobo.392.4">It then proceeds to execute a plan to create or modify the necessary resources to achieve the intended state. </span><span class="koboSpan" id="kobo.392.5">Terraform includes a state file that maintains the current state of </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">your infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">The Terraform workflow is incredibly straightforward, with just three simple steps to effectively manage any kind of infrastructure: write, plan, apply. </span><span class="koboSpan" id="kobo.394.2">One of the simplest workflows for managing any kind of infrastructure is Terraform’s three-step process. </span><span class="koboSpan" id="kobo.394.3">It allows users to customize the workflow according to their specific requirements and implementation style. </span><span class="koboSpan" id="kobo.394.4">To illustrate how Terraform works, let’s examine a sample Terraform plan that can be used to create</span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.395.1"> an EC2 instance </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">in AWS:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.397.1"><img alt="Figure 6.4: Example Terraform plan – configured to provision an AWS EC2 instance" src="image/B21803_06_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.398.1">Figure 6.4: Example Terraform plan – configured to provision an AWS EC2 instance</span></p>
<h3><span class="koboSpan" id="kobo.399.1">Pulumi</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.400.1">Pulumi</span></strong><span class="koboSpan" id="kobo.401.1"> is a cutting-edge IaC platform. </span><span class="koboSpan" id="kobo.401.2">It utilizes popular</span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.402.1"> programming languages such as TypeScript, JavaScript, Python, Go, .NET, Java, and markup languages like YAML, along with their respective ecosystems, to seamlessly interact with cloud resources. </span><span class="koboSpan" id="kobo.402.2">Pulumi’s comprehensive platform seamlessly integrates a downloadable CLI, runtime, libraries, and a hosted service to deploy virtual infrastructure. </span><span class="koboSpan" id="kobo.402.3">This flexible combination allows for efficient provisioning, updating, and management of </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">cloud infrastructure.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">Pulumi programs, written in popular programming languages, outline the composition of your cloud infrastructure. </span><span class="koboSpan" id="kobo.404.2">When adding new infrastructure to your program, you simply assign resource objects with properties that match the desired state of your infrastructure. </span><span class="koboSpan" id="kobo.404.3">These properties can be utilized to manage dependencies between resources and can be exported beyond the stack, </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">if required.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">The Pulumi platform is made </span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.407.1">up of </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">various components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.409.1">Pulumi software development kit</span></strong><span class="koboSpan" id="kobo.410.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.411.1">SDK</span></strong><span class="koboSpan" id="kobo.412.1">): This offers bindings for every resource type</span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.413.1"> that can be managed by the provider. </span><span class="koboSpan" id="kobo.413.2">This resource equips users with the essential tools and libraries to effectively define and oversee cloud resources across various providers </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">and platforms.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.415.1">Command-line interface</span></strong><span class="koboSpan" id="kobo.416.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.417.1">CLI</span></strong><span class="koboSpan" id="kobo.418.1">): This allows you to deploy updates</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.419.1"> to cloud applications and infrastructure. </span><span class="koboSpan" id="kobo.419.2">It maintains a record of team updates, including the contributors </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">and timestamps.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.421.1">Deployment engine</span></strong><span class="koboSpan" id="kobo.422.1">: The deployment engine calculates the necessary</span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.423.1"> operations to align your infrastructure’s current state with the desired state specified by </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">your program.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.425.1">Programs are stored in a project, which is a directory that holds the program’s source code and instructions on how to execute it. </span><span class="koboSpan" id="kobo.425.2">Once your program is complete, you can execute the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">Pulumi up</span></strong><span class="koboSpan" id="kobo.427.1"> command using the Pulumi CLI from your project directory. </span><span class="koboSpan" id="kobo.427.2">This command allows you to create a separate and customizable instance of your program, referred to as a stack. </span><span class="koboSpan" id="kobo.427.3">Stacks function</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.428.1"> as various deployment environments utilized for testing and implementing application updates. </span><span class="koboSpan" id="kobo.428.2">As an example, you can create and test separate development, staging, and </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">production stacks.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Here’s an example program that demonstrates the concepts. </span><span class="koboSpan" id="kobo.430.2">It creates an AWS EC2 security group called </span><strong class="source-inline"><span class="koboSpan" id="kobo.431.1">web-sg</span></strong><span class="koboSpan" id="kobo.432.1"> with one ingress rule and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">t2.micro-sized</span></strong><span class="koboSpan" id="kobo.434.1"> EC2 instance that uses that security group. </span><span class="koboSpan" id="kobo.434.2">The EC2 resource needs the ID of the security group to utilize it. </span><span class="koboSpan" id="kobo.434.3">Pulumi facilitates this by utilizing the output property name on the security group resource. </span><span class="koboSpan" id="kobo.434.4">Pulumi has a deep understanding of resource dependencies, allowing it to optimize parallelism and maintain the correct order when a stack </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">is created.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">Finally, the IP address and DNS name</span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.437.1"> of the server are exported as stack outputs for easy access through a CLI command or by </span><span class="No-Break"><span class="koboSpan" id="kobo.438.1">another stack.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.439.1"><img alt="Figure 6.5: Example Pulumi code – configured to provision an AWS EC2 instance" src="image/B21803_06_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.440.1">Figure 6.5: Example Pulumi code – configured to provision an AWS EC2 instance</span></p>
<h3><span class="koboSpan" id="kobo.441.1">Ansible</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.442.1">Ansible</span></strong><span class="koboSpan" id="kobo.443.1"> is an open source configuration management</span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.444.1"> tool that offers a streamlined server automation framework using YAML definitions. </span><span class="koboSpan" id="kobo.444.2">Ansible has gained immense popularity as a configuration management tool due to its simplified infrastructure requirements and </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">user-friendly syntax.</span></span></p>
<p><span class="koboSpan" id="kobo.446.1">Unlike other tools in its category, such as Chef or Puppet, Ansible does not need any specialized software (agents) to be installed on remote nodes. </span><span class="koboSpan" id="kobo.446.2">A control machine is configured with the Ansible software, enabling it to communicate with the nodes through standard SSH protocols, and Python is enlisted to execute the </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">remote instructions.</span></span></p>
<p><span class="koboSpan" id="kobo.448.1">A task is the smallest unit of action you can automate using an Ansible playbook. </span><span class="koboSpan" id="kobo.448.2">Playbooks typically contain a series of tasks that serve a goal, such as setting up a web server or deploying an application to remote environments. </span><span class="koboSpan" id="kobo.448.3">Ansible executes tasks in the same order they are defined inside a playbook. </span><span class="koboSpan" id="kobo.448.4">Before automating a procedure, such as setting up a LAMP server (Linux, Apache, MySQL, PHP), you’ll need to assess which manual steps are necessary and the order in which they must be completed to get everything done. </span><span class="koboSpan" id="kobo.448.5">You’ll then be able to determine which tasks you’ll need and which modules you can use to reach your goals in </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">fewer steps.</span></span></p>
<p><span class="koboSpan" id="kobo.450.1">Furthermore, Ansible offers a comprehensive range of pre-built modules that streamline the process of automating routine server operations. </span><span class="koboSpan" id="kobo.450.2">These modules cover a wide array of tasks, including package installation, user management, file manipulation, permission handling, and </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">service management.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">To illustrate how Ansible works, let’s examine a sample Ansible play that can be used to create an EC2 instance </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">in AWS:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.454.1"><img alt="Figure 6.6: Example Ansible play – configured to provision an AWS EC2 instance" src="image/B21803_06_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.455.1">Figure 6.6: Example Ansible play – configured to provision an AWS EC2 instance</span></p>
<h3><span class="koboSpan" id="kobo.456.1">Puppet</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.457.1">Puppet</span></strong><span class="koboSpan" id="kobo.458.1"> is a configuration management tool</span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.459.1"> that utilizes its own declarative language for describing infrastructure state. </span><span class="koboSpan" id="kobo.459.2">Puppet’s language is designed to efficiently handle every life cycle stage of IT infrastructure. </span><span class="koboSpan" id="kobo.459.3">This includes tasks such as provisioning, patching, configuration, and management of operating systems and application components in both data centers and </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">cloud infrastructures.</span></span></p>
<p><span class="koboSpan" id="kobo.461.1">Puppet is specifically designed to handle the configuration of Unix-like and Microsoft Windows systems. </span><span class="koboSpan" id="kobo.461.2">To accomplish this, a user assigns system resources and their state, utilizing either </span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.462.1">Puppet’s declarative language or a Ruby </span><strong class="bold"><span class="koboSpan" id="kobo.463.1">domain-specific language</span></strong><span class="koboSpan" id="kobo.464.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.465.1">DSL</span></strong><span class="koboSpan" id="kobo.466.1">). </span><span class="koboSpan" id="kobo.466.2">In doing so, the infrastructure configurations get stored</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.467.1"> in configuration files referred to as Puppet manifests. </span><span class="koboSpan" id="kobo.467.2">When executed, the Puppet utility will compile the Puppet manifests into a system-specific catalog that includes resources and their dependencies. </span><span class="koboSpan" id="kobo.467.3">This catalog can then be applied to the target systems, and the response from Puppet’s actions is reported to </span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.469.1">Puppet typically adheres to a client-server architecture. </span><span class="koboSpan" id="kobo.469.2">In this case, the</span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.470.1"> client is referred to as an agent, while the server is commonly</span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.471.1"> referred to as the master. </span><span class="koboSpan" id="kobo.471.2">Additionally, it can function as a standalone application that can be executed from the command line, making it convenient for testing and basic configuration purposes. </span><span class="koboSpan" id="kobo.471.3">Puppet Server is usually installed on multiple servers, while Puppet Agent gets installed on all of the machines that need to be managed. </span><span class="koboSpan" id="kobo.471.4">In this way, Puppet agents communicate with the server to retrieve configuration instructions so that they can be deployed. </span><span class="koboSpan" id="kobo.471.5">The agent proceeds to implement the configuration on the targeted systems and promptly sends a comprehensive status report to the server. </span><span class="koboSpan" id="kobo.471.6">Notably, machines have the capability to run the Puppet agent as a daemon, which can be scheduled to run periodically as a Cron job or can be manually executed </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">as required.</span></span></p>
<p><span class="koboSpan" id="kobo.473.1">To illustrate how Puppet works, let’s examine a sample Puppet manifest that can be used to create an EC2 instance </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">in AWS:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.475.1"><img alt="Figure 6.7: Example Ansible play – configured to provision an AWS EC2 instance" src="image/B21803_06_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.476.1">Figure 6.7: Example Ansible play – configured to provision an AWS EC2 instance</span></p>
<h3><span class="koboSpan" id="kobo.477.1">What is the difference between infrastructure as code (IaC) and configuration as code (CaC)?</span></h3>
<p><span class="koboSpan" id="kobo.478.1">Although there are similarities</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.479.1"> between IaC and CaC, they</span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.480.1"> also have notable differences. </span><span class="koboSpan" id="kobo.480.2">As asserted previously, IaC is predominantly used for deploying virtual infrastructure, including server instances, storage devices, and networking components, as well as any additional resources and permissions needed. </span><span class="koboSpan" id="kobo.480.3">In contrast, configuration as code tools follow up on this by configuring and customizing operating systems, application configurations, and monitoring devices after the infrastructure has been generated using IaC tooling. </span><span class="koboSpan" id="kobo.480.4">This activity is used to automate the creation of computing systems precisely tailored to meet the specific requirements and objectives of a client or business. </span><span class="koboSpan" id="kobo.480.5">These two types of automation tools have unique strengths that make them suitable for specific use cases or when </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">used together.</span></span></p>
<p><span class="koboSpan" id="kobo.482.1">To help you understand the difference, here is an analogy. </span><span class="koboSpan" id="kobo.482.2">Infrastructure as code can be thought of as using tools to construct an office building, while configuration as code is a set of tools used to furnish the office building with the equipment and resources that a business needs to actually get </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">work done.</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">Notably, when integrating cloud-based deployments, software developers have the ability to easily and affordably create multiple testing environments and iterate them. </span><span class="koboSpan" id="kobo.484.2">Historically, when working in on-premises environments, it was much more difficult to dynamically create test environments, but this is no longer the case. </span><span class="koboSpan" id="kobo.484.3">Cleverly, computer hardware manufacturers, such as HP, Dell, and SuperMircro, have made many improvements to their product designs that modernize the on-prem experience. </span><span class="koboSpan" id="kobo.484.4">These days, most rack-mount servers have APIs embedded into their firmware with native integrations for the commonly used IaC and CaC tools on the market. </span><span class="koboSpan" id="kobo.484.5">This gives on-premises hardware similar</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.485.1"> functionality to their cloud-based</span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.486.1"> competitors, enabling them to remain relevant in a </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">competitive landscape.</span></span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.488.1">The continuous delivery pipeline</span></h2>
<p><span class="koboSpan" id="kobo.489.1">The primary characteristic</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.490.1"> of a legitimate CD pipeline is its ability to facilitate software deployment at any stage of its life cycle. </span><span class="koboSpan" id="kobo.490.2">Put another way, well-architected CI/CD pipeline infrastructure should ensure that any application version can be easily deployed to the designated testing, staging, or production environments with only a few mouse clicks and with absolute idempotence. </span><span class="koboSpan" id="kobo.490.3">Furthermore, development teams should be able to receive prompt feedback from automated tests being conducted in any environment, and this feedback should be leveraged to facilitate product improvements and greater </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">operational efficiency.</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">The continuous delivery pipeline has five </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">primary phases:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.494.1"><img alt="Figure 6.8: The five common phases of continuous delivery" src="image/B21803_06_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.495.1">Figure 6.8: The five common phases of continuous delivery</span></p>
<p><span class="koboSpan" id="kobo.496.1">This figure represents the five most common</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.497.1"> phases in a continuous delivery strategy: commit, test, build, stage, and deploy. </span><span class="koboSpan" id="kobo.497.2">As you can see, the cycle is designed to be short, promoting the shortest possible interval from when a new code change is committed, to version control, to the time it takes to see it deployed in production. </span><span class="koboSpan" id="kobo.497.3">Beyond that, there are several validation steps in between to ensure the highest quality possible. </span><span class="koboSpan" id="kobo.497.4">This includes the ability to build the code, which can be seen as a form of testing in its </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">own right.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">Notably, it is far easier to achieve continuous deployment workflows in a product-centric company rather than a services-focused company. </span><span class="koboSpan" id="kobo.499.2">The reason for this is that service companies must tailor their solutions to each individual client, whereas a product company is aligned with a narrow scope of </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">value streams.</span></span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.501.1">The difference between continuous delivery and continuous deployment</span></h2>
<p><span class="koboSpan" id="kobo.502.1">In the context of DevOps release</span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.503.1"> management, the terms continuous delivery and continuous deployment denote two tiers </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">of automation.</span></span></p>
<p><span class="koboSpan" id="kobo.505.1">With continuous delivery, the need for the manual deployment of new code is reduced, saving both time and resources. </span><span class="koboSpan" id="kobo.505.2">First, the code is written, then automatically tested, then approved, and finally pushed to a repository where other engineers can access it. </span><span class="koboSpan" id="kobo.505.3">When the code is complete, the operations team can quickly fetch it and effortlessly deploy it to live application environments using kiosk-like, </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">self-serve functionality.</span></span></p>
<p><span class="koboSpan" id="kobo.507.1">This diagram depicts the differences between the continuous delivery and continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">deployment sequences:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.509.1"><img alt="Figure 6.9: Continuous delivery versus continuous deployment" src="image/B21803_06_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.510.1">Figure 6.9: Continuous delivery versus continuous deployment</span></p>
<p><span class="koboSpan" id="kobo.511.1">As you can see, there is one defining feature that distinguishes the two: deploying to production. </span><span class="koboSpan" id="kobo.511.2">With continuous delivery, there is a manual approval step that is enforced before new code changes are permitted to be deployed into production environments. </span><span class="koboSpan" id="kobo.511.3">With continuous deployment, automated testing fulfills this role so that no manual human intervention </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">is necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">By expanding the automation</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.514.1"> of continuous delivery to the next stage of the </span><strong class="bold"><span class="koboSpan" id="kobo.515.1">software development life cycle</span></strong><span class="koboSpan" id="kobo.516.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.517.1">SDLC</span></strong><span class="koboSpan" id="kobo.518.1">), continuous deployment can help reduce the workload of operations teams and speed up the delivery of applications. </span><span class="koboSpan" id="kobo.518.2">Any auxiliary software release procedures will often get automated too, reducing or eliminating the extent of manual human interaction. </span><span class="koboSpan" id="kobo.518.3">For instance, a continuous deployment pipeline might be set up to deploy new releases after being committed into a Git repository and deployed into the production environment so that customers can take advantage of it as early </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.520.1">Continuous deployment is substantially</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.521.1"> harder to implement than continuous delivery since it eliminates the need for any kind of human intervention throughout the process of deploying authorized software products into production environments. </span><span class="koboSpan" id="kobo.521.2">This means that in order to achieve true continuous deployment, your automated testing regimen must be prolific, interoperable, </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">and extensible.</span></span></p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.523.1">How GitOps fits in with continuous delivery</span></h2>
<p><span class="koboSpan" id="kobo.524.1">Some notable distinctions</span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.525.1"> exist between GitOps and DevOps. </span><span class="koboSpan" id="kobo.525.2">Perhaps the most</span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.526.1"> significant aspect is that GitOps places even greater emphasis on the use of automation and tooling in order to effectively manage and distribute code modifications. </span><span class="koboSpan" id="kobo.526.2">Conversely, DevOps places greater emphasis on fostering effective communication and collaboration among team members. </span><span class="koboSpan" id="kobo.526.3">Another distinction is that GitOps is widely used in tandem with containerization technologies such as Kubernetes, whereas DevOps can be applied to a variety of other types of </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">application deployments.</span></span></p>
<p><span class="koboSpan" id="kobo.528.1">It is important to recognize that GitOps is a specialized domain within the broader field of DevOps that centers around the use of Git repositories for the purpose of effectively managing infrastructure state and application deployments. </span><span class="koboSpan" id="kobo.528.2">A vital distinction between GitOps and DevOps is that with GitOps, the Git repository serves as the single authoritative source of truth for the deployment state of applications and infrastructure. </span><span class="koboSpan" id="kobo.528.3">In this way, the Git repository acts as a ledger or is similar in concept to </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">a blockchain.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">Another key thing to grasp is that GitOps relies heavily on pull-based deployment as its primary method of implementation. </span><span class="koboSpan" id="kobo.530.2">With conventional DevOps approaches, continuous integration and continuous delivery pipelines are triggered by an external event, such as when new code is pushed to the application repository. </span><span class="koboSpan" id="kobo.530.3">With GitOps, instead of pushing out new code every time there’s a change in the environment, the pull-based strategy keeps the application current by actively comparing the currently deployed application state with the ideal application deployment state as declared in the version control repository. </span><span class="koboSpan" id="kobo.530.4">If any discrepancy is detected between the two, the GitOps operator updates the live infrastructure to match the configurations declared in the </span><span class="No-Break"><span class="koboSpan" id="kobo.531.1">designated repository.</span></span></p>
<p><span class="koboSpan" id="kobo.532.1">Cleverly, pull-based deployments make it easy to roll back unstable software deployments to the last known stable version in the event of an issue. </span><span class="koboSpan" id="kobo.532.2">Additionally, pull-based techniques are declarative, making advanced deployment strategies, such as blue/green and canary deployments, effortless </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">to implement.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.534.1">Blue/green deployments</span></p>
<p class="callout"><span class="koboSpan" id="kobo.535.1">Blue/green deployments produce two identical</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.536.1"> environments. </span><span class="koboSpan" id="kobo.536.2">One environment (blue) runs the existing program version and one (green) runs the new one. </span><span class="koboSpan" id="kobo.536.3">After testing passes on the green environment, live application traffic is directed there, and the blue environment is deprecated. </span><span class="koboSpan" id="kobo.536.4">By simplifying rollbacks if deployments fail, blue/green deployment strategies boost application availability and reduce </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">deployment risk.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">Since GitOps deployments are immutable, it is easy to reset any arbitrary or undocumented modifications to the live infrastructure. </span><span class="koboSpan" id="kobo.538.2">It enforces a complete audit trail of all changes in the Git log and helps</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.539.1"> avoid direct cluster changes that could result in inconsistencies</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.540.1"> in the </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">system’s state.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.542.1">Canary deployments</span></p>
<p class="callout"><span class="koboSpan" id="kobo.543.1">A canary deployment refers to a gradual</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.544.1"> and controlled release strategy for an application, wherein traffic is divided between an existing version and a new version. </span><span class="koboSpan" id="kobo.544.2">This approach involves initially introducing the new version to a subset of users before expanding its deployment to the entire user base. </span><span class="koboSpan" id="kobo.544.3">By following this approach, one can determine the reliability of the updated version of the application prior to its widespread distribution </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">to consumers.</span></span></p>
<h1 id="_idParaDest-106"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.546.1">What is continuous testing?</span></h1>
<p><span class="koboSpan" id="kobo.547.1">By now, you should have a firm grasp</span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.548.1"> on the importance of automated testing, at least based on the number of times the subject has been mentioned. </span><span class="koboSpan" id="kobo.548.2">The emphasis on how important automated testing is to DevOps release management cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">be overstated.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.550.1">Continuous testing</span></strong><span class="koboSpan" id="kobo.551.1"> is a practice within the broader context</span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.552.1"> of CI/CD that contributes to software quality throughout the development life cycle. </span><span class="koboSpan" id="kobo.552.2">Using carefully curated automated testing strategies, continuous testing ensures that software development teams get real-time feedback, allowing them to rapidly eliminate as many potential risks and flaws as possible and as soon as possible, spanning the entire software development life cycle. </span><span class="koboSpan" id="kobo.552.3">Furthermore, teammates will be properly equipped to continuously gain new insights into their products and ways that they can </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">be improved.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">However, implementing continuous testing in your organization is not a straightforward process because you must come up with a testing strategy that ensures a change will move forward without triggering any false positives. </span><span class="koboSpan" id="kobo.554.2">Like continuous deployment, it is far more difficult to implement continuous testing than it might sound, as they are part and parcel with one another. </span><span class="koboSpan" id="kobo.554.3">Traditionally, testing software was carried out for the very first time after the code had been written and then forwarded to the Quality Assurance team to be tested independently. </span><span class="koboSpan" id="kobo.554.4">When errors were discovered in the code, it got handed back to the developers so that they could correct it. </span><span class="koboSpan" id="kobo.554.5">This testing model is practical to a reasonable extent in an era when slower development cycles were acceptable. </span><span class="koboSpan" id="kobo.554.6">However, it is challenging, tedious, and fraught with potential for disruption and human error. </span><span class="koboSpan" id="kobo.554.7">Instead, contemporary organizations require prompt delivery of products that are of superior quality because this is what customers have grown to expect in today’s competitive digital marketplace. </span><span class="koboSpan" id="kobo.554.8">If the resources exist to implement it properly, there is no better way to test in a DevOps-centric organization </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">than continuously.</span></span></p>
<p><span class="koboSpan" id="kobo.556.1">Therein lies the value of conducting testing on an ongoing basis. </span><span class="koboSpan" id="kobo.556.2">Bugs can be found and fixed before more work is done if code is tested immediately after being added to the repository. </span><span class="koboSpan" id="kobo.556.3">It would then be unnecessary to make future code modifications addressing a bug fix because their existence would be avoided in the first place. </span><span class="koboSpan" id="kobo.556.4">In our modern age, developers even benefit from automated </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.557.1">testing plugins that install directly into a developer’s local </span><strong class="bold"><span class="koboSpan" id="kobo.558.1">integrated development environment</span></strong><span class="koboSpan" id="kobo.559.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.560.1">IDE</span></strong><span class="koboSpan" id="kobo.561.1">), such as Eclipse, Microsoft Visual Studio, and PyCharm. </span><span class="koboSpan" id="kobo.561.2">This gives developers the opportunity to detect and fix issues as they write and before code ever gets committed to source control in the </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">first place.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">Quality assurance of customer-facing software requires thorough end-to-end testing that exercises the entire system, this will help you verify that your app is performing as expected. </span><span class="koboSpan" id="kobo.563.2">End-to-end testing necessitates that real data and environments be used for the most reliable results. </span><span class="koboSpan" id="kobo.563.3">You will be better positioned to find and fix problems with the code when using mock data that is representative of real-world production data. </span><span class="koboSpan" id="kobo.563.4">Leveraging this information, you can learn more about the app’s real-world performance by simulating it in real-world testing conditions. </span><span class="koboSpan" id="kobo.563.5">As a side note, this philosophy is core to the ethos of implementing canary deployments, exposing a small percentage of users to vetted pre-release versions </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">Effective continuous testing requires both continuous integration and continuous delivery. </span><span class="koboSpan" id="kobo.565.2">Many steps in the testing process, such as code construction, deployment, and analysis, can be automated with the help of CI/CD tools. </span><span class="koboSpan" id="kobo.565.3">New features and bug fixes can be released more quickly while still meeting high standards of quality when using CI/CD and DevOps release management. </span><span class="koboSpan" id="kobo.565.4">Keep an eye on test results and user feedback to ensure your software is continually getting better. </span><span class="koboSpan" id="kobo.565.5">This data will help you spot problems in your process and make the necessary adjustments to improve them. </span><span class="koboSpan" id="kobo.565.6">Maintaining high-quality software requires maintaining</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.566.1"> high-quality awareness of test results </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.568.1">In the following section, we’ll examine the case study of how the financial institution Capital One made the most of CI/CD while conducting its own </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">DevOps transformation.</span></span></p>
<h1 id="_idParaDest-107"><a id="_idTextAnchor108"/><span class="koboSpan" id="kobo.570.1">The DevOps transformation of Capital One</span></h1>
<p><span class="koboSpan" id="kobo.571.1">In 2010, Capital One acknowledged</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.572.1"> their customers’ preferences for online and mobile banking. </span><span class="koboSpan" id="kobo.572.2">In light of this, executive leadership decided to enhance the business’s technological capabilities and establish a culture that would attract and grow a workforce of highly skilled technologists with a knack for collaborative development. </span><span class="koboSpan" id="kobo.572.3">Prudently, Capital One prioritized the recruitment of these hearty souls and made sure they were working closely with relevant decision-makers who consummately understood the business requirements. </span><span class="koboSpan" id="kobo.572.4">Shortly after, the company embraced agile software development techniques that eventually became the basis for implementing DevOps release management at </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">the company.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">Promptly addressing customer feedback has always been the top concern at Capital One. </span><span class="koboSpan" id="kobo.574.2">Therefore, DevOps emerged as the logical option for development teams to attain accelerated development and deployment cycles. </span><span class="koboSpan" id="kobo.574.3">Between 2012 and 2020, Capital One experienced a series </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">of transformations:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.576.1">Embracing </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">agile practices</span></span></li>
<li><span class="koboSpan" id="kobo.578.1">Creating automated </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">test cases</span></span></li>
<li><span class="koboSpan" id="kobo.580.1">Automating deployments and tests </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">using CI/CD</span></span></li>
<li><span class="koboSpan" id="kobo.582.1">Migrating operations to public </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">cloud providers</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.584.1">Through these modifications, the bank transformed</span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.585.1"> into an organization that embraced open source solutions and rapid delivery cycles. </span><span class="koboSpan" id="kobo.585.2">In 2020, Capital made history by becoming the first US bank to transfer the entirety of its legacy on-premises data centers to public </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">cloud providers.</span></span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor109"/><span class="koboSpan" id="kobo.587.1">Capital One’s DevOps transformation strategy</span></h2>
<p><span class="koboSpan" id="kobo.588.1">Despite starting with a handful</span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.589.1"> of employees, Capital One aimed to establish a company-wide DevOps approach. </span><span class="koboSpan" id="kobo.589.2">Over time, the corporation implemented its DevOps initiatives architected with a </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">three-phased approach.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.591.1"><img alt="Figure 6.10: Capitol One’s three-phase DevOps transformation" src="image/B21803_06_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.592.1">Figure 6.10: Capitol One’s three-phase DevOps transformation</span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor110"/><span class="koboSpan" id="kobo.593.1">Creating cross-functional teams</span></h2>
<p><span class="koboSpan" id="kobo.594.1">Capital One began implementing</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.595.1"> DevOps by assigning specialized and versatile SWAT</span><em class="italic"> </em><span class="koboSpan" id="kobo.596.1">teams to two of its older applications within the company. </span><span class="koboSpan" id="kobo.596.2">These cross-functional teams magnanimously implemented configuration management and automation of essential functions and optimized the workflow of these two applications. </span><span class="koboSpan" id="kobo.596.3">Following that, each team continued to assert ownership of the delivery process for their designated application. </span><span class="koboSpan" id="kobo.596.4">This strategy was repeated for four additional applications at Capitol One before management encouraged the rest of the company’s development teams to implement these newly discovered </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">best practices.</span></span></p>
<p><span class="koboSpan" id="kobo.598.1">Notably, Capital One’s ability to establish common objectives was greatly enhanced by the presence of a cross-functional team and excellent leadership during the earliest stages of their DevOps Journey. </span><span class="koboSpan" id="kobo.598.2">It was also beneficial for developers and operation teams to acquire essential DevOps skills needed</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.599.1"> to influence others and proliferate the culture across </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">the organization.</span></span></p>
<h2 id="_idParaDest-110"><a id="_idTextAnchor111"/><span class="koboSpan" id="kobo.601.1">Leveraging microservices architecture</span></h2>
<p><span class="koboSpan" id="kobo.602.1">Like other businesses that existed during</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.603.1"> the dot com era, Capital One</span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.604.1"> used a monolithic design while architecting its technology stack. </span><span class="koboSpan" id="kobo.604.2">Over time, their projects began to expand, making it necessary to consider future requirements. </span><span class="koboSpan" id="kobo.604.3">As a result, the bank dedicated additional resources to thoroughly examine the microservices architecture and its applicability to </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">their organization.</span></span></p>
<p><span class="koboSpan" id="kobo.606.1">At Capital One, the primary objective was to enhance delivery speed while maintaining high-quality standards. </span><span class="koboSpan" id="kobo.606.2">The development team chose to use automated deployments that align with their established quality standards. </span><span class="koboSpan" id="kobo.606.3">They established strict and clear rules for software deployment and modifications </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">to production.</span></span></p>
<p><span class="koboSpan" id="kobo.608.1">The team at Capital One has implemented immutable stages in their </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">pipeline delivery:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.610.1">Implementing effective source </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">control management</span></span></li>
<li><span class="koboSpan" id="kobo.612.1">Implementing a safe place to store application and </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">binary data</span></span></li>
<li><span class="koboSpan" id="kobo.614.1">Implementing robust privileged access management </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">and authorization</span></span></li>
<li><span class="koboSpan" id="kobo.616.1">Ensuring that quality and safety checks are </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">regularly performed</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.618.1">Each application team was obligated to fulfill these requirements prior to releasing their code to the production environment. </span><span class="koboSpan" id="kobo.618.2">In the end, the benefits that Capital One received because of implementing microservice architectures were </span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.620.1">Asymmetric </span><span class="No-Break"><span class="koboSpan" id="kobo.621.1">service deployments</span></span></li>
<li><span class="koboSpan" id="kobo.622.1">Infinitely </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">scalable applications</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.624.1">High availability</span></span></li>
<li><span class="koboSpan" id="kobo.625.1">Logical separation of duties </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">and responsibilities</span></span></li>
<li><span class="koboSpan" id="kobo.627.1">Improved </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">error handling</span></span></li>
</ul>
<h2 id="_idParaDest-111"><a id="_idTextAnchor112"/><span class="koboSpan" id="kobo.629.1">Building an on-demand infrastructure on AWS</span></h2>
<p><span class="koboSpan" id="kobo.630.1">After receiving feedback</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.631.1"> from customers, product</span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.632.1"> managers at Capital One</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.633.1"> focused their efforts on enhancing the quality of the banking and financial services to provide customers with an exceptional experience. </span><span class="koboSpan" id="kobo.633.2">Exactly for this reason, the organization adopted a cloud-first policy, and its architects moved the newly developed applications to </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">the cloud.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">The development team at Capital One was able to obtain valuable user insights and respond more quickly thanks to the following Amazon Web </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">Services tools:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.637.1">Virtual private </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.638.1">cloud</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.639.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.640.1">VPC</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.642.1">Simple storage </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.643.1">service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.644.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.645.1">S3</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.647.1">Elastic compute </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.648.1">cloud</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.649.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.650.1">EC2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.651.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.652.1">Relational database </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.653.1">service</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.654.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.655.1">RDS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.656.1">)</span></span></li>
</ul>
<h2 id="_idParaDest-112"><a id="_idTextAnchor113"/><span class="koboSpan" id="kobo.657.1">Automating delivery pipelines using Jenkins</span></h2>
<p><span class="koboSpan" id="kobo.658.1">Capital One employs a range of pipelines</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.659.1"> to thoroughly scan</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.660.1"> and test its code, ensuring</span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.661.1"> high-quality standards across the company. </span><span class="koboSpan" id="kobo.661.2">In addition, a similar procedure is carried out to ensure expedited delivery. </span><span class="koboSpan" id="kobo.661.3">The code updates go through a thorough process of automated testing, which includes integration tests, unit tests, security scanning, and quality checks. </span><span class="koboSpan" id="kobo.661.4">The release is deployed automatically by the pipeline after the code successfully passes all the tests. </span><span class="koboSpan" id="kobo.661.5">By ensuring uninterrupted service, users can enjoy a seamless experience while teams can effortlessly </span><span class="No-Break"><span class="koboSpan" id="kobo.662.1">deploy updates.</span></span></p>
<p><span class="koboSpan" id="kobo.663.1">The development team utilized Jenkins, a widely used tool for creating continuous integration and delivery pipelines. </span><span class="koboSpan" id="kobo.663.2">In taking this approach, Capital One was able to avoid the need to create its own integration process from scratch. </span><span class="koboSpan" id="kobo.663.3">The Jenkins-based pipeline efficiently breaks down the entire development process into stages and further divides them into additional steps, such as application build, integration testing, and deployment. </span><span class="koboSpan" id="kobo.663.4">Notably, Capitol One employs boilerplate tools that are used to accelerate the creation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">Jenkinsfiles</span></strong><span class="koboSpan" id="kobo.665.1"> for expediting the development of </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">various applications.</span></span></p>
<p><span class="koboSpan" id="kobo.667.1">Jenkins has allowed Capital One</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.668.1"> to streamline software</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.669.1"> delivery, enhance</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.670.1"> operational stability, and provide a better experience for </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">developers overall.</span></span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor114"/><span class="koboSpan" id="kobo.672.1">Governance within Capitol One’s CI/CD pipelines</span></h2>
<p><span class="koboSpan" id="kobo.673.1">Capital One aimed to achieve a culture</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.674.1"> of fearless releases to promote creative thinking. </span><span class="koboSpan" id="kobo.674.2">However, this also necessitated the adoption of a mindset where individuals take responsibility for the decisions they make and their roles in software delivery. </span><span class="koboSpan" id="kobo.674.3">Tapabrata “Topo” Pal, a well-known strategist and DevOps evangelist, and his team</span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.675.1"> implemented the concept of </span><strong class="bold"><span class="koboSpan" id="kobo.676.1">clean room</span></strong><span class="koboSpan" id="kobo.677.1"> development at Capital One. </span><span class="koboSpan" id="kobo.677.2">They modified the concept for the software development life cycle to embrace a culture of courageousness </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">and accountability.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.679.1">Clean room</span></p>
<p class="callout"><span class="koboSpan" id="kobo.680.1">The term “clean room” refers to an engineered</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.681.1"> space that keeps the concentration of airborne particulates very low. </span><span class="koboSpan" id="kobo.681.2">It has active cleansing, good isolation, and good contamination control. </span><span class="koboSpan" id="kobo.681.3">These types of rooms are usually required for industrial production for all nanoscale processes, including semiconductor manufacturing, as well as for scientific research. </span><span class="koboSpan" id="kobo.681.4">Dust and other airborne organisms, such as vaporized particles, are to be kept away from a cleanroom in order to protect the materials being handled </span><span class="No-Break"><span class="koboSpan" id="kobo.682.1">inside it.</span></span></p>
<p><span class="koboSpan" id="kobo.683.1">A set of clear guidelines to guarantee code quality before release can be considered the company’s virtual development clean room. </span><span class="koboSpan" id="kobo.683.2">These policies cover procedures such as locating and registering each product pipeline, vetting and inspecting each version of the code, restricting access to production servers, and so forth. </span><span class="koboSpan" id="kobo.683.3">To put it simply, the clean room approach emphasizes preventing defects rather than eliminating them. </span><span class="koboSpan" id="kobo.683.4">In the end, Capital One utilized a clean room model to detect and address issues across different product pipelines, guaranteeing quality right from the beginning. </span><span class="koboSpan" id="kobo.683.5">After all, an ounce of prevention is worth a pound </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">of cure.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">The following illustration describes Capital One’s “Clean Room” DevOps release management methodology in its entirety. </span><span class="koboSpan" id="kobo.685.2">This process begins with the development phase, where application code is kept in version control management. </span><span class="koboSpan" id="kobo.685.3">Then, a series of security measures are enforced, such as restricting access to binaries and including static code analysis. </span><span class="koboSpan" id="kobo.685.4">The focus of this section is to ensure that the code being written is stored with integrity, confidentiality, </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">and availability.</span></span></p>
<p><span class="koboSpan" id="kobo.687.1">Further along in the clean room process is the testing phase. </span><span class="koboSpan" id="kobo.687.2">This step ensures end-to-end traceability of the quality assurance procedures, starting with tying functional test activity to their respective user stories. </span><span class="koboSpan" id="kobo.687.3">From there, the product owner works hand-in-hand with the development team to ensure that all critical testing is performed and </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">properly documented.</span></span></p>
<p><span class="koboSpan" id="kobo.689.1">The final two phases in the clean</span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.690.1"> room process include implementation and monitoring. </span><span class="koboSpan" id="kobo.690.2">In these steps, the production process is for peak performance, including testing the deployment scripts, approving changes, vetting rollback procedures, freezing source code, and restricting access controls to automated processes. </span><span class="koboSpan" id="kobo.690.3">Finally, a release is cut and deployed to the production environment and proper application monitoring is conducted. </span><span class="koboSpan" id="kobo.690.4">Have a look at the diagram of the </span><span class="No-Break"><span class="koboSpan" id="kobo.691.1">entire process:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.692.1"><img alt="Figure 6.11: Capital One’s clean room release methodology" src="image/B21803_06_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.693.1">Figure 6.11: Capital One’s clean room release methodology</span></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor115"/><span class="koboSpan" id="kobo.694.1">Implementing chaos engineering</span></h2>
<p><span class="koboSpan" id="kobo.695.1">Even with multiple access controls</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.696.1"> and safeguards, software</span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.697.1"> deployment can sometimes become chaotic. </span><span class="koboSpan" id="kobo.697.2">Cloud failures can be unpredictable and unavoidable, and they can pose risks in certain situations, such as availability zone blackouts. </span><span class="koboSpan" id="kobo.697.3">One could argue that continuous delivery also brings about the possibility of continuous chaos. </span><span class="koboSpan" id="kobo.697.4">Capital One has a dedicated team focused on addressing that specific issue. </span><span class="koboSpan" id="kobo.697.5">No one wants to accidentally automate their </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">own destruction.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">Conventional methods struggle to anticipate every possible failure scenario caused by intricate request patterns, unpredictable data conditions, and more. </span><span class="koboSpan" id="kobo.699.2">In 2017, Capital One took inspiration from Netflix and introduced its own form of </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">chaos engineering.</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">The company implemented</span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.702.1"> a disruption-causing tool called “Cloud Detour” to assess the resiliency of the applications that they build. </span><span class="koboSpan" id="kobo.702.2">At this stage, the development team intentionally subjects mission-critical applications to various failure scenarios for testing purposes. </span><span class="koboSpan" id="kobo.702.3">This aids in developing solutions that guarantee sufficient resiliency and function as a powerful disaster </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">recovery exercise.</span></span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor116"/><span class="koboSpan" id="kobo.704.1">Embedding security principles in DevOps workflows</span></h2>
<p><span class="koboSpan" id="kobo.705.1">At first, Capital One adhered</span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.706.1"> to a labor-intensive and time-consuming security certification</span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.707.1"> process. </span><span class="koboSpan" id="kobo.707.2">Nevertheless, the company</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.708.1"> quickly recognized the significance of fortifying container environments to enhance its encryption and overall security posture across all systems services within </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">the business.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">Consequently, Capital One integrated automated security checks into its DevOps pipeline. </span><span class="koboSpan" id="kobo.710.2">It facilitated the accelerated evaluation of misconfigurations and vulnerabilities in their containers and virtual machine images. </span><span class="koboSpan" id="kobo.710.3">The DevOps team quickly obtained API privileges for vulnerability management and policy compliance tools that could be implemented into the CI/CD process. </span><span class="koboSpan" id="kobo.710.4">This allowed them to conduct essential tests, acquire reports, and initiate corrective measures without requiring the involvement of the </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">security team.</span></span></p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor117"/><span class="koboSpan" id="kobo.712.1">What can we learn from Capital One’s DevOps transformation?</span></h2>
<p><span class="koboSpan" id="kobo.713.1">As you can see, there are a lot of great</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.714.1"> insights that we might gain from studying how Capitol One achieved its DevOps Transformation. </span><span class="koboSpan" id="kobo.714.2">Among the numerous improvements that were made, some </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">stand out:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.716.1">A DevOps transformation can take a long time. </span><span class="koboSpan" id="kobo.716.2">In the case of Capitol One, they started in 2010 and didn’t reach a state of maturity until 2020. </span><span class="koboSpan" id="kobo.716.3">That is an entire decade. </span><span class="koboSpan" id="kobo.716.4">Be prepared to commit to such long time horizons before reaping the rewards. </span><span class="koboSpan" id="kobo.716.5">They do call it a journey for </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">a reason.</span></span></li>
<li><span class="koboSpan" id="kobo.718.1">Speed is crucial in meeting the ever-shifting requirements of users. </span><span class="koboSpan" id="kobo.718.2">That is exactly what you can accomplish with the help of internal team collaboration and </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">process automation.</span></span></li>
<li><span class="koboSpan" id="kobo.720.1">Embracing DevOps practices and fostering team collaborations can inspire a culture of innovation and continuous experimentation. </span><span class="koboSpan" id="kobo.720.2">Adopting a fail-fast mindset will lead you to a practical solution in </span><span class="No-Break"><span class="koboSpan" id="kobo.721.1">no time.</span></span></li>
<li><span class="koboSpan" id="kobo.722.1">Implementing continuous monitoring practices can help your organization accomplish superior outcomes together with scalability, even if your processes initially had a </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">sluggish start.</span></span></li>
<li><span class="koboSpan" id="kobo.724.1">Centralizing delivery tooling streamlines the development and management of each team’s tech stack, eliminating the need for individual silos. </span><span class="koboSpan" id="kobo.724.2">Minimizing redundant work and promoting resource sharing </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">maximizes efficiency.</span></span></li>
<li><span class="koboSpan" id="kobo.726.1">Cloud infrastructure allows for the flexible utilization of resources. </span><span class="koboSpan" id="kobo.726.2">As a result, you can easily expand and adapt to changing needs </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">without limitations.</span></span></li>
<li><span class="koboSpan" id="kobo.728.1">Thoroughly examine all current development processes and establish a standard of quality to attain optimal outcomes. </span><span class="koboSpan" id="kobo.728.2">Then, streamline quality control processes to reduce human error</span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.729.1"> and facilitate </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">DevOps compliance.</span></span></li>
</ul>
<h1 id="_idParaDest-117"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.731.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.732.1">This concludes </span><a href="B21803_06.xhtml#_idTextAnchor095"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.733.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.734.1">. </span><span class="koboSpan" id="kobo.734.2">In our discussion, you’ve learned the basics of CI/CD from a release manager’s perspective. </span><span class="koboSpan" id="kobo.734.3">You now grasp how continuous integration incentivizes developers to continuously push their code to source control repositories, unifying their work into a single release. </span><span class="koboSpan" id="kobo.734.4">From there, we’ve reviewed why continuous delivery is such a powerful companion to continuous integration. </span><span class="koboSpan" id="kobo.734.5">Then, we examined all of the appropriate stages of a continuous delivery pipeline, and how it differs from a continuous deployment pipeline. </span><span class="koboSpan" id="kobo.734.6">Furthermore, you have become familiar with GitOps, a contemporary DevOps strategy that amplifies the concept of continuous deployment by introducing pull-based deployment tactics. </span><span class="koboSpan" id="kobo.734.7">Finally, we’ve examined continuous testing, the premier quality assurance strategy for any DevOps-centric </span><span class="No-Break"><span class="koboSpan" id="kobo.735.1">software organization.</span></span></p>
<p><span class="koboSpan" id="kobo.736.1">In the next chapter, you will be shown how to build a docker image containing a simple web application that deploys to AWS EC2, using </span><span class="No-Break"><span class="koboSpan" id="kobo.737.1">GitHub Actions.</span></span></p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.738.1">Questions</span></h1>
<p><span class="koboSpan" id="kobo.739.1">Answer the following questions to test your knowledge of </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">this chapter:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.741.1">Can CI/CD pipelines be used to automate more than just the activities required for releasing and </span><span class="No-Break"><span class="koboSpan" id="kobo.742.1">deploying software?</span></span></li>
<li><span class="koboSpan" id="kobo.743.1">Why do software development teams need a unified set of technologies to work with in order to attain </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">peak productivity?</span></span></li>
<li><span class="koboSpan" id="kobo.745.1">What is the benefit of increasing </span><span class="No-Break"><span class="koboSpan" id="kobo.746.1">commit frequency?</span></span></li>
<li><span class="koboSpan" id="kobo.747.1">What is a continuous integration server and what does </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">it do?</span></span></li>
<li><span class="koboSpan" id="kobo.749.1">What is the primary difference between continuous delivery and </span><span class="No-Break"><span class="koboSpan" id="kobo.750.1">continuous deployment?</span></span></li>
<li><span class="koboSpan" id="kobo.751.1">What are the five primary phases of a continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.752.1">delivery pipeline?</span></span></li>
<li><span class="koboSpan" id="kobo.753.1">What is GitOps and how is it different </span><span class="No-Break"><span class="koboSpan" id="kobo.754.1">from DevOps?</span></span></li>
<li><span class="koboSpan" id="kobo.755.1">What is the distinction between automated testing and </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">continuous testing?</span></span></li>
<li><span class="koboSpan" id="kobo.757.1">What is the best way for software developers to detect and fix bugs or defects in their code before it ever gets committed in the </span><span class="No-Break"><span class="koboSpan" id="kobo.758.1">first place?</span></span></li>
<li><span class="koboSpan" id="kobo.759.1">What do canary deployments have in common with </span><span class="No-Break"><span class="koboSpan" id="kobo.760.1">continuous testing?</span></span></li>
</ol>
</div>
</body></html>