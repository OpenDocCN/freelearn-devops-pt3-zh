<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-94"><a id="_idTextAnchor098"/><a id="_idTextAnchor099"/>6</h1>
<h1 id="_idParaDest-95"><a id="_idTextAnchor100"/>Networking in Linux</h1>
<p>Networking is a complex topic no matter the operating system. Linux, in terms of its flexibility, can be very overwhelming regarding the multitude of possibilities of configuration, kernel features, and command-line tools that can help us configure those options. In this chapter, we will lay the foundation for this topic so that you can search for more information on a specific topic in other publications. In this chapter, we are going to cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Networking <span class="No-Break">in Linux</span></li>
<li>ISO/OSI as a <span class="No-Break">networking standard</span></li>
<li><span class="No-Break">Firewalls</span></li>
<li><span class="No-Break">Advanced topics</span></li>
</ul>
<h1 id="_idParaDest-96"><a id="_idTextAnchor101"/>Networking in Linux</h1>
<p>In Linux, networking<a id="_idIndexMarker381"/> is implemented in the kernel, which means that it is a part of the operating system. The kernel<a id="_idIndexMarker382"/> includes several components that work together to enable networking, including device drivers, protocol implementations, and <span class="No-Break">system calls.</span></p>
<p>When a user wants to send or receive data over a network, they can do so using any of the networking applications available in Linux, such as <strong class="source-inline">ping</strong>, <strong class="source-inline">traceroute</strong>, <strong class="source-inline">telnet</strong>, or <strong class="source-inline">ssh</strong>. These applications use system calls to communicate with the kernel and request that data be sent or received over <span class="No-Break">the network.</span></p>
<p>The kernel communicates with the network hardware using device drivers, which are software programs that allow the kernel to access and control the hardware. Different drivers are needed for different types of network hardware, such as Ethernet <span class="No-Break">or Wi-Fi.</span></p>
<p>The kernel also implements several networking protocols, which are rules and standards that define how data is formatted and transmitted over the network. Common protocols used in Linux include TCP, UDP, and IP (version <strong class="source-inline">4</strong> and <span class="No-Break">version </span><span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">)<a id="_idTextAnchor102"/>.</span></p>
<h1 id="_idParaDest-97">ISO/OSI as a networking standard</h1>
<p>The <a id="_idIndexMarker383"/>starting point of any discussion about networks always starts with the reference model defined by the <strong class="bold">International Organization for Standardization/Open Systems Interconnection</strong> (<strong class="bold">ISO/OSI</strong>). The ISO/OSI reference model is a conceptual model that defines a networking framework to implement protocols in seven layers. It is a framework that allows us to view communications between systems (computer or otherwise) as separate from the actual physical and software structure <span class="No-Break">underlying it.</span></p>
<p>In Linux, the OSI model is implemented through a series of software components that are responsible for performing the functions of each layer. These components work together to enable networking capabilities <span class="No-Break">in Linux.</span></p>
<p>The seven layers of the OSI model<a id="_idIndexMarker384"/> that are implemented in Linux are <span class="No-Break">as follows:</span></p>
<ul>
<li><span class="No-Break">Physical</span></li>
<li><span class="No-Break">Data link</span></li>
<li><span class="No-Break">Network</span></li>
<li><span class="No-Break">Transport</span></li>
<li><span class="No-Break">Session</span></li>
<li><span class="No-Break">Presentation</span></li>
<li><span class="No-Break">Application</span></li>
</ul>
<p>In a system running in the cloud, you will have access to all the layers that are implemented in the Linux kernel. These layers are Network, Transport. Session, Presentation, and Application. To debug network connectivity, check statistics, and find any other possible issues, Linux has a console tool you can use. Let’s go through every layer one by one and investigate what command-line tools we can use in Linux to investigate each <span class="No-Break">of them.</span></p>
<p>To learn more about the <a id="_idIndexMarker385"/>OSI model, you can refer to <a href="https://osi-model.com/">https://osi-model.com/</a>. We are going to delve into the layers and explain them in the <span class="No-Break">following subsecti<a id="_idTextAnchor103"/>ons.</span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor104"/>Physical layer</h2>
<p>This <a id="_idIndexMarker386"/>layer is <a id="_idIndexMarker387"/>responsible for transmitting raw bits over a communication channel and is implemented through device drivers that control the network hardware, such as Ethernet standards such as <strong class="source-inline">10BASE-T</strong>, <strong class="source-inline">10BASE2</strong>, <strong class="source-inline">10BASE5</strong>, <strong class="source-inline">100BASE-TX</strong>, <strong class="source-inline">100BASE-FX</strong>, <strong class="source-inline">100BASE-T</strong>, <strong class="source-inline">1000BASE-T</strong>, and others. We will not look at this layer in more detail here as we will focus on software implementation and how to interact with it on the Linux console. You can find plenty of information about cabling, hardware devices, and <span class="No-Break">networking o<a id="_idTextAnchor105"/>nline.</span></p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor106"/>Data link layer – MAC, VLAN</h2>
<p>The <strong class="bold">data link layer</strong> is<a id="_idIndexMarker388"/> responsible for providing a reliable link between<a id="_idIndexMarker389"/> devices on a network. It’s <a id="_idIndexMarker390"/>divided into the <strong class="bold">Logical Link Control</strong> (<strong class="bold">LLC</strong>) sublayer<a id="_idIndexMarker391"/> and the <strong class="bold">Media Access Control</strong> (<span class="No-Break"><strong class="bold">MAC</strong></span><span class="No-Break">) sublayer.</span></p>
<p>The data link layer takes the raw data from the network layer (layer 3) and converts it into a format that can be transmitted over the physical link. It also provides error detection and correction, flow control, and <span class="No-Break">MAC functions.</span></p>
<p>The LLC sublayer <a id="_idIndexMarker392"/>provides a consistent interface to the network layer, regardless of the type of physical network being used. It also provides flow control and error <span class="No-Break">correction services.</span></p>
<p>The MAC sublayer <a id="_idIndexMarker393"/>controls access to the physical network and provides addressing services. It uses MAC addresses, which are unique identifiers that are assigned to each device on a network, to ensure that data is delivered to the <span class="No-Break">correct destination.</span></p>
<p>The data link layer also includes the use of protocols such as Ethernet, PPP, and Frame Relay to provide communication between devices on a network. It also provides a mechanism for flow and error control – for example, it uses a <strong class="bold">cyclic redundancy check</strong> (<strong class="bold">CRC</strong>) for error <a id="_idIndexMarker394"/>detection and a sliding window for <span class="No-Break">flow control.</span></p>
<p>Several Linux command-line tools can be used to debug data link layer problems. Here are a <span class="No-Break">few examples:</span></p>
<ul>
<li><strong class="source-inline">ifconfig</strong>: This<a id="_idIndexMarker395"/> command can be used to view the status of network interfaces and their associated IP addresses, netmasks, and MAC addresses. It can also be used to configure network interfaces, such as setting an IP address or enabling or disabling <span class="No-Break">an interface.</span></li>
<li><strong class="source-inline">ping</strong>: This<a id="_idIndexMarker396"/> command can be used to test the reachability of a host on a network. It sends<a id="_idIndexMarker397"/> an <strong class="bold">Internet Control Message Protocol</strong> (<strong class="bold">ICMP</strong>) echo request packet to the specified host and waits for an echo reply. If the host responds, it indicates that the host is reachable and that the data link layer is <span class="No-Break">functioning properly.</span></li>
<li><strong class="source-inline">traceroute</strong>, <strong class="source-inline">tracepath</strong>, and <strong class="source-inline">mtr</strong>: These commands can be used to trace the route that<a id="_idIndexMarker398"/> packets take from the source to the destination. They can also be used to identify any network hops or devices that may be causing problems. Additionally, <strong class="source-inline">tracepath</strong> measures the <strong class="bold">Maximum Transmit Unit</strong> (<strong class="bold">MTU</strong>) you can use for this <a id="_idIndexMarker399"/>connection. <strong class="source-inline">mtr</strong>, on the other hand, provides more<a id="_idIndexMarker400"/> information about <span class="No-Break">network health.</span></li>
<li><strong class="source-inline">arp</strong>: This <a id="_idIndexMarker401"/>command can be used to view and manipulate the <strong class="bold">Address Resolution Protocol</strong> (<strong class="bold">ARP</strong>) cache. ARP is used to map an IP address to a MAC address on a<a id="_idIndexMarker402"/> local network. This command can be used to verify that the correct IP-MAC address mappings are in the <span class="No-Break">ARP cache.</span></li>
<li><strong class="source-inline">ethtool</strong>: This<a id="_idIndexMarker403"/> command can be used to view and configure advanced settings on Ethernet interfaces such as link speed, duplex mode, and <span class="No-Break">auto-negotiation settings.</span></li>
<li><strong class="source-inline">tcpdump</strong>: This <a id="_idIndexMarker404"/>command can be used to capture and analyze network packets in real time. It can be used to troubleshoot problems such as packet loss, delayed packets, and <span class="No-Break">network congestion.</span></li>
</ul>
<p>We will dive deeper into the preceding tools in the next sections of this chapter as most of them can be used to look into several differ<a id="_idTextAnchor107"/>ent OSI layers <span class="No-Break">at once.</span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor108"/>Network layer – IPv4 and IPv6</h2>
<p>Each device on a <a id="_idIndexMarker405"/>public (internet) or private (your office or home) network has a unique <a id="_idIndexMarker406"/>address that is used to identify it and connect to it. When you send a request to a website, your device sends a message to the destination server using its address. The server then responds by sending a message back to your device using its address. This process is how devices communicate <a id="_idIndexMarker407"/>with each other over the internet. There are two types of <a id="_idIndexMarker408"/>addresses we<a id="_idIndexMarker409"/> use: IPv6 and IPv4. <strong class="bold">IP</strong> stands for <strong class="bold">Internet Protocol</strong> and the main difference between <strong class="source-inline">v4</strong> (version <strong class="source-inline">4</strong>) and <strong class="source-inline">v6</strong> (version <strong class="source-inline">6</strong>) is the number of addresses you <span class="No-Break">can use.</span></p>
<p>IPv4 is the most widely used version of IP and there are only about 4.3 billion unique addresses available. However, this is not enough to support the increasing number of devices that are being connected to the internet. To address this issue, a new version of IP called IPv6 was developed to provide a much larger <span class="No-Break">address space.</span></p>
<p>IPv4 addresses are 32-bit numbers that are usually represented in a dotted decimal notation, with four octets ranging from <strong class="source-inline">0</strong> to <strong class="source-inline">255</strong>. For example, <strong class="source-inline">192.168.0.1</strong> or <strong class="source-inline">1.2.3.4</strong> are valid <span class="No-Break">IPv4 addresses.</span></p>
<p>IPv6 addresses are 128-bit numbers (between <strong class="source-inline">zero</strong> and <strong class="source-inline">FFFF</strong> in hexadecimal, which is equal to the decimal value <strong class="source-inline">65535</strong>), represented in hexadecimal notation with eight groups of four hexadecimal digits separated by colons. An example of an IPv6 address <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">2001:0db8:bad:f00d:0000:dead:beef:7331</strong></span><span class="No-Break">.</span></p>
<p>We’re mainly going to focus on IPv4 here as it’s generally easier to understand, but similar principles work for IPv6, so it’s going to be easier to reapply what we’ll learn later in this chapte<a id="_idTextAnchor109"/>r to the <span class="No-Break">IPv6 world.</span></p>
<h3>Subnets, classes, and network masks</h3>
<p><strong class="bold">Subnets</strong> are<a id="_idIndexMarker410"/> pieces of a network that are created by dividing a larger network into smaller networks. This is done for several reasons, including security, organization, and the efficient use of IP addresses. In public internet networks, every organization <em class="italic">owns</em> a piece of the network – <span class="No-Break">a subnet.</span></p>
<p>When a network is subnetted, the host portion of the IP address (the part of the address that identifies a specific device on the network) is divided into two parts: one that identifies the subnet and one that identifies the host IPs within the subnet. The subnet mask, which is a binary representation that is applied to the IP address, is used to determine which part of the IP address identifies the<a id="_idIndexMarker411"/> subnet and which part identifies <span class="No-Break">the host.</span></p>
<p>Imagine a network that uses the IP address range <strong class="source-inline">192.168.11.0/24</strong> (or <strong class="source-inline">192.168.11.0/255.255.255.0</strong> in decimal form). The <strong class="source-inline">/24</strong> part is a <strong class="bold">Classless Inter-Domain Routing</strong> (<strong class="bold">CIDR</strong>) notation, which <a id="_idIndexMarker412"/>is a decimal representation of the number of bits used for the network (here, this is <strong class="source-inline">24</strong>) <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">host</strong></span><span class="No-Break">.</span></p>
<p>This means that this particular network has 24 bits (or three numbers from the full address) for the <strong class="source-inline">network</strong> portion of the IP address and 8 bits (or one, last, number) for the <strong class="source-inline">host</strong> portion. So, for this network, you’ll have an available range of <strong class="source-inline">192.168.11.0 - 192.168.11.255</strong>, where <strong class="source-inline">192.168.11.0</strong> is a network address and <strong class="source-inline">192.168.11.255</strong> is a <span class="No-Break">broadcast address.</span></p>
<p>A <strong class="bold">broadcast network address</strong> is a special type of IP address that is used to send a message to all hosts on a<a id="_idIndexMarker413"/> particular network or subnet. The broadcast address is the highest in a network or subnet’s IP address range, and it is used in conjunction with the subnet mask to identify the broadcast domain. When a host sends a packet to a broadcast address, the packet is delivered to all hosts on the same network or subnet. It’s important to note that broadcast packets don’t leave the current subnet network – they only work within the local network <span class="No-Break">or subnet.</span></p>
<p>Before standardizing CIDR, IP addresses were divided into classes (<strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, and <strong class="source-inline">C</strong>) based on the number of hosts that a network needed to support. These classes were defined by the leading bits of the IP <a id="_idIndexMarker414"/>address, and each class had a different number of bits for the network portion and host portion of the IP <a id="_idIndexMarker415"/>address. Right now, we’re mainly using CIDRs, but some network addressing remains. For example, <strong class="source-inline">10.0.0.0</strong>, <strong class="source-inline">12.0.0.0</strong>, or <strong class="source-inline">15.0.0.0</strong> usually have <strong class="source-inline">255.0.0.0</strong> or <strong class="source-inline">/8</strong> network masks. Here are some other networks you <span class="No-Break">could encounter:</span></p>
<ul>
<li><strong class="bold">Class A</strong>: <strong class="source-inline">10.0.0.0/8</strong>, <strong class="source-inline">12.0.0.0/8</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">15.0.0.0/8</strong></span></li>
<li><strong class="bold">Class B</strong>: <strong class="source-inline">172.16.0.0/16</strong>, <strong class="source-inline">172.17.0.0/16</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">172.18.0.0/16</strong></span></li>
<li><strong class="bold">Class C</strong>: <strong class="source-inline">192.168.0.0/24</strong>, <strong class="source-inline">192.168.1.0/24</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">192.168.2.0/24</strong></span></li>
</ul>
<p>These examples are not actual networks, but just a representation of how to identify the network class by looking at the leading bits of the IP address and the subnet mask – it’s not a rule and you could create smaller (or bigger) networks within <span class="No-Break">your infrastructure.</span></p>
<p>You can find a lot of calculators<a id="_idIndexMarker416"/> online that will help you better understand how networks address work. Here are <span class="No-Break">some examples:</span></p>
<ul>
<li><a href="https://www.calculator.net/ip-subnet-calculator.xhtml"><span class="No-Break">https://www.calculator.net/ip-subnet-calculator.xhtml</span></a></li>
<li><a href="https://mxtoolbox.com/subnetcalculator.aspx"><span class="No-Break">https://mxtoolbox.com/subnetcalculator.aspx</span></a></li>
<li><a href="https://www.subnet-calculator.com/cidr.php"><span class="No-Break">https://www.subnet-calculator.com/cidr.php</span></a></li>
</ul>
<p>Now that we have learned about subnets, classes, and network masks, le<a id="_idTextAnchor110"/>t’s move on to the <span class="No-Break">next subsection.</span></p>
<h3>Network configuration and console tools</h3>
<p>With the knowledge you’ve gained so far, you can easily check your Linux network configuration using some CLI tools that are available in every modern <span class="No-Break">Linux environment.</span></p>
<p>Here are <a id="_idIndexMarker417"/>some basic<a id="_idIndexMarker418"/> console tools to use for <span class="No-Break">network configuration:</span></p>
<ul>
<li>The <strong class="source-inline">iproute2</strong> package, replacing the <strong class="source-inline">ifconfig</strong> and <span class="No-Break"><strong class="source-inline">route</strong></span><span class="No-Break"> commands</span></li>
<li><span class="No-Break"><strong class="source-inline">ifconfig</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">route</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">ip</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">netplan</strong></span></li>
</ul>
<p>Let’s go through the syntax and wha<a id="_idTextAnchor111"/>t’s possible while using <span class="No-Break">these tools.</span></p>
<h4>ifconfig</h4>
<p>One of the commands that’s<a id="_idIndexMarker419"/> usually available in Linux is <strong class="source-inline">ifconfig</strong>. This tool is used to <a id="_idIndexMarker420"/>configure network interfaces. It can be used to show the status of an interface, assign an IP address to an interface, set the netmask, and set the default gateway. <strong class="source-inline">ifconfig</strong> (from the net-tools package) was replaced in recent years with the <strong class="source-inline">iproute2</strong> set of tools; the most well-known CLI command from this package <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">ip</strong></span><span class="No-Break">.</span></p>
<p>Here’s <a id="_idIndexMarker421"/>some <a id="_idIndexMarker422"/>example <a id="_idIndexMarker423"/>output of the <span class="No-Break"><strong class="source-inline">ifconfig</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ ifconfig
eth0: flags=4163&lt;UP,BRODCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)
        RX packets 17433  bytes 26244858 (26.2 MB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 8968  bytes 488744 (488.7 KB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</pre>
<p><strong class="source-inline">ifconfig</strong>, when<a id="_idIndexMarker424"/> invoked without any additional options, will<a id="_idIndexMarker425"/> list all available interfaces in our system with some basic information such as<a id="_idIndexMarker426"/> interface name (here, these are <strong class="source-inline">eth0</strong> and <strong class="source-inline">lo</strong>), the MAC address of the network card (the physical address of your device), network configuration (IP address, network mask, and broadcast address), received and transmitted packets, and other information. This will allow you to check your network status at <span class="No-Break">a glance.</span></p>
<p>The loopback device (named <strong class="source-inline">lo</strong> in the preceding example) is a virtual network interface that is used to send network packets to the same host that they were sent from. It is also known as the loopback interface and is represented by <strong class="source-inline">lo</strong> <span class="No-Break">or</span><span class="No-Break"><strong class="source-inline"> lo0</strong></span><span class="No-Break">.</span></p>
<p>The primary purpose of the loopback device is to provide a stable and consistent way for the host to communicate with itself over the network stack, without having to rely on any physical <span class="No-Break">network interface.</span></p>
<p>The loopback interface is typically used for testing, troubleshooting, and some system and application functions, as well<a id="_idIndexMarker427"/> as <strong class="bold">inter-process communication</strong> (<strong class="bold">IPC</strong>) between processes running on the <span class="No-Break">same host.</span></p>
<p>Using <strong class="source-inline">ifconfig</strong> will also allow you to bring some interfaces up and down and configure their settings. To persist the configuration, you will need to save it to the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">etc/network/interfaces</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
auto lo
iface lo inet loopback
# eth0 network device
auto eth0
iface eth0 inet static
    address 172.17.0.2
    netmask 255.255.0.0
    gateway 172.17.0.1
    dns-nameservers 8.8.8.8 4.4.4.4
auto eth1
allow-hotplug eth1
iface eth1 inet dhcp</pre>
<p>In the <a id="_idIndexMarker428"/>preceding example, we’re setting an automatic loopback <a id="_idIndexMarker429"/>device with <strong class="source-inline">eth0</strong> and <strong class="source-inline">eth1</strong>. The <strong class="source-inline">eth0</strong> interface has a static network configuration and will be also configured, the same as <strong class="source-inline">lo</strong>, when your system boots. The <strong class="source-inline">eth1</strong> interface has a dynamic network <a id="_idIndexMarker430"/>configuration that’s retrieved by the <strong class="bold">Dynamic Host Configuration Protocol</strong> (<strong class="bold">DHCP</strong>) server in the<a id="_idIndexMarker431"/> network it’s connected to. (DHCP is a widely used and de facto standard way to automatically and dynamically assign a system IP address; it is also possible to pass some other configuration parameters related to networking through DHCP.) Additional <strong class="source-inline">allow-hotplug</strong> configuration means that this device will be started upon detection by the <span class="No-Break">Linux kernel.</span></p>
<p>It’s useful to know that after editing the <strong class="source-inline">/etc/network/interfaces</strong> file, you’ll need to use either <strong class="source-inline">ifup</strong> or <strong class="source-inline">ifdown</strong> tools on Debian Linux or Ubuntu Linux, or <strong class="source-inline">ifupdown</strong> tools in Alpine Linux. Alternatively, you can restart networking by using the <strong class="source-inline">systemctl restart</strong> network on Debian Linux, Ubuntu Linux, or RHEL/CentOS. You must use the <strong class="source-inline">rc-service</strong> networking <strong class="source-inline">restart</strong> command on <span class="No-Break">Alpine Linux.</span></p>
<p>To manually configure a device using <strong class="source-inline">ifconfig</strong>, you’ll need to run the <span class="No-Break">following commands:</span></p>
<pre class="console">
admin@myhome:~$ ifconfig eth0 192.168.1.2 netmask 255.255.255.0
admin@myhome:~$ ifconfig eth0 up</pre>
<p>This will configure the <strong class="source-inline">eth0</strong> interface with a <strong class="source-inline">192.168.1.2</strong> IP address for the network with a netmask of <strong class="source-inline">255.255.255.0</strong> (or <strong class="source-inline">/24</strong> in <span class="No-Break">CIDR notation).</span></p>
<p>Instead of <a id="_idIndexMarker432"/>using the <strong class="source-inline">ifconfig up</strong> and <strong class="source-inline">ifconfig down</strong> commands, you <a id="_idIndexMarker433"/>can also use <strong class="source-inline">ifup</strong> and <strong class="source-inline">ifdown</strong> in Debian Linux and Ubuntu Linux syste<a id="_idTextAnchor112"/>ms, respectively, or <strong class="source-inline">ifupdown</strong> in Arch <span class="No-Break">Linux systems.</span></p>
<h4>route</h4>
<p>The <strong class="source-inline">route</strong> command<a id="_idIndexMarker434"/> is used to view and manipulate the IP routing table. It’s used to <a id="_idIndexMarker435"/>determine where network packets are sent given the destination<a id="_idIndexMarker436"/> <span class="No-Break">IP addresses.</span></p>
<p>Invoking the <strong class="source-inline">route</strong> command without any options will display the current route table in <span class="No-Break">our system:</span></p>
<pre class="console">
admin@myhome:~$ route
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
default       172.17.0.1      0.0.0.0         UG    0      0        0 eth0
172.17.0.0      0.0.0.0       255.255.0.0     U     0      0       0 eth0</pre>
<p>To <a id="_idIndexMarker437"/>add a new<a id="_idIndexMarker438"/> entry to the routing table, use the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ sudo route add default gw 172.17.0.1 eth0</pre>
<p>There can be only one default route. To add a custom route, do <span class="No-Break">the following:</span></p>
<pre class="console">
admin@myhome:~$ sudo route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.1.1 dev eth0</pre>
<p>The <strong class="source-inline">del</strong> command<a id="_idIndexMarker439"/> deletes an entry from the routing table, similar to the <span class="No-Break">preceding example:</span></p>
<pre class="console">
admin@myhome:~$ route del -net 192.168.1.0 gw 192.168.1.1 netmask 255.255.255.0 dev eth0</pre>
<p>Finally, the <strong class="source-inline">flush</strong> command<a id="_idIndexMarker440"/> deletes all entries from the routing table, which means you will lose all network connections and if you are connected to a remote machine, you won’t be able to work on <span class="No-Break">it anymore.</span></p>
<p>There are<a id="_idIndexMarker441"/> more possibilities while using the <strong class="source-inline">ifconfig</strong> and <strong class="source-inline">route</strong> commands, but as we’ve already stated, both commands got replaced by the <strong class="source-inline">iproute2</strong> pack<a id="_idTextAnchor113"/>age (a successor of <strong class="source-inline">iproute</strong>), which includes the <span class="No-Break"><strong class="source-inline">ip</strong></span><span class="No-Break"> command.</span></p>
<h4>iproute2</h4>
<p>A more advanced <a id="_idIndexMarker442"/>command to<a id="_idIndexMarker443"/> manipulate routes and the configuration of network devices is <strong class="source-inline">ip</strong>, which can be used to perform a wider range of tasks, such as creating and deleting interfaces, adding and removing routes, and displaying <span class="No-Break">network statistics.</span></p>
<p>Let’s look at the most common commands you can perform <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">iproute2</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="source-inline">ip addr</strong> or <strong class="source-inline">ip a</strong>: This shows information about network interfaces and their IP addresses. It also supports subcommands; for instance, the <strong class="source-inline">ip addr add</strong> command can be used to add an IP address to an interface, and <strong class="source-inline">ip route add</strong> can be used to add a route to the <span class="No-Break">routing table.</span></li>
<li><strong class="source-inline">ip link</strong> or <strong class="source-inline">ip l</strong>: This shows information about network interfaces and their <span class="No-Break">link-layer settings.</span></li>
<li><strong class="source-inline">ip route</strong> or <strong class="source-inline">ip r</strong>: This shows the IP <span class="No-Break">routing table.</span></li>
<li><strong class="source-inline">ip -s link</strong> (or <strong class="source-inline">ip -s l</strong>): This shows statistics about <span class="No-Break">network interfaces.</span></li>
</ul>
<p>The following<a id="_idIndexMarker444"/> is the output<a id="_idIndexMarker445"/> of running<a id="_idIndexMarker446"/> the <strong class="source-inline">ip link</strong> and <strong class="source-inline">ip </strong><span class="No-Break"><strong class="source-inline">addr</strong></span><span class="No-Break"> commands:</span></p>
<pre class="console">
admin@myhome:~$ sudo ip link
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ipip 0.0.0.0 brd 0.0.0.0
3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/tunnel6 :: brd :: permaddr 4ec4:2248:2903::
47: eth0@if48: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
admin@myhome:~$ sudo ip addr
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1000
    link/ipip 0.0.0.0 brd 0.0.0.0
3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1000
    link/tunnel6 :: brd :: permaddr 4ec4:2248:2903::
47: eth0@if48: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever</pre>
<p>Both<a id="_idIndexMarker447"/> commands print out very similar information, but <strong class="source-inline">ip addr</strong>, apart <a id="_idIndexMarker448"/>from providing information about physical<a id="_idIndexMarker449"/> interfaces, adds information about network configuration. The <strong class="source-inline">ip link</strong> command is being used to control the interface status. Similar to how <strong class="source-inline">ifconfig up eth0</strong> was enabling the interface, <strong class="source-inline">ip link set dev eth0 up</strong> will do <span class="No-Break">the same.</span></p>
<p>To configure a network interface using <strong class="source-inline">iproute2</strong>, you will need to execute the <span class="No-Break">following commands:</span></p>
<pre class="console">
admin@myhome:~$ sudo ip addr add 172.17.0.2/255.255.0.0 dev eth0
admin@myhome:~$ sudo ip link set dev eth0 up</pre>
<p>To<a id="_idIndexMarker450"/> set the interface<a id="_idIndexMarker451"/> as the default route, use the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ sudo ip route add default via 172.17.0.1 dev eth0</pre>
<p>To check only the <strong class="source-inline">eth0</strong> interface’s status, you’d execute the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ sudo ip addr show dev eth0
47: eth0@if48: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid
0
    inet 172.17.0.2/16 brd 172.17.25<a id="_idTextAnchor114"/>5.255 scope global eth0
       valid_lft forever preferred_lft forever</pre>
<h4>netplan</h4>
<p>This tool is a <a id="_idIndexMarker452"/>new <a id="_idIndexMarker453"/>network configuration tool that was introduced in Ubuntu and is supported in Debian. It is a YAML configuration file and can be used to manage network interfaces, IP addresses, and other network settings. It was first introduced in Ubuntu 17.10 as a replacement for the traditional <strong class="source-inline">/etc/network/interfaces</strong> file and has since been adopted by other distributions. such as Debian and Fedora. Ubuntu 18.04 and newer versions have <strong class="source-inline">netplan</strong> installed by default. Other distributions, such as Debian 10 and Fedora 29 onwards, have also included <strong class="source-inline">netplan</strong> <span class="No-Break">by default.</span></p>
<p>To use Netplan, you will first need to create a configuration file in the <strong class="source-inline">/etc/netplan/</strong> directory. The file should have a <strong class="source-inline">.yaml</strong> extension and should be named <a id="_idIndexMarker454"/>something descriptive, such as <strong class="source-inline">01-eth0.yaml</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">homenetwork.yaml</strong></span><span class="No-Break">.</span></p>
<p>The sample configuration looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
network:
  version: 2
  renderer: networkd
  ethernets:
    eth0:
      dhcp4: true</pre>
<p>This configuration defines a <a id="_idIndexMarker455"/>single network interface, <strong class="source-inline">eth0</strong>, that uses DHCP to obtain an IP address. The <strong class="source-inline">renderer</strong> key tells netplan which network manager to use (in this case, <strong class="source-inline">networkd</strong>). The <strong class="source-inline">version</strong> key is used to indicate the version of <strong class="source-inline">netplan</strong> being used. <strong class="source-inline">networkd</strong> is a network management daemon that is part of the <strong class="source-inline">systemd</strong> system and <span class="No-Break">service manager.</span></p>
<p>A<a id="_idIndexMarker456"/> configuration with a static IP address for the <strong class="source-inline">eth0</strong> interface <a id="_idIndexMarker457"/>would look <span class="No-Break">like this:</span></p>
<pre class="source-code">
network:
  version: 2
  renderer: networkd
  ethernets:
    eth0:
      addresses: [192.168.0.2/24]
      gateway4: 192.168.0.1
      nameservers:
        addresses: [8.8.8.8, 4.4.4.4]</pre>
<p>This <a id="_idIndexMarker458"/>configuration file defines one ethernet interface (<strong class="source-inline">eth0</strong>) with a static IP address. This interface also has a gateway and DNS servers defined. Note that we’ve used a CIDR notation instead <a id="_idIndexMarker459"/>of a <span class="No-Break">decimal one.</span></p>
<p>Once you saved your configuration, to apply the changes, you can run the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ sudo netplan apply</pre>
<p>You can also use the following command to check the configuration for <span class="No-Break">syntax errors:</span></p>
<pre class="console">
admin@myhome:~$ sudo netplan --debug generate</pre>
<p>You can check the current status of the network interfaces using the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ sudo netplan --debug try</pre>
<p>Finally, if you want to check the network interface’s status without applying the configuration, use the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ sudo netplan --debug networkd try</pre>
<p>To view logs regarding errors while bringing up network interfaces, you can use the <strong class="source-inline">dmesg</strong> command<a id="_idIndexMarker460"/> to view kernel messages, including those related to network interfaces. You can use <strong class="source-inline">dmesg | grep eth0</strong> to filter logs related to the <strong class="source-inline">eth0</strong> interface specifically. Other locations include the <strong class="source-inline">/var/log/messages</strong> file, <strong class="source-inline">journalctl</strong> (for example, the <strong class="source-inline">journalctl -u systemd-networkd.service</strong> command), and <strong class="source-inline">/var/log/netplan/</strong>, which contains logs generated <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">netplan</strong></span><span class="No-Break">.</span></p>
<p>In day-to-day operations, it’s much more likely you’ll edit the <strong class="source-inline">/etc/network/interfaces</strong> file or <strong class="source-inline">netplan</strong> configuration than configure the interface manually, but it’s very useful to know how to do it in case you need to temporarily <a id="_idIndexMarker461"/>change something in the network configu<a id="_idTextAnchor115"/>ration for testing or <span class="No-Break">debugging issues.</span></p>
<p>Next, we will cover the <span class="No-Break">transport layer.</span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor116"/>Transport layer – TCP and UDP</h2>
<p>In the <strong class="bold">transport layer</strong> of the<a id="_idIndexMarker462"/> OSI model, we <a id="_idIndexMarker463"/>focus more on <strong class="bold">Transmission Control Protocol</strong> (<strong class="bold">TCP</strong>) and IP, which<a id="_idIndexMarker464"/> are the foundation of the modern internet. Additionally, we’ll look into the <strong class="bold">User Datagram Protocol</strong> (<strong class="bold">UDP</strong>). We talked <a id="_idIndexMarker465"/>about IP in the <em class="italic">Network layer – IPv4 and IPv6</em> subsection of this chapter, so we’re only going to deepen our knowledge of this protocol a <span class="No-Break">bit here.</span></p>
<p>TCP is used for <a id="_idIndexMarker466"/>communication and needs reliable two-way communication between services. UDP is a stateless<a id="_idIndexMarker467"/> protocol that does not need a <span class="No-Break">constant connection.</span></p>
<p>A TCP connection is established using <a id="_idIndexMarker468"/>a <span class="No-Break"><em class="italic">three-way handshake</em></span><span class="No-Break">:</span></p>
<ol>
<li>The client sends a <strong class="source-inline">SYN</strong> (synchronize) packet to the server, to initiate <span class="No-Break">the connection.</span></li>
<li>The server receives the <strong class="source-inline">SYN</strong> packet and sends back a <strong class="source-inline">SYN-ACK</strong> (synchronize-acknowledgment) packet to the client to confirm that the connection has <span class="No-Break">been established.</span></li>
<li>The client receives the <strong class="source-inline">SYN-ACK</strong> packet and sends back an <strong class="source-inline">ACK</strong> (acknowledgment) packet to the server to complete the <span class="No-Break">three-way handshake.</span></li>
</ol>
<p>Once the three-way handshake is completed, the devices can start sending data to each other over the established <span class="No-Break">TCP connection.</span></p>
<p>The connection for <a id="_idIndexMarker469"/>TCP and UDP protocols is initiated by sending packets to a port on the server end of the connection. The port number is included in the IP<a id="_idIndexMarker470"/> packet header, along with the IP address, so that the destination device knows which process to send the <span class="No-Break">data to.</span></p>
<p>A port<a id="_idIndexMarker471"/> is an integer ranging from <strong class="source-inline">0</strong> to <strong class="source-inline">65535</strong>. It is used to identify a specific process running on a device and to differentiate it from other services. The port number is added to the IP address. Thus, if more than one program listens for a connection on one IP address, the other side can tell exactly which program it wants to talk to. Let’s assume that two processes are running and listening: a WWW server and an SSH server. The WWW server will typically listen on ports <strong class="source-inline">80</strong> or <strong class="source-inline">443</strong> and the SSH server will listen on port <strong class="source-inline">22</strong>. Let’s assume the system has an IP address of <strong class="source-inline">192.168.1.1</strong>. To connect to the SSH server, we would pair the IP address with the port address (commonly written as <strong class="source-inline">192.168.1.1:22</strong>). The server will know that this incoming connection has to be handled by the SSH process. A UDP connection, unlike TCP, doesn’t establish a connection to a server machine. Instead, devices can start sending UDP datagrams (<strong class="bold">packets</strong>) to each other <a id="_idIndexMarker472"/>on <span class="No-Break">known ports.</span></p>
<p>When a device sends a UDP datagram, it includes the destination IP address and port number in the packet header. The receiving device checks the destination IP address and port number in the packet header to determine which process to send the <span class="No-Break">data to.</span></p>
<p>Because UDP is connectionless, there is no guarantee that the data will be received by the destination device or that it will be received in the order it was sent. There is also no error checking or retransmission of lost packets. UDP is typically used for services that require a low overhead and fast communication. The most well-known service that uses UDP for<a id="_idIndexMarker473"/> communication is <strong class="bold">Domain Name </strong><span class="No-Break"><strong class="bold">Service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">DNS</strong></span><span class="No-Break">).</span></p>
<p>There are three types of <span class="No-Break">port numbers:</span></p>
<ul>
<li><strong class="bold">Well-known ports</strong>, which<a id="_idIndexMarker474"/> you can typically find in your Linux system in the <strong class="source-inline">/etc/services</strong> file. These are port numbers that are reserved for specific services, such as <strong class="source-inline">HTTP</strong> traffic on <strong class="source-inline">port 80</strong> or DNS traffic on <span class="No-Break"><strong class="source-inline">port 53</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Privileged ports</strong> are <a id="_idIndexMarker475"/>ports that only root users can open a listening service on. Those ports are between <strong class="source-inline">1</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">1024</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Ephemeral ports</strong> are <a id="_idIndexMarker476"/>port numbers that are used for temporary connections and are assigned dynamically by the operating system, such as for <span class="No-Break">TCP connections.</span></li>
</ul>
<p>There are various tools available for viewing details on TCP and UDP traffic on the machine you’re working on. <a id="_idTextAnchor117"/>You can also set up a firewall so that you can control access to your machine from <span class="No-Break">the network.</span></p>
<h3>netstat</h3>
<p>To view all TCP connections made from your machine, you can use a <strong class="source-inline">netstat</strong> command. It can be <a id="_idIndexMarker477"/>used to view a list of open connections, as well as display statistics about the network traffic on <span class="No-Break">your system.</span></p>
<p>To view a list of all open connections on your system, you can use the <strong class="source-inline">netstat -an</strong> command. This will display a list of all current connections, including the local and remote IP addresses and ports, as well as the status of the connection (for example, listening, established, and <span class="No-Break">so on).</span></p>
<p>Using <strong class="source-inline">netstat -s</strong>, you can view statistics on each connection on your system. This will display a variety of statistics about the network traffic on your system, including the number of packets sent and received, the number of errors, <span class="No-Break">and more.</span></p>
<p>To view only <a id="_idIndexMarker478"/>the UDP connections using <strong class="source-inline">netstat</strong>, you can use the <strong class="source-inline">netstat -an -u</strong> command. This will display a list of all current UDP connections, including the local and remote IP addresses and ports, as well as the status of <span class="No-Break">the connection.</span></p>
<p>Alternatively, you can use the <strong class="source-inline">netstat -an -u | grep "udp" | grep "0.0.0.0:*"</strong> command to only show UDP connections that are in a listening state. This command filters the output of <strong class="source-inline">netstat -an -u</strong> to show only lines that contain <strong class="source-inline">"UDP"</strong> and <strong class="source-inline">"0.0.0.0:*"</strong>, which indicates a listening <span class="No-Break">UDP connection.</span></p>
<p>You can also use other options, such as <strong class="source-inline">-p</strong> to show the process ID and name of the process that owns each co<a id="_idTextAnchor118"/>nnection, <strong class="source-inline">-r</strong> to show the routing table, and <strong class="source-inline">-i</strong> to show the statistics for a <span class="No-Break">particular interface.</span></p>
<h3>tcpdump</h3>
<p><strong class="source-inline">tcpdump</strong> is a <a id="_idIndexMarker479"/>command-line packet analyzer that allows you to capture and analyze network traffic by displaying packets being transmitted or received over a network to which the computer is attached. <strong class="source-inline">tcpdump</strong> can be used to troubleshoot network issues, analyze network performance, and monitor network security. You can capture packets on a specific interface, filter packets based on various criteria, and save the captured packets to a file for <span class="No-Break">later analysis.</span></p>
<p>To capture and display all network traffic on the <strong class="source-inline">eth0</strong> interface, you can use the <strong class="source-inline">-i</strong> option, followed by the interface name. To capture and display all network traffic on the <strong class="source-inline">eth0</strong> interface, you would need to run <strong class="source-inline">sudo tcpdump -</strong><span class="No-Break"><strong class="source-inline">i eth0</strong></span><span class="No-Break">.</span></p>
<p>You can also save the captured packets to a file for later analysis by using the <strong class="source-inline">-w</strong> option – for example, <strong class="source-inline">tcpdump -i eth0 -w all_traffic.pcap</strong>. This will save all the captured packets on the <strong class="source-inline">eth0</strong> interface in <span class="No-Break">the file.</span></p>
<p>By default, <strong class="source-inline">tcpdump</strong> captures <span class="No-Break">packets indefinitely.</span></p>
<p>To capture packets for a specific amount of time, you can use the <strong class="source-inline">-c</strong> option, followed by the number of packets to capture – for example, <strong class="source-inline">sudo tcpdump -i eth0 -c 100</strong>. This command captures and displays <strong class="source-inline">100</strong> packets, <span class="No-Break">then exits.</span></p>
<p>You can also filter the traffic by using filters such as <strong class="source-inline">port</strong>, <strong class="source-inline">ip</strong>, <strong class="source-inline">host</strong>, and so on – for example, <strong class="source-inline">sudo tcpdump -i eth0 'src host 192.168.1.2 and (tcp or udp)'</strong>. This filter captures all the packets on the <strong class="source-inline">eth0</strong> interface with a source IP address of <strong class="source-inline">192.168.1.2</strong> and is either <strong class="source-inline">TCP</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">UDP</strong></span><span class="No-Break">.</span></p>
<p>To show more advanced use of <strong class="source-inline">tcpdump</strong>, let’s capture only <strong class="source-inline">SYN</strong> packets (see all connections being established). You can achieve this by using the <strong class="source-inline">tcp[tcpflags] &amp; (tcp-syn) != 0</strong> filter. This filter checks if the <strong class="source-inline">SYN</strong> flag is set in the <strong class="source-inline">TCP</strong> header of <span class="No-Break">the packet.</span></p>
<p>Here is an<a id="_idIndexMarker480"/> example command that captures and displays all <strong class="source-inline">SYN</strong> packets on the <span class="No-Break"><strong class="source-inline">eth0</strong></span><span class="No-Break"> interface:</span></p>
<pre class="console">
sudo tcpdump -i eth0 'tcp[tcpflags] &amp; (tcp-syn) != 0'</pre>
<p>You can also save the captured packets to a file for later analysis by using the <strong class="source-inline">-w</strong> option, <span class="No-Break">like this:</span></p>
<pre class="console">
sudo tcpdump -i eth0 -w syn_packets.pcap 'tcp[tcpflags] &amp; (tcp-syn) != 0'</pre>
<p>This will save all the captured <strong class="source-inline">SYN</strong> packets in the <span class="No-Break"><strong class="source-inline">syn_packets.pcap</strong></span><span class="No-Break"> file.</span></p>
<p>You can <a id="_idIndexMarker481"/>also specify a filter with a more complex filter, <span class="No-Break">like this:</span></p>
<pre class="console">
sudo tcpdump -i eth0 'tcp[tcpflags] &amp; (tcp-syn) != 0 and src h<a id="_idTextAnchor119"/>ost 192.168.1.2'</pre>
<p>This filter captures only <strong class="source-inline">SYN</strong> packets that have a source IP address <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">192.168.1.2</strong></span><span class="No-Break">.</span></p>
<h3>Wireshark</h3>
<p>Another popular tool that’s similar <a id="_idIndexMarker482"/>to <strong class="source-inline">tcpdump</strong> is Wireshark. It can be used both headless (only in a command line) and via a <span class="No-Break">graphical interface:</span></p>
<ul>
<li>To show all traffic on the <strong class="source-inline">eth0</strong> interface using Wireshark, you can use the <strong class="source-inline">sudo wireshark -i eth0</strong> command. This will start Wireshark and listen for traffic on the <strong class="source-inline">eth0</strong> interface. You can also use the <strong class="source-inline">-k</strong> flag to start capturing immediately and the <strong class="source-inline">-w</strong> flag to write the captured traffic to a file: <strong class="source-inline">sudo wireshark -k -i eth0 -</strong><span class="No-Break"><strong class="source-inline">w output_file.pcap</strong></span><span class="No-Break">.</span></li>
<li>If you’d like to show only <strong class="source-inline">SYN</strong> packets, as we showed in the <strong class="source-inline">tcpdump</strong> example, you can run the <strong class="source-inline">sudo wireshark -i eth0 -f "tcp.flags.syn == 1"</strong> command. The preceding command uses a filter, <strong class="source-inline">"tcp.flags.syn == 1"</strong>, which says that we want to see only <strong class="source-inline">TCP</strong> protocol flags marked as <strong class="source-inline">SYN</strong>. You can also use this filter in the GUI version of Wireshark by going to the <strong class="bold">Capture</strong> menu, selecting <strong class="bold">Options</strong>, then entering the filter in the <strong class="bold">Capture Filter</strong> field before starting <span class="No-Break">the capture.</span></li>
</ul>
<p>Alternatively, you can apply this filter after capturing the traffic by clicking on the <strong class="bold">filter</strong> button on the to<a id="_idTextAnchor120"/>p-right corner of the Wireshark window, type <strong class="source-inline">"tcp.flags.syn==1"</strong> in the filter field, and <span class="No-Break">press </span><span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break">.</span></p>
<h3>ngrep</h3>
<p>The next very useful <a id="_idIndexMarker483"/>tool that’s similar to <strong class="source-inline">tcpdump</strong> and Wireshark is <strong class="source-inline">ngrep</strong>. What differentiates it from other tools we’ve been talking about is that it’s much simpler to use, and it allows you to (similar to <strong class="source-inline">grep</strong>) search for strings inside <span class="No-Break">network packets.</span></p>
<p>For instance, to monitor <strong class="source-inline">GET HTTP</strong> requests, you can use the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ ngrep -d eth0 -q -W byline "GET" "tcp and port 80"
interface: en0 (192.168.1.0/255.255.255.0)
filter: ( tcp and port 80 ) and ((ip || ip6) || (vlan &amp;&amp; (ip || ip6)))
match: GET
# Later output will contain actual GET requests, removed for readability</pre>
<p>This command will<a id="_idIndexMarker484"/> listen on the <strong class="source-inline">eth0</strong> interface and match only <strong class="source-inline">TCP</strong> packets on port<strong class="source-inline"> 80</strong> (the default port for <strong class="source-inline">HTTP</strong>). The <strong class="source-inline">-q</strong> option tells <strong class="source-inline">ngrep</strong> to be quiet and not display packet summary information, while <strong class="source-inline">-W</strong> te<a id="_idTextAnchor121"/>lls <strong class="source-inline">ngrep</strong> to print each packet data in separate lines. At this point, we can move to the <span class="No-Break">session layer.</span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor122"/>Session layer</h2>
<p>The <strong class="bold">session layer</strong>, as we’ve already mentioned, is responsible for establishing, maintaining, and terminating <a id="_idIndexMarker485"/>connections between devices. This means it sets up, coordinates, and terminates conversations, exchanges, or connections between the applications. The <a id="_idIndexMarker486"/>session layer ensures that data is transmitted reliably and in the proper sequence by using techniques such as token management and checkpointing. It is also responsible for resolving any conflicts that may arise during a session, such as when two applications attempt to initiate a session at the same time. In a nutshell, the session layer establishes, maintains, and terminates the connections between the devices on <span class="No-Break">a network.</span></p>
<p>In other words, the session layer is a glue between the lower layers we’ve already covered and the higher layers we will be covering in the next few sections of <span class="No-Break">this chapter.</span></p>
<p>The best tools to figure out issues with sessions are logs tied to the service you’re working with. If you have a problem with an FTP connection, you might want to look into logs of your client and/or server running on the machine you manage. The tools we <a id="_idTextAnchor123"/>covered previously can also help if logs are not enough to understand the issue you’re trying <span class="No-Break">to resolve.</span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor124"/>Presentation layer – SSL and TLS</h2>
<p>The <strong class="bold">presentation layer</strong> is the<a id="_idIndexMarker487"/> sixth layer of the OSI model, and it is responsible <a id="_idIndexMarker488"/>for representing the data in a format that can be understood by the application layer. This includes converting data between different<a id="_idIndexMarker489"/> formats, such as the <strong class="bold">American Standard Code for Information Interchange</strong> (<strong class="bold">ASCII</strong>) and <strong class="bold">Extended Binary Coded Decimal Interchange Code</strong> (<strong class="bold">EBCDIC</strong>). Both are<a id="_idIndexMarker490"/> character encoding standards that represent characters using 7-bit (<strong class="source-inline">ASCII</strong>) or 8-bit (<strong class="source-inline">EBCDIC</strong>) integers. We also handle encryption and compression in this layer. The presentation layer also ensures that the data is in the correct format for the application to process. It acts as an intermediary between the application and the data, allowing the application to be independent of the specific format of the data <span class="No-Break">being received.</span></p>
<p>For this layer, the most common encryption <a id="_idIndexMarker491"/>standards, <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) and <strong class="bold">Transport Layer Security</strong> (<strong class="bold">TLS</strong>) are the ones you might need to debug and fix<a id="_idIndexMarker492"/> <span class="No-Break">issues with.</span></p>
<p><strong class="bold">TLS</strong> is a widely <a id="_idIndexMarker493"/>used protocol for securing communications over a network. It is a successor <a id="_idIndexMarker494"/>to <strong class="bold">SSL</strong> and is used to encrypt and authenticate data transmitted over a network, such as <span class="No-Break">the internet.</span></p>
<p>TLS works by establishing a secure <em class="italic">tunnel</em> between two devices, such as a web server and a web browser. This tunnel is used to transmit data between the two devices in an encrypted format, making it difficult for an attacker to intercept and read <span class="No-Break">the data.</span></p>
<p>The process of establishing a TLS connection involves <span class="No-Break">several steps:</span></p>
<ol>
<li><strong class="bold">Handshake</strong>: The<a id="_idIndexMarker495"/> client and server exchange information to establish a shared understanding of the encryption method and keys that will be used to secure <span class="No-Break">the connection.</span></li>
<li><strong class="bold">Authentication</strong>: The server authenticates itself to the client by providing a digital certificate that contains <a id="_idIndexMarker496"/>information about the server’s identity and public key. The client can then use this information to verify the <span class="No-Break">server’s identity.</span></li>
<li><strong class="bold">Key exchange</strong>: The<a id="_idIndexMarker497"/> client and server exchange public keys to establish a shared secret key that will be used to encrypt and <span class="No-Break">decrypt data.</span></li>
<li><strong class="bold">Data encryption</strong>: Once the <a id="_idIndexMarker498"/>shared secret key has been established, the client and server can start encrypting data using symmetric <span class="No-Break">encryption algorithms.</span></li>
<li><strong class="bold">Data transfer</strong>: Data is<a id="_idIndexMarker499"/> then transferred over the secure connection, protected by the encryption established during <span class="No-Break">the handshake.</span></li>
</ol>
<p>TLS has multiple versions, among which the newest are considered more secure. However, older systems might not support the most recent versions. The available TLS versions are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="bold">TLS 1.0</strong>: This was the<a id="_idIndexMarker500"/> first version of the<a id="_idIndexMarker501"/> protocol, released <span class="No-Break">in 1999.</span></li>
<li><strong class="bold">TLS 1.1</strong>: This <a id="_idIndexMarker502"/>was released <span class="No-Break">in 2006.</span></li>
<li><strong class="bold">TLS 1.2</strong>: This was<a id="_idIndexMarker503"/> released in 2008. It added support for new cryptographic algorithms and made several other <span class="No-Break">security enhancements.</span></li>
<li><strong class="bold">TLS 1.3</strong>: This was <a id="_idIndexMarker504"/>released in 2018 and includes the use of forward secrecy, which makes it harder for attackers to decrypt <span class="No-Break">captured data.</span></li>
</ul>
<p>SSL is a<a id="_idIndexMarker505"/> security protocol that is widely used to secure communications over a network, such as the internet. It was developed by Netscape in the 1990s and was later succeeded by the <span class="No-Break">TLS protocol.</span></p>
<p>Like TLS, SSL works by establishing a secure <em class="italic">tunnel</em> between two devices, such as a web server and a web browser. This tunnel is used to transmit data between the two devices in an encrypted format, making it difficult for an attacker to intercept and read the data. It’s not recommended to use SSL anymore and it’s better to use the latest version of TLS, but you might still encounter systems <span class="No-Break">using it.</span></p>
<p>The best tool to debug issues with both <a id="_idIndexMarker506"/>SSL and TLS is the <strong class="source-inline">openssl</strong> command. You can use it to test a connection to a server using SSL. For <a id="_idIndexMarker507"/>example, you can use the following command to test a connection to a server on port (usually, it’s <strong class="source-inline">443</strong> as it’s a common port <span class="No-Break">for HTTPS</span><span class="No-Break">):</span></p>
<pre class="console">
admin@myhome:~$ openssl s_client -connect myhome:443</pre>
<p>You can use the <strong class="source-inline">openssl</strong> command to check the details of an SSL certificate, including the expiration date, the issuing authority, and the public key. For example, you can use the following command to check the details of <span class="No-Break">a certificate:</span></p>
<pre class="console">
admin@myhome:~$ openssl s_client -connect myhome:443 -showcerts</pre>
<p>This will allow you to check if the certificates served by your server are valid and what you expect them to be. This is much faster than using a <span class="No-Break">web browser.</span></p>
<p>Using the <strong class="source-inline">openssl</strong> command, you <a id="_idIndexMarker508"/>can also check which ciphers are supported by a server. For example, you can use the following command to check the ciphers supported by <span class="No-Break">a server:</span></p>
<pre class="console">
admin@myhome:~$ openssl s_client -connect myhome:443 -cipher 'ALL:eNULL'
# Cut most of the output for readability
SSL handshake has read 5368 bytes and written 415 bytes
---
New, TLSv1/SSLv3, Cipher is AEAD-AES256-GCM-SHA384
Server public key is 2048 bit
Secure Renegotiation IS NOT supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
SSL-Session:
    Protocol  : TLSv1.3
    Cipher    : AEAD-AES256-GCM-SHA384
    Session-ID:
    Session-ID-ctx:
    Master-Key:
    Start Time: 1674075742
    Timeout   : 7200 (sec)
    Verify return code: 0 (ok)
---
closed</pre>
<p>Additionally, <strong class="source-inline">openssl</strong> has a<a id="_idIndexMarker509"/> built-in diagnostic that can detect known vulnerabilities that exist in <span class="No-Break">your system:</span></p>
<pre class="console">
admin@myhome:~$ openssl s_client -connect myhome:443 -tlsextdebug -status
CONNECTED(00000006)
140704621852864:error:1404B42E:SSL routines:ST_CONNECT:tlsv1 alert protocol version:/AppleInternal/Library/BuildRoots/aaefcfd1-5c95-11ed-8734-2e32217d8374/Library/Caches/com.apple.xbs/Sources/libressl/libressl-3.3/ssl/tls13_lib.c:151:
---
no peer certificate available
---
No client certificate CA names sent
---
SSL handshake has read 5 bytes and written 303 bytes
---
New, (NONE), Cipher is (NONE)
Secure Renegotiation IS NOT supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
SSL-Session:
    Protocol  : TLSv1.3
    Cipher    : 0000
    Session-ID:
    Session-ID-ctx:
    Master-Key:
    Start Time: 1674075828
    Timeout   : 7200 (sec)
    Verify return code: 0 (ok)
---</pre>
<p>It’s also worth noting that both<a id="_idIndexMarker510"/> SSL and TLS use public key encryption. With <a id="_idIndexMarker511"/>this encryption method, we create two files: a private key and a public key. Together, they form a pair. The public key is designed to encrypt data, while the private key is designed to decrypt it. The private key should be kept private at all times, as its name implies. This method of encryption is based on the mathematical properties of large prime numbers, and it is considered to be <span class="No-Break">very secure.</span></p>
<p>In the case of TLS, public key encryption is used during the <em class="italic">handshake</em> phase to establish a secure<a id="_idIndexMarker512"/> connection between the client and the server. The process works <span class="No-Break">as follows:</span></p>
<ol>
<li>The server generates a public key and a private key. The public key is sent to the client as part of the server’s <span class="No-Break">digital certificate.</span></li>
<li>The client generates a session key, which is used to encrypt data that is sent to the server. The server’s public key is used to encrypt the session key. Once the server receives the encrypted data, it uses its private key to decrypt it and retrieve the <span class="No-Break">session key.</span></li>
<li>Once the session key has been decrypted, it is used to encrypt data that is sent between<a id="_idIndexMarker513"/> the client and <span class="No-Break">the server.</span></li>
</ol>
<p>The next and final layer is the top layer of the OSI model. In the next section, which cover<a id="_idTextAnchor125"/>s the application layer, we’ll cover protocols such as HTTP and FTP, which are commonly used for browsing the web and <span class="No-Break">sharing files.</span></p>
<h2 id="_idParaDest-104"><a id="_idTextAnchor126"/>Application layer – HTTP and FTP</h2>
<p>The <strong class="bold">application layer</strong> is the <a id="_idIndexMarker514"/>seventh and highest layer of the OSI network model. It provides the interface between the software application and the network, allowing<a id="_idIndexMarker515"/> the application to access the network’s communication services. The application layer defines protocols and <a id="_idIndexMarker516"/>services that are specific to the application, such as file <a id="_idIndexMarker517"/>transfer (<strong class="bold">File Transfer Protocol</strong> (<strong class="bold">FTP</strong>)), email (<strong class="bold">Simple Mail Transfer Protocol</strong> (<strong class="bold">SMTP</strong>) and <strong class="bold">Internet Message Access Protocol</strong> (<strong class="bold">IMAP</strong>)), and<a id="_idIndexMarker518"/> well-known web<a id="_idIndexMarker519"/> services (<strong class="bold">Hypertext Transfer </strong><span class="No-Break"><strong class="bold">Protocol</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">HTTP</strong></span><span class="No-Break">)).</span></p>
<p>Let’s take a closer look at HTTP. This communication protocol is used for transferring data on the World Wide Web. It is based on a client-server model, where a web browser (the client) sends a request to a web server, and the server sends back <span class="No-Break">a response.</span></p>
<p>When a user <a id="_idIndexMarker520"/>enters a <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) in their web browser, the browser sends an HTTP request to the web server associated with that URL. A URL is something you can see in your browser address input field and is usually located at the top of the browser window – for <span class="No-Break">example, </span><a href="https://google.com"><span class="No-Break">https://google.com</span></a><span class="No-Break">.</span></p>
<p>The request includes the method (such as <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">PATCH</strong>, or <strong class="source-inline">DELETE</strong>), which indicates the type of action the browser wants the server to perform, as well as any additional information, such as data for a <strong class="source-inline">POST</strong> or <span class="No-Break"><strong class="source-inline">PUT</strong></span><span class="No-Break"> request.</span></p>
<p>The web server then processes the request, after which the server sends back an HTTP response, which includes a status code (such as <strong class="source-inline">200</strong> for success or <strong class="source-inline">404</strong> for <strong class="source-inline">not found</strong>) and any data requested by the browser, such as the HTML and CSS that make up <span class="No-Break">the website.</span></p>
<p>Once the browser receives the response, it parses the HTML, CSS, and – very often – JavaScript to display the website to <span class="No-Break">the user.</span></p>
<p>HTTP is a <a id="_idIndexMarker521"/>stateless protocol, which means that each request is independent and the server does not retain any information about previous requests. However, many web applications use cookies or other techniques to maintain state across <span class="No-Break">multiple requests.</span></p>
<p>HTTP version 1.1 introduced new features such as persistent connections, a host header field, and byte-serving which, improved the overall performance of the protocol and made it more suitable for heavy usage scenarios. The most recent version of this protocol is 2.0 and is described in detail by RFC 7540 (https://www.rfc-editor.org/rfc/rfc7540.xhtml), which was released in 2015, and updated by RFC 8740 (<a href="https://www.rfc-editor.org/rfc/rfc8740.xhtml">https://www.rfc-editor.org/rfc/rfc8740.xhtml</a>), which was released <span class="No-Break">in 2020.</span></p>
<p>To resolve issues with HTTP, you can use any of the tools for debugging network problems, such as <strong class="source-inline">tcpdump</strong> or <strong class="source-inline">ngrep</strong>. There are several console and GUI tools available you can use for debugging HTTP. The most common are <strong class="source-inline">wget</strong> and <strong class="source-inline">curl</strong> for the console and <strong class="source-inline">Postman</strong> or <strong class="source-inline">Fiddler</strong> for the GUI. There will also be debugging tools built into your browser, such as Firefox or Chrome <span class="No-Break">Developer Tools.</span></p>
<p>We’re going to focus on console tools right now, so let’s look into <strong class="source-inline">wget</strong> first. This tool is intended to download files, but we still can use it to debug HTTP. For the first example, we will show detailed information about the request <span class="No-Break">and response:</span></p>
<pre class="console">
admin@myhome:~$ wget -d https://google.com
DEBUG output created by Wget 1.21.3 on darwin22.1.0.
Reading HSTS entries from /home/admin/.wget-hsts
URI encoding = 'UTF-8'
Converted file name 'index.xhtml' (UTF-8) -&gt; 'index.xhtml' (UTF-8)
--2023-01-20 14:11:02--  https://google.com/
Resolving google.com (google.com)... 216.58.215.78
Caching google.com =&gt; 216.58.215.78
Connecting to google.com (google.com)|216.58.215.78|:443... connected.
Created socket 5.
Releasing 0x0000600000d2dac0 (new refcount 1).
Initiating SSL handshake.
Handshake successful; connected socket 5 to SSL handle 0x00007fca4a008c00
certificate:
  subject: CN=*.google.com
  issuer:  CN=GTS CA 1C3,O=Google Trust Services LLC,C=US
X509 certificate successfully verified and matches host google.com
---request begin---
GET / HTTP/1.1
Host: google.com
User-Agent: Wget/1.21.3
Accept: */*
Accept-Encoding: identity
Connection: Keep-Alive
---request end---
HTTP request sent, awaiting response...
# Rest of the output omitted</pre>
<p>You might need to send an HTTP request with specific headers. To do so, you can use the <strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">header</strong></span><span class="No-Break"> option:</span></p>
<pre class="console">
admin@myhome:~$ wget --header='&lt;header-name&gt;: &lt;header-value&gt;' &lt;url&gt;</pre>
<p><strong class="source-inline">POST</strong> is a <a id="_idIndexMarker522"/>special HTTP request – it uses a URL, but it will also require some request data as it’s intended to send some data to your system, be it a username and password or files. To send an HTTP<strong class="source-inline"> POST</strong> request<a id="_idIndexMarker523"/> with prepared data, you can use the <strong class="source-inline">--post-data</strong> option, <span class="No-Break">like this:</span></p>
<pre class="console">
admin@myhome:~$ wget --post-data=&lt;data&gt; &lt;url&gt;</pre>
<p>A more powerful tool for <a id="_idIndexMarker524"/>debugging HTTP issues is <strong class="source-inline">curl</strong>. To send an HTTP<strong class="source-inline"> GET</strong> request<a id="_idIndexMarker525"/> and display the response, you can use the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ curl linux.com
&lt;html&gt;
&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
<p>To send an HTTP<strong class="source-inline"> POST</strong> request and display the response, you can use the <strong class="source-inline">-X POST</strong> option and the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">d</strong></span><span class="No-Break"> option:</span></p>
<pre class="console">
admin@myhome:~$ curl -X POST -d &lt;data&gt; &lt;url&gt;</pre>
<p>Using the <strong class="source-inline">-X</strong> option, you can send other types of requests, such as <strong class="source-inline">PATCH</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">DELETE</strong></span><span class="No-Break">.</span></p>
<p>To send an HTTP request with specific headers, you can use the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">H</strong></span><span class="No-Break"> option:</span></p>
<pre class="console">
admin@myhome:~$ curl -H '&lt;header-name&gt;: &lt;header-value&gt;' &lt;url&gt;</pre>
<p>To display the <a id="_idIndexMarker526"/>response headers only, use the <span class="No-Break">following code:</span></p>
<pre class="console">
admin@myhome:~$ curl -I linux.com
HTTP/1.1 301 Moved Permanently
Connection: keep-alive
Content-Length: 162
Content-Type: text/html
Location: https://linux.com/
Server: nginx
X-Pantheon-Styx-Hostname: styx-fe3-b-7f84d5c76-q4hpv
X-Styx-Req-Id: f1409a84-9832-11ed-abcb-7611ac88195f
Cache-Control: public, max-age=86400
Date: Fri, 20 Jan 2023 13:14:42 GMT
X-Served-By: cache-chi-kigq8000084-CHI, cache-fra-eddf8230050-FRA
X-Cache: HIT, HIT
X-Cache-Hits: 37, 1
X-Timer: S1674220483.602573,VS0,VE1
Vary: Cookie, Cookie
Age: 62475
Accept-Ranges: bytes
Via: 1.1 varnish, 1.1 varnish</pre>
<p>You can also show detailed information about the request and response by using the <strong class="source-inline">-v</strong> option, <span class="No-Break">like this:</span></p>
<pre class="console">
admin@myhome:~$ curl -v &lt;url&gt;</pre>
<p>By sending different types of requests and analyzing the responses, you can use either <strong class="source-inline">wget</strong> or <strong class="source-inline">curl</strong> to debug various HTTP issues, such as connectivity problems, response errors, and performance issues. As usual, you can refer to the full documentation of both tools to deepen your understanding of how to <span class="No-Break">use them.</span></p>
<p>In this section, we introduced several network layers, as defined by the ISO/<a id="_idTextAnchor127"/>OSI standard. Each of them standardizes the functions of different elements of networking communication. Next, we are going to <span class="No-Break">discuss firewalls.</span></p>
<h1 id="_idParaDest-105">Firewalls</h1>
<p>A <strong class="bold">firewall</strong> is a <a id="_idIndexMarker527"/>security measure that controls incoming and outgoing network traffic based on predefined rules and policies. It is typically placed between a protected network and the internet, and its main purpose is to block unauthorized access while allowing authorized communication. Firewalls can be hardware-based or software-based, and they can use a variety of techniques, such as packet filtering, stateful inspection, and application-level filtering, to control network traffic. In this section, we’re going to look into a firewall available on <span class="No-Break">Linux systems.</span></p>
<p>To control a Linux firewall, you <a id="_idTextAnchor128"/>will need to use <strong class="source-inline">iptables</strong>, <strong class="source-inline">ufw</strong>, <strong class="source-inline">nftables</strong>, or <strong class="source-inline">firewalld</strong>. Packet filtering is built into the Linux kernel, so those CLI tools will interact <span class="No-Break">with it.</span></p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor129"/>iptables</h2>
<p><strong class="bold">iptables</strong> is the <a id="_idIndexMarker528"/>most verbose tool for controlling a firewall, meaning it does not have much abstraction built into it, but it’s important to understand the basic concepts so that we can move on to more <span class="No-Break">user-friendly tools.</span></p>
<p>As mentioned previously, <strong class="source-inline">iptables</strong> allows you to create rules for filtering and manipulating network packets, and it can be used to control incoming and outgoing network traffic based on various criteria, such as IP or MAC addresses, ports, <span class="No-Break">and protocols.</span></p>
<p><strong class="source-inline">iptables</strong> uses several concepts to organize rules and divide them into functional parts: tables, chains, rules, and targets. The most general are tables to organize <span class="No-Break">the rules.</span></p>
<p>There are three tables we can use: <strong class="source-inline">filter</strong>, <strong class="source-inline">nat</strong>, and <strong class="source-inline">mangle</strong>. The <strong class="source-inline">filter</strong> table is used to filter incoming and outgoing<a id="_idIndexMarker529"/> packets, the <strong class="source-inline">nat</strong> table is used for <strong class="bold">Network Address Translation</strong> (<strong class="bold">NAT</strong>), which we will get back to later, and the <strong class="source-inline">mangle</strong> table is used for advanced <span class="No-Break">packet alteration.</span></p>
<p>Each table contains a set of chains, which are used to organize the rules. The <strong class="source-inline">filter</strong> table, for example, contains three predefined chains: <strong class="source-inline">INPUT</strong>, <strong class="source-inline">OUTPUT</strong>, and <strong class="source-inline">FORWARD</strong>. The <strong class="source-inline">INPUT</strong> chain is used for incoming packets, the <strong class="source-inline">OUTPUT</strong> chain is used for outgoing packets, and the <strong class="source-inline">FORWARD</strong> chain is used for packets that are being forwarded through <span class="No-Break">the network.</span></p>
<p>Each chain contains a set of rules, which are used to match packets and decide what to do with them. Each rule has a match condition and an action. For example, a rule might match packets coming from a specific IP address and drop them, or it might match packets going to a specific port and <span class="No-Break">accept them.</span></p>
<p>Each rule has a target, which is the action that should be taken when the rule’s match condition is met. The most common targets are <strong class="source-inline">ACCEPT</strong>, <strong class="source-inline">DROP</strong>, and <strong class="source-inline">REJECT</strong>. <strong class="source-inline">ACCEPT</strong> means to allow the packet through the firewall, <strong class="source-inline">DROP</strong> means to discard the packet without any feedback to the other end, and <strong class="source-inline">REJECT</strong> means to refuse the packet actively so that the remote end will know access is rejected to the <span class="No-Break">said port.</span></p>
<p>The default<a id="_idIndexMarker530"/> table of <strong class="source-inline">iptables</strong> will add rules to the filter table and by default, each chain (<strong class="source-inline">INPUT</strong>, <strong class="source-inline">OUTPUT</strong>, and <strong class="source-inline">FORWARD</strong>) has a default policy set to <strong class="source-inline">ACCEPT</strong>. You can also create additional tables and direct packets to this table for later processing. It’s a good practice to set at least the <strong class="source-inline">FORWARD</strong> and <strong class="source-inline">INPUT</strong> policies <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">DROP</strong></span><span class="No-Break">:</span></p>
<pre class="console">
admin@myhome:~$ sudo iptables -P INPUT DROP
admin@myhome:~$ sudo iptables -P FORWARD DROP</pre>
<p>At the same time, we can allow all loopback interface access <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ACCEPT</strong></span><span class="No-Break">:</span></p>
<pre class="console">
admin@myhome:~$ sudo iptables -A INPUT -i lo -j ACCEPT</pre>
<p>Additionally, all packets that are in the <strong class="source-inline">ESTABLISHED</strong> or <strong class="source-inline">RELATED</strong> state should be accepted; otherwise, we will lose all established connections or connections that are in the process of <span class="No-Break">being established:</span></p>
<pre class="console">
admin@myhome:~$ sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT</pre>
<p>To allow HTTP and HTTPS traffic, we can do <span class="No-Break">the following:</span></p>
<pre class="console">
admin@myhome:~$ sudo iptables -A INPUT -p tcp --dport 80 -j ACCEPT
admin@myhome:~$ sudo iptables -A INPUT -p tcp --dport 443 -j ACCEPT</pre>
<p>It’s a good idea to allow <strong class="source-inline">SSH</strong> traffic so that we can remotely log into <span class="No-Break">this machine:</span></p>
<pre class="console">
admin@myhome:~$ sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT</pre>
<p>Here are some other more commonly <a id="_idIndexMarker531"/>used options you can use <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">iptables</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="source-inline">-A</strong> or <strong class="source-inline">--append</strong>: Appends a rule to the end of <span class="No-Break">a chain</span></li>
<li><strong class="source-inline">-I</strong> or <strong class="source-inline">--insert</strong>: Inserts a rule at a specific position in <span class="No-Break">a chain</span></li>
<li><strong class="source-inline">-D</strong> or <strong class="source-inline">--delete</strong>: Deletes a rule from <span class="No-Break">a chain</span></li>
<li><strong class="source-inline">-P</strong> or <strong class="source-inline">--policy</strong>: Sets the default policy for <span class="No-Break">a chain</span></li>
<li><strong class="source-inline">-j</strong> or <strong class="source-inline">--jump</strong>: Specifies the target for <span class="No-Break">a rule</span></li>
<li><strong class="source-inline">-</strong>s or <strong class="source-inline">--source</strong>: Matches packets based on the source IP address <span class="No-Break">or network</span></li>
<li><strong class="source-inline">-d</strong> or <strong class="source-inline">--destination</strong>: Matches packets based on the destination IP address <span class="No-Break">or network</span></li>
<li><strong class="source-inline">-p</strong> or <strong class="source-inline">--protocol</strong>: Matches packets based on the protocol (for example, TCP, UDP, <span class="No-Break">or ICMP)</span></li>
<li><strong class="source-inline">-i</strong> or <strong class="source-inline">--in-interface</strong>: Matches packets based on the <span class="No-Break">incoming interface</span></li>
<li><strong class="source-inline">-o</strong> or <strong class="source-inline">--out-interface</strong>: Matches packets based on the <span class="No-Break">outgoing interface</span></li>
<li><strong class="source-inline">--sport</strong> or <strong class="source-inline">--source-port</strong>: Matches packets based on the <span class="No-Break">source port</span></li>
<li><strong class="source-inline">--dport</strong> or <strong class="source-inline">--destination-port</strong>: Matches packets based on the <span class="No-Break">destination port</span></li>
<li><strong class="source-inline">-m</strong> or <strong class="source-inline">--match</strong>: Adds a <a id="_idIndexMarker532"/>match extension, which allows you to match packets based on additional criteria such as connection state, packet length, <span class="No-Break">and more</span></li>
</ul>
<p>There are many more features available when dealing with <strong class="source-inline">iptables</strong>, such as setting up NAT, interface bonding, TCP multipath, and many more. We will cover some of these in the <em class="italic">Advanced topics</em> section of <span class="No-Break">this chapter.</span></p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor130"/>nftables</h2>
<p><strong class="bold">nftables</strong> is a <a id="_idIndexMarker533"/>versatile tool for managing firewall configurations, offering a more streamlined and user-friendly approach compared to <strong class="source-inline">iptables</strong>, which is known for its verbosity and lack of <span class="No-Break">built-in abstraction.</span></p>
<p><strong class="source-inline">nftables</strong> employs a logical structure to organize rules that comprises tables, chains, rules, and verdicts. Tables serve as the top-level containers for rules and are instrumental in categorizing them. <strong class="source-inline">nftables</strong> offers several table types: <strong class="source-inline">ip</strong>, <strong class="source-inline">arp</strong>, <strong class="source-inline">ip6</strong>, <strong class="source-inline">bridge</strong>, <strong class="source-inline">inet</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">netdev</strong></span><span class="No-Break">.</span></p>
<p>Within each table, there are chains, which help organize the rules further between categories: <strong class="source-inline">filter</strong>, <strong class="source-inline">route</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">nat</strong></span><span class="No-Break">.</span></p>
<p>Each chain comprises individual rules, which serve as the criteria for matching packets and determining subsequent actions. A rule consists of both a matching condition and a verdict. For instance, a rule may match packets originating from a specific IP address and instruct the firewall to drop them, or it might match packets headed for a particular port and <span class="No-Break">dictate acceptance.</span></p>
<p>Let’s set a default policy for incoming and forwarded packets to “drop” (stop processing the packet and <span class="No-Break">don’t respond):</span></p>
<pre class="console">
sudo nft add rule ip filter input drop
sudo nft add rule ip filter forward drop</pre>
<p>Additionally, it’s common practice to allow all loopback <span class="No-Break">interface access:</span></p>
<pre class="console">
sudo nft add rule ip filter input iifname "lo" accept</pre>
<p>To ensure established and related connections are permitted, you can run the <span class="No-Break">following command:</span></p>
<pre class="console">
sudo nft add rule ip filter input ct state established,related accept</pre>
<p>You can run the following command to allow HTTP and <span class="No-Break">HTTPS traffic:</span></p>
<pre class="console">
sudo nft add rule ip filter input tcp dport {80, 443} accept</pre>
<p>Finally, to enable SSH traffic for remote access, you can use the <span class="No-Break">following command:</span></p>
<pre class="console">
sudo nft add rule ip filter input tcp dport 22 accept</pre>
<p>These are some frequently <a id="_idIndexMarker534"/>used options <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">nftables</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="source-inline">add</strong>: Appends a rule to the end of <span class="No-Break">a chain</span></li>
<li><strong class="source-inline">insert</strong>: Inserts a rule at a specific position in <span class="No-Break">a chain</span></li>
<li><strong class="source-inline">delete</strong>: Deletes a rule from <span class="No-Break">a chain</span></li>
<li><strong class="source-inline">chain</strong>: Specifies the target for <span class="No-Break">a rule</span></li>
<li><strong class="source-inline">ip saddr</strong>: Matches packets based on the source IP address <span class="No-Break">or network</span></li>
<li><strong class="source-inline">ip daddr</strong>: Matches packets based on the destination IP address <span class="No-Break">or network</span></li>
<li><strong class="source-inline">ip protocol</strong>: Matches packets based on the protocol (for example, TCP, UDP, <span class="No-Break">or ICMP)</span></li>
<li><strong class="source-inline">iifname</strong>: Matches packets based on the <span class="No-Break">incoming interface</span></li>
<li><strong class="source-inline">oifname</strong>: Matches packets based on the <span class="No-Break">outgoing interface</span></li>
<li><strong class="source-inline">tcp sport</strong>: Matches packets based on the <span class="No-Break">source port</span></li>
<li><strong class="source-inline">tcp dport</strong>: Matches packets based on the <span class="No-Break">destination port</span></li>
<li><strong class="source-inline">ct state</strong>: Adds a match extension, allowing packet matching based on additional criteria such as<a id="_idIndexMarker535"/> connection state, packet length, <span class="No-Break">and more</span></li>
</ul>
<p><strong class="source-inline">nftables</strong> is set to be a repl<a id="_idTextAnchor131"/>acement for <strong class="source-inline">iptables</strong>, but both are frequently used in modern systems. Let’s move on to other tools that are more abstract and by this, <span class="No-Break">more user-friendly.</span></p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor132"/>ufw</h2>
<p><strong class="source-inline">ufw</strong> is a <a id="_idIndexMarker536"/>frontend for the Linux <strong class="source-inline">iptables</strong> firewall and provides a simple and easy-to-use interface for managing it. <strong class="source-inline">ufw</strong> is designed to be easy to use, and it automatically sets up the <strong class="source-inline">iptables</strong> rules for you based on the configuration options you specify. It’s much more user-friendly and easier to use for more <span class="No-Break">common tasks.</span></p>
<p>Before you start to use <strong class="source-inline">ufw</strong>, you will need to enable it so that all rules you add or remove will persist after system reboot. To do just that, run the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ sudo ufw enable</pre>
<p>To open TCP ports <strong class="source-inline">80</strong> and <strong class="source-inline">443</strong> using <strong class="source-inline">ufw</strong>, you can use the <span class="No-Break">following commands:</span></p>
<pre class="console">
admin@myhome:~$ sudo ufw allow 80/tcp
admin@myhome:~$ sudo ufw allow 443/tcp</pre>
<p>Alternatively, you can open both ports with <span class="No-Break">one command:</span></p>
<pre class="console">
admin@myhome:~$ sudo ufw allow 80,443/tcp</pre>
<p>Once you have opened the ports, you can verify the changes by checking the status <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">ufw</strong></span><span class="No-Break">:</span></p>
<pre class="console">
admin@myhome:~$ sudo ufw status</pre>
<p><strong class="source-inline">ufw</strong> is available on all major Linux distributions, incl<a id="_idTextAnchor133"/>uding Debian Linux, Ubuntu Linux, Arch Linux, and Fedora Linux. However, in some cases, you will need to install it as it’s not part of the <span class="No-Break">default system.</span></p>
<h2 id="_idParaDest-109"><a id="_idTextAnchor134"/>firewalld</h2>
<p>Another tool you can use<a id="_idIndexMarker537"/> to manage a firewall on Linux is <strong class="source-inline">firewalld</strong>. This is a program that was created to streamline the dynamic configuration of firewalls. One of the big features of <strong class="source-inline">firewalld</strong> is zones, which allow you to declare different levels of trust in interfaces and networks. It is included by default in many popular Linux distributions such as Red Hat Enterprise Linux, Fedora, CentOS, and Debian. Some other Linux distributions, such as Ubuntu, do not include <strong class="source-inline">firewalld</strong> by default but it can be installed and used on those systems <span class="No-Break">as well.</span></p>
<p>To open TCP ports <strong class="source-inline">80</strong> and <strong class="source-inline">443</strong> using <strong class="source-inline">firewalld</strong>, you can use the <strong class="source-inline">firewall-cmd</strong> command-line tool. Here are the commands to open <span class="No-Break">those ports:</span></p>
<pre class="console">
admin@myhome:~$ sudo firewall-cmd --add-port=80/tcp --permanent
admin@myhome:~$ sudo firewall-cmd --add-port=443/tcp --permanent</pre>
<p>You can open both ports with <span class="No-Break">one command:</span></p>
<pre class="console">
admin@myhome:~$ sudo firewall-cmd --add-port=80/tcp --add-port=443/tcp --permanent</pre>
<p>After adding the ports, you need to reload the firewall for the changes to <span class="No-Break">take effect:</span></p>
<pre class="console">
admin@myhome:~$ sudo firewall-cmd --reload</pre>
<p>You can also check the status of the ports using the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ sudo firewall-cmd --list-ports</pre>
<p>Whatever<a id="_idIndexMarker538"/> tool you use to configure your firewall, it’s always a good idea to set default rule policies to <strong class="source-inline">DROP</strong> and only allow the traffic you expect to be handled <a id="_idTextAnchor135"/>by your system. There are some topics we don’t have much space for in this chapter, but it’s useful to know about possibilities when dealing <span class="No-Break">with networking.</span></p>
<h1 id="_idParaDest-110">Advanced topics</h1>
<p>In this section, we will cover more advanced uses of network features. Some are very common (such as port forwarding or NAT), while some are le<a id="_idTextAnchor136"/>ss known. Let’s start with well-known features you will most likely encounter very often and then make our way down to more advanced and <span class="No-Break">less-known features.</span></p>
<h2 id="_idParaDest-111"><a id="_idTextAnchor137"/>NAT</h2>
<p><strong class="bold">Network Address Translation</strong> (<strong class="bold">NAT</strong>) is a <a id="_idIndexMarker539"/>technique that involves mapping one network to another. The original reason for this was to simplify routing whole network segments without changing the address of every host in <span class="No-Break">the packets.</span></p>
<p><strong class="bold">Source NAT</strong> (<strong class="bold">SNAT</strong>) is a <a id="_idIndexMarker540"/>type of NAT that changes the source IP address of a packet. It is used to allow hosts on a private network to access the internet using a single public <span class="No-Break">IP address.</span></p>
<p><strong class="bold">Destination NAT</strong> (<strong class="bold">DNAT</strong>) is a <a id="_idIndexMarker541"/>type of NAT that changes the destination IP address of a packet. It is used to forward incoming traffic to a specific internal host based on the destination IP address. This is often used to allow external clients to access services running on internal hosts using a public <span class="No-Break">IP address.</span></p>
<p>To set up NAT using <strong class="source-inline">iptables</strong>, you can use the following <span class="No-Break">basic commands:</span></p>
<pre class="console">
admin@myhome:~$ echo 1 &gt; /proc/sys/net/ipv4/ip_forward</pre>
<p>This will enable forwarding, which allows your machine to forward packets from one interface to another. This particular command updates the Linux kernel configuration on the fly by using the <strong class="source-inline">proc</strong> filesystem. You can achieve the same thing using the <span class="No-Break"><strong class="source-inline">sysctl</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ sudo sysctl -w net.ipv4.ip_forward=1</pre>
<p>To configure <a id="_idIndexMarker542"/>NAT for a local network such as <strong class="source-inline">192.168.10.0/24</strong>, you will need to run the following commands as <span class="No-Break"><strong class="source-inline">root user</strong></span><span class="No-Break">:</span></p>
<pre class="console">
admin@myhome:~$ sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
admin@myhome:~$ sudo iptables -A FORWARD -i eth0 -o eth1 -m state --state RELATED,ESTABLISHED -j ACCEPT
admin@myhome:~$ sudo iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT</pre>
<p>Note that <strong class="source-inline">eth0</strong> is the interface connected to the internet, and <strong class="source-inline">eth1</strong> is the interface connected to the <span class="No-Break">internal network.</span></p>
<p>The <strong class="source-inline">MASQUERADE</strong> target<a id="_idIndexMarker543"/> is used to implement NAT on a Linux router. When packets pass through the router and are sent out to the internet, the <strong class="source-inline">MASQUERADE</strong> target changes the source address of the packets to the router’s public IP address. This allows devices on the internal network to communicate with devices on the internet using the router’s public IP address as a source address, effectively hiding the internal network from <span class="No-Break">the internet.</span></p>
<p>The <strong class="source-inline">MASQUERADE</strong> target is typically used in the <strong class="source-inline">POSTROUTING</strong> chain of the <strong class="source-inline">nat</strong> table and is commonly applied <a id="_idTextAnchor138"/>to the interface that is connected to the internet. It works only with dynamically assigned IP addresses (DHCP) and it’s mostly used in the case of a <span class="No-Break">home router.</span></p>
<h2 id="_idParaDest-112"><a id="_idTextAnchor139"/>Port forwarding</h2>
<p><strong class="bold">Port forwarding</strong> is a<a id="_idIndexMarker544"/> technique that’s used to direct network traffic from one network address and port to another. This can be useful for directing incoming traffic to a specific service or application running on a computer or network device. This helps with accessing services or applications on a private network from a remote location, or for making services or applications running on a private network accessible to <span class="No-Break">the public.</span></p>
<p>Essentially, it’s another use of NAT as you will change the destination IP (and also port) of the packet that arrived on <span class="No-Break">your machine.</span></p>
<p>To forward packets coming into TCP port <strong class="source-inline">80</strong> on the <strong class="source-inline">eth0</strong> interface to internal IP <strong class="source-inline">192.168.10.101</strong> on port <strong class="source-inline">8080</strong> using <strong class="source-inline">iptables</strong>, you can use the <span class="No-Break">following commands:</span></p>
<pre class="console">
admin@myhome:~$ sudo iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j DNAT --to-destination<a id="_idTextAnchor140"/> 192.168.10.101:8080
admin@myhome:~$ sudo iptables -t nat -A POSTROUTING -j MASQUERADE</pre>
<p>We need <strong class="source-inline">MASQUERADE</strong> here as we want to hide the internal IP from <span class="No-Break">the outside.</span></p>
<h2 id="_idParaDest-113"><a id="_idTextAnchor141"/>Interface bonding</h2>
<p><strong class="bold">Network interface bonding</strong> is a feature in Linux that allows multiple network interfaces to be combined<a id="_idIndexMarker545"/> into a single <em class="italic">bonded</em> interface. This can provide increased bandwidth, redundancy, and failover capabilities. Several different bonding modes can be used, each with its benefits and drawbacks. Some common modes include <strong class="source-inline">active-backup</strong>, <strong class="source-inline">balance-rr</strong>, and <strong class="source-inline">802.3ad</strong>. <strong class="source-inline">active-backup</strong> mode means that one of the two bonding interfaces is used as a backup when the primary device is down. <strong class="source-inline">balance-rr</strong> will use both interfaces simultaneously with a round-robin policy. The <strong class="source-inline">802.3ad</strong> bonding creates aggregation groups that share the same technical specifications (speed and duplex<a id="_idTextAnchor142"/> settings). You can read more about modes and bonding settings<a id="_idIndexMarker546"/> on the official Linux kernel <span class="No-Break">website: </span><a href="https://www.kernel.org/doc/Documentation/networking/bonding.txt%20"><span class="No-Break">https://www.kernel.org/doc/Documentation/networking/bonding.txt</span></a></p>
<h2 id="_idParaDest-114"><a id="_idTextAnchor143"/>TCP multipath</h2>
<p><strong class="bold">TCP multipath</strong> refers<a id="_idIndexMarker547"/> to using multiple paths to send and receive data between two points in a network, rather than just one. This can improve the reliability and performance of the network by allowing for failover if one of the paths becomes unavailable, and by allowing for load balancing across multiple paths. This can be achieved using various techniques, such as by using multiple interfaces on a device or by using multiple routing paths through <span class="No-Break">the network.</span></p>
<p>Configuring multipath is quite easy with the use of the <strong class="source-inline">iproute2</strong> package. To configure multipath on Linux using the <strong class="source-inline">eth0</strong> and <strong class="source-inline">eth1</strong> interfaces, you will need to run the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ ip route add default scope global nexthop via 192.168.1.1 dev eth0 nexthop via 192.168.2.1 dev eth1 weight 1</pre>
<p>This command creates a new default route that uses both the <strong class="source-inline">eth0</strong> and <strong class="source-inline">eth1</strong> interfaces, with a weight of <strong class="source-inline">1</strong>. The IP addresses used in this example (<strong class="source-inline">192.168.1.1</strong> and <strong class="source-inline">192.168.2.1</strong>) should be replaced with the actual IP addresses of the next hop routers on the <strong class="source-inline">eth0</strong> and <span class="No-Break"><strong class="source-inline">eth1</strong></span><span class="No-Break"> interfaces.</span></p>
<p>When running <strong class="source-inline">ip route show</strong>, you will see that a new multipath route is present. To start using it, you will need to change the <span class="No-Break">default route:</span></p>
<pre class="console">
admin@myhome:~$ ip route change default scope gl<a id="_idTextAnchor144"/>obal nexthop via 192.168.1.1 dev eth0 nexthop via 192.168.2.1 dev eth1 weight 1</pre>
<p>You can read more about multipath<a id="_idIndexMarker548"/> and how to use it <span class="No-Break">at </span><a href="https://www.multipath-tcp.org/"><span class="No-Break">https://www.multipath-tcp.org/</span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-115"><a id="_idTextAnchor145"/>BGP</h2>
<p><strong class="bold">Border Gateway Protocol</strong> (<strong class="bold">BGP</strong>) is a routing protocol that’s used to distribute routing information within<a id="_idIndexMarker549"/> a single <strong class="bold">autonomous system</strong> (<strong class="bold">AS</strong>) or <a id="_idIndexMarker550"/>between multiple autonomous systems on the internet. BGP is used to build routing tables in routers in the internet backbone, as well as in <span class="No-Break">enterprise networks.</span></p>
<p>BGP<a id="_idIndexMarker551"/> routers exchange routing information with their neighbors, which can be other BGP routers in the same AS or a different AS. When a BGP router receives routing information from its neighbors, it uses a set of rules and policies to decide which routes to add to its routing table and advertise to its neighbors. This allows BGP to support multiple paths to a destination, and to choose the best path based on various factors such as distance, cost, <span class="No-Break">or preference.</span></p>
<p>BGP is considered a path vector protocol because it exchanges information about the complete path to a destination, rather than just the next hop. This allows BGP to support advanced features such as routing policy and <span class="No-Break">traffic engineering.</span></p>
<p>There are several ways to use BGP on a Linux machine, depending on your specific use case and <span class="No-Break">network environment.</span></p>
<p><strong class="bold">BIRD</strong> is a <a id="_idIndexMarker552"/>routing daemon for Linux that supports BGP and other routing protocols. You can configure BIRD so that it acts as a BGP speaker and exchange routing information with other BGP routers. BIRD can be installed on most Linux distributions and can be configured using a simple <span class="No-Break">configuration file.</span></p>
<p><strong class="bold">Quagga</strong> is <a id="_idIndexMarker553"/>another open source routing software suite for Linux that supports BGP, OSPF, and other routing protocols. You can configure Quagga to act as a BGP speaker and exchange routing information with other BGP routers. Quagga can be installed on most Linux distributions and can be configured using a command-line interface or a <span class="No-Break">configuration file.</span></p>
<p><strong class="bold">Free Range Routing</strong> (<strong class="bold">FRR</strong>) is a<a id="_idIndexMarker554"/> routing software suite for Linux that supports BGP, OSPF, and other routing protocols; it<a id="_idTextAnchor146"/>’s a fork <span class="No-Break">of Quagga.</span></p>
<p>You can read more about <a id="_idIndexMarker555"/>BGP and using BIRD<a id="_idIndexMarker556"/> in the following Linux Journal <span class="No-Break">article: </span><a href="https://www.linuxjournal.com/content/linux-advanced-routing-tutorial"><span class="No-Break">https://www.linuxjournal.com/content/linux-advanced-routing-tutorial</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-116">Summary</h1>
<p>In this chapter, we covered basic networking topics that you will probably encounter during your work in a DevOps team. This is a starting point and a base to help you understand network-related topics when dealing with services running inside a container. You will probably also want to expand your knowledge on this topic by reading about the IPv6 protocol, which is yet to <span class="No-Break">replace IPv4.</span></p>
<p>In the next chapter, we will switch focus to a <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>) that is mainly used in modern <span class="No-Break">organizations: </span><span class="No-Break"><strong class="bold">Git</strong></span><span class="No-Break">.</span></p>
</div>
</div></body></html>