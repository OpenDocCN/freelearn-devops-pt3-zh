- en: '[*Chapter 8*](B17124_08_Final_SK_ePub.xhtml#_idTextAnchor189): AWS Database
    Services'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '[*第8章*](B17124_08_Final_SK_ePub.xhtml#_idTextAnchor189): AWS数据库服务'
- en: Most applications need to store, access, organize, and manipulate data in some
    way. Normally, the data would reside externally to the actual application in what
    we call a *database* for several reasons, including efficiency improvements. Databases
    are designed to do more than simply store data, however. Depending on the type
    of database, data can be organized and stored in a structured or semi-structured
    manner, offer high-speed access to the data, and give you the ability to perform
    queries and scans against the data. Data can also be combined from different *tables*
    within the database to help you create complex analytics and reporting. Typical
    examples of where you would use a database include storing customer records and
    their orders for your e-commerce website, storing a product listing catalog, and
    storing temperature information from your home IoT thermostat devices. AWS offers
    three primary database solutions and several others for specific application types.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序需要以某种方式存储、访问、组织和操作数据。通常，数据会存储在实际应用程序之外的*数据库*中，原因有很多，包括提高效率。然而，数据库的设计不仅仅是存储数据。根据数据库的类型，数据可以以结构化或半结构化的方式组织和存储，提供高效的访问速度，并允许你对数据执行查询和扫描操作。数据还可以从数据库中的不同*表*中组合，以帮助你创建复杂的分析和报告。你可能使用数据库的典型场景包括：存储电子商务网站的客户记录及其订单、存储产品目录以及存储家用物联网恒温器设备的温度信息。AWS提供了三种主要的数据库解决方案，以及为特定应用类型提供的其他解决方案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涉及以下主题：
- en: Managed databases versus unmanaged databases
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 托管数据库与非托管数据库
- en: Introduction to database concepts and models
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库概念与模型简介
- en: Introduction to **Amazon Relational Database Service** (**Amazon RDS**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon关系数据库服务**（**Amazon RDS**）简介'
- en: Learning about Amazon DynamoDB (aNoSQL database solution)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Amazon DynamoDB（一个NoSQL数据库解决方案）
- en: Understand the use cases for Amazon Redshift and data warehousing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Amazon Redshift的使用案例及数据仓库
- en: Understanding the importance of in-memory caching options with Amazon Elasticache
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Amazon Elasticache的内存缓存选项的重要性
- en: Learning about additional database services for specific niche requirements
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解针对特定细分需求的额外数据库服务
- en: '**Database Migration Service** (**DMS**)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库迁移服务**（**DMS**）'
- en: In this chapter, you will learn about the various managed databases solutions
    offered by AWS and launch your very first Amazon Relational Database service running
    the MySQL engine. Later in this book, we will configure a database to store data
    that's been uploaded via a web application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习AWS提供的各种托管数据库解决方案，并启动你第一个运行MySQL引擎的Amazon关系数据库服务。稍后在本书中，我们将配置一个数据库，用于存储通过Web应用程序上传的数据。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete the exercises in this chapter, you will need to access your AWS
    account and be logged in as our fictitious administrator, **Alice**, using her
    IAM user credentials.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，你需要访问你的AWS账户，并以我们虚拟管理员**Alice**的身份登录，使用她的IAM用户凭证。
- en: Managed databases versus unmanaged databases
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 托管数据库与非托管数据库
- en: Traditionally, in an on-premises setup, you would configure a server (physical
    or virtual) with a base operating system and then proceed to install the database
    software on it. Because the primary purpose of a database is to store data, you
    would also need to ensure that you had adequate storage attached to your server.
    Due to the importance of the data store, you would take additional security measures
    to protect the data and ensure you had adequate backups and copies of the data
    (ideally stored offsite in another location) in case of disasters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在本地部署环境中，你需要配置一台服务器（物理服务器或虚拟服务器），并安装操作系统，然后在其上安装数据库软件。由于数据库的主要目的是存储数据，因此你还需要确保服务器上附加了足够的存储。由于数据存储的重要性，你还需要采取额外的安全措施来保护数据，并确保有足够的数据备份和副本（理想情况下，备份应存储在其他位置的异地）以应对灾难。
- en: On AWS, you can set up an **Elastic Compute Cloud** (**EC2**) instance and install
    your database, such as **Microsoft SQL Server** or **Oracle**, in the same manner
    to serve your frontend web and application servers as required. In this case,
    you take full ownership of managing the database, provisioning the required amount
    of **Elastic Block Store** (**EBS**) volumes for storage, and ensuring adequate
    backups are made. You also need to design for high availability and performance.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 上，你可以设置 **弹性计算云**（**EC2**）实例，并以相同的方式安装你的数据库，例如 **Microsoft SQL Server**
    或 **Oracle**，以便根据需要为前端 Web 和应用服务器提供服务。在这种情况下，你将完全负责管理数据库，配置所需的 **弹性块存储**（**EBS**）卷以供存储，并确保做好足够的备份。你还需要设计高可用性和性能。
- en: Alternatively, AWS also offers **managed database solutions**. AWS takes care
    of provisioning your database instances, where you specify certain parameters
    to ensure the required capacity for your application. AWS will also provision
    and manage the required storage for your database, as well as perform all backups
    and replications as required. Ultimately, you get a fully managed solution where
    AWS takes care of almost every configuration option you choose, except for ensuring
    that your application is optimized for the chosen database solution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，AWS 还提供 **托管数据库解决方案**。AWS 会负责配置你的数据库实例，你只需要指定某些参数以确保应用所需的容量。AWS 还会配置并管理你的数据库所需的存储，并执行所有必要的备份和复制操作。最终，你将获得一个完全托管的解决方案，AWS
    会处理你选择的几乎所有配置选项，除了确保你的应用程序针对所选择的数据库解决方案进行了优化。
- en: Learning about additional database services for specific niche requirements
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解特定细分需求的额外数据库服务
- en: In this section, we introduced you to the concept of unmanaged databases and
    how traditionally, we would have to install our database software on a physical
    or virtual server. However, hosting a database on a server carries additional
    administrative efforts. While on AWS, you can install a database on an EC2 instance,
    it makes more sense to consider using AWS managed database offerings such as **Amazon
    RDS** as this reduces the management burden on the customer. In the next section,
    we will introduce you to database concepts and models.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们向你介绍了非托管数据库的概念，以及传统上我们如何在物理或虚拟服务器上安装数据库软件。然而，在服务器上托管数据库需要额外的管理工作。虽然在
    AWS 上你可以在 EC2 实例上安装数据库，但考虑使用 AWS 的托管数据库服务（如 **Amazon RDS**）更为合适，因为这能减轻客户的管理负担。在下一部分中，我们将向你介绍数据库概念和模型。
- en: Introduction to database concepts and models
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库概念和模型介绍
- en: Today, there are several types of database models, but the most common are *relational*
    and *non-relational* models. Relational databases have existed for years and allow
    you to efficiently manage your data with the ability to perform complex queries
    and analyses. However, they have certain restrictions, such as the fact that you
    need to define the database schema (its structure) before you can add data, and
    changing this later can be difficult. Non-relational databases offer a lot more
    flexibility and are used for many modern-day web and mobile applications. Let's
    look at the key differences.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有几种类型的数据库模型，但最常见的模型是 *关系型* 和 *非关系型* 模型。关系型数据库已经存在多年，允许你高效地管理数据，并能够执行复杂的查询和分析。然而，它们也有一些限制，比如在你添加数据之前必须定义数据库模式（其结构），而且之后更改模式会比较困难。非关系型数据库提供了更多的灵活性，并且被广泛应用于现代的
    Web 和移动应用中。我们来看看它们之间的主要区别。
- en: Relational databases
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: A `tables`. Within each table, you have rows and columns – columns define `attributes`
    for your data and rows contain individual `records` in the database. Each row
    in your table then contains data that relates to the attributes that were defined
    in the columns. So, for example, in a customer's table, you can have columns such
    as `First Name` and `Last Name`, then your rows will contain data related to those
    columns comprised of your customer's first and last names.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`表`。在每个表中，你会有行和列——列定义了你数据的 `属性`，行包含了数据库中的单个 `记录`。因此，例如，在客户的表中，你可以有像 `名` 和 `姓`
    这样的列，然后你的行将包含与这些列相关的数据，包含你客户的名字和姓氏。'
- en: Another important factor to consider with `First Name` and a second column called
    `Date of Birth`, then you need to define the type of data you will permit in each
    of those columns prior to adding any data; for the `First Name` column, the type
    of data will be `string`, whereas for the `Date of Birth` column, you will define
    the type of data as `date`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的重要因素是`First Name`和一个名为`Date of Birth`的第二列，在添加数据之前，必须先定义每一列允许的数据信息类型；对于`First
    Name`列，数据类型应为`string`，而对于`Date of Birth`列，数据类型应定义为`date`。
- en: 'An important column (`attribute`) that must exist in a relational database
    is the `Primary Key` field. Each record must have a primary key that is unique
    across the whole table. This ensures that each record within the table is unique,
    allowing you to easily query specific records in the table. As shown in the following
    table, the customer records table has a primary key called `CustomerID`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库中必须存在一个重要的列（`属性`），即`主键`字段。每一条记录都必须有一个在整个表中唯一的主键。这确保了表中每条记录的唯一性，使得你可以方便地查询表中的特定记录。如下面的表格所示，客户记录表有一个名为`CustomerID`的主键：
- en: '![Figure 8.1 – Customer contact table'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 客户联系方式表'
- en: '](img/B17124_08_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17124_08_01.jpg)'
- en: Figure 8.1 – Customer contact table
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 客户联系方式表
- en: A database can also host multiple tables for specific record sets. Rather than
    storing all the records within a single table, you can have separate tables for
    related data. So, for example, in one table, you can have your *customer contact*
    details and in another, you can have your *customer order* details. In most cases,
    the tables will have some relationship with other tables in the same database.
    In this example, the tables are related to specific customers; one for their contact
    details and another for their orders.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数据库也可以托管多个特定记录集的表格。与其将所有记录存储在一个表中，不如为相关数据创建单独的表。例如，你可以在一个表中存储*客户联系方式*，在另一个表中存储*客户订单*。在大多数情况下，这些表格之间会有某种关系。在这个例子中，表格与特定客户相关，一个表存储他们的联系方式，另一个表存储他们的订单。
- en: 'The purpose of separating different sets of data into separate tables is to
    allow for better management, performance, and to avoid duplicate data. For example,
    if you have a single table to host customers'' contact details as well as their
    orders, then you would have multiple records relisting the customers'' contact
    information for every single order they placed. By separating the orders from
    the contact details into separate tables, we can avoid this duplication of data
    and improve performance. The following is an example of a customers'' orders table:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 将不同的数据集分离到不同的表中，目的是为了更好地管理、提高性能并避免数据重复。例如，如果你有一个单独的表来存储客户的联系方式以及他们的订单，那么每个订单记录都会重复列出客户的联系方式。通过将订单和联系方式分开到不同的表中，我们可以避免数据的重复并提高性能。以下是一个客户订单表的示例：
- en: '![Figure 8.2 – Customer order table'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 客户订单表'
- en: '](img/B17124_08_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17124_08_02.jpg)'
- en: Figure 8.2 – Customer order table
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 客户订单表
- en: In the preceding two tables, note that we avoided replicating the data by separating
    the customer contact details table from the orders table. If we have all the data
    in one table, then we would have multiple columns with the same pieces of information
    repeated, such as First Name and Last Name for every order placed by the same
    customer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个表格中，请注意通过将客户联系方式表与订单表分开，我们避免了数据的重复。如果将所有数据放在一个表中，那么我们将有多个包含相同信息的列重复出现，例如同一个客户每次下单时，名字和姓氏都会重复。
- en: The tables in a database can relate to each other, and we need some form of
    connection between the two tables to effectively structure the data. In the previous
    example, rather than repeating all customer address details in the orders table,
    we simply include the `Customer-ID` column, where we identify which customer the
    order relates to. Remember that the `Customer-ID` column is the primary key of
    the **Customer Contacts Table**, so each Customer ID uniquely identifies a customer.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的表格可以相互关联，我们需要某种连接方式来有效地组织数据。在之前的示例中，除了在订单表中重复客户地址信息外，我们仅仅添加了`Customer-ID`列，用来标识该订单对应的客户。记住，`Customer-ID`列是**客户联系方式表**的主键，因此每个客户ID都唯一标识一个客户。
- en: Ultimately, we can now query the database by combining data from both columns
    using the Customer ID as a reference point. We can then produce a report from
    a query to list all the orders that have been placed by a customer, whose `Customer-ID`
    is `Cust002`. In this report, we can list the customer contact details, which
    will be extracted from the first table, and the list of orders placed from the
    second table, where `Customer-ID` is `Cust002`. This report could then be sent
    to the customer as a statement of account.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们现在可以通过使用客户ID作为参考点，结合两列数据来查询数据库。然后，我们可以通过查询生成一份报告，列出所有由客户`Customer-ID`为`Cust002`下的订单。在此报告中，我们可以列出从第一个表格提取的客户联系方式，以及从第二个表格中列出的订单信息，其中`Customer-ID`为`Cust002`。该报告可以发送给客户作为账户明细。
- en: Relational databases enable you to perform such complex queries, analyses, and
    reports from large datasets. Performance is directly correlated to the types of
    queries you need to perform and the volume of data you host. Often, this means
    that your infrastructure may need to be upgraded from time to time to cope with
    demanding applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库使你能够对大数据集进行复杂的查询、分析和报告。性能与需要执行的查询类型和托管的数据量直接相关。通常，这意味着你的基础设施可能需要不时升级，以应对需求较高的应用程序。
- en: Relational databases use the `SELECT` statement enables you to query specific
    data, whereas the `WhereHERE` statement enables you to restrict your `SELECT`
    query to match a specific condition. For the *AWS Certified Cloud Practitioner*
    exam, you are not expected to know how to use the SQL language.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库使用`SELECT`语句使你能够查询特定数据，而`WHERE`语句则可以限制`SELECT`查询以匹配特定条件。在*AWS认证云从业者*考试中，你不需要掌握如何使用SQL语言。
- en: Relational databases are also known as **Online Transaction Processing** (**OLTP**)
    **databases**. **OLTP databases** are designed for adding, updating, and deleting
    small amounts of data in a database regularly. Typical examples include a *customer
    orders* database for an e-commerce website or a student's database for a university.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库也被称为**在线事务处理**（**OLTP**）**数据库**。**OLTP数据库**旨在定期向数据库中添加、更新和删除少量数据。典型的例子包括电子商务网站的*客户订单*数据库或大学的学生数据库。
- en: Non-relational (NoSQL) databases
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非关系型（NoSQL）数据库
- en: With relational databases, you store data in a structured format of a defined
    schema in tables. Each column of a table (known as an attribute) will only hold
    one type of data and this needs to be predefined. You usually query multiple tables
    of related data and combining queries across your tables can yield required pieces
    of information.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关系型数据库，你将数据以表格形式存储在定义好的结构中。每个表格的列（称为属性）只会包含一种类型的数据，并且这种类型需要预先定义。你通常会查询多个相关的数据表，通过跨表查询来获取所需的信息。
- en: However, the problem with relational databases is the lack of flexibility since
    data needs to be structured. Furthermore, the more tables you have across your
    database, the more complex the queries tend to be, and the more resources are
    required to run and manage the databases. Relational databases also do not lend
    themselves well when trying to perform thousands of reads and writes to the database
    per second.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关系型数据库的问题在于缺乏灵活性，因为数据必须是结构化的。此外，数据库中的表格越多，查询就越复杂，运行和管理数据库所需的资源也越多。关系型数据库在执行每秒数千次读取和写入操作时，也表现得不够理想。
- en: 'In contrast, non-relational databases do not follow the traditional relational
    approach to storing data. Non-relational database data is stored using different
    models, depending on the type of data being stored. These are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，非关系型数据库不遵循传统的关系型数据存储方法。非关系型数据库的数据存储使用不同的模型，具体取决于存储的数据类型。以下是这些模型：
- en: '**Key-value stores**: This is a collection of key-value pairs contained within
    an object.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键值存储**：这是包含在对象中的键值对集合。'
- en: '**Document data stores**: This is typically a **JavaScript Object Notation**
    (**JSON**) format document (although other formats can be used) that''s used to
    store data in a structured or semi-structured form. Data can be comprised of nested
    attributes of key-value pairs. All the documents in the store are not required
    to maintain identical data structures and this offers greater levels of flexibility.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档数据存储**：这通常是**JavaScript对象表示法**（**JSON**）格式的文档（尽管也可以使用其他格式），用于以结构化或半结构化的形式存储数据。数据可以包含键值对的嵌套属性。存储中的所有文档不要求保持相同的数据结构，这提供了更高的灵活性。'
- en: "**Columnar data stores**: Data is organized into cells grouped by columns rather\
    \ \Lthan by rows. Furthermore, reads and writes are carried out using columns\
    \ rather than rows."
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列式数据存储**：数据按列而非行组织为单元格。此外，读写操作是通过列而不是通过行进行的。'
- en: There is no requirement to predefine the schema of the database, and this creates
    a lot of flexibility because you can freely add fields (attributes) to a document
    without the need to define them first. Therefore, you have documents with different
    numbers of fields. For example, one document listing a customer's details could
    include their name, address details, order history, and credit card information,
    while another document could include a list of their favorite products.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的模式无需预定义，这创造了很多灵活性，因为您可以自由地向文档中添加字段（属性），而无需先定义它们。因此，您的文档可以包含不同数量的字段。例如，一个列出客户详细信息的文档可能包括他们的姓名、地址信息、订单历史和信用卡信息，而另一个文档则可能包含他们最喜欢的产品列表。
- en: Non-relational databases were developed as an alternative to relational databases
    where the flexibility of the schema was required, as well as to handle very large
    data stores that required thousands of reads/writes per second, something that
    relational databases have traditionally found difficult to do. Non-relational
    databases can cope with this kind of load because a query does not have to view
    several related tables to extract the results. Furthermore, a non-relational database
    can handle frequent changes to the data.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 非关系型数据库作为关系型数据库的替代品开发，主要解决了需要灵活模式的场景，同时也能处理需要每秒上千次读写的大型数据存储，这是关系型数据库传统上难以做到的。非关系型数据库能够应对这种负载，因为查询不需要查看多个相关的表来提取结果。此外，非关系型数据库可以处理数据的频繁变化。
- en: Like relational databases, though, non-relational databases do require you to
    have at least one primary key field (attribute) and this is the only attribute
    required. Beyond this, your database tables are effectively schemaless. The primary
    key is used to ensure that each record of the database is unique.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像关系型数据库一样，非关系型数据库仍然要求至少有一个主键字段（属性），这是唯一必需的属性。除此之外，您的数据库表实际上是无模式的。主键用于确保每条记录在数据库中是唯一的。
- en: In this section, we reviewed the primary differences between relational and
    non-relational databases. We looked at the use cases for both types of database
    solutions and compared the key differences between the two. On AWS, both relational
    databases and non-relational databases are offered. In the next section, we will
    look at the services that are offered in detail.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了关系型和非关系型数据库之间的主要区别。我们研究了这两种类型数据库解决方案的使用案例，并比较了它们之间的关键差异。在AWS上，提供了关系型和非关系型数据库服务。在接下来的部分中，我们将详细介绍提供的服务。
- en: Introduction to Amazon RDS
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 亚马逊RDS简介
- en: '**Amazon RDS** offers traditional relational databases as fully managed services
    on the AWS platform. Ideal for transactional database requirements, also known
    as **OLTP**, AWS offers six different database engines, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊RDS**在AWS平台上提供传统的关系型数据库作为完全托管的服务。它非常适用于事务型数据库需求，也称为**OLTP**，AWS提供以下六种不同的数据库引擎：'
- en: MySQL
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL
- en: PostgreSQL
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: MariaDB
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MariaDB
- en: Microsoft SQL server
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft SQL服务器
- en: Oracle
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle
- en: Amazon Aurora
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亚马逊Aurora
- en: Another term you might have heard of is **Relational Database Management System**
    (**RDBMS**). An RDBMS performs functions to **create, read, update, and delete**
    (**CRUD**) data from the database using an underlying software component, which
    we call the database engine.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能听说过的术语是**关系型数据库管理系统**（**RDBMS**）。RDBMS执行创建、读取、更新和删除（**CRUD**）数据库数据的功能，通过一个底层的软件组件，也就是我们称之为数据库引擎。
- en: An important point to understand here is that when you choose to set up an Amazon
    RDS database, you are setting up a *database instance* with a chosen engine to
    run on that instance. You can then create one or more databases supported by that
    engine on your database instance. This means you can have several databases running
    on an individual database instance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要理解的一个重要点是，当你选择设置 Amazon RDS 数据库时，你是在为选择的引擎设置一个 *数据库实例*，该引擎将在该实例上运行。你可以在数据库实例上创建一个或多个该引擎支持的数据库。这意味着你可以在单个数据库实例上运行多个数据库。
- en: 'Furthermore, on Amazon RDS, when you set up a database instance, you specify
    hardware capabilities in the form of CPU and memory allocation. The type of instance
    will also determine the maximum storage bandwidth and network performance that
    the instance can offer. AWS offers three different types of instance classes with
    varying virtual hardware specifications and is designed for various uses cases.
    These are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 Amazon RDS 上，当你设置数据库实例时，你需要指定硬件能力，形式为 CPU 和内存分配。实例的类型还将决定实例可以提供的最大存储带宽和网络性能。AWS
    提供三种不同类型的实例类，具有不同的虚拟硬件规格，适用于各种使用场景。具体如下：
- en: '**Standard classes (includes m classes**): These classes offer a balance of
    compute, memory, and network resources, and they are ideal for most application
    requirements. Standard classes offer the following specs:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准类（包括 m 类）**：这些类提供计算、内存和网络资源的平衡，适用于大多数应用需求。标准类提供以下规格：'
- en: Between 2 and 96 vCPUs
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介于 2 到 96 个 vCPU 之间
- en: Up to 384 GB of memory
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大支持 384 GB 内存
- en: '**Memory-optimized classes (includes r and x classes)**: These classes are
    ideal for most demanding applications that require greater levels of memory and
    are optimized for memory-intensive applications. Memory-optimized classes offer
    the following specs:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存优化类（包括 r 类和 x 类）**：这些类非常适合需要更高内存水平的高要求应用，并且针对内存密集型应用进行了优化。内存优化类提供以下规格：'
- en: Between 4 and 128 vCPUs
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介于 4 到 128 个 vCPU 之间
- en: Up to 3,904 GB of memory
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大支持 3,904 GB 内存
- en: '**Burstable classes (includes t classes)**: These classes are designed for
    nonproduction databases and provide a baseline performance level, with the ability
    to burst to full CPU usage. Burstable classes are ideal for database workloads
    with moderate CPU usage that experience occasional spikes. Burstable classes offer
    the following specs:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**突发类（包括 t 类）**：这些类专为非生产数据库设计，提供基准性能水平，并能够突发到完全的 CPU 使用率。突发类适用于 CPU 使用量适中的数据库工作负载，这些工作负载偶尔会出现性能高峰。突发类提供以下规格：'
- en: Between 1 and 8 vCPUs
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介于 1 到 8 个 vCPU 之间
- en: Up to 32 GB of memory
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大支持 32 GB 内存
- en: 'The following screenshot shows the different **DB instance class** options
    you can select from:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了你可以选择的不同 **DB 实例类** 选项：
- en: '![Figure 8.3 – Database instance class options'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 数据库实例类型选项'
- en: '](img/B17124_08_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17124_08_03.jpg)'
- en: Figure 8.3 – Database instance class options
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 数据库实例类型选项
- en: 'In addition to the compute resource, Amazon RDS also requires storage capabilities
    to host all the required data. The storage platform runs on Amazon **EBS**, so
    it is decoupled from the actual database instance class. This allows you to upgrade
    the storage volumes without necessarily having to upgrade the instance class and
    vice versa, so long as compatibility is maintained. The volume''s throughput is
    determined by the instance types chosen, as well as the **input/output operations
    per second** (**IOPS**) that the EBS volume supports. AWS offers the following
    different storage options for your databases:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了计算资源外，Amazon RDS 还需要存储能力来托管所有必需的数据。存储平台运行在 Amazon **EBS** 上，因此它与实际的数据库实例类型解耦。这使得你可以升级存储卷，而不必必然地升级实例类型，反之亦然，只要兼容性得到保证。存储卷的吞吐量由选择的实例类型以及
    **每秒输入/输出操作次数** (**IOPS**) 决定。AWS 为你的数据库提供以下不同的存储选项：
- en: '**General Purpose SSD**: Designed for standard workloads and ideal for most
    databases, General Purpose SSD volumes offer between 20 GiB to 64 TiB of storage
    data for MariaDB, MySQL, PostgreSQL, and Oracle databases, and between 20 GiB
    to 16 TiB for Microsoft SQL Server.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用 SSD**：为标准工作负载设计，适用于大多数数据库，通用 SSD 卷为 MariaDB、MySQL、PostgreSQL 和 Oracle
    数据库提供 20 GiB 至 64 TiB 的存储空间，为 Microsoft SQL Server 提供 20 GiB 至 16 TiB 的存储空间。'
- en: The number of IOPS that's achieved is dependent on the size of the storage volume,
    with a baseline I/O performance of 3 IOPS per GiB (minimum 100 IOPS). The larger
    the volume size, the higher the performance; for example, a 60 GiB volume would
    give you 180 IOPS.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 达到的IOPS数量取决于存储卷的大小，基准I/O性能为每GiB 3 IOPS（最少100 IOPS）。卷的大小越大，性能越高；例如，一个60 GiB的卷将提供180
    IOPS。
- en: General Purpose SSDs also offer bursts in performance for volumes less than
    1 TiB in size for extended periods. This means that smaller volumes will get an
    additional performance boost when required and you do not need to allocate unnecessary
    storage for short-term occasional spikes. Bursting is not relevant for volume
    sizes above 1 TiB, however.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通用型SSD还为小于1 TiB的卷提供了延时性能提升。这意味着较小的卷在需要时将获得额外的性能提升，而无需为短期偶发的性能峰值分配不必要的存储。然而，对于大于1
    TiB的卷，性能提升无关紧要。
- en: '**Provisioned IOPS SSD**: AWS recommends using Provisioned IOPS SSDs for production
    applications that require fast and consistent I/O performance. With Provisioned
    IOPS SSDs, you specify the IOPS rate and the size of the volume. Like General
    Purpose SSDs, you can allocate up to 64 TiB of storage, depending on the underlying
    database engine you use. Provisioned IOPS SSD does not offer any bursting, however.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预配置IOPS SSD**：AWS建议对于需要快速且稳定I/O性能的生产应用，使用预配置IOPS SSD。使用预配置IOPS SSD时，你可以指定IOPS速率和卷的大小。与通用型SSD类似，你可以根据使用的底层数据库引擎分配最多64
    TiB的存储。然而，预配置IOPS SSD不提供任何性能提升。'
- en: '**Magnetic**: AWS also offers magnetic storage volumes for backward compatibility.
    They are not recommended for any production environments and are limited to 1,000
    IOPS and up to 3 TiB of storage.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**磁性存储**：AWS还提供了磁性存储卷以支持向后兼容性。它们不建议用于任何生产环境，并且限制为1,000 IOPS和最多3 TiB的存储。'
- en: Ultimately, you can upgrade your storage if required, but this will usually
    require a short outage, typically of a few minutes (for Magnetic, this can take
    much longer), so this must be planned for.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，如果需要，你可以升级存储，但这通常需要短时间的停机，通常为几分钟（对于磁性存储，可能需要更长时间），因此必须提前规划。
- en: Deploying in Amazon VPCs
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署在Amazon VPC中
- en: Amazon RDS is a regional service, which means that you need to select the Region
    you want to deploy your database instance in first. Amazon RDS database instances
    can only be deployed in a VPC, and like EC2 instances, in a specified subnet.
    Since a subnet is always only associated with a single Availability Zone, this
    also means that if there is an Availability Zone failure, your database will not
    be accessible. With Amazon RDS, you can only deploy a **single master database
    instance**. This type of instance can perform both read and write operations to
    the database. Amazon does offer various solutions in case the master database
    instance fails and we look at these options later in this chapter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon RDS是一个区域性服务，这意味着你需要首先选择要部署数据库实例的区域。Amazon RDS数据库实例只能部署在VPC中，并且与EC2实例一样，部署在指定的子网中。由于子网始终只与一个可用区关联，这也意味着如果发生可用区故障，你的数据库将无法访问。使用Amazon
    RDS，你只能部署**单一主数据库实例**。这种类型的实例既能执行读取操作，也能执行写入操作。Amazon确实提供了多种解决方案，以防主数据库实例发生故障，我们将在本章稍后讨论这些选项。
- en: Deploying your RDS database in a VPC gives granular control over how the databases
    is going to be accessed and allows you to configure various network security components
    such as the private IP addressing range you will use, security groups to protect
    your RDS instance, and **Network Access Control Lists** (**NACLs**) to protect
    traffic in the subnet that will host the database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在VPC中部署RDS数据库可以精细控制数据库的访问方式，并允许你配置多种网络安全组件，如你将使用的私有IP地址范围、保护RDS实例的安全组，以及保护将托管数据库的子网中流量的**网络访问控制列表**（**NACLs**）。
- en: 'Deploying your RDS database in a VPC also means that you can configure various
    architectures from which to access that database. The following are some scenarios
    that you could configure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在VPC中部署RDS数据库也意味着你可以配置多种访问该数据库的架构。以下是你可以配置的一些场景：
- en: '`3306` for a MySQL RDS instance.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`3306`用于MySQL RDS实例。'
- en: '**A DB instance in a VPC that''s accessed by an EC2 instance in a different
    VPC**: In [*Chapter 6*](B17124_06_Final_SK_ePub.xhtml#_idTextAnchor122), *AWS
    Networking Services, VPCs, Route53, and CloudFront*, we discussed that you could
    connect two VPCs using a service known as VPC peering. Instances in either VPC
    can then communicate with each other over that peering connection using private
    IP addresses as though they were within the same network. Once the peering connection
    has been established, you would then need to configure the necessary rules for
    your security groups to enable traffic to flow between the EC2 instance and your
    RDS database. VPC peering can allow you to peer connections between VPCs in the
    same Region, cross-Region, and even across AWS accounts.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过不同VPC中的EC2实例访问的VPC中的DB实例**：在[*第6章*](B17124_06_Final_SK_ePub.xhtml#_idTextAnchor122)，*AWS网络服务、VPC、Route53和CloudFront*中，我们讨论了如何使用VPC对等连接服务连接两个VPC。然后，两个VPC中的实例可以通过该对等连接使用私有IP地址进行通信，就像它们在同一网络中一样。一旦建立了对等连接，您就需要配置安全组的必要规则，以使流量能够在EC2实例和RDS数据库之间流动。VPC对等连接可以让您在同一区域内、跨区域，甚至跨AWS账户之间建立对等连接。'
- en: '**A DB instance in a VPC that''s accessed by a client application through the
    internet**: While nothing is stopping you from placing your RDS database instance
    in a public subnet of a VPC, this is not considered a best practice for production
    environments. Databases are considered backend services that contain critical
    and maybe sensitive information. They should always be placed in the private subnet
    of the VPC. Placing your RDS database in a public subnet should only really be
    done for testing purposes or specific use cases.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过互联网访问的VPC中的DB实例**：虽然没有什么可以阻止你将RDS数据库实例放置在VPC的公共子网中，但这并不被认为是生产环境中的最佳实践。数据库被视为包含关键信息且可能是敏感信息的后端服务。它们应该始终放置在VPC的私有子网中。将RDS数据库放置在公共子网中应仅限于测试目的或特定用例。'
- en: '**A DB instance in a VPC that''s accessed by a private network**: With a VPC
    in place, you can set up a VPN tunnel or a Direct Connect service between your
    on-premises network and the VPC. This allows you to place your RDS database in
    a private subnet of the VPC, and still be able to access it from your corporate
    offices via the VPN tunnel or Direct Connect service.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过私有网络访问的VPC中的DB实例**：有了VPC后，您可以在本地网络和VPC之间设置VPN隧道或Direct Connect服务。这使您可以将RDS数据库放置在VPC的私有子网中，并通过VPN隧道或Direct
    Connect服务从公司办公室访问它。'
- en: 'For production environments, always place your RDS database instances in the
    private subnet(s) of your VPC. The architecture shown in the following diagram
    illustrates one such best practice methodology. Here, the RDS database has deployed
    a private subnet, dubbed a **database subnet**. To access the database via a standard
    web application, traffic from the internet is routed via an **Elastic Load Balancer**
    (**ELB**) (discussed in detail in [*Chapter 9*](B17124_09_Final_SK_ePub.xhtml#_idTextAnchor223),
    *High Availability and Elasticity on AWS*) and distributed to web servers placed
    in another set of private subnets within your VPC. Your web servers then connect
    to the RDS database to perform any data operations such as adding, updating, or
    deleting records as required by the application. Traffic can flow based on the
    rules that have been defined by your **Network Access Control Lists** (**NACLs**)
    and security groups:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，始终将RDS数据库实例放置在VPC的私有子网中。以下图所示的架构展示了这种最佳实践方法。在这里，RDS数据库部署了一个私有子网，称为**数据库子网**。为了通过标准Web应用程序访问数据库，来自互联网的流量通过**弹性负载均衡器**（**ELB**）进行路由（在[*第9章*](B17124_09_Final_SK_ePub.xhtml#_idTextAnchor223)，*AWS上的高可用性与弹性*中详细讨论），并分发到放置在VPC内另一组私有子网中的Web服务器。然后，您的Web服务器连接到RDS数据库，执行如添加、更新或删除记录等数据操作，以满足应用程序的需求。流量可以根据**网络访问控制列表**（**NACLs**）和安全组中定义的规则进行流动：
- en: '![Figure 8.4 – Amazon RDS deployed in a VPC in private subnets'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – 在VPC的私有子网中部署的Amazon RDS](img/B17124_08_04.jpg)'
- en: '](img/B17124_08_04.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17124_08_04.jpg)'
- en: Figure 8.4 – Amazon RDS deployed in a VPC in private subnets
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 在VPC的私有子网中部署的Amazon RDS
- en: In the preceding diagram, users from the internet can access the database via
    the web/app server rather than have direct access to the database. Users will
    connect to the web/app servers via an **Application Load Balancer** (**ALB**)
    (which distributes traffic among healthy EC2 instances in the fleet). The web/app
    server will have a process in place to send database operations requests to the
    RDS database in the backend private subnet.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示意图中，互联网用户可以通过 web/app 服务器访问数据库，而不是直接访问数据库。用户将通过**应用负载均衡器**（**ALB**）连接到
    web/app 服务器（该负载均衡器会在健康的 EC2 实例之间分配流量）。web/app 服务器将通过某种流程将数据库操作请求发送到后端私有子网中的 RDS
    数据库。
- en: Note that the RDS database will only accept traffic from the EC2 instances that
    are attached to the appropriate security groups. This ensures that if the EC2
    instances are replaced or if additional EC2 instances are attached to the fleet,
    and if they are attached to the same security sroup, they will be able to communicate
    with the RDS database.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，RDS 数据库只接受来自附加到适当安全组的 EC2 实例的流量。这确保了如果 EC2 实例被替换或附加了新的 EC2 实例，且这些新实例被附加到相同的安全组，它们仍然能够与
    RDS 数据库通信。
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Your applications connect to the backend database via an RDS DNS endpoint name,
    rather than the database instance's specific IP addresses. This allows you to
    easily manage failovers in the event of a disaster, which we will discuss next
    in this chapter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序通过 RDS DNS 端点名称连接到后端数据库，而不是连接到数据库实例的具体 IP 地址。这使得您在发生灾难时能够轻松管理故障切换，我们将在本章的后续内容中讨论这一点。
- en: Backup and recovery
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份与恢复
- en: Your database is going to be very important to you and ensuring that you can
    recover from failures, data loss, or even data corruption is going to be an important
    factor in your design architecture. AWS enables you to address your disaster recovery
    and business continuity concerns, and Amazon RDS comes with several configuration
    options to choose from.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您的数据库对您来说非常重要，确保您能够从故障、数据丢失甚至数据损坏中恢复将是设计架构时的一个重要因素。AWS 使您能够解决灾难恢复和业务连续性问题，而
    Amazon RDS 提供了多个配置选项供您选择。
- en: What are your RPO and RTO requirements?
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 您的 RPO 和 RTO 要求是什么？
- en: 'When deciding on a strategy to protect your database on AWS from unexpected
    failures or data corruption, you need to consider what configuration options are
    going to meet your organization''s expectations for recovery. If your business
    hosts critical data that needs to be recovered fast in the event of a failure,
    you need to design an architecture that will support this requirement. To help
    you identify how critical your recovery is going to be, you need to determine
    your **Recovery Point Objective** (**RPO**) and **Recovery Time Objective** (**RTO**).
    These two parameters will help you design a recovery strategy that meets your
    business requirements:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定在 AWS 上保护数据库免受意外故障或数据损坏时，您需要考虑哪些配置选项能够满足您组织对恢复的期望。如果您的业务托管着关键数据，且在发生故障时需要快速恢复，您需要设计一个能够支持此需求的架构。为了帮助您确定恢复的关键性，您需要确定**恢复点目标**（**RPO**）和**恢复时间目标**（**RTO**）。这两个参数将帮助您设计出符合业务要求的恢复策略：
- en: '**RTO**: This represents the time (in hours) it takes to recover from a disaster
    and return to a working state. The time taken will involve provisioning a new
    database instance, performing a restore job, and any other administrative or technical
    tasks that need to be completed.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RTO**：表示从灾难恢复并返回到工作状态所需的时间（以小时为单位）。恢复所需的时间将包括新建数据库实例、执行恢复操作以及完成其他行政或技术任务。'
- en: '**RPO**: This represents how much data (again, as a measure of time, and generally
    in hours) you will lose in the event of a disaster. The shorter the RPO, the less
    data you are likely to lose in the event of a failure.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RPO**：表示在发生灾难时您会丢失多少数据（同样以时间为单位，通常是小时）。RPO 越短，发生故障时您丢失的数据就越少。'
- en: If your organization stipulates that it can only afford an RTO of 2 hours and
    an RPO of 4 hours, this means that you need to recover from failure to a working
    state within 2 hours and the maximum amount of data you can afford to lose (probably
    because you can create that data) is 4 hours' worth.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的组织规定只能接受 2 小时的 RTO 和 4 小时的 RPO，这意味着您需要在 2 小时内从故障恢复到正常状态，而您能接受的最大数据丢失量（可能因为您可以重新生成这些数据）为
    4 小时的数据量。
- en: Based on your RPO and RTO levels, you can then choose a disaster recovery strategy
    that fits your requirements. For example, if your RPO is set to 4 hours and your
    recovery strategy was based on restoring older backups of your database, then
    you should be performing a backup of your database every 4 hours.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的 RPO 和 RTO 水平，您可以选择符合要求的灾难恢复策略。例如，如果您的 RPO 设置为 4 小时，并且您的恢复策略基于恢复数据库的较旧备份，那么您应每
    4 小时执行一次数据库备份。
- en: High availability with Multi-AZ
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高可用性与多可用区（Multi-AZ）
- en: For Amazon RDS database engines running MariaDB, MySQL, PostgreSQL, Oracle,
    Microsoft SQL, and Amazon Aurora, AWS offers high availability and failover support
    using the **RDS Multi-AZ** solution. Multi-AZ is an architectural design pattern
    where a primary (master) copy of your database is deployed in one Availability
    Zone and a secondary (standby) copy is deployed in another Availability Zone.
    Data is then **synchronously** replicated from the master copy to the standby
    copy continuously. Normally, with relational databases, only one database can
    hold the *master* status, meaning that data can be both written to and read from
    it. In the case of Multi-AZ deployments, this is still true, and the standby copy
    of the database simply receives all the changes that have been made to the master
    synchronously. However, you cannot write or read from the standby directly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行 MariaDB、MySQL、PostgreSQL、Oracle、Microsoft SQL 和 Amazon Aurora 的 Amazon
    RDS 数据库引擎，AWS 提供了使用 **RDS 多可用区** 解决方案的高可用性和故障切换支持。多可用区是一种架构设计模式，其中数据库的主副本部署在一个可用区，而数据库的备用副本则部署在另一个可用区。然后，数据会从主副本同步复制到备用副本，持续进行。通常，对于关系型数据库，只有一个数据库可以保持
    *主* 状态，意味着数据可以同时对其进行写入和读取。在多可用区部署的情况下，这仍然适用，数据库的备用副本只是同步接收主副本所做的所有更改。然而，您无法直接从备用副本进行写入或读取。
- en: 'If the master copy of your database fails, then AWS will perform a failover
    operation to the standby copy of the database. The standby copy will be promoted
    to become the new master, and the previous master will be terminated and replaced
    with another standby copy. Replication will then be initiated in the opposite
    direction. During failover, your application may experience a brief outage (about
    2 minutes), but then will be able to reconnect to the database (the standby copy
    that has been promoted to the new master) and continue operating:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库的主副本发生故障，AWS 将执行故障切换操作，将数据库切换到备用副本。备用副本将被提升为新的主副本，之前的主副本将被终止，并替换为另一个备用副本。随后，复制将会在相反方向启动。在故障切换过程中，您的应用可能会经历短暂的中断（大约
    2 分钟），但之后能够重新连接到数据库（即已被提升为新主副本的备用副本）并继续运行：
- en: '![Figure 8.5 – Amazon RDS configured with Multi-AZ'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 配置了多可用区的 Amazon RDS](img/B17124_08_05.jpg)'
- en: '](img/B17124_08_05.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17124_08_05.jpg)'
- en: Figure 8.5 – Amazon RDS configured with Multi-AZ
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 配置了多可用区的 Amazon RDS
- en: Failover can be triggered for several reasons other than Availability Zone outages,
    including patching the master database or upgrades of the instance. You can also
    perform a failover test to ensure that the configuration has been set up correctly
    by performing a reboot of the master database and requesting a failover operation
    on reboot.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 故障切换可以因多种原因触发，除了可用区故障外，还包括对主数据库进行修补或实例的升级。您也可以执行故障切换测试，以确保配置正确，通过重启主数据库并在重启时请求故障切换操作来验证。
- en: With Multi-AZ, you can reduce your RTO and RPO levels drastically. Because existing
    data has already been replicated to a standby copy in another Availability Zone,
    failover happens in a matter of minutes and data loss is minimized.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过多可用区部署，您可以大幅降低 RTO 和 RPO 水平。因为现有数据已被同步复制到另一个可用区的备用副本，故障切换可以在几分钟内完成，且数据丢失被最小化。
- en: However, in certain circumstances, Multi-AZ alone as a DR strategy may not be
    enough. For example, what happens if there is data corruption on the master copy
    of your database? That corrupted data will be replicated across to the standby
    too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，仅仅依靠多可用区作为灾难恢复（DR）策略可能不足够。例如，如果数据库的主副本发生数据损坏怎么办？那损坏的数据将会同步到备用副本。
- en: Backup and recovery
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份与恢复
- en: 'AWS also offers options to perform regular backups of your database, which
    you can use to perform point-in-time restores. AWS offers two options here: *automatic
    backups* and *manual snapshots*.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 还提供了定期备份数据库的选项，您可以使用这些备份来执行时间点恢复。AWS 提供了两种选项：*自动备份* 和 *手动快照*。
- en: Automatic backups
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动备份
- en: 'AWS offers a fully managed automatic backup service free of cost up to the
    total size of your database. While performing automatic backups, the first snapshot
    that''s created will be a full backup; subsequent snapshots will be incremental,
    ensuring that only changes to the data are backed up. Some additional features
    of automatic backups include the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 提供完全托管的自动备份服务，免费提供至数据库总大小。在执行自动备份时，第一次创建的快照将是完全备份；后续快照将是增量备份，确保只备份数据的变化部分。自动备份的一些附加功能包括：
- en: '**Backup window**: Automatic backups are performed during a predefined window
    that is configurable for the customer. The default backup time allocated is 30
    minutes but you can change this as well. Furthermore, if the backup requires more
    time than what''s been allotted to the backup window, the backup continues after
    the window ends, until it finishes.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**备份窗口**：自动备份将在预定义的窗口内进行，客户可以进行配置。默认的备份时间为 30 分钟，但你也可以更改此时间。此外，如果备份需要的时间超过了分配的备份窗口时间，备份将在窗口结束后继续，直到完成为止。'
- en: '`0` days, which essentially translates to disabling backup operations. If you
    disabled automatic backups at the time of launching your RDS instance, you can
    enable this later by setting the backup retention period to a positive non-zero
    value.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0` 天，这基本上意味着禁用备份操作。如果在启动 RDS 实例时禁用了自动备份，你可以通过将备份保留期设置为正的非零值来稍后启用备份。'
- en: '`LatestRestorableTime`, which is typically the last 5 minutes.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LatestRestorableTime`，通常是最后的 5 分钟。'
- en: Manual snapshots
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动快照
- en: In addition to automatic backups, you can also create manual snapshots of your
    database, which can provide additional protection. You can then use manual snapshots
    to restore your DB instance to a known state as frequently as you like.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动备份，你还可以创建数据库的手动快照，以提供额外的保护。然后，你可以使用手动快照将数据库实例恢复到已知的状态，按需要频繁进行恢复。
- en: Manual snapshots can be very useful if you plan to make a major change to your
    database and would like an additional snapshot before making that change.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计划对数据库进行重大更改，并且希望在更改前再创建一个额外的快照，手动快照非常有用。
- en: Automatic and manual backups are particularly useful if you need to restore
    due to data corruption. Remember that even if you have Multi-AZ enabled, any data
    corruption on the master copy will be replicated across to the standby, and having
    older backups can enable you to revert your database to a time before that data
    corruption occurred.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 自动备份和手动备份在因数据损坏需要恢复时特别有用。请记住，即使启用了多可用区（Multi-AZ），主副本上的任何数据损坏也会复制到备用副本，而拥有较旧的备份可以使你将数据库恢复到数据损坏发生之前的时间点。
- en: Cross-Region snapshots
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨区域快照
- en: You can copy your snapshots across Regions to improve the availability of your
    backups even further, in the event of a regional outage or disaster. You can also
    configure the replication of your automatic backups and transactional logs across
    to another Region. Amazon RDS initiates a cross-Region copy of all snapshots and
    transaction logs as soon as they are ready on the DB instance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将快照复制到其他区域，以进一步提高备份的可用性，以防发生区域性故障或灾难。你还可以配置自动备份和事务日志的复制，将其复制到另一个区域。当 DB 实例上的快照和事务日志准备好时，Amazon
    RDS 会立即启动跨区域复制。
- en: I/O suspense issue
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: I/O 挂起问题
- en: An important behavior pattern to be aware of is that a brief I/O suspension
    (usually lasting only a few seconds) is experienced when your backup process initializes.
    In scenarios where you have a single Database instance deployed, this results
    in a brief outage when connecting to the database. This means that if your backup
    operations are taking place during business hours, then users may experience some
    interruption during the backup process.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要行为模式是，在备份过程初始化时，通常会经历短暂的 I/O 挂起（通常仅持续几秒钟）。在只有单个数据库实例部署的情况下，这会导致连接数据库时出现短暂的中断。这意味着，如果备份操作在工作时间内进行，则用户可能会在备份过程中经历一些中断。
- en: To work around this problem, you can choose to ensure that your backup processes
    take place outside of business hours, or better still, follow Amazon's recommendations
    for deploying a Multi-AZ deployment for database, particularly for MariaDB, MySQL,
    Oracle, and PostgreSQL engines. This is because, in a Multi-AZ configuration,
    the backup is taken from the standby copy of the database and not the master.
    Note that for Microsoft SQL Server, I/O activity is suspended briefly during backup,
    even for Multi-AZ deployments.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal scaling with read replicas
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, relational databases do not scale well horizontally due to their
    architecture. A relational database can normally only have one master copy (the
    copy that you can write data to), which means that if you experience a failure
    on the master copy, you need to resort to restoring data from backups. AWS offers
    Multi-AZ as a means to overcome this single point of failure by enabling you to
    create a standby copy of the database that has data synchronously replicated to
    it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: However, you cannot use a standby copy to perform write or read queries since
    your standby copy is only accessible in the event of the failure of the master
    copy. If the master copy of your database fails, your standby copy gets promoted
    to become the new master copy of the database, upon which you will be reading
    and writing to it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to scaling horizontally, where you can have multiple nodes of
    your database, AWS offers an option to scale read copies of your database using
    a feature called **read replicas**. AWS RDS can use its built-in replication functionality
    for Microsoft SQL, MySQL, Oracle, and PostgreSQL to create additional read replicas
    of the source DB instance. Data is then replicated from the source DB to the replicas
    using *asynchronous* replication. This can help reduce the load on your master
    copy by redirecting read queries to the read replicas instead. Application components
    that only need to read from the database can be routed to send requests to the
    read replicas, allowing your master copy to focus on those applications that need
    to write to the database:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – AWS RDS with read replicas'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_08_06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – AWS RDS with read replicas
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Read replicas can also be configured for cross-Region replication, as depicted
    in the preceding diagram. (The exception is for the Microsoft SQL Server engine,
    which doesn't allow Multi-AZ read replicas or cross-Region read replicas.) This
    means that you can maintain read copies of your database in a different Region
    that can be used by other applications that may only require read access to the
    data. Storing read replicas across Regions can also help you address any compliance
    or regulatory needs that stipulate that you need to maintain copies of your data
    at a considerable distance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: You can also set the read replica as Multi-AZ, which will enable you to use
    the read replicas as a DR target. This means that if you ever need to promote
    the read replica to a standalone database, it will already be configured for Multi-AZ.
    This feature is available for MySQL, MariaDB, PostgreSQL, and Oracle engines.
    Finally you can add up to five read replicas to each DB instance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将读副本设置为多可用区（Multi-AZ），这将使你能够将读副本作为灾难恢复（DR）目标。如果你需要将读副本提升为独立的数据库，它将已经配置为多可用区。此功能适用于
    MySQL、MariaDB、PostgreSQL 和 Oracle 引擎。最后，你可以为每个数据库实例添加最多五个读副本。
- en: Furthermore, in the event of a major disaster, a read replica can also be promoted
    to become the master copy, after which it becomes independent of the original
    master copy of the database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在发生重大灾难时，读副本也可以被提升为主副本，此后它将独立于原始的主数据库副本。
- en: In this section, we examined Amazon RDS and the key offerings by its managed
    RDS. We reviewed the various database engines on offer, concepts related to high
    availability and scalability, as well as backup and recovery.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们探讨了亚马逊 RDS 及其管理型 RDS 的关键功能。我们回顾了提供的各种数据库引擎、与高可用性和可扩展性相关的概念，以及备份和恢复。
- en: In the next section, we will briefly look at one AWS RDS offering, specifically
    Amazon Aurora. While Amazon Aurora is an RDS database solution from AWS, it offers
    several enhanced capabilities.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将简要介绍 AWS RDS 的一项服务，特别是亚马逊 Aurora。虽然亚马逊 Aurora 是 AWS 提供的 RDS 数据库解决方案，但它提供了几项增强的功能。
- en: A brief introduction to Amazon Aurora
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亚马逊 Aurora 简介
- en: Amazon Aurora is AWS's proprietary MySQL- and PostgreSQL-compatible database
    solution and was designed for enterprise-grade production environments. Amazon
    Aurora comes with a vast array of features that enable you to design your database
    solution with high availability, scalability, and cost-effective deployments to
    suit a variety of business needs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊 Aurora 是 AWS 的专有 MySQL 和 PostgreSQL 兼容数据库解决方案，旨在企业级生产环境中使用。亚马逊 Aurora 提供了丰富的功能，帮助你设计具有高可用性、可扩展性和成本效益的数据库解决方案，以满足各种业务需求。
- en: Amazon Aurora is architected to offer high resilience, with copies of the database
    placed across a minimum of three Availability Zones, It is up to five times faster
    than standard MySQL databases and three times faster than standard PostgreSQL
    databases.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊 Aurora 采用高韧性架构，数据库副本分布在至少三个可用区。它比标准 MySQL 数据库快五倍，比标准 PostgreSQL 数据库快三倍。
- en: The service offers *fault tolerance* and *self-healing storage capabilities*
    that can scale up to 128 TB per database instance. Amazon Aurora also offers the
    ability to host up to 15 low latency read replicas. Let's review some of the key
    features of Amazon Aurora.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务提供 *容错* 和 *自愈存储能力*，可以将每个数据库实例的规模扩展到 128 TB。亚马逊 Aurora 还支持最多 15 个低延迟的读副本。让我们回顾一下亚马逊
    Aurora 的一些关键特性。
- en: Amazon Aurora DB clusters
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 亚马逊 Aurora 数据库集群
- en: Amazon Aurora is deployed as **DB clusters** that consist of one or more **DB
    instances** and a *cluster volume*. This cluster volume spans multiple Availability
    Zones, within which copies of the cluster data are stored.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊 Aurora 被部署为由一个或多个 **数据库实例** 和 *集群存储卷* 组成的 **数据库集群**。该集群存储卷跨多个可用区，其中存储着集群数据的副本。
- en: 'The Aurora DB cluster is made of up two types of DB instances, as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Aurora 数据库集群由两种类型的数据库实例组成，如下所示：
- en: '**Primary DB instance**: This instance supports both read and write operations,
    and it performs all of the data modifications to the cluster volume. You have
    *one* Primary DB instance.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主数据库实例**：该实例支持读写操作，并执行所有数据修改操作到集群存储卷。你只有 *一个* 主数据库实例。'
- en: '**Aurora Replica**: You can have up to 15 Aurora Replicas in addition to the
    primary DB instance. Aurora Replicas connect to the same storage volume as the
    primary DB instance but are only used for read operations. You use Aurora Replicas
    as a failover option if the primary DB instance fails. You can also offload read
    queries from the primary DB instance to the replicas.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Aurora 副本**：除了主数据库实例外，你可以有最多 15 个 Aurora 副本。Aurora 副本连接到与主数据库实例相同的存储卷，但仅用于读操作。当主数据库实例发生故障时，你可以将
    Aurora 副本用作故障转移选项。你也可以将主数据库实例的读取查询卸载到副本上。'
- en: With regard to the architecture, DB instances (compute capacity) and cluster
    volume (storage) are decoupled, as illustrated in the following diagram.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构方面，数据库实例（计算能力）和集群存储卷（存储）是解耦的，如下图所示。
- en: '![Figure 8.7 – Amazon Aurora DB cluster architecture'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 亚马逊 Aurora 数据库集群架构](#)'
- en: '](img/B17124_08_07.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17124_08_07.jpg)'
- en: Figure 8.7 – Amazon Aurora DB cluster architecture
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – Amazon Aurora DB 集群架构
- en: This decoupling of the computer capacity and storage also means that even a
    single DB instance is still a cluster due to the fact storage volumes are spread
    across multiple storage nodes, across multiple Availability Zones.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 计算能力和存储的解耦还意味着，即使是单个 DB 实例，由于存储卷分布在多个存储节点和多个可用区之间，它仍然是一个集群。
- en: With regards to provisioning your DB instances, you have a choice of two instance
    classes. These are memory optimized (designed for memory-intensive workloads)
    and burstable performance (which provides a baseline performance level with the
    ability to burst to full CPU usage).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 DB 实例时，你可以选择两种实例类别。这些类别分别是内存优化型（为内存密集型工作负载设计）和突发性能型（提供基准性能水平，并能在需要时提供完整
    CPU 使用率的突发能力）。
- en: While the standard Amazon Aurora deployment seems somewhat similar to deploying
    an Amazon RDS database, where you choose the compute capacity and underlying storage,
    AWS also offers a serverless alternative, which we will look at briefly next.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标准的 Amazon Aurora 部署看起来与部署 Amazon RDS 数据库类似，你需要选择计算能力和基础存储，AWS 也提供了一个无服务器的替代方案，接下来我们将简要介绍。
- en: Amazon Aurora Serverless
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Amazon Aurora Serverless
- en: Amazon Aurora Serverless (version 1) is an on-demand autoscaling configuration
    for Amazon Aurora. The DB Cluster automatically scales compute capacity up and
    down based on your requirements. The serverless alternative automatically starts
    up, scales compute capacity to match your application's usage, and shuts down
    when it's not in use. Furthermore, the cluster volume is always encrypted.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon Aurora Serverless（版本 1）是 Amazon Aurora 的按需自动扩展配置。DB 集群根据需求自动扩展计算能力，并且在不使用时会自动关闭。无服务器的替代方案会根据应用程序的使用情况自动启动，扩展计算能力，并在不使用时关闭。此外，集群的存储卷始终加密。
- en: In terms of use cases, Amazon Aurora Serverless is ideal for applications with
    unpredictable workloads. Another use case is where you have a lightweight application
    that experiences peaks for 30 minutes to several hours a few times a day or perhaps
    at regular intervals throughout the year. Examples include budgeting, accounting,
    and reporting applications.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用场景方面，Amazon Aurora Serverless 非常适合工作负载不可预测的应用程序。另一个使用场景是你有一个轻量级应用程序，它每天可能会经历
    30 分钟到几小时的高峰，或者在一年中的规律性时间间隔内出现高峰。例子包括预算、会计和报告应用程序。
- en: In this section, we were briefly introduced to the Amazon Aurora Service. In
    the next section, we will examine Amazon DynamoDB, which is AWS's non-relational
    (NoSQL) database offering.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要介绍了 Amazon Aurora 服务。在下一节中，我们将研究 Amazon DynamoDB，这是 AWS 提供的非关系型（NoSQL）数据库服务。
- en: Learning about Amazon DynamoDB (NoSQL database solution)
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Amazon DynamoDB（NoSQL 数据库解决方案）
- en: Amazon offers a fully managed non-relational database solution called Amazon
    DynamoDB. Unlike AWS's relational database offerings (excluding Amazon Aurora,
    which also has a serverless offering, as discussed earlier), you do not need to
    worry about provisioning the right DB instance with the right specification for
    your application. DynamoDB is offered as a serverless solution because you do
    not need to define any database instance configuration, such as CPU or memory
    configuration. Amazon manages the underlying infrastructure that hosts the DynamoDB
    service.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Amazon 提供了一种完全托管的非关系型数据库解决方案，称为 Amazon DynamoDB。与 AWS 提供的关系型数据库服务（不包括 Amazon
    Aurora，它也有无服务器选项，如前所述）不同，你不需要担心为应用程序配置合适的 DB 实例。DynamoDB 提供了一个无服务器的解决方案，因为你不需要定义任何数据库实例配置，例如
    CPU 或内存配置。Amazon 管理着托管 DynamoDB 服务的基础设施。
- en: DynamoDB is a regional service just like Amazon RDS, but it comes with higher
    levels of scalability and high availability. You do not need to provision a single
    DB instance in one Availability Zone as you do with a single instance of an Amazon
    RDS database. Instead, when you provision a DynamoDB table, Amazon provisions
    the database and automatically spreads the data across several servers to handle
    your throughput and storage requirements. All data is stored on **solid-state
    disks** (**SSDs**) and the underlying storage is replicated across multiple Availability
    Zones.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB 是一个区域性服务，类似于 Amazon RDS，但具有更高的可扩展性和高可用性。你不需要像配置单个 Amazon RDS 数据库实例那样，在一个可用区中配置单个
    DB 实例。相反，当你配置 DynamoDB 表时，Amazon 会自动配置数据库，并将数据分布在多个服务器上，以满足你的吞吐量和存储需求。所有数据都存储在**固态硬盘**（**SSDs**）上，底层存储会在多个可用区之间进行复制。
- en: The architecture of DynamoDB means that it can be used for use cases that are
    similar Amazon RDS's, although they are more ideal for applications that can have
    millions of concurrent users and where the application needs to perform thousands
    of reads and writes per second.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: DynamoDB的架构意味着它可以用于类似于Amazon RDS的使用场景，尽管它们更适用于可以拥有数百万并发用户的应用程序，以及需要每秒执行数千次读写操作的场景。
- en: Tables, items, and attributes
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表格、项和属性
- en: 'Let''s look at the core components of a DynamoDB database:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下DynamoDB数据库的核心组件：
- en: '**Tables**: Like Amazon RDS databases, your data is stored in tables. So, you
    can have a customers table that will host information about your customers and
    their orders. Each table will also have a unique primary key, which is crucial
    for uniquely identifying every record in the table. Records are known as items
    in DynamoDB Tables.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表格**：像Amazon RDS数据库一样，你的数据存储在表格中。因此，你可以有一个客户表来存储客户和他们订单的信息。每个表也会有一个唯一的主键，这是唯一标识表中每个记录的关键。记录在DynamoDB表格中被称为项。'
- en: '`400 KB` in size and can contain key-value pairs called attributes.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`400 KB`大小，可以包含称为属性的键值对。'
- en: '`First-Name` or `Last-Name` and so on.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`First-Name`或`Last-Name`等。'
- en: Unlike Amazon RDS, you do not need to predefine the schema of the table. This
    offers greater flexibility as your table evolves. Other than the primary key,
    you can add new attributes and define them to expand the table at will.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与Amazon RDS不同，你不需要预定义表的模式。这提供了更大的灵活性，因为你的表会随着时间的推移而发展。除了主键外，你可以添加新的属性并定义它们，以便根据需要扩展表格。
- en: Furthermore, the items don't have to have a value for all attributes – so, for
    example, you can have a table that contains customer address details, their orders,
    and their favorite dessert for a restaurant. Some items may have a value set against
    the favorite dessert, while some may not, and this is perfectly fine.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，项不必为所有属性都有值——例如，你可以有一个包含客户地址信息、订单和他们在餐厅最喜欢的甜点的表格。有些项可能会有关于最喜欢甜点的值，而有些可能没有，这完全没问题。
- en: 'However, attributes need to have data types defined. The following are the
    options that are available here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，属性需要定义数据类型。以下是这里可用的选项：
- en: '**Scalar**: This only has one value and it can be a number, string, binary,
    Boolean, or null.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标量**：只有一个值，可以是数字、字符串、二进制、布尔值或null。'
- en: '**Set**: This represents multiple scalar values and can be a string set, number
    set, or binary set.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：表示多个标量值，可以是字符串集合、数字集合或二进制集合。'
- en: '**Document**: This is a complex structure with options for nested attributes.
    You can use JSON formatted documents and retrieve data you need without having
    to retrieve the entire document. There are two subtypes of the document data type:'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**：这是一个复杂的结构，提供了嵌套属性的选项。你可以使用JSON格式的文档，并检索你需要的数据，而无需检索整个文档。文档数据类型有两个子类型：'
- en: '**List**: An ordered collection of values'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：一组有序的值'
- en: '**Map**: An unordered collection of name-value pairs'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射**：一组无序的名称-值对'
- en: In this section, we examined the different components of a DynamoDB database.
    In the next section, we will learn how to provision the required capacity for
    our database requirements.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们审视了DynamoDB数据库的不同组件。在下一节中，我们将学习如何为我们的数据库需求提供所需的容量。
- en: Provisioning capacity for DynamoDB
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为DynamoDB提供容量
- en: When it comes to provisioning your database, all you need to provide is the
    parameters that define the **read capacity units** (**RCUs**) and **write capacity
    units** (**WCUs**). These values enable Amazon to determine the underlying infrastructure
    to provision to host your database and your throughput levels.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供数据库容量时，你只需要提供定义**读取容量单位**（**RCUs**）和**写入容量单位**（**WCUs**）的参数。这些值使得Amazon能够确定为托管你的数据库和吞吐量级别而配置的底层基础设施。
- en: Depending on your RCU and WCU, DynamoDB will provision one or more partitions
    to store your data in and use the primary key to distribute your items across
    multiple partitions. Spreading data across multiple partitions enables DynamoDB
    to achieve ultra-low latency reads and writes, regardless of the number of items
    you have in the table.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的RCU和WCU，DynamoDB将分配一个或多个分区来存储你的数据，并使用主键将你的项分布到多个分区。将数据分布到多个分区使得DynamoDB能够实现超低延迟的读写操作，无论你表中有多少项。
- en: 'The two options that are available for provisioning capacity are as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 提供容量的两种选项如下：
- en: '**On-Demand**: DynamoDB will provision capacity based on your read and write
    requests and provision capacity dynamically. This option is ideal when you have
    unpredictable application traffic and unknown workloads.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Provisioned**: You specify the number of reads and writes per second that
    are required by your application. This is ideal if you have predictable application
    access patterns. You can always also enable *auto-scaling* to automatically adjust
    to traffic changes.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we looked at Amazon DynamoDB and AWS's non-relational database
    solution. We discovered how DynamoDB is suitable for modern web applications that
    require thousands of reads and writes per second, as well as how DynamoDB is built
    for this purpose specifically.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at Amazon's data warehousing solution, known
    as Amazon Redshift.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the use cases for Amazon Redshift and data warehousing
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A data warehousing solution is a specialized database solution designed to pull
    data from other relational databases and enable complex querying and analytics
    to be performed across different datasets. For example, you can combine data across
    customer orders, inventory data, and financial information to analyze product
    trends, demands, and return on investments.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Clients of Amazon Redshift include **business intelligence** (**BI**) applications,
    reporting, and analytics toolsets.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Online Analytical Processing (OLAP)
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Amazon Redshift is designed for analytics and is optimized for scanning many
    rows of data for one or multiple columns. Instead of organizing data as rows,
    Redshift transparently organizes data by columns; it converts the data into columnar
    storage for each of the columns. Let's look at what this means.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: In a traditional database, data for each record is stored as rows. The columns
    represent the attributes of your data, and each row will contain field values
    for the relevant columns.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a table we saw earlier and see how the data is stored in blocks
    on disk:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Data stored in blocks on disk'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_08_08.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Data stored in blocks on disk
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Note that the data is stored sequentially for each column that makes up the
    entire row in blocks on the disk (*block 1, 2, 3, and so on*). If the record size
    is greater than the block size, then the record is stored across more than one
    block. Similarly, if the record size is smaller than the block size, then the
    record may consume less than the size of one block. Ultimately, this way of storing
    data leads to inefficiencies in the use of storage.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, in a traditional relational database, most transactions will
    involve frequent read and write queries for a small set of records at a time,
    where the entire record set needs to be retrieved.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at how Redshift stores data. Using the same customer data
    table, each data block stores values of a single column for multiple rows, as
    per the following diagram:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Data stored on Amazon Redshift'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_08_09.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Data stored on Amazon Redshift
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Redshift converts the data as it is added into columnar storage. With
    this architecture, Amazon Redshift can store column field values for as many as
    three times the number of records compared to traditional row-based database storage.
    This means that you only consume a third of the I/O operations when it comes to
    reading column field values for a given set of records, compared to row-wise storage.
    Furthermore, because the data that's stored in blocks will be of the same type,
    you can use a compression method design for the columnar data type to achieve
    even better I/O and reduce the overall storage space. This architecture works
    well for data warehousing solutions because, by its very nature, your queries
    are designed to read only a few columns for a very large number of rows to extract
    data for analysis. In addition, queries require a fraction of the memory that
    would be required for processing row-wise blocks.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, Redshift is designed to host petabytes of data and supports massively
    parallel data processing for high-performance queries.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Redshift architecture
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Redshift architecture is built on a cluster model that is comprised of
    the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**Leader node**: A single node that manages all communications between client
    applications and with *compute nodes*. The leader node carries out all operations
    such as the steps required to carry out various complex queries – the leader node
    will compile code and distribute these to compute nodes.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`128` compute nodes can be part of a Redshift cluster. The compute nodes execute
    the compiled code that was provided by the leader node and sends back intermediate
    results for the final aggregation. Each compute node will have its own dedicated
    CPU, memory, and disk type, which determines the node''s type:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dense compute nodes**: These can store up to 326 TB of data on magnetic disks.'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dense storage nodes**: Can store up to 2 PB of data on **solid-state disks**
    (**SSDs**).'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RA3 instances**: This next generation of Nitro-powered compute instances
    come with *managed storage* (unlike the other previous node types). You choose
    some nodes based on your performance requirements and only pay for the managed
    storage that you consume. This architecture has the compute and storage components
    decoupled. Furthermore, data storage is split, whereby local SSD storage is used
    for fast access to cached data and Amazon S3 is used to use longer-term durable
    storage that scales automatically. You will need to upgrade your dense compute
    and dense storage nodes if you wish to make use of managed storage.'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we introduced you to the Amazon Redshift service, a cloud-hosted
    data warehousing solution designed for **OLAP** operations. In the next section,
    we will look at another feature of Amazon Redshift known as the Redshift Spectrum
    service, which allows you to directly query data held in Amazon S3.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: About Redshift Spectrum
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another solution from Amazon Redshift is the **Redshift Spectrum** service,
    which allows you to perform SQL queries against data stored directly on Amazon
    S3 buckets. This is particularly useful if, for instance, you store frequently
    accessed data in Redshift and some infrequent data in Amazon S3\. Rather than
    import the infrequent data into Redshift, which will only be queried occasionally,
    storing them in Amazon S3 and using Redshift Spectrum will be more cost-effective.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that data in S3 must be structured and you must
    define the structure to enable Redshift to consume it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the importance of in-memory caching options with Amazon Elasticache
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you will find yourself accessing a set of data regularly, which is what
    we term as frequently accessed data. Every time you run a query on the database,
    you consume resources to perform the query operation and then retrieve that data.
    Overall, this can add additional load to your database and may even affect performance
    as you constantly write new data to the database.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: As part of your overall application architecture, you should consider using
    in-memory caching engines offered by AWS to alleviate the load on your primary
    databases. **Amazon Elasticache** is a web service that offers in-memory caching
    in the cloud. By caching frequently accessed data on Amazon Elasticache, applications
    can be configured to retrieve frequently accessed data from it rather than make
    more expensive database calls.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS offers two in-memory caching engines, as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Elasticache for Redis**: This is built as a cluster, which is a collection
    of one or more cache nodes, all of which run an instance of the Redis cache engine
    software. Redis is designed for **complex data types**, offers Multi-AZ capabilities,
    encryption of data, and compliance with FedRAMP, HIPAA, and PCI-DSS, as well as
    high availability and automatic failover options.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Elasticache for Memcached**: This is designed for **simple data types**.
    Here, you can run large nodes with multiple cores or threads and scale out. It
    should be used where you require object caching.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned about the various AWS Elasticache services, which
    offer in-memory caching capabilities for our applications. In-memory caching can
    be used to alleviate the load on your primary databases by caching frequently
    access data rather than having to run expensive queries repeatedly. In the next
    section, we will look at some additional databases offered by AWS that address
    specific niche market requirements.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Learning about additional database services for specific niche requirements
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to Amazon RDS and DynamoDB, AWS also offers additional databases
    that meet the requirements of specific niche applications. In this section, we
    will take a look at two of those databases: **Amazon Neptune** and **Amazon Quantum
    Ledger Database** (**QLDB**).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Amazon Neptune
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Amazon Neptune is a fully managed graph database service and a type of NoSQL
    database. Graph databases are designed to store data as nodes (person, place,
    location, and so on) and directions. Each node would have some property and nodes
    have relationships between them. So, for example, **Alice** lives in **London**,
    and in **London**, there is a resident called **Alice**. This is a simple example,
    but you can start to imagine how complex your nodes and their relationships can
    become. These kinds of complex relationships between the nodes are just as important
    as the data itself and are ideal for a graph database solution. Traditional relational
    databases would require you to define complex joins between tables and even then,
    this would result in inefficiencies when trying to extract data.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Neptune support well-known graph models such as Property Graph and W3C's
    RDF and their respective query languages such as Apache TinkerPop, Gremlin, and
    SPARQL. Amazon Neptune is a highly available database solution that offers point-in-time
    recovery and continuous backups to Amazon S3 with Availability Zone replication.
    Typical use cases for Amazon Neptune include applications such as fraud detection,
    knowledge graphs, drug discovery, and network security.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Amazon QLDB
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some types of data are highly sensitive and maintaining data integrity is of
    paramount importance. Examples of this include bank transaction records, where
    you need to track the history of credits and debits, or insurance claim applications
    that require you to maintain a verifiable history of the claim process. Another
    example is that of having to trace the movement of parts in a supply chain network
    and being able to prove the journey those items took to reach the customer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Although you can use relational databases to host these ledger types of data,
    you would need to build in an audit trail, which can be very cumbersome and prone
    to errors. Furthermore, because data stored in relational databases is not inherently
    immutable, it can become difficult to verify if data has been altered or deleted.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: An alternative solution is to build a **blockchain** network. Blockchain frameworks
    such as Hyperledger Fabric and Ethereum enable you to build decentralized databases
    where the data stored is immutably and is cryptographically verifiable. However,
    blockchain networks are very complex and are designed on a decentralized model
    where you have multiple nodes that need to verify each record before it is committed
    to the database.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazon **QLDB** is a fully managed ledger database that enables you to store
    immutable records with cryptographically verifiable transaction logs in a centralized
    database model. Amazon QLDB can maintain a history of all data changes. The following
    are the key benefits of Amazon QLDB:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**Immutable and transparent**: It enables you to track and maintain a sequence
    transaction log (journal) of every single change you make to your data. With QLDB,
    this transaction log is immutable, which means it cannot be altered or deleted.
    QLDB tracks each application data change and maintains a complete and verifiable
    history of all changes over time.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cryptographically verifiable**: You can use a SHA 256 cryptographic hash
    function to generate secure output files of your data''s change history. This
    is also known as a *digest*, which acts as proof of any changes that have been
    made to your data. This can validate the integrity of all your data changes.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to use**: It uses a flexible document data model. You can use a SQL-like
    query language to query your data known as PartiQL. Amazon QLDB transactions are
    ACID-compliant.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serverless**: Amazon QLDB is a fully managed database service with no need
    to provision database instances or worry about capacity restraints. You start
    by creating a ledger and defining your tables. At this point, QLDB will automatically
    scale as required by your application.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we examined a couple of additional database solutions designed
    for niche applications. In the next section, we will look at the database migration
    services offered by AWS, enabling you to move your on-premises databases to the
    cloud.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Database Migration Service
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon offers a **Database Migration Service** (**DMS**) that can be used to
    migrate data from one database to another. Often, this is used as part of an on-premises
    to cloud migration strategy, where you need to migrate database services located
    in your data center to your AWS account in the cloud. AWS DMS offers support for
    both homogeneous migrations, such as from MySQL to MySQL or Oracle to Oracle,
    as well as heterogeneous migrations between engines, such as Oracle to Microsoft
    SQL Server or Amazon Aurora.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: An important point to be aware of is that, while migrating, you can continue
    to use your source database, which minimizes downtime for your business operations.
    In addition, you can also use DMS to perform continuous data replication from
    your on-premises environment to the cloud to offer high availability or disaster
    recovery capabilities.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.1 – Extending your VPC to host database subnets
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B17124_07_Final_SK_ePub.xhtml#_idTextAnchor157), *AWS Compute
    Services*, you expanded your VPC to include both private subnets and public subnets.
    Generally, you would only host services in a public subnet that would need direct
    exposure on the internet. Examples include the bastion host server we deployed
    earlier in [*Chapter 7*](B17124_07_Final_SK_ePub.xhtml#_idTextAnchor157), *AWS
    Compute Services* (which we will discuss in the next chapter).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Most applications are deployed across tiers – so, for example, you can have
    a web tier, an application tier, and a database tier. These different tiers are
    designed to separate different components of your application stack, allowing
    you to create a degree of isolation, as well as benefit from a layered security
    model. In [*Chapter 7*](B17124_07_Final_SK_ePub.xhtml#_idTextAnchor157), *AWS
    Compute Services* , as part of *Exercise 7.1 – Expanding ProductionVPC so that
    it includes two public subnets and two private subnets*, you also configured two
    private subnets across two Availability Zones to host your application servers.
    In this example, the application tier and web tier are the same. However, in many
    real-world scenarios, they would be separate.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you will be extending your VPC to add an additional tier,
    known as the database tier, within which you will be able to launch an Amazon
    RDS database. Like EC2 instances, Amazon RDS needs to be deployed in a VPC.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you can see that your VPC now has three tiers – a
    public (DMZ) tier to host bastion host servers, NAT gateways, and Elastic Load
    Balancers, an application tier comprised of the **Private Subnet One – App** and
    **Private Subnet Two – App** subnets, and finally, a database tier comprised of
    the **Private Subnet Three – Data** and **Private Subnet Four – Data** subnets.
    Note that the subnets are spread across two Availability Zones to enable you to
    offer high availability of services in the event of an Availability Zone failure.
    We will discuss high availability in more detail in the next chapter:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Extending the VPC to include a database tier'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_08_10.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Extending the VPC to include a database tier
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by extending your VPC so that it includes our database tier:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Log back into your AWS account as our administrator, **Alice**.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the **VPC** dashboard and ensure you are in the **US-East-1** Region.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the left-hand menu, click on **Subnets**.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, click the **Create subnet** button in the top right-hand corner of the
    screen.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will be presented with the **Create subnet** wizard page.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **VPC ID**, select **ProductionVPC** from the drop-down menu.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Subnet settings** section, under **Subnet 1 of 1**, provide a name
    for your first database subnet. For this exercise, name your subnet **Private
    Subnet Three – Data**.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Availability Zone**, select the **us-east-1a** Availability Zone.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, for `10.0.5.0/24`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, rather than create this subnet and repeat the wizard to create the second
    database subnet, simply click on the **Add new subnet** button, as per the following
    screenshot:![Figure 8.11 – Creating multiple subnets
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17124_08_11.jpg)'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.11 – Creating multiple subnets
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A new subsection, **Subnet 2 of 2**, will appear, allowing you to create an
    additional subnet in the same wizard. Under **Subnet name**, type in **Private
    Subnet Four – Data**.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For **Availability Zone**, select the **us-east-1b** Availability Zone from
    the drop-down list.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `10.0.6.0/24`.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create subnet** button at the bottom of this page.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AWS will successfully create two new subnets, which you will use to host your
    Amazon RDS database. In the right-hand menu, click on **Subnets** to view all
    the subnets now associated with your **ProductionVPC**, as per the following screenshot:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Subnets in ProductionVPC'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_08_12.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – Subnets in ProductionVPC
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have created an additional two subnets for your **ProductionVPC**,
    you can proceed with the next part of this exercise. Like EC2 instances, Amazon
    RDS databases require you to configure the necessary security groups that will
    permit traffic to the database instances.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'In our layered security model, we wish to ensure that only our application
    servers will be able to communicate with the databases in the backend. In this
    part of the exercise, you will create a new security group that will be configured
    to allow database-relevant traffic from any application servers you deploy later.
    To do this, you must configure an inbound rule on the new database security group
    to accept traffic on port `3306` for MySQL traffic from the security group of
    the application servers, specifically from the **AppServers-SG** security group.
    Let''s get started:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you are currently in the **VPC** dashboard. Then, from the left-hand
    menu, click on **Security Groups**.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create security group** button in the top right-hand corner of the
    screen.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Database-SG`. Under description, type in `Allow MYSQL traffic from AppServer-SG`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **VPC**, ensure you select **ProductionVPC** from the drop-down list.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the **Inbound rules** section, click on the **Add rule** button.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Type**, select **MySQL/Aurora**.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that `sg-`. You should see that a list of all security groups shows up
    in a list. Select the **AppServers-SG** security group.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide an optional description if required.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Create security group** button in the bottom right-hand corner
    of the screen.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS will now confirm that the security group has been created successfully.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you extended your VPC to host two additional private subnets
    that we will use to host our Amazon RDS database. You also created a new security
    group, `3306` from any EC2 instance that is associated with the **AppServer-SG**
    security group.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will configure an Amazon RDS database subnet group
    that will be used to inform Amazon RDS of which subnets it can deploy our databases
    to.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.2 – Creating a database subnet group
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can launch an RDS database in your VPC, you need to define a DB subnet
    group. A **DB subnet group** is a collection of two or more subnets within the
    VPC where you want to deploy your database instance. When creating your DB subnet
    group, at least two subnets must be selected in the VPC that are associated with
    two separate Availability Zones in a Region. Amazon RDS uses the subnet group's
    IP address CIDR block to assign your RDS database instance(s) with an IP address.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Amazon RDS can then deploy the database instance on one of your chosen subnets
    that is part of the group. In the case of a Multi-AZ deployment, the master copy
    will be deployed in one subnet in a particular Availability Zone, while the standby
    copy will be deployed in another subnet that is hosted within another Availability
    Zone.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Note that the subnets in a DB subnet group are either public or private, but
    they cannot be a mix of both public and private subnets. Ideally, you want to
    configure private subnets as part of your subnet group because you want to deploy
    any backend databases in the private subnets of your VPC. Your databases should
    only be accessible from web/application servers and not directly from the internet.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up the DB subnet group, follow these steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you are logged into your **AWS Management Console** as the IAM user
    **Alice**.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the top left-hand menu, click on the **Services** drop-down arrow and select
    **RDS** located under the **Database** category. This will take you to the Amazon
    RDS dashboard.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you are in the **us-east-1** Region and from the left-hand menu,
    click on **Subnet groups**.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, in the main pane of the screen, click the **Create DB Subnet Group** button.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the page that appears, you will need to define your DB subnet group details:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a name for your DB subnet group; for example, `ProductionVPC-DBSubnet`.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the description, type in `DB Subnet Group to host RDS Database in Production
    VPC`.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Under **VPC**, select **ProductionVPC** from the drop-down menu.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, under **Availability Zone**, choose the Availability Zones that include
    the subnets you want to add. For this exercise, select the checkboxes next to
    **us-east-1a** and **us-east-1b**.
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, under `10.0.5.0/24` and `10.0.6.0/24` Ipv4 CIDR blocks, as per the following
    screenshot:![Figure 8.13 – Creating database subnet groups
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17124_08_13.jpg)'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.13 – Creating database subnet groups
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, click the **Create** button at the bottom right-hand corner of the screen.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'AWS will create your DB subnet group using the details you provided, as per
    the following screenshot:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Successfully creating a database subnet group'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_08_14.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Successfully creating a database subnet group
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you learned about RDS DB subnet groups, which allow you to
    define a minimum of two subnets across two Availability Zones, where Amazon RDS
    can deploy your RDS DB instance when you choose to launch your database.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, we will launch our RDS database in **ProductionVPC**.
    We will also use this database to host the backend data of our web application,
    which we will then deploy in the fourth exercise of this next chapter.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.3 – Launching your Amazon RDS database in ProductionVPC
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, you will launch an Amazon RDS MySQL database in the DB subnet
    group of **ProductionVPC**. Let''s get started:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you are logged into your AWS account as the IAM user **Alice**.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the Amazon RDS dashboard.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the left-hand menu, select **Databases**.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the right-hand side of the pane, click the **Create database** button.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you will be presented with the `t2.micro` database instance running the
    MySQL engine as part of the Free Tier offering, which comes with the following
    features for up to 12 months:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 750 hours of Amazon RDS in a Single-AZ db.t2.micro instance.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20 GB of General Purpose storage (SSD).
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 20 GB for automated backup storage and any user-initiated DB snapshots.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For **Choose a database creation method**, select the option next to **Standard
    create**.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, for the database engine option, select **MySQL**.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the **Edition** and **Version** settings as-is.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Templates**, select the **Free Tier** option.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you need to provide some settings:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the DB instance identifier, type in `productiondb`.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Under **Credential Settings**, leave the **Master** username set to **admin**
    and provide a password of your choice. Make sure that you note this password down;
    otherwise, you will not be able to connect to the database.
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Under **Database instance class**, leave the settings as-is.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Storage**, leave the settings as-is except for **Storage autoscaling**,
    where you should *disable* the option for **Enable storage autoscaling**.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Availability & durability**, you will note that the option to enable
    **Multi-AZ** is grayed out. This is because Multi-AZ is not available in the Free
    Tier.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, under `productionvpc-dbsubnet`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under `3306`.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Database authentication options**, ensure that **Password authentication**
    is enabled.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under `productiondb`.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave **DB parameters group** and **Options group** as-is.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Backups**, ensure that **Enable automatic backups** is enabled and then
    set **Backup retention period** to **1 Day**.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Backup window**, select the **No preference** option. For real-world
    applications, you may wish to set the backup window to a period outside of normal
    business hours.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the **Maintenance** subheading, leave the settings as-is.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click the **Create database** button at the bottom right-hand corner
    of the screen.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your RDS database will take a few minutes to launch. As part of the launch
    process, an initial backup will also be performed. Once the database has been
    successfully launched and ready to use, you will see that its **Status** will
    be set to **Available**, as per the following screenshot:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – RDS database created successfully notification'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_08_15.jpg)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – RDS database created successfully notification
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will learn how to deploy a DynamoDB table.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 8.4 – Deploying an Amazon DynamoDB table
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, you will deploy a very simple DynamoDB table. Let''s get
    started:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you are logged into your AWS account as the IAM user known as **Alice**.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, navigate to the DynamoDB dashboard. You can search for `DynamoDB` from
    the top search box of **AWS Management Console**.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this is the first time you have visited the **DynamoDB console** page, you
    will be presented with a splash screen.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create table** button.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a name for your table in the text box next to `Recipes`.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `RecipeName` and ensure that the type is set to **String**.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **Table settings**, uncheck the box next to **Use default settings**.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Read/write capacity mode** section, select the **On-demand** option.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button at the bottom of the page. DynamoDB will create
    a new table for you in a few seconds, as per the following screenshot:![Figure
    8.16 – DynamoDB table – Recipes
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17124_08_16.jpg)'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.16 – DynamoDB table – Recipes
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Items** tab.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can start adding items in the **Items** tab. Click the **Create item** button.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will see a dialog box in which you can add a new item (record) to your database.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the text box next to `Vegan Sausage Rolls`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Save** button.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the new item has been added and that the value of the primary key
    for this item is the name of the recipe, `Vegan Sausage Rolls`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create item** button again.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the text box next to `Vegan Peri Peri Burger`.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the *plus* sign and select the `Ingredients`. You will also notice
    that an additional entry appears below this **StringSet**, which is where you
    would input the values for the field you just created. Click on the *plus* sign
    next to the *empty array* line and select **Append**.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Lettuce` `Tomato` `Cucumber`. Click on a different part of the screen
    to update the values, as per the following screenshot:![Figure 8.17 – DymanoDB
    item entry
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17124_08_17.jpg)'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 8.17 – DymanoDB item entry
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the **Save** button.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, your table has been updated with a new record. You will see
    the two items in your table. The **Vegan Sausage Roll** item only has one field
    with a value in it, namely the primary key. The **Vegan Peri Peri Burger** item
    has two fields associated with it, which are the primary key and an attribute
    called **Ingredients**. Review the following screenshot for reference:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.18 – DynamoDB Recipes table'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_08_18.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – DynamoDB Recipes table
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, DynamoDB offers lots of flexibility in not requiring a rigid
    schema definition before inputting data.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will conclude by summarizing this chapter.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the various database services offered by Amazon,
    comprising both relational and non-relational databases services. You learned
    how AWS enables you to quickly deploy new RDS databases and offers full management
    of your database as a service, rather than you having to provision EC2 instances
    that you will install database software on.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Amazon RDS comes with six engines – MySQL, PostgreSQL, Microsoft SQL, Oracle,
    MariaDB, and Amazon Aurora. Amazon RDS is a regional service and must be deployed
    in your VPC. You have options to configure for high availability using services
    such as Multi-AZ and backup and restore strategies. You can also scale out read
    copies of your RDS database to offload read queries away from the primary master
    copy of your database.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Aurora comes with a lot more features and addresses some of the limitations
    of traditional RDS engines out of the box, including features such as self-healing
    and high availability.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at Amazon DynamoDB, which is a non-relational database designed
    for the modern web, mobiles, and IoT applications that can read and write thousands
    of requests per second. Amazon DynamoDB is offered as a completely serverless
    solution – you do not need to provision database instances or storage yourself.
    You simply specify **WCUs** and **RCUs** and AWS will provision the underlying
    infrastructure for you.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we looked at two in-memory caching engines offered by the Amazon
    Elasticache service – Redis and Memcached – and compared which engine to use in
    what scenario.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we examined AWS DMS3, which offers both homogenous migrations such
    as Oracle to Oracle migrations and heterogenous migration such as Oracle to Microsoft
    SQL type migrations. AWS DMS can be used to migrate on-premises databases to the
    cloud very easily.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss concepts related to high availability and
    scalability. In addition, we will carry out various lab exercises that will enable
    you to learn how to combine the various core services we have learned about so
    far. You will do this by deploying a multi-tier application architecture.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A company plans to migrate its on-premises MySQL database to Amazon RDS. Which
    AWS service should they use for this task?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon Snowball
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Database Migration Service (AWS DMS)
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS VM Import/Export
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Server Migration Service
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is the primary benefit of using an Amazon RDS database
    instead of installing a MySQL-compatible database on your EC2 instance?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing the database, including patching and backups, is taken care of by Amazon.
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Managing the database, including patching and backups, is taken care of by the
    customer.
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You have full access to the operating system layer that the RDS database runs
    on.
  id: totrans-393
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can choose which drive and partition to install the RDS database on.
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS RDS supports six database engines. From the following list, choose *three*
    engines supported by Amazon RDS.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Microsoft SQL
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Oracle
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: MySQL
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: FoxPro
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Db2
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You are building an application for a wealth asset management company that will
    be used to store portfolio data and transactions of stocks, mutual funds, and
    forex purchased. To that end, you need a backend database solution that will ensure
    a ledger-like functionality because they want to maintain an accurate history
    of their applications' data, for example, tracking the history of credits and
    debits for its customers. Which AWS database solution would you recommend for
    this business requirement?
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon RDS
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon DynamoDB
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon QLDB
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon Redshift
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which AWS database solution enables you to build a complete data warehousing
    solution, capable of handling complex analytic queries against petabytes of structured
    data using standard SQL and industry-recognized business intelligence tools?
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS DynamoDB
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Redshift
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Neptune
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Pluto
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You are looking to host a production-grade enterprise relational database solution
    that offers high-end features such as self-healing storage systems that are capable
    of scaling up to 128 TB per database instance. Which of the following AWS database
    solutions fulfills the requirement?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon DynamoDB
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon Aurora
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon Redshift
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon Neptune
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which AWS feature of Amazon Redshift enables you to run SQL queries against
    data stored directly on Amazon S3 buckets?
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Redshift DaX
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Athena
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Redshift Spectrum
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Redshift Cache
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which AWS service enables you to migrate an on-premises MySQL database to an
    Amazon RDS database running the Oracle Engine?
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Cross-Region Replication
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS SMS
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS DMS
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS EFS
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You are running a single RDS DB instance. Which configuration would you recommend
    so that you can avoid I/O suspension issues when performing backups?
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure RDS read replicas.
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure RDS Multi-AZ.
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure RDS Cross Region Backup.
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure DynamoDB DaX.
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
