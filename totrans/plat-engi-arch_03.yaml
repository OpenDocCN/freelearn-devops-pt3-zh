- en: <st c="0">3</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Building the Foundation for</st> <st c="30">Supporting Platform Capabilities</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="62">Solving a problem users have, designing for good user and developer
    experience, and avoiding technical complexity are the foundational steps toward
    successful products and successful</st> <st c="246">platform engineering.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="267">In reality, many projects fail because those foundational principles
    are neglected: we see architects getting lost in technical details and losing
    sight of the problem they need to solve.</st> <st c="456">Too often projects fail
    because the end user wasn’t continuously involved throughout the creation process
    of a new product.</st> <st c="580">Frequently, architectural decisions are made
    without considering how this new product will fit into the existing ecosystem,
    processes, and skill set of the organization.</st> <st c="750">All of this leads
    to a shaky foundation with limited potential</st> <st c="813">for success.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="825">In this chapter, we’ll walk through the mandatory steps and processes
    of defining a solid foundation of a platform that can grow from an initial set
    of features to key enterprise-supporting</st> <st c="1016">platform capabilities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1038">As such, we’ll cover the following main topics in</st> <st c="1089">this
    chapter:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1102">Financial One ACME – our</st> <st c="1128">fictitious company</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1146">Overcoming platform complexity by finding the</st> <st c="1193">right
    perspective</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1210">Considering existing processes and integrating a</st> <st c="1260">new
    implementation</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1278">Designing the</st> <st c="1293">infrastructure architecture</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1320">Exploring multi-cloud, multi-SaaS, and the fragmentation</st> <st
    c="1378">of capabilities</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1393">Exploring a reference architecture for</st> <st c="1433">our platform</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1445">Financial One ACME – our fictitious company</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1489">In this section, we’ll learn</st> <st c="1518">how to understand
    the requirements of users in an engineering organization, how to balance the requirements
    of different teams, and how to decide what capabilities should be included in
    a platform and which</st> <st c="1726">ones not.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1735">To make this more applicable and real, we’re going to introduce
    to you</st> *<st c="1807">Financial One ACME</st>*<st c="1825">. While it’s a
    fictitious company, the history, technology challenges, and teams we’ll introduce
    and use throughout the remainder of this book are what we’ve seen in many organizations
    that we’ve worked with in the past years.</st> <st c="2052">Having such an organization
    allows us to better explain how to apply the theory we’ll present in this book
    to</st> <st c="2162">practical actions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2180">Let’s have a look at some</st> <st c="2206">important details about</st>
    *<st c="2231">Financial</st>* *<st c="2241">One ACME</st>*<st c="2249">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="2251">A brief history of Financial One ACME</st>**<st c="2288">: Financial
    One ACME has been a leader in providing software solutions for the financial services
    market.</st> <st c="2395">The company started in the early 2000s with a classical
    3-tier application architecture (Windows rich client, application server, and
    database) that customers installed in their data centers, with new releases of
    their software shipping twice</st> <st c="2638">a year.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2645">Over the years, the Windows rich client was slowly replaced with
    a</st> <st c="2713">web client.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="2724">Providing a self-hosted SaaS and on-premises offering</st>**<st
    c="2778">: In 2015, the demand for a SaaS-hosted version increased.</st> <st c="2838">Instead
    of re-architecting the product to support multi-tenancy for a SaaS-based solution,
    the decision was made to simply host the Application Server and Database for each
    SaaS Customer separately in the existing Financial One ACME data center.</st>
    <st c="3084">This solved concerns about data residency and data access.</st> <st
    c="3143">However, it meant that with a growing number of SaaS-based customers,
    the operational overhead grew as each customer (=tenant) had a production deployment
    on their</st> <st c="3307">separate VMs.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3320">Additionally, IT operations had the challenge of continuously expanding
    data center capacity for production</st> <st c="3428">environments to keep up
    with business growth.</st> <st c="3475">Due to different customer sizes, they
    also had to do individual capacity planning for each tenant to properly size and
    not</st> <st c="3598">oversize environments.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="3620">Development teams, on the other hand, owned the pre-production
    environments.</st> <st c="3698">This included everything from the development
    workstations, build servers, and pre-production testing and</st> <st c="3804">staging
    environments.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="3825">Moving to monthly releases</st>**<st c="3852">: From 2015 to
    2020, the release cadency was constantly improved, leading to a monthly release
    cycle.</st> <st c="3955">Those releases were built and tested by the development
    teams and then provided to IT operations to deploy into SaaS, as well as to those
    customers that still ran the software on-premises.</st> <st c="4144">This change
    in speed resulted in a situation where not every customer wanted to update their
    software that frequently as it had to be aligned with their internal change request
    processes.</st> <st c="4332">Some customers were up to six releases behind the
    current build, which put an extra strain on the development team to support all
    those</st> <st c="4468">older versions.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="4483">The lift and shift to the cloud</st>**<st c="4515">: In 2020,
    the business expanded into new regions, and with that, the requirement grew to
    offer the SaaS offering in new regions.</st> <st c="4646">Instead of building
    more data centers, the company decided to</st> *<st c="4708">lift and shift</st>*
    <st c="4722">their existing production architecture into the public cloud vendors’</st>
    <st c="4793">compute offerings.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="4811">This move also included new processes and guidelines on how to
    update software or access data on those cloud servers – for example, how to access
    logs from server X that belong to</st> <st c="4992">Tenant Y!</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="5001">Outperformed by new FinTech companies</st>**<st c="5039">: During
    the pandemic, new FinTech software companies emerged that were</st> *<st c="5112">born
    and architected for the cloud</st>*<st c="5146">! This put pressure on Financial
    One ACME as those new SaaS-only companies didn’t have to maintain a legacy architecture
    to support both SaaS and on-premises.</st> <st c="5305">Their architectures were
    also multi-tenant and multi-cloud, which allowed them to run more cost-efficiently
    than the Financial One ACME</st> <st c="5441">counterpart offering.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="5462">Leadership made a</st> <st c="5481">strategic decision to re-architect
    their offering while also improving the efficiency of developing, supporting,
    and operating the existing platform until every customer could be migrated over
    to the future</st> <st c="5688">SaaS-only offering.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="5707">And here we are: it’s 2024, so it’s time to think about how to
    help this organization modernize and re-invent themselves.</st> <st c="5830">Kubernetes
    and cloud native are the future tech stack!</st> <st c="5885">The hope lies in
    platform engineering to improve the work of engineers that work on the future
    stack as well as maintain the old stack.</st> <st c="6021">This is where we come
    in – the newly formed platform</st> <st c="6074">engineering team!</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6091">Now, let’s understand who the</st> <st c="6122">potential users
    of our future</st> **<st c="6152">internal developer platform</st>** <st c="6179">(</st>**<st
    c="6181">IDP</st>**<st c="6184">)</st> <st c="6187">might be:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="6196">Development teams</st>**<st c="6214">: Managing all pre-production
    tools</st> <st c="6251">and environments</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="6267">IT ops</st>**<st c="6274">: Who has been managing on-premises
    data center and cloud</st> <st c="6333">compute resources</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="6350">DevOps</st>**<st c="6357">: The team responsible for deploying
    and operating the existing SaaS-based production environments from an</st> <st
    c="6465">application perspective</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="6488">Quality engineers</st>**<st c="6506">: The teams focusing on
    testing new software before it gets promoted</st> <st c="6576">to production</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="6589">Site reliability engineers (SREs)</st>**<st c="6623">: Teams
    focusing on resiliency, availability, and help with reporting and enforcing SLAs</st>
    <st c="6713">and SLOs</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="6721">Technical docs</st>**<st c="6736">: The team who’s preparing
    end-user-facing documentation to accompany every release, along with release notes,
    new features, and</st> <st c="6866">how-to guides</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="6879">Some others</st>**<st c="6891">: This includes</st> **<st c="6908">database
    admins</st>**<st c="6923">,</st> **<st c="6925">project managers</st>**<st c="6941">,</st>
    **<st c="6943">product owners</st>**<st c="6957">,</st> **<st c="6959">ProdSec</st>**<st
    c="6966">,</st> <st c="6968">and others</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="6978">Now that we know who</st> *<st c="7000">we</st>* <st c="7002">as
    a team are and who</st> *<st c="7025">our</st>* <st c="7028">potential users are,
    let’s look into</st> *<st c="7066">how</st>* <st c="7069">we need to build a platform
    that solves</st> *<st c="7110">their</st>* <st c="7115">pain poi</st><st c="7124">nts!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7129">Overcoming platform complexity by finding the right perspective</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="7193">“</st>*<st c="7195">We spent months building our new platform.</st>
    <st c="7238">Devs hate it!</st> <st c="7252">Help me</st>* *<st c="7260">understand
    why!</st>*<st c="7275">”</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7277">We don’t want to end up in</st> <st c="7304">a situation where
    we feel like we have to post such a question on a public discussion forum.</st>
    <st c="7397">This heading is – believe it or not – from a real post.</st> <st
    c="7453">If you want to learn more about this story, then</st> <st c="7501">read
    the</st> **<st c="7511">Reddit</st>** <st c="7517">post</st> *<st c="7523">[1]</st>*
    <st c="7526">provided in the</st> *<st c="7543">Further</st>* *<st c="7551">reading</st>*
    <st c="7558">section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="7567">So, how can this happen?</st> <st c="7593">The reason why many
    platform engineering initiatives fail is the same reason why other product development
    initiatives have failed: somebody had a great idea – built or made somebody build
    a product – but ended up finding nobody that saw the benefit of this new product
    as it didn’t solve any real problem</st> <st c="7899">people have.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7911">The mistake many make is to not validate the initial idea with
    their potential end users that they think would benefit from that solution.</st>
    <st c="8051">If you don’t find a critical mass of users that have a problem that’s
    solved by a new product, then it’s better to not build a product at all as it’s
    bound to fail from</st> <st c="8220">the start.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8230">If you’ve done any product management in the past, you’re probably
    thinking, “</st>*<st c="8309">But this is Product Management 101</st>*<st c="8344">!”
    Fully agreed!</st> <st c="8361">However, not every team that’s tasked with building
    a new platform has previous experience in product management.</st> <st c="8475">Many
    teams that we’ve seen happen to find themselves in a situation where they can
    start building a platform without seeing the parallels to building any regular
    product.</st> <st c="8646">Many tasks go with building a product before even starting
    to build</st> *<st c="8714">the pr</st><st c="8720">oduct</st>*<st c="8726">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8727">Applying basic product management – “Don’t give your users a faster
    horse”</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="8802">The</st> <st c="8807">right approach to successful platform engineering
    initiatives is aligned with what successful product teams have done in</st> <st
    c="8928">the past:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="8937">Identify</st>* <st c="8946">a problem that a large enough user</st>
    <st c="8982">base has</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="8990">Understand</st>* <st c="9001">why this is a challenge and what
    the negative impact is</st> <st c="9058">right now</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="9067">Research</st>* <st c="9076">on why this problem hasn’t been</st>
    <st c="9109">solved already</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="9123">How</st>* <st c="9127">you would quantify the benefit if you
    could solve</st> <st c="9178">this problem</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9190">To answer those questions and go a step beyond the basics, we suggest
    talking with your potential end users.</st> <st c="9300">Let them tell you about
    the actual problem they have and give them the freedom to explain a solution that
    gets them to the ideal way of getting their</st> <st c="9450">work done.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9460">As you listen, make sure you aren’t constraining yourself with
    any technical limitations or challenges you’re aware of right now.</st> <st c="9591">There’s
    a famous quote attributed to</st> *<st c="9628">Henry Ford</st>* <st c="9638">who
    allegedly said, “</st>*<st c="9660">If I had asked people what they wanted, they
    would have said faster horses.</st>*<st c="9736">” You’ll learn that your users
    typically easily describe the problem they have.</st> <st c="9817">However, the
    solution they often come up with is constrained by what they think is possible
    or by the technical limitations they’re currently</st> <st c="9959">aware of.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9968">Now, we aren’t going to start by coming up with a revolutionary
    new way for software engineering that takes months or years.</st> <st c="10094">However,
    this mindset is important as it’s a step toward solving problems that others have
    failed to solve in a way that the solution is</st> <st c="10231">widely adopted!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10246">To start, let’s think about how to</st> *<st c="10282">solve this
    problem</st>* <st c="10300">with the</st> *<st c="10310">simplest and fastest</st>*
    <st c="10330">technical solution.</st> *<st c="10351">Don’t over-engineer</st>*
    <st c="10370">from the start to come up with the best or most revolutionary technical
    implementation.</st> <st c="10459">While this should be an inspiring goal, our
    initial goal is to get</st> *<st c="10526">fast feedback and validation</st>*
    <st c="10554">on whether our proposed implementation solves the pain of our potential</st>
    <st c="10627">end users.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10637">To get this fast feedback, you need to do</st> <st c="10680">the
    following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="10694">Deliver</st>* <st c="10702">a</st> <st c="10705">solution quickly</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="10721">Show</st>* <st c="10726">it to your potential</st> <st c="10748">end
    users</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="10757">Get</st>* <st c="10761">continuous feedback</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="10781">Refine</st>* <st c="10788">based on</st> <st c="10798">the feedback</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="10810">Keep</st>* <st c="10815">iterating through</st> <st c="10834">these
    steps</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10845">This process</st> <st c="10859">continues until you can prove
    that your users would be willing to use your solution as it improves their way
    of getting</st> <st c="10979">thing</st><st c="10984">s done.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10992">Avoiding the “sunk cost fallacy”</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="11025">Not every project will lead to success, no matter how hard and
    often you try and iterate.</st> <st c="11116">The</st> **<st c="11120">sunk cost
    fallacy</st>** <st c="11137">is a</st> <st c="11143">known problem pattern that
    we see in everyday life decisions, as</st> <st c="11208">well as when in software
    engineering.</st> <st c="11246">It highlights the problem that organizations are
    continuing to invest in a strategy because of the existing investment already
    made, even when it’s obvious that it would be better to stop that investment as
    it has no chance of success.</st> <st c="11482">There’s plenty of material on
    this that you can read up on such, as the</st> **<st c="11554">Sunk Cost</st>**
    <st c="11563">article</st> *<st c="11572">[2]</st>*<st c="11575">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11576">Therefore, it’s important to define when to stop your iterations.</st>
    <st c="11643">If the moment of “</st>*<st c="11661">Users love the solution</st>*<st
    c="11685">” doesn’t happen within a certain amount of time, you have to be ready
    to pull the plug and stop the initiative.</st> <st c="11799">To do this, you need
    to set yourself</st> <st c="11835">milestones on reaching that</st> **<st c="11864">validation
    point</st>** <st c="11880">of your solution.</st> <st c="11899">Remember, as mentioned
    previously, you don’t want to end up with a post that says “</st>*<st c="11982">We
    spent months building this platform.</st> <st c="12023">Devs hate it!</st> <st
    c="12037">Help me</st>* *<st c="12045">under</st><st c="12050">stand why!</st>*<st
    c="12061">”</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12063">Steps to building the thing that users need – a real-life example</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="12128">Let’s take a step back to the beginning.</st> <st c="12170">What
    is it that we need to build?</st> <st c="12204">In product management, there are
    many different memes (take a look at</st> *<st c="12274">Figure 3</st>**<st c="12282">.1</st>*
    <st c="12284">for one such example) about how the things that are being built
    differ from what the user needs.</st> <st c="12382">The same is true if you search
    for memes on overengineering.</st> <st c="12443">They all come up with the same
    conclusion:</st> *<st c="12486">Building something without first understanding
    what the</st>* *<st c="12542">user needs!</st>*
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: The overengineering paradox](img/Figure_3.01_B31164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="12633">Figure 3.1: The overengineering paradox</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12672">It’s possible to avoid a situation</st> <st c="12707">where we
    end up building something that doesn’t solve the real problem or solves it in
    a way that’s far too complex and there’s no return</st> <st c="12846">on investment.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12860">The hardest step in every journey is the first step.</st> <st
    c="12914">In our case, it’s understanding</st> *<st c="12946">who</st>* <st c="12949">our
    potential platform users are and</st> *<st c="12987">what</st>* <st c="12991">the</st>
    *<st c="12996">real pain point</st>* <st c="13011">a platform can</st> <st c="13027">solve
    is!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13036">To see this in action, let’s walk through several steps on how
    we would approach this for Financial</st> <st c="13136">One ACME!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13146">Step 1 – understand the real pain points of your users</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="13201">In hallway</st> <st c="13213">conversations, the development teams
    often complain that analyzing problems in their software was so much easier in
    pre-production compared to production environments.</st> <st c="13381">They have
    full access to all the logs from their build server (Jenkins) and testing tools
    (Selenium and JMeter), as well as the environment where they deployed their software.</st>
    <st c="13557">They could easily increase log levels or quickly deploy a new version
    with more log output to triage</st> <st c="13658">problems faster.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13674">When</st> <st c="13680">problems are detected in production, analyzing
    the problem is a completely different story!</st> <st c="13772">The development
    teams must ask IT ops for permission to get access to the logs by opening up a
    Jira ticket.</st> <st c="13880">That sometimes takes hours as the IT ops team
    is typically overwhelmed with many other tasks.</st> <st c="13974">The IT ops
    team also doesn’t have the inside knowledge about where the software is writing
    all the logs to and the development teams don’t always provide this information
    in the initial ticket either.</st> <st c="14175">That’s why it often takes several
    iterations to capture the desired logs and upload them to the IT-ops-owned tool
    to share production-relevant data with other teams.</st> <st c="14341">Changing
    log levels is also not that easy.</st> <st c="14384">Production changes like this
    have to follow a special change approval process.</st> <st c="14463">As its a
    software change, it’s handled by the DevOps team, which slows things down</st>
    <st c="14546">even further!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14559">For the development teams, this means that instead of just remoting
    into a server to access and analyze the logs on the spot, those logs have to be
    analyzed through the IT ops central production data storage tool.</st> <st c="14774">However,
    the development team isn’t super familiar with this as they don’t work with it
    regularly.</st> <st c="14873">That centralized tool also has its own permission
    system that was initially set up to prevent unauthorized access to restricted
    data.</st> <st c="15007">As that system isn’t integrated with the same authentication
    and access control system developers use, it’s often out of sync with the current
    team assignment.</st> <st c="15167">This is leading to situations where individual
    engineers in a team can’t access the logs they need, leading to additional cycles
    with IT ops and DevOps or using a non-approved shortcut by simply asking a dev
    colleague who happened to have access to</st> <st c="15416">the logs!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15425">As you can see, there’s lots of frustration and pain in the development
    team.</st> <st c="15504">But as you can also imagine, there’s also lots of frustration
    on the IT ops and DevOps teams.</st> <st c="15598">Their job of operating production
    is constantly interrupted with tasks to look up and provide access to data from
    production or approve a log-level change.</st> <st c="15754">There’s constantly
    a lot of back and forth to understand what data is requested, where to find that
    data, and who should have access to</st> <st c="15890">this data.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15900">Lots of conversations typically go into understanding the full
    picture, understanding the pain points on both sides, and having enough details
    to start thinking about a better way of doing this.</st> <st c="16096">When you
    apply this in your organization, plan enough time and notify people you want to
    talk to ahead of time so that they can gather their thoughts to have</st> <st
    c="16254">those conversations!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16274">To start proposing a solution, it’s best to get an organized overview
    of the pain points of all sides, as shown</st> <st c="16387">in the</st> <st c="16394">following
    table:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="16410">Problem</st>**<st c="16418">: Devs don’t have direct access
    to logs</st> <st c="16459">in production</st> |'
  prefs: []
  type: TYPE_TB
- en: '| **<st c="16472">Pain Points</st>**<st c="16484">:</st> <st c="16487">Development
    team</st> | **<st c="16503">Pain Points</st>**<st c="16515">:</st> <st c="16518">IT
    ops</st> | **<st c="16524">Pain</st>** **<st c="16530">Points</st>**<st c="16536">:
    DevOps</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="16545">Need to create Jira tickets to request access to logs</st>
    <st c="16600">in production.</st> | <st c="16614">Need to deal with Jira tickets
    requesting access</st> <st c="16664">to logs.</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="16672">Lots of time is spent on tickets until the IT ops team identifies
    the right log</st> <st c="16753">to capture.</st> | <st c="16764">Devs don’t always
    provide enough information in tickets.</st> <st c="16822">Additional iterations
    are required to get all the</st> <st c="16872">necessary details.</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="16890">It’s hard to change log levels in production during triage.</st>
    <st c="16951">Yet more change request tickets need to</st> <st c="16991">be created.</st>
    |  | <st c="17002">Working on unplanned change request tickets to increase</st>
    <st c="17059">log levels.</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="17070">Inefficient log analytics.</st> <st c="17098">Devs are more
    used to the tool used in pre-production.</st> <st c="17153">The production tool
    isn’t as intuitive to them and slows</st> <st c="17210">them down.</st> |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="17220">Dealing with permission issues in the production log</st> <st
    c="17274">analytics tool.</st> | <st c="17289">Additional overhead to explain
    that ownership and permission information is not in sync with</st> <st c="17383">dev
    systems.</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '<st c="17395">Table 3.1: Organizing the problem and its pain points into an
    easy-to-consume table</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17479">Now that we have</st> <st c="17496">a list of pain points from
    both sides, it’s time to think about a solution to those pain points, how much
    of an impact this solution would</st> <st c="17635">have, how much it would cost,
    and what the</st> **<st c="17679">return on investment</st>** <st c="17699">(</st>**<st
    c="17701">ROI</st>**<st c="17704">)</st> <st c="17707">would be</st><st c="17715">!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17716">Step 2 – quantify the benefit of solving those pain points</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="17774">We start by</st> <st c="17787">quantifying the impact that a solution
    would have.</st> <st c="17838">This is necessary to justify how much time and
    effort goes into building a platform that solves those pain points.</st> <st c="17953">While
    the pain explained previously is real, we need to understand whether these are
    single occurrences or regular occurrences.</st> <st c="18081">The question we
    need to answer is, is it justified to invest weeks into building a platform that
    solves</st> <st c="18185">this problem?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18198">Going back to the same teams, it’s time to quantify the costs
    of those listed pain points in terms of time spent or actual $.</st> <st c="18326">We
    can get those numbers either through educated guesses or numbers from their current
    time tracking (the best option).</st> <st c="18446">As the team is currently using
    tickets, we should be able to get the total amount of time spent on those tickets
    on</st> <st c="18562">both sides.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18573">Here’s a revised table with the additional</st> <st c="18617">cost
    impact!</st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="18629">Pain/Time Spent</st>** **<st c="18646">per Month</st>** |
    **<st c="18655">Development Teams</st>** | **<st c="18673">IT Ops</st>** | **<st
    c="18680">DevOps</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="18687">Slow process to request</st> <st c="18712">log access</st>
    | <st c="18722">2 days</st> | <st c="18729">4 days</st> |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="18736">Extra process to change the</st> <st c="18765">log level</st>
    | <st c="18774">0.5 days</st> |  | <st c="18783">0.5 days</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="18792">Inefficient</st> <st c="18805">log analytics</st> | <st c="18818">2
    days</st> |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="18825">Workaround for</st> <st c="18841">permission issues</st> |
    <st c="18858">0.5 days</st> |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **<st c="18867">Total Sum</st>** | <st c="18877">5 days a month or 60 days</st>
    <st c="18904">a year</st> | <st c="18910">4 days a month or 48 days</st> <st c="18937">a
    year</st> | <st c="18943">0.5 days a month or 6 days</st> <st c="18971">a year</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '<st c="18977">Table 3.2: Quantifying the benefit of each pain point and providing
    an easy overview</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19062">Now, this is a</st> <st c="19078">great overview with interesting
    stats to make our decision easier.</st> <st c="19145">If we can solve all those
    pain points for the problem that developers have, which is that they currently
    don’t have easy access to the necessary log files in production, we can save up
    to 114 engineering days per year.</st> <st c="19364">That’s a good starting point
    and a great argument to invest in improving the efficiency of our teams by investing
    in</st> <st c="19481">platform engineering!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19502">Step 3 – propose a solution that improves developer experience</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="19565">Now that we know</st> <st c="19583">that we can potentially save
    up to 114</st> **<st c="19622">full-time equivalent</st>** <st c="19642">(</st>**<st
    c="19644">FTE</st>**<st c="19647">) engineering days per year, we should go ahead
    and come up with a proposed solution that we can present back to the users involved.</st>
    <st c="19781">We must not present the technical details of the solution but how
    the developers will experience the user journey.</st> **<st c="19896">Developer
    experience</st>** <st c="19916">is the</st> <st c="19924">key word here that gets
    talked a lot about in platform engineering.</st> <st c="19992">So, let’s come
    up with a solution that gives our developers a new experience that will make them
    want to use</st> <st c="20101">our solution!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20114">Like in product engineering, we need to involve our end users
    by asking for input on how they would like to interact with a future solution.</st>
    <st c="20256">Developers often favor an approach where they can do everything
    through code or a simple-to-use</st> **<st c="20352">command-line interface</st>**
    <st c="20374">(</st>**<st c="20376">CLI</st>**<st c="20379">).</st> <st c="20383">The</st>
    <st c="20387">important piece here is that we want to come up with a solution
    that fits into the current work process and tools so that our users don’t have
    to learn yet another tool or change their way</st> <st c="20576">of working.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20587">The</st> <st c="20592">proposal in our scenario leverages the</st>
    *<st c="20631">Configuration as Code</st>* <st c="20652">approach.</st> <st c="20663">Developers
    can specify log levels, log output, ownership, and notification channels in code.</st>
    <st c="20756">This could be a standalone YAML or JSON file or could be part of
    a Kubernetes deployment definition.</st> <st c="20857">The developers simply need
    to check that file into their Git repository.</st> <st c="20930">DevOps and IT
    ops can validate and approve the</st> **<st c="20977">pull request</st>** <st
    c="20989">(</st>**<st c="20991">PR</st>**<st c="20993">) to</st> <st c="20999">make
    sure that all the data is accurate.</st> <st c="21040">If a new alert comes in,
    or if someone requests logs on demand, the new platform engineering capability
    will get the right log files for that component that has a problem.</st> <st c="21212">Then,
    it uses the ownership and notification information to contact the development
    team with a link or a digest of the logs that are relevant to that situation.</st>
    <st c="21374">The following diagram visualizes the proposed end-to-end workflow
    and shows how it improves the experience for developers, IT ops,</st> <st c="21505">and
    DevOps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: Improving experience through Configuration as Code for dev, DevOps,
    and IT ops](img/Figure_3.02_B31164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="21636">Figure 3.2: Improving experience through Configuration as Code
    for dev, DevOps, and IT ops</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21726">The</st> <st c="21731">proposed solution addresses all the current
    pain points while ensuring that only teams that own a component get to see their
    data.</st> <st c="21862">This solution is also extensible to make it work the
    same in production and pre-production environments.</st> <st c="21967">This would
    be a future iteration of</st> <st c="22003">this capabi</st><st c="22014">lity!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22020">Step 4 – your first prototype</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="22050">If the proposed</st> <st c="22066">solution is accepted, it’s
    time to work on a prototype implementation.</st> <st c="22138">Prototypes are
    a great way to get fast feedback on an implementation that must not be technically
    perfect – yet!</st> <st c="22251">For our intents and purposes, a prototype is
    the best way as we want to validate that the problem users want to get solved
    can be solved in a way that they would start using</st> <st c="22425">our solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22438">The first part of the prototype should focus on the</st> *<st
    c="22491">interface</st>* <st c="22500">to this new capability we are building.</st>
    <st c="22541">In our case, this is the config file we discussed earlier.</st>
    <st c="22600">A key consideration for the prototype is deciding whether the solution
    should solve the problem on the existing technology stack (3-tier app on cloud
    VMs) or whether this is a problem that we only want to solve as Financial One
    ACME moves their new cloud-native implementation.</st> <st c="22878">The goal
    should always be to provide the same developer experience, regardless of the underlying
    technology stack.</st> <st c="22993">However, when it comes to the implementation,
    the gain and effort might be</st> <st c="23068">very different.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23083">To proof the prototype for both technology stacks, see the following
    Configuration as</st> <st c="23170">Code files:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 3.3: Two declarative ways to implement the proposed solution](img/Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="24106">Table 3.3: Two declarative ways to implement the proposed solution</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24172">Both</st> <st c="24177">options allow the development teams to
    provide all the relevant information and allow DevOps and IT ops to</st> <st c="24285">validate
    it:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="24297">Service details</st>**<st c="24313">: Name, version, to which
    component</st> <st c="24350">it belongs</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24360">Ownership</st>**<st c="24370">: Team identifier, notification
    tool of choice, and channel</st> <st c="24431">of choice</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="24440">Logs</st>**<st c="24445">: What the log level is and where
    logs are</st> <st c="24489">written to</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="24499">In this Kubernetes example, you can also see how we can pass some
    of this information in already standardized annotations such as</st> `<st c="24630">app.kubernetes.io/name</st>`<st
    c="24652">,</st> `<st c="24654">part-of</st>`<st c="24661">, and</st> `<st c="24667">version</st>`<st
    c="24674">. We can also see that information such as log level can be passed to
    the container as changing the log level in this configuration file can also change
    the logs that are getting produced by the</st> <st c="24869">deployed container!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24888">Getting early feedback on this proposed configuration file format
    can happen before any actual implementation is done.</st> <st c="25008">It gives
    development, DevOps, and IT ops the chance to come up with additional metadata
    they want, such as the</st> *<st c="25119">priority</st>* <st c="25127">of the
    service.</st> <st c="25144">This could be used to define the escalation process
    when problem alerts occur in production, or a fallback email address to send email
    updates to</st> <st c="25290">the team.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25299">The heart of our proposed solution is not the configuration file
    but the automation process that can react to requests from developers but can
    also be triggered from an alert.</st> <st c="25476">The easiest solution would
    be a simple service that exposes a REST endpoint to be triggered for both use
    cases.</st> <st c="25588">That service needs to run in an environment where it
    has access to</st> <st c="25655">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25669">The Git repository or the K8s cluster that holds “</st><st c="25720">the
    configuration”</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25739">API access to the existing log solution in the</st> <st c="25787">target
    environment</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25805">API access to the</st> <st c="25824">notification tools</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25842">To start</st> <st c="25852">with a minimum viable prototype, we
    can define that we only support K8s, only support the production log solution,
    and only support a single notification tool, such as Slack.</st> <st c="26027">This
    allows us to prove the value through the prototype with the option to extend it
    to other config data sources, additional log environments, and a longer list of</st>
    <st c="26192">notification tools.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26211">What’s remaining is the definition of the REST API.</st> <st c="26264">Here,
    we should consult with the development and IT ops teams as they are the main users
    of that API.</st> <st c="26366">Developers use it to request access to logs on
    demand, while IT ops use it to call the API when a problem gets identified.</st>
    <st c="26489">The following table shows a sample REST API definition for both</st>
    <st c="26553">use cases:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="26563">Request Data</st>** **<st c="26577">on Demand</st>** | **<st
    c="26586">Notify about</st>** **<st c="26600">a Problem</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| `<st c="26609">GET</st>` <st c="26613">https://logservice/request?service=fund-transfer-service&environment=prod-useast-01</st>
    | `<st c="26697">GET</st>` <st c="26702">https://logservice/request?service=fund-transfer-service&environment=prod-useast-01&incident=PROD-1234</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '<st c="26804">Table 3.4: Examples of a REST API for the newly proposed service</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26869">While both implementations will try to find the right log files
    for those services and send them to the correct team, the Notify API also receives
    an incident reference, which allows our implementation to include that information
    in the message that’s sent to the</st> <st c="27134">development team.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27151">There are many more things we could do as part of the prototype
    of</st> <st c="27219">this solution:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27233">Determine the current SDLC efficiency measured and learn how to
    measure the positive impact we intend</st> <st c="27336">to have</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27343">Providing a CLI, chatbot, or</st> <st c="27373">web UI</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27379">Create a template Git repository for new services to include the</st>
    <st c="27445">new configuration</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27462">Create audit logs to track who is</st> <st c="27497">requesting
    data</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27512">Expose metrics to track the usage and performance of</st> <st
    c="27566">the API</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27573">Implement proper authentication to call the</st> <st c="27618">REST
    API</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27626">Implement rate limits to avoid any issues when calling the backend
    Git, K8s API, or Logging</st> <st c="27719">Platform API</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27731">The list could</st> <st c="27747">go on.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27753">It isn’t</st> <st c="27763">necessary to implement all of these
    at the start to validate the prototype and prove the value of</st> <st c="27861">such
    capabilities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27879">Apply basic product management skills to your platform project</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27942">What we’ve learned so far is how to understand the real pain of
    our users, how to quantify the benefit of building a solution for those pain points,
    how to propose a solution, and how to keep the users in a close feedback loop
    by building</st> <st c="28182">a prototype!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28194">Now that we understand that we need a product mindset when building
    a new platform, it’s time to expand our requirements gathering.</st> <st c="28327">Looking
    beyond the needs of the developers by understanding how the platform will fit
    into the existing end-to-end processes and tools will set us up for future adoption
    and growth in terms</st> <st c="28517">of capabilities!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28533">Considering existing processes and integrating a new implementation</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="28601">We’ve just talked about how to identify the real pain points of
    your users and how to pick good candidates for your first prototypes to get early
    feedback.</st> <st c="28758">However, requirements must not just come from your
    end users.</st> <st c="28820">We must look beyond simply providing self-service
    through a chatbot, template repository, or a</st> <st c="28915">new CLI.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28923">We need to look at and analyze the whole value creation journey
    and where the new platform capabilities fit in.</st> <st c="29036">We need to
    make sure that we understand the current</st> **<st c="29088">software development
    life cycle</st>** <st c="29119">(</st>**<st c="29121">SDLC</st>**<st c="29125">)
    – the process the organization follows as new</st> <st c="29173">software gets
    developed, released, operated, and retired.</st> <st c="29232">There are a couple
    of questions we need to be able</st> <st c="29283">to answer:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29293">What are the criteria and process to introduce change in the</st>
    <st c="29355">existing SDLC?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29369">How is the current SDLC efficiency measured and how can we measure
    the positive impact we intend</st> <st c="29467">to have?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29475">Are there any regulatory requirements for new tools we need to</st>
    <st c="29539">adhere to?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29549">Who within the organization needs to be informed or needs to approve</st>
    <st c="29619">new tools?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29629">Do new tools integrate with existing systems for authentication,
    access control, auditing, observability, security,</st> <st c="29746">and resiliency?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29761">The first step is to understand the existing process, how we can
    prove the positive impact we want to achieve, the requirements to extend it, and
    who the key</st> <st c="29920">decision-makers are</st><st c="29939">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29940">Understanding the existing SDLC – “the life cycle of an artifact”</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="30006">As</st> <st c="30009">platform engineering</st> <st c="30031">aims
    to provide platform capabilities that improve and change the way developers do
    certain tasks alongside the SDLC, it’s important to understand the current SDLC
    in the organization.</st> <st c="30216">Especially in large enterprises, it’s
    very likely that there isn’t just one process but many that have evolved over
    the years.</st> <st c="30343">It’s also very likely that not many – if any – know
    the current SDLC from the first requirement and creation of the artifact until
    the new software is operated in production until it gets replaced</st> <st c="30540">or
    retired.</st> <st c="30552">It’s very important to not make the mistake of assuming
    we – or a single person – know the existing end-to-end process.</st> <st c="30672">Even
    engineers</st> <st c="30687">who have been working for companies for many years
    often live in their own bubble and only have a limited understanding of what typically
    happens from the inception of a new idea until that code gets shipped, operated,
    and</st> <st c="30910">eventually ret</st><st c="30924">ired.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30930">The artifact life cycle experiment – from idea, to git commit,
    to prod!</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="31002">A simple approach to learning the end-to-end process is doing
    a</st> <st c="31067">little experiment.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="31085">As a kid, I’m</st> <st c="31100">you were as fascinated by rivers
    (small or large) as I was.</st> <st c="31160">I’m sure you’ve dropped a piece
    of wood or a small branch of a tree into the water and then observed it as the
    water carried it away.</st> <st c="31294">You probably ran along the river to
    watch that branch making its way to its final life cycle step: the ocean!</st>
    <st c="31404">Because that’s where all water streams eventually end up.</st> <st
    c="31462">As kids, we didn’t have the chance to follow that branch to the ocean.</st>
    <st c="31533">However, as engineers, we do have the chance to follow the full
    life cycle of an artifact: from the inception of the idea (a ticket in a requirements
    engineering tool) to its first git commit by a developer until the artifact gets
    deployed to, updated, or replaced</st> <st c="31798">in production.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31812">We have two options to understand that artifact life cycle.</st>
    <st c="31873">First, we can pick an existing service or feature and do some forensics
    by analyzing all tickets, git commits, pipeline runs, test reports, emails, change
    requests, and incident reports, and with that learn the processes, tools, and</st>
    <st c="32106">people involved!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32122">Another approach is to ask one of the development teams to create
    a “demo” or “non-impacting” feature.</st> <st c="32226">With the popularity of
    feature flagging, this could be a simple feature behind a flag that changes a
    small runtime aspect of the artifact.</st> <st c="32365">The benefit of this is
    that it imposes no risk in production but it allows us to learn everything there
    is to learn about the current SDLC and with that derive the current artifact life
    cycle in</st> <st c="32560">that organiz</st><st c="32572">ation!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32579">Insights into the artifact life cycle</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="32617">I have</st> <st c="32625">run several of those “</st>*<st c="32647">Let’s
    understand the life cycle of an artifact</st>*<st c="32694">” workshops with different
    organizations around the world.</st> <st c="32754">The results were lots of insights
    and learnings about the people, process, and tools.</st> <st c="32840">This included</st>
    <st c="32854">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32868">What</st> *<st c="32874">tasks</st>* <st c="32879">were involved
    from requirement to the first git commit to</st> <st c="32938">prod deployment</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="32953">who</st>* <st c="32957">was involved – the different teams that
    were involved in developing, testing, validating, and promoting changes from development</st>
    <st c="33087">to production</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33100">The</st> *<st c="33105">tools</st>* <st c="33110">that were being
    used along the way and whether there might have been different tools being used
    for the same task in</st> <st c="33228">different environments</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33250">Which tasks along the process were</st> *<st c="33286">manual</st>*
    <st c="33292">versus which were</st> <st c="33311">already</st> *<st c="33319">automated</st>*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="33328">Dependencies</st>* <st c="33341">on other tasks or teams to
    keep the change moving</st> <st c="33392">toward production</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33409">The</st> *<st c="33414">time</st>* <st c="33418">it took for each
    task, the overall time, the wait time between tasks,</st> <st c="33489">and more</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33497">This insight</st> <st c="33511">allows you to also craft a visualization
    of the full SDLC or the full artifact life cycle.</st> <st c="33602">Such a visualization
    will become very handy once we enter discussions on how our platform capabilities
    will impact the current</st> <st c="33729">existing processes:</st>
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.3: Understanding the life cycle of a software a\uFEFFrtifact](img/Figure_3.03_B31164.jpg)"
  prefs: []
  type: TYPE_IMG
- en: '<st c="33802">Figure 3.3: Understanding the life cycle of a software a</st><st
    c="33858">rtifact</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33866">The artifact life cycle isn’t limited to the initial delivery</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="33928">While</st> <st c="33935">platform engineering initiatives often
    aim to improve the initial onboarding or delivery aspect of software components,
    we must not limit ourselves to this.</st> <st c="34092">This is why the term</st>
    *<st c="34113">artifact life cycle</st>* <st c="34132">is a good alternative to
    use as the life cycle doesn’t stop with the initial development process.</st>
    <st c="34231">The life cycle of an artifact also includes operations, releasing
    updates, maintenance, or even replacing or retiring</st> <st c="34349">that artifact.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34363">In our first example from Financial One ACME, we talked about
    an operational life cycle phase.</st> <st c="34459">This covered the tedious process
    for development teams to get access to log files in production to triage current
    problems.</st> <st c="34583">The following figure visualizes that life cycle phase</st>
    <st c="34637">and process!</st>
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.4: Life cycle of the incident response when accessi\uFEFFng logs](img/Figure_3.04_B31164.jpg)"
  prefs: []
  type: TYPE_IMG
- en: '<st c="34743">Figure 3.4: Life cycle of the incident response when accessi</st><st
    c="34803">ng logs</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34811">Requirements from involved teams and existing processes</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="34867">In our</st> <st c="34874">exercise to understand the flow of an
    artifact throughout the life cycle, we’ve learned a lot about the teams, existing
    tools, and processes involved.</st> <st c="35026">We’ve also learned about which
    tools our future platform capabilities may need to integrate, which teams we need
    to collaborate with, and – if we end up replacing or integrating with existing
    tools – what we need to do to not break anything that the current tool</st> <st
    c="35289">implementation provides.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35313">Here are some examples of</st> <st c="35340">those findings:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="35355">Single sign-on (SSO)</st>**<st c="35376">: Every tool needs
    to integrate with the</st> <st c="35418">central SSO</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="35429">Security</st>**<st c="35438">: Every tool needs to pass the
    software supply chain</st> <st c="35492">security guidelines</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="35511">Auditing</st>**<st c="35520">: Every tool needs to create specific</st>
    <st c="35559">access logs</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="35570">Service-level agreements (SLAs)</st>**<st c="35602">: Every
    critical tool needs to adhere to the company-wide defined SLAs on availability
    for</st> <st c="35694">critical services</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="35711">So far, we’ve</st> <st c="35726">learned how important it is to
    understand the full process and life cycle of software artifacts.</st> <st c="35823">It’s
    important to learn about which teams are involved and which existing processes
    we have to go through when introducing a new tool.</st> <st c="35958">We’ve also
    learned about additional future areas where a platform engineering capability
    can provide significant improvements to the software delivery and artifact</st>
    <st c="36122">li</st><st c="36124">fe cycle!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36134">Introducing life cycle events – measuring and improving the efficiency
    of the SDLC</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '<st c="36217">We’ve</st> <st c="36224">already talked about the concept of
    the artifact life cycle.</st> <st c="36285">An artifact typically runs through
    a list of phases: requirement accepted, implementation started, pull request,
    artifact built, security scan finished, test complete, build validated, artifact
    promoted, deployment finished, feature released, problem detected, configuration
    changed, problem</st> <st c="36576">resolved, and artifact retired.</st> <st c="36609">While
    every organization will have slightly different life cycle stages or phases, we
    can visualize this nicely using the DevOps infinity loop.</st> <st c="36753">To
    trace the artifact along its life cycle, we encourage you to log every step along
    the way as a life cycle event.</st> <st c="36869">The following figure shows an
    example of those events and some of the metadata the involved tools and teams
    should add to better understand the full flow of an artifact, from its initial
    requirements</st> <st c="37069">to operations:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: The SDLC and its artifact life cycle events](img/Figure_3.05_B31164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="38218">Figure 3.5: The SDLC and its artifact life cycle events</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38273">The</st> <st c="38277">idea of life cycle events isn’t new.</st>
    <st c="38315">Many organizations are implementing the concept through different</st>
    <st c="38381">means, such as by adding log output into their CI/CD pipelines at
    the beginning and end of the pipeline, including metadata such as the timestamp,
    Git repository, pipeline, created artifact, and success status.</st> <st c="38592">The
    Continuous Delivery Foundation has been working</st> <st c="38643">on the</st>
    **<st c="38651">CDEvents</st>** *<st c="38659">[3]</st>* <st c="38663">spec, which
    defines a vocabulary of events that allow tools to communicate in an interoperable
    way.</st> <st c="38764">CDEvents is a great starting point that can be extended
    to cover the full life cycle of artifacts, as</st> <st c="38866">proposed previously.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38886">There are many benefits of standardizing events</st> <st c="38935">like
    this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="38945">Every artifact can be traced through its life cycle</st>**<st
    c="38997">: This means it can answer questions such as who was involved in the
    creation of</st> <st c="39079">an artifact!</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="39091">Management of releases</st>**<st c="39114">: What version of
    a release artifact has been deployed and</st> *<st c="39174">when</st>* <st c="39178">by</st>
    *<st c="39182">whom</st>* <st c="39186">in</st> *<st c="39190">which</st>* <st
    c="39195">environment?</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="39208">The life cycle stages can be measured, which gives us DORA
    metrics</st>**<st c="39275">: How long does it take from initial requirement until
    first deployment (lead time), how many deployments do we have (deployment frequency),
    how many deployments result in a problem in production (deployment failure rate),
    and how long does it take to fix a problem in production (time to</st> <st c="39565">restore
    service)?</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="39582">Compliance</st>**<st c="39593">: It allows us to identify whether
    some artifacts have skipped important steps such as security scans, resiliency
    testing,</st> <st c="39717">and more.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="39726">Interoperability</st>**<st c="39743">: This specifies whether
    we use Jenkins or GitHub Actions to build artifacts.</st> <st c="39822">If all
    tools generate the same type of events, we stay in control of the</st> <st c="39895">life
    cycle.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39906">Before</st> <st c="39914">you</st> <st c="39917">go off and define
    your life cycle events, have a look at the existing initiatives in</st> <st c="40003">the
    open source communities, as well as what the vendors in the delivery, observability,
    and</st> **<st c="40096">application life cycle management</st>** <st c="40129">(</st>**<st
    c="40131">ALM</st>**<st c="40134">) space are doing.</st> <st c="40154">There’s
    no need to reinvent the wheel as standards are currentl</st><st c="40217">y in</st>
    <st c="40223">the making!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40234">Presenting the value proposition for improving the existing SDLC/DORA</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="40304">Understanding</st> <st c="40318">the existing SDLC and making
    the life cycle of an artifact visible will be invaluable insights for our ongoing
    platform engineering initiatives.</st> <st c="40464">This will also be eye-opening
    for all members of the engineering organization as many of them most likely never
    got that overview to see where the current process provides opportunities to</st>
    <st c="40653">be improved.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40665">The gained insights allow us to work on a value proposition that
    will improve the day-to-day life of not just development teams but ideally many
    other teams along the SDLC.</st> <st c="40839">This is why understanding and measuring
    the current process is so important – it allows us to not only propose a new solution
    but also present the improvements backed by hard facts, such as improving lead
    time, deployment frequency, deployment failure rate, or time to restore service
    (our beloved</st> <st c="41137">DORA metrics).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41151">Regarding everything we’ve learned so far, how would this look
    in our log access use case for Financial One ACME?</st> <st c="41266">Our initial
    use case only focused on improving the access to logs in case of an error in production.</st>
    <st c="41367">Upon understanding the full end-to-end process, all teams involved,
    as well as existing processes, tools, and organizational requirements, we could
    propose the following solution and</st> <st c="41550">value proposition:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="41568">Proposal</st>**<st c="41577">: Automating observability as
    a non-functional</st> <st c="41625">software requirement</st> |'
  prefs: []
  type: TYPE_TB
- en: '| **<st c="41645">Value proposition</st>**<st c="41663">: Improve DORA metrics,
    reduce cognitive load, and scale</st> <st c="41721">best practices</st> |'
  prefs: []
  type: TYPE_TB
- en: '| **<st c="41735">KPIs and</st>** **<st c="41745">impacted teams</st>**<st
    c="41759">:</st>*<st c="41761">Improve time to restore service by 50%</st>* <st
    c="41799">by automatically routing relevant observability data from production
    to the development team.</st> <st c="41894">This eliminates manual log capturing
    and forwarding for DevOps and</st> <st c="41961">IT ops.</st>*<st c="41968">Improve
    lead time by 50%</st>* <st c="41993">by automating the process of capturing and
    analyzing observability data (logs, metrics, traces, and events) in earlier stages
    of the life cycle (dev, testing).</st> <st c="42154">The analysis will improve
    and automate the validation of new build artifacts and therefore reduce manual
    effort for</st> <st c="42270">quality engineers.</st>*<st c="42288">Reduce production
    deployment failure rate by 50%</st>* <st c="42337">by automatically capturing
    problems in earlier environments by automating the detection of common problems
    (new critical logs, exceptions, slowness in the app, and so on) based on</st>
    <st c="42518">observability data.</st> |'
  prefs: []
  type: TYPE_TB
- en: '| **<st c="42537">High-level user journeys</st>** **<st c="42563">and collaboration</st>**<st
    c="42580">:</st><st c="42582">As a</st> *<st c="42587">development team</st>*<st
    c="42603">, I commit an</st> *<st c="42617">Observability as Code</st>* <st c="42638">configuration
    file that includes information about the log source (for automated capturing),
    ownership (for automated routing), and important log patterns (to be used in automated
    validation and</st> <st c="42834">automated alerting).</st><st c="42854">As a</st>
    *<st c="42860">quality engineering team</st>*<st c="42884">, I collaborate and
    extend the log patterns to auto-detect regressions as part of test</st> <st c="42971">result
    analysis.</st><st c="42987">As a</st> *<st c="42993">DevOps team</st>*<st c="43004">,
    I collaborate and extend log pattern detection rules based on experiences and
    patterns seen in other</st> <st c="43107">development teams.</st><st c="43125">As
    an</st> *<st c="43132">IT ops team</st>*<st c="43143">, I collaborate and validate
    correct log sources and extend production problem detection based on relevant
    log patterns defined by development</st> <st c="43286">and DevOps.</st> |'
  prefs: []
  type: TYPE_TB
- en: '<st c="43297">Table 3.5: Formulating a proposal for our solution in a presentable
    layout</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43372">Have a clear proposal and value proposition</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43416">The chance of success will be higher if we can clearly articulate
    the benefits of</st> <st c="43499">our platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43512">Now that we’ve</st> <st c="43527">learned how to craft our proposals
    so that they include everyone involved in the software delivery and artifact life
    cycle, it’s time to think about how we should design the</st> <st c="43702">proposed
    solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43720">Designing the infrastructure architecture</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="43762">At</st> <st c="43765">this point, we’ve pitched our proposal.</st>
    <st c="43806">Once we get the initial buy-in from all teams and executive sponsors
    involved, it’s time to move to the next stage: we need to think about designing
    the solution and how it fits with the underlying infrastructure to achieve all
    those non-functional requirements of our organization: resiliency, availability,
    auditability, security, mandatory integrations, and</st> <st c="44167">so on.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44173">While we must not over-engineer from the start, it’s important
    to be aware of all the requirements that will have an impact on our infrastructure
    decisions.</st> <st c="44331">Here are a couple of questions we need to be able</st>
    <st c="44381">to answer:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44391">How, who, and where are we deploying, updating, and operating</st>
    <st c="44454">the platform?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44467">Are there organizational requirements to run on</st> <st c="44516">certain
    infrastructure?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44539">Is there a requirement to run our solution across multiple geographical
    regions or even across multiple</st> <st c="44644">infrastructure providers?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44669">Are there infrastructure requirements to access and connect with</st>
    <st c="44735">other systems?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44749">How many users must our solution be able</st> <st c="44791">to
    sustain?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44802">What are our SLAs for infrastructure as well as for</st> <st c="44855">end
    users?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44865">How would we scale in</st> <st c="44888">and out?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44896">In</st> [*<st c="44900">Chapter 4</st>*](B31164_04.xhtml#_idTextAnchor201)<st
    c="44909">, we’ll</st> <st c="44917">spend more time diving into architecting
    the platform core while using Kubernetes as the unified orchestration layer.</st>
    <st c="45035">Whether you end up deciding on Kubernetes as the underlying abstraction
    layer or using something else, you will have to answer these questions as they
    will impact some of the decisions you will make.</st> <st c="45235">So, let’s
    dive into getting some answers on how that would impact our</st> <st c="45305">architectural
    decision</st><st c="45327">s!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45330">Avoid the ivory tower approach – we own the platform!</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="45384">Before</st> <st c="45392">answering the infrastructure-impacting
    questions, let’s answer the fundamental</st> <st c="45471">ownership question:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45490">We own the platform!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45511">The platform engineering team owns the platform as a</st> <st
    c="45565">product end-to-end!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45584">As our platform will provide capabilities to make delivering and
    operating software components easier, our top goal must be to follow our own best
    practices and ideally deploy the platform with the same golden paths and self-service
    capabilities we want our end users to use.</st> <st c="45861">Some organizations
    call this</st> *<st c="45890">being customer zero</st>* <st c="45909">or</st>
    *<st c="45913">drink your own champagne</st>*<st c="45937">. If we don’t follow
    that mantra and just build something, throw it over the wall, and hope somebody
    else operates it, we miss the whole point of having a modern product mindset for</st>
    <st c="46119">platform engineering.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46140">We need to feel the same pain of software delivery and operations
    that our users currently feel.</st> <st c="46238">This will be even more motivation
    for us to build platform capabilities that make our lives as software</st> <st
    c="46342">teams easier.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="46355">We need to avoid an</st> *<st c="46376">ivory tower approach</st>*
    <st c="46396">where we’re forcing best practices from the top down without following
    those best practices ourselves.</st> <st c="46500">If we do this, we may end up
    with a famous Reddit posting, similar to the one mentioned at the beginning of
    this chapter: “</st>*<st c="46623">We spent months building this platform.</st>
    <st c="46664">Devs hate it!</st> <st c="46678">Help me</st>* *<st c="46686">understand
    why!</st>*<st c="46701">”</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46703">Now, let’s go back and answer some of those infrastructure questions
    that were raised earlier that may influence our</st> <st c="46820">architectural
    decisio</st><st c="46841">ns.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46845">Organizational constraints – existing infrastructure requirements?</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="46912">We need to</st> <st c="46924">find out whether there are constraints
    on using existing infrastructure services.</st> <st c="47006">When it comes to
    enterprises, contracts with infrastructure or cloud providers will likely exist.</st>
    <st c="47104">If such constraints exist, it will play a role in our decisions
    – for example, do we need to run and operate our own K8s cluster on-premises or
    can we leverage a managed service from a vendor?</st> <st c="47297">If we’re constrained
    to a certain cloud vendor, this also means we’re potentially constrained to use
    their service offerings (storage, database, caches,</st> <st c="47450">and more).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47460">Regarding that area, we also want to look into access control,
    ingress and egress, and</st> <st c="47548">cost constraints!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47565">It’s important to know about all such organizational constraints
    before finalizing the decisions on infrastructure</st> <st c="47681">and architect</st><st
    c="47694">ure!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47699">Connectivity constraints – interoperability requirements?</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="47757">Our platform</st> <st c="47771">capabilities will require us to
    connect to and interact with other existing systems.</st> <st c="47856">That ranges
    from having access to SSO, your Git repository, CI/CD pipelines, observability,
    orchestration layers, cloud APIs,</st> <st c="47982">and more.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47991">Depending on where the platform will run – that is, on-premises
    versus the cloud – this will have an impact on how the platform can connect with
    all those tools or how those tools can connect back to</st> <st c="48192">the
    platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48205">We need to think about firewalls, pull versus push connectivity,
    and API rate limits and costs as we need to ensure resilient interoperability
    between all</st> <st c="48361">those systems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48375">It’s important to know all those connectivity constraints before
    finalizing the decisions on the infrastructure and location where our platform
    resides regarding all other systems we need to</st> <st c="48567">connec</st><st
    c="48573">t to.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48579">Resiliency constraints – SLAs and other non-functional requirements?</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="48648">The</st> <st c="48652">goal of our platform is to improve day-to-day
    work for a variety of internal users (developers, DevOps, IT ops, quality engineers,
    app support, and more).</st> <st c="48808">This means that our platform needs
    to be available and working every time our users need it.</st> <st c="48901">In
    global enterprises, this could mean operational resiliency and high availability
    24/7\.</st> <st c="48991">If the platform isn’t available, our engineers can’t
    do their critical work, such as releasing a new version of a piece of software,
    patching a security issue, or scaling their workloads to handle increased end</st>
    <st c="49202">user demand!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49214">So, we need to understand the non-functional requirements on our
    platform, such as</st> <st c="49298">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49312">Availability – for example, 9 A.M.</st> <st c="49348">to 5 P.M.</st>
    <st c="49358">in a single time zone or Monday to Friday across all</st> <st c="49411">time
    zones</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="49421">User experience – for example, the acceptable end user performance
    of a system must be guaranteed, with up to 100 concurrent engineers using the</st>
    <st c="49567">platform capabilities</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="49588">Those non-functional requirements also mean we need to think about
    how we scale up and down, as well as scale out and in.</st> <st c="49711">We need
    to define whether we provide our platform centrally so that it serves all geographies
    around the globe or whether we need to deploy the platform components across the
    different regions to better fulfill the user experience requirements on</st> <st
    c="49958">acceptable performance.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49981">Dynamic, horizontal, or vertical scaling is a topic that we’ll
    look at in more detail later in this book when we dive into architecting the platform’s
    core with Kubernetes as a</st> <st c="50159">unified layer.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50173">Now that we have answers to all those questions, we’ll be able
    to make better-informed decisions about infrastructure and architectural choices
    for our platform and</st> <st c="50339">its capabil</st><st c="50350">ities!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50357">Exploring multi-cloud, multi-SaaS, and the fragmentation of capabilities</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="50430">When we look into the fragmentation of capabilities and how that
    interoperates with the platform as a service and its scalability, one thing comes
    to our mind as a critical function that may not be the most obvious at first:
    the</st> *<st c="50660">IDP should be multi-tenant, not</st>* *<st c="50692">just
    multi-</st><st c="50703">user</st>*<st c="50708">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50709">Multi-tenancy and ownership as a capability of our platform</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="50769">Multi-tenancy is</st> <st c="50786">usually thought of in the
    context of a production application.</st> <st c="50850">For example, our platform
    client Financial One ACME is looking to turn their single-tenant product into
    a multi-tenant product.</st> <st c="50978">This will help them achieve higher
    profit margins, give them less operational overhead, and a slew of other business
    wins.</st> <st c="51101">The same data separation that exists within a production
    application in a highly regulated industry should exist at every level of that
    application life cycle, including the IDP.</st> <st c="51280">This is not only
    best practice but may be necessary to gain certain security and</st> <st c="51361">compliance
    certifications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51387">Since production data can make its way into tests, ensuring that
    the default access level of every user on the platform is as restrictive as possible
    by default helps to ensure that should data end up somewhere undesired, the surface
    level of exposure for that data is as minimal as possible.</st> <st c="51681">Additionally,
    the full isolation of multi-tenancy ensures that secrets that each team may need
    are isolated from each other, further mitigating any</st> <st c="51829">risk surfaces.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51843">We’ll explore the benefits of security and multi-tenancy in the
    platform further in</st> [*<st c="51928">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="51937">. However, it’s important to note that multi-tenancy can also help reduce
    the cognitive load of the platform’s users.</st> <st c="52055">We’ll cover how
    more fully in</st> [*<st c="52085">Chapter 6</st>*](B31164_06.xhtml#_idTextAnchor341)<st
    c="52094">,</st> *<st c="52096">Building for Developers and</st>* *<st c="52124">their
    Self-Service</st>*<st c="52142">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52143">Multi-tenancy also means that any architectural decision we make
    – any tools we include in our platform – also support multi-tenancy.</st> <st
    c="52278">Take observability as an example – if we capture logs, metrics, traces,
    and events for the core platform, as well as the applications our users are deploying,
    we need to make sure that this observability data can be “separated” into its
    individual tenants.</st> <st c="52535">We’ve already discussed that our platform
    must include ownership as metadata when deploying our core platform, as well as
    when we provide templates for self-service onboarding of new apps.</st> <st c="52724">Let’s
    consider an example deployment definition enriched with ownership metadata, as
    discussed in the</st> *<st c="52826">Overcoming platform complexity</st>* <st
    c="52856">section.</st> <st c="52866">That ownership metadata</st> <st c="52889">can
    be used to enforce access control to any data captured for that deployment, including
    using it for filters when querying for your metrics</st> <st c="53032">or traces:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="53042">service-abc.yaml (</st>****<st c="53061">Kubernetes Deployment)</st>**
    | **<st c="53084">Using Ownership Metadata</st>** **<st c="53110">with Observability!</st>**
    |'
  prefs: []
  type: TYPE_TB
- en: '| `<st c="53129">apiVersion: apps/v1</st>``<st c="53149">kind: Deployment</st>``<st
    c="53166">metadata:</st>``**<st c="53176">name: fund-transfer-service</st>**`
    **`**<st c="53204">namespace: prod-useast-01</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<st c="53230">spec:</st>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="53236">…</st>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`**<st c="53237">template:</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`**<st c="53246">metadata:</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`**<st c="53256">annotations:</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`**<st c="53269">owner.team: dev-team-backend</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`**<st c="53298">app.kubernetes.io/name: fund-transfer-service</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`**<st c="53344">app.kubernetes.io/part-of: backend-services</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`**<st c="53388">app.kubernetes.io/version: 2.34</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<st c="53420">…</st>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`**<st c="53421">spec:</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`**<st c="53426">containers:</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<st c="53438">-</st>` `<st c="53441">name: fund-transfer</st>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`**<st c="53460">image: "financeoneacme/fund-transfer:2.34"</st>**`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`<st c="53503">…</st>`************************  | <st c="53504">The annotations
    can be used as filters in PromQL queries,</st> <st c="53562">for example:</st>`<st
    c="53574">sum(rate(container_cpu_usage_seconds_total{annotation_name="owner.team",
    annotation_value="dev-team-backend"}[5m]))</st>` |'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="53690">Table 3.6: How ownership metadata can be defined and used</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53748">This</st> <st c="53754">ownership information can be used to give
    access to observability data to those teams that own that component.</st> <st
    c="53865">It allows us to separate the data into its tenants while also allowing
    admins of our platform or owners of shared services to analyze data that goes
    beyond a single tenant.</st> <st c="54038">This is also an important capability
    as it’s very likely we will run into cross-tenant issues.</st> <st c="54133">So,
    having all observability with the right context available will be critical to
    identifying issues and</st> <st c="54238">fixing them.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54250">Data pipelines – whether using OpenTelemetry Collectors or commercial
    products – can also use this metadata to send the observability data to different
    backend storages to even separate the storage of that data based</st> <st c="54468">on
    tenancy!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54479">The topic of ownership and observability will be discussed in
    more detail in the following chapters as it’s a key enabler for many capabilities
    and attributes of</st> <st c="54642">our platform!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54655">The considerations for running on multi-X</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="54697">In the</st> *<st c="54705">Organizational constraints</st>* <st
    c="54731">section, we talked about understanding any existing constraints, such</st>
    <st c="54802">as whether we have the</st> <st c="54824">business or regulatory
    obligation to run multi-cloud, multi-SaaS, or – as some call it –</st> **<st c="54914">hybrid
    cloud</st>**<st c="54926">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54927">When Financial One ACME wants to sell into different global markets,
    there will likely be the requirement to operate our software out of a cloud vendor’s
    most local region – for example, EU-WEST or APAC-SOUTHEAST.</st> <st c="55142">There
    might even be the requirement to run it across multiple regions or multiple different
    vendors to fulfill contractual obligations for high availability and resiliency
    while adhering to the standards that those companies need</st> <st c="55372">to
    obey.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55380">For competitive or regulatory reasons, it’s also possible that
    some cloud or SaaS vendors can’t be used at all.</st> <st c="55493">Why is that?</st>
    <st c="55506">Well, if a potential customer of Financial One ACME considers one
    of those cloud vendors as a competitor or if one vendor doesn’t meet some regulatory
    requirement, they wouldn’t be able to purchase our</st> <st c="55708">software
    services.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="55726">This sounds</st> <st c="55739">like a lot of constraints leaving
    us with not much choice, doesn’t it?</st> <st c="55810">Fortunately, there are
    solutions to solve that problem: in the coming chapters, we’ll talk a lot about
    Kubernetes as the underlying abstraction layer.</st> <st c="55961">Building on
    top of this abstraction layer will make it easier – but not hassle-free – for
    us to move workloads to different regions and different</st> <st c="56107">cloud
    vendors.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56121">As our platform and all of its components will not exclusively
    run on Kubernetes but also include other services, it’s important to create a
    thorough checklist to avoid any architectural decisions that will be hard to change
    in the future.</st> <st c="56362">For example, if our platform has requirements
    for a document store service, we can either decide to run and operate a document
    database such as MongoDB on Kubernetes or pick an existing SaaS offering from
    one of the cloud vendors.</st> <st c="56593">Picking a managed service will reduce
    the effort on our end, but we need to make sure that each potential SaaS vendor
    that supports a document store service provides the same interface, similar performance
    characteristics, and similar cost structure.</st> <st c="56844">If we make the
    wrong architectural decision, it might be difficult to do</st> <st c="56917">the
    following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56931">Change our implementation so that it supports a</st> <st c="56980">different
    API</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56993">Have a performance and scalability impact on</st> <st c="57039">different
    vendors</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57056">Increase the overall operational costs of</st> <st c="57099">our
    softw</st><st c="57108">are</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57112">Centralized and decentralized platform capabilities</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="57164">In the</st> <st c="57172">following chapters, we’ll provide more
    examples of</st> <st c="57222">running our IDP and its components either as a
    central service, per environment, per region, or even per tenant (if that is a
    requirement).</st> <st c="57363">Your findings about organizational requirements
    will impact those decisions, such as whether our customers demand that they run
    in certain regions or aren’t allowed to use a certain</st> <st c="57545">cloud
    vendor.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57558">Centralizing components has the big advantage of them being easier
    to manage.</st> <st c="57637">Think about a</st> <st c="57651">central</st> **<st
    c="57659">continuous integration</st>** <st c="57681">(</st>**<st c="57683">CI</st>**<st
    c="57685">) system such as Jenkins or GitLab that runs pipelines triggered by
    pull requests to build new artifacts.</st> <st c="57792">A central instance of
    such a CI system is easier to operate, observe, secure, and manage.</st> <st c="57882">On
    the flip side, it means that all our users share the same system, which can easily
    lead to bottlenecks.</st> <st c="57989">The central system also needs to</st>
    <st c="58022">have access to all target environments, which may reside in different
    geographical</st> <st c="58105">regions or even other cloud providers.</st> <st
    c="58144">The number of dependencies to those cloud environments increases with
    every new team that onboards their application or with every new customer of Financial
    One ACME that demands our software to be</st> <st c="58342">deployed specially!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58361">Decentralizing components have the advantage of being able to
    automatically encapsulate the data capture, storage, and access processes.</st>
    <st c="58499">These components are only used by those teams in those regions or
    environments, which limits the potential of patterns such as noisy neighbors,
    something we’ll discuss in more detail in</st> [*<st c="58685">Chapter 6</st>*](B31164_06.xhtml#_idTextAnchor341)<st
    c="58694">. The drawback of a decentralized approach is that it’s harder to operate,
    observe, secure, and manage those components as the number of components will
    grow with every new environment.</st> <st c="58880">Automation can help here,
    but we can’t downplay the additional level of complexity.</st> <st c="58964">Just
    think about whether a vulnerability is found in our CI system.</st> <st c="59032">Instead
    of patching it once in a central system, we need to patch every single instance
    across all our</st> <st c="59135">decentralized services!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59158">Now that we’ve learned that multi-X – which includes multi-tenancy,
    cloud, and SaaS – will have an impact on our architectural decisions, it’s important
    to find a good balance between the effort, benefit, and external requirements
    we have on our platform.</st> <st c="59415">All the knowledge we’ve gained so
    far allows us to come up with a good reference architecture for our platform,
    something we’ll discuss in the last part of</st> <st c="59571">this</st> <st c="59576">chapter!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59584">Exploring a reference architecture for our platform</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="59636">Architectural</st> <st c="59651">diagrams are a great way to give
    a good overview of what a system provides to the end user and how the inner plumbing
    works.</st> <st c="59776">In this chapter, we discussed several important steps
    toward building the foundation for a future platform and</st> <st c="59887">its
    capabilities:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="59904">The purpose of our platform (solving end user pain)</st>**<st
    c="59956">: Who are our end users and what problem do we need</st> <st c="60009">to
    solve?</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="60018">User interface/dev experience</st>**<st c="60048">: What is
    the ideal developer experience for our end users to best fit into their day-to-day</st>
    <st c="60142">work activity?</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="60156">Core platform components</st>**<st c="60181">: Picking the
    right components to adhere to existing processes, tools, infrastructure,</st>
    <st c="60269">and constraints.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="60285">Our platform as a product</st>**<st c="60311">: Like any software
    product, our platform must be available, resilient (also work under heavy usage),
    and secure</st> <st c="60425">by default.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="60436">Success KPIs</st>**<st c="60449">: Use observability to measure
    and drive for adoption, efficiency,</st> <st c="60517">and productivity.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="60534">A different way to</st> <st c="60554">present this is through
    a high-level diagram of our platform.</st> <st c="60616">While the following diagram
    isn’t complete, it can be a good reference for the platforms that you’ll</st>
    <st c="60717">be building:</st>
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.6: Reference architecture for our platform \uFEFFfoundation (The\
    \ image is intended as a visual reference; the textual information isn't essential.)](img/Figure_3.06_B31164.jpg)"
  prefs: []
  type: TYPE_IMG
- en: '<st c="60896">Figure 3.6: Reference architecture for our platform foundation
    (The image is intended as a visual reference; the textual information isn''t essential.)</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61046">Our platform as a product has to have a clear purpose!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61101">Start by visualizing and articulating the purpose before going
    into the</st> <st c="61174">technical details!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61192">Let’s walk through this diagram as you would when presenting it
    to your peers or end users.</st> <st c="61285">We’ll start from the top down before
    we look into the aspects of observability, availability, resilience,</st> <st
    c="61391">and</st> <st c="61395">security.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61404">The purpose – self-service for your end users</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="61450">In</st> [*<st c="61454">Chapter 2</st>*](B31164_02.xhtml#_idTextAnchor055)<st
    c="61463">, we gave</st> <st c="61473">an example of a platform principle that
    we called</st> *<st c="61523">self-service first</st>*<st c="61541">. We provided
    a detailed description stating, “</st>*<st c="61588">We will provide our customers
    with every platform capability as a self-service, focusing on their user experience
    and enabling self-determined</st>* *<st c="61732">software development.</st>*<st
    c="61753">”</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61755">This is exactly what’s reflected at the top of the preceding diagram.</st>
    <st c="61825">Here, we listed all of the potential end users we learned about.</st>
    <st c="61890">For Financial One ACME, we have our development teams supporting
    them with use cases around easier onboarding of new applications or getting easier
    access to log files from the legacy systems in production.</st> <st c="62097">We
    also provide self-service for the DevOps, security,</st> **<st c="62152">site
    reliability engineering</st>** <st c="62180">(</st>**<st c="62182">SRE</st>**<st
    c="62185">), and</st> <st c="62192">application support teams by reducing the
    manual work and cognitive load through</st> <st c="62274">self-service capabilities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62300">There is only so much space on a high-level diagram like this.</st>
    <st c="62364">We could add examples for the different end user self-service features
    as text or – if needed – provide a more detailed version of this diagram for every
    end user and their</st> <st c="62537">self-servic</st><st c="62548">e features!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62560">User interface/dev experience</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="62590">Every end user</st> <st c="62605">group is different.</st> <st
    c="62626">Even within end user groups we may have different skill sets that need
    to be considered when designing and implementing the user interface for our platform’s</st>
    <st c="62784">self-service capabilities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62810">Development teams most likely prefer to stay in their preferred
    IDE, such as Visual Studio Code or IntelliJ.</st> <st c="62920">They’re probably
    OK to edit YAML files to enable new self-service capabilities.</st> <st c="63000">Some
    may expect an IDE extension that will bootstrap the creation of those YAML files
    or an extension that provides code completion and schema validation to reduce
    the chances of making a mistake such as</st> <st c="63204">a typo.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63211">On the other hand, other teams within the same organization might
    want a nice developer portal UI – something such as Backstage, which provides
    nice templating features for creating</st> <st c="63394">new components.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63409">Then, you will have your automation engineers, who neither live
    in an IDE nor want to click through a wizard to create a new project.</st> <st
    c="63544">They want an API or a CLI they can use to automate tasks as this is
    the way they’re used to working.</st> <st c="63645">They probably expect some
    Python libraries to call our</st> <st c="63700">self-service capabilities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63726">As discussed</st> <st c="63740">earlier in this chapter, every
    user has different skills and therefore also different expectations of what a
    good user experience looks like.</st> <st c="63882">Focusing on a good user experience
    is key as this will be a deciding factor on whether the platform will be adopted
    or not.</st> <st c="64006">This is why it’s important to highlight the user interface
    and how it may look in our reference architecture as this is the way our users
    will interact with</st> <st c="64163">our platform!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64176">Core platform components</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="64201">While we all</st> <st c="64215">have our preferences for picking
    tools and technology, the right approach to picking your core platform components
    should not be by personal preference.</st> <st c="64368">It must be based on what
    self-service use cases (that is, features of our platform) we want to deliver
    through a user interface that delivers a good user and</st> <st c="64526">developer
    experience.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64547">In the preceding diagram, we subcategorized the platform components
    into the</st> <st c="64625">following areas:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="64641">Delivery services</st>**<st c="64659">: Those</st> <st c="64668">are
    tools and services that focus on software delivery as this is going to be a primary
    use case of our platform.</st> <st c="64782">CNCF open source tools such as Backstage,
    ArgoCD, Flux, and OpenFeature, open source tools such as GitLab, Jenkins, and
    K6, or even commercial tools such as the tools from Atlassian would fall into</st>
    <st c="64980">this category.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="64994">Platform services</st>**<st c="65012">: As a</st> <st c="65020">key
    use case will be around delivering and operating software components, our platform
    should also provide core platform services that those software components need.</st>
    <st c="65187">That could include services such as caching or databases (Redis,
    MongoDB, or Postgres), messaging and eventing (Apache Kafka or RabbitMB), service
    mesh (Istio, Linkerd, or Nginx), and core services such as secrets management,
    container registries, policy agents, auto-scalers</st> <st c="65463">and more.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="65472">Platform</st>**<st c="65481">: While the platform doesn’t need
    to run on Kubernetes, in the remainder of this book, we will focus on K8s as the
    underlying platform orchestration layer.</st> <st c="65638">However, Kubernetes
    must not be the answer to all platform engineering questions.</st> <st c="65720">The
    goal is to pick the right platform components to provide the self-service your
    end users require.</st> <st c="65822">This may lead you to run your platform on
    VMs or even pick a fully managed out-of-the-box</st> <st c="65912">SaaS solution!</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="65926">X-as-Code</st>**<st c="65936">: Besides</st> *<st c="65947">self-service
    first</st>*<st c="65965">, we must also embrace an</st> *<st c="65991">Everything
    as Code</st>* <st c="66009">mantra.</st> <st c="66018">Whether</st> <st c="66025">it’s
    defining deployments, observability, or ownership, as</st> <st c="66085">discussed
    earlier in this chapter, or any other software life cycle aspect, everything should
    be expressed in some type of code.</st> <st c="66214">This is where you want to
    pick tools such as Crossplane, Terraform, or Ansible.</st> <st c="66294">Crossplane
    in particular is emerging in the cloud-native space as a tool of choice when it
    comes to orchestrating applications and infrastructure in a declarative way.</st>
    <st c="66462">Also, make sure to validate your tool choices for delivery and platform
    services based on how</st> *<st c="66556">X-as-Code</st>*<st c="66565">-friendly
    they are, such as how they</st> <st c="66603">define</st> **<st c="66610">service-level
    objectives</st>** <st c="66634">(</st>**<st c="66636">SLOs</st>**<st c="66640">)
    or monitoring alerts with the selected</st> <st c="66682">observability tool!</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="66701">Observability</st>**<st c="66715">: You wouldn’t drive</st>
    <st c="66736">a car or fly a plane without any telemetry and your key indicators
    such as speed, altitude, or fuel gauge.</st> <st c="66844">We must also not operate
    any platform without observability built-in.</st> <st c="66914">Thanks to standards</st>
    <st c="66934">such as OpenTelemetry and projects such as Prometheus and Fluent,
    we have a lot of built-in observability signals in the components that we’ll be
    using in our platform.</st> <st c="67103">Whether it’s Kubernetes itself or tools
    such as Nginx, Reddis, Harbour, ArgoCD, or Backstage, all those tools emit metrics,
    logs, events, and/or traces that we can collect and send to our observability
    backend for automated analysis or alerting!</st> <st c="67349">While lots are
    already built in, not every tool we choose will likely provide all the data we
    need out of the box.</st> <st c="67464">Therefore, it’s important to validate
    your tool choices based on their state of observability.</st> <st c="67559">For
    some tools, you may need to extract metrics from logs.</st> <st c="67618">For
    others, you may need an extension – for example, Jenkins provides an OpenTelemetry
    plugin to emit traces for each Jenkins Job execution.</st> <st c="67759">In other
    cases, you may need to rely on commercial observability offerings through</st>
    <st c="67842">agent-based instrumentation.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="67870">Observability will be covered more later in this book as it’s
    the enabler for many disciplines, such as SRE, auto-scaling, incident response,</st>
    <st c="68012">and troubleshooting.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="68033">A platform that’s available, resilient, and secure</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="68084">A platform is a product!</st> <st c="68110">So, a product that
    we want to be used by our internal users has to be available when they need it,
    resilient when a lot of users need it at the same time, and secure to ensure our
    users trust</st> <st c="68302">the product.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68314">To ensure that our platform is always there when our users need
    it, we need to apply the same architectural principles that we would apply to
    any type of software product that we want to become successful.</st> <st c="68521">For
    our platform, this means that all critical components of the platform also need
    to be available, resilient, and secure by default.</st> <st c="68656">Let’s have
    a look at some examples and best practices for</st> <st c="68713">these</st> <st
    c="68720">three pillars.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68734">Availability</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="68747">Our users</st> <st c="68758">consider our platform available when
    they can use it for the self-service use cases we promised it would deliver.</st>
    <st c="68872">Remember our proposed</st> *<st c="68894">Request a log from production
    self-service</st>* <st c="68936">use case from</st> *<st c="68951">Figure 3</st>**<st
    c="68959">.2</st>*<st c="68961">? If a development team follows that self-service
    use case, they expect that our platform will deliver the requested logs in a reasonable
    amount of time at any time, whether it’s Tuesday at noon or Friday at</st> <st
    c="69169">11 P.M.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69176">That use case involves a lot of different tools, such as Git (where
    the config as code files are stored) and our homegrown solution, which offers
    a REST API to request specific logs.</st> <st c="69360">Both systems need to be
    available.</st> <st c="69395">Both systems also need to respond to requests in
    a specified amount of time with a</st> <st c="69478">valid response.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69493">The best way to ensure availability is by following</st> <st c="69546">two
    steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="69556">End-to-end use case monitoring</st>**<st c="69587">: As we
    would do for business-critical applications, we can set up synthetic tests to
    simulate the end-to-end user journey for that use case.</st> <st c="69730">In
    this case, we would validate that calls to the Git API work as expected by executing
    dummy commits and PRs and validating the response time and response code.</st>
    <st c="69892">We would also do the same for our REST API call to request the logs.</st>
    <st c="69961">However, this scenario also needs to wait until the requested logs
    are sent back to the development team’s communication channel so that we can measure
    the full</st> <st c="70122">end-two-end time.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="70139">Both scenarios can be done through custom scripting, which we
    run as a cron job, or we can leverage</st> <st c="70240">existing synthetic testing
    solutions.</st> <st c="70278">You should validate whether your observability platform
    already provides synthetic tests as many of those vendors have this feature in
    their portfolio.</st> <st c="70430">This will also make it easier for our second
    step, which is monitoring and alerting on key</st> <st c="70521">quality indicators!</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="70540">Monitor and alert on key availability indicators</st>**<st
    c="70589">: As the platform team, we want to be notified if our platform self-service
    use cases are no longer working as expected before our end users start complaining.</st>
    <st c="70750">This is where monitoring and alerting on key indicators come in.</st>
    <st c="70815">Our synthetic tests already provide a good indicator, but we should
    set up automated alerting in case the Git API or our REST API starts to slow down
    or start responding to errors.</st> <st c="70996">On top of that, we can also
    alert on other leading indicators.</st> <st c="71059">Many tools in our platform
    – including Git, from our example – will produce logs as well as health indicator
    metrics.</st> <st c="71177">We want to be notified in case we see</st> *<st c="71215">ANY
    ERROR</st>* <st c="71224">logs on those systems.</st> <st c="71248">They can be
    early warning indicators.</st> <st c="71286">Most systems also have internal queues,
    such as request queues.</st> <st c="71350">We want to be notified if those queues
    keep growing since this is an indicator that too many incoming requests are piling
    up, which will eventually lead to performance and</st> <st c="71522">availability
    problems.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="71544">There are many other things we have to do to ensure systems stay
    available.</st> <st c="71621">We’ll discuss those in the next section, where we’ll</st>
    <st c="71673">talk</st> <st c="71679">about resiliency.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71696">Resiliency</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="71707">We just</st> <st c="71715">talked about the availability of our
    product.</st> <st c="71762">For our end users, the platform must always be available,
    whether they’re the only user on the system or whether 1,000 others are trying
    to execute self-service tasks.</st> <st c="71930">They also expect availability,
    regardless of whether there are any issues in our internal infrastructure or our
    cloud services.</st> <st c="72058">This is when we talk about the resiliency of
    a system.</st> <st c="72113">It means that despite any unexpected events (high
    load, component failures, connectivity issues, and so on), the system itself</st>
    <st c="72240">stays available.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72256">From an</st> <st c="72264">architectural perspective, there are
    many things we can do to make a system more resilient, thus leading to high availability.</st>
    <st c="72392">Let’s consider our REST API example again.</st> <st c="72435">From
    a deployment perspective, we can do</st> <st c="72476">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="72490">Load balance replicated deployments</st>**<st c="72526">: We
    can deploy our implementation using ReplicaSets, which leads to multiple actual
    Pod instances having to handle incoming requests.</st> <st c="72662">Requests
    can be load balanced with round-robin or other more</st> <st c="72723">sophisticated
    algorithms.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="72748">Implement geographical diversity</st>**<st c="72781">: To adhere
    to a global user base, we can deploy our implementation into regions where our
    users reside.</st> <st c="72887">This reduces the impact of network latency and
    distributes the load, depending on where our</st> <st c="72979">users are.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="72989">Provide automatic scaling</st>**<st c="73015">:</st> **<st
    c="73018">Horizontal Pod Autoscaler</st>** <st c="73043">(</st>**<st c="73045">HPA</st>**<st
    c="73048">) and</st> **<st c="73055">Kubernetes Event Driven Autoscaling</st>**
    <st c="73090">(</st>**<st c="73092">KEDA</st>**<st c="73096">) allow us to scale
    our implementation</st> <st c="73135">based on indicators</st> <st c="73155">such
    as CPU, memory, incoming requests, or even user experience.</st> <st c="73221">This
    allows us to avoid most resource constraint</st> <st c="73270">resilience issues.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="73288">Perform automated backup and recovery</st>**<st c="73326">:
    Not every issue can be averted.</st> <st c="73361">If disaster strikes, it’s important
    to have automated backup and recovery options so that we can return to normal
    operation as fast</st> <st c="73493">as possible.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="73505">From a software architecture perspective, our REST API has</st>
    <st c="73565">several options:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="73581">API rate limiting</st>**<st c="73599">: We can limit the number
    of incoming requests overall or from a particular user or team.</st> <st c="73690">This
    avoids problems that may arise if someone accidentally (or on purpose) is flooding
    our system with too</st> <st c="73798">many requests.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="73812">Queuing incoming requests</st>**<st c="73838">: Event-driven
    architectures allow us to queue requests and work on them when workers are available.</st>
    <st c="73940">Workers can then also be scaled depending on queue length.</st>
    <st c="73999">While additional layers, such as request queues, will potentially
    impact request latency, this architectural pattern will increase stability, resiliency,</st>
    <st c="74153">and availability.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="74170">Retries and backoff to downstream systems</st>**<st c="74212">:
    As we also make calls to backend systems such as Git or the logging observability
    backend, we want to make</st> <st c="74322">sure we aren’t impacted by problems
    on their end.</st> <st c="74372">For this, we can implement API retries (in case
    an API call takes too long or fails) in combination with backoff (increasing the
    time between API calls).</st> <st c="74526">Those strategies will increase our
    resiliency and also</st> <st c="74581">help our</st> <st c="74590">downstream
    systems.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="74609">Security</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="74618">If our platform</st> <st c="74635">is available at any time, that’s
    a great start.</st> <st c="74683">But like any software product, it has to also
    be secure.</st> <st c="74740">This is even more important for platforms as they
    enable our end users to create, deploy, and operate new software applications
    that also have to be secure.</st> <st c="74897">If our platform runs on a stack
    and tools that have known vulnerabilities or that can be hacked into, we’re open
    to attackers leveraging this for software supply chain attacks or to get access
    to confidential information.</st> <st c="75119">Let’s look at our REST API again.</st>
    <st c="75153">If we allow everyone to use that API to request logs from production,
    we may end up sending critical log information to</st> <st c="75273">a hacker.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75282">That’s why it’s important to apply the strictest security guidelines
    to our platform, every component and tool we use, and every line of code we’re
    developing.</st> <st c="75443">In</st> [*<st c="75446">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="75455">, we’ll cover the topic of building compliant and secure products in
    more detail, which is why we keep it at a high level here.</st> <st c="75583">We
    must consider our platform to be the most critical software in our company.</st>
    <st c="75662">Therefore, we must not deploy any components that have known vulnerabilities.</st>
    <st c="75740">We must implement proper access control in all our custom-developed
    APIs.</st> <st c="75814">We must use all the security scanning and alerting tools
    for our platform that we would also use for any business-critical software we
    run</st> <st c="75953">in production.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75967">We’re the platform engineering team, which means we’re responsible
    for our platform’s security, just as we are for its</st> <st c="76086">availability</st>
    <st c="76100">and resiliency!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76115">Success KPIs and optimization</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="76145">“</st>*<st c="76147">We spent months building our new platform.</st>
    <st c="76190">Devs hate it!</st> <st c="76204">Help me</st>* *<st c="76212">understand
    why!</st>*<st c="76227">”</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76229">With</st> <st c="76233">everything we’ve learned so far, we should
    be in a good position to not run into the problem we wanted to avoid from the
    start of this chapter.</st> <st c="76378">We want to build something that our
    users love to use as it makes their lives easier.</st> <st c="76464">But we can’t
    just claim success based on a gut feeling or anecdotal evidence.</st> <st c="76542">We
    need to measure our impact and report our success based on KPIs and we need to
    leverage all the data we can observe from within our platform to</st> <st c="76689">keep
    optimizing those success KPIs, as well as the operational aspect of</st> <st c="76762">the
    platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76775">We’ve already talked a lot about observability, both as a self-service
    feature of our platform and for our end users, as well as using observability
    to understand the inner workings of our platform to ensure availability and resiliency.</st>
    <st c="77013">Observing our platform components such as Backstage, ArgoCD, Jenkins,
    OpenFeature, Git, Harbor, Redis, Istio, and Kubernetes itself gives us a lot of
    insights into the success of our platform and its features.</st> <st c="77223">Let’s
    dive into some key indicators, how to capture them, and what we can do with them
    to optimize our pl</st><st c="77328">atform adoption</st> <st c="77345">and efficiency.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77360">Active users</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="77373">If tools</st> <st c="77383">such as</st> <st c="77390">Backstage
    are the developer portal of choice for our platform, we’ll want to measure how
    many of our users log in to Backstage on a day or in a week.</st> <st c="77541">We
    want to measure how many new projects get created through the Backstage templating
    engine and how many new or updated Git repositories that</st> <st c="77684">results
    in.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77695">For our Financial One ACME use case on log analytics, we can measure
    how often our REST API is called.</st> <st c="77799">As teams should identify
    with a team identifier or token, we can measure how many teams are using our feature
    and</st> <st c="77913">how often.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77923">These are all good indicators of current adoption.</st> <st c="77975">If
    we see slow adoption, we can reach out with more education or utilize more one-on-one
    sessions to enable more teams.</st> <st c="78095">We can also use the existing
    adoption of individual teams and create internal success stories to promote the
    platform’s capabilities to</st> <st c="78231">other teams.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78243">However, it’s important to start measuring how many active users
    we have on the platform and use this as a baseline so that we can set addi</st><st
    c="78383">tional actions and</st> <st c="78403">grow adoption!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78417">SLOs/DORA</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="78427">A platform</st> <st c="78439">is a chance to promote best practices
    through self-service templates.</st> <st c="78509">This is where SLOs come in.</st>
    <st c="78537">Not only can we define SLOs for our platform components, such as
    availability, but we can take this as a chance to include SLO definitions in any
    new template for new software projects our end users are creating through our
    platform – we want their software to also be highly available, resilient,</st>
    <st c="78835">and secure.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78846">On top of that, we can measure how many new software projects
    and releases are created and published with the help of our platform.</st> <st
    c="78979">We can look into the number of Jenkins job executions, how long they
    take, how often ArgoCD syncs, and how many of those deployments that end up in
    production meet their SLOs.</st> <st c="79155">These are all indicators that help
    us report parts of the DORA metrics back to the engineering teams.</st> <st c="79257">They
    need these metrics to show how efficient they are.</st> <st c="79313">This also
    helps us, as the platform team, to highlight how much more efficient teams are
    becoming with the help of our platform as we assume metrics such as</st> *<st
    c="79470">deployment frequency</st>* <st c="79490">or</st> *<st c="79494">lead
    time for change</st>* <st c="79514">will improve.</st> <st c="79529">We’ll cover
    DORA in more detail in</st> [*<st c="79564">Chapter 5</st>*](B31164_05.xhtml#_idTextAnchor255)<st
    c="79573">, where</st> <st c="79580">we’ll dive into</st> <st c="79597">CI/CD
    automation!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79614">Utilization/FinOps</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="79633">Having a</st> <st c="79642">lot of users adopt our platform is
    a great goal and we’ve already learned how to measure it.</st> <st c="79736">Bringing
    more teams onto a centralized platform allows us to centrally enforce best practices
    around the right-sizing and right-scaling of deployments and optimizing the utilization
    of the underlying infrastructure, which results in optimizing costs for the platform
    and all the apps that get deployed</st> <st c="80038">through it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80049">In</st> [*<st c="80053">Chapter 1</st>*](B31164_01.xhtml#_idTextAnchor014)<st
    c="80062">, we mentioned a new European regulation for reporting carbon emissions.</st>
    <st c="80135">This can also be done centrally as a platform capability by reporting
    actual resource utilization, the costs, and the calculated carbon impact of the
    platform, each platform service, and every application that gets deployed and
    operated through</st> <st c="80380">the platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80393">There are many more such use cases that help us optimize the utilization
    of the underlying infrastructure to keep our costs under control.</st> <st c="80533">Overall,
    this means that our platform is a</st> <st c="80576">great place for our</st>
    <st c="80596">FinOps initiatives!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80615">We hope you can apply a similar approach to creating an architectural
    reference architecture for your platform engineering projects.</st> <st c="80749">Start
    with a high-level overview that shows the purpose of the platform, gives an overview
    of the features and the user interface, gives insights into the core platform
    components, and indicates how you measure the success of yo</st><st c="80977">ur
    platform</st> <st c="80990">engineering initiative.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81013">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="81021">In this chapter, we learned how to approach platform engineering
    with a product mindset: find the real problem we need to solve, provide a simple
    quick solution to validate our implementation, identify how our platform fits
    into existing processes and organizational requirements, pitch a solution with
    the value proposition, which doesn’t just focus on development teams alone, and
    then design for flexibility without going down the route</st> <st c="81462">of
    over-engineering!</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81482">We ended up with a high-level reference architecture that you
    can use to promote the purpose of the platform to your end users and any other
    stakeholder that needs to support</st> <st c="81658">this project.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81671">In</st> [*<st c="81675">Chapter 4</st>*](B31164_04.xhtml#_idTextAnchor201)<st
    c="81684">, we’ll dive into the architectural details of a platform, the role
    of Kubernetes, how to integrate it with your existing services, and how to provide
    the platform’s capabilities to your application and service</st> <st c="81895">development
    teams!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81913">Further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="81929">[1] Reddit</st> <st c="81941">Post:</st> [<st c="81946">https://www.reddit.com/r/devops/comments/stuep4/weve_spent_months_building_this_platform_devs/</st>](
    https://www.reddit.com/r/devops/comments/stuep4/weve_spent_months_building_this_platform_devs/
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="82041">[2] Sunk</st> <st c="82051">Cost:</st> [<st c="82057">https://developerexperience.io/articles/sunk-cost</st>](https://developerexperience.io/articles/sunk-cost
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="82106">[3]</st> <st c="82111">CDEvents:</st> [<st c="82121">https://github.com/cdevents/spec</st>](https://github.com/cdevents/spec)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="0">Part 2 – Designing and Crafting Platforms</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="42">In</st> *<st c="46">Part 2</st>*<st c="52">, we will tackle the technical
    foundation of a platform and walk you through relevant decision points during
    the design process.</st> <st c="181">To do so, you will learn about the four primary
    parts of a platform – the core components and infrastructure represented by Kubernetes,
    the required automation for a platform, the relevant components for a self-service,
    developer-friendly oriented platform, and the steps required to build secure and</st>
    <st c="482">compliant environments.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="505">This part has the</st> <st c="524">following chapters:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[*<st c="543">Chapter 4</st>*](B31164_04.xhtml#_idTextAnchor201)<st c="553">,</st>
    *<st c="555">Architecting the Platform Core – Kubernetes as a Unified Layer</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="617">Chapter 5</st>*](B31164_05.xhtml#_idTextAnchor255)<st c="627">,</st>
    *<st c="629">Integration, Delivery, and Deployment – Automation is Ubiquitous</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="693">Chapter 6</st>*](B31164_06.xhtml#_idTextAnchor341)<st c="703">,</st>
    *<st c="705">Build for Developers and Their Self-Service</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
