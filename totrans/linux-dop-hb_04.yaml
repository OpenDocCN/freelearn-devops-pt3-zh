- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Automating with Shell Scripts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Shell 脚本自动化
- en: In this chapter, we’re going to demonstrate system administration task automation
    with shell scripts. We are going to illustrate several ways of handling scripting
    using Bash shell. The plan is to create a script that will automate the creation
    of the database dump. This task, while easy, will demonstrate how things can go
    sideways and how to handle those situations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过 shell 脚本演示系统管理任务的自动化。我们将展示使用 Bash shell 处理脚本的几种方法。计划是创建一个脚本来自动化数据库转储的创建。这个任务虽然简单，但将演示如何处理可能出现的问题，并且如何应对这些情况。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Backing up a database
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份数据库
- en: Understanding scripting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解脚本编写
- en: Understanding Bash built-ins and grammar
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Bash 内建命令和语法
- en: Understanding the backup script – first steps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解备份脚本——第一步
- en: Handling errors and debugging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误和调试
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will require a Linux system where you can install packages
    and are not afraid to break things in the process. To that end, a virtual machine
    would be most preferred, typically running on an old computer that you can reinstall
    from scratch. We do not expect to break anything, but during learning, this may
    happen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，你将需要一个可以安装软件包的 Linux 系统，并且不害怕在过程中出错。为此，虚拟机是最理想的，通常是在一台可以从头开始重新安装的旧计算机上运行。我们不指望会出错，但在学习过程中，可能会发生这种情况。
- en: Backing up a database
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份数据库
- en: 'In terms of most common databases, such as MySQL and PostgreSQL, there are
    at least two different ways to back up a database:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最常见的数据库，如 MySQL 和 PostgreSQL，至少有两种不同的方式来备份数据库：
- en: Take a database dump by extracting all current data, along with the database
    schema
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提取当前的所有数据和数据库架构来进行数据库转储
- en: Copy replication logs
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制复制日志
- en: In cloud environments, you can also take a snapshot of the disk database where
    the backup is being saved.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，你也可以对存储备份的磁盘数据库进行快照。
- en: A database dump can also be used as a full backup. Replication logs aren’t self-sufficient
    database dumps, so you will need to combine them with a full backup. This is called
    an incremental backup.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库转储也可以作为完整备份使用。复制日志并不是独立的数据库转储，因此你需要将它们与完整备份结合使用。这叫做增量备份。
- en: Doing a full backup can take a long time, especially for big databases. While
    it’s running, the database puts a lock on its data files, so it doesn’t save new
    data on the disk; instead, it stores everything in the replication logs until
    the database lock is released. For large databases, this operation can take hours.
    Because of that, we will be creating a full backup once a week and copying all
    replication logs every hour. Additionally, we will be creating a daily disk snapshot
    of our AWS database instance.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 进行完整备份可能会花费很长时间，尤其是对于大型数据库。在备份过程中，数据库会锁定其数据文件，因此不会将新数据保存到磁盘上；相反，所有数据都会存储在复制日志中，直到数据库锁被释放。对于大型数据库，这个过程可能需要数小时。鉴于此，我们将每周进行一次完整备份，并每小时复制一次所有复制日志。此外，我们还会每天创建一次
    AWS 数据库实例的磁盘快照。
- en: With this knowledge, we can start creating the most basic version of our script.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，我们可以开始创建最基本版本的脚本了。
- en: Understanding scripting
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解脚本编写
- en: A shell script is a simple text file filled with commands. Unlike compiled programs,
    shell scripts are not evaluated before execution, but rather while they are being
    executed. This makes for a very quick development process – there’s no compilation
    at all. But at the same time, the execution is a bit slower. Also, the errors
    that the compiler would have caught surface during execution and can often lead
    to script exiting.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本是一个简单的文本文件，里面包含了命令。与编译程序不同，shell 脚本在执行之前并不会被解析，而是在执行时解析。这使得开发过程非常快速——完全没有编译过程。但同时，执行速度稍慢。而且，编译器能够捕获的错误会在执行时显现，通常会导致脚本退出。
- en: On the upside, there’s not much to learn when you are writing a script – much
    less than when you are writing a program in C or Python. Interacting with system
    commands is as simple as just typing their names.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 优点是，编写脚本时需要学习的东西并不多——远远少于用 C 或 Python 编写程序时。与系统命令的交互就像是直接输入命令的名称一样简单。
- en: 'Bash lacks a lot of sophistication in programming languages: there are not
    many data types and structures, there’s very rudimentary control of scope, and
    the memory implementation is not meant to be efficient with scale.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 编程语言缺乏许多复杂性：它没有很多数据类型和结构，作用域控制非常基础，内存实现也不是为了在大规模下高效。
- en: 'There’s not one good rule of thumb for choosing when to write a script and
    when to develop a program. However, there are some points to consider. A good
    candidate for a shell script is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个固定的经验法则来选择何时编写脚本，何时开发程序。然而，有一些要点需要考虑。适合用 Shell 脚本的一个好候选条件如下：
- en: It’s not very long. We can’t give you a rule, but when you start to go into
    hundreds of lines, it may be good to consider using Python or splitting it into
    several scripts.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会很长。我们不能给你一个具体的规则，但当你的代码行数达到数百行时，考虑使用 Python 或将其拆分成多个脚本可能是个好主意。
- en: It interacts with system commands, sometimes a lot. You can consider it an automated
    way of running those commands.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与系统命令进行交互，有时会进行很多交互。你可以将其视为一种自动化运行这些命令的方式。
- en: It doesn’t do a lot of data handling. There are few arrays, strings, and numbers.
    That’s all.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不做大量的数据处理。只有少数的数组、字符串和数字，仅此而已。
- en: It doesn’t do any system calls. Shell scripts are not there for system calls.
    There’s no straightforward way to do it.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不执行任何系统调用。Shell 脚本不是用来做系统调用的，也没有直接的方法来做到这一点。
- en: 'The basic structure of a shell script is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本的基本结构如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line starts with the so-called she-bang. It’s being used to tell
    the system which interpreter (in this case, it’s Bash) to use to run this script.
    In a lot of scripts found online, she-bang looks like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行以所谓的 she-bang 开头。它用于告诉系统使用哪个解释器（在本例中是 Bash）来运行这个脚本。在很多网上的脚本中，she-bang 看起来像这样：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the `env` command has a big advantage and disadvantage at the same time.
    The advantage of using it is that it will use a Bash executable that is first
    in the current user `PATH` environment variable. It all depends on the purpose.
    The `env` command also won’t let you pass any arguments to the interpreter you
    choose.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `env` 命令既有一个很大的优势，也有一个劣势。使用它的优点是它会使用当前用户 `PATH` 环境变量中排在最前面的 Bash 可执行文件。具体取决于目的。`env`
    命令还不允许你传递任何参数给你选择的解释器。
- en: The second line of the preceding script simply displays **Hello world**. It
    uses a built-in command echo that does just that – it displays whatever text you
    put as input.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上面脚本的第二行简单地显示了**Hello world**。它使用了一个内置命令 `echo`，它的作用就是显示你输入的任何文本。
- en: 'Now, to execute this script, we will need to save it to a file. It’s good practice
    to end this file with a `.sh` or `.bash` suffix. There are two ways to execute
    this new script – by invoking the interpreter with a script name or by directly
    executing the script by its name:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要执行这个脚本，我们需要将其保存到一个文件中。最好以 `.sh` 或 `.bash` 后缀来结束这个文件。执行这个新脚本有两种方式——通过调用解释器并传入脚本名，或者直接通过脚本名执行：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To directly execute the script, we will need to change its permissions so that
    it can be executed; otherwise, the system won’t recognize it as something it can
    execute:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接执行脚本，我们需要更改其权限，使其可以被执行；否则，系统将无法识别它为可执行文件：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Similarly, we could easily set Python or any other shell as an interpreter of
    our script.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以轻松地将 Python 或任何其他 Shell 设置为我们脚本的解释器。
- en: For now, let’s focus on Bash and look at some built-in Bash commands that we’re
    going to use.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们聚焦于 Bash，并看一些我们将要使用的 Bash 内置命令。
- en: Understanding Bash built-ins and grammar
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Bash 内置命令和语法
- en: Let’s get back to the fundamentals before we start creating a script. First,
    we will look into the Bash scripting language syntax and its limitations.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建脚本之前，让我们回归基础。首先，我们将探讨 Bash 脚本语言的语法及其局限性。
- en: Built-in commands are commands that are integral to Bash and are the main scripting
    syntax we are going to use. Bash will try to execute any other commands from the
    system it runs on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 内置命令是与 Bash 紧密相关的命令，是我们将要使用的主要脚本语法。Bash 会尝试执行它运行所在系统中的任何其他命令。
- en: Just like any other interpreted language (for example, Python or Ruby), Bash
    has unique syntax and grammar. Let’s look into it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他任何解释型语言（例如 Python 或 Ruby）一样，Bash 有其独特的语法和语法规则。让我们来看看。
- en: 'Bash, similar to other programming languages, interprets files from top to
    bottom and from left to right. Each line usually contains one or more commands.
    You can glue several commands together in one line using a pipe (`|`) or double
    pipe character (`||`), semicolon (`;`), or double ampersands (`&&`). It’s useful
    to remember that double pipes have the same function as logical `OR` and double
    ampersands have the same function as logical `AND`. This way, you can run commands
    in sequence and execute the next command depending on the outcome of the previous
    command, without using more complex conditional statements. This is called a list
    or chain of commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Bash，类似于其他编程语言，从上到下、从左到右解释文件。每行通常包含一个或多个命令。你可以使用管道符号（`|`）或双管道符号（`||`）、分号（`;`）或双和符号（`&&`）将多个命令连接在同一行中。记住，双管道的作用与逻辑`OR`相同，而双和符号的作用与逻辑`AND`相同。这种方式可以让你按顺序运行命令，并根据前一个命令的结果执行下一个命令，而不需要使用更复杂的条件语句。这被称为命令列表或命令链：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding command, you can see an example of using double ampersands.
    Here, `commandB` will only be executed if `commandA` is successfully executed.
    We can chain more commands like this by adding `||` at the end of the chain.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，你可以看到使用双和符号的示例。在这里，`commandB` 只有在 `commandA` 成功执行后才会执行。我们可以通过在命令链的末尾添加`||`来继续连接更多的命令。
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example, on the other hand, shows how to use a double pipe. Here, `commandB`
    will only be executed if `commandA` fails to execute.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这个示例展示了如何使用双管道。在这里，`commandB` 只有在 `commandA` 执行失败时才会执行。
- en: Bash (or any other shell in Linux) determines whether a command failed to execute
    or exited with success by using return codes. Every command needs to exit with
    a positive number – zero (`0`) is a code for success, and any other code is a
    failure. If you chain multiple commands with `AND(&&)` or `OR` `(||)`, the return
    status of the whole line will be determined by the previous command that was executed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Bash（或 Linux 中的任何其他 shell）通过使用返回码来判断一个命令是否执行失败或成功退出。每个命令需要以一个正整数退出——零（`0`）是成功的代码，任何其他代码都是失败的。如果你使用`AND(&&)`或`OR`(`||`)将多个命令连接在一起，则整行的返回状态将由先前执行的命令的返回状态决定。
- en: What about a single ampersand (`&`) after a command? It has an entirely different
    function – it will execute a command it is after in the background and the script
    will continue running without waiting for the command to complete. It’s useful
    for tasks that aren’t required to be completed for other parts of the program,
    or running multiple instances of the same command at the same time, such as running
    a full backup of multiple databases to shorten execution time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么命令后面的单个和符号（`&`）呢？它有一个完全不同的功能——它会在后台执行命令，并且脚本会继续运行，而无需等待命令完成。这对于不需要其他部分程序完成的任务，或者同时运行多个相同命令的实例（例如同时进行多个数据库的完整备份以缩短执行时间）非常有用。
- en: Now that we know how to chain commands, we can jump into another core feature
    of any programming language – variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何连接命令，接下来我们可以了解任何编程语言的另一个核心特性——变量。
- en: Variables
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'In Bash, there are two types of variables: global and local variables. *Global
    variables* are accessible throughout the whole time the script is running unless
    the variable is unset. *Local variables* are accessible only within a block of
    the script (for example, a defined function).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Bash 中，有两种类型的变量：全局变量和局部变量。*全局变量*在脚本运行期间可以访问，除非该变量被取消设置。*局部变量*仅在脚本的某个块中可访问（例如，定义的函数）。
- en: Whenever a script gets executed, it gets an existing set of variables from the
    currently running shell; this is called an *environment*. You can add new variables
    to the environment using the `export` command, and remove variables by using the
    `use unset` command. You can also add functions to the environment by using the
    `declare -``x` command.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每当脚本执行时，它会从当前运行的 shell 中获取一组现有的变量；这被称为*环境*。你可以使用`export`命令将新变量添加到环境中，使用`use
    unset`命令移除变量。你也可以使用`declare -x`命令将函数添加到环境中。
- en: All parameters, regardless of whether they’re local or global, are prefixed
    with a dollar sign (`$`). So, if you have a variable named `CARS` (case-sensitive),
    to refer to it, you will need to write `$CARS` inside your script.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的参数，无论是局部的还是全局的，都以美元符号（`$`）为前缀。所以，如果你有一个名为 `CARS`（区分大小写）的变量，引用它时，需要在脚本中写成`$CARS`。
- en: For variables, single or double quotes (or no quotes) matter. If you put a variable
    in a single quote, it won’t be expanded, and a variable name inside quotes will
    be treated as a literal string. Variables inside double quotes will be expanded,
    and it’s considered a safe way to refer to variables (and concatenate them, or
    glue them together) because if there is a space or other special character in
    a string, it won’t be significant for the script – that is, it won’t be executed.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于变量，单引号或双引号（或没有引号）是重要的。如果你将变量放在单引号中，它将不会被展开，而引号中的变量名将被当作字面字符串处理。双引号中的变量会被展开，并且这被认为是一种安全的引用变量的方式（以及连接它们，或者将它们拼接在一起），因为如果字符串中有空格或其他特殊字符，它们对脚本不会有实际意义
    —— 也就是说，它们不会被执行。
- en: 'Sometimes, you will need to concatenate multiple variables. You can do this
    using curly brackets (`{}`). For example, `"${VAR1}${VAR2}"` will expand to whatever
    you have `VAR1` and `VAR2` set to. In that context, you can also use curly brackets
    to cut or replace parts of the string. Here’s an example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要将多个变量连接起来。你可以使用大括号（`{}`）来完成。例如，`"${VAR1}${VAR2}"` 将扩展为你设置的 `VAR1` 和 `VAR2`
    的值。在这种情况下，你也可以使用大括号来截取或替换字符串的部分。这里有一个例子：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code will display `%` operator will only remove characters from
    the end of the string. If you want to cut variables from the beginning of the
    string, you would use the `#` operator in the same way.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将显示 `%` 操作符只会移除字符串末尾的字符。如果你想从字符串开头截取变量，你可以使用 `#` 操作符，方法相同。
- en: If you refer to a variable without any quotes, space inside the value of the
    variable may break the flow of the script and impede debugging, so we strongly
    suggest using either single or double quotes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在没有引号的情况下引用变量，变量值中的空格可能会破坏脚本的流程并妨碍调试，因此我们强烈建议使用单引号或双引号。
- en: Parameters
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数
- en: There are two kinds of parameters we could use, but both are a special kind
    of variable, so each is prefixed with a dollar sign (`$`).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种类型的参数，但它们都是特殊类型的变量，因此每个变量前都有一个美元符号（`$`）。
- en: The first kind of parameters you need to be aware of are *positional parameters*
    – these are the parameters that are passed to your script or a function inside
    a script. All parameters are indexed starting with `1` until `n`, where `n` is
    the last parameter. You’ll refer to each of these parameters with `$1` until `$n`.
    You’re probably wondering what will happen if you use `$0`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要注意的第一类参数是 *位置参数* —— 这些是传递给脚本或脚本内函数的参数。所有参数从 `1` 开始索引，一直到 `n`，其中 `n` 是最后一个参数。你可以用
    `$1` 到 `$n` 引用每一个参数。你可能会好奇，如果使用 `$0` 会发生什么。
- en: '`$0` contains the name of your script, so it’s useful for generating documentation
    within a script, for example.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`$0` 包含脚本的名称，因此它对于在脚本中生成文档等操作非常有用。'
- en: To refer to all available parameters starting from 1, you can use `$@` (dollar
    sign, at).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用从1开始的所有可用参数，你可以使用 `$@`（美元符号，at符号）。
- en: 'Here are some other special parameters that are commonly used:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他常用的特殊参数：
- en: '`#`: Number of positional parameters'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`#`：位置参数的数量'
- en: '`?`: Exit code of the most recently executed foreground command'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`：最近执行的前台命令的退出代码'
- en: '`$`: Process ID of the shell'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$`：Shell的进程ID'
- en: Loops
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: You are probably familiar with different types of loops as they are in other
    programming languages. You can find all of those in Bash, but with a slightly
    different syntax than you might be familiar with.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉其他编程语言中的不同类型的循环。在 Bash 中也有这些循环，但语法稍有不同。
- en: 'The most basic, a `for loop`, looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的 `for 循环` 看起来像这样：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This variant of the `for` loop sets whatever element inside `other_variable`
    as a value of `variable_name` and executes `some_commands` for every element it
    finds. After it’s completed, it exits the loop with the status of the last executed
    command. The `in other_variable` part can be omitted – in that case, the `for`
    loop executes `some_commands` once for each positional parameter. The use of this
    parameter will look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变种的 `for` 循环将 `other_variable` 中的每个元素设置为 `variable_name` 的值，并为每个找到的元素执行 `some_commands`。执行完成后，它将以最后执行的命令的状态退出循环。`in
    other_variable` 部分是可以省略的 —— 在这种情况下，`for` 循环会为每个位置参数执行一次 `some_commands`。使用该参数的示例如下：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding `for` loop will run as many times as you added input variables
    for your function (or script in this case). You can refer to all positional parameters
    with `$@`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `for` 循环将根据你为函数（或此情况下的脚本）添加的输入变量执行多次。你可以使用 `$@` 引用所有位置参数。
- en: 'The following is a for loop in a form known from C/C++:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个C/C++风格的`for`循环：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s an example use of this syntax:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是此语法的一个示例：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first expression sets the `i` variable to `1`, the second expression is
    a condition to be met for the loop to still run, and the final expression is incrementing
    the `i` variable by 1\. Each loop run will display the next value set to the `i`
    variable.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式将`i`变量设置为`1`，第二个表达式是循环继续运行的条件，最后一个表达式将`i`变量的值增加1。每次循环运行时，会显示分配给`i`变量的下一个值。
- en: 'The output of this command will look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出将如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another useful loop is a `while loop`, which runs as many times as needed until
    the condition is met (the command we pass to it exits with a success – it returns
    zero). Its counterpart is a loop called `until`, which will keep running so long
    as the command we pass to it returns a non-zero status:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的循环是`while`循环，它会根据需要运行多次，直到满足条件（传递给它的命令成功退出——返回零）。与之对应的是`until`循环，它会一直运行，直到传递给它的命令返回非零状态：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can create an infinite loop by using a command that will always meet the
    condition, so for the `while` loop, it can be simply `true`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用始终满足条件的命令来创建一个无限循环，对于`while`循环，条件可以简单地设为`true`。
- en: The most commonly used blocks of commands are conditionals and are used with
    `if` statements. Let’s take a closer look.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的命令块是条件语句，它们与`if`语句一起使用。让我们仔细看看。
- en: Conditional execution – if statement
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件执行——`if`语句
- en: 'The if statement has the following syntax:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句的语法如下：'
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`test_command` can be any command you can think of, but commonly, the test
    is wrapped between double or single square brackets. The difference between these
    two is the former is a system command called `test` (you can check its syntax
    by executing `man test`), while the latter is a Bash built-in and more powerful
    test.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_command` 可以是你能想到的任何命令，但通常，测试是用双方括号或单方括号包围的。这两者之间的区别是前者是一个系统命令，叫做`test`（你可以通过执行`man
    test`来查看它的语法），而后者是Bash的内建命令，功能更强大。'
- en: 'The rule of thumb for putting variables between square brackets is using double
    quotes, so if a variable contains spaces, it won’t change the intention of our
    test:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 放置变量在方括号中的经验法则是使用双引号，这样即使变量包含空格，也不会改变我们的测试意图：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `-z` test checks whether the `$SOME_VAR` variable is empty. It evaluates
    to `true` if the variable is empty and `false` if not.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`-z` 测试检查`$SOME_VAR`变量是否为空。如果变量为空，评估为`true`，否则为`false`。'
- en: 'The following are other commonly used tests:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其他常用的测试：
- en: '`-a`: Logical AND'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`：逻辑“与”'
- en: '`-o`: Logical OR'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o`：逻辑“或”'
- en: '`-eq`: Is equal to'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-eq`：等于'
- en: '`-ne`: Is not equal to'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ne`：不等于'
- en: '`-gt or >`: Is greater than'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-gt 或 >`：大于'
- en: '`-ge or >=`: Is greater than or equal to'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ge 或 >=`：大于或等于'
- en: '`-lt or <`: Is less than'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lt 或 <`：小于'
- en: '`-le or <=`: Is less than or equal to'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-le 或 <=`：小于或等于'
- en: '`= or ==`: Is equal to'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`= 或 ==`：等于'
- en: '`!=`: Is not equal to'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=`：不等于'
- en: '`-z`: String is null (its length is zero characters)'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-z`：字符串为空（其长度为零字符）'
- en: '`-n`: String is not null'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`：字符串不为空'
- en: '`-e`: File exists (directory, symlink, device file, or any other file in the
    filesystem)'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`：文件存在（目录、符号链接、设备文件或文件系统中的任何其他文件）'
- en: '`-f`: File is a regular file (not a directory or device file)'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：文件是常规文件（不是目录或设备文件）'
- en: '`-d`: File is a directory'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：文件是目录'
- en: '`-h` or `-L`: File is a symbolic link'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h` 或 `-L`：文件是符号链接'
- en: '`-r`: File has read permission (for the user running the test)'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`：文件具有读取权限（对于执行测试的用户）'
- en: '`-w`: File has write permission (for the user running the test)'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`：文件具有写权限（对于执行测试的用户）'
- en: '`-x`: File can be executed by the user that executed the script'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`：文件可以被执行脚本的用户执行'
- en: Note that tests may behave differently when using a system test (single square
    brackets, `[...]`) rather than the built-in one (double square brackets, `[[...]]`).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用系统测试（单方括号，`[...]`）时，测试可能与内建测试（双方括号，`[[...]]`）行为不同。
- en: The double equal comparison operator, while comparing strings when using globbing,
    will match the pattern or literal string, depending on whether you’ve quoted the
    pattern or not.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 双等号比较运算符，在使用通配符匹配字符串时，将根据你是否对模式加引号来匹配模式或字面字符串。
- en: 'The following is an example of pattern matching if the string starts with `w`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个模式匹配的例子，假设字符串以`w`开头：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When using a system test (a single square bracket) instead of a built-in one,
    the test will try to find whether the `$` variable matches any of the filenames
    in the local directory (including those with spaces). This can lead to some unpredictable
    outcomes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用系统测试（单个方括号）而不是内置测试时，测试将尝试查找`$`变量是否与本地目录中的任何文件名匹配（包括带有空格的文件）。这可能会导致一些不可预测的结果。
- en: 'The following is an example of pattern matching if the string is `w*`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模式匹配的示例，如果字符串为`w*`：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Equipped with this knowledge, we’re ready to start creating and running scripts.
    So, let’s jump right to it!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些知识后，我们已经准备好开始创建和运行脚本了。让我们直接开始吧！
- en: Understanding the backup script – first steps
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解备份脚本 – 第一步
- en: 'Now that we know what a script can look like, we can start writing one. You
    can use your favorite console editor or IDE to do this. Let’s create an empty
    file named `run_backups.sh` and change its permissions so that they’re executable:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道脚本的样子了，就可以开始编写脚本了。你可以使用你喜欢的控制台编辑器或IDE来做这件事。让我们创建一个名为`run_backups.sh`的空文件，并更改其权限，使其可执行：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s an empty file, so we’ll need to add a basic database backup command and
    proceed from there. We won’t be covering granting this script access to a database.
    We will be backing up a PostgreSQL database and using the `pg_dump` tool for that
    purpose.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个空文件，因此我们需要添加一个基本的数据库备份命令，并从那里继续。我们不会讨论如何授予该脚本访问数据库的权限。我们将备份一个 PostgreSQL
    数据库，并使用`pg_dump`工具来实现。
- en: 'Let’s input a shebang line and a `pg_dump` command call in our base script:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在基本脚本中输入一个 shebang 行并调用`pg_dump`命令：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To execute this script, we’ll need to start the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此脚本，我们需要启动以下命令：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The dot and slash indicate that we want to execute something that is located
    in a current directory, and its name is `run_backups.sh`. Without the initial
    dot-slash pair, the shell we’re running on (here, `bash`) would look into the
    `PATH` environment variable and would try to find our script in one of the directories
    listed there:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 点号和斜杠表示我们要执行当前目录中的某个文件，文件名为`run_backups.sh`。如果没有最初的点斜杠对，当前运行的 shell（这里是`bash`）将查找`PATH`环境变量，并尝试在其中列出的目录中查找我们的脚本：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, it’s a list of directories delimited with a colon.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这是一个由冒号分隔的目录列表。
- en: 'Now, let’s see what our Bash script does when executed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看执行时我们的 Bash 脚本做了什么：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Unless you already have `pg_dump` installed on your system, you will see this
    error. It means that Bash didn’t find the command we intended to run. It also
    displays the line where the error occurred. Also, an empty `mydatabase.sql` file
    was created.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你系统中已安装`pg_dump`，否则你将看到此错误。这意味着 Bash 没有找到我们打算运行的命令。它还会显示错误发生的行。此外，一个空的`mydatabase.sql`文件被创建了。
- en: 'Normally, we would proceed with creating a Docker image with all the tools
    we need, and a second one with a PostgreSQL database running. But since this will
    be covered in [*Chapter 8*](B18197_08.xhtml#_idTextAnchor166), let’s just proceed
    and install everything we need on a local machine. Assuming you’re on an Ubuntu
    or a Debian Linux machine, you want to run the following commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会创建一个包含所有所需工具的 Docker 镜像，另一个镜像运行 PostgreSQL 数据库。但由于这一部分将在[*第8章*](B18197_08.xhtml#_idTextAnchor166)中讲解，我们就直接继续安装所有所需的软件包到本地机器上吧。假设你使用的是
    Ubuntu 或 Debian Linux 系统，你可以运行以下命令：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After user confirmation, the database will be installed, configured, and started
    in the background. We’ve cut the further output for readability.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 经用户确认后，数据库将被安装、配置，并在后台启动。为了可读性，我们已经截断了后续输出。
- en: After installation, you might need an additional configuration change for the
    database so that you can connect to the database with another tool called `psql`,
    which is a console command that’s useful for connecting to PostgreSQL. In the
    `/etc/postgresql/14/main/pg_hba.conf` file, we have defined trust relationships
    and who can connect to the database using multiple mechanisms.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，可能还需要对数据库做一些额外的配置更改，以便你能够使用另一个名为`psql`的工具连接到数据库。`psql`是一个用于连接 PostgreSQL
    的控制台命令。在`/etc/postgresql/14/main/pg_hba.conf`文件中，我们定义了信任关系以及谁可以使用多种机制连接到数据库。
- en: 'Find the following line:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 查找以下行：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Change it to the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After making this modification, you can restart the database with the following
    command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 做出此修改后，你可以使用以下命令重启数据库：
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, you should be able to log in to the database and list all available databases:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够登录到数据库并列出所有可用的数据库：
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After logging in, we list all available databases with `\l` (backslash, lowercase
    L) and quit the `psql` shell with `\q` (backslash, lowercase Q). Once this is
    set, we can get back to our script and try to run it again:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，我们使用 `\l`（反斜杠，小写 L）列出所有可用的数据库，并使用 `\q`（反斜杠，小写 Q）退出 `psql` shell。一旦设置完成，我们可以回到脚本并再次尝试运行它：
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'There’s no root role in PostgreSQL, which is an expected error at this point.
    We will need to use a different role to connect to the database. The default is
    `postgres` and the option to pass to `pg_dump` is `-U`, the same as what we used
    with `psql`. After updating it, our script will look like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 中没有 root 角色，这是此时预期的错误。我们需要使用不同的角色连接到数据库。默认角色是 `postgres`，传递给 `pg_dump`
    的选项是 `-U`，这与我们在 `psql` 中使用的相同。更新后，我们的脚本将如下所示：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final step is to create a database and some actual data so that the output
    `sql` file won’t be empty. The following script will create a database named `mydatabase`
    and create two tables that contain random data:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建一个数据库并生成一些实际数据，以确保输出的 `sql` 文件不会为空。以下脚本将创建一个名为 `mydatabase` 的数据库，并创建两个包含随机数据的表：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `CREATE DATABASE` line is creating a database named `mydatabase`. The second
    line indicates we’re connecting to this new database. Two additional lines starting
    with `CREATE TABLE` are both creating tables and filling them with data using
    built-in PostgreSQL functions. Let’s break it down into two distinct queries –
    `SELECT` and `CREATE`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE DATABASE` 这一行正在创建一个名为 `mydatabase` 的数据库。第二行表示我们正在连接到这个新数据库。接下来的两行以
    `CREATE TABLE` 开头，分别创建表并使用内置的 PostgreSQL 函数填充数据。让我们将其分解为两个独立的查询——`SELECT` 和 `CREATE`：'
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'There are a few things going on here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了几件事：
- en: The `generate_series()` function is creating a series of integers starting from
    1 up to 100,000 – this will generate all our records in a table
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generate_series()` 函数正在创建一个从 1 到 100,000 的整数序列——这将生成表中的所有记录'
- en: The `data_series` keyword, just before a semicolon, names output from the `generate_series()`
    function, so it’s an actual field name in a table we intend to create
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data_series` 关键字位于分号之前，命名了来自 `generate_series()` 函数的输出，因此它是我们打算创建的表中的实际字段名。'
- en: The `random()` function is generating a value between 0 and 1 – that is, greater
    than or equal to 0 and less than 1
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random()` 函数生成一个介于 0 和 1 之间的值——即大于或等于 0 小于 1'
- en: The `::text` after the `random()` function is converting output from this function
    into text
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`random()` 函数后的 `::text` 将此函数的输出转换为文本格式'
- en: The `md5()` function is taking the output from `random()::text` and hashing
    it with an `md5` algorithm, ensuring that we have a unique string and run as many
    times as the `generate_series()` function’s output amount will be (here, this
    is from 1 to 100,000)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`md5()` 函数将 `random()::text` 的输出进行哈希处理，使用 `md5` 算法，确保我们获得一个唯一的字符串，并运行的次数与 `generate_series()`
    函数的输出数量一致（这里是从 1 到 100,000）'
- en: Finally, `SELECT data_series, md5()` is producing a table with two fields (`data_series`
    and `md5`) with data generated by both functions
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`SELECT data_series, md5()` 正在生成一个包含两列（`data_series` 和 `md5`）的表，这两列的数据由两个函数生成
- en: Now, getting back to `CREATE TABLE`, there’s a part called `another_random AS`
    – this will get the output from `SELECT` and create a table for us.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 `CREATE TABLE`，有一部分叫做 `another_random AS` —— 这将从 `SELECT` 获取输出，并为我们创建一个表。
- en: 'With this knowledge, we can create a `sql` script and execute it using `psql`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，我们可以创建一个 `sql` 脚本并使用 `psql` 执行它：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To check whether we’ve created something and investigate the data we’ve created,
    again, we will need to use `psql` and the `SELECT` query on our new database:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们是否创建了某些内容并查看我们创建的数据，我们再次需要使用 `psql` 和对新数据库的 `SELECT` 查询：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`--More–` at the end of the preceding output indicates there are more records
    to be shown. You can see more data by pressing the spacebar or quit by pressing
    *Q* on your keyboard.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出末尾的 `--More--` 表示还有更多记录要显示。你可以按空格键查看更多数据，或按 *Q* 键退出。
- en: 'Once you have created a database and filled it with some data, you can try
    to run our backup script again:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个数据库并填充了一些数据，你可以尝试再次运行我们的备份脚本：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There are no errors, so we have probably created a full database dump with
    success:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 没有错误，所以我们可能已经成功创建了完整的数据库转储：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output file isn’t empty; let’s see what’s inside:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件不是空的；让我们看看里面有什么：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: After some `SET` statements, you should also find `CREATE TABLE` and `INSERT`
    statements. I haven’t provided full output here as it would take up a lot of space.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些 `SET` 语句之后，你还应该找到 `CREATE TABLE` 和 `INSERT` 语句。由于输出内容较多，我没有提供完整的输出。
- en: In this section, we learned how to set up a testing environment for our script
    and made it possible for our script to create a database dump. In the next section,
    we’ll focus more on error handling and checking whether the backup was successful.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何为脚本设置测试环境，并使得脚本能够创建数据库转储。在下一节中，我们将更多地关注错误处理，检查备份是否成功。
- en: Handling errors and debugging
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理和调试
- en: 'While running our backup script, we can encounter several errors: access to
    the database might be blocked, the `pg_dump` process might get killed, we may
    be out of disk space, or any other error preventing us from completing a full
    database dump.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行备份脚本时，我们可能会遇到几种错误：数据库访问可能被阻止，`pg_dump` 进程可能被杀死，磁盘空间可能不足，或者任何其他错误导致我们无法完成完整的数据库转储。
- en: In any of those cases, we will need to catch the error and handle it gracefully.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何这些情况下，我们需要捕获错误并优雅地处理它。
- en: Additionally, we might want to refactor the script to make it configurable,
    make use of functions, and debug the script. Debugging will prove very useful,
    especially when dealing with larger scripts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可能需要重构脚本，使其具有配置功能，使用函数，并进行调试。调试将非常有用，特别是在处理较大的脚本时。
- en: 'Let’s dive right into it and start with adding a function:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解并开始添加一个函数：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We’ve added a `run_dump` function that takes one argument and sets a local variable
    called `database_name` with the content of this argument. It then uses this local
    variable to pass options to the `pg_dump` command.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 `run_dump` 函数，它接受一个参数，并将该参数的内容设置为一个名为 `database_name` 的局部变量。然后它使用这个局部变量将选项传递给
    `pg_dump` 命令。
- en: 'This will immediately allow us to back up multiple databases by using a for
    loop, like so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将立即允许我们通过使用 `for` 循环来备份多个数据库，代码如下：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This loop will create a full dump of the databases: `mydatabase`, `mydatabase2`,
    and `mydatabase3`. Backups will be done one by one using this function. We can
    now put a list of the databases in a variable to make it more configurable. The
    current script will look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将创建数据库 `mydatabase`、`mydatabase2` 和 `mydatabase3` 的完整转储。备份将逐个完成，通过此函数。我们现在可以将数据库列表放入变量中，以使其更具配置性。当前脚本将如下所示：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, this backup script is becoming more complicated. We need to note a few
    things that will be happening now:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个备份脚本变得更加复杂。我们需要注意接下来会发生的一些事情：
- en: If any of the backups should fail, the script will continue running
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何备份失败，脚本将继续运行
- en: If the backups fail due to `pg_dump` not having access to the database, we will
    overwrite our previous database dump
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果备份由于 `pg_dump` 无法访问数据库而失败，我们将覆盖之前的数据库转储
- en: We will be overwriting the dump file on every run
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在每次运行时覆盖转储文件
- en: 'Several default settings are considered to be good practice to override in
    a script. One that would mitigate the first problem we’ve pointed out is aborting
    running when any command returns a value that’s different than zero (or `true`).
    This means the command finished running with an error. The option’s name is `errexit`
    and can we override it with the `set` command, a Bash built-in command. We could
    do this in two ways:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，几项默认设置被认为是良好的实践需要覆盖。我们提到的第一个问题可以通过在任何命令返回一个与零（或 `true`）不同的值时终止运行来减轻。这意味着该命令执行时出现了错误。此选项名为
    `errexit`，我们可以通过 `set` 命令覆盖它，`set` 是 Bash 内建命令。我们可以通过两种方式来实现这一点：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here are some other options we recommend using:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们推荐使用的一些其他选项：
- en: '`set -u`: This treats any unset variable we try to use in a script as an error'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set -u`：这将把我们在脚本中尝试使用的任何未设置的变量视为错误'
- en: '`set -o pipefail`: When using chaining commands with a pipe, the exit status
    of this pipeline will be the status of the last command that finished with a non-zero
    status or zero (a success) if all commands exit successfully'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set -o pipefail`：当使用管道链式命令时，这个管道的退出状态将是最后一个命令的状态，如果该命令以非零状态结束，或者如果所有命令都成功执行（即退出状态为零），则为零（成功）。'
- en: '`set -C` or `set -o noclobber`: If set, Bash won’t overwrite any existing file
    with the redirection commands (for example, `>`, which we’re using in our script)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set -C` 或 `set -o noclobber`：如果启用，Bash 将不会使用重定向命令（例如我们在脚本中使用的 `>`）覆盖任何现有文件'
- en: An additional option that is extremely useful is `set -x` or `set -o xtrace`,
    which causes Bash to print every command before executing said command.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常有用的附加选项是 `set -x` 或 `set -o xtrace`，它使得 Bash 在执行每个命令之前打印该命令。
- en: 'Let’s see how it works for a simple Bash script:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单 Bash 脚本的工作原理：
- en: '[PRE40]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here’s the output of executing this script:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行该脚本后的输出：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s update our backup script with the recommended Bash settings:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用推荐的 Bash 设置更新我们的备份脚本：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let’s get back to the console to test whether it’s still working as we
    expect:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到控制台测试它是否仍然按预期工作：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We’ve enabled the `noclobber` option and it has prevented us from overwriting
    previously made backups. We’ll need to rename or delete the old file before we
    can proceed. This time, let’s also enable the `xtrace` option to see what command
    script is being executed:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已启用 `noclobber` 选项，它已防止我们覆盖先前创建的备份。我们需要重命名或删除旧文件才能继续。现在，我们还将启用 `xtrace` 选项，以查看正在执行的命令脚本：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To mitigate the overwrite existing file error, we could do one of three things:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免覆盖现有文件错误，我们可以采取以下三种方法之一：
- en: Delete the previous file before attempting to run the backup, which would destroy
    the previous backup.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在尝试运行备份之前删除旧文件，这将销毁以前的备份。
- en: Rename the previous backup file and add a current date suffix.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名上一个备份文件并添加当前日期后缀。
- en: Make sure that every time we run a script, the dump file has a different name,
    such as a current date. This would ensure we are keeping previous backups in case
    we need to get back to a version that’s earlier than the last full backup.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每次运行脚本时，转储文件都有一个不同的名称，例如当前日期。这将确保我们保留以前的备份，以防需要恢复到比上次完整备份更早的版本。
- en: 'In this case, the most common solution would be the final one we’ve proposed
    – generate a different backup file name every time the backup runs. First, let’s
    try to get a timestamp with the local date and time in the `YYYYMMDD_HHMM` format,
    where we have the following options:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，最常见的解决方案是我们提出的最后一个——每次备份运行时生成不同的备份文件名。首先，让我们尝试获取一个带有本地日期和时间的时间戳，格式为 `YYYYMMDD_HHMM`，我们有以下选项：
- en: '`YYYY`: The current year in a four-digit format'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YYYY`：当前年份的四位数字格式'
- en: '`MM`: The current month in a two-digit format'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MM`：当前月份的两位数字格式'
- en: '`DD`: The day of the month in a two-digit format'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DD`：两位数格式的日期'
- en: '`HH`: The current hour'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HH`：当前小时'
- en: '`MM`: The current minute'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MM`：当前分钟'
- en: 'We can achieve this by using the `date` command. By default, it will return
    the current date, day of the week, and the time zone:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`date`命令来实现这一点。默认情况下，它将返回当前的日期、星期几和时区：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: To change the default output of this command, we’ll need to pass a date format
    string using formatting characters.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更改该命令的默认输出，我们需要使用格式字符传递一个日期格式字符串。
- en: 'The most common formatting characters for the `date` command are as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`date` 命令的最常见格式字符如下：'
- en: '`%Y`: Year (for example, 2022)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%Y`：年份（例如，2022）'
- en: '`%m`: Month (01-12)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%m`：月份（01-12）'
- en: '`%B`: Long month name (for example, January)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%B`：长月份名称（例如，January）'
- en: '`%b`: Short month name (for example, Jan)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%b`：短月份名称（例如，Jan）'
- en: '`%d`: Day of month (for example, 01-31, depending on how many days are in a
    certain month)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%d`：日期（例如，01-31，取决于某个月的天数）'
- en: '`%j`: Day of year (for example, 001-366)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%j`：年份中的天数（例如，001-366）'
- en: '`%u`: Day of week (1-7)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%u`：星期几（1-7）'
- en: '`%A`: Full weekday name (for example, Friday)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%A`：完整的星期几名称（例如，Friday）'
- en: '`%a`: Short weekday name (for example, Fri)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%a`：短星期几名称（例如，Fri）'
- en: '`%H`: Hour (00-23)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%H`：小时（00-23）'
- en: '`%I`: Hour (01-12)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%I`：小时（01-12）'
- en: '`%M`: Minute (00-59)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%M`：分钟（00-59）'
- en: '`%S`: Second (00-59)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%S`：秒（00-59）'
- en: '`%D`: Display date as mm/dd/yy'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%D`：以 mm/dd/yy 格式显示日期'
- en: 'To format the date in a format we want, we’ll need to use formatting characters,
    `%Y%m%d_%H%M`, and pass it to the `date` command for interpretation:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照我们希望的格式格式化日期，我们需要使用格式字符 `%Y%m%d_%H%M`，并将其传递给 `date` 命令进行解释：
- en: '[PRE46]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To pass the output string to a variable in our script, we’ll need to run the
    date in a subshell (a Bash process executed by our Bash script):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将输出字符串传递给脚本中的变量，我们需要在子 shell 中运行 `date`（由我们的 Bash 脚本执行的 Bash 进程）：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let’s put it inside our script and use a `timestamp` variable to generate an
    output filename:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其放入脚本中，并使用`timestamp`变量来生成输出文件名：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you have spotted curly braces between variables in a `pg_dump` line, you’re
    probably wondering why we need them. We use curly braces to make sure that the
    variable name will be correct when we expand a variable to a string. In our case,
    we’re preventing Bash from trying to search for a variable name, `$database_name_`,
    that doesn’t exist.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`pg_dump`命令行中看到变量之间有大括号，可能会想知道为什么我们需要它们。我们使用大括号确保变量名称在扩展为字符串时是正确的。在我们的案例中，我们防止了Bash尝试搜索一个不存在的变量名`$database_name_`。
- en: Now, each time we run our backup script, it will try to create a new file with
    the current date and time of the backup start time. If we’re running this script
    every day, the number of files will increase over time and will eventually fill
    our disk space. So, we’ll also need our script to remove old backups – say, 14
    days and older.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次运行备份脚本时，它都会尝试创建一个带有当前日期和备份开始时间的文件。如果我们每天运行这个脚本，文件数量会随时间增加，最终填满我们的磁盘空间。所以，我们还需要让脚本删除旧备份——比如，删除14天及以上的备份。
- en: 'We can achieve this by using the `find` command. Let’s find all files beginning
    with a database name, followed by an underscore, and ending with`.sql` that are
    older than 14 days:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`find`命令来实现这一点。让我们找到所有以数据库名开头，后跟下划线，且以`.sql`结尾的文件，这些文件的修改时间超过14天：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `find` command has a peculiar syntax that is a bit different than other
    command-line tools have, so let’s describe what each option means:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`命令有一种独特的语法，与其他命令行工具略有不同，所以我们来描述一下每个选项的含义：'
- en: '`.` (a dot): This is a directory where we want to search for our files. Dot
    means *a* *current directory*.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.`（一个点）：这是我们希望搜索文件的目录。点代表*当前目录*。'
- en: '`-name`: This option can take a full string or wildcards such as `*` or `?`
    and it’s looking for filenames in this case. It’s case-sensitive. If we’re not
    certain that the file or directory we’re looking for is uppercase or lowercase,
    we could use the `-iname` option instead.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-name`：此选项可以接受完整字符串或通配符，如`*`或`?`，用于查找文件名。它是区分大小写的。如果我们不确定正在查找的文件或目录是大写还是小写，可以使用`-iname`选项代替。'
- en: '`-type f`: This indicates we’re looking for a regular file. Other options are
    as follows:'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-type f`：这表示我们在寻找一个常规文件。其他选项如下：'
- en: '`d`: Directory'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：目录'
- en: '`l`: Symbolic link'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`l`：符号链接'
- en: '`s`: A socket file'
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：套接字文件'
- en: '`p`: FIFO file'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p`：FIFO文件'
- en: '`b`: Block device'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：块设备'
- en: '`c`: A character device'
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：字符设备'
- en: '`-mtime +14`: The modification time of this file should be older than 14 days.
    This option can also take other units (seconds, - `s`, weeks, - `w`, hours, -
    `h`, and days, - `d` – it’s the default if no unit is given).'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-mtime +14`：此文件的修改时间应早于14天。此选项还可以接受其他单位（秒，`s`；周，`w`；小时，`h`；天，`d`——如果未提供单位，则默认为天）。'
- en: 'To delete found files, we have at least two options: the `-delete` option or
    the `rm` command via an `-exec find` option. Let’s see how this looks in both
    cases:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除找到的文件，我们至少有两种选择：使用`-delete`选项或通过`-exec find`选项使用`rm`命令。让我们看看在这两种情况下的表现：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this case, a safer choice would be to use `-execdir` instead of `-exec`.
    The difference is subtle but important: `-` `exec` will not be executed in the
    same directory where the found file is located, but `-execdir` will, which makes
    it a safer option in edge cases.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，更安全的选择是使用`-execdir`而不是`-exec`。它们的区别微妙但重要：`-exec`不会在找到的文件所在的同一目录中执行，而`-execdir`会，这使得它在边缘情况下更安全。
- en: 'Let’s deconstruct what we have after the `-``exec` option:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解析一下`-exec`选项之后的内容：
- en: '`rm`: This is a CLI tool for removing files or directories.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`：这是一个CLI工具，用于删除文件或目录。'
- en: '`--` (double dash): This indicates that it will take arguments from `stdin`,
    or the output of the `find` command.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--`（双破折号）：这表示将从`stdin`获取参数，或`find`命令的输出。'
- en: '`{}`: This will substitute for a filename we’ve found.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{}`：这将替代我们找到的文件名。'
- en: '`\;` (backslash, semicolon): This will take multiple commands to be executed
    by `-exec`. A backslash is an escape character that prevents this semicolon from
    being interpreted as a separator for the next command. The `find` utility uses
    `;` or `+` to terminate the shell commands, so we could note it as `";"`, `\+`,
    or `+` (without quotes).'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\;`（反斜杠，分号）：这将允许多个命令由`-exec`执行。反斜杠是一个转义字符，可以防止该分号被解释为下一个命令的分隔符。`find`工具使用`;`或`+`来终止Shell命令，因此我们可以将其标记为`";"`、`\+`或`+`（不带引号）。'
- en: The `-delete` option is good for removing files, but it always returns `true`,
    so it will fail silently if, for example, our script doesn’t have permission to
    remove any files. It’s relatively safe to use it in our script, so we’ll go ahead
    with it.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-delete`选项用于删除文件，但它总是返回`true`，因此如果例如我们的脚本没有删除文件的权限，它会悄无声息地失败。在我们的脚本中使用它相对安全，所以我们会继续使用它。'
- en: 'Now, let’s embed this into our script and see the final iteration of it:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这个嵌入到我们的脚本中，看看它的最终版本：
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, we’ve added a function called `cleanup_old_backups` that will run before
    creating a new dump to free some space for fresh files. We’re calling this function
    inside a for loop just before `run_dump`. This script can be run automatically
    by a `cron daemon` or `systemd cron` service; we’ll cover this in more detail
    in [*Chapter 5*](B18197_05.xhtml#_idTextAnchor083), *Managing Services* *in Linux*.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个名为`cleanup_old_backups`的函数，它会在创建新转储之前运行，以释放一些空间来存放新的文件。我们在`run_dump`之前的for循环中调用了这个函数。这个脚本可以通过`cron守护进程`或`systemd
    cron`服务自动运行；我们将在[*第5章*](B18197_05.xhtml#_idTextAnchor083)，*在Linux中管理服务*中更详细地讨论这一点。
- en: In this section, we learned about the recommended options to enable in shell
    scripts and how to enable debugging options. We know now how to create functions
    and loops. Additionally, we partially touched on PostgreSQL and how to create
    a testing database.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了在Shell脚本中建议启用的选项以及如何启用调试选项。我们现在知道如何创建函数和循环。此外，我们也部分了解了PostgreSQL以及如何创建测试数据库。
- en: The next chapter will take us deeper into various Linux services and how to
    manage them using `init` and `systemd`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将带领我们深入了解各种Linux服务，以及如何使用`init`和`systemd`来管理它们。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Shell scripting is a very common way of automating periodically running tasks
    in a Linux system. Sometimes, it evolves to a bigger system chained together with
    multiple Bash scripts and Python programs to complete complex tasks using multiple
    smaller tasks that do one thing at the same time in a very reliable way.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: Shell脚本是一种在Linux系统中自动化定期执行任务的常见方式。有时，它会演变成一个更大的系统，通过多个Bash脚本和Python程序连接起来，完成复杂任务，同时利用多个小任务以非常可靠的方式同时做一件事。
- en: In modern systems, you will probably see as much Bash as Python scripts.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代系统中，你可能会看到和Bash一样多的Python脚本。
- en: In this chapter, we learned how to create an executable script, as well as how
    to create a simple backup script that handles errors and generates a new filename
    on each run. We also added a function that removes old backups so that we can
    avoid filling the disk space. Additionally, as a side effect, we learned how to
    create a new PostgreSQL database and allow access to it from a local system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们学习了如何创建可执行脚本，并且如何创建一个简单的备份脚本，处理错误并在每次运行时生成一个新的文件名。我们还添加了一个函数来删除旧的备份，以避免填满磁盘空间。此外，作为附带效果，我们学习了如何创建一个新的PostgreSQL数据库，并允许本地系统访问它。
- en: In the next chapter, we’ll learn how to create Linux services and how to manage
    them.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习如何创建Linux服务以及如何管理它们。
- en: Exercises
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Try out the following exercises to test your knowledge of this chapter:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试以下练习，以测试你对本章内容的理解：
- en: Write a function that will list all databases and feed that list to the for
    loop we’ve created.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，列出所有数据库，并将该列表传递给我们创建的for循环。
- en: Change a date timestamp into another format of your choosing.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将日期时间戳转换为您选择的另一种格式。
- en: Catch any errors the `find` function could return (for example, it couldn’t
    delete a file).
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 捕捉`find`函数可能返回的任何错误（例如，它无法删除文件）。
- en: 'Part 2: Your Day-to-Day DevOps Tools'
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2部分：日常DevOps工具
- en: In this second part, we will learn about Linux internals. Starting with managing
    services and networking, we will then move on to look at the most common tools,
    such as Git and Docker.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分中，我们将学习Linux内部机制。从管理服务和网络开始，我们将继续了解最常见的工具，如Git和Docker。
- en: 'This part has the following chapters:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B18197_05.xhtml#_idTextAnchor083), *Managing Services in Linux*'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第5章*](B18197_05.xhtml#_idTextAnchor083)，*在Linux中管理服务*'
- en: '[*Chapter 6*](B18197_06.xhtml#_idTextAnchor098), *Networking in Linux*'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第6章*](B18197_06.xhtml#_idTextAnchor098)，*Linux中的网络*'
- en: '[*Chapter 7*](B18197_07.xhtml#_idTextAnchor147), *Git, Your Doorway to DevOps*'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第7章*](B18197_07.xhtml#_idTextAnchor147)，*Git，通向DevOps的大门*'
- en: '[*Chapter 8*](B18197_08.xhtml#_idTextAnchor166), *Docker Basics*'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第8章*](B18197_08.xhtml#_idTextAnchor166)，*Docker基础*'
- en: '[*Chapter 9*](B18197_09.xhtml#_idTextAnchor245), *A Deep Dive into Docker*'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B18197_09.xhtml#_idTextAnchor245)，*深入探讨Docker*'
