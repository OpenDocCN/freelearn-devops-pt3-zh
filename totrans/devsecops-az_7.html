<html><head></head><body>
		<div id="_idContainer276">
			<h1 id="_idParaDest-139" class="chapter-number"><a id="_idTextAnchor145"/><st c="0">7</st></h1>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor146"/><st c="2">Implementing Security in the Test and Release Phases of DevOps</st></h1>
			<p><st c="64">The goal of the </st><strong class="bold"><st c="81">test</st></strong><st c="85"> phase is to </st><a id="_idIndexMarker687"/><st c="98">make sure the compiled application provides the expected functionalities and does not contain any bugs that were not detected in the </st><a id="_idIndexMarker688"/><st c="231">build phase. </st><st c="244">The goal of the </st><strong class="bold"><st c="260">release</st></strong><st c="267"> phase is to prepare and deliver the tested application for deployment to production or other target environments. </st><st c="382">Depending on a project’s release strategy, the test and release phases often overlap. </st><st c="468">It is common to release software into a pre-production environment for automated runtime testing, using tools such as Selenium, before releasing it to production. </st><st c="631">In this chapter, we will cover DevSecOps practices to secure and integrate security into these phases. </st><st c="734">By the end of this chapter, you will understand these key </st><span class="No-Break"><st c="792">security practices:</st></span></p>
			<ul>
				<li><st c="811">Ensuring that release artifacts are built from </st><span class="No-Break"><st c="859">protected branches</st></span></li>
				<li><st c="877">Implementing a code </st><span class="No-Break"><st c="898">review process</st></span></li>
				<li><st c="912">Selecting a secure </st><span class="No-Break"><st c="932">artifact source</st></span></li>
				<li><st c="947">Implementing a process to validate </st><span class="No-Break"><st c="983">artifact integrity</st></span></li>
				<li><st c="1001">Managing secrets securely in the </st><span class="No-Break"><st c="1035">release phase</st></span></li>
				<li><st c="1048">Validating and enforcing runtime security with </st><span class="No-Break"><st c="1096">release gates</st></span></li>
			</ul>
			<p><st c="1109">Let’s </st><span class="No-Break"><st c="1116">get started!</st></span></p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor147"/><st c="1128">Technical requirements</st></h1>
			<p><st c="1151">To follow along with the instructions in this chapter, you will need </st><span class="No-Break"><st c="1221">the following:</st></span></p>
			<ul>
				<li><st c="1235">A PC with </st><span class="No-Break"><st c="1246">internet connection</st></span></li>
				<li><st c="1265">An active </st><span class="No-Break"><st c="1276">Azure subscription</st></span></li>
				<li><st c="1294">An Azure </st><span class="No-Break"><st c="1304">DevOps organization</st></span></li>
				<li><st c="1323">A GitHub </st><span class="No-Break"><st c="1333">Enterprise organization</st></span></li>
			</ul>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor148"/><st c="1356">Understanding the continuous deployment phase of DevOps</st></h1>
			<p><strong class="bold"><st c="1412">Continuous Deployment (CD)</st></strong><st c="1439"> is a DevOps practice where code changes that have been successfully </st><a id="_idIndexMarker689"/><st c="1508">integrated and passed automated testing are automatically transitioned to the production environment. </st><st c="1610">Activities </st><a id="_idIndexMarker690"/><st c="1621">in this phase include packaging the code into deployable formats, storing the packages in an artifact repository, and validating the software in a pre-production runtime environment before its final transition to the production </st><span class="No-Break"><st c="1849">runtime environment.</st></span></p>
			<p><st c="1869">The process ensures that new features, bug fixes, and updates are rapidly and consistently delivered to users without manual intervention, enabling a seamless flow from development to deployment. </st><st c="2066">The key to a successful CD is a robust automated testing framework that validates changes and ensures the stability and reliability of the application in a </st><span class="No-Break"><st c="2222">real-world setting.</st></span></p>
			<p><span class="No-Break"><em class="italic"><st c="2241">Figure 7</st></em></span><em class="italic"><st c="2250">.1</st></em><st c="2252"> shows a simplified example of a DevOps CD process. </st><st c="2304">In the scenario, an application package, labeled as </st><em class="italic"><st c="2356">APP:V1</st></em><st c="2362">, is published into the artifact store from the build process. </st><st c="2425">The creation of the new package initiates a CD pipeline, which automatically deploys it to a staging environment for testing. </st><st c="2551">Once the testing has successfully passed, the package is deployed to the production environment where it becomes available for </st><span class="No-Break"><st c="2678">end-user access.</st></span></p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/B19710_07_01.jpg" alt="Figure 7.1 – Continuous delivery example scenario"/><st c="2694"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="3035">Figure 7.1 – Continuous delivery example scenario</st></p>
			<p><st c="3084">Implementing </st><a id="_idIndexMarker691"/><st c="3098">security in the CD phase involves securely storing the release artifacts, validating their security before release, ensuring </st><a id="_idIndexMarker692"/><st c="3223">the runtime environment’s security before software deployment, and using </st><strong class="bold"><st c="3296">infrastructure as code</st></strong><st c="3318"> (</st><strong class="bold"><st c="3320">IaC</st></strong><st c="3323">) to automatically configure the runtime environment’s security. </st><st c="3389">Let us review </st><span class="No-Break"><st c="3403">these areas.</st></span></p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor149"/><st c="3415">Protecting release artifacts in the release phase</st></h1>
			<p><st c="3465">DevOps processes are about speed and agility. </st><st c="3512">The aim is to remove obstacles that could slow down </st><a id="_idIndexMarker693"/><st c="3564">the </st><a id="_idTextAnchor150"/><st c="3568">speed to market. </st><st c="3585">It is not unusual for code changes to move from a developer’s workspace to the production environment </st><a id="_idIndexMarker694"/><st c="3687">within minutes, mainly driven by automation and with few manual checks. </st><st c="3759">It is impressive to read about the deployment figures from organizations that are more mature in their DevOps practices. </st><st c="3880">For example, Netflix maintains over 600 services in production and does around 100 deployments a day; Uber operates over 1,000 services in production with several thousand deployments weekly; WeChat has more than 3,000 services in production and manages approximately 1,000 </st><span class="No-Break"><st c="4154">deployments daily!</st></span></p>
			<p class="callout-heading"><st c="4172">Note</st></p>
			<p class="callout"><st c="4177">For information that highlights the deployment pace of companies such as Netflix, Uber, and WeChat, please refer to this </st><span class="No-Break"><st c="4299">document: </st></span><a href="https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition"><span class="No-Break"><st c="4309">https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/definition</st></span></a><span class="No-Break"><st c="4386">.</st></span></p>
			<p><st c="4387">To integrate security in the release phase, start by reviewing your CI/CD process and ensuring that no one (person or application) can deploy code changes or new artifacts without </st><a id="_idIndexMarker695"/><st c="4568">strict reviews and approvals. </st><st c="4598">The </st><a id="_idIndexMarker696"/><st c="4602">reviews should include both automated checks and human-led reviews. </st><st c="4670">Following zero-trust principles, you have to assume that an attacker might eventually gain access to a system within your CI/CD process (source control, CI system, or artifact repository). </st><st c="4859">To mitigate this, we need to implement measures that prevent any single entity from independently pushing code ch</st><a id="_idTextAnchor151"/><st c="4972">anges or release artifacts through the </st><span class="No-Break"><st c="5012">release pipeline.</st></span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor152"/><st c="5029">Ensuring that release artifacts are built from protected branches</st></h2>
			<p><st c="5095">Implementing </st><a id="_idIndexMarker697"/><st c="5109">security in the test and release phases of DevOps starts with the security of the artifacts that will be deployed – we refer </st><a id="_idIndexMarker698"/><st c="5234">to them as </st><span class="No-Break"><strong class="bold"><st c="5245">release artifacts</st></strong></span><span class="No-Break"><st c="5262">.</st></span></p>
			<p class="callout-heading"><st c="5263">Note</st></p>
			<p class="callout"><st c="5268">A release artifact is software or a software component that is packaged and ready for deployment. </st><st c="5367">Artifacts vary depending on the technology stack and target deployment platforms. </st><st c="5449">For </st><a id="_idIndexMarker699"/><st c="5453">example, Java applications are typically packaged as </st><strong class="bold"><st c="5506">Java Archive</st></strong><st c="5518"> (</st><strong class="bold"><st c="5520">JAR</st></strong><st c="5523">) files. </st><st c="5533">Java web applications are packaged as </st><strong class="bold"><st c="5571">Web Application Archive</st></strong><st c="5594"> (</st><strong class="bold"><st c="5596">WAR</st></strong><st c="5599">) files. </st><st c="5609">In </st><a id="_idIndexMarker700"/><st c="5612">the .NET ecosystem, </st><strong class="bold"><st c="5632">.NET assemblies</st></strong><st c="5647"> (</st><strong class="source-inline"><st c="5649">.dll</st></strong><st c="5653"> or </st><strong class="source-inline"><st c="5657">.exe</st></strong><st c="5661"> files) are the compiled code artifacts </st><a id="_idIndexMarker701"/><st c="5701">that are deployed to run on the .NET runtime. </st><st c="5747">In JavaScript </st><a id="_idIndexMarker702"/><st c="5761">or Node.js projects, </st><strong class="bold"><st c="5782">NPM packages</st></strong><st c="5794"> are the artifacts. </st><st c="5814">They include the application code along with its dependencies, defined in a </st><strong class="source-inline"><st c="5890">package.json</st></strong><st c="5902"> file. </st><st c="5909">For </st><a id="_idIndexMarker703"/><st c="5913">Python applications, </st><strong class="bold"><st c="5934">wheel</st></strong><st c="5939"> (</st><strong class="source-inline"><st c="5941">.whl</st></strong><st c="5945">) files are a more modern packaging format, aimed at replacing egg files. </st><st c="6020">They facilitate the distribution and installation of Python libraries and applications. </st><st c="6108">For containerized solutions, applications are packaged as </st><span class="No-Break"><st c="6166">container images.</st></span></p>
			<p><st c="6183">A good starting point is to protect all branches that are used to create these release artifacts. </st><st c="6282">In GitHub Enterprise, this can be done with </st><strong class="bold"><st c="6326">Branch protection rules</st></strong><st c="6349">, and in Azure DevOps, this can be done with </st><span class="No-Break"><strong class="bold"><st c="6394">Branch Policies</st></strong></span><span class="No-Break"><st c="6409">.</st></span></p>
			<p><st c="6410">To implement in GitHub Enterprise, navigate to </st><strong class="bold"><st c="6458">Repository Settings</st></strong><st c="6477">, then </st><strong class="bold"><st c="6484">Code and automation</st></strong><st c="6503"> | </st><strong class="bold"><st c="6506">Branches</st></strong><st c="6514"> | </st><strong class="bold"><st c="6517">Branch protection rules</st></strong><st c="6540">, and then click on </st><strong class="bold"><st c="6560">Add rule</st></strong><st c="6568">. </st><span class="No-Break"><em class="italic"><st c="6570">Figure 7</st></em></span><em class="italic"><st c="6578">.2</st></em><st c="6580"> shows an example of a branch protection rule that is used to protect any branch </st><a id="_idIndexMarker704"/><st c="6661">that contains the word “release.” This requires admin permissions or a custom role with the </st><strong class="bold"><st c="6753">Edit repository </st></strong><span class="No-Break"><strong class="bold"><st c="6769">rules</st></strong></span><span class="No-Break"><st c="6774"> permission.</st></span></p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/B19710_07_02.jpg" alt="Figure 7.2 – Sample branch protection rule in GitHub Enterprise"/><st c="6786"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="7593">Figure 7.2 – Sample branch protection rule in GitHub Enterprise</st></p>
			<p><st c="7656">To implement in Azure DevOps, go to </st><strong class="bold"><st c="7693">Project Settings</st></strong><st c="7709"> | </st><strong class="bold"><st c="7712">Repos</st></strong><st c="7717"> | </st><strong class="bold"><st c="7720">Repositories</st></strong><st c="7732">, select a </st><strong class="bold"><st c="7743">repository</st></strong><st c="7753">, choose </st><strong class="bold"><st c="7762">Policies</st></strong><st c="7770"> | </st><strong class="bold"><st c="7773">Branch Policies</st></strong><st c="7788">, and select a </st><strong class="bold"><st c="7803">branch</st></strong><st c="7809"> (note that you may need to scroll down to see your list of branches). </st><span class="No-Break"><em class="italic"><st c="7880">Figure 7</st></em></span><em class="italic"><st c="7888">.3</st></em><st c="7890"> shows an example of a branch policy in Azure DevOps. </st><st c="7944">This requires admin permissions or a custom role with the </st><strong class="bold"><st c="8002">Edit </st></strong><span class="No-Break"><strong class="bold"><st c="8007">policies</st></strong></span><span class="No-Break"><st c="8015"> permission.</st></span></p>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="image/B19710_07_03.jpg" alt="Figure 7.3 – Sample branch protection rule in Azure DevOps"/><st c="8027"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="8687">Figure 7.3 – Sample branch protection rule in Azure DevOps</st></p>
			<p><st c="8745">Overall, both platforms offer similar branch protection features. </st><st c="8812">GitHub Enterprise may not have </st><a id="_idIndexMarker705"/><st c="8843">direct branch protection settings for build validation and human reviews, but these capabilities can be achieved through alternative methods (see </st><span class="No-Break"><em class="italic"><st c="8989">Figure 7</st></em></span><em class="italic"><st c="8997">.4</st></em><st c="8999">). </st><st c="9003">A notable distinction is the lack of support for requiring signed commits in Azure DevOps, which is available in GitHub Enterprise. </st><st c="9135">For a detailed comparison of branch protection features between the two platforms, see </st><span class="No-Break"><em class="italic"><st c="9222">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="9230">.4</st></em></span><span class="No-Break"><st c="9232">.</st></span></p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="image/B19710_07_04.jpg" alt="Figure 7.4 – Branch protection feature comparison"/><st c="9233"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="9716">Figure 7.4 – Branch protection feature comparison</st></p>
			<p><st c="9765">Following zero-trust principles, we also want to make sure that branch protection policies are enforced for everyone, including administrators. </st><st c="9910">This is extremely important since administrator accounts are often targeted for account hijacking due to their </st><span class="No-Break"><st c="10021">privileged role.</st></span></p>
			<p class="author-quote"><st c="10037">Adopt a zero-trust approach to all main release branches for everyone with exceptions only in rare scenarios</st></p>
			<p><st c="10146">In GitHub </st><a id="_idIndexMarker706"/><st c="10157">Enterprise, we can activate the </st><strong class="bold"><st c="10189">Do not allow bypassing the above settings</st></strong><st c="10230"> option in our branch protection rule (see </st><span class="No-Break"><em class="italic"><st c="10273">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="10281">.5</st></em></span><span class="No-Break"><st c="10283">).</st></span></p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="image/B19710_07_05.jpg" alt="Figure 7.5 – Enforce branch protection settings for everyone in GitHub Enterprise"/><st c="10286"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="10729">Figure 7.5 – Enforce branch protection settings for everyone in GitHub Enterprise</st></p>
			<p><st c="10810">In Azure DevOps, there is no equivalent setting for this, but we can restrict or audit roles/users with permissions to bypass policies on pull requests and pushes. </st><st c="10975">By default, no role, including administrators, has these permissions assigned (see </st><span class="No-Break"><em class="italic"><st c="11058">Figure 7</st></em></span><em class="italic"><st c="11066">.6</st></em><st c="11068">). </st><st c="11072">To review permissions in Azure DevOps, navigate to </st><strong class="bold"><st c="11123">Project Settings</st></strong><st c="11139"> | </st><strong class="bold"><st c="11142">Repos</st></strong><st c="11147"> | </st><strong class="bold"><st c="11150">Repositories</st></strong><st c="11162">, select a </st><strong class="bold"><st c="11173">repository</st></strong><st c="11183">, then </st><strong class="bold"><st c="11190">Security</st></strong><st c="11198">, and check </st><strong class="bold"><st c="11210">Bypass policies when completing pull requests</st></strong><st c="11255"> and </st><strong class="bold"><st c="11260">Bypass policies when pushing</st></strong><st c="11288"> (</st><span class="No-Break"><em class="italic"><st c="11290">Figure 7</st></em></span><em class="italic"><st c="11298">.6</st></em><st c="11300">). </st><st c="11304">The permission can also be configured at the branch level, rather than the </st><span class="No-Break"><st c="11379">repository level.</st></span></p>
			<div>
				<div id="_idContainer225" class="IMG---Figure">
					<img src="image/B19710_07_06.jpg" alt="Figure 7.6 – Reviewing permissions to bypass branch protection policies in Azure DevOps"/><st c="11396"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12078">Figure 7.6 – Reviewing permissions to bypass branch protection policies in Azure DevOps</st></p>
			<p><st c="12165">In case </st><a id="_idIndexMarker707"/><st c="12174">of a compromise of an administrator account, branch protection settings could be disabled to allow an attacker to fast-track malicious code changes to production by bypassing the required checks. </st><st c="12370">For this reason, it is important to also track and audit branch protection and sensitive permission changes to spot unusual bypass attempts. </st><span class="No-Break"><em class="italic"><st c="12511">Figure 7</st></em></span><em class="italic"><st c="12519">.7</st></em><st c="12521"> shows an example audit log entry for a modification to a sensitive branch protection setting in </st><span class="No-Break"><st c="12618">GitHub Enterprise.</st></span></p>
			<div>
				<div id="_idContainer226" class="IMG---Figure">
					<img src="image/B19710_07_07.jpg" alt="Figure 7.7 – Sample log entry for a modification to a sensitive branch protection setting"/><st c="12636"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="13012">Figure 7.7 – Sample log entry for a modification to a sensitive branch protection setting</st></p>
			<p><st c="13101">For information on enabling auditing, please refer to the </st><em class="italic"><st c="13160">Ensuring the build environment is logged</st></em><st c="13200"> section in </st><a href="B19710_06.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic"><st c="13212">Chapter 6</st></em></span></a><span class="No-Break"><st c="13221">.</st></span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor153"/><st c="13222">Implementing a code review process</st></h2>
			<p><st c="13257">Another good security measure is to require human-led reviews for both the release branches </st><a id="_idIndexMarker708"/><st c="13350">and the deployment workflow/pipeline configuration files. </st><st c="13408">This should be in addition to automated security scans that are enforced for code to be merged with the release branches. </st><st c="13530">Automated scans are useful but can be bypassed, hence the need for human checks. </st><st c="13611">Even with necessary controls in place, new bypass methods may be discovered. </st><st c="13688">Including experienced human reviewers provides an additional layer of defense against potential </st><span class="No-Break"><st c="13784">malicious attacks.</st></span></p>
			<p><st c="13802">Both the GitHub Enterprise and Azure DevOps platforms support granular implementation of code reviewers where we can assign different reviewers for different paths of the code base. </st><st c="13985">In Azure DevOps, this can be implemented with a branch protection control while in GitHub Enterprise, this can be implemented with a branch protection control </st><a id="_idIndexMarker709"/><st c="14144">combined with a capability </st><span class="No-Break"><st c="14171">called </st></span><span class="No-Break"><strong class="source-inline"><st c="14178">CODEOWNERS</st></strong></span><span class="No-Break"><st c="14188">.</st></span></p>
			<p><st c="14189">To enable granular code review in Azure DevOps, navigate to </st><strong class="bold"><st c="14250">Project Settings</st></strong><st c="14266">, then </st><strong class="bold"><st c="14273">Repos</st></strong><st c="14278">, and select </st><strong class="bold"><st c="14291">Repositories</st></strong><st c="14303">. Choose a repository, click on </st><strong class="bold"><st c="14335">Policies</st></strong><st c="14343">, and then scroll down to the </st><strong class="bold"><st c="14373">Branch Policies</st></strong><st c="14388"> section to find your release branch. </st><st c="14426">Under </st><strong class="bold"><st c="14432">Branch Policies</st></strong><st c="14447">, activate </st><strong class="bold"><st c="14458">Require a minimum number of reviewers</st></strong><st c="14495"> by setting it to </st><strong class="bold"><st c="14513">On</st></strong><st c="14515">. Enter the number of required reviewers and choose from the available options (</st><span class="No-Break"><em class="italic"><st c="14595">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="14604">.8</st></em></span><span class="No-Break"><st c="14606">).</st></span></p>
			<div>
				<div id="_idContainer227" class="IMG---Figure">
					<img src="image/B19710_07_08.jpg" alt="Figure 7.8 – Enabling human-led code reviews in Azure DevOps"/><st c="14609"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="15304">Figure 7.8 – Enabling human-led code reviews in Azure DevOps</st></p>
			<p><st c="15364">We can </st><a id="_idIndexMarker710"/><st c="15372">also automatically add reviewers to pull requests that change files in specific directories and files. </st><st c="15475">For example, we may want to add members of the security team to review any change to the pipeline file or security champions in the development team to review code changes to the release branch. </st><st c="15670">We can do this by configuring the option to </st><strong class="bold"><st c="15714">Automatically include reviewers</st></strong><st c="15745"> (</st><span class="No-Break"><em class="italic"><st c="15747">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="15755">.9</st></em></span><span class="No-Break"><st c="15757">).</st></span></p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="image/B19710_07_09.jpg" alt="Figure 7.9 – Adding required reviewers in an Azure repository branch policy"/><st c="15760"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="16089">Figure 7.9 – Adding required reviewers in an Azure repository branch policy</st></p>
			<p><st c="16164">If the setting is marked as </st><strong class="bold"><st c="16193">Required</st></strong><st c="16201">, every individual listed as a reviewer must approve the changes. </st><st c="16267">If group names are added as reviewers, at least one member from each group </st><a id="_idIndexMarker711"/><st c="16342">must approve the changes. </st><st c="16368">If approval is required from only one group, then the number of approvals needed is the minimum number specified for that group. </st><st c="16497">For example, a group could be formed for each development team that includes the security champions from the team, and this group would be required as a reviewer. </st><st c="16660">This ensures that at least one person with security experience and training reviews the code changes before they </st><span class="No-Break"><st c="16773">are approved.</st></span></p>
			<p><st c="16786">For GitHub Enterprise, we can enable a branch protection rule to require a pull request before merging by selecting the </st><strong class="bold"><st c="16907">Require a pull request before merging</st></strong><st c="16944"> option and configuring it to require reviews from designated code owners defined in a </st><strong class="source-inline"><st c="17031">CODEOWNERS</st></strong><st c="17041"> file (</st><span class="No-Break"><em class="italic"><st c="17048">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="17057">.10</st></em></span><span class="No-Break"><st c="17060">).</st></span></p>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="image/B19710_07_10.jpg" alt="Figure 7.10 – Enabling a Code Owners review in a GitHub Enterprise branch protection policy"/><st c="17063"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="18171">Figure 7.10 – Enabling a Code Owners review in a GitHub Enterprise branch protection policy</st></p>
			<p class="callout-heading"><st c="18262">CODEOWNERS</st></p>
			<p class="callout"><strong class="source-inline"><st c="18273">CODEOWNERS</st></strong><st c="18284"> is a feature </st><a id="_idIndexMarker712"/><st c="18298">of GitHub that we can use to specify individuals or teams that are responsible for maintaining specific parts of a project. </st><st c="18422">When changes are made to those parts, the designated code owners are automatically required to review and approve the changes before they can be merged. </st><st c="18575">We can use this feature to implement code reviews for release branches and deployment </st><span class="No-Break"><st c="18661">workflow files.</st></span></p>
			<p class="callout"><st c="18676">To use </st><strong class="source-inline"><st c="18684">CODEOWNERS</st></strong><st c="18694">, we need to create a file called </st><strong class="source-inline"><st c="18728">CODEOWNERS</st></strong><st c="18738"> in the </st><strong class="source-inline"><st c="18746">.github/</st></strong><st c="18754">, </st><strong class="source-inline"><st c="18756">root</st></strong><st c="18760">, or </st><strong class="source-inline"><st c="18765">docs/</st></strong><st c="18770"> directory of the repository. </st><st c="18800">The file uses a pattern that follows most (not all) of the same rules used in </st><strong class="source-inline"><st c="18878">gitignore</st></strong><st c="18887"> files. </st><st c="18895">For example, a line entry of </st><strong class="source-inline"><st c="18924">/workflows/ @dev @security</st></strong><st c="18950"> means that any changes inside the </st><strong class="source-inline"><st c="18985">/workflows</st></strong><st c="18995"> directory will require approval from members of the </st><strong class="source-inline"><st c="19048">@dev or @security</st></strong><st c="19065"> teams, but approvals from both are </st><span class="No-Break"><st c="19101">not required.</st></span></p>
			<p class="callout"><st c="19114">A line entry of </st><strong class="source-inline"><st c="19131">**/releases @securitychampions @teamleaders</st></strong><st c="19174"> means the </st><strong class="source-inline"><st c="19185">@securitychampions</st></strong><st c="19203"> and </st><strong class="source-inline"><st c="19208">@teamleaders</st></strong><st c="19220"> teams own any file in any </st><strong class="source-inline"><st c="19247">/releases</st></strong><st c="19256"> directory. </st><st c="19268">To </st><a id="_idIndexMarker713"/><st c="19271">learn more about the </st><strong class="source-inline"><st c="19292">CODEOWNERS</st></strong><st c="19302"> file, please refer to this </st><span class="No-Break"><st c="19330">document: </st></span><a href="https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax"><span class="No-Break"><st c="19340">https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners#codeowners-syntax</st></span></a><span class="No-Break"><st c="19491">.</st></span></p>
			<p><st c="19492">Now that </st><a id="_idIndexMarker714"/><st c="19502">we understand one of some of the controls that we can implement to ensure release artifacts only come from validated code, let us move on to examine the secure storage of </st><span class="No-Break"><st c="19673">these artifacts.</st></span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor154"/><st c="19689">Selecting secure artifact sources</st></h2>
			<p><st c="19723">Another key security best practice in the test and release phases of DevOps is to secure the artifacts </st><a id="_idIndexMarker715"/><st c="19827">that will be deployed. </st><st c="19850">These artifacts should be stored in trusted locations that maintain their integrity </st><a id="_idIndexMarker716"/><st c="19934">and prevent tampering. </st><st c="19957">Both GitHub Actions and Azure Pipelines support deploying artifacts from various sources, such as build environments, package repositories, container repositories, file shares, and source control repositories. </st><span class="No-Break"><em class="italic"><st c="20167">Figure 7</st></em></span><em class="italic"><st c="20175">.11</st></em><st c="20178"> shows a screenshot of supported artifact sources for a classic Azure </st><span class="No-Break"><st c="20248">release pipeline.</st></span></p>
			<p><st c="20265">DevSecOps </st><a id="_idIndexMarker717"/><st c="20276">requires us to only use artifact sources that support </st><strong class="bold"><st c="20330">immutability</st></strong><st c="20342">, </st><strong class="bold"><st c="20344">traceability</st></strong><st c="20356">, and </st><strong class="bold"><st c="20362">access control</st></strong><st c="20376">. Immutability guarantees integrity by ensuring </st><a id="_idIndexMarker718"/><st c="20424">that an artifact’s contents will not change from when it is published, tested for security, and eventually released to production. </st><st c="20555">This can be implemented </st><a id="_idIndexMarker719"/><st c="20579">at the artifact source level or the package level. </st><st c="20630">Implementing at the source level means that our artifact sources should not allow any modifications to packages once published. </st><st c="20758">To correct any issues, a new version should be published instead of modifying an existing one. </st><st c="20853">This ensures that the content of the artifact that </st><a id="_idIndexMarker720"/><st c="20904">has been security tested is the same as the one deployed. </st><st c="20962">Sources such as file shares, </st><strong class="bold"><st c="20991">Azure Container Registry</st></strong><st c="21015"> (</st><strong class="bold"><st c="21017">ACR</st></strong><st c="21020">), and GitHub Packages should be used carefully as they are mutable by default. </st><st c="21101">Anyone with the right set of permissions can update the content of published artifacts that are stored in them. </st><st c="21213">This can be exploited by attackers to replace the original version with a compromised one </st><span class="No-Break"><st c="21303">before deployment.</st></span></p>
			<div>
				<div id="_idContainer230" class="IMG---Figure">
					<img src="image/B19710_07_11.jpg" alt="Figure 7.11 – Supported artifact sources for a classic Azure release pipeline"/><st c="21321"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="21464">Figure 7.11 – Supported artifact sources for a classic Azure release pipeline</st></p>
			<p><st c="21541">For ACR, we can </st><a id="_idIndexMarker721"/><st c="21558">enforce immutability at the artifact store level by configuring image locking. </st><st c="21637">This is achieved using the </st><strong class="source-inline"><st c="21664">az acr repository update</st></strong><st c="21688"> command. </st><span class="No-Break"><em class="italic"><st c="21698">Figure 7</st></em></span><em class="italic"><st c="21706">.12</st></em><st c="21709"> shows a sample GitHub workflow that uses this command to lock a new container image in the build and </st><span class="No-Break"><st c="21811">publish phase.</st></span></p>
			<div>
				<div id="_idContainer231" class="IMG---Figure">
					<img src="image/B19710_07_12.jpg" alt="Figure 7.12 – Sample GitHub workflow with ACR image locking"/><st c="21825"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="22553">Figure 7.12 – Sample GitHub workflow with ACR image locking</st></p>
			<p><st c="22612">Immutability is one of several factors to consider when selecting artifact sources. </st><st c="22697">Other important factors to consider are traceability and versioning. </st><st c="22766">Traceability gives visibility into a package’s origin and links it to code changes, test cases, and work items. </st><st c="22878">This makes it easier to perform forensic auditing in case of a breach. </st><st c="22949">Versioning allows us to track security outcomes between different versions of our artifacts and allows quick rollbacks to secure versions when facing major </st><span class="No-Break"><st c="23105">zero-day vulnerabilities.</st></span></p>
			<p><st c="23130">Support for </st><a id="_idIndexMarker722"/><st c="23143">traceability and versioning varies by artifact source. </st><st c="23198">For example, file shares are basic storage solutions that typically lack built-in versioning and traceability to source control. </st><st c="23327">Implementing these features in file shares usually requires additional tools or </st><span class="No-Break"><st c="23407">custom configurations.</st></span></p>
			<p><st c="23429">File shares are generally not recommended as artifact sources in DevOps workflows. </st><st c="23513">Workflow/pipeline artifacts naturally include these features, while ACR, GitHub Packages, and Azure Artifacts might also need </st><span class="No-Break"><st c="23639">extra configuration.</st></span></p>
			<h3><st c="23659">Understanding workflow/pipeline artifacts</st></h3>
			<p><st c="23701">Both GitHub </st><a id="_idIndexMarker723"/><st c="23714">Actions and Azure Pipelines support options to publish artifacts internally within the build platform. </st><st c="23817">For GitHub Actions, the </st><strong class="source-inline"><st c="23841">upload-artifact</st></strong><st c="23856"> action can be used to upload an artifact into an </st><strong class="bold"><st c="23906">Actions artifacts</st></strong><st c="23923"> store (</st><span class="No-Break"><em class="italic"><st c="23931">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="23940">.13</st></em></span><span class="No-Break"><st c="23943">).</st></span></p>
			<div>
				<div id="_idContainer232" class="IMG---Figure">
					<img src="image/B19710_07_13.jpg" alt="Figure 7.13 – GitHub Actions upload-artifact action"/><st c="23946"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="24500">Figure 7.13 – GitHub Actions upload-artifact action</st></p>
			<p><st c="24551">For Azure </st><a id="_idIndexMarker724"/><st c="24562">Pipelines, the </st><strong class="source-inline"><st c="24577">PublishPipelineArtifact</st></strong><st c="24600"> or </st><strong class="source-inline"><st c="24604">PublishBuildArtifact</st></strong><st c="24624"> tasks can be used for the same purpose (</st><span class="No-Break"><em class="italic"><st c="24665">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="24674">.14</st></em></span><span class="No-Break"><st c="24677">).</st></span></p>
			<div>
				<div id="_idContainer233" class="IMG---Figure">
					<img src="image/B19710_07_14.jpg" alt="Figure 7.14 – Azure Pipelines PublishPipelineArtifact task"/><st c="24680"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="25294">Figure 7.14 – Azure Pipelines PublishPipelineArtifact task</st></p>
			<p><st c="25352">These options are popular because they are easy to use, yet they impact immutability and traceability. </st><st c="25456">Because the artifacts are stored within the build platform and they have a link to the workflow/pipeline run or job that created them, so, in this case, they offer built-in traceability. </st><st c="25643">However, retention policies and behavior should also be considered to understand the overall impact. </st><st c="25744">For example, GitHub Enterprise stores action </st><a id="_idIndexMarker725"/><st c="25789">artifacts for 90 days, but this can be extended up to 400 days. </st><st c="25853">The customization can be done at the Enterprise, Organization, or Repository levels (</st><span class="No-Break"><em class="italic"><st c="25938">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="25947">.15</st></em></span><span class="No-Break"><st c="25950">).</st></span></p>
			<div>
				<div id="_idContainer234" class="IMG---Figure">
					<img src="image/B19710_07_15.jpg" alt="Figure 7.15 – Configuring the retention period for GitHub workflow artifacts"/><st c="25953"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="26239">Figure 7.15 – Configuring the retention period for GitHub workflow artifacts</st></p>
			<p class="callout-heading"><st c="26315">Configuring artifact retention period in GitHub Enterprise</st></p>
			<p class="callout"><st c="26374">The </st><a id="_idIndexMarker726"/><st c="26379">artifacts retention settings can be customized at different levels in </st><span class="No-Break"><st c="26449">GitHub Enterprise:</st></span></p>
			<ul>
				<li class="callout"><strong class="bold"><st c="26467">Enterprise</st></strong><st c="26478">: Go to </st><strong class="bold"><st c="26487">Settings</st></strong><st c="26495"> | </st><strong class="bold"><st c="26498">Policies</st></strong><st c="26506"> | </st><strong class="bold"><st c="26509">Actions</st></strong><st c="26516"> | </st><strong class="bold"><st c="26519">Policies</st></strong><st c="26527"> | </st><strong class="bold"><st c="26530">Artifact and </st></strong><span class="No-Break"><strong class="bold"><st c="26543">log retention</st></strong></span><span class="No-Break"><st c="26556">.</st></span></li>
				<li class="callout"><strong class="bold"><st c="26557">Organization</st></strong><st c="26570">: Go to </st><strong class="bold"><st c="26579">Settings</st></strong><st c="26587"> | </st><strong class="bold"><st c="26590">Code, planning, and automation</st></strong><st c="26620"> | </st><strong class="bold"><st c="26623">Actions</st></strong><st c="26630"> | </st><strong class="bold"><st c="26633">General</st></strong><st c="26640"> | </st><strong class="bold"><st c="26643">Artifact and </st></strong><span class="No-Break"><strong class="bold"><st c="26656">log retention</st></strong></span><span class="No-Break"><st c="26669">.</st></span></li>
				<li class="callout"><strong class="bold"><st c="26670">Repository</st></strong><st c="26681">: Go to </st><strong class="bold"><st c="26690">Settings</st></strong><st c="26698"> | </st><strong class="bold"><st c="26701">Code and automation</st></strong><st c="26720"> | </st><strong class="bold"><st c="26723">Actions</st></strong><st c="26730"> | </st><strong class="bold"><st c="26733">General</st></strong><st c="26740"> | </st><strong class="bold"><st c="26743">Artifact and </st></strong><span class="No-Break"><strong class="bold"><st c="26756">log retention</st></strong></span><span class="No-Break"><st c="26769">.</st></span></li>
			</ul>
			<p><st c="26770">The chosen retention period affects traceability. </st><st c="26821">If we set a retention period of 100 days and we need to download a previous artifact from 120 days ago to investigate a recently discovered breach, we won’t be able to do so, unless we have transferred the artifact to another storage location. </st><st c="27065">In Azure Pipelines, deleting a pipeline run also deletes all associated artifacts. </st><st c="27148">This can also compromise traceability if a deleted artifact needs to be </st><span class="No-Break"><st c="27220">investigated later.</st></span></p>
			<p><st c="27239">From an immutabilit</st><a id="_idTextAnchor155"/><st c="27259">y standpoint, the GitHub </st><strong class="source-inline"><st c="27285">upload-artifact</st></strong><st c="27300"> action can overwrite artifacts if the </st><strong class="source-inline"><st c="27339">overwrite</st></strong><st c="27348"> option is enabled (</st><span class="No-Break"><em class="italic"><st c="27368">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="27377">.16</st></em></span><span class="No-Break"><st c="27380">).</st></span></p>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="image/B19710_07_16.jpg" alt="Figure 7.16 – Implementing an artifact overwrite"/><st c="27383"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="27576">Figure 7.16 – Implementing an artifact overwrite</st></p>
			<p><st c="27624">If developers </st><a id="_idIndexMarker727"/><st c="27639">do not pin release artifacts by IDs and use names instead, this could be exploited in an artifact swap attack. </st><st c="27750">The Azure Pipelines </st><strong class="source-inline"><st c="27770">PublishPipelineArtifact@1</st></strong><st c="27795"> task behaves differently from this. </st><st c="27832">It is designed to ensure immutable artifacts for a given build. </st><st c="27896">Once published, another artifact with the same name cannot </st><span class="No-Break"><st c="27955">be published.</st></span></p>
			<p class="callout-heading"><st c="27968">Note</st></p>
			<p class="callout"><st c="27973">For more information on the action and task behavior, refer to the </st><span class="No-Break"><st c="28041">following documents:</st></span></p>
			<ul>
				<li class="callout"><span class="No-Break"><strong class="source-inline"><st c="28061">upload-artifact</st></strong></span><span class="No-Break"><st c="28077">: </st></span><a href="https://github.com/actions/upload-artifact"><span class="No-Break"><st c="28080">https://github.com/actions/upload-artifact</st></span></a><span class="No-Break"><st c="28122">.</st></span></li>
				<li class="callout"><span class="No-Break"><strong class="source-inline"><st c="28123">PublishPipelineArtifact@1</st></strong></span><span class="No-Break"><st c="28149">: </st></span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/publish-pipeline-artifact-v1"><span class="No-Break"><st c="28152">https://learn.microsoft.com/en-us/azure/devops/pipelines/tasks/reference/publish-pipeline-artifact-v1</st></span></a><span class="No-Break"><st c="28253">.</st></span></li>
			</ul>
			<p><st c="28254">Now that we have discussed security considerations for using workflow/pipeline artifacts as release sources, let us explore similar considerations for </st><span class="No-Break"><st c="28406">standalone services.</st></span></p>
			<h3><st c="28426">Understanding Azure Artifacts and GitHub Packages</st></h3>
			<p><st c="28476">Both GitHub Enterprise and Azure DevOps provide standalone services for storing and managing </st><a id="_idIndexMarker728"/><st c="28570">release artifacts. </st><st c="28589">GitHub Enterprise offers GitHub Packages, while Azure DevOps provides Azure Artifacts. </st><st c="28676">Both services </st><a id="_idIndexMarker729"/><st c="28690">support feeds that can handle various package types such as NPM, NuGet, Maven, Python, and Universal packages. </st><st c="28801">GitHub Packages also supports </st><a id="_idIndexMarker730"/><st c="28831">containers while Azure Artifacts does </st><a id="_idIndexMarker731"/><st c="28869">not. </st><st c="28874">Azure offers ACR for storing containers. </st><st c="28915">From a security consideration, both services are similar (</st><span class="No-Break"><em class="italic"><st c="28973">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="28982">.17</st></em></span><span class="No-Break"><st c="28985">).</st></span></p>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/B19710_07_17.jpg" alt="Figure 7.17 – Security considerations in GitHub Packages and Azure Artifacts"/><st c="28988"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="29156">Figure 7.17 – Security considerations in GitHub Packages and Azure Artifacts</st></p>
			<p><st c="29232">Packages in both GitHub Packages and Azure Artifacts are immutable by default. </st><st c="29312">Once a package version is published, it cannot be modified. </st><st c="29372">Any updates or fixes must be published as new versions, ensuring that deployed artifacts are consistent with those that have been verified. </st><st c="29512">Traceability in Azure Artifacts is primarily managed through integration with Azure DevOps services. </st><st c="29613">Each artifact is linked to a specific pipeline run, including details such as build number and associated commits. </st><st c="29728">This data is crucial for reconstructing the artifact’s development history. </st><st c="29804">Each package in GitHub Packages stores detailed provenance information including the commit SHA, branch, or tag from which it was built. </st><st c="29941">This level of detail is particularly valuable for compliance and </st><span class="No-Break"><st c="30006">security auditing.</st></span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor156"/><st c="30024">Implementing artifact signing for integrity checks</st></h2>
			<p><st c="30075">Securing </st><a id="_idIndexMarker732"/><st c="30085">the DevOps </st><a id="_idIndexMarker733"/><st c="30096">workflow involves ensuring the integrity of every step in the software supply chain. </st><st c="30181">If an attacker breaches the artifact store, they could tamper with packages meant for production and upload unauthorized artifacts. </st><st c="30313">For example, in the CodeCov incident, an attacker used leaked credentials to upload a harmful artifact, leading to direct downloads by users. </st><st c="30455">One mitigation strategy is to enforce an integrity validation process for all release artifacts. </st><st c="30552">This includes signing packages and verifying digital signatures before deployment. </st><st c="30635">Various tools </st><a id="_idIndexMarker734"/><st c="30649">and approaches could be used for this, but two common </st><a id="_idIndexMarker735"/><st c="30703">ones are </st><strong class="bold"><st c="30712">Sigstore’s Cosign</st></strong><st c="30729"> and </st><strong class="bold"><st c="30734">Notation</st></strong><st c="30742">. Let us </st><span class="No-Break"><st c="30751">review these.</st></span></p>
			<h3><st c="30764">Implementing artifact signing using Sigstore’s Cosign</st></h3>
			<p><strong class="bold"><st c="30818">Sigstore</st></strong><st c="30827"> is a set </st><a id="_idIndexMarker736"/><st c="30837">of open-source tools designed to automate the digital signing </st><a id="_idIndexMarker737"/><st c="30899">and verification of software </st><a id="_idIndexMarker738"/><st c="30928">artifacts. </st><st c="30939">It is primarily aimed at software artifacts such as container images and binaries, but it can be used for any file type, including ZIP archives. </st><st c="31084">It combines several tools and technologies, including </st><span class="No-Break"><st c="31138">the following:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="31152">Cosign</st></strong><st c="31159">: This </st><a id="_idIndexMarker739"/><st c="31167">signs and verifies containers </st><span class="No-Break"><st c="31197">and artifacts</st></span></li>
				<li><strong class="bold"><st c="31210">Fulcio</st></strong><st c="31217">: A free </st><a id="_idIndexMarker740"/><st c="31227">root certification authority that issues </st><span class="No-Break"><st c="31268">temporary certificates</st></span></li>
				<li><strong class="bold"><st c="31290">Rekor</st></strong><st c="31296">: This records </st><a id="_idIndexMarker741"/><st c="31312">signed metadata to a </st><span class="No-Break"><st c="31333">tamper-resistant ledger</st></span></li>
				<li><strong class="bold"><st c="31356">OpenID Connect</st></strong><st c="31371">: This </st><a id="_idIndexMarker742"/><st c="31379">provides </st><span class="No-Break"><st c="31388">identity verification</st></span></li>
			</ul>
			<p class="callout-heading"><st c="31409">Sigstore</st></p>
			<p class="callout"><st c="31418">To learn </st><a id="_idIndexMarker743"/><st c="31428">more about the Sigstore project, you can visit their website at </st><a href="https://www.sigstore.dev/"><st c="31492">https://www.sigstore.dev/</st></a><st c="31517"> and explore their GitHub repository </st><span class="No-Break"><st c="31554">at </st></span><a href="https://github.com/sigstore"><span class="No-Break"><st c="31557">https://github.com/sigstore</st></span></a><span class="No-Break"><st c="31584">.</st></span></p>
			<p><strong class="bold"><st c="31585">Cosign</st></strong><st c="31592"> (one of the tools included in the Sigstore project) simplifies signing and verifying </st><a id="_idIndexMarker744"/><st c="31678">software artifacts such as container images by making the process of managing signatures invisible. </st><st c="31778">It automatically signs artifacts, stores the signatures in an OCI registry, and performs verifications without user intervention regarding signature handling. </st><st c="31937">When signing a Docker image, Cosign creates a special tag in the OCI registry that incorporates the image’s unique digest (its immutable identifier) into the tag name. </st><st c="32105">This allows for easy retrieval and verification of the image’s signature based on </st><span class="No-Break"><st c="32187">its digest.</st></span></p>
			<p><st c="32198">To use </st><a id="_idIndexMarker745"/><st c="32206">Cosign, we </st><em class="italic"><st c="32217">first</st></em><st c="32222"> must ensure </st><a id="_idIndexMarker746"/><st c="32235">that it is installed on the runner/agent used for our workflow/pipeline. </st><st c="32308">For GitHub, this can be done using the </st><strong class="source-inline"><st c="32347">cosign-installer</st></strong><st c="32363"> GitHub </st><a id="_idIndexMarker747"/><st c="32371">marketplace task (</st><span class="No-Break"><em class="italic"><st c="32389">Figure 7</st></em></span><em class="italic"><st c="32398">.18</st></em><st c="32401">). </st><st c="32405">For Azure DevOps, we use a command line step with our preferred OS package manager, as detailed </st><span class="No-Break"><st c="32501">at </st></span><a href="https://docs.sigstore.dev/system_config/installation/"><span class="No-Break"><st c="32504">https://docs.sigstore.dev/system_config/installation/</st></span></a><span class="No-Break"><st c="32557">.</st></span></p>
			<div>
				<div id="_idContainer237" class="IMG---Figure">
					<img src="image/B19710_07_18.jpg" alt="Figure 7.18 – The cosign-installer GitHub marketplace task"/><st c="32558"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="33001">Figure 7.18 – The cosign-installer GitHub marketplace task</st></p>
			<p><st c="33059">The </st><em class="italic"><st c="33064">second</st></em><st c="33070"> step is optional. </st><st c="33089">We could generate the key pairs that will be used for the digital signature using the </st><strong class="source-inline"><st c="33175">cosign generate-key-pair</st></strong><st c="33199"> command. </st><st c="33209">This allows for more control but introduces the complexity of key management. </st><st c="33287">Cosign also supports keyless signing, which uses ephemeral keys and logs the signing process transparently. </st><st c="33395">This approach improves security and simplifies operations by eliminating the direct management of keys. </st><st c="33499">The </st><em class="italic"><st c="33503">third</st></em><st c="33508"> step is to sign our artifact using the </st><strong class="source-inline"><st c="33548">cosign sign</st></strong><st c="33559"> command. </st><st c="33569">The </st><em class="italic"><st c="33573">final</st></em><st c="33578"> step is to verify the signature with the </st><strong class="source-inline"><st c="33620">cosign verify</st></strong><st c="33633"> command, as part of our </st><span class="No-Break"><st c="33658">pre-deployment check.</st></span></p>
			<h3><st c="33679">Implementing artifact signing using Notation</st></h3>
			<p><st c="33724">Notation </st><a id="_idIndexMarker748"/><st c="33734">is another tool that can be used to </st><a id="_idIndexMarker749"/><st c="33770">sign and verify the integrity and the publisher of digital artifacts. </st><st c="33840">It is part of the Notary project, an incubating </st><a id="_idIndexMarker750"/><st c="33888">project of the </st><strong class="bold"><st c="33903">Cloud Native Computing </st></strong><span class="No-Break"><strong class="bold"><st c="33926">Foundation</st></strong></span><span class="No-Break"><st c="33936"> (</st></span><span class="No-Break"><strong class="bold"><st c="33938">CNCF</st></strong></span><span class="No-Break"><st c="33942">).</st></span></p>
			<p class="callout-heading"><st c="33945">Notary project</st></p>
			<p class="callout"><st c="33960">To learn </st><a id="_idIndexMarker751"/><st c="33970">more about the Notary project, you can visit their website at </st><a href="https://notaryproject.dev/"><st c="34032">https://notaryproject.dev/</st></a><st c="34058"> and explore their GitHub repository </st><span class="No-Break"><st c="34095">at </st></span><a href="https://github.com/notaryproject"><span class="No-Break"><st c="34098">https://github.com/notaryproject</st></span></a><span class="No-Break"><st c="34130">.</st></span></p>
			<p><st c="34131">Similar to Sigstore, it is also primarily aimed at software artifacts such as container images and binaries, but it can be used for any file type, including ZIP files. </st><st c="34300">Digital artifacts can be signed during the build process and their integrity and origin verified at deployment. </st><span class="No-Break"><em class="italic"><st c="34412">Figure 7</st></em></span><em class="italic"><st c="34420">.19</st></em><st c="34423"> provides a high-level overview of how Notation is integrated into a </st><span class="No-Break"><st c="34492">DevOps workflow.</st></span></p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/B19710_07_19.jpg" alt="Figure 7.19 – How Notation is integrated into a DevOps workflow"/><st c="34508"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="34704">Figure 7.19 – How Notation is integrated into a DevOps workflow</st></p>
			<p><st c="34767">To use </st><a id="_idIndexMarker752"/><st c="34775">Notation, we </st><em class="italic"><st c="34788">first</st></em><st c="34793"> must ensure </st><a id="_idIndexMarker753"/><st c="34806">that it is installed on the runner/agent used for our workflow/pipeline. </st><st c="34879">For GitHub, this can be done using the </st><strong class="source-inline"><st c="34918">notation-action</st></strong><st c="34933"> GitHub marketplace action. </st><st c="34961">Azure DevOps also has a </st><strong class="source-inline"><st c="34985">Notation</st></strong><st c="34993"> marketplace task that we can use for this (</st><span class="No-Break"><em class="italic"><st c="35037">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="35046">.20</st></em></span><span class="No-Break"><st c="35049">).</st></span></p>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/B19710_07_20.jpg" alt="Figure 7.20 – Azure DevOps Notation marketplace task"/><st c="35052"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="35131">Figure 7.20 – Azure DevOps Notation marketplace task</st></p>
			<p><st c="35183">The </st><em class="italic"><st c="35188">second</st></em><st c="35194"> step is to sign our artifact. </st><st c="35225">The Notation task in Azure Pipelines natively supports the Azure Key Vault plugin, which enables the Notation CLI to generate signatures using Azure-Key-Vault-managed certificates and keys (</st><span class="No-Break"><em class="italic"><st c="35415">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="35424">.21</st></em></span><span class="No-Break"><st c="35427">).</st></span></p>
			<div>
				<div id="_idContainer240" class="IMG---Figure">
					<img src="image/B19710_07_21.jpg" alt="Figure 7.21 – Implementing Notation in Azure Pipelines"/><st c="35430"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="35668">Figure 7.21 – Implementing Notation in Azure Pipelines</st></p>
			<p><st c="35722">It supports </st><a id="_idIndexMarker754"/><st c="35735">signing with self-signed </st><a id="_idIndexMarker755"/><st c="35760">certificates and </st><strong class="bold"><st c="35777">Certificate Authority</st></strong><st c="35798"> (</st><strong class="bold"><st c="35800">CA</st></strong><st c="35802">) issued certificates. </st><st c="35826">This can also be done using the </st><strong class="source-inline"><st c="35858">notation sign</st></strong><st c="35871"> command. </st><st c="35881">The </st><a id="_idIndexMarker756"/><st c="35885">third and final step is to verify the signature as part of our pre-deployment checks. </st><st c="35971">Notation supports specifying a Trust Policy file that defines the signature verification levels that we want to enforce. </st><st c="36092">There are four </st><span class="No-Break"><st c="36107">verification levels:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="36127">Strict</st></strong><st c="36134">: This </st><a id="_idIndexMarker757"/><st c="36142">enforces all validations. </st><st c="36168">If any validation fails, the verification fails. </st><st c="36217">Best for build environments or </st><span class="No-Break"><st c="36248">high-assurance deployment.</st></span></li>
				<li><strong class="bold"><st c="36274">Permissive</st></strong><st c="36285">: This </st><a id="_idIndexMarker758"/><st c="36293">conducts most validations but logs issues such as revocation and expiry. </st><st c="36366">Suitable for deployment or runtime when integrity and authenticity </st><span class="No-Break"><st c="36433">are key.</st></span></li>
				<li><strong class="bold"><st c="36441">Audit</st></strong><st c="36447">: Only </st><a id="_idIndexMarker759"/><st c="36455">ensures signature integrity if present; logs other </st><span class="No-Break"><st c="36506">validation failures.</st></span></li>
				<li><strong class="bold"><st c="36526">Skip</st></strong><st c="36531">: This does </st><a id="_idIndexMarker760"/><st c="36544">not perform signature verification. </st><st c="36580">It is used when mixing signed and unsigned artifacts but requires specifying exact registry URLs </st><span class="No-Break"><st c="36677">in registryScopes.</st></span></li>
			</ul>
			<p><span class="No-Break"><em class="italic"><st c="36695">Figure 7</st></em></span><em class="italic"><st c="36704">.22</st></em><st c="36707"> displays </st><a id="_idIndexMarker761"/><st c="36717">the four levels (strict, permissive, audit, and skip) and </st><a id="_idIndexMarker762"/><st c="36775">their </st><span class="No-Break"><st c="36781">respective validations.</st></span></p>
			<div>
				<div id="_idContainer241" class="IMG---Figure">
					<img src="image/B19710_07_22.jpg" alt="Figure 7.22 – Notation’s verification levels"/><st c="36804"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="37310">Figure 7.22 – Notation’s verification levels</st></p>
			<p><st c="37354">To learn </st><a id="_idIndexMarker763"/><st c="37364">more about Notation’s Trust Policy file, please refer to this </st><span class="No-Break"><st c="37426">document: </st></span><a href="https://github.com/notaryproject/specifications/blob/v1.0.0/specs/trust-store-trust-policy.md"><span class="No-Break"><st c="37436">https://github.com/notaryproject/specifications/blob/v1.0.0/specs/trust-store-trust-policy.md</st></span></a><span class="No-Break"><st c="37529">.</st></span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor157"/><st c="37530">Managing secrets securely in the release phase</st></h2>
			<p><st c="37577">In automated build and deployment pipelines, developers may need to supply credentials </st><a id="_idIndexMarker764"/><st c="37665">needed to access internal </st><a id="_idIndexMarker765"/><st c="37691">or external services. </st><st c="37713">For example, a build pipeline task that downloads code from a private repository may require the credentials to be provided. </st><st c="37838">Another task may be to download a package from a private registry and the necessary credentials must be supplied. </st><st c="37952">In a deployment pipeline, a task may </st><em class="italic"><st c="37989">need</st></em><st c="37993"> the credentials to connect to a hosted Kubernetes cluster to deploy the latest version of </st><span class="No-Break"><st c="38084">an application.</st></span></p>
			<p class="callout-heading"><st c="38099">Note</st></p>
			<p class="callout"><st c="38104">A good security best practice is to prioritize the use of workload identities for access instead of secrets. </st><st c="38214">For example, implementing managed identities to access Azure services. </st><st c="38285">Secrets should only be used for scenarios where workload identities are not </st><span class="No-Break"><st c="38361">yet supported.</st></span></p>
			<p><st c="38375">These sensitive credentials should never be stored in plaintext within build or deployment pipeline workflow files. </st><st c="38492">One possible option is to store the credentials as encrypted environment </st><a id="_idIndexMarker766"/><st c="38565">variables. </st><st c="38576">These are referred to as </st><strong class="bold"><st c="38601">secrets</st></strong><st c="38608"> in GitHub </st><a id="_idIndexMarker767"/><st c="38619">Enterprise and </st><strong class="bold"><st c="38634">secret variables</st></strong><st c="38650"> in Azure Pipelines. </st><st c="38671">For our discussion, we will just refer to them </st><span class="No-Break"><st c="38718">as </st></span><span class="No-Break"><em class="italic"><st c="38721">secrets</st></em></span><span class="No-Break"><st c="38728">.</st></span></p>
			<p><st c="38729">In GitHub, secrets can be set at the organization, repository, or repository environment levels. </st><st c="38827">In Azure DevOps, they can be set at the project (using variable groups), pipeline, stage, or job levels. </st><st c="38932">Organization/project-level secrets allow teams to share secrets across multiple workflows or pipelines. </st><st c="39036">This reduces the need to create duplicate secrets across multiple repositories/pipelines. </st><st c="39126">Secrets are encrypted at rest using a 2048-bit RSA key and are accessible on the agent for tasks and scripts </st><span class="No-Break"><st c="39235">to use.</st></span></p>
			<p><st c="39242">On both platforms, users with read permissions cannot read secrets, but those with write permissions to a repository/project can read all secrets. </st><st c="39390">To reduce the risk of a secret leak, we need to be careful about who is granted write access to </st><span class="No-Break"><st c="39486">our repositories/projects.</st></span></p>
			<p><st c="39512">In following zero-trust principles, we need to assume that breaches can happen and only grant the minimum necessary privileges for the secrets in use in workflows/pipelines. </st><st c="39687">This approach reduces the potential impact in case a user with write access is compromised. </st><st c="39779">For example, a secret that is used for deploying applications to a Kubernetes cluster should only have that specific permission. </st><st c="39908">It should not have permission to modify other configurations in </st><span class="No-Break"><st c="39972">the cluster.</st></span></p>
			<p><st c="39984">Both GitHub Actions and Azure Pipelines try to mask secrets in log outputs (</st><span class="No-Break"><em class="italic"><st c="40061">Figure 7</st></em></span><em class="italic"><st c="40070">.23</st></em><st c="40073">). </st><st c="40077">They look for secrets that are printed in plain text on the command line, as well as exact </st><a id="_idIndexMarker768"/><st c="40168">matches of secret values in </st><a id="_idIndexMarker769"/><st c="40196">the logged outputs. </st><st c="40216">However, this process is not perfect. </st><st c="40254">Developers must still exercise caution to prevent </st><span class="No-Break"><st c="40304">accidental exposure.</st></span></p>
			<div>
				<div id="_idContainer242" class="IMG---Figure">
					<img src="image/B19710_07_23.jpg" alt="Figure 7.23 – A masked secret in an Azure Pipeline log"/><st c="40324"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="40819">Figure 7.23 – A masked secret in an Azure Pipeline log</st></p>
			<p><st c="40873">For example, it is not recommended to define a secret value using a structured data format such as JSON, XML, or YAML. </st><st c="40993">This could lead to redaction failures. </st><st c="41032">An example of this is if a secret value is defined as </st><strong class="source-inline"><st c="41086">{"apikey": "secretpass"}</st></strong><st c="41110">; if the exact value is printed to the console in plain text, it may not be masked (</st><span class="No-Break"><em class="italic"><st c="41195">Figure 7</st></em></span><em class="italic"><st c="41204">.24</st></em><st c="41207">). </st><st c="41211">Instead, developers should create individual plain secrets for each sensitive value instead of mapping them in a structured data format, to ensure they are properly masked </st><span class="No-Break"><st c="41383">in logs.</st></span></p>
			<div>
				<div id="_idContainer243" class="IMG---Figure">
					<img src="image/B19710_07_24.jpg" alt="Figure 7.24 – An example of an unmasked secret due to the structured data format"/><st c="41391"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="42036">Figure 7.24 – An example of an unmasked secret due to the structured data format</st></p>
			<p><st c="42116">Also, if a secret is used to generate a sensitive value within a workflow/pipeline, that generated </st><a id="_idIndexMarker770"/><st c="42216">value should be registered as a secret to </st><a id="_idIndexMarker771"/><st c="42258">ensure it is masked if it appears in the logs. </st><st c="42305">For example, a private key may be used to generate a signed </st><strong class="bold"><st c="42365">JSON Web Token</st></strong><st c="42379"> (</st><strong class="bold"><st c="42381">JWT</st></strong><st c="42384">) to access </st><a id="_idIndexMarker772"/><st c="42397">a web API. </st><st c="42408">That JWT should be registered as a secret, or it will not be masked if it is recorded in the workflow/pipeline log output. </st><st c="42531">Similarly, if a secret is transformed in any way, such as being Base64 or URL-encoded, it should also be registered as a secret to ensure it will be masked if it appears in </st><span class="No-Break"><st c="42704">log outputs.</st></span></p>
			<h3><st c="42716">Integrating a secret vault in your DevOps pipelines</st></h3>
			<p><st c="42768">Apart from implementing secrets in our workflows/pipelines, we could also implement processes to </st><a id="_idIndexMarker773"/><st c="42866">centrally manage secrets </st><a id="_idIndexMarker774"/><st c="42891">using a secret management service such as Azure Key Vault or HashiCorp Vault. </st><st c="42969">This is the preferred option as it has the added advantage of scalability, and it allows for the decoupling of secret management from the DevOps platform. </st><st c="43124">As we mentioned previously, a better approach is to transition to using workload identities if supported for </st><span class="No-Break"><st c="43233">your scenario.</st></span></p>
			<p><st c="43247">Azure Key Vault is a secrets management service, a key management service, and a certificate management service. </st><st c="43361">A </st><strong class="bold"><st c="43363">secret</st></strong><st c="43369"> is data under 25 KB (for standard vaults) that can be stored and retrieved in plain text. </st><st c="43460">Examples include passwords, database connection strings, and storage account connection strings. </st><strong class="bold"><st c="43557">Keys</st></strong><st c="43561"> are cryptographic keys (i.e., secrets generated using an algorithm) that can be imported or generated in the vault. </st><st c="43678">Key Vault currently supports RSA and elliptic curve keys. </st><strong class="bold"><st c="43736">Certificates</st></strong><st c="43748"> are self-signed </st><a id="_idIndexMarker775"/><st c="43765">SSL/TLS certificates generated </st><a id="_idIndexMarker776"/><st c="43796">in Key Vault or third-party SSL/TLS certificates that have been imported into the vault. </st><span class="No-Break"><em class="italic"><st c="43885">Figure 7</st></em></span><em class="italic"><st c="43893">.25</st></em><st c="43896"> shows example use cases of these three </st><span class="No-Break"><st c="43936">object types.</st></span></p>
			<div>
				<div id="_idContainer244" class="IMG---Figure">
					<img src="image/B19710_07_25.jpg" alt="Figure 7.25 – Sample Azure Key Vault use cases"/><st c="43949"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="44434">Figure 7.25 – Sample Azure Key Vault use cases</st></p>
			<p><st c="44480">To integrate the Azure Key Vault into our GitHub Action workflows, we can implement the </st><strong class="source-inline"><st c="44569">azure/get-keyvault-secrets</st></strong><st c="44595"> action that is authenticated with a workload identity or a service principal. </st><st c="44674">In an Azure DevOps pipeline, this integration can be done with the </st><strong class="source-inline"><st c="44741">AzureKeyVault</st></strong><st c="44754"> task that uses a service connection that is backed by a managed identity or a service principal (</st><span class="No-Break"><em class="italic"><st c="44852">Figure 7</st></em></span><em class="italic"><st c="44861">.26</st></em><st c="44864">). </st><st c="44868">For both options, we want to make sure that the access is scoped to the secret that is needed. </st><st c="44963">This requires a least privileged </st><span class="No-Break"><st c="44996">access design.</st></span></p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/B19710_07_26.jpg" alt="Figure 7.26 – Sample Azure DevOps integration with Key Vault"/><st c="45010"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="45211">Figure 7.26 – Sample Azure DevOps integration with Key Vault</st></p>
			<p><st c="45271">Now, let us </st><a id="_idIndexMarker777"/><st c="45284">review another best practice </st><a id="_idIndexMarker778"/><st c="45313">regarding securing our build/release environment – </st><span class="No-Break"><st c="45364">implementing auditing.</st></span></p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor158"/><st c="45386">Implementing auditing for the CI/CD environment</st></h2>
			<p><st c="45434">The CIS framework also recommends enabling logging in the build/release environment. </st><st c="45520">This is </st><a id="_idIndexMarker779"/><st c="45528">critical for security </st><a id="_idIndexMarker780"/><st c="45550">monitoring, threat detection, and forensic analysis in the case of an incident. </st><st c="45630">Ideally, logging should be enabled on both the control plane, for management operations, and the </st><span class="No-Break"><st c="45727">data plane.</st></span></p>
			<h3><st c="45738">Enabling and configuring control plane logging</st></h3>
			<p><st c="45785">In </st><strong class="bold"><st c="45789">GitHub Enterprise Cloud</st></strong><st c="45812"> (</st><strong class="bold"><st c="45814">GHEC</st></strong><st c="45818">), we </st><a id="_idIndexMarker781"/><st c="45825">don’t need </st><a id="_idIndexMarker782"/><st c="45836">to do anything to enable control plane audit </st><a id="_idIndexMarker783"/><st c="45881">logs. </st><st c="45887">They are enabled by default. </st><st c="45916">The logs can be </st><a id="_idIndexMarker784"/><st c="45932">viewed at the enterprise level </st><a id="_idIndexMarker785"/><st c="45963">via </st><strong class="bold"><st c="45967">Settings</st></strong><st c="45975"> | </st><strong class="bold"><st c="45978">Audit Log</st></strong><st c="45987"> | </st><strong class="bold"><st c="45990">Events</st></strong><st c="45996">, or at the organization level through </st><strong class="bold"><st c="46035">Organization</st></strong><st c="46047"> | </st><strong class="bold"><st c="46050">Settings</st></strong><st c="46058"> | </st><strong class="bold"><st c="46061">Archive</st></strong><st c="46068"> | </st><strong class="bold"><st c="46071">Logs</st></strong><st c="46075"> | </st><strong class="bold"><st c="46078">Audit Log</st></strong><st c="46087"> | </st><strong class="bold"><st c="46090">Events</st></strong><st c="46096">. By default, only events from the last three months are visible, but events are stored for up to seven months after which they </st><span class="No-Break"><st c="46224">are deleted.</st></span></p>
			<p><st c="46236">The logs </st><a id="_idIndexMarker786"/><st c="46246">capture a range of events </st><a id="_idIndexMarker787"/><st c="46272">including workflow control plane activities categorized under </st><strong class="bold"><st c="46334">org</st></strong><st c="46337"> and </st><strong class="bold"><st c="46342">workflow</st></strong><st c="46350">. This includes actions </st><a id="_idIndexMarker788"/><st c="46374">such as creation, update, deletion, and execution </st><a id="_idIndexMarker789"/><st c="46424">of workflows. </st><st c="46438">A comprehensive list of the audited events is available </st><span class="No-Break"><st c="46494">here: </st></span><a href="https://docs.github.com/en/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization"><span class="No-Break"><st c="46500">https://docs.github.com/en/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization</st></span></a><span class="No-Break"><st c="46661">.</st></span></p>
			<p><st c="46662">For privacy, the audit logs omit the source IP address of events. </st><st c="46729">To add source IP addresses to the audit logs, the adjustment can be made at either the enterprise or </st><span class="No-Break"><st c="46830">organization level:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="46849">Enterprise level</st></strong><st c="46866">: Navigate through </st><strong class="bold"><st c="46886">Enterprise</st></strong><st c="46896"> | </st><strong class="bold"><st c="46899">Settings</st></strong><st c="46907"> | </st><strong class="bold"><st c="46910">Audit Log</st></strong><st c="46919"> | </st><strong class="bold"><st c="46922">Settings</st></strong><st c="46930">. Activate and save the </st><strong class="bold"><st c="46954">Enable source IP </st></strong><span class="No-Break"><strong class="bold"><st c="46971">disclosure</st></strong></span><span class="No-Break"><st c="46981"> option.</st></span></li>
				<li><strong class="bold"><st c="46989">Organization level</st></strong><st c="47008">: Go to </st><strong class="bold"><st c="47017">Organization</st></strong><st c="47029"> | </st><strong class="bold"><st c="47032">Settings</st></strong><st c="47040"> | </st><strong class="bold"><st c="47043">Archive</st></strong><st c="47050"> | </st><strong class="bold"><st c="47053">Logs</st></strong><st c="47057"> | </st><strong class="bold"><st c="47060">Audit Log</st></strong><st c="47069"> | </st><strong class="bold"><st c="47072">Settings</st></strong><st c="47080">. Activate and save the </st><strong class="bold"><st c="47104">Enable source IP </st></strong><span class="No-Break"><strong class="bold"><st c="47121">disclosure</st></strong></span><span class="No-Break"><st c="47131"> option.</st></span></li>
			</ul>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/B19710_07_27.jpg" alt="Figure 7.27 – Enabling source IP recording for audit logs"/><st c="47139"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="47556">Figure 7.27 – Enabling source IP recording for audit logs</st></p>
			<p><st c="47613">To stream the logs externally, maybe to keep them for longer than the maximum retention period, we have the option to stream directly to Amazon S3, Azure Blob Storage, Google </st><a id="_idIndexMarker790"/><st c="47789">Cloud Storage, Splunk, and Datadog. </st><st c="47825">We can </st><a id="_idIndexMarker791"/><st c="47832">also stream to other third-party services via Azure Event </st><a id="_idIndexMarker792"/><st c="47890">Hub. </st><st c="47895">This can </st><a id="_idIndexMarker793"/><st c="47904">be configured at the enterprise level via </st><strong class="bold"><st c="47946">Settings</st></strong><st c="47954"> | </st><strong class="bold"><st c="47957">Audit log</st></strong><st c="47966"> | </st><strong class="bold"><st c="47969">Log streaming</st></strong><st c="47982"> | </st><span class="No-Break"><strong class="bold"><st c="47985">Configure stream</st></strong></span><span class="No-Break"><st c="48001">.</st></span></p>
			<div>
				<div id="_idContainer247" class="IMG---Figure">
					<img src="image/B19710_07_28.jpg" alt="Figure 7.28 – Configuring audit log streaming at the enterprise level"/><st c="48002"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="48291">Figure 7.28 – Configuring audit log streaming at the enterprise level</st></p>
			<p><st c="48360">For Azure Pipelines, control plane logging can be enabled in the organization settings in </st><strong class="bold"><st c="48451">Security</st></strong><st c="48459"> | </st><strong class="bold"><st c="48462">Policies</st></strong><st c="48470"> | </st><strong class="bold"><st c="48473">Security policies</st></strong><st c="48490"> | </st><strong class="bold"><st c="48493">Log </st></strong><span class="No-Break"><strong class="bold"><st c="48497">Audit Events</st></strong></span><span class="No-Break"><st c="48509">.</st></span></p>
			<div>
				<div id="_idContainer248" class="IMG---Figure">
					<img src="image/B19710_07_29.jpg" alt="Figure 7.29 – Enabling audit logging"/><st c="48510"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="48854">Figure 7.29 – Enabling audit logging</st></p>
			<p><st c="48890">Once </st><a id="_idIndexMarker794"/><st c="48896">this setting is enabled, it records multiple events, including </st><a id="_idIndexMarker795"/><st c="48959">Azure Pipeline </st><a id="_idIndexMarker796"/><st c="48974">control plane events </st><a id="_idIndexMarker797"/><st c="48995">such as pipeline creation, modification, deletion, and </st><a id="_idIndexMarker798"/><st c="49050">execution. </st><st c="49061">The full list of pipeline events that are audited can be found </st><span class="No-Break"><st c="49124">here: </st></span><a href="https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops#pipelines"><span class="No-Break"><st c="49130">https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops#pipelines</st></span></a><span class="No-Break"><st c="49240">.</st></span></p>
			<p><st c="49241">Once enabled, the events can be viewed in </st><strong class="bold"><st c="49284">Organization Settings</st></strong><st c="49305"> | </st><strong class="bold"><st c="49308">General</st></strong><st c="49315"> | </st><strong class="bold"><st c="49318">Auditing</st></strong><st c="49326"> | </st><strong class="bold"><st c="49329">Logs</st></strong><st c="49333">. The events are stored for 90 days, after which they </st><span class="No-Break"><st c="49387">are deleted.</st></span></p>
			<p><st c="49399">They collect the logs in a centralized log store where we can keep them for longer, and we can configure audit streams in </st><strong class="bold"><st c="49522">Organization Settings</st></strong><st c="49543"> | </st><strong class="bold"><st c="49546">General</st></strong><st c="49553"> | </st><strong class="bold"><st c="49556">Auditing</st></strong><st c="49564"> | </st><strong class="bold"><st c="49567">Streams</st></strong><st c="49574"> | </st><strong class="bold"><st c="49577">New stream</st></strong><st c="49587">, where we have the option to export the logs to Azure Monitor, Splunk, or other third-party solutions via Azure </st><span class="No-Break"><st c="49700">Event Grid.</st></span></p>
			<div>
				<div id="_idContainer249" class="IMG---Figure">
					<img src="image/B19710_07_30.jpg" alt="Figure 7.30 – Azure DevOps audit stream options"/><st c="49711"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="49913">Figure 7.30 – Azure DevOps audit stream options</st></p>
			<h3><st c="49960">Enabling and configuring data plane logging</st></h3>
			<p><st c="50004">GHEC </st><a id="_idIndexMarker799"/><st c="50010">workflow run logs (build environment data plane logs) are also </st><a id="_idIndexMarker800"/><st c="50073">enabled by default and retained for 90 days </st><a id="_idIndexMarker801"/><st c="50117">by default. </st><st c="50129">The retention </st><a id="_idIndexMarker802"/><st c="50143">settings can be adjusted to a maximum of 400 days at the enterprise, organization, or </st><span class="No-Break"><st c="50229">repository levels:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="50247">Enterprise level</st></strong><st c="50264">: Navigate through </st><strong class="bold"><st c="50284">Enterprise</st></strong><st c="50294"> | </st><strong class="bold"><st c="50297">Settings</st></strong><st c="50305"> | </st><strong class="bold"><st c="50308">Policies</st></strong><st c="50316"> | </st><strong class="bold"><st c="50319">Actions</st></strong><st c="50326"> | </st><strong class="bold"><st c="50329">Artifact and log retention</st></strong><st c="50355">. Set the retention days and </st><span class="No-Break"><st c="50384">click </st></span><span class="No-Break"><strong class="bold"><st c="50390">Save</st></strong></span><span class="No-Break"><st c="50394">.</st></span></li>
				<li><strong class="bold"><st c="50395">Organization level</st></strong><st c="50414">: Go to </st><strong class="bold"><st c="50423">Organization</st></strong><st c="50435"> | </st><strong class="bold"><st c="50438">Settings</st></strong><st c="50446"> | </st><strong class="bold"><st c="50449">Code, planning, and automation</st></strong><st c="50479"> | </st><strong class="bold"><st c="50482">Artifact and log retention</st></strong><st c="50508">. Set the retention days and </st><span class="No-Break"><st c="50537">click </st></span><span class="No-Break"><strong class="bold"><st c="50543">Save</st></strong></span><span class="No-Break"><st c="50547">.</st></span></li>
				<li><strong class="bold"><st c="50548">Repository level</st></strong><st c="50565">: Go to </st><strong class="bold"><st c="50574">Repository</st></strong><st c="50584"> | </st><strong class="bold"><st c="50587">Settings</st></strong><st c="50595"> | </st><strong class="bold"><st c="50598">Code and automation</st></strong><st c="50617"> | </st><strong class="bold"><st c="50620">Actions</st></strong><st c="50627"> | </st><strong class="bold"><st c="50630">General</st></strong><st c="50637"> | </st><strong class="bold"><st c="50640">Artifact and log retention</st></strong><st c="50666">. Set the retention days and </st><span class="No-Break"><st c="50695">click </st></span><span class="No-Break"><strong class="bold"><st c="50701">Save</st></strong></span><span class="No-Break"><st c="50705">.</st></span></li>
			</ul>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/B19710_07_31.jpg" alt="Figure 7.31 – Configuring workflow log retention policy in GitHub"/><st c="50706"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="50980">Figure 7.31 – Configuring workflow log retention policy in GitHub</st></p>
			<p><st c="51045">Azure </st><a id="_idIndexMarker803"/><st c="51052">Pipelines build logs are also enabled by default and retained </st><a id="_idIndexMarker804"/><st c="51114">for 30 days by default. </st><st c="51138">The </st><a id="_idIndexMarker805"/><st c="51142">retention settings </st><a id="_idIndexMarker806"/><st c="51161">can be adjusted via </st><strong class="bold"><st c="51181">Project Settings</st></strong><st c="51197"> | </st><strong class="bold"><st c="51200">Pipelines</st></strong><st c="51209"> | </st><strong class="bold"><st c="51212">Settings</st></strong><st c="51220"> | </st><strong class="bold"><st c="51223">Retention policy</st></strong><st c="51239"> | </st><strong class="bold"><st c="51242">Days to </st></strong><span class="No-Break"><strong class="bold"><st c="51250">keep runs</st></strong></span><span class="No-Break"><st c="51259">.</st></span></p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="image/B19710_07_32.jpg" alt="Figure 7.32 – Configuring retention policy in Azure DevOps project settings"/><st c="51260"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="51593">Figure 7.32 – Configuring retention policy in Azure DevOps project settings</st></p>
			<p><st c="51668">Let’s now learn about </st><span class="No-Break"><st c="51691">security gates.</st></span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor159"/><st c="51706">Implementing security gates in release pipelines</st></h1>
			<p><st c="51755">Gates are </st><a id="_idIndexMarker807"/><st c="51766">important components </st><a id="_idIndexMarker808"/><st c="51787">of software release pipelines. </st><st c="51818">They act as quality checkpoints that software must pass before moving to the next stage of deployment. </st><st c="51921">Their main objective use case is to reduce the likelihood of deploying poor quality software that fails to meet agreed performance and </st><span class="No-Break"><st c="52056">quality standards.</st></span></p>
			<p><st c="52074">For example, a development team might deploy software or updates to a test environment, run automated load and functional tests using tools such as Azure Load Testing </st><a id="_idIndexMarker809"/><st c="52242">and Selenium, and review </st><a id="_idIndexMarker810"/><st c="52267">the results in </st><span class="No-Break"><st c="52282">Azure Monitor.</st></span></p>
			<p><st c="52296">If the </st><a id="_idIndexMarker811"/><st c="52304">software meets the agreed </st><strong class="bold"><st c="52330">service-level agreements</st></strong><st c="52354"> (</st><strong class="bold"><st c="52356">SLAs</st></strong><st c="52360">), it is deployed to the next stage. </st><st c="52398">If it does not meet the SLAs, the deployment stops, and the telemetry data is collected for the team to investigate and resolve the issues (</st><span class="No-Break"><em class="italic"><st c="52538">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="52547">.33</st></em></span><span class="No-Break"><st c="52550">).</st></span></p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="image/B19710_07_33.jpg" alt="Figure 7.33 – Sample quality gate testing in a release pipeline"/><st c="52553"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="52807">Figure 7.33 – Sample quality gate testing in a release pipeline</st></p>
			<p><st c="52870">DevSecOps extends the use of gates to include the validation of security (security gates) – see </st><span class="No-Break"><em class="italic"><st c="52967">Figure 7</st></em></span><em class="italic"><st c="52975">.34</st></em><st c="52978">. The goal of a security gate is to prevent the most critical software risks from being deployed to production or other environments with higher </st><span class="No-Break"><st c="53123">exploitation risks.</st></span></p>
			<div>
				<div id="_idContainer253" class="IMG---Figure">
					<img src="image/B19710_07_34.jpg" alt="Figure 7.34 – Sample security gate testing in a release pipeline"/><st c="53142"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="53432">Figure 7.34 – Sample security gate testing in a release pipeline</st></p>
			<p><st c="53496">Security gates </st><a id="_idIndexMarker812"/><st c="53512">in release pipelines vary based on project needs. </st><strong class="bold"><st c="53562">Dynamic application security testing</st></strong><st c="53598"> (</st><strong class="bold"><st c="53600">DAST</st></strong><st c="53604">) gates use tools such as OWASP ZAP, Burp Suite, and Acunetix to test running applications in a pre-production environment. </st><st c="53729">These tools check for issues such as API security, SSL/TLS configuration, and </st><a id="_idIndexMarker813"/><st c="53807">authentication. </st><strong class="bold"><st c="53823">Compliance gates</st></strong><st c="53839"> ensure regulatory </st><a id="_idIndexMarker814"/><st c="53858">standards are met, while </st><strong class="bold"><st c="53883">penetration testing gates</st></strong><st c="53908"> simulate cyberattacks to </st><span class="No-Break"><st c="53934">find vulnerabilities.</st></span></p>
			<p><st c="53955">Effective security gates require balancing thorough security checks while maintaining development speed. </st><st c="54061">Start with the most critical checks that offer the most value and expand gradually. </st><st c="54145">To determine the most critical checks, begin with the major issues currently seen in production and implement checks to prevent these from reaching production. </st><st c="54305">Continuously refine your process based on feedback and evolving </st><span class="No-Break"><st c="54369">security threats.</st></span></p>
			<p><st c="54386">Regarding maintaining development speed, security gates should be automated as much as possible to avoid slowing down the software release process. </st><st c="54535">If security gates are used to stop non-compliant software from being deployed to production, it is recommended to implement a well-governed manual override process. </st><st c="54700">This should require a minimum of two manual approvers to prevent it from being abused as a security bypass and to ensure that only business-accepted risks are </st><span class="No-Break"><st c="54859">allowed through.</st></span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor160"/><st c="54875">Implementing DAST as security gates</st></h2>
			<p><st c="54911">Unlike the </st><a id="_idIndexMarker815"/><st c="54923">security assessments covered in previous chapters, DAST identifies security issues while an application is running. </st><st c="55039">It is a great </st><a id="_idIndexMarker816"/><st c="55053">complement to </st><strong class="bold"><st c="55067">static application security testing</st></strong><st c="55102"> (</st><strong class="bold"><st c="55104">SAST</st></strong><st c="55108">) and SCA assessments as it can detect runtime issues that may not be apparent in the code alone. </st><st c="55207">It does this by simulating attacks against a running application. </st><st c="55273">For example, a DAST tool may crawl a running web application </st><a id="_idIndexMarker817"/><st c="55334">and send malformed inputs to identify issues such as SQL injection, </st><strong class="bold"><st c="55402">cross-site scripting</st></strong><st c="55422"> (</st><strong class="bold"><st c="55424">XSS</st></strong><st c="55427">), and insecure direct </st><span class="No-Break"><st c="55451">object references.</st></span></p>
			<p><st c="55469">Integrating DAST into a project that follows a DevOps process in a way that does not impact users requires an understanding of the deployment strategy and collaborating with the pipeline development teams. </st><st c="55676">The deployment strategy influences the types of tests and the approach to implementing them. </st><st c="55769">For example, the traditional application deployment strategy involves releasing it into a </st><em class="italic"><st c="55859">test</st></em><st c="55863"> environment, and then into a </st><em class="italic"><st c="55893">staging</st></em><st c="55900"> environment before going to </st><em class="italic"><st c="55929">production</st></em><st c="55939">. Test and staging deployments are ideal points for integrating a continuous </st><span class="No-Break"><st c="56016">DAST process.</st></span></p>
			<p><st c="56029">There are </st><a id="_idIndexMarker818"/><st c="56040">modern deployment strategies embraced by DevOps teams that allow for more frequent deployments to production and sometimes even testing in production. </st><st c="56191">Strategies such as deployment rings, Canary releases, </st><strong class="bold"><st c="56245">dark launching</st></strong><st c="56259">, and A/B </st><a id="_idIndexMarker819"/><st c="56269">testing fall into this category. </st><st c="56302">The main thing to keep in mind when integrating DAST with these strategies is that tests should be conducted in a production-like but non-production environment to ensure accurate results while protecting the data in the </st><span class="No-Break"><st c="56523">production environment.</st></span></p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor161"/><st c="56546">Challenges of implementing DAST in a DevOps process</st></h2>
			<p><st c="56598">The effectiveness of a DAST tool is tied to the types of tests it can perform automatically. </st><st c="56692">This may sound simple, but there are many nuances. </st><st c="56743">For example, the tests for </st><a id="_idIndexMarker820"/><st c="56770">a web application differ </st><a id="_idIndexMarker821"/><st c="56795">from those for an API application, which in turn differ from those for a generative AI app implementing a </st><strong class="bold"><st c="56901">retrieval-augmented generation</st></strong><st c="56931"> (</st><strong class="bold"><st c="56933">RAG</st></strong><st c="56936">) workflow. </st><st c="56949">If a DAST tool only supports attacks </st><a id="_idIndexMarker822"/><st c="56986">against web and API applications, it may not add much value for other types of applications. </st><st c="57079">Don’t integrate DAST just for the sake of integration. </st><st c="57134">The value must be clearly defined, as there is a velocity cost. </st><st c="57198">Ensure that the benefits of DAST outweigh the impact on development speed and efficiency. </st><st c="57288">Properly assess the specific security needs and potential vulnerabilities of the application to determine whether DAST integration </st><span class="No-Break"><st c="57419">is worthwhile.</st></span></p>
			<p><st c="57433">The majority of existing DAST tools focus on testing web applications. </st><st c="57505">While many organizations have web-based apps, other types of applications may not be covered. </st><st c="57599">Most DAST solutions test only the exposed HTTP and HTML interfaces of web-enabled applications. </st><st c="57695">However, some </st><a id="_idIndexMarker823"/><st c="57709">solutions are designed specifically for non-web protocols and data malformation, such as </st><strong class="bold"><st c="57798">remote procedure </st></strong><span class="No-Break"><strong class="bold"><st c="57815">calls</st></strong></span><span class="No-Break"><st c="57820"> (</st></span><span class="No-Break"><strong class="bold"><st c="57822">RPC</st></strong></span><span class="No-Break"><st c="57825">).</st></span></p>
			<p><st c="57828">Another challenge is that while DAST has existed for a while, most tools were created for use by security teams within legacy processes. </st><st c="57966">Modern DAST solutions, however, are built from the ground up for developers, QA, and DevOps professionals, making the tooling and its outputs more relatable and accessible to them. </st><st c="58147">One of the key features of modern DAST solutions is the flexibility of deployment, including containerized or agent-based scanners and options for both cloud and </st><span class="No-Break"><st c="58309">self-hosted reporting.</st></span></p>
			<p><st c="58331">Remediation is another area of challenge. </st><st c="58374">Remediation guidance from DAST tools may not be contextual. </st><st c="58434">For example, a DAST tool may identify a SQL injection vulnerability in a running application, but it may not be able to identify the line of code that developers need to </st><a id="_idIndexMarker824"/><st c="58604">change to fix the issue. </st><st c="58629">This is where another tooling category, </st><strong class="bold"><st c="58669">interactive application security testing</st></strong><st c="58709"> (</st><strong class="bold"><st c="58711">IAST</st></strong><st c="58715">), can help. </st><st c="58729">IAST combines the security functions of SAST and DAST into one tool and provides more actionable insights </st><span class="No-Break"><st c="58835">for developers.</st></span></p>
			<p><st c="58850">Even </st><a id="_idIndexMarker825"/><st c="58856">though both IAST and DAST </st><a id="_idIndexMarker826"/><st c="58882">focus on application behavior during runtime, IAST offers a more comprehensive analysis by combining internal application flow analysis, scanning, and black-box testing. </st><st c="59052">This enables IAST to link findings similar to those in DAST directly to the source code. </st><st c="59141">It achieves this by analyzing the code executed in tests and pinpointing the exact location of vulnerabilities in the code. </st><st c="59265">However, as a relatively new approach to application security, IAST has its drawbacks. </st><st c="59352">It is dependent on the programming language and can slow down the </st><span class="No-Break"><st c="59418">CI pipeline.</st></span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor162"/><st c="59430">Implementing security gates in Azure Pipelines and GitHub Actions</st></h2>
			<p><st c="59496">In Azure Pipelines, release strategies are set up as </st><strong class="bold"><st c="59550">stages</st></strong><st c="59556"> in a release pipeline. </st><st c="59580">For classic </st><a id="_idIndexMarker827"/><st c="59592">pipelines, quality gates are defined </st><a id="_idIndexMarker828"/><st c="59629">using pre-deployment </st><a id="_idIndexMarker829"/><st c="59650">and post-deployment </st><a id="_idIndexMarker830"/><st c="59670">conditions for each </st><a id="_idIndexMarker831"/><st c="59690">stage. </st><strong class="bold"><st c="59697">Pre-deployment conditions</st></strong><st c="59722"> are checks and validations that must be satisfied before a deployment stage can start. </st><st c="59810">They serve as </st><a id="_idIndexMarker832"/><st c="59824">gatekeepers to ensure that quality criteria are met before the deployment begins. </st><strong class="bold"><st c="59906">Post-deployment conditions</st></strong><st c="59932"> are checks that happen after a deployment has completed and before it proceeds to the next stage. </st><st c="60031">They are used to verify that the deployment did not introduce any new issues and that the application is functioning correctly. </st><st c="60159">To implement them, follow </st><span class="No-Break"><st c="60185">these steps:</st></span></p>
			<ol>
				<li><st c="60197">In Azure Pipelines, navigate to </st><strong class="bold"><st c="60230">Pipelines</st></strong><st c="60239"> | </st><span class="No-Break"><strong class="bold"><st c="60242">Releases</st></strong></span><span class="No-Break"><st c="60250">.</st></span></li>
				<li><st c="60251">Select the relevant </st><span class="No-Break"><st c="60272">release pipeline.</st></span></li>
				<li><st c="60289">Choose either pre-deployment or post-deployment conditions for the release stage (</st><span class="No-Break"><em class="italic"><st c="60372">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="60381">.35</st></em></span><span class="No-Break"><st c="60384">).</st></span></li>
				<li><st c="60387">Under </st><strong class="bold"><st c="60394">Gates</st></strong><st c="60399">, click </st><strong class="bold"><st c="60407">Add</st></strong><st c="60410"> to configure your release </st><span class="No-Break"><st c="60437">gate settings.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer254" class="IMG---Figure">
					<img src="image/B19710_07_35.jpg" alt="Figure 7.35 – Configuring pre-deployment or post-deployment conditions"/><st c="60451"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="61390">Figure 7.35 – Configuring pre-deployment or post-deployment conditions</st></p>
			<p><st c="61460">GitHub </st><a id="_idIndexMarker833"/><st c="61468">Actions offers a similar functionality </st><a id="_idIndexMarker834"/><st c="61507">with environments, which </st><a id="_idIndexMarker835"/><st c="61532">can have protection rules </st><a id="_idIndexMarker836"/><st c="61558">that serve as release gates. </st><st c="61587">For instance, a workflow in GitHub can include a job that must be manually approved by designated reviewers before the deployment can proceed to the next environment. </st><st c="61754">This is particularly useful for workflows that deploy to multiple stages, such as staging and production. </st><st c="61860">Each stage can have its own set of rules that are enforced by these gates. </st><st c="61935">To read more about environments and protection rules, please refer to this </st><span class="No-Break"><st c="62010">document: </st></span><a href="https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#custom-deployment-protection-rules"><span class="No-Break"><st c="62020">https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment#custom-deployment-protection-rules</st></span></a><span class="No-Break"><st c="62167">.</st></span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor163"/><st c="62168">Hands-on exercise – Integrating security within the build and test phases</st></h1>
			<p><st c="62242">In this </st><a id="_idIndexMarker837"/><st c="62251">exercise, we will be integrating security </st><a id="_idIndexMarker838"/><st c="62293">within the build and test phases of our pipeline. </st><st c="62343">We will practically implement artifact signing for integrity and implement DAST </st><span class="No-Break"><st c="62423">using ZAP.</st></span></p>
			<p><st c="62433">The following are the tasks for </st><span class="No-Break"><st c="62466">this exercise:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="62480">Task </st></strong><strong class="bold"><st c="62486">1 –</st></strong><st c="62489"> Implementing artifact signing for </st><span class="No-Break"><st c="62524">integrity checks</st></span></li>
				<li><strong class="bold"><st c="62540">Task </st></strong><strong class="bold"><st c="62546">2 –</st></strong><st c="62549"> Integrating DAST tools to find and fix security vulnerabilities in the </st><span class="No-Break"><st c="62621">test</st></span><span class="No-Break"><st c="62625"> phase</st></span></li>
			</ul>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor164"/><st c="62631">Prerequisites</st></h2>
			<p><st c="62645">Before diving </st><a id="_idIndexMarker839"/><st c="62660">into the first task, let’s first create a key vault in Azure Key Vault then generate a self-signed key and certificate. </st><st c="62780">This is what we will use later to sign the image </st><span class="No-Break"><st c="62829">with Notation.</st></span></p>
			<ol>
				<li><st c="62843">Navigate to your Azure portal </st><span class="No-Break"><st c="62874">at </st></span><a href="https://portal.azure.com"><span class="No-Break"><st c="62877">https://portal.azure.com</st></span></a><span class="No-Break"><st c="62901">.</st></span></li>
				<li><st c="62902">Search for </st><strong class="source-inline"><st c="62914">key vaults</st></strong><st c="62924"> in the search bar and select </st><span class="No-Break"><strong class="bold"><st c="62954">Key vaults</st></strong></span><span class="No-Break"><st c="62964">.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer255" class="IMG---Figure">
					<img src="image/B19710_07_36.jpg" alt="Figure 7.36 – Search and select Key vaults"/><st c="62965"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="63210">Figure 7.36 – Search and select Key vaults</st></p>
			<ol>
				<li value="3"><st c="63252">Click on </st><strong class="bold"><st c="63262">Create</st></strong><st c="63268"> and fill in the required details, click </st><strong class="bold"><st c="63309">Review + create</st></strong><st c="63324">, and then </st><span class="No-Break"><st c="63335">click </st></span><span class="No-Break"><strong class="bold"><st c="63341">Create</st></strong></span><span class="No-Break"><st c="63347">.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer256" class="IMG---Figure">
					<img src="image/B19710_07_37.jpg" alt="Figure 7.37 – Create a key vault"/><st c="63348"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="65266">Figure 7.37 – Create a key vault</st></p>
			<ol>
				<li value="4"><st c="65298">Now that we’ve created the key vault, let’s now create a self-signed certificate using Azure CLI. </st><st c="65397">First, create a certificate policy file which, when executed, creates a </st><a id="_idIndexMarker840"/><st c="65469">valid certificate compatible with Notation. </st><st c="65513">Copy the following code into Azure CLI bash terminal to create the policy file. </st><st c="65593">Copy this </st><span class="No-Break"><st c="65603">from </st></span><a href="https://github.com/PacktPublishing/eShopOnWeb/blob/main/policy.txt"><span class="No-Break"><st c="65608">https://github.com/PacktPublishing/eShopOnWeb/blob/main/policy.txt</st></span></a><span class="No-Break"><st c="65674">.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer257" class="IMG---Figure">
					<img src="image/B19710_07_38.jpg" alt="Figure 7.38 – Content of certificate policy file"/><st c="65675"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="66078">Figure 7.38 – Content of certificate policy file</st></p>
			<ol>
				<li value="5"><st c="66126">Create the certificate by pasting the following command to your </st><span class="No-Break"><st c="66191">Bash terminal</st></span><span class="No-Break"><st c="66204">:</st></span><pre class="source-code"><st c="66206">
az keyvault certificate create -n </st><strong class="bold"><st c="66241">test-io</st></strong><st c="66248"> --vault-name </st><strong class="bold"><st c="66262">devsecopsKeyVaultTest</st></strong><st c="66283"> -p @my_policy.json</st></pre><p class="list-inset"><st c="66302">Remember to </st><a id="_idIndexMarker841"/><st c="66315">change the key vault name to the one created in </st><em class="italic"><st c="66363">step 3</st></em><st c="66369">. </st><span class="No-Break"><em class="italic"><st c="66371">Figure 7</st></em></span><em class="italic"><st c="66379">.39</st></em><st c="66382"> shows the successful creation of a </st><span class="No-Break"><st c="66418">self-signed certificate.</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer258" class="IMG---Figure">
					<img src="image/B19710_07_39.jpg" alt="Figure 7.39 – Create a self-signed certificate"/><st c="66442"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="67677">Figure 7.39 – Create a self-signed certificate</st></p>
			<ol>
				<li value="6"><st c="67723">Let’s confirm the certificate was created by going to your key vault then navigate to </st><strong class="bold"><st c="67810">Objects</st></strong><st c="67817"> and then click on </st><strong class="bold"><st c="67836">Certificates</st></strong><st c="67848">. You will find the just created </st><span class="No-Break"><st c="67881">certificate here.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer259" class="IMG---Figure">
					<img src="image/B19710_07_40.jpg" alt="Figure 7.40 – Self-signed certificate (test-io) created"/><st c="67898"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="68347">Figure 7.40 – Self-signed certificate (test-io) created</st></p>
			<p class="list-inset"><st c="68402">In </st><a href="B19710_06.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic"><st c="68406">Chapter 6</st></em></span></a><st c="68415">, hands on </st><em class="italic"><st c="68426">Exercise 1 – Integrating SAST, SCA, and secret scanning into the build process</st></em><st c="68504"> section, we ran </st><strong class="source-inline"><st c="68521">azure-pipelines.yml</st></strong><st c="68540"> which built and deployed the docker image. </st><st c="68584">Several resources were created including a </st><a id="_idIndexMarker842"/><st c="68627">container registry. </st><st c="68647">Several access permissions need to be set before configuring the notation task to sign the </st><span class="No-Break"><st c="68738">image created.</st></span></p>
			<ol>
				<li value="7"><st c="68752">Let’s first </st><a id="_idIndexMarker843"/><st c="68765">authorize access to the </st><strong class="bold"><st c="68789">Azure Container Registry (ACR)</st></strong><st c="68819"> and </st><strong class="bold"><st c="68824">Azure Key Vault (AKV)</st></strong><st c="68845">. Two roles are required </st><a id="_idIndexMarker844"/><st c="68870">for signing container images in ACR; </st><strong class="source-inline"><st c="68907">AcrPull</st></strong><st c="68914"> and </st><strong class="source-inline"><st c="68919">AcrPush</st></strong><st c="68926">. Let’s configure ACR and AKV environment variables on Azure CLI </st><span class="No-Break"><st c="68991">Bash terminal.</st></span><pre class="source-code"><st c="69005">
ACR_SUB_ID=myACRSubscriptionId
ACR_RG=myAcrResourceGroup
ACR_NAME=myregistry
AKV_SUB_ID=myAKVSubscriptionId
AKV_RG=myAkvResourceGroup
AKV_NAME=myAKV</st></pre></li>				<li><st c="69154">Authorize access to ACR by first setting the subscription that contains the </st><span class="No-Break"><st c="69231">ACR resource.</st></span><pre class="source-code"><st c="69244">
az account set --subscription $ACR_SUB_ID</st></pre><p class="list-inset"><st c="69286">Then assign </st><a id="_idIndexMarker845"/><st c="69299">the </st><strong class="source-inline"><st c="69303">AcrPull</st></strong><st c="69310"> and </st><strong class="source-inline"><st c="69315">AcrPush</st></strong><st c="69322"> roles using the </st><span class="No-Break"><st c="69339">following commands:</st></span></p><pre class="source-code"><st c="69358">USER_ID=$(az ad signed-in-user show --query id -o tsv)</st></pre><p class="list-inset"><span class="No-Break"><st c="69413">and</st></span></p><pre class="source-code"><st c="69417">az role assignment create --role "AcrPull" --role "AcrPush" --assignee $USER_ID --scope "/subscriptions/$ACR_SUB_ID/resourceGroups/$ACR_RG/providers/Microsoft.ContainerRegistry/registries/$ACR_NAME"</st></pre></li>				<li><st c="69616">Let’s now authorize access to AKV where the following roles are required for signing using </st><span class="No-Break"><st c="69708">self-signed certificates:</st></span><ul><li><strong class="bold"><st c="69733">Key Vault Certificates Officer</st></strong><st c="69764"> for creating and </st><span class="No-Break"><st c="69782">reading certificates</st></span></li><li><strong class="bold"><st c="69802">Key Vault Certificates User</st></strong><st c="69830"> for reading </st><span class="No-Break"><st c="69843">existing certificates</st></span></li><li><strong class="bold"><st c="69864">Key Vault Crypto User</st></strong><st c="69886"> for </st><span class="No-Break"><st c="69891">signing operations</st></span></li></ul><p class="list-inset"><st c="69909">First set the subscription that contains the AKV resource using </st><span class="No-Break"><st c="69974">the command:</st></span></p><pre class="source-code"><st c="69986">
az account set --subscription $AKV_SUB_ID</st></pre><p class="list-inset"><st c="70028">Then assign the required roles using </st><span class="No-Break"><st c="70066">the commands:</st></span></p><pre class="source-code"><st c="70079">USER_ID=$(az ad signed-in-user show --query id -o tsv)</st></pre><p class="list-inset"><span class="No-Break"><st c="70134">and</st></span></p><pre class="source-code"><st c="70138">az role assignment create --role "Key Vault Certificates Officer" --role "Key Vault Crypto User" --assignee $USER_ID --scope "/subscriptions/$AKV_SUB_ID/resourceGroups/$AKV_RG/providers/Microsoft.KeyVault/vaults/$AKV_NAME"</st></pre></li>				<li><st c="70361">Now let’s </st><a id="_idIndexMarker846"/><st c="70372">create the Docker Registry service connection. </st><st c="70419">To sign the images using notation, we will use the Docker task in Azure Pipelines to log into the ACR. </st><st c="70522">This task allows you to build, push and pull </st><span class="No-Break"><st c="70567">Docker images.</st></span></li>
				<li><st c="70581">Navigate to </st><strong class="bold"><st c="70594">Project Settings</st></strong><st c="70610"> and then </st><span class="No-Break"><strong class="bold"><st c="70620">Service connections</st></strong></span><span class="No-Break"><st c="70639">.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer260" class="IMG---Figure">
					<img src="image/B19710_07_41.jpg" alt="Figure 7.41 – Setting service connections"/><st c="70640"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="70975">Figure 7.41 – Setting service connections</st></p>
			<ol>
				<li value="12"><st c="71016">Choose </st><strong class="bold"><st c="71024">New service connection</st></strong><st c="71046"> and select </st><span class="No-Break"><strong class="bold"><st c="71058">Docker Registry</st></strong></span><span class="No-Break"><st c="71073">.</st></span></li>
				<li><st c="71074">Next choose </st><strong class="bold"><st c="71087">Azure </st></strong><span class="No-Break"><strong class="bold"><st c="71093">Container Registry</st></strong></span><span class="No-Break"><st c="71111">.</st></span></li>
				<li><st c="71112">Select </st><strong class="bold"><st c="71120">Service Principal</st></strong><st c="71137"> in the </st><strong class="bold"><st c="71145">Authentication Type</st></strong><st c="71164"> field and enter the service </st><a id="_idIndexMarker847"/><st c="71193">principal details including your Azure Subscription and </st><span class="No-Break"><st c="71249">ACR registry.</st></span></li>
				<li><st c="71262">Enter the </st><strong class="bold"><st c="71273">Service connection name</st></strong><st c="71296"> to use when referring to this service connection as shown in the </st><span class="No-Break"><st c="71362">following figure:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer261" class="IMG---Figure">
					<img src="image/B19710_07_42.jpg" alt="Figure 7.42 – Setting Docker Registry service connection"/><st c="71379"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="71743">Figure 7.42 – Setting Docker Registry service connection</st></p>
			<ol>
				<li value="16"><st c="71799">The last </st><a id="_idIndexMarker848"/><st c="71809">bit of access needed is to grant Azure Key Vault access policy to your </st><span class="No-Break"><st c="71880">service principal.</st></span></li>
				<li><st c="71898">Open the Azure Resource Manager service connection you created and click on </st><strong class="bold"><st c="71975">Manage Service Principal</st></strong><st c="71999"> to access the Azure service </st><span class="No-Break"><st c="72028">principal portal.</st></span></li>
				<li><st c="72045">Copy the </st><strong class="bold"><st c="72055">Application (client) ID</st></strong><st c="72078">. This ID will be used to grant permissions to the </st><span class="No-Break"><st c="72129">service principal.</st></span></li>
				<li><st c="72147">Navigate to the </st><strong class="bold"><st c="72164">Azure Key Vault</st></strong><st c="72179"> portal and go to the </st><strong class="bold"><st c="72201">Access </st></strong><span class="No-Break"><strong class="bold"><st c="72208">Policies</st></strong></span><span class="No-Break"><st c="72216"> page.</st></span></li>
				<li><st c="72222">Create a new access policy with the following permissions: key sign, secret get, and </st><span class="No-Break"><st c="72308">certificate get.</st></span></li>
				<li><st c="72324">Assign this </st><a id="_idIndexMarker849"/><st c="72337">new access policy to a service principal using the </st><strong class="bold"><st c="72388">Application (client) ID </st></strong><st c="72412">you </st><span class="No-Break"><st c="72416">copied earlier.</st></span></li>
				<li><st c="72431">Save the changes to complete </st><span class="No-Break"><st c="72461">the setup.</st></span></li>
			</ol>
			<p><st c="72471">Now that we've met the prerequisites, we can begin with </st><span class="No-Break"><st c="72528">the tasks.</st></span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor165"/><st c="72538">Task 1 – Implementing artifact signing for integrity checks</st></h2>
			<p><st c="72598">In this task, we will be signing our artifacts using Notation to enforce authenticity and integrity </st><a id="_idIndexMarker850"/><st c="72699">validation for all release artifacts, including container images, by adding a digital signature </st><a id="_idIndexMarker851"/><st c="72795">that will be validated during </st><a id="_idIndexMarker852"/><st c="72825">deployment. </st><st c="72837">The signature is used to verify that the artifact is from a trusted publisher and no modification has been made. </st><st c="72950">This prevents tampering of packages and artifacts meant for production like in the CodeCov incident we </st><span class="No-Break"><st c="73053">covered earlier.</st></span></p>
			<p><st c="73069">Let’s implement artifact signing </st><span class="No-Break"><st c="73103">using Notation:</st></span></p>
			<ol>
				<li><st c="73118">Navigate to your DevOps instance at </st><a href="https://dev.azure.com"><st c="73155">https://dev.azure.com</st></a><st c="73176"> and choose the organization you used in the </st><span class="No-Break"><st c="73221">previous chapter.</st></span></li>
				<li><st c="73238">Select the </st><strong class="bold"><st c="73250">eShopOnWeb</st></strong><st c="73260"> private project we were using in the </st><span class="No-Break"><st c="73298">previous chapter.</st></span></li>
				<li><st c="73315">Azure DevOps has a </st><strong class="bold"><st c="73335">Notation</st></strong><st c="73343"> task that we can use for this task. </st><st c="73380">There is an option of Notation CLI. </st><st c="73416">Navigate to </st><strong class="bold"><st c="73428">Pipeline</st></strong><st c="73436"> | </st><strong class="bold"><st c="73439">Pipelines</st></strong><st c="73448"> and edit the pipeline we have been working on (</st><strong class="source-inline"><st c="73496">azure-pipelines.yml</st></strong><st c="73516">). </st><st c="73520">Click on the pipeline editing panel and search </st><span class="No-Break"><st c="73567">for </st></span><span class="No-Break"><strong class="source-inline"><st c="73571">notation</st></strong></span><span class="No-Break"><st c="73579">.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer262" class="IMG---Figure">
					<img src="image/B19710_07_43.jpg" alt="Figure 7.43 – Notation marketplace task on Azure DevOps pipeline"/><st c="73580"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="73652">Figure 7.43 – Notation marketplace task on Azure DevOps pipeline</st></p>
			<ol>
				<li value="4"><st c="73716">Click on </st><a id="_idIndexMarker853"/><st c="73726">the </st><strong class="bold"><st c="73730">Notation</st></strong><st c="73738"> task and select </st><strong class="bold"><st c="73755">Install</st></strong><st c="73762"> under </st><strong class="bold"><st c="73769">Command to run</st></strong><st c="73783">. Then, click </st><a id="_idIndexMarker854"/><st c="73797">the </st><strong class="bold"><st c="73801">Add</st></strong><st c="73804"> button. </st><st c="73813">This will </st><a id="_idIndexMarker855"/><st c="73823">add the task for installing Notation to your pipeline as shown in the </st><span class="No-Break"><st c="73893">following figure:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer263" class="IMG---Figure">
					<img src="image/B19710_07_44.jpg" alt="Figure 7.44 – Notation Install task on Azure DevOps pipeline"/><st c="73910"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="74016">Figure 7.44 – Notation Install task on Azure DevOps pipeline</st></p>
			<ol>
				<li value="5"><st c="74076">Next, let’s add the Notation task for signing our artifacts. </st><st c="74138">Navigate back to the pipeline editing panel and search for notation again. </st><st c="74213">This time, we will select </st><strong class="bold"><st c="74239">Sign</st></strong><st c="74243"> under </st><strong class="bold"><st c="74250">Command </st></strong><span class="No-Break"><strong class="bold"><st c="74258">to run</st></strong></span><span class="No-Break"><st c="74264">.</st></span></li>
				<li><st c="74265">On the </st><strong class="bold"><st c="74273">Artifact references</st></strong><st c="74292"> field, add your Azure Container Registry Login server, the repository and the tag as shown in </st><span class="No-Break"><em class="italic"><st c="74387">Figure </st></em></span><span class="No-Break"><em class="italic"><st c="74394">7</st></em></span><span class="No-Break"><em class="italic"><st c="74395">.46</st></em></span><span class="No-Break"><st c="74398"> (</st></span><span class="No-Break"><strong class="source-inline"><st c="74400">crx6xa5yuubr2hm.azurecr.io/eshoponweb/web:latest</st></strong></span><span class="No-Break"><st c="74448">).</st></span></li>
				<li><st c="74451">The Notation task in Azure Pipelines natively supports the Azure Key Vault plugin, which enables the Notation CLI to generate signatures using Azure-Key-Vault-managed certificates and keys. </st><st c="74642">Select </st><strong class="bold"><st c="74649">Azure Key Vault Plugin</st></strong><st c="74671"> under </st><strong class="bold"><st c="74678">Plugin</st></strong><st c="74684"> and then select the service connection earlier created in the </st><a href="B19710_06.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic"><st c="74747">Chapter 6</st></em></span></a> <span class="No-Break"><st c="74756">hands-on exercise.</st></span></li>
				<li><st c="74775">For the </st><strong class="bold"><st c="74784">Key ID</st></strong><st c="74790"> section, add the result you get from running the following command </st><a id="_idIndexMarker856"/><st c="74858">on Azure </st><a id="_idIndexMarker857"/><st c="74867">Cloud Shell. </st><st c="74880">Add the </st><a id="_idIndexMarker858"/><st c="74888">correct certificate and key </st><span class="No-Break"><st c="74916">vault names.</st></span><pre class="source-code"><st c="74928">
az keyvault certificate show -n test-io --vault-name &lt;your keyvault name&gt; --query 'kid' -o tsv</st></pre></li>			</ol>
			<div>
				<div id="_idContainer264" class="IMG---Figure">
					<img src="image/B19710_07_45.jpg" alt="Figure 7.45 – Key ID value"/><st c="75023"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="75229">Figure 7.45 – Key ID value</st></p>
			<p class="list-inset"><st c="75255">In this case, the Key ID </st><span class="No-Break"><st c="75281">is </st></span><span class="No-Break"><strong class="source-inline"><st c="75284">https://devsecopskeyvaulttest.vault.azure.net/keys/test-io/0daaced86b764e37855e02740e4f2d7c</st></strong></span><span class="No-Break"><st c="75375">.</st></span></p>
			<ol>
				<li value="9"><st c="75376">Notation supports signing using self-signed certificates and CA-issued certificates. </st><st c="75462">For this task, we will use self-signed certificates. </st><st c="75515">Scroll down and check </st><strong class="bold"><st c="75537">Self-signed Certificate</st></strong><st c="75560">. Then, click </st><strong class="bold"><st c="75574">Add</st></strong><st c="75577"> to add the sign task to </st><span class="No-Break"><st c="75602">your pipeline.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer265" class="IMG---Figure">
					<img src="image/B19710_07_46.jpg" alt="Figure 7.46 – Sign Notation marketplace task on Azure DevOps pipeline"/><st c="75616"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="75690">Figure 7.46 – Sign Notation marketplace task on Azure DevOps pipeline</st></p>
			<ol>
				<li value="10"><st c="75759">Run </st><a id="_idIndexMarker859"/><st c="75764">the pipeline </st><a id="_idIndexMarker860"/><st c="75777">and check </st><a id="_idIndexMarker861"/><st c="75787">on the two tasks added. </st><st c="75811">Upon successful execution, the image will be signed as shown in </st><span class="No-Break"><em class="italic"><st c="75875">Figure 7</st></em></span><span class="No-Break"><em class="italic"><st c="75883">.47</st></em></span><span class="No-Break"><st c="75886">:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer266" class="IMG---Figure">
					<img src="image/B19710_07_47.jpg" alt="Figure 7.47 – Notation tasks completed, and image signed."/><st c="75888"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="77070">Figure 7.47 – Notation tasks completed, and image signed.</st></p>
			<p><st c="77127">Let’s </st><a id="_idIndexMarker862"/><st c="77134">now look </st><a id="_idIndexMarker863"/><st c="77143">at how we can perform DAST </st><a id="_idIndexMarker864"/><st c="77170">on the application running in the </st><span class="No-Break"><st c="77204">test environment.</st></span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor166"/><st c="77221">Task 2 – Integrating DAST tools to find and fix security vulnerabilities in the test phase</st></h2>
			<p><st c="77312">This </st><a id="_idIndexMarker865"/><st c="77318">task aims to </st><a id="_idIndexMarker866"/><st c="77331">integrate ZAP </st><a id="_idIndexMarker867"/><st c="77345">to perform </st><a id="_idIndexMarker868"/><st c="77356">DAST. </st><st c="77362">There are several other commercial and open-source DAST tools such as Acunetix, Checkmarx DAST, Fortify WebInspect, Insight by Rapid7, PortSwigger Burp Suite, and Veracode, just to mention a few. </st><st c="77558">Many of these tools are available on the Azure DevOps Marketplace (</st><a href="https://marketplace.visualstudio.com/azuredevops"><st c="77625">https://marketplace.visualstudio.com/azuredevops</st></a><st c="77674">). </st><st c="77678">It is important </st><a id="_idIndexMarker869"/><st c="77694">to perform a DAST scan because it looks at a broad range of vulnerabilities, including input validation that could make an application vulnerable to XSS or SQL injection. </st><st c="77865">DAST is performed on an application that is running. </st><st c="77918">It runs automated penetration tests on your web applications </st><a id="_idIndexMarker870"/><st c="77979">and APIs </st><a id="_idIndexMarker871"/><st c="77988">that are </st><a id="_idIndexMarker872"/><st c="77997">already </st><a id="_idIndexMarker873"/><st c="78005">running. </st><st c="78014">It simulates real-world attacks covering the </st><em class="italic"><st c="78059">OWASP Top </st></em><span class="No-Break"><em class="italic"><st c="78069">10</st></em></span><span class="No-Break"><st c="78071"> (</st></span><a href="https://owasp.org/www-project-top-ten/"><span class="No-Break"><st c="78073">https://owasp.org/www-project-top-ten/</st></span></a><span class="No-Break"><st c="78111">).</st></span></p>
			<p><st c="78114">In the previous task, we ran a pipeline that built and deployed the </st><span class="No-Break"><st c="78183">eShopOnWeb application.</st></span></p>
			<div>
				<div id="_idContainer267" class="IMG---Figure">
					<img src="image/B19710_07_48.jpg" alt="Figure 7.48 – The eShopOnWeb application deployed"/><st c="78206"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="78571">Figure 7.48 – The eShopOnWeb application deployed</st></p>
			<p><st c="78620">Let’s see how we can perform DAST scans on our running application </st><span class="No-Break"><st c="78688">using ZAP:</st></span></p>
			<ol>
				<li><st c="78698">OWASP ZAP is available on the Azure Marketplace. </st><st c="78748">Navigate to the Azure Marketplace at </st><a href="https://marketplace.visualstudio.com/azuredevops"><st c="78785">https://marketplace.visualstudio.com/azuredevops</st></a><st c="78833">, and search for </st><strong class="source-inline"><st c="78850">OWASP ZAP Scanner</st></strong><st c="78867">. Click on </st><strong class="bold"><st c="78878">Get it free</st></strong><st c="78889">, select the correct organization to install the extension, and then go back to your project </st><span class="No-Break"><st c="78982">after installation.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer268" class="IMG---Figure">
					<img src="image/B19710_07_49.jpg" alt="Figure 7.49 – OWASP ZAP Scanner in Azure Marketplace"/><st c="79001"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="79187">Figure 7.49 – OWASP ZAP Scanner in Azure Marketplace</st></p>
			<ol>
				<li value="2"><st c="79239">We will </st><a id="_idIndexMarker874"/><st c="79248">add the OWASP ZAP Scanner task in a pipeline YAML file. </st><st c="79304">For this </st><a id="_idIndexMarker875"/><st c="79313">instance, we will create a new pipeline for OWASP ZAP, however, you can still add the same tasks in the </st><span class="No-Break"><st c="79417">existing pipeline.</st></span></li>
				<li><st c="79435">Navigate </st><a id="_idIndexMarker876"/><st c="79445">to </st><strong class="bold"><st c="79448">Pipelines</st></strong><st c="79457"> on </st><a id="_idIndexMarker877"/><st c="79461">the left, select </st><strong class="bold"><st c="79478">Pipelines</st></strong><st c="79487">, and then select </st><span class="No-Break"><strong class="bold"><st c="79505">New pipeline</st></strong></span><span class="No-Break"><st c="79517">.</st></span></li>
				<li><st c="79518">Select </st><strong class="bold"><st c="79526">Azure Repos Git</st></strong><st c="79541"> and then </st><strong class="bold"><st c="79551">eShopOnWeb</st></strong><st c="79561">. We will use </st><span class="No-Break"><strong class="bold"><st c="79575">Starter pipeline</st></strong></span><span class="No-Break"><st c="79591">.</st></span></li>
				<li><st c="79592">Delete the starter scripts, and then add the </st><strong class="bold"><st c="79638">OWASP Zap Scanner</st></strong><st c="79655"> task from the </st><span class="No-Break"><strong class="bold"><st c="79670">Tasks</st></strong></span><span class="No-Break"><st c="79675"> assistant.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer269" class="IMG---Figure">
					<img src="image/B19710_07_50.jpg" alt="Figure 7.50 – OWASP ZAP Scanner in Azure Marketplace"/><st c="79686"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="79962">Figure 7.50 – OWASP ZAP Scanner in Azure Marketplace</st></p>
			<ol>
				<li value="6"><st c="80014">Set </st><strong class="bold"><st c="80019">Failure Threshold</st></strong><st c="80036"> to </st><strong class="source-inline"><st c="80040">1500</st></strong><st c="80044"> and select </st><strong class="bold"><st c="80056">Targeted Scan</st></strong><st c="80069"> as your scan type. </st><st c="80089">Input </st><a id="_idIndexMarker878"/><st c="80095">the URL </st><a id="_idIndexMarker879"/><st c="80103">for the </st><a id="_idIndexMarker880"/><st c="80111">app deployed </st><a id="_idIndexMarker881"/><st c="80124">on the test environment and then </st><span class="No-Break"><st c="80157">click </st></span><span class="No-Break"><strong class="bold"><st c="80163">Add</st></strong></span><span class="No-Break"><st c="80166">.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer270" class="IMG---Figure">
					<img src="image/B19710_07_51.jpg" alt="Figure 7.51 – Set the OWASP Zap Scanner configurations"/><st c="80167"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="80352">Figure 7.51 – Set the OWASP Zap Scanner configurations</st></p>
			<ol>
				<li value="7"><st c="80406">The YAML file should now look like this after adding a </st><span class="No-Break"><st c="80462">display name.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer271" class="IMG---Figure">
					<img src="image/B19710_07_52.jpg" alt="Figure 7.52 – The OWASP Zap Scanner task"/><st c="80475"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="80721">Figure 7.52 – The OWASP Zap Scanner task</st></p>
			<ol>
				<li value="8"><st c="80761">We </st><a id="_idIndexMarker882"/><st c="80765">need to publish the report generated by the OWASP ZAP Scanner </st><a id="_idIndexMarker883"/><st c="80827">task. </st><st c="80833">From the </st><a id="_idIndexMarker884"/><st c="80842">assistant </st><strong class="bold"><st c="80852">Tasks</st></strong><st c="80857"> section, search for </st><strong class="source-inline"><st c="80878">publish build artifacts</st></strong><st c="80901">. Leave the </st><a id="_idIndexMarker885"/><st c="80913">Path to publish as </st><strong class="source-inline"><st c="80932">$(Build.ArtifactStagingDirectory)</st></strong><st c="80965"> and the artifact name as </st><span class="No-Break"><strong class="bold"><st c="80991">ZAP Reports</st></strong></span><span class="No-Break"><st c="81002">.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer272" class="IMG---Figure">
					<img src="image/B19710_07_53.jpg" alt="Figure 7.53 – Publish build artifacts task"/><st c="81003"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="81447">Figure 7.53 – Publish build artifacts task</st></p>
			<ol>
				<li value="9"><st c="81489">Our </st><a id="_idIndexMarker886"/><st c="81494">YAML file </st><a id="_idIndexMarker887"/><st c="81504">now looks </st><a id="_idIndexMarker888"/><st c="81514">like </st><span class="No-Break"><st c="81519">the </st></span><span class="No-Break"><a id="_idIndexMarker889"/></span><span class="No-Break"><st c="81523">following:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer273" class="IMG---Figure">
					<img src="image/B19710_07_54.jpg" alt="Figure 7.54 – OWASP ZAP and Publish tasks"/><st c="81533"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="81864">Figure 7.54 – OWASP ZAP and Publish tasks</st></p>
			<ol>
				<li value="10"><st c="81905">The report is generated in JSON and HTML formats, which are machine readable, so the output can be used for further processing. </st><st c="82034">We can also have the scan results published to the </st><strong class="bold"><st c="82085">Tests results</st></strong><st c="82098"> tab by adding the code snippets of the </st><strong class="bold"><st c="82138">Install handlebars</st></strong><st c="82156">, </st><strong class="bold"><st c="82158">Report Generation</st></strong><st c="82175">, and </st><strong class="bold"><st c="82181">Publish Report (Nunit Style)</st></strong><st c="82209"> code sections </st><span class="No-Break"><st c="82224">from </st></span><a href="https://marketplace.visualstudio.com/items?itemName=CSE-DevOps.zap-scanner"><span class="No-Break"><st c="82229">https://marketplace.visualstudio.com/items?itemName=CSE-DevOps.zap-scanner</st></span></a><span class="No-Break"><st c="82303">.</st></span></li>
				<li><st c="82304">Once you’ve added the preceding three code snippets, update the file path parameter from the </st><strong class="bold"><st c="82398">Install handlebars</st></strong><st c="82416"> code snippet to </st><span class="No-Break"><st c="82433">the following:</st></span><pre class="source-code"><st c="82447">
&lt;filePath&gt;$(Build.SourcesDirectory)/owaspzap/report.html&lt;/filePath&gt;</st></pre></li>				<li><st c="82515">Save </st><a id="_idIndexMarker890"/><st c="82521">and commit </st><a id="_idIndexMarker891"/><st c="82532">the new pipeline and then </st><span class="No-Break"><st c="82558">run it.</st></span></li>
				<li><st c="82565">After a </st><a id="_idIndexMarker892"/><st c="82574">few minutes, the </st><a id="_idIndexMarker893"/><st c="82591">tasks are completed, and the scan results </st><span class="No-Break"><st c="82633">are published.</st></span></li>
			</ol>
			<div>
				<div id="_idContainer274" class="IMG---Figure">
					<img src="image/B19710_07_55.jpg" alt="Figure 7.55 – OWASP ZAP and Publish tasks successful"/><st c="82647"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="83026">Figure 7.55 – OWASP ZAP and Publish tasks successful</st></p>
			<p><st c="83078">Let’s see </st><a id="_idIndexMarker894"/><st c="83089">the scan </st><a id="_idIndexMarker895"/><st c="83098">results from </st><a id="_idIndexMarker896"/><st c="83111">the </st><strong class="bold"><st c="83115">Test results</st></strong><st c="83127"> tab. </st><st c="83133">Navigate </st><a id="_idIndexMarker897"/><st c="83142">to the successful pipeline run and click on the </st><span class="No-Break"><strong class="bold"><st c="83190">Tests</st></strong></span><span class="No-Break"><st c="83195"> tab.</st></span></p>
			<div>
				<div id="_idContainer275" class="IMG---Figure">
					<img src="image/B19710_07_56.jpg" alt="Figure 7.56 – The Tests results tab"/><st c="83200"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="83527">Figure 7.56 – The Tests results tab</st></p>
			<p><st c="83562">Go through the scan results and familiarize yourself with the findings from </st><span class="No-Break"><st c="83639">OWASP ZAP.</st></span></p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor167"/><st c="83649">Summary</st></h1>
			<p><st c="83657">In this chapter, we covered several checks that should be performed before releasing an application to production. </st><st c="83773">This includes ensuring that release artifacts are built from protected branches, implementing a code review process, selecting a secure artifact source, implementing a process to validate artifact integrity, managing secrets securely in the release phase, implementing IaC security scans, and validating and enforcing runtime security with release gates. </st><st c="84128">We also covered runtime verification tools in place </st><span class="No-Break"><st c="84180">including DAST.</st></span></p>
			<p><st c="84195">In the next chapter, we will look at continuous security monitoring on Azure. </st><st c="84274">Now that we have deployed the resources, we need to make sure they remain secure. </st><st c="84356">Let’s </st><span class="No-Break"><st c="84362">dive in.</st></span></p>
		</div>
	<div id="charCountTotal" value="84370"/></body></html>