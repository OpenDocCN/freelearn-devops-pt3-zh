<html><head></head><body>
		<div id="_idContainer014">
			<h1 class="chapter-number" id="_idParaDest-45"><a id="_idTextAnchor046"/>3</h1>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor047"/>The Value of Source Control</h1>
			<p>As we move toward the <a id="_idIndexMarker066"/>technical aspects of Salesforce DevOps, we should start by exploring <strong class="bold">source control</strong>. In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Why source control is vital for the implementation of a <span class="No-Break">DevOps process</span></li>
				<li>Fundamental Git operations for managing <span class="No-Break">your changes</span></li>
				<li>Effective Git branching strategies for successful delivery with <span class="No-Break">source control</span></li>
			</ul>
			<p>Source control, also referred to as <strong class="bold">version control</strong>, is the <a id="_idIndexMarker067"/>technical backbone of modern DevOps, and all other tools and techniques are built upon that solid foundation. By tackling this topic first and looking at some of the common tasks it entails, you will have a solid foundation for the topics discussed later in this book, such as <span class="No-Break">CI/CD automation.</span></p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor048"/>Technical requirements</h1>
			<p>The examples in this chapter all pertain to the <strong class="bold">Git</strong> source control system and it is recommended that you have it installed if you want to follow along. Equally, a Git hosting provider is recommended. Many are available, such as GitHub, GitLab, and BitBucket. However, in our examples, we’ll be <span class="No-Break">using GitHub.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor049"/>The importance of source control</h1>
			<p>While <a id="_idIndexMarker068"/>establishing a DevOps culture is the most important aspect of DevOps from a process perspective, as we saw in the previous chapter, it’s fair to say that source control is the most important technical aspect. It underpins all the other tools and techniques of a mature DevOps process and enables deployments, peer review, rollbacks, and automation as part of a CI/CD process. Let’s explore some of the advantages afforded by source control and the processes that build <span class="No-Break">upon it.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor050"/>Collaboration</h2>
			<p>DevOps is<a id="_idIndexMarker069"/> fundamentally a collaborative approach to software<a id="_idIndexMarker070"/> development, so effective collaboration is vital. Source control enables multiple developers to work on the same code base simultaneously while indicating when they could be overlapping or overwriting each other’s changes during the development phase. Changes are merged later, and when coupled with appropriate reviews, they allow for rapid development and fewer defects, since changes are tested and reviewed far earlier in the development cycle. Only when manual and automated checks have passed does code make it higher up the environments toward production. It’s worth noting that production issues are harder to track down and more expensive to deal with compared to <span class="No-Break">development environments.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor051"/>Traceability</h2>
			<p>As the<a id="_idIndexMarker071"/> importance of good governance grows across all processes and businesses, including software development, so does the need to have accountability and audit trails of software change. Source control facilitates this with a complete history of all changes to your code and configurations, detailing what was changed, by whom, and (with diligence around commit messages, comments, and references to change management tools such as Jira) why the change occurred. In addition to these audit <a id="_idTextAnchor052"/>trail benefits, a complete history also helps you find the origin of bugs <span class="No-Break">and issues.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor053"/>Automation</h2>
			<p>DevOps relies heavily on<a id="_idIndexMarker072"/> automation, and source control provides the foundation for automating many of the processes involved in software development, such as building, testing, and deploying code. For example, with source control, it’s possible to automatically build, test, and deploy code to different environments every time a change <span class="No-Break">is committed.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor054"/>Continuous integration</h2>
			<p><strong class="bold">Continuous integration</strong> (<strong class="bold">CI</strong>) allows<a id="_idIndexMarker073"/> developers to <a id="_idIndexMarker074"/>integrate their code changes from their development or feature branches into a shared integration branch, and then run automated tests to ensure that the changes do not break the existing system. This process is made possible by source control as it allows developers to easily merge their changes and track conflicts. By adopting this technique and regularly integrating changes into<a id="_idIndexMarker075"/> the main code, developers can detect issues earlier, which makes it easier to <span class="No-Break">fix</span><span class="No-Break"><a id="_idIndexMarker076"/></span><span class="No-Break"> them.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor055"/>Continuous deployment</h2>
			<p><strong class="bold">Continuous deployment</strong> (<strong class="bold">CD</strong>) is a <a id="_idIndexMarker077"/>practice where code changes are automatically deployed <a id="_idIndexMarker078"/>to production after they pass through the CI process. This process is also made possible by source control as it allows the deployment process to be automated. This can be accomplished by using general-purpose CI/CD tools such as Jenkins, Travis CI, and CircleCI, or with Salesforce-specific tools such as DevOps Center, Gearset, or Copado. Regardless of the tool you choose, they can be configured to automatically deploy code changes to production when they pass through the CI process. This is the reason why CI and CD are usually grouped into <a id="_idIndexMarker079"/>the <span class="No-Break">CI/CD process.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor056"/>Continuous delivery (also CD)</h2>
			<p>The other<a id="_idIndexMarker080"/> CD you may hear concerning <a id="_idIndexMarker081"/>DevOps is <strong class="bold">continuous deliv<a id="_idTextAnchor057"/>ery</strong>. Its shared initials with continuous deployment often create a lot of confusion. The aim of CI/CD is continuous delivery: promptly and dependably delivering enhanced value to users. Distinct from continuous integration and continuous deployment, which are workflows or specific processes, continuous delivery delineates a working culture or methodology. Grounded in a practice of progressive enhancements, continuous delivery focuses on diminishing lead times and curtailing the development cycle, which includes swift feedback from all <span class="No-Break">parties involved.</span></p>
			<p>This approach enables Salesforce teams to aid their businesses in responding swiftly and more flexibly to evolving priorities and market prospects. Both CI and CD are processes that help teams accomplish <span class="No-Break">continuous delivery.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor058"/>Rollbacks</h2>
			<p>Source control<a id="_idIndexMarker082"/> allows for easy rollbacks, which lets you revert to a previous version of <a id="_idIndexMarker083"/>the code base if there are issues with the incoming changes. It is important to be able to roll back changes quickly and easily in case of bugs or other issues that may arise in the production environment. This is made possible by source control as it keeps a history of all the changes that have been made to the code base, making it easier to revert to a previous version if needed. However, keep in mind that not everything can be reverted in Salesforce. For example, if you are trying to revert a commit that contained a record type or a new flow and that change was deployed to an org, then you may have issues reverting that change. Record types cannot be removed via the Metadata API, and flows require you to specify the version number to <span class="No-Break">be removed.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor059"/>Incremental development</h2>
			<p>Another <a id="_idIndexMarker084"/>significant advantage of a source-control-driven approach to development and deployment is that it encourages developers to think incrementally – one commit at a time.  This further supports many of the points covered previously – committing changes in smaller incremental chunks has the potential to make it easier to manage and merge work done by other team members, reducing the chance of code conflicts. It also makes debugging and tracking issues easier since you can compare the current version with the previous commit to see the net difference. Finally, it encourages better coding standards, in which smaller commits tend to promote more modular, decoupled <span class="No-Break">code architecture.</span></p>
			<p>Now that we’ve looked at the many advantages of using source control, and why it is so important to a mature DevOps process, let’s look at some of the core Git tasks and commands that bring source control <span class="No-Break">to life.</span></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor060"/>Fundamental Git operations</h1>
			<p>Before we dive into the sea of Git commands and how they come into play, it’s essential to get a firm grasp of the basics of <span class="No-Break">source control.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor061"/>Commits</h2>
			<p>A commit<a id="_idIndexMarker085"/> is a snapshot<a id="_idIndexMarker086"/> of your project’s files and directories at a specific point in time. Every commit is assigned a unique identifier (known as a SHA hash) and includes metadata such as the author, timestamp, and a descriptive message explaining <span class="No-Break">the changes.</span></p>
			<p>Commits aren’t just frozen moments in time, though. They’re also part of a larger narrative that reflects your project’s evolution. In Git, commits are linked in a chain, with each commit referencing its predecessor. This allows you to traverse your project’s history, compare versions, or even revert changes <span class="No-Break">when necessary.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor062"/>Staging</h2>
			<p>Before you can <a id="_idIndexMarker087"/>commit changes in Git, you need to <strong class="bold">stage</strong> them. The staging area, also known as the index, is like a preparation zone where you gather and organize your<a id="_idIndexMarker088"/> changes before making a commit. Staging changes allows you to create meaningful, well-organized commits that communicate what you’ve done <span class="No-Break">and why.</span></p>
			<p>When you stage a file, you are telling Git that you want to include updates to that file in the next commit. However, it is important to note that Git stages a file exactly as it is when you stage it. If you continue to make changes to a file after staging it, you will need to stage it again to include the latest changes in your <span class="No-Break">next commit.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor063"/>Repositories</h2>
			<p>A repository, often <a id="_idIndexMarker089"/>abbreviated to <strong class="bold">repo</strong>, is a container where your project lives. It’s not just a storage space, though. A repository also includes a complete history of your project, tracking changes, branching paths, and the intricate web of collaboration. In Git, creating a new repository is as simple as using the <strong class="source-inline">git init</strong> command in the directory that contains your <span class="No-Break">source code.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor064"/>Putting source control into practice</h2>
			<p>While this<a id="_idIndexMarker090"/> book is not intended to give an <em class="italic">exhaustive</em> overview of Git’s myriad of commands and options, there are a few key operations that make up Git’s <span class="No-Break">typical usage.</span></p>
			<p>Firstly, it’s important to note the difference between a local repository and a remote repository since many Git commands are specifically for moving changes between <span class="No-Break">the two.</span></p>
			<p>As the name suggests, a local repository <a id="_idIndexMarker091"/>exists on your local development machine and can be either a newly initialized repository or one that you have cloned from another (usually remote) repository. Operations carried out on this repository will remain on your local machine until you push those changes to a <span class="No-Break">remote repository.</span></p>
			<p>A remote repository<a id="_idIndexMarker092"/> is hosted on a remote server – either with a Git hosting pro<a id="_idTextAnchor065"/>vider or a physical server, perhaps within your own company’s data center. This remote repository serves as the centralized source of truth from which other developers can get your changes and vice versa. With this distinction between local and remote repositories in mind, let’s start looking at some common Git operations and the <a id="_idIndexMarker093"/>commands to carry <span class="No-Break">them out.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor066"/>Initializing a new repository</h2>
			<p>The initial step in <a id="_idIndexMarker094"/>any source control workflow is to create a repository in which to <a id="_idIndexMarker095"/>store your work, and while it is likely you will be working with a repository that already exists, creating a new repository can be achieved by running the following command in the directory that contains your source code. This will create a brand-new empty repository locally, into which you can then start <span class="No-Break">adding files:</span></p>
			<pre class="source-code">
git init</pre>			<h2 id="_idParaDest-63"><a id="_idTextAnchor067"/>Adding new files to the staging area</h2>
			<p>By default, Git<a id="_idIndexMarker096"/> will consider all files to be untracked and not part of your source control. Adding the files (also referred to as “staging” them) indicates that they should be included as part of your source control. Staging these files is the first part of a two-step process – first, we add files that we intend to commit; then, once we are sure everything that should be grouped as a single commit has been added, we can proceed to the <span class="No-Break">second step.</span></p>
			<p>You can add a single file to your local Git repository, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
git add &lt;file&gt;</pre>			<p>Alternatively, you can add all files in the current directory, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
git add .</pre>			<p>At this stage, they <a id="_idIndexMarker097"/>are not part of your local repository until you commit the changes, as shown in the next section. This is where it’s important to note that the current directory is not the same as your local repository. Although there may be many files in the local directory, they don’t form part of your local repository until you add and <span class="No-Break">commit them.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor068"/>Checking everything has been added before the commit</h2>
			<p>While<a id="_idIndexMarker098"/> not strictly required, it is recommended to get into the habit of checking that everything you wish to commit has been added. This can easily be achieved using the <strong class="source-inline">git status</strong> command. In the <a id="_idIndexMarker099"/>following example output, we can easily see changes that have been added, changes that have been made but not added, and files that are not currently being tracked for changes. This last category may be because the files have been added to the <strong class="source-inline">.gitignore</strong> file, which, as its name suggests, is a list of files and paths that Git should ignore, or they could be <span class="No-Break">empty directories:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer008">
					<img alt="Figure 3.1 – Example output of the git status command" src="image/Figure_3.01_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Example output of the git status command</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor069"/>Committing changes to the local repository</h2>
			<p>Once you have staged your changes with<a id="_idIndexMarker100"/> the <strong class="source-inline">git add</strong> command, you can create a snapshot of these modifications in your local repository wit<a id="_idTextAnchor070"/>h the <strong class="source-inline">git commit</strong> command. When <a id="_idIndexMarker101"/>you commit your changes, it is important to include a descriptive message that <a id="_idIndexMarker102"/>explains the purpose of the commit. This makes it easier for you and your collaborators to understand the version <span class="No-Break">control history.</span></p>
			<p>Many tools that work with Git, including GitHub, make use of certain formats and tags in commit messages. These not only help provide additional context to developers but can also drive workflow integrations, such as in bug-tracking tools. Writing commit messages in this way involves following certain guidelines to maintain readability and effectiveness. A commit message typically includes a header or title, the type of commit (such as <strong class="source-inline">feat</strong>, <strong class="source-inline">fix</strong>, <strong class="source-inline">docs</strong>, and so on), an optional scope to specify the area of change, and a subject that concisely describes the change. It can also contain a detailed explanatory body and a footer referencing related issue IDs. The subject and header are often limited to 50 characters and the body wraps at 72 characters. The commit message should be clear and concise, explaining what the commit does <span class="No-Break">and why.</span>
To commit your staged changes with a commit message, use the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
git commit -m "Commit message"</pre>			<p>You can use the <strong class="source-inline">git log</strong> command<a id="_idIndexMarker103"/> to view commits made to your repository. By default, it will display an SHA-1 checksum, along with the author, date, and commit message of each commit. However, there<a id="_idIndexMarker104"/> are many options for filtering and searching the log, all of which you can find in Git’s <span class="No-Break">built-in documentation.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor071"/>Connecting your remote repository</h2>
			<p>With our <a id="_idIndexMarker105"/>changes committed to our local repository, we need to ensure that our remote repository has been connected correctly and is ready to push our changes. If it is not already connected, we can use the <strong class="source-inline">git remote</strong> command<a id="_idIndexMarker106"/> to connect it and provide it with a working alias. Conventionally, this alias is often referred to as <strong class="source-inline">origin</strong>, but you can use any name you like. An example of this command is <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
git remote add origin https://github.com/myuser/myrepo.git</pre>			<p>This command connects our remote repository at the URL specified, via the <span class="No-Break"><strong class="source-inline">origin</strong></span><span class="No-Break"> alias.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor072"/>Pushing changes to a remote repository</h2>
			<p>Once you’re confident that your local changes are stable and <a id="_idIndexMarker107"/>well tested, you can use the <strong class="source-inline">git push</strong> command<a id="_idIndexMarker108"/> to transfer these updates to the remote repository. This ensures that your changes are shared with other collaborators and makes the updated code accessible to anyone with access to <span class="No-Break">the repository.</span></p>
			<p>To perform a <strong class="source-inline">git push</strong> operation, simply run the following command in your terminal or <span class="No-Break">Command Prompt:</span></p>
			<pre class="source-code">
git push</pre>			<p>By default, this <a id="_idIndexMarker109"/>command pushes your changes to the <a id="_idIndexMarker110"/>branch of the remote repository that is currently checked out in your local repository. However, you can also specify the remote repository and branch you want to push to, <span class="No-Break">if necessary:</span></p>
			<pre class="source-code">
git push &lt;remote&gt; &lt;branch&gt;</pre>			<h2 id="_idParaDest-68"><a id="_idTextAnchor073"/>Merging changes from one branch to another</h2>
			<p>If you’re <a id="_idIndexMarker111"/>working with an already existing Git repository, you may be working in a separate branch from the main branch – we’ll be looking at a few example branching strategies in <span class="No-Break">this chapter.</span></p>
			<p>If this is the case, you will eventually need to merge your changes into the main branch, which can be achieved with<a id="_idIndexMarker112"/> the <strong class="source-inline">git merge</strong> command. This ensures that the main branch incorporates the changes in your branch, without conflicts. Git will automatically try to merge the changes, but if conflicts arise, you’ll have to resolve <span class="No-Break">them manually.</span></p>
			<p>This manual resolution of conflicts involves going through the files that contain conflicts, such as lines of code that have been changed in both branches, and deciding which version should be kept as the final output. Git will automatically add sections marked with <strong class="source-inline">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</strong>, <strong class="source-inline">=======</strong>, and <strong class="source-inline">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</strong> to indicate where these conflicts exist within the file. The following code snippet demonstrates a <span class="No-Break">typical example:</span></p>
			<pre class="source-code">
public class ExampleClass {
    public void doSomething() {
&lt;&lt;&lt;&lt;&lt;&lt;&lt;
        System.debug('This is the current branch code.');
=======
        System.debug('This is the code from the branch being merged.');
&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-to-merge
    }
}</pre>			<p>The first marker shows the start of the conflicting lines. The second marker acts as a separator between the conflicting versions – everything before the marker is in the current branch and everything after it is in the branch to <span class="No-Break">be merged.</span></p>
			<p>To <a id="_idIndexMarker113"/>resolve the conflict, delete the conflict markers and edit the code so that it reflects the intended version you wish to keep. It is important to consider the context and intention of the changes. For this reason, it is recommended to liaise with the author of the conflicting change <span class="No-Break">wherever possible.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor074"/>Merge strategies</h2>
			<p>Whe<a id="_idTextAnchor075"/>n it comes to <a id="_idIndexMarker114"/>merging changes bet<a id="_idTextAnchor076"/>ween branches, it’s worth taking a brief look at merge strategies. These are the different approaches used by Git to determine how it handles the conflicting changes and merges them, as well a<a id="_idTextAnchor077"/>s how it manages different situations during the merge process. Here are a few examples, although there are <span class="No-Break">many more:</span></p>
			<ul>
				<li><strong class="bold">Recursive</strong>: The recursive strategy<a id="_idIndexMarker115"/> is Git’s default strategy and works for most common<a id="_idIndexMarker116"/> scenarios. It analyzes the commit history of both branches to determine a common starting point before the branches diverged and then applies changes from both bran<a id="_idTextAnchor078"/>ches. If it hits a conflict along the way, it will prompt for <span class="No-Break">manual intervention.</span></li>
				<li><strong class="bold">Octopus</strong>: The <a id="_idIndexMarker117"/>octopus strategy<a id="_idIndexMarker118"/> is used to merge multiple branches into a single branch. For example, you may want to merge multiple feature branches into a single <span class="No-Break">release branch.</span></li>
				<li><strong class="bold">Resolve</strong>: The resolve<a id="_idIndexMarker119"/> strategy is similar to the recursive<a id="_idIndexMarker120"/> strategy, in that it will attempt to automatically merge changes and pause for manual intervention if conflicts are detected. The difference in this strategy, however, is that it doesn’t recursively analyze the <span class="No-Break">commit history.</span></li>
				<li><strong class="bold">Ours</strong>: The ours<a id="_idIndexMarker121"/> strategy is designed to give preference to the branch <a id="_idIndexMarker122"/>being merged into. Like the other strategies, it will automatically merge where no conflicts exist, but in the event of a conflict, it will discard changes from the incoming branch and keep the current version. As you might have guessed at this point, the opposing strategy, in which the incoming changes are favored, is called <a id="_idIndexMarker123"/>the <span class="No-Break"><strong class="bold">theirs</strong></span><span class="No-Break"> strategy.</span></li>
				<li><strong class="bold">Subtree</strong>: The subtree<a id="_idIndexMarker124"/> merge strategy is used to merge changes <a id="_idIndexMarker125"/>from a remote repository into a subfolder of your current repository. This can be useful for very modular projects, or libraries of code that you wish to<a id="_idIndexMarker126"/> incorporate into <span class="No-Break">larger projects.</span></li>
			</ul>
			<p>These strate<a id="_idTextAnchor079"/>gies are just a glimpse of the available options for me<a id="_idTextAnchor080"/>rging in Git. You have the flexibility to choose the desired merge strategy by utilizing command-line options or configuration settings. Which merge strategy you choose depends on the specific needs and complexities of <span class="No-Break">your project.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor081"/>Creating a new branch</h2>
			<p>As we’ll see in the next <a id="_idIndexMarker127"/>section on branching strategies, when you are about to start working on a new feature, bug fix, or any other change, it’s a common practice to create a new branch, often referred to<a id="_idIndexMarker128"/> as a <strong class="bold">feature branch</strong>. This ensures that your work is isolated from the main branch, which is usually more stable <span class="No-Break">and production-ready.</span></p>
			<p>To create a new branch, you can<a id="_idIndexMarker129"/> use the <strong class="source-inline">git branch</strong> command, followed by the desired <span class="No-Break">branch name:</span></p>
			<pre class="source-code">
git branch &lt;branch_name&gt;</pre>			<h2 id="_idParaDest-71"><a id="_idTextAnchor082"/>Switching to a different branch</h2>
			<p>To switch to another branch<a id="_idIndexMarker130"/> from the current one in use, simply check out that branch, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
git checkout &lt;branch_name&gt;</pre>			<p>Alternatively, you can create a new branch and switch to it with a single command using the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">b</strong></span><span class="No-Break"> flag:</span></p>
			<pre class="source-code">
git checkout -b &lt;branch_name&gt;</pre>			<p>Now that you’ve created and switched to your new branch, you can start making changes to the code base without them affecting the main branch. Once your work is complete and has been tested, you can merge your feature branch back into the main branch, ensuring a clean and organized version <span class="No-Break">control history.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor083"/>Viewing commit history</h2>
			<p>The <strong class="source-inline">git log</strong> command<a id="_idIndexMarker131"/> allows you to see the history of all<a id="_idIndexMarker132"/> commits that make up your current branch – this could consist of commits directly to the branch, commits merged from other branches, or commits made from the original branch that your branch was created from. You can view this history, including any commit messages, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
git log</pre>			<h2 id="_idParaDest-73"><a id="_idTextAnchor084"/>Reverting to a previous version of a file</h2>
			<p>It is<a id="_idIndexMarker133"/> possible to revert a specific file to a previous version, as opposed to reverting an entire commit that may contain multiple file changes. Using the commit hash from the log shown in the commit history and the name of the file you wish to restore from that point in time, you can check out the file, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
git checkout &lt;commit_hash&gt; &lt;file&gt;</pre>			<h2 id="_idParaDest-74"><a id="_idTextAnchor085"/>Git rebasing</h2>
			<p><strong class="bold">git rebase</strong> is a way <a id="_idIndexMarker134"/>to integrate changes from one branch into another. It involves <a id="_idIndexMarker135"/>replaying the commits from the feature branch on top of the base branch, which replaces the feature branch with an updated version that includes all the changes from the <span class="No-Break">base branch.</span></p>
			<p>The main principle behind <strong class="source-inline">git rebase</strong> is to maintain a linear history, which makes it easier to understand and follow the changes made to the code over time. A linear history means that there are no merge commits (a special type of commit when merges are made, to maintain the history of both branches going forward), only a straight line <span class="No-Break">of commits.</span></p>
			<p><strong class="source-inline">git rebase</strong> also helps in re<a id="_idTextAnchor086"/>solving conflicts that may arise while merging. Instead of creating a merge commit, it replays commits one by one on top of the base branch, which can make conflicts easier to resolve. It’s important to note that <strong class="source-inline">git rebase</strong> modifies the existing commits, and it can cause issues if other people have already pulled the feature branch. <em class="italic">Therefore, it’s recommended to only use git rebase on branches that haven’t been shared </em><span class="No-Break"><em class="italic">with others.</em></span></p>
			<p>In summary, <strong class="source-inline">git rebase</strong> is a powerful command that can help keep your Git history clean and easy to understand, but it <em class="italic">should be used with caution</em>. Now that we’ve looked at the foundational Git commands and why they are used in our workflow, let’s discuss <span class="No-Break">branching strategies.</span></p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor087"/>Effective Salesforce branching strategies</h1>
			<p>When developing<a id="_idIndexMarker136"/> features in version control, a branching strategy establishes guidelines for how branches are utilized and managed. However, there is no single strategy that is ideal for every team. The best strategy for your team will depend on several factors, such as team size, team structure/complexity, the desired release schedule, and the <span class="No-Break">current workflow.</span></p>
			<p>For ex<a id="_idTextAnchor088"/>ample, larger teams may require a more complex strategy to accommodate different roles, while a simpler strategy may be more suitable for smaller teams. Additionally, business requirements may dictate a specific release cycle, and the branching strategy should be able to accommodate those needs. Furthermore, it is important to consider how your current workflow and environment setup (for example, the number of sandboxes) may align with the chosen <span class="No-Break">branching strategy.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor089"/>Git as a backup</h2>
			<p>The first strategy we can look at is using Git<a id="_idIndexMarker137"/> as a lightweight backup of your Salesforce metadata. This approach is frequently the initial step teams take when they start version-controlling their metadata. They establish one branch per environment and begin transferring metadata from their orgs to <span class="No-Break">the branches.</span></p>
			<p>While this is a good initial approach to getting metadata into Git, the development life cycle is not truly source-driven in this way. Version control does not serve as the primary source of truth here, but rather as a retrospective record of the changes that have already occurred. It is still useful, but to fully reap the benefits of Git, it is important to ensure that once changes have been developed, they are placed into version control to facilitate a smooth flow between environments. Additionally, this model often results in isolated environment branches, where changes aren’t exchanged between them in source control. Consequently, transitioning from this model to establish source control as the definitive source of truth can be challenging. This is primarily because the same file in each organizational branch lacks a shared commit history, which can make it difficult for Git to <span class="No-Break">handle them.</span></p>
			<p>For instance, with this workflow, it can be difficult to accommodate parallel development streams for multiple features. There are no pull requests in this model, which allows you to easily integrate peer review into <span class="No-Break">the workflow.</span></p>
			<p>Additionally, because changes are not regularly deployed from version control into the environments, there may be less confidence in the ability to roll back a release by deploying an older revision from <span class="No-Break">version control.</span></p>
			<p>It is important to remember that version control is primarily designed to assist teams in creating, tracking, and deploying new features. It should not be viewed as a comprehensive backup of Salesforce environments for disaster recovery purposes, as that is the role of backup solutions in a comprehensive <span class="No-Break">DevOps strategy.</span></p>
			<p>You can see an example of using Git as a backup, and how the branches mirror your Salesforce environments, in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer009">
					<img alt="Figure 3.2 – Git as a backup" src="image/Figure_3.02_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Git as a backup</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor090"/>Trunk-based development</h2>
			<p>With <strong class="bold">trunk-based development</strong> (<strong class="bold">TBD</strong>), all<a id="_idIndexMarker138"/> developers work on a single branch, called the <strong class="bold">trunk</strong> or <strong class="bold">main</strong>. Feature toggles are used to hide incomplete work. Branches <a id="_idIndexMarker139"/>are short-lived and<a id="_idIndexMarker140"/> are merged back into the main branch as soon as possible. While the thought of merging your work into the main branch daily (or even multiple times a day) might seem daunting, many teams find that the benefits of TBD far outweigh the initial discomfort. Embracing TBD can lead to increased collaboration, higher-quality code, and a more streamlined <span class="No-Break">development process.</span></p>
			<p>In TBD, developers create branches for new features or bug fixes, but these branches are short-lived. They are merged back into the main branch as soon as possible, often within a day. To avoid unfinished features being pushed into production, TBD employs feature toggles (also known as feature flags). This allows teams to hide features until they are ready for production use. With everyone merging their changes into the main branch frequently, CI is necessary. Automated testing ensures that the main branch is always in a releasable state. You’ll notice that the diagram for this approach (see <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.2</em>) and the feature branch one (see <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.3</em>), are extremely similar. The fundamental difference <a id="_idIndexMarker141"/>between <a id="_idIndexMarker142"/>the two strategies is that the branches for TBD are much more granular in their scope <span class="No-Break">and short-lived:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer010">
					<img alt="Figure 3.3 – ﻿TBD" src="image/Figure_3.03_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – TBD</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor091"/>The feature branch model</h2>
			<p>The<a id="_idIndexMarker143"/> feature branch model is <a id="_idIndexMarker144"/>a basic approach that integrates Git into the development process, rather than just being used for backup. While some teams may choose more complex branching methods, the feature branch model is a good starting point due to its simplicity. The master branch<a id="_idIndexMarker145"/> is the only long-term, permanent branch. When you work on new features or fixes, a separate branch is created from the main branch, and once completed, it is merged back into the <span class="No-Break">main branch.</span></p>
			<p>In this model, it is best to keep feature branches as short-lived as possible and delete them after use for cleanliness. Large features should be divided into smaller chunks and implement<a id="_idTextAnchor092"/>ed one at a time to shorten the feedback cycle and decrease the likelihood of merge conflicts. It should be noted that any failure in the master branch is a blocker to the whole release process since it relies on all the prod-ready testing to happen on each feature branch, which is not <span class="No-Break">always realistic.</span></p>
			<p>The master branch is <a id="_idIndexMarker146"/>typically<a id="_idIndexMarker147"/> deployed automatically to<a id="_idIndexMarker148"/> a staging environment using a CI process, making the latest version readily available for testing. Once the version in the staging environment is satisfactory, a deployment from the master branch to the production environment releases the changes to the end users. As <a id="_idIndexMarker149"/>an option, before deploying to production, the changes can be deployed to a <strong class="bold">User Acceptance Testing</strong> (<strong class="bold">UAT</strong>) or <strong class="bold">quality assurance</strong> (<strong class="bold">QA</strong>) environment<a id="_idIndexMarker150"/> for <span class="No-Break">further testing.</span></p>
			<p>The following diagram shows a typical feature branch model and how changes in that branch are re-integrated into the master branch so that they can be deployed in your <span class="No-Break">Salesforce environments.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer011">
					<img alt="Figure 3.4 – The feature br﻿anch model" src="image/Figure_3.04_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – The feature br<a id="_idTextAnchor093"/>anch model</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor094"/>The protected master branch model</h2>
			<p>The <a id="_idIndexMarker151"/>protected <a id="_idIndexMarker152"/>master branch model is similar to the feature branch model, but it includes an additional long-lived branch for integration before merging into the master branch. In this model, the master branch is not updated until everything has been fully tested and is ready for release. The master branch is a more secure source of truth since only work that has been thoroughly tested in UAT is included in <span class="No-Break">the branch.</span></p>
			<p>However, one downside of this model is that it is not possible to propagate only a subset of changes if some are not ready yet. If some work has been tested and approved in UAT, but other work is not ready, it is difficult to selectively promote changes to the master branch. Instead, it is necessary to revert features that are not yet ready from the release branch. This inflexibility is a major concern for many teams, which is why this model is not as popular. If you find that you need to selectively promote changes regularly, then you have not selected the right branching strategy for your way <span class="No-Break">of working.</span></p>
			<p>The following diagram illustrates the protected master branch approach, with its separate integration branch for testing changes before they <span class="No-Break">reach production:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer012">
					<img alt="Figure 3.5 – The protected master branch model" src="image/Figure_3.05_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – The protected master branch model</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor095"/>The expanded branching model</h2>
			<p>Taking the process of isolating <a id="_idIndexMarker153"/>branches a step further, the expanded branching <a id="_idIndexMarker154"/>model includes several additional long-lived branches that correspond to the integration and UAT/QA environments. Instead of merging feature branches directly into the master branch, they are first merged into the integration branch. To move changes that are ready for release to the next environment in sequence, they are merged into the UAT/QA branch, and then into the <span class="No-Break">master branch.</span></p>
			<p>This approach allows for more precise control over which changes are deployed to each environment and allows for isolated evaluations of changes on a per-request basis. The expanded branching model is well suited to teams that prioritize gating and quality control over frequent releases. However, like every other branchi<a id="_idTextAnchor096"/>ng strategy we’ve looked at, there are still some important caveats, particularly if merge conflicts are encountered. For example, if merge conflicts are found during the merge to UAT, then the entirety of the UAT branch will need to be merged in to resolve them, which would mean that a subsequent merge to master would bring in the whole of the UAT branch too, whether it is ready to be promoted <span class="No-Break">or not.</span></p>
			<p>You can see the correlation between branches and Salesforce environments in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer013">
					<img alt="Figure 3.6 – The expanded branching model" src="image/Figure_3.06_B19436.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – The expanded branching model</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor097"/>Comparing the branching strategies</h2>
			<p>So, let’s recap and<a id="_idIndexMarker155"/> summarize these <span class="No-Break">four approaches:</span></p>
			<ul>
				<li>Using Git as a backup is pretty self-explanatory: we use it as a mechanism to save our metadata off-platform, which allows us to revert changes – although this is not easy if the change is several Git commits back and there are deep chains of dependencies. It also doesn’t deliver any of the main benefits of a source-driven <span class="No-Break">development approach.</span></li>
				<li>The TBD approach offers an array of advantages that streamline and accelerate software development. By promoting frequent integration of short-lived branches, it drastically reduces the occurrence of “merge hell,” the oft-dreaded scenario of conflicting changes. The visibility of changes is also greatly enhanced as most work is carried out on the main branch, facilitating a clearer understanding of how alterations impact the project. TBD simplifies the development process by eliminating the need to maintain multiple long-lived branches and keeps the main branch in a perpetually releasable state, enabling any-time deployment and thus, quicker delivery <span class="No-Break">of features.</span></li>
				<li>The feature branch model is great for teams that rapidly iterate – we use it ourselves internally and it allows us to deliver changes daily, or often more frequently than that. If your process requires more stage gates and checks along the way, this may not work for your longer <span class="No-Break">dev cycles.</span></li>
				<li>The protected master branch model has multiple testing environments and an integration branch to support them, which means that your primary master or main branch is the source of truth. However, this model still acts as a queue, where items that require longer test cycles can hold up other changes until <span class="No-Break">they’re promoted.</span></li>
				<li>The expanded branch <a id="_idIndexMarker156"/>model allows for a more asynchronous approach to changes, with individual pieces of work that can be moved through the environments. This allows for questions in the style of “Bob, where are we with Jira 34533?” to be answered accurately in the style of “It’s in UAT awaiting sign-off for release to <span class="No-Break">production, Sarah.”</span></li>
			</ul>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor098"/>Summary</h1>
			<p>In this chapter, we looked at the reasons why source control is fundamental to the adoption <span class="No-Break">of DevOps:</span></p>
			<ul>
				<li><strong class="bold">Collaboration</strong>: DevOps emphasizes collaboration in software development. Source control allows multiple developers to work concurrently on a code base without them having to interfere with each other’s changes. By merging and reviewing changes later, teams can achieve faster development and <span class="No-Break">reduce defects.</span></li>
				<li><strong class="bold">Traceability</strong>: The growing need for governance in software development demands accountability and audit trails. Source control provides a comprehensive history of code and configuration changes, including details about the who, what, and why. This not only aids in auditing but also assists in identifying the origin of bugs <span class="No-Break">and issues.</span></li>
				<li><strong class="bold">Automation</strong>: DevOps emphasizes automation, and source control serves as a foundation for automating software development processes such as building, testing, and deploying code. This allows for the automatic execution of these tasks upon committing changes to the <span class="No-Break">code base.</span></li>
				<li><strong class="bold">Continuous integration</strong>: CI enables developers to frequently merge code changes into a shared repository and run automated tests, facilitated by source control. This practice helps detect and resolve issues early, streamlining the <span class="No-Break">development process.</span></li>
				<li><strong class="bold">Continuous deployment</strong>: CD automatically deploys code changes to production after passing CI tests, with source control enabling automation. This integration of CI and CD forms the <span class="No-Break">CI/CD pipeline.</span></li>
				<li><strong class="bold">Rollbacks</strong>: Source control enables easy rollbacks by maintaining a code base history, allowing you to quickly revert to previous versions in case there are bugs or issues in the production environment. This ensures you can efficiently and reliably handle <span class="No-Break">unexpected problems.</span></li>
			</ul>
			<p>We then explored some typical Git operations that you’re likely to use regularly as you work on creating changes to your Salesforce orgs. Finally, we looked at some of the common Git branching strategies for Salesforce development, and the advantages and disadvantages <span class="No-Break">of each.</span></p>
			<p>In the next chapter, we will look at the next fundamental part of a mature Salesforce DevOps process – testing your changes effectively to ensure <span class="No-Break">quality deliverables.</span></p>
		</div>
	</body></html>