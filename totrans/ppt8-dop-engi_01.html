<html><head></head><body>
		<div id="_idContainer015">
			<h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor018"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor019"/>Puppet Concepts and Practices</h1>
			<p>This chapter will focus on the origins of Puppet, why it was created, and how it is used in DevOps engineering. It will look at Puppet’s approach to configuration management and how its declarative approach differs from more regular procedural languages. Puppet has many features that are common in other languages such as variables, conditional statements, and functions. But in this chapter, we will cover the key terms, structure, and ideas of the language that make it different and how the underlying platform runs. We will give a clear, high-level overview of its approach and how it relates to customer needs and infrastructure environments. Finally, as there are a lot of preconceptions regarding Puppet, this chapter will finish by addressing some of the most common ones, including where they come from, and <span class="No-Break">unwrap them.</span></p>
			<p>This should ensure a fundamental understanding of Puppet and its approach before we build up a deeper, technical understanding of the language in upcoming chapters. It will also ensure this book is not just about technology but how genuine value can be delivered to customers using the service that <span class="No-Break">Puppet provides.</span></p>
			<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><a id="_idTextAnchor020"/>Puppet’s history and relationship <span class="No-Break">to DevOps</span></li>
				<li>Puppet as a declarative and <span class="No-Break">idempotent language</span></li>
				<li>Key terms in the <span class="No-Break">Puppet language</span></li>
				<li>Puppet as <span class="No-Break">a platform</span></li>
				<li><span class="No-Break">Common misconceptions</span></li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor021"/>Puppet’s history and relationship to DevOps</h1>
			<p>Puppet was <a id="_idIndexMarker000"/>started by creator and founder Luke Kaines, who was working as a sysadmin and consultant. He was unable to find the tooling he wanted to use and that his customers could rely on, so he created Puppet as a Ruby-based open source configuration management language in 2005. The success of this open source project resulted in the release of a commercial offering, Puppet Enterprise, in February 2011. But as the demands increased and Puppet needed to reform and expand as both a company and an open source project, Luke stood down, stating that the challenges of growing Puppet to enterprise-scale were <em class="italic">far from what I love to do most, and far from my core skills. We need to scale, and we need </em><span class="No-Break"><em class="italic">to execute</em></span><span class="No-Break">.</span></p>
			<p>The new leadership that followed took a direction that saw the company develop its professional services, and focus more effort on developer tooling and education while expanding its product range both organically and via acquisitions, striking a difficult balance between the open source community and its enterprise customer demands. Puppet was acquired by Perforce Software on May 17, 2022, following the Chef (2020) and Ansible (2015) acquisitions, as the last of the standalone configuration management start-ups. Luke summed up the change that has taken place in the industry: <em class="italic">DevOps teams are different now. Companies are looking for a complete solution, rather than wanting to integrate individual </em><span class="No-Break"><em class="italic">best-of-breed vendors.</em></span></p>
			<p>This history has <a id="_idIndexMarker001"/>seen Puppet move from a tool that left it to the developer to decided how best to use it to solve problems to, today, a tool with patterns and solutions that users can just consume to standardize their automation and deployment. This has allowed users to focus on their solutions and not the <span class="No-Break">underlying technology.</span></p>
			<p>DevOps itself has <a id="_idIndexMarker002"/>become a frustrating term in the IT industry; the definition given by formal sources differs hugely from how companies actually use it, and references to it can be used as a cynical buzzword or sales gimmick. The focus of this book is on DevOps engineering, as used particularly by large companies and has been well r1esearched and discussed in studies such as the Puppet-run <em class="italic">State of DevOps Report</em>. DevOps engineering is normally delivered as part of projects such as digital transformations, cloud-first migrations, and various other modernization projects. What is typically seen in these projects is a desire to automate self-service deployment, compliance, and remove toil. This approach follows the DevOps goal of breaking down the silos between developers and ops teams by allowing better communication and establishing shared goals. What is noticeable is that the system administrator role in which Luke worked originally has effectively been replaced by roles such as <span class="No-Break">DevOps engineers.</span></p>
			<p>Puppet will be used as part of a DevOps toolchain, and <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em> shows an example set of tools and their relative functions. It is typical for Puppet to start its role at the end of a provisioning pipeline, as infrastructure is stood up in a platform and needs to be configured <span class="No-Break">and enforced:</span></p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/Figure_01.01.jpg" alt="Figure 1.1 – A DevOps toolset"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – A DevOps toolset</p>
			<p>This book will <a id="_idIndexMarker003"/>focus not just on a technological understanding but also on how to use the maturity of the Puppet language, tooling, and platform with opinionated patterns. These approaches have been developed through years of customer engagements for Puppet and the communities’ own implementations to allow users to reduce their effort in finding the right approach, focus on their solutions, and deliver immediate benefit and return to <span class="No-Break">their customers.</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor022"/>Puppet as a declarative and idempotent language</h1>
			<p>The first important thing to understand is how Puppet differs from normal scripting or coding languages. Puppet <a id="_idIndexMarker004"/>is declarative, meaning you describe the state you want the system to be in. For example, you could describe that your system should have a user called <strong class="source-inline">username</strong> with UID <strong class="source-inline">1234</strong>, a configuration file should not exist, and a kernel setting should be at a particular value. In comparison to most languages where you have to describe the process to get to the state, Puppet’s approach brings us closer to how customers request services. They don’t want to know how it’s done, just that it will meet their requirements. These resource definitions can be saved in your version control system. Often, this approach is described as <a id="_idIndexMarker005"/>being part of <strong class="bold">Infrastructure </strong><span class="No-Break"><strong class="bold">as Code</strong></span><span class="No-Break">.</span></p>
			<p>Puppet is idempotent, meaning that it will only make the changes required to get into the declared state. Meanwhile, most procedural languages will run steps every time and, typically, require various checks such as <strong class="source-inline">if</strong> statements to be added to make checks to avoid duplication. This is particularly powerful as what is called <em class="italic">enforcement</em> can be run with the Puppet language, ensuring the state you declared has been reached, and is capable of detecting whether a change happened because of you updating the state you wished the <a id="_idIndexMarker006"/>machine to be in or whether it was a change that happened on the machine itself moving away from the desired state. This can greatly assist with audits and avoid any configuration drifts in an estate and ensure change is managed <span class="No-Break">and deliberate.</span></p>
			<p>Puppet is OS-independent; the language is focused on the state, not the underlying implementation of how particular OSes install a package or add a user. This gives us a universal language that is independent of any underlying implementations, allowing for less duplication of code, avoiding the need to use layers of <strong class="source-inline">case</strong>/<strong class="source-inline">if</strong> statements to detect differences, and allowing multiple language implementations such as PowerShell for Windows and Bash for Unix-based systems. Additionally, it makes it easier to recover after failures in applying code. If in a procedural language, a step fails, it might not be safe to run the script in full again depending on how well the check steps have been coded. In contrast, Puppet code is able to resume only performing the steps it needs to reach the <span class="No-Break">correct state.</span></p>
			<p>A simple example of Puppet code to create a user would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
user { 'david'
  uid =&gt; '123'
}</pre>
			<p>In contrast, a shell script might have a section <span class="No-Break">like this:</span></p>
			<pre class="source-code">
if ! getent passwd david; then
  useradd -u 123 david
elif ! $(uid david) == 123; then
  usermod -u 123 david
fi</pre>
			<p>In the preceding shell example, we have to check whether a user exists, and if not, create one. If it does exist, then does it have the right UID? If not, we change it. This script only covers OSes that can use <strong class="source-inline">useradd</strong> and <strong class="source-inline">usermod</strong>. To achieve compatibility with multiple OSes, we would need a test to detect the OS type and produce a section of code like this for every OS or group of OSes and their required commands. Often, it would be more practical to write in multiple languages and scripts to cover a broader base of OS flavors, that is, if we wanted to cover both Unix and Windows, <span class="No-Break">for example.</span></p>
			<p>This compares to <a id="_idIndexMarker007"/>the Puppet declaration, which will work on multiple OSes without change as Puppet will detect the required commands and perform all the necessary state checks as part <span class="No-Break">of that.</span></p>
			<p>This example is all just for a single resource with a single attribute. You can quickly see how the shell script example will not scale as it becomes increasingly complex with almost endless checks <span class="No-Break">and options.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor023"/>Key terms in the Puppet language</h1>
			<p>Looking at the <a id="_idIndexMarker008"/>Puppet language in more detail, the most fundamental item in Puppet is a <strong class="bold">resource</strong>. Each resource describes some part of the system and the desired state you wish it to be in. Each resource has a <strong class="bold">type</strong>, which is a definition for the Puppet language of how this particular resource can be configured, which <strong class="bold">attributes</strong> can be set, and what <strong class="bold">providers</strong> can be used. The attributes are what describe the state. So, for a user, this might be a home directory or, for a file, the permissions. <strong class="bold">Providers</strong> are what <a id="_idIndexMarker009"/>make the Puppet OS independent since they do the underlying commands be they for creating a user or installing <span class="No-Break">a package.</span></p>
			<p>So, let’s take an example of a company that typically submits build request forms to an environments team to request the configuration for <span class="No-Break">a server:</span></p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Table_01.01.jpg" alt="Table 1.1 – An example build request form"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 1.1 – An example build request form</p>
			<p>In <em class="italic">Table 1.1</em>, the request <a id="_idIndexMarker010"/>form, we see groupings of users, groups, and directories, which are all, essentially, <strong class="bold">types</strong>. Each item under them is a resource, and the configuration settings are <span class="No-Break">the attributes.</span></p>
			<p>This request could translate to something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
user { 'exampleapp':
  uid =&gt; '1234'.
  gid =&gt; '123'
}
group { 'exampleapp':
  Gid =&gt; '123'
}
file { '/opt/exampleapp/':
  owner =&gt; 'exampleapp',
  group =&gt; 'exampleapp',
  mode  =&gt; 755
}
file { '/etc/exampleapp/':
  owner =&gt; 'exampleapp',
  group =&gt; 'exampleapp',
  mode  =&gt; 750
}</pre>
			<p>The preceding <a id="_idIndexMarker011"/>example shows how Puppet translates more directly to user requests and can remain readable without even understanding any of the <span class="No-Break">Puppet language.</span></p>
			<p>What isn’t visible, in this example, is the <strong class="bold">providers</strong>. Puppet has defaults, such as in the preceding example, where the user resource assumes a RedHat host will use the <strong class="source-inline">usermod</strong> provider. Instead, if I wished to use LDAP commands for user creation, I would set my <strong class="source-inline">provider</strong> attribute <span class="No-Break">to LDAP.</span></p>
			<p>The next important thing to note is that due to the nature of writing Puppet in a stateful way, we are not writing an ordered process that executes line by line but only declaring the state of resources that could be implemented in any order. Therefore, if we have any dependencies, we need to use the <strong class="source-inline">relationship</strong> parameter; this describes a before/after relationship, which is exactly as it sounds, or a subscribe/refresh, whereby, for example, updating a configuration file could cause a service to restart. In the previous example, Puppet automatically creates certain dependencies such as ensuring the group is created before the user, so we don’t have to add a <strong class="bold">relationship</strong> parameter.Often, these relationships are seen as one of the most difficult parts of Puppet to adapt to, as many coders are used to writing a process to follow and mistakes can be made. This can cause a cycle of dependencies, whereby a chain of these dependencies cycles round, and there is no way to create a starting resource that isn’t dependent <span class="No-Break">on another.</span></p>
			<p>Evidently, the resources we declare need a structure, and the first step is for this code to be in a file. Puppet calls these <strong class="bold">manifest</strong> files, which have an extension of <strong class="source-inline">.pp</strong>. <strong class="bold">Classes</strong> are blocks of Ppuppet code that give us a way to specifically call sections of code to be run on hosts. Normally, as a good practice, we only have one <strong class="bold">class</strong> in a <strong class="bold">manifest</strong> file. Puppet then uses <strong class="bold">modules</strong> as a way to group these <strong class="bold">manifests</strong> and <strong class="bold">classes</strong>. This grouping is based on the principle that a <strong class="bold">module</strong> should do a single thing well and represent <a id="_idIndexMarker012"/>a technical implementation, such as a <strong class="bold">module</strong> configuring the IIS application or configuring postfix as a mail relay. <strong class="bold">Modules</strong> are simply a directory structure storing the <strong class="bold">manifests</strong>, <strong class="bold">classes</strong>, and other Puppet items (which we will cover, in detail, in <a href="B18492_08.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>) and are not a keyword in the language itself. So, ideally, modules should be shareable and reusable for different users and organizations with many taken straight from the <strong class="bold">Puppet Forge</strong>, which is Puppet’s catalog of modules with both commercial and open <span class="No-Break">source offerings.</span></p>
			<p>An example of one common style and practice for modules is to have a manifest file with a single class for <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">install.pp</strong> (grouping resources related to <span class="No-Break">installing software)</span></li>
				<li><strong class="source-inline">config.pp</strong> (grouping resources related to <span class="No-Break">configuring software)</span></li>
				<li><strong class="source-inline">service.pp</strong> (grouping resources related to <span class="No-Break">running services)</span></li>
				<li><strong class="source-inline">init.pp</strong> (a way of initializing the module and <span class="No-Break">accepting parameters)</span></li>
			</ul>
			<p>At a higher level, we then have <strong class="bold">roles</strong> and <strong class="bold">profiles, which</strong> are used to create the structure of your organization. While <strong class="bold">modules</strong> should be sharable and repeatable installations of technical implementations, such as Oracle or IIS, <strong class="bold">roles</strong> and <strong class="bold">profiles</strong> will only have context within your organization. <strong class="bold">Roles</strong> and <strong class="bold">profiles</strong> are <strong class="bold">classes</strong> used to group <strong class="bold">modules</strong> and selected parameters into logical technical stacks and customer solutions. It is common to make a <strong class="bold">roles module</strong> and a <strong class="bold">profiles module</strong> while keeping together the <span class="No-Break"><strong class="bold">classes</strong></span><span class="No-Break"> used.</span></p>
			<p>What can be confusing, at this point, is that you can end up with an Oracle <strong class="bold">Role</strong>, an Oracle <strong class="bold">profile</strong>, and an Oracle <strong class="bold">module</strong>. So, while the Oracle module configures and installs Oracle with various parameters available to it to customize the installation, the Oracle profile is about how your organization uses this module and what other modules it might add to this technology stack. You might specify that you always use Oracle with a cluster service and, therefore, your Oracle profile contains both an Oracle module and a cluster module. Alternatively, it might pass parameters to the Oracle module within your profile, which set default kernel settings for your <span class="No-Break">organization’s configuration.</span></p>
			<p>You can think of a role as being what the customer actually wants when they submit a build request; they need a particular type of server, be it an Oracle or an IIS server. They don’t care about <a id="_idIndexMarker013"/>the underlying implementations – only that it meets their requirements. While the Oracle role will certainly need the Oracle profile, it will expect it to meet the OS security standard and to have any agents or other supporting tools your organization defines. Therefore, a common profile for many organizations is a base OS security standard that ensures every server is compliant and that is part of almost <span class="No-Break">every role.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em> shows an example of what has just been described as an Oracle role class in the roles module, which includes an Oracle profile class and an OS security profile class, both from the profile module. Then, the Oracle profile includes an Oracle module, while the <strong class="source-inline">os_security</strong> profile includes the <span class="No-Break">DNS module:</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_01.02.jpg" alt="Figure 1.2 – The structure of roles, profiles, and modules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – The structure of roles, profiles, and modules</p>
			<p>In <a href="B18492_08.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, we will go into <a id="_idIndexMarker014"/>more technical detail, but the key takeaway from this overview is to understand that modules provide sharable and reusable single-use technical installations. In contrast, the roles and profiles pattern provides the context for your organization. Roles are for customers ordering server offerings; they don’t need to understand the technical implementation, only that it meets their business requirement. The profiles in your organization’s technology stack are managed by technical designers and architects, who combine and specify modules according to your organization’s standards and configurations. These roles are responsible for defining how different components are integrated to create the desired technology stack. So while an Oracle module by itself can configure and install Oracle, it is the profile that defines the exact configurations that should be passed to that Oracle module and the other modules it may be dependent on such as having a NetBackup <span class="No-Break">client installed.</span></p>
			<p>With what we have <a id="_idIndexMarker015"/>covered in modules, roles, and profiles, going back to <em class="italic">Table 1.1</em>, instead, we can have a customer submitting the build request form but not having to specify everything they need; they could simply order an <strong class="source-inline">exampleapp</strong> <span class="No-Break">role server.</span></p>
			<p>What we have seen so far is fine when servers meet all the specifications and are standard, but exceptions <a id="_idIndexMarker016"/>are commonplace. <strong class="bold">Hiera</strong> is Puppet's data system, and it can be used to pass parameters to the roles and profiles model to handle exceptions. Hiera, as its name suggests, is hierarchical. It defines an ordered lists of data sources to access to find the most relevant setting. These data sources will typically be ordered from the default value for all nodes to a more specific group such as a particular role and specific values for an <span class="No-Break">individual node.</span></p>
			<p>For example, if email servers were disabled by the default OS security profile but were required for <strong class="source-inline">exampleapp</strong>, we could have the following <span class="No-Break">YAML file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">exampleapp.yaml</p>
			<pre class="source-code">
profile::os_security:email_enabled: true</pre>
			<p>Similarly, if <strong class="source-inline">server1</strong> needed a different UID, we could have the following <span class="No-Break">YAML file:</span></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">server1.yaml</p>
			<pre class="source-code">
profile::exampleapp:uid: '1235'</pre>
			<p>One of the most important points of creating these patterns is to avoid hardcoded values in your modules. By using Hiera, you give yourself a dynamic way to change the values in the future without modifying the code. This could evolve to access the data via a self-service portal – automating away from builds ordered via spreadsheets, emails, and discussions, which would have to be configured by the build teams instead of portals such as VMware vRealize Automation <span class="No-Break">or ServiceNow:</span></p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_01.03.jpg" alt="Figure 1.﻿3 – An example portal"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – An example portal</p>
			<p>In <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.3</em>, an example portal <a id="_idIndexMarker017"/>shows how customers can be presented with simplified products. The focus of the Puppet language should be to deliver consistent products to customers and allow customers, architects, and technical staff to focus on what they care about and not have to delve into the technical requirements or coding <span class="No-Break">sections themselves.</span></p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor024"/>Puppet as a platform</h1>
			<p>So far, this chapter has focused on the Puppet language, but now we will look at the Puppet platform <a id="_idIndexMarker018"/>and how it applies the desired state to client servers. Puppet can be run with just an installed agent and all the files locally, which is common for testing, but this overview will focus on the client-server setup. In <em class="italic">Chapters 10</em>, <em class="italic">13</em>, and <em class="italic">14</em>, we will go into much more detail about resilience, scalability, and more advanced running options. However, for now, we will focus on how a Puppet client talks to a server to request and apply its <span class="No-Break">desired state.</span></p>
			<p>Every client under Puppet control will install a Puppet agent. <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.4</em> shows the steps of a Puppet agent run, which this section <span class="No-Break">will outline:</span></p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_01.04.jpg" alt="Figure 1.﻿4 – The Puppet agent run life cycle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – The Puppet agent run life cycle</p>
			<p>The first step <a id="_idIndexMarker019"/>is for the agent to identify itself to the primary server with SSL keys or to create new SSL keys for the primary server to sign. This will secure communication between the server <span class="No-Break">and client.</span></p>
			<p>The next action is for the client <a id="_idIndexMarker020"/>to use a Ruby library called <strong class="source-inline">Facter</strong>. This is a system profiler to gather what is known as <strong class="bold">facts</strong> about the system. This can be things such as the OS version or RAM size. These facts can be used in code or by Hiera to make choices about what state a host should be in, such as Windows Server 2022 having a particular <span class="No-Break">registry setting.</span></p>
			<p>Then, the server identifies what classes should be applied to a server. Typically, this is done by what <a id="_idIndexMarker021"/>is called an <strong class="bold">end node classifier</strong> (<strong class="bold">ENC</strong>) script, which is based on the facts and user definitions. Normally, this will apply a role class to a server, which, as we discussed in the previous section, builds up a definition of profiles and <span class="No-Break">module classes.</span></p>
			<p>Then, the primary server compiles a catalog and a YAML file of the resources to be applied to the node (ensuring the CPU-intensive work happens on the server and not <span class="No-Break">the client).</span></p>
			<p>This catalog is then sent to the client who uses the catalog as a blueprint of what the state should look like and makes any necessary changes to enforce the state on <span class="No-Break">the client.</span></p>
			<p>Finally, a report is <a id="_idIndexMarker022"/>sent back to the primary server confirming what resources were applied and whether these resources had to be changed due to a change in Puppet code or whether they were changed outside of Puppet control (which might be an audit or <span class="No-Break">security breach).</span></p>
			<p>In <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.5</em>, we see an example extract from a Puppet report showing the name of the resource, the type of change made, and the value it needed to change. Additionally, the report includes a record of unchanged resources highlighting what is part of <span class="No-Break">Puppet's enforcement:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_01.05.jpg" alt="Figure 1.﻿5 – The Puppet console server report"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – The Puppet console server report</p>
			<p>By default, this cycle takes place every 30 minutes. In the previous sections, the focus was on how <a id="_idIndexMarker023"/>the language can automate the building of servers. Here, we can see that, via the platform, we can ensure all our deployed servers are enforced with the state we set out to achieve; whether that be a security standard profile or whether we decided to update the settings in a particular implementation such as adding extra features to IIS. This avoids server drift, where servers on the estate are difficult to keep up to date or are vulnerable to changes made manually in error or that maliciously breach standards. <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.6</em> shows the dashboard view of Puppet Enterprise, giving a clear view of an estate of servers and the status of the last run. This highlights whether <a id="_idIndexMarker024"/>the servers are in compliance with our state or had to make changes in their <span class="No-Break">previous run:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_01.06.jpg" alt="Figure 1.﻿6 – The Puppet console status dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – The Puppet console status dashboard</p>
			<p>What we have reviewed so far would presume a common code base, and when any code changes are made, all clients would have a new state enforced within the next 30 minutes as agents contact the primary server. This would clearly be problematic, as bugs will affect all servers within a brief period. This is why Puppet has <strong class="bold">environments</strong>. An environment is <a id="_idIndexMarker025"/>a collection of versioned modules. This is achieved by storing the modules in revision control, such as <strong class="source-inline">git</strong>, where the version can be declared as a commit, a tag, or a <a id="_idIndexMarker026"/>branch, which we can list in a file called <span class="No-Break">a </span><span class="No-Break"><strong class="bold">Puppetfile</strong></span><span class="No-Break">.</span></p>
			<p>An example module declaration would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
mod 'apache',
  :git =&gt; 'https://github.com/exampleorg/exampleapp'
  :tag =&gt; '1.2'</pre>
			<p>By maintaining this <strong class="bold">Puppetfile</strong> in <strong class="source-inline">git</strong>, in what is known as a <strong class="bold">control</strong> repo, it is possible to represent multiple environments by having different branches with different versions of the <span class="No-Break">Puppet file.</span></p>
			<p>A common practice is to match environments against how your organization classifies server usage. Normally, this means a minimum of a development environment and a production environment. So, changes can be tested against servers in development, and then the successfully tested ones can be deployed to production. This can be taken further using canary environments to test small subsets of the server. This approach can all be customized to the change and risk setup of <span class="No-Break">different organizations.</span></p>
			<p>All the facts and reports we mentioned, as part of the agent cycle, are stored in <strong class="source-inline">PuppetDB</strong>, a frontend database for PostgreSQL. which is designed to manage Puppet data such as reports and facts. This is <a id="_idIndexMarker027"/>used with the <strong class="bold">Puppet Query Language</strong> (<strong class="bold">PQL</strong>), which allows us to search the information we have gathered. This can allow for searching of facts giving <strong class="source-inline">CMDB</strong> style data and for combinations where we can check whether a certain resource for a role had changed, which could indicate a change breach had <span class="No-Break">taken place.</span></p>
			<p>So, in this section, we have seen that the Puppet platform gives a way to progressively deploy new code based on environments. It stores facts about the clients along with the reports generated on each run, giving a powerful view of CMDB along with audit and compliance information in the reports as we confirm what state the servers are in. This can all be searched using PQL. This can lead to huge savings in operational toil in terms of audit and compliance report generation and helps avoid building technical debt as standards and <span class="No-Break">configurations change.</span></p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor025"/>Common misconceptions</h1>
			<p><em class="italic">Isn’t </em><span class="No-Break"><em class="italic">Puppet dead?</em></span></p>
			<p>The focus of <a id="_idIndexMarker028"/>bleeding-edge technology has moved on to serverless and other <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>)/containerized offerings, while <a id="_idIndexMarker029"/>at an <strong class="bold">Infrastructure-as-a-Service</strong> (<strong class="bold">IaaS</strong>) level, development in Puppet has reached a much greater level of maturity. 10 years ago, you might have bought this book assuming it was relevant regardless of whether you were going to work with Puppet. Today, you have a Puppet solution to implement <span class="No-Break">or understand.</span></p>
			<p><em class="italic">I need to know Ruby to </em><span class="No-Break"><em class="italic">use Puppet</em></span><span class="No-Break">.</span></p>
			<p>Some basic knowledge <a id="_idIndexMarker030"/>of Ruby would be an advantage for certain areas of Puppet code. A focus on the good use of the Puppet language to get early returns is what this book will focus on, and the reality is that the majority of Puppet professionals don’t spend much time with Ruby trying to create customizations. Even specialists working for Puppet itself find that it can be some time before they need to write something custom <span class="No-Break">in Ruby.</span></p>
			<p><em class="italic">Puppet won’t work with our </em><span class="No-Break"><em class="italic">change management</em></span><span class="No-Break">.</span></p>
			<p>A big fear is the idea of Puppet making changes outside the scope of governance and change management. This often reflects assumptions and a lack of communication with change management teams. Puppet will enforce the state you have described; therefore, changes will <a id="_idIndexMarker031"/>only happen if the state described in the code has changed or if it has been changed outside of Puppet’s control. As previously mentioned, as long as it is agreed that Puppet is the way to define particular resources, any change to the state should be seen as outside of governance and, therefore, put back into place. Later chapters will discuss how to release code and environments to ensure that Puppet remains properly access-controlled and, therefore, <span class="No-Break">within governance.</span></p>
			<p><em class="italic">I can’t make manual changes </em><span class="No-Break"><em class="italic">or exceptions</em></span><span class="No-Break">.</span></p>
			<p>This could certainly happen if users try to work around Puppet. To avoid this, it’s important to define <a id="_idIndexMarker032"/>what Puppet is responsible for, what other tooling or manual processes are responsible for, and how exceptions should be requested and approved in your system. As will be discussed in <em class="italic">Chapters 8</em> and <em class="italic">9</em>, by using parameters in modules and Hiera for exceptions, a controlled method can be used for exceptions, which also keeps a record <span class="No-Break">in code.</span></p>
			<p><em class="italic">I need Puppet Enterprise to use add-ons </em><span class="No-Break"><em class="italic">and integrations</em></span><span class="No-Break">.</span></p>
			<p>There is a huge amount of confusion, particularly from industry analysts, who make comparisons about <a id="_idIndexMarker033"/>what users get with Puppet Enterprise and how open <a id="_idIndexMarker034"/>source might be limited. This book will go into more depth in <a href="B18492_14.xhtml#_idTextAnchor340"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, but the fundamental difference for Puppet Enterprise is you are paying for support, services, and pre-canned modules, infrastructure, and solutions. If you have the skills, developers, and time, all of these features can be replicated in open source. Ultimately, Enterprise runs on the open <span class="No-Break">source components.</span></p>
			<p><em class="italic">Everyone will need to </em><span class="No-Break"><em class="italic">learn Puppet</em></span><span class="No-Break">.</span></p>
			<p>A major focus <a id="_idIndexMarker035"/>of this book will be the importance of structuring code to allow for self-service processes. This avoids users who might wish to have small exceptions or integrations having to learn everything as a Puppet developer and only having to understand <span class="No-Break">your offerings.</span></p>
			<p><em class="italic">It will clash with </em><span class="No-Break"><em class="italic">other systems</em></span><span class="No-Break">.</span></p>
			<p>The key part is to understand what Puppet will be responsible for and what other systems will be responsible for, and to document this well. Many environments will run multiple configuration management, orchestration, and software management tools. The important thing is to use them to their strengths with <span class="No-Break">clear boundaries.</span></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor026"/>Summary</h1>
			<p>In this chapter, you learned how Puppet was created by Luke Kaines as a stateful language to ease the automation of the configuration management of servers. We learned how using this stateful approach provides a language more natural for describing user requirements for configuration management and reduces the complexity involved in more traditional <span class="No-Break">procedural approaches.</span></p>
			<p>We looked at an overview of the core language terms and components and how they are structured via roles, profiles, and modules. This structure offers a natural way to create customer offerings, technical stacks, and reusable <span class="No-Break">technical modules.</span></p>
			<p>We looked at how the states described in the language are then applied to hosts via Puppet runs, and from these runs, we examined how valuable audit and compliance information can be gathered and stored in <strong class="source-inline">PuppetDB</strong>. We discussed how code can be managed in environments to allow the gradual release of state changes in a managed way in logical groups of servers that suits your organization’s risk appetite and <span class="No-Break">development structure.</span></p>
			<p>The chapter discussed some misconceptions around Puppet along with the main themes of relevance, complexity, and flexibility. Puppet’s maturity and focus on IaaS make it less fashionable, but using patterns and modules developed by Puppet and the community allows you to use Puppet to its strengths and deliver automation and self-service configuration and compliance to customers. Ensuring clear boundaries and responsibilities so that Puppet can integrate with, and work alongside, other tooling and teams avoids clashes and allows others to interact with Puppet and gain <span class="No-Break">the benefits.</span></p>
			<p>In the next chapter, we will review the major changes that have taken place in Puppet since version 5 and in the latest version, 7. Recommendations of the tooling to use to create an effective development environment will be made, and the creation of lab environments will be outlined and demonstrated. Additional reference sites will be outlined to allow readers to continue their research and stay up to date with developments in Puppet. This will ensure that as we start on the technical details in the following chapters, you will have the capability to test and experiment in your own environment and follow up in more detail on your points <span class="No-Break">of interest.</span></p>
		</div>
	</body></html>