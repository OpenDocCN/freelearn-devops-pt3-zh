<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer018">
			<h1 id="_idParaDest-189"><a id="_idTextAnchor403"/>Chapter <a id="_idTextAnchor404"/><a id="_idTextAnchor405"/>7: Writing Command-Line Tooling</h1>
			<p>Visit any DevOps engineer and you will find their screens filled with terminals executing <strong class="bold">Command-Line Interface</strong> (<strong class="bold">CLI</strong>) applications.</p>
			<p>As a DevOps engineer, we don't want to only use applications that others have made for us; we want to be able to write our own CLI applications. These applications might communicate to various systems via REST or gRPC, as we discussed in our previous chapter. Or you might want to execute various applications and run their output through custom processing. An application might even set up a development environment and kick off a test cycle for a new release.</p>
			<p>Whatever your use case, you will need to use some common packages to help you manage the application's input and output processing. </p>
			<p>In this chapter, you will learn how to use the <strong class="source-inline">flag</strong> and <strong class="source-inline">os</strong> packages to write simple CLI applications. For more complex applications, you will learn how to use the Cobra package. These skills, combined with the skills gained from our previous chapter, will let you build a wide gamut of applications for your needs or those of your customers.</p>
			<p>We will cover the following main topics in this chapter:</p>
			<ul>
				<li>Implementing application I/O</li>
				<li>Using Cobra for advanced CLI applications</li>
				<li>Handling OS signals</li>
			</ul>
			<p><a id="_idTextAnchor406"/>In this first section, we will jump into how to use the standard library's <strong class="source-inline">flag</strong> package to build basic command-line programs. Let's get started!</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor407"/>Technical requirements</h1>
			<p>The code files for this chapter can be downloaded from <a href="https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7">https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7</a></p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor408"/>Implementing application I/O</h1>
			<p>CLI applications require a way to understand<a id="_idIndexMarker656"/> how you want them to execute. This might include what files to read, what servers to contact, and what credentials to use. </p>
			<p>There are a couple of ways to start an application with the parameters it requires:</p>
			<ul>
				<li>Using the <strong class="source-inline">flag</strong> package to define command-line flags</li>
				<li>Using <strong class="source-inline">os.Args</strong> to read arguments that are not defined</li>
			</ul>
			<p>The <strong class="source-inline">flag</strong> package will help you when<a id="_idIndexMarker657"/> you have a command-line argument that has a strict definition. This might be an argument that defines the endpoint for a needed service. The program might want to have a default value for production , but allow an override when doing testing. This is perfect for a flag.</p>
			<p>An example might<a id="_idIndexMarker658"/> be a program that queries our <strong class="bold">Quote of the Day</strong> (<strong class="bold">QOTD</strong>) server that we created earlier. We might want to have it automatically use our production endpoint unless we specify it to use another address. This might look like this:</p>
			<p class="source-code">qotd</p>
			<p>This simply contacts our production server and gets our quote. The <strong class="source-inline">--endpoint</strong> flag, which defaulted to our production address, will use another address below:</p>
			<p class="source-code">qotd --endpoint="127.0.0.1:3850"</p>
			<p>Sometimes, application arguments will suffice. Take an application that reformats JSON data for human readability. We might want to just read from <strong class="source-inline">STDIN</strong> if no files are provided. In this case, just reading the values from the command line will suffice, using the <strong class="source-inline">os</strong> package. This will give us executions that look like this:</p>
			<p class="source-code">reformat file1.json file2.json</p>
			<p>Here, we are reading in <strong class="source-inline">file1.json</strong> and <strong class="source-inline">file2.json</strong> and outputting the reformatted text.</p>
			<p>Here, we receive the output from the <strong class="source-inline">wget</strong> call and read that via STDIN to our <strong class="source-inline">reformat</strong> binary . This is similar to how <strong class="source-inline">cat</strong> and <strong class="source-inline">grep</strong> work. When our arguments are empty, they simply read from <strong class="source-inline">STDIN</strong>:</p>
			<p class="source-code">wget "http://some.server.com" | reformat</p>
			<p>And sometimes, we may want a mix of flags and arguments. The <strong class="source-inline">flag</strong> package can help with that as well.</p>
			<p>So, let's jump into using the <strong class="source-inline">flag</strong> package.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor409"/>The flag package</h2>
			<p>To help take<a id="_idIndexMarker659"/> in command-line arguments, Go has the standard library <strong class="source-inline">flag</strong> package. With <strong class="source-inline">flag</strong>, you can set up default values for your flags, provide descriptions for flags, and allow users to override defaults at the command line.</p>
			<p>Flags with the <strong class="source-inline">flag</strong> package are simply proceeded by <strong class="source-inline">--</strong>, similar to <strong class="source-inline">--endpoint</strong>. Values can simply be a contiguous string following the endpoint or a quoted string. While you can use a single <strong class="source-inline">-</strong> instead of <strong class="source-inline">--</strong>, there are some corner cases when dealing with Boolean flags. I would recommend using <strong class="source-inline">--</strong> in all cases.</p>
			<p>You can find the <strong class="source-inline">flag</strong> package documentation here: <a href="https://pkg.go.dev/flag">https://pkg.go.dev/flag</a>.</p>
			<p>Let's show a flag in action:</p>
			<p class="source-code">var endpoint = flag.String(</p>
			<p class="source-code">     "endpoint", </p>
			<p class="source-code">     "myserver.aws.com", </p>
			<p class="source-code">     "The server this app will contact",</p>
			<p class="source-code">)</p>
			<p>This code does the following:</p>
			<ul>
				<li>Defines an <strong class="source-inline">endpoint</strong> variable that stores the flag</li>
				<li>Uses a <strong class="source-inline">String</strong> flag</li>
				<li>Defines the flag as <strong class="source-inline">endpoint</strong></li>
				<li>Sets the flag's default value as <strong class="source-inline">myserver.aws.com</strong></li>
				<li>Sets the flag's description</li>
			</ul>
			<p>If we don't pass <strong class="source-inline">--endpoint</strong>, the code will use the default value. To have our program read the value, we simply do the following:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     flag.Parse()</p>
			<p class="source-code">     fmt.Println("server endpoint is: ", *endpoint)</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Important Note </p>
			<p class="callout"><strong class="source-inline">flag.String()</strong> returns <strong class="source-inline">*string</strong>, hence <strong class="source-inline">*endpoint</strong> above.</p>
			<p><strong class="source-inline">flag.Parse()</strong> is crucial to making your flags<a id="_idIndexMarker660"/> available in your application. This should only be called inside your <strong class="source-inline">main()</strong> package. </p>
			<p class="callout-heading">Pro Tip </p>
			<p class="callout">A best practice in Go is to never define flags outside your <strong class="source-inline">main</strong> package. Simply pass the values as function arguments or in object constructors.</p>
			<p><strong class="source-inline">flag</strong> also defines a few other flag functions other than <strong class="source-inline">String()</strong>:</p>
			<ul>
				<li><strong class="source-inline">Bool()</strong> for capturing <strong class="source-inline">bool</strong></li>
				<li><strong class="source-inline">Int()</strong> for capturing <strong class="source-inline">int</strong></li>
				<li><strong class="source-inline">Int64()</strong> for capturing <strong class="source-inline">int64</strong></li>
				<li><strong class="source-inline">Uint()</strong> for capturing <strong class="source-inline">uint</strong></li>
				<li><strong class="source-inline">Uint64()</strong> for capturing <strong class="source-inline">uint64</strong></li>
				<li><strong class="source-inline">Float64()</strong> for capturing <strong class="source-inline">float64</strong></li>
				<li><strong class="source-inline">Duration()</strong> for capturing <strong class="source-inline">time.Duration</strong>, such as <strong class="source-inline">3m10s</strong></li>
			</ul>
			<p>Now that we have seen the basic types, let's talk about custom flag types.</p>
			<h2 id="_idParaDest-193"><a id="_idTextAnchor410"/>Custom flags</h2>
			<p>Sometimes, we want to take values<a id="_idIndexMarker661"/> and put them in types that aren't defined in the <strong class="source-inline">flag</strong> package. </p>
			<p>To use a custom flag, you must define a type that implements the <strong class="source-inline">flag.Value</strong> interface, defined as the following:</p>
			<p class="source-code">type Value interface {</p>
			<p class="source-code">     String() string</p>
			<p class="source-code">     Set(string) error</p>
			<p class="source-code">}</p>
			<p>Next, we are going to borrow<a id="_idIndexMarker662"/> an example from Godoc that shows a custom value called <strong class="source-inline">URLValue</strong>, which handles flags that represent URLs, and store it in our standard <strong class="source-inline">*url.URL</strong> type:</p>
			<p class="source-code">type URLValue struct {</p>
			<p class="source-code">    URL *url.URL</p>
			<p class="source-code">}</p>
			<p class="source-code">func (v URLValue) String() string {</p>
			<p class="source-code">    if v.URL != nil {</p>
			<p class="source-code">        return v.URL.String()</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return ""</p>
			<p class="source-code">}</p>
			<p class="source-code">func (v URLValue) Set(s string) error {</p>
			<p class="source-code">    if u, err := url.Parse(s); err != nil {</p>
			<p class="source-code">        return err</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">        *v.URL = *u</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return nil</p>
			<p class="source-code">}</p>
			<p class="source-code">var u = &amp;url.URL{}</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">    flag.Var(&amp;URLValue{u}, "url", "URL to parse")</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">    flag.Parse()</p>
			<p class="source-code">    if reflect.ValueOf(*u).IsZero() {</p>
			<p class="source-code">        panic("did not pass an URL")</p>
			<p class="source-code">    }</p>
			<p class="source-code">    fmt.Printf(`{scheme: %q, host: %q, path: %q}`, </p>
			<p class="source-code">                 u.Scheme, u.Host, u.Path)</p>
			<p class="source-code">}</p>
			<p>This code<a id="_idIndexMarker663"/> does the following:</p>
			<ul>
				<li>Defines a <strong class="source-inline">flag.Value</strong> type called <strong class="source-inline">URLValue</strong></li>
				<li>Creates a flag called <strong class="source-inline">-url</strong> that reads in a valid URL</li>
				<li>Uses the <strong class="source-inline">URLValue</strong> wrapper to store the URL in a <strong class="source-inline">*url.URL</strong> variable</li>
				<li>Uses the <strong class="source-inline">reflect</strong> package to determine whether <strong class="source-inline">struct</strong> is empty</li>
			</ul>
			<p>By defining a <strong class="source-inline">Set()</strong> method on a type, as we did previously, you can read in any custom value.</p>
			<p>Now that we have our flag types down, let's look at some basic error handling.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor411"/>Basic flag error handling</h2>
			<p>When we enter flags<a id="_idIndexMarker664"/> that are not compatible or have a bad value, often we want the program to print out the bad flag and the flag values. </p>
			<p>This can be accomplished with the <strong class="source-inline">PrintDefaults()</strong> option. Here's an example:</p>
			<p class="source-code">var (</p>
			<p class="source-code">     useProd = flag.Bool("prod", true, "Use a production endpoint")</p>
			<p class="source-code">     useDev = flag.Bool("dev", false, "Use a development endpoint")</p>
			<p class="source-code">     help = flag.Bool("help", false, "Display help text")</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     flag.Parse()</p>
			<p class="source-code">     if *help {</p>
			<p class="source-code">          flag.PrintDefaults()</p>
			<p class="source-code">          return</p>
			<p class="source-code">     }</p>
			<p class="source-code">     switch {</p>
			<p class="source-code">     case *useProd &amp;&amp; *useDev:</p>
			<p class="source-code">          log.Println("Error: --prod and --dev cannot both be set")</p>
			<p class="source-code">          flag.PrintDefaults()</p>
			<p class="source-code">          os.Exit(1)</p>
			<p class="source-code">     case !(*useProd || *useDev):</p>
			<p class="source-code">          log.Println("Error: either --prod or --dev must be set")</p>
			<p class="source-code">          flag.PrintDefaults()</p>
			<p class="source-code">          os.Exit(1)</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>This code does the following:</p>
			<ul>
				<li>Defines a <strong class="source-inline">--help</strong> flag<a id="_idIndexMarker665"/> that just prints our defaults if set</li>
				<li>Defines two other flags, <strong class="source-inline">--prod</strong> and <strong class="source-inline">--dev</strong></li>
				<li>If <strong class="source-inline">--prod</strong> and <strong class="source-inline">--dev</strong> are set, prints out an error message and the default flag values</li>
				<li>If neither are set, puts out an error message and the defaults</li>
			</ul>
			<p>Here is an example of the output:</p>
			<p class="source-code">Error: --prod and --dev cannot both be set</p>
			<p class="source-code">  -dev</p>
			<p class="source-code">         Use a development endpoint (default false)</p>
			<p class="source-code">  -prod</p>
			<p class="source-code">         Use a production endpoint (default true)</p>
			<p>This code illustrates how we can have flags with valid default values, but if the values are changed to cause an error, we can detect and handle the error. And in the spirit of good command-line tools, we provide <strong class="source-inline">--help</strong> to allow users to discover the flags they can use.</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor412"/>Shorthand flags</h2>
			<p>In the previous example, we had a <strong class="source-inline">--help</strong> flag. But often, you may want to offer a shorthand such as <strong class="source-inline">-h</strong> for the user<a id="_idIndexMarker666"/> to use. These need to have the same default values and both need to set the same variable, so they cannot have two separate values.</p>
			<p>We can use the <strong class="source-inline">flag.[Type]Var()</strong> calls to help<a id="_idIndexMarker667"/> us accomplish this:</p>
			<p class="source-code">var (</p>
			<p class="source-code">    useProd = flag.Bool("prod", true, </p>
			<p class="source-code">                  "Use a production endpoint")</p>
			<p class="source-code">    useDev = flag.Bool("dev", false, </p>
			<p class="source-code">                  "Use a development endpoint")</p>
			<p class="source-code">    help = new(bool)</p>
			<p class="source-code">)</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">    flag.BoolVar(help, "help", false, "Display help text")</p>
			<p class="source-code">    flag.BoolVar(help, "h", false, </p>
			<p class="source-code">                 "Display help text (shorthand)")</p>
			<p class="source-code">}     </p>
			<p>Here, we store the results of <strong class="source-inline">--help</strong> and <strong class="source-inline">--h</strong> in our <strong class="source-inline">help</strong> variable. We use <strong class="source-inline">init()</strong> to do the setup, as <strong class="source-inline">BoolVar()</strong> does not return a variable; therefore, it cannot be used in a <strong class="source-inline">var()</strong> statement.</p>
			<p>Now that we know how a shorthand flag works, let's have a look at non-flag arguments.</p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor413"/>Accessing non-flag arguments</h2>
			<p>Arguments in Go are read in a few ways. You can read<a id="_idIndexMarker668"/> the raw arguments using <strong class="source-inline">os.Args</strong>, which will also include all the flags. This is great when no flags are used.</p>
			<p>When using flags, <strong class="source-inline">flag.Args()</strong> can be used to retrieve only the non-flag arguments. If we want to send a list of authors to a development server and retrieve QOTDs for each author, the command might look like this: </p>
			<p class="source-code">qotd --dev "abraham lincoln" "martin king" "mark twain"</p>
			<p>In this list, we use a <strong class="source-inline">--dev</strong> flag to indicate that we want to use the development server. Following our flag, we have a list<a id="_idIndexMarker669"/> of arguments. Let's retrieve those:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     flag.Parse()</p>
			<p class="source-code">     authors := flag.Args</p>
			<p class="source-code">     if len(authors) == 0 {</p>
			<p class="source-code">          log.Println("did not pass any authors")</p>
			<p class="source-code">          os.Exit(1)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     ...</p>
			<p>In this code, we do the following:</p>
			<ul>
				<li>Retrieve the non-flag arguments using <strong class="source-inline">flag.Args()</strong>.</li>
				<li>Test that we received at least one author or exit with an error.</li>
			</ul>
			<p>We have seen how to retrieve input that comes as arguments or flags. This can be used to define how to contact a server or what files to open. Let's look at receiving input f<a id="_idTextAnchor414"/>rom a stream.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor415"/>Retrieving input from STDIN</h2>
			<p>Most applications that are written<a id="_idIndexMarker670"/> today in the DevOps community tend to revolve<a id="_idIndexMarker671"/> around flags and arguments, as seen previously. One of the less common methods of input that DevOps people use daily is piping input into a program.</p>
			<p>Tools such as <strong class="source-inline">cat</strong>, <strong class="source-inline">xargs</strong>, <strong class="source-inline">sed</strong>, <strong class="source-inline">awk</strong>, and <strong class="source-inline">grep</strong> allow you to pipe the output of one tool into the input of the next to accomplish a task. A simple example might be just looking for lines in a file we retrieved from the web that contains the word <strong class="source-inline">error</strong>: </p>
			<p class="source-code">wget http://server/log | grep -i "error" &gt; only_errors.txt </p>
			<p>Programs such as <strong class="source-inline">cat</strong> read input from <strong class="source-inline">STDIN</strong> when no file<a id="_idIndexMarker672"/> has been specified. Let's duplicate that here for a program<a id="_idIndexMarker673"/> that looks for the word <strong class="source-inline">error</strong> on any input line and prints it out:</p>
			<p class="source-code">var errRE = regexp.MustCompile(`(?i)error`)</p>
			<p class="source-code">func main() { </p>
			<p class="source-code">    var s *bufio.Scanner </p>
			<p class="source-code">    switch len(os.Args) { </p>
			<p class="source-code">  case 1:</p>
			<p class="source-code">          log.Println("No file specified, using STDIN")</p>
			<p class="source-code">          s = bufio.NewScanner(os.Stdin)</p>
			<p class="source-code">  case 2:</p>
			<p class="source-code">          f, err := os.Open(os.Args[1])</p>
			<p class="source-code">          if err != nil {</p>
			<p class="source-code">                  log.Println(err)</p>
			<p class="source-code">                  os.Exit(1)</p>
			<p class="source-code">          }</p>
			<p class="source-code">          s = bufio.NewScanner(f)</p>
			<p class="source-code">  default:</p>
			<p class="source-code">          log.Println("too many arguments provided")</p>
			<p class="source-code">          os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  for s.Scan() {</p>
			<p class="source-code">          line := s.Bytes()</p>
			<p class="source-code">          if errRE.Match(line) {</p>
			<p class="source-code">                  fmt.Printf("%s\n", line)</p>
			<p class="source-code">          }</p>
			<p class="source-code">  }</p>
			<p class="source-code">  if err := s.Err(); err != nil {</p>
			<p class="source-code">          log.Println("Error: ", err)</p>
			<p class="source-code">          os.Exit(1)</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This code does the following:</p>
			<ul>
				<li>Compiles a regex<a id="_idIndexMarker674"/> using the <strong class="source-inline">regexp</strong> package to look for a line<a id="_idIndexMarker675"/> containing <strong class="source-inline">error</strong> – the match is case-insensitive.</li>
				<li>Uses <strong class="source-inline">os.Args()</strong> to read our argument list. We use this instead of <strong class="source-inline">flag.Args()</strong>, as we haven't defined any flags.</li>
				<li>Uses <strong class="source-inline">os.Stdin</strong> if we have a single argument (the program name), which is an <strong class="source-inline">io.Reader</strong> that we wrap in a <strong class="source-inline">bufio.Scanner</strong>.</li>
				<li>Opens the file if we have a file argument and wraps the <strong class="source-inline">io.Reader</strong> in a <strong class="source-inline">bufio.Scanner</strong> object.</li>
				<li>Returns an error if we have more arguments.</li>
				<li>Reads input line by line and prints to <strong class="source-inline">os.Stdout</strong> every line containing the word <strong class="source-inline">error</strong>.</li>
				<li>Checks whether we had an input error – <strong class="source-inline">io.EOF</strong> is not considered an error and won't trip the <strong class="source-inline">if</strong> statement.</li>
			</ul>
			<p>You can find this code in the repository <a href="https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/7/filter_errors/main.go">https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/7/filter_errors/main.go</a>.</p>
			<p>Using this code compiled as <strong class="source-inline">filter_errors</strong>, we can use this to scan <strong class="source-inline">wget</strong> input (or any piped input) for lines containing<a id="_idIndexMarker676"/> the word <strong class="source-inline">error</strong> and then use <strong class="source-inline">grep</strong> to filter for a particular error code<a id="_idIndexMarker677"/> such as <strong class="source-inline">401</strong> (unauthorized):</p>
			<p class="source-code">wget http://server/log | filter_errors | grep 401</p>
			<p>Or we can search a log file in the same way:</p>
			<p class="source-code">filter_errors log.txt | grep 401</p>
			<p>This is a simplistic example that can easily be achieved with existing tools, but this gives a demonstration of how to build similar tooling.</p>
			<p>In this section, we have looked at how to read different input from the command line in the form of flags and arguments. We looked at shorthand flags that share state with long-form flags. You saw how to create custom types to use as flags. And finally, we looked at how to successfully use STDIN to read input that is sent via a pipe.</p>
			<p>Next, we will look at how to use Cobra, a third-party package, to create more sophisticated comma<a id="_idTextAnchor416"/>nd-line applications.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor417"/>Using Cobra for advanced CLI applications</h1>
			<p>Cobra is a set of packages<a id="_idIndexMarker678"/> that allows a developer to create more complex<a id="_idIndexMarker679"/> CLI applications. This becomes more useful than just the standard <strong class="source-inline">flag</strong> package when the complexity of an application causes a list of flags to become numerous.</p>
			<p>In this section, we will talk about how to use Cobra to create structured CLI applications that are friendly to developers to add features and allow users to understand what is available in an application.</p>
			<p>A few features that Cobra provides are as follows:</p>
			<ul>
				<li>Nested subcommands</li>
				<li>Command suggestions </li>
				<li>Aliases for commands so that you can make changes without breaking users</li>
				<li>Generation of help text from flags and commands</li>
				<li>Generation of autocompletion for various shells</li>
				<li>Man page creation</li>
			</ul>
			<p>This section<a id="_idIndexMarker680"/> will borrow heavily<a id="_idIndexMarker681"/> from the Cobra documentation, which you can find here: <a href="https://github.com/spf13/cobra/blob/master/user_guide.md">https://github.com/spf13/cobra/blob/master/user_guide.md</a>.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor418"/>Code organization</h2>
			<p>To make effective use of Cobra<a id="_idIndexMarker682"/> and make it easy for developers to understand where to add and change commands, Cobra suggests the following structure:</p>
			<p class="source-code"> appName/</p>
			<p class="source-code">     cmd/</p>
			<p class="source-code">          add.go</p>
			<p class="source-code">          your.go</p>
			<p class="source-code">          commands.go</p>
			<p class="source-code">          here.go</p>
			<p class="source-code">     main.go</p>
			<p>This structure has your main <strong class="source-inline">main.go</strong> executable at the top-level directory and all of your commands under <strong class="source-inline">cmd/</strong>. </p>
			<p>The main file for a Cobra application is primarily used to simply initialize Cobra and let it perform command executions. The file will look like this:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">     "{pathToYourApp}/cmd"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     cmd.Execute()</p>
			<p class="source-code">}</p>
			<p>Next, we will look at using the Cobra generator<a id="_idIndexMarker683"/> application to generate boilerplate code.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor419"/>The optional Cobra generator</h2>
			<p>Cobra provides an application<a id="_idIndexMarker684"/> that can generate boilerplate code for our application. To get started with the generator, we will create a configuration file for our application in our root directory called <strong class="source-inline">~/.cobra.yaml</strong>:</p>
			<p class="source-code">author: John Doak myemail@somedomain.com</p>
			<p class="source-code">year: 2021</p>
			<p class="source-code">license: MIT</p>
			<p>This will handle printing our MIT license. You can use any of these values for the following built-in licenses:</p>
			<ul>
				<li>GPLv2</li>
				<li>GPLv3</li>
				<li>LGPL</li>
				<li>AGPL</li>
				<li>2-Clause BSD</li>
				<li>3-Clause BSD</li>
			</ul>
			<p>If you need a license not found here, instructions on how to provide a custom license can be found here: <a href="https://github.com/spf13/cobra-cli/blob/main/README.md#configuring-the-cobra-generator">https://github.com/spf13/cobra-cli/blob/main/README.md#configuring-the-cobra-generator</a>.</p>
			<p>By default, Cobra will use this configuration file from your <strong class="source-inline">home</strong> directory. If you need a different license, put the configuration in your repository and use <strong class="source-inline">cobra --config="config/location.yaml</strong> to use the alternate configuration file.</p>
			<p>To download Cobra<a id="_idIndexMarker685"/> and build with the Cobra generator, type the following on your command line:</p>
			<p class="source-code">go get github.com/spf13/cobra/cobra</p>
			<p class="source-code">go install github.com/spf13/cobra/cobra</p>
			<p>Now, to initialize the application, make sure that you are in the new application's root directory and do the following:</p>
			<p class="source-code">cobra init --pkg-name [repo path]</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><strong class="source-inline">[repo path]</strong> will be something such as <strong class="source-inline">github.com/spf13/newApp</strong>.</p>
			<p>Let's create a few commands for our application:</p>
			<p class="source-code">cobra add serve</p>
			<p class="source-code">cobra add config</p>
			<p class="source-code">cobra add create -p 'configCmd'</p>
			<p>This will deliver us the following:</p>
			<p class="source-code">app/</p>
			<p class="source-code">      cmd/</p>
			<p class="source-code">         serve.go</p>
			<p class="source-code">         config.go</p>
			<p class="source-code">         create.go</p>
			<p class="source-code">       main.go</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You are required to use camelCase for command names. Not doing this will cause you to encounter errors.</p>
			<p>The <strong class="source-inline">-p</strong> option for <strong class="source-inline">create</strong> is used to make<a id="_idIndexMarker686"/> it a subcommand of <strong class="source-inline">config</strong>. The string that follows is the parent's name plus <strong class="source-inline">Cmd</strong>. All other <strong class="source-inline">add</strong> calls have <strong class="source-inline">-p</strong> set to <strong class="source-inline">rootCmd</strong>.</p>
			<p>After you <strong class="source-inline">go build</strong> the application, we can run it like so:</p>
			<ul>
				<li><strong class="source-inline">app</strong></li>
				<li><strong class="source-inline">app serve</strong></li>
				<li><strong class="source-inline">app config</strong></li>
				<li><strong class="source-inline">app config create</strong></li>
				<li><strong class="source-inline">app help serve</strong></li>
			</ul>
			<p>With the boilerplate now in place, we will only need to conf<a id="_idTextAnchor420"/>igure the commands to execute.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor421"/>The command package</h2>
			<p>In the <strong class="source-inline">cmd</strong> package<a id="_idIndexMarker687"/> that has been generated, you will find a file for each command<a id="_idIndexMarker688"/> that can be executed. We will need to modify each file to give the correct help text, use flags, and execute the command.</p>
			<p>We will look at a generated <strong class="source-inline">cmd/get.go</strong> file for an application created with the following commands:</p>
			<p class="source-code">cobra init --pkg-name [repo path]</p>
			<p class="source-code">cobra add get</p>
			<p>This application will talk to the QOTD server that we created in <a href="B17626_06.xhtml#_idTextAnchor367"><em class="italic">Chapter 6</em></a>, <em class="italic">Interacting with Remote Data Sources</em>.</p>
			<p>The generated <strong class="source-inline">cmd/get.go</strong> file will look similar to this:</p>
			<p class="source-code">var getCmd = &amp;cobra.Command{</p>
			<p class="source-code">        Use:   "get",</p>
			<p class="source-code">        Short: "A brief description of your command",</p>
			<p class="source-code">        Long: `A longer description that spans multiple lines and likely contains examples and usage of using your command.`,</p>
			<p class="source-code">        Run: func(cmd *cobra.Command, args []string) {</p>
			<p class="source-code">                fmt.Println("get called")</p>
			<p class="source-code">        },</p>
			<p class="source-code">}</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">        rootCmd.AddCommand(getCmd)</p>
			<p class="source-code">}</p>
			<p>This code<a id="_idIndexMarker689"/> does the<a id="_idIndexMarker690"/> following:</p>
			<ul>
				<li>Creates a variable called <strong class="source-inline">serveCmd</strong>:<ul><li>Variable name is based on the command name plus <strong class="source-inline">Cmd</strong>.</li><li><strong class="source-inline">Use</strong> is the argument name for the command line.</li><li><strong class="source-inline">Short</strong> is the brief description.</li><li><strong class="source-inline">Long</strong> is a longer description with examples.</li><li><strong class="source-inline">Run</strong> is the entry point for the code you want to execute.</li></ul></li>
				<li>Defines <strong class="source-inline">init()</strong>, which does the following:<ul><li>Adds this command to the <strong class="source-inline">rootCmd</strong> object.</li></ul></li>
			</ul>
			<p>Let's use this to write our QOTD CLI:</p>
			<p class="source-code">     ...</p>
			<p class="source-code">     Run: func(cmd *cobra.Command, args []string) {</p>
			<p class="source-code">        const devAddr = "127.0.0.1:3450"</p>
			<p class="source-code">        fs := cmd.Flags()</p>
			<p class="source-code">        addr := mustString(fs, "addr")</p>
			<p class="source-code">        if mustBool(fs, "dev") {</p>
			<p class="source-code">                addr = devAddr</p>
			<p class="source-code">        }</p>
			<p class="source-code">        c, err := client.New(addr)</p>
			<p class="source-code">        if err != nil {</p>
			<p class="source-code">                fmt.Println("error: ", err)</p>
			<p class="source-code">                os.Exit(1)</p>
			<p class="source-code">        }</p>
			<p class="source-code">        a, q, err := c.QOTD(cmd.Context(), mustString(fs, "author"))</p>
			<p class="source-code">        if err != nil {</p>
			<p class="source-code">                fmt.Println("error: ", err)</p>
			<p class="source-code">                os.Exit(1)</p>
			<p class="source-code">        }</p>
			<p class="source-code">        switch {</p>
			<p class="source-code">        case mustBool(fs, "json"):</p>
			<p class="source-code">                b, err := json.Marshal(</p>
			<p class="source-code">                        struct{</p>
			<p class="source-code">                                Author string</p>
			<p class="source-code">                                Quote string</p>
			<p class="source-code">                        }{a, q},</p>
			<p class="source-code">                )</p>
			<p class="source-code">                if err != nil {</p>
			<p class="source-code">                        panic(err)</p>
			<p class="source-code">                }</p>
			<p class="source-code">                fmt.Printf("%s\n", b)</p>
			<p class="source-code">        default:</p>
			<p class="source-code">                fmt.Println("Author: ", a)</p>
			<p class="source-code">                fmt.Println("Quote: ", q)</p>
			<p class="source-code">        }</p>
			<p class="source-code">     },</p>
			<p class="source-code">}</p>
			<p>This code<a id="_idIndexMarker691"/> does the following:</p>
			<ul>
				<li>Sets up an <strong class="source-inline">addr</strong> variable<a id="_idIndexMarker692"/> to hold our server address:<ul><li>If <strong class="source-inline">--dev</strong> is passed, it sets <strong class="source-inline">addr</strong> to <strong class="source-inline">devAddr</strong>.</li><li>Otherwise, it uses the <strong class="source-inline">--addr</strong> flag's value.</li><li><strong class="source-inline">--addr</strong> defaults to <strong class="source-inline">127.0.0.1:80</strong>.</li></ul></li>
				<li>Creates a new client for our QOTD server</li>
				<li>Calls the QOTD server:<ul><li>Uses <strong class="source-inline">Context</strong> passed to <strong class="source-inline">*cobra.Command</strong></li><li>Uses the <strong class="source-inline">--author</strong> flag value, which defaults to an empty string</li></ul></li>
				<li>Uses a <strong class="source-inline">--json</strong> flag to determine<a id="_idIndexMarker693"/> whether the output should<a id="_idIndexMarker694"/> be in JSON:<ul><li>If JSON, it outputs an inline-defined struct as JSON.</li><li>Otherwise, it just pretty prints it to the screen.<p class="callout-heading">Important Note</p><p class="callout">You will see the <strong class="source-inline">mustBool()</strong> and <strong class="source-inline">mustString()</strong> functions. These simply return the value from<a id="_idIndexMarker695"/> the flag name<a id="_idIndexMarker696"/> that is passed. If the flag isn't defined, it panics. This removes a lot of ugly code for something that must always work for the CLI application to be valid. These functions are in the repository version.</p><p class="callout">The flags that you see are not from the standard library <strong class="source-inline">flag</strong> package. Instead, this package uses flag types from <a href="https://github.com/spf13/pflag">https://github.com/spf13/pflag</a>. This package has more built-in types and methods than the standard <strong class="source-inline">flag</strong> package.</p></li></ul></li>
			</ul>
			<p>Now, we need to define the flags that we are using in our <strong class="source-inline">Run</strong> function:</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">        rootCmd.AddCommand(getCmd)</p>
			<p class="source-code">        getCmd.Flags().BoolP("dev", "d", false, </p>
			<p class="source-code">            "Uses the dev server instead of prod")</p>
			<p class="source-code">        getCmd.Flags().String("addr", "127.0.0.1:80", </p>
			<p class="source-code">            "Set the QOTD server to use, </p>
			<p class="source-code">            defaults to production")</p>
			<p class="source-code">        getCmd.Flags().StringP("author", "a", "", </p>
			<p class="source-code">            "Specify the author to </p>
			<p class="source-code">            get a quote for")</p>
			<p class="source-code">        getCmd.Flags().Bool("json", false, </p>
			<p class="source-code">            "Output is in JSON format")</p>
			<p class="source-code">}</p>
			<p>This code<a id="_idIndexMarker697"/> does the<a id="_idIndexMarker698"/> following:</p>
			<ul>
				<li>Adds a flag called <strong class="source-inline">--dev</strong> that can be shortened to <strong class="source-inline">-d</strong> and defaults to <strong class="source-inline">false</strong></li>
				<li>Adds a flag called <strong class="source-inline">--addr</strong> that defaults to <strong class="source-inline">"127.0.0.1:80"</strong></li>
				<li>Adds a flag called <strong class="source-inline">--author</strong> that can be shortened to <strong class="source-inline">-a</strong></li>
				<li>Adds a flag called <strong class="source-inline">--json</strong> that defaults to <strong class="source-inline">false</strong><p class="callout-heading">Important Note </p><p class="callout">Methods followed by <strong class="source-inline">P</strong>, such as <strong class="source-inline">BoolP()</strong>, define shortened flags as well as the long flag names.</p></li>
			</ul>
			<p>The flags we defined are only available when the <strong class="source-inline">get</strong> command is invoked. If we create subcommands on <strong class="source-inline">get</strong>, these will only be available on <strong class="source-inline">get</strong> with no sub-commands defined.</p>
			<p>To add flags that work on all subcommands, use <strong class="source-inline">.PersistentFlags()</strong> instead of <strong class="source-inline">.Flags()</strong>.</p>
			<p>The code for this client can be found in the repository here: <a href="https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/cobra/app/">https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/cobra/app/</a>.</p>
			<p>Now, we can run our app and call this command. In these examples, you will need to run the QOTD server from the gRPC chapter, like so:</p>
			<p class="source-code">$ go run qotd.go --addr=127.0.0.1:3560</p>
			<p class="source-code">$ go run main.go get --addr=127.0.0.1:3560 --author="Eleanor Roosevelt" –json </p>
			<p>This runs our application using the server at the <strong class="source-inline">127.0.0.1:3560</strong> address and requests a quote from Eleanor Roosevelt, with output in JSON format:</p>
			<p class="source-code">{"Author":"Eleanor Roosevelt","Quote":"The future belongs to</p>
			<p class="source-code">those who believe in the beauty of their dreams"}</p>
			<p>This next example gets a random quote from the server at address <strong class="source-inline">127.0.0.1:3560</strong>:</p>
			<p class="source-code">$ go run main.go get --addr=127.0.0.1:3560 </p>
			<p class="source-code">Author: Mark Twain </p>
			<p class="source-code">Quote: Golf is a good walk spoiled</p>
			<p>In this section, we have learned what the Cobra package is, how to use the Cobra generator tool<a id="_idIndexMarker699"/> to bootstrap a CLI application, and finally, how to build commands for your application<a id="_idIndexMarker700"/> using this package.</p>
			<p>Next, we are going to look at handling signals to <a id="_idTextAnchor422"/>do cleanup before exiting your applications.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor423"/>Handling OS signals</h1>
			<p>When writing CLI applications, there<a id="_idIndexMarker701"/> are occasions when a developer wants to handle OS signals. The most common example is a user trying to exit a program, usually through a keyboard shortcut.</p>
			<p>In these cases, you may want to do some file cleanup before exiting or cancel a call you made to a remote system.</p>
			<p>In this section, we will talk about how you can capture and respond to these <a id="_idTextAnchor424"/>events to make your applications more robust.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor425"/>Capturing an OS signal</h2>
			<p>Go deals<a id="_idIndexMarker702"/> with two types of OS signals:</p>
			<ul>
				<li>Synchronous</li>
				<li>Asynchronous</li>
			</ul>
			<p>Synchronous signals generally<a id="_idIndexMarker703"/> revolve around program errors. Go treats these as runtime panics, and therefore, interception of these can be handled with a <strong class="source-inline">defer</strong> statement.</p>
			<p>There are different asynchronous signals, depending on the platform, but for a Go programmer, the most relevant are as follows:</p>
			<ul>
				<li><strong class="source-inline">SIGHUP</strong>: The connected terminal disconnected.</li>
				<li><strong class="source-inline">SIGTERM</strong>: Please quit and do cleanup (generated from a program).</li>
				<li><strong class="source-inline">SIGINT</strong>: The same as <strong class="source-inline">SIGTERM</strong> (sent from the terminal).</li>
				<li><strong class="source-inline">SIGQUIT</strong>: The same as <strong class="source-inline">SIGTERM</strong> plus a core dump (sent from the terminal).</li>
				<li><strong class="source-inline">SIGKILL</strong>: The program must quit; this signal cannot be captured.</li>
			</ul>
			<p>In situations where these arise, it can be useful to intercept these signals so that you can cancel ongoing operations and do a cleanup before exiting. It should be noted that <strong class="source-inline">SIGKILL</strong> cannot be intercepted, and <strong class="source-inline">SIGHUP</strong> is simply an indication that a process has lost its terminal, not necessarily that it was canceled. This could be because it was moved to the background or another similar event.</p>
			<p>To capture a signal, we can use the <strong class="source-inline">os/signal</strong> package. This package allows a program to receive notifications of a signal from an OS and respond. Here is a simple example:</p>
			<p class="source-code">signals := make(chan os.Signal, 1)</p>
			<p class="source-code">signal.Notify(</p>
			<p class="source-code">     signals,</p>
			<p class="source-code">     syscall.SIGINT,</p>
			<p class="source-code">     syscall.SIGTERM,</p>
			<p class="source-code">     syscall.SIGQUIT,</p>
			<p class="source-code">)</p>
			<p class="source-code">go func() {</p>
			<p class="source-code">     switch &lt;-signals {</p>
			<p class="source-code">     case syscall.SIGINT, syscall.SIGTERM:</p>
			<p class="source-code">          cleanup()</p>
			<p class="source-code">          os.Exit(1)</p>
			<p class="source-code">     case syscall.SIGQUIT:     </p>
			<p class="source-code">          cleanup()</p>
			<p class="source-code">          panic("SIGQUIT called")</p>
			<p class="source-code">     }</p>
			<p class="source-code">}()</p>
			<p>This code<a id="_idIndexMarker704"/> does the following:</p>
			<ul>
				<li>Creates a channel, <strong class="source-inline">signals</strong>, on which to receive signals</li>
				<li>Subscribes to signals of the <strong class="source-inline">SIGINT</strong>, <strong class="source-inline">SIGTERM</strong>, and <strong class="source-inline">SIGQUIT</strong> types</li>
				<li>Uses a goroutine to handle incoming signals, which does the following:<ul><li>Calls the <strong class="source-inline">cleanup()</strong> function to handle program cleanup</li><li>Exits with the <strong class="source-inline">1</strong> code on <strong class="source-inline">SIGINT</strong> and <strong class="source-inline">SIGTERM</strong></li><li>Panics, which gives a basic core dump on <strong class="source-inline">SIGQUIT</strong></li></ul></li>
			</ul>
			<p>Signal-handling code should be done in your <strong class="source-inline">main</strong> package. The <strong class="source-inline">cleanup()</strong> function should contain function calls that handle outstanding items, such as remote call cancellations and file cleanup.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">You can control the amount of data and generation method of a core dump using an environmental<a id="_idIndexMarker705"/> variable, <strong class="source-inline">GOTRACEBACK</strong>. You can read about it here: <a href="https://pkg.go.dev/runtime#hdr-Environment_Variables">https://pkg.go.dev/runtime#hdr-Environment_Variables</a>.</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor426"/>Using Context to cancel</h2>
			<p>The key method in Go to cause<a id="_idIndexMarker706"/> operations to stop processing is to use<a id="_idIndexMarker707"/> the context cancellation feature of Go's <strong class="source-inline">context.Context</strong> object. This object was discussed in <a href="B17626_02.xhtml#_idTextAnchor166"><em class="italic">Chapter 2</em></a>, <em class="italic">Go Language Essentials</em>, if you need a refresher.</p>
			<p>By simply creating a <strong class="source-inline">Context</strong> object with cancellation in <strong class="source-inline">main()</strong> and passing it to all function calls, we can effectively cancel all ongoing work. This can be handy when we want to stop processing and do cleanup because a user hits <em class="italic">Ctrl</em> + <em class="italic">C</em>.</p>
			<p>We are going to show an advanced signal handling method on a program that does the following:</p>
			<ul>
				<li>Creates a new temporary file every 1 second for 30 seconds</li>
				<li>Cleans up files if the program is canceled </li>
			</ul>
			<p>Let's start by creating a function to handle our signals:</p>
			<p class="source-code">func handleSignal(cancel context.CancelFunc) chan os.Signal {</p>
			<p class="source-code">        out := make(chan os.Signal, 1)</p>
			<p class="source-code">        notify := make(chan os.Signal, 10)</p>
			<p class="source-code">        signal.Notify(</p>
			<p class="source-code">                notify,</p>
			<p class="source-code">                syscall.SIGINT,</p>
			<p class="source-code">                syscall.SIGTERM,</p>
			<p class="source-code">                syscall.SIGQUIT,</p>
			<p class="source-code">        )</p>
			<p class="source-code">        go func() {</p>
			<p class="source-code">                defer close(out)</p>
			<p class="source-code">                for {</p>
			<p class="source-code">                        sig := &lt;-notify</p>
			<p class="source-code">                        switch sig {</p>
			<p class="source-code">                        case syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:</p>
			<p class="source-code">                                cancel()</p>
			<p class="source-code">                                out &lt;- sig</p>
			<p class="source-code">                                return</p>
			<p class="source-code">                        default:</p>
			<p class="source-code">                                log.Println("unhandled signal: ", sig)</p>
			<p class="source-code">                        }</p>
			<p class="source-code">                }</p>
			<p class="source-code">        }()</p>
			<p class="source-code">        return out</p>
			<p class="source-code">}</p>
			<p>This code<a id="_idIndexMarker708"/> does the following:</p>
			<ul>
				<li>Creates<a id="_idIndexMarker709"/> a new function called <strong class="source-inline">handleSignal()</strong></li>
				<li>Has an argument called <strong class="source-inline">cancel</strong>, which is used to signal a function chain to stop processing</li>
				<li>Creates an <strong class="source-inline">out</strong> channel that we use to return with the signal received</li>
				<li>Creates a <strong class="source-inline">notify</strong> channel to receive signal notifications</li>
				<li>Creates a goroutine to receive signals:<ul><li>If the signal is for exiting, call <strong class="source-inline">cancel()</strong>.</li><li>Return the signal that told us to exit.</li><li>If it is some other signal, just log it.</li></ul></li>
			</ul>
			<p>Now, let's create a function that creates our files:</p>
			<p class="source-code">func createFiles(ctx context.Context, tmpFiles string) error {</p>
			<p class="source-code">        for i := 0; i &lt; 30; i++ {</p>
			<p class="source-code">                if err := ctx.Err(); err != nil {</p>
			<p class="source-code">                        return ctx.Err()</p>
			<p class="source-code">                }</p>
			<p class="source-code">                _, err := os.Create(filepath.Join(tmpFiles, strconv.Itoa(i)))</p>
			<p class="source-code">                if err != nil {</p>
			<p class="source-code">                        return err</p>
			<p class="source-code">                }</p>
			<p class="source-code">                fmt.Println("Created file: ", i)</p>
			<p class="source-code">                time.Sleep(1 * time.Second)</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return nil</p>
			<p class="source-code">}</p>
			<p>This code<a id="_idIndexMarker710"/> does the<a id="_idIndexMarker711"/> following:</p>
			<ul>
				<li>Loops 30 times, which does the following:<ul><li>Checks whether our <strong class="source-inline">ctx</strong> is canceled</li><li>If so, returns the error</li><li>Otherwise, creates a file in <strong class="source-inline">tmpFiles</strong></li><li>Sleeps for 1 second between file creations</li></ul></li>
			</ul>
			<p>This code will create files in <strong class="source-inline">tmpFiles</strong> named from <strong class="source-inline">0</strong> to <strong class="source-inline">29</strong> unless there is a problem writing the file or <strong class="source-inline">Context</strong> is canceled.</p>
			<p>Now, we need some code to clean up the files if we receive a <strong class="source-inline">quit</strong> signal. If we don't, the files are left alone:</p>
			<p class="source-code">func cleanup(tmpFiles string) {</p>
			<p class="source-code">        if err := os.RemoveAll(tmpFiles); err != nil {</p>
			<p class="source-code">                fmt.Println("problem doing file cleanup: ", err)</p>
			<p class="source-code">                return</p>
			<p class="source-code">        }</p>
			<p class="source-code">        fmt.Println("cleanup done")</p>
			<p class="source-code">}</p>
			<p>This code<a id="_idIndexMarker712"/> does the<a id="_idIndexMarker713"/> following:</p>
			<ul>
				<li>Uses <strong class="source-inline">os.RemoveAll()</strong> to remove the files:<ul><li>Also removes the temporary directory</li></ul></li>
				<li>Notifies the user that cleanup was done </li>
			</ul>
			<p>Let's tie it all together with our <strong class="source-inline">main()</strong>:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">        tmpFiles, err := os.MkdirTemp("", "myApp_*")</p>
			<p class="source-code">        if err != nil {</p>
			<p class="source-code">                log.Println("error creating temp file directory: ", err)</p>
			<p class="source-code">                os.Exit(1)</p>
			<p class="source-code">        }</p>
			<p class="source-code">        fmt.Println("temp files located at: ", tmpFiles)</p>
			<p class="source-code">        ctx, cancel := context.WithCancel(context.Background())</p>
			<p class="source-code">        recvSig := handleSignal(cancel)</p>
			<p class="source-code">        if err := createFiles(ctx, tmpFiles); err != nil {</p>
			<p class="source-code">                cleanup(tmpFiles)</p>
			<p class="source-code">                select {</p>
			<p class="source-code">                case sig := &lt;-recvSig:</p>
			<p class="source-code">                        if sig == syscall.SIGQUIT {</p>
			<p class="source-code">                                panic("SIGQUIT called")</p>
			<p class="source-code">                        }</p>
			<p class="source-code">                default:</p>
			<p class="source-code">                // Prevents waiting on a</p>
			<p class="source-code">                // signal if none exists.</p>
			<p class="source-code">                }</p>
			<p class="source-code">                log.Println("error: ", err)</p>
			<p class="source-code">                os.Exit(1)</p>
			<p class="source-code">        }</p>
			<p class="source-code">        fmt.Println("Done")</p>
			<p class="source-code">}</p>
			<p>This code<a id="_idIndexMarker714"/> does the<a id="_idIndexMarker715"/> following:</p>
			<ul>
				<li>Creates a temporary file directory </li>
				<li>Creates a root <strong class="source-inline">Context</strong> object, <strong class="source-inline">ctx</strong>:<ul><li><strong class="source-inline">ctx</strong> can be canceled with <strong class="source-inline">cancel()</strong>.</li></ul></li>
				<li>Calls our <strong class="source-inline">handleSignal()</strong> to handle any signal to quit</li>
				<li>Executes our <strong class="source-inline">createFiles()</strong> function:<ul><li>If we have an error, we call <strong class="source-inline">cleanup()</strong>.</li><li>After cleanup, we see whether we received a signal as opposed to just an error.</li><li>If it is a signal and it is <strong class="source-inline">SIGQUIT</strong>, we call <strong class="source-inline">panic()</strong>. This is because <strong class="source-inline">SIGQUIT</strong> should core-dump by definition.</li><li>If it was just<a id="_idIndexMarker716"/> an error, print the error and return<a id="_idIndexMarker717"/> an error code.</li></ul></li>
			</ul>
			<p>The full code for this can be found in the repository here: <a href="https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/signals">https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/signals</a>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The code must be built with <strong class="source-inline">go build</strong> and run as a binary. It cannot be run with <strong class="source-inline">go run</strong>, as the <strong class="source-inline">go</strong> binary that forks our program will intercept the signal before our program can.</p>
			<p class="callout">Multiple types<a id="_idIndexMarker718"/> of core dumps can be created in Go, controlled by an environmental variable. This is controlled by <strong class="source-inline">GOTRACEBACK</strong>. You can read about <a id="_idTextAnchor427"/>it here: <a href="https://pkg.go.dev/runtime#hdr-Environment_Variables">https://pkg.go.dev/runtime#hdr-Environment_Variables</a>.</p>
			<h3>Cancellation with Cobra</h3>
			<p>When Cobra was initially<a id="_idIndexMarker719"/> created, the <strong class="source-inline">context</strong> package did not exist. In 2020, the program was patched to allow the passing of a <strong class="source-inline">Context</strong> object into <strong class="source-inline">cobra.Command</strong>. But unfortunately, the Cobra generator was not updated to generate the necessary boilerplate.</p>
			<p>To add signal handling as we did previously, we simply need to make a couple of modifications – first, to the <strong class="source-inline">main.go</strong> file:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">	ctx, cancel := context.WithCancel(context.Background())</p>
			<p class="source-code">	var sigCh chan os.Signal</p>
			<p class="source-code">	go func() {</p>
			<p class="source-code">		handleSignal(ctx, cancel)</p>
			<p class="source-code">	}()</p>
			<p class="source-code">	cmd.Execute(ctx)</p>
			<p class="source-code">	cancel()</p>
			<p class="source-code">	if sig := &lt;-sigCh; sig == syscall.SIGQUIT {</p>
			<p class="source-code">		panic("SIGQUIT")</p>
			<p class="source-code">	}</p>
			<p class="source-code">}</p>
			<p>We will also need to modify <strong class="source-inline">handleSignal()</strong>. You can see those changes here: <a href="https://go.dev/play/p/F4SdN-xC-V_L">https://go.dev/play/p/F4SdN-xC-V_L</a></p>
			<p>Finally, you must change the <strong class="source-inline">cmd/root.go</strong> file like so: </p>
			<p class="source-code">func Execute(ctx context.Context) {</p>
			<p class="source-code">        cobra.CheckErr(rootCmd.ExecuteContext(ctx))</p>
			<p class="source-code">}</p>
			<p>We now have signal<a id="_idIndexMarker720"/> handling. When writing our <strong class="source-inline">Run</strong> function, we can use <strong class="source-inline">cmd.Co<a id="_idTextAnchor428"/>ntext()</strong> to retrieve the <strong class="source-inline">Context</strong> object and look for cancelation.</p>
			<h3>Case study – a lack of cancellation leads to a death spiral</h3>
			<p>One of the early Google systems to help automate the network was a system called Chipmunk. Chipmunk<a id="_idIndexMarker721"/> contained authoritative data on the network and would generate router configurations from that data.</p>
			<p>Like most software, Chipmunk started off working fast and saving a lot of time. As the network continued its yearly tenfold growth, the limits of its design and language choice began to show. </p>
			<p>Chipmunk was built on Django and Python and was not designed for horizontal scaling. As the system became busy, configuration requests would start to take 30 minutes or longer. Timers for these requests would have limits of no more than 30 minutes. </p>
			<p>The design had a fatal flaw when generation approached these limits – if a request was canceled, the cancellation was not signaled to the running configuration generator. </p>
			<p>This meant that if generation took 25 minutes but was canceled 1 minute in, the generator would spend the next 24 minutes working, with no one to receive the work.</p>
			<p>When a call reached the time limit, the callers would time out and retry. But the generator was still working on the previous call. This would lead to a cascade failure, as multiple compute-heavy calculations were running, some of which no longer had a receiver. This would<a id="_idIndexMarker722"/> push the new call over the time limit, as the Python <strong class="bold">Global Interpreter Lock</strong> (<strong class="bold">GIL</strong>  <a href="https://wiki.python.org/moin/GlobalInterpreterLock">https://wiki.python.org/moin/GlobalInterpreterLock</a>) prevents true multi-threading<a id="_idIndexMarker723"/> and each call was doubling CPU usage.</p>
			<p>One of the keys to dealing with this type of failure scenario is being able to cancel jobs that are no longer needed. This is why it is so important to pipe a <strong class="source-inline">context.Context</strong> object throughout a function call chain and look for cancellation at logical points. This can greatly reduce the load on a system that reaches a threshold and reduce<a id="_idIndexMarker724"/> the damage of <strong class="bold">Distributed Denial of Service</strong> (<strong class="bold">DDoS</strong>) attacks. </p>
			<p>This section has looked at how a program can intercept OS signals and respond to those signals. It has provided<a id="_idIndexMarker725"/> an example of using <strong class="source-inline">Context</strong> to handle canceling executions that can be used in any application. We have discussed how we can integrate that into programs generated with the Cobra generator.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor429"/>Summary</h1>
			<p>This chapter has given you the skills to write basic and advanced command-line applications. We discussed how you can use the <strong class="source-inline">flag</strong> package and <strong class="source-inline">os</strong> package to receive signals from the user in the form of flags and arguments. We also discussed how to read data from <strong class="source-inline">os.Stdin</strong>, which allows you to string multiple executables into a chain for processing. </p>
			<p>We have discussed more advanced applications, namely the Cobra package and its accompanying generator binary, to build advanced command-line tooling with help text, shortcuts, and sub-commands. </p>
			<p>Finally, we have talked about dealing with signals and providing cleanup on cancellation from these signals. This included a case study on why cancellation can be critical.</p>
			<p>The skills you have learned here will be critical in writing tooling in the future, from interacting with local files to interacting with services. </p>
			<p>In the next chapter, we will talk about how to automate interactions with the command line on your local device or remote devices. </p>
		</div>
	</div></body></html>