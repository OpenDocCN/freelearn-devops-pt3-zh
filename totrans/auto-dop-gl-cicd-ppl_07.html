<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer077">
			<h1 id="_idParaDest-152" class="chapter-number"><a id="_idTextAnchor162"/>7</h1>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor163"/>Securing Your Code</h1>
			<p>Now that you know how to configure your GitLab CI/CD pipeline to verify that your project’s code is meeting its requirements, the next step in constructing a pipeline is to add jobs that look for security vulnerabilities. This is an optional step, but since GitLab makes it easy to add security scanning to your pipelines, and since there’s virtually no downside other than adding a few minutes to your pipeline’s runtime, <em class="italic">we recommend that you enable all security scanners that are relevant to </em><span class="No-Break"><em class="italic">your projects</em></span><span class="No-Break">.</span></p>
			<p>We’ll start this chapter by providing an overview of GitLab’s general strategy around using security scanners; several aspects of security scanning are helpful to understand before you start learning about individual scanners. Then, we’ll explain the purpose of each of the seven types of security testing that GitLab offers: <strong class="bold">Static Application Security Testing</strong> (<strong class="bold">SAST</strong>), <strong class="bold">Secret Detection</strong>, <strong class="bold">Dynamic Application Security Testing</strong> (<strong class="bold">DAST</strong>), <strong class="bold">Dependency Scanning</strong>, <strong class="bold">Container Scanning</strong>, <strong class="bold">License Compliance</strong>, and <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) <strong class="bold">Scanning</strong>. We’ll show you how to enable each type of scanner in your pipelines, and then discuss some sample configuration options and techniques you can use to adjust their behavior to best suit your needs. Finally, we’ll cover three additional GitLab features that make security scanners easier to use and more powerful: reading scanner reports, tracking scanner findings using vulnerability management, and integrating outside <span class="No-Break">security scanners.</span></p>
			<p>By the end of this chapter, you’ll have learned some critical skills for keeping your code safe and your data secure. You’ll understand how to identify which GitLab-provided security scanners are relevant to your project. You’ll know how to add them to your CI/CD pipelines and configure their behavior to suit your needs. You’ll have a solid grasp of the different types of security reports that GitLab provides. You’ll also be able to track your team’s progress in remediating any security vulnerabilities. Finally, you’ll understand how to add third-party security scanners to your pipelines. In short, you’ll feel confident that your code is as secure <span class="No-Break">as possible.</span></p>
			<p>The following topics will be covered in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Understanding GitLab’s security <span class="No-Break">scanning strategy</span></li>
				<li>Using SAST to scan your source code <span class="No-Break">for vulnerabilities</span></li>
				<li>Using Secret Detection to find private information in <span class="No-Break">your repository</span></li>
				<li>Using DAST to find vulnerabilities in <span class="No-Break">web applications</span></li>
				<li>Using Dependency Scanning to find vulnerabilities <span class="No-Break">in dependencies</span></li>
				<li>Using Container Scanning to find vulnerabilities in <span class="No-Break">Docker images</span></li>
				<li>Using License Compliance to manage licenses <span class="No-Break">of dependencies</span></li>
				<li>Using IaC Scanning to find problems in infrastructure <span class="No-Break">configuration files</span></li>
				<li>Understanding the different types of <span class="No-Break">security reports</span></li>
				<li>Managing <span class="No-Break">security vulnerabilities</span></li>
				<li>Integrating outside <span class="No-Break">security scanners</span></li>
			</ul>
			<p>GitLab uses the same handful of configuration techniques for all of its security scanners. To avoid repetition, we’ll discuss these in detail only in the section dedicated to the first scanner type (SAST). When we discuss configuration techniques for the other scanners, we’ll refer you back to the <span class="No-Break">SAST section.</span></p>
			<p>While we’re on the subject of scanner configuration, it’s important to understand that most of these scanners offer <em class="italic">many</em> configuration options, and it is impossible to discuss all of them – or even most of them – in this book. Instead, we’ll show you how to get each scanner up and running in a fairly basic form, give you a sample of the kinds of configuration options that exist for each scanner, and point you to the official GitLab documentation as the best source of up-to-date information about the full range of configuration settings for each type of scanner. Fortunately, the documentation on this subject is both clear <span class="No-Break">and comprehensive.</span></p>
			<p>Finally, note that many of these scanners are only available to users with a GitLab Ultimate license. However, GitLab has a history of making Ultimate-only scanners available to Premium or Free license users in later releases. At the time of writing, SAST, Secret Detection, Container Scanning, and Infrastructure as Code Scanning are available to all users regardless of license tier, albeit sometimes in a feature-limited (but still useful) form. So, if you find your favorite scanner is not yet available for your license, there’s a chance that it will become available in the future, even if you never upgrade <span class="No-Break">your license.</span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor164"/>Technical requirements</h1>
			<p>As with the previous chapters, you’ll get the most out of this chapter if you have an account on a GitLab instance (either self-managed or <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>)) that you can log in to and use for practicing and experimenting with the <span class="No-Break">concepts discussed.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor165"/>Understanding GitLab’s security scanning strategy</h1>
			<p>There are a few <a id="_idIndexMarker506"/>fundamental principles underlying GitLab’s security scanners that will be useful for you to know before you learn about what each scanner does. Let’s look at <span class="No-Break">those now.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor166"/>GitLab uses open-source scanners</h2>
			<p>It might surprise you to learn that all the <a id="_idIndexMarker507"/>security scanners discussed in this chapter are <strong class="bold">third-party, open-source tools</strong>; none of them are developed in-house by GitLab. For example, IaC scanning is performed by the<a id="_idIndexMarker508"/> open-source tool <strong class="bold">Keeping Infrastructure as Code Secure</strong> (<strong class="bold">KICS</strong>), and Dependency Scanning is <a id="_idIndexMarker509"/>handled by the open-source <span class="No-Break">tool </span><span class="No-Break"><strong class="bold">Gemnasium</strong></span><span class="No-Break">.</span></p>
			<p>That doesn’t mean that these third-party scanners are inferior to GitLab-developed software in any way. They are all rigorously researched and vetted by GitLab before they are adopted as official GitLab scanners. Furthermore, GitLab frequently reviews new open-source security scanners to see whether they should replace or supplement any of the product’s current scanners. So, don’t worry – these scanners are all first-rate additions to your pipelines, even if their code wasn’t written by <span class="No-Break">GitLab developers.</span></p>
			<p>Security scanners that are developed by organizations or companies that are dedicated solely to security are likely to have fewer bugs than proprietary software developed by companies for whom security is not their primary focus. As the saying about open-source code goes, “<em class="italic">given enough eyeballs, all bugs are shallow.</em>” Making bugs shallow – and then fixing them – is especially important for security-related tools: using a poorly designed security scanner that gives you the false impression that your code is secure is worse than knowing nothing about your product’s security <span class="No-Break">at all.</span></p>
			<p>Since these scanners are open-source software, what’s stopping you from downloading them yourself and running them independently of GitLab? Nothing! But it’s hard to see why you’d want to. The scanners that are blessed by GitLab are simple to integrate into GitLab CI/CD pipelines, and GitLab automatically updates them to ensure that your pipelines always run<a id="_idIndexMarker510"/> the latest versions (unless you specify otherwise), with no action on your part required. If you have CI/CD pipelines set up in GitLab already, and if your GitLab license tier gives you access to the scanners you need, we advise that you use these tools within GitLab rather than running them independently. You would have nothing to gain and a fair amount to lose in the form of extra system administration and maintenance if you were to download and run them on <span class="No-Break">your own.</span></p>
			<p class="callout-heading">Which languages do GitLab’s security scanners support?</p>
			<p class="callout">To see a list of <a id="_idIndexMarker511"/>all the languages supported by each type of GitLab security scanner, as well as the names of the open-source tools that are used, consult the official GitLab documentation (<a href="https://docs.gitlab.com/ee/user/application_security/sast/#supported-languages-and-frameworks">https://docs.gitlab.com/ee/user/application_security/sast/#supported-languages-and-frameworks</a>). Keep in mind that these details do change from time to time, so it’s wise to revisit the documentation periodically to see which new languages are supported by the different <span class="No-Break">scanner types.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor167"/>Scanners are packaged as Docker images</h2>
			<p>When a <a id="_idIndexMarker512"/>security scanner runs in your GitLab CI/CD pipeline, it runs within a Docker container. This is irrelevant for most GitLab users, but there are three implications that you should <span class="No-Break">know about.</span></p>
			<p>First, because the pipeline job that runs a scanner has to pull down the Docker image for that scanner, this will add a minute or so to the job’s runtime. Of course, the exact delay depends on your network speed and on whether the image has been cached somewhere. This usually isn’t a big problem since many scanners take a few minutes to run, even after their Docker image has been downloaded. Also, most non-trivial pipelines run in minutes rather than seconds, so you probably won’t notice any short delays caused by pulling down security scanner <span class="No-Break">Docker images.</span></p>
			<p>Second, any security scanning jobs must run on a GitLab Runner that uses Docker or Kubernetes executors. You can refresh your memory about GitLab Runner executors by referring to the previous chapter if you’re not sure what this means. If your organization uses the SaaS version of GitLab (that is, you use the instance at <strong class="source-inline">gitlab.com</strong>), this problem is solved for you: all SaaS-provided GitLab Runners use one of those two executors. If you’re using a self-managed instance of GitLab, you probably have a GitLab administrator who is in charge of setting up all the GitLab Runners that your team needs. Just make sure they understand that at least some of those Runners must use Docker or <a id="_idIndexMarker513"/>Kubernetes executors if you intend to add security scanning to <span class="No-Break">your pipelines.</span></p>
			<p>Third, because your jobs download security scanner Docker images every time they run, you never have to worry about updating your security scanners. GitLab makes sure that the latest version of each scanner is included in the Docker image pulled down by each job. That’s one less maintenance chore for you to keep <span class="No-Break">track of.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor168"/>Some scanners use different analyzers for different languages</h2>
			<p>Some <a id="_idIndexMarker514"/>scanners, such as SAST and Dependency Scanning, rely on different open-source tools for scanning code written in different computer languages. GitLab calls these language-specific tools <strong class="bold">analyzers</strong>. For <a id="_idIndexMarker515"/>example, when you enable SAST in a project that contains only Go code, GitLab will run an open-source, Go-aware SAST analyzer called <strong class="bold">Semgrep</strong>. But <a id="_idIndexMarker516"/>when you enable SAST on a Ruby-based project, GitLab runs a different open-source analyzer<a id="_idIndexMarker517"/> called <strong class="bold">Brakeman</strong>, which knows how to scan <span class="No-Break">Ruby code.</span></p>
			<p>You don’t need to tell GitLab which analyzers to run – it detects the computer languages in your project automatically and only runs the analyzers that work with those languages. It does<a id="_idIndexMarker518"/> this by looking for <strong class="bold">trigger files</strong>, which are files with certain names or extensions in your project’s Git repository. For example, if it finds any files that end in <strong class="source-inline">.py</strong>, it assumes that your project contains Python code and runs Python-based analyzers for any security scanners you’ve enabled. It also looks for certain configuration files that are traditionally used with various languages, such as <strong class="source-inline">Gemfile</strong> or <strong class="source-inline">Gemfile.lock</strong> in Ruby projects, <strong class="source-inline">requirements.txt</strong> in Python projects, and <strong class="source-inline">pom.xml</strong> in Java projects that use the Maven build tool. Most of the time, you don’t need to worry about making your computer languages easy for GitLab to detect – it’s smart enough to do the right thing with almost all projects. But if you find that it’s not recognizing languages as it should, you can see lists of trigger files in the official GitLab documentation for each security scanner type, and make sure that you have at least one trigger file for each language in <span class="No-Break">your project.</span></p>
			<p>It’s fine to use multiple computer languages in the same project. GitLab will detect all languages in the project’s repository and run the appropriate analyzer for each, assuming that an analyzer exists for that scanner type <span class="No-Break">and language.</span></p>
			<p>For some combinations of scanner type and language, GitLab has more than one analyzer available. When this occurs, it runs all of the relevant analyzers. For example, if you enable SAST on a<a id="_idIndexMarker519"/> project with Python code, it will <a id="_idIndexMarker520"/>run both the <strong class="bold">Semgrep</strong> and <strong class="bold">Bandit</strong> analyzers. If both of the <a id="_idIndexMarker521"/>analyzers detect the same problems, you may see duplicate results in the scanner reports, with one result from each analyzer. This might clutter up your reports somewhat, but it’s better to be safe than sorry. Also, since every open-source analyzer is written by a different development team with a different focus or area of concern, and since different analyzers have different levels of comprehensiveness or maturity, running multiple analyzers is a great way to maximize the number of <span class="No-Break">vulnerabilities found.</span></p>
			<p>If running more than one analyzer for a particular language is producing too much noise, you can configure most scanners to disable individual analyzers. For example, you could tell GitLab to run only the Bandit analyzer and not the Semgrep analyzer when performing SAST scans on Python code. However, we generally recommend that you keep as many analyzers enabled as possible to reduce the chance of vulnerabilities slipping through. And there’s no need to disable analyzers for languages that are not included in your project: GitLab is smart enough to run only the analyzers that support the languages that <span class="No-Break">it detects.</span></p>
			<p>Not all analyzers for a particular scanner type will find the same problems. For example, if you have a divide-by-zero vulnerability in Go code and the same vulnerability in Ruby code, one of the two analyzers might report this as a potential problem, while the other analyzer might ignore it. Again, this is the result of different open-source analyzers being written and maintained by different teams <span class="No-Break">of developers.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor169"/>Vulnerabilities don’t stop the pipeline</h2>
			<p>The default <a id="_idIndexMarker522"/>behavior for most GitLab jobs is to abort the pipeline as soon as the stage containing the failed job completes. After all, if your tests fail in an early stage, there’s no need to deploy your code in a later stage. GitLab’s security scanners sort of follow this standard… and sort of don’t. Let’s explain what we mean <span class="No-Break">by that.</span></p>
			<p>Every security scanner that runs successfully marks its pipeline job as <em class="italic">passed</em>, regardless of whether it detected any vulnerabilities. In other words, seeing that a security scanner’s pipeline job has a <em class="italic">passed</em> status simply means the scanner ran to completion – it doesn’t tell you anything about whether the scanner found vulnerabilities. So even if your pipeline’s scanners find a huge number of vulnerabilities in <a id="_idIndexMarker523"/>your code, their jobs will be given a <em class="italic">passed</em> status and the pipeline will continue to <span class="No-Break">later stages.</span></p>
			<p>This might seem counterintuitive. Isn’t detecting a vulnerability similar to having an automated test fail? Well, yes and no. Vulnerabilities are typically something that your team should look at carefully, but as you’ll learn later when we talk about GitLab’s vulnerability management feature, you might decide not to fix the vulnerability. GitLab doesn’t want to presume that you will fix all the vulnerabilities before deploying your code to production, so it continues running pipelines even after vulnerabilities are found. This approach equips development teams with all the information GitLab can provide about the security of their code, without asking the tool to make any assessments about whether that code is suitable to <span class="No-Break">be deployed.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor170"/>Findings appear in three different reports</h2>
			<p>Any vulnerabilities or <a id="_idIndexMarker524"/>other problems discovered by GitLab’s security scanners appear in reports that consolidate the results from all the different scanners. There are three of these reports in different places within the GitLab GUI. Each report shows subtly different information than the others, and it’s important to understand the purpose of each so that you don’t misinterpret the results. We’ll discuss this topic in more detail later in this chapter, but for now, we’ll just introduce you <a id="_idIndexMarker525"/>to the vulnerability report, which you can find by clicking <strong class="bold">Security &amp; Compliance</strong> in the left navigation pane and then clicking <strong class="bold">Vulnerability report</strong>. When we discuss the security scanners in the rest of this chapter, we’ll include screenshots of sample findings from each scanner as they appear in the <span class="No-Break">vulnerability report.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor171"/>Pipelines can use non-GitLab-provided scanners</h2>
			<p>Although<a id="_idIndexMarker526"/> GitLab’s built-in scanners might give you all the protection you need from security vulnerabilities, it’s possible to supplement your security testing by adding many other third-party scanners to your pipelines. We’ll discuss how to configure this type of integration in a dedicated section (<em class="italic">Integrating outside security scanners</em>) toward the end of <span class="No-Break">this chapter.</span></p>
			<p>Now that you <a id="_idIndexMarker527"/>understand some of the concepts that underly all of GitLab’s security scanners, let’s look at each scanner to learn what kinds of problems it can spot and how to <span class="No-Break">use them.</span></p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor172"/>Using SAST to scan your source code for vulnerabilities</h1>
			<p>Let’s start our survey of scanners with <strong class="bold">SAST</strong>. <em class="italic">We encourage you to read this section carefully, even if you don’t intend to use SAST</em>, because many of the principles and practices involved with using SAST carry over to the other scanners as well. Understanding how to<a id="_idIndexMarker528"/> use SAST gives you a huge head start in terms of enabling, configuring, and reading the findings of <span class="No-Break">other scanners.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor173"/>Understanding SAST</h2>
			<p>SAST looks at your project’s source code, as opposed to interacting with your code as it runs. Sometimes, this approach<a id="_idIndexMarker529"/> is referred to as <em class="italic">white-box scanning</em>, meaning that the scanner looks <em class="italic">inside</em> your app to inspect its code instead of staying <em class="italic">outside</em> the app and simply analyzing <span class="No-Break">its behavior.</span></p>
			<p>This scanner looks for bad coding practices, anti-patterns, or the hallmarks of poorly designed or structured code, which <a id="_idIndexMarker530"/>are sometimes referred to as <em class="italic">code smells</em>, that could potentially result in exploitable security problems. For example, consider this single line of <span class="No-Break">Python code:</span></p>
			<pre class="source-code">
temp_dir = '/tmp'</pre>
			<p>It looks harmless, but non-Python programmers might be surprised to learn that it’s considered a security vulnerability. A Python best practice is to use the language’s built-in <strong class="source-inline">tempfile</strong> module to create and manage temporary directories and files. Any directories or files created with this module are automatically deleted when the program finishes executing, which ensures that no sensitive data is accidentally left on the computer’s filesystem. Creating a directory to hold temporary files is dangerous because it’s easy to forget to clean up after yourself by deleting this directory when the program no longer needs it. This is exactly the kind of problem that SAST is designed <span class="No-Break">to detect.</span></p>
			<p>As mentioned in<a id="_idIndexMarker531"/> the previous section, different SAST analyzers for different computer languages will look for different security vulnerabilities. The GitLab SAST analyzer for a different language might not detect a similar problem in code written in that language, either because the code isn’t considered to be a vulnerability in that language or because the analyzer might not be as mature or robust as GitLab’s Python <span class="No-Break">SAST analyzers.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor174"/>Enabling SAST</h2>
			<p>There are<a id="_idIndexMarker532"/> two ways to enable SAST in a GitLab project’s pipeline: manually, or with the GitLab GUI. They boil down to the same thing since they both result in adding a few lines of content to the <strong class="source-inline">.gitlab-ci.yml</strong> file that configures your CI/CD pipeline. Let’s look at <span class="No-Break">both approaches.</span></p>
			<h3>Enabling SAST manually</h3>
			<p>To enable SAST <a id="_idIndexMarker533"/>manually, you need to do two things to your project’s <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitlab-ci.yml</strong></span><span class="No-Break"> file:</span></p>
			<ul>
				<li>Make sure the pipeline has a <strong class="source-inline">test</strong> <span class="No-Break">stage defined</span></li>
				<li>Include a template <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">Security/SAST.gitlab-ci.yml</strong></span></li>
			</ul>
			<p>The code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
stages:
  - test
include:
  - template: Security/SAST.gitlab-ci.yml</pre>
			<p>The first of these steps is easy since pipelines usually already have a <strong class="source-inline">test</strong> stage defined by the time you must add security scanning. But if you’re adding security scanning before you’ve added any other test-related jobs, just add the first two lines in the preceding snippet. Of course, if you already have other stages defined, don’t delete them when adding your <strong class="source-inline">test</strong> stage – just add <strong class="source-inline">test</strong> to the <span class="No-Break">existing stages.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Remember that the order in which you list stages matters because that’s the order in which GitLab will run them in <span class="No-Break">your pipeline.</span></p>
			<p>The second step<a id="_idIndexMarker534"/> involves adding a template to your CI/CD configuration. A template is a file provided by GitLab that contains CI/CD code that defines new job definitions or adds other features. By including a template in your CI/CD configuration file, you can add job definitions that perform tasks such as SAST scanning without having to know how those <span class="No-Break">jobs work.</span></p>
			<p>In this case, the template adds a job definition for each GitLab SAST analyzer. It also adds logic to detect which languages exist in your project so that it knows which of the SAST-related jobs to run. If you imagine that your <strong class="source-inline">hats-for-cats</strong> project contains only Python code, you would expect this template to run two new jobs in the project’s pipeline: one for Bandit and one for Semgrep, which are GitLab’s two Python <span class="No-Break">SAST analyzers.</span></p>
			<p>Sure enough, if you commit this change to <strong class="source-inline">.gitlab-ci.yml</strong> and look at the details of the pipeline triggered by that commit, you’ll see that those jobs are now included in your pipeline, under the <span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> stage:</span></p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B18073_07_1.jpg" alt="Figure 7.1 – Python SAST jobs on the pipeline details page" width="359" height="231"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Python SAST jobs on the pipeline details page</p>
			<p>Remember that if your project contains code in a language other than Python, you’ll see different job names and potentially a different number of jobs on this page. And if your project contains<a id="_idIndexMarker535"/> code in Python and another language, you’ll see jobs for the SAST analyzers for each of <span class="No-Break">those languages.</span></p>
			<h3>Enabling SAST with the GitLab GUI</h3>
			<p>Strangely enough, using the GUI to add SAST scanning to your pipeline is a more involved process<a id="_idIndexMarker536"/> than doing <span class="No-Break">so manually:</span></p>
			<ol>
				<li>Start the process by navigating to the <strong class="bold">Security and Compliance</strong> option in the left pane and then selecting <strong class="bold">Configuration</strong>. This will direct you to a control panel for enabling and configuring most (but not all) of GitLab’s <span class="No-Break">security scanners.</span></li>
				<li>The exact GUI controls sometimes change with new GitLab releases, but there will be a button that lets you enable SAST. Clicking that button will take you to a new page for <span class="No-Break">configuring SAST.</span></li>
				<li>You can usually keep all the options set to their default values and click the button at the bottom that creates a merge request. That will take you to a merge request <span class="No-Break">creation page.</span></li>
				<li>Once again, you can usually leave all the fields at their default values and click the button at the bottom to create the <span class="No-Break">merge request.</span></li>
				<li>Navigate to the merge request and merge it to complete the process. Your <strong class="source-inline">.gitlab-ci.yml</strong> file should now include the <strong class="source-inline">test</strong> stage if it didn’t do so already, as well as include the SAST template described in the previous section. You can see<a id="_idIndexMarker537"/> how simply editing that file manually would have probably been <span class="No-Break">much easier!</span></li>
			</ol>
			<p>Once you’ve enabled SAST using the GUI, you should see the same results as if you’d enabled SAST manually: two new jobs will be added to each run of your pipeline, corresponding to the two Python-based analyzers that GitLab supports <span class="No-Break">for SAST.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor175"/>Configuring SAST</h2>
			<p>Now, you know how to add SAST to your GitLab pipeline. But what if you want to change SAST’s default<a id="_idIndexMarker538"/> behavior? The techniques you can use for configuring SAST are also used to configure most of the other security scanners. We’ll discuss these techniques in detail here and then refer you back to this section instead of repeating this information when we introduce you to the <span class="No-Break">other scanners.</span></p>
			<p>There are three ways to configure SAST or any other <span class="No-Break">security scanner:</span></p>
			<ul>
				<li>In <strong class="source-inline">.gitlab-ci.yml</strong>, set a <span class="No-Break">global variable</span></li>
				<li>In <strong class="source-inline">.gitlab-ci.yml</strong>, override a job definition that was originally added by the template you included, and set a job-scoped variable for <span class="No-Break">that job</span></li>
				<li>Use the <span class="No-Break">GitLab GUI</span></li>
			</ul>
			<p>Which of these three techniques you use to configure SAST or any other scanner depends on what configuration option you want to set. Unfortunately, you don’t get to pick which of these techniques you’d like to use to set a particular configuration option – you have to refer to the GitLab documentation to see which technique or techniques you must use to set the configuration option you’re <span class="No-Break">interested in.</span></p>
			<p>Let’s see some examples of <span class="No-Break">configuring SAST.</span></p>
			<h3>Configuring SAST with a global variable</h3>
			<p>First, say that you <a id="_idIndexMarker539"/>want to disable the Semgrep SAST analyzer for Python. You can do that by setting a global variable <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">.gitlab-ci.yml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
variables:
  SAST_EXCLUDED_ANALYZERS: "semgrep"</pre>
			<p>If you add this variable to your CI/CD configuration file and then rerun your pipeline, you’ll notice that the <strong class="source-inline">semgrep-sast</strong> job you saw in the preceding screenshot is <span class="No-Break">now gone.</span></p>
			<p>Of course, if your CI/CD configuration file already has a <strong class="source-inline">variables</strong> section, you should add this new variable to any existing variables instead of creating an entirely new <span class="No-Break"><strong class="source-inline">variables</strong></span><span class="No-Break"> section.</span></p>
			<h3>Configuring SAST by overriding a job definition and setting a job-scoped variable</h3>
			<p>Next, imagine that you<a id="_idIndexMarker540"/> want the Bandit SAST analyzer not to scan certain directories, such as a directory that contains test code. Perhaps you know that your tests are filled with security vulnerabilities, but you don’t care because customers will never use that code. You can set that configuration option by editing <strong class="source-inline">.gitlab-ci.yml</strong> to override the definition of the job that triggers Bandit, and setting a job-scoped variable within the new <span class="No-Break">job definition:</span></p>
			<pre class="source-code">
bandit-sast:
  variables:
    SAST_BANDIT_EXCLUDED_PATHS: "*/my_tests/*"</pre>
			<p>Don’t be thrown by the strange-looking value of the variable. This particular variable expects a value written in the slightly odd <strong class="source-inline">fnmatch</strong> syntax. That’s the kind of detail you’ll learn about when you consult the GitLab documentation to learn more about various configuration options for this and <span class="No-Break">other scanners.</span></p>
			<p>If you add this code to your CI/CD configuration file and rerun your pipeline, the Bandit analyzer will stop reporting any vulnerabilities it finds in the <strong class="source-inline">my_tests</strong> directory. We haven’t talked about how to view the results of these analyzers yet, but don’t worry – that will come later in <span class="No-Break">this chapter.</span></p>
			<h3>Configuring SAST with the GUI</h3>
			<p>Finally, you can <a id="_idIndexMarker541"/>use GitLab’s GUI to set certain configuration options for some scanners. For example, on the same GUI page that you used to enable SAST, you can configure SAST to use an analyzer from an alternative Docker image, change the pipeline stage it runs in, or change the depth of directories it searches when detecting the languages in your project. You can also use that GUI page to disable certain language-specific SAST analyzers if you find that they are unhelpful or produce findings that duplicate the results generated by <span class="No-Break">other analyzers.</span></p>
			<p>Compared to other scanner types, SAST makes an unusually large number of configuration options available from the GUI. The GitLab documentation can give you more information about which options are available in the GUI for other scanners, and which options must be set by editing <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitlab-ci.yml</strong></span><span class="No-Break"> instead.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor176"/>Viewing SAST’s findings</h2>
			<p>Once you’ve <a id="_idIndexMarker542"/>enabled and, optionally, configured SAST, it will run the appropriate analyzer(s) for whatever language(s) it detects in your project, and will display its findings in GitLab’s three security reports. For example, here’s the finding for the vulnerability related to temporary directories that was described previously, as shown in GitLab’s <strong class="bold">Vulnerability </strong><span class="No-Break"><strong class="bold">Report</strong></span><span class="No-Break"> area:</span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B18073_07_2.jpg" alt="Figure 7.2 – SAST finding" width="1093" height="688"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – SAST finding</p>
			<p>This wraps <a id="_idIndexMarker543"/>up our summary of SAST. Let’s move on to a separate but related security scanner: <span class="No-Break">Secret Detection.</span></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor177"/>Using Secret Detection to find private information in your repository</h1>
			<p>You can<a id="_idIndexMarker544"/> think of Secret Detection as a special, focused version of SAST that’s dedicated to finding secrets that are accidentally lurking in your source code, such as United States social security numbers or AWS deploy keys. It operates in the same way as SAST – that is, by scanning your source code rather than by interacting with your <span class="No-Break">executing application.</span></p>
			<p>Secret Detection used to be part of GitLab’s SAST feature but was eventually spun off to become its own first-class security scanner. We are mentioning this so that you won’t be confused if you run into references in old documentation or blog posts suggesting that Secret Detection is performed by GitLab’s <span class="No-Break">SAST scanner.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor178"/>Understanding Secret Detection</h2>
			<p>Secret Detection<a id="_idIndexMarker545"/> looks for a wide variety of strings that represent secrets that should not normally be stored in files in a Git repository. In addition to the social security numbers and AWS deploy keys already mentioned, here are just a few of the 50 or so kinds of secrets it <span class="No-Break">looks for:</span></p>
			<ul>
				<li>Short- and long-lived Dropbox <span class="No-Break">API tokens</span></li>
				<li>GitLab personal <span class="No-Break">access tokens</span></li>
				<li>Heroku <span class="No-Break">API keys</span></li>
				<li>Private <span class="No-Break">SSH keys</span></li>
				<li>Stripe <span class="No-Break">access tokens</span></li>
			</ul>
			<p>For example, Secret Detection should find and report on all three of the secrets contained in this snippet of <span class="No-Break">Python code:</span></p>
			<pre class="source-code">
MY_SSN = '123-45-6789'
MY_GITLAB_ACCESS_TOKEN = 'glpat-txQxy1frpAJodkxJYL8U'
MY_PRIVATE_SSH_KEY = '''
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzbmUAAAAEbm9uZAwAAAAtzc2gt==
-----END OPENSSH PRIVATE KEY-----
'''</pre>
			<p>Secret Detection is <a id="_idIndexMarker546"/>based on <strong class="bold">regular expressions</strong> (or <strong class="bold">regexes</strong>): the scanner has a regex for each type of string it tries to detect and reports any string literals that match <span class="No-Break">those regexes.</span></p>
			<p>The use of regexes means that Secret Detection is completely language-agnostic. Since it just scans files to see whether any strings match regexes, it doesn’t care what computer language is used in your repository. This means that, unlike SAST, Secret Detection doesn’t require separate analyzers for different languages: it uses one analyzer for all source code files. Secret Detection is even file type-agnostic: it will scan configuration files, README files, plain text files, and any other non-binary files in your repository. It can look for strings that match regexes in a JSON configuration file just as easily as it can look for strings in<a id="_idIndexMarker547"/> a Go source <span class="No-Break">code file.</span></p>
			<p>While regexes are a powerful tool, Secret Detection’s reliance on them does mean that the scanner has an important limitation: it can’t detect passwords. This sounds surprising at first but makes sense once you realize that a well-written password should be difficult to capture with a regex. It’s hard to think up a regex that would capture any possible password without also matching non-secret text such as a sentence in documentation or a series of words in a GUI element. But other than this one case, Secret Detection does a great job at ferreting out strings that should be kept in a more secure location than a <span class="No-Break">Git repository.</span></p>
			<p>There’s one fantastic feature that Secret Detection is the only GitLab scanner to offer: <strong class="bold">historic mode</strong>. If you <a id="_idIndexMarker548"/>enable this mode, Secret Detection will scan all the commits in your repository to see whether there have <em class="italic">ever</em> been any secrets committed <span class="No-Break">to it.</span></p>
			<p>Why is historic mode important? Since one of the goals of version control systems such as Git is to allow you to go back to the state of files as they were at any point in time, it’s easy to see any secrets that have ever been committed, even if they were immediately removed in the very next commit. Once a secret is in a Git repository, it’s always retrievable. So, whenever Secret Detection discovers a secret, the entry it creates in any of the security scanner reports always mentions that the secret should not just be removed, but <em class="italic">revoked</em>. Any secret that makes its way into a Git repository should be considered to have been exposed to the world, and should no longer <span class="No-Break">be used.</span></p>
			<p>This is an extremely important point! If Secret Detection finds a password, you should immediately retire that password and set a new one (which, of course, you shouldn’t check into Git). If it detects a deploy key, you should cancel that key and create a new one. This principle holds for any kind of secret. If Secret Detection spots it, simply removing it from the repo is not sufficient. It should be considered no longer usable and should be replaced as soon <span class="No-Break">as possible.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor179"/>Enabling and configuring Secret Detection</h2>
			<p>Since Secret Detection used to be a part of SAST, it’s not surprising that you can use the same manual or GUI-based methods to enable <span class="No-Break">both scanners.</span></p>
			<p>To enable <a id="_idIndexMarker549"/>Secret Detection manually, make sure you have a <strong class="source-inline">test</strong> stage defined in your pipeline. Then, include the GitLab-provided template that contains the Secret Detection-related <span class="No-Break">job definitions:</span></p>
			<pre class="source-code">
stages:
  - test
include:
  - template: Security/Secret-Detection.gitlab-ci.yml</pre>
			<p>That’s all there is to it! The next time you trigger a pipeline, you will notice that a Secret Detection job is now running under the <span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> stage.</span></p>
			<p>To enable Secret Detection using the GUI, you can use the same process as for SAST: click the <strong class="bold">Security and Compliance</strong> option in the left navigation pane and select <strong class="bold">Configuration</strong>. From there, you’ll see an option to enable Secret Detection. Clicking that allows you to create a branch and associated merge request that edits your <strong class="source-inline">.gitlab-ci.yml</strong> file to include the Secret Detection template described previously. If you merge the request and trigger a new pipeline run, you’ll find that Secret Detection is now enabled in your pipeline. As with SAST, many people find this process more cumbersome than simply editing <strong class="source-inline">.gitlab-ci.yml</strong> manually, but your experience <span class="No-Break">may vary.</span></p>
			<p>Like most GitLab security scanners, Secret Detection has several configurable options. You can learn about all of the options and how to set them in the GitLab documentation, but two are especially worth <span class="No-Break">highlighting here.</span></p>
			<p>First, you might want to enable the special <strong class="bold">historic mode</strong> discussed previously to scan an existing repository that you’ve just imported into GitLab. Second, you can ask Secret Detection not to scan certain directories in your repository. For example, you might store fake social security numbers for testing purposes within a <strong class="source-inline">test/</strong> directory, and have fake deploy keys stored in a <strong class="source-inline">docs/</strong> directory. You would probably want to prevent Secret Detection from flagging these as security vulnerabilities by excluding <span class="No-Break">those directories.</span></p>
			<p>You can set both of <a id="_idIndexMarker550"/>these configuration options by overriding the <strong class="source-inline">secret_detection</strong> job definition that’s provided by the Secret Detection CI/CD template and then setting <span class="No-Break">job-scoped variables:</span></p>
			<pre class="source-code">
secret_detection:
  variables:
    SECRET_DETECTION_HISTORIC_SCAN: "true"
    SECRET_DETECTION_EXCLUDED_PATHS: "tests,docs"</pre>
			<p>With Secret Detection already configured and enabled, let us now view <span class="No-Break">its findings.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor180"/>Viewing Secret Detection’s findings</h2>
			<p>Once you’ve<a id="_idIndexMarker551"/> enabled and configured Secret Detection to your liking and it has run successfully in a pipeline, you can see the results in the <strong class="bold">Vulnerability Report</strong> area, just like you did with the SAST results. For example, here are the results that are generated by running Secret Detection on the Python code <span class="No-Break">provided previously:</span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B18073_07_3.jpg" alt="Figure 7.3 – Secret Detection findings" width="746" height="330"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Secret Detection findings</p>
			<p>Now that you’ve got a handle on Secret Detection, it’s time to look at the next security scanner in the GitLab <span class="No-Break">arsenal: DAST.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor181"/>Using DAST to find vulnerabilities in web applications</h1>
			<p>Let’s move <a id="_idIndexMarker552"/>on to the next type of security scanner: <strong class="bold">DAST</strong>. This scanner interacts with your code as it runs instead of looking at your source code. If SAST and Secret Detection are examples of “white-box” testing – they look inside your app to see how it works – then DAST is a form of “black-box” testing – it just sends input and looks for potential problems or security vulnerabilities in the output, without knowing how your application performs that transformation of input <span class="No-Break">into output.</span></p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor182"/>Understanding DAST</h2>
			<p>DAST tests either <strong class="bold">web application URLs</strong> or <strong class="bold">Web API endpoints</strong>. If you feed DAST the URL of a website’s home page, it will visit that page, identify any links or clickable GUI elements on the page, follow those links or click those elements, and repeat the process. It will continue this “spidering” procedure until it has visited every page that it can reach within your app. At each step, it checks the results returned by the web application to see whether it finds any problems. Here are just three examples of the sorts of things it <span class="No-Break">looks for:</span></p>
			<ul>
				<li>Exposure of private <span class="No-Break">personal information</span></li>
				<li>Missing cross-site request <span class="No-Break">forgery tokens</span></li>
				<li>Accepting sensitive information such as passwords through <span class="No-Break">query strings</span></li>
			</ul>
			<p>If you tell DAST to scan a Web API endpoint, it sends information to the endpoint and analyzes the response, looking for the same sorts <span class="No-Break">of problems.</span></p>
			<p>Regardless of whether it targets URLs or Web API endpoints, DAST can operate in either <strong class="bold">passive</strong> or <strong class="bold">active</strong> mode. Every time DAST runs, it performs a passive scan, which means that it makes benign, non-malicious requests similar to the requests sent by a real user. If you want a deeper analysis of your web app, you can enable a so-called <strong class="bold">full scan</strong>, which adds active attacks to the passive requests that it normally makes. These active attacks are more aggressive and could be considered malicious if they were directed at a website or Web API that you don’t own. However, they are invaluable in that they mimic the types of attacks that actual hackers might use, and therefore reveal many weaknesses<a id="_idIndexMarker553"/> that could be exploited by <span class="No-Break">malicious actors.</span></p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor183"/>Enabling and configuring DAST</h2>
			<p>DAST has a <a id="_idIndexMarker554"/>plethora of configuration options. We’ll cover a handful of the most commonly used options, which will be enough to get you up and running with DAST. As usual, the official GitLab documentation has full details on all of the ways you can configure DAST to behave in <span class="No-Break">non-default ways.</span></p>
			<p>It’s easiest to enable and configure DAST using the GUI. The exact details of this process may change in future GitLab releases, so we’ll cover the high-level concepts without going too far into <span class="No-Break">specific details.</span></p>
			<p>You can start enabling <a id="_idIndexMarker555"/>and configuring DAST by visiting the same security scanner configuration page you used for SAST and Secret Detection: click the <strong class="bold">Security and Compliance</strong> option in the left navigation pane and select <strong class="bold">Configuration</strong>. From there, you’ll be able to click a button to enable DAST, though the button will first take you to another page that lets you set up some configuration options that DAST needs to <span class="No-Break">go through.</span></p>
			<p>First, you’ll need to set up a <strong class="bold">scanner profile</strong>. This tells DAST whether to use only passive scans or to <a id="_idIndexMarker556"/>perform active scans as well. You can also set timeout values to limit the amount of time DAST spends spidering a website. GitLab will let you name this profile so that you can use the same profile later with several different URLs or Web <span class="No-Break">API targets.</span></p>
			<p>Second, GitLab will guide <a id="_idIndexMarker557"/>you to create a <strong class="bold">site profile</strong>. This profile contains the URL of the website’s home page or Web API endpoint that you want to scan. If you’re scanning a website, you can optionally add authentication credentials to the site profile. These allow DAST to sign in to the website like a user would, which typically exposes additional URLs to <span class="No-Break">be scanned.</span></p>
			<p>After you’ve created the two profiles, the GUI will present a code snippet that you can copy and paste into your project’s <strong class="source-inline">.gitlab-ci.yml</strong> file. This is a slightly different workflow than the merge request-driven workflow you use to enable SAST or Secret Detection through the GUI, but the result is the same: you add a few lines of code to your CI/CD configuration file, instructing DAST to run in <span class="No-Break">your pipeline.</span></p>
			<p class="callout-heading">Which URLs can you target with DAST?</p>
			<p class="callout">Although you can create a site profile with the URL of any website or web API, we strongly recommend that you only target websites and API endpoints that you own and manage. This is especially true if you are using DAST’s <strong class="bold">full scan</strong> option, which conducts more aggressive scanning. Furthermore, we recommend that you run DAST only against your application as it runs in a review, staging, or pre-production environment. Running DAST against the production version of your application could destabilize it, degrade performance for real users, or even knock it <span class="No-Break">out completely.</span></p>
			<p>If you prefer to <a id="_idIndexMarker558"/>enable and configure DAST manually, you’ll need to add a <strong class="source-inline">dast</strong> stage <a id="_idIndexMarker559"/>to your pipeline <em class="italic">after</em> the <strong class="source-inline">deploy</strong> stage. You must also include the DAST template, set a global variable with the URL that you’d like DAST to scan, and set any additional global or job-scoped variables that you need to modify <span class="No-Break">DAST’s behavior:</span></p>
			<pre class="source-code">
stages:
  - deploy
  - dast
include:
  - template: DAST.gitlab-ci.yml
variables:
  DAST_WEBSITE: <a href="https://example.com">https://example.com</a>
  DAST_FULL_SCAN_ENABLED: "true"</pre>
			<p>You might have noticed that DAST is the first scanner we’ve run across that expects to run in its own dedicated stage. The reason for this becomes obvious once you remember that DAST scans executing code and not source code: it can’t execute your code until it has been built and deployed. Those tasks usually take place in the <strong class="source-inline">build</strong> and <strong class="source-inline">deploy</strong> stages, so DAST must occur in a stage that falls after those stages in <span class="No-Break">the pipeline.</span></p>
			<p>Because DAST<a id="_idIndexMarker560"/> can sometimes take a long time to work its way through all the pages <a id="_idIndexMarker561"/>of a website, and because you don’t always want to hold up your pipeline while DAST does its thing, GitLab also allows you to run DAST scans on demand or according to a schedule. The process of triggering an on-demand scan or creating a scanning schedule is quite straightforward: in the <strong class="bold">Security &amp; Compliance</strong> option in the left navigation pane, select <strong class="bold">On-demand scans</strong> and let the GUI wizard guide you through <span class="No-Break">the process.</span></p>
			<p>As mentioned previously, DAST offers an unusually wide array of configurable options. There are far too many to describe here, but the options we’ve discussed so far are enough for you to get useful vulnerability findings in most cases. If you need to set timeout values for the spider process, disable particular vulnerability checks, set login credentials for the target website, or adjust DAST’s behavior in other ways, you can find all the information you need in the official <span class="No-Break">GitLab documentation.</span></p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor184"/>Viewing DAST’s findings</h2>
			<p>The results <a id="_idIndexMarker562"/>of a DAST scan show up in the <strong class="bold">Vulnerability Report</strong> area, just like the results for SAST and Secret Detection. Since we don’t have a full <strong class="bold">Hats for Cats</strong> app available to run DAST against, here are some sample results from running a DAST passive scan against <a href="https://example.com"><span class="hidden">https://example.com</span></a>. You can see that all of the results concern header fields, which is the most common type of finding resulting from <span class="No-Break">passive scans:</span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B18073_07_4.jpg" alt="Figure 7.4 – DAST findings" width="766" height="388"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – DAST findings</p>
			<p>That concludes your<a id="_idIndexMarker563"/> introduction to DAST. Now, let’s change gears and investigate Dependency Scanning, a type of security scan that looks at code that you’ve imported into your project from some <span class="No-Break">outside source.</span></p>
			<h1 id="_idParaDest-175"><a id="_idTextAnchor185"/>Using Dependency Scanning to find vulnerabilities in dependencies</h1>
			<p>Why write your own<a id="_idIndexMarker564"/> functions when someone else has already written, tested, and documented a library to perform exactly what you need? It’s often easy to find third-party Python modules, Ruby gems, Java JARs, or other open-source software packages that speed up the development of your project. Unfortunately, these third-party dependencies can contain security vulnerabilities, and if you include them in your project, you inherit those problems. This is where GitLab’s Dependency Scanning feature steps in – it ensures that any dependencies you use are free of <span class="No-Break">known vulnerabilities.</span></p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor186"/>Understanding Dependency Scanning</h2>
			<p>Like SAST, Dependency Scanning supports many languages – including all of the major languages you’d expect – but not every language under the Sun. You can consult the GitLab documentation to see an up-to-date list of <span class="No-Break">supported languages.</span></p>
			<p>Dependency<a id="_idIndexMarker565"/> Scanning knows how to parse the configuration files used by the package managers of each supported language, and it uses this information to determine which dependencies your project relies on. For example, it might scan <strong class="source-inline">Gemfile.lock</strong> in a Ruby project, <strong class="source-inline">requirements.txt</strong> or <strong class="source-inline">requirements.pip</strong> in a Python project, or <strong class="source-inline">pom.xml</strong> in a Java project that uses the Maven build tool. As you can see from the fact that we mentioned two different Python configuration files, the scanner is smart enough to know that some languages use several different files to list their configurations and it can parse all the most commonly used files in each language. Just like SAST, Dependency Scanning can handle projects that contain several different computer languages. It will parse the dependency configuration files for any languages that it detects, and look for vulnerabilities in all <span class="No-Break">of them.</span></p>
			<p>For example, if your Hats for Cats website is built on an old version of the Django web framework, your project might contain a <strong class="source-inline">requirements.txt</strong> file with just <span class="No-Break">one entry:</span></p>
			<pre class="source-code">
django==4.0</pre>
			<p>The scanner looks not just for the names and version numbers of dependencies that your project declares explicitly but also for the names and version numbers of any dependencies that those dependencies have. In other words, it looks recursively through the dependency tree to detect transitive dependencies, as well as direct dependencies. It reports on vulnerabilities found on <em class="italic">any</em> dependencies within the tree, which means that you might see vulnerabilities reported in dependencies that you didn’t even know your <span class="No-Break">project used.</span></p>
			<p>Once Dependency Scanning knows the names and version numbers of each dependency in your project, it looks up each dependency name and version number in a database to see whetherthere are known vulnerabilities in that particular version of that particular library. It’s important to understand that Dependency Scanning does not do SAST-style scanning of the dependency code – that is, it does not analyze the code within the dependencies, trying to detect new vulnerabilities. Instead, it uses a much more straightforward strategy. It simply determines whether the database contains any information about vulnerabilities that have <em class="italic">already been discovered</em> in that version of that dependency. This may sound like an unsophisticated approach, but it turns out to be extremely useful and is quite good at revealing problems with commonly <span class="No-Break">used libraries.</span></p>
			<p>Dependency Scanning has a special feature that isn’t always available but can be a nice time-saver when it is. If the scanner detects a vulnerability in an old version of a library and knows that the vulnerability has been fixed in a later version of the same library, it will sometimes<a id="_idIndexMarker566"/> offer to create a merge request that rewrites your project’s dependency configuration file so that it uses the later, fixed version of the library. This only happens under some circumstances and with some languages but is worth taking advantage of when <span class="No-Break">it’s offered.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor187"/>Enabling and configuring Dependency Scanning</h2>
			<p>You have the <a id="_idIndexMarker567"/>same GUI or manual options for adding Dependency<a id="_idIndexMarker568"/> Scanning to your project’s pipelines as you do for SAST, Secret Detection, or DAST. To enable it through the GUI, click the <strong class="bold">Security &amp; Compliance</strong> option in the left navigation pane, select <strong class="bold">Configuration</strong>, and find the control for enabling Dependency Scanning. This will create a merge request that adds two lines of code to your <strong class="source-inline">.gitlab-ci.yml</strong> file, which enables the scanner. Merge the merge request, and <span class="No-Break">you’re done.</span></p>
			<p>Enabling it manually is even simpler. Just make sure your pipeline has a <strong class="source-inline">test</strong> stage defined and add the Dependency Scanning template <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">.gitlab-ci.yml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
stages:
  - test
include:
  - template: Security/Dependency-Scanning.gitlab-ci.yml</pre>
			<p>Like the other scanners, Dependency Scanning has several configurable options. Also, like the other scanners, these are controlled either by setting global variables in <strong class="source-inline">.gitlab-ci.yml</strong> or by overriding job definitions and setting job-scoped variables in <span class="No-Break">that file.</span></p>
			<p>For example, the following code sets a job-scoped variable that tells Dependency Scanning’s Python analyzer to look for a dependency configuration file with a non-standard name<a id="_idIndexMarker569"/> instead of the<a id="_idIndexMarker570"/> traditional <span class="No-Break"><strong class="source-inline">requirements.txt</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
gemnasium-python-dependency_scanning:
  variables:
    PIP_REQUIREMENTS_FILE: "hats-for-cats-requirements.txt"</pre>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor188"/>Viewing Dependency Scanning’s findings</h2>
			<p>The vulnerability<a id="_idIndexMarker571"/> report shows any potential security problems detected in your project’s dependencies. For example, here are five critical and high-severity vulnerabilities stemming from Hats for Cats’ dependency on an old version of the Django library, as specified in the sample <span class="No-Break"><strong class="source-inline">requirements.txt</strong></span><span class="No-Break"> file:</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B18073_07_5.jpg" alt="Figure 7.5 – Dependency Scanning findings" width="787" height="514"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Dependency Scanning findings</p>
			<p>By now, you should have a firm grasp of what Dependency Scanning does and how to use it. Let’s move on and look at a Docker-focused security scanner: <span class="No-Break">Container Scanning.</span></p>
			<h1 id="_idParaDest-179"><a id="_idTextAnchor189"/>Using Container Scanning to find vulnerabilities in Docker images</h1>
			<p>Container Scanning <a id="_idIndexMarker572"/>does for Docker images what Dependency Scanning does for your project’s dependencies: it checks for known vulnerabilities in the particular versions of Linux distributions that your project uses as a base when it builds <span class="No-Break">Docker images.</span></p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor190"/>Understanding Container Scanning</h2>
			<p>If you package and deploy your application as a Docker image – or, technically, an Open Container Initiative-compliant image – you should use GitLab’s Container Scanning feature to find known vulnerabilities in the base Linux distribution that your image is built on <span class="No-Break">top of.</span></p>
			<p>If you haven’t worked with Docker images before, this might sound mysterious, but it’s not complicated. Think of a Docker image as a little bit like a virtual machine. There’s a special file called <strong class="source-inline">Dockerfile</strong> that serves as a “recipe” for creating that virtual machine. This <strong class="source-inline">Dockerfile</strong> file specifies which Linux distribution to use as the virtual machine’s operating system, which additional software packages you should install on top of Linux to support your application, and ultimately what application you want to install on the virtual machine. This whole stack of the operating system and the dependencies and your application makes up a <span class="No-Break">Docker image.</span></p>
			<p>Container Scanning looks for vulnerabilities both in the software packages that come installed by default in that base Linux operating system and in any additional packages that you specified in your <strong class="source-inline">Dockerfile</strong>. As you would expect, the older the Linux distribution, and the more dependencies you install on it, the more problems Container Scanning is likely <span class="No-Break">to find.</span></p>
			<p>Although Container Scanning doesn’t know how to find vulnerable packages in all versions of all Linux distributions, it does support the last two or three versions of the most commonly used distributions. Unless you use a truly exotic distribution to serve as the base of your application’s Docker image, you should be able to use Container Scanning. The GitLab documentation has a list of all supported distributions if you’d like to make sure your images <span class="No-Break">are scannable.</span></p>
			<p>Container Scanning<a id="_idIndexMarker573"/> has an optional feature that is disabled by default: it can also look for vulnerabilities in “language packages,” which are libraries that are added by a language’s package manager. For example, you might use Ruby’s <strong class="source-inline">bundler</strong> utility to install the <strong class="source-inline">Ruby on Rails</strong> gem, or Python’s <strong class="source-inline">pip</strong> tool to install the <strong class="source-inline">Flask</strong> module. You might notice that this functionality covers the same ground as GitLab’s Dependency Scanning – and as a result, often produces duplicate findings. Because of this, many GitLab users rely on Dependency Scanning instead of enabling this feature in <span class="No-Break">Container Scanning.</span></p>
			<p>Although Container Scanning can look for problems in any Docker image that it can access via the web, its default behavior is to scan any images it finds in your project’s <strong class="bold">Container Registry</strong>. The Container Registry is a<a id="_idIndexMarker574"/> feature provided for all GitLab projects and lets you store Docker images in a safe, access-controlled location instead of storing them on a site such as Docker Hub, which is open to everyone, or in an instance of a tool such as Artifactory. To use Container Scanning to inspect an image in the Container Registry, you’ll need your pipeline to build a Docker image and then push it to the registry. We’ll discuss this process in the next chapter on <span class="No-Break">deployment strategies.</span></p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor191"/>Enabling and configuring Container Scanning</h2>
			<p>You can enable Container <a id="_idIndexMarker575"/>Scanning by manually editing <strong class="source-inline">.gitlab-ci.yml</strong> or by using the GitLab GUI. To enable it manually, make sure your pipeline contains a <strong class="source-inline">test</strong> stage and include the Container <span class="No-Break">Scanning template:</span></p>
			<pre class="source-code">
stages:
  - test
include:
  - template: Security/Container-Scanning.gitlab-ci.yml</pre>
			<p>To configure <a id="_idIndexMarker576"/>Container Scanning with the GUI, you can use the same technique as for the other scanners discussed so far: click the <strong class="bold">Security &amp; Compliance</strong> option in the left navigation pane, select <strong class="bold">Configuration</strong>, and find the control for enabling Container Scanning. This will produce an MR that adds the preceding template to your CI/CD configuration file. Merge this MR, and <span class="No-Break">you’re done.</span></p>
			<p>If you’re happy with having Container Scanning look for Docker images in your project’s Container Registry, these manual or GUI-based techniques for enabling the scanner are the only steps you need to perform. But if you need to change its default behavior, you can use two of the same techniques you’ve used to configure other scanners: set a global variable or<a id="_idIndexMarker577"/> override a job definition and set a job-scoped variable. Some<a id="_idIndexMarker578"/> of the configuration options available for this scanner include aiming the scanner at a Docker image stored in a location other than your project’s Container Registry, enabling language package scanning, or setting the minimum severity level that a vulnerability must have to be included in the Container <span class="No-Break">Scanning’s findings.</span></p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor192"/>Viewing Container Scanning’s findings</h2>
			<p>It’s not unusual for <a id="_idIndexMarker579"/>Container Scanning to find dozens of vulnerabilities in a Docker image that you’ve built, especially if you’re using a less-than-recent Linux distribution as your base image. When you consider the huge number of packages that are installed by default on every Linux distribution, and the speed with which vulnerabilities are found in open-source packages, this is <span class="No-Break">not surprising.</span></p>
			<p>For example, Alpine Linux is known as one of the smallest major distributions, meaning that it has fewer packages installed than other popular distributions, such as Ubuntu or Debian. This makes it a popular distribution to use as a base for Docker images. If you build a Docker image based on Alpine Linux version 3.14.1, which is only 10 months old at the time of writing, Container Scanning finds no fewer than 30 vulnerabilities among its default packages. You can see a handful of the highest severity vulnerabilities found in a Docker image built on this distribution, as displayed in the <strong class="bold">Vulnerability </strong><span class="No-Break"><strong class="bold">Report</strong></span><span class="No-Break"> area:</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/B18073_07_6.jpg" alt="Figure 7.6 – Container Scanning findings" width="863" height="572"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Container Scanning findings</p>
			<p>Now that we’ve <a id="_idIndexMarker580"/>covered the basics of Container Scanning, let’s take a look at yet another security scanner: <span class="No-Break">License Compliance.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor193"/>Using License Compliance to manage licenses of dependencies</h1>
			<p>It can be easy to<a id="_idIndexMarker581"/> lose track of what software licenses are used by your project’s various dependencies. It’s also easy to forget which licenses are compatible with your project’s overall license, and which licenses should be excluded for various reasons. This is where GitLab’s License Compliance feature can <span class="No-Break">help out.</span></p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor194"/>Understanding License Compliance</h2>
			<p>Most open-source libraries are released under a software license. There are hundreds of licenses available – though only 20 or so are commonly used – and the legal details of each vary considerably. If you <a id="_idIndexMarker582"/>use a third-party library in your project, you must make sure that the library’s license and the license under which you intend to release your software are compatible with each other. If they are incompatible, you must replace that dependency with an alternative library that uses a <span class="No-Break">friendlier license.</span></p>
			<p>What do we mean by “compatible” when talking about licenses? Most licenses are considered to <a id="_idIndexMarker583"/>be <strong class="bold">permissive</strong>, meaning that you can use software released under that license for almost any purpose. Two well-known examples of this type of license are the MIT license and the BSD license. You generally won’t face any compatibility problems if you stick to dependencies that use permissive licenses. Other licenses are <strong class="bold">protective</strong> rather than <a id="_idIndexMarker584"/>permissive, meaning that they restrict how you can use software that’s released under those licenses. Here are some examples of the restrictions imposed by <span class="No-Break">protective licenses:</span></p>
			<ul>
				<li>Some open-source licenses such as GPL or AGPL fall under a category informally called <strong class="bold">copyleft</strong>. Software<a id="_idIndexMarker585"/> released under these licenses can be used as dependencies in other projects, but only if those other projects are themselves released under the same copyleft license. For example, if your Hats for Cats app uses an open-source Python sorting library that is released under the GPL license, then <em class="italic">the entire Hats for Cats project must also use the GPL license</em>. It’s not hard to see how this would be a problem if you intended to sell your software rather than release it as <span class="No-Break">open source.</span></li>
			</ul>
			<p>To use more controversial terms, copyleft licenses are sometimes called “viral” because they can be thought of as “infecting” parent projects. This disease metaphor is probably unfair, and many fine pieces of software have been released using copyleft licenses, but the fact remains that you need to be careful about <span class="No-Break">using them.</span></p>
			<ul>
				<li>Some licenses explicitly <em class="italic">disallow use by certain industries</em>, such as the military. Code released under a military exclusion license can’t be used as a dependency for missile guidance software, <span class="No-Break">for example.</span></li>
				<li>A license could <em class="italic">exclude usage of the software by certain countries</em>. This isn’t commonly seen, but it is legal for a license to include restrictions of <span class="No-Break">this type.</span></li>
			</ul>
			<p>As you can see, it’s important to understand what licenses your project’s dependencies use so that you’re aware of any restrictions imposed by those licenses and you steer well clear of any dependencies that are released under licenses that will restrict your ability to use or sell your software<a id="_idIndexMarker586"/> in the ways that <span class="No-Break">you intend.</span></p>
			<p>GitLab’s License Compliance feature has <span class="No-Break">three phases:</span></p>
			<ul>
				<li>The scanner looks through your project’s dependencies and generates a list of all <span class="No-Break">licenses used.</span></li>
				<li>The software development team – or your company’s legal department – creates <strong class="bold">license policies</strong> that explicitly allow or deny each license that’s found in your project’s dependencies. Alternatively, you can preemptively create license policies before any dependencies are added to the project if you already know which licenses are incompatible with your main project’s <span class="No-Break">overall license.</span></li>
				<li>If a developer introduces a new dependency on a branch, and that dependency uses a license that has been denied, the License Compliance feature blocks the merge request for that branch until the license is removed or the block <span class="No-Break">is overridden.</span></li>
			</ul>
			<p>From this workflow, you can tell that creating license policies is an important part of using the License Compliance feature. To view, create, delete, or edit license policies, click <strong class="bold">Security &amp; Compliance</strong> in the left navigation pane and then click <strong class="bold">License compliance</strong>. Here’s what that screen looks like when you’ve approved two licenses and denied two <span class="No-Break">other licenses:</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B18073_07_7.jpg" alt="Figure 7.7 – License policies" width="760" height="406"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – License policies</p>
			<p>The workflow description mentions the power of License Compliance to block any merge request that <a id="_idIndexMarker587"/>introduces a dependency that uses a license that has been explicitly denied with a license policy. To block an MR, License Compliance deactivates or hides the <strong class="bold">Merge</strong> button so that it can’t be clicked. Here’s a blocked MR, which displays a list of licenses used by a new dependency (and its dependencies) that have been introduced on the <span class="No-Break">MR’s branch:</span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B18073_07_8.jpg" alt="Figure 7.8 – Merge request blocked by a denied license" width="884" height="794"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Merge request blocked by a denied license</p>
			<h3>Using GitLab rulesets to unblock an MR</h3>
			<p>GitLab has several<a id="_idIndexMarker588"/> other triggers that cause an MR to become blocked until some sort of corrective action is taken, in addition to the case you’ve just seen. To take just one example, when a developer writes new product code without writing automated tests to cover that code, GitLab can be configured to notice that the “code coverage” figure on the developer’s branch has dropped, and the MR for that branch will be blocked until the developer adds automated tests that test their <span class="No-Break">new code.</span></p>
			<p>Any MR that is automatically blocked can be unblocked with a GitLab feature called <strong class="bold">approval rules</strong>. These <a id="_idIndexMarker589"/>rules allow specific people to unblock an MR simply by <strong class="bold">approving</strong> that MR. Each of these approval rules has a name; the rule that lets you override blocks caused by denied<a id="_idIndexMarker590"/> licenses is called <strong class="bold">License-Check</strong>. We don’t have room to go into configuring approval rules here, but they are quite straightforward to set up and use. The<a id="_idIndexMarker591"/> GitLab documentation can give you <span class="No-Break">more details.</span></p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor195"/>Enabling and configuring License Compliance</h2>
			<p>You can’t use the<a id="_idIndexMarker592"/> GUI to enable License Compliance, but the<a id="_idIndexMarker593"/> manual technique of enabling it should seem very familiar by now. Just ensure that you have a <strong class="source-inline">test</strong> stage defined in your pipeline and include the License <span class="No-Break">Compliance template:</span></p>
			<pre class="source-code">
stages:
  - test
include:
  - template: Security/License-Scanning.gitlab-ci.yml</pre>
			<p>Configuring License Compliance can be accomplished in the same way you configure the other scanners: edit <strong class="source-inline">.gitlab-ci.yml</strong> to either set a global variable or override a job definition and set a <span class="No-Break">job-scoped variable.</span></p>
			<p>As mentioned previously, an important part of configuring License Compliance is creating the license policies that stipulate which open-source licenses are allowed or denied for your project’s dependencies. To create or edit these policies, navigate to the <strong class="bold">Security &amp; Compliance</strong> option in the left navigation pane, click <strong class="bold">License compliance</strong>, and click the <strong class="bold">Policies</strong> tab. From there, you can add policies to either allow or deny any of the hundreds of licenses that GitLab recognizes. You can create policies for licenses, regardless of whether your project contains dependencies with those licenses. It might make sense for your legal team to create policies for any denied licenses before the development of your project begins so that MRs are blocked immediately if they introduce dependencies that use <span class="No-Break">denied licenses.</span></p>
			<p class="callout-heading">Prerequisite for editing license policies</p>
			<p class="callout">This is not well documented by GitLab, but to add, remove, or edit license policies, you must first run at least one instance of a pipeline that contains the License Scanning job. This “unlocks” the allowed and denied license lists and lets you <span class="No-Break">edit policies.</span></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor196"/>Viewing License Compliance’s findings</h2>
			<p>Unlike the other <a id="_idIndexMarker594"/>scanners we’ve looked at so far, License Compliance does not display its findings in the <strong class="bold">Vulnerability Report</strong> window. To see which licenses it has identified among the <em class="italic">dependencies on your project’s default branch</em>, click the <strong class="bold">Security &amp; Compliance</strong> option in the left navigation pane, and then click <span class="No-Break"><strong class="bold">License compliance</strong></span><span class="No-Break">.</span></p>
			<p>To see which licenses are used by <em class="italic">dependencies that are on a feature or bugfix branch</em>, navigate to the pipeline details page for a pipeline that ran against that branch and click the <strong class="bold">Licenses</strong> tab. This view also shows you which licenses are allowed, which are denied, and which are not <span class="No-Break">yet categorized.</span></p>
			<p>You’re now equipped to put License Compliance to use in your projects. It’s time to tackle the final security scanner provided by GitLab: Infrastructure as <span class="No-Break">Code Scanning.</span></p>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor197"/>Using IaC Scanning to find problems in infrastructure configuration files</h1>
			<p>In the last decade or so, the phrase “treat hardware as cattle, not pets” has been used to describe a new <a id="_idIndexMarker595"/>approach to managing computers. By thinking of hardware as a fungible commodity rather than a collection of special snowflakes, development and operations teams are liberated from carefully configuring and maintaining the computers they use to host deployment environments, run databases, serve web applications, or do any of the countless other tasks involved with developing and deploying<a id="_idIndexMarker596"/> software. By using so-called IaC tools such as Ansible or Terraform to configure and maintain the configuration state on hardware (whether real or virtual, local or cloud-based), system administrators can adjust server capacity, create new environments, or experiment with hardware configurations without worrying about how difficult it will be to revert their systems if something goes wrong or an experiment fails. To get back to normal, they can simply wipe out the old machines and reconfigure them automatically with IaC tools, using settings that have already been proven to work. The time savings and freedom this grants development teams <span class="No-Break">are enormous.</span></p>
			<p>But with this new freedom comes a new kind of vulnerability. It’s easy to create configuration files for IaC tools that introduce security vulnerabilities to machines that are configured with those files. GitLab’s IaC scanner looks for exactly that sort of vulnerability. Once they are identified, a team can remediate them in the configuration file and then easily reconfigure their machines using the newer, <span class="No-Break">safer setup.</span></p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor198"/>Understanding IaC Scanning</h2>
			<p>GitLab’s IaC Scanning is a specialized form of SAST. It looks through a project’s repository to see whether it can<a id="_idIndexMarker597"/> find any configuration files from the supported IaC tools (the GitLab documentation can give you an up-to-date list of which IaC tools this scanner supports). It then identifies any vulnerabilities or poor programming practices in those <span class="No-Break">configuration files.</span></p>
			<p>Here’s a trivial Terraform configuration file that creates an <span class="No-Break">S3 bucket:</span></p>
			<pre class="source-code">
resource "aws_s3_bucket" "testBucket" {
    bucket = "myBucket"
    acl = "authenticatedRead"
}</pre>
			<p>This code looks simple enough, but it introduces several security vulnerabilities and fails to follow some best practices for Terraform configuration files, as you’ll see in an IaC scanning report later in <span class="No-Break">this chapter.</span></p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor199"/>Enabling and configuring IaC scanning</h2>
			<p>As with many of the other scanners, you can enable IaC Scanning either with the GUI or by manually editing <strong class="source-inline">.gitlab-ci.yml</strong>. To enable it through the GitLab GUI, you can use the same<a id="_idIndexMarker598"/> technique you used to <a id="_idIndexMarker599"/>enable the other scanners: under the <strong class="bold">Security &amp; Compliance</strong> option in the left navigation pane, click <strong class="bold">Configuration</strong>, tell the GUI to create a merge request, and merge the <span class="No-Break">merge request.</span></p>
			<p>To enable IaC Scanning manually, add a <strong class="source-inline">test</strong> stage to your project’s pipeline if it doesn’t already<a id="_idIndexMarker600"/> have one, and include the <span class="No-Break">scanner’s</span><span class="No-Break"><a id="_idIndexMarker601"/></span><span class="No-Break"> template:</span></p>
			<pre class="source-code">
stages:
  - test
include:
  - template: SAST-IaC.latest.gitlab-ci.yml</pre>
			<p>IaC Scanning doesn’t currently offer any configuration options but may do so in <span class="No-Break">the future.</span></p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor200"/>Viewing IaC Scanning’s findings</h2>
			<p>The Terraform configuration for creating an S3 bucket that was presented previously contains quite<a id="_idIndexMarker602"/> a few problems in just a few lines of code. There are some security vulnerabilities and some failures to follow best practices around creating S3 resources. The findings shown in the Vulnerability Report are invaluable in helping you understand where you need to tighten up your Terraform code to eliminate <span class="No-Break">these problems:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B18073_07_9.jpg" alt="Figure 7.9 – IaC Scanning findings" width="1113" height="672"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – IaC Scanning findings</p>
			<p>By looking at the <strong class="bold">Tool</strong> column of the findings in the vulnerability report, you’ll see that the IaC Scanning findings are all listed as coming from SAST instead of the IaC scanner. That’s because the IaC scanner is<a id="_idIndexMarker603"/> classified within GitLab as belonging to the SAST group of tools. To see only IaC findings in the vulnerability report, you’ll need to pick <strong class="bold">SAST</strong> in the <strong class="bold">Tool</strong> dropdown – and even then, you’ll still see findings from the SAST tool and any third-party scanners you’ve integrated into the SAST group <span class="No-Break">of tools.</span></p>
			<p>This concludes our survey of GitLab’s seven security scanners. Let’s move on to discuss two features that GitLab offers to make its security scanners easier to use and more powerful: reports and <span class="No-Break">vulnerability management.</span></p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor201"/>Understanding the different types of security reports</h1>
			<p>All GitLab security<a id="_idIndexMarker604"/> scanners display their results in three separate reports. Because each report shows results from all of the scanners, there’s no need to bounce around the GitLab GUI, collecting information from all the different scanners. However, each of the three report locations presents a slightly different spin on the scanners’ findings. It’s important to understand how these three reports differ, so let’s look at <span class="No-Break">each one:</span></p>
			<ul>
				<li>The <strong class="bold">vulnerability report</strong> is the report that we’ve shown in screenshots throughout <a id="_idIndexMarker605"/>this chapter. It shows<a id="_idIndexMarker606"/> the findings of any scanner that ran during the last pipeline on your project’s default branch (normally <strong class="source-inline">main</strong> or <strong class="source-inline">master</strong>). If you want to know how secure your stable code base is, look at the vulnerability report. It won’t tell you anything about the state of security on any feature or bugfix branches – only the <span class="No-Break">default branch.</span></li>
				<li>The <strong class="bold">pipeline details page</strong> for each pipeline that runs tells you about security problems that exist on<a id="_idIndexMarker607"/> whatever branch that pipeline<a id="_idIndexMarker608"/> ran on. So, if a pipeline ran against the default branch, its pipeline details page will contain the same information as the vulnerability report. But the pipeline details page for pipelines that run against feature or bugfix branches will alert you to whatever vulnerabilities exist on those branches, regardless of whether they also exist on the default branch. This page will reveal a tab called <strong class="bold">Licenses</strong> if License Compliance is enabled and has detected dependencies with licenses, and a tab called <strong class="bold">Security</strong> if it has findings from any of the other scanners to display. The types of information displayed on the pipeline details page are identical to what is displayed in the vulnerability report, albeit formatted <span class="No-Break">slightly differently.</span></li>
				<li>Every <strong class="bold">merge request</strong> displays<a id="_idIndexMarker609"/> scanner results from the most recent pipeline that ran against the MR’s<a id="_idIndexMarker610"/> source branch. However, the reports found in MRs are different from the vulnerability report and the pipeline details report in an important way: an MR report only displays the <em class="italic">differences</em> between vulnerabilities found by the last pipeline that ran on the MR’s source branch and vulnerabilities found on the MR’s target branch. In other words, it shows a delta view rather than a full list of all vulnerabilities on <span class="No-Break">its branch.</span></li>
			</ul>
			<p>Let’s consider an example to illustrate the difference between these <span class="No-Break">three reports:</span></p>
			<ol>
				<li value="1">Imagine that the <strong class="source-inline">main</strong> branch for Hats for Cats has one SAST vulnerability and one problem spotted by <span class="No-Break">Secret Detection.</span></li>
				<li>A developer makes a branch off of <strong class="source-inline">main</strong> <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">make-hats-sortable</strong></span><span class="No-Break">.</span></li>
				<li>Following the best practices of GitLab Flow, the developer creates an MR with <strong class="source-inline">make-hats-sortable</strong> as the source branch and <strong class="source-inline">main</strong> as the <span class="No-Break">target branch.</span></li>
				<li>The developer commits code to the <strong class="source-inline">make-hats-sortable</strong> branch. Let’s say that the commit fixes the SAST vulnerability but introduces a new <span class="No-Break">DAST vulnerability.</span></li>
			</ol>
			<p>Here’s what each of the three reports will show at <span class="No-Break">this point:</span></p>
			<ul>
				<li>The <strong class="bold">vulnerability report</strong> displays the SAST and Secret Detection problems since both of those<a id="_idIndexMarker611"/> issues exist on the <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> branch.</span></li>
				<li>The <strong class="bold">pipeline details page report</strong> for the most recent pipeline that ran against the <strong class="source-inline">make-hats-sortable</strong> branch (that is, the merge request’s source branch) shows <a id="_idIndexMarker612"/>only the vulnerabilities found by Secret Detection and DAST since the SAST vulnerability has been fixed on <span class="No-Break">that branch.</span></li>
				<li>The <strong class="bold">merge request report</strong> shows <a id="_idIndexMarker613"/>the delta view of the vulnerabilities on its source and target branches. In this case, it reports that the SAST vulnerability is fixed and the DAST vulnerability has appeared, but it doesn’t list the Secret Detection vulnerability since that exists on both the <strong class="source-inline">make-hats-sortable</strong> and <span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break"> branches.</span></li>
			</ul>
			<p>That concludes our discussion of the different types of GitLab security reports. After you read these reports and understand where your security vulnerabilities lie, how do you track your progress in remediating those vulnerabilities? That’s the topic of the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor202"/>Managing security vulnerabilities</h1>
			<p>Whenever any scanner except License <a id="_idIndexMarker614"/>Compliance finds a vulnerability, it grants that vulnerability the <strong class="bold">Needs Triage</strong> status. This status shows up in the vulnerability’s entry in the vulnerability report and the pipeline details <span class="No-Break">page report.</span></p>
			<p>You should decide what you intend to do about each vulnerability that has that status and change its status accordingly. Here are the possible <span class="No-Break">status values:</span></p>
			<ul>
				<li><strong class="bold">Dismissed</strong> means that you do not intend to remediate this vulnerability. Maybe you’ve determined that it’s a false positive, maybe you’ve decided it’s a real problem but isn’t worth fixing, or maybe you’ve realized that it doesn’t apply to your product or <span class="No-Break">your users.</span></li>
				<li><strong class="bold">Confirmed</strong> means that it’s a real problem, and you do intend to fix it. After setting a finding to this status, you would normally create an issue to track your progress as your team works to remediate this vulnerability. GitLab offers a few shortcuts in the report GUIs to do this, and even prepopulates the issue’s title and description with information from the finding to make it as easy as possible <span class="No-Break">to fix.</span></li>
				<li><strong class="bold">Resolved</strong> means that you have fixed the problem, so it no longer exists in your project. This status has to be set manually. <em class="italic">GitLab will not automatically resolve vulnerabilities</em>. This is because it does not want to accidentally resolve problems that are still present, thereby giving you a false sense <span class="No-Break">of security.</span></li>
			</ul>
			<p>GitLab’s vulnerability management feature just boils down to setting the status of a vulnerability and then optionally using a GitLab issue to track progress on fixing that vulnerability. A typical vulnerability management workflow might look <span class="No-Break">like this:</span></p>
			<ol>
				<li value="1">A scanner reports a vulnerability, giving it the <strong class="bold">Needs </strong><span class="No-Break"><strong class="bold">Triage</strong></span><span class="No-Break"> status.</span></li>
				<li>The development team triages the vulnerability and decides not to fix it, in which case you set its status to <strong class="bold">Dismissed</strong> and stop <span class="No-Break">the workflow.</span></li>
			</ol>
			<p>Alternatively, the team triages the vulnerability and decides that it does need to be fixed, in which case you can set its status <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Confirmed</strong></span><span class="No-Break">.</span></p>
			<ol>
				<li value="3">Optionally, you can create an issue that contains information about the vulnerability and possibly instructions on how to fix it. This issue is discussed, added to a sprint, and assigned to a developer just like any <span class="No-Break">other issue.</span></li>
				<li>The developer assigned<a id="_idIndexMarker615"/> to the issue creates a branch, creates a merge request for that branch, and fixes the issue on <span class="No-Break">that branch.</span></li>
				<li>The “delta” security report for the merge request shows that the issue exists on the default branch but no longer exists on the <span class="No-Break">developer’s branch.</span></li>
				<li>Your team merges the merge request. The vulnerability is now remediated in the <span class="No-Break">default branch.</span></li>
				<li>You close <span class="No-Break">the issue.</span></li>
				<li>On the vulnerability report, you must set the vulnerability’s status <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Resolved</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>This process may feel cumbersome when you see it laid out like this, but most people quickly get used to the flow and come to appreciate the visibility it gives them into the state of security in <span class="No-Break">their projects.</span></p>
			<p>Now, you know how to track your team’s efforts at fixing security vulnerabilities in your code. There’s one final topic to tackle in this chapter: using security scanners other than the ones that are provided <span class="No-Break">by GitLab.</span></p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor203"/>Integrating outside security scanners</h1>
			<p>Many teams are <a id="_idIndexMarker616"/>committed to using one or more security scanners that are not part of GitLab’s security offering. Never fear – it’s usually possible to integrate outside scanners into your GitLab <span class="No-Break">CI/CD pipelines.</span></p>
			<p>Integration has two parts. First, you need to tell your pipeline to trigger the outside scanner. This is easy, so long as your scanner comes packaged in a Docker image and can be run from the <span class="No-Break">command line:</span></p>
			<ol>
				<li value="1">Create a new pipeline job in the <strong class="source-inline">test</strong> stage (unless there’s a reason to run <span class="No-Break">it elsewhere).</span></li>
				<li>Use the <strong class="source-inline">images</strong> keyword in the job definition to specify the location of the Docker image that contains the scanner you’d like to add to <span class="No-Break">your pipeline.</span></li>
				<li>In the <strong class="source-inline">script</strong> section <a id="_idIndexMarker617"/>of the job definition, trigger the scanner using whatever CLI command you use when you run it manually. You might need to pass some options to the CLI command to control where it generates its results file, and what format it uses for <span class="No-Break">that file.</span></li>
				<li>Add <strong class="source-inline">allow_failure: true</strong> to your job definition so that the pipeline will continue to run even if the outside scanner <span class="No-Break">finds vulnerabilities.</span></li>
			</ol>
			<p>The second part of integrating an outside scanner is to tell GitLab how to include the scanner’s results in the three standard GitLab security reports that we’ve discussed in this chapter. GitLab can only incorporate these results if they are written to a JSON file that conforms to specific JSON schemas, where each scanner type (SAST, DAST, and so on) has a separate schema. The documentation for each scanner type provides more information about <span class="No-Break">these schemas.</span></p>
			<p class="callout-heading">Integrating third-party scanners that generate non-standard results files</p>
			<p class="callout">If your third-party scanner can’t generate results files that validate against the appropriate schema, you’ll need to write a short script to parse the results and create a new results file that does conform to the schema. You’ll need to trigger this script somewhere in your pipeline after the <span class="No-Break">scanner runs.</span></p>
			<p>In the job definition you create for the third-party scanner, you must declare the scanner’s results file to be an artifact, specifically an artifact that contains the results for a certain type of security report. For example, if you are integrating an additional SAST scanner that creates a results file called <strong class="source-inline">my_scanner/results.json</strong>, you would need to include this code in the job definition that runs <span class="No-Break">that scanner:</span></p>
			<pre class="source-code">
  artifacts:
    reports:
      sast: my_scanner/results.json</pre>
			<p>This high-level description may be all you need to integrate third-party scanners, but if you need more detailed configuration instructions – including guidance on results schemas, best practices <a id="_idIndexMarker618"/>for what to name your pipeline job and results files, and more – the official GitLab documentation has a very thorough page on exactly <span class="No-Break">this topic.</span></p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor204"/>Summary</h1>
			<p>Security is one of the biggest and most complicated topics covered in this book, so congratulations on making it through! Let’s take stock of what we learned in <span class="No-Break">this chapter.</span></p>
			<p>First, we covered some common principles that underly all of GitLab’s security scanners. We discussed the fact that all of the scanners are open-source tools developed outside of GitLab, and why that’s a good thing. We saw that some scanners use different analyzers to support different computer languages, though all scanners support the most commonly used languages, and some scanners are completely language-agnostic. We learned about the implications of packaging the scanners as Docker images. We saw that scanners don’t stop CI/CD pipelines when they find vulnerabilities, and we learned that it’s usually possible to integrate outside scanners into your pipelines if the GitLab-provided scanners aren’t sufficient for <span class="No-Break">your needs.</span></p>
			<p>Then, we marched through the list of GitLab security scanners, learning what kinds of problems each one looks for, how to enable them with the GUI or manually, how to configure their behavior, and how to view their findings. We saw <span class="No-Break">the following:</span></p>
			<ul>
				<li>SAST looks for vulnerabilities in <span class="No-Break">source code</span></li>
				<li>Secret Detection looks for sensitive information that should not be stored in <span class="No-Break">Git repositories</span></li>
				<li>DAST finds vulnerabilities in running web apps or <span class="No-Break">Web APIs</span></li>
				<li>Dependency Scanning spots known vulnerabilities in your project’s <span class="No-Break">third-party libraries</span></li>
				<li>Container Scanning finds known problems with Linux distributions that form the base of your <span class="No-Break">Docker images</span></li>
				<li>License Compliance identifies dependencies with licenses that are incompatible with your overall <span class="No-Break">project license</span></li>
				<li>IaC Scanning looks for infrastructure configuration files that could introduce vulnerabilities into computers that <span class="No-Break">you manage</span></li>
			</ul>
			<p>Finally, we investigated three topics adjacent to the scanners themselves: the differences between the three different security reports provided by GitLab, managing security vulnerabilities that are identified by the scanners, and integrating outside scanners into your pipeline for projects that need even <span class="No-Break">more protection.</span></p>
			<p>Unfortunately, security concerns have become such a large and important part of developing software. But as we’ve seen throughout this chapter, GitLab’s suite of tools for detecting and fixing security vulnerabilities is one of its most powerful and valuable features. We can breathe a little easier knowing that many potential problems can now be identified early in the development process when there’s still plenty of time to fix them before they result in embarrassing, expensive, or reputation-damaging security breaches <span class="No-Break">in production.</span></p>
			<p>At this point, your code has been written, verified, and secured. The next step in the software development life cycle is to package and deploy it. We’ll tackle those tasks in the <span class="No-Break">next chapter.</span></p>
		</div>
		<div>
			<div id="_idContainer078" class="IMG---Figure">
			</div>
		</div>
	</div>
</div>
</body></html>